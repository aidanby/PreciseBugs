{"buggy_code": ["<?php\n/**\n * Administration API: Core Ajax handlers\n *\n * @package WordPress\n * @subpackage Administration\n * @since 2.1.0\n */\n\n//\n// No-privilege Ajax handlers.\n//\n\n/**\n * Ajax handler for the Heartbeat API in\n * the no-privilege context.\n *\n * Runs when the user is not logged in.\n *\n * @since 3.6.0\n */\nfunction wp_ajax_nopriv_heartbeat() {\n\t$response = array();\n\n\t// screen_id is the same as $current_screen->id and the JS global 'pagenow'.\n\tif ( ! empty( $_POST['screen_id'] ) ) {\n\t\t$screen_id = sanitize_key( $_POST['screen_id'] );\n\t} else {\n\t\t$screen_id = 'front';\n\t}\n\n\tif ( ! empty( $_POST['data'] ) ) {\n\t\t$data = wp_unslash( (array) $_POST['data'] );\n\n\t\t/**\n\t\t * Filters Heartbeat Ajax response in no-privilege environments.\n\t\t *\n\t\t * @since 3.6.0\n\t\t *\n\t\t * @param array  $response  The no-priv Heartbeat response.\n\t\t * @param array  $data      The $_POST data sent.\n\t\t * @param string $screen_id The screen id.\n\t\t */\n\t\t$response = apply_filters( 'heartbeat_nopriv_received', $response, $data, $screen_id );\n\t}\n\n\t/**\n\t * Filters Heartbeat Ajax response in no-privilege environments when no data is passed.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The no-priv Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\t$response = apply_filters( 'heartbeat_nopriv_send', $response, $screen_id );\n\n\t/**\n\t * Fires when Heartbeat ticks in no-privilege environments.\n\t *\n\t * Allows the transport to be easily replaced with long-polling.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The no-priv Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\tdo_action( 'heartbeat_nopriv_tick', $response, $screen_id );\n\n\t// Send the current time according to the server.\n\t$response['server_time'] = time();\n\n\twp_send_json( $response );\n}\n\n//\n// GET-based Ajax handlers.\n//\n\n/**\n * Ajax handler for fetching a list table.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_fetch_list() {\n\t$list_class = $_GET['list_args']['class'];\n\tcheck_ajax_referer( \"fetch-list-$list_class\", '_ajax_fetch_list_nonce' );\n\n\t$wp_list_table = _get_list_table( $list_class, array( 'screen' => $_GET['list_args']['screen']['id'] ) );\n\tif ( ! $wp_list_table ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $wp_list_table->ajax_user_can() ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table->ajax_response();\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for tag search.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_ajax_tag_search() {\n\tif ( ! isset( $_GET['tax'] ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$taxonomy = sanitize_key( $_GET['tax'] );\n\t$tax      = get_taxonomy( $taxonomy );\n\tif ( ! $tax ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! current_user_can( $tax->cap->assign_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$s = wp_unslash( $_GET['q'] );\n\n\t$comma = _x( ',', 'tag delimiter' );\n\tif ( ',' !== $comma ) {\n\t\t$s = str_replace( $comma, ',', $s );\n\t}\n\tif ( false !== strpos( $s, ',' ) ) {\n\t\t$s = explode( ',', $s );\n\t\t$s = $s[ count( $s ) - 1 ];\n\t}\n\t$s = trim( $s );\n\n\t/**\n\t * Filters the minimum number of characters required to fire a tag search via Ajax.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param int         $characters The minimum number of characters required. Default 2.\n\t * @param WP_Taxonomy $tax        The taxonomy object.\n\t * @param string      $s          The search term.\n\t */\n\t$term_search_min_chars = (int) apply_filters( 'term_search_min_chars', 2, $tax, $s );\n\n\t/*\n\t * Require $term_search_min_chars chars for matching (default: 2)\n\t * ensure it's a non-negative, non-zero integer.\n\t */\n\tif ( ( $term_search_min_chars == 0 ) || ( strlen( $s ) < $term_search_min_chars ) ) {\n\t\twp_die();\n\t}\n\n\t$results = get_terms(\n\t\t$taxonomy,\n\t\tarray(\n\t\t\t'name__like' => $s,\n\t\t\t'fields'     => 'names',\n\t\t\t'hide_empty' => false,\n\t\t)\n\t);\n\n\techo join( $results, \"\\n\" );\n\twp_die();\n}\n\n/**\n * Ajax handler for compression testing.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_wp_compression_test() {\n\tif ( ! current_user_can( 'manage_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ini_get( 'zlib.output_compression' ) || 'ob_gzhandler' == ini_get( 'output_handler' ) ) {\n\t\tupdate_site_option( 'can_compress_scripts', 0 );\n\t\twp_die( 0 );\n\t}\n\n\tif ( isset( $_GET['test'] ) ) {\n\t\theader( 'Expires: Wed, 11 Jan 1984 05:00:00 GMT' );\n\t\theader( 'Last-Modified: ' . gmdate( 'D, d M Y H:i:s' ) . ' GMT' );\n\t\theader( 'Cache-Control: no-cache, must-revalidate, max-age=0' );\n\t\theader( 'Content-Type: application/javascript; charset=UTF-8' );\n\t\t$force_gzip = ( defined( 'ENFORCE_GZIP' ) && ENFORCE_GZIP );\n\t\t$test_str   = '\"wpCompressionTest Lorem ipsum dolor sit amet consectetuer mollis sapien urna ut a. Eu nonummy condimentum fringilla tempor pretium platea vel nibh netus Maecenas. Hac molestie amet justo quis pellentesque est ultrices interdum nibh Morbi. Cras mattis pretium Phasellus ante ipsum ipsum ut sociis Suspendisse Lorem. Ante et non molestie. Porta urna Vestibulum egestas id congue nibh eu risus gravida sit. Ac augue auctor Ut et non a elit massa id sodales. Elit eu Nulla at nibh adipiscing mattis lacus mauris at tempus. Netus nibh quis suscipit nec feugiat eget sed lorem et urna. Pellentesque lacus at ut massa consectetuer ligula ut auctor semper Pellentesque. Ut metus massa nibh quam Curabitur molestie nec mauris congue. Volutpat molestie elit justo facilisis neque ac risus Ut nascetur tristique. Vitae sit lorem tellus et quis Phasellus lacus tincidunt nunc Fusce. Pharetra wisi Suspendisse mus sagittis libero lacinia Integer consequat ac Phasellus. Et urna ac cursus tortor aliquam Aliquam amet tellus volutpat Vestibulum. Justo interdum condimentum In augue congue tellus sollicitudin Quisque quis nibh.\"';\n\n\t\tif ( 1 == $_GET['test'] ) {\n\t\t\techo $test_str;\n\t\t\twp_die();\n\t\t} elseif ( 2 == $_GET['test'] ) {\n\t\t\tif ( ! isset( $_SERVER['HTTP_ACCEPT_ENCODING'] ) ) {\n\t\t\t\twp_die( -1 );\n\t\t\t}\n\t\t\tif ( false !== stripos( $_SERVER['HTTP_ACCEPT_ENCODING'], 'deflate' ) && function_exists( 'gzdeflate' ) && ! $force_gzip ) {\n\t\t\t\theader( 'Content-Encoding: deflate' );\n\t\t\t\t$out = gzdeflate( $test_str, 1 );\n\t\t\t} elseif ( false !== stripos( $_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip' ) && function_exists( 'gzencode' ) ) {\n\t\t\t\theader( 'Content-Encoding: gzip' );\n\t\t\t\t$out = gzencode( $test_str, 1 );\n\t\t\t} else {\n\t\t\t\twp_die( -1 );\n\t\t\t}\n\t\t\techo $out;\n\t\t\twp_die();\n\t\t} elseif ( 'no' == $_GET['test'] ) {\n\t\t\tcheck_ajax_referer( 'update_can_compress_scripts' );\n\t\t\tupdate_site_option( 'can_compress_scripts', 0 );\n\t\t} elseif ( 'yes' == $_GET['test'] ) {\n\t\t\tcheck_ajax_referer( 'update_can_compress_scripts' );\n\t\t\tupdate_site_option( 'can_compress_scripts', 1 );\n\t\t}\n\t}\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for image editor previews.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_imgedit_preview() {\n\t$post_id = intval( $_GET['postid'] );\n\tif ( empty( $post_id ) || ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tcheck_ajax_referer( \"image_editor-$post_id\" );\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/image-edit.php' );\n\tif ( ! stream_preview_image( $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\twp_die();\n}\n\n/**\n * Ajax handler for oEmbed caching.\n *\n * @since 3.1.0\n *\n * @global WP_Embed $wp_embed\n */\nfunction wp_ajax_oembed_cache() {\n\t$GLOBALS['wp_embed']->cache_oembed( $_GET['post'] );\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for user autocomplete.\n *\n * @since 3.4.0\n */\nfunction wp_ajax_autocomplete_user() {\n\tif ( ! is_multisite() || ! current_user_can( 'promote_users' ) || wp_is_large_network( 'users' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t/** This filter is documented in wp-admin/user-new.php */\n\tif ( ! current_user_can( 'manage_network_users' ) && ! apply_filters( 'autocomplete_users_for_site_admins', false ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$return = array();\n\n\t// Check the type of request\n\t// Current allowed values are `add` and `search`\n\tif ( isset( $_REQUEST['autocomplete_type'] ) && 'search' === $_REQUEST['autocomplete_type'] ) {\n\t\t$type = $_REQUEST['autocomplete_type'];\n\t} else {\n\t\t$type = 'add';\n\t}\n\n\t// Check the desired field for value\n\t// Current allowed values are `user_email` and `user_login`\n\tif ( isset( $_REQUEST['autocomplete_field'] ) && 'user_email' === $_REQUEST['autocomplete_field'] ) {\n\t\t$field = $_REQUEST['autocomplete_field'];\n\t} else {\n\t\t$field = 'user_login';\n\t}\n\n\t// Exclude current users of this blog\n\tif ( isset( $_REQUEST['site_id'] ) ) {\n\t\t$id = absint( $_REQUEST['site_id'] );\n\t} else {\n\t\t$id = get_current_blog_id();\n\t}\n\n\t$include_blog_users = ( $type == 'search' ? get_users(\n\t\tarray(\n\t\t\t'blog_id' => $id,\n\t\t\t'fields'  => 'ID',\n\t\t)\n\t) : array() );\n\t$exclude_blog_users = ( $type == 'add' ? get_users(\n\t\tarray(\n\t\t\t'blog_id' => $id,\n\t\t\t'fields'  => 'ID',\n\t\t)\n\t) : array() );\n\n\t$users = get_users(\n\t\tarray(\n\t\t\t'blog_id'        => false,\n\t\t\t'search'         => '*' . $_REQUEST['term'] . '*',\n\t\t\t'include'        => $include_blog_users,\n\t\t\t'exclude'        => $exclude_blog_users,\n\t\t\t'search_columns' => array( 'user_login', 'user_nicename', 'user_email' ),\n\t\t)\n\t);\n\n\tforeach ( $users as $user ) {\n\t\t$return[] = array(\n\t\t\t/* translators: 1: user_login, 2: user_email */\n\t\t\t'label' => sprintf( _x( '%1$s (%2$s)', 'user autocomplete result' ), $user->user_login, $user->user_email ),\n\t\t\t'value' => $user->$field,\n\t\t);\n\t}\n\n\twp_die( wp_json_encode( $return ) );\n}\n\n/**\n * Handles AJAX requests for community events\n *\n * @since 4.8.0\n */\nfunction wp_ajax_get_community_events() {\n\trequire_once( ABSPATH . 'wp-admin/includes/class-wp-community-events.php' );\n\n\tcheck_ajax_referer( 'community_events' );\n\n\t$search         = isset( $_POST['location'] ) ? wp_unslash( $_POST['location'] ) : '';\n\t$timezone       = isset( $_POST['timezone'] ) ? wp_unslash( $_POST['timezone'] ) : '';\n\t$user_id        = get_current_user_id();\n\t$saved_location = get_user_option( 'community-events-location', $user_id );\n\t$events_client  = new WP_Community_Events( $user_id, $saved_location );\n\t$events         = $events_client->get_events( $search, $timezone );\n\t$ip_changed     = false;\n\n\tif ( is_wp_error( $events ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'error' => $events->get_error_message(),\n\t\t\t)\n\t\t);\n\t} else {\n\t\tif ( empty( $saved_location['ip'] ) && ! empty( $events['location']['ip'] ) ) {\n\t\t\t$ip_changed = true;\n\t\t} elseif ( isset( $saved_location['ip'] ) && ! empty( $events['location']['ip'] ) && $saved_location['ip'] !== $events['location']['ip'] ) {\n\t\t\t$ip_changed = true;\n\t\t}\n\n\t\t/*\n\t\t * The location should only be updated when it changes. The API doesn't always return\n\t\t * a full location; sometimes it's missing the description or country. The location\n\t\t * that was saved during the initial request is known to be good and complete, though.\n\t\t * It should be left intact until the user explicitly changes it (either by manually\n\t\t * searching for a new location, or by changing their IP address).\n\t\t *\n\t\t * If the location was updated with an incomplete response from the API, then it could\n\t\t * break assumptions that the UI makes (e.g., that there will always be a description\n\t\t * that corresponds to a latitude/longitude location).\n\t\t *\n\t\t * The location is stored network-wide, so that the user doesn't have to set it on each site.\n\t\t */\n\t\tif ( $ip_changed || $search ) {\n\t\t\tupdate_user_option( $user_id, 'community-events-location', $events['location'], true );\n\t\t}\n\n\t\twp_send_json_success( $events );\n\t}\n}\n\n/**\n * Ajax handler for dashboard widgets.\n *\n * @since 3.4.0\n */\nfunction wp_ajax_dashboard_widgets() {\n\trequire_once ABSPATH . 'wp-admin/includes/dashboard.php';\n\n\t$pagenow = $_GET['pagenow'];\n\tif ( $pagenow === 'dashboard-user' || $pagenow === 'dashboard-network' || $pagenow === 'dashboard' ) {\n\t\tset_current_screen( $pagenow );\n\t}\n\n\tswitch ( $_GET['widget'] ) {\n\t\tcase 'dashboard_primary':\n\t\t\twp_dashboard_primary();\n\t\t\tbreak;\n\t}\n\twp_die();\n}\n\n/**\n * Ajax handler for Customizer preview logged-in status.\n *\n * @since 3.4.0\n */\nfunction wp_ajax_logged_in() {\n\twp_die( 1 );\n}\n\n//\n// Ajax helpers.\n//\n\n/**\n * Sends back current comment total and new page links if they need to be updated.\n *\n * Contrary to normal success Ajax response (\"1\"), die with time() on success.\n *\n * @access private\n * @since 2.7.0\n *\n * @param int $comment_id\n * @param int $delta\n */\nfunction _wp_ajax_delete_comment_response( $comment_id, $delta = -1 ) {\n\t$total    = isset( $_POST['_total'] ) ? (int) $_POST['_total'] : 0;\n\t$per_page = isset( $_POST['_per_page'] ) ? (int) $_POST['_per_page'] : 0;\n\t$page     = isset( $_POST['_page'] ) ? (int) $_POST['_page'] : 0;\n\t$url      = isset( $_POST['_url'] ) ? esc_url_raw( $_POST['_url'] ) : '';\n\n\t// JS didn't send us everything we need to know. Just die with success message\n\tif ( ! $total || ! $per_page || ! $page || ! $url ) {\n\t\t$time           = time();\n\t\t$comment        = get_comment( $comment_id );\n\t\t$comment_status = '';\n\t\t$comment_link   = '';\n\n\t\tif ( $comment ) {\n\t\t\t$comment_status = $comment->comment_approved;\n\t\t}\n\n\t\tif ( 1 === (int) $comment_status ) {\n\t\t\t$comment_link = get_comment_link( $comment );\n\t\t}\n\n\t\t$counts = wp_count_comments();\n\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what'         => 'comment',\n\t\t\t\t// Here for completeness - not used.\n\t\t\t\t'id'           => $comment_id,\n\t\t\t\t'supplemental' => array(\n\t\t\t\t\t'status'               => $comment_status,\n\t\t\t\t\t'postId'               => $comment ? $comment->comment_post_ID : '',\n\t\t\t\t\t'time'                 => $time,\n\t\t\t\t\t'in_moderation'        => $counts->moderated,\n\t\t\t\t\t'i18n_comments_text'   => sprintf(\n\t\t\t\t\t\t/* translators: %s: number of comments approved */\n\t\t\t\t\t\t_n( '%s Comment', '%s Comments', $counts->approved ),\n\t\t\t\t\t\tnumber_format_i18n( $counts->approved )\n\t\t\t\t\t),\n\t\t\t\t\t'i18n_moderation_text' => sprintf(\n\t\t\t\t\t\t/* translators: %s: number of comments in moderation */\n\t\t\t\t\t\t_nx( '%s in moderation', '%s in moderation', $counts->moderated, 'comments' ),\n\t\t\t\t\t\tnumber_format_i18n( $counts->moderated )\n\t\t\t\t\t),\n\t\t\t\t\t'comment_link'         => $comment_link,\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\t$total += $delta;\n\tif ( $total < 0 ) {\n\t\t$total = 0;\n\t}\n\n\t// Only do the expensive stuff on a page-break, and about 1 other time per page\n\tif ( 0 == $total % $per_page || 1 == mt_rand( 1, $per_page ) ) {\n\t\t$post_id = 0;\n\t\t// What type of comment count are we looking for?\n\t\t$status = 'all';\n\t\t$parsed = parse_url( $url );\n\t\tif ( isset( $parsed['query'] ) ) {\n\t\t\tparse_str( $parsed['query'], $query_vars );\n\t\t\tif ( ! empty( $query_vars['comment_status'] ) ) {\n\t\t\t\t$status = $query_vars['comment_status'];\n\t\t\t}\n\t\t\tif ( ! empty( $query_vars['p'] ) ) {\n\t\t\t\t$post_id = (int) $query_vars['p'];\n\t\t\t}\n\t\t\tif ( ! empty( $query_vars['comment_type'] ) ) {\n\t\t\t\t$type = $query_vars['comment_type'];\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $type ) ) {\n\t\t\t// Only use the comment count if not filtering by a comment_type.\n\t\t\t$comment_count = wp_count_comments( $post_id );\n\n\t\t\t// We're looking for a known type of comment count.\n\t\t\tif ( isset( $comment_count->$status ) ) {\n\t\t\t\t$total = $comment_count->$status;\n\t\t\t}\n\t\t}\n\t\t// Else use the decremented value from above.\n\t}\n\n\t// The time since the last comment count.\n\t$time    = time();\n\t$comment = get_comment( $comment_id );\n\n\t$x = new WP_Ajax_Response(\n\t\tarray(\n\t\t\t'what'         => 'comment',\n\t\t\t// Here for completeness - not used.\n\t\t\t'id'           => $comment_id,\n\t\t\t'supplemental' => array(\n\t\t\t\t'status'           => $comment ? $comment->comment_approved : '',\n\t\t\t\t'postId'           => $comment ? $comment->comment_post_ID : '',\n\t\t\t\t/* translators: %s: number of comments */\n\t\t\t\t'total_items_i18n' => sprintf( _n( '%s item', '%s items', $total ), number_format_i18n( $total ) ),\n\t\t\t\t'total_pages'      => ceil( $total / $per_page ),\n\t\t\t\t'total_pages_i18n' => number_format_i18n( ceil( $total / $per_page ) ),\n\t\t\t\t'total'            => $total,\n\t\t\t\t'time'             => $time,\n\t\t\t),\n\t\t)\n\t);\n\t$x->send();\n}\n\n//\n// POST-based Ajax handlers.\n//\n\n/**\n * Ajax handler for adding a hierarchical term.\n *\n * @access private\n * @since 3.1.0\n */\nfunction _wp_ajax_add_hierarchical_term() {\n\t$action   = $_POST['action'];\n\t$taxonomy = get_taxonomy( substr( $action, 4 ) );\n\tcheck_ajax_referer( $action, '_ajax_nonce-add-' . $taxonomy->name );\n\tif ( ! current_user_can( $taxonomy->cap->edit_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\t$names  = explode( ',', $_POST[ 'new' . $taxonomy->name ] );\n\t$parent = isset( $_POST[ 'new' . $taxonomy->name . '_parent' ] ) ? (int) $_POST[ 'new' . $taxonomy->name . '_parent' ] : 0;\n\tif ( 0 > $parent ) {\n\t\t$parent = 0;\n\t}\n\tif ( $taxonomy->name == 'category' ) {\n\t\t$post_category = isset( $_POST['post_category'] ) ? (array) $_POST['post_category'] : array();\n\t} else {\n\t\t$post_category = ( isset( $_POST['tax_input'] ) && isset( $_POST['tax_input'][ $taxonomy->name ] ) ) ? (array) $_POST['tax_input'][ $taxonomy->name ] : array();\n\t}\n\t$checked_categories = array_map( 'absint', (array) $post_category );\n\t$popular_ids        = wp_popular_terms_checklist( $taxonomy->name, 0, 10, false );\n\n\tforeach ( $names as $cat_name ) {\n\t\t$cat_name          = trim( $cat_name );\n\t\t$category_nicename = sanitize_title( $cat_name );\n\t\tif ( '' === $category_nicename ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$cat_id = wp_insert_term( $cat_name, $taxonomy->name, array( 'parent' => $parent ) );\n\t\tif ( ! $cat_id || is_wp_error( $cat_id ) ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t$cat_id = $cat_id['term_id'];\n\t\t}\n\t\t$checked_categories[] = $cat_id;\n\t\tif ( $parent ) { // Do these all at once in a second\n\t\t\tcontinue;\n\t\t}\n\n\t\tob_start();\n\n\t\twp_terms_checklist(\n\t\t\t0,\n\t\t\tarray(\n\t\t\t\t'taxonomy'             => $taxonomy->name,\n\t\t\t\t'descendants_and_self' => $cat_id,\n\t\t\t\t'selected_cats'        => $checked_categories,\n\t\t\t\t'popular_cats'         => $popular_ids,\n\t\t\t)\n\t\t);\n\n\t\t$data = ob_get_clean();\n\n\t\t$add = array(\n\t\t\t'what'     => $taxonomy->name,\n\t\t\t'id'       => $cat_id,\n\t\t\t'data'     => str_replace( array( \"\\n\", \"\\t\" ), '', $data ),\n\t\t\t'position' => -1,\n\t\t);\n\t}\n\n\tif ( $parent ) { // Foncy - replace the parent and all its children\n\t\t$parent  = get_term( $parent, $taxonomy->name );\n\t\t$term_id = $parent->term_id;\n\n\t\twhile ( $parent->parent ) { // get the top parent\n\t\t\t$parent = get_term( $parent->parent, $taxonomy->name );\n\t\t\tif ( is_wp_error( $parent ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$term_id = $parent->term_id;\n\t\t}\n\n\t\tob_start();\n\n\t\twp_terms_checklist(\n\t\t\t0,\n\t\t\tarray(\n\t\t\t\t'taxonomy'             => $taxonomy->name,\n\t\t\t\t'descendants_and_self' => $term_id,\n\t\t\t\t'selected_cats'        => $checked_categories,\n\t\t\t\t'popular_cats'         => $popular_ids,\n\t\t\t)\n\t\t);\n\n\t\t$data = ob_get_clean();\n\n\t\t$add = array(\n\t\t\t'what'     => $taxonomy->name,\n\t\t\t'id'       => $term_id,\n\t\t\t'data'     => str_replace( array( \"\\n\", \"\\t\" ), '', $data ),\n\t\t\t'position' => -1,\n\t\t);\n\t}\n\n\tob_start();\n\n\twp_dropdown_categories(\n\t\tarray(\n\t\t\t'taxonomy'         => $taxonomy->name,\n\t\t\t'hide_empty'       => 0,\n\t\t\t'name'             => 'new' . $taxonomy->name . '_parent',\n\t\t\t'orderby'          => 'name',\n\t\t\t'hierarchical'     => 1,\n\t\t\t'show_option_none' => '&mdash; ' . $taxonomy->labels->parent_item . ' &mdash;',\n\t\t)\n\t);\n\n\t$sup = ob_get_clean();\n\n\t$add['supplemental'] = array( 'newcat_parent' => $sup );\n\n\t$x = new WP_Ajax_Response( $add );\n\t$x->send();\n}\n\n/**\n * Ajax handler for deleting a comment.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_comment() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tif ( ! $comment = get_comment( $id ) ) {\n\t\twp_die( time() );\n\t}\n\tif ( ! current_user_can( 'edit_comment', $comment->comment_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tcheck_ajax_referer( \"delete-comment_$id\" );\n\t$status = wp_get_comment_status( $comment );\n\n\t$delta = -1;\n\tif ( isset( $_POST['trash'] ) && 1 == $_POST['trash'] ) {\n\t\tif ( 'trash' == $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_trash_comment( $comment );\n\t} elseif ( isset( $_POST['untrash'] ) && 1 == $_POST['untrash'] ) {\n\t\tif ( 'trash' != $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_untrash_comment( $comment );\n\t\tif ( ! isset( $_POST['comment_status'] ) || $_POST['comment_status'] != 'trash' ) { // undo trash, not in trash\n\t\t\t$delta = 1;\n\t\t}\n\t} elseif ( isset( $_POST['spam'] ) && 1 == $_POST['spam'] ) {\n\t\tif ( 'spam' == $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_spam_comment( $comment );\n\t} elseif ( isset( $_POST['unspam'] ) && 1 == $_POST['unspam'] ) {\n\t\tif ( 'spam' != $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_unspam_comment( $comment );\n\t\tif ( ! isset( $_POST['comment_status'] ) || $_POST['comment_status'] != 'spam' ) { // undo spam, not in spam\n\t\t\t$delta = 1;\n\t\t}\n\t} elseif ( isset( $_POST['delete'] ) && 1 == $_POST['delete'] ) {\n\t\t$r = wp_delete_comment( $comment );\n\t} else {\n\t\twp_die( -1 );\n\t}\n\n\tif ( $r ) { // Decide if we need to send back '1' or a more complicated response including page links and comment counts\n\t\t_wp_ajax_delete_comment_response( $comment->comment_ID, $delta );\n\t}\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for deleting a tag.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_tag() {\n\t$tag_id = (int) $_POST['tag_ID'];\n\tcheck_ajax_referer( \"delete-tag_$tag_id\" );\n\n\tif ( ! current_user_can( 'delete_term', $tag_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$taxonomy = ! empty( $_POST['taxonomy'] ) ? $_POST['taxonomy'] : 'post_tag';\n\t$tag      = get_term( $tag_id, $taxonomy );\n\tif ( ! $tag || is_wp_error( $tag ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_term( $tag_id, $taxonomy ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler for deleting a link.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_link() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"delete-bookmark_$id\" );\n\tif ( ! current_user_can( 'manage_links' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$link = get_bookmark( $id );\n\tif ( ! $link || is_wp_error( $link ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_link( $id ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler for deleting meta.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_meta() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"delete-meta_$id\" );\n\tif ( ! $meta = get_metadata_by_mid( 'post', $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( is_protected_meta( $meta->meta_key, 'post' ) || ! current_user_can( 'delete_post_meta', $meta->post_id, $meta->meta_key ) ) {\n\t\twp_die( -1 );\n\t}\n\tif ( delete_meta( $meta->meta_id ) ) {\n\t\twp_die( 1 );\n\t}\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for deleting a post.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_delete_post( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'delete-post';\n\t}\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"{$action}_$id\" );\n\tif ( ! current_user_can( 'delete_post', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! get_post( $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_post( $id ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler for sending a post to the trash.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_trash_post( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'trash-post';\n\t}\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"{$action}_$id\" );\n\tif ( ! current_user_can( 'delete_post', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! get_post( $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( 'trash-post' == $action ) {\n\t\t$done = wp_trash_post( $id );\n\t} else {\n\t\t$done = wp_untrash_post( $id );\n\t}\n\n\tif ( $done ) {\n\t\twp_die( 1 );\n\t}\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler to restore a post from the trash.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_untrash_post( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'untrash-post';\n\t}\n\twp_ajax_trash_post( $action );\n}\n\n/**\n * Ajax handler to delete a page.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_delete_page( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'delete-page';\n\t}\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"{$action}_$id\" );\n\tif ( ! current_user_can( 'delete_page', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! get_post( $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_post( $id ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler to dim a comment.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_dim_comment() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tif ( ! $comment = get_comment( $id ) ) {\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what' => 'comment',\n\t\t\t\t/* translators: %d: comment ID */\n\t\t\t\t'id'   => new WP_Error( 'invalid_comment', sprintf( __( 'Comment %d does not exist' ), $id ) ),\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\tif ( ! current_user_can( 'edit_comment', $comment->comment_ID ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$current = wp_get_comment_status( $comment );\n\tif ( isset( $_POST['new'] ) && $_POST['new'] == $current ) {\n\t\twp_die( time() );\n\t}\n\n\tcheck_ajax_referer( \"approve-comment_$id\" );\n\tif ( in_array( $current, array( 'unapproved', 'spam' ) ) ) {\n\t\t$result = wp_set_comment_status( $comment, 'approve', true );\n\t} else {\n\t\t$result = wp_set_comment_status( $comment, 'hold', true );\n\t}\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what' => 'comment',\n\t\t\t\t'id'   => $result,\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\t// Decide if we need to send back '1' or a more complicated response including page links and comment counts\n\t_wp_ajax_delete_comment_response( $comment->comment_ID );\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for adding a link category.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_add_link_category( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'add-link-category';\n\t}\n\tcheck_ajax_referer( $action );\n\t$tax = get_taxonomy( 'link_category' );\n\tif ( ! current_user_can( $tax->cap->manage_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\t$names = explode( ',', wp_unslash( $_POST['newcat'] ) );\n\t$x     = new WP_Ajax_Response();\n\tforeach ( $names as $cat_name ) {\n\t\t$cat_name = trim( $cat_name );\n\t\t$slug     = sanitize_title( $cat_name );\n\t\tif ( '' === $slug ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$cat_id = wp_insert_term( $cat_name, 'link_category' );\n\t\tif ( ! $cat_id || is_wp_error( $cat_id ) ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t$cat_id = $cat_id['term_id'];\n\t\t}\n\t\t$cat_name = esc_html( $cat_name );\n\t\t$x->add(\n\t\t\tarray(\n\t\t\t\t'what'     => 'link-category',\n\t\t\t\t'id'       => $cat_id,\n\t\t\t\t'data'     => \"<li id='link-category-$cat_id'><label for='in-link-category-$cat_id' class='selectit'><input value='\" . esc_attr( $cat_id ) . \"' type='checkbox' checked='checked' name='link_category[]' id='in-link-category-$cat_id'/> $cat_name</label></li>\",\n\t\t\t\t'position' => -1,\n\t\t\t)\n\t\t);\n\t}\n\t$x->send();\n}\n\n/**\n * Ajax handler to add a tag.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_add_tag() {\n\tcheck_ajax_referer( 'add-tag', '_wpnonce_add-tag' );\n\t$taxonomy = ! empty( $_POST['taxonomy'] ) ? $_POST['taxonomy'] : 'post_tag';\n\t$tax      = get_taxonomy( $taxonomy );\n\n\tif ( ! current_user_can( $tax->cap->edit_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$x = new WP_Ajax_Response();\n\n\t$tag = wp_insert_term( $_POST['tag-name'], $taxonomy, $_POST );\n\n\tif ( ! $tag || is_wp_error( $tag ) || ( ! $tag = get_term( $tag['term_id'], $taxonomy ) ) ) {\n\t\t$message = __( 'An error has occurred. Please reload the page and try again.' );\n\t\tif ( is_wp_error( $tag ) && $tag->get_error_message() ) {\n\t\t\t$message = $tag->get_error_message();\n\t\t}\n\n\t\t$x->add(\n\t\t\tarray(\n\t\t\t\t'what' => 'taxonomy',\n\t\t\t\t'data' => new WP_Error( 'error', $message ),\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\t$wp_list_table = _get_list_table( 'WP_Terms_List_Table', array( 'screen' => $_POST['screen'] ) );\n\n\t$level = 0;\n\tif ( is_taxonomy_hierarchical( $taxonomy ) ) {\n\t\t$level = count( get_ancestors( $tag->term_id, $taxonomy, 'taxonomy' ) );\n\t\tob_start();\n\t\t$wp_list_table->single_row( $tag, $level );\n\t\t$noparents = ob_get_clean();\n\t}\n\n\tob_start();\n\t$wp_list_table->single_row( $tag );\n\t$parents = ob_get_clean();\n\n\t$x->add(\n\t\tarray(\n\t\t\t'what'         => 'taxonomy',\n\t\t\t'supplemental' => compact( 'parents', 'noparents' ),\n\t\t)\n\t);\n\t$x->add(\n\t\tarray(\n\t\t\t'what'         => 'term',\n\t\t\t'position'     => $level,\n\t\t\t'supplemental' => (array) $tag,\n\t\t)\n\t);\n\t$x->send();\n}\n\n/**\n * Ajax handler for getting a tagcloud.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_get_tagcloud() {\n\tif ( ! isset( $_POST['tax'] ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$taxonomy = sanitize_key( $_POST['tax'] );\n\t$tax      = get_taxonomy( $taxonomy );\n\tif ( ! $tax ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! current_user_can( $tax->cap->assign_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$tags = get_terms(\n\t\t$taxonomy,\n\t\tarray(\n\t\t\t'number'  => 45,\n\t\t\t'orderby' => 'count',\n\t\t\t'order'   => 'DESC',\n\t\t)\n\t);\n\n\tif ( empty( $tags ) ) {\n\t\twp_die( $tax->labels->not_found );\n\t}\n\n\tif ( is_wp_error( $tags ) ) {\n\t\twp_die( $tags->get_error_message() );\n\t}\n\n\tforeach ( $tags as $key => $tag ) {\n\t\t$tags[ $key ]->link = '#';\n\t\t$tags[ $key ]->id   = $tag->term_id;\n\t}\n\n\t// We need raw tag names here, so don't filter the output\n\t$return = wp_generate_tag_cloud(\n\t\t$tags,\n\t\tarray(\n\t\t\t'filter' => 0,\n\t\t\t'format' => 'list',\n\t\t)\n\t);\n\n\tif ( empty( $return ) ) {\n\t\twp_die( 0 );\n\t}\n\n\techo $return;\n\n\twp_die();\n}\n\n/**\n * Ajax handler for getting comments.\n *\n * @since 3.1.0\n *\n * @global int           $post_id\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_get_comments( $action ) {\n\tglobal $post_id;\n\tif ( empty( $action ) ) {\n\t\t$action = 'get-comments';\n\t}\n\tcheck_ajax_referer( $action );\n\n\tif ( empty( $post_id ) && ! empty( $_REQUEST['p'] ) ) {\n\t\t$id = absint( $_REQUEST['p'] );\n\t\tif ( ! empty( $id ) ) {\n\t\t\t$post_id = $id;\n\t\t}\n\t}\n\n\tif ( empty( $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table = _get_list_table( 'WP_Post_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\n\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table->prepare_items();\n\n\tif ( ! $wp_list_table->has_items() ) {\n\t\twp_die( 1 );\n\t}\n\n\t$x = new WP_Ajax_Response();\n\tob_start();\n\tforeach ( $wp_list_table->items as $comment ) {\n\t\tif ( ! current_user_can( 'edit_comment', $comment->comment_ID ) && 0 === $comment->comment_approved ) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_comment( $comment );\n\t\t$wp_list_table->single_row( $comment );\n\t}\n\t$comment_list_item = ob_get_clean();\n\n\t$x->add(\n\t\tarray(\n\t\t\t'what' => 'comments',\n\t\t\t'data' => $comment_list_item,\n\t\t)\n\t);\n\t$x->send();\n}\n\n/**\n * Ajax handler for replying to a comment.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_replyto_comment( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'replyto-comment';\n\t}\n\n\tcheck_ajax_referer( $action, '_ajax_nonce-replyto-comment' );\n\n\t$comment_post_ID = (int) $_POST['comment_post_ID'];\n\t$post            = get_post( $comment_post_ID );\n\tif ( ! $post ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! current_user_can( 'edit_post', $comment_post_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( empty( $post->post_status ) ) {\n\t\twp_die( 1 );\n\t} elseif ( in_array( $post->post_status, array( 'draft', 'pending', 'trash' ) ) ) {\n\t\twp_die( __( 'ERROR: you are replying to a comment on a draft post.' ) );\n\t}\n\n\t$user = wp_get_current_user();\n\tif ( $user->exists() ) {\n\t\t$user_ID              = $user->ID;\n\t\t$comment_author       = wp_slash( $user->display_name );\n\t\t$comment_author_email = wp_slash( $user->user_email );\n\t\t$comment_author_url   = wp_slash( $user->user_url );\n\t\t$comment_content      = trim( $_POST['content'] );\n\t\t$comment_type         = isset( $_POST['comment_type'] ) ? trim( $_POST['comment_type'] ) : '';\n\t\tif ( current_user_can( 'unfiltered_html' ) ) {\n\t\t\tif ( ! isset( $_POST['_wp_unfiltered_html_comment'] ) ) {\n\t\t\t\t$_POST['_wp_unfiltered_html_comment'] = '';\n\t\t\t}\n\n\t\t\tif ( wp_create_nonce( 'unfiltered-html-comment' ) != $_POST['_wp_unfiltered_html_comment'] ) {\n\t\t\t\tkses_remove_filters(); // start with a clean slate\n\t\t\t\tkses_init_filters(); // set up the filters\n\t\t\t}\n\t\t}\n\t} else {\n\t\twp_die( __( 'Sorry, you must be logged in to reply to a comment.' ) );\n\t}\n\n\tif ( '' == $comment_content ) {\n\t\twp_die( __( 'ERROR: please type a comment.' ) );\n\t}\n\n\t$comment_parent = 0;\n\tif ( isset( $_POST['comment_ID'] ) ) {\n\t\t$comment_parent = absint( $_POST['comment_ID'] );\n\t}\n\t$comment_auto_approved = false;\n\t$commentdata           = compact( 'comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_content', 'comment_type', 'comment_parent', 'user_ID' );\n\n\t// Automatically approve parent comment.\n\tif ( ! empty( $_POST['approve_parent'] ) ) {\n\t\t$parent = get_comment( $comment_parent );\n\n\t\tif ( $parent && $parent->comment_approved === '0' && $parent->comment_post_ID == $comment_post_ID ) {\n\t\t\tif ( ! current_user_can( 'edit_comment', $parent->comment_ID ) ) {\n\t\t\t\twp_die( -1 );\n\t\t\t}\n\n\t\t\tif ( wp_set_comment_status( $parent, 'approve' ) ) {\n\t\t\t\t$comment_auto_approved = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t$comment_id = wp_new_comment( $commentdata );\n\n\tif ( is_wp_error( $comment_id ) ) {\n\t\twp_die( $comment_id->get_error_message() );\n\t}\n\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\twp_die( 1 );\n\t}\n\n\t$position = ( isset( $_POST['position'] ) && (int) $_POST['position'] ) ? (int) $_POST['position'] : '-1';\n\n\tob_start();\n\tif ( isset( $_REQUEST['mode'] ) && 'dashboard' == $_REQUEST['mode'] ) {\n\t\trequire_once( ABSPATH . 'wp-admin/includes/dashboard.php' );\n\t\t_wp_dashboard_recent_comments_row( $comment );\n\t} else {\n\t\tif ( isset( $_REQUEST['mode'] ) && 'single' == $_REQUEST['mode'] ) {\n\t\t\t$wp_list_table = _get_list_table( 'WP_Post_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\t\t} else {\n\t\t\t$wp_list_table = _get_list_table( 'WP_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\t\t}\n\t\t$wp_list_table->single_row( $comment );\n\t}\n\t$comment_list_item = ob_get_clean();\n\n\t$response = array(\n\t\t'what'     => 'comment',\n\t\t'id'       => $comment->comment_ID,\n\t\t'data'     => $comment_list_item,\n\t\t'position' => $position,\n\t);\n\n\t$counts                   = wp_count_comments();\n\t$response['supplemental'] = array(\n\t\t'in_moderation'        => $counts->moderated,\n\t\t'i18n_comments_text'   => sprintf(\n\t\t\t/* translators: %s: number of comments approved */\n\t\t\t_n( '%s Comment', '%s Comments', $counts->approved ),\n\t\t\tnumber_format_i18n( $counts->approved )\n\t\t),\n\t\t'i18n_moderation_text' => sprintf(\n\t\t\t/* translators: %s: number of comments moderated */\n\t\t\t_nx( '%s in moderation', '%s in moderation', $counts->moderated, 'comments' ),\n\t\t\tnumber_format_i18n( $counts->moderated )\n\t\t),\n\t);\n\n\tif ( $comment_auto_approved ) {\n\t\t$response['supplemental']['parent_approved'] = $parent->comment_ID;\n\t\t$response['supplemental']['parent_post_id']  = $parent->comment_post_ID;\n\t}\n\n\t$x = new WP_Ajax_Response();\n\t$x->add( $response );\n\t$x->send();\n}\n\n/**\n * Ajax handler for editing a comment.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_edit_comment() {\n\tcheck_ajax_referer( 'replyto-comment', '_ajax_nonce-replyto-comment' );\n\n\t$comment_id = (int) $_POST['comment_ID'];\n\tif ( ! current_user_can( 'edit_comment', $comment_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( '' == $_POST['content'] ) {\n\t\twp_die( __( 'ERROR: please type a comment.' ) );\n\t}\n\n\tif ( isset( $_POST['status'] ) ) {\n\t\t$_POST['comment_status'] = $_POST['status'];\n\t}\n\tedit_comment();\n\n\t$position      = ( isset( $_POST['position'] ) && (int) $_POST['position'] ) ? (int) $_POST['position'] : '-1';\n\t$checkbox      = ( isset( $_POST['checkbox'] ) && true == $_POST['checkbox'] ) ? 1 : 0;\n\t$wp_list_table = _get_list_table( $checkbox ? 'WP_Comments_List_Table' : 'WP_Post_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\n\t$comment = get_comment( $comment_id );\n\tif ( empty( $comment->comment_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tob_start();\n\t$wp_list_table->single_row( $comment );\n\t$comment_list_item = ob_get_clean();\n\n\t$x = new WP_Ajax_Response();\n\n\t$x->add(\n\t\tarray(\n\t\t\t'what'     => 'edit_comment',\n\t\t\t'id'       => $comment->comment_ID,\n\t\t\t'data'     => $comment_list_item,\n\t\t\t'position' => $position,\n\t\t)\n\t);\n\n\t$x->send();\n}\n\n/**\n * Ajax handler for adding a menu item.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_add_menu_item() {\n\tcheck_ajax_referer( 'add-menu_item', 'menu-settings-column-nonce' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\trequire_once ABSPATH . 'wp-admin/includes/nav-menu.php';\n\n\t// For performance reasons, we omit some object properties from the checklist.\n\t// The following is a hacky way to restore them when adding non-custom items.\n\n\t$menu_items_data = array();\n\tforeach ( (array) $_POST['menu-item'] as $menu_item_data ) {\n\t\tif (\n\t\t\t! empty( $menu_item_data['menu-item-type'] ) &&\n\t\t\t'custom' != $menu_item_data['menu-item-type'] &&\n\t\t\t! empty( $menu_item_data['menu-item-object-id'] )\n\t\t) {\n\t\t\tswitch ( $menu_item_data['menu-item-type'] ) {\n\t\t\t\tcase 'post_type':\n\t\t\t\t\t$_object = get_post( $menu_item_data['menu-item-object-id'] );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post_type_archive':\n\t\t\t\t\t$_object = get_post_type_object( $menu_item_data['menu-item-object'] );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'taxonomy':\n\t\t\t\t\t$_object = get_term( $menu_item_data['menu-item-object-id'], $menu_item_data['menu-item-object'] );\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$_menu_items = array_map( 'wp_setup_nav_menu_item', array( $_object ) );\n\t\t\t$_menu_item  = reset( $_menu_items );\n\n\t\t\t// Restore the missing menu item properties\n\t\t\t$menu_item_data['menu-item-description'] = $_menu_item->description;\n\t\t}\n\n\t\t$menu_items_data[] = $menu_item_data;\n\t}\n\n\t$item_ids = wp_save_nav_menu_items( 0, $menu_items_data );\n\tif ( is_wp_error( $item_ids ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$menu_items = array();\n\n\tforeach ( (array) $item_ids as $menu_item_id ) {\n\t\t$menu_obj = get_post( $menu_item_id );\n\t\tif ( ! empty( $menu_obj->ID ) ) {\n\t\t\t$menu_obj        = wp_setup_nav_menu_item( $menu_obj );\n\t\t\t$menu_obj->label = $menu_obj->title; // don't show \"(pending)\" in ajax-added items\n\t\t\t$menu_items[]    = $menu_obj;\n\t\t}\n\t}\n\n\t/** This filter is documented in wp-admin/includes/nav-menu.php */\n\t$walker_class_name = apply_filters( 'wp_edit_nav_menu_walker', 'Walker_Nav_Menu_Edit', $_POST['menu'] );\n\n\tif ( ! class_exists( $walker_class_name ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! empty( $menu_items ) ) {\n\t\t$args = array(\n\t\t\t'after'       => '',\n\t\t\t'before'      => '',\n\t\t\t'link_after'  => '',\n\t\t\t'link_before' => '',\n\t\t\t'walker'      => new $walker_class_name,\n\t\t);\n\t\techo walk_nav_menu_tree( $menu_items, 0, (object) $args );\n\t}\n\twp_die();\n}\n\n/**\n * Ajax handler for adding meta.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_add_meta() {\n\tcheck_ajax_referer( 'add-meta', '_ajax_nonce-add-meta' );\n\t$c    = 0;\n\t$pid  = (int) $_POST['post_id'];\n\t$post = get_post( $pid );\n\n\tif ( isset( $_POST['metakeyselect'] ) || isset( $_POST['metakeyinput'] ) ) {\n\t\tif ( ! current_user_can( 'edit_post', $pid ) ) {\n\t\t\twp_die( -1 );\n\t\t}\n\t\tif ( isset( $_POST['metakeyselect'] ) && '#NONE#' == $_POST['metakeyselect'] && empty( $_POST['metakeyinput'] ) ) {\n\t\t\twp_die( 1 );\n\t\t}\n\n\t\t// If the post is an autodraft, save the post as a draft and then attempt to save the meta.\n\t\tif ( $post->post_status == 'auto-draft' ) {\n\t\t\t$post_data                = array();\n\t\t\t$post_data['action']      = 'draft'; // Warning fix\n\t\t\t$post_data['post_ID']     = $pid;\n\t\t\t$post_data['post_type']   = $post->post_type;\n\t\t\t$post_data['post_status'] = 'draft';\n\t\t\t$now                      = time();\n\t\t\t/* translators: 1: Post creation date, 2: Post creation time */\n\t\t\t$post_data['post_title'] = sprintf( __( 'Draft created on %1$s at %2$s' ), date( __( 'F j, Y' ), $now ), date( __( 'g:i a' ), $now ) );\n\n\t\t\t$pid = edit_post( $post_data );\n\t\t\tif ( $pid ) {\n\t\t\t\tif ( is_wp_error( $pid ) ) {\n\t\t\t\t\t$x = new WP_Ajax_Response(\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'what' => 'meta',\n\t\t\t\t\t\t\t'data' => $pid,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\t$x->send();\n\t\t\t\t}\n\n\t\t\t\tif ( ! $mid = add_meta( $pid ) ) {\n\t\t\t\t\twp_die( __( 'Please provide a custom field value.' ) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twp_die( 0 );\n\t\t\t}\n\t\t} elseif ( ! $mid = add_meta( $pid ) ) {\n\t\t\twp_die( __( 'Please provide a custom field value.' ) );\n\t\t}\n\n\t\t$meta = get_metadata_by_mid( 'post', $mid );\n\t\t$pid  = (int) $meta->post_id;\n\t\t$meta = get_object_vars( $meta );\n\t\t$x    = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what'         => 'meta',\n\t\t\t\t'id'           => $mid,\n\t\t\t\t'data'         => _list_meta_row( $meta, $c ),\n\t\t\t\t'position'     => 1,\n\t\t\t\t'supplemental' => array( 'postid' => $pid ),\n\t\t\t)\n\t\t);\n\t} else { // Update?\n\t\t$mid   = (int) key( $_POST['meta'] );\n\t\t$key   = wp_unslash( $_POST['meta'][ $mid ]['key'] );\n\t\t$value = wp_unslash( $_POST['meta'][ $mid ]['value'] );\n\t\tif ( '' == trim( $key ) ) {\n\t\t\twp_die( __( 'Please provide a custom field name.' ) );\n\t\t}\n\t\tif ( ! $meta = get_metadata_by_mid( 'post', $mid ) ) {\n\t\t\twp_die( 0 ); // if meta doesn't exist\n\t\t}\n\t\tif ( is_protected_meta( $meta->meta_key, 'post' ) || is_protected_meta( $key, 'post' ) ||\n\t\t\t! current_user_can( 'edit_post_meta', $meta->post_id, $meta->meta_key ) ||\n\t\t\t! current_user_can( 'edit_post_meta', $meta->post_id, $key ) ) {\n\t\t\twp_die( -1 );\n\t\t}\n\t\tif ( $meta->meta_value != $value || $meta->meta_key != $key ) {\n\t\t\tif ( ! $u = update_metadata_by_mid( 'post', $mid, $value, $key ) ) {\n\t\t\t\twp_die( 0 ); // We know meta exists; we also know it's unchanged (or DB error, in which case there are bigger problems).\n\t\t\t}\n\t\t}\n\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what'         => 'meta',\n\t\t\t\t'id'           => $mid,\n\t\t\t\t'old_id'       => $mid,\n\t\t\t\t'data'         => _list_meta_row(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'meta_key'   => $key,\n\t\t\t\t\t\t'meta_value' => $value,\n\t\t\t\t\t\t'meta_id'    => $mid,\n\t\t\t\t\t),\n\t\t\t\t\t$c\n\t\t\t\t),\n\t\t\t\t'position'     => 0,\n\t\t\t\t'supplemental' => array( 'postid' => $meta->post_id ),\n\t\t\t)\n\t\t);\n\t}\n\t$x->send();\n}\n\n/**\n * Ajax handler for adding a user.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_add_user( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'add-user';\n\t}\n\n\tcheck_ajax_referer( $action );\n\tif ( ! current_user_can( 'create_users' ) ) {\n\t\twp_die( -1 );\n\t}\n\tif ( ! $user_id = edit_user() ) {\n\t\twp_die( 0 );\n\t} elseif ( is_wp_error( $user_id ) ) {\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what' => 'user',\n\t\t\t\t'id'   => $user_id,\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\t$user_object = get_userdata( $user_id );\n\n\t$wp_list_table = _get_list_table( 'WP_Users_List_Table' );\n\n\t$role = current( $user_object->roles );\n\n\t$x = new WP_Ajax_Response(\n\t\tarray(\n\t\t\t'what'         => 'user',\n\t\t\t'id'           => $user_id,\n\t\t\t'data'         => $wp_list_table->single_row( $user_object, '', $role ),\n\t\t\t'supplemental' => array(\n\t\t\t\t'show-link' => sprintf(\n\t\t\t\t\t/* translators: %s: the new user */\n\t\t\t\t\t__( 'User %s added' ),\n\t\t\t\t\t'<a href=\"#user-' . $user_id . '\">' . $user_object->user_login . '</a>'\n\t\t\t\t),\n\t\t\t\t'role'      => $role,\n\t\t\t),\n\t\t)\n\t);\n\t$x->send();\n}\n\n/**\n * Ajax handler for closed post boxes.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_closed_postboxes() {\n\tcheck_ajax_referer( 'closedpostboxes', 'closedpostboxesnonce' );\n\t$closed = isset( $_POST['closed'] ) ? explode( ',', $_POST['closed'] ) : array();\n\t$closed = array_filter( $closed );\n\n\t$hidden = isset( $_POST['hidden'] ) ? explode( ',', $_POST['hidden'] ) : array();\n\t$hidden = array_filter( $hidden );\n\n\t$page = isset( $_POST['page'] ) ? $_POST['page'] : '';\n\n\tif ( $page != sanitize_key( $page ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $user = wp_get_current_user() ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( is_array( $closed ) ) {\n\t\tupdate_user_option( $user->ID, \"closedpostboxes_$page\", $closed, true );\n\t}\n\n\tif ( is_array( $hidden ) ) {\n\t\t$hidden = array_diff( $hidden, array( 'submitdiv', 'linksubmitdiv', 'manage-menu', 'create-menu' ) ); // postboxes that are always shown\n\t\tupdate_user_option( $user->ID, \"metaboxhidden_$page\", $hidden, true );\n\t}\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for hidden columns.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_hidden_columns() {\n\tcheck_ajax_referer( 'screen-options-nonce', 'screenoptionnonce' );\n\t$page = isset( $_POST['page'] ) ? $_POST['page'] : '';\n\n\tif ( $page != sanitize_key( $page ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $user = wp_get_current_user() ) {\n\t\twp_die( -1 );\n\t}\n\n\t$hidden = ! empty( $_POST['hidden'] ) ? explode( ',', $_POST['hidden'] ) : array();\n\tupdate_user_option( $user->ID, \"manage{$page}columnshidden\", $hidden, true );\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for updating whether to display the welcome panel.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_update_welcome_panel() {\n\tcheck_ajax_referer( 'welcome-panel-nonce', 'welcomepanelnonce' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tupdate_user_meta( get_current_user_id(), 'show_welcome_panel', empty( $_POST['visible'] ) ? 0 : 1 );\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for retrieving menu meta boxes.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_menu_get_metabox() {\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\trequire_once ABSPATH . 'wp-admin/includes/nav-menu.php';\n\n\tif ( isset( $_POST['item-type'] ) && 'post_type' == $_POST['item-type'] ) {\n\t\t$type     = 'posttype';\n\t\t$callback = 'wp_nav_menu_item_post_type_meta_box';\n\t\t$items    = (array) get_post_types( array( 'show_in_nav_menus' => true ), 'object' );\n\t} elseif ( isset( $_POST['item-type'] ) && 'taxonomy' == $_POST['item-type'] ) {\n\t\t$type     = 'taxonomy';\n\t\t$callback = 'wp_nav_menu_item_taxonomy_meta_box';\n\t\t$items    = (array) get_taxonomies( array( 'show_ui' => true ), 'object' );\n\t}\n\n\tif ( ! empty( $_POST['item-object'] ) && isset( $items[ $_POST['item-object'] ] ) ) {\n\t\t$menus_meta_box_object = $items[ $_POST['item-object'] ];\n\n\t\t/** This filter is documented in wp-admin/includes/nav-menu.php */\n\t\t$item = apply_filters( 'nav_menu_meta_box_object', $menus_meta_box_object );\n\t\tob_start();\n\t\tcall_user_func_array(\n\t\t\t$callback,\n\t\t\tarray(\n\t\t\t\tnull,\n\t\t\t\tarray(\n\t\t\t\t\t'id'       => 'add-' . $item->name,\n\t\t\t\t\t'title'    => $item->labels->name,\n\t\t\t\t\t'callback' => $callback,\n\t\t\t\t\t'args'     => $item,\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\n\t\t$markup = ob_get_clean();\n\n\t\techo wp_json_encode(\n\t\t\tarray(\n\t\t\t\t'replace-id' => $type . '-' . $item->name,\n\t\t\t\t'markup'     => $markup,\n\t\t\t)\n\t\t);\n\t}\n\n\twp_die();\n}\n\n/**\n * Ajax handler for internal linking.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_wp_link_ajax() {\n\tcheck_ajax_referer( 'internal-linking', '_ajax_linking_nonce' );\n\n\t$args = array();\n\n\tif ( isset( $_POST['search'] ) ) {\n\t\t$args['s'] = wp_unslash( $_POST['search'] );\n\t}\n\n\tif ( isset( $_POST['term'] ) ) {\n\t\t$args['s'] = wp_unslash( $_POST['term'] );\n\t}\n\n\t$args['pagenum'] = ! empty( $_POST['page'] ) ? absint( $_POST['page'] ) : 1;\n\n\tif ( ! class_exists( '_WP_Editors', false ) ) {\n\t\trequire( ABSPATH . WPINC . '/class-wp-editor.php' );\n\t}\n\n\t$results = _WP_Editors::wp_link_query( $args );\n\n\tif ( ! isset( $results ) ) {\n\t\twp_die( 0 );\n\t}\n\n\techo wp_json_encode( $results );\n\techo \"\\n\";\n\n\twp_die();\n}\n\n/**\n * Ajax handler for menu locations save.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_menu_locations_save() {\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\tcheck_ajax_referer( 'add-menu_item', 'menu-settings-column-nonce' );\n\tif ( ! isset( $_POST['menu-locations'] ) ) {\n\t\twp_die( 0 );\n\t}\n\tset_theme_mod( 'nav_menu_locations', array_map( 'absint', $_POST['menu-locations'] ) );\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for saving the meta box order.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_meta_box_order() {\n\tcheck_ajax_referer( 'meta-box-order' );\n\t$order        = isset( $_POST['order'] ) ? (array) $_POST['order'] : false;\n\t$page_columns = isset( $_POST['page_columns'] ) ? $_POST['page_columns'] : 'auto';\n\n\tif ( $page_columns != 'auto' ) {\n\t\t$page_columns = (int) $page_columns;\n\t}\n\n\t$page = isset( $_POST['page'] ) ? $_POST['page'] : '';\n\n\tif ( $page != sanitize_key( $page ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $user = wp_get_current_user() ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( $order ) {\n\t\tupdate_user_option( $user->ID, \"meta-box-order_$page\", $order, true );\n\t}\n\n\tif ( $page_columns ) {\n\t\tupdate_user_option( $user->ID, \"screen_layout_$page\", $page_columns, true );\n\t}\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for menu quick searching.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_menu_quick_search() {\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\trequire_once ABSPATH . 'wp-admin/includes/nav-menu.php';\n\n\t_wp_ajax_menu_quick_search( $_POST );\n\n\twp_die();\n}\n\n/**\n * Ajax handler to retrieve a permalink.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_get_permalink() {\n\tcheck_ajax_referer( 'getpermalink', 'getpermalinknonce' );\n\t$post_id = isset( $_POST['post_id'] ) ? intval( $_POST['post_id'] ) : 0;\n\twp_die( get_preview_post_link( $post_id ) );\n}\n\n/**\n * Ajax handler to retrieve a sample permalink.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_sample_permalink() {\n\tcheck_ajax_referer( 'samplepermalink', 'samplepermalinknonce' );\n\t$post_id = isset( $_POST['post_id'] ) ? intval( $_POST['post_id'] ) : 0;\n\t$title   = isset( $_POST['new_title'] ) ? $_POST['new_title'] : '';\n\t$slug    = isset( $_POST['new_slug'] ) ? $_POST['new_slug'] : null;\n\twp_die( get_sample_permalink_html( $post_id, $title, $slug ) );\n}\n\n/**\n * Ajax handler for Quick Edit saving a post from a list table.\n *\n * @since 3.1.0\n *\n * @global string $mode List table view mode.\n */\nfunction wp_ajax_inline_save() {\n\tglobal $mode;\n\n\tcheck_ajax_referer( 'inlineeditnonce', '_inline_edit' );\n\n\tif ( ! isset( $_POST['post_ID'] ) || ! ( $post_ID = (int) $_POST['post_ID'] ) ) {\n\t\twp_die();\n\t}\n\n\tif ( 'page' == $_POST['post_type'] ) {\n\t\tif ( ! current_user_can( 'edit_page', $post_ID ) ) {\n\t\t\twp_die( __( 'Sorry, you are not allowed to edit this page.' ) );\n\t\t}\n\t} else {\n\t\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\t\twp_die( __( 'Sorry, you are not allowed to edit this post.' ) );\n\t\t}\n\t}\n\n\tif ( $last = wp_check_post_lock( $post_ID ) ) {\n\t\t$last_user      = get_userdata( $last );\n\t\t$last_user_name = $last_user ? $last_user->display_name : __( 'Someone' );\n\n\t\t/* translators: %s: user who is currently editing the post */\n\t\t$msg_template = __( 'Saving is disabled: %s is currently editing this post.' );\n\t\tif ( $_POST['post_type'] == 'page' ) {\n\t\t\t/* translators: %s: user who is currently editing the page */\n\t\t\t$msg_template = __( 'Saving is disabled: %s is currently editing this page.' );\n\t\t}\n\n\t\tprintf( $msg_template, esc_html( $last_user_name ) );\n\t\twp_die();\n\t}\n\n\t$data = &$_POST;\n\n\t$post = get_post( $post_ID, ARRAY_A );\n\n\t// Since it's coming from the database.\n\t$post = wp_slash( $post );\n\n\t$data['content'] = $post['post_content'];\n\t$data['excerpt'] = $post['post_excerpt'];\n\n\t// Rename.\n\t$data['user_ID'] = get_current_user_id();\n\n\tif ( isset( $data['post_parent'] ) ) {\n\t\t$data['parent_id'] = $data['post_parent'];\n\t}\n\n\t// Status.\n\tif ( isset( $data['keep_private'] ) && 'private' == $data['keep_private'] ) {\n\t\t$data['visibility']  = 'private';\n\t\t$data['post_status'] = 'private';\n\t} else {\n\t\t$data['post_status'] = $data['_status'];\n\t}\n\n\tif ( empty( $data['comment_status'] ) ) {\n\t\t$data['comment_status'] = 'closed';\n\t}\n\tif ( empty( $data['ping_status'] ) ) {\n\t\t$data['ping_status'] = 'closed';\n\t}\n\n\t// Exclude terms from taxonomies that are not supposed to appear in Quick Edit.\n\tif ( ! empty( $data['tax_input'] ) ) {\n\t\tforeach ( $data['tax_input'] as $taxonomy => $terms ) {\n\t\t\t$tax_object = get_taxonomy( $taxonomy );\n\t\t\t/** This filter is documented in wp-admin/includes/class-wp-posts-list-table.php */\n\t\t\tif ( ! apply_filters( 'quick_edit_show_taxonomy', $tax_object->show_in_quick_edit, $taxonomy, $post['post_type'] ) ) {\n\t\t\t\tunset( $data['tax_input'][ $taxonomy ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Hack: wp_unique_post_slug() doesn't work for drafts, so we will fake that our post is published.\n\tif ( ! empty( $data['post_name'] ) && in_array( $post['post_status'], array( 'draft', 'pending' ) ) ) {\n\t\t$post['post_status'] = 'publish';\n\t\t$data['post_name']   = wp_unique_post_slug( $data['post_name'], $post['ID'], $post['post_status'], $post['post_type'], $post['post_parent'] );\n\t}\n\n\t// Update the post.\n\tedit_post();\n\n\t$wp_list_table = _get_list_table( 'WP_Posts_List_Table', array( 'screen' => $_POST['screen'] ) );\n\n\t$mode = $_POST['post_view'] === 'excerpt' ? 'excerpt' : 'list';\n\n\t$level = 0;\n\tif ( is_post_type_hierarchical( $wp_list_table->screen->post_type ) ) {\n\t\t$request_post = array( get_post( $_POST['post_ID'] ) );\n\t\t$parent       = $request_post[0]->post_parent;\n\n\t\twhile ( $parent > 0 ) {\n\t\t\t$parent_post = get_post( $parent );\n\t\t\t$parent      = $parent_post->post_parent;\n\t\t\t$level++;\n\t\t}\n\t}\n\n\t$wp_list_table->display_rows( array( get_post( $_POST['post_ID'] ) ), $level );\n\n\twp_die();\n}\n\n/**\n * Ajax handler for quick edit saving for a term.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_inline_save_tax() {\n\tcheck_ajax_referer( 'taxinlineeditnonce', '_inline_edit' );\n\n\t$taxonomy = sanitize_key( $_POST['taxonomy'] );\n\t$tax      = get_taxonomy( $taxonomy );\n\tif ( ! $tax ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! isset( $_POST['tax_ID'] ) || ! ( $id = (int) $_POST['tax_ID'] ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! current_user_can( 'edit_term', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table = _get_list_table( 'WP_Terms_List_Table', array( 'screen' => 'edit-' . $taxonomy ) );\n\n\t$tag                  = get_term( $id, $taxonomy );\n\t$_POST['description'] = $tag->description;\n\n\t$updated = wp_update_term( $id, $taxonomy, $_POST );\n\tif ( $updated && ! is_wp_error( $updated ) ) {\n\t\t$tag = get_term( $updated['term_id'], $taxonomy );\n\t\tif ( ! $tag || is_wp_error( $tag ) ) {\n\t\t\tif ( is_wp_error( $tag ) && $tag->get_error_message() ) {\n\t\t\t\twp_die( $tag->get_error_message() );\n\t\t\t}\n\t\t\twp_die( __( 'Item not updated.' ) );\n\t\t}\n\t} else {\n\t\tif ( is_wp_error( $updated ) && $updated->get_error_message() ) {\n\t\t\twp_die( $updated->get_error_message() );\n\t\t}\n\t\twp_die( __( 'Item not updated.' ) );\n\t}\n\t$level  = 0;\n\t$parent = $tag->parent;\n\twhile ( $parent > 0 ) {\n\t\t$parent_tag = get_term( $parent, $taxonomy );\n\t\t$parent     = $parent_tag->parent;\n\t\t$level++;\n\t}\n\t$wp_list_table->single_row( $tag, $level );\n\twp_die();\n}\n\n/**\n * Ajax handler for querying posts for the Find Posts modal.\n *\n * @see window.findPosts\n *\n * @since 3.1.0\n */\nfunction wp_ajax_find_posts() {\n\tcheck_ajax_referer( 'find-posts' );\n\n\t$post_types = get_post_types( array( 'public' => true ), 'objects' );\n\tunset( $post_types['attachment'] );\n\n\t$s    = wp_unslash( $_POST['ps'] );\n\t$args = array(\n\t\t'post_type'      => array_keys( $post_types ),\n\t\t'post_status'    => 'any',\n\t\t'posts_per_page' => 50,\n\t);\n\tif ( '' !== $s ) {\n\t\t$args['s'] = $s;\n\t}\n\n\t$posts = get_posts( $args );\n\n\tif ( ! $posts ) {\n\t\twp_send_json_error( __( 'No items found.' ) );\n\t}\n\n\t$html = '<table class=\"widefat\"><thead><tr><th class=\"found-radio\"><br /></th><th>' . __( 'Title' ) . '</th><th class=\"no-break\">' . __( 'Type' ) . '</th><th class=\"no-break\">' . __( 'Date' ) . '</th><th class=\"no-break\">' . __( 'Status' ) . '</th></tr></thead><tbody>';\n\t$alt  = '';\n\tforeach ( $posts as $post ) {\n\t\t$title = trim( $post->post_title ) ? $post->post_title : __( '(no title)' );\n\t\t$alt   = ( 'alternate' == $alt ) ? '' : 'alternate';\n\n\t\tswitch ( $post->post_status ) {\n\t\t\tcase 'publish':\n\t\t\tcase 'private':\n\t\t\t\t$stat = __( 'Published' );\n\t\t\t\tbreak;\n\t\t\tcase 'future':\n\t\t\t\t$stat = __( 'Scheduled' );\n\t\t\t\tbreak;\n\t\t\tcase 'pending':\n\t\t\t\t$stat = __( 'Pending Review' );\n\t\t\t\tbreak;\n\t\t\tcase 'draft':\n\t\t\t\t$stat = __( 'Draft' );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( '0000-00-00 00:00:00' == $post->post_date ) {\n\t\t\t$time = '';\n\t\t} else {\n\t\t\t/* translators: date format in table columns, see https://secure.php.net/date */\n\t\t\t$time = mysql2date( __( 'Y/m/d' ), $post->post_date );\n\t\t}\n\n\t\t$html .= '<tr class=\"' . trim( 'found-posts ' . $alt ) . '\"><td class=\"found-radio\"><input type=\"radio\" id=\"found-' . $post->ID . '\" name=\"found_post_id\" value=\"' . esc_attr( $post->ID ) . '\"></td>';\n\t\t$html .= '<td><label for=\"found-' . $post->ID . '\">' . esc_html( $title ) . '</label></td><td class=\"no-break\">' . esc_html( $post_types[ $post->post_type ]->labels->singular_name ) . '</td><td class=\"no-break\">' . esc_html( $time ) . '</td><td class=\"no-break\">' . esc_html( $stat ) . ' </td></tr>' . \"\\n\\n\";\n\t}\n\n\t$html .= '</tbody></table>';\n\n\twp_send_json_success( $html );\n}\n\n/**\n * Ajax handler for saving the widgets order.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_widgets_order() {\n\tcheck_ajax_referer( 'save-sidebar-widgets', 'savewidgets' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tunset( $_POST['savewidgets'], $_POST['action'] );\n\n\t// Save widgets order for all sidebars.\n\tif ( is_array( $_POST['sidebars'] ) ) {\n\t\t$sidebars = array();\n\t\tforeach ( wp_unslash( $_POST['sidebars'] ) as $key => $val ) {\n\t\t\t$sb = array();\n\t\t\tif ( ! empty( $val ) ) {\n\t\t\t\t$val = explode( ',', $val );\n\t\t\t\tforeach ( $val as $k => $v ) {\n\t\t\t\t\tif ( strpos( $v, 'widget-' ) === false ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$sb[ $k ] = substr( $v, strpos( $v, '_' ) + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\t$sidebars[ $key ] = $sb;\n\t\t}\n\t\twp_set_sidebars_widgets( $sidebars );\n\t\twp_die( 1 );\n\t}\n\n\twp_die( -1 );\n}\n\n/**\n * Ajax handler for saving a widget.\n *\n * @since 3.1.0\n *\n * @global array $wp_registered_widgets\n * @global array $wp_registered_widget_controls\n * @global array $wp_registered_widget_updates\n */\nfunction wp_ajax_save_widget() {\n\tglobal $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates;\n\n\tcheck_ajax_referer( 'save-sidebar-widgets', 'savewidgets' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) || ! isset( $_POST['id_base'] ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tunset( $_POST['savewidgets'], $_POST['action'] );\n\n\t/**\n\t * Fires early when editing the widgets displayed in sidebars.\n\t *\n\t * @since 2.8.0\n\t */\n\tdo_action( 'load-widgets.php' );\n\n\t/**\n\t * Fires early when editing the widgets displayed in sidebars.\n\t *\n\t * @since 2.8.0\n\t */\n\tdo_action( 'widgets.php' );\n\n\t/** This action is documented in wp-admin/widgets.php */\n\tdo_action( 'sidebar_admin_setup' );\n\n\t$id_base      = wp_unslash( $_POST['id_base'] );\n\t$widget_id    = wp_unslash( $_POST['widget-id'] );\n\t$sidebar_id   = $_POST['sidebar'];\n\t$multi_number = ! empty( $_POST['multi_number'] ) ? (int) $_POST['multi_number'] : 0;\n\t$settings     = isset( $_POST[ 'widget-' . $id_base ] ) && is_array( $_POST[ 'widget-' . $id_base ] ) ? $_POST[ 'widget-' . $id_base ] : false;\n\t$error        = '<p>' . __( 'An error has occurred. Please reload the page and try again.' ) . '</p>';\n\n\t$sidebars = wp_get_sidebars_widgets();\n\t$sidebar  = isset( $sidebars[ $sidebar_id ] ) ? $sidebars[ $sidebar_id ] : array();\n\n\t// Delete.\n\tif ( isset( $_POST['delete_widget'] ) && $_POST['delete_widget'] ) {\n\n\t\tif ( ! isset( $wp_registered_widgets[ $widget_id ] ) ) {\n\t\t\twp_die( $error );\n\t\t}\n\n\t\t$sidebar = array_diff( $sidebar, array( $widget_id ) );\n\t\t$_POST   = array(\n\t\t\t'sidebar'            => $sidebar_id,\n\t\t\t'widget-' . $id_base => array(),\n\t\t\t'the-widget-id'      => $widget_id,\n\t\t\t'delete_widget'      => '1',\n\t\t);\n\n\t\t/** This action is documented in wp-admin/widgets.php */\n\t\tdo_action( 'delete_widget', $widget_id, $sidebar_id, $id_base );\n\n\t} elseif ( $settings && preg_match( '/__i__|%i%/', key( $settings ) ) ) {\n\t\tif ( ! $multi_number ) {\n\t\t\twp_die( $error );\n\t\t}\n\n\t\t$_POST[ 'widget-' . $id_base ] = array( $multi_number => reset( $settings ) );\n\t\t$widget_id                     = $id_base . '-' . $multi_number;\n\t\t$sidebar[]                     = $widget_id;\n\t}\n\t$_POST['widget-id'] = $sidebar;\n\n\tforeach ( (array) $wp_registered_widget_updates as $name => $control ) {\n\n\t\tif ( $name == $id_base ) {\n\t\t\tif ( ! is_callable( $control['callback'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tob_start();\n\t\t\t\tcall_user_func_array( $control['callback'], $control['params'] );\n\t\t\tob_end_clean();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( isset( $_POST['delete_widget'] ) && $_POST['delete_widget'] ) {\n\t\t$sidebars[ $sidebar_id ] = $sidebar;\n\t\twp_set_sidebars_widgets( $sidebars );\n\t\techo \"deleted:$widget_id\";\n\t\twp_die();\n\t}\n\n\tif ( ! empty( $_POST['add_new'] ) ) {\n\t\twp_die();\n\t}\n\n\tif ( $form = $wp_registered_widget_controls[ $widget_id ] ) {\n\t\tcall_user_func_array( $form['callback'], $form['params'] );\n\t}\n\n\twp_die();\n}\n\n/**\n * Ajax handler for saving a widget.\n *\n * @since 3.9.0\n *\n * @global WP_Customize_Manager $wp_customize\n */\nfunction wp_ajax_update_widget() {\n\tglobal $wp_customize;\n\t$wp_customize->widgets->wp_ajax_update_widget();\n}\n\n/**\n * Ajax handler for removing inactive widgets.\n *\n * @since 4.4.0\n */\nfunction wp_ajax_delete_inactive_widgets() {\n\tcheck_ajax_referer( 'remove-inactive-widgets', 'removeinactivewidgets' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tunset( $_POST['removeinactivewidgets'], $_POST['action'] );\n\t/** This action is documented in wp-admin/includes/ajax-actions.php */\n\tdo_action( 'load-widgets.php' );\n\t/** This action is documented in wp-admin/includes/ajax-actions.php */\n\tdo_action( 'widgets.php' );\n\t/** This action is documented in wp-admin/widgets.php */\n\tdo_action( 'sidebar_admin_setup' );\n\n\t$sidebars_widgets = wp_get_sidebars_widgets();\n\n\tforeach ( $sidebars_widgets['wp_inactive_widgets'] as $key => $widget_id ) {\n\t\t$pieces       = explode( '-', $widget_id );\n\t\t$multi_number = array_pop( $pieces );\n\t\t$id_base      = implode( '-', $pieces );\n\t\t$widget       = get_option( 'widget_' . $id_base );\n\t\tunset( $widget[ $multi_number ] );\n\t\tupdate_option( 'widget_' . $id_base, $widget );\n\t\tunset( $sidebars_widgets['wp_inactive_widgets'][ $key ] );\n\t}\n\n\twp_set_sidebars_widgets( $sidebars_widgets );\n\n\twp_die();\n}\n\n/**\n * Ajax handler for uploading attachments\n *\n * @since 3.3.0\n */\nfunction wp_ajax_upload_attachment() {\n\tcheck_ajax_referer( 'media-form' );\n\t/*\n\t * This function does not use wp_send_json_success() / wp_send_json_error()\n\t * as the html4 Plupload handler requires a text/html content-type for older IE.\n\t * See https://core.trac.wordpress.org/ticket/31037\n\t */\n\n\tif ( ! current_user_can( 'upload_files' ) ) {\n\t\techo wp_json_encode(\n\t\t\tarray(\n\t\t\t\t'success' => false,\n\t\t\t\t'data'    => array(\n\t\t\t\t\t'message'  => __( 'Sorry, you are not allowed to upload files.' ),\n\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\n\t\twp_die();\n\t}\n\n\tif ( isset( $_REQUEST['post_id'] ) ) {\n\t\t$post_id = $_REQUEST['post_id'];\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\t\techo wp_json_encode(\n\t\t\t\tarray(\n\t\t\t\t\t'success' => false,\n\t\t\t\t\t'data'    => array(\n\t\t\t\t\t\t'message'  => __( 'Sorry, you are not allowed to attach files to this post.' ),\n\t\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t);\n\n\t\t\twp_die();\n\t\t}\n\t} else {\n\t\t$post_id = null;\n\t}\n\n\t$post_data = ! empty( $_REQUEST['post_data'] ) ? _wp_get_allowed_postdata( _wp_translate_postdata( false, (array) $_REQUEST['post_data'] ) ) : array();\n\n\tif ( is_wp_error( $post_data ) ) {\n\t\twp_die( $post_data->get_error_message() );\n\t}\n\n\t// If the context is custom header or background, make sure the uploaded file is an image.\n\tif ( isset( $post_data['context'] ) && in_array( $post_data['context'], array( 'custom-header', 'custom-background' ) ) ) {\n\t\t$wp_filetype = wp_check_filetype_and_ext( $_FILES['async-upload']['tmp_name'], $_FILES['async-upload']['name'] );\n\t\tif ( ! wp_match_mime_types( 'image', $wp_filetype['type'] ) ) {\n\t\t\techo wp_json_encode(\n\t\t\t\tarray(\n\t\t\t\t\t'success' => false,\n\t\t\t\t\t'data'    => array(\n\t\t\t\t\t\t'message'  => __( 'The uploaded file is not a valid image. Please try again.' ),\n\t\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t);\n\n\t\t\twp_die();\n\t\t}\n\t}\n\n\t$attachment_id = media_handle_upload( 'async-upload', $post_id, $post_data );\n\n\tif ( is_wp_error( $attachment_id ) ) {\n\t\techo wp_json_encode(\n\t\t\tarray(\n\t\t\t\t'success' => false,\n\t\t\t\t'data'    => array(\n\t\t\t\t\t'message'  => $attachment_id->get_error_message(),\n\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\n\t\twp_die();\n\t}\n\n\tif ( isset( $post_data['context'] ) && isset( $post_data['theme'] ) ) {\n\t\tif ( 'custom-background' === $post_data['context'] ) {\n\t\t\tupdate_post_meta( $attachment_id, '_wp_attachment_is_custom_background', $post_data['theme'] );\n\t\t}\n\n\t\tif ( 'custom-header' === $post_data['context'] ) {\n\t\t\tupdate_post_meta( $attachment_id, '_wp_attachment_is_custom_header', $post_data['theme'] );\n\t\t}\n\t}\n\n\tif ( ! $attachment = wp_prepare_attachment_for_js( $attachment_id ) ) {\n\t\twp_die();\n\t}\n\n\techo wp_json_encode(\n\t\tarray(\n\t\t\t'success' => true,\n\t\t\t'data'    => $attachment,\n\t\t)\n\t);\n\n\twp_die();\n}\n\n/**\n * Ajax handler for image editing.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_image_editor() {\n\t$attachment_id = intval( $_POST['postid'] );\n\tif ( empty( $attachment_id ) || ! current_user_can( 'edit_post', $attachment_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tcheck_ajax_referer( \"image_editor-$attachment_id\" );\n\tinclude_once( ABSPATH . 'wp-admin/includes/image-edit.php' );\n\n\t$msg = false;\n\tswitch ( $_POST['do'] ) {\n\t\tcase 'save':\n\t\t\t$msg = wp_save_image( $attachment_id );\n\t\t\t$msg = wp_json_encode( $msg );\n\t\t\twp_die( $msg );\n\t\t\tbreak;\n\t\tcase 'scale':\n\t\t\t$msg = wp_save_image( $attachment_id );\n\t\t\tbreak;\n\t\tcase 'restore':\n\t\t\t$msg = wp_restore_image( $attachment_id );\n\t\t\tbreak;\n\t}\n\n\twp_image_editor( $attachment_id, $msg );\n\twp_die();\n}\n\n/**\n * Ajax handler for setting the featured image.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_set_post_thumbnail() {\n\t$json = ! empty( $_REQUEST['json'] ); // New-style request\n\n\t$post_ID = intval( $_POST['post_id'] );\n\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$thumbnail_id = intval( $_POST['thumbnail_id'] );\n\n\tif ( $json ) {\n\t\tcheck_ajax_referer( \"update-post_$post_ID\" );\n\t} else {\n\t\tcheck_ajax_referer( \"set_post_thumbnail-$post_ID\" );\n\t}\n\n\tif ( $thumbnail_id == '-1' ) {\n\t\tif ( delete_post_thumbnail( $post_ID ) ) {\n\t\t\t$return = _wp_post_thumbnail_html( null, $post_ID );\n\t\t\t$json ? wp_send_json_success( $return ) : wp_die( $return );\n\t\t} else {\n\t\t\twp_die( 0 );\n\t\t}\n\t}\n\n\tif ( set_post_thumbnail( $post_ID, $thumbnail_id ) ) {\n\t\t$return = _wp_post_thumbnail_html( $thumbnail_id, $post_ID );\n\t\t$json ? wp_send_json_success( $return ) : wp_die( $return );\n\t}\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for retrieving HTML for the featured image.\n *\n * @since 4.6.0\n */\nfunction wp_ajax_get_post_thumbnail_html() {\n\t$post_ID = intval( $_POST['post_id'] );\n\n\tcheck_ajax_referer( \"update-post_$post_ID\" );\n\n\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$thumbnail_id = intval( $_POST['thumbnail_id'] );\n\n\t// For backward compatibility, -1 refers to no featured image.\n\tif ( -1 === $thumbnail_id ) {\n\t\t$thumbnail_id = null;\n\t}\n\n\t$return = _wp_post_thumbnail_html( $thumbnail_id, $post_ID );\n\twp_send_json_success( $return );\n}\n\n/**\n * Ajax handler for setting the featured image for an attachment.\n *\n * @since 4.0.0\n *\n * @see set_post_thumbnail()\n */\nfunction wp_ajax_set_attachment_thumbnail() {\n\tif ( empty( $_POST['urls'] ) || ! is_array( $_POST['urls'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$thumbnail_id = (int) $_POST['thumbnail_id'];\n\tif ( empty( $thumbnail_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$post_ids = array();\n\t// For each URL, try to find its corresponding post ID.\n\tforeach ( $_POST['urls'] as $url ) {\n\t\t$post_id = attachment_url_to_postid( $url );\n\t\tif ( ! empty( $post_id ) ) {\n\t\t\t$post_ids[] = $post_id;\n\t\t}\n\t}\n\n\tif ( empty( $post_ids ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$success = 0;\n\t// For each found attachment, set its thumbnail.\n\tforeach ( $post_ids as $post_id ) {\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( set_post_thumbnail( $post_id, $thumbnail_id ) ) {\n\t\t\t$success++;\n\t\t}\n\t}\n\n\tif ( 0 === $success ) {\n\t\twp_send_json_error();\n\t} else {\n\t\twp_send_json_success();\n\t}\n\n\twp_send_json_error();\n}\n\n/**\n * Ajax handler for date formatting.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_date_format() {\n\twp_die( date_i18n( sanitize_option( 'date_format', wp_unslash( $_POST['date'] ) ) ) );\n}\n\n/**\n * Ajax handler for time formatting.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_time_format() {\n\twp_die( date_i18n( sanitize_option( 'time_format', wp_unslash( $_POST['date'] ) ) ) );\n}\n\n/**\n * Ajax handler for saving posts from the fullscreen editor.\n *\n * @since 3.1.0\n * @deprecated 4.3.0\n */\nfunction wp_ajax_wp_fullscreen_save_post() {\n\t$post_id = isset( $_POST['post_ID'] ) ? (int) $_POST['post_ID'] : 0;\n\n\t$post = null;\n\n\tif ( $post_id ) {\n\t\t$post = get_post( $post_id );\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $post_id, '_wpnonce' );\n\n\t$post_id = edit_post();\n\n\tif ( is_wp_error( $post_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( $post ) {\n\t\t$last_date = mysql2date( __( 'F j, Y' ), $post->post_modified );\n\t\t$last_time = mysql2date( __( 'g:i a' ), $post->post_modified );\n\t} else {\n\t\t$last_date = date_i18n( __( 'F j, Y' ) );\n\t\t$last_time = date_i18n( __( 'g:i a' ) );\n\t}\n\n\tif ( $last_id = get_post_meta( $post_id, '_edit_last', true ) ) {\n\t\t$last_user = get_userdata( $last_id );\n\t\t/* translators: 1: display_name of last user, 2: date of last edit, 3: time of last edit. */\n\t\t$last_edited = sprintf( __( 'Last edited by %1$s on %2$s at %3$s' ), esc_html( $last_user->display_name ), $last_date, $last_time );\n\t} else {\n\t\t/* translators: 1: date of last edit, 2: time of last edit. */\n\t\t$last_edited = sprintf( __( 'Last edited on %1$s at %2$s' ), $last_date, $last_time );\n\t}\n\n\twp_send_json_success( array( 'last_edited' => $last_edited ) );\n}\n\n/**\n * Ajax handler for removing a post lock.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_wp_remove_post_lock() {\n\tif ( empty( $_POST['post_ID'] ) || empty( $_POST['active_post_lock'] ) ) {\n\t\twp_die( 0 );\n\t}\n\t$post_id = (int) $_POST['post_ID'];\n\tif ( ! $post = get_post( $post_id ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $post_id );\n\n\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$active_lock = array_map( 'absint', explode( ':', $_POST['active_post_lock'] ) );\n\tif ( $active_lock[1] != get_current_user_id() ) {\n\t\twp_die( 0 );\n\t}\n\n\t/**\n\t * Filters the post lock window duration.\n\t *\n\t * @since 3.3.0\n\t *\n\t * @param int $interval The interval in seconds the post lock duration\n\t *                      should last, plus 5 seconds. Default 150.\n\t */\n\t$new_lock = ( time() - apply_filters( 'wp_check_post_lock_window', 150 ) + 5 ) . ':' . $active_lock[1];\n\tupdate_post_meta( $post_id, '_edit_lock', $new_lock, implode( ':', $active_lock ) );\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for dismissing a WordPress pointer.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_dismiss_wp_pointer() {\n\t$pointer = $_POST['pointer'];\n\tif ( $pointer != sanitize_key( $pointer ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t//  check_ajax_referer( 'dismiss-pointer_' . $pointer );\n\n\t$dismissed = array_filter( explode( ',', (string) get_user_meta( get_current_user_id(), 'dismissed_wp_pointers', true ) ) );\n\n\tif ( in_array( $pointer, $dismissed ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$dismissed[] = $pointer;\n\t$dismissed   = implode( ',', $dismissed );\n\n\tupdate_user_meta( get_current_user_id(), 'dismissed_wp_pointers', $dismissed );\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for getting an attachment.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_get_attachment() {\n\tif ( ! isset( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $id = absint( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $post = get_post( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( 'attachment' != $post->post_type ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! current_user_can( 'upload_files' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $attachment = wp_prepare_attachment_for_js( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\twp_send_json_success( $attachment );\n}\n\n/**\n * Ajax handler for querying attachments.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_query_attachments() {\n\tif ( ! current_user_can( 'upload_files' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$query = isset( $_REQUEST['query'] ) ? (array) $_REQUEST['query'] : array();\n\t$keys  = array(\n\t\t's',\n\t\t'order',\n\t\t'orderby',\n\t\t'posts_per_page',\n\t\t'paged',\n\t\t'post_mime_type',\n\t\t'post_parent',\n\t\t'author',\n\t\t'post__in',\n\t\t'post__not_in',\n\t\t'year',\n\t\t'monthnum',\n\t);\n\tforeach ( get_taxonomies_for_attachments( 'objects' ) as $t ) {\n\t\tif ( $t->query_var && isset( $query[ $t->query_var ] ) ) {\n\t\t\t$keys[] = $t->query_var;\n\t\t}\n\t}\n\n\t$query              = array_intersect_key( $query, array_flip( $keys ) );\n\t$query['post_type'] = 'attachment';\n\tif ( MEDIA_TRASH\n\t\t&& ! empty( $_REQUEST['query']['post_status'] )\n\t\t&& 'trash' === $_REQUEST['query']['post_status'] ) {\n\t\t$query['post_status'] = 'trash';\n\t} else {\n\t\t$query['post_status'] = 'inherit';\n\t}\n\n\tif ( current_user_can( get_post_type_object( 'attachment' )->cap->read_private_posts ) ) {\n\t\t$query['post_status'] .= ',private';\n\t}\n\n\t// Filter query clauses to include filenames.\n\tif ( isset( $query['s'] ) ) {\n\t\tadd_filter( 'posts_clauses', '_filter_query_attachment_filenames' );\n\t}\n\n\t/**\n\t * Filters the arguments passed to WP_Query during an Ajax\n\t * call for querying attachments.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @see WP_Query::parse_query()\n\t *\n\t * @param array $query An array of query variables.\n\t */\n\t$query = apply_filters( 'ajax_query_attachments_args', $query );\n\t$query = new WP_Query( $query );\n\n\t$posts = array_map( 'wp_prepare_attachment_for_js', $query->posts );\n\t$posts = array_filter( $posts );\n\n\twp_send_json_success( $posts );\n}\n\n/**\n * Ajax handler for updating attachment attributes.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_save_attachment() {\n\tif ( ! isset( $_REQUEST['id'] ) || ! isset( $_REQUEST['changes'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $id = absint( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $id, 'nonce' );\n\n\tif ( ! current_user_can( 'edit_post', $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$changes = $_REQUEST['changes'];\n\t$post    = get_post( $id, ARRAY_A );\n\n\tif ( 'attachment' != $post['post_type'] ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( isset( $changes['parent'] ) ) {\n\t\t$post['post_parent'] = $changes['parent'];\n\t}\n\n\tif ( isset( $changes['title'] ) ) {\n\t\t$post['post_title'] = $changes['title'];\n\t}\n\n\tif ( isset( $changes['caption'] ) ) {\n\t\t$post['post_excerpt'] = $changes['caption'];\n\t}\n\n\tif ( isset( $changes['description'] ) ) {\n\t\t$post['post_content'] = $changes['description'];\n\t}\n\n\tif ( MEDIA_TRASH && isset( $changes['status'] ) ) {\n\t\t$post['post_status'] = $changes['status'];\n\t}\n\n\tif ( isset( $changes['alt'] ) ) {\n\t\t$alt = wp_unslash( $changes['alt'] );\n\t\tif ( $alt != get_post_meta( $id, '_wp_attachment_image_alt', true ) ) {\n\t\t\t$alt = wp_strip_all_tags( $alt, true );\n\t\t\tupdate_post_meta( $id, '_wp_attachment_image_alt', wp_slash( $alt ) );\n\t\t}\n\t}\n\n\tif ( wp_attachment_is( 'audio', $post['ID'] ) ) {\n\t\t$changed = false;\n\t\t$id3data = wp_get_attachment_metadata( $post['ID'] );\n\t\tif ( ! is_array( $id3data ) ) {\n\t\t\t$changed = true;\n\t\t\t$id3data = array();\n\t\t}\n\t\tforeach ( wp_get_attachment_id3_keys( (object) $post, 'edit' ) as $key => $label ) {\n\t\t\tif ( isset( $changes[ $key ] ) ) {\n\t\t\t\t$changed         = true;\n\t\t\t\t$id3data[ $key ] = sanitize_text_field( wp_unslash( $changes[ $key ] ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( $changed ) {\n\t\t\twp_update_attachment_metadata( $id, $id3data );\n\t\t}\n\t}\n\n\tif ( MEDIA_TRASH && isset( $changes['status'] ) && 'trash' === $changes['status'] ) {\n\t\twp_delete_post( $id );\n\t} else {\n\t\twp_update_post( $post );\n\t}\n\n\twp_send_json_success();\n}\n\n/**\n * Ajax handler for saving backward compatible attachment attributes.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_save_attachment_compat() {\n\tif ( ! isset( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $id = absint( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( empty( $_REQUEST['attachments'] ) || empty( $_REQUEST['attachments'][ $id ] ) ) {\n\t\twp_send_json_error();\n\t}\n\t$attachment_data = $_REQUEST['attachments'][ $id ];\n\n\tcheck_ajax_referer( 'update-post_' . $id, 'nonce' );\n\n\tif ( ! current_user_can( 'edit_post', $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$post = get_post( $id, ARRAY_A );\n\n\tif ( 'attachment' != $post['post_type'] ) {\n\t\twp_send_json_error();\n\t}\n\n\t/** This filter is documented in wp-admin/includes/media.php */\n\t$post = apply_filters( 'attachment_fields_to_save', $post, $attachment_data );\n\n\tif ( isset( $post['errors'] ) ) {\n\t\t$errors = $post['errors']; // @todo return me and display me!\n\t\tunset( $post['errors'] );\n\t}\n\n\twp_update_post( $post );\n\n\tforeach ( get_attachment_taxonomies( $post ) as $taxonomy ) {\n\t\tif ( isset( $attachment_data[ $taxonomy ] ) ) {\n\t\t\twp_set_object_terms( $id, array_map( 'trim', preg_split( '/,+/', $attachment_data[ $taxonomy ] ) ), $taxonomy, false );\n\t\t}\n\t}\n\n\tif ( ! $attachment = wp_prepare_attachment_for_js( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\twp_send_json_success( $attachment );\n}\n\n/**\n * Ajax handler for saving the attachment order.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_save_attachment_order() {\n\tif ( ! isset( $_REQUEST['post_id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $post_id = absint( $_REQUEST['post_id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( empty( $_REQUEST['attachments'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $post_id, 'nonce' );\n\n\t$attachments = $_REQUEST['attachments'];\n\n\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tforeach ( $attachments as $attachment_id => $menu_order ) {\n\t\tif ( ! current_user_can( 'edit_post', $attachment_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( ! $attachment = get_post( $attachment_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( 'attachment' != $attachment->post_type ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\twp_update_post(\n\t\t\tarray(\n\t\t\t\t'ID'         => $attachment_id,\n\t\t\t\t'menu_order' => $menu_order,\n\t\t\t)\n\t\t);\n\t}\n\n\twp_send_json_success();\n}\n\n/**\n * Ajax handler for sending an attachment to the editor.\n *\n * Generates the HTML to send an attachment to the editor.\n * Backward compatible with the {@see 'media_send_to_editor'} filter\n * and the chain of filters that follow.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_send_attachment_to_editor() {\n\tcheck_ajax_referer( 'media-send-to-editor', 'nonce' );\n\n\t$attachment = wp_unslash( $_POST['attachment'] );\n\n\t$id = intval( $attachment['id'] );\n\n\tif ( ! $post = get_post( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( 'attachment' != $post->post_type ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( current_user_can( 'edit_post', $id ) ) {\n\t\t// If this attachment is unattached, attach it. Primarily a back compat thing.\n\t\tif ( 0 == $post->post_parent && $insert_into_post_id = intval( $_POST['post_id'] ) ) {\n\t\t\twp_update_post(\n\t\t\t\tarray(\n\t\t\t\t\t'ID'          => $id,\n\t\t\t\t\t'post_parent' => $insert_into_post_id,\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t$url = empty( $attachment['url'] ) ? '' : $attachment['url'];\n\t$rel = ( strpos( $url, 'attachment_id' ) || get_attachment_link( $id ) == $url );\n\n\tremove_filter( 'media_send_to_editor', 'image_media_send_to_editor' );\n\n\tif ( 'image' === substr( $post->post_mime_type, 0, 5 ) ) {\n\t\t$align = isset( $attachment['align'] ) ? $attachment['align'] : 'none';\n\t\t$size  = isset( $attachment['image-size'] ) ? $attachment['image-size'] : 'medium';\n\t\t$alt   = isset( $attachment['image_alt'] ) ? $attachment['image_alt'] : '';\n\n\t\t// No whitespace-only captions.\n\t\t$caption = isset( $attachment['post_excerpt'] ) ? $attachment['post_excerpt'] : '';\n\t\tif ( '' === trim( $caption ) ) {\n\t\t\t$caption = '';\n\t\t}\n\n\t\t$title = ''; // We no longer insert title tags into <img> tags, as they are redundant.\n\t\t$html  = get_image_send_to_editor( $id, $caption, $title, $align, $url, $rel, $size, $alt );\n\t} elseif ( wp_attachment_is( 'video', $post ) || wp_attachment_is( 'audio', $post ) ) {\n\t\t$html = stripslashes_deep( $_POST['html'] );\n\t} else {\n\t\t$html = isset( $attachment['post_title'] ) ? $attachment['post_title'] : '';\n\t\t$rel  = $rel ? ' rel=\"attachment wp-att-' . $id . '\"' : ''; // Hard-coded string, $id is already sanitized\n\n\t\tif ( ! empty( $url ) ) {\n\t\t\t$html = '<a href=\"' . esc_url( $url ) . '\"' . $rel . '>' . $html . '</a>';\n\t\t}\n\t}\n\n\t/** This filter is documented in wp-admin/includes/media.php */\n\t$html = apply_filters( 'media_send_to_editor', $html, $id, $attachment );\n\n\twp_send_json_success( $html );\n}\n\n/**\n * Ajax handler for sending a link to the editor.\n *\n * Generates the HTML to send a non-image embed link to the editor.\n *\n * Backward compatible with the following filters:\n * - file_send_to_editor_url\n * - audio_send_to_editor_url\n * - video_send_to_editor_url\n *\n * @since 3.5.0\n *\n * @global WP_Post  $post\n * @global WP_Embed $wp_embed\n */\nfunction wp_ajax_send_link_to_editor() {\n\tglobal $post, $wp_embed;\n\n\tcheck_ajax_referer( 'media-send-to-editor', 'nonce' );\n\n\tif ( ! $src = wp_unslash( $_POST['src'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! strpos( $src, '://' ) ) {\n\t\t$src = 'http://' . $src;\n\t}\n\n\tif ( ! $src = esc_url_raw( $src ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $link_text = trim( wp_unslash( $_POST['link_text'] ) ) ) {\n\t\t$link_text = wp_basename( $src );\n\t}\n\n\t$post = get_post( isset( $_POST['post_id'] ) ? $_POST['post_id'] : 0 );\n\n\t// Ping WordPress for an embed.\n\t$check_embed = $wp_embed->run_shortcode( '[embed]' . $src . '[/embed]' );\n\n\t// Fallback that WordPress creates when no oEmbed was found.\n\t$fallback = $wp_embed->maybe_make_link( $src );\n\n\tif ( $check_embed !== $fallback ) {\n\t\t// TinyMCE view for [embed] will parse this\n\t\t$html = '[embed]' . $src . '[/embed]';\n\t} elseif ( $link_text ) {\n\t\t$html = '<a href=\"' . esc_url( $src ) . '\">' . $link_text . '</a>';\n\t} else {\n\t\t$html = '';\n\t}\n\n\t// Figure out what filter to run:\n\t$type = 'file';\n\tif ( ( $ext = preg_replace( '/^.+?\\.([^.]+)$/', '$1', $src ) ) && ( $ext_type = wp_ext2type( $ext ) )\n\t\t&& ( 'audio' == $ext_type || 'video' == $ext_type ) ) {\n\t\t\t$type = $ext_type;\n\t}\n\n\t/** This filter is documented in wp-admin/includes/media.php */\n\t$html = apply_filters( \"{$type}_send_to_editor_url\", $html, $src, $link_text );\n\n\twp_send_json_success( $html );\n}\n\n/**\n * Ajax handler for the Heartbeat API.\n *\n * Runs when the user is logged in.\n *\n * @since 3.6.0\n */\nfunction wp_ajax_heartbeat() {\n\tif ( empty( $_POST['_nonce'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$response    = $data = array();\n\t$nonce_state = wp_verify_nonce( $_POST['_nonce'], 'heartbeat-nonce' );\n\n\t// screen_id is the same as $current_screen->id and the JS global 'pagenow'.\n\tif ( ! empty( $_POST['screen_id'] ) ) {\n\t\t$screen_id = sanitize_key( $_POST['screen_id'] );\n\t} else {\n\t\t$screen_id = 'front';\n\t}\n\n\tif ( ! empty( $_POST['data'] ) ) {\n\t\t$data = wp_unslash( (array) $_POST['data'] );\n\t}\n\n\tif ( 1 !== $nonce_state ) {\n\t\t/**\n\t\t * Filters the nonces to send to the New/Edit Post screen.\n\t\t *\n\t\t * @since 4.3.0\n\t\t *\n\t\t * @param array  $response  The Heartbeat response.\n\t\t * @param array  $data      The $_POST data sent.\n\t\t * @param string $screen_id The screen id.\n\t\t */\n\t\t$response = apply_filters( 'wp_refresh_nonces', $response, $data, $screen_id );\n\n\t\tif ( false === $nonce_state ) {\n\t\t\t// User is logged in but nonces have expired.\n\t\t\t$response['nonces_expired'] = true;\n\t\t\twp_send_json( $response );\n\t\t}\n\t}\n\n\tif ( ! empty( $data ) ) {\n\t\t/**\n\t\t * Filters the Heartbeat response received.\n\t\t *\n\t\t * @since 3.6.0\n\t\t *\n\t\t * @param array  $response  The Heartbeat response.\n\t\t * @param array  $data      The $_POST data sent.\n\t\t * @param string $screen_id The screen id.\n\t\t */\n\t\t$response = apply_filters( 'heartbeat_received', $response, $data, $screen_id );\n\t}\n\n\t/**\n\t * Filters the Heartbeat response sent.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\t$response = apply_filters( 'heartbeat_send', $response, $screen_id );\n\n\t/**\n\t * Fires when Heartbeat ticks in logged-in environments.\n\t *\n\t * Allows the transport to be easily replaced with long-polling.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\tdo_action( 'heartbeat_tick', $response, $screen_id );\n\n\t// Send the current time according to the server\n\t$response['server_time'] = time();\n\n\twp_send_json( $response );\n}\n\n/**\n * Ajax handler for getting revision diffs.\n *\n * @since 3.6.0\n */\nfunction wp_ajax_get_revision_diffs() {\n\trequire ABSPATH . 'wp-admin/includes/revision.php';\n\n\tif ( ! $post = get_post( (int) $_REQUEST['post_id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! current_user_can( 'edit_post', $post->ID ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t// Really just pre-loading the cache here.\n\tif ( ! $revisions = wp_get_post_revisions( $post->ID, array( 'check_enabled' => false ) ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$return = array();\n\t@set_time_limit( 0 );\n\n\tforeach ( $_REQUEST['compare'] as $compare_key ) {\n\t\tlist( $compare_from, $compare_to ) = explode( ':', $compare_key ); // from:to\n\n\t\t$return[] = array(\n\t\t\t'id'     => $compare_key,\n\t\t\t'fields' => wp_get_revision_ui_diff( $post, $compare_from, $compare_to ),\n\t\t);\n\t}\n\twp_send_json_success( $return );\n}\n\n/**\n * Ajax handler for auto-saving the selected color scheme for\n * a user's own profile.\n *\n * @since 3.8.0\n *\n * @global array $_wp_admin_css_colors\n */\nfunction wp_ajax_save_user_color_scheme() {\n\tglobal $_wp_admin_css_colors;\n\n\tcheck_ajax_referer( 'save-color-scheme', 'nonce' );\n\n\t$color_scheme = sanitize_key( $_POST['color_scheme'] );\n\n\tif ( ! isset( $_wp_admin_css_colors[ $color_scheme ] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$previous_color_scheme = get_user_meta( get_current_user_id(), 'admin_color', true );\n\tupdate_user_meta( get_current_user_id(), 'admin_color', $color_scheme );\n\n\twp_send_json_success(\n\t\tarray(\n\t\t\t'previousScheme' => 'admin-color-' . $previous_color_scheme,\n\t\t\t'currentScheme'  => 'admin-color-' . $color_scheme,\n\t\t)\n\t);\n}\n\n/**\n * Ajax handler for getting themes from themes_api().\n *\n * @since 3.9.0\n *\n * @global array $themes_allowedtags\n * @global array $theme_field_defaults\n */\nfunction wp_ajax_query_themes() {\n\tglobal $themes_allowedtags, $theme_field_defaults;\n\n\tif ( ! current_user_can( 'install_themes' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$args = wp_parse_args(\n\t\twp_unslash( $_REQUEST['request'] ),\n\t\tarray(\n\t\t\t'per_page' => 20,\n\t\t\t'fields'   => $theme_field_defaults,\n\t\t)\n\t);\n\n\tif ( isset( $args['browse'] ) && 'favorites' === $args['browse'] && ! isset( $args['user'] ) ) {\n\t\t$user = get_user_option( 'wporg_favorites' );\n\t\tif ( $user ) {\n\t\t\t$args['user'] = $user;\n\t\t}\n\t}\n\n\t$old_filter = isset( $args['browse'] ) ? $args['browse'] : 'search';\n\n\t/** This filter is documented in wp-admin/includes/class-wp-theme-install-list-table.php */\n\t$args = apply_filters( 'install_themes_table_api_args_' . $old_filter, $args );\n\n\t$api = themes_api( 'query_themes', $args );\n\n\tif ( is_wp_error( $api ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$update_php = network_admin_url( 'update.php?action=install-theme' );\n\tforeach ( $api->themes as &$theme ) {\n\t\t$theme->install_url = add_query_arg(\n\t\t\tarray(\n\t\t\t\t'theme'    => $theme->slug,\n\t\t\t\t'_wpnonce' => wp_create_nonce( 'install-theme_' . $theme->slug ),\n\t\t\t),\n\t\t\t$update_php\n\t\t);\n\n\t\tif ( current_user_can( 'switch_themes' ) ) {\n\t\t\tif ( is_multisite() ) {\n\t\t\t\t$theme->activate_url = add_query_arg(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'action'   => 'enable',\n\t\t\t\t\t\t'_wpnonce' => wp_create_nonce( 'enable-theme_' . $theme->slug ),\n\t\t\t\t\t\t'theme'    => $theme->slug,\n\t\t\t\t\t),\n\t\t\t\t\tnetwork_admin_url( 'themes.php' )\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t$theme->activate_url = add_query_arg(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'action'     => 'activate',\n\t\t\t\t\t\t'_wpnonce'   => wp_create_nonce( 'switch-theme_' . $theme->slug ),\n\t\t\t\t\t\t'stylesheet' => $theme->slug,\n\t\t\t\t\t),\n\t\t\t\t\tadmin_url( 'themes.php' )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif ( ! is_multisite() && current_user_can( 'edit_theme_options' ) && current_user_can( 'customize' ) ) {\n\t\t\t$theme->customize_url = add_query_arg(\n\t\t\t\tarray(\n\t\t\t\t\t'return' => urlencode( network_admin_url( 'theme-install.php', 'relative' ) ),\n\t\t\t\t),\n\t\t\t\twp_customize_url( $theme->slug )\n\t\t\t);\n\t\t}\n\n\t\t$theme->name        = wp_kses( $theme->name, $themes_allowedtags );\n\t\t$theme->author      = wp_kses( $theme->author['display_name'], $themes_allowedtags );\n\t\t$theme->version     = wp_kses( $theme->version, $themes_allowedtags );\n\t\t$theme->description = wp_kses( $theme->description, $themes_allowedtags );\n\t\t$theme->stars       = wp_star_rating(\n\t\t\tarray(\n\t\t\t\t'rating' => $theme->rating,\n\t\t\t\t'type'   => 'percent',\n\t\t\t\t'number' => $theme->num_ratings,\n\t\t\t\t'echo'   => false,\n\t\t\t)\n\t\t);\n\t\t$theme->num_ratings = number_format_i18n( $theme->num_ratings );\n\t\t$theme->preview_url = set_url_scheme( $theme->preview_url );\n\t}\n\n\twp_send_json_success( $api );\n}\n\n/**\n * Apply [embed] Ajax handlers to a string.\n *\n * @since 4.0.0\n *\n * @global WP_Post    $post       Global $post.\n * @global WP_Embed   $wp_embed   Embed API instance.\n * @global WP_Scripts $wp_scripts\n * @global int        $content_width\n */\nfunction wp_ajax_parse_embed() {\n\tglobal $post, $wp_embed, $content_width;\n\n\tif ( empty( $_POST['shortcode'] ) ) {\n\t\twp_send_json_error();\n\t}\n\t$post_id = isset( $_POST['post_ID'] ) ? intval( $_POST['post_ID'] ) : 0;\n\tif ( $post_id > 0 ) {\n\t\t$post = get_post( $post_id );\n\t\tif ( ! $post || ! current_user_can( 'edit_post', $post->ID ) ) {\n\t\t\twp_send_json_error();\n\t\t}\n\t\tsetup_postdata( $post );\n\t} elseif ( ! current_user_can( 'edit_posts' ) ) { // See WP_oEmbed_Controller::get_proxy_item_permissions_check().\n\t\twp_send_json_error();\n\t}\n\n\t$shortcode = wp_unslash( $_POST['shortcode'] );\n\n\tpreg_match( '/' . get_shortcode_regex() . '/s', $shortcode, $matches );\n\t$atts = shortcode_parse_atts( $matches[3] );\n\tif ( ! empty( $matches[5] ) ) {\n\t\t$url = $matches[5];\n\t} elseif ( ! empty( $atts['src'] ) ) {\n\t\t$url = $atts['src'];\n\t} else {\n\t\t$url = '';\n\t}\n\n\t$parsed                         = false;\n\t$wp_embed->return_false_on_fail = true;\n\n\tif ( 0 === $post_id ) {\n\t\t/*\n\t\t * Refresh oEmbeds cached outside of posts that are past their TTL.\n\t\t * Posts are excluded because they have separate logic for refreshing\n\t\t * their post meta caches. See WP_Embed::cache_oembed().\n\t\t */\n\t\t$wp_embed->usecache = false;\n\t}\n\n\tif ( is_ssl() && 0 === strpos( $url, 'http://' ) ) {\n\t\t// Admin is ssl and the user pasted non-ssl URL.\n\t\t// Check if the provider supports ssl embeds and use that for the preview.\n\t\t$ssl_shortcode = preg_replace( '%^(\\\\[embed[^\\\\]]*\\\\])http://%i', '$1https://', $shortcode );\n\t\t$parsed        = $wp_embed->run_shortcode( $ssl_shortcode );\n\n\t\tif ( ! $parsed ) {\n\t\t\t$no_ssl_support = true;\n\t\t}\n\t}\n\n\t// Set $content_width so any embeds fit in the destination iframe.\n\tif ( isset( $_POST['maxwidth'] ) && is_numeric( $_POST['maxwidth'] ) && $_POST['maxwidth'] > 0 ) {\n\t\tif ( ! isset( $content_width ) ) {\n\t\t\t$content_width = intval( $_POST['maxwidth'] );\n\t\t} else {\n\t\t\t$content_width = min( $content_width, intval( $_POST['maxwidth'] ) );\n\t\t}\n\t}\n\n\tif ( $url && ! $parsed ) {\n\t\t$parsed = $wp_embed->run_shortcode( $shortcode );\n\t}\n\n\tif ( ! $parsed ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'type'    => 'not-embeddable',\n\t\t\t\t/* translators: %s: URL which cannot be embedded, between code tags */\n\t\t\t\t'message' => sprintf( __( '%s failed to embed.' ), '<code>' . esc_html( $url ) . '</code>' ),\n\t\t\t)\n\t\t);\n\t}\n\n\tif ( has_shortcode( $parsed, 'audio' ) || has_shortcode( $parsed, 'video' ) ) {\n\t\t$styles     = '';\n\t\t$mce_styles = wpview_media_sandbox_styles();\n\t\tforeach ( $mce_styles as $style ) {\n\t\t\t$styles .= sprintf( '<link rel=\"stylesheet\" href=\"%s\"/>', $style );\n\t\t}\n\n\t\t$html = do_shortcode( $parsed );\n\n\t\tglobal $wp_scripts;\n\t\tif ( ! empty( $wp_scripts ) ) {\n\t\t\t$wp_scripts->done = array();\n\t\t}\n\t\tob_start();\n\t\twp_print_scripts( array( 'mediaelement-vimeo', 'wp-mediaelement' ) );\n\t\t$scripts = ob_get_clean();\n\n\t\t$parsed = $styles . $html . $scripts;\n\t}\n\n\tif ( ! empty( $no_ssl_support ) || ( is_ssl() && ( preg_match( '%<(iframe|script|embed) [^>]*src=\"http://%', $parsed ) ||\n\t\tpreg_match( '%<link [^>]*href=\"http://%', $parsed ) ) ) ) {\n\t\t// Admin is ssl and the embed is not. Iframes, scripts, and other \"active content\" will be blocked.\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'type'    => 'not-ssl',\n\t\t\t\t'message' => __( 'This preview is unavailable in the editor.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$return = array(\n\t\t'body' => $parsed,\n\t\t'attr' => $wp_embed->last_attr,\n\t);\n\n\tif ( strpos( $parsed, 'class=\"wp-embedded-content' ) ) {\n\t\tif ( defined( 'SCRIPT_DEBUG' ) && SCRIPT_DEBUG ) {\n\t\t\t$script_src = includes_url( 'js/wp-embed.js' );\n\t\t} else {\n\t\t\t$script_src = includes_url( 'js/wp-embed.min.js' );\n\t\t}\n\n\t\t$return['head']    = '<script src=\"' . $script_src . '\"></script>';\n\t\t$return['sandbox'] = true;\n\t}\n\n\twp_send_json_success( $return );\n}\n\n/**\n * @since 4.0.0\n *\n * @global WP_Post    $post\n * @global WP_Scripts $wp_scripts\n */\nfunction wp_ajax_parse_media_shortcode() {\n\tglobal $post, $wp_scripts;\n\n\tif ( empty( $_POST['shortcode'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$shortcode = wp_unslash( $_POST['shortcode'] );\n\n\tif ( ! empty( $_POST['post_ID'] ) ) {\n\t\t$post = get_post( (int) $_POST['post_ID'] );\n\t}\n\n\t// the embed shortcode requires a post\n\tif ( ! $post || ! current_user_can( 'edit_post', $post->ID ) ) {\n\t\tif ( 'embed' === $shortcode ) {\n\t\t\twp_send_json_error();\n\t\t}\n\t} else {\n\t\tsetup_postdata( $post );\n\t}\n\n\t$parsed = do_shortcode( $shortcode );\n\n\tif ( empty( $parsed ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'type'    => 'no-items',\n\t\t\t\t'message' => __( 'No items found.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$head   = '';\n\t$styles = wpview_media_sandbox_styles();\n\n\tforeach ( $styles as $style ) {\n\t\t$head .= '<link type=\"text/css\" rel=\"stylesheet\" href=\"' . $style . '\">';\n\t}\n\n\tif ( ! empty( $wp_scripts ) ) {\n\t\t$wp_scripts->done = array();\n\t}\n\n\tob_start();\n\n\techo $parsed;\n\n\tif ( 'playlist' === $_REQUEST['type'] ) {\n\t\twp_underscore_playlist_templates();\n\n\t\twp_print_scripts( 'wp-playlist' );\n\t} else {\n\t\twp_print_scripts( array( 'mediaelement-vimeo', 'wp-mediaelement' ) );\n\t}\n\n\twp_send_json_success(\n\t\tarray(\n\t\t\t'head' => $head,\n\t\t\t'body' => ob_get_clean(),\n\t\t)\n\t);\n}\n\n/**\n * Ajax handler for destroying multiple open sessions for a user.\n *\n * @since 4.1.0\n */\nfunction wp_ajax_destroy_sessions() {\n\t$user = get_userdata( (int) $_POST['user_id'] );\n\tif ( $user ) {\n\t\tif ( ! current_user_can( 'edit_user', $user->ID ) ) {\n\t\t\t$user = false;\n\t\t} elseif ( ! wp_verify_nonce( $_POST['nonce'], 'update-user_' . $user->ID ) ) {\n\t\t\t$user = false;\n\t\t}\n\t}\n\n\tif ( ! $user ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'message' => __( 'Could not log out user sessions. Please try again.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$sessions = WP_Session_Tokens::get_instance( $user->ID );\n\n\tif ( $user->ID === get_current_user_id() ) {\n\t\t$sessions->destroy_others( wp_get_session_token() );\n\t\t$message = __( 'You are now logged out everywhere else.' );\n\t} else {\n\t\t$sessions->destroy_all();\n\t\t/* translators: %s: User's display name. */\n\t\t$message = sprintf( __( '%s has been logged out.' ), $user->display_name );\n\t}\n\n\twp_send_json_success( array( 'message' => $message ) );\n}\n\n/**\n * Ajax handler for cropping an image.\n *\n * @since 4.3.0\n */\nfunction wp_ajax_crop_image() {\n\t$attachment_id = absint( $_POST['id'] );\n\n\tcheck_ajax_referer( 'image_editor-' . $attachment_id, 'nonce' );\n\tif ( empty( $attachment_id ) || ! current_user_can( 'edit_post', $attachment_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$context = str_replace( '_', '-', $_POST['context'] );\n\t$data    = array_map( 'absint', $_POST['cropDetails'] );\n\t$cropped = wp_crop_image( $attachment_id, $data['x1'], $data['y1'], $data['width'], $data['height'], $data['dst_width'], $data['dst_height'] );\n\n\tif ( ! $cropped || is_wp_error( $cropped ) ) {\n\t\twp_send_json_error( array( 'message' => __( 'Image could not be processed.' ) ) );\n\t}\n\n\tswitch ( $context ) {\n\t\tcase 'site-icon':\n\t\t\trequire_once ABSPATH . '/wp-admin/includes/class-wp-site-icon.php';\n\t\t\t$wp_site_icon = new WP_Site_Icon();\n\n\t\t\t// Skip creating a new attachment if the attachment is a Site Icon.\n\t\t\tif ( get_post_meta( $attachment_id, '_wp_attachment_context', true ) == $context ) {\n\n\t\t\t\t// Delete the temporary cropped file, we don't need it.\n\t\t\t\twp_delete_file( $cropped );\n\n\t\t\t\t// Additional sizes in wp_prepare_attachment_for_js().\n\t\t\t\tadd_filter( 'image_size_names_choose', array( $wp_site_icon, 'additional_sizes' ) );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/** This filter is documented in wp-admin/custom-header.php */\n\t\t\t$cropped = apply_filters( 'wp_create_file_in_uploads', $cropped, $attachment_id ); // For replication.\n\t\t\t$object  = $wp_site_icon->create_attachment_object( $cropped, $attachment_id );\n\t\t\tunset( $object['ID'] );\n\n\t\t\t// Update the attachment.\n\t\t\tadd_filter( 'intermediate_image_sizes_advanced', array( $wp_site_icon, 'additional_sizes' ) );\n\t\t\t$attachment_id = $wp_site_icon->insert_attachment( $object, $cropped );\n\t\t\tremove_filter( 'intermediate_image_sizes_advanced', array( $wp_site_icon, 'additional_sizes' ) );\n\n\t\t\t// Additional sizes in wp_prepare_attachment_for_js().\n\t\t\tadd_filter( 'image_size_names_choose', array( $wp_site_icon, 'additional_sizes' ) );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/**\n\t\t\t * Fires before a cropped image is saved.\n\t\t\t *\n\t\t\t * Allows to add filters to modify the way a cropped image is saved.\n\t\t\t *\n\t\t\t * @since 4.3.0\n\t\t\t *\n\t\t\t * @param string $context       The Customizer control requesting the cropped image.\n\t\t\t * @param int    $attachment_id The attachment ID of the original image.\n\t\t\t * @param string $cropped       Path to the cropped image file.\n\t\t\t */\n\t\t\tdo_action( 'wp_ajax_crop_image_pre_save', $context, $attachment_id, $cropped );\n\n\t\t\t/** This filter is documented in wp-admin/custom-header.php */\n\t\t\t$cropped = apply_filters( 'wp_create_file_in_uploads', $cropped, $attachment_id ); // For replication.\n\n\t\t\t$parent_url = wp_get_attachment_url( $attachment_id );\n\t\t\t$url        = str_replace( wp_basename( $parent_url ), wp_basename( $cropped ), $parent_url );\n\n\t\t\t$size       = @getimagesize( $cropped );\n\t\t\t$image_type = ( $size ) ? $size['mime'] : 'image/jpeg';\n\n\t\t\t$object = array(\n\t\t\t\t'post_title'     => wp_basename( $cropped ),\n\t\t\t\t'post_content'   => $url,\n\t\t\t\t'post_mime_type' => $image_type,\n\t\t\t\t'guid'           => $url,\n\t\t\t\t'context'        => $context,\n\t\t\t);\n\n\t\t\t$attachment_id = wp_insert_attachment( $object, $cropped );\n\t\t\t$metadata      = wp_generate_attachment_metadata( $attachment_id, $cropped );\n\n\t\t\t/**\n\t\t\t * Filters the cropped image attachment metadata.\n\t\t\t *\n\t\t\t * @since 4.3.0\n\t\t\t *\n\t\t\t * @see wp_generate_attachment_metadata()\n\t\t\t *\n\t\t\t * @param array $metadata Attachment metadata.\n\t\t\t */\n\t\t\t$metadata = apply_filters( 'wp_ajax_cropped_attachment_metadata', $metadata );\n\t\t\twp_update_attachment_metadata( $attachment_id, $metadata );\n\n\t\t\t/**\n\t\t\t * Filters the attachment ID for a cropped image.\n\t\t\t *\n\t\t\t * @since 4.3.0\n\t\t\t *\n\t\t\t * @param int    $attachment_id The attachment ID of the cropped image.\n\t\t\t * @param string $context       The Customizer control requesting the cropped image.\n\t\t\t */\n\t\t\t$attachment_id = apply_filters( 'wp_ajax_cropped_attachment_id', $attachment_id, $context );\n\t}\n\n\twp_send_json_success( wp_prepare_attachment_for_js( $attachment_id ) );\n}\n\n/**\n * Ajax handler for generating a password.\n *\n * @since 4.4.0\n */\nfunction wp_ajax_generate_password() {\n\twp_send_json_success( wp_generate_password( 24 ) );\n}\n\n/**\n * Ajax handler for saving the user's WordPress.org username.\n *\n * @since 4.4.0\n */\nfunction wp_ajax_save_wporg_username() {\n\tif ( ! current_user_can( 'install_themes' ) && ! current_user_can( 'install_plugins' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tcheck_ajax_referer( 'save_wporg_username_' . get_current_user_id() );\n\n\t$username = isset( $_REQUEST['username'] ) ? wp_unslash( $_REQUEST['username'] ) : false;\n\n\tif ( ! $username ) {\n\t\twp_send_json_error();\n\t}\n\n\twp_send_json_success( update_user_meta( get_current_user_id(), 'wporg_favorites', $username ) );\n}\n\n/**\n * Ajax handler for installing a theme.\n *\n * @since 4.6.0\n *\n * @see Theme_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_install_theme() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_theme_specified',\n\t\t\t\t'errorMessage' => __( 'No theme specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$slug = sanitize_key( wp_unslash( $_POST['slug'] ) );\n\n\t$status = array(\n\t\t'install' => 'theme',\n\t\t'slug'    => $slug,\n\t);\n\n\tif ( ! current_user_can( 'install_themes' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to install themes on this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\tinclude_once( ABSPATH . 'wp-admin/includes/theme.php' );\n\n\t$api = themes_api(\n\t\t'theme_information',\n\t\tarray(\n\t\t\t'slug'   => $slug,\n\t\t\t'fields' => array( 'sections' => false ),\n\t\t)\n\t);\n\n\tif ( is_wp_error( $api ) ) {\n\t\t$status['errorMessage'] = $api->get_error_message();\n\t\twp_send_json_error( $status );\n\t}\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Theme_Upgrader( $skin );\n\t$result   = $upgrader->install( $api->download_link );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorCode']    = $result->get_error_code();\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_null( $result ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t$status['themeName'] = wp_get_theme( $slug )->get( 'Name' );\n\n\tif ( current_user_can( 'switch_themes' ) ) {\n\t\tif ( is_multisite() ) {\n\t\t\t$status['activateUrl'] = add_query_arg(\n\t\t\t\tarray(\n\t\t\t\t\t'action'   => 'enable',\n\t\t\t\t\t'_wpnonce' => wp_create_nonce( 'enable-theme_' . $slug ),\n\t\t\t\t\t'theme'    => $slug,\n\t\t\t\t),\n\t\t\t\tnetwork_admin_url( 'themes.php' )\n\t\t\t);\n\t\t} else {\n\t\t\t$status['activateUrl'] = add_query_arg(\n\t\t\t\tarray(\n\t\t\t\t\t'action'     => 'activate',\n\t\t\t\t\t'_wpnonce'   => wp_create_nonce( 'switch-theme_' . $slug ),\n\t\t\t\t\t'stylesheet' => $slug,\n\t\t\t\t),\n\t\t\t\tadmin_url( 'themes.php' )\n\t\t\t);\n\t\t}\n\t}\n\n\tif ( ! is_multisite() && current_user_can( 'edit_theme_options' ) && current_user_can( 'customize' ) ) {\n\t\t$status['customizeUrl'] = add_query_arg(\n\t\t\tarray(\n\t\t\t\t'return' => urlencode( network_admin_url( 'theme-install.php', 'relative' ) ),\n\t\t\t),\n\t\t\twp_customize_url( $slug )\n\t\t);\n\t}\n\n\t/*\n\t * See WP_Theme_Install_List_Table::_get_theme_status() if we wanted to check\n\t * on post-installation status.\n\t */\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for updating a theme.\n *\n * @since 4.6.0\n *\n * @see Theme_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_update_theme() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_theme_specified',\n\t\t\t\t'errorMessage' => __( 'No theme specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$stylesheet = preg_replace( '/[^A-z0-9_\\-]/', '', wp_unslash( $_POST['slug'] ) );\n\t$status     = array(\n\t\t'update'     => 'theme',\n\t\t'slug'       => $stylesheet,\n\t\t'oldVersion' => '',\n\t\t'newVersion' => '',\n\t);\n\n\tif ( ! current_user_can( 'update_themes' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to update themes for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t$theme = wp_get_theme( $stylesheet );\n\tif ( $theme->exists() ) {\n\t\t$status['oldVersion'] = $theme->get( 'Version' );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\n\t$current = get_site_transient( 'update_themes' );\n\tif ( empty( $current ) ) {\n\t\twp_update_themes();\n\t}\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Theme_Upgrader( $skin );\n\t$result   = $upgrader->bulk_upgrade( array( $stylesheet ) );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_array( $result ) && ! empty( $result[ $stylesheet ] ) ) {\n\n\t\t// Theme is already at the latest version.\n\t\tif ( true === $result[ $stylesheet ] ) {\n\t\t\t$status['errorMessage'] = $upgrader->strings['up_to_date'];\n\t\t\twp_send_json_error( $status );\n\t\t}\n\n\t\t$theme = wp_get_theme( $stylesheet );\n\t\tif ( $theme->exists() ) {\n\t\t\t$status['newVersion'] = $theme->get( 'Version' );\n\t\t}\n\n\t\twp_send_json_success( $status );\n\t} elseif ( false === $result ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t// An unhandled error occurred.\n\t$status['errorMessage'] = __( 'Update failed.' );\n\twp_send_json_error( $status );\n}\n\n/**\n * Ajax handler for deleting a theme.\n *\n * @since 4.6.0\n *\n * @see delete_theme()\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_delete_theme() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_theme_specified',\n\t\t\t\t'errorMessage' => __( 'No theme specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$stylesheet = preg_replace( '/[^A-z0-9_\\-]/', '', wp_unslash( $_POST['slug'] ) );\n\t$status     = array(\n\t\t'delete' => 'theme',\n\t\t'slug'   => $stylesheet,\n\t);\n\n\tif ( ! current_user_can( 'delete_themes' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to delete themes on this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\tif ( ! wp_get_theme( $stylesheet )->exists() ) {\n\t\t$status['errorMessage'] = __( 'The requested theme does not exist.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Check filesystem credentials. `delete_theme()` will bail otherwise.\n\t$url = wp_nonce_url( 'themes.php?action=delete&stylesheet=' . urlencode( $stylesheet ), 'delete-theme_' . $stylesheet );\n\tob_start();\n\t$credentials = request_filesystem_credentials( $url );\n\tob_end_clean();\n\tif ( false === $credentials || ! WP_Filesystem( $credentials ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/theme.php' );\n\n\t$result = delete_theme( $stylesheet );\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( false === $result ) {\n\t\t$status['errorMessage'] = __( 'Theme could not be deleted.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for installing a plugin.\n *\n * @since 4.6.0\n *\n * @see Plugin_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_install_plugin() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_plugin_specified',\n\t\t\t\t'errorMessage' => __( 'No plugin specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$status = array(\n\t\t'install' => 'plugin',\n\t\t'slug'    => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t);\n\n\tif ( ! current_user_can( 'install_plugins' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to install plugins on this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\tinclude_once( ABSPATH . 'wp-admin/includes/plugin-install.php' );\n\n\t$api = plugins_api(\n\t\t'plugin_information',\n\t\tarray(\n\t\t\t'slug'   => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t\t\t'fields' => array(\n\t\t\t\t'sections' => false,\n\t\t\t),\n\t\t)\n\t);\n\n\tif ( is_wp_error( $api ) ) {\n\t\t$status['errorMessage'] = $api->get_error_message();\n\t\twp_send_json_error( $status );\n\t}\n\n\t$status['pluginName'] = $api->name;\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Plugin_Upgrader( $skin );\n\t$result   = $upgrader->install( $api->download_link );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorCode']    = $result->get_error_code();\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_null( $result ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t$install_status = install_plugin_install_status( $api );\n\t$pagenow        = isset( $_POST['pagenow'] ) ? sanitize_key( $_POST['pagenow'] ) : '';\n\n\t// If installation request is coming from import page, do not return network activation link.\n\t$plugins_url = ( 'import' === $pagenow ) ? admin_url( 'plugins.php' ) : network_admin_url( 'plugins.php' );\n\n\tif ( current_user_can( 'activate_plugin', $install_status['file'] ) && is_plugin_inactive( $install_status['file'] ) ) {\n\t\t$status['activateUrl'] = add_query_arg(\n\t\t\tarray(\n\t\t\t\t'_wpnonce' => wp_create_nonce( 'activate-plugin_' . $install_status['file'] ),\n\t\t\t\t'action'   => 'activate',\n\t\t\t\t'plugin'   => $install_status['file'],\n\t\t\t),\n\t\t\t$plugins_url\n\t\t);\n\t}\n\n\tif ( is_multisite() && current_user_can( 'manage_network_plugins' ) && 'import' !== $pagenow ) {\n\t\t$status['activateUrl'] = add_query_arg( array( 'networkwide' => 1 ), $status['activateUrl'] );\n\t}\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for updating a plugin.\n *\n * @since 4.2.0\n *\n * @see Plugin_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_update_plugin() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['plugin'] ) || empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_plugin_specified',\n\t\t\t\t'errorMessage' => __( 'No plugin specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$plugin = plugin_basename( sanitize_text_field( wp_unslash( $_POST['plugin'] ) ) );\n\n\t$status = array(\n\t\t'update'     => 'plugin',\n\t\t'slug'       => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t\t'oldVersion' => '',\n\t\t'newVersion' => '',\n\t);\n\n\tif ( ! current_user_can( 'update_plugins' ) || 0 !== validate_file( $plugin ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to update plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t$plugin_data          = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin );\n\t$status['plugin']     = $plugin;\n\t$status['pluginName'] = $plugin_data['Name'];\n\n\tif ( $plugin_data['Version'] ) {\n\t\t/* translators: %s: Plugin version */\n\t\t$status['oldVersion'] = sprintf( __( 'Version %s' ), $plugin_data['Version'] );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\n\twp_update_plugins();\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Plugin_Upgrader( $skin );\n\t$result   = $upgrader->bulk_upgrade( array( $plugin ) );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_array( $result ) && ! empty( $result[ $plugin ] ) ) {\n\t\t$plugin_update_data = current( $result );\n\n\t\t/*\n\t\t * If the `update_plugins` site transient is empty (e.g. when you update\n\t\t * two plugins in quick succession before the transient repopulates),\n\t\t * this may be the return.\n\t\t *\n\t\t * Preferably something can be done to ensure `update_plugins` isn't empty.\n\t\t * For now, surface some sort of error here.\n\t\t */\n\t\tif ( true === $plugin_update_data ) {\n\t\t\t$status['errorMessage'] = __( 'Plugin update failed.' );\n\t\t\twp_send_json_error( $status );\n\t\t}\n\n\t\t$plugin_data = get_plugins( '/' . $result[ $plugin ]['destination_name'] );\n\t\t$plugin_data = reset( $plugin_data );\n\n\t\tif ( $plugin_data['Version'] ) {\n\t\t\t/* translators: %s: Plugin version */\n\t\t\t$status['newVersion'] = sprintf( __( 'Version %s' ), $plugin_data['Version'] );\n\t\t}\n\t\twp_send_json_success( $status );\n\t} elseif ( false === $result ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t// An unhandled error occurred.\n\t$status['errorMessage'] = __( 'Plugin update failed.' );\n\twp_send_json_error( $status );\n}\n\n/**\n * Ajax handler for deleting a plugin.\n *\n * @since 4.6.0\n *\n * @see delete_plugins()\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_delete_plugin() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) || empty( $_POST['plugin'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_plugin_specified',\n\t\t\t\t'errorMessage' => __( 'No plugin specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$plugin = plugin_basename( sanitize_text_field( wp_unslash( $_POST['plugin'] ) ) );\n\n\t$status = array(\n\t\t'delete' => 'plugin',\n\t\t'slug'   => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t);\n\n\tif ( ! current_user_can( 'delete_plugins' ) || 0 !== validate_file( $plugin ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to delete plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t$plugin_data          = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin );\n\t$status['plugin']     = $plugin;\n\t$status['pluginName'] = $plugin_data['Name'];\n\n\tif ( is_plugin_active( $plugin ) ) {\n\t\t$status['errorMessage'] = __( 'You cannot delete a plugin while it is active on the main site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Check filesystem credentials. `delete_plugins()` will bail otherwise.\n\t$url = wp_nonce_url( 'plugins.php?action=delete-selected&verify-delete=1&checked[]=' . $plugin, 'bulk-plugins' );\n\tob_start();\n\t$credentials = request_filesystem_credentials( $url );\n\tob_end_clean();\n\tif ( false === $credentials || ! WP_Filesystem( $credentials ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t$result = delete_plugins( array( $plugin ) );\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( false === $result ) {\n\t\t$status['errorMessage'] = __( 'Plugin could not be deleted.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for searching plugins.\n *\n * @since 4.6.0\n *\n * @global string $s Search term.\n */\nfunction wp_ajax_search_plugins() {\n\tcheck_ajax_referer( 'updates' );\n\n\t$pagenow = isset( $_POST['pagenow'] ) ? sanitize_key( $_POST['pagenow'] ) : '';\n\tif ( 'plugins-network' === $pagenow || 'plugins' === $pagenow ) {\n\t\tset_current_screen( $pagenow );\n\t}\n\n\t/** @var WP_Plugins_List_Table $wp_list_table */\n\t$wp_list_table = _get_list_table(\n\t\t'WP_Plugins_List_Table',\n\t\tarray(\n\t\t\t'screen' => get_current_screen(),\n\t\t)\n\t);\n\n\t$status = array();\n\n\tif ( ! $wp_list_table->ajax_user_can() ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to manage plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Set the correct requester, so pagination works.\n\t$_SERVER['REQUEST_URI'] = add_query_arg(\n\t\tarray_diff_key(\n\t\t\t$_POST,\n\t\t\tarray(\n\t\t\t\t'_ajax_nonce' => null,\n\t\t\t\t'action'      => null,\n\t\t\t)\n\t\t),\n\t\tnetwork_admin_url( 'plugins.php', 'relative' )\n\t);\n\n\t$GLOBALS['s'] = wp_unslash( $_POST['s'] );\n\n\t$wp_list_table->prepare_items();\n\n\tob_start();\n\t$wp_list_table->display();\n\t$status['count'] = count( $wp_list_table->items );\n\t$status['items'] = ob_get_clean();\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for searching plugins to install.\n *\n * @since 4.6.0\n */\nfunction wp_ajax_search_install_plugins() {\n\tcheck_ajax_referer( 'updates' );\n\n\t$pagenow = isset( $_POST['pagenow'] ) ? sanitize_key( $_POST['pagenow'] ) : '';\n\tif ( 'plugin-install-network' === $pagenow || 'plugin-install' === $pagenow ) {\n\t\tset_current_screen( $pagenow );\n\t}\n\n\t/** @var WP_Plugin_Install_List_Table $wp_list_table */\n\t$wp_list_table = _get_list_table(\n\t\t'WP_Plugin_Install_List_Table',\n\t\tarray(\n\t\t\t'screen' => get_current_screen(),\n\t\t)\n\t);\n\n\t$status = array();\n\n\tif ( ! $wp_list_table->ajax_user_can() ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to manage plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Set the correct requester, so pagination works.\n\t$_SERVER['REQUEST_URI'] = add_query_arg(\n\t\tarray_diff_key(\n\t\t\t$_POST,\n\t\t\tarray(\n\t\t\t\t'_ajax_nonce' => null,\n\t\t\t\t'action'      => null,\n\t\t\t)\n\t\t),\n\t\tnetwork_admin_url( 'plugin-install.php', 'relative' )\n\t);\n\n\t$wp_list_table->prepare_items();\n\n\tob_start();\n\t$wp_list_table->display();\n\t$status['count'] = (int) $wp_list_table->get_pagination_arg( 'total_items' );\n\t$status['items'] = ob_get_clean();\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for editing a theme or plugin file.\n *\n * @since 4.9.0\n * @see wp_edit_theme_plugin_file()\n */\nfunction wp_ajax_edit_theme_plugin_file() {\n\t$r = wp_edit_theme_plugin_file( wp_unslash( $_POST ) ); // Validation of args is done in wp_edit_theme_plugin_file().\n\tif ( is_wp_error( $r ) ) {\n\t\twp_send_json_error(\n\t\t\tarray_merge(\n\t\t\t\tarray(\n\t\t\t\t\t'code'    => $r->get_error_code(),\n\t\t\t\t\t'message' => $r->get_error_message(),\n\t\t\t\t),\n\t\t\t\t(array) $r->get_error_data()\n\t\t\t)\n\t\t);\n\t} else {\n\t\twp_send_json_success(\n\t\t\tarray(\n\t\t\t\t'message' => __( 'File edited successfully.' ),\n\t\t\t)\n\t\t);\n\t}\n}\n\n/**\n * Ajax handler for exporting a user's personal data.\n *\n * @since 4.9.6\n */\nfunction wp_ajax_wp_privacy_export_personal_data() {\n\n\tif ( empty( $_POST['id'] ) ) {\n\t\twp_send_json_error( __( 'Missing request ID.' ) );\n\t}\n\t$request_id = (int) $_POST['id'];\n\n\tif ( $request_id < 1 ) {\n\t\twp_send_json_error( __( 'Invalid request ID.' ) );\n\t}\n\n\tif ( ! current_user_can( 'export_others_personal_data' ) ) {\n\t\twp_send_json_error( __( 'Sorry, you are not allowed to perform this action.' ) );\n\t}\n\n\tcheck_ajax_referer( 'wp-privacy-export-personal-data-' . $request_id, 'security' );\n\n\t// Get the request data.\n\t$request = wp_get_user_request_data( $request_id );\n\n\tif ( ! $request || 'export_personal_data' !== $request->action_name ) {\n\t\twp_send_json_error( __( 'Invalid request type.' ) );\n\t}\n\n\t$email_address = $request->email;\n\tif ( ! is_email( $email_address ) ) {\n\t\twp_send_json_error( __( 'A valid email address must be given.' ) );\n\t}\n\n\tif ( ! isset( $_POST['exporter'] ) ) {\n\t\twp_send_json_error( __( 'Missing exporter index.' ) );\n\t}\n\t$exporter_index = (int) $_POST['exporter'];\n\n\tif ( ! isset( $_POST['page'] ) ) {\n\t\twp_send_json_error( __( 'Missing page index.' ) );\n\t}\n\t$page = (int) $_POST['page'];\n\n\t$send_as_email = isset( $_POST['sendAsEmail'] ) ? ( 'true' === $_POST['sendAsEmail'] ) : false;\n\n\t/**\n\t * Filters the array of exporter callbacks.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array $args {\n\t *     An array of callable exporters of personal data. Default empty array.\n\t *\n\t *     @type array {\n\t *         Array of personal data exporters.\n\t *\n\t *         @type string $callback               Callable exporter function that accepts an\n\t *                                              email address and a page and returns an array\n\t *                                              of name => value pairs of personal data.\n\t *         @type string $exporter_friendly_name Translated user facing friendly name for the\n\t *                                              exporter.\n\t *     }\n\t * }\n\t */\n\t$exporters = apply_filters( 'wp_privacy_personal_data_exporters', array() );\n\n\tif ( ! is_array( $exporters ) ) {\n\t\twp_send_json_error( __( 'An exporter has improperly used the registration filter.' ) );\n\t}\n\n\t// Do we have any registered exporters?\n\tif ( 0 < count( $exporters ) ) {\n\t\tif ( $exporter_index < 1 ) {\n\t\t\twp_send_json_error( __( 'Exporter index cannot be negative.' ) );\n\t\t}\n\n\t\tif ( $exporter_index > count( $exporters ) ) {\n\t\t\twp_send_json_error( __( 'Exporter index out of range.' ) );\n\t\t}\n\n\t\tif ( $page < 1 ) {\n\t\t\twp_send_json_error( __( 'Page index cannot be less than one.' ) );\n\t\t}\n\n\t\t$exporter_keys = array_keys( $exporters );\n\t\t$exporter_key  = $exporter_keys[ $exporter_index - 1 ];\n\t\t$exporter      = $exporters[ $exporter_key ];\n\n\t\tif ( ! is_array( $exporter ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: array index */\n\t\t\t\tsprintf( __( 'Expected an array describing the exporter at index %s.' ), $exporter_key )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'exporter_friendly_name', $exporter ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: array index */\n\t\t\t\tsprintf( __( 'Exporter array at index %s does not include a friendly name.' ), $exporter_key )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'callback', $exporter ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Exporter does not include a callback: %s.' ), esc_html( $exporter['exporter_friendly_name'] ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! is_callable( $exporter['callback'] ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Exporter callback is not a valid callback: %s.' ), esc_html( $exporter['exporter_friendly_name'] ) )\n\t\t\t);\n\t\t}\n\n\t\t$callback               = $exporter['callback'];\n\t\t$exporter_friendly_name = $exporter['exporter_friendly_name'];\n\n\t\t$response = call_user_func( $callback, $email_address, $page );\n\t\tif ( is_wp_error( $response ) ) {\n\t\t\twp_send_json_error( $response );\n\t\t}\n\n\t\tif ( ! is_array( $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected response as an array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'data', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected data in response array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! is_array( $response['data'] ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected data array in response array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'done', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected done (boolean) in response array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// No exporters, so we're done.\n\t\t$exporter_key = '';\n\n\t\t$response = array(\n\t\t\t'data' => array(),\n\t\t\t'done' => true,\n\t\t);\n\t}\n\n\t/**\n\t * Filters a page of personal data exporter data. Used to build the export report.\n\t *\n\t * Allows the export response to be consumed by destinations in addition to Ajax.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array  $response        The personal data for the given exporter and page.\n\t * @param int    $exporter_index  The index of the exporter that provided this data.\n\t * @param string $email_address   The email address associated with this personal data.\n\t * @param int    $page            The page for this response.\n\t * @param int    $request_id      The privacy request post ID associated with this request.\n\t * @param bool   $send_as_email   Whether the final results of the export should be emailed to the user.\n\t * @param string $exporter_key    The key (slug) of the exporter that provided this data.\n\t */\n\t$response = apply_filters( 'wp_privacy_personal_data_export_page', $response, $exporter_index, $email_address, $page, $request_id, $send_as_email, $exporter_key );\n\n\tif ( is_wp_error( $response ) ) {\n\t\twp_send_json_error( $response );\n\t}\n\n\twp_send_json_success( $response );\n}\n\n/**\n * Ajax handler for erasing personal data.\n *\n * @since 4.9.6\n */\nfunction wp_ajax_wp_privacy_erase_personal_data() {\n\n\tif ( empty( $_POST['id'] ) ) {\n\t\twp_send_json_error( __( 'Missing request ID.' ) );\n\t}\n\n\t$request_id = (int) $_POST['id'];\n\n\tif ( $request_id < 1 ) {\n\t\twp_send_json_error( __( 'Invalid request ID.' ) );\n\t}\n\n\t// Both capabilities are required to avoid confusion, see `_wp_personal_data_removal_page()`.\n\tif ( ! current_user_can( 'erase_others_personal_data' ) || ! current_user_can( 'delete_users' ) ) {\n\t\twp_send_json_error( __( 'Sorry, you are not allowed to perform this action.' ) );\n\t}\n\n\tcheck_ajax_referer( 'wp-privacy-erase-personal-data-' . $request_id, 'security' );\n\n\t// Get the request data.\n\t$request = wp_get_user_request_data( $request_id );\n\n\tif ( ! $request || 'remove_personal_data' !== $request->action_name ) {\n\t\twp_send_json_error( __( 'Invalid request ID.' ) );\n\t}\n\n\t$email_address = $request->email;\n\n\tif ( ! is_email( $email_address ) ) {\n\t\twp_send_json_error( __( 'Invalid email address in request.' ) );\n\t}\n\n\tif ( ! isset( $_POST['eraser'] ) ) {\n\t\twp_send_json_error( __( 'Missing eraser index.' ) );\n\t}\n\n\t$eraser_index = (int) $_POST['eraser'];\n\n\tif ( ! isset( $_POST['page'] ) ) {\n\t\twp_send_json_error( __( 'Missing page index.' ) );\n\t}\n\n\t$page = (int) $_POST['page'];\n\n\t/**\n\t * Filters the array of personal data eraser callbacks.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array $args {\n\t *     An array of callable erasers of personal data. Default empty array.\n\t *\n\t *     @type array {\n\t *         Array of personal data exporters.\n\t *\n\t *         @type string $callback               Callable eraser that accepts an email address and\n\t *                                              a page and returns an array with boolean values for\n\t *                                              whether items were removed or retained and any messages\n\t *                                              from the eraser, as well as if additional pages are\n\t *                                              available.\n\t *         @type string $exporter_friendly_name Translated user facing friendly name for the eraser.\n\t *     }\n\t * }\n\t */\n\t$erasers = apply_filters( 'wp_privacy_personal_data_erasers', array() );\n\n\t// Do we have any registered erasers?\n\tif ( 0 < count( $erasers ) ) {\n\n\t\tif ( $eraser_index < 1 ) {\n\t\t\twp_send_json_error( __( 'Eraser index cannot be less than one.' ) );\n\t\t}\n\n\t\tif ( $eraser_index > count( $erasers ) ) {\n\t\t\twp_send_json_error( __( 'Eraser index is out of range.' ) );\n\t\t}\n\n\t\tif ( $page < 1 ) {\n\t\t\twp_send_json_error( __( 'Page index cannot be less than one.' ) );\n\t\t}\n\n\t\t$eraser_keys = array_keys( $erasers );\n\t\t$eraser_key  = $eraser_keys[ $eraser_index - 1 ];\n\t\t$eraser      = $erasers[ $eraser_key ];\n\n\t\tif ( ! is_array( $eraser ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Expected an array describing the eraser at index %d.' ), $eraser_index ) );\n\t\t}\n\n\t\tif ( ! array_key_exists( 'callback', $eraser ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Eraser array at index %d does not include a callback.' ), $eraser_index ) );\n\t\t}\n\n\t\tif ( ! is_callable( $eraser['callback'] ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Eraser callback at index %d is not a valid callback.' ), $eraser_index ) );\n\t\t}\n\n\t\tif ( ! array_key_exists( 'eraser_friendly_name', $eraser ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Eraser array at index %d does not include a friendly name.' ), $eraser_index ) );\n\t\t}\n\n\t\t$callback             = $eraser['callback'];\n\t\t$eraser_friendly_name = $eraser['eraser_friendly_name'];\n\n\t\t$response = call_user_func( $callback, $email_address, $page );\n\n\t\tif ( is_wp_error( $response ) ) {\n\t\t\twp_send_json_error( $response );\n\t\t}\n\n\t\tif ( ! is_array( $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Did not receive array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'items_removed', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected items_removed key in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'items_retained', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected items_retained key in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'messages', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected messages key in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! is_array( $response['messages'] ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected messages key to reference an array in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'done', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected done flag in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// No erasers, so we're done.\n\t\t$eraser_key = '';\n\n\t\t$response = array(\n\t\t\t'items_removed'  => false,\n\t\t\t'items_retained' => false,\n\t\t\t'messages'       => array(),\n\t\t\t'done'           => true,\n\t\t);\n\t}\n\n\t/**\n\t * Filters a page of personal data eraser data.\n\t *\n\t * Allows the erasure response to be consumed by destinations in addition to Ajax.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array  $response        The personal data for the given exporter and page.\n\t * @param int    $eraser_index    The index of the eraser that provided this data.\n\t * @param string $email_address   The email address associated with this personal data.\n\t * @param int    $page            The page for this response.\n\t * @param int    $request_id      The privacy request post ID associated with this request.\n\t * @param string $eraser_key      The key (slug) of the eraser that provided this data.\n\t */\n\t$response = apply_filters( 'wp_privacy_personal_data_erasure_page', $response, $eraser_index, $email_address, $page, $request_id, $eraser_key );\n\n\tif ( is_wp_error( $response ) ) {\n\t\twp_send_json_error( $response );\n\t}\n\n\twp_send_json_success( $response );\n}\n", "<?php\n/**\n * Core Comment API\n *\n * @package WordPress\n * @subpackage Comment\n */\n\n/**\n * Check whether a comment passes internal checks to be allowed to add.\n *\n * If manual comment moderation is set in the administration, then all checks,\n * regardless of their type and whitelist, will fail and the function will\n * return false.\n *\n * If the number of links exceeds the amount in the administration, then the\n * check fails. If any of the parameter contents match the blacklist of words,\n * then the check fails.\n *\n * If the comment author was approved before, then the comment is automatically\n * whitelisted.\n *\n * If all checks pass, the function will return true.\n *\n * @since 1.2.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $author       Comment author name.\n * @param string $email        Comment author email.\n * @param string $url          Comment author URL.\n * @param string $comment      Content of the comment.\n * @param string $user_ip      Comment author IP address.\n * @param string $user_agent   Comment author User-Agent.\n * @param string $comment_type Comment type, either user-submitted comment,\n *                             trackback, or pingback.\n * @return bool If all checks pass, true, otherwise false.\n */\nfunction check_comment( $author, $email, $url, $comment, $user_ip, $user_agent, $comment_type ) {\n\tglobal $wpdb;\n\n\t// If manual moderation is enabled, skip all checks and return false.\n\tif ( 1 == get_option( 'comment_moderation' ) ) {\n\t\treturn false;\n\t}\n\n\t/** This filter is documented in wp-includes/comment-template.php */\n\t$comment = apply_filters( 'comment_text', $comment, null, array() );\n\n\t// Check for the number of external links if a max allowed number is set.\n\tif ( $max_links = get_option( 'comment_max_links' ) ) {\n\t\t$num_links = preg_match_all( '/<a [^>]*href/i', $comment, $out );\n\n\t\t/**\n\t\t * Filters the number of links found in a comment.\n\t\t *\n\t\t * @since 3.0.0\n\t\t * @since 4.7.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int    $num_links The number of links found.\n\t\t * @param string $url       Comment author's URL. Included in allowed links total.\n\t\t * @param string $comment   Content of the comment.\n\t\t */\n\t\t$num_links = apply_filters( 'comment_max_links_url', $num_links, $url, $comment );\n\n\t\t/*\n\t\t * If the number of links in the comment exceeds the allowed amount,\n\t\t * fail the check by returning false.\n\t\t */\n\t\tif ( $num_links >= $max_links ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$mod_keys = trim( get_option( 'moderation_keys' ) );\n\n\t// If moderation 'keys' (keywords) are set, process them.\n\tif ( ! empty( $mod_keys ) ) {\n\t\t$words = explode( \"\\n\", $mod_keys );\n\n\t\tforeach ( (array) $words as $word ) {\n\t\t\t$word = trim( $word );\n\n\t\t\t// Skip empty lines.\n\t\t\tif ( empty( $word ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do some escaping magic so that '#' (number of) characters in the spam\n\t\t\t * words don't break things:\n\t\t\t */\n\t\t\t$word = preg_quote( $word, '#' );\n\n\t\t\t/*\n\t\t\t * Check the comment fields for moderation keywords. If any are found,\n\t\t\t * fail the check for the given field by returning false.\n\t\t\t */\n\t\t\t$pattern = \"#$word#i\";\n\t\t\tif ( preg_match( $pattern, $author ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $email ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $url ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $comment ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $user_ip ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $user_agent ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Check if the option to approve comments by previously-approved authors is enabled.\n\t *\n\t * If it is enabled, check whether the comment author has a previously-approved comment,\n\t * as well as whether there are any moderation keywords (if set) present in the author\n\t * email address. If both checks pass, return true. Otherwise, return false.\n\t */\n\tif ( 1 == get_option( 'comment_whitelist' ) ) {\n\t\tif ( 'trackback' != $comment_type && 'pingback' != $comment_type && $author != '' && $email != '' ) {\n\t\t\t$comment_user = get_user_by( 'email', wp_unslash( $email ) );\n\t\t\tif ( ! empty( $comment_user->ID ) ) {\n\t\t\t\t$ok_to_comment = $wpdb->get_var( $wpdb->prepare( \"SELECT comment_approved FROM $wpdb->comments WHERE user_id = %d AND comment_approved = '1' LIMIT 1\", $comment_user->ID ) );\n\t\t\t} else {\n\t\t\t\t// expected_slashed ($author, $email)\n\t\t\t\t$ok_to_comment = $wpdb->get_var( $wpdb->prepare( \"SELECT comment_approved FROM $wpdb->comments WHERE comment_author = %s AND comment_author_email = %s and comment_approved = '1' LIMIT 1\", $author, $email ) );\n\t\t\t}\n\t\t\tif ( ( 1 == $ok_to_comment ) &&\n\t\t\t\t( empty( $mod_keys ) || false === strpos( $email, $mod_keys ) ) ) {\n\t\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Retrieve the approved comments for post $post_id.\n *\n * @since 2.0.0\n * @since 4.1.0 Refactored to leverage WP_Comment_Query over a direct query.\n *\n * @param  int   $post_id The ID of the post.\n * @param  array $args    Optional. See WP_Comment_Query::__construct() for information on accepted arguments.\n * @return int|array $comments The approved comments, or number of comments if `$count`\n *                             argument is true.\n */\nfunction get_approved_comments( $post_id, $args = array() ) {\n\tif ( ! $post_id ) {\n\t\treturn array();\n\t}\n\n\t$defaults = array(\n\t\t'status'  => 1,\n\t\t'post_id' => $post_id,\n\t\t'order'   => 'ASC',\n\t);\n\t$r        = wp_parse_args( $args, $defaults );\n\n\t$query = new WP_Comment_Query;\n\treturn $query->query( $r );\n}\n\n/**\n * Retrieves comment data given a comment ID or comment object.\n *\n * If an object is passed then the comment data will be cached and then returned\n * after being passed through a filter. If the comment is empty, then the global\n * comment variable will be used, if it is set.\n *\n * @since 2.0.0\n *\n * @global WP_Comment $comment\n *\n * @param WP_Comment|string|int $comment Comment to retrieve.\n * @param string                $output  Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to\n *                                       a WP_Comment object, an associative array, or a numeric array, respectively. Default OBJECT.\n * @return WP_Comment|array|null Depends on $output value.\n */\nfunction get_comment( &$comment = null, $output = OBJECT ) {\n\tif ( empty( $comment ) && isset( $GLOBALS['comment'] ) ) {\n\t\t$comment = $GLOBALS['comment'];\n\t}\n\n\tif ( $comment instanceof WP_Comment ) {\n\t\t$_comment = $comment;\n\t} elseif ( is_object( $comment ) ) {\n\t\t$_comment = new WP_Comment( $comment );\n\t} else {\n\t\t$_comment = WP_Comment::get_instance( $comment );\n\t}\n\n\tif ( ! $_comment ) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Fires after a comment is retrieved.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param mixed $_comment Comment data.\n\t */\n\t$_comment = apply_filters( 'get_comment', $_comment );\n\n\tif ( $output == OBJECT ) {\n\t\treturn $_comment;\n\t} elseif ( $output == ARRAY_A ) {\n\t\treturn $_comment->to_array();\n\t} elseif ( $output == ARRAY_N ) {\n\t\treturn array_values( $_comment->to_array() );\n\t}\n\treturn $_comment;\n}\n\n/**\n * Retrieve a list of comments.\n *\n * The comment list can be for the blog as a whole or for an individual post.\n *\n * @since 2.7.0\n *\n * @param string|array $args Optional. Array or string of arguments. See WP_Comment_Query::__construct()\n *                           for information on accepted arguments. Default empty.\n * @return int|array List of comments or number of found comments if `$count` argument is true.\n */\nfunction get_comments( $args = '' ) {\n\t$query = new WP_Comment_Query;\n\treturn $query->query( $args );\n}\n\n/**\n * Retrieve all of the WordPress supported comment statuses.\n *\n * Comments have a limited set of valid status values, this provides the comment\n * status values and descriptions.\n *\n * @since 2.7.0\n *\n * @return array List of comment statuses.\n */\nfunction get_comment_statuses() {\n\t$status = array(\n\t\t'hold'    => __( 'Unapproved' ),\n\t\t'approve' => _x( 'Approved', 'comment status' ),\n\t\t'spam'    => _x( 'Spam', 'comment status' ),\n\t\t'trash'   => _x( 'Trash', 'comment status' ),\n\t);\n\n\treturn $status;\n}\n\n/**\n * Gets the default comment status for a post type.\n *\n * @since 4.3.0\n *\n * @param string $post_type    Optional. Post type. Default 'post'.\n * @param string $comment_type Optional. Comment type. Default 'comment'.\n * @return string Expected return value is 'open' or 'closed'.\n */\nfunction get_default_comment_status( $post_type = 'post', $comment_type = 'comment' ) {\n\tswitch ( $comment_type ) {\n\t\tcase 'pingback':\n\t\tcase 'trackback':\n\t\t\t$supports = 'trackbacks';\n\t\t\t$option   = 'ping';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$supports = 'comments';\n\t\t\t$option   = 'comment';\n\t}\n\n\t// Set the status.\n\tif ( 'page' === $post_type ) {\n\t\t$status = 'closed';\n\t} elseif ( post_type_supports( $post_type, $supports ) ) {\n\t\t$status = get_option( \"default_{$option}_status\" );\n\t} else {\n\t\t$status = 'closed';\n\t}\n\n\t/**\n\t * Filters the default comment status for the given post type.\n\t *\n\t * @since 4.3.0\n\t *\n\t * @param string $status       Default status for the given post type,\n\t *                             either 'open' or 'closed'.\n\t * @param string $post_type    Post type. Default is `post`.\n\t * @param string $comment_type Type of comment. Default is `comment`.\n\t */\n\treturn apply_filters( 'get_default_comment_status', $status, $post_type, $comment_type );\n}\n\n/**\n * The date the last comment was modified.\n *\n * @since 1.5.0\n * @since 4.7.0 Replaced caching the modified date in a local static variable\n *              with the Object Cache API.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $timezone Which timezone to use in reference to 'gmt', 'blog', or 'server' locations.\n * @return string|false Last comment modified date on success, false on failure.\n */\nfunction get_lastcommentmodified( $timezone = 'server' ) {\n\tglobal $wpdb;\n\n\t$timezone = strtolower( $timezone );\n\t$key      = \"lastcommentmodified:$timezone\";\n\n\t$comment_modified_date = wp_cache_get( $key, 'timeinfo' );\n\tif ( false !== $comment_modified_date ) {\n\t\treturn $comment_modified_date;\n\t}\n\n\tswitch ( $timezone ) {\n\t\tcase 'gmt':\n\t\t\t$comment_modified_date = $wpdb->get_var( \"SELECT comment_date_gmt FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1\" );\n\t\t\tbreak;\n\t\tcase 'blog':\n\t\t\t$comment_modified_date = $wpdb->get_var( \"SELECT comment_date FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1\" );\n\t\t\tbreak;\n\t\tcase 'server':\n\t\t\t$add_seconds_server = date( 'Z' );\n\n\t\t\t$comment_modified_date = $wpdb->get_var( $wpdb->prepare( \"SELECT DATE_ADD(comment_date_gmt, INTERVAL %s SECOND) FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1\", $add_seconds_server ) );\n\t\t\tbreak;\n\t}\n\n\tif ( $comment_modified_date ) {\n\t\twp_cache_set( $key, $comment_modified_date, 'timeinfo' );\n\n\t\treturn $comment_modified_date;\n\t}\n\n\treturn false;\n}\n\n/**\n * The amount of comments in a post or total comments.\n *\n * A lot like wp_count_comments(), in that they both return comment stats (albeit with different types).\n * The wp_count_comments() actually caches, but this function does not.\n *\n * @since 2.0.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $post_id Optional. Comment amount in post if > 0, else total comments blog wide.\n * @return array The amount of spam, approved, awaiting moderation, and total comments.\n */\nfunction get_comment_count( $post_id = 0 ) {\n\tglobal $wpdb;\n\n\t$post_id = (int) $post_id;\n\n\t$where = '';\n\tif ( $post_id > 0 ) {\n\t\t$where = $wpdb->prepare( 'WHERE comment_post_ID = %d', $post_id );\n\t}\n\n\t$totals = (array) $wpdb->get_results(\n\t\t\"\n\t\tSELECT comment_approved, COUNT( * ) AS total\n\t\tFROM {$wpdb->comments}\n\t\t{$where}\n\t\tGROUP BY comment_approved\n\t\",\n\t\tARRAY_A\n\t);\n\n\t$comment_count = array(\n\t\t'approved'            => 0,\n\t\t'awaiting_moderation' => 0,\n\t\t'spam'                => 0,\n\t\t'trash'               => 0,\n\t\t'post-trashed'        => 0,\n\t\t'total_comments'      => 0,\n\t\t'all'                 => 0,\n\t);\n\n\tforeach ( $totals as $row ) {\n\t\tswitch ( $row['comment_approved'] ) {\n\t\t\tcase 'trash':\n\t\t\t\t$comment_count['trash'] = $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase 'post-trashed':\n\t\t\t\t$comment_count['post-trashed'] = $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase 'spam':\n\t\t\t\t$comment_count['spam']            = $row['total'];\n\t\t\t\t$comment_count['total_comments'] += $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\t$comment_count['approved']        = $row['total'];\n\t\t\t\t$comment_count['total_comments'] += $row['total'];\n\t\t\t\t$comment_count['all']            += $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\t$comment_count['awaiting_moderation'] = $row['total'];\n\t\t\t\t$comment_count['total_comments']     += $row['total'];\n\t\t\t\t$comment_count['all']                += $row['total'];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn $comment_count;\n}\n\n//\n// Comment meta functions\n//\n\n/**\n * Add meta data field to a comment.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/add_comment_meta\n *\n * @param int $comment_id Comment ID.\n * @param string $meta_key Metadata name.\n * @param mixed $meta_value Metadata value.\n * @param bool $unique Optional, default is false. Whether the same key should not be added.\n * @return int|bool Meta ID on success, false on failure.\n */\nfunction add_comment_meta( $comment_id, $meta_key, $meta_value, $unique = false ) {\n\treturn add_metadata( 'comment', $comment_id, $meta_key, $meta_value, $unique );\n}\n\n/**\n * Remove metadata matching criteria from a comment.\n *\n * You can match based on the key, or key and value. Removing based on key and\n * value, will keep from removing duplicate metadata with the same key. It also\n * allows removing all metadata matching key, if needed.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/delete_comment_meta\n *\n * @param int $comment_id comment ID\n * @param string $meta_key Metadata name.\n * @param mixed $meta_value Optional. Metadata value.\n * @return bool True on success, false on failure.\n */\nfunction delete_comment_meta( $comment_id, $meta_key, $meta_value = '' ) {\n\treturn delete_metadata( 'comment', $comment_id, $meta_key, $meta_value );\n}\n\n/**\n * Retrieve comment meta field for a comment.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/get_comment_meta\n *\n * @param int $comment_id Comment ID.\n * @param string $key Optional. The meta key to retrieve. By default, returns data for all keys.\n * @param bool $single Whether to return a single value.\n * @return mixed Will be an array if $single is false. Will be value of meta data field if $single\n *  is true.\n */\nfunction get_comment_meta( $comment_id, $key = '', $single = false ) {\n\treturn get_metadata( 'comment', $comment_id, $key, $single );\n}\n\n/**\n * Update comment meta field based on comment ID.\n *\n * Use the $prev_value parameter to differentiate between meta fields with the\n * same key and comment ID.\n *\n * If the meta field for the comment does not exist, it will be added.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/update_comment_meta\n *\n * @param int $comment_id Comment ID.\n * @param string $meta_key Metadata key.\n * @param mixed $meta_value Metadata value.\n * @param mixed $prev_value Optional. Previous value to check before removing.\n * @return int|bool Meta ID if the key didn't exist, true on successful update, false on failure.\n */\nfunction update_comment_meta( $comment_id, $meta_key, $meta_value, $prev_value = '' ) {\n\treturn update_metadata( 'comment', $comment_id, $meta_key, $meta_value, $prev_value );\n}\n\n/**\n * Queues comments for metadata lazy-loading.\n *\n * @since 4.5.0\n *\n * @param WP_Comment[] $comments Array of comment objects.\n */\nfunction wp_queue_comments_for_comment_meta_lazyload( $comments ) {\n\t// Don't use `wp_list_pluck()` to avoid by-reference manipulation.\n\t$comment_ids = array();\n\tif ( is_array( $comments ) ) {\n\t\tforeach ( $comments as $comment ) {\n\t\t\tif ( $comment instanceof WP_Comment ) {\n\t\t\t\t$comment_ids[] = $comment->comment_ID;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( $comment_ids ) {\n\t\t$lazyloader = wp_metadata_lazyloader();\n\t\t$lazyloader->queue_objects( 'comment', $comment_ids );\n\t}\n}\n\n/**\n * Sets the cookies used to store an unauthenticated commentator's identity. Typically used\n * to recall previous comments by this commentator that are still held in moderation.\n *\n * @since 3.4.0\n * @since 4.9.6 The `$cookies_consent` parameter was added.\n *\n * @param WP_Comment $comment         Comment object.\n * @param WP_User    $user            Comment author's user object. The user may not exist.\n * @param boolean    $cookies_consent Optional. Comment author's consent to store cookies. Default true.\n */\nfunction wp_set_comment_cookies( $comment, $user, $cookies_consent = true ) {\n\t// If the user already exists, or the user opted out of cookies, don't set cookies.\n\tif ( $user->exists() ) {\n\t\treturn;\n\t}\n\n\tif ( false === $cookies_consent ) {\n\t\t// Remove any existing cookies.\n\t\t$past = time() - YEAR_IN_SECONDS;\n\t\tsetcookie( 'comment_author_' . COOKIEHASH, ' ', $past, COOKIEPATH, COOKIE_DOMAIN );\n\t\tsetcookie( 'comment_author_email_' . COOKIEHASH, ' ', $past, COOKIEPATH, COOKIE_DOMAIN );\n\t\tsetcookie( 'comment_author_url_' . COOKIEHASH, ' ', $past, COOKIEPATH, COOKIE_DOMAIN );\n\n\t\treturn;\n\t}\n\n\t/**\n\t * Filters the lifetime of the comment cookie in seconds.\n\t *\n\t * @since 2.8.0\n\t *\n\t * @param int $seconds Comment cookie lifetime. Default 30000000.\n\t */\n\t$comment_cookie_lifetime = time() + apply_filters( 'comment_cookie_lifetime', 30000000 );\n\t$secure                  = ( 'https' === parse_url( home_url(), PHP_URL_SCHEME ) );\n\tsetcookie( 'comment_author_' . COOKIEHASH, $comment->comment_author, $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );\n\tsetcookie( 'comment_author_email_' . COOKIEHASH, $comment->comment_author_email, $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );\n\tsetcookie( 'comment_author_url_' . COOKIEHASH, esc_url( $comment->comment_author_url ), $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );\n}\n\n/**\n * Sanitizes the cookies sent to the user already.\n *\n * Will only do anything if the cookies have already been created for the user.\n * Mostly used after cookies had been sent to use elsewhere.\n *\n * @since 2.0.4\n */\nfunction sanitize_comment_cookies() {\n\tif ( isset( $_COOKIE[ 'comment_author_' . COOKIEHASH ] ) ) {\n\t\t/**\n\t\t * Filters the comment author's name cookie before it is set.\n\t\t *\n\t\t * When this filter hook is evaluated in wp_filter_comment(),\n\t\t * the comment author's name string is passed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string $author_cookie The comment author name cookie.\n\t\t */\n\t\t$comment_author                            = apply_filters( 'pre_comment_author_name', $_COOKIE[ 'comment_author_' . COOKIEHASH ] );\n\t\t$comment_author                            = wp_unslash( $comment_author );\n\t\t$comment_author                            = esc_attr( $comment_author );\n\t\t$_COOKIE[ 'comment_author_' . COOKIEHASH ] = $comment_author;\n\t}\n\n\tif ( isset( $_COOKIE[ 'comment_author_email_' . COOKIEHASH ] ) ) {\n\t\t/**\n\t\t * Filters the comment author's email cookie before it is set.\n\t\t *\n\t\t * When this filter hook is evaluated in wp_filter_comment(),\n\t\t * the comment author's email string is passed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string $author_email_cookie The comment author email cookie.\n\t\t */\n\t\t$comment_author_email                            = apply_filters( 'pre_comment_author_email', $_COOKIE[ 'comment_author_email_' . COOKIEHASH ] );\n\t\t$comment_author_email                            = wp_unslash( $comment_author_email );\n\t\t$comment_author_email                            = esc_attr( $comment_author_email );\n\t\t$_COOKIE[ 'comment_author_email_' . COOKIEHASH ] = $comment_author_email;\n\t}\n\n\tif ( isset( $_COOKIE[ 'comment_author_url_' . COOKIEHASH ] ) ) {\n\t\t/**\n\t\t * Filters the comment author's URL cookie before it is set.\n\t\t *\n\t\t * When this filter hook is evaluated in wp_filter_comment(),\n\t\t * the comment author's URL string is passed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string $author_url_cookie The comment author URL cookie.\n\t\t */\n\t\t$comment_author_url                            = apply_filters( 'pre_comment_author_url', $_COOKIE[ 'comment_author_url_' . COOKIEHASH ] );\n\t\t$comment_author_url                            = wp_unslash( $comment_author_url );\n\t\t$_COOKIE[ 'comment_author_url_' . COOKIEHASH ] = $comment_author_url;\n\t}\n}\n\n/**\n * Validates whether this comment is allowed to be made.\n *\n * @since 2.0.0\n * @since 4.7.0 The `$avoid_die` parameter was added, allowing the function to\n *              return a WP_Error object instead of dying.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentdata Contains information on the comment.\n * @param bool  $avoid_die   When true, a disallowed comment will result in the function\n *                           returning a WP_Error object, rather than executing wp_die().\n *                           Default false.\n * @return int|string|WP_Error Allowed comments return the approval status (0|1|'spam').\n *                             If `$avoid_die` is true, disallowed comments return a WP_Error.\n */\nfunction wp_allow_comment( $commentdata, $avoid_die = false ) {\n\tglobal $wpdb;\n\n\t// Simple duplicate check\n\t// expected_slashed ($comment_post_ID, $comment_author, $comment_author_email, $comment_content)\n\t$dupe = $wpdb->prepare(\n\t\t\"SELECT comment_ID FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_parent = %s AND comment_approved != 'trash' AND ( comment_author = %s \",\n\t\twp_unslash( $commentdata['comment_post_ID'] ),\n\t\twp_unslash( $commentdata['comment_parent'] ),\n\t\twp_unslash( $commentdata['comment_author'] )\n\t);\n\tif ( $commentdata['comment_author_email'] ) {\n\t\t$dupe .= $wpdb->prepare(\n\t\t\t'AND comment_author_email = %s ',\n\t\t\twp_unslash( $commentdata['comment_author_email'] )\n\t\t);\n\t}\n\t$dupe .= $wpdb->prepare(\n\t\t') AND comment_content = %s LIMIT 1',\n\t\twp_unslash( $commentdata['comment_content'] )\n\t);\n\n\t$dupe_id = $wpdb->get_var( $dupe );\n\n\t/**\n\t * Filters the ID, if any, of the duplicate comment found when creating a new comment.\n\t *\n\t * Return an empty value from this filter to allow what WP considers a duplicate comment.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param int   $dupe_id     ID of the comment identified as a duplicate.\n\t * @param array $commentdata Data for the comment being created.\n\t */\n\t$dupe_id = apply_filters( 'duplicate_comment_id', $dupe_id, $commentdata );\n\n\tif ( $dupe_id ) {\n\t\t/**\n\t\t * Fires immediately after a duplicate comment is detected.\n\t\t *\n\t\t * @since 3.0.0\n\t\t *\n\t\t * @param array $commentdata Comment data.\n\t\t */\n\t\tdo_action( 'comment_duplicate_trigger', $commentdata );\n\t\tif ( true === $avoid_die ) {\n\t\t\treturn new WP_Error( 'comment_duplicate', __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ), 409 );\n\t\t} else {\n\t\t\tif ( wp_doing_ajax() ) {\n\t\t\t\tdie( __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ) );\n\t\t\t}\n\n\t\t\twp_die( __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ), 409 );\n\t\t}\n\t}\n\n\t/**\n\t * Fires immediately before a comment is marked approved.\n\t *\n\t * Allows checking for comment flooding.\n\t *\n\t * @since 2.3.0\n\t * @since 4.7.0 The `$avoid_die` parameter was added.\n\t *\n\t * @param string $comment_author_IP    Comment author's IP address.\n\t * @param string $comment_author_email Comment author's email.\n\t * @param string $comment_date_gmt     GMT date the comment was posted.\n\t * @param bool   $avoid_die            Whether to prevent executing wp_die()\n\t *                                     or die() if a comment flood is occurring.\n\t */\n\tdo_action(\n\t\t'check_comment_flood',\n\t\t$commentdata['comment_author_IP'],\n\t\t$commentdata['comment_author_email'],\n\t\t$commentdata['comment_date_gmt'],\n\t\t$avoid_die\n\t);\n\n\t/**\n\t * Filters whether a comment is part of a comment flood.\n\t *\n\t * The default check is wp_check_comment_flood(). See check_comment_flood_db().\n\t *\n\t * @since 4.7.0\n\t *\n\t * @param bool   $is_flood             Is a comment flooding occurring? Default false.\n\t * @param string $comment_author_IP    Comment author's IP address.\n\t * @param string $comment_author_email Comment author's email.\n\t * @param string $comment_date_gmt     GMT date the comment was posted.\n\t * @param bool   $avoid_die            Whether to prevent executing wp_die()\n\t *                                     or die() if a comment flood is occurring.\n\t */\n\t$is_flood = apply_filters(\n\t\t'wp_is_comment_flood',\n\t\tfalse,\n\t\t$commentdata['comment_author_IP'],\n\t\t$commentdata['comment_author_email'],\n\t\t$commentdata['comment_date_gmt'],\n\t\t$avoid_die\n\t);\n\n\tif ( $is_flood ) {\n\t\treturn new WP_Error( 'comment_flood', __( 'You are posting comments too quickly. Slow down.' ), 429 );\n\t}\n\n\tif ( ! empty( $commentdata['user_id'] ) ) {\n\t\t$user        = get_userdata( $commentdata['user_id'] );\n\t\t$post_author = $wpdb->get_var(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"SELECT post_author FROM $wpdb->posts WHERE ID = %d LIMIT 1\",\n\t\t\t\t$commentdata['comment_post_ID']\n\t\t\t)\n\t\t);\n\t}\n\n\tif ( isset( $user ) && ( $commentdata['user_id'] == $post_author || $user->has_cap( 'moderate_comments' ) ) ) {\n\t\t// The author and the admins get respect.\n\t\t$approved = 1;\n\t} else {\n\t\t// Everyone else's comments will be checked.\n\t\tif ( check_comment(\n\t\t\t$commentdata['comment_author'],\n\t\t\t$commentdata['comment_author_email'],\n\t\t\t$commentdata['comment_author_url'],\n\t\t\t$commentdata['comment_content'],\n\t\t\t$commentdata['comment_author_IP'],\n\t\t\t$commentdata['comment_agent'],\n\t\t\t$commentdata['comment_type']\n\t\t) ) {\n\t\t\t$approved = 1;\n\t\t} else {\n\t\t\t$approved = 0;\n\t\t}\n\n\t\tif ( wp_blacklist_check(\n\t\t\t$commentdata['comment_author'],\n\t\t\t$commentdata['comment_author_email'],\n\t\t\t$commentdata['comment_author_url'],\n\t\t\t$commentdata['comment_content'],\n\t\t\t$commentdata['comment_author_IP'],\n\t\t\t$commentdata['comment_agent']\n\t\t) ) {\n\t\t\t$approved = EMPTY_TRASH_DAYS ? 'trash' : 'spam';\n\t\t}\n\t}\n\n\t/**\n\t * Filters a comment's approval status before it is set.\n\t *\n\t * @since 2.1.0\n\t * @since 4.9.0 Returning a WP_Error value from the filter will shortcircuit comment insertion and\n\t *              allow skipping further processing.\n\t *\n\t * @param bool|string|WP_Error $approved    The approval status. Accepts 1, 0, 'spam' or WP_Error.\n\t * @param array                $commentdata Comment data.\n\t */\n\t$approved = apply_filters( 'pre_comment_approved', $approved, $commentdata );\n\treturn $approved;\n}\n\n/**\n * Hooks WP's native database-based comment-flood check.\n *\n * This wrapper maintains backward compatibility with plugins that expect to\n * be able to unhook the legacy check_comment_flood_db() function from\n * 'check_comment_flood' using remove_action().\n *\n * @since 2.3.0\n * @since 4.7.0 Converted to be an add_filter() wrapper.\n */\nfunction check_comment_flood_db() {\n\tadd_filter( 'wp_is_comment_flood', 'wp_check_comment_flood', 10, 5 );\n}\n\n/**\n * Checks whether comment flooding is occurring.\n *\n * Won't run, if current user can manage options, so to not block\n * administrators.\n *\n * @since 4.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param bool   $is_flood  Is a comment flooding occurring?\n * @param string $ip        Comment author's IP address.\n * @param string $email     Comment author's email address.\n * @param string $date      MySQL time string.\n * @param bool   $avoid_die When true, a disallowed comment will result in the function\n *                          returning a WP_Error object, rather than executing wp_die().\n *                          Default false.\n * @return bool Whether comment flooding is occurring.\n */\nfunction wp_check_comment_flood( $is_flood, $ip, $email, $date, $avoid_die = false ) {\n\n\tglobal $wpdb;\n\n\t// Another callback has declared a flood. Trust it.\n\tif ( true === $is_flood ) {\n\t\treturn $is_flood;\n\t}\n\n\t// don't throttle admins or moderators\n\tif ( current_user_can( 'manage_options' ) || current_user_can( 'moderate_comments' ) ) {\n\t\treturn false;\n\t}\n\t$hour_ago = gmdate( 'Y-m-d H:i:s', time() - HOUR_IN_SECONDS );\n\n\tif ( is_user_logged_in() ) {\n\t\t$user         = get_current_user_id();\n\t\t$check_column = '`user_id`';\n\t} else {\n\t\t$user         = $ip;\n\t\t$check_column = '`comment_author_IP`';\n\t}\n\n\t$sql      = $wpdb->prepare(\n\t\t\"SELECT `comment_date_gmt` FROM `$wpdb->comments` WHERE `comment_date_gmt` >= %s AND ( $check_column = %s OR `comment_author_email` = %s ) ORDER BY `comment_date_gmt` DESC LIMIT 1\",\n\t\t$hour_ago,\n\t\t$user,\n\t\t$email\n\t);\n\t$lasttime = $wpdb->get_var( $sql );\n\tif ( $lasttime ) {\n\t\t$time_lastcomment = mysql2date( 'U', $lasttime, false );\n\t\t$time_newcomment  = mysql2date( 'U', $date, false );\n\t\t/**\n\t\t * Filters the comment flood status.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param bool $bool             Whether a comment flood is occurring. Default false.\n\t\t * @param int  $time_lastcomment Timestamp of when the last comment was posted.\n\t\t * @param int  $time_newcomment  Timestamp of when the new comment was posted.\n\t\t */\n\t\t$flood_die = apply_filters( 'comment_flood_filter', false, $time_lastcomment, $time_newcomment );\n\t\tif ( $flood_die ) {\n\t\t\t/**\n\t\t\t * Fires before the comment flood message is triggered.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param int $time_lastcomment Timestamp of when the last comment was posted.\n\t\t\t * @param int $time_newcomment  Timestamp of when the new comment was posted.\n\t\t\t */\n\t\t\tdo_action( 'comment_flood_trigger', $time_lastcomment, $time_newcomment );\n\t\t\tif ( true === $avoid_die ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif ( wp_doing_ajax() ) {\n\t\t\t\t\tdie( __( 'You are posting comments too quickly. Slow down.' ) );\n\t\t\t\t}\n\n\t\t\t\twp_die( __( 'You are posting comments too quickly. Slow down.' ), 429 );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Separates an array of comments into an array keyed by comment_type.\n *\n * @since 2.7.0\n *\n * @param WP_Comment[] $comments Array of comments\n * @return WP_Comment[] Array of comments keyed by comment_type.\n */\nfunction separate_comments( &$comments ) {\n\t$comments_by_type = array(\n\t\t'comment'   => array(),\n\t\t'trackback' => array(),\n\t\t'pingback'  => array(),\n\t\t'pings'     => array(),\n\t);\n\t$count            = count( $comments );\n\tfor ( $i = 0; $i < $count; $i++ ) {\n\t\t$type = $comments[ $i ]->comment_type;\n\t\tif ( empty( $type ) ) {\n\t\t\t$type = 'comment';\n\t\t}\n\t\t$comments_by_type[ $type ][] = &$comments[ $i ];\n\t\tif ( 'trackback' == $type || 'pingback' == $type ) {\n\t\t\t$comments_by_type['pings'][] = &$comments[ $i ];\n\t\t}\n\t}\n\n\treturn $comments_by_type;\n}\n\n/**\n * Calculate the total number of comment pages.\n *\n * @since 2.7.0\n *\n * @uses Walker_Comment\n *\n * @global WP_Query $wp_query\n *\n * @param WP_Comment[] $comments Optional. Array of WP_Comment objects. Defaults to $wp_query->comments.\n * @param int          $per_page Optional. Comments per page.\n * @param bool         $threaded Optional. Control over flat or threaded comments.\n * @return int Number of comment pages.\n */\nfunction get_comment_pages_count( $comments = null, $per_page = null, $threaded = null ) {\n\tglobal $wp_query;\n\n\tif ( null === $comments && null === $per_page && null === $threaded && ! empty( $wp_query->max_num_comment_pages ) ) {\n\t\treturn $wp_query->max_num_comment_pages;\n\t}\n\n\tif ( ( ! $comments || ! is_array( $comments ) ) && ! empty( $wp_query->comments ) ) {\n\t\t$comments = $wp_query->comments;\n\t}\n\n\tif ( empty( $comments ) ) {\n\t\treturn 0;\n\t}\n\n\tif ( ! get_option( 'page_comments' ) ) {\n\t\treturn 1;\n\t}\n\n\tif ( ! isset( $per_page ) ) {\n\t\t$per_page = (int) get_query_var( 'comments_per_page' );\n\t}\n\tif ( 0 === $per_page ) {\n\t\t$per_page = (int) get_option( 'comments_per_page' );\n\t}\n\tif ( 0 === $per_page ) {\n\t\treturn 1;\n\t}\n\n\tif ( ! isset( $threaded ) ) {\n\t\t$threaded = get_option( 'thread_comments' );\n\t}\n\n\tif ( $threaded ) {\n\t\t$walker = new Walker_Comment;\n\t\t$count  = ceil( $walker->get_number_of_root_elements( $comments ) / $per_page );\n\t} else {\n\t\t$count = ceil( count( $comments ) / $per_page );\n\t}\n\n\treturn $count;\n}\n\n/**\n * Calculate what page number a comment will appear on for comment paging.\n *\n * @since 2.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int   $comment_ID Comment ID.\n * @param array $args {\n *      Array of optional arguments.\n *      @type string     $type      Limit paginated comments to those matching a given type. Accepts 'comment',\n *                                  'trackback', 'pingback', 'pings' (trackbacks and pingbacks), or 'all'.\n *                                  Default is 'all'.\n *      @type int        $per_page  Per-page count to use when calculating pagination. Defaults to the value of the\n *                                  'comments_per_page' option.\n *      @type int|string $max_depth If greater than 1, comment page will be determined for the top-level parent of\n *                                  `$comment_ID`. Defaults to the value of the 'thread_comments_depth' option.\n * } *\n * @return int|null Comment page number or null on error.\n */\nfunction get_page_of_comment( $comment_ID, $args = array() ) {\n\tglobal $wpdb;\n\n\t$page = null;\n\n\tif ( ! $comment = get_comment( $comment_ID ) ) {\n\t\treturn;\n\t}\n\n\t$defaults      = array(\n\t\t'type'      => 'all',\n\t\t'page'      => '',\n\t\t'per_page'  => '',\n\t\t'max_depth' => '',\n\t);\n\t$args          = wp_parse_args( $args, $defaults );\n\t$original_args = $args;\n\n\t// Order of precedence: 1. `$args['per_page']`, 2. 'comments_per_page' query_var, 3. 'comments_per_page' option.\n\tif ( get_option( 'page_comments' ) ) {\n\t\tif ( '' === $args['per_page'] ) {\n\t\t\t$args['per_page'] = get_query_var( 'comments_per_page' );\n\t\t}\n\n\t\tif ( '' === $args['per_page'] ) {\n\t\t\t$args['per_page'] = get_option( 'comments_per_page' );\n\t\t}\n\t}\n\n\tif ( empty( $args['per_page'] ) ) {\n\t\t$args['per_page'] = 0;\n\t\t$args['page']     = 0;\n\t}\n\n\tif ( $args['per_page'] < 1 ) {\n\t\t$page = 1;\n\t}\n\n\tif ( null === $page ) {\n\t\tif ( '' === $args['max_depth'] ) {\n\t\t\tif ( get_option( 'thread_comments' ) ) {\n\t\t\t\t$args['max_depth'] = get_option( 'thread_comments_depth' );\n\t\t\t} else {\n\t\t\t\t$args['max_depth'] = -1;\n\t\t\t}\n\t\t}\n\n\t\t// Find this comment's top level parent if threading is enabled\n\t\tif ( $args['max_depth'] > 1 && 0 != $comment->comment_parent ) {\n\t\t\treturn get_page_of_comment( $comment->comment_parent, $args );\n\t\t}\n\n\t\t$comment_args = array(\n\t\t\t'type'       => $args['type'],\n\t\t\t'post_id'    => $comment->comment_post_ID,\n\t\t\t'fields'     => 'ids',\n\t\t\t'count'      => true,\n\t\t\t'status'     => 'approve',\n\t\t\t'parent'     => 0,\n\t\t\t'date_query' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'column' => \"$wpdb->comments.comment_date_gmt\",\n\t\t\t\t\t'before' => $comment->comment_date_gmt,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$comment_query       = new WP_Comment_Query();\n\t\t$older_comment_count = $comment_query->query( $comment_args );\n\n\t\t// No older comments? Then it's page #1.\n\t\tif ( 0 == $older_comment_count ) {\n\t\t\t$page = 1;\n\n\t\t\t// Divide comments older than this one by comments per page to get this comment's page number\n\t\t} else {\n\t\t\t$page = ceil( ( $older_comment_count + 1 ) / $args['per_page'] );\n\t\t}\n\t}\n\n\t/**\n\t * Filters the calculated page on which a comment appears.\n\t *\n\t * @since 4.4.0\n\t * @since 4.7.0 Introduced the `$comment_ID` parameter.\n\t *\n\t * @param int   $page          Comment page.\n\t * @param array $args {\n\t *     Arguments used to calculate pagination. These include arguments auto-detected by the function,\n\t *     based on query vars, system settings, etc. For pristine arguments passed to the function,\n\t *     see `$original_args`.\n\t *\n\t *     @type string $type      Type of comments to count.\n\t *     @type int    $page      Calculated current page.\n\t *     @type int    $per_page  Calculated number of comments per page.\n\t *     @type int    $max_depth Maximum comment threading depth allowed.\n\t * }\n\t * @param array $original_args {\n\t *     Array of arguments passed to the function. Some or all of these may not be set.\n\t *\n\t *     @type string $type      Type of comments to count.\n\t *     @type int    $page      Current comment page.\n\t *     @type int    $per_page  Number of comments per page.\n\t *     @type int    $max_depth Maximum comment threading depth allowed.\n\t * }\n\t * @param int $comment_ID ID of the comment.\n\t */\n\treturn apply_filters( 'get_page_of_comment', (int) $page, $args, $original_args, $comment_ID );\n}\n\n/**\n * Retrieves the maximum character lengths for the comment form fields.\n *\n * @since 4.5.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @return array Maximum character length for the comment form fields.\n */\nfunction wp_get_comment_fields_max_lengths() {\n\tglobal $wpdb;\n\n\t$lengths = array(\n\t\t'comment_author'       => 245,\n\t\t'comment_author_email' => 100,\n\t\t'comment_author_url'   => 200,\n\t\t'comment_content'      => 65525,\n\t);\n\n\tif ( $wpdb->is_mysql ) {\n\t\tforeach ( $lengths as $column => $length ) {\n\t\t\t$col_length = $wpdb->get_col_length( $wpdb->comments, $column );\n\t\t\t$max_length = 0;\n\n\t\t\t// No point if we can't get the DB column lengths\n\t\t\tif ( is_wp_error( $col_length ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( ! is_array( $col_length ) && (int) $col_length > 0 ) {\n\t\t\t\t$max_length = (int) $col_length;\n\t\t\t} elseif ( is_array( $col_length ) && isset( $col_length['length'] ) && intval( $col_length['length'] ) > 0 ) {\n\t\t\t\t$max_length = (int) $col_length['length'];\n\n\t\t\t\tif ( ! empty( $col_length['type'] ) && 'byte' === $col_length['type'] ) {\n\t\t\t\t\t$max_length = $max_length - 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $max_length > 0 ) {\n\t\t\t\t$lengths[ $column ] = $max_length;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filters the lengths for the comment form fields.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @param array $lengths Associative array `'field_name' => 'maximum length'`.\n\t */\n\treturn apply_filters( 'wp_get_comment_fields_max_lengths', $lengths );\n}\n\n/**\n * Compares the lengths of comment data against the maximum character limits.\n *\n * @since 4.7.0\n *\n * @param array $comment_data Array of arguments for inserting a comment.\n * @return WP_Error|true WP_Error when a comment field exceeds the limit,\n *                       otherwise true.\n */\nfunction wp_check_comment_data_max_lengths( $comment_data ) {\n\t$max_lengths = wp_get_comment_fields_max_lengths();\n\n\tif ( isset( $comment_data['comment_author'] ) && mb_strlen( $comment_data['comment_author'], '8bit' ) > $max_lengths['comment_author'] ) {\n\t\treturn new WP_Error( 'comment_author_column_length', __( '<strong>ERROR</strong>: your name is too long.' ), 200 );\n\t}\n\n\tif ( isset( $comment_data['comment_author_email'] ) && strlen( $comment_data['comment_author_email'] ) > $max_lengths['comment_author_email'] ) {\n\t\treturn new WP_Error( 'comment_author_email_column_length', __( '<strong>ERROR</strong>: your email address is too long.' ), 200 );\n\t}\n\n\tif ( isset( $comment_data['comment_author_url'] ) && strlen( $comment_data['comment_author_url'] ) > $max_lengths['comment_author_url'] ) {\n\t\treturn new WP_Error( 'comment_author_url_column_length', __( '<strong>ERROR</strong>: your url is too long.' ), 200 );\n\t}\n\n\tif ( isset( $comment_data['comment_content'] ) && mb_strlen( $comment_data['comment_content'], '8bit' ) > $max_lengths['comment_content'] ) {\n\t\treturn new WP_Error( 'comment_content_column_length', __( '<strong>ERROR</strong>: your comment is too long.' ), 200 );\n\t}\n\n\treturn true;\n}\n\n/**\n * Does comment contain blacklisted characters or words.\n *\n * @since 1.5.0\n *\n * @param string $author The author of the comment\n * @param string $email The email of the comment\n * @param string $url The url used in the comment\n * @param string $comment The comment content\n * @param string $user_ip The comment author's IP address\n * @param string $user_agent The author's browser user agent\n * @return bool True if comment contains blacklisted content, false if comment does not\n */\nfunction wp_blacklist_check( $author, $email, $url, $comment, $user_ip, $user_agent ) {\n\t/**\n\t * Fires before the comment is tested for blacklisted characters or words.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $author     Comment author.\n\t * @param string $email      Comment author's email.\n\t * @param string $url        Comment author's URL.\n\t * @param string $comment    Comment content.\n\t * @param string $user_ip    Comment author's IP address.\n\t * @param string $user_agent Comment author's browser user agent.\n\t */\n\tdo_action( 'wp_blacklist_check', $author, $email, $url, $comment, $user_ip, $user_agent );\n\n\t$mod_keys = trim( get_option( 'blacklist_keys' ) );\n\tif ( '' == $mod_keys ) {\n\t\treturn false; // If moderation keys are empty\n\t}\n\n\t// Ensure HTML tags are not being used to bypass the blacklist.\n\t$comment_without_html = wp_strip_all_tags( $comment );\n\n\t$words = explode( \"\\n\", $mod_keys );\n\n\tforeach ( (array) $words as $word ) {\n\t\t$word = trim( $word );\n\n\t\t// Skip empty lines\n\t\tif ( empty( $word ) ) {\n\t\t\tcontinue; }\n\n\t\t// Do some escaping magic so that '#' chars in the\n\t\t// spam words don't break things:\n\t\t$word = preg_quote( $word, '#' );\n\n\t\t$pattern = \"#$word#i\";\n\t\tif ( preg_match( $pattern, $author )\n\t\t\t|| preg_match( $pattern, $email )\n\t\t\t|| preg_match( $pattern, $url )\n\t\t\t|| preg_match( $pattern, $comment )\n\t\t\t|| preg_match( $pattern, $comment_without_html )\n\t\t\t|| preg_match( $pattern, $user_ip )\n\t\t\t|| preg_match( $pattern, $user_agent )\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Retrieve total comments for blog or single post.\n *\n * The properties of the returned object contain the 'moderated', 'approved',\n * and spam comments for either the entire blog or single post. Those properties\n * contain the amount of comments that match the status. The 'total_comments'\n * property contains the integer of total comments.\n *\n * The comment stats are cached and then retrieved, if they already exist in the\n * cache.\n *\n * @since 2.5.0\n *\n * @param int $post_id Optional. Post ID.\n * @return object|array Comment stats.\n */\nfunction wp_count_comments( $post_id = 0 ) {\n\t$post_id = (int) $post_id;\n\n\t/**\n\t * Filters the comments count for a given post.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array $count   An empty array.\n\t * @param int   $post_id The post ID.\n\t */\n\t$filtered = apply_filters( 'wp_count_comments', array(), $post_id );\n\tif ( ! empty( $filtered ) ) {\n\t\treturn $filtered;\n\t}\n\n\t$count = wp_cache_get( \"comments-{$post_id}\", 'counts' );\n\tif ( false !== $count ) {\n\t\treturn $count;\n\t}\n\n\t$stats              = get_comment_count( $post_id );\n\t$stats['moderated'] = $stats['awaiting_moderation'];\n\tunset( $stats['awaiting_moderation'] );\n\n\t$stats_object = (object) $stats;\n\twp_cache_set( \"comments-{$post_id}\", $stats_object, 'counts' );\n\n\treturn $stats_object;\n}\n\n/**\n * Trashes or deletes a comment.\n *\n * The comment is moved to trash instead of permanently deleted unless trash is\n * disabled, item is already in the trash, or $force_delete is true.\n *\n * The post comment count will be updated if the comment was approved and has a\n * post ID available.\n *\n * @since 2.0.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int|WP_Comment $comment_id   Comment ID or WP_Comment object.\n * @param bool           $force_delete Whether to bypass trash and force deletion. Default is false.\n * @return bool True on success, false on failure.\n */\nfunction wp_delete_comment( $comment_id, $force_delete = false ) {\n\tglobal $wpdb;\n\tif ( ! $comment = get_comment( $comment_id ) ) {\n\t\treturn false;\n\t}\n\n\tif ( ! $force_delete && EMPTY_TRASH_DAYS && ! in_array( wp_get_comment_status( $comment ), array( 'trash', 'spam' ) ) ) {\n\t\treturn wp_trash_comment( $comment_id );\n\t}\n\n\t/**\n\t * Fires immediately before a comment is deleted from the database.\n\t *\n\t * @since 1.2.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be deleted.\n\t */\n\tdo_action( 'delete_comment', $comment->comment_ID, $comment );\n\n\t// Move children up a level.\n\t$children = $wpdb->get_col( $wpdb->prepare( \"SELECT comment_ID FROM $wpdb->comments WHERE comment_parent = %d\", $comment->comment_ID ) );\n\tif ( ! empty( $children ) ) {\n\t\t$wpdb->update( $wpdb->comments, array( 'comment_parent' => $comment->comment_parent ), array( 'comment_parent' => $comment->comment_ID ) );\n\t\tclean_comment_cache( $children );\n\t}\n\n\t// Delete metadata\n\t$meta_ids = $wpdb->get_col( $wpdb->prepare( \"SELECT meta_id FROM $wpdb->commentmeta WHERE comment_id = %d\", $comment->comment_ID ) );\n\tforeach ( $meta_ids as $mid ) {\n\t\tdelete_metadata_by_mid( 'comment', $mid );\n\t}\n\n\tif ( ! $wpdb->delete( $wpdb->comments, array( 'comment_ID' => $comment->comment_ID ) ) ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately after a comment is deleted from the database.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The deleted comment.\n\t */\n\tdo_action( 'deleted_comment', $comment->comment_ID, $comment );\n\n\t$post_id = $comment->comment_post_ID;\n\tif ( $post_id && $comment->comment_approved == 1 ) {\n\t\twp_update_comment_count( $post_id );\n\t}\n\n\tclean_comment_cache( $comment->comment_ID );\n\n\t/** This action is documented in wp-includes/comment.php */\n\tdo_action( 'wp_set_comment_status', $comment->comment_ID, 'delete' );\n\n\twp_transition_comment_status( 'delete', $comment->comment_approved, $comment );\n\treturn true;\n}\n\n/**\n * Moves a comment to the Trash\n *\n * If trash is disabled, comment is permanently deleted.\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_trash_comment( $comment_id ) {\n\tif ( ! EMPTY_TRASH_DAYS ) {\n\t\treturn wp_delete_comment( $comment_id, true );\n\t}\n\n\tif ( ! $comment = get_comment( $comment_id ) ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is sent to the Trash.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be trashed.\n\t */\n\tdo_action( 'trash_comment', $comment->comment_ID, $comment );\n\n\tif ( wp_set_comment_status( $comment, 'trash' ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', $comment->comment_approved );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_time', time() );\n\n\t\t/**\n\t\t * Fires immediately after a comment is sent to Trash.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The trashed comment.\n\t\t */\n\t\tdo_action( 'trashed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Removes a comment from the Trash\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_untrash_comment( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is restored from the Trash.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be untrashed.\n\t */\n\tdo_action( 'untrash_comment', $comment->comment_ID, $comment );\n\n\t$status = (string) get_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', true );\n\tif ( empty( $status ) ) {\n\t\t$status = '0';\n\t}\n\n\tif ( wp_set_comment_status( $comment, $status ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\t/**\n\t\t * Fires immediately after a comment is restored from the Trash.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The untrashed comment.\n\t\t */\n\t\tdo_action( 'untrashed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Marks a comment as Spam\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_spam_comment( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is marked as Spam.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be marked as spam.\n\t */\n\tdo_action( 'spam_comment', $comment->comment_ID, $comment );\n\n\tif ( wp_set_comment_status( $comment, 'spam' ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', $comment->comment_approved );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_time', time() );\n\t\t/**\n\t\t * Fires immediately after a comment is marked as Spam.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The comment marked as spam.\n\t\t */\n\t\tdo_action( 'spammed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Removes a comment from the Spam\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_unspam_comment( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is unmarked as Spam.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be unmarked as spam.\n\t */\n\tdo_action( 'unspam_comment', $comment->comment_ID, $comment );\n\n\t$status = (string) get_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', true );\n\tif ( empty( $status ) ) {\n\t\t$status = '0';\n\t}\n\n\tif ( wp_set_comment_status( $comment, $status ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\t/**\n\t\t * Fires immediately after a comment is unmarked as Spam.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The comment unmarked as spam.\n\t\t */\n\t\tdo_action( 'unspammed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * The status of a comment by ID.\n *\n * @since 1.0.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object\n * @return false|string Status might be 'trash', 'approved', 'unapproved', 'spam'. False on failure.\n */\nfunction wp_get_comment_status( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t$approved = $comment->comment_approved;\n\n\tif ( $approved == null ) {\n\t\treturn false;\n\t} elseif ( $approved == '1' ) {\n\t\treturn 'approved';\n\t} elseif ( $approved == '0' ) {\n\t\treturn 'unapproved';\n\t} elseif ( $approved == 'spam' ) {\n\t\treturn 'spam';\n\t} elseif ( $approved == 'trash' ) {\n\t\treturn 'trash';\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Call hooks for when a comment status transition occurs.\n *\n * Calls hooks for comment status transitions. If the new comment status is not the same\n * as the previous comment status, then two hooks will be ran, the first is\n * {@see 'transition_comment_status'} with new status, old status, and comment data. The\n * next action called is {@see comment_$old_status_to_$new_status'}. It has the\n * comment data.\n *\n * The final action will run whether or not the comment statuses are the same. The\n * action is named {@see 'comment_$new_status_$comment->comment_type'}.\n *\n * @since 2.7.0\n *\n * @param string $new_status New comment status.\n * @param string $old_status Previous comment status.\n * @param object $comment Comment data.\n */\nfunction wp_transition_comment_status( $new_status, $old_status, $comment ) {\n\t/*\n\t * Translate raw statuses to human readable formats for the hooks.\n\t * This is not a complete list of comment status, it's only the ones\n\t * that need to be renamed\n\t */\n\t$comment_statuses = array(\n\t\t0         => 'unapproved',\n\t\t'hold'    => 'unapproved', // wp_set_comment_status() uses \"hold\"\n\t\t1         => 'approved',\n\t\t'approve' => 'approved', // wp_set_comment_status() uses \"approve\"\n\t);\n\tif ( isset( $comment_statuses[ $new_status ] ) ) {\n\t\t$new_status = $comment_statuses[ $new_status ];\n\t}\n\tif ( isset( $comment_statuses[ $old_status ] ) ) {\n\t\t$old_status = $comment_statuses[ $old_status ];\n\t}\n\n\t// Call the hooks\n\tif ( $new_status != $old_status ) {\n\t\t/**\n\t\t * Fires when the comment status is in transition.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param int|string $new_status The new comment status.\n\t\t * @param int|string $old_status The old comment status.\n\t\t * @param object     $comment    The comment data.\n\t\t */\n\t\tdo_action( 'transition_comment_status', $new_status, $old_status, $comment );\n\t\t/**\n\t\t * Fires when the comment status is in transition from one specific status to another.\n\t\t *\n\t\t * The dynamic portions of the hook name, `$old_status`, and `$new_status`,\n\t\t * refer to the old and new comment statuses, respectively.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param WP_Comment $comment Comment object.\n\t\t */\n\t\tdo_action( \"comment_{$old_status}_to_{$new_status}\", $comment );\n\t}\n\t/**\n\t * Fires when the status of a specific comment type is in transition.\n\t *\n\t * The dynamic portions of the hook name, `$new_status`, and `$comment->comment_type`,\n\t * refer to the new comment status, and the type of comment, respectively.\n\t *\n\t * Typical comment types include an empty string (standard comment), 'pingback',\n\t * or 'trackback'.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param int        $comment_ID The comment ID.\n\t * @param WP_Comment $comment    Comment object.\n\t */\n\tdo_action( \"comment_{$new_status}_{$comment->comment_type}\", $comment->comment_ID, $comment );\n}\n\n/**\n * Clear the lastcommentmodified cached value when a comment status is changed.\n *\n * Deletes the lastcommentmodified cache key when a comment enters or leaves\n * 'approved' status.\n *\n * @since 4.7.0\n * @access private\n *\n * @param string $new_status The new comment status.\n * @param string $old_status The old comment status.\n */\nfunction _clear_modified_cache_on_transition_comment_status( $new_status, $old_status ) {\n\tif ( 'approved' === $new_status || 'approved' === $old_status ) {\n\t\tforeach ( array( 'server', 'gmt', 'blog' ) as $timezone ) {\n\t\t\twp_cache_delete( \"lastcommentmodified:$timezone\", 'timeinfo' );\n\t\t}\n\t}\n}\n\n/**\n * Get current commenter's name, email, and URL.\n *\n * Expects cookies content to already be sanitized. User of this function might\n * wish to recheck the returned array for validity.\n *\n * @see sanitize_comment_cookies() Use to sanitize cookies\n *\n * @since 2.0.4\n *\n * @return array Comment author, email, url respectively.\n */\nfunction wp_get_current_commenter() {\n\t// Cookies should already be sanitized.\n\n\t$comment_author = '';\n\tif ( isset( $_COOKIE[ 'comment_author_' . COOKIEHASH ] ) ) {\n\t\t$comment_author = $_COOKIE[ 'comment_author_' . COOKIEHASH ];\n\t}\n\n\t$comment_author_email = '';\n\tif ( isset( $_COOKIE[ 'comment_author_email_' . COOKIEHASH ] ) ) {\n\t\t$comment_author_email = $_COOKIE[ 'comment_author_email_' . COOKIEHASH ];\n\t}\n\n\t$comment_author_url = '';\n\tif ( isset( $_COOKIE[ 'comment_author_url_' . COOKIEHASH ] ) ) {\n\t\t$comment_author_url = $_COOKIE[ 'comment_author_url_' . COOKIEHASH ];\n\t}\n\n\t/**\n\t * Filters the current commenter's name, email, and URL.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array $comment_author_data {\n\t *     An array of current commenter variables.\n\t *\n\t *     @type string $comment_author       The name of the author of the comment. Default empty.\n\t *     @type string $comment_author_email The email address of the `$comment_author`. Default empty.\n\t *     @type string $comment_author_url   The URL address of the `$comment_author`. Default empty.\n\t * }\n\t */\n\treturn apply_filters( 'wp_get_current_commenter', compact( 'comment_author', 'comment_author_email', 'comment_author_url' ) );\n}\n\n/**\n * Get unapproved comment author's email.\n *\n * Used to allow the commenter to see their pending comment.\n *\n * @since 5.1.0\n *\n * @return string The unapproved comment author's email (when supplied).\n */\nfunction wp_get_unapproved_comment_author_email() {\n\t$commenter_email = '';\n\n\tif ( ! empty( $_GET['unapproved'] ) && ! empty( $_GET['moderation-hash'] ) ) {\n\t\t$comment_id = (int) $_GET['unapproved'];\n\t\t$comment    = get_comment( $comment_id );\n\n\t\tif ( $comment && hash_equals( $_GET['moderation-hash'], wp_hash( $comment->comment_date_gmt ) ) ) {\n\t\t\t$commenter_email = $comment->comment_author_email;\n\t\t}\n\t}\n\n\tif ( ! $commenter_email ) {\n\t\t$commenter       = wp_get_current_commenter();\n\t\t$commenter_email = $commenter['comment_author_email'];\n\t}\n\n\treturn $commenter_email;\n}\n\n/**\n * Inserts a comment into the database.\n *\n * @since 2.0.0\n * @since 4.4.0 Introduced `$comment_meta` argument.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentdata {\n *     Array of arguments for inserting a new comment.\n *\n *     @type string     $comment_agent        The HTTP user agent of the `$comment_author` when\n *                                            the comment was submitted. Default empty.\n *     @type int|string $comment_approved     Whether the comment has been approved. Default 1.\n *     @type string     $comment_author       The name of the author of the comment. Default empty.\n *     @type string     $comment_author_email The email address of the `$comment_author`. Default empty.\n *     @type string     $comment_author_IP    The IP address of the `$comment_author`. Default empty.\n *     @type string     $comment_author_url   The URL address of the `$comment_author`. Default empty.\n *     @type string     $comment_content      The content of the comment. Default empty.\n *     @type string     $comment_date         The date the comment was submitted. To set the date\n *                                            manually, `$comment_date_gmt` must also be specified.\n *                                            Default is the current time.\n *     @type string     $comment_date_gmt     The date the comment was submitted in the GMT timezone.\n *                                            Default is `$comment_date` in the site's GMT timezone.\n *     @type int        $comment_karma        The karma of the comment. Default 0.\n *     @type int        $comment_parent       ID of this comment's parent, if any. Default 0.\n *     @type int        $comment_post_ID      ID of the post that relates to the comment, if any.\n *                                            Default 0.\n *     @type string     $comment_type         Comment type. Default empty.\n *     @type array      $comment_meta         Optional. Array of key/value pairs to be stored in commentmeta for the\n *                                            new comment.\n *     @type int        $user_id              ID of the user who submitted the comment. Default 0.\n * }\n * @return int|false The new comment's ID on success, false on failure.\n */\nfunction wp_insert_comment( $commentdata ) {\n\tglobal $wpdb;\n\t$data = wp_unslash( $commentdata );\n\n\t$comment_author       = ! isset( $data['comment_author'] ) ? '' : $data['comment_author'];\n\t$comment_author_email = ! isset( $data['comment_author_email'] ) ? '' : $data['comment_author_email'];\n\t$comment_author_url   = ! isset( $data['comment_author_url'] ) ? '' : $data['comment_author_url'];\n\t$comment_author_IP    = ! isset( $data['comment_author_IP'] ) ? '' : $data['comment_author_IP'];\n\n\t$comment_date     = ! isset( $data['comment_date'] ) ? current_time( 'mysql' ) : $data['comment_date'];\n\t$comment_date_gmt = ! isset( $data['comment_date_gmt'] ) ? get_gmt_from_date( $comment_date ) : $data['comment_date_gmt'];\n\n\t$comment_post_ID  = ! isset( $data['comment_post_ID'] ) ? 0 : $data['comment_post_ID'];\n\t$comment_content  = ! isset( $data['comment_content'] ) ? '' : $data['comment_content'];\n\t$comment_karma    = ! isset( $data['comment_karma'] ) ? 0 : $data['comment_karma'];\n\t$comment_approved = ! isset( $data['comment_approved'] ) ? 1 : $data['comment_approved'];\n\t$comment_agent    = ! isset( $data['comment_agent'] ) ? '' : $data['comment_agent'];\n\t$comment_type     = ! isset( $data['comment_type'] ) ? '' : $data['comment_type'];\n\t$comment_parent   = ! isset( $data['comment_parent'] ) ? 0 : $data['comment_parent'];\n\n\t$user_id = ! isset( $data['user_id'] ) ? 0 : $data['user_id'];\n\n\t$compacted = compact( 'comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_author_IP', 'comment_date', 'comment_date_gmt', 'comment_content', 'comment_karma', 'comment_approved', 'comment_agent', 'comment_type', 'comment_parent', 'user_id' );\n\tif ( ! $wpdb->insert( $wpdb->comments, $compacted ) ) {\n\t\treturn false;\n\t}\n\n\t$id = (int) $wpdb->insert_id;\n\n\tif ( $comment_approved == 1 ) {\n\t\twp_update_comment_count( $comment_post_ID );\n\n\t\tforeach ( array( 'server', 'gmt', 'blog' ) as $timezone ) {\n\t\t\twp_cache_delete( \"lastcommentmodified:$timezone\", 'timeinfo' );\n\t\t}\n\t}\n\n\tclean_comment_cache( $id );\n\n\t$comment = get_comment( $id );\n\n\t// If metadata is provided, store it.\n\tif ( isset( $commentdata['comment_meta'] ) && is_array( $commentdata['comment_meta'] ) ) {\n\t\tforeach ( $commentdata['comment_meta'] as $meta_key => $meta_value ) {\n\t\t\tadd_comment_meta( $comment->comment_ID, $meta_key, $meta_value, true );\n\t\t}\n\t}\n\n\t/**\n\t * Fires immediately after a comment is inserted into the database.\n\t *\n\t * @since 2.8.0\n\t *\n\t * @param int        $id      The comment ID.\n\t * @param WP_Comment $comment Comment object.\n\t */\n\tdo_action( 'wp_insert_comment', $id, $comment );\n\n\treturn $id;\n}\n\n/**\n * Filters and sanitizes comment data.\n *\n * Sets the comment data 'filtered' field to true when finished. This can be\n * checked as to whether the comment should be filtered and to keep from\n * filtering the same comment more than once.\n *\n * @since 2.0.0\n *\n * @param array $commentdata Contains information on the comment.\n * @return array Parsed comment information.\n */\nfunction wp_filter_comment( $commentdata ) {\n\tif ( isset( $commentdata['user_ID'] ) ) {\n\t\t/**\n\t\t * Filters the comment author's user id before it is set.\n\t\t *\n\t\t * The first time this filter is evaluated, 'user_ID' is checked\n\t\t * (for back-compat), followed by the standard 'user_id' value.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param int $user_ID The comment author's user ID.\n\t\t */\n\t\t$commentdata['user_id'] = apply_filters( 'pre_user_id', $commentdata['user_ID'] );\n\t} elseif ( isset( $commentdata['user_id'] ) ) {\n\t\t/** This filter is documented in wp-includes/comment.php */\n\t\t$commentdata['user_id'] = apply_filters( 'pre_user_id', $commentdata['user_id'] );\n\t}\n\n\t/**\n\t * Filters the comment author's browser user agent before it is set.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_agent The comment author's browser user agent.\n\t */\n\t$commentdata['comment_agent'] = apply_filters( 'pre_comment_user_agent', ( isset( $commentdata['comment_agent'] ) ? $commentdata['comment_agent'] : '' ) );\n\t/** This filter is documented in wp-includes/comment.php */\n\t$commentdata['comment_author'] = apply_filters( 'pre_comment_author_name', $commentdata['comment_author'] );\n\t/**\n\t * Filters the comment content before it is set.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_content The comment content.\n\t */\n\t$commentdata['comment_content'] = apply_filters( 'pre_comment_content', $commentdata['comment_content'] );\n\t/**\n\t * Filters the comment author's IP address before it is set.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_author_ip The comment author's IP address.\n\t */\n\t$commentdata['comment_author_IP'] = apply_filters( 'pre_comment_user_ip', $commentdata['comment_author_IP'] );\n\t/** This filter is documented in wp-includes/comment.php */\n\t$commentdata['comment_author_url'] = apply_filters( 'pre_comment_author_url', $commentdata['comment_author_url'] );\n\t/** This filter is documented in wp-includes/comment.php */\n\t$commentdata['comment_author_email'] = apply_filters( 'pre_comment_author_email', $commentdata['comment_author_email'] );\n\t$commentdata['filtered']             = true;\n\treturn $commentdata;\n}\n\n/**\n * Whether a comment should be blocked because of comment flood.\n *\n * @since 2.1.0\n *\n * @param bool $block Whether plugin has already blocked comment.\n * @param int $time_lastcomment Timestamp for last comment.\n * @param int $time_newcomment Timestamp for new comment.\n * @return bool Whether comment should be blocked.\n */\nfunction wp_throttle_comment_flood( $block, $time_lastcomment, $time_newcomment ) {\n\tif ( $block ) { // a plugin has already blocked... we'll let that decision stand\n\t\treturn $block;\n\t}\n\tif ( ( $time_newcomment - $time_lastcomment ) < 15 ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Adds a new comment to the database.\n *\n * Filters new comment to ensure that the fields are sanitized and valid before\n * inserting comment into database. Calls {@see 'comment_post'} action with comment ID\n * and whether comment is approved by WordPress. Also has {@see 'preprocess_comment'}\n * filter for processing the comment data before the function handles it.\n *\n * We use `REMOTE_ADDR` here directly. If you are behind a proxy, you should ensure\n * that it is properly set, such as in wp-config.php, for your environment.\n *\n * See {@link https://core.trac.wordpress.org/ticket/9235}\n *\n * @since 1.5.0\n * @since 4.3.0 'comment_agent' and 'comment_author_IP' can be set via `$commentdata`.\n * @since 4.7.0 The `$avoid_die` parameter was added, allowing the function to\n *              return a WP_Error object instead of dying.\n *\n * @see wp_insert_comment()\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentdata {\n *     Comment data.\n *\n *     @type string $comment_author       The name of the comment author.\n *     @type string $comment_author_email The comment author email address.\n *     @type string $comment_author_url   The comment author URL.\n *     @type string $comment_content      The content of the comment.\n *     @type string $comment_date         The date the comment was submitted. Default is the current time.\n *     @type string $comment_date_gmt     The date the comment was submitted in the GMT timezone.\n *                                        Default is `$comment_date` in the GMT timezone.\n *     @type int    $comment_parent       The ID of this comment's parent, if any. Default 0.\n *     @type int    $comment_post_ID      The ID of the post that relates to the comment.\n *     @type int    $user_id              The ID of the user who submitted the comment. Default 0.\n *     @type int    $user_ID              Kept for backward-compatibility. Use `$user_id` instead.\n *     @type string $comment_agent        Comment author user agent. Default is the value of 'HTTP_USER_AGENT'\n *                                        in the `$_SERVER` superglobal sent in the original request.\n *     @type string $comment_author_IP    Comment author IP address in IPv4 format. Default is the value of\n *                                        'REMOTE_ADDR' in the `$_SERVER` superglobal sent in the original request.\n * }\n * @param bool $avoid_die Should errors be returned as WP_Error objects instead of\n *                        executing wp_die()? Default false.\n * @return int|false|WP_Error The ID of the comment on success, false or WP_Error on failure.\n */\nfunction wp_new_comment( $commentdata, $avoid_die = false ) {\n\tglobal $wpdb;\n\n\tif ( isset( $commentdata['user_ID'] ) ) {\n\t\t$commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];\n\t}\n\n\t$prefiltered_user_id = ( isset( $commentdata['user_id'] ) ) ? (int) $commentdata['user_id'] : 0;\n\n\t/**\n\t * Filters a comment's data before it is sanitized and inserted into the database.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array $commentdata Comment data.\n\t */\n\t$commentdata = apply_filters( 'preprocess_comment', $commentdata );\n\n\t$commentdata['comment_post_ID'] = (int) $commentdata['comment_post_ID'];\n\tif ( isset( $commentdata['user_ID'] ) && $prefiltered_user_id !== (int) $commentdata['user_ID'] ) {\n\t\t$commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];\n\t} elseif ( isset( $commentdata['user_id'] ) ) {\n\t\t$commentdata['user_id'] = (int) $commentdata['user_id'];\n\t}\n\n\t$commentdata['comment_parent'] = isset( $commentdata['comment_parent'] ) ? absint( $commentdata['comment_parent'] ) : 0;\n\t$parent_status                 = ( 0 < $commentdata['comment_parent'] ) ? wp_get_comment_status( $commentdata['comment_parent'] ) : '';\n\t$commentdata['comment_parent'] = ( 'approved' == $parent_status || 'unapproved' == $parent_status ) ? $commentdata['comment_parent'] : 0;\n\n\tif ( ! isset( $commentdata['comment_author_IP'] ) ) {\n\t\t$commentdata['comment_author_IP'] = $_SERVER['REMOTE_ADDR'];\n\t}\n\t$commentdata['comment_author_IP'] = preg_replace( '/[^0-9a-fA-F:., ]/', '', $commentdata['comment_author_IP'] );\n\n\tif ( ! isset( $commentdata['comment_agent'] ) ) {\n\t\t$commentdata['comment_agent'] = isset( $_SERVER['HTTP_USER_AGENT'] ) ? $_SERVER['HTTP_USER_AGENT'] : '';\n\t}\n\t$commentdata['comment_agent'] = substr( $commentdata['comment_agent'], 0, 254 );\n\n\tif ( empty( $commentdata['comment_date'] ) ) {\n\t\t$commentdata['comment_date'] = current_time( 'mysql' );\n\t}\n\n\tif ( empty( $commentdata['comment_date_gmt'] ) ) {\n\t\t$commentdata['comment_date_gmt'] = current_time( 'mysql', 1 );\n\t}\n\n\t$commentdata = wp_filter_comment( $commentdata );\n\n\t$commentdata['comment_approved'] = wp_allow_comment( $commentdata, $avoid_die );\n\tif ( is_wp_error( $commentdata['comment_approved'] ) ) {\n\t\treturn $commentdata['comment_approved'];\n\t}\n\n\t$comment_ID = wp_insert_comment( $commentdata );\n\tif ( ! $comment_ID ) {\n\t\t$fields = array( 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_content' );\n\n\t\tforeach ( $fields as $field ) {\n\t\t\tif ( isset( $commentdata[ $field ] ) ) {\n\t\t\t\t$commentdata[ $field ] = $wpdb->strip_invalid_text_for_column( $wpdb->comments, $field, $commentdata[ $field ] );\n\t\t\t}\n\t\t}\n\n\t\t$commentdata = wp_filter_comment( $commentdata );\n\n\t\t$commentdata['comment_approved'] = wp_allow_comment( $commentdata, $avoid_die );\n\t\tif ( is_wp_error( $commentdata['comment_approved'] ) ) {\n\t\t\treturn $commentdata['comment_approved'];\n\t\t}\n\n\t\t$comment_ID = wp_insert_comment( $commentdata );\n\t\tif ( ! $comment_ID ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Fires immediately after a comment is inserted into the database.\n\t *\n\t * @since 1.2.0\n\t * @since 4.5.0 The `$commentdata` parameter was added.\n\t *\n\t * @param int        $comment_ID       The comment ID.\n\t * @param int|string $comment_approved 1 if the comment is approved, 0 if not, 'spam' if spam.\n\t * @param array      $commentdata      Comment data.\n\t */\n\tdo_action( 'comment_post', $comment_ID, $commentdata['comment_approved'], $commentdata );\n\n\treturn $comment_ID;\n}\n\n/**\n * Send a comment moderation notification to the comment moderator.\n *\n * @since 4.4.0\n *\n * @param int $comment_ID ID of the comment.\n * @return bool True on success, false on failure.\n */\nfunction wp_new_comment_notify_moderator( $comment_ID ) {\n\t$comment = get_comment( $comment_ID );\n\n\t// Only send notifications for pending comments.\n\t$maybe_notify = ( '0' == $comment->comment_approved );\n\n\t/** This filter is documented in wp-includes/comment.php */\n\t$maybe_notify = apply_filters( 'notify_moderator', $maybe_notify, $comment_ID );\n\n\tif ( ! $maybe_notify ) {\n\t\treturn false;\n\t}\n\n\treturn wp_notify_moderator( $comment_ID );\n}\n\n/**\n * Send a notification of a new comment to the post author.\n *\n * @since 4.4.0\n *\n * Uses the {@see 'notify_post_author'} filter to determine whether the post author\n * should be notified when a new comment is added, overriding site setting.\n *\n * @param int $comment_ID Comment ID.\n * @return bool True on success, false on failure.\n */\nfunction wp_new_comment_notify_postauthor( $comment_ID ) {\n\t$comment = get_comment( $comment_ID );\n\n\t$maybe_notify = get_option( 'comments_notify' );\n\n\t/**\n\t * Filters whether to send the post author new comment notification emails,\n\t * overriding the site setting.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param bool $maybe_notify Whether to notify the post author about the new comment.\n\t * @param int  $comment_ID   The ID of the comment for the notification.\n\t */\n\t$maybe_notify = apply_filters( 'notify_post_author', $maybe_notify, $comment_ID );\n\n\t/*\n\t * wp_notify_postauthor() checks if notifying the author of their own comment.\n\t * By default, it won't, but filters can override this.\n\t */\n\tif ( ! $maybe_notify ) {\n\t\treturn false;\n\t}\n\n\t// Only send notifications for approved comments.\n\tif ( ! isset( $comment->comment_approved ) || '1' != $comment->comment_approved ) {\n\t\treturn false;\n\t}\n\n\treturn wp_notify_postauthor( $comment_ID );\n}\n\n/**\n * Sets the status of a comment.\n *\n * The {@see 'wp_set_comment_status'} action is called after the comment is handled.\n * If the comment status is not in the list, then false is returned.\n *\n * @since 1.0.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int|WP_Comment $comment_id     Comment ID or WP_Comment object.\n * @param string         $comment_status New comment status, either 'hold', 'approve', 'spam', or 'trash'.\n * @param bool           $wp_error       Whether to return a WP_Error object if there is a failure. Default is false.\n * @return bool|WP_Error True on success, false or WP_Error on failure.\n */\nfunction wp_set_comment_status( $comment_id, $comment_status, $wp_error = false ) {\n\tglobal $wpdb;\n\n\tswitch ( $comment_status ) {\n\t\tcase 'hold':\n\t\tcase '0':\n\t\t\t$status = '0';\n\t\t\tbreak;\n\t\tcase 'approve':\n\t\tcase '1':\n\t\t\t$status = '1';\n\t\t\tadd_action( 'wp_set_comment_status', 'wp_new_comment_notify_postauthor' );\n\t\t\tbreak;\n\t\tcase 'spam':\n\t\t\t$status = 'spam';\n\t\t\tbreak;\n\t\tcase 'trash':\n\t\t\t$status = 'trash';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\t$comment_old = clone get_comment( $comment_id );\n\n\tif ( ! $wpdb->update( $wpdb->comments, array( 'comment_approved' => $status ), array( 'comment_ID' => $comment_old->comment_ID ) ) ) {\n\t\tif ( $wp_error ) {\n\t\t\treturn new WP_Error( 'db_update_error', __( 'Could not update comment status' ), $wpdb->last_error );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tclean_comment_cache( $comment_old->comment_ID );\n\n\t$comment = get_comment( $comment_old->comment_ID );\n\n\t/**\n\t * Fires immediately before transitioning a comment's status from one to another\n\t * in the database.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param int         $comment_id     Comment ID.\n\t * @param string|bool $comment_status Current comment status. Possible values include\n\t *                                    'hold', 'approve', 'spam', 'trash', or false.\n\t */\n\tdo_action( 'wp_set_comment_status', $comment->comment_ID, $comment_status );\n\n\twp_transition_comment_status( $comment_status, $comment_old->comment_approved, $comment );\n\n\twp_update_comment_count( $comment->comment_post_ID );\n\n\treturn true;\n}\n\n/**\n * Updates an existing comment in the database.\n *\n * Filters the comment and makes sure certain fields are valid before updating.\n *\n * @since 2.0.0\n * @since 4.9.0 Add updating comment meta during comment update.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentarr Contains information on the comment.\n * @return int Comment was updated if value is 1, or was not updated if value is 0.\n */\nfunction wp_update_comment( $commentarr ) {\n\tglobal $wpdb;\n\n\t// First, get all of the original fields\n\t$comment = get_comment( $commentarr['comment_ID'], ARRAY_A );\n\tif ( empty( $comment ) ) {\n\t\treturn 0;\n\t}\n\n\t// Make sure that the comment post ID is valid (if specified).\n\tif ( ! empty( $commentarr['comment_post_ID'] ) && ! get_post( $commentarr['comment_post_ID'] ) ) {\n\t\treturn 0;\n\t}\n\n\t// Escape data pulled from DB.\n\t$comment = wp_slash( $comment );\n\n\t$old_status = $comment['comment_approved'];\n\n\t// Merge old and new fields with new fields overwriting old ones.\n\t$commentarr = array_merge( $comment, $commentarr );\n\n\t$commentarr = wp_filter_comment( $commentarr );\n\n\t// Now extract the merged array.\n\t$data = wp_unslash( $commentarr );\n\n\t/**\n\t * Filters the comment content before it is updated in the database.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_content The comment data.\n\t */\n\t$data['comment_content'] = apply_filters( 'comment_save_pre', $data['comment_content'] );\n\n\t$data['comment_date_gmt'] = get_gmt_from_date( $data['comment_date'] );\n\n\tif ( ! isset( $data['comment_approved'] ) ) {\n\t\t$data['comment_approved'] = 1;\n\t} elseif ( 'hold' == $data['comment_approved'] ) {\n\t\t$data['comment_approved'] = 0;\n\t} elseif ( 'approve' == $data['comment_approved'] ) {\n\t\t$data['comment_approved'] = 1;\n\t}\n\n\t$comment_ID      = $data['comment_ID'];\n\t$comment_post_ID = $data['comment_post_ID'];\n\n\t/**\n\t * Filters the comment data immediately before it is updated in the database.\n\t *\n\t * Note: data being passed to the filter is already unslashed.\n\t *\n\t * @since 4.7.0\n\t *\n\t * @param array $data       The new, processed comment data.\n\t * @param array $comment    The old, unslashed comment data.\n\t * @param array $commentarr The new, raw comment data.\n\t */\n\t$data = apply_filters( 'wp_update_comment_data', $data, $comment, $commentarr );\n\n\t$keys = array( 'comment_post_ID', 'comment_content', 'comment_author', 'comment_author_email', 'comment_approved', 'comment_karma', 'comment_author_url', 'comment_date', 'comment_date_gmt', 'comment_type', 'comment_parent', 'user_id', 'comment_agent', 'comment_author_IP' );\n\t$data = wp_array_slice_assoc( $data, $keys );\n\n\t$rval = $wpdb->update( $wpdb->comments, $data, compact( 'comment_ID' ) );\n\n\t// If metadata is provided, store it.\n\tif ( isset( $commentarr['comment_meta'] ) && is_array( $commentarr['comment_meta'] ) ) {\n\t\tforeach ( $commentarr['comment_meta'] as $meta_key => $meta_value ) {\n\t\t\tupdate_comment_meta( $comment_ID, $meta_key, $meta_value );\n\t\t}\n\t}\n\n\tclean_comment_cache( $comment_ID );\n\twp_update_comment_count( $comment_post_ID );\n\t/**\n\t * Fires immediately after a comment is updated in the database.\n\t *\n\t * The hook also fires immediately before comment status transition hooks are fired.\n\t *\n\t * @since 1.2.0\n\t * @since 4.6.0 Added the `$data` parameter.\n\t *\n\t * @param int   $comment_ID The comment ID.\n\t * @param array $data       Comment data.\n\t */\n\tdo_action( 'edit_comment', $comment_ID, $data );\n\t$comment = get_comment( $comment_ID );\n\twp_transition_comment_status( $comment->comment_approved, $old_status, $comment );\n\treturn $rval;\n}\n\n/**\n * Whether to defer comment counting.\n *\n * When setting $defer to true, all post comment counts will not be updated\n * until $defer is set to false. When $defer is set to false, then all\n * previously deferred updated post comment counts will then be automatically\n * updated without having to call wp_update_comment_count() after.\n *\n * @since 2.5.0\n * @staticvar bool $_defer\n *\n * @param bool $defer\n * @return bool\n */\nfunction wp_defer_comment_counting( $defer = null ) {\n\tstatic $_defer = false;\n\n\tif ( is_bool( $defer ) ) {\n\t\t$_defer = $defer;\n\t\t// flush any deferred counts\n\t\tif ( ! $defer ) {\n\t\t\twp_update_comment_count( null, true );\n\t\t}\n\t}\n\n\treturn $_defer;\n}\n\n/**\n * Updates the comment count for post(s).\n *\n * When $do_deferred is false (is by default) and the comments have been set to\n * be deferred, the post_id will be added to a queue, which will be updated at a\n * later date and only updated once per post ID.\n *\n * If the comments have not be set up to be deferred, then the post will be\n * updated. When $do_deferred is set to true, then all previous deferred post\n * IDs will be updated along with the current $post_id.\n *\n * @since 2.1.0\n * @see wp_update_comment_count_now() For what could cause a false return value\n *\n * @staticvar array $_deferred\n *\n * @param int|null $post_id     Post ID.\n * @param bool     $do_deferred Optional. Whether to process previously deferred\n *                              post comment counts. Default false.\n * @return bool|void True on success, false on failure or if post with ID does\n *                   not exist.\n */\nfunction wp_update_comment_count( $post_id, $do_deferred = false ) {\n\tstatic $_deferred = array();\n\n\tif ( empty( $post_id ) && ! $do_deferred ) {\n\t\treturn false;\n\t}\n\n\tif ( $do_deferred ) {\n\t\t$_deferred = array_unique( $_deferred );\n\t\tforeach ( $_deferred as $i => $_post_id ) {\n\t\t\twp_update_comment_count_now( $_post_id );\n\t\t\tunset( $_deferred[ $i ] );\n\t\t\t/** @todo Move this outside of the foreach and reset $_deferred to an array instead */\n\t\t}\n\t}\n\n\tif ( wp_defer_comment_counting() ) {\n\t\t$_deferred[] = $post_id;\n\t\treturn true;\n\t} elseif ( $post_id ) {\n\t\treturn wp_update_comment_count_now( $post_id );\n\t}\n\n}\n\n/**\n * Updates the comment count for the post.\n *\n * @since 2.5.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $post_id Post ID\n * @return bool True on success, false on '0' $post_id or if post with ID does not exist.\n */\nfunction wp_update_comment_count_now( $post_id ) {\n\tglobal $wpdb;\n\t$post_id = (int) $post_id;\n\tif ( ! $post_id ) {\n\t\treturn false;\n\t}\n\n\twp_cache_delete( 'comments-0', 'counts' );\n\twp_cache_delete( \"comments-{$post_id}\", 'counts' );\n\n\tif ( ! $post = get_post( $post_id ) ) {\n\t\treturn false;\n\t}\n\n\t$old = (int) $post->comment_count;\n\n\t/**\n\t * Filters a post's comment count before it is updated in the database.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @param int $new     The new comment count. Default null.\n\t * @param int $old     The old comment count.\n\t * @param int $post_id Post ID.\n\t */\n\t$new = apply_filters( 'pre_wp_update_comment_count_now', null, $old, $post_id );\n\n\tif ( is_null( $new ) ) {\n\t\t$new = (int) $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(*) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1'\", $post_id ) );\n\t} else {\n\t\t$new = (int) $new;\n\t}\n\n\t$wpdb->update( $wpdb->posts, array( 'comment_count' => $new ), array( 'ID' => $post_id ) );\n\n\tclean_post_cache( $post );\n\n\t/**\n\t * Fires immediately after a post's comment count is updated in the database.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param int $post_id Post ID.\n\t * @param int $new     The new comment count.\n\t * @param int $old     The old comment count.\n\t */\n\tdo_action( 'wp_update_comment_count', $post_id, $new, $old );\n\n\t/** This action is documented in wp-includes/post.php */\n\tdo_action( \"edit_post_{$post->post_type}\", $post_id, $post );\n\n\t/** This action is documented in wp-includes/post.php */\n\tdo_action( 'edit_post', $post_id, $post );\n\n\treturn true;\n}\n\n//\n// Ping and trackback functions.\n//\n\n/**\n * Finds a pingback server URI based on the given URL.\n *\n * Checks the HTML for the rel=\"pingback\" link and x-pingback headers. It does\n * a check for the x-pingback headers first and returns that, if available. The\n * check for the rel=\"pingback\" has more overhead than just the header.\n *\n * @since 1.5.0\n *\n * @param string $url URL to ping.\n * @param int $deprecated Not Used.\n * @return false|string False on failure, string containing URI on success.\n */\nfunction discover_pingback_server_uri( $url, $deprecated = '' ) {\n\tif ( ! empty( $deprecated ) ) {\n\t\t_deprecated_argument( __FUNCTION__, '2.7.0' );\n\t}\n\n\t$pingback_str_dquote = 'rel=\"pingback\"';\n\t$pingback_str_squote = 'rel=\\'pingback\\'';\n\n\t/** @todo Should use Filter Extension or custom preg_match instead. */\n\t$parsed_url = parse_url( $url );\n\n\tif ( ! isset( $parsed_url['host'] ) ) { // Not a URL. This should never happen.\n\t\treturn false;\n\t}\n\n\t//Do not search for a pingback server on our own uploads\n\t$uploads_dir = wp_get_upload_dir();\n\tif ( 0 === strpos( $url, $uploads_dir['baseurl'] ) ) {\n\t\treturn false;\n\t}\n\n\t$response = wp_safe_remote_head(\n\t\t$url,\n\t\tarray(\n\t\t\t'timeout'     => 2,\n\t\t\t'httpversion' => '1.0',\n\t\t)\n\t);\n\n\tif ( is_wp_error( $response ) ) {\n\t\treturn false;\n\t}\n\n\tif ( wp_remote_retrieve_header( $response, 'x-pingback' ) ) {\n\t\treturn wp_remote_retrieve_header( $response, 'x-pingback' );\n\t}\n\n\t// Not an (x)html, sgml, or xml page, no use going further.\n\tif ( preg_match( '#(image|audio|video|model)/#is', wp_remote_retrieve_header( $response, 'content-type' ) ) ) {\n\t\treturn false;\n\t}\n\n\t// Now do a GET since we're going to look in the html headers (and we're sure it's not a binary file)\n\t$response = wp_safe_remote_get(\n\t\t$url,\n\t\tarray(\n\t\t\t'timeout'     => 2,\n\t\t\t'httpversion' => '1.0',\n\t\t)\n\t);\n\n\tif ( is_wp_error( $response ) ) {\n\t\treturn false;\n\t}\n\n\t$contents = wp_remote_retrieve_body( $response );\n\n\t$pingback_link_offset_dquote = strpos( $contents, $pingback_str_dquote );\n\t$pingback_link_offset_squote = strpos( $contents, $pingback_str_squote );\n\tif ( $pingback_link_offset_dquote || $pingback_link_offset_squote ) {\n\t\t$quote                   = ( $pingback_link_offset_dquote ) ? '\"' : '\\'';\n\t\t$pingback_link_offset    = ( $quote == '\"' ) ? $pingback_link_offset_dquote : $pingback_link_offset_squote;\n\t\t$pingback_href_pos       = @strpos( $contents, 'href=', $pingback_link_offset );\n\t\t$pingback_href_start     = $pingback_href_pos + 6;\n\t\t$pingback_href_end       = @strpos( $contents, $quote, $pingback_href_start );\n\t\t$pingback_server_url_len = $pingback_href_end - $pingback_href_start;\n\t\t$pingback_server_url     = substr( $contents, $pingback_href_start, $pingback_server_url_len );\n\n\t\t// We may find rel=\"pingback\" but an incomplete pingback URL\n\t\tif ( $pingback_server_url_len > 0 ) { // We got it!\n\t\t\treturn $pingback_server_url;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Perform all pingbacks, enclosures, trackbacks, and send to pingback services.\n *\n * @since 2.1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\nfunction do_all_pings() {\n\tglobal $wpdb;\n\n\t// Do pingbacks\n\twhile ( $ping = $wpdb->get_row( \"SELECT ID, post_content, meta_id FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_pingme' LIMIT 1\" ) ) {\n\t\tdelete_metadata_by_mid( 'post', $ping->meta_id );\n\t\tpingback( $ping->post_content, $ping->ID );\n\t}\n\n\t// Do Enclosures\n\twhile ( $enclosure = $wpdb->get_row( \"SELECT ID, post_content, meta_id FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_encloseme' LIMIT 1\" ) ) {\n\t\tdelete_metadata_by_mid( 'post', $enclosure->meta_id );\n\t\tdo_enclose( $enclosure->post_content, $enclosure->ID );\n\t}\n\n\t// Do Trackbacks\n\t$trackbacks = $wpdb->get_col( \"SELECT ID FROM $wpdb->posts WHERE to_ping <> '' AND post_status = 'publish'\" );\n\tif ( is_array( $trackbacks ) ) {\n\t\tforeach ( $trackbacks as $trackback ) {\n\t\t\tdo_trackbacks( $trackback );\n\t\t}\n\t}\n\n\t//Do Update Services/Generic Pings\n\tgeneric_ping();\n}\n\n/**\n * Perform trackbacks.\n *\n * @since 1.5.0\n * @since 4.7.0 `$post_id` can be a WP_Post object.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int|WP_Post $post_id Post object or ID to do trackbacks on.\n */\nfunction do_trackbacks( $post_id ) {\n\tglobal $wpdb;\n\t$post = get_post( $post_id );\n\tif ( ! $post ) {\n\t\treturn false;\n\t}\n\n\t$to_ping = get_to_ping( $post );\n\t$pinged  = get_pung( $post );\n\tif ( empty( $to_ping ) ) {\n\t\t$wpdb->update( $wpdb->posts, array( 'to_ping' => '' ), array( 'ID' => $post->ID ) );\n\t\treturn;\n\t}\n\n\tif ( empty( $post->post_excerpt ) ) {\n\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t$excerpt = apply_filters( 'the_content', $post->post_content, $post->ID );\n\t} else {\n\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t$excerpt = apply_filters( 'the_excerpt', $post->post_excerpt );\n\t}\n\n\t$excerpt = str_replace( ']]>', ']]&gt;', $excerpt );\n\t$excerpt = wp_html_excerpt( $excerpt, 252, '&#8230;' );\n\n\t/** This filter is documented in wp-includes/post-template.php */\n\t$post_title = apply_filters( 'the_title', $post->post_title, $post->ID );\n\t$post_title = strip_tags( $post_title );\n\n\tif ( $to_ping ) {\n\t\tforeach ( (array) $to_ping as $tb_ping ) {\n\t\t\t$tb_ping = trim( $tb_ping );\n\t\t\tif ( ! in_array( $tb_ping, $pinged ) ) {\n\t\t\t\ttrackback( $tb_ping, $post_title, $excerpt, $post->ID );\n\t\t\t\t$pinged[] = $tb_ping;\n\t\t\t} else {\n\t\t\t\t$wpdb->query(\n\t\t\t\t\t$wpdb->prepare(\n\t\t\t\t\t\t\"UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, %s,\n\t\t\t\t\t'')) WHERE ID = %d\",\n\t\t\t\t\t\t$tb_ping,\n\t\t\t\t\t\t$post->ID\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Sends pings to all of the ping site services.\n *\n * @since 1.2.0\n *\n * @param int $post_id Post ID.\n * @return int Same as Post ID from parameter\n */\nfunction generic_ping( $post_id = 0 ) {\n\t$services = get_option( 'ping_sites' );\n\n\t$services = explode( \"\\n\", $services );\n\tforeach ( (array) $services as $service ) {\n\t\t$service = trim( $service );\n\t\tif ( '' != $service ) {\n\t\t\tweblog_ping( $service );\n\t\t}\n\t}\n\n\treturn $post_id;\n}\n\n/**\n * Pings back the links found in a post.\n *\n * @since 0.71\n * @since 4.7.0 `$post_id` can be a WP_Post object.\n *\n * @param string $content Post content to check for links. If empty will retrieve from post.\n * @param int|WP_Post $post_id Post Object or ID.\n */\nfunction pingback( $content, $post_id ) {\n\tinclude_once( ABSPATH . WPINC . '/class-IXR.php' );\n\tinclude_once( ABSPATH . WPINC . '/class-wp-http-ixr-client.php' );\n\n\t// original code by Mort (http://mort.mine.nu:8080)\n\t$post_links = array();\n\n\t$post = get_post( $post_id );\n\tif ( ! $post ) {\n\t\treturn;\n\t}\n\n\t$pung = get_pung( $post );\n\n\tif ( empty( $content ) ) {\n\t\t$content = $post->post_content;\n\t}\n\n\t// Step 1\n\t// Parsing the post, external links (if any) are stored in the $post_links array\n\t$post_links_temp = wp_extract_urls( $content );\n\n\t// Step 2.\n\t// Walking thru the links array\n\t// first we get rid of links pointing to sites, not to specific files\n\t// Example:\n\t// http://dummy-weblog.org\n\t// http://dummy-weblog.org/\n\t// http://dummy-weblog.org/post.php\n\t// We don't wanna ping first and second types, even if they have a valid <link/>\n\n\tforeach ( (array) $post_links_temp as $link_test ) :\n\t\tif ( ! in_array( $link_test, $pung ) && ( url_to_postid( $link_test ) != $post->ID ) // If we haven't pung it already and it isn't a link to itself\n\t\t\t\t&& ! is_local_attachment( $link_test ) ) : // Also, let's never ping local attachments.\n\t\t\tif ( $test = @parse_url( $link_test ) ) {\n\t\t\t\tif ( isset( $test['query'] ) ) {\n\t\t\t\t\t$post_links[] = $link_test;\n\t\t\t\t} elseif ( isset( $test['path'] ) && ( $test['path'] != '/' ) && ( $test['path'] != '' ) ) {\n\t\t\t\t\t$post_links[] = $link_test;\n\t\t\t\t}\n\t\t\t}\n\t\tendif;\n\tendforeach;\n\n\t$post_links = array_unique( $post_links );\n\t/**\n\t * Fires just before pinging back links found in a post.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @param string[] $post_links Array of link URLs to be checked (passed by reference).\n\t * @param string[] $pung       Array of link URLs already pinged (passed by reference).\n\t * @param int      $post_ID    The post ID.\n\t */\n\tdo_action_ref_array( 'pre_ping', array( &$post_links, &$pung, $post->ID ) );\n\n\tforeach ( (array) $post_links as $pagelinkedto ) {\n\t\t$pingback_server_url = discover_pingback_server_uri( $pagelinkedto );\n\n\t\tif ( $pingback_server_url ) {\n\t\t\t@ set_time_limit( 60 );\n\t\t\t// Now, the RPC call\n\t\t\t$pagelinkedfrom = get_permalink( $post );\n\n\t\t\t// using a timeout of 3 seconds should be enough to cover slow servers\n\t\t\t$client          = new WP_HTTP_IXR_Client( $pingback_server_url );\n\t\t\t$client->timeout = 3;\n\t\t\t/**\n\t\t\t * Filters the user agent sent when pinging-back a URL.\n\t\t\t *\n\t\t\t * @since 2.9.0\n\t\t\t *\n\t\t\t * @param string $concat_useragent    The user agent concatenated with ' -- WordPress/'\n\t\t\t *                                    and the WordPress version.\n\t\t\t * @param string $useragent           The useragent.\n\t\t\t * @param string $pingback_server_url The server URL being linked to.\n\t\t\t * @param string $pagelinkedto        URL of page linked to.\n\t\t\t * @param string $pagelinkedfrom      URL of page linked from.\n\t\t\t */\n\t\t\t$client->useragent = apply_filters( 'pingback_useragent', $client->useragent . ' -- WordPress/' . get_bloginfo( 'version' ), $client->useragent, $pingback_server_url, $pagelinkedto, $pagelinkedfrom );\n\t\t\t// when set to true, this outputs debug messages by itself\n\t\t\t$client->debug = false;\n\n\t\t\tif ( $client->query( 'pingback.ping', $pagelinkedfrom, $pagelinkedto ) || ( isset( $client->error->code ) && 48 == $client->error->code ) ) { // Already registered\n\t\t\t\tadd_ping( $post, $pagelinkedto );\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Check whether blog is public before returning sites.\n *\n * @since 2.1.0\n *\n * @param mixed $sites Will return if blog is public, will not return if not public.\n * @return mixed Empty string if blog is not public, returns $sites, if site is public.\n */\nfunction privacy_ping_filter( $sites ) {\n\tif ( '0' != get_option( 'blog_public' ) ) {\n\t\treturn $sites;\n\t} else {\n\t\treturn '';\n\t}\n}\n\n/**\n * Send a Trackback.\n *\n * Updates database when sending trackback to prevent duplicates.\n *\n * @since 0.71\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $trackback_url URL to send trackbacks.\n * @param string $title Title of post.\n * @param string $excerpt Excerpt of post.\n * @param int $ID Post ID.\n * @return int|false|void Database query from update.\n */\nfunction trackback( $trackback_url, $title, $excerpt, $ID ) {\n\tglobal $wpdb;\n\n\tif ( empty( $trackback_url ) ) {\n\t\treturn;\n\t}\n\n\t$options            = array();\n\t$options['timeout'] = 10;\n\t$options['body']    = array(\n\t\t'title'     => $title,\n\t\t'url'       => get_permalink( $ID ),\n\t\t'blog_name' => get_option( 'blogname' ),\n\t\t'excerpt'   => $excerpt,\n\t);\n\n\t$response = wp_safe_remote_post( $trackback_url, $options );\n\n\tif ( is_wp_error( $response ) ) {\n\t\treturn;\n\t}\n\n\t$wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->posts SET pinged = CONCAT(pinged, '\\n', %s) WHERE ID = %d\", $trackback_url, $ID ) );\n\treturn $wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, %s, '')) WHERE ID = %d\", $trackback_url, $ID ) );\n}\n\n/**\n * Send a pingback.\n *\n * @since 1.2.0\n *\n * @param string $server Host of blog to connect to.\n * @param string $path Path to send the ping.\n */\nfunction weblog_ping( $server = '', $path = '' ) {\n\tinclude_once( ABSPATH . WPINC . '/class-IXR.php' );\n\tinclude_once( ABSPATH . WPINC . '/class-wp-http-ixr-client.php' );\n\n\t// using a timeout of 3 seconds should be enough to cover slow servers\n\t$client             = new WP_HTTP_IXR_Client( $server, ( ( ! strlen( trim( $path ) ) || ( '/' == $path ) ) ? false : $path ) );\n\t$client->timeout    = 3;\n\t$client->useragent .= ' -- WordPress/' . get_bloginfo( 'version' );\n\n\t// when set to true, this outputs debug messages by itself\n\t$client->debug = false;\n\t$home          = trailingslashit( home_url() );\n\tif ( ! $client->query( 'weblogUpdates.extendedPing', get_option( 'blogname' ), $home, get_bloginfo( 'rss2_url' ) ) ) { // then try a normal ping\n\t\t$client->query( 'weblogUpdates.ping', get_option( 'blogname' ), $home );\n\t}\n}\n\n/**\n * Default filter attached to pingback_ping_source_uri to validate the pingback's Source URI\n *\n * @since 3.5.1\n * @see wp_http_validate_url()\n *\n * @param string $source_uri\n * @return string\n */\nfunction pingback_ping_source_uri( $source_uri ) {\n\treturn (string) wp_http_validate_url( $source_uri );\n}\n\n/**\n * Default filter attached to xmlrpc_pingback_error.\n *\n * Returns a generic pingback error code unless the error code is 48,\n * which reports that the pingback is already registered.\n *\n * @since 3.5.1\n * @link https://www.hixie.ch/specs/pingback/pingback#TOC3\n *\n * @param IXR_Error $ixr_error\n * @return IXR_Error\n */\nfunction xmlrpc_pingback_error( $ixr_error ) {\n\tif ( $ixr_error->code === 48 ) {\n\t\treturn $ixr_error;\n\t}\n\treturn new IXR_Error( 0, '' );\n}\n\n//\n// Cache\n//\n\n/**\n * Removes a comment from the object cache.\n *\n * @since 2.3.0\n *\n * @param int|array $ids Comment ID or an array of comment IDs to remove from cache.\n */\nfunction clean_comment_cache( $ids ) {\n\tforeach ( (array) $ids as $id ) {\n\t\twp_cache_delete( $id, 'comment' );\n\n\t\t/**\n\t\t * Fires immediately after a comment has been removed from the object cache.\n\t\t *\n\t\t * @since 4.5.0\n\t\t *\n\t\t * @param int $id Comment ID.\n\t\t */\n\t\tdo_action( 'clean_comment_cache', $id );\n\t}\n\n\twp_cache_set( 'last_changed', microtime(), 'comment' );\n}\n\n/**\n * Updates the comment cache of given comments.\n *\n * Will add the comments in $comments to the cache. If comment ID already exists\n * in the comment cache then it will not be updated. The comment is added to the\n * cache using the comment group with the key using the ID of the comments.\n *\n * @since 2.3.0\n * @since 4.4.0 Introduced the `$update_meta_cache` parameter.\n *\n * @param WP_Comment[] $comments          Array of comment objects\n * @param bool         $update_meta_cache Whether to update commentmeta cache. Default true.\n */\nfunction update_comment_cache( $comments, $update_meta_cache = true ) {\n\tforeach ( (array) $comments as $comment ) {\n\t\twp_cache_add( $comment->comment_ID, $comment, 'comment' );\n\t}\n\n\tif ( $update_meta_cache ) {\n\t\t// Avoid `wp_list_pluck()` in case `$comments` is passed by reference.\n\t\t$comment_ids = array();\n\t\tforeach ( $comments as $comment ) {\n\t\t\t$comment_ids[] = $comment->comment_ID;\n\t\t}\n\t\tupdate_meta_cache( 'comment', $comment_ids );\n\t}\n}\n\n/**\n * Adds any comments from the given IDs to the cache that do not already exist in cache.\n *\n * @since 4.4.0\n * @access private\n *\n * @see update_comment_cache()\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int[] $comment_ids       Array of comment IDs.\n * @param bool  $update_meta_cache Optional. Whether to update the meta cache. Default true.\n */\nfunction _prime_comment_caches( $comment_ids, $update_meta_cache = true ) {\n\tglobal $wpdb;\n\n\t$non_cached_ids = _get_non_cached_ids( $comment_ids, 'comment' );\n\tif ( ! empty( $non_cached_ids ) ) {\n\t\t$fresh_comments = $wpdb->get_results( sprintf( \"SELECT $wpdb->comments.* FROM $wpdb->comments WHERE comment_ID IN (%s)\", join( ',', array_map( 'intval', $non_cached_ids ) ) ) );\n\n\t\tupdate_comment_cache( $fresh_comments, $update_meta_cache );\n\t}\n}\n\n//\n// Internal\n//\n\n/**\n * Close comments on old posts on the fly, without any extra DB queries. Hooked to the_posts.\n *\n * @access private\n * @since 2.7.0\n *\n * @param WP_Post  $posts Post data object.\n * @param WP_Query $query Query object.\n * @return array\n */\nfunction _close_comments_for_old_posts( $posts, $query ) {\n\tif ( empty( $posts ) || ! $query->is_singular() || ! get_option( 'close_comments_for_old_posts' ) ) {\n\t\treturn $posts;\n\t}\n\n\t/**\n\t * Filters the list of post types to automatically close comments for.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @param string[] $post_types An array of post type names.\n\t */\n\t$post_types = apply_filters( 'close_comments_for_post_types', array( 'post' ) );\n\tif ( ! in_array( $posts[0]->post_type, $post_types ) ) {\n\t\treturn $posts;\n\t}\n\n\t$days_old = (int) get_option( 'close_comments_days_old' );\n\tif ( ! $days_old ) {\n\t\treturn $posts;\n\t}\n\n\tif ( time() - strtotime( $posts[0]->post_date_gmt ) > ( $days_old * DAY_IN_SECONDS ) ) {\n\t\t$posts[0]->comment_status = 'closed';\n\t\t$posts[0]->ping_status    = 'closed';\n\t}\n\n\treturn $posts;\n}\n\n/**\n * Close comments on an old post. Hooked to comments_open and pings_open.\n *\n * @access private\n * @since 2.7.0\n *\n * @param bool $open Comments open or closed\n * @param int $post_id Post ID\n * @return bool $open\n */\nfunction _close_comments_for_old_post( $open, $post_id ) {\n\tif ( ! $open ) {\n\t\treturn $open;\n\t}\n\n\tif ( ! get_option( 'close_comments_for_old_posts' ) ) {\n\t\treturn $open;\n\t}\n\n\t$days_old = (int) get_option( 'close_comments_days_old' );\n\tif ( ! $days_old ) {\n\t\treturn $open;\n\t}\n\n\t$post = get_post( $post_id );\n\n\t/** This filter is documented in wp-includes/comment.php */\n\t$post_types = apply_filters( 'close_comments_for_post_types', array( 'post' ) );\n\tif ( ! in_array( $post->post_type, $post_types ) ) {\n\t\treturn $open;\n\t}\n\n\t// Undated drafts should not show up as comments closed.\n\tif ( '0000-00-00 00:00:00' === $post->post_date_gmt ) {\n\t\treturn $open;\n\t}\n\n\tif ( time() - strtotime( $post->post_date_gmt ) > ( $days_old * DAY_IN_SECONDS ) ) {\n\t\treturn false;\n\t}\n\n\treturn $open;\n}\n\n/**\n * Handles the submission of a comment, usually posted to wp-comments-post.php via a comment form.\n *\n * This function expects unslashed data, as opposed to functions such as `wp_new_comment()` which\n * expect slashed data.\n *\n * @since 4.4.0\n *\n * @param array $comment_data {\n *     Comment data.\n *\n *     @type string|int $comment_post_ID             The ID of the post that relates to the comment.\n *     @type string     $author                      The name of the comment author.\n *     @type string     $email                       The comment author email address.\n *     @type string     $url                         The comment author URL.\n *     @type string     $comment                     The content of the comment.\n *     @type string|int $comment_parent              The ID of this comment's parent, if any. Default 0.\n *     @type string     $_wp_unfiltered_html_comment The nonce value for allowing unfiltered HTML.\n * }\n * @return WP_Comment|WP_Error A WP_Comment object on success, a WP_Error object on failure.\n */\nfunction wp_handle_comment_submission( $comment_data ) {\n\n\t$comment_post_ID = $comment_parent = $user_ID = 0;\n\t$comment_author  = $comment_author_email = $comment_author_url = $comment_content = null;\n\n\tif ( isset( $comment_data['comment_post_ID'] ) ) {\n\t\t$comment_post_ID = (int) $comment_data['comment_post_ID'];\n\t}\n\tif ( isset( $comment_data['author'] ) && is_string( $comment_data['author'] ) ) {\n\t\t$comment_author = trim( strip_tags( $comment_data['author'] ) );\n\t}\n\tif ( isset( $comment_data['email'] ) && is_string( $comment_data['email'] ) ) {\n\t\t$comment_author_email = trim( $comment_data['email'] );\n\t}\n\tif ( isset( $comment_data['url'] ) && is_string( $comment_data['url'] ) ) {\n\t\t$comment_author_url = trim( $comment_data['url'] );\n\t}\n\tif ( isset( $comment_data['comment'] ) && is_string( $comment_data['comment'] ) ) {\n\t\t$comment_content = trim( $comment_data['comment'] );\n\t}\n\tif ( isset( $comment_data['comment_parent'] ) ) {\n\t\t$comment_parent = absint( $comment_data['comment_parent'] );\n\t}\n\n\t$post = get_post( $comment_post_ID );\n\n\tif ( empty( $post->comment_status ) ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a post that does not exist.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_id_not_found', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_id_not_found' );\n\n\t}\n\n\t// get_post_status() will get the parent status for attachments.\n\t$status = get_post_status( $post );\n\n\tif ( ( 'private' == $status ) && ! current_user_can( 'read_post', $comment_post_ID ) ) {\n\t\treturn new WP_Error( 'comment_id_not_found' );\n\t}\n\n\t$status_obj = get_post_status_object( $status );\n\n\tif ( ! comments_open( $comment_post_ID ) ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a post that has comments closed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_closed', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_closed', __( 'Sorry, comments are closed for this item.' ), 403 );\n\n\t} elseif ( 'trash' == $status ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a trashed post.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_on_trash', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_on_trash' );\n\n\t} elseif ( ! $status_obj->public && ! $status_obj->private ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a post in draft mode.\n\t\t *\n\t\t * @since 1.5.1\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_on_draft', $comment_post_ID );\n\n\t\tif ( current_user_can( 'read_post', $comment_post_ID ) ) {\n\t\t\treturn new WP_Error( 'comment_on_draft', __( 'Sorry, comments are not allowed for this item.' ), 403 );\n\t\t} else {\n\t\t\treturn new WP_Error( 'comment_on_draft' );\n\t\t}\n\t} elseif ( post_password_required( $comment_post_ID ) ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a password-protected post.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_on_password_protected', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_on_password_protected' );\n\n\t} else {\n\n\t\t/**\n\t\t * Fires before a comment is posted.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'pre_comment_on_post', $comment_post_ID );\n\n\t}\n\n\t// If the user is logged in\n\t$user = wp_get_current_user();\n\tif ( $user->exists() ) {\n\t\tif ( empty( $user->display_name ) ) {\n\t\t\t$user->display_name = $user->user_login;\n\t\t}\n\t\t$comment_author       = $user->display_name;\n\t\t$comment_author_email = $user->user_email;\n\t\t$comment_author_url   = $user->user_url;\n\t\t$user_ID              = $user->ID;\n\t\tif ( current_user_can( 'unfiltered_html' ) ) {\n\t\t\tif ( ! isset( $comment_data['_wp_unfiltered_html_comment'] )\n\t\t\t\t|| ! wp_verify_nonce( $comment_data['_wp_unfiltered_html_comment'], 'unfiltered-html-comment_' . $comment_post_ID )\n\t\t\t) {\n\t\t\t\tkses_remove_filters(); // start with a clean slate\n\t\t\t\tkses_init_filters(); // set up the filters\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ( get_option( 'comment_registration' ) ) {\n\t\t\treturn new WP_Error( 'not_logged_in', __( 'Sorry, you must be logged in to comment.' ), 403 );\n\t\t}\n\t}\n\n\t$comment_type = '';\n\n\tif ( get_option( 'require_name_email' ) && ! $user->exists() ) {\n\t\tif ( '' == $comment_author_email || '' == $comment_author ) {\n\t\t\treturn new WP_Error( 'require_name_email', __( '<strong>ERROR</strong>: please fill the required fields (name, email).' ), 200 );\n\t\t} elseif ( ! is_email( $comment_author_email ) ) {\n\t\t\treturn new WP_Error( 'require_valid_email', __( '<strong>ERROR</strong>: please enter a valid email address.' ), 200 );\n\t\t}\n\t}\n\n\t$commentdata = compact(\n\t\t'comment_post_ID',\n\t\t'comment_author',\n\t\t'comment_author_email',\n\t\t'comment_author_url',\n\t\t'comment_content',\n\t\t'comment_type',\n\t\t'comment_parent',\n\t\t'user_ID'\n\t);\n\n\t/**\n\t * Filters whether an empty comment should be allowed.\n\t *\n\t * @since 5.1.0\n\t *\n\t * @param bool  $allow_empty_comment Whether to allow empty comments. Default false.\n\t * @param array $commentdata         Array of comment data to be sent to wp_insert_comment().\n\t */\n\t$allow_empty_comment = apply_filters( 'allow_empty_comment', false, $commentdata );\n\tif ( '' === $comment_content && ! $allow_empty_comment ) {\n\t\treturn new WP_Error( 'require_valid_comment', __( '<strong>ERROR</strong>: please type a comment.' ), 200 );\n\t}\n\n\t$check_max_lengths = wp_check_comment_data_max_lengths( $commentdata );\n\tif ( is_wp_error( $check_max_lengths ) ) {\n\t\treturn $check_max_lengths;\n\t}\n\n\t$comment_id = wp_new_comment( wp_slash( $commentdata ), true );\n\tif ( is_wp_error( $comment_id ) ) {\n\t\treturn $comment_id;\n\t}\n\n\tif ( ! $comment_id ) {\n\t\treturn new WP_Error( 'comment_save_error', __( '<strong>ERROR</strong>: The comment could not be saved. Please try again later.' ), 500 );\n\t}\n\n\treturn get_comment( $comment_id );\n}\n\n/**\n * Registers the personal data exporter for comments.\n *\n * @since 4.9.6\n *\n * @param array $exporters An array of personal data exporters.\n * @return array $exporters An array of personal data exporters.\n */\nfunction wp_register_comment_personal_data_exporter( $exporters ) {\n\t$exporters['wordpress-comments'] = array(\n\t\t'exporter_friendly_name' => __( 'WordPress Comments' ),\n\t\t'callback'               => 'wp_comments_personal_data_exporter',\n\t);\n\n\treturn $exporters;\n}\n\n/**\n * Finds and exports personal data associated with an email address from the comments table.\n *\n * @since 4.9.6\n *\n * @param string $email_address The comment author email address.\n * @param int    $page          Comment page.\n * @return array $return An array of personal data.\n */\nfunction wp_comments_personal_data_exporter( $email_address, $page = 1 ) {\n\t// Limit us to 500 comments at a time to avoid timing out.\n\t$number = 500;\n\t$page   = (int) $page;\n\n\t$data_to_export = array();\n\n\t$comments = get_comments(\n\t\tarray(\n\t\t\t'author_email'              => $email_address,\n\t\t\t'number'                    => $number,\n\t\t\t'paged'                     => $page,\n\t\t\t'order_by'                  => 'comment_ID',\n\t\t\t'order'                     => 'ASC',\n\t\t\t'update_comment_meta_cache' => false,\n\t\t)\n\t);\n\n\t$comment_prop_to_export = array(\n\t\t'comment_author'       => __( 'Comment Author' ),\n\t\t'comment_author_email' => __( 'Comment Author Email' ),\n\t\t'comment_author_url'   => __( 'Comment Author URL' ),\n\t\t'comment_author_IP'    => __( 'Comment Author IP' ),\n\t\t'comment_agent'        => __( 'Comment Author User Agent' ),\n\t\t'comment_date'         => __( 'Comment Date' ),\n\t\t'comment_content'      => __( 'Comment Content' ),\n\t\t'comment_link'         => __( 'Comment URL' ),\n\t);\n\n\tforeach ( (array) $comments as $comment ) {\n\t\t$comment_data_to_export = array();\n\n\t\tforeach ( $comment_prop_to_export as $key => $name ) {\n\t\t\t$value = '';\n\n\t\t\tswitch ( $key ) {\n\t\t\t\tcase 'comment_author':\n\t\t\t\tcase 'comment_author_email':\n\t\t\t\tcase 'comment_author_url':\n\t\t\t\tcase 'comment_author_IP':\n\t\t\t\tcase 'comment_agent':\n\t\t\t\tcase 'comment_date':\n\t\t\t\t\t$value = $comment->{$key};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'comment_content':\n\t\t\t\t\t$value = get_comment_text( $comment->comment_ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'comment_link':\n\t\t\t\t\t$value = get_comment_link( $comment->comment_ID );\n\t\t\t\t\t$value = sprintf(\n\t\t\t\t\t\t'<a href=\"%s\" target=\"_blank\" rel=\"noreferrer noopener\">%s</a>',\n\t\t\t\t\t\tesc_url( $value ),\n\t\t\t\t\t\tesc_html( $value )\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( ! empty( $value ) ) {\n\t\t\t\t$comment_data_to_export[] = array(\n\t\t\t\t\t'name'  => $name,\n\t\t\t\t\t'value' => $value,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$data_to_export[] = array(\n\t\t\t'group_id'    => 'comments',\n\t\t\t'group_label' => __( 'Comments' ),\n\t\t\t'item_id'     => \"comment-{$comment->comment_ID}\",\n\t\t\t'data'        => $comment_data_to_export,\n\t\t);\n\t}\n\n\t$done = count( $comments ) < $number;\n\n\treturn array(\n\t\t'data' => $data_to_export,\n\t\t'done' => $done,\n\t);\n}\n\n/**\n * Registers the personal data eraser for comments.\n *\n * @since 4.9.6\n *\n * @param  array $erasers An array of personal data erasers.\n * @return array $erasers An array of personal data erasers.\n */\nfunction wp_register_comment_personal_data_eraser( $erasers ) {\n\t$erasers['wordpress-comments'] = array(\n\t\t'eraser_friendly_name' => __( 'WordPress Comments' ),\n\t\t'callback'             => 'wp_comments_personal_data_eraser',\n\t);\n\n\treturn $erasers;\n}\n\n/**\n * Erases personal data associated with an email address from the comments table.\n *\n * @since 4.9.6\n *\n * @param  string $email_address The comment author email address.\n * @param  int    $page          Comment page.\n * @return array\n */\nfunction wp_comments_personal_data_eraser( $email_address, $page = 1 ) {\n\tglobal $wpdb;\n\n\tif ( empty( $email_address ) ) {\n\t\treturn array(\n\t\t\t'items_removed'  => false,\n\t\t\t'items_retained' => false,\n\t\t\t'messages'       => array(),\n\t\t\t'done'           => true,\n\t\t);\n\t}\n\n\t// Limit us to 500 comments at a time to avoid timing out.\n\t$number         = 500;\n\t$page           = (int) $page;\n\t$items_removed  = false;\n\t$items_retained = false;\n\n\t$comments = get_comments(\n\t\tarray(\n\t\t\t'author_email'       => $email_address,\n\t\t\t'number'             => $number,\n\t\t\t'paged'              => $page,\n\t\t\t'order_by'           => 'comment_ID',\n\t\t\t'order'              => 'ASC',\n\t\t\t'include_unapproved' => true,\n\t\t)\n\t);\n\n\t/* translators: Name of a comment's author after being anonymized. */\n\t$anon_author = __( 'Anonymous' );\n\t$messages    = array();\n\n\tforeach ( (array) $comments as $comment ) {\n\t\t$anonymized_comment                         = array();\n\t\t$anonymized_comment['comment_agent']        = '';\n\t\t$anonymized_comment['comment_author']       = $anon_author;\n\t\t$anonymized_comment['comment_author_email'] = '';\n\t\t$anonymized_comment['comment_author_IP']    = wp_privacy_anonymize_data( 'ip', $comment->comment_author_IP );\n\t\t$anonymized_comment['comment_author_url']   = '';\n\t\t$anonymized_comment['user_id']              = 0;\n\n\t\t$comment_id = (int) $comment->comment_ID;\n\n\t\t/**\n\t\t * Filters whether to anonymize the comment.\n\t\t *\n\t\t * @since 4.9.6\n\t\t *\n\t\t * @param bool|string                    Whether to apply the comment anonymization (bool).\n\t\t *                                       Custom prevention message (string). Default true.\n\t\t * @param WP_Comment $comment            WP_Comment object.\n\t\t * @param array      $anonymized_comment Anonymized comment data.\n\t\t */\n\t\t$anon_message = apply_filters( 'wp_anonymize_comment', true, $comment, $anonymized_comment );\n\n\t\tif ( true !== $anon_message ) {\n\t\t\tif ( $anon_message && is_string( $anon_message ) ) {\n\t\t\t\t$messages[] = esc_html( $anon_message );\n\t\t\t} else {\n\t\t\t\t/* translators: %d: Comment ID */\n\t\t\t\t$messages[] = sprintf( __( 'Comment %d contains personal data but could not be anonymized.' ), $comment_id );\n\t\t\t}\n\n\t\t\t$items_retained = true;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t$args = array(\n\t\t\t'comment_ID' => $comment_id,\n\t\t);\n\n\t\t$updated = $wpdb->update( $wpdb->comments, $anonymized_comment, $args );\n\n\t\tif ( $updated ) {\n\t\t\t$items_removed = true;\n\t\t\tclean_comment_cache( $comment_id );\n\t\t} else {\n\t\t\t$items_retained = true;\n\t\t}\n\t}\n\n\t$done = count( $comments ) < $number;\n\n\treturn array(\n\t\t'items_removed'  => $items_removed,\n\t\t'items_retained' => $items_retained,\n\t\t'messages'       => $messages,\n\t\t'done'           => $done,\n\t);\n}\n\n/**\n * Sets the last changed time for the 'comment' cache group.\n *\n * @since 5.0.0\n */\nfunction wp_cache_set_comments_last_changed() {\n\twp_cache_set( 'last_changed', microtime(), 'comment' );\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.2-alpha-44833';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 44719;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4920-20181217';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * Administration API: Core Ajax handlers\n *\n * @package WordPress\n * @subpackage Administration\n * @since 2.1.0\n */\n\n//\n// No-privilege Ajax handlers.\n//\n\n/**\n * Ajax handler for the Heartbeat API in\n * the no-privilege context.\n *\n * Runs when the user is not logged in.\n *\n * @since 3.6.0\n */\nfunction wp_ajax_nopriv_heartbeat() {\n\t$response = array();\n\n\t// screen_id is the same as $current_screen->id and the JS global 'pagenow'.\n\tif ( ! empty( $_POST['screen_id'] ) ) {\n\t\t$screen_id = sanitize_key( $_POST['screen_id'] );\n\t} else {\n\t\t$screen_id = 'front';\n\t}\n\n\tif ( ! empty( $_POST['data'] ) ) {\n\t\t$data = wp_unslash( (array) $_POST['data'] );\n\n\t\t/**\n\t\t * Filters Heartbeat Ajax response in no-privilege environments.\n\t\t *\n\t\t * @since 3.6.0\n\t\t *\n\t\t * @param array  $response  The no-priv Heartbeat response.\n\t\t * @param array  $data      The $_POST data sent.\n\t\t * @param string $screen_id The screen id.\n\t\t */\n\t\t$response = apply_filters( 'heartbeat_nopriv_received', $response, $data, $screen_id );\n\t}\n\n\t/**\n\t * Filters Heartbeat Ajax response in no-privilege environments when no data is passed.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The no-priv Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\t$response = apply_filters( 'heartbeat_nopriv_send', $response, $screen_id );\n\n\t/**\n\t * Fires when Heartbeat ticks in no-privilege environments.\n\t *\n\t * Allows the transport to be easily replaced with long-polling.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The no-priv Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\tdo_action( 'heartbeat_nopriv_tick', $response, $screen_id );\n\n\t// Send the current time according to the server.\n\t$response['server_time'] = time();\n\n\twp_send_json( $response );\n}\n\n//\n// GET-based Ajax handlers.\n//\n\n/**\n * Ajax handler for fetching a list table.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_fetch_list() {\n\t$list_class = $_GET['list_args']['class'];\n\tcheck_ajax_referer( \"fetch-list-$list_class\", '_ajax_fetch_list_nonce' );\n\n\t$wp_list_table = _get_list_table( $list_class, array( 'screen' => $_GET['list_args']['screen']['id'] ) );\n\tif ( ! $wp_list_table ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $wp_list_table->ajax_user_can() ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table->ajax_response();\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for tag search.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_ajax_tag_search() {\n\tif ( ! isset( $_GET['tax'] ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$taxonomy = sanitize_key( $_GET['tax'] );\n\t$tax      = get_taxonomy( $taxonomy );\n\tif ( ! $tax ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! current_user_can( $tax->cap->assign_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$s = wp_unslash( $_GET['q'] );\n\n\t$comma = _x( ',', 'tag delimiter' );\n\tif ( ',' !== $comma ) {\n\t\t$s = str_replace( $comma, ',', $s );\n\t}\n\tif ( false !== strpos( $s, ',' ) ) {\n\t\t$s = explode( ',', $s );\n\t\t$s = $s[ count( $s ) - 1 ];\n\t}\n\t$s = trim( $s );\n\n\t/**\n\t * Filters the minimum number of characters required to fire a tag search via Ajax.\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param int         $characters The minimum number of characters required. Default 2.\n\t * @param WP_Taxonomy $tax        The taxonomy object.\n\t * @param string      $s          The search term.\n\t */\n\t$term_search_min_chars = (int) apply_filters( 'term_search_min_chars', 2, $tax, $s );\n\n\t/*\n\t * Require $term_search_min_chars chars for matching (default: 2)\n\t * ensure it's a non-negative, non-zero integer.\n\t */\n\tif ( ( $term_search_min_chars == 0 ) || ( strlen( $s ) < $term_search_min_chars ) ) {\n\t\twp_die();\n\t}\n\n\t$results = get_terms(\n\t\t$taxonomy,\n\t\tarray(\n\t\t\t'name__like' => $s,\n\t\t\t'fields'     => 'names',\n\t\t\t'hide_empty' => false,\n\t\t)\n\t);\n\n\techo join( $results, \"\\n\" );\n\twp_die();\n}\n\n/**\n * Ajax handler for compression testing.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_wp_compression_test() {\n\tif ( ! current_user_can( 'manage_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ini_get( 'zlib.output_compression' ) || 'ob_gzhandler' == ini_get( 'output_handler' ) ) {\n\t\tupdate_site_option( 'can_compress_scripts', 0 );\n\t\twp_die( 0 );\n\t}\n\n\tif ( isset( $_GET['test'] ) ) {\n\t\theader( 'Expires: Wed, 11 Jan 1984 05:00:00 GMT' );\n\t\theader( 'Last-Modified: ' . gmdate( 'D, d M Y H:i:s' ) . ' GMT' );\n\t\theader( 'Cache-Control: no-cache, must-revalidate, max-age=0' );\n\t\theader( 'Content-Type: application/javascript; charset=UTF-8' );\n\t\t$force_gzip = ( defined( 'ENFORCE_GZIP' ) && ENFORCE_GZIP );\n\t\t$test_str   = '\"wpCompressionTest Lorem ipsum dolor sit amet consectetuer mollis sapien urna ut a. Eu nonummy condimentum fringilla tempor pretium platea vel nibh netus Maecenas. Hac molestie amet justo quis pellentesque est ultrices interdum nibh Morbi. Cras mattis pretium Phasellus ante ipsum ipsum ut sociis Suspendisse Lorem. Ante et non molestie. Porta urna Vestibulum egestas id congue nibh eu risus gravida sit. Ac augue auctor Ut et non a elit massa id sodales. Elit eu Nulla at nibh adipiscing mattis lacus mauris at tempus. Netus nibh quis suscipit nec feugiat eget sed lorem et urna. Pellentesque lacus at ut massa consectetuer ligula ut auctor semper Pellentesque. Ut metus massa nibh quam Curabitur molestie nec mauris congue. Volutpat molestie elit justo facilisis neque ac risus Ut nascetur tristique. Vitae sit lorem tellus et quis Phasellus lacus tincidunt nunc Fusce. Pharetra wisi Suspendisse mus sagittis libero lacinia Integer consequat ac Phasellus. Et urna ac cursus tortor aliquam Aliquam amet tellus volutpat Vestibulum. Justo interdum condimentum In augue congue tellus sollicitudin Quisque quis nibh.\"';\n\n\t\tif ( 1 == $_GET['test'] ) {\n\t\t\techo $test_str;\n\t\t\twp_die();\n\t\t} elseif ( 2 == $_GET['test'] ) {\n\t\t\tif ( ! isset( $_SERVER['HTTP_ACCEPT_ENCODING'] ) ) {\n\t\t\t\twp_die( -1 );\n\t\t\t}\n\t\t\tif ( false !== stripos( $_SERVER['HTTP_ACCEPT_ENCODING'], 'deflate' ) && function_exists( 'gzdeflate' ) && ! $force_gzip ) {\n\t\t\t\theader( 'Content-Encoding: deflate' );\n\t\t\t\t$out = gzdeflate( $test_str, 1 );\n\t\t\t} elseif ( false !== stripos( $_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip' ) && function_exists( 'gzencode' ) ) {\n\t\t\t\theader( 'Content-Encoding: gzip' );\n\t\t\t\t$out = gzencode( $test_str, 1 );\n\t\t\t} else {\n\t\t\t\twp_die( -1 );\n\t\t\t}\n\t\t\techo $out;\n\t\t\twp_die();\n\t\t} elseif ( 'no' == $_GET['test'] ) {\n\t\t\tcheck_ajax_referer( 'update_can_compress_scripts' );\n\t\t\tupdate_site_option( 'can_compress_scripts', 0 );\n\t\t} elseif ( 'yes' == $_GET['test'] ) {\n\t\t\tcheck_ajax_referer( 'update_can_compress_scripts' );\n\t\t\tupdate_site_option( 'can_compress_scripts', 1 );\n\t\t}\n\t}\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for image editor previews.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_imgedit_preview() {\n\t$post_id = intval( $_GET['postid'] );\n\tif ( empty( $post_id ) || ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tcheck_ajax_referer( \"image_editor-$post_id\" );\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/image-edit.php' );\n\tif ( ! stream_preview_image( $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\twp_die();\n}\n\n/**\n * Ajax handler for oEmbed caching.\n *\n * @since 3.1.0\n *\n * @global WP_Embed $wp_embed\n */\nfunction wp_ajax_oembed_cache() {\n\t$GLOBALS['wp_embed']->cache_oembed( $_GET['post'] );\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for user autocomplete.\n *\n * @since 3.4.0\n */\nfunction wp_ajax_autocomplete_user() {\n\tif ( ! is_multisite() || ! current_user_can( 'promote_users' ) || wp_is_large_network( 'users' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t/** This filter is documented in wp-admin/user-new.php */\n\tif ( ! current_user_can( 'manage_network_users' ) && ! apply_filters( 'autocomplete_users_for_site_admins', false ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$return = array();\n\n\t// Check the type of request\n\t// Current allowed values are `add` and `search`\n\tif ( isset( $_REQUEST['autocomplete_type'] ) && 'search' === $_REQUEST['autocomplete_type'] ) {\n\t\t$type = $_REQUEST['autocomplete_type'];\n\t} else {\n\t\t$type = 'add';\n\t}\n\n\t// Check the desired field for value\n\t// Current allowed values are `user_email` and `user_login`\n\tif ( isset( $_REQUEST['autocomplete_field'] ) && 'user_email' === $_REQUEST['autocomplete_field'] ) {\n\t\t$field = $_REQUEST['autocomplete_field'];\n\t} else {\n\t\t$field = 'user_login';\n\t}\n\n\t// Exclude current users of this blog\n\tif ( isset( $_REQUEST['site_id'] ) ) {\n\t\t$id = absint( $_REQUEST['site_id'] );\n\t} else {\n\t\t$id = get_current_blog_id();\n\t}\n\n\t$include_blog_users = ( $type == 'search' ? get_users(\n\t\tarray(\n\t\t\t'blog_id' => $id,\n\t\t\t'fields'  => 'ID',\n\t\t)\n\t) : array() );\n\t$exclude_blog_users = ( $type == 'add' ? get_users(\n\t\tarray(\n\t\t\t'blog_id' => $id,\n\t\t\t'fields'  => 'ID',\n\t\t)\n\t) : array() );\n\n\t$users = get_users(\n\t\tarray(\n\t\t\t'blog_id'        => false,\n\t\t\t'search'         => '*' . $_REQUEST['term'] . '*',\n\t\t\t'include'        => $include_blog_users,\n\t\t\t'exclude'        => $exclude_blog_users,\n\t\t\t'search_columns' => array( 'user_login', 'user_nicename', 'user_email' ),\n\t\t)\n\t);\n\n\tforeach ( $users as $user ) {\n\t\t$return[] = array(\n\t\t\t/* translators: 1: user_login, 2: user_email */\n\t\t\t'label' => sprintf( _x( '%1$s (%2$s)', 'user autocomplete result' ), $user->user_login, $user->user_email ),\n\t\t\t'value' => $user->$field,\n\t\t);\n\t}\n\n\twp_die( wp_json_encode( $return ) );\n}\n\n/**\n * Handles AJAX requests for community events\n *\n * @since 4.8.0\n */\nfunction wp_ajax_get_community_events() {\n\trequire_once( ABSPATH . 'wp-admin/includes/class-wp-community-events.php' );\n\n\tcheck_ajax_referer( 'community_events' );\n\n\t$search         = isset( $_POST['location'] ) ? wp_unslash( $_POST['location'] ) : '';\n\t$timezone       = isset( $_POST['timezone'] ) ? wp_unslash( $_POST['timezone'] ) : '';\n\t$user_id        = get_current_user_id();\n\t$saved_location = get_user_option( 'community-events-location', $user_id );\n\t$events_client  = new WP_Community_Events( $user_id, $saved_location );\n\t$events         = $events_client->get_events( $search, $timezone );\n\t$ip_changed     = false;\n\n\tif ( is_wp_error( $events ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'error' => $events->get_error_message(),\n\t\t\t)\n\t\t);\n\t} else {\n\t\tif ( empty( $saved_location['ip'] ) && ! empty( $events['location']['ip'] ) ) {\n\t\t\t$ip_changed = true;\n\t\t} elseif ( isset( $saved_location['ip'] ) && ! empty( $events['location']['ip'] ) && $saved_location['ip'] !== $events['location']['ip'] ) {\n\t\t\t$ip_changed = true;\n\t\t}\n\n\t\t/*\n\t\t * The location should only be updated when it changes. The API doesn't always return\n\t\t * a full location; sometimes it's missing the description or country. The location\n\t\t * that was saved during the initial request is known to be good and complete, though.\n\t\t * It should be left intact until the user explicitly changes it (either by manually\n\t\t * searching for a new location, or by changing their IP address).\n\t\t *\n\t\t * If the location was updated with an incomplete response from the API, then it could\n\t\t * break assumptions that the UI makes (e.g., that there will always be a description\n\t\t * that corresponds to a latitude/longitude location).\n\t\t *\n\t\t * The location is stored network-wide, so that the user doesn't have to set it on each site.\n\t\t */\n\t\tif ( $ip_changed || $search ) {\n\t\t\tupdate_user_option( $user_id, 'community-events-location', $events['location'], true );\n\t\t}\n\n\t\twp_send_json_success( $events );\n\t}\n}\n\n/**\n * Ajax handler for dashboard widgets.\n *\n * @since 3.4.0\n */\nfunction wp_ajax_dashboard_widgets() {\n\trequire_once ABSPATH . 'wp-admin/includes/dashboard.php';\n\n\t$pagenow = $_GET['pagenow'];\n\tif ( $pagenow === 'dashboard-user' || $pagenow === 'dashboard-network' || $pagenow === 'dashboard' ) {\n\t\tset_current_screen( $pagenow );\n\t}\n\n\tswitch ( $_GET['widget'] ) {\n\t\tcase 'dashboard_primary':\n\t\t\twp_dashboard_primary();\n\t\t\tbreak;\n\t}\n\twp_die();\n}\n\n/**\n * Ajax handler for Customizer preview logged-in status.\n *\n * @since 3.4.0\n */\nfunction wp_ajax_logged_in() {\n\twp_die( 1 );\n}\n\n//\n// Ajax helpers.\n//\n\n/**\n * Sends back current comment total and new page links if they need to be updated.\n *\n * Contrary to normal success Ajax response (\"1\"), die with time() on success.\n *\n * @access private\n * @since 2.7.0\n *\n * @param int $comment_id\n * @param int $delta\n */\nfunction _wp_ajax_delete_comment_response( $comment_id, $delta = -1 ) {\n\t$total    = isset( $_POST['_total'] ) ? (int) $_POST['_total'] : 0;\n\t$per_page = isset( $_POST['_per_page'] ) ? (int) $_POST['_per_page'] : 0;\n\t$page     = isset( $_POST['_page'] ) ? (int) $_POST['_page'] : 0;\n\t$url      = isset( $_POST['_url'] ) ? esc_url_raw( $_POST['_url'] ) : '';\n\n\t// JS didn't send us everything we need to know. Just die with success message\n\tif ( ! $total || ! $per_page || ! $page || ! $url ) {\n\t\t$time           = time();\n\t\t$comment        = get_comment( $comment_id );\n\t\t$comment_status = '';\n\t\t$comment_link   = '';\n\n\t\tif ( $comment ) {\n\t\t\t$comment_status = $comment->comment_approved;\n\t\t}\n\n\t\tif ( 1 === (int) $comment_status ) {\n\t\t\t$comment_link = get_comment_link( $comment );\n\t\t}\n\n\t\t$counts = wp_count_comments();\n\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what'         => 'comment',\n\t\t\t\t// Here for completeness - not used.\n\t\t\t\t'id'           => $comment_id,\n\t\t\t\t'supplemental' => array(\n\t\t\t\t\t'status'               => $comment_status,\n\t\t\t\t\t'postId'               => $comment ? $comment->comment_post_ID : '',\n\t\t\t\t\t'time'                 => $time,\n\t\t\t\t\t'in_moderation'        => $counts->moderated,\n\t\t\t\t\t'i18n_comments_text'   => sprintf(\n\t\t\t\t\t\t/* translators: %s: number of comments approved */\n\t\t\t\t\t\t_n( '%s Comment', '%s Comments', $counts->approved ),\n\t\t\t\t\t\tnumber_format_i18n( $counts->approved )\n\t\t\t\t\t),\n\t\t\t\t\t'i18n_moderation_text' => sprintf(\n\t\t\t\t\t\t/* translators: %s: number of comments in moderation */\n\t\t\t\t\t\t_nx( '%s in moderation', '%s in moderation', $counts->moderated, 'comments' ),\n\t\t\t\t\t\tnumber_format_i18n( $counts->moderated )\n\t\t\t\t\t),\n\t\t\t\t\t'comment_link'         => $comment_link,\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\t$total += $delta;\n\tif ( $total < 0 ) {\n\t\t$total = 0;\n\t}\n\n\t// Only do the expensive stuff on a page-break, and about 1 other time per page\n\tif ( 0 == $total % $per_page || 1 == mt_rand( 1, $per_page ) ) {\n\t\t$post_id = 0;\n\t\t// What type of comment count are we looking for?\n\t\t$status = 'all';\n\t\t$parsed = parse_url( $url );\n\t\tif ( isset( $parsed['query'] ) ) {\n\t\t\tparse_str( $parsed['query'], $query_vars );\n\t\t\tif ( ! empty( $query_vars['comment_status'] ) ) {\n\t\t\t\t$status = $query_vars['comment_status'];\n\t\t\t}\n\t\t\tif ( ! empty( $query_vars['p'] ) ) {\n\t\t\t\t$post_id = (int) $query_vars['p'];\n\t\t\t}\n\t\t\tif ( ! empty( $query_vars['comment_type'] ) ) {\n\t\t\t\t$type = $query_vars['comment_type'];\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $type ) ) {\n\t\t\t// Only use the comment count if not filtering by a comment_type.\n\t\t\t$comment_count = wp_count_comments( $post_id );\n\n\t\t\t// We're looking for a known type of comment count.\n\t\t\tif ( isset( $comment_count->$status ) ) {\n\t\t\t\t$total = $comment_count->$status;\n\t\t\t}\n\t\t}\n\t\t// Else use the decremented value from above.\n\t}\n\n\t// The time since the last comment count.\n\t$time    = time();\n\t$comment = get_comment( $comment_id );\n\n\t$x = new WP_Ajax_Response(\n\t\tarray(\n\t\t\t'what'         => 'comment',\n\t\t\t// Here for completeness - not used.\n\t\t\t'id'           => $comment_id,\n\t\t\t'supplemental' => array(\n\t\t\t\t'status'           => $comment ? $comment->comment_approved : '',\n\t\t\t\t'postId'           => $comment ? $comment->comment_post_ID : '',\n\t\t\t\t/* translators: %s: number of comments */\n\t\t\t\t'total_items_i18n' => sprintf( _n( '%s item', '%s items', $total ), number_format_i18n( $total ) ),\n\t\t\t\t'total_pages'      => ceil( $total / $per_page ),\n\t\t\t\t'total_pages_i18n' => number_format_i18n( ceil( $total / $per_page ) ),\n\t\t\t\t'total'            => $total,\n\t\t\t\t'time'             => $time,\n\t\t\t),\n\t\t)\n\t);\n\t$x->send();\n}\n\n//\n// POST-based Ajax handlers.\n//\n\n/**\n * Ajax handler for adding a hierarchical term.\n *\n * @access private\n * @since 3.1.0\n */\nfunction _wp_ajax_add_hierarchical_term() {\n\t$action   = $_POST['action'];\n\t$taxonomy = get_taxonomy( substr( $action, 4 ) );\n\tcheck_ajax_referer( $action, '_ajax_nonce-add-' . $taxonomy->name );\n\tif ( ! current_user_can( $taxonomy->cap->edit_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\t$names  = explode( ',', $_POST[ 'new' . $taxonomy->name ] );\n\t$parent = isset( $_POST[ 'new' . $taxonomy->name . '_parent' ] ) ? (int) $_POST[ 'new' . $taxonomy->name . '_parent' ] : 0;\n\tif ( 0 > $parent ) {\n\t\t$parent = 0;\n\t}\n\tif ( $taxonomy->name == 'category' ) {\n\t\t$post_category = isset( $_POST['post_category'] ) ? (array) $_POST['post_category'] : array();\n\t} else {\n\t\t$post_category = ( isset( $_POST['tax_input'] ) && isset( $_POST['tax_input'][ $taxonomy->name ] ) ) ? (array) $_POST['tax_input'][ $taxonomy->name ] : array();\n\t}\n\t$checked_categories = array_map( 'absint', (array) $post_category );\n\t$popular_ids        = wp_popular_terms_checklist( $taxonomy->name, 0, 10, false );\n\n\tforeach ( $names as $cat_name ) {\n\t\t$cat_name          = trim( $cat_name );\n\t\t$category_nicename = sanitize_title( $cat_name );\n\t\tif ( '' === $category_nicename ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$cat_id = wp_insert_term( $cat_name, $taxonomy->name, array( 'parent' => $parent ) );\n\t\tif ( ! $cat_id || is_wp_error( $cat_id ) ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t$cat_id = $cat_id['term_id'];\n\t\t}\n\t\t$checked_categories[] = $cat_id;\n\t\tif ( $parent ) { // Do these all at once in a second\n\t\t\tcontinue;\n\t\t}\n\n\t\tob_start();\n\n\t\twp_terms_checklist(\n\t\t\t0,\n\t\t\tarray(\n\t\t\t\t'taxonomy'             => $taxonomy->name,\n\t\t\t\t'descendants_and_self' => $cat_id,\n\t\t\t\t'selected_cats'        => $checked_categories,\n\t\t\t\t'popular_cats'         => $popular_ids,\n\t\t\t)\n\t\t);\n\n\t\t$data = ob_get_clean();\n\n\t\t$add = array(\n\t\t\t'what'     => $taxonomy->name,\n\t\t\t'id'       => $cat_id,\n\t\t\t'data'     => str_replace( array( \"\\n\", \"\\t\" ), '', $data ),\n\t\t\t'position' => -1,\n\t\t);\n\t}\n\n\tif ( $parent ) { // Foncy - replace the parent and all its children\n\t\t$parent  = get_term( $parent, $taxonomy->name );\n\t\t$term_id = $parent->term_id;\n\n\t\twhile ( $parent->parent ) { // get the top parent\n\t\t\t$parent = get_term( $parent->parent, $taxonomy->name );\n\t\t\tif ( is_wp_error( $parent ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$term_id = $parent->term_id;\n\t\t}\n\n\t\tob_start();\n\n\t\twp_terms_checklist(\n\t\t\t0,\n\t\t\tarray(\n\t\t\t\t'taxonomy'             => $taxonomy->name,\n\t\t\t\t'descendants_and_self' => $term_id,\n\t\t\t\t'selected_cats'        => $checked_categories,\n\t\t\t\t'popular_cats'         => $popular_ids,\n\t\t\t)\n\t\t);\n\n\t\t$data = ob_get_clean();\n\n\t\t$add = array(\n\t\t\t'what'     => $taxonomy->name,\n\t\t\t'id'       => $term_id,\n\t\t\t'data'     => str_replace( array( \"\\n\", \"\\t\" ), '', $data ),\n\t\t\t'position' => -1,\n\t\t);\n\t}\n\n\tob_start();\n\n\twp_dropdown_categories(\n\t\tarray(\n\t\t\t'taxonomy'         => $taxonomy->name,\n\t\t\t'hide_empty'       => 0,\n\t\t\t'name'             => 'new' . $taxonomy->name . '_parent',\n\t\t\t'orderby'          => 'name',\n\t\t\t'hierarchical'     => 1,\n\t\t\t'show_option_none' => '&mdash; ' . $taxonomy->labels->parent_item . ' &mdash;',\n\t\t)\n\t);\n\n\t$sup = ob_get_clean();\n\n\t$add['supplemental'] = array( 'newcat_parent' => $sup );\n\n\t$x = new WP_Ajax_Response( $add );\n\t$x->send();\n}\n\n/**\n * Ajax handler for deleting a comment.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_comment() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tif ( ! $comment = get_comment( $id ) ) {\n\t\twp_die( time() );\n\t}\n\tif ( ! current_user_can( 'edit_comment', $comment->comment_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tcheck_ajax_referer( \"delete-comment_$id\" );\n\t$status = wp_get_comment_status( $comment );\n\n\t$delta = -1;\n\tif ( isset( $_POST['trash'] ) && 1 == $_POST['trash'] ) {\n\t\tif ( 'trash' == $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_trash_comment( $comment );\n\t} elseif ( isset( $_POST['untrash'] ) && 1 == $_POST['untrash'] ) {\n\t\tif ( 'trash' != $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_untrash_comment( $comment );\n\t\tif ( ! isset( $_POST['comment_status'] ) || $_POST['comment_status'] != 'trash' ) { // undo trash, not in trash\n\t\t\t$delta = 1;\n\t\t}\n\t} elseif ( isset( $_POST['spam'] ) && 1 == $_POST['spam'] ) {\n\t\tif ( 'spam' == $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_spam_comment( $comment );\n\t} elseif ( isset( $_POST['unspam'] ) && 1 == $_POST['unspam'] ) {\n\t\tif ( 'spam' != $status ) {\n\t\t\twp_die( time() );\n\t\t}\n\t\t$r = wp_unspam_comment( $comment );\n\t\tif ( ! isset( $_POST['comment_status'] ) || $_POST['comment_status'] != 'spam' ) { // undo spam, not in spam\n\t\t\t$delta = 1;\n\t\t}\n\t} elseif ( isset( $_POST['delete'] ) && 1 == $_POST['delete'] ) {\n\t\t$r = wp_delete_comment( $comment );\n\t} else {\n\t\twp_die( -1 );\n\t}\n\n\tif ( $r ) { // Decide if we need to send back '1' or a more complicated response including page links and comment counts\n\t\t_wp_ajax_delete_comment_response( $comment->comment_ID, $delta );\n\t}\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for deleting a tag.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_tag() {\n\t$tag_id = (int) $_POST['tag_ID'];\n\tcheck_ajax_referer( \"delete-tag_$tag_id\" );\n\n\tif ( ! current_user_can( 'delete_term', $tag_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$taxonomy = ! empty( $_POST['taxonomy'] ) ? $_POST['taxonomy'] : 'post_tag';\n\t$tag      = get_term( $tag_id, $taxonomy );\n\tif ( ! $tag || is_wp_error( $tag ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_term( $tag_id, $taxonomy ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler for deleting a link.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_link() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"delete-bookmark_$id\" );\n\tif ( ! current_user_can( 'manage_links' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$link = get_bookmark( $id );\n\tif ( ! $link || is_wp_error( $link ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_link( $id ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler for deleting meta.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_delete_meta() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"delete-meta_$id\" );\n\tif ( ! $meta = get_metadata_by_mid( 'post', $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( is_protected_meta( $meta->meta_key, 'post' ) || ! current_user_can( 'delete_post_meta', $meta->post_id, $meta->meta_key ) ) {\n\t\twp_die( -1 );\n\t}\n\tif ( delete_meta( $meta->meta_id ) ) {\n\t\twp_die( 1 );\n\t}\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for deleting a post.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_delete_post( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'delete-post';\n\t}\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"{$action}_$id\" );\n\tif ( ! current_user_can( 'delete_post', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! get_post( $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_post( $id ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler for sending a post to the trash.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_trash_post( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'trash-post';\n\t}\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"{$action}_$id\" );\n\tif ( ! current_user_can( 'delete_post', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! get_post( $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( 'trash-post' == $action ) {\n\t\t$done = wp_trash_post( $id );\n\t} else {\n\t\t$done = wp_untrash_post( $id );\n\t}\n\n\tif ( $done ) {\n\t\twp_die( 1 );\n\t}\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler to restore a post from the trash.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_untrash_post( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'untrash-post';\n\t}\n\twp_ajax_trash_post( $action );\n}\n\n/**\n * Ajax handler to delete a page.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_delete_page( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'delete-page';\n\t}\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tcheck_ajax_referer( \"{$action}_$id\" );\n\tif ( ! current_user_can( 'delete_page', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! get_post( $id ) ) {\n\t\twp_die( 1 );\n\t}\n\n\tif ( wp_delete_post( $id ) ) {\n\t\twp_die( 1 );\n\t} else {\n\t\twp_die( 0 );\n\t}\n}\n\n/**\n * Ajax handler to dim a comment.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_dim_comment() {\n\t$id = isset( $_POST['id'] ) ? (int) $_POST['id'] : 0;\n\n\tif ( ! $comment = get_comment( $id ) ) {\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what' => 'comment',\n\t\t\t\t/* translators: %d: comment ID */\n\t\t\t\t'id'   => new WP_Error( 'invalid_comment', sprintf( __( 'Comment %d does not exist' ), $id ) ),\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\tif ( ! current_user_can( 'edit_comment', $comment->comment_ID ) && ! current_user_can( 'moderate_comments' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$current = wp_get_comment_status( $comment );\n\tif ( isset( $_POST['new'] ) && $_POST['new'] == $current ) {\n\t\twp_die( time() );\n\t}\n\n\tcheck_ajax_referer( \"approve-comment_$id\" );\n\tif ( in_array( $current, array( 'unapproved', 'spam' ) ) ) {\n\t\t$result = wp_set_comment_status( $comment, 'approve', true );\n\t} else {\n\t\t$result = wp_set_comment_status( $comment, 'hold', true );\n\t}\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what' => 'comment',\n\t\t\t\t'id'   => $result,\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\t// Decide if we need to send back '1' or a more complicated response including page links and comment counts\n\t_wp_ajax_delete_comment_response( $comment->comment_ID );\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for adding a link category.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_add_link_category( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'add-link-category';\n\t}\n\tcheck_ajax_referer( $action );\n\t$tax = get_taxonomy( 'link_category' );\n\tif ( ! current_user_can( $tax->cap->manage_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\t$names = explode( ',', wp_unslash( $_POST['newcat'] ) );\n\t$x     = new WP_Ajax_Response();\n\tforeach ( $names as $cat_name ) {\n\t\t$cat_name = trim( $cat_name );\n\t\t$slug     = sanitize_title( $cat_name );\n\t\tif ( '' === $slug ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t$cat_id = wp_insert_term( $cat_name, 'link_category' );\n\t\tif ( ! $cat_id || is_wp_error( $cat_id ) ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\t$cat_id = $cat_id['term_id'];\n\t\t}\n\t\t$cat_name = esc_html( $cat_name );\n\t\t$x->add(\n\t\t\tarray(\n\t\t\t\t'what'     => 'link-category',\n\t\t\t\t'id'       => $cat_id,\n\t\t\t\t'data'     => \"<li id='link-category-$cat_id'><label for='in-link-category-$cat_id' class='selectit'><input value='\" . esc_attr( $cat_id ) . \"' type='checkbox' checked='checked' name='link_category[]' id='in-link-category-$cat_id'/> $cat_name</label></li>\",\n\t\t\t\t'position' => -1,\n\t\t\t)\n\t\t);\n\t}\n\t$x->send();\n}\n\n/**\n * Ajax handler to add a tag.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_add_tag() {\n\tcheck_ajax_referer( 'add-tag', '_wpnonce_add-tag' );\n\t$taxonomy = ! empty( $_POST['taxonomy'] ) ? $_POST['taxonomy'] : 'post_tag';\n\t$tax      = get_taxonomy( $taxonomy );\n\n\tif ( ! current_user_can( $tax->cap->edit_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$x = new WP_Ajax_Response();\n\n\t$tag = wp_insert_term( $_POST['tag-name'], $taxonomy, $_POST );\n\n\tif ( ! $tag || is_wp_error( $tag ) || ( ! $tag = get_term( $tag['term_id'], $taxonomy ) ) ) {\n\t\t$message = __( 'An error has occurred. Please reload the page and try again.' );\n\t\tif ( is_wp_error( $tag ) && $tag->get_error_message() ) {\n\t\t\t$message = $tag->get_error_message();\n\t\t}\n\n\t\t$x->add(\n\t\t\tarray(\n\t\t\t\t'what' => 'taxonomy',\n\t\t\t\t'data' => new WP_Error( 'error', $message ),\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\n\t$wp_list_table = _get_list_table( 'WP_Terms_List_Table', array( 'screen' => $_POST['screen'] ) );\n\n\t$level = 0;\n\tif ( is_taxonomy_hierarchical( $taxonomy ) ) {\n\t\t$level = count( get_ancestors( $tag->term_id, $taxonomy, 'taxonomy' ) );\n\t\tob_start();\n\t\t$wp_list_table->single_row( $tag, $level );\n\t\t$noparents = ob_get_clean();\n\t}\n\n\tob_start();\n\t$wp_list_table->single_row( $tag );\n\t$parents = ob_get_clean();\n\n\t$x->add(\n\t\tarray(\n\t\t\t'what'         => 'taxonomy',\n\t\t\t'supplemental' => compact( 'parents', 'noparents' ),\n\t\t)\n\t);\n\t$x->add(\n\t\tarray(\n\t\t\t'what'         => 'term',\n\t\t\t'position'     => $level,\n\t\t\t'supplemental' => (array) $tag,\n\t\t)\n\t);\n\t$x->send();\n}\n\n/**\n * Ajax handler for getting a tagcloud.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_get_tagcloud() {\n\tif ( ! isset( $_POST['tax'] ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$taxonomy = sanitize_key( $_POST['tax'] );\n\t$tax      = get_taxonomy( $taxonomy );\n\tif ( ! $tax ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! current_user_can( $tax->cap->assign_terms ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$tags = get_terms(\n\t\t$taxonomy,\n\t\tarray(\n\t\t\t'number'  => 45,\n\t\t\t'orderby' => 'count',\n\t\t\t'order'   => 'DESC',\n\t\t)\n\t);\n\n\tif ( empty( $tags ) ) {\n\t\twp_die( $tax->labels->not_found );\n\t}\n\n\tif ( is_wp_error( $tags ) ) {\n\t\twp_die( $tags->get_error_message() );\n\t}\n\n\tforeach ( $tags as $key => $tag ) {\n\t\t$tags[ $key ]->link = '#';\n\t\t$tags[ $key ]->id   = $tag->term_id;\n\t}\n\n\t// We need raw tag names here, so don't filter the output\n\t$return = wp_generate_tag_cloud(\n\t\t$tags,\n\t\tarray(\n\t\t\t'filter' => 0,\n\t\t\t'format' => 'list',\n\t\t)\n\t);\n\n\tif ( empty( $return ) ) {\n\t\twp_die( 0 );\n\t}\n\n\techo $return;\n\n\twp_die();\n}\n\n/**\n * Ajax handler for getting comments.\n *\n * @since 3.1.0\n *\n * @global int           $post_id\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_get_comments( $action ) {\n\tglobal $post_id;\n\tif ( empty( $action ) ) {\n\t\t$action = 'get-comments';\n\t}\n\tcheck_ajax_referer( $action );\n\n\tif ( empty( $post_id ) && ! empty( $_REQUEST['p'] ) ) {\n\t\t$id = absint( $_REQUEST['p'] );\n\t\tif ( ! empty( $id ) ) {\n\t\t\t$post_id = $id;\n\t\t}\n\t}\n\n\tif ( empty( $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table = _get_list_table( 'WP_Post_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\n\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table->prepare_items();\n\n\tif ( ! $wp_list_table->has_items() ) {\n\t\twp_die( 1 );\n\t}\n\n\t$x = new WP_Ajax_Response();\n\tob_start();\n\tforeach ( $wp_list_table->items as $comment ) {\n\t\tif ( ! current_user_can( 'edit_comment', $comment->comment_ID ) && 0 === $comment->comment_approved ) {\n\t\t\tcontinue;\n\t\t}\n\t\tget_comment( $comment );\n\t\t$wp_list_table->single_row( $comment );\n\t}\n\t$comment_list_item = ob_get_clean();\n\n\t$x->add(\n\t\tarray(\n\t\t\t'what' => 'comments',\n\t\t\t'data' => $comment_list_item,\n\t\t)\n\t);\n\t$x->send();\n}\n\n/**\n * Ajax handler for replying to a comment.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_replyto_comment( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'replyto-comment';\n\t}\n\n\tcheck_ajax_referer( $action, '_ajax_nonce-replyto-comment' );\n\n\t$comment_post_ID = (int) $_POST['comment_post_ID'];\n\t$post            = get_post( $comment_post_ID );\n\tif ( ! $post ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! current_user_can( 'edit_post', $comment_post_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( empty( $post->post_status ) ) {\n\t\twp_die( 1 );\n\t} elseif ( in_array( $post->post_status, array( 'draft', 'pending', 'trash' ) ) ) {\n\t\twp_die( __( 'ERROR: you are replying to a comment on a draft post.' ) );\n\t}\n\n\t$user = wp_get_current_user();\n\tif ( $user->exists() ) {\n\t\t$user_ID              = $user->ID;\n\t\t$comment_author       = wp_slash( $user->display_name );\n\t\t$comment_author_email = wp_slash( $user->user_email );\n\t\t$comment_author_url   = wp_slash( $user->user_url );\n\t\t$comment_content      = trim( $_POST['content'] );\n\t\t$comment_type         = isset( $_POST['comment_type'] ) ? trim( $_POST['comment_type'] ) : '';\n\t\tif ( current_user_can( 'unfiltered_html' ) ) {\n\t\t\tif ( ! isset( $_POST['_wp_unfiltered_html_comment'] ) ) {\n\t\t\t\t$_POST['_wp_unfiltered_html_comment'] = '';\n\t\t\t}\n\n\t\t\tif ( wp_create_nonce( 'unfiltered-html-comment' ) != $_POST['_wp_unfiltered_html_comment'] ) {\n\t\t\t\tkses_remove_filters(); // start with a clean slate\n\t\t\t\tkses_init_filters(); // set up the filters\n\t\t\t\tremove_filter( 'pre_comment_content', 'wp_filter_post_kses' );\n\t\t\t\tadd_filter( 'pre_comment_content', 'wp_filter_kses' );\n\t\t\t}\n\t\t}\n\t} else {\n\t\twp_die( __( 'Sorry, you must be logged in to reply to a comment.' ) );\n\t}\n\n\tif ( '' == $comment_content ) {\n\t\twp_die( __( 'ERROR: please type a comment.' ) );\n\t}\n\n\t$comment_parent = 0;\n\tif ( isset( $_POST['comment_ID'] ) ) {\n\t\t$comment_parent = absint( $_POST['comment_ID'] );\n\t}\n\t$comment_auto_approved = false;\n\t$commentdata           = compact( 'comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_content', 'comment_type', 'comment_parent', 'user_ID' );\n\n\t// Automatically approve parent comment.\n\tif ( ! empty( $_POST['approve_parent'] ) ) {\n\t\t$parent = get_comment( $comment_parent );\n\n\t\tif ( $parent && $parent->comment_approved === '0' && $parent->comment_post_ID == $comment_post_ID ) {\n\t\t\tif ( ! current_user_can( 'edit_comment', $parent->comment_ID ) ) {\n\t\t\t\twp_die( -1 );\n\t\t\t}\n\n\t\t\tif ( wp_set_comment_status( $parent, 'approve' ) ) {\n\t\t\t\t$comment_auto_approved = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t$comment_id = wp_new_comment( $commentdata );\n\n\tif ( is_wp_error( $comment_id ) ) {\n\t\twp_die( $comment_id->get_error_message() );\n\t}\n\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\twp_die( 1 );\n\t}\n\n\t$position = ( isset( $_POST['position'] ) && (int) $_POST['position'] ) ? (int) $_POST['position'] : '-1';\n\n\tob_start();\n\tif ( isset( $_REQUEST['mode'] ) && 'dashboard' == $_REQUEST['mode'] ) {\n\t\trequire_once( ABSPATH . 'wp-admin/includes/dashboard.php' );\n\t\t_wp_dashboard_recent_comments_row( $comment );\n\t} else {\n\t\tif ( isset( $_REQUEST['mode'] ) && 'single' == $_REQUEST['mode'] ) {\n\t\t\t$wp_list_table = _get_list_table( 'WP_Post_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\t\t} else {\n\t\t\t$wp_list_table = _get_list_table( 'WP_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\t\t}\n\t\t$wp_list_table->single_row( $comment );\n\t}\n\t$comment_list_item = ob_get_clean();\n\n\t$response = array(\n\t\t'what'     => 'comment',\n\t\t'id'       => $comment->comment_ID,\n\t\t'data'     => $comment_list_item,\n\t\t'position' => $position,\n\t);\n\n\t$counts                   = wp_count_comments();\n\t$response['supplemental'] = array(\n\t\t'in_moderation'        => $counts->moderated,\n\t\t'i18n_comments_text'   => sprintf(\n\t\t\t/* translators: %s: number of comments approved */\n\t\t\t_n( '%s Comment', '%s Comments', $counts->approved ),\n\t\t\tnumber_format_i18n( $counts->approved )\n\t\t),\n\t\t'i18n_moderation_text' => sprintf(\n\t\t\t/* translators: %s: number of comments moderated */\n\t\t\t_nx( '%s in moderation', '%s in moderation', $counts->moderated, 'comments' ),\n\t\t\tnumber_format_i18n( $counts->moderated )\n\t\t),\n\t);\n\n\tif ( $comment_auto_approved ) {\n\t\t$response['supplemental']['parent_approved'] = $parent->comment_ID;\n\t\t$response['supplemental']['parent_post_id']  = $parent->comment_post_ID;\n\t}\n\n\t$x = new WP_Ajax_Response();\n\t$x->add( $response );\n\t$x->send();\n}\n\n/**\n * Ajax handler for editing a comment.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_edit_comment() {\n\tcheck_ajax_referer( 'replyto-comment', '_ajax_nonce-replyto-comment' );\n\n\t$comment_id = (int) $_POST['comment_ID'];\n\tif ( ! current_user_can( 'edit_comment', $comment_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( '' == $_POST['content'] ) {\n\t\twp_die( __( 'ERROR: please type a comment.' ) );\n\t}\n\n\tif ( isset( $_POST['status'] ) ) {\n\t\t$_POST['comment_status'] = $_POST['status'];\n\t}\n\tedit_comment();\n\n\t$position      = ( isset( $_POST['position'] ) && (int) $_POST['position'] ) ? (int) $_POST['position'] : '-1';\n\t$checkbox      = ( isset( $_POST['checkbox'] ) && true == $_POST['checkbox'] ) ? 1 : 0;\n\t$wp_list_table = _get_list_table( $checkbox ? 'WP_Comments_List_Table' : 'WP_Post_Comments_List_Table', array( 'screen' => 'edit-comments' ) );\n\n\t$comment = get_comment( $comment_id );\n\tif ( empty( $comment->comment_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tob_start();\n\t$wp_list_table->single_row( $comment );\n\t$comment_list_item = ob_get_clean();\n\n\t$x = new WP_Ajax_Response();\n\n\t$x->add(\n\t\tarray(\n\t\t\t'what'     => 'edit_comment',\n\t\t\t'id'       => $comment->comment_ID,\n\t\t\t'data'     => $comment_list_item,\n\t\t\t'position' => $position,\n\t\t)\n\t);\n\n\t$x->send();\n}\n\n/**\n * Ajax handler for adding a menu item.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_add_menu_item() {\n\tcheck_ajax_referer( 'add-menu_item', 'menu-settings-column-nonce' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\trequire_once ABSPATH . 'wp-admin/includes/nav-menu.php';\n\n\t// For performance reasons, we omit some object properties from the checklist.\n\t// The following is a hacky way to restore them when adding non-custom items.\n\n\t$menu_items_data = array();\n\tforeach ( (array) $_POST['menu-item'] as $menu_item_data ) {\n\t\tif (\n\t\t\t! empty( $menu_item_data['menu-item-type'] ) &&\n\t\t\t'custom' != $menu_item_data['menu-item-type'] &&\n\t\t\t! empty( $menu_item_data['menu-item-object-id'] )\n\t\t) {\n\t\t\tswitch ( $menu_item_data['menu-item-type'] ) {\n\t\t\t\tcase 'post_type':\n\t\t\t\t\t$_object = get_post( $menu_item_data['menu-item-object-id'] );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'post_type_archive':\n\t\t\t\t\t$_object = get_post_type_object( $menu_item_data['menu-item-object'] );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'taxonomy':\n\t\t\t\t\t$_object = get_term( $menu_item_data['menu-item-object-id'], $menu_item_data['menu-item-object'] );\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t$_menu_items = array_map( 'wp_setup_nav_menu_item', array( $_object ) );\n\t\t\t$_menu_item  = reset( $_menu_items );\n\n\t\t\t// Restore the missing menu item properties\n\t\t\t$menu_item_data['menu-item-description'] = $_menu_item->description;\n\t\t}\n\n\t\t$menu_items_data[] = $menu_item_data;\n\t}\n\n\t$item_ids = wp_save_nav_menu_items( 0, $menu_items_data );\n\tif ( is_wp_error( $item_ids ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$menu_items = array();\n\n\tforeach ( (array) $item_ids as $menu_item_id ) {\n\t\t$menu_obj = get_post( $menu_item_id );\n\t\tif ( ! empty( $menu_obj->ID ) ) {\n\t\t\t$menu_obj        = wp_setup_nav_menu_item( $menu_obj );\n\t\t\t$menu_obj->label = $menu_obj->title; // don't show \"(pending)\" in ajax-added items\n\t\t\t$menu_items[]    = $menu_obj;\n\t\t}\n\t}\n\n\t/** This filter is documented in wp-admin/includes/nav-menu.php */\n\t$walker_class_name = apply_filters( 'wp_edit_nav_menu_walker', 'Walker_Nav_Menu_Edit', $_POST['menu'] );\n\n\tif ( ! class_exists( $walker_class_name ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! empty( $menu_items ) ) {\n\t\t$args = array(\n\t\t\t'after'       => '',\n\t\t\t'before'      => '',\n\t\t\t'link_after'  => '',\n\t\t\t'link_before' => '',\n\t\t\t'walker'      => new $walker_class_name,\n\t\t);\n\t\techo walk_nav_menu_tree( $menu_items, 0, (object) $args );\n\t}\n\twp_die();\n}\n\n/**\n * Ajax handler for adding meta.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_add_meta() {\n\tcheck_ajax_referer( 'add-meta', '_ajax_nonce-add-meta' );\n\t$c    = 0;\n\t$pid  = (int) $_POST['post_id'];\n\t$post = get_post( $pid );\n\n\tif ( isset( $_POST['metakeyselect'] ) || isset( $_POST['metakeyinput'] ) ) {\n\t\tif ( ! current_user_can( 'edit_post', $pid ) ) {\n\t\t\twp_die( -1 );\n\t\t}\n\t\tif ( isset( $_POST['metakeyselect'] ) && '#NONE#' == $_POST['metakeyselect'] && empty( $_POST['metakeyinput'] ) ) {\n\t\t\twp_die( 1 );\n\t\t}\n\n\t\t// If the post is an autodraft, save the post as a draft and then attempt to save the meta.\n\t\tif ( $post->post_status == 'auto-draft' ) {\n\t\t\t$post_data                = array();\n\t\t\t$post_data['action']      = 'draft'; // Warning fix\n\t\t\t$post_data['post_ID']     = $pid;\n\t\t\t$post_data['post_type']   = $post->post_type;\n\t\t\t$post_data['post_status'] = 'draft';\n\t\t\t$now                      = time();\n\t\t\t/* translators: 1: Post creation date, 2: Post creation time */\n\t\t\t$post_data['post_title'] = sprintf( __( 'Draft created on %1$s at %2$s' ), date( __( 'F j, Y' ), $now ), date( __( 'g:i a' ), $now ) );\n\n\t\t\t$pid = edit_post( $post_data );\n\t\t\tif ( $pid ) {\n\t\t\t\tif ( is_wp_error( $pid ) ) {\n\t\t\t\t\t$x = new WP_Ajax_Response(\n\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t'what' => 'meta',\n\t\t\t\t\t\t\t'data' => $pid,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\t$x->send();\n\t\t\t\t}\n\n\t\t\t\tif ( ! $mid = add_meta( $pid ) ) {\n\t\t\t\t\twp_die( __( 'Please provide a custom field value.' ) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twp_die( 0 );\n\t\t\t}\n\t\t} elseif ( ! $mid = add_meta( $pid ) ) {\n\t\t\twp_die( __( 'Please provide a custom field value.' ) );\n\t\t}\n\n\t\t$meta = get_metadata_by_mid( 'post', $mid );\n\t\t$pid  = (int) $meta->post_id;\n\t\t$meta = get_object_vars( $meta );\n\t\t$x    = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what'         => 'meta',\n\t\t\t\t'id'           => $mid,\n\t\t\t\t'data'         => _list_meta_row( $meta, $c ),\n\t\t\t\t'position'     => 1,\n\t\t\t\t'supplemental' => array( 'postid' => $pid ),\n\t\t\t)\n\t\t);\n\t} else { // Update?\n\t\t$mid   = (int) key( $_POST['meta'] );\n\t\t$key   = wp_unslash( $_POST['meta'][ $mid ]['key'] );\n\t\t$value = wp_unslash( $_POST['meta'][ $mid ]['value'] );\n\t\tif ( '' == trim( $key ) ) {\n\t\t\twp_die( __( 'Please provide a custom field name.' ) );\n\t\t}\n\t\tif ( ! $meta = get_metadata_by_mid( 'post', $mid ) ) {\n\t\t\twp_die( 0 ); // if meta doesn't exist\n\t\t}\n\t\tif ( is_protected_meta( $meta->meta_key, 'post' ) || is_protected_meta( $key, 'post' ) ||\n\t\t\t! current_user_can( 'edit_post_meta', $meta->post_id, $meta->meta_key ) ||\n\t\t\t! current_user_can( 'edit_post_meta', $meta->post_id, $key ) ) {\n\t\t\twp_die( -1 );\n\t\t}\n\t\tif ( $meta->meta_value != $value || $meta->meta_key != $key ) {\n\t\t\tif ( ! $u = update_metadata_by_mid( 'post', $mid, $value, $key ) ) {\n\t\t\t\twp_die( 0 ); // We know meta exists; we also know it's unchanged (or DB error, in which case there are bigger problems).\n\t\t\t}\n\t\t}\n\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what'         => 'meta',\n\t\t\t\t'id'           => $mid,\n\t\t\t\t'old_id'       => $mid,\n\t\t\t\t'data'         => _list_meta_row(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'meta_key'   => $key,\n\t\t\t\t\t\t'meta_value' => $value,\n\t\t\t\t\t\t'meta_id'    => $mid,\n\t\t\t\t\t),\n\t\t\t\t\t$c\n\t\t\t\t),\n\t\t\t\t'position'     => 0,\n\t\t\t\t'supplemental' => array( 'postid' => $meta->post_id ),\n\t\t\t)\n\t\t);\n\t}\n\t$x->send();\n}\n\n/**\n * Ajax handler for adding a user.\n *\n * @since 3.1.0\n *\n * @param string $action Action to perform.\n */\nfunction wp_ajax_add_user( $action ) {\n\tif ( empty( $action ) ) {\n\t\t$action = 'add-user';\n\t}\n\n\tcheck_ajax_referer( $action );\n\tif ( ! current_user_can( 'create_users' ) ) {\n\t\twp_die( -1 );\n\t}\n\tif ( ! $user_id = edit_user() ) {\n\t\twp_die( 0 );\n\t} elseif ( is_wp_error( $user_id ) ) {\n\t\t$x = new WP_Ajax_Response(\n\t\t\tarray(\n\t\t\t\t'what' => 'user',\n\t\t\t\t'id'   => $user_id,\n\t\t\t)\n\t\t);\n\t\t$x->send();\n\t}\n\t$user_object = get_userdata( $user_id );\n\n\t$wp_list_table = _get_list_table( 'WP_Users_List_Table' );\n\n\t$role = current( $user_object->roles );\n\n\t$x = new WP_Ajax_Response(\n\t\tarray(\n\t\t\t'what'         => 'user',\n\t\t\t'id'           => $user_id,\n\t\t\t'data'         => $wp_list_table->single_row( $user_object, '', $role ),\n\t\t\t'supplemental' => array(\n\t\t\t\t'show-link' => sprintf(\n\t\t\t\t\t/* translators: %s: the new user */\n\t\t\t\t\t__( 'User %s added' ),\n\t\t\t\t\t'<a href=\"#user-' . $user_id . '\">' . $user_object->user_login . '</a>'\n\t\t\t\t),\n\t\t\t\t'role'      => $role,\n\t\t\t),\n\t\t)\n\t);\n\t$x->send();\n}\n\n/**\n * Ajax handler for closed post boxes.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_closed_postboxes() {\n\tcheck_ajax_referer( 'closedpostboxes', 'closedpostboxesnonce' );\n\t$closed = isset( $_POST['closed'] ) ? explode( ',', $_POST['closed'] ) : array();\n\t$closed = array_filter( $closed );\n\n\t$hidden = isset( $_POST['hidden'] ) ? explode( ',', $_POST['hidden'] ) : array();\n\t$hidden = array_filter( $hidden );\n\n\t$page = isset( $_POST['page'] ) ? $_POST['page'] : '';\n\n\tif ( $page != sanitize_key( $page ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $user = wp_get_current_user() ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( is_array( $closed ) ) {\n\t\tupdate_user_option( $user->ID, \"closedpostboxes_$page\", $closed, true );\n\t}\n\n\tif ( is_array( $hidden ) ) {\n\t\t$hidden = array_diff( $hidden, array( 'submitdiv', 'linksubmitdiv', 'manage-menu', 'create-menu' ) ); // postboxes that are always shown\n\t\tupdate_user_option( $user->ID, \"metaboxhidden_$page\", $hidden, true );\n\t}\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for hidden columns.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_hidden_columns() {\n\tcheck_ajax_referer( 'screen-options-nonce', 'screenoptionnonce' );\n\t$page = isset( $_POST['page'] ) ? $_POST['page'] : '';\n\n\tif ( $page != sanitize_key( $page ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $user = wp_get_current_user() ) {\n\t\twp_die( -1 );\n\t}\n\n\t$hidden = ! empty( $_POST['hidden'] ) ? explode( ',', $_POST['hidden'] ) : array();\n\tupdate_user_option( $user->ID, \"manage{$page}columnshidden\", $hidden, true );\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for updating whether to display the welcome panel.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_update_welcome_panel() {\n\tcheck_ajax_referer( 'welcome-panel-nonce', 'welcomepanelnonce' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tupdate_user_meta( get_current_user_id(), 'show_welcome_panel', empty( $_POST['visible'] ) ? 0 : 1 );\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for retrieving menu meta boxes.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_menu_get_metabox() {\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\trequire_once ABSPATH . 'wp-admin/includes/nav-menu.php';\n\n\tif ( isset( $_POST['item-type'] ) && 'post_type' == $_POST['item-type'] ) {\n\t\t$type     = 'posttype';\n\t\t$callback = 'wp_nav_menu_item_post_type_meta_box';\n\t\t$items    = (array) get_post_types( array( 'show_in_nav_menus' => true ), 'object' );\n\t} elseif ( isset( $_POST['item-type'] ) && 'taxonomy' == $_POST['item-type'] ) {\n\t\t$type     = 'taxonomy';\n\t\t$callback = 'wp_nav_menu_item_taxonomy_meta_box';\n\t\t$items    = (array) get_taxonomies( array( 'show_ui' => true ), 'object' );\n\t}\n\n\tif ( ! empty( $_POST['item-object'] ) && isset( $items[ $_POST['item-object'] ] ) ) {\n\t\t$menus_meta_box_object = $items[ $_POST['item-object'] ];\n\n\t\t/** This filter is documented in wp-admin/includes/nav-menu.php */\n\t\t$item = apply_filters( 'nav_menu_meta_box_object', $menus_meta_box_object );\n\t\tob_start();\n\t\tcall_user_func_array(\n\t\t\t$callback,\n\t\t\tarray(\n\t\t\t\tnull,\n\t\t\t\tarray(\n\t\t\t\t\t'id'       => 'add-' . $item->name,\n\t\t\t\t\t'title'    => $item->labels->name,\n\t\t\t\t\t'callback' => $callback,\n\t\t\t\t\t'args'     => $item,\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\n\t\t$markup = ob_get_clean();\n\n\t\techo wp_json_encode(\n\t\t\tarray(\n\t\t\t\t'replace-id' => $type . '-' . $item->name,\n\t\t\t\t'markup'     => $markup,\n\t\t\t)\n\t\t);\n\t}\n\n\twp_die();\n}\n\n/**\n * Ajax handler for internal linking.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_wp_link_ajax() {\n\tcheck_ajax_referer( 'internal-linking', '_ajax_linking_nonce' );\n\n\t$args = array();\n\n\tif ( isset( $_POST['search'] ) ) {\n\t\t$args['s'] = wp_unslash( $_POST['search'] );\n\t}\n\n\tif ( isset( $_POST['term'] ) ) {\n\t\t$args['s'] = wp_unslash( $_POST['term'] );\n\t}\n\n\t$args['pagenum'] = ! empty( $_POST['page'] ) ? absint( $_POST['page'] ) : 1;\n\n\tif ( ! class_exists( '_WP_Editors', false ) ) {\n\t\trequire( ABSPATH . WPINC . '/class-wp-editor.php' );\n\t}\n\n\t$results = _WP_Editors::wp_link_query( $args );\n\n\tif ( ! isset( $results ) ) {\n\t\twp_die( 0 );\n\t}\n\n\techo wp_json_encode( $results );\n\techo \"\\n\";\n\n\twp_die();\n}\n\n/**\n * Ajax handler for menu locations save.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_menu_locations_save() {\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\tcheck_ajax_referer( 'add-menu_item', 'menu-settings-column-nonce' );\n\tif ( ! isset( $_POST['menu-locations'] ) ) {\n\t\twp_die( 0 );\n\t}\n\tset_theme_mod( 'nav_menu_locations', array_map( 'absint', $_POST['menu-locations'] ) );\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for saving the meta box order.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_meta_box_order() {\n\tcheck_ajax_referer( 'meta-box-order' );\n\t$order        = isset( $_POST['order'] ) ? (array) $_POST['order'] : false;\n\t$page_columns = isset( $_POST['page_columns'] ) ? $_POST['page_columns'] : 'auto';\n\n\tif ( $page_columns != 'auto' ) {\n\t\t$page_columns = (int) $page_columns;\n\t}\n\n\t$page = isset( $_POST['page'] ) ? $_POST['page'] : '';\n\n\tif ( $page != sanitize_key( $page ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! $user = wp_get_current_user() ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( $order ) {\n\t\tupdate_user_option( $user->ID, \"meta-box-order_$page\", $order, true );\n\t}\n\n\tif ( $page_columns ) {\n\t\tupdate_user_option( $user->ID, \"screen_layout_$page\", $page_columns, true );\n\t}\n\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for menu quick searching.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_menu_quick_search() {\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\trequire_once ABSPATH . 'wp-admin/includes/nav-menu.php';\n\n\t_wp_ajax_menu_quick_search( $_POST );\n\n\twp_die();\n}\n\n/**\n * Ajax handler to retrieve a permalink.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_get_permalink() {\n\tcheck_ajax_referer( 'getpermalink', 'getpermalinknonce' );\n\t$post_id = isset( $_POST['post_id'] ) ? intval( $_POST['post_id'] ) : 0;\n\twp_die( get_preview_post_link( $post_id ) );\n}\n\n/**\n * Ajax handler to retrieve a sample permalink.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_sample_permalink() {\n\tcheck_ajax_referer( 'samplepermalink', 'samplepermalinknonce' );\n\t$post_id = isset( $_POST['post_id'] ) ? intval( $_POST['post_id'] ) : 0;\n\t$title   = isset( $_POST['new_title'] ) ? $_POST['new_title'] : '';\n\t$slug    = isset( $_POST['new_slug'] ) ? $_POST['new_slug'] : null;\n\twp_die( get_sample_permalink_html( $post_id, $title, $slug ) );\n}\n\n/**\n * Ajax handler for Quick Edit saving a post from a list table.\n *\n * @since 3.1.0\n *\n * @global string $mode List table view mode.\n */\nfunction wp_ajax_inline_save() {\n\tglobal $mode;\n\n\tcheck_ajax_referer( 'inlineeditnonce', '_inline_edit' );\n\n\tif ( ! isset( $_POST['post_ID'] ) || ! ( $post_ID = (int) $_POST['post_ID'] ) ) {\n\t\twp_die();\n\t}\n\n\tif ( 'page' == $_POST['post_type'] ) {\n\t\tif ( ! current_user_can( 'edit_page', $post_ID ) ) {\n\t\t\twp_die( __( 'Sorry, you are not allowed to edit this page.' ) );\n\t\t}\n\t} else {\n\t\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\t\twp_die( __( 'Sorry, you are not allowed to edit this post.' ) );\n\t\t}\n\t}\n\n\tif ( $last = wp_check_post_lock( $post_ID ) ) {\n\t\t$last_user      = get_userdata( $last );\n\t\t$last_user_name = $last_user ? $last_user->display_name : __( 'Someone' );\n\n\t\t/* translators: %s: user who is currently editing the post */\n\t\t$msg_template = __( 'Saving is disabled: %s is currently editing this post.' );\n\t\tif ( $_POST['post_type'] == 'page' ) {\n\t\t\t/* translators: %s: user who is currently editing the page */\n\t\t\t$msg_template = __( 'Saving is disabled: %s is currently editing this page.' );\n\t\t}\n\n\t\tprintf( $msg_template, esc_html( $last_user_name ) );\n\t\twp_die();\n\t}\n\n\t$data = &$_POST;\n\n\t$post = get_post( $post_ID, ARRAY_A );\n\n\t// Since it's coming from the database.\n\t$post = wp_slash( $post );\n\n\t$data['content'] = $post['post_content'];\n\t$data['excerpt'] = $post['post_excerpt'];\n\n\t// Rename.\n\t$data['user_ID'] = get_current_user_id();\n\n\tif ( isset( $data['post_parent'] ) ) {\n\t\t$data['parent_id'] = $data['post_parent'];\n\t}\n\n\t// Status.\n\tif ( isset( $data['keep_private'] ) && 'private' == $data['keep_private'] ) {\n\t\t$data['visibility']  = 'private';\n\t\t$data['post_status'] = 'private';\n\t} else {\n\t\t$data['post_status'] = $data['_status'];\n\t}\n\n\tif ( empty( $data['comment_status'] ) ) {\n\t\t$data['comment_status'] = 'closed';\n\t}\n\tif ( empty( $data['ping_status'] ) ) {\n\t\t$data['ping_status'] = 'closed';\n\t}\n\n\t// Exclude terms from taxonomies that are not supposed to appear in Quick Edit.\n\tif ( ! empty( $data['tax_input'] ) ) {\n\t\tforeach ( $data['tax_input'] as $taxonomy => $terms ) {\n\t\t\t$tax_object = get_taxonomy( $taxonomy );\n\t\t\t/** This filter is documented in wp-admin/includes/class-wp-posts-list-table.php */\n\t\t\tif ( ! apply_filters( 'quick_edit_show_taxonomy', $tax_object->show_in_quick_edit, $taxonomy, $post['post_type'] ) ) {\n\t\t\t\tunset( $data['tax_input'][ $taxonomy ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Hack: wp_unique_post_slug() doesn't work for drafts, so we will fake that our post is published.\n\tif ( ! empty( $data['post_name'] ) && in_array( $post['post_status'], array( 'draft', 'pending' ) ) ) {\n\t\t$post['post_status'] = 'publish';\n\t\t$data['post_name']   = wp_unique_post_slug( $data['post_name'], $post['ID'], $post['post_status'], $post['post_type'], $post['post_parent'] );\n\t}\n\n\t// Update the post.\n\tedit_post();\n\n\t$wp_list_table = _get_list_table( 'WP_Posts_List_Table', array( 'screen' => $_POST['screen'] ) );\n\n\t$mode = $_POST['post_view'] === 'excerpt' ? 'excerpt' : 'list';\n\n\t$level = 0;\n\tif ( is_post_type_hierarchical( $wp_list_table->screen->post_type ) ) {\n\t\t$request_post = array( get_post( $_POST['post_ID'] ) );\n\t\t$parent       = $request_post[0]->post_parent;\n\n\t\twhile ( $parent > 0 ) {\n\t\t\t$parent_post = get_post( $parent );\n\t\t\t$parent      = $parent_post->post_parent;\n\t\t\t$level++;\n\t\t}\n\t}\n\n\t$wp_list_table->display_rows( array( get_post( $_POST['post_ID'] ) ), $level );\n\n\twp_die();\n}\n\n/**\n * Ajax handler for quick edit saving for a term.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_inline_save_tax() {\n\tcheck_ajax_referer( 'taxinlineeditnonce', '_inline_edit' );\n\n\t$taxonomy = sanitize_key( $_POST['taxonomy'] );\n\t$tax      = get_taxonomy( $taxonomy );\n\tif ( ! $tax ) {\n\t\twp_die( 0 );\n\t}\n\n\tif ( ! isset( $_POST['tax_ID'] ) || ! ( $id = (int) $_POST['tax_ID'] ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tif ( ! current_user_can( 'edit_term', $id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$wp_list_table = _get_list_table( 'WP_Terms_List_Table', array( 'screen' => 'edit-' . $taxonomy ) );\n\n\t$tag                  = get_term( $id, $taxonomy );\n\t$_POST['description'] = $tag->description;\n\n\t$updated = wp_update_term( $id, $taxonomy, $_POST );\n\tif ( $updated && ! is_wp_error( $updated ) ) {\n\t\t$tag = get_term( $updated['term_id'], $taxonomy );\n\t\tif ( ! $tag || is_wp_error( $tag ) ) {\n\t\t\tif ( is_wp_error( $tag ) && $tag->get_error_message() ) {\n\t\t\t\twp_die( $tag->get_error_message() );\n\t\t\t}\n\t\t\twp_die( __( 'Item not updated.' ) );\n\t\t}\n\t} else {\n\t\tif ( is_wp_error( $updated ) && $updated->get_error_message() ) {\n\t\t\twp_die( $updated->get_error_message() );\n\t\t}\n\t\twp_die( __( 'Item not updated.' ) );\n\t}\n\t$level  = 0;\n\t$parent = $tag->parent;\n\twhile ( $parent > 0 ) {\n\t\t$parent_tag = get_term( $parent, $taxonomy );\n\t\t$parent     = $parent_tag->parent;\n\t\t$level++;\n\t}\n\t$wp_list_table->single_row( $tag, $level );\n\twp_die();\n}\n\n/**\n * Ajax handler for querying posts for the Find Posts modal.\n *\n * @see window.findPosts\n *\n * @since 3.1.0\n */\nfunction wp_ajax_find_posts() {\n\tcheck_ajax_referer( 'find-posts' );\n\n\t$post_types = get_post_types( array( 'public' => true ), 'objects' );\n\tunset( $post_types['attachment'] );\n\n\t$s    = wp_unslash( $_POST['ps'] );\n\t$args = array(\n\t\t'post_type'      => array_keys( $post_types ),\n\t\t'post_status'    => 'any',\n\t\t'posts_per_page' => 50,\n\t);\n\tif ( '' !== $s ) {\n\t\t$args['s'] = $s;\n\t}\n\n\t$posts = get_posts( $args );\n\n\tif ( ! $posts ) {\n\t\twp_send_json_error( __( 'No items found.' ) );\n\t}\n\n\t$html = '<table class=\"widefat\"><thead><tr><th class=\"found-radio\"><br /></th><th>' . __( 'Title' ) . '</th><th class=\"no-break\">' . __( 'Type' ) . '</th><th class=\"no-break\">' . __( 'Date' ) . '</th><th class=\"no-break\">' . __( 'Status' ) . '</th></tr></thead><tbody>';\n\t$alt  = '';\n\tforeach ( $posts as $post ) {\n\t\t$title = trim( $post->post_title ) ? $post->post_title : __( '(no title)' );\n\t\t$alt   = ( 'alternate' == $alt ) ? '' : 'alternate';\n\n\t\tswitch ( $post->post_status ) {\n\t\t\tcase 'publish':\n\t\t\tcase 'private':\n\t\t\t\t$stat = __( 'Published' );\n\t\t\t\tbreak;\n\t\t\tcase 'future':\n\t\t\t\t$stat = __( 'Scheduled' );\n\t\t\t\tbreak;\n\t\t\tcase 'pending':\n\t\t\t\t$stat = __( 'Pending Review' );\n\t\t\t\tbreak;\n\t\t\tcase 'draft':\n\t\t\t\t$stat = __( 'Draft' );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ( '0000-00-00 00:00:00' == $post->post_date ) {\n\t\t\t$time = '';\n\t\t} else {\n\t\t\t/* translators: date format in table columns, see https://secure.php.net/date */\n\t\t\t$time = mysql2date( __( 'Y/m/d' ), $post->post_date );\n\t\t}\n\n\t\t$html .= '<tr class=\"' . trim( 'found-posts ' . $alt ) . '\"><td class=\"found-radio\"><input type=\"radio\" id=\"found-' . $post->ID . '\" name=\"found_post_id\" value=\"' . esc_attr( $post->ID ) . '\"></td>';\n\t\t$html .= '<td><label for=\"found-' . $post->ID . '\">' . esc_html( $title ) . '</label></td><td class=\"no-break\">' . esc_html( $post_types[ $post->post_type ]->labels->singular_name ) . '</td><td class=\"no-break\">' . esc_html( $time ) . '</td><td class=\"no-break\">' . esc_html( $stat ) . ' </td></tr>' . \"\\n\\n\";\n\t}\n\n\t$html .= '</tbody></table>';\n\n\twp_send_json_success( $html );\n}\n\n/**\n * Ajax handler for saving the widgets order.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_widgets_order() {\n\tcheck_ajax_referer( 'save-sidebar-widgets', 'savewidgets' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tunset( $_POST['savewidgets'], $_POST['action'] );\n\n\t// Save widgets order for all sidebars.\n\tif ( is_array( $_POST['sidebars'] ) ) {\n\t\t$sidebars = array();\n\t\tforeach ( wp_unslash( $_POST['sidebars'] ) as $key => $val ) {\n\t\t\t$sb = array();\n\t\t\tif ( ! empty( $val ) ) {\n\t\t\t\t$val = explode( ',', $val );\n\t\t\t\tforeach ( $val as $k => $v ) {\n\t\t\t\t\tif ( strpos( $v, 'widget-' ) === false ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$sb[ $k ] = substr( $v, strpos( $v, '_' ) + 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\t$sidebars[ $key ] = $sb;\n\t\t}\n\t\twp_set_sidebars_widgets( $sidebars );\n\t\twp_die( 1 );\n\t}\n\n\twp_die( -1 );\n}\n\n/**\n * Ajax handler for saving a widget.\n *\n * @since 3.1.0\n *\n * @global array $wp_registered_widgets\n * @global array $wp_registered_widget_controls\n * @global array $wp_registered_widget_updates\n */\nfunction wp_ajax_save_widget() {\n\tglobal $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates;\n\n\tcheck_ajax_referer( 'save-sidebar-widgets', 'savewidgets' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) || ! isset( $_POST['id_base'] ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tunset( $_POST['savewidgets'], $_POST['action'] );\n\n\t/**\n\t * Fires early when editing the widgets displayed in sidebars.\n\t *\n\t * @since 2.8.0\n\t */\n\tdo_action( 'load-widgets.php' );\n\n\t/**\n\t * Fires early when editing the widgets displayed in sidebars.\n\t *\n\t * @since 2.8.0\n\t */\n\tdo_action( 'widgets.php' );\n\n\t/** This action is documented in wp-admin/widgets.php */\n\tdo_action( 'sidebar_admin_setup' );\n\n\t$id_base      = wp_unslash( $_POST['id_base'] );\n\t$widget_id    = wp_unslash( $_POST['widget-id'] );\n\t$sidebar_id   = $_POST['sidebar'];\n\t$multi_number = ! empty( $_POST['multi_number'] ) ? (int) $_POST['multi_number'] : 0;\n\t$settings     = isset( $_POST[ 'widget-' . $id_base ] ) && is_array( $_POST[ 'widget-' . $id_base ] ) ? $_POST[ 'widget-' . $id_base ] : false;\n\t$error        = '<p>' . __( 'An error has occurred. Please reload the page and try again.' ) . '</p>';\n\n\t$sidebars = wp_get_sidebars_widgets();\n\t$sidebar  = isset( $sidebars[ $sidebar_id ] ) ? $sidebars[ $sidebar_id ] : array();\n\n\t// Delete.\n\tif ( isset( $_POST['delete_widget'] ) && $_POST['delete_widget'] ) {\n\n\t\tif ( ! isset( $wp_registered_widgets[ $widget_id ] ) ) {\n\t\t\twp_die( $error );\n\t\t}\n\n\t\t$sidebar = array_diff( $sidebar, array( $widget_id ) );\n\t\t$_POST   = array(\n\t\t\t'sidebar'            => $sidebar_id,\n\t\t\t'widget-' . $id_base => array(),\n\t\t\t'the-widget-id'      => $widget_id,\n\t\t\t'delete_widget'      => '1',\n\t\t);\n\n\t\t/** This action is documented in wp-admin/widgets.php */\n\t\tdo_action( 'delete_widget', $widget_id, $sidebar_id, $id_base );\n\n\t} elseif ( $settings && preg_match( '/__i__|%i%/', key( $settings ) ) ) {\n\t\tif ( ! $multi_number ) {\n\t\t\twp_die( $error );\n\t\t}\n\n\t\t$_POST[ 'widget-' . $id_base ] = array( $multi_number => reset( $settings ) );\n\t\t$widget_id                     = $id_base . '-' . $multi_number;\n\t\t$sidebar[]                     = $widget_id;\n\t}\n\t$_POST['widget-id'] = $sidebar;\n\n\tforeach ( (array) $wp_registered_widget_updates as $name => $control ) {\n\n\t\tif ( $name == $id_base ) {\n\t\t\tif ( ! is_callable( $control['callback'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tob_start();\n\t\t\t\tcall_user_func_array( $control['callback'], $control['params'] );\n\t\t\tob_end_clean();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( isset( $_POST['delete_widget'] ) && $_POST['delete_widget'] ) {\n\t\t$sidebars[ $sidebar_id ] = $sidebar;\n\t\twp_set_sidebars_widgets( $sidebars );\n\t\techo \"deleted:$widget_id\";\n\t\twp_die();\n\t}\n\n\tif ( ! empty( $_POST['add_new'] ) ) {\n\t\twp_die();\n\t}\n\n\tif ( $form = $wp_registered_widget_controls[ $widget_id ] ) {\n\t\tcall_user_func_array( $form['callback'], $form['params'] );\n\t}\n\n\twp_die();\n}\n\n/**\n * Ajax handler for saving a widget.\n *\n * @since 3.9.0\n *\n * @global WP_Customize_Manager $wp_customize\n */\nfunction wp_ajax_update_widget() {\n\tglobal $wp_customize;\n\t$wp_customize->widgets->wp_ajax_update_widget();\n}\n\n/**\n * Ajax handler for removing inactive widgets.\n *\n * @since 4.4.0\n */\nfunction wp_ajax_delete_inactive_widgets() {\n\tcheck_ajax_referer( 'remove-inactive-widgets', 'removeinactivewidgets' );\n\n\tif ( ! current_user_can( 'edit_theme_options' ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tunset( $_POST['removeinactivewidgets'], $_POST['action'] );\n\t/** This action is documented in wp-admin/includes/ajax-actions.php */\n\tdo_action( 'load-widgets.php' );\n\t/** This action is documented in wp-admin/includes/ajax-actions.php */\n\tdo_action( 'widgets.php' );\n\t/** This action is documented in wp-admin/widgets.php */\n\tdo_action( 'sidebar_admin_setup' );\n\n\t$sidebars_widgets = wp_get_sidebars_widgets();\n\n\tforeach ( $sidebars_widgets['wp_inactive_widgets'] as $key => $widget_id ) {\n\t\t$pieces       = explode( '-', $widget_id );\n\t\t$multi_number = array_pop( $pieces );\n\t\t$id_base      = implode( '-', $pieces );\n\t\t$widget       = get_option( 'widget_' . $id_base );\n\t\tunset( $widget[ $multi_number ] );\n\t\tupdate_option( 'widget_' . $id_base, $widget );\n\t\tunset( $sidebars_widgets['wp_inactive_widgets'][ $key ] );\n\t}\n\n\twp_set_sidebars_widgets( $sidebars_widgets );\n\n\twp_die();\n}\n\n/**\n * Ajax handler for uploading attachments\n *\n * @since 3.3.0\n */\nfunction wp_ajax_upload_attachment() {\n\tcheck_ajax_referer( 'media-form' );\n\t/*\n\t * This function does not use wp_send_json_success() / wp_send_json_error()\n\t * as the html4 Plupload handler requires a text/html content-type for older IE.\n\t * See https://core.trac.wordpress.org/ticket/31037\n\t */\n\n\tif ( ! current_user_can( 'upload_files' ) ) {\n\t\techo wp_json_encode(\n\t\t\tarray(\n\t\t\t\t'success' => false,\n\t\t\t\t'data'    => array(\n\t\t\t\t\t'message'  => __( 'Sorry, you are not allowed to upload files.' ),\n\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\n\t\twp_die();\n\t}\n\n\tif ( isset( $_REQUEST['post_id'] ) ) {\n\t\t$post_id = $_REQUEST['post_id'];\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\t\techo wp_json_encode(\n\t\t\t\tarray(\n\t\t\t\t\t'success' => false,\n\t\t\t\t\t'data'    => array(\n\t\t\t\t\t\t'message'  => __( 'Sorry, you are not allowed to attach files to this post.' ),\n\t\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t);\n\n\t\t\twp_die();\n\t\t}\n\t} else {\n\t\t$post_id = null;\n\t}\n\n\t$post_data = ! empty( $_REQUEST['post_data'] ) ? _wp_get_allowed_postdata( _wp_translate_postdata( false, (array) $_REQUEST['post_data'] ) ) : array();\n\n\tif ( is_wp_error( $post_data ) ) {\n\t\twp_die( $post_data->get_error_message() );\n\t}\n\n\t// If the context is custom header or background, make sure the uploaded file is an image.\n\tif ( isset( $post_data['context'] ) && in_array( $post_data['context'], array( 'custom-header', 'custom-background' ) ) ) {\n\t\t$wp_filetype = wp_check_filetype_and_ext( $_FILES['async-upload']['tmp_name'], $_FILES['async-upload']['name'] );\n\t\tif ( ! wp_match_mime_types( 'image', $wp_filetype['type'] ) ) {\n\t\t\techo wp_json_encode(\n\t\t\t\tarray(\n\t\t\t\t\t'success' => false,\n\t\t\t\t\t'data'    => array(\n\t\t\t\t\t\t'message'  => __( 'The uploaded file is not a valid image. Please try again.' ),\n\t\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t);\n\n\t\t\twp_die();\n\t\t}\n\t}\n\n\t$attachment_id = media_handle_upload( 'async-upload', $post_id, $post_data );\n\n\tif ( is_wp_error( $attachment_id ) ) {\n\t\techo wp_json_encode(\n\t\t\tarray(\n\t\t\t\t'success' => false,\n\t\t\t\t'data'    => array(\n\t\t\t\t\t'message'  => $attachment_id->get_error_message(),\n\t\t\t\t\t'filename' => $_FILES['async-upload']['name'],\n\t\t\t\t),\n\t\t\t)\n\t\t);\n\n\t\twp_die();\n\t}\n\n\tif ( isset( $post_data['context'] ) && isset( $post_data['theme'] ) ) {\n\t\tif ( 'custom-background' === $post_data['context'] ) {\n\t\t\tupdate_post_meta( $attachment_id, '_wp_attachment_is_custom_background', $post_data['theme'] );\n\t\t}\n\n\t\tif ( 'custom-header' === $post_data['context'] ) {\n\t\t\tupdate_post_meta( $attachment_id, '_wp_attachment_is_custom_header', $post_data['theme'] );\n\t\t}\n\t}\n\n\tif ( ! $attachment = wp_prepare_attachment_for_js( $attachment_id ) ) {\n\t\twp_die();\n\t}\n\n\techo wp_json_encode(\n\t\tarray(\n\t\t\t'success' => true,\n\t\t\t'data'    => $attachment,\n\t\t)\n\t);\n\n\twp_die();\n}\n\n/**\n * Ajax handler for image editing.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_image_editor() {\n\t$attachment_id = intval( $_POST['postid'] );\n\tif ( empty( $attachment_id ) || ! current_user_can( 'edit_post', $attachment_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\tcheck_ajax_referer( \"image_editor-$attachment_id\" );\n\tinclude_once( ABSPATH . 'wp-admin/includes/image-edit.php' );\n\n\t$msg = false;\n\tswitch ( $_POST['do'] ) {\n\t\tcase 'save':\n\t\t\t$msg = wp_save_image( $attachment_id );\n\t\t\t$msg = wp_json_encode( $msg );\n\t\t\twp_die( $msg );\n\t\t\tbreak;\n\t\tcase 'scale':\n\t\t\t$msg = wp_save_image( $attachment_id );\n\t\t\tbreak;\n\t\tcase 'restore':\n\t\t\t$msg = wp_restore_image( $attachment_id );\n\t\t\tbreak;\n\t}\n\n\twp_image_editor( $attachment_id, $msg );\n\twp_die();\n}\n\n/**\n * Ajax handler for setting the featured image.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_set_post_thumbnail() {\n\t$json = ! empty( $_REQUEST['json'] ); // New-style request\n\n\t$post_ID = intval( $_POST['post_id'] );\n\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$thumbnail_id = intval( $_POST['thumbnail_id'] );\n\n\tif ( $json ) {\n\t\tcheck_ajax_referer( \"update-post_$post_ID\" );\n\t} else {\n\t\tcheck_ajax_referer( \"set_post_thumbnail-$post_ID\" );\n\t}\n\n\tif ( $thumbnail_id == '-1' ) {\n\t\tif ( delete_post_thumbnail( $post_ID ) ) {\n\t\t\t$return = _wp_post_thumbnail_html( null, $post_ID );\n\t\t\t$json ? wp_send_json_success( $return ) : wp_die( $return );\n\t\t} else {\n\t\t\twp_die( 0 );\n\t\t}\n\t}\n\n\tif ( set_post_thumbnail( $post_ID, $thumbnail_id ) ) {\n\t\t$return = _wp_post_thumbnail_html( $thumbnail_id, $post_ID );\n\t\t$json ? wp_send_json_success( $return ) : wp_die( $return );\n\t}\n\n\twp_die( 0 );\n}\n\n/**\n * Ajax handler for retrieving HTML for the featured image.\n *\n * @since 4.6.0\n */\nfunction wp_ajax_get_post_thumbnail_html() {\n\t$post_ID = intval( $_POST['post_id'] );\n\n\tcheck_ajax_referer( \"update-post_$post_ID\" );\n\n\tif ( ! current_user_can( 'edit_post', $post_ID ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$thumbnail_id = intval( $_POST['thumbnail_id'] );\n\n\t// For backward compatibility, -1 refers to no featured image.\n\tif ( -1 === $thumbnail_id ) {\n\t\t$thumbnail_id = null;\n\t}\n\n\t$return = _wp_post_thumbnail_html( $thumbnail_id, $post_ID );\n\twp_send_json_success( $return );\n}\n\n/**\n * Ajax handler for setting the featured image for an attachment.\n *\n * @since 4.0.0\n *\n * @see set_post_thumbnail()\n */\nfunction wp_ajax_set_attachment_thumbnail() {\n\tif ( empty( $_POST['urls'] ) || ! is_array( $_POST['urls'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$thumbnail_id = (int) $_POST['thumbnail_id'];\n\tif ( empty( $thumbnail_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$post_ids = array();\n\t// For each URL, try to find its corresponding post ID.\n\tforeach ( $_POST['urls'] as $url ) {\n\t\t$post_id = attachment_url_to_postid( $url );\n\t\tif ( ! empty( $post_id ) ) {\n\t\t\t$post_ids[] = $post_id;\n\t\t}\n\t}\n\n\tif ( empty( $post_ids ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$success = 0;\n\t// For each found attachment, set its thumbnail.\n\tforeach ( $post_ids as $post_id ) {\n\t\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( set_post_thumbnail( $post_id, $thumbnail_id ) ) {\n\t\t\t$success++;\n\t\t}\n\t}\n\n\tif ( 0 === $success ) {\n\t\twp_send_json_error();\n\t} else {\n\t\twp_send_json_success();\n\t}\n\n\twp_send_json_error();\n}\n\n/**\n * Ajax handler for date formatting.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_date_format() {\n\twp_die( date_i18n( sanitize_option( 'date_format', wp_unslash( $_POST['date'] ) ) ) );\n}\n\n/**\n * Ajax handler for time formatting.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_time_format() {\n\twp_die( date_i18n( sanitize_option( 'time_format', wp_unslash( $_POST['date'] ) ) ) );\n}\n\n/**\n * Ajax handler for saving posts from the fullscreen editor.\n *\n * @since 3.1.0\n * @deprecated 4.3.0\n */\nfunction wp_ajax_wp_fullscreen_save_post() {\n\t$post_id = isset( $_POST['post_ID'] ) ? (int) $_POST['post_ID'] : 0;\n\n\t$post = null;\n\n\tif ( $post_id ) {\n\t\t$post = get_post( $post_id );\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $post_id, '_wpnonce' );\n\n\t$post_id = edit_post();\n\n\tif ( is_wp_error( $post_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( $post ) {\n\t\t$last_date = mysql2date( __( 'F j, Y' ), $post->post_modified );\n\t\t$last_time = mysql2date( __( 'g:i a' ), $post->post_modified );\n\t} else {\n\t\t$last_date = date_i18n( __( 'F j, Y' ) );\n\t\t$last_time = date_i18n( __( 'g:i a' ) );\n\t}\n\n\tif ( $last_id = get_post_meta( $post_id, '_edit_last', true ) ) {\n\t\t$last_user = get_userdata( $last_id );\n\t\t/* translators: 1: display_name of last user, 2: date of last edit, 3: time of last edit. */\n\t\t$last_edited = sprintf( __( 'Last edited by %1$s on %2$s at %3$s' ), esc_html( $last_user->display_name ), $last_date, $last_time );\n\t} else {\n\t\t/* translators: 1: date of last edit, 2: time of last edit. */\n\t\t$last_edited = sprintf( __( 'Last edited on %1$s at %2$s' ), $last_date, $last_time );\n\t}\n\n\twp_send_json_success( array( 'last_edited' => $last_edited ) );\n}\n\n/**\n * Ajax handler for removing a post lock.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_wp_remove_post_lock() {\n\tif ( empty( $_POST['post_ID'] ) || empty( $_POST['active_post_lock'] ) ) {\n\t\twp_die( 0 );\n\t}\n\t$post_id = (int) $_POST['post_ID'];\n\tif ( ! $post = get_post( $post_id ) ) {\n\t\twp_die( 0 );\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $post_id );\n\n\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_die( -1 );\n\t}\n\n\t$active_lock = array_map( 'absint', explode( ':', $_POST['active_post_lock'] ) );\n\tif ( $active_lock[1] != get_current_user_id() ) {\n\t\twp_die( 0 );\n\t}\n\n\t/**\n\t * Filters the post lock window duration.\n\t *\n\t * @since 3.3.0\n\t *\n\t * @param int $interval The interval in seconds the post lock duration\n\t *                      should last, plus 5 seconds. Default 150.\n\t */\n\t$new_lock = ( time() - apply_filters( 'wp_check_post_lock_window', 150 ) + 5 ) . ':' . $active_lock[1];\n\tupdate_post_meta( $post_id, '_edit_lock', $new_lock, implode( ':', $active_lock ) );\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for dismissing a WordPress pointer.\n *\n * @since 3.1.0\n */\nfunction wp_ajax_dismiss_wp_pointer() {\n\t$pointer = $_POST['pointer'];\n\tif ( $pointer != sanitize_key( $pointer ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t//  check_ajax_referer( 'dismiss-pointer_' . $pointer );\n\n\t$dismissed = array_filter( explode( ',', (string) get_user_meta( get_current_user_id(), 'dismissed_wp_pointers', true ) ) );\n\n\tif ( in_array( $pointer, $dismissed ) ) {\n\t\twp_die( 0 );\n\t}\n\n\t$dismissed[] = $pointer;\n\t$dismissed   = implode( ',', $dismissed );\n\n\tupdate_user_meta( get_current_user_id(), 'dismissed_wp_pointers', $dismissed );\n\twp_die( 1 );\n}\n\n/**\n * Ajax handler for getting an attachment.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_get_attachment() {\n\tif ( ! isset( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $id = absint( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $post = get_post( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( 'attachment' != $post->post_type ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! current_user_can( 'upload_files' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $attachment = wp_prepare_attachment_for_js( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\twp_send_json_success( $attachment );\n}\n\n/**\n * Ajax handler for querying attachments.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_query_attachments() {\n\tif ( ! current_user_can( 'upload_files' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$query = isset( $_REQUEST['query'] ) ? (array) $_REQUEST['query'] : array();\n\t$keys  = array(\n\t\t's',\n\t\t'order',\n\t\t'orderby',\n\t\t'posts_per_page',\n\t\t'paged',\n\t\t'post_mime_type',\n\t\t'post_parent',\n\t\t'author',\n\t\t'post__in',\n\t\t'post__not_in',\n\t\t'year',\n\t\t'monthnum',\n\t);\n\tforeach ( get_taxonomies_for_attachments( 'objects' ) as $t ) {\n\t\tif ( $t->query_var && isset( $query[ $t->query_var ] ) ) {\n\t\t\t$keys[] = $t->query_var;\n\t\t}\n\t}\n\n\t$query              = array_intersect_key( $query, array_flip( $keys ) );\n\t$query['post_type'] = 'attachment';\n\tif ( MEDIA_TRASH\n\t\t&& ! empty( $_REQUEST['query']['post_status'] )\n\t\t&& 'trash' === $_REQUEST['query']['post_status'] ) {\n\t\t$query['post_status'] = 'trash';\n\t} else {\n\t\t$query['post_status'] = 'inherit';\n\t}\n\n\tif ( current_user_can( get_post_type_object( 'attachment' )->cap->read_private_posts ) ) {\n\t\t$query['post_status'] .= ',private';\n\t}\n\n\t// Filter query clauses to include filenames.\n\tif ( isset( $query['s'] ) ) {\n\t\tadd_filter( 'posts_clauses', '_filter_query_attachment_filenames' );\n\t}\n\n\t/**\n\t * Filters the arguments passed to WP_Query during an Ajax\n\t * call for querying attachments.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @see WP_Query::parse_query()\n\t *\n\t * @param array $query An array of query variables.\n\t */\n\t$query = apply_filters( 'ajax_query_attachments_args', $query );\n\t$query = new WP_Query( $query );\n\n\t$posts = array_map( 'wp_prepare_attachment_for_js', $query->posts );\n\t$posts = array_filter( $posts );\n\n\twp_send_json_success( $posts );\n}\n\n/**\n * Ajax handler for updating attachment attributes.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_save_attachment() {\n\tif ( ! isset( $_REQUEST['id'] ) || ! isset( $_REQUEST['changes'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $id = absint( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $id, 'nonce' );\n\n\tif ( ! current_user_can( 'edit_post', $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$changes = $_REQUEST['changes'];\n\t$post    = get_post( $id, ARRAY_A );\n\n\tif ( 'attachment' != $post['post_type'] ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( isset( $changes['parent'] ) ) {\n\t\t$post['post_parent'] = $changes['parent'];\n\t}\n\n\tif ( isset( $changes['title'] ) ) {\n\t\t$post['post_title'] = $changes['title'];\n\t}\n\n\tif ( isset( $changes['caption'] ) ) {\n\t\t$post['post_excerpt'] = $changes['caption'];\n\t}\n\n\tif ( isset( $changes['description'] ) ) {\n\t\t$post['post_content'] = $changes['description'];\n\t}\n\n\tif ( MEDIA_TRASH && isset( $changes['status'] ) ) {\n\t\t$post['post_status'] = $changes['status'];\n\t}\n\n\tif ( isset( $changes['alt'] ) ) {\n\t\t$alt = wp_unslash( $changes['alt'] );\n\t\tif ( $alt != get_post_meta( $id, '_wp_attachment_image_alt', true ) ) {\n\t\t\t$alt = wp_strip_all_tags( $alt, true );\n\t\t\tupdate_post_meta( $id, '_wp_attachment_image_alt', wp_slash( $alt ) );\n\t\t}\n\t}\n\n\tif ( wp_attachment_is( 'audio', $post['ID'] ) ) {\n\t\t$changed = false;\n\t\t$id3data = wp_get_attachment_metadata( $post['ID'] );\n\t\tif ( ! is_array( $id3data ) ) {\n\t\t\t$changed = true;\n\t\t\t$id3data = array();\n\t\t}\n\t\tforeach ( wp_get_attachment_id3_keys( (object) $post, 'edit' ) as $key => $label ) {\n\t\t\tif ( isset( $changes[ $key ] ) ) {\n\t\t\t\t$changed         = true;\n\t\t\t\t$id3data[ $key ] = sanitize_text_field( wp_unslash( $changes[ $key ] ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( $changed ) {\n\t\t\twp_update_attachment_metadata( $id, $id3data );\n\t\t}\n\t}\n\n\tif ( MEDIA_TRASH && isset( $changes['status'] ) && 'trash' === $changes['status'] ) {\n\t\twp_delete_post( $id );\n\t} else {\n\t\twp_update_post( $post );\n\t}\n\n\twp_send_json_success();\n}\n\n/**\n * Ajax handler for saving backward compatible attachment attributes.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_save_attachment_compat() {\n\tif ( ! isset( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $id = absint( $_REQUEST['id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( empty( $_REQUEST['attachments'] ) || empty( $_REQUEST['attachments'][ $id ] ) ) {\n\t\twp_send_json_error();\n\t}\n\t$attachment_data = $_REQUEST['attachments'][ $id ];\n\n\tcheck_ajax_referer( 'update-post_' . $id, 'nonce' );\n\n\tif ( ! current_user_can( 'edit_post', $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$post = get_post( $id, ARRAY_A );\n\n\tif ( 'attachment' != $post['post_type'] ) {\n\t\twp_send_json_error();\n\t}\n\n\t/** This filter is documented in wp-admin/includes/media.php */\n\t$post = apply_filters( 'attachment_fields_to_save', $post, $attachment_data );\n\n\tif ( isset( $post['errors'] ) ) {\n\t\t$errors = $post['errors']; // @todo return me and display me!\n\t\tunset( $post['errors'] );\n\t}\n\n\twp_update_post( $post );\n\n\tforeach ( get_attachment_taxonomies( $post ) as $taxonomy ) {\n\t\tif ( isset( $attachment_data[ $taxonomy ] ) ) {\n\t\t\twp_set_object_terms( $id, array_map( 'trim', preg_split( '/,+/', $attachment_data[ $taxonomy ] ) ), $taxonomy, false );\n\t\t}\n\t}\n\n\tif ( ! $attachment = wp_prepare_attachment_for_js( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\twp_send_json_success( $attachment );\n}\n\n/**\n * Ajax handler for saving the attachment order.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_save_attachment_order() {\n\tif ( ! isset( $_REQUEST['post_id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $post_id = absint( $_REQUEST['post_id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( empty( $_REQUEST['attachments'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tcheck_ajax_referer( 'update-post_' . $post_id, 'nonce' );\n\n\t$attachments = $_REQUEST['attachments'];\n\n\tif ( ! current_user_can( 'edit_post', $post_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tforeach ( $attachments as $attachment_id => $menu_order ) {\n\t\tif ( ! current_user_can( 'edit_post', $attachment_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( ! $attachment = get_post( $attachment_id ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( 'attachment' != $attachment->post_type ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\twp_update_post(\n\t\t\tarray(\n\t\t\t\t'ID'         => $attachment_id,\n\t\t\t\t'menu_order' => $menu_order,\n\t\t\t)\n\t\t);\n\t}\n\n\twp_send_json_success();\n}\n\n/**\n * Ajax handler for sending an attachment to the editor.\n *\n * Generates the HTML to send an attachment to the editor.\n * Backward compatible with the {@see 'media_send_to_editor'} filter\n * and the chain of filters that follow.\n *\n * @since 3.5.0\n */\nfunction wp_ajax_send_attachment_to_editor() {\n\tcheck_ajax_referer( 'media-send-to-editor', 'nonce' );\n\n\t$attachment = wp_unslash( $_POST['attachment'] );\n\n\t$id = intval( $attachment['id'] );\n\n\tif ( ! $post = get_post( $id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( 'attachment' != $post->post_type ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( current_user_can( 'edit_post', $id ) ) {\n\t\t// If this attachment is unattached, attach it. Primarily a back compat thing.\n\t\tif ( 0 == $post->post_parent && $insert_into_post_id = intval( $_POST['post_id'] ) ) {\n\t\t\twp_update_post(\n\t\t\t\tarray(\n\t\t\t\t\t'ID'          => $id,\n\t\t\t\t\t'post_parent' => $insert_into_post_id,\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t$url = empty( $attachment['url'] ) ? '' : $attachment['url'];\n\t$rel = ( strpos( $url, 'attachment_id' ) || get_attachment_link( $id ) == $url );\n\n\tremove_filter( 'media_send_to_editor', 'image_media_send_to_editor' );\n\n\tif ( 'image' === substr( $post->post_mime_type, 0, 5 ) ) {\n\t\t$align = isset( $attachment['align'] ) ? $attachment['align'] : 'none';\n\t\t$size  = isset( $attachment['image-size'] ) ? $attachment['image-size'] : 'medium';\n\t\t$alt   = isset( $attachment['image_alt'] ) ? $attachment['image_alt'] : '';\n\n\t\t// No whitespace-only captions.\n\t\t$caption = isset( $attachment['post_excerpt'] ) ? $attachment['post_excerpt'] : '';\n\t\tif ( '' === trim( $caption ) ) {\n\t\t\t$caption = '';\n\t\t}\n\n\t\t$title = ''; // We no longer insert title tags into <img> tags, as they are redundant.\n\t\t$html  = get_image_send_to_editor( $id, $caption, $title, $align, $url, $rel, $size, $alt );\n\t} elseif ( wp_attachment_is( 'video', $post ) || wp_attachment_is( 'audio', $post ) ) {\n\t\t$html = stripslashes_deep( $_POST['html'] );\n\t} else {\n\t\t$html = isset( $attachment['post_title'] ) ? $attachment['post_title'] : '';\n\t\t$rel  = $rel ? ' rel=\"attachment wp-att-' . $id . '\"' : ''; // Hard-coded string, $id is already sanitized\n\n\t\tif ( ! empty( $url ) ) {\n\t\t\t$html = '<a href=\"' . esc_url( $url ) . '\"' . $rel . '>' . $html . '</a>';\n\t\t}\n\t}\n\n\t/** This filter is documented in wp-admin/includes/media.php */\n\t$html = apply_filters( 'media_send_to_editor', $html, $id, $attachment );\n\n\twp_send_json_success( $html );\n}\n\n/**\n * Ajax handler for sending a link to the editor.\n *\n * Generates the HTML to send a non-image embed link to the editor.\n *\n * Backward compatible with the following filters:\n * - file_send_to_editor_url\n * - audio_send_to_editor_url\n * - video_send_to_editor_url\n *\n * @since 3.5.0\n *\n * @global WP_Post  $post\n * @global WP_Embed $wp_embed\n */\nfunction wp_ajax_send_link_to_editor() {\n\tglobal $post, $wp_embed;\n\n\tcheck_ajax_referer( 'media-send-to-editor', 'nonce' );\n\n\tif ( ! $src = wp_unslash( $_POST['src'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! strpos( $src, '://' ) ) {\n\t\t$src = 'http://' . $src;\n\t}\n\n\tif ( ! $src = esc_url_raw( $src ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! $link_text = trim( wp_unslash( $_POST['link_text'] ) ) ) {\n\t\t$link_text = wp_basename( $src );\n\t}\n\n\t$post = get_post( isset( $_POST['post_id'] ) ? $_POST['post_id'] : 0 );\n\n\t// Ping WordPress for an embed.\n\t$check_embed = $wp_embed->run_shortcode( '[embed]' . $src . '[/embed]' );\n\n\t// Fallback that WordPress creates when no oEmbed was found.\n\t$fallback = $wp_embed->maybe_make_link( $src );\n\n\tif ( $check_embed !== $fallback ) {\n\t\t// TinyMCE view for [embed] will parse this\n\t\t$html = '[embed]' . $src . '[/embed]';\n\t} elseif ( $link_text ) {\n\t\t$html = '<a href=\"' . esc_url( $src ) . '\">' . $link_text . '</a>';\n\t} else {\n\t\t$html = '';\n\t}\n\n\t// Figure out what filter to run:\n\t$type = 'file';\n\tif ( ( $ext = preg_replace( '/^.+?\\.([^.]+)$/', '$1', $src ) ) && ( $ext_type = wp_ext2type( $ext ) )\n\t\t&& ( 'audio' == $ext_type || 'video' == $ext_type ) ) {\n\t\t\t$type = $ext_type;\n\t}\n\n\t/** This filter is documented in wp-admin/includes/media.php */\n\t$html = apply_filters( \"{$type}_send_to_editor_url\", $html, $src, $link_text );\n\n\twp_send_json_success( $html );\n}\n\n/**\n * Ajax handler for the Heartbeat API.\n *\n * Runs when the user is logged in.\n *\n * @since 3.6.0\n */\nfunction wp_ajax_heartbeat() {\n\tif ( empty( $_POST['_nonce'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$response    = $data = array();\n\t$nonce_state = wp_verify_nonce( $_POST['_nonce'], 'heartbeat-nonce' );\n\n\t// screen_id is the same as $current_screen->id and the JS global 'pagenow'.\n\tif ( ! empty( $_POST['screen_id'] ) ) {\n\t\t$screen_id = sanitize_key( $_POST['screen_id'] );\n\t} else {\n\t\t$screen_id = 'front';\n\t}\n\n\tif ( ! empty( $_POST['data'] ) ) {\n\t\t$data = wp_unslash( (array) $_POST['data'] );\n\t}\n\n\tif ( 1 !== $nonce_state ) {\n\t\t/**\n\t\t * Filters the nonces to send to the New/Edit Post screen.\n\t\t *\n\t\t * @since 4.3.0\n\t\t *\n\t\t * @param array  $response  The Heartbeat response.\n\t\t * @param array  $data      The $_POST data sent.\n\t\t * @param string $screen_id The screen id.\n\t\t */\n\t\t$response = apply_filters( 'wp_refresh_nonces', $response, $data, $screen_id );\n\n\t\tif ( false === $nonce_state ) {\n\t\t\t// User is logged in but nonces have expired.\n\t\t\t$response['nonces_expired'] = true;\n\t\t\twp_send_json( $response );\n\t\t}\n\t}\n\n\tif ( ! empty( $data ) ) {\n\t\t/**\n\t\t * Filters the Heartbeat response received.\n\t\t *\n\t\t * @since 3.6.0\n\t\t *\n\t\t * @param array  $response  The Heartbeat response.\n\t\t * @param array  $data      The $_POST data sent.\n\t\t * @param string $screen_id The screen id.\n\t\t */\n\t\t$response = apply_filters( 'heartbeat_received', $response, $data, $screen_id );\n\t}\n\n\t/**\n\t * Filters the Heartbeat response sent.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\t$response = apply_filters( 'heartbeat_send', $response, $screen_id );\n\n\t/**\n\t * Fires when Heartbeat ticks in logged-in environments.\n\t *\n\t * Allows the transport to be easily replaced with long-polling.\n\t *\n\t * @since 3.6.0\n\t *\n\t * @param array  $response  The Heartbeat response.\n\t * @param string $screen_id The screen id.\n\t */\n\tdo_action( 'heartbeat_tick', $response, $screen_id );\n\n\t// Send the current time according to the server\n\t$response['server_time'] = time();\n\n\twp_send_json( $response );\n}\n\n/**\n * Ajax handler for getting revision diffs.\n *\n * @since 3.6.0\n */\nfunction wp_ajax_get_revision_diffs() {\n\trequire ABSPATH . 'wp-admin/includes/revision.php';\n\n\tif ( ! $post = get_post( (int) $_REQUEST['post_id'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tif ( ! current_user_can( 'edit_post', $post->ID ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t// Really just pre-loading the cache here.\n\tif ( ! $revisions = wp_get_post_revisions( $post->ID, array( 'check_enabled' => false ) ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$return = array();\n\t@set_time_limit( 0 );\n\n\tforeach ( $_REQUEST['compare'] as $compare_key ) {\n\t\tlist( $compare_from, $compare_to ) = explode( ':', $compare_key ); // from:to\n\n\t\t$return[] = array(\n\t\t\t'id'     => $compare_key,\n\t\t\t'fields' => wp_get_revision_ui_diff( $post, $compare_from, $compare_to ),\n\t\t);\n\t}\n\twp_send_json_success( $return );\n}\n\n/**\n * Ajax handler for auto-saving the selected color scheme for\n * a user's own profile.\n *\n * @since 3.8.0\n *\n * @global array $_wp_admin_css_colors\n */\nfunction wp_ajax_save_user_color_scheme() {\n\tglobal $_wp_admin_css_colors;\n\n\tcheck_ajax_referer( 'save-color-scheme', 'nonce' );\n\n\t$color_scheme = sanitize_key( $_POST['color_scheme'] );\n\n\tif ( ! isset( $_wp_admin_css_colors[ $color_scheme ] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$previous_color_scheme = get_user_meta( get_current_user_id(), 'admin_color', true );\n\tupdate_user_meta( get_current_user_id(), 'admin_color', $color_scheme );\n\n\twp_send_json_success(\n\t\tarray(\n\t\t\t'previousScheme' => 'admin-color-' . $previous_color_scheme,\n\t\t\t'currentScheme'  => 'admin-color-' . $color_scheme,\n\t\t)\n\t);\n}\n\n/**\n * Ajax handler for getting themes from themes_api().\n *\n * @since 3.9.0\n *\n * @global array $themes_allowedtags\n * @global array $theme_field_defaults\n */\nfunction wp_ajax_query_themes() {\n\tglobal $themes_allowedtags, $theme_field_defaults;\n\n\tif ( ! current_user_can( 'install_themes' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$args = wp_parse_args(\n\t\twp_unslash( $_REQUEST['request'] ),\n\t\tarray(\n\t\t\t'per_page' => 20,\n\t\t\t'fields'   => $theme_field_defaults,\n\t\t)\n\t);\n\n\tif ( isset( $args['browse'] ) && 'favorites' === $args['browse'] && ! isset( $args['user'] ) ) {\n\t\t$user = get_user_option( 'wporg_favorites' );\n\t\tif ( $user ) {\n\t\t\t$args['user'] = $user;\n\t\t}\n\t}\n\n\t$old_filter = isset( $args['browse'] ) ? $args['browse'] : 'search';\n\n\t/** This filter is documented in wp-admin/includes/class-wp-theme-install-list-table.php */\n\t$args = apply_filters( 'install_themes_table_api_args_' . $old_filter, $args );\n\n\t$api = themes_api( 'query_themes', $args );\n\n\tif ( is_wp_error( $api ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$update_php = network_admin_url( 'update.php?action=install-theme' );\n\tforeach ( $api->themes as &$theme ) {\n\t\t$theme->install_url = add_query_arg(\n\t\t\tarray(\n\t\t\t\t'theme'    => $theme->slug,\n\t\t\t\t'_wpnonce' => wp_create_nonce( 'install-theme_' . $theme->slug ),\n\t\t\t),\n\t\t\t$update_php\n\t\t);\n\n\t\tif ( current_user_can( 'switch_themes' ) ) {\n\t\t\tif ( is_multisite() ) {\n\t\t\t\t$theme->activate_url = add_query_arg(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'action'   => 'enable',\n\t\t\t\t\t\t'_wpnonce' => wp_create_nonce( 'enable-theme_' . $theme->slug ),\n\t\t\t\t\t\t'theme'    => $theme->slug,\n\t\t\t\t\t),\n\t\t\t\t\tnetwork_admin_url( 'themes.php' )\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t$theme->activate_url = add_query_arg(\n\t\t\t\t\tarray(\n\t\t\t\t\t\t'action'     => 'activate',\n\t\t\t\t\t\t'_wpnonce'   => wp_create_nonce( 'switch-theme_' . $theme->slug ),\n\t\t\t\t\t\t'stylesheet' => $theme->slug,\n\t\t\t\t\t),\n\t\t\t\t\tadmin_url( 'themes.php' )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif ( ! is_multisite() && current_user_can( 'edit_theme_options' ) && current_user_can( 'customize' ) ) {\n\t\t\t$theme->customize_url = add_query_arg(\n\t\t\t\tarray(\n\t\t\t\t\t'return' => urlencode( network_admin_url( 'theme-install.php', 'relative' ) ),\n\t\t\t\t),\n\t\t\t\twp_customize_url( $theme->slug )\n\t\t\t);\n\t\t}\n\n\t\t$theme->name        = wp_kses( $theme->name, $themes_allowedtags );\n\t\t$theme->author      = wp_kses( $theme->author['display_name'], $themes_allowedtags );\n\t\t$theme->version     = wp_kses( $theme->version, $themes_allowedtags );\n\t\t$theme->description = wp_kses( $theme->description, $themes_allowedtags );\n\t\t$theme->stars       = wp_star_rating(\n\t\t\tarray(\n\t\t\t\t'rating' => $theme->rating,\n\t\t\t\t'type'   => 'percent',\n\t\t\t\t'number' => $theme->num_ratings,\n\t\t\t\t'echo'   => false,\n\t\t\t)\n\t\t);\n\t\t$theme->num_ratings = number_format_i18n( $theme->num_ratings );\n\t\t$theme->preview_url = set_url_scheme( $theme->preview_url );\n\t}\n\n\twp_send_json_success( $api );\n}\n\n/**\n * Apply [embed] Ajax handlers to a string.\n *\n * @since 4.0.0\n *\n * @global WP_Post    $post       Global $post.\n * @global WP_Embed   $wp_embed   Embed API instance.\n * @global WP_Scripts $wp_scripts\n * @global int        $content_width\n */\nfunction wp_ajax_parse_embed() {\n\tglobal $post, $wp_embed, $content_width;\n\n\tif ( empty( $_POST['shortcode'] ) ) {\n\t\twp_send_json_error();\n\t}\n\t$post_id = isset( $_POST['post_ID'] ) ? intval( $_POST['post_ID'] ) : 0;\n\tif ( $post_id > 0 ) {\n\t\t$post = get_post( $post_id );\n\t\tif ( ! $post || ! current_user_can( 'edit_post', $post->ID ) ) {\n\t\t\twp_send_json_error();\n\t\t}\n\t\tsetup_postdata( $post );\n\t} elseif ( ! current_user_can( 'edit_posts' ) ) { // See WP_oEmbed_Controller::get_proxy_item_permissions_check().\n\t\twp_send_json_error();\n\t}\n\n\t$shortcode = wp_unslash( $_POST['shortcode'] );\n\n\tpreg_match( '/' . get_shortcode_regex() . '/s', $shortcode, $matches );\n\t$atts = shortcode_parse_atts( $matches[3] );\n\tif ( ! empty( $matches[5] ) ) {\n\t\t$url = $matches[5];\n\t} elseif ( ! empty( $atts['src'] ) ) {\n\t\t$url = $atts['src'];\n\t} else {\n\t\t$url = '';\n\t}\n\n\t$parsed                         = false;\n\t$wp_embed->return_false_on_fail = true;\n\n\tif ( 0 === $post_id ) {\n\t\t/*\n\t\t * Refresh oEmbeds cached outside of posts that are past their TTL.\n\t\t * Posts are excluded because they have separate logic for refreshing\n\t\t * their post meta caches. See WP_Embed::cache_oembed().\n\t\t */\n\t\t$wp_embed->usecache = false;\n\t}\n\n\tif ( is_ssl() && 0 === strpos( $url, 'http://' ) ) {\n\t\t// Admin is ssl and the user pasted non-ssl URL.\n\t\t// Check if the provider supports ssl embeds and use that for the preview.\n\t\t$ssl_shortcode = preg_replace( '%^(\\\\[embed[^\\\\]]*\\\\])http://%i', '$1https://', $shortcode );\n\t\t$parsed        = $wp_embed->run_shortcode( $ssl_shortcode );\n\n\t\tif ( ! $parsed ) {\n\t\t\t$no_ssl_support = true;\n\t\t}\n\t}\n\n\t// Set $content_width so any embeds fit in the destination iframe.\n\tif ( isset( $_POST['maxwidth'] ) && is_numeric( $_POST['maxwidth'] ) && $_POST['maxwidth'] > 0 ) {\n\t\tif ( ! isset( $content_width ) ) {\n\t\t\t$content_width = intval( $_POST['maxwidth'] );\n\t\t} else {\n\t\t\t$content_width = min( $content_width, intval( $_POST['maxwidth'] ) );\n\t\t}\n\t}\n\n\tif ( $url && ! $parsed ) {\n\t\t$parsed = $wp_embed->run_shortcode( $shortcode );\n\t}\n\n\tif ( ! $parsed ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'type'    => 'not-embeddable',\n\t\t\t\t/* translators: %s: URL which cannot be embedded, between code tags */\n\t\t\t\t'message' => sprintf( __( '%s failed to embed.' ), '<code>' . esc_html( $url ) . '</code>' ),\n\t\t\t)\n\t\t);\n\t}\n\n\tif ( has_shortcode( $parsed, 'audio' ) || has_shortcode( $parsed, 'video' ) ) {\n\t\t$styles     = '';\n\t\t$mce_styles = wpview_media_sandbox_styles();\n\t\tforeach ( $mce_styles as $style ) {\n\t\t\t$styles .= sprintf( '<link rel=\"stylesheet\" href=\"%s\"/>', $style );\n\t\t}\n\n\t\t$html = do_shortcode( $parsed );\n\n\t\tglobal $wp_scripts;\n\t\tif ( ! empty( $wp_scripts ) ) {\n\t\t\t$wp_scripts->done = array();\n\t\t}\n\t\tob_start();\n\t\twp_print_scripts( array( 'mediaelement-vimeo', 'wp-mediaelement' ) );\n\t\t$scripts = ob_get_clean();\n\n\t\t$parsed = $styles . $html . $scripts;\n\t}\n\n\tif ( ! empty( $no_ssl_support ) || ( is_ssl() && ( preg_match( '%<(iframe|script|embed) [^>]*src=\"http://%', $parsed ) ||\n\t\tpreg_match( '%<link [^>]*href=\"http://%', $parsed ) ) ) ) {\n\t\t// Admin is ssl and the embed is not. Iframes, scripts, and other \"active content\" will be blocked.\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'type'    => 'not-ssl',\n\t\t\t\t'message' => __( 'This preview is unavailable in the editor.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$return = array(\n\t\t'body' => $parsed,\n\t\t'attr' => $wp_embed->last_attr,\n\t);\n\n\tif ( strpos( $parsed, 'class=\"wp-embedded-content' ) ) {\n\t\tif ( defined( 'SCRIPT_DEBUG' ) && SCRIPT_DEBUG ) {\n\t\t\t$script_src = includes_url( 'js/wp-embed.js' );\n\t\t} else {\n\t\t\t$script_src = includes_url( 'js/wp-embed.min.js' );\n\t\t}\n\n\t\t$return['head']    = '<script src=\"' . $script_src . '\"></script>';\n\t\t$return['sandbox'] = true;\n\t}\n\n\twp_send_json_success( $return );\n}\n\n/**\n * @since 4.0.0\n *\n * @global WP_Post    $post\n * @global WP_Scripts $wp_scripts\n */\nfunction wp_ajax_parse_media_shortcode() {\n\tglobal $post, $wp_scripts;\n\n\tif ( empty( $_POST['shortcode'] ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$shortcode = wp_unslash( $_POST['shortcode'] );\n\n\tif ( ! empty( $_POST['post_ID'] ) ) {\n\t\t$post = get_post( (int) $_POST['post_ID'] );\n\t}\n\n\t// the embed shortcode requires a post\n\tif ( ! $post || ! current_user_can( 'edit_post', $post->ID ) ) {\n\t\tif ( 'embed' === $shortcode ) {\n\t\t\twp_send_json_error();\n\t\t}\n\t} else {\n\t\tsetup_postdata( $post );\n\t}\n\n\t$parsed = do_shortcode( $shortcode );\n\n\tif ( empty( $parsed ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'type'    => 'no-items',\n\t\t\t\t'message' => __( 'No items found.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$head   = '';\n\t$styles = wpview_media_sandbox_styles();\n\n\tforeach ( $styles as $style ) {\n\t\t$head .= '<link type=\"text/css\" rel=\"stylesheet\" href=\"' . $style . '\">';\n\t}\n\n\tif ( ! empty( $wp_scripts ) ) {\n\t\t$wp_scripts->done = array();\n\t}\n\n\tob_start();\n\n\techo $parsed;\n\n\tif ( 'playlist' === $_REQUEST['type'] ) {\n\t\twp_underscore_playlist_templates();\n\n\t\twp_print_scripts( 'wp-playlist' );\n\t} else {\n\t\twp_print_scripts( array( 'mediaelement-vimeo', 'wp-mediaelement' ) );\n\t}\n\n\twp_send_json_success(\n\t\tarray(\n\t\t\t'head' => $head,\n\t\t\t'body' => ob_get_clean(),\n\t\t)\n\t);\n}\n\n/**\n * Ajax handler for destroying multiple open sessions for a user.\n *\n * @since 4.1.0\n */\nfunction wp_ajax_destroy_sessions() {\n\t$user = get_userdata( (int) $_POST['user_id'] );\n\tif ( $user ) {\n\t\tif ( ! current_user_can( 'edit_user', $user->ID ) ) {\n\t\t\t$user = false;\n\t\t} elseif ( ! wp_verify_nonce( $_POST['nonce'], 'update-user_' . $user->ID ) ) {\n\t\t\t$user = false;\n\t\t}\n\t}\n\n\tif ( ! $user ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'message' => __( 'Could not log out user sessions. Please try again.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$sessions = WP_Session_Tokens::get_instance( $user->ID );\n\n\tif ( $user->ID === get_current_user_id() ) {\n\t\t$sessions->destroy_others( wp_get_session_token() );\n\t\t$message = __( 'You are now logged out everywhere else.' );\n\t} else {\n\t\t$sessions->destroy_all();\n\t\t/* translators: %s: User's display name. */\n\t\t$message = sprintf( __( '%s has been logged out.' ), $user->display_name );\n\t}\n\n\twp_send_json_success( array( 'message' => $message ) );\n}\n\n/**\n * Ajax handler for cropping an image.\n *\n * @since 4.3.0\n */\nfunction wp_ajax_crop_image() {\n\t$attachment_id = absint( $_POST['id'] );\n\n\tcheck_ajax_referer( 'image_editor-' . $attachment_id, 'nonce' );\n\tif ( empty( $attachment_id ) || ! current_user_can( 'edit_post', $attachment_id ) ) {\n\t\twp_send_json_error();\n\t}\n\n\t$context = str_replace( '_', '-', $_POST['context'] );\n\t$data    = array_map( 'absint', $_POST['cropDetails'] );\n\t$cropped = wp_crop_image( $attachment_id, $data['x1'], $data['y1'], $data['width'], $data['height'], $data['dst_width'], $data['dst_height'] );\n\n\tif ( ! $cropped || is_wp_error( $cropped ) ) {\n\t\twp_send_json_error( array( 'message' => __( 'Image could not be processed.' ) ) );\n\t}\n\n\tswitch ( $context ) {\n\t\tcase 'site-icon':\n\t\t\trequire_once ABSPATH . '/wp-admin/includes/class-wp-site-icon.php';\n\t\t\t$wp_site_icon = new WP_Site_Icon();\n\n\t\t\t// Skip creating a new attachment if the attachment is a Site Icon.\n\t\t\tif ( get_post_meta( $attachment_id, '_wp_attachment_context', true ) == $context ) {\n\n\t\t\t\t// Delete the temporary cropped file, we don't need it.\n\t\t\t\twp_delete_file( $cropped );\n\n\t\t\t\t// Additional sizes in wp_prepare_attachment_for_js().\n\t\t\t\tadd_filter( 'image_size_names_choose', array( $wp_site_icon, 'additional_sizes' ) );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/** This filter is documented in wp-admin/custom-header.php */\n\t\t\t$cropped = apply_filters( 'wp_create_file_in_uploads', $cropped, $attachment_id ); // For replication.\n\t\t\t$object  = $wp_site_icon->create_attachment_object( $cropped, $attachment_id );\n\t\t\tunset( $object['ID'] );\n\n\t\t\t// Update the attachment.\n\t\t\tadd_filter( 'intermediate_image_sizes_advanced', array( $wp_site_icon, 'additional_sizes' ) );\n\t\t\t$attachment_id = $wp_site_icon->insert_attachment( $object, $cropped );\n\t\t\tremove_filter( 'intermediate_image_sizes_advanced', array( $wp_site_icon, 'additional_sizes' ) );\n\n\t\t\t// Additional sizes in wp_prepare_attachment_for_js().\n\t\t\tadd_filter( 'image_size_names_choose', array( $wp_site_icon, 'additional_sizes' ) );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/**\n\t\t\t * Fires before a cropped image is saved.\n\t\t\t *\n\t\t\t * Allows to add filters to modify the way a cropped image is saved.\n\t\t\t *\n\t\t\t * @since 4.3.0\n\t\t\t *\n\t\t\t * @param string $context       The Customizer control requesting the cropped image.\n\t\t\t * @param int    $attachment_id The attachment ID of the original image.\n\t\t\t * @param string $cropped       Path to the cropped image file.\n\t\t\t */\n\t\t\tdo_action( 'wp_ajax_crop_image_pre_save', $context, $attachment_id, $cropped );\n\n\t\t\t/** This filter is documented in wp-admin/custom-header.php */\n\t\t\t$cropped = apply_filters( 'wp_create_file_in_uploads', $cropped, $attachment_id ); // For replication.\n\n\t\t\t$parent_url = wp_get_attachment_url( $attachment_id );\n\t\t\t$url        = str_replace( wp_basename( $parent_url ), wp_basename( $cropped ), $parent_url );\n\n\t\t\t$size       = @getimagesize( $cropped );\n\t\t\t$image_type = ( $size ) ? $size['mime'] : 'image/jpeg';\n\n\t\t\t$object = array(\n\t\t\t\t'post_title'     => wp_basename( $cropped ),\n\t\t\t\t'post_content'   => $url,\n\t\t\t\t'post_mime_type' => $image_type,\n\t\t\t\t'guid'           => $url,\n\t\t\t\t'context'        => $context,\n\t\t\t);\n\n\t\t\t$attachment_id = wp_insert_attachment( $object, $cropped );\n\t\t\t$metadata      = wp_generate_attachment_metadata( $attachment_id, $cropped );\n\n\t\t\t/**\n\t\t\t * Filters the cropped image attachment metadata.\n\t\t\t *\n\t\t\t * @since 4.3.0\n\t\t\t *\n\t\t\t * @see wp_generate_attachment_metadata()\n\t\t\t *\n\t\t\t * @param array $metadata Attachment metadata.\n\t\t\t */\n\t\t\t$metadata = apply_filters( 'wp_ajax_cropped_attachment_metadata', $metadata );\n\t\t\twp_update_attachment_metadata( $attachment_id, $metadata );\n\n\t\t\t/**\n\t\t\t * Filters the attachment ID for a cropped image.\n\t\t\t *\n\t\t\t * @since 4.3.0\n\t\t\t *\n\t\t\t * @param int    $attachment_id The attachment ID of the cropped image.\n\t\t\t * @param string $context       The Customizer control requesting the cropped image.\n\t\t\t */\n\t\t\t$attachment_id = apply_filters( 'wp_ajax_cropped_attachment_id', $attachment_id, $context );\n\t}\n\n\twp_send_json_success( wp_prepare_attachment_for_js( $attachment_id ) );\n}\n\n/**\n * Ajax handler for generating a password.\n *\n * @since 4.4.0\n */\nfunction wp_ajax_generate_password() {\n\twp_send_json_success( wp_generate_password( 24 ) );\n}\n\n/**\n * Ajax handler for saving the user's WordPress.org username.\n *\n * @since 4.4.0\n */\nfunction wp_ajax_save_wporg_username() {\n\tif ( ! current_user_can( 'install_themes' ) && ! current_user_can( 'install_plugins' ) ) {\n\t\twp_send_json_error();\n\t}\n\n\tcheck_ajax_referer( 'save_wporg_username_' . get_current_user_id() );\n\n\t$username = isset( $_REQUEST['username'] ) ? wp_unslash( $_REQUEST['username'] ) : false;\n\n\tif ( ! $username ) {\n\t\twp_send_json_error();\n\t}\n\n\twp_send_json_success( update_user_meta( get_current_user_id(), 'wporg_favorites', $username ) );\n}\n\n/**\n * Ajax handler for installing a theme.\n *\n * @since 4.6.0\n *\n * @see Theme_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_install_theme() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_theme_specified',\n\t\t\t\t'errorMessage' => __( 'No theme specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$slug = sanitize_key( wp_unslash( $_POST['slug'] ) );\n\n\t$status = array(\n\t\t'install' => 'theme',\n\t\t'slug'    => $slug,\n\t);\n\n\tif ( ! current_user_can( 'install_themes' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to install themes on this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\tinclude_once( ABSPATH . 'wp-admin/includes/theme.php' );\n\n\t$api = themes_api(\n\t\t'theme_information',\n\t\tarray(\n\t\t\t'slug'   => $slug,\n\t\t\t'fields' => array( 'sections' => false ),\n\t\t)\n\t);\n\n\tif ( is_wp_error( $api ) ) {\n\t\t$status['errorMessage'] = $api->get_error_message();\n\t\twp_send_json_error( $status );\n\t}\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Theme_Upgrader( $skin );\n\t$result   = $upgrader->install( $api->download_link );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorCode']    = $result->get_error_code();\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_null( $result ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t$status['themeName'] = wp_get_theme( $slug )->get( 'Name' );\n\n\tif ( current_user_can( 'switch_themes' ) ) {\n\t\tif ( is_multisite() ) {\n\t\t\t$status['activateUrl'] = add_query_arg(\n\t\t\t\tarray(\n\t\t\t\t\t'action'   => 'enable',\n\t\t\t\t\t'_wpnonce' => wp_create_nonce( 'enable-theme_' . $slug ),\n\t\t\t\t\t'theme'    => $slug,\n\t\t\t\t),\n\t\t\t\tnetwork_admin_url( 'themes.php' )\n\t\t\t);\n\t\t} else {\n\t\t\t$status['activateUrl'] = add_query_arg(\n\t\t\t\tarray(\n\t\t\t\t\t'action'     => 'activate',\n\t\t\t\t\t'_wpnonce'   => wp_create_nonce( 'switch-theme_' . $slug ),\n\t\t\t\t\t'stylesheet' => $slug,\n\t\t\t\t),\n\t\t\t\tadmin_url( 'themes.php' )\n\t\t\t);\n\t\t}\n\t}\n\n\tif ( ! is_multisite() && current_user_can( 'edit_theme_options' ) && current_user_can( 'customize' ) ) {\n\t\t$status['customizeUrl'] = add_query_arg(\n\t\t\tarray(\n\t\t\t\t'return' => urlencode( network_admin_url( 'theme-install.php', 'relative' ) ),\n\t\t\t),\n\t\t\twp_customize_url( $slug )\n\t\t);\n\t}\n\n\t/*\n\t * See WP_Theme_Install_List_Table::_get_theme_status() if we wanted to check\n\t * on post-installation status.\n\t */\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for updating a theme.\n *\n * @since 4.6.0\n *\n * @see Theme_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_update_theme() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_theme_specified',\n\t\t\t\t'errorMessage' => __( 'No theme specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$stylesheet = preg_replace( '/[^A-z0-9_\\-]/', '', wp_unslash( $_POST['slug'] ) );\n\t$status     = array(\n\t\t'update'     => 'theme',\n\t\t'slug'       => $stylesheet,\n\t\t'oldVersion' => '',\n\t\t'newVersion' => '',\n\t);\n\n\tif ( ! current_user_can( 'update_themes' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to update themes for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t$theme = wp_get_theme( $stylesheet );\n\tif ( $theme->exists() ) {\n\t\t$status['oldVersion'] = $theme->get( 'Version' );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\n\t$current = get_site_transient( 'update_themes' );\n\tif ( empty( $current ) ) {\n\t\twp_update_themes();\n\t}\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Theme_Upgrader( $skin );\n\t$result   = $upgrader->bulk_upgrade( array( $stylesheet ) );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_array( $result ) && ! empty( $result[ $stylesheet ] ) ) {\n\n\t\t// Theme is already at the latest version.\n\t\tif ( true === $result[ $stylesheet ] ) {\n\t\t\t$status['errorMessage'] = $upgrader->strings['up_to_date'];\n\t\t\twp_send_json_error( $status );\n\t\t}\n\n\t\t$theme = wp_get_theme( $stylesheet );\n\t\tif ( $theme->exists() ) {\n\t\t\t$status['newVersion'] = $theme->get( 'Version' );\n\t\t}\n\n\t\twp_send_json_success( $status );\n\t} elseif ( false === $result ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t// An unhandled error occurred.\n\t$status['errorMessage'] = __( 'Update failed.' );\n\twp_send_json_error( $status );\n}\n\n/**\n * Ajax handler for deleting a theme.\n *\n * @since 4.6.0\n *\n * @see delete_theme()\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_delete_theme() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_theme_specified',\n\t\t\t\t'errorMessage' => __( 'No theme specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$stylesheet = preg_replace( '/[^A-z0-9_\\-]/', '', wp_unslash( $_POST['slug'] ) );\n\t$status     = array(\n\t\t'delete' => 'theme',\n\t\t'slug'   => $stylesheet,\n\t);\n\n\tif ( ! current_user_can( 'delete_themes' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to delete themes on this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\tif ( ! wp_get_theme( $stylesheet )->exists() ) {\n\t\t$status['errorMessage'] = __( 'The requested theme does not exist.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Check filesystem credentials. `delete_theme()` will bail otherwise.\n\t$url = wp_nonce_url( 'themes.php?action=delete&stylesheet=' . urlencode( $stylesheet ), 'delete-theme_' . $stylesheet );\n\tob_start();\n\t$credentials = request_filesystem_credentials( $url );\n\tob_end_clean();\n\tif ( false === $credentials || ! WP_Filesystem( $credentials ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/theme.php' );\n\n\t$result = delete_theme( $stylesheet );\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( false === $result ) {\n\t\t$status['errorMessage'] = __( 'Theme could not be deleted.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for installing a plugin.\n *\n * @since 4.6.0\n *\n * @see Plugin_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_install_plugin() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_plugin_specified',\n\t\t\t\t'errorMessage' => __( 'No plugin specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$status = array(\n\t\t'install' => 'plugin',\n\t\t'slug'    => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t);\n\n\tif ( ! current_user_can( 'install_plugins' ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to install plugins on this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\tinclude_once( ABSPATH . 'wp-admin/includes/plugin-install.php' );\n\n\t$api = plugins_api(\n\t\t'plugin_information',\n\t\tarray(\n\t\t\t'slug'   => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t\t\t'fields' => array(\n\t\t\t\t'sections' => false,\n\t\t\t),\n\t\t)\n\t);\n\n\tif ( is_wp_error( $api ) ) {\n\t\t$status['errorMessage'] = $api->get_error_message();\n\t\twp_send_json_error( $status );\n\t}\n\n\t$status['pluginName'] = $api->name;\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Plugin_Upgrader( $skin );\n\t$result   = $upgrader->install( $api->download_link );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorCode']    = $result->get_error_code();\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_null( $result ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t$install_status = install_plugin_install_status( $api );\n\t$pagenow        = isset( $_POST['pagenow'] ) ? sanitize_key( $_POST['pagenow'] ) : '';\n\n\t// If installation request is coming from import page, do not return network activation link.\n\t$plugins_url = ( 'import' === $pagenow ) ? admin_url( 'plugins.php' ) : network_admin_url( 'plugins.php' );\n\n\tif ( current_user_can( 'activate_plugin', $install_status['file'] ) && is_plugin_inactive( $install_status['file'] ) ) {\n\t\t$status['activateUrl'] = add_query_arg(\n\t\t\tarray(\n\t\t\t\t'_wpnonce' => wp_create_nonce( 'activate-plugin_' . $install_status['file'] ),\n\t\t\t\t'action'   => 'activate',\n\t\t\t\t'plugin'   => $install_status['file'],\n\t\t\t),\n\t\t\t$plugins_url\n\t\t);\n\t}\n\n\tif ( is_multisite() && current_user_can( 'manage_network_plugins' ) && 'import' !== $pagenow ) {\n\t\t$status['activateUrl'] = add_query_arg( array( 'networkwide' => 1 ), $status['activateUrl'] );\n\t}\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for updating a plugin.\n *\n * @since 4.2.0\n *\n * @see Plugin_Upgrader\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_update_plugin() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['plugin'] ) || empty( $_POST['slug'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_plugin_specified',\n\t\t\t\t'errorMessage' => __( 'No plugin specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$plugin = plugin_basename( sanitize_text_field( wp_unslash( $_POST['plugin'] ) ) );\n\n\t$status = array(\n\t\t'update'     => 'plugin',\n\t\t'slug'       => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t\t'oldVersion' => '',\n\t\t'newVersion' => '',\n\t);\n\n\tif ( ! current_user_can( 'update_plugins' ) || 0 !== validate_file( $plugin ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to update plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t$plugin_data          = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin );\n\t$status['plugin']     = $plugin;\n\t$status['pluginName'] = $plugin_data['Name'];\n\n\tif ( $plugin_data['Version'] ) {\n\t\t/* translators: %s: Plugin version */\n\t\t$status['oldVersion'] = sprintf( __( 'Version %s' ), $plugin_data['Version'] );\n\t}\n\n\tinclude_once( ABSPATH . 'wp-admin/includes/class-wp-upgrader.php' );\n\n\twp_update_plugins();\n\n\t$skin     = new WP_Ajax_Upgrader_Skin();\n\t$upgrader = new Plugin_Upgrader( $skin );\n\t$result   = $upgrader->bulk_upgrade( array( $plugin ) );\n\n\tif ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {\n\t\t$status['debug'] = $skin->get_upgrade_messages();\n\t}\n\n\tif ( is_wp_error( $skin->result ) ) {\n\t\t$status['errorCode']    = $skin->result->get_error_code();\n\t\t$status['errorMessage'] = $skin->result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( $skin->get_errors()->has_errors() ) {\n\t\t$status['errorMessage'] = $skin->get_error_messages();\n\t\twp_send_json_error( $status );\n\t} elseif ( is_array( $result ) && ! empty( $result[ $plugin ] ) ) {\n\t\t$plugin_update_data = current( $result );\n\n\t\t/*\n\t\t * If the `update_plugins` site transient is empty (e.g. when you update\n\t\t * two plugins in quick succession before the transient repopulates),\n\t\t * this may be the return.\n\t\t *\n\t\t * Preferably something can be done to ensure `update_plugins` isn't empty.\n\t\t * For now, surface some sort of error here.\n\t\t */\n\t\tif ( true === $plugin_update_data ) {\n\t\t\t$status['errorMessage'] = __( 'Plugin update failed.' );\n\t\t\twp_send_json_error( $status );\n\t\t}\n\n\t\t$plugin_data = get_plugins( '/' . $result[ $plugin ]['destination_name'] );\n\t\t$plugin_data = reset( $plugin_data );\n\n\t\tif ( $plugin_data['Version'] ) {\n\t\t\t/* translators: %s: Plugin version */\n\t\t\t$status['newVersion'] = sprintf( __( 'Version %s' ), $plugin_data['Version'] );\n\t\t}\n\t\twp_send_json_success( $status );\n\t} elseif ( false === $result ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t// An unhandled error occurred.\n\t$status['errorMessage'] = __( 'Plugin update failed.' );\n\twp_send_json_error( $status );\n}\n\n/**\n * Ajax handler for deleting a plugin.\n *\n * @since 4.6.0\n *\n * @see delete_plugins()\n *\n * @global WP_Filesystem_Base $wp_filesystem WordPress filesystem subclass.\n */\nfunction wp_ajax_delete_plugin() {\n\tcheck_ajax_referer( 'updates' );\n\n\tif ( empty( $_POST['slug'] ) || empty( $_POST['plugin'] ) ) {\n\t\twp_send_json_error(\n\t\t\tarray(\n\t\t\t\t'slug'         => '',\n\t\t\t\t'errorCode'    => 'no_plugin_specified',\n\t\t\t\t'errorMessage' => __( 'No plugin specified.' ),\n\t\t\t)\n\t\t);\n\t}\n\n\t$plugin = plugin_basename( sanitize_text_field( wp_unslash( $_POST['plugin'] ) ) );\n\n\t$status = array(\n\t\t'delete' => 'plugin',\n\t\t'slug'   => sanitize_key( wp_unslash( $_POST['slug'] ) ),\n\t);\n\n\tif ( ! current_user_can( 'delete_plugins' ) || 0 !== validate_file( $plugin ) ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to delete plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t$plugin_data          = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin );\n\t$status['plugin']     = $plugin;\n\t$status['pluginName'] = $plugin_data['Name'];\n\n\tif ( is_plugin_active( $plugin ) ) {\n\t\t$status['errorMessage'] = __( 'You cannot delete a plugin while it is active on the main site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Check filesystem credentials. `delete_plugins()` will bail otherwise.\n\t$url = wp_nonce_url( 'plugins.php?action=delete-selected&verify-delete=1&checked[]=' . $plugin, 'bulk-plugins' );\n\tob_start();\n\t$credentials = request_filesystem_credentials( $url );\n\tob_end_clean();\n\tif ( false === $credentials || ! WP_Filesystem( $credentials ) ) {\n\t\tglobal $wp_filesystem;\n\n\t\t$status['errorCode']    = 'unable_to_connect_to_filesystem';\n\t\t$status['errorMessage'] = __( 'Unable to connect to the filesystem. Please confirm your credentials.' );\n\n\t\t// Pass through the error from WP_Filesystem if one was raised.\n\t\tif ( $wp_filesystem instanceof WP_Filesystem_Base && is_wp_error( $wp_filesystem->errors ) && $wp_filesystem->errors->has_errors() ) {\n\t\t\t$status['errorMessage'] = esc_html( $wp_filesystem->errors->get_error_message() );\n\t\t}\n\n\t\twp_send_json_error( $status );\n\t}\n\n\t$result = delete_plugins( array( $plugin ) );\n\n\tif ( is_wp_error( $result ) ) {\n\t\t$status['errorMessage'] = $result->get_error_message();\n\t\twp_send_json_error( $status );\n\t} elseif ( false === $result ) {\n\t\t$status['errorMessage'] = __( 'Plugin could not be deleted.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for searching plugins.\n *\n * @since 4.6.0\n *\n * @global string $s Search term.\n */\nfunction wp_ajax_search_plugins() {\n\tcheck_ajax_referer( 'updates' );\n\n\t$pagenow = isset( $_POST['pagenow'] ) ? sanitize_key( $_POST['pagenow'] ) : '';\n\tif ( 'plugins-network' === $pagenow || 'plugins' === $pagenow ) {\n\t\tset_current_screen( $pagenow );\n\t}\n\n\t/** @var WP_Plugins_List_Table $wp_list_table */\n\t$wp_list_table = _get_list_table(\n\t\t'WP_Plugins_List_Table',\n\t\tarray(\n\t\t\t'screen' => get_current_screen(),\n\t\t)\n\t);\n\n\t$status = array();\n\n\tif ( ! $wp_list_table->ajax_user_can() ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to manage plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Set the correct requester, so pagination works.\n\t$_SERVER['REQUEST_URI'] = add_query_arg(\n\t\tarray_diff_key(\n\t\t\t$_POST,\n\t\t\tarray(\n\t\t\t\t'_ajax_nonce' => null,\n\t\t\t\t'action'      => null,\n\t\t\t)\n\t\t),\n\t\tnetwork_admin_url( 'plugins.php', 'relative' )\n\t);\n\n\t$GLOBALS['s'] = wp_unslash( $_POST['s'] );\n\n\t$wp_list_table->prepare_items();\n\n\tob_start();\n\t$wp_list_table->display();\n\t$status['count'] = count( $wp_list_table->items );\n\t$status['items'] = ob_get_clean();\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for searching plugins to install.\n *\n * @since 4.6.0\n */\nfunction wp_ajax_search_install_plugins() {\n\tcheck_ajax_referer( 'updates' );\n\n\t$pagenow = isset( $_POST['pagenow'] ) ? sanitize_key( $_POST['pagenow'] ) : '';\n\tif ( 'plugin-install-network' === $pagenow || 'plugin-install' === $pagenow ) {\n\t\tset_current_screen( $pagenow );\n\t}\n\n\t/** @var WP_Plugin_Install_List_Table $wp_list_table */\n\t$wp_list_table = _get_list_table(\n\t\t'WP_Plugin_Install_List_Table',\n\t\tarray(\n\t\t\t'screen' => get_current_screen(),\n\t\t)\n\t);\n\n\t$status = array();\n\n\tif ( ! $wp_list_table->ajax_user_can() ) {\n\t\t$status['errorMessage'] = __( 'Sorry, you are not allowed to manage plugins for this site.' );\n\t\twp_send_json_error( $status );\n\t}\n\n\t// Set the correct requester, so pagination works.\n\t$_SERVER['REQUEST_URI'] = add_query_arg(\n\t\tarray_diff_key(\n\t\t\t$_POST,\n\t\t\tarray(\n\t\t\t\t'_ajax_nonce' => null,\n\t\t\t\t'action'      => null,\n\t\t\t)\n\t\t),\n\t\tnetwork_admin_url( 'plugin-install.php', 'relative' )\n\t);\n\n\t$wp_list_table->prepare_items();\n\n\tob_start();\n\t$wp_list_table->display();\n\t$status['count'] = (int) $wp_list_table->get_pagination_arg( 'total_items' );\n\t$status['items'] = ob_get_clean();\n\n\twp_send_json_success( $status );\n}\n\n/**\n * Ajax handler for editing a theme or plugin file.\n *\n * @since 4.9.0\n * @see wp_edit_theme_plugin_file()\n */\nfunction wp_ajax_edit_theme_plugin_file() {\n\t$r = wp_edit_theme_plugin_file( wp_unslash( $_POST ) ); // Validation of args is done in wp_edit_theme_plugin_file().\n\tif ( is_wp_error( $r ) ) {\n\t\twp_send_json_error(\n\t\t\tarray_merge(\n\t\t\t\tarray(\n\t\t\t\t\t'code'    => $r->get_error_code(),\n\t\t\t\t\t'message' => $r->get_error_message(),\n\t\t\t\t),\n\t\t\t\t(array) $r->get_error_data()\n\t\t\t)\n\t\t);\n\t} else {\n\t\twp_send_json_success(\n\t\t\tarray(\n\t\t\t\t'message' => __( 'File edited successfully.' ),\n\t\t\t)\n\t\t);\n\t}\n}\n\n/**\n * Ajax handler for exporting a user's personal data.\n *\n * @since 4.9.6\n */\nfunction wp_ajax_wp_privacy_export_personal_data() {\n\n\tif ( empty( $_POST['id'] ) ) {\n\t\twp_send_json_error( __( 'Missing request ID.' ) );\n\t}\n\t$request_id = (int) $_POST['id'];\n\n\tif ( $request_id < 1 ) {\n\t\twp_send_json_error( __( 'Invalid request ID.' ) );\n\t}\n\n\tif ( ! current_user_can( 'export_others_personal_data' ) ) {\n\t\twp_send_json_error( __( 'Sorry, you are not allowed to perform this action.' ) );\n\t}\n\n\tcheck_ajax_referer( 'wp-privacy-export-personal-data-' . $request_id, 'security' );\n\n\t// Get the request data.\n\t$request = wp_get_user_request_data( $request_id );\n\n\tif ( ! $request || 'export_personal_data' !== $request->action_name ) {\n\t\twp_send_json_error( __( 'Invalid request type.' ) );\n\t}\n\n\t$email_address = $request->email;\n\tif ( ! is_email( $email_address ) ) {\n\t\twp_send_json_error( __( 'A valid email address must be given.' ) );\n\t}\n\n\tif ( ! isset( $_POST['exporter'] ) ) {\n\t\twp_send_json_error( __( 'Missing exporter index.' ) );\n\t}\n\t$exporter_index = (int) $_POST['exporter'];\n\n\tif ( ! isset( $_POST['page'] ) ) {\n\t\twp_send_json_error( __( 'Missing page index.' ) );\n\t}\n\t$page = (int) $_POST['page'];\n\n\t$send_as_email = isset( $_POST['sendAsEmail'] ) ? ( 'true' === $_POST['sendAsEmail'] ) : false;\n\n\t/**\n\t * Filters the array of exporter callbacks.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array $args {\n\t *     An array of callable exporters of personal data. Default empty array.\n\t *\n\t *     @type array {\n\t *         Array of personal data exporters.\n\t *\n\t *         @type string $callback               Callable exporter function that accepts an\n\t *                                              email address and a page and returns an array\n\t *                                              of name => value pairs of personal data.\n\t *         @type string $exporter_friendly_name Translated user facing friendly name for the\n\t *                                              exporter.\n\t *     }\n\t * }\n\t */\n\t$exporters = apply_filters( 'wp_privacy_personal_data_exporters', array() );\n\n\tif ( ! is_array( $exporters ) ) {\n\t\twp_send_json_error( __( 'An exporter has improperly used the registration filter.' ) );\n\t}\n\n\t// Do we have any registered exporters?\n\tif ( 0 < count( $exporters ) ) {\n\t\tif ( $exporter_index < 1 ) {\n\t\t\twp_send_json_error( __( 'Exporter index cannot be negative.' ) );\n\t\t}\n\n\t\tif ( $exporter_index > count( $exporters ) ) {\n\t\t\twp_send_json_error( __( 'Exporter index out of range.' ) );\n\t\t}\n\n\t\tif ( $page < 1 ) {\n\t\t\twp_send_json_error( __( 'Page index cannot be less than one.' ) );\n\t\t}\n\n\t\t$exporter_keys = array_keys( $exporters );\n\t\t$exporter_key  = $exporter_keys[ $exporter_index - 1 ];\n\t\t$exporter      = $exporters[ $exporter_key ];\n\n\t\tif ( ! is_array( $exporter ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: array index */\n\t\t\t\tsprintf( __( 'Expected an array describing the exporter at index %s.' ), $exporter_key )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'exporter_friendly_name', $exporter ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: array index */\n\t\t\t\tsprintf( __( 'Exporter array at index %s does not include a friendly name.' ), $exporter_key )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'callback', $exporter ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Exporter does not include a callback: %s.' ), esc_html( $exporter['exporter_friendly_name'] ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! is_callable( $exporter['callback'] ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Exporter callback is not a valid callback: %s.' ), esc_html( $exporter['exporter_friendly_name'] ) )\n\t\t\t);\n\t\t}\n\n\t\t$callback               = $exporter['callback'];\n\t\t$exporter_friendly_name = $exporter['exporter_friendly_name'];\n\n\t\t$response = call_user_func( $callback, $email_address, $page );\n\t\tif ( is_wp_error( $response ) ) {\n\t\t\twp_send_json_error( $response );\n\t\t}\n\n\t\tif ( ! is_array( $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected response as an array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'data', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected data in response array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! is_array( $response['data'] ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected data array in response array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t\tif ( ! array_key_exists( 'done', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\t/* translators: %s: exporter friendly name */\n\t\t\t\tsprintf( __( 'Expected done (boolean) in response array from exporter: %s.' ), esc_html( $exporter_friendly_name ) )\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// No exporters, so we're done.\n\t\t$exporter_key = '';\n\n\t\t$response = array(\n\t\t\t'data' => array(),\n\t\t\t'done' => true,\n\t\t);\n\t}\n\n\t/**\n\t * Filters a page of personal data exporter data. Used to build the export report.\n\t *\n\t * Allows the export response to be consumed by destinations in addition to Ajax.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array  $response        The personal data for the given exporter and page.\n\t * @param int    $exporter_index  The index of the exporter that provided this data.\n\t * @param string $email_address   The email address associated with this personal data.\n\t * @param int    $page            The page for this response.\n\t * @param int    $request_id      The privacy request post ID associated with this request.\n\t * @param bool   $send_as_email   Whether the final results of the export should be emailed to the user.\n\t * @param string $exporter_key    The key (slug) of the exporter that provided this data.\n\t */\n\t$response = apply_filters( 'wp_privacy_personal_data_export_page', $response, $exporter_index, $email_address, $page, $request_id, $send_as_email, $exporter_key );\n\n\tif ( is_wp_error( $response ) ) {\n\t\twp_send_json_error( $response );\n\t}\n\n\twp_send_json_success( $response );\n}\n\n/**\n * Ajax handler for erasing personal data.\n *\n * @since 4.9.6\n */\nfunction wp_ajax_wp_privacy_erase_personal_data() {\n\n\tif ( empty( $_POST['id'] ) ) {\n\t\twp_send_json_error( __( 'Missing request ID.' ) );\n\t}\n\n\t$request_id = (int) $_POST['id'];\n\n\tif ( $request_id < 1 ) {\n\t\twp_send_json_error( __( 'Invalid request ID.' ) );\n\t}\n\n\t// Both capabilities are required to avoid confusion, see `_wp_personal_data_removal_page()`.\n\tif ( ! current_user_can( 'erase_others_personal_data' ) || ! current_user_can( 'delete_users' ) ) {\n\t\twp_send_json_error( __( 'Sorry, you are not allowed to perform this action.' ) );\n\t}\n\n\tcheck_ajax_referer( 'wp-privacy-erase-personal-data-' . $request_id, 'security' );\n\n\t// Get the request data.\n\t$request = wp_get_user_request_data( $request_id );\n\n\tif ( ! $request || 'remove_personal_data' !== $request->action_name ) {\n\t\twp_send_json_error( __( 'Invalid request ID.' ) );\n\t}\n\n\t$email_address = $request->email;\n\n\tif ( ! is_email( $email_address ) ) {\n\t\twp_send_json_error( __( 'Invalid email address in request.' ) );\n\t}\n\n\tif ( ! isset( $_POST['eraser'] ) ) {\n\t\twp_send_json_error( __( 'Missing eraser index.' ) );\n\t}\n\n\t$eraser_index = (int) $_POST['eraser'];\n\n\tif ( ! isset( $_POST['page'] ) ) {\n\t\twp_send_json_error( __( 'Missing page index.' ) );\n\t}\n\n\t$page = (int) $_POST['page'];\n\n\t/**\n\t * Filters the array of personal data eraser callbacks.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array $args {\n\t *     An array of callable erasers of personal data. Default empty array.\n\t *\n\t *     @type array {\n\t *         Array of personal data exporters.\n\t *\n\t *         @type string $callback               Callable eraser that accepts an email address and\n\t *                                              a page and returns an array with boolean values for\n\t *                                              whether items were removed or retained and any messages\n\t *                                              from the eraser, as well as if additional pages are\n\t *                                              available.\n\t *         @type string $exporter_friendly_name Translated user facing friendly name for the eraser.\n\t *     }\n\t * }\n\t */\n\t$erasers = apply_filters( 'wp_privacy_personal_data_erasers', array() );\n\n\t// Do we have any registered erasers?\n\tif ( 0 < count( $erasers ) ) {\n\n\t\tif ( $eraser_index < 1 ) {\n\t\t\twp_send_json_error( __( 'Eraser index cannot be less than one.' ) );\n\t\t}\n\n\t\tif ( $eraser_index > count( $erasers ) ) {\n\t\t\twp_send_json_error( __( 'Eraser index is out of range.' ) );\n\t\t}\n\n\t\tif ( $page < 1 ) {\n\t\t\twp_send_json_error( __( 'Page index cannot be less than one.' ) );\n\t\t}\n\n\t\t$eraser_keys = array_keys( $erasers );\n\t\t$eraser_key  = $eraser_keys[ $eraser_index - 1 ];\n\t\t$eraser      = $erasers[ $eraser_key ];\n\n\t\tif ( ! is_array( $eraser ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Expected an array describing the eraser at index %d.' ), $eraser_index ) );\n\t\t}\n\n\t\tif ( ! array_key_exists( 'callback', $eraser ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Eraser array at index %d does not include a callback.' ), $eraser_index ) );\n\t\t}\n\n\t\tif ( ! is_callable( $eraser['callback'] ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Eraser callback at index %d is not a valid callback.' ), $eraser_index ) );\n\t\t}\n\n\t\tif ( ! array_key_exists( 'eraser_friendly_name', $eraser ) ) {\n\t\t\t/* translators: %d: array index */\n\t\t\twp_send_json_error( sprintf( __( 'Eraser array at index %d does not include a friendly name.' ), $eraser_index ) );\n\t\t}\n\n\t\t$callback             = $eraser['callback'];\n\t\t$eraser_friendly_name = $eraser['eraser_friendly_name'];\n\n\t\t$response = call_user_func( $callback, $email_address, $page );\n\n\t\tif ( is_wp_error( $response ) ) {\n\t\t\twp_send_json_error( $response );\n\t\t}\n\n\t\tif ( ! is_array( $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Did not receive array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'items_removed', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected items_removed key in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'items_retained', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected items_retained key in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'messages', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected messages key in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! is_array( $response['messages'] ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected messages key to reference an array in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif ( ! array_key_exists( 'done', $response ) ) {\n\t\t\twp_send_json_error(\n\t\t\t\tsprintf(\n\t\t\t\t\t/* translators: 1: eraser friendly name, 2: array index */\n\t\t\t\t\t__( 'Expected done flag in response array from %1$s eraser (index %2$d).' ),\n\t\t\t\t\tesc_html( $eraser_friendly_name ),\n\t\t\t\t\t$eraser_index\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t} else {\n\t\t// No erasers, so we're done.\n\t\t$eraser_key = '';\n\n\t\t$response = array(\n\t\t\t'items_removed'  => false,\n\t\t\t'items_retained' => false,\n\t\t\t'messages'       => array(),\n\t\t\t'done'           => true,\n\t\t);\n\t}\n\n\t/**\n\t * Filters a page of personal data eraser data.\n\t *\n\t * Allows the erasure response to be consumed by destinations in addition to Ajax.\n\t *\n\t * @since 4.9.6\n\t *\n\t * @param array  $response        The personal data for the given exporter and page.\n\t * @param int    $eraser_index    The index of the eraser that provided this data.\n\t * @param string $email_address   The email address associated with this personal data.\n\t * @param int    $page            The page for this response.\n\t * @param int    $request_id      The privacy request post ID associated with this request.\n\t * @param string $eraser_key      The key (slug) of the eraser that provided this data.\n\t */\n\t$response = apply_filters( 'wp_privacy_personal_data_erasure_page', $response, $eraser_index, $email_address, $page, $request_id, $eraser_key );\n\n\tif ( is_wp_error( $response ) ) {\n\t\twp_send_json_error( $response );\n\t}\n\n\twp_send_json_success( $response );\n}\n", "<?php\n/**\n * Core Comment API\n *\n * @package WordPress\n * @subpackage Comment\n */\n\n/**\n * Check whether a comment passes internal checks to be allowed to add.\n *\n * If manual comment moderation is set in the administration, then all checks,\n * regardless of their type and whitelist, will fail and the function will\n * return false.\n *\n * If the number of links exceeds the amount in the administration, then the\n * check fails. If any of the parameter contents match the blacklist of words,\n * then the check fails.\n *\n * If the comment author was approved before, then the comment is automatically\n * whitelisted.\n *\n * If all checks pass, the function will return true.\n *\n * @since 1.2.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $author       Comment author name.\n * @param string $email        Comment author email.\n * @param string $url          Comment author URL.\n * @param string $comment      Content of the comment.\n * @param string $user_ip      Comment author IP address.\n * @param string $user_agent   Comment author User-Agent.\n * @param string $comment_type Comment type, either user-submitted comment,\n *                             trackback, or pingback.\n * @return bool If all checks pass, true, otherwise false.\n */\nfunction check_comment( $author, $email, $url, $comment, $user_ip, $user_agent, $comment_type ) {\n\tglobal $wpdb;\n\n\t// If manual moderation is enabled, skip all checks and return false.\n\tif ( 1 == get_option( 'comment_moderation' ) ) {\n\t\treturn false;\n\t}\n\n\t/** This filter is documented in wp-includes/comment-template.php */\n\t$comment = apply_filters( 'comment_text', $comment, null, array() );\n\n\t// Check for the number of external links if a max allowed number is set.\n\tif ( $max_links = get_option( 'comment_max_links' ) ) {\n\t\t$num_links = preg_match_all( '/<a [^>]*href/i', $comment, $out );\n\n\t\t/**\n\t\t * Filters the number of links found in a comment.\n\t\t *\n\t\t * @since 3.0.0\n\t\t * @since 4.7.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int    $num_links The number of links found.\n\t\t * @param string $url       Comment author's URL. Included in allowed links total.\n\t\t * @param string $comment   Content of the comment.\n\t\t */\n\t\t$num_links = apply_filters( 'comment_max_links_url', $num_links, $url, $comment );\n\n\t\t/*\n\t\t * If the number of links in the comment exceeds the allowed amount,\n\t\t * fail the check by returning false.\n\t\t */\n\t\tif ( $num_links >= $max_links ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t$mod_keys = trim( get_option( 'moderation_keys' ) );\n\n\t// If moderation 'keys' (keywords) are set, process them.\n\tif ( ! empty( $mod_keys ) ) {\n\t\t$words = explode( \"\\n\", $mod_keys );\n\n\t\tforeach ( (array) $words as $word ) {\n\t\t\t$word = trim( $word );\n\n\t\t\t// Skip empty lines.\n\t\t\tif ( empty( $word ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do some escaping magic so that '#' (number of) characters in the spam\n\t\t\t * words don't break things:\n\t\t\t */\n\t\t\t$word = preg_quote( $word, '#' );\n\n\t\t\t/*\n\t\t\t * Check the comment fields for moderation keywords. If any are found,\n\t\t\t * fail the check for the given field by returning false.\n\t\t\t */\n\t\t\t$pattern = \"#$word#i\";\n\t\t\tif ( preg_match( $pattern, $author ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $email ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $url ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $comment ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $user_ip ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ( preg_match( $pattern, $user_agent ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Check if the option to approve comments by previously-approved authors is enabled.\n\t *\n\t * If it is enabled, check whether the comment author has a previously-approved comment,\n\t * as well as whether there are any moderation keywords (if set) present in the author\n\t * email address. If both checks pass, return true. Otherwise, return false.\n\t */\n\tif ( 1 == get_option( 'comment_whitelist' ) ) {\n\t\tif ( 'trackback' != $comment_type && 'pingback' != $comment_type && $author != '' && $email != '' ) {\n\t\t\t$comment_user = get_user_by( 'email', wp_unslash( $email ) );\n\t\t\tif ( ! empty( $comment_user->ID ) ) {\n\t\t\t\t$ok_to_comment = $wpdb->get_var( $wpdb->prepare( \"SELECT comment_approved FROM $wpdb->comments WHERE user_id = %d AND comment_approved = '1' LIMIT 1\", $comment_user->ID ) );\n\t\t\t} else {\n\t\t\t\t// expected_slashed ($author, $email)\n\t\t\t\t$ok_to_comment = $wpdb->get_var( $wpdb->prepare( \"SELECT comment_approved FROM $wpdb->comments WHERE comment_author = %s AND comment_author_email = %s and comment_approved = '1' LIMIT 1\", $author, $email ) );\n\t\t\t}\n\t\t\tif ( ( 1 == $ok_to_comment ) &&\n\t\t\t\t( empty( $mod_keys ) || false === strpos( $email, $mod_keys ) ) ) {\n\t\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\n * Retrieve the approved comments for post $post_id.\n *\n * @since 2.0.0\n * @since 4.1.0 Refactored to leverage WP_Comment_Query over a direct query.\n *\n * @param  int   $post_id The ID of the post.\n * @param  array $args    Optional. See WP_Comment_Query::__construct() for information on accepted arguments.\n * @return int|array $comments The approved comments, or number of comments if `$count`\n *                             argument is true.\n */\nfunction get_approved_comments( $post_id, $args = array() ) {\n\tif ( ! $post_id ) {\n\t\treturn array();\n\t}\n\n\t$defaults = array(\n\t\t'status'  => 1,\n\t\t'post_id' => $post_id,\n\t\t'order'   => 'ASC',\n\t);\n\t$r        = wp_parse_args( $args, $defaults );\n\n\t$query = new WP_Comment_Query;\n\treturn $query->query( $r );\n}\n\n/**\n * Retrieves comment data given a comment ID or comment object.\n *\n * If an object is passed then the comment data will be cached and then returned\n * after being passed through a filter. If the comment is empty, then the global\n * comment variable will be used, if it is set.\n *\n * @since 2.0.0\n *\n * @global WP_Comment $comment\n *\n * @param WP_Comment|string|int $comment Comment to retrieve.\n * @param string                $output  Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to\n *                                       a WP_Comment object, an associative array, or a numeric array, respectively. Default OBJECT.\n * @return WP_Comment|array|null Depends on $output value.\n */\nfunction get_comment( &$comment = null, $output = OBJECT ) {\n\tif ( empty( $comment ) && isset( $GLOBALS['comment'] ) ) {\n\t\t$comment = $GLOBALS['comment'];\n\t}\n\n\tif ( $comment instanceof WP_Comment ) {\n\t\t$_comment = $comment;\n\t} elseif ( is_object( $comment ) ) {\n\t\t$_comment = new WP_Comment( $comment );\n\t} else {\n\t\t$_comment = WP_Comment::get_instance( $comment );\n\t}\n\n\tif ( ! $_comment ) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Fires after a comment is retrieved.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param mixed $_comment Comment data.\n\t */\n\t$_comment = apply_filters( 'get_comment', $_comment );\n\n\tif ( $output == OBJECT ) {\n\t\treturn $_comment;\n\t} elseif ( $output == ARRAY_A ) {\n\t\treturn $_comment->to_array();\n\t} elseif ( $output == ARRAY_N ) {\n\t\treturn array_values( $_comment->to_array() );\n\t}\n\treturn $_comment;\n}\n\n/**\n * Retrieve a list of comments.\n *\n * The comment list can be for the blog as a whole or for an individual post.\n *\n * @since 2.7.0\n *\n * @param string|array $args Optional. Array or string of arguments. See WP_Comment_Query::__construct()\n *                           for information on accepted arguments. Default empty.\n * @return int|array List of comments or number of found comments if `$count` argument is true.\n */\nfunction get_comments( $args = '' ) {\n\t$query = new WP_Comment_Query;\n\treturn $query->query( $args );\n}\n\n/**\n * Retrieve all of the WordPress supported comment statuses.\n *\n * Comments have a limited set of valid status values, this provides the comment\n * status values and descriptions.\n *\n * @since 2.7.0\n *\n * @return array List of comment statuses.\n */\nfunction get_comment_statuses() {\n\t$status = array(\n\t\t'hold'    => __( 'Unapproved' ),\n\t\t'approve' => _x( 'Approved', 'comment status' ),\n\t\t'spam'    => _x( 'Spam', 'comment status' ),\n\t\t'trash'   => _x( 'Trash', 'comment status' ),\n\t);\n\n\treturn $status;\n}\n\n/**\n * Gets the default comment status for a post type.\n *\n * @since 4.3.0\n *\n * @param string $post_type    Optional. Post type. Default 'post'.\n * @param string $comment_type Optional. Comment type. Default 'comment'.\n * @return string Expected return value is 'open' or 'closed'.\n */\nfunction get_default_comment_status( $post_type = 'post', $comment_type = 'comment' ) {\n\tswitch ( $comment_type ) {\n\t\tcase 'pingback':\n\t\tcase 'trackback':\n\t\t\t$supports = 'trackbacks';\n\t\t\t$option   = 'ping';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$supports = 'comments';\n\t\t\t$option   = 'comment';\n\t}\n\n\t// Set the status.\n\tif ( 'page' === $post_type ) {\n\t\t$status = 'closed';\n\t} elseif ( post_type_supports( $post_type, $supports ) ) {\n\t\t$status = get_option( \"default_{$option}_status\" );\n\t} else {\n\t\t$status = 'closed';\n\t}\n\n\t/**\n\t * Filters the default comment status for the given post type.\n\t *\n\t * @since 4.3.0\n\t *\n\t * @param string $status       Default status for the given post type,\n\t *                             either 'open' or 'closed'.\n\t * @param string $post_type    Post type. Default is `post`.\n\t * @param string $comment_type Type of comment. Default is `comment`.\n\t */\n\treturn apply_filters( 'get_default_comment_status', $status, $post_type, $comment_type );\n}\n\n/**\n * The date the last comment was modified.\n *\n * @since 1.5.0\n * @since 4.7.0 Replaced caching the modified date in a local static variable\n *              with the Object Cache API.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $timezone Which timezone to use in reference to 'gmt', 'blog', or 'server' locations.\n * @return string|false Last comment modified date on success, false on failure.\n */\nfunction get_lastcommentmodified( $timezone = 'server' ) {\n\tglobal $wpdb;\n\n\t$timezone = strtolower( $timezone );\n\t$key      = \"lastcommentmodified:$timezone\";\n\n\t$comment_modified_date = wp_cache_get( $key, 'timeinfo' );\n\tif ( false !== $comment_modified_date ) {\n\t\treturn $comment_modified_date;\n\t}\n\n\tswitch ( $timezone ) {\n\t\tcase 'gmt':\n\t\t\t$comment_modified_date = $wpdb->get_var( \"SELECT comment_date_gmt FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1\" );\n\t\t\tbreak;\n\t\tcase 'blog':\n\t\t\t$comment_modified_date = $wpdb->get_var( \"SELECT comment_date FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1\" );\n\t\t\tbreak;\n\t\tcase 'server':\n\t\t\t$add_seconds_server = date( 'Z' );\n\n\t\t\t$comment_modified_date = $wpdb->get_var( $wpdb->prepare( \"SELECT DATE_ADD(comment_date_gmt, INTERVAL %s SECOND) FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1\", $add_seconds_server ) );\n\t\t\tbreak;\n\t}\n\n\tif ( $comment_modified_date ) {\n\t\twp_cache_set( $key, $comment_modified_date, 'timeinfo' );\n\n\t\treturn $comment_modified_date;\n\t}\n\n\treturn false;\n}\n\n/**\n * The amount of comments in a post or total comments.\n *\n * A lot like wp_count_comments(), in that they both return comment stats (albeit with different types).\n * The wp_count_comments() actually caches, but this function does not.\n *\n * @since 2.0.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $post_id Optional. Comment amount in post if > 0, else total comments blog wide.\n * @return array The amount of spam, approved, awaiting moderation, and total comments.\n */\nfunction get_comment_count( $post_id = 0 ) {\n\tglobal $wpdb;\n\n\t$post_id = (int) $post_id;\n\n\t$where = '';\n\tif ( $post_id > 0 ) {\n\t\t$where = $wpdb->prepare( 'WHERE comment_post_ID = %d', $post_id );\n\t}\n\n\t$totals = (array) $wpdb->get_results(\n\t\t\"\n\t\tSELECT comment_approved, COUNT( * ) AS total\n\t\tFROM {$wpdb->comments}\n\t\t{$where}\n\t\tGROUP BY comment_approved\n\t\",\n\t\tARRAY_A\n\t);\n\n\t$comment_count = array(\n\t\t'approved'            => 0,\n\t\t'awaiting_moderation' => 0,\n\t\t'spam'                => 0,\n\t\t'trash'               => 0,\n\t\t'post-trashed'        => 0,\n\t\t'total_comments'      => 0,\n\t\t'all'                 => 0,\n\t);\n\n\tforeach ( $totals as $row ) {\n\t\tswitch ( $row['comment_approved'] ) {\n\t\t\tcase 'trash':\n\t\t\t\t$comment_count['trash'] = $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase 'post-trashed':\n\t\t\t\t$comment_count['post-trashed'] = $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase 'spam':\n\t\t\t\t$comment_count['spam']            = $row['total'];\n\t\t\t\t$comment_count['total_comments'] += $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\t$comment_count['approved']        = $row['total'];\n\t\t\t\t$comment_count['total_comments'] += $row['total'];\n\t\t\t\t$comment_count['all']            += $row['total'];\n\t\t\t\tbreak;\n\t\t\tcase '0':\n\t\t\t\t$comment_count['awaiting_moderation'] = $row['total'];\n\t\t\t\t$comment_count['total_comments']     += $row['total'];\n\t\t\t\t$comment_count['all']                += $row['total'];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn $comment_count;\n}\n\n//\n// Comment meta functions\n//\n\n/**\n * Add meta data field to a comment.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/add_comment_meta\n *\n * @param int $comment_id Comment ID.\n * @param string $meta_key Metadata name.\n * @param mixed $meta_value Metadata value.\n * @param bool $unique Optional, default is false. Whether the same key should not be added.\n * @return int|bool Meta ID on success, false on failure.\n */\nfunction add_comment_meta( $comment_id, $meta_key, $meta_value, $unique = false ) {\n\treturn add_metadata( 'comment', $comment_id, $meta_key, $meta_value, $unique );\n}\n\n/**\n * Remove metadata matching criteria from a comment.\n *\n * You can match based on the key, or key and value. Removing based on key and\n * value, will keep from removing duplicate metadata with the same key. It also\n * allows removing all metadata matching key, if needed.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/delete_comment_meta\n *\n * @param int $comment_id comment ID\n * @param string $meta_key Metadata name.\n * @param mixed $meta_value Optional. Metadata value.\n * @return bool True on success, false on failure.\n */\nfunction delete_comment_meta( $comment_id, $meta_key, $meta_value = '' ) {\n\treturn delete_metadata( 'comment', $comment_id, $meta_key, $meta_value );\n}\n\n/**\n * Retrieve comment meta field for a comment.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/get_comment_meta\n *\n * @param int $comment_id Comment ID.\n * @param string $key Optional. The meta key to retrieve. By default, returns data for all keys.\n * @param bool $single Whether to return a single value.\n * @return mixed Will be an array if $single is false. Will be value of meta data field if $single\n *  is true.\n */\nfunction get_comment_meta( $comment_id, $key = '', $single = false ) {\n\treturn get_metadata( 'comment', $comment_id, $key, $single );\n}\n\n/**\n * Update comment meta field based on comment ID.\n *\n * Use the $prev_value parameter to differentiate between meta fields with the\n * same key and comment ID.\n *\n * If the meta field for the comment does not exist, it will be added.\n *\n * @since 2.9.0\n * @link https://codex.wordpress.org/Function_Reference/update_comment_meta\n *\n * @param int $comment_id Comment ID.\n * @param string $meta_key Metadata key.\n * @param mixed $meta_value Metadata value.\n * @param mixed $prev_value Optional. Previous value to check before removing.\n * @return int|bool Meta ID if the key didn't exist, true on successful update, false on failure.\n */\nfunction update_comment_meta( $comment_id, $meta_key, $meta_value, $prev_value = '' ) {\n\treturn update_metadata( 'comment', $comment_id, $meta_key, $meta_value, $prev_value );\n}\n\n/**\n * Queues comments for metadata lazy-loading.\n *\n * @since 4.5.0\n *\n * @param WP_Comment[] $comments Array of comment objects.\n */\nfunction wp_queue_comments_for_comment_meta_lazyload( $comments ) {\n\t// Don't use `wp_list_pluck()` to avoid by-reference manipulation.\n\t$comment_ids = array();\n\tif ( is_array( $comments ) ) {\n\t\tforeach ( $comments as $comment ) {\n\t\t\tif ( $comment instanceof WP_Comment ) {\n\t\t\t\t$comment_ids[] = $comment->comment_ID;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( $comment_ids ) {\n\t\t$lazyloader = wp_metadata_lazyloader();\n\t\t$lazyloader->queue_objects( 'comment', $comment_ids );\n\t}\n}\n\n/**\n * Sets the cookies used to store an unauthenticated commentator's identity. Typically used\n * to recall previous comments by this commentator that are still held in moderation.\n *\n * @since 3.4.0\n * @since 4.9.6 The `$cookies_consent` parameter was added.\n *\n * @param WP_Comment $comment         Comment object.\n * @param WP_User    $user            Comment author's user object. The user may not exist.\n * @param boolean    $cookies_consent Optional. Comment author's consent to store cookies. Default true.\n */\nfunction wp_set_comment_cookies( $comment, $user, $cookies_consent = true ) {\n\t// If the user already exists, or the user opted out of cookies, don't set cookies.\n\tif ( $user->exists() ) {\n\t\treturn;\n\t}\n\n\tif ( false === $cookies_consent ) {\n\t\t// Remove any existing cookies.\n\t\t$past = time() - YEAR_IN_SECONDS;\n\t\tsetcookie( 'comment_author_' . COOKIEHASH, ' ', $past, COOKIEPATH, COOKIE_DOMAIN );\n\t\tsetcookie( 'comment_author_email_' . COOKIEHASH, ' ', $past, COOKIEPATH, COOKIE_DOMAIN );\n\t\tsetcookie( 'comment_author_url_' . COOKIEHASH, ' ', $past, COOKIEPATH, COOKIE_DOMAIN );\n\n\t\treturn;\n\t}\n\n\t/**\n\t * Filters the lifetime of the comment cookie in seconds.\n\t *\n\t * @since 2.8.0\n\t *\n\t * @param int $seconds Comment cookie lifetime. Default 30000000.\n\t */\n\t$comment_cookie_lifetime = time() + apply_filters( 'comment_cookie_lifetime', 30000000 );\n\t$secure                  = ( 'https' === parse_url( home_url(), PHP_URL_SCHEME ) );\n\tsetcookie( 'comment_author_' . COOKIEHASH, $comment->comment_author, $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );\n\tsetcookie( 'comment_author_email_' . COOKIEHASH, $comment->comment_author_email, $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );\n\tsetcookie( 'comment_author_url_' . COOKIEHASH, esc_url( $comment->comment_author_url ), $comment_cookie_lifetime, COOKIEPATH, COOKIE_DOMAIN, $secure );\n}\n\n/**\n * Sanitizes the cookies sent to the user already.\n *\n * Will only do anything if the cookies have already been created for the user.\n * Mostly used after cookies had been sent to use elsewhere.\n *\n * @since 2.0.4\n */\nfunction sanitize_comment_cookies() {\n\tif ( isset( $_COOKIE[ 'comment_author_' . COOKIEHASH ] ) ) {\n\t\t/**\n\t\t * Filters the comment author's name cookie before it is set.\n\t\t *\n\t\t * When this filter hook is evaluated in wp_filter_comment(),\n\t\t * the comment author's name string is passed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string $author_cookie The comment author name cookie.\n\t\t */\n\t\t$comment_author                            = apply_filters( 'pre_comment_author_name', $_COOKIE[ 'comment_author_' . COOKIEHASH ] );\n\t\t$comment_author                            = wp_unslash( $comment_author );\n\t\t$comment_author                            = esc_attr( $comment_author );\n\t\t$_COOKIE[ 'comment_author_' . COOKIEHASH ] = $comment_author;\n\t}\n\n\tif ( isset( $_COOKIE[ 'comment_author_email_' . COOKIEHASH ] ) ) {\n\t\t/**\n\t\t * Filters the comment author's email cookie before it is set.\n\t\t *\n\t\t * When this filter hook is evaluated in wp_filter_comment(),\n\t\t * the comment author's email string is passed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string $author_email_cookie The comment author email cookie.\n\t\t */\n\t\t$comment_author_email                            = apply_filters( 'pre_comment_author_email', $_COOKIE[ 'comment_author_email_' . COOKIEHASH ] );\n\t\t$comment_author_email                            = wp_unslash( $comment_author_email );\n\t\t$comment_author_email                            = esc_attr( $comment_author_email );\n\t\t$_COOKIE[ 'comment_author_email_' . COOKIEHASH ] = $comment_author_email;\n\t}\n\n\tif ( isset( $_COOKIE[ 'comment_author_url_' . COOKIEHASH ] ) ) {\n\t\t/**\n\t\t * Filters the comment author's URL cookie before it is set.\n\t\t *\n\t\t * When this filter hook is evaluated in wp_filter_comment(),\n\t\t * the comment author's URL string is passed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param string $author_url_cookie The comment author URL cookie.\n\t\t */\n\t\t$comment_author_url                            = apply_filters( 'pre_comment_author_url', $_COOKIE[ 'comment_author_url_' . COOKIEHASH ] );\n\t\t$comment_author_url                            = wp_unslash( $comment_author_url );\n\t\t$_COOKIE[ 'comment_author_url_' . COOKIEHASH ] = $comment_author_url;\n\t}\n}\n\n/**\n * Validates whether this comment is allowed to be made.\n *\n * @since 2.0.0\n * @since 4.7.0 The `$avoid_die` parameter was added, allowing the function to\n *              return a WP_Error object instead of dying.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentdata Contains information on the comment.\n * @param bool  $avoid_die   When true, a disallowed comment will result in the function\n *                           returning a WP_Error object, rather than executing wp_die().\n *                           Default false.\n * @return int|string|WP_Error Allowed comments return the approval status (0|1|'spam').\n *                             If `$avoid_die` is true, disallowed comments return a WP_Error.\n */\nfunction wp_allow_comment( $commentdata, $avoid_die = false ) {\n\tglobal $wpdb;\n\n\t// Simple duplicate check\n\t// expected_slashed ($comment_post_ID, $comment_author, $comment_author_email, $comment_content)\n\t$dupe = $wpdb->prepare(\n\t\t\"SELECT comment_ID FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_parent = %s AND comment_approved != 'trash' AND ( comment_author = %s \",\n\t\twp_unslash( $commentdata['comment_post_ID'] ),\n\t\twp_unslash( $commentdata['comment_parent'] ),\n\t\twp_unslash( $commentdata['comment_author'] )\n\t);\n\tif ( $commentdata['comment_author_email'] ) {\n\t\t$dupe .= $wpdb->prepare(\n\t\t\t'AND comment_author_email = %s ',\n\t\t\twp_unslash( $commentdata['comment_author_email'] )\n\t\t);\n\t}\n\t$dupe .= $wpdb->prepare(\n\t\t') AND comment_content = %s LIMIT 1',\n\t\twp_unslash( $commentdata['comment_content'] )\n\t);\n\n\t$dupe_id = $wpdb->get_var( $dupe );\n\n\t/**\n\t * Filters the ID, if any, of the duplicate comment found when creating a new comment.\n\t *\n\t * Return an empty value from this filter to allow what WP considers a duplicate comment.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param int   $dupe_id     ID of the comment identified as a duplicate.\n\t * @param array $commentdata Data for the comment being created.\n\t */\n\t$dupe_id = apply_filters( 'duplicate_comment_id', $dupe_id, $commentdata );\n\n\tif ( $dupe_id ) {\n\t\t/**\n\t\t * Fires immediately after a duplicate comment is detected.\n\t\t *\n\t\t * @since 3.0.0\n\t\t *\n\t\t * @param array $commentdata Comment data.\n\t\t */\n\t\tdo_action( 'comment_duplicate_trigger', $commentdata );\n\t\tif ( true === $avoid_die ) {\n\t\t\treturn new WP_Error( 'comment_duplicate', __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ), 409 );\n\t\t} else {\n\t\t\tif ( wp_doing_ajax() ) {\n\t\t\t\tdie( __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ) );\n\t\t\t}\n\n\t\t\twp_die( __( 'Duplicate comment detected; it looks as though you&#8217;ve already said that!' ), 409 );\n\t\t}\n\t}\n\n\t/**\n\t * Fires immediately before a comment is marked approved.\n\t *\n\t * Allows checking for comment flooding.\n\t *\n\t * @since 2.3.0\n\t * @since 4.7.0 The `$avoid_die` parameter was added.\n\t *\n\t * @param string $comment_author_IP    Comment author's IP address.\n\t * @param string $comment_author_email Comment author's email.\n\t * @param string $comment_date_gmt     GMT date the comment was posted.\n\t * @param bool   $avoid_die            Whether to prevent executing wp_die()\n\t *                                     or die() if a comment flood is occurring.\n\t */\n\tdo_action(\n\t\t'check_comment_flood',\n\t\t$commentdata['comment_author_IP'],\n\t\t$commentdata['comment_author_email'],\n\t\t$commentdata['comment_date_gmt'],\n\t\t$avoid_die\n\t);\n\n\t/**\n\t * Filters whether a comment is part of a comment flood.\n\t *\n\t * The default check is wp_check_comment_flood(). See check_comment_flood_db().\n\t *\n\t * @since 4.7.0\n\t *\n\t * @param bool   $is_flood             Is a comment flooding occurring? Default false.\n\t * @param string $comment_author_IP    Comment author's IP address.\n\t * @param string $comment_author_email Comment author's email.\n\t * @param string $comment_date_gmt     GMT date the comment was posted.\n\t * @param bool   $avoid_die            Whether to prevent executing wp_die()\n\t *                                     or die() if a comment flood is occurring.\n\t */\n\t$is_flood = apply_filters(\n\t\t'wp_is_comment_flood',\n\t\tfalse,\n\t\t$commentdata['comment_author_IP'],\n\t\t$commentdata['comment_author_email'],\n\t\t$commentdata['comment_date_gmt'],\n\t\t$avoid_die\n\t);\n\n\tif ( $is_flood ) {\n\t\treturn new WP_Error( 'comment_flood', __( 'You are posting comments too quickly. Slow down.' ), 429 );\n\t}\n\n\tif ( ! empty( $commentdata['user_id'] ) ) {\n\t\t$user        = get_userdata( $commentdata['user_id'] );\n\t\t$post_author = $wpdb->get_var(\n\t\t\t$wpdb->prepare(\n\t\t\t\t\"SELECT post_author FROM $wpdb->posts WHERE ID = %d LIMIT 1\",\n\t\t\t\t$commentdata['comment_post_ID']\n\t\t\t)\n\t\t);\n\t}\n\n\tif ( isset( $user ) && ( $commentdata['user_id'] == $post_author || $user->has_cap( 'moderate_comments' ) ) ) {\n\t\t// The author and the admins get respect.\n\t\t$approved = 1;\n\t} else {\n\t\t// Everyone else's comments will be checked.\n\t\tif ( check_comment(\n\t\t\t$commentdata['comment_author'],\n\t\t\t$commentdata['comment_author_email'],\n\t\t\t$commentdata['comment_author_url'],\n\t\t\t$commentdata['comment_content'],\n\t\t\t$commentdata['comment_author_IP'],\n\t\t\t$commentdata['comment_agent'],\n\t\t\t$commentdata['comment_type']\n\t\t) ) {\n\t\t\t$approved = 1;\n\t\t} else {\n\t\t\t$approved = 0;\n\t\t}\n\n\t\tif ( wp_blacklist_check(\n\t\t\t$commentdata['comment_author'],\n\t\t\t$commentdata['comment_author_email'],\n\t\t\t$commentdata['comment_author_url'],\n\t\t\t$commentdata['comment_content'],\n\t\t\t$commentdata['comment_author_IP'],\n\t\t\t$commentdata['comment_agent']\n\t\t) ) {\n\t\t\t$approved = EMPTY_TRASH_DAYS ? 'trash' : 'spam';\n\t\t}\n\t}\n\n\t/**\n\t * Filters a comment's approval status before it is set.\n\t *\n\t * @since 2.1.0\n\t * @since 4.9.0 Returning a WP_Error value from the filter will shortcircuit comment insertion and\n\t *              allow skipping further processing.\n\t *\n\t * @param bool|string|WP_Error $approved    The approval status. Accepts 1, 0, 'spam' or WP_Error.\n\t * @param array                $commentdata Comment data.\n\t */\n\t$approved = apply_filters( 'pre_comment_approved', $approved, $commentdata );\n\treturn $approved;\n}\n\n/**\n * Hooks WP's native database-based comment-flood check.\n *\n * This wrapper maintains backward compatibility with plugins that expect to\n * be able to unhook the legacy check_comment_flood_db() function from\n * 'check_comment_flood' using remove_action().\n *\n * @since 2.3.0\n * @since 4.7.0 Converted to be an add_filter() wrapper.\n */\nfunction check_comment_flood_db() {\n\tadd_filter( 'wp_is_comment_flood', 'wp_check_comment_flood', 10, 5 );\n}\n\n/**\n * Checks whether comment flooding is occurring.\n *\n * Won't run, if current user can manage options, so to not block\n * administrators.\n *\n * @since 4.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param bool   $is_flood  Is a comment flooding occurring?\n * @param string $ip        Comment author's IP address.\n * @param string $email     Comment author's email address.\n * @param string $date      MySQL time string.\n * @param bool   $avoid_die When true, a disallowed comment will result in the function\n *                          returning a WP_Error object, rather than executing wp_die().\n *                          Default false.\n * @return bool Whether comment flooding is occurring.\n */\nfunction wp_check_comment_flood( $is_flood, $ip, $email, $date, $avoid_die = false ) {\n\n\tglobal $wpdb;\n\n\t// Another callback has declared a flood. Trust it.\n\tif ( true === $is_flood ) {\n\t\treturn $is_flood;\n\t}\n\n\t// don't throttle admins or moderators\n\tif ( current_user_can( 'manage_options' ) || current_user_can( 'moderate_comments' ) ) {\n\t\treturn false;\n\t}\n\t$hour_ago = gmdate( 'Y-m-d H:i:s', time() - HOUR_IN_SECONDS );\n\n\tif ( is_user_logged_in() ) {\n\t\t$user         = get_current_user_id();\n\t\t$check_column = '`user_id`';\n\t} else {\n\t\t$user         = $ip;\n\t\t$check_column = '`comment_author_IP`';\n\t}\n\n\t$sql      = $wpdb->prepare(\n\t\t\"SELECT `comment_date_gmt` FROM `$wpdb->comments` WHERE `comment_date_gmt` >= %s AND ( $check_column = %s OR `comment_author_email` = %s ) ORDER BY `comment_date_gmt` DESC LIMIT 1\",\n\t\t$hour_ago,\n\t\t$user,\n\t\t$email\n\t);\n\t$lasttime = $wpdb->get_var( $sql );\n\tif ( $lasttime ) {\n\t\t$time_lastcomment = mysql2date( 'U', $lasttime, false );\n\t\t$time_newcomment  = mysql2date( 'U', $date, false );\n\t\t/**\n\t\t * Filters the comment flood status.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param bool $bool             Whether a comment flood is occurring. Default false.\n\t\t * @param int  $time_lastcomment Timestamp of when the last comment was posted.\n\t\t * @param int  $time_newcomment  Timestamp of when the new comment was posted.\n\t\t */\n\t\t$flood_die = apply_filters( 'comment_flood_filter', false, $time_lastcomment, $time_newcomment );\n\t\tif ( $flood_die ) {\n\t\t\t/**\n\t\t\t * Fires before the comment flood message is triggered.\n\t\t\t *\n\t\t\t * @since 1.5.0\n\t\t\t *\n\t\t\t * @param int $time_lastcomment Timestamp of when the last comment was posted.\n\t\t\t * @param int $time_newcomment  Timestamp of when the new comment was posted.\n\t\t\t */\n\t\t\tdo_action( 'comment_flood_trigger', $time_lastcomment, $time_newcomment );\n\t\t\tif ( true === $avoid_die ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif ( wp_doing_ajax() ) {\n\t\t\t\t\tdie( __( 'You are posting comments too quickly. Slow down.' ) );\n\t\t\t\t}\n\n\t\t\t\twp_die( __( 'You are posting comments too quickly. Slow down.' ), 429 );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Separates an array of comments into an array keyed by comment_type.\n *\n * @since 2.7.0\n *\n * @param WP_Comment[] $comments Array of comments\n * @return WP_Comment[] Array of comments keyed by comment_type.\n */\nfunction separate_comments( &$comments ) {\n\t$comments_by_type = array(\n\t\t'comment'   => array(),\n\t\t'trackback' => array(),\n\t\t'pingback'  => array(),\n\t\t'pings'     => array(),\n\t);\n\t$count            = count( $comments );\n\tfor ( $i = 0; $i < $count; $i++ ) {\n\t\t$type = $comments[ $i ]->comment_type;\n\t\tif ( empty( $type ) ) {\n\t\t\t$type = 'comment';\n\t\t}\n\t\t$comments_by_type[ $type ][] = &$comments[ $i ];\n\t\tif ( 'trackback' == $type || 'pingback' == $type ) {\n\t\t\t$comments_by_type['pings'][] = &$comments[ $i ];\n\t\t}\n\t}\n\n\treturn $comments_by_type;\n}\n\n/**\n * Calculate the total number of comment pages.\n *\n * @since 2.7.0\n *\n * @uses Walker_Comment\n *\n * @global WP_Query $wp_query\n *\n * @param WP_Comment[] $comments Optional. Array of WP_Comment objects. Defaults to $wp_query->comments.\n * @param int          $per_page Optional. Comments per page.\n * @param bool         $threaded Optional. Control over flat or threaded comments.\n * @return int Number of comment pages.\n */\nfunction get_comment_pages_count( $comments = null, $per_page = null, $threaded = null ) {\n\tglobal $wp_query;\n\n\tif ( null === $comments && null === $per_page && null === $threaded && ! empty( $wp_query->max_num_comment_pages ) ) {\n\t\treturn $wp_query->max_num_comment_pages;\n\t}\n\n\tif ( ( ! $comments || ! is_array( $comments ) ) && ! empty( $wp_query->comments ) ) {\n\t\t$comments = $wp_query->comments;\n\t}\n\n\tif ( empty( $comments ) ) {\n\t\treturn 0;\n\t}\n\n\tif ( ! get_option( 'page_comments' ) ) {\n\t\treturn 1;\n\t}\n\n\tif ( ! isset( $per_page ) ) {\n\t\t$per_page = (int) get_query_var( 'comments_per_page' );\n\t}\n\tif ( 0 === $per_page ) {\n\t\t$per_page = (int) get_option( 'comments_per_page' );\n\t}\n\tif ( 0 === $per_page ) {\n\t\treturn 1;\n\t}\n\n\tif ( ! isset( $threaded ) ) {\n\t\t$threaded = get_option( 'thread_comments' );\n\t}\n\n\tif ( $threaded ) {\n\t\t$walker = new Walker_Comment;\n\t\t$count  = ceil( $walker->get_number_of_root_elements( $comments ) / $per_page );\n\t} else {\n\t\t$count = ceil( count( $comments ) / $per_page );\n\t}\n\n\treturn $count;\n}\n\n/**\n * Calculate what page number a comment will appear on for comment paging.\n *\n * @since 2.7.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int   $comment_ID Comment ID.\n * @param array $args {\n *      Array of optional arguments.\n *      @type string     $type      Limit paginated comments to those matching a given type. Accepts 'comment',\n *                                  'trackback', 'pingback', 'pings' (trackbacks and pingbacks), or 'all'.\n *                                  Default is 'all'.\n *      @type int        $per_page  Per-page count to use when calculating pagination. Defaults to the value of the\n *                                  'comments_per_page' option.\n *      @type int|string $max_depth If greater than 1, comment page will be determined for the top-level parent of\n *                                  `$comment_ID`. Defaults to the value of the 'thread_comments_depth' option.\n * } *\n * @return int|null Comment page number or null on error.\n */\nfunction get_page_of_comment( $comment_ID, $args = array() ) {\n\tglobal $wpdb;\n\n\t$page = null;\n\n\tif ( ! $comment = get_comment( $comment_ID ) ) {\n\t\treturn;\n\t}\n\n\t$defaults      = array(\n\t\t'type'      => 'all',\n\t\t'page'      => '',\n\t\t'per_page'  => '',\n\t\t'max_depth' => '',\n\t);\n\t$args          = wp_parse_args( $args, $defaults );\n\t$original_args = $args;\n\n\t// Order of precedence: 1. `$args['per_page']`, 2. 'comments_per_page' query_var, 3. 'comments_per_page' option.\n\tif ( get_option( 'page_comments' ) ) {\n\t\tif ( '' === $args['per_page'] ) {\n\t\t\t$args['per_page'] = get_query_var( 'comments_per_page' );\n\t\t}\n\n\t\tif ( '' === $args['per_page'] ) {\n\t\t\t$args['per_page'] = get_option( 'comments_per_page' );\n\t\t}\n\t}\n\n\tif ( empty( $args['per_page'] ) ) {\n\t\t$args['per_page'] = 0;\n\t\t$args['page']     = 0;\n\t}\n\n\tif ( $args['per_page'] < 1 ) {\n\t\t$page = 1;\n\t}\n\n\tif ( null === $page ) {\n\t\tif ( '' === $args['max_depth'] ) {\n\t\t\tif ( get_option( 'thread_comments' ) ) {\n\t\t\t\t$args['max_depth'] = get_option( 'thread_comments_depth' );\n\t\t\t} else {\n\t\t\t\t$args['max_depth'] = -1;\n\t\t\t}\n\t\t}\n\n\t\t// Find this comment's top level parent if threading is enabled\n\t\tif ( $args['max_depth'] > 1 && 0 != $comment->comment_parent ) {\n\t\t\treturn get_page_of_comment( $comment->comment_parent, $args );\n\t\t}\n\n\t\t$comment_args = array(\n\t\t\t'type'       => $args['type'],\n\t\t\t'post_id'    => $comment->comment_post_ID,\n\t\t\t'fields'     => 'ids',\n\t\t\t'count'      => true,\n\t\t\t'status'     => 'approve',\n\t\t\t'parent'     => 0,\n\t\t\t'date_query' => array(\n\t\t\t\tarray(\n\t\t\t\t\t'column' => \"$wpdb->comments.comment_date_gmt\",\n\t\t\t\t\t'before' => $comment->comment_date_gmt,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\t$comment_query       = new WP_Comment_Query();\n\t\t$older_comment_count = $comment_query->query( $comment_args );\n\n\t\t// No older comments? Then it's page #1.\n\t\tif ( 0 == $older_comment_count ) {\n\t\t\t$page = 1;\n\n\t\t\t// Divide comments older than this one by comments per page to get this comment's page number\n\t\t} else {\n\t\t\t$page = ceil( ( $older_comment_count + 1 ) / $args['per_page'] );\n\t\t}\n\t}\n\n\t/**\n\t * Filters the calculated page on which a comment appears.\n\t *\n\t * @since 4.4.0\n\t * @since 4.7.0 Introduced the `$comment_ID` parameter.\n\t *\n\t * @param int   $page          Comment page.\n\t * @param array $args {\n\t *     Arguments used to calculate pagination. These include arguments auto-detected by the function,\n\t *     based on query vars, system settings, etc. For pristine arguments passed to the function,\n\t *     see `$original_args`.\n\t *\n\t *     @type string $type      Type of comments to count.\n\t *     @type int    $page      Calculated current page.\n\t *     @type int    $per_page  Calculated number of comments per page.\n\t *     @type int    $max_depth Maximum comment threading depth allowed.\n\t * }\n\t * @param array $original_args {\n\t *     Array of arguments passed to the function. Some or all of these may not be set.\n\t *\n\t *     @type string $type      Type of comments to count.\n\t *     @type int    $page      Current comment page.\n\t *     @type int    $per_page  Number of comments per page.\n\t *     @type int    $max_depth Maximum comment threading depth allowed.\n\t * }\n\t * @param int $comment_ID ID of the comment.\n\t */\n\treturn apply_filters( 'get_page_of_comment', (int) $page, $args, $original_args, $comment_ID );\n}\n\n/**\n * Retrieves the maximum character lengths for the comment form fields.\n *\n * @since 4.5.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @return array Maximum character length for the comment form fields.\n */\nfunction wp_get_comment_fields_max_lengths() {\n\tglobal $wpdb;\n\n\t$lengths = array(\n\t\t'comment_author'       => 245,\n\t\t'comment_author_email' => 100,\n\t\t'comment_author_url'   => 200,\n\t\t'comment_content'      => 65525,\n\t);\n\n\tif ( $wpdb->is_mysql ) {\n\t\tforeach ( $lengths as $column => $length ) {\n\t\t\t$col_length = $wpdb->get_col_length( $wpdb->comments, $column );\n\t\t\t$max_length = 0;\n\n\t\t\t// No point if we can't get the DB column lengths\n\t\t\tif ( is_wp_error( $col_length ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( ! is_array( $col_length ) && (int) $col_length > 0 ) {\n\t\t\t\t$max_length = (int) $col_length;\n\t\t\t} elseif ( is_array( $col_length ) && isset( $col_length['length'] ) && intval( $col_length['length'] ) > 0 ) {\n\t\t\t\t$max_length = (int) $col_length['length'];\n\n\t\t\t\tif ( ! empty( $col_length['type'] ) && 'byte' === $col_length['type'] ) {\n\t\t\t\t\t$max_length = $max_length - 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( $max_length > 0 ) {\n\t\t\t\t$lengths[ $column ] = $max_length;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filters the lengths for the comment form fields.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @param array $lengths Associative array `'field_name' => 'maximum length'`.\n\t */\n\treturn apply_filters( 'wp_get_comment_fields_max_lengths', $lengths );\n}\n\n/**\n * Compares the lengths of comment data against the maximum character limits.\n *\n * @since 4.7.0\n *\n * @param array $comment_data Array of arguments for inserting a comment.\n * @return WP_Error|true WP_Error when a comment field exceeds the limit,\n *                       otherwise true.\n */\nfunction wp_check_comment_data_max_lengths( $comment_data ) {\n\t$max_lengths = wp_get_comment_fields_max_lengths();\n\n\tif ( isset( $comment_data['comment_author'] ) && mb_strlen( $comment_data['comment_author'], '8bit' ) > $max_lengths['comment_author'] ) {\n\t\treturn new WP_Error( 'comment_author_column_length', __( '<strong>ERROR</strong>: your name is too long.' ), 200 );\n\t}\n\n\tif ( isset( $comment_data['comment_author_email'] ) && strlen( $comment_data['comment_author_email'] ) > $max_lengths['comment_author_email'] ) {\n\t\treturn new WP_Error( 'comment_author_email_column_length', __( '<strong>ERROR</strong>: your email address is too long.' ), 200 );\n\t}\n\n\tif ( isset( $comment_data['comment_author_url'] ) && strlen( $comment_data['comment_author_url'] ) > $max_lengths['comment_author_url'] ) {\n\t\treturn new WP_Error( 'comment_author_url_column_length', __( '<strong>ERROR</strong>: your url is too long.' ), 200 );\n\t}\n\n\tif ( isset( $comment_data['comment_content'] ) && mb_strlen( $comment_data['comment_content'], '8bit' ) > $max_lengths['comment_content'] ) {\n\t\treturn new WP_Error( 'comment_content_column_length', __( '<strong>ERROR</strong>: your comment is too long.' ), 200 );\n\t}\n\n\treturn true;\n}\n\n/**\n * Does comment contain blacklisted characters or words.\n *\n * @since 1.5.0\n *\n * @param string $author The author of the comment\n * @param string $email The email of the comment\n * @param string $url The url used in the comment\n * @param string $comment The comment content\n * @param string $user_ip The comment author's IP address\n * @param string $user_agent The author's browser user agent\n * @return bool True if comment contains blacklisted content, false if comment does not\n */\nfunction wp_blacklist_check( $author, $email, $url, $comment, $user_ip, $user_agent ) {\n\t/**\n\t * Fires before the comment is tested for blacklisted characters or words.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $author     Comment author.\n\t * @param string $email      Comment author's email.\n\t * @param string $url        Comment author's URL.\n\t * @param string $comment    Comment content.\n\t * @param string $user_ip    Comment author's IP address.\n\t * @param string $user_agent Comment author's browser user agent.\n\t */\n\tdo_action( 'wp_blacklist_check', $author, $email, $url, $comment, $user_ip, $user_agent );\n\n\t$mod_keys = trim( get_option( 'blacklist_keys' ) );\n\tif ( '' == $mod_keys ) {\n\t\treturn false; // If moderation keys are empty\n\t}\n\n\t// Ensure HTML tags are not being used to bypass the blacklist.\n\t$comment_without_html = wp_strip_all_tags( $comment );\n\n\t$words = explode( \"\\n\", $mod_keys );\n\n\tforeach ( (array) $words as $word ) {\n\t\t$word = trim( $word );\n\n\t\t// Skip empty lines\n\t\tif ( empty( $word ) ) {\n\t\t\tcontinue; }\n\n\t\t// Do some escaping magic so that '#' chars in the\n\t\t// spam words don't break things:\n\t\t$word = preg_quote( $word, '#' );\n\n\t\t$pattern = \"#$word#i\";\n\t\tif ( preg_match( $pattern, $author )\n\t\t\t|| preg_match( $pattern, $email )\n\t\t\t|| preg_match( $pattern, $url )\n\t\t\t|| preg_match( $pattern, $comment )\n\t\t\t|| preg_match( $pattern, $comment_without_html )\n\t\t\t|| preg_match( $pattern, $user_ip )\n\t\t\t|| preg_match( $pattern, $user_agent )\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Retrieve total comments for blog or single post.\n *\n * The properties of the returned object contain the 'moderated', 'approved',\n * and spam comments for either the entire blog or single post. Those properties\n * contain the amount of comments that match the status. The 'total_comments'\n * property contains the integer of total comments.\n *\n * The comment stats are cached and then retrieved, if they already exist in the\n * cache.\n *\n * @since 2.5.0\n *\n * @param int $post_id Optional. Post ID.\n * @return object|array Comment stats.\n */\nfunction wp_count_comments( $post_id = 0 ) {\n\t$post_id = (int) $post_id;\n\n\t/**\n\t * Filters the comments count for a given post.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param array $count   An empty array.\n\t * @param int   $post_id The post ID.\n\t */\n\t$filtered = apply_filters( 'wp_count_comments', array(), $post_id );\n\tif ( ! empty( $filtered ) ) {\n\t\treturn $filtered;\n\t}\n\n\t$count = wp_cache_get( \"comments-{$post_id}\", 'counts' );\n\tif ( false !== $count ) {\n\t\treturn $count;\n\t}\n\n\t$stats              = get_comment_count( $post_id );\n\t$stats['moderated'] = $stats['awaiting_moderation'];\n\tunset( $stats['awaiting_moderation'] );\n\n\t$stats_object = (object) $stats;\n\twp_cache_set( \"comments-{$post_id}\", $stats_object, 'counts' );\n\n\treturn $stats_object;\n}\n\n/**\n * Trashes or deletes a comment.\n *\n * The comment is moved to trash instead of permanently deleted unless trash is\n * disabled, item is already in the trash, or $force_delete is true.\n *\n * The post comment count will be updated if the comment was approved and has a\n * post ID available.\n *\n * @since 2.0.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int|WP_Comment $comment_id   Comment ID or WP_Comment object.\n * @param bool           $force_delete Whether to bypass trash and force deletion. Default is false.\n * @return bool True on success, false on failure.\n */\nfunction wp_delete_comment( $comment_id, $force_delete = false ) {\n\tglobal $wpdb;\n\tif ( ! $comment = get_comment( $comment_id ) ) {\n\t\treturn false;\n\t}\n\n\tif ( ! $force_delete && EMPTY_TRASH_DAYS && ! in_array( wp_get_comment_status( $comment ), array( 'trash', 'spam' ) ) ) {\n\t\treturn wp_trash_comment( $comment_id );\n\t}\n\n\t/**\n\t * Fires immediately before a comment is deleted from the database.\n\t *\n\t * @since 1.2.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be deleted.\n\t */\n\tdo_action( 'delete_comment', $comment->comment_ID, $comment );\n\n\t// Move children up a level.\n\t$children = $wpdb->get_col( $wpdb->prepare( \"SELECT comment_ID FROM $wpdb->comments WHERE comment_parent = %d\", $comment->comment_ID ) );\n\tif ( ! empty( $children ) ) {\n\t\t$wpdb->update( $wpdb->comments, array( 'comment_parent' => $comment->comment_parent ), array( 'comment_parent' => $comment->comment_ID ) );\n\t\tclean_comment_cache( $children );\n\t}\n\n\t// Delete metadata\n\t$meta_ids = $wpdb->get_col( $wpdb->prepare( \"SELECT meta_id FROM $wpdb->commentmeta WHERE comment_id = %d\", $comment->comment_ID ) );\n\tforeach ( $meta_ids as $mid ) {\n\t\tdelete_metadata_by_mid( 'comment', $mid );\n\t}\n\n\tif ( ! $wpdb->delete( $wpdb->comments, array( 'comment_ID' => $comment->comment_ID ) ) ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately after a comment is deleted from the database.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The deleted comment.\n\t */\n\tdo_action( 'deleted_comment', $comment->comment_ID, $comment );\n\n\t$post_id = $comment->comment_post_ID;\n\tif ( $post_id && $comment->comment_approved == 1 ) {\n\t\twp_update_comment_count( $post_id );\n\t}\n\n\tclean_comment_cache( $comment->comment_ID );\n\n\t/** This action is documented in wp-includes/comment.php */\n\tdo_action( 'wp_set_comment_status', $comment->comment_ID, 'delete' );\n\n\twp_transition_comment_status( 'delete', $comment->comment_approved, $comment );\n\treturn true;\n}\n\n/**\n * Moves a comment to the Trash\n *\n * If trash is disabled, comment is permanently deleted.\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_trash_comment( $comment_id ) {\n\tif ( ! EMPTY_TRASH_DAYS ) {\n\t\treturn wp_delete_comment( $comment_id, true );\n\t}\n\n\tif ( ! $comment = get_comment( $comment_id ) ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is sent to the Trash.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be trashed.\n\t */\n\tdo_action( 'trash_comment', $comment->comment_ID, $comment );\n\n\tif ( wp_set_comment_status( $comment, 'trash' ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', $comment->comment_approved );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_time', time() );\n\n\t\t/**\n\t\t * Fires immediately after a comment is sent to Trash.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The trashed comment.\n\t\t */\n\t\tdo_action( 'trashed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Removes a comment from the Trash\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_untrash_comment( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is restored from the Trash.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be untrashed.\n\t */\n\tdo_action( 'untrash_comment', $comment->comment_ID, $comment );\n\n\t$status = (string) get_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', true );\n\tif ( empty( $status ) ) {\n\t\t$status = '0';\n\t}\n\n\tif ( wp_set_comment_status( $comment, $status ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\t/**\n\t\t * Fires immediately after a comment is restored from the Trash.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The untrashed comment.\n\t\t */\n\t\tdo_action( 'untrashed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Marks a comment as Spam\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_spam_comment( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is marked as Spam.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be marked as spam.\n\t */\n\tdo_action( 'spam_comment', $comment->comment_ID, $comment );\n\n\tif ( wp_set_comment_status( $comment, 'spam' ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', $comment->comment_approved );\n\t\tadd_comment_meta( $comment->comment_ID, '_wp_trash_meta_time', time() );\n\t\t/**\n\t\t * Fires immediately after a comment is marked as Spam.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The comment marked as spam.\n\t\t */\n\t\tdo_action( 'spammed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * Removes a comment from the Spam\n *\n * @since 2.9.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object.\n * @return bool True on success, false on failure.\n */\nfunction wp_unspam_comment( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Fires immediately before a comment is unmarked as Spam.\n\t *\n\t * @since 2.9.0\n\t * @since 4.9.0 Added the `$comment` parameter.\n\t *\n\t * @param int        $comment_id The comment ID.\n\t * @param WP_Comment $comment    The comment to be unmarked as spam.\n\t */\n\tdo_action( 'unspam_comment', $comment->comment_ID, $comment );\n\n\t$status = (string) get_comment_meta( $comment->comment_ID, '_wp_trash_meta_status', true );\n\tif ( empty( $status ) ) {\n\t\t$status = '0';\n\t}\n\n\tif ( wp_set_comment_status( $comment, $status ) ) {\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_status' );\n\t\tdelete_comment_meta( $comment->comment_ID, '_wp_trash_meta_time' );\n\t\t/**\n\t\t * Fires immediately after a comment is unmarked as Spam.\n\t\t *\n\t\t * @since 2.9.0\n\t\t * @since 4.9.0 Added the `$comment` parameter.\n\t\t *\n\t\t * @param int        $comment_id The comment ID.\n\t\t * @param WP_Comment $comment    The comment unmarked as spam.\n\t\t */\n\t\tdo_action( 'unspammed_comment', $comment->comment_ID, $comment );\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * The status of a comment by ID.\n *\n * @since 1.0.0\n *\n * @param int|WP_Comment $comment_id Comment ID or WP_Comment object\n * @return false|string Status might be 'trash', 'approved', 'unapproved', 'spam'. False on failure.\n */\nfunction wp_get_comment_status( $comment_id ) {\n\t$comment = get_comment( $comment_id );\n\tif ( ! $comment ) {\n\t\treturn false;\n\t}\n\n\t$approved = $comment->comment_approved;\n\n\tif ( $approved == null ) {\n\t\treturn false;\n\t} elseif ( $approved == '1' ) {\n\t\treturn 'approved';\n\t} elseif ( $approved == '0' ) {\n\t\treturn 'unapproved';\n\t} elseif ( $approved == 'spam' ) {\n\t\treturn 'spam';\n\t} elseif ( $approved == 'trash' ) {\n\t\treturn 'trash';\n\t} else {\n\t\treturn false;\n\t}\n}\n\n/**\n * Call hooks for when a comment status transition occurs.\n *\n * Calls hooks for comment status transitions. If the new comment status is not the same\n * as the previous comment status, then two hooks will be ran, the first is\n * {@see 'transition_comment_status'} with new status, old status, and comment data. The\n * next action called is {@see comment_$old_status_to_$new_status'}. It has the\n * comment data.\n *\n * The final action will run whether or not the comment statuses are the same. The\n * action is named {@see 'comment_$new_status_$comment->comment_type'}.\n *\n * @since 2.7.0\n *\n * @param string $new_status New comment status.\n * @param string $old_status Previous comment status.\n * @param object $comment Comment data.\n */\nfunction wp_transition_comment_status( $new_status, $old_status, $comment ) {\n\t/*\n\t * Translate raw statuses to human readable formats for the hooks.\n\t * This is not a complete list of comment status, it's only the ones\n\t * that need to be renamed\n\t */\n\t$comment_statuses = array(\n\t\t0         => 'unapproved',\n\t\t'hold'    => 'unapproved', // wp_set_comment_status() uses \"hold\"\n\t\t1         => 'approved',\n\t\t'approve' => 'approved', // wp_set_comment_status() uses \"approve\"\n\t);\n\tif ( isset( $comment_statuses[ $new_status ] ) ) {\n\t\t$new_status = $comment_statuses[ $new_status ];\n\t}\n\tif ( isset( $comment_statuses[ $old_status ] ) ) {\n\t\t$old_status = $comment_statuses[ $old_status ];\n\t}\n\n\t// Call the hooks\n\tif ( $new_status != $old_status ) {\n\t\t/**\n\t\t * Fires when the comment status is in transition.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param int|string $new_status The new comment status.\n\t\t * @param int|string $old_status The old comment status.\n\t\t * @param object     $comment    The comment data.\n\t\t */\n\t\tdo_action( 'transition_comment_status', $new_status, $old_status, $comment );\n\t\t/**\n\t\t * Fires when the comment status is in transition from one specific status to another.\n\t\t *\n\t\t * The dynamic portions of the hook name, `$old_status`, and `$new_status`,\n\t\t * refer to the old and new comment statuses, respectively.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param WP_Comment $comment Comment object.\n\t\t */\n\t\tdo_action( \"comment_{$old_status}_to_{$new_status}\", $comment );\n\t}\n\t/**\n\t * Fires when the status of a specific comment type is in transition.\n\t *\n\t * The dynamic portions of the hook name, `$new_status`, and `$comment->comment_type`,\n\t * refer to the new comment status, and the type of comment, respectively.\n\t *\n\t * Typical comment types include an empty string (standard comment), 'pingback',\n\t * or 'trackback'.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @param int        $comment_ID The comment ID.\n\t * @param WP_Comment $comment    Comment object.\n\t */\n\tdo_action( \"comment_{$new_status}_{$comment->comment_type}\", $comment->comment_ID, $comment );\n}\n\n/**\n * Clear the lastcommentmodified cached value when a comment status is changed.\n *\n * Deletes the lastcommentmodified cache key when a comment enters or leaves\n * 'approved' status.\n *\n * @since 4.7.0\n * @access private\n *\n * @param string $new_status The new comment status.\n * @param string $old_status The old comment status.\n */\nfunction _clear_modified_cache_on_transition_comment_status( $new_status, $old_status ) {\n\tif ( 'approved' === $new_status || 'approved' === $old_status ) {\n\t\tforeach ( array( 'server', 'gmt', 'blog' ) as $timezone ) {\n\t\t\twp_cache_delete( \"lastcommentmodified:$timezone\", 'timeinfo' );\n\t\t}\n\t}\n}\n\n/**\n * Get current commenter's name, email, and URL.\n *\n * Expects cookies content to already be sanitized. User of this function might\n * wish to recheck the returned array for validity.\n *\n * @see sanitize_comment_cookies() Use to sanitize cookies\n *\n * @since 2.0.4\n *\n * @return array Comment author, email, url respectively.\n */\nfunction wp_get_current_commenter() {\n\t// Cookies should already be sanitized.\n\n\t$comment_author = '';\n\tif ( isset( $_COOKIE[ 'comment_author_' . COOKIEHASH ] ) ) {\n\t\t$comment_author = $_COOKIE[ 'comment_author_' . COOKIEHASH ];\n\t}\n\n\t$comment_author_email = '';\n\tif ( isset( $_COOKIE[ 'comment_author_email_' . COOKIEHASH ] ) ) {\n\t\t$comment_author_email = $_COOKIE[ 'comment_author_email_' . COOKIEHASH ];\n\t}\n\n\t$comment_author_url = '';\n\tif ( isset( $_COOKIE[ 'comment_author_url_' . COOKIEHASH ] ) ) {\n\t\t$comment_author_url = $_COOKIE[ 'comment_author_url_' . COOKIEHASH ];\n\t}\n\n\t/**\n\t * Filters the current commenter's name, email, and URL.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param array $comment_author_data {\n\t *     An array of current commenter variables.\n\t *\n\t *     @type string $comment_author       The name of the author of the comment. Default empty.\n\t *     @type string $comment_author_email The email address of the `$comment_author`. Default empty.\n\t *     @type string $comment_author_url   The URL address of the `$comment_author`. Default empty.\n\t * }\n\t */\n\treturn apply_filters( 'wp_get_current_commenter', compact( 'comment_author', 'comment_author_email', 'comment_author_url' ) );\n}\n\n/**\n * Get unapproved comment author's email.\n *\n * Used to allow the commenter to see their pending comment.\n *\n * @since 5.1.0\n *\n * @return string The unapproved comment author's email (when supplied).\n */\nfunction wp_get_unapproved_comment_author_email() {\n\t$commenter_email = '';\n\n\tif ( ! empty( $_GET['unapproved'] ) && ! empty( $_GET['moderation-hash'] ) ) {\n\t\t$comment_id = (int) $_GET['unapproved'];\n\t\t$comment    = get_comment( $comment_id );\n\n\t\tif ( $comment && hash_equals( $_GET['moderation-hash'], wp_hash( $comment->comment_date_gmt ) ) ) {\n\t\t\t$commenter_email = $comment->comment_author_email;\n\t\t}\n\t}\n\n\tif ( ! $commenter_email ) {\n\t\t$commenter       = wp_get_current_commenter();\n\t\t$commenter_email = $commenter['comment_author_email'];\n\t}\n\n\treturn $commenter_email;\n}\n\n/**\n * Inserts a comment into the database.\n *\n * @since 2.0.0\n * @since 4.4.0 Introduced `$comment_meta` argument.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentdata {\n *     Array of arguments for inserting a new comment.\n *\n *     @type string     $comment_agent        The HTTP user agent of the `$comment_author` when\n *                                            the comment was submitted. Default empty.\n *     @type int|string $comment_approved     Whether the comment has been approved. Default 1.\n *     @type string     $comment_author       The name of the author of the comment. Default empty.\n *     @type string     $comment_author_email The email address of the `$comment_author`. Default empty.\n *     @type string     $comment_author_IP    The IP address of the `$comment_author`. Default empty.\n *     @type string     $comment_author_url   The URL address of the `$comment_author`. Default empty.\n *     @type string     $comment_content      The content of the comment. Default empty.\n *     @type string     $comment_date         The date the comment was submitted. To set the date\n *                                            manually, `$comment_date_gmt` must also be specified.\n *                                            Default is the current time.\n *     @type string     $comment_date_gmt     The date the comment was submitted in the GMT timezone.\n *                                            Default is `$comment_date` in the site's GMT timezone.\n *     @type int        $comment_karma        The karma of the comment. Default 0.\n *     @type int        $comment_parent       ID of this comment's parent, if any. Default 0.\n *     @type int        $comment_post_ID      ID of the post that relates to the comment, if any.\n *                                            Default 0.\n *     @type string     $comment_type         Comment type. Default empty.\n *     @type array      $comment_meta         Optional. Array of key/value pairs to be stored in commentmeta for the\n *                                            new comment.\n *     @type int        $user_id              ID of the user who submitted the comment. Default 0.\n * }\n * @return int|false The new comment's ID on success, false on failure.\n */\nfunction wp_insert_comment( $commentdata ) {\n\tglobal $wpdb;\n\t$data = wp_unslash( $commentdata );\n\n\t$comment_author       = ! isset( $data['comment_author'] ) ? '' : $data['comment_author'];\n\t$comment_author_email = ! isset( $data['comment_author_email'] ) ? '' : $data['comment_author_email'];\n\t$comment_author_url   = ! isset( $data['comment_author_url'] ) ? '' : $data['comment_author_url'];\n\t$comment_author_IP    = ! isset( $data['comment_author_IP'] ) ? '' : $data['comment_author_IP'];\n\n\t$comment_date     = ! isset( $data['comment_date'] ) ? current_time( 'mysql' ) : $data['comment_date'];\n\t$comment_date_gmt = ! isset( $data['comment_date_gmt'] ) ? get_gmt_from_date( $comment_date ) : $data['comment_date_gmt'];\n\n\t$comment_post_ID  = ! isset( $data['comment_post_ID'] ) ? 0 : $data['comment_post_ID'];\n\t$comment_content  = ! isset( $data['comment_content'] ) ? '' : $data['comment_content'];\n\t$comment_karma    = ! isset( $data['comment_karma'] ) ? 0 : $data['comment_karma'];\n\t$comment_approved = ! isset( $data['comment_approved'] ) ? 1 : $data['comment_approved'];\n\t$comment_agent    = ! isset( $data['comment_agent'] ) ? '' : $data['comment_agent'];\n\t$comment_type     = ! isset( $data['comment_type'] ) ? '' : $data['comment_type'];\n\t$comment_parent   = ! isset( $data['comment_parent'] ) ? 0 : $data['comment_parent'];\n\n\t$user_id = ! isset( $data['user_id'] ) ? 0 : $data['user_id'];\n\n\t$compacted = compact( 'comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_author_IP', 'comment_date', 'comment_date_gmt', 'comment_content', 'comment_karma', 'comment_approved', 'comment_agent', 'comment_type', 'comment_parent', 'user_id' );\n\tif ( ! $wpdb->insert( $wpdb->comments, $compacted ) ) {\n\t\treturn false;\n\t}\n\n\t$id = (int) $wpdb->insert_id;\n\n\tif ( $comment_approved == 1 ) {\n\t\twp_update_comment_count( $comment_post_ID );\n\n\t\tforeach ( array( 'server', 'gmt', 'blog' ) as $timezone ) {\n\t\t\twp_cache_delete( \"lastcommentmodified:$timezone\", 'timeinfo' );\n\t\t}\n\t}\n\n\tclean_comment_cache( $id );\n\n\t$comment = get_comment( $id );\n\n\t// If metadata is provided, store it.\n\tif ( isset( $commentdata['comment_meta'] ) && is_array( $commentdata['comment_meta'] ) ) {\n\t\tforeach ( $commentdata['comment_meta'] as $meta_key => $meta_value ) {\n\t\t\tadd_comment_meta( $comment->comment_ID, $meta_key, $meta_value, true );\n\t\t}\n\t}\n\n\t/**\n\t * Fires immediately after a comment is inserted into the database.\n\t *\n\t * @since 2.8.0\n\t *\n\t * @param int        $id      The comment ID.\n\t * @param WP_Comment $comment Comment object.\n\t */\n\tdo_action( 'wp_insert_comment', $id, $comment );\n\n\treturn $id;\n}\n\n/**\n * Filters and sanitizes comment data.\n *\n * Sets the comment data 'filtered' field to true when finished. This can be\n * checked as to whether the comment should be filtered and to keep from\n * filtering the same comment more than once.\n *\n * @since 2.0.0\n *\n * @param array $commentdata Contains information on the comment.\n * @return array Parsed comment information.\n */\nfunction wp_filter_comment( $commentdata ) {\n\tif ( isset( $commentdata['user_ID'] ) ) {\n\t\t/**\n\t\t * Filters the comment author's user id before it is set.\n\t\t *\n\t\t * The first time this filter is evaluated, 'user_ID' is checked\n\t\t * (for back-compat), followed by the standard 'user_id' value.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param int $user_ID The comment author's user ID.\n\t\t */\n\t\t$commentdata['user_id'] = apply_filters( 'pre_user_id', $commentdata['user_ID'] );\n\t} elseif ( isset( $commentdata['user_id'] ) ) {\n\t\t/** This filter is documented in wp-includes/comment.php */\n\t\t$commentdata['user_id'] = apply_filters( 'pre_user_id', $commentdata['user_id'] );\n\t}\n\n\t/**\n\t * Filters the comment author's browser user agent before it is set.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_agent The comment author's browser user agent.\n\t */\n\t$commentdata['comment_agent'] = apply_filters( 'pre_comment_user_agent', ( isset( $commentdata['comment_agent'] ) ? $commentdata['comment_agent'] : '' ) );\n\t/** This filter is documented in wp-includes/comment.php */\n\t$commentdata['comment_author'] = apply_filters( 'pre_comment_author_name', $commentdata['comment_author'] );\n\t/**\n\t * Filters the comment content before it is set.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_content The comment content.\n\t */\n\t$commentdata['comment_content'] = apply_filters( 'pre_comment_content', $commentdata['comment_content'] );\n\t/**\n\t * Filters the comment author's IP address before it is set.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_author_ip The comment author's IP address.\n\t */\n\t$commentdata['comment_author_IP'] = apply_filters( 'pre_comment_user_ip', $commentdata['comment_author_IP'] );\n\t/** This filter is documented in wp-includes/comment.php */\n\t$commentdata['comment_author_url'] = apply_filters( 'pre_comment_author_url', $commentdata['comment_author_url'] );\n\t/** This filter is documented in wp-includes/comment.php */\n\t$commentdata['comment_author_email'] = apply_filters( 'pre_comment_author_email', $commentdata['comment_author_email'] );\n\t$commentdata['filtered']             = true;\n\treturn $commentdata;\n}\n\n/**\n * Whether a comment should be blocked because of comment flood.\n *\n * @since 2.1.0\n *\n * @param bool $block Whether plugin has already blocked comment.\n * @param int $time_lastcomment Timestamp for last comment.\n * @param int $time_newcomment Timestamp for new comment.\n * @return bool Whether comment should be blocked.\n */\nfunction wp_throttle_comment_flood( $block, $time_lastcomment, $time_newcomment ) {\n\tif ( $block ) { // a plugin has already blocked... we'll let that decision stand\n\t\treturn $block;\n\t}\n\tif ( ( $time_newcomment - $time_lastcomment ) < 15 ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Adds a new comment to the database.\n *\n * Filters new comment to ensure that the fields are sanitized and valid before\n * inserting comment into database. Calls {@see 'comment_post'} action with comment ID\n * and whether comment is approved by WordPress. Also has {@see 'preprocess_comment'}\n * filter for processing the comment data before the function handles it.\n *\n * We use `REMOTE_ADDR` here directly. If you are behind a proxy, you should ensure\n * that it is properly set, such as in wp-config.php, for your environment.\n *\n * See {@link https://core.trac.wordpress.org/ticket/9235}\n *\n * @since 1.5.0\n * @since 4.3.0 'comment_agent' and 'comment_author_IP' can be set via `$commentdata`.\n * @since 4.7.0 The `$avoid_die` parameter was added, allowing the function to\n *              return a WP_Error object instead of dying.\n *\n * @see wp_insert_comment()\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentdata {\n *     Comment data.\n *\n *     @type string $comment_author       The name of the comment author.\n *     @type string $comment_author_email The comment author email address.\n *     @type string $comment_author_url   The comment author URL.\n *     @type string $comment_content      The content of the comment.\n *     @type string $comment_date         The date the comment was submitted. Default is the current time.\n *     @type string $comment_date_gmt     The date the comment was submitted in the GMT timezone.\n *                                        Default is `$comment_date` in the GMT timezone.\n *     @type int    $comment_parent       The ID of this comment's parent, if any. Default 0.\n *     @type int    $comment_post_ID      The ID of the post that relates to the comment.\n *     @type int    $user_id              The ID of the user who submitted the comment. Default 0.\n *     @type int    $user_ID              Kept for backward-compatibility. Use `$user_id` instead.\n *     @type string $comment_agent        Comment author user agent. Default is the value of 'HTTP_USER_AGENT'\n *                                        in the `$_SERVER` superglobal sent in the original request.\n *     @type string $comment_author_IP    Comment author IP address in IPv4 format. Default is the value of\n *                                        'REMOTE_ADDR' in the `$_SERVER` superglobal sent in the original request.\n * }\n * @param bool $avoid_die Should errors be returned as WP_Error objects instead of\n *                        executing wp_die()? Default false.\n * @return int|false|WP_Error The ID of the comment on success, false or WP_Error on failure.\n */\nfunction wp_new_comment( $commentdata, $avoid_die = false ) {\n\tglobal $wpdb;\n\n\tif ( isset( $commentdata['user_ID'] ) ) {\n\t\t$commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];\n\t}\n\n\t$prefiltered_user_id = ( isset( $commentdata['user_id'] ) ) ? (int) $commentdata['user_id'] : 0;\n\n\t/**\n\t * Filters a comment's data before it is sanitized and inserted into the database.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param array $commentdata Comment data.\n\t */\n\t$commentdata = apply_filters( 'preprocess_comment', $commentdata );\n\n\t$commentdata['comment_post_ID'] = (int) $commentdata['comment_post_ID'];\n\tif ( isset( $commentdata['user_ID'] ) && $prefiltered_user_id !== (int) $commentdata['user_ID'] ) {\n\t\t$commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];\n\t} elseif ( isset( $commentdata['user_id'] ) ) {\n\t\t$commentdata['user_id'] = (int) $commentdata['user_id'];\n\t}\n\n\t$commentdata['comment_parent'] = isset( $commentdata['comment_parent'] ) ? absint( $commentdata['comment_parent'] ) : 0;\n\t$parent_status                 = ( 0 < $commentdata['comment_parent'] ) ? wp_get_comment_status( $commentdata['comment_parent'] ) : '';\n\t$commentdata['comment_parent'] = ( 'approved' == $parent_status || 'unapproved' == $parent_status ) ? $commentdata['comment_parent'] : 0;\n\n\tif ( ! isset( $commentdata['comment_author_IP'] ) ) {\n\t\t$commentdata['comment_author_IP'] = $_SERVER['REMOTE_ADDR'];\n\t}\n\t$commentdata['comment_author_IP'] = preg_replace( '/[^0-9a-fA-F:., ]/', '', $commentdata['comment_author_IP'] );\n\n\tif ( ! isset( $commentdata['comment_agent'] ) ) {\n\t\t$commentdata['comment_agent'] = isset( $_SERVER['HTTP_USER_AGENT'] ) ? $_SERVER['HTTP_USER_AGENT'] : '';\n\t}\n\t$commentdata['comment_agent'] = substr( $commentdata['comment_agent'], 0, 254 );\n\n\tif ( empty( $commentdata['comment_date'] ) ) {\n\t\t$commentdata['comment_date'] = current_time( 'mysql' );\n\t}\n\n\tif ( empty( $commentdata['comment_date_gmt'] ) ) {\n\t\t$commentdata['comment_date_gmt'] = current_time( 'mysql', 1 );\n\t}\n\n\t$commentdata = wp_filter_comment( $commentdata );\n\n\t$commentdata['comment_approved'] = wp_allow_comment( $commentdata, $avoid_die );\n\tif ( is_wp_error( $commentdata['comment_approved'] ) ) {\n\t\treturn $commentdata['comment_approved'];\n\t}\n\n\t$comment_ID = wp_insert_comment( $commentdata );\n\tif ( ! $comment_ID ) {\n\t\t$fields = array( 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_content' );\n\n\t\tforeach ( $fields as $field ) {\n\t\t\tif ( isset( $commentdata[ $field ] ) ) {\n\t\t\t\t$commentdata[ $field ] = $wpdb->strip_invalid_text_for_column( $wpdb->comments, $field, $commentdata[ $field ] );\n\t\t\t}\n\t\t}\n\n\t\t$commentdata = wp_filter_comment( $commentdata );\n\n\t\t$commentdata['comment_approved'] = wp_allow_comment( $commentdata, $avoid_die );\n\t\tif ( is_wp_error( $commentdata['comment_approved'] ) ) {\n\t\t\treturn $commentdata['comment_approved'];\n\t\t}\n\n\t\t$comment_ID = wp_insert_comment( $commentdata );\n\t\tif ( ! $comment_ID ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Fires immediately after a comment is inserted into the database.\n\t *\n\t * @since 1.2.0\n\t * @since 4.5.0 The `$commentdata` parameter was added.\n\t *\n\t * @param int        $comment_ID       The comment ID.\n\t * @param int|string $comment_approved 1 if the comment is approved, 0 if not, 'spam' if spam.\n\t * @param array      $commentdata      Comment data.\n\t */\n\tdo_action( 'comment_post', $comment_ID, $commentdata['comment_approved'], $commentdata );\n\n\treturn $comment_ID;\n}\n\n/**\n * Send a comment moderation notification to the comment moderator.\n *\n * @since 4.4.0\n *\n * @param int $comment_ID ID of the comment.\n * @return bool True on success, false on failure.\n */\nfunction wp_new_comment_notify_moderator( $comment_ID ) {\n\t$comment = get_comment( $comment_ID );\n\n\t// Only send notifications for pending comments.\n\t$maybe_notify = ( '0' == $comment->comment_approved );\n\n\t/** This filter is documented in wp-includes/comment.php */\n\t$maybe_notify = apply_filters( 'notify_moderator', $maybe_notify, $comment_ID );\n\n\tif ( ! $maybe_notify ) {\n\t\treturn false;\n\t}\n\n\treturn wp_notify_moderator( $comment_ID );\n}\n\n/**\n * Send a notification of a new comment to the post author.\n *\n * @since 4.4.0\n *\n * Uses the {@see 'notify_post_author'} filter to determine whether the post author\n * should be notified when a new comment is added, overriding site setting.\n *\n * @param int $comment_ID Comment ID.\n * @return bool True on success, false on failure.\n */\nfunction wp_new_comment_notify_postauthor( $comment_ID ) {\n\t$comment = get_comment( $comment_ID );\n\n\t$maybe_notify = get_option( 'comments_notify' );\n\n\t/**\n\t * Filters whether to send the post author new comment notification emails,\n\t * overriding the site setting.\n\t *\n\t * @since 4.4.0\n\t *\n\t * @param bool $maybe_notify Whether to notify the post author about the new comment.\n\t * @param int  $comment_ID   The ID of the comment for the notification.\n\t */\n\t$maybe_notify = apply_filters( 'notify_post_author', $maybe_notify, $comment_ID );\n\n\t/*\n\t * wp_notify_postauthor() checks if notifying the author of their own comment.\n\t * By default, it won't, but filters can override this.\n\t */\n\tif ( ! $maybe_notify ) {\n\t\treturn false;\n\t}\n\n\t// Only send notifications for approved comments.\n\tif ( ! isset( $comment->comment_approved ) || '1' != $comment->comment_approved ) {\n\t\treturn false;\n\t}\n\n\treturn wp_notify_postauthor( $comment_ID );\n}\n\n/**\n * Sets the status of a comment.\n *\n * The {@see 'wp_set_comment_status'} action is called after the comment is handled.\n * If the comment status is not in the list, then false is returned.\n *\n * @since 1.0.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int|WP_Comment $comment_id     Comment ID or WP_Comment object.\n * @param string         $comment_status New comment status, either 'hold', 'approve', 'spam', or 'trash'.\n * @param bool           $wp_error       Whether to return a WP_Error object if there is a failure. Default is false.\n * @return bool|WP_Error True on success, false or WP_Error on failure.\n */\nfunction wp_set_comment_status( $comment_id, $comment_status, $wp_error = false ) {\n\tglobal $wpdb;\n\n\tswitch ( $comment_status ) {\n\t\tcase 'hold':\n\t\tcase '0':\n\t\t\t$status = '0';\n\t\t\tbreak;\n\t\tcase 'approve':\n\t\tcase '1':\n\t\t\t$status = '1';\n\t\t\tadd_action( 'wp_set_comment_status', 'wp_new_comment_notify_postauthor' );\n\t\t\tbreak;\n\t\tcase 'spam':\n\t\t\t$status = 'spam';\n\t\t\tbreak;\n\t\tcase 'trash':\n\t\t\t$status = 'trash';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\t$comment_old = clone get_comment( $comment_id );\n\n\tif ( ! $wpdb->update( $wpdb->comments, array( 'comment_approved' => $status ), array( 'comment_ID' => $comment_old->comment_ID ) ) ) {\n\t\tif ( $wp_error ) {\n\t\t\treturn new WP_Error( 'db_update_error', __( 'Could not update comment status' ), $wpdb->last_error );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tclean_comment_cache( $comment_old->comment_ID );\n\n\t$comment = get_comment( $comment_old->comment_ID );\n\n\t/**\n\t * Fires immediately before transitioning a comment's status from one to another\n\t * in the database.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param int         $comment_id     Comment ID.\n\t * @param string|bool $comment_status Current comment status. Possible values include\n\t *                                    'hold', 'approve', 'spam', 'trash', or false.\n\t */\n\tdo_action( 'wp_set_comment_status', $comment->comment_ID, $comment_status );\n\n\twp_transition_comment_status( $comment_status, $comment_old->comment_approved, $comment );\n\n\twp_update_comment_count( $comment->comment_post_ID );\n\n\treturn true;\n}\n\n/**\n * Updates an existing comment in the database.\n *\n * Filters the comment and makes sure certain fields are valid before updating.\n *\n * @since 2.0.0\n * @since 4.9.0 Add updating comment meta during comment update.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param array $commentarr Contains information on the comment.\n * @return int Comment was updated if value is 1, or was not updated if value is 0.\n */\nfunction wp_update_comment( $commentarr ) {\n\tglobal $wpdb;\n\n\t// First, get all of the original fields\n\t$comment = get_comment( $commentarr['comment_ID'], ARRAY_A );\n\tif ( empty( $comment ) ) {\n\t\treturn 0;\n\t}\n\n\t// Make sure that the comment post ID is valid (if specified).\n\tif ( ! empty( $commentarr['comment_post_ID'] ) && ! get_post( $commentarr['comment_post_ID'] ) ) {\n\t\treturn 0;\n\t}\n\n\t// Escape data pulled from DB.\n\t$comment = wp_slash( $comment );\n\n\t$old_status = $comment['comment_approved'];\n\n\t// Merge old and new fields with new fields overwriting old ones.\n\t$commentarr = array_merge( $comment, $commentarr );\n\n\t$commentarr = wp_filter_comment( $commentarr );\n\n\t// Now extract the merged array.\n\t$data = wp_unslash( $commentarr );\n\n\t/**\n\t * Filters the comment content before it is updated in the database.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $comment_content The comment data.\n\t */\n\t$data['comment_content'] = apply_filters( 'comment_save_pre', $data['comment_content'] );\n\n\t$data['comment_date_gmt'] = get_gmt_from_date( $data['comment_date'] );\n\n\tif ( ! isset( $data['comment_approved'] ) ) {\n\t\t$data['comment_approved'] = 1;\n\t} elseif ( 'hold' == $data['comment_approved'] ) {\n\t\t$data['comment_approved'] = 0;\n\t} elseif ( 'approve' == $data['comment_approved'] ) {\n\t\t$data['comment_approved'] = 1;\n\t}\n\n\t$comment_ID      = $data['comment_ID'];\n\t$comment_post_ID = $data['comment_post_ID'];\n\n\t/**\n\t * Filters the comment data immediately before it is updated in the database.\n\t *\n\t * Note: data being passed to the filter is already unslashed.\n\t *\n\t * @since 4.7.0\n\t *\n\t * @param array $data       The new, processed comment data.\n\t * @param array $comment    The old, unslashed comment data.\n\t * @param array $commentarr The new, raw comment data.\n\t */\n\t$data = apply_filters( 'wp_update_comment_data', $data, $comment, $commentarr );\n\n\t$keys = array( 'comment_post_ID', 'comment_content', 'comment_author', 'comment_author_email', 'comment_approved', 'comment_karma', 'comment_author_url', 'comment_date', 'comment_date_gmt', 'comment_type', 'comment_parent', 'user_id', 'comment_agent', 'comment_author_IP' );\n\t$data = wp_array_slice_assoc( $data, $keys );\n\n\t$rval = $wpdb->update( $wpdb->comments, $data, compact( 'comment_ID' ) );\n\n\t// If metadata is provided, store it.\n\tif ( isset( $commentarr['comment_meta'] ) && is_array( $commentarr['comment_meta'] ) ) {\n\t\tforeach ( $commentarr['comment_meta'] as $meta_key => $meta_value ) {\n\t\t\tupdate_comment_meta( $comment_ID, $meta_key, $meta_value );\n\t\t}\n\t}\n\n\tclean_comment_cache( $comment_ID );\n\twp_update_comment_count( $comment_post_ID );\n\t/**\n\t * Fires immediately after a comment is updated in the database.\n\t *\n\t * The hook also fires immediately before comment status transition hooks are fired.\n\t *\n\t * @since 1.2.0\n\t * @since 4.6.0 Added the `$data` parameter.\n\t *\n\t * @param int   $comment_ID The comment ID.\n\t * @param array $data       Comment data.\n\t */\n\tdo_action( 'edit_comment', $comment_ID, $data );\n\t$comment = get_comment( $comment_ID );\n\twp_transition_comment_status( $comment->comment_approved, $old_status, $comment );\n\treturn $rval;\n}\n\n/**\n * Whether to defer comment counting.\n *\n * When setting $defer to true, all post comment counts will not be updated\n * until $defer is set to false. When $defer is set to false, then all\n * previously deferred updated post comment counts will then be automatically\n * updated without having to call wp_update_comment_count() after.\n *\n * @since 2.5.0\n * @staticvar bool $_defer\n *\n * @param bool $defer\n * @return bool\n */\nfunction wp_defer_comment_counting( $defer = null ) {\n\tstatic $_defer = false;\n\n\tif ( is_bool( $defer ) ) {\n\t\t$_defer = $defer;\n\t\t// flush any deferred counts\n\t\tif ( ! $defer ) {\n\t\t\twp_update_comment_count( null, true );\n\t\t}\n\t}\n\n\treturn $_defer;\n}\n\n/**\n * Updates the comment count for post(s).\n *\n * When $do_deferred is false (is by default) and the comments have been set to\n * be deferred, the post_id will be added to a queue, which will be updated at a\n * later date and only updated once per post ID.\n *\n * If the comments have not be set up to be deferred, then the post will be\n * updated. When $do_deferred is set to true, then all previous deferred post\n * IDs will be updated along with the current $post_id.\n *\n * @since 2.1.0\n * @see wp_update_comment_count_now() For what could cause a false return value\n *\n * @staticvar array $_deferred\n *\n * @param int|null $post_id     Post ID.\n * @param bool     $do_deferred Optional. Whether to process previously deferred\n *                              post comment counts. Default false.\n * @return bool|void True on success, false on failure or if post with ID does\n *                   not exist.\n */\nfunction wp_update_comment_count( $post_id, $do_deferred = false ) {\n\tstatic $_deferred = array();\n\n\tif ( empty( $post_id ) && ! $do_deferred ) {\n\t\treturn false;\n\t}\n\n\tif ( $do_deferred ) {\n\t\t$_deferred = array_unique( $_deferred );\n\t\tforeach ( $_deferred as $i => $_post_id ) {\n\t\t\twp_update_comment_count_now( $_post_id );\n\t\t\tunset( $_deferred[ $i ] );\n\t\t\t/** @todo Move this outside of the foreach and reset $_deferred to an array instead */\n\t\t}\n\t}\n\n\tif ( wp_defer_comment_counting() ) {\n\t\t$_deferred[] = $post_id;\n\t\treturn true;\n\t} elseif ( $post_id ) {\n\t\treturn wp_update_comment_count_now( $post_id );\n\t}\n\n}\n\n/**\n * Updates the comment count for the post.\n *\n * @since 2.5.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int $post_id Post ID\n * @return bool True on success, false on '0' $post_id or if post with ID does not exist.\n */\nfunction wp_update_comment_count_now( $post_id ) {\n\tglobal $wpdb;\n\t$post_id = (int) $post_id;\n\tif ( ! $post_id ) {\n\t\treturn false;\n\t}\n\n\twp_cache_delete( 'comments-0', 'counts' );\n\twp_cache_delete( \"comments-{$post_id}\", 'counts' );\n\n\tif ( ! $post = get_post( $post_id ) ) {\n\t\treturn false;\n\t}\n\n\t$old = (int) $post->comment_count;\n\n\t/**\n\t * Filters a post's comment count before it is updated in the database.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @param int $new     The new comment count. Default null.\n\t * @param int $old     The old comment count.\n\t * @param int $post_id Post ID.\n\t */\n\t$new = apply_filters( 'pre_wp_update_comment_count_now', null, $old, $post_id );\n\n\tif ( is_null( $new ) ) {\n\t\t$new = (int) $wpdb->get_var( $wpdb->prepare( \"SELECT COUNT(*) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1'\", $post_id ) );\n\t} else {\n\t\t$new = (int) $new;\n\t}\n\n\t$wpdb->update( $wpdb->posts, array( 'comment_count' => $new ), array( 'ID' => $post_id ) );\n\n\tclean_post_cache( $post );\n\n\t/**\n\t * Fires immediately after a post's comment count is updated in the database.\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param int $post_id Post ID.\n\t * @param int $new     The new comment count.\n\t * @param int $old     The old comment count.\n\t */\n\tdo_action( 'wp_update_comment_count', $post_id, $new, $old );\n\n\t/** This action is documented in wp-includes/post.php */\n\tdo_action( \"edit_post_{$post->post_type}\", $post_id, $post );\n\n\t/** This action is documented in wp-includes/post.php */\n\tdo_action( 'edit_post', $post_id, $post );\n\n\treturn true;\n}\n\n//\n// Ping and trackback functions.\n//\n\n/**\n * Finds a pingback server URI based on the given URL.\n *\n * Checks the HTML for the rel=\"pingback\" link and x-pingback headers. It does\n * a check for the x-pingback headers first and returns that, if available. The\n * check for the rel=\"pingback\" has more overhead than just the header.\n *\n * @since 1.5.0\n *\n * @param string $url URL to ping.\n * @param int $deprecated Not Used.\n * @return false|string False on failure, string containing URI on success.\n */\nfunction discover_pingback_server_uri( $url, $deprecated = '' ) {\n\tif ( ! empty( $deprecated ) ) {\n\t\t_deprecated_argument( __FUNCTION__, '2.7.0' );\n\t}\n\n\t$pingback_str_dquote = 'rel=\"pingback\"';\n\t$pingback_str_squote = 'rel=\\'pingback\\'';\n\n\t/** @todo Should use Filter Extension or custom preg_match instead. */\n\t$parsed_url = parse_url( $url );\n\n\tif ( ! isset( $parsed_url['host'] ) ) { // Not a URL. This should never happen.\n\t\treturn false;\n\t}\n\n\t//Do not search for a pingback server on our own uploads\n\t$uploads_dir = wp_get_upload_dir();\n\tif ( 0 === strpos( $url, $uploads_dir['baseurl'] ) ) {\n\t\treturn false;\n\t}\n\n\t$response = wp_safe_remote_head(\n\t\t$url,\n\t\tarray(\n\t\t\t'timeout'     => 2,\n\t\t\t'httpversion' => '1.0',\n\t\t)\n\t);\n\n\tif ( is_wp_error( $response ) ) {\n\t\treturn false;\n\t}\n\n\tif ( wp_remote_retrieve_header( $response, 'x-pingback' ) ) {\n\t\treturn wp_remote_retrieve_header( $response, 'x-pingback' );\n\t}\n\n\t// Not an (x)html, sgml, or xml page, no use going further.\n\tif ( preg_match( '#(image|audio|video|model)/#is', wp_remote_retrieve_header( $response, 'content-type' ) ) ) {\n\t\treturn false;\n\t}\n\n\t// Now do a GET since we're going to look in the html headers (and we're sure it's not a binary file)\n\t$response = wp_safe_remote_get(\n\t\t$url,\n\t\tarray(\n\t\t\t'timeout'     => 2,\n\t\t\t'httpversion' => '1.0',\n\t\t)\n\t);\n\n\tif ( is_wp_error( $response ) ) {\n\t\treturn false;\n\t}\n\n\t$contents = wp_remote_retrieve_body( $response );\n\n\t$pingback_link_offset_dquote = strpos( $contents, $pingback_str_dquote );\n\t$pingback_link_offset_squote = strpos( $contents, $pingback_str_squote );\n\tif ( $pingback_link_offset_dquote || $pingback_link_offset_squote ) {\n\t\t$quote                   = ( $pingback_link_offset_dquote ) ? '\"' : '\\'';\n\t\t$pingback_link_offset    = ( $quote == '\"' ) ? $pingback_link_offset_dquote : $pingback_link_offset_squote;\n\t\t$pingback_href_pos       = @strpos( $contents, 'href=', $pingback_link_offset );\n\t\t$pingback_href_start     = $pingback_href_pos + 6;\n\t\t$pingback_href_end       = @strpos( $contents, $quote, $pingback_href_start );\n\t\t$pingback_server_url_len = $pingback_href_end - $pingback_href_start;\n\t\t$pingback_server_url     = substr( $contents, $pingback_href_start, $pingback_server_url_len );\n\n\t\t// We may find rel=\"pingback\" but an incomplete pingback URL\n\t\tif ( $pingback_server_url_len > 0 ) { // We got it!\n\t\t\treturn $pingback_server_url;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Perform all pingbacks, enclosures, trackbacks, and send to pingback services.\n *\n * @since 2.1.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n */\nfunction do_all_pings() {\n\tglobal $wpdb;\n\n\t// Do pingbacks\n\twhile ( $ping = $wpdb->get_row( \"SELECT ID, post_content, meta_id FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_pingme' LIMIT 1\" ) ) {\n\t\tdelete_metadata_by_mid( 'post', $ping->meta_id );\n\t\tpingback( $ping->post_content, $ping->ID );\n\t}\n\n\t// Do Enclosures\n\twhile ( $enclosure = $wpdb->get_row( \"SELECT ID, post_content, meta_id FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_encloseme' LIMIT 1\" ) ) {\n\t\tdelete_metadata_by_mid( 'post', $enclosure->meta_id );\n\t\tdo_enclose( $enclosure->post_content, $enclosure->ID );\n\t}\n\n\t// Do Trackbacks\n\t$trackbacks = $wpdb->get_col( \"SELECT ID FROM $wpdb->posts WHERE to_ping <> '' AND post_status = 'publish'\" );\n\tif ( is_array( $trackbacks ) ) {\n\t\tforeach ( $trackbacks as $trackback ) {\n\t\t\tdo_trackbacks( $trackback );\n\t\t}\n\t}\n\n\t//Do Update Services/Generic Pings\n\tgeneric_ping();\n}\n\n/**\n * Perform trackbacks.\n *\n * @since 1.5.0\n * @since 4.7.0 `$post_id` can be a WP_Post object.\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int|WP_Post $post_id Post object or ID to do trackbacks on.\n */\nfunction do_trackbacks( $post_id ) {\n\tglobal $wpdb;\n\t$post = get_post( $post_id );\n\tif ( ! $post ) {\n\t\treturn false;\n\t}\n\n\t$to_ping = get_to_ping( $post );\n\t$pinged  = get_pung( $post );\n\tif ( empty( $to_ping ) ) {\n\t\t$wpdb->update( $wpdb->posts, array( 'to_ping' => '' ), array( 'ID' => $post->ID ) );\n\t\treturn;\n\t}\n\n\tif ( empty( $post->post_excerpt ) ) {\n\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t$excerpt = apply_filters( 'the_content', $post->post_content, $post->ID );\n\t} else {\n\t\t/** This filter is documented in wp-includes/post-template.php */\n\t\t$excerpt = apply_filters( 'the_excerpt', $post->post_excerpt );\n\t}\n\n\t$excerpt = str_replace( ']]>', ']]&gt;', $excerpt );\n\t$excerpt = wp_html_excerpt( $excerpt, 252, '&#8230;' );\n\n\t/** This filter is documented in wp-includes/post-template.php */\n\t$post_title = apply_filters( 'the_title', $post->post_title, $post->ID );\n\t$post_title = strip_tags( $post_title );\n\n\tif ( $to_ping ) {\n\t\tforeach ( (array) $to_ping as $tb_ping ) {\n\t\t\t$tb_ping = trim( $tb_ping );\n\t\t\tif ( ! in_array( $tb_ping, $pinged ) ) {\n\t\t\t\ttrackback( $tb_ping, $post_title, $excerpt, $post->ID );\n\t\t\t\t$pinged[] = $tb_ping;\n\t\t\t} else {\n\t\t\t\t$wpdb->query(\n\t\t\t\t\t$wpdb->prepare(\n\t\t\t\t\t\t\"UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, %s,\n\t\t\t\t\t'')) WHERE ID = %d\",\n\t\t\t\t\t\t$tb_ping,\n\t\t\t\t\t\t$post->ID\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Sends pings to all of the ping site services.\n *\n * @since 1.2.0\n *\n * @param int $post_id Post ID.\n * @return int Same as Post ID from parameter\n */\nfunction generic_ping( $post_id = 0 ) {\n\t$services = get_option( 'ping_sites' );\n\n\t$services = explode( \"\\n\", $services );\n\tforeach ( (array) $services as $service ) {\n\t\t$service = trim( $service );\n\t\tif ( '' != $service ) {\n\t\t\tweblog_ping( $service );\n\t\t}\n\t}\n\n\treturn $post_id;\n}\n\n/**\n * Pings back the links found in a post.\n *\n * @since 0.71\n * @since 4.7.0 `$post_id` can be a WP_Post object.\n *\n * @param string $content Post content to check for links. If empty will retrieve from post.\n * @param int|WP_Post $post_id Post Object or ID.\n */\nfunction pingback( $content, $post_id ) {\n\tinclude_once( ABSPATH . WPINC . '/class-IXR.php' );\n\tinclude_once( ABSPATH . WPINC . '/class-wp-http-ixr-client.php' );\n\n\t// original code by Mort (http://mort.mine.nu:8080)\n\t$post_links = array();\n\n\t$post = get_post( $post_id );\n\tif ( ! $post ) {\n\t\treturn;\n\t}\n\n\t$pung = get_pung( $post );\n\n\tif ( empty( $content ) ) {\n\t\t$content = $post->post_content;\n\t}\n\n\t// Step 1\n\t// Parsing the post, external links (if any) are stored in the $post_links array\n\t$post_links_temp = wp_extract_urls( $content );\n\n\t// Step 2.\n\t// Walking thru the links array\n\t// first we get rid of links pointing to sites, not to specific files\n\t// Example:\n\t// http://dummy-weblog.org\n\t// http://dummy-weblog.org/\n\t// http://dummy-weblog.org/post.php\n\t// We don't wanna ping first and second types, even if they have a valid <link/>\n\n\tforeach ( (array) $post_links_temp as $link_test ) :\n\t\tif ( ! in_array( $link_test, $pung ) && ( url_to_postid( $link_test ) != $post->ID ) // If we haven't pung it already and it isn't a link to itself\n\t\t\t\t&& ! is_local_attachment( $link_test ) ) : // Also, let's never ping local attachments.\n\t\t\tif ( $test = @parse_url( $link_test ) ) {\n\t\t\t\tif ( isset( $test['query'] ) ) {\n\t\t\t\t\t$post_links[] = $link_test;\n\t\t\t\t} elseif ( isset( $test['path'] ) && ( $test['path'] != '/' ) && ( $test['path'] != '' ) ) {\n\t\t\t\t\t$post_links[] = $link_test;\n\t\t\t\t}\n\t\t\t}\n\t\tendif;\n\tendforeach;\n\n\t$post_links = array_unique( $post_links );\n\t/**\n\t * Fires just before pinging back links found in a post.\n\t *\n\t * @since 2.0.0\n\t *\n\t * @param string[] $post_links Array of link URLs to be checked (passed by reference).\n\t * @param string[] $pung       Array of link URLs already pinged (passed by reference).\n\t * @param int      $post_ID    The post ID.\n\t */\n\tdo_action_ref_array( 'pre_ping', array( &$post_links, &$pung, $post->ID ) );\n\n\tforeach ( (array) $post_links as $pagelinkedto ) {\n\t\t$pingback_server_url = discover_pingback_server_uri( $pagelinkedto );\n\n\t\tif ( $pingback_server_url ) {\n\t\t\t@ set_time_limit( 60 );\n\t\t\t// Now, the RPC call\n\t\t\t$pagelinkedfrom = get_permalink( $post );\n\n\t\t\t// using a timeout of 3 seconds should be enough to cover slow servers\n\t\t\t$client          = new WP_HTTP_IXR_Client( $pingback_server_url );\n\t\t\t$client->timeout = 3;\n\t\t\t/**\n\t\t\t * Filters the user agent sent when pinging-back a URL.\n\t\t\t *\n\t\t\t * @since 2.9.0\n\t\t\t *\n\t\t\t * @param string $concat_useragent    The user agent concatenated with ' -- WordPress/'\n\t\t\t *                                    and the WordPress version.\n\t\t\t * @param string $useragent           The useragent.\n\t\t\t * @param string $pingback_server_url The server URL being linked to.\n\t\t\t * @param string $pagelinkedto        URL of page linked to.\n\t\t\t * @param string $pagelinkedfrom      URL of page linked from.\n\t\t\t */\n\t\t\t$client->useragent = apply_filters( 'pingback_useragent', $client->useragent . ' -- WordPress/' . get_bloginfo( 'version' ), $client->useragent, $pingback_server_url, $pagelinkedto, $pagelinkedfrom );\n\t\t\t// when set to true, this outputs debug messages by itself\n\t\t\t$client->debug = false;\n\n\t\t\tif ( $client->query( 'pingback.ping', $pagelinkedfrom, $pagelinkedto ) || ( isset( $client->error->code ) && 48 == $client->error->code ) ) { // Already registered\n\t\t\t\tadd_ping( $post, $pagelinkedto );\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Check whether blog is public before returning sites.\n *\n * @since 2.1.0\n *\n * @param mixed $sites Will return if blog is public, will not return if not public.\n * @return mixed Empty string if blog is not public, returns $sites, if site is public.\n */\nfunction privacy_ping_filter( $sites ) {\n\tif ( '0' != get_option( 'blog_public' ) ) {\n\t\treturn $sites;\n\t} else {\n\t\treturn '';\n\t}\n}\n\n/**\n * Send a Trackback.\n *\n * Updates database when sending trackback to prevent duplicates.\n *\n * @since 0.71\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param string $trackback_url URL to send trackbacks.\n * @param string $title Title of post.\n * @param string $excerpt Excerpt of post.\n * @param int $ID Post ID.\n * @return int|false|void Database query from update.\n */\nfunction trackback( $trackback_url, $title, $excerpt, $ID ) {\n\tglobal $wpdb;\n\n\tif ( empty( $trackback_url ) ) {\n\t\treturn;\n\t}\n\n\t$options            = array();\n\t$options['timeout'] = 10;\n\t$options['body']    = array(\n\t\t'title'     => $title,\n\t\t'url'       => get_permalink( $ID ),\n\t\t'blog_name' => get_option( 'blogname' ),\n\t\t'excerpt'   => $excerpt,\n\t);\n\n\t$response = wp_safe_remote_post( $trackback_url, $options );\n\n\tif ( is_wp_error( $response ) ) {\n\t\treturn;\n\t}\n\n\t$wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->posts SET pinged = CONCAT(pinged, '\\n', %s) WHERE ID = %d\", $trackback_url, $ID ) );\n\treturn $wpdb->query( $wpdb->prepare( \"UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, %s, '')) WHERE ID = %d\", $trackback_url, $ID ) );\n}\n\n/**\n * Send a pingback.\n *\n * @since 1.2.0\n *\n * @param string $server Host of blog to connect to.\n * @param string $path Path to send the ping.\n */\nfunction weblog_ping( $server = '', $path = '' ) {\n\tinclude_once( ABSPATH . WPINC . '/class-IXR.php' );\n\tinclude_once( ABSPATH . WPINC . '/class-wp-http-ixr-client.php' );\n\n\t// using a timeout of 3 seconds should be enough to cover slow servers\n\t$client             = new WP_HTTP_IXR_Client( $server, ( ( ! strlen( trim( $path ) ) || ( '/' == $path ) ) ? false : $path ) );\n\t$client->timeout    = 3;\n\t$client->useragent .= ' -- WordPress/' . get_bloginfo( 'version' );\n\n\t// when set to true, this outputs debug messages by itself\n\t$client->debug = false;\n\t$home          = trailingslashit( home_url() );\n\tif ( ! $client->query( 'weblogUpdates.extendedPing', get_option( 'blogname' ), $home, get_bloginfo( 'rss2_url' ) ) ) { // then try a normal ping\n\t\t$client->query( 'weblogUpdates.ping', get_option( 'blogname' ), $home );\n\t}\n}\n\n/**\n * Default filter attached to pingback_ping_source_uri to validate the pingback's Source URI\n *\n * @since 3.5.1\n * @see wp_http_validate_url()\n *\n * @param string $source_uri\n * @return string\n */\nfunction pingback_ping_source_uri( $source_uri ) {\n\treturn (string) wp_http_validate_url( $source_uri );\n}\n\n/**\n * Default filter attached to xmlrpc_pingback_error.\n *\n * Returns a generic pingback error code unless the error code is 48,\n * which reports that the pingback is already registered.\n *\n * @since 3.5.1\n * @link https://www.hixie.ch/specs/pingback/pingback#TOC3\n *\n * @param IXR_Error $ixr_error\n * @return IXR_Error\n */\nfunction xmlrpc_pingback_error( $ixr_error ) {\n\tif ( $ixr_error->code === 48 ) {\n\t\treturn $ixr_error;\n\t}\n\treturn new IXR_Error( 0, '' );\n}\n\n//\n// Cache\n//\n\n/**\n * Removes a comment from the object cache.\n *\n * @since 2.3.0\n *\n * @param int|array $ids Comment ID or an array of comment IDs to remove from cache.\n */\nfunction clean_comment_cache( $ids ) {\n\tforeach ( (array) $ids as $id ) {\n\t\twp_cache_delete( $id, 'comment' );\n\n\t\t/**\n\t\t * Fires immediately after a comment has been removed from the object cache.\n\t\t *\n\t\t * @since 4.5.0\n\t\t *\n\t\t * @param int $id Comment ID.\n\t\t */\n\t\tdo_action( 'clean_comment_cache', $id );\n\t}\n\n\twp_cache_set( 'last_changed', microtime(), 'comment' );\n}\n\n/**\n * Updates the comment cache of given comments.\n *\n * Will add the comments in $comments to the cache. If comment ID already exists\n * in the comment cache then it will not be updated. The comment is added to the\n * cache using the comment group with the key using the ID of the comments.\n *\n * @since 2.3.0\n * @since 4.4.0 Introduced the `$update_meta_cache` parameter.\n *\n * @param WP_Comment[] $comments          Array of comment objects\n * @param bool         $update_meta_cache Whether to update commentmeta cache. Default true.\n */\nfunction update_comment_cache( $comments, $update_meta_cache = true ) {\n\tforeach ( (array) $comments as $comment ) {\n\t\twp_cache_add( $comment->comment_ID, $comment, 'comment' );\n\t}\n\n\tif ( $update_meta_cache ) {\n\t\t// Avoid `wp_list_pluck()` in case `$comments` is passed by reference.\n\t\t$comment_ids = array();\n\t\tforeach ( $comments as $comment ) {\n\t\t\t$comment_ids[] = $comment->comment_ID;\n\t\t}\n\t\tupdate_meta_cache( 'comment', $comment_ids );\n\t}\n}\n\n/**\n * Adds any comments from the given IDs to the cache that do not already exist in cache.\n *\n * @since 4.4.0\n * @access private\n *\n * @see update_comment_cache()\n * @global wpdb $wpdb WordPress database abstraction object.\n *\n * @param int[] $comment_ids       Array of comment IDs.\n * @param bool  $update_meta_cache Optional. Whether to update the meta cache. Default true.\n */\nfunction _prime_comment_caches( $comment_ids, $update_meta_cache = true ) {\n\tglobal $wpdb;\n\n\t$non_cached_ids = _get_non_cached_ids( $comment_ids, 'comment' );\n\tif ( ! empty( $non_cached_ids ) ) {\n\t\t$fresh_comments = $wpdb->get_results( sprintf( \"SELECT $wpdb->comments.* FROM $wpdb->comments WHERE comment_ID IN (%s)\", join( ',', array_map( 'intval', $non_cached_ids ) ) ) );\n\n\t\tupdate_comment_cache( $fresh_comments, $update_meta_cache );\n\t}\n}\n\n//\n// Internal\n//\n\n/**\n * Close comments on old posts on the fly, without any extra DB queries. Hooked to the_posts.\n *\n * @access private\n * @since 2.7.0\n *\n * @param WP_Post  $posts Post data object.\n * @param WP_Query $query Query object.\n * @return array\n */\nfunction _close_comments_for_old_posts( $posts, $query ) {\n\tif ( empty( $posts ) || ! $query->is_singular() || ! get_option( 'close_comments_for_old_posts' ) ) {\n\t\treturn $posts;\n\t}\n\n\t/**\n\t * Filters the list of post types to automatically close comments for.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @param string[] $post_types An array of post type names.\n\t */\n\t$post_types = apply_filters( 'close_comments_for_post_types', array( 'post' ) );\n\tif ( ! in_array( $posts[0]->post_type, $post_types ) ) {\n\t\treturn $posts;\n\t}\n\n\t$days_old = (int) get_option( 'close_comments_days_old' );\n\tif ( ! $days_old ) {\n\t\treturn $posts;\n\t}\n\n\tif ( time() - strtotime( $posts[0]->post_date_gmt ) > ( $days_old * DAY_IN_SECONDS ) ) {\n\t\t$posts[0]->comment_status = 'closed';\n\t\t$posts[0]->ping_status    = 'closed';\n\t}\n\n\treturn $posts;\n}\n\n/**\n * Close comments on an old post. Hooked to comments_open and pings_open.\n *\n * @access private\n * @since 2.7.0\n *\n * @param bool $open Comments open or closed\n * @param int $post_id Post ID\n * @return bool $open\n */\nfunction _close_comments_for_old_post( $open, $post_id ) {\n\tif ( ! $open ) {\n\t\treturn $open;\n\t}\n\n\tif ( ! get_option( 'close_comments_for_old_posts' ) ) {\n\t\treturn $open;\n\t}\n\n\t$days_old = (int) get_option( 'close_comments_days_old' );\n\tif ( ! $days_old ) {\n\t\treturn $open;\n\t}\n\n\t$post = get_post( $post_id );\n\n\t/** This filter is documented in wp-includes/comment.php */\n\t$post_types = apply_filters( 'close_comments_for_post_types', array( 'post' ) );\n\tif ( ! in_array( $post->post_type, $post_types ) ) {\n\t\treturn $open;\n\t}\n\n\t// Undated drafts should not show up as comments closed.\n\tif ( '0000-00-00 00:00:00' === $post->post_date_gmt ) {\n\t\treturn $open;\n\t}\n\n\tif ( time() - strtotime( $post->post_date_gmt ) > ( $days_old * DAY_IN_SECONDS ) ) {\n\t\treturn false;\n\t}\n\n\treturn $open;\n}\n\n/**\n * Handles the submission of a comment, usually posted to wp-comments-post.php via a comment form.\n *\n * This function expects unslashed data, as opposed to functions such as `wp_new_comment()` which\n * expect slashed data.\n *\n * @since 4.4.0\n *\n * @param array $comment_data {\n *     Comment data.\n *\n *     @type string|int $comment_post_ID             The ID of the post that relates to the comment.\n *     @type string     $author                      The name of the comment author.\n *     @type string     $email                       The comment author email address.\n *     @type string     $url                         The comment author URL.\n *     @type string     $comment                     The content of the comment.\n *     @type string|int $comment_parent              The ID of this comment's parent, if any. Default 0.\n *     @type string     $_wp_unfiltered_html_comment The nonce value for allowing unfiltered HTML.\n * }\n * @return WP_Comment|WP_Error A WP_Comment object on success, a WP_Error object on failure.\n */\nfunction wp_handle_comment_submission( $comment_data ) {\n\n\t$comment_post_ID = $comment_parent = $user_ID = 0;\n\t$comment_author  = $comment_author_email = $comment_author_url = $comment_content = null;\n\n\tif ( isset( $comment_data['comment_post_ID'] ) ) {\n\t\t$comment_post_ID = (int) $comment_data['comment_post_ID'];\n\t}\n\tif ( isset( $comment_data['author'] ) && is_string( $comment_data['author'] ) ) {\n\t\t$comment_author = trim( strip_tags( $comment_data['author'] ) );\n\t}\n\tif ( isset( $comment_data['email'] ) && is_string( $comment_data['email'] ) ) {\n\t\t$comment_author_email = trim( $comment_data['email'] );\n\t}\n\tif ( isset( $comment_data['url'] ) && is_string( $comment_data['url'] ) ) {\n\t\t$comment_author_url = trim( $comment_data['url'] );\n\t}\n\tif ( isset( $comment_data['comment'] ) && is_string( $comment_data['comment'] ) ) {\n\t\t$comment_content = trim( $comment_data['comment'] );\n\t}\n\tif ( isset( $comment_data['comment_parent'] ) ) {\n\t\t$comment_parent = absint( $comment_data['comment_parent'] );\n\t}\n\n\t$post = get_post( $comment_post_ID );\n\n\tif ( empty( $post->comment_status ) ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a post that does not exist.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_id_not_found', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_id_not_found' );\n\n\t}\n\n\t// get_post_status() will get the parent status for attachments.\n\t$status = get_post_status( $post );\n\n\tif ( ( 'private' == $status ) && ! current_user_can( 'read_post', $comment_post_ID ) ) {\n\t\treturn new WP_Error( 'comment_id_not_found' );\n\t}\n\n\t$status_obj = get_post_status_object( $status );\n\n\tif ( ! comments_open( $comment_post_ID ) ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a post that has comments closed.\n\t\t *\n\t\t * @since 1.5.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_closed', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_closed', __( 'Sorry, comments are closed for this item.' ), 403 );\n\n\t} elseif ( 'trash' == $status ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a trashed post.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_on_trash', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_on_trash' );\n\n\t} elseif ( ! $status_obj->public && ! $status_obj->private ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a post in draft mode.\n\t\t *\n\t\t * @since 1.5.1\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_on_draft', $comment_post_ID );\n\n\t\tif ( current_user_can( 'read_post', $comment_post_ID ) ) {\n\t\t\treturn new WP_Error( 'comment_on_draft', __( 'Sorry, comments are not allowed for this item.' ), 403 );\n\t\t} else {\n\t\t\treturn new WP_Error( 'comment_on_draft' );\n\t\t}\n\t} elseif ( post_password_required( $comment_post_ID ) ) {\n\n\t\t/**\n\t\t * Fires when a comment is attempted on a password-protected post.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'comment_on_password_protected', $comment_post_ID );\n\n\t\treturn new WP_Error( 'comment_on_password_protected' );\n\n\t} else {\n\n\t\t/**\n\t\t * Fires before a comment is posted.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param int $comment_post_ID Post ID.\n\t\t */\n\t\tdo_action( 'pre_comment_on_post', $comment_post_ID );\n\n\t}\n\n\t// If the user is logged in\n\t$user = wp_get_current_user();\n\tif ( $user->exists() ) {\n\t\tif ( empty( $user->display_name ) ) {\n\t\t\t$user->display_name = $user->user_login;\n\t\t}\n\t\t$comment_author       = $user->display_name;\n\t\t$comment_author_email = $user->user_email;\n\t\t$comment_author_url   = $user->user_url;\n\t\t$user_ID              = $user->ID;\n\t\tif ( current_user_can( 'unfiltered_html' ) ) {\n\t\t\tif ( ! isset( $comment_data['_wp_unfiltered_html_comment'] )\n\t\t\t\t|| ! wp_verify_nonce( $comment_data['_wp_unfiltered_html_comment'], 'unfiltered-html-comment_' . $comment_post_ID )\n\t\t\t) {\n\t\t\t\tkses_remove_filters(); // start with a clean slate\n\t\t\t\tkses_init_filters(); // set up the filters\n\t\t\t\tremove_filter( 'pre_comment_content', 'wp_filter_post_kses' );\n\t\t\t\tadd_filter( 'pre_comment_content', 'wp_filter_kses' );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ( get_option( 'comment_registration' ) ) {\n\t\t\treturn new WP_Error( 'not_logged_in', __( 'Sorry, you must be logged in to comment.' ), 403 );\n\t\t}\n\t}\n\n\t$comment_type = '';\n\n\tif ( get_option( 'require_name_email' ) && ! $user->exists() ) {\n\t\tif ( '' == $comment_author_email || '' == $comment_author ) {\n\t\t\treturn new WP_Error( 'require_name_email', __( '<strong>ERROR</strong>: please fill the required fields (name, email).' ), 200 );\n\t\t} elseif ( ! is_email( $comment_author_email ) ) {\n\t\t\treturn new WP_Error( 'require_valid_email', __( '<strong>ERROR</strong>: please enter a valid email address.' ), 200 );\n\t\t}\n\t}\n\n\t$commentdata = compact(\n\t\t'comment_post_ID',\n\t\t'comment_author',\n\t\t'comment_author_email',\n\t\t'comment_author_url',\n\t\t'comment_content',\n\t\t'comment_type',\n\t\t'comment_parent',\n\t\t'user_ID'\n\t);\n\n\t/**\n\t * Filters whether an empty comment should be allowed.\n\t *\n\t * @since 5.1.0\n\t *\n\t * @param bool  $allow_empty_comment Whether to allow empty comments. Default false.\n\t * @param array $commentdata         Array of comment data to be sent to wp_insert_comment().\n\t */\n\t$allow_empty_comment = apply_filters( 'allow_empty_comment', false, $commentdata );\n\tif ( '' === $comment_content && ! $allow_empty_comment ) {\n\t\treturn new WP_Error( 'require_valid_comment', __( '<strong>ERROR</strong>: please type a comment.' ), 200 );\n\t}\n\n\t$check_max_lengths = wp_check_comment_data_max_lengths( $commentdata );\n\tif ( is_wp_error( $check_max_lengths ) ) {\n\t\treturn $check_max_lengths;\n\t}\n\n\t$comment_id = wp_new_comment( wp_slash( $commentdata ), true );\n\tif ( is_wp_error( $comment_id ) ) {\n\t\treturn $comment_id;\n\t}\n\n\tif ( ! $comment_id ) {\n\t\treturn new WP_Error( 'comment_save_error', __( '<strong>ERROR</strong>: The comment could not be saved. Please try again later.' ), 500 );\n\t}\n\n\treturn get_comment( $comment_id );\n}\n\n/**\n * Registers the personal data exporter for comments.\n *\n * @since 4.9.6\n *\n * @param array $exporters An array of personal data exporters.\n * @return array $exporters An array of personal data exporters.\n */\nfunction wp_register_comment_personal_data_exporter( $exporters ) {\n\t$exporters['wordpress-comments'] = array(\n\t\t'exporter_friendly_name' => __( 'WordPress Comments' ),\n\t\t'callback'               => 'wp_comments_personal_data_exporter',\n\t);\n\n\treturn $exporters;\n}\n\n/**\n * Finds and exports personal data associated with an email address from the comments table.\n *\n * @since 4.9.6\n *\n * @param string $email_address The comment author email address.\n * @param int    $page          Comment page.\n * @return array $return An array of personal data.\n */\nfunction wp_comments_personal_data_exporter( $email_address, $page = 1 ) {\n\t// Limit us to 500 comments at a time to avoid timing out.\n\t$number = 500;\n\t$page   = (int) $page;\n\n\t$data_to_export = array();\n\n\t$comments = get_comments(\n\t\tarray(\n\t\t\t'author_email'              => $email_address,\n\t\t\t'number'                    => $number,\n\t\t\t'paged'                     => $page,\n\t\t\t'order_by'                  => 'comment_ID',\n\t\t\t'order'                     => 'ASC',\n\t\t\t'update_comment_meta_cache' => false,\n\t\t)\n\t);\n\n\t$comment_prop_to_export = array(\n\t\t'comment_author'       => __( 'Comment Author' ),\n\t\t'comment_author_email' => __( 'Comment Author Email' ),\n\t\t'comment_author_url'   => __( 'Comment Author URL' ),\n\t\t'comment_author_IP'    => __( 'Comment Author IP' ),\n\t\t'comment_agent'        => __( 'Comment Author User Agent' ),\n\t\t'comment_date'         => __( 'Comment Date' ),\n\t\t'comment_content'      => __( 'Comment Content' ),\n\t\t'comment_link'         => __( 'Comment URL' ),\n\t);\n\n\tforeach ( (array) $comments as $comment ) {\n\t\t$comment_data_to_export = array();\n\n\t\tforeach ( $comment_prop_to_export as $key => $name ) {\n\t\t\t$value = '';\n\n\t\t\tswitch ( $key ) {\n\t\t\t\tcase 'comment_author':\n\t\t\t\tcase 'comment_author_email':\n\t\t\t\tcase 'comment_author_url':\n\t\t\t\tcase 'comment_author_IP':\n\t\t\t\tcase 'comment_agent':\n\t\t\t\tcase 'comment_date':\n\t\t\t\t\t$value = $comment->{$key};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'comment_content':\n\t\t\t\t\t$value = get_comment_text( $comment->comment_ID );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'comment_link':\n\t\t\t\t\t$value = get_comment_link( $comment->comment_ID );\n\t\t\t\t\t$value = sprintf(\n\t\t\t\t\t\t'<a href=\"%s\" target=\"_blank\" rel=\"noreferrer noopener\">%s</a>',\n\t\t\t\t\t\tesc_url( $value ),\n\t\t\t\t\t\tesc_html( $value )\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( ! empty( $value ) ) {\n\t\t\t\t$comment_data_to_export[] = array(\n\t\t\t\t\t'name'  => $name,\n\t\t\t\t\t'value' => $value,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t$data_to_export[] = array(\n\t\t\t'group_id'    => 'comments',\n\t\t\t'group_label' => __( 'Comments' ),\n\t\t\t'item_id'     => \"comment-{$comment->comment_ID}\",\n\t\t\t'data'        => $comment_data_to_export,\n\t\t);\n\t}\n\n\t$done = count( $comments ) < $number;\n\n\treturn array(\n\t\t'data' => $data_to_export,\n\t\t'done' => $done,\n\t);\n}\n\n/**\n * Registers the personal data eraser for comments.\n *\n * @since 4.9.6\n *\n * @param  array $erasers An array of personal data erasers.\n * @return array $erasers An array of personal data erasers.\n */\nfunction wp_register_comment_personal_data_eraser( $erasers ) {\n\t$erasers['wordpress-comments'] = array(\n\t\t'eraser_friendly_name' => __( 'WordPress Comments' ),\n\t\t'callback'             => 'wp_comments_personal_data_eraser',\n\t);\n\n\treturn $erasers;\n}\n\n/**\n * Erases personal data associated with an email address from the comments table.\n *\n * @since 4.9.6\n *\n * @param  string $email_address The comment author email address.\n * @param  int    $page          Comment page.\n * @return array\n */\nfunction wp_comments_personal_data_eraser( $email_address, $page = 1 ) {\n\tglobal $wpdb;\n\n\tif ( empty( $email_address ) ) {\n\t\treturn array(\n\t\t\t'items_removed'  => false,\n\t\t\t'items_retained' => false,\n\t\t\t'messages'       => array(),\n\t\t\t'done'           => true,\n\t\t);\n\t}\n\n\t// Limit us to 500 comments at a time to avoid timing out.\n\t$number         = 500;\n\t$page           = (int) $page;\n\t$items_removed  = false;\n\t$items_retained = false;\n\n\t$comments = get_comments(\n\t\tarray(\n\t\t\t'author_email'       => $email_address,\n\t\t\t'number'             => $number,\n\t\t\t'paged'              => $page,\n\t\t\t'order_by'           => 'comment_ID',\n\t\t\t'order'              => 'ASC',\n\t\t\t'include_unapproved' => true,\n\t\t)\n\t);\n\n\t/* translators: Name of a comment's author after being anonymized. */\n\t$anon_author = __( 'Anonymous' );\n\t$messages    = array();\n\n\tforeach ( (array) $comments as $comment ) {\n\t\t$anonymized_comment                         = array();\n\t\t$anonymized_comment['comment_agent']        = '';\n\t\t$anonymized_comment['comment_author']       = $anon_author;\n\t\t$anonymized_comment['comment_author_email'] = '';\n\t\t$anonymized_comment['comment_author_IP']    = wp_privacy_anonymize_data( 'ip', $comment->comment_author_IP );\n\t\t$anonymized_comment['comment_author_url']   = '';\n\t\t$anonymized_comment['user_id']              = 0;\n\n\t\t$comment_id = (int) $comment->comment_ID;\n\n\t\t/**\n\t\t * Filters whether to anonymize the comment.\n\t\t *\n\t\t * @since 4.9.6\n\t\t *\n\t\t * @param bool|string                    Whether to apply the comment anonymization (bool).\n\t\t *                                       Custom prevention message (string). Default true.\n\t\t * @param WP_Comment $comment            WP_Comment object.\n\t\t * @param array      $anonymized_comment Anonymized comment data.\n\t\t */\n\t\t$anon_message = apply_filters( 'wp_anonymize_comment', true, $comment, $anonymized_comment );\n\n\t\tif ( true !== $anon_message ) {\n\t\t\tif ( $anon_message && is_string( $anon_message ) ) {\n\t\t\t\t$messages[] = esc_html( $anon_message );\n\t\t\t} else {\n\t\t\t\t/* translators: %d: Comment ID */\n\t\t\t\t$messages[] = sprintf( __( 'Comment %d contains personal data but could not be anonymized.' ), $comment_id );\n\t\t\t}\n\n\t\t\t$items_retained = true;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t$args = array(\n\t\t\t'comment_ID' => $comment_id,\n\t\t);\n\n\t\t$updated = $wpdb->update( $wpdb->comments, $anonymized_comment, $args );\n\n\t\tif ( $updated ) {\n\t\t\t$items_removed = true;\n\t\t\tclean_comment_cache( $comment_id );\n\t\t} else {\n\t\t\t$items_retained = true;\n\t\t}\n\t}\n\n\t$done = count( $comments ) < $number;\n\n\treturn array(\n\t\t'items_removed'  => $items_removed,\n\t\t'items_retained' => $items_retained,\n\t\t'messages'       => $messages,\n\t\t'done'           => $done,\n\t);\n}\n\n/**\n * Sets the last changed time for the 'comment' cache group.\n *\n * @since 5.0.0\n */\nfunction wp_cache_set_comments_last_changed() {\n\twp_cache_set( 'last_changed', microtime(), 'comment' );\n}\n", "<?php\n/**\n * WordPress Version\n *\n * Contains version information for the current WordPress release.\n *\n * @package WordPress\n * @since 1.1.0\n */\n\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.2-alpha-44842';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 44719;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4920-20181217';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-admin/includes/ajax-actions.php", "wp-includes/comment.php", "wp-includes/version.php"], "buggy_code_start_loc": [1216, 3245, 16], "buggy_code_end_loc": [1216, 3245, 17], "fixing_code_start_loc": [1217, 3246, 16], "fixing_code_end_loc": [1219, 3248, 17], "type": "CWE-352", "message": "WordPress before 5.1.1 does not properly filter comment content, leading to Remote Code Execution by unauthenticated users in a default configuration. This occurs because CSRF protection is mishandled, and because Search Engine Optimization of A elements is performed incorrectly, leading to XSS. The XSS results in administrative access, which allows arbitrary changes to .php files. This is related to wp-admin/includes/ajax-actions.php and wp-includes/comment.php.", "other": {"cve": {"id": "CVE-2019-9787", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-14T16:29:00.337", "lastModified": "2019-03-31T22:29:00.497", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "WordPress before 5.1.1 does not properly filter comment content, leading to Remote Code Execution by unauthenticated users in a default configuration. This occurs because CSRF protection is mishandled, and because Search Engine Optimization of A elements is performed incorrectly, leading to XSS. The XSS results in administrative access, which allows arbitrary changes to .php files. This is related to wp-admin/includes/ajax-actions.php and wp-includes/comment.php."}, {"lang": "es", "value": "WordPress, en versiones anteriores a la 5.1.1, no filtra correctamente el contenido, lo que conduce a la ejecuci\u00f3n remota de c\u00f3digo por parte de usuarios no autenticados en una configuraci\u00f3n por defecto. Esto ocurre debido a que la protecci\u00f3n CSRF se gestiona de manera incorrecta y porque la optimizaci\u00f3n del motor de b\u00fasqueda de los elementos A se realiza incorrectamente, lo que desemboca en Cross-Site Scripting (XSS). El XSS resulta en un acceso administrativo, lo que permite cambios arbitrarios en archivos .php. Esto est\u00e1 relacionado con wp-admin/includes/ajax-actions.php y wp-includes/comment.php."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.1.1", "matchCriteriaId": "58A14BF4-1BA8-4758-9703-829F85F4D04C"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/107411", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blog.ripstech.com/2019/wordpress-csrf-to-rce/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/0292de60ec78c5a44956765189403654fe4d080b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00044.html", "source": "cve@mitre.org"}, {"url": "https://wordpress.org/news/2019/03/wordpress-5-1-1-security-and-maintenance-release/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://wordpress.org/support/wordpress-version/version-5-1-1/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/9230", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4677", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/0292de60ec78c5a44956765189403654fe4d080b"}}