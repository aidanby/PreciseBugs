{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\ntemplate <typename T, typename Treal>\nclass SparseAddOp : public OpKernel {\n public:\n  explicit SparseAddOp(OpKernelConstruction *ctx) : OpKernel(ctx) {}\n\n  void Compute(OpKernelContext *ctx) override {\n    // (0) validations\n    const Tensor *a_indices, *b_indices, *a_values_t, *b_values_t, *a_shape,\n        *b_shape, *thresh_t;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsMatrix(a_indices->shape()) &&\n                    TensorShapeUtils::IsMatrix(b_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be matrices but received shapes: \",\n                    a_indices->shape().DebugString(), \" and \",\n                    b_indices->shape().DebugString()));\n    const int64 a_nnz = a_indices->dim_size(0);\n    const int64 b_nnz = b_indices->dim_size(0);\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_values_t->shape()) &&\n                    TensorShapeUtils::IsVector(b_values_t->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be vectors but received shapes: \",\n                    a_values_t->shape().DebugString(), \" and \",\n                    b_values_t->shape().DebugString()));\n    auto a_values = ctx->input(1).vec<T>();\n    auto b_values = ctx->input(4).vec<T>();\n    OP_REQUIRES(\n        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n        errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n                                \" non-empty input values, got \",\n                                a_values.size(), \" and \", b_values.size()));\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_shape->shape()) &&\n                    TensorShapeUtils::IsVector(b_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shapes should be a vector but received shapes \",\n                    a_shape->shape().DebugString(), \" and \",\n                    b_shape->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, a_shape->IsSameSize(*b_shape),\n        errors::InvalidArgument(\n            \"Operands do not have the same ranks; got shapes: \",\n            a_shape->SummarizeValue(10), \" and \", b_shape->SummarizeValue(10)));\n    const auto a_shape_flat = a_shape->flat<int64>();\n    const auto b_shape_flat = b_shape->flat<int64>();\n    for (int i = 0; i < a_shape->NumElements(); ++i) {\n      OP_REQUIRES(ctx, a_shape_flat(i) == b_shape_flat(i),\n                  errors::InvalidArgument(\n                      \"Operands' shapes do not match: got \", a_shape_flat(i),\n                      \" and \", b_shape_flat(i), \" for dimension \", i));\n    }\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"thresh\", &thresh_t));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(thresh_t->shape()),\n                errors::InvalidArgument(\n                    \"The magnitude threshold must be a scalar: got shape \",\n                    thresh_t->shape().DebugString()));\n    // std::abs() so that it works for complex{64,128} values as well\n    const Treal thresh = thresh_t->scalar<Treal>()();\n\n    // (1) do a pass over inputs, and append values and indices to vectors\n    auto a_indices_mat = a_indices->matrix<int64>();\n    auto b_indices_mat = b_indices->matrix<int64>();\n    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx\n    entries_to_copy.reserve(a_nnz + b_nnz);\n    std::vector<T> out_values;\n    const int num_dims = a_shape->dim_size(0);\n\n    OP_REQUIRES(ctx, num_dims > 0,\n                errors::InvalidArgument(\"Invalid input_a shape. Received: \",\n                                        a_shape->DebugString()));\n\n    // The input and output sparse tensors are assumed to be ordered along\n    // increasing dimension number.\n    int64 i = 0, j = 0;\n    T s;\n    while (i < a_nnz && j < b_nnz) {\n      switch (sparse::DimComparator::cmp(a_indices_mat, b_indices_mat, i, j,\n                                         num_dims)) {\n        case -1:\n          entries_to_copy.emplace_back(true, i);\n          out_values.push_back(a_values(i));\n          ++i;\n          break;\n        case 0:\n          s = a_values(i) + b_values(j);\n          if (thresh <= std::abs(s)) {\n            entries_to_copy.emplace_back(true, i);\n            out_values.push_back(s);\n          }\n          ++i;\n          ++j;\n          break;\n        case 1:\n          entries_to_copy.emplace_back(false, j);\n          out_values.push_back(b_values(j));\n          ++j;\n          break;\n      }\n    }\n\n#define HANDLE_LEFTOVERS(A_OR_B, IDX, IS_A)     \\\n  while (IDX < A_OR_B##_nnz) {                  \\\n    entries_to_copy.emplace_back(IS_A, IDX);    \\\n    out_values.push_back(A_OR_B##_values(IDX)); \\\n    ++IDX;                                      \\\n  }\n\n    // at most one of these calls appends new values\n    HANDLE_LEFTOVERS(a, i, true);\n    HANDLE_LEFTOVERS(b, j, false);\n#undef HANDLE_LEFTOVERS\n\n    // (2) allocate and fill output tensors\n    const int64 sum_nnz = out_values.size();\n    Tensor *out_indices_t, *out_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                        &out_indices_t));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &out_values_t));\n    auto out_indices_mat = out_indices_t->matrix<int64>();\n    auto out_values_flat = out_values_t->vec<T>();\n\n    for (i = 0; i < sum_nnz; ++i) {\n      const bool from_a = entries_to_copy[i].first;\n      const int64 idx = entries_to_copy[i].second;\n      out_indices_mat.chip<0>(i) =\n          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n    }\n    if (sum_nnz > 0) {\n      std::copy_n(out_values.begin(), sum_nnz, &out_values_flat(0));\n    }\n    ctx->set_output(2, *a_shape);\n  }\n};\n\n#define REGISTER_KERNELS(type, thresh_type)                           \\\n  REGISTER_KERNEL_BUILDER(                                            \\\n      Name(\"SparseAdd\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      SparseAddOp<type, thresh_type>)\n\n// The list below is equivalent to TF_CALL_REAL_NUMBER_TYPES, minus uint8.  This\n// is because std::abs() on uint8 does not compile.\nREGISTER_KERNELS(float, float);\nREGISTER_KERNELS(double, double);\nREGISTER_KERNELS(int64, int64);\nREGISTER_KERNELS(int32, int32);\nREGISTER_KERNELS(int16, int16);\nREGISTER_KERNELS(int8, int8);\nREGISTER_KERNELS(complex64, float);\nREGISTER_KERNELS(complex128, double);\n#undef REGISTER_KERNELS\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\ntemplate <typename T, typename Treal>\nclass SparseAddOp : public OpKernel {\n public:\n  explicit SparseAddOp(OpKernelConstruction *ctx) : OpKernel(ctx) {}\n\n  void Compute(OpKernelContext *ctx) override {\n    // (0) validations\n    const Tensor *a_indices, *b_indices, *a_values_t, *b_values_t, *a_shape,\n        *b_shape, *thresh_t;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsMatrix(a_indices->shape()) &&\n                    TensorShapeUtils::IsMatrix(b_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be matrices but received shapes: \",\n                    a_indices->shape().DebugString(), \" and \",\n                    b_indices->shape().DebugString()));\n    const int64 a_nnz = a_indices->dim_size(0);\n    const int64 b_nnz = b_indices->dim_size(0);\n    const int num_dims = a_indices->dim_size(1);\n    OP_REQUIRES(ctx, b_indices->dim_size(1) == num_dims,\n                errors::InvalidArgument(\n                    \"Input indices must have the same dimension, got \",\n                    num_dims, \" and \", b_indices->dim_size(1)));\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_values_t->shape()) &&\n                    TensorShapeUtils::IsVector(b_values_t->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be vectors but received shapes: \",\n                    a_values_t->shape().DebugString(), \" and \",\n                    b_values_t->shape().DebugString()));\n    auto a_values = ctx->input(1).vec<T>();\n    auto b_values = ctx->input(4).vec<T>();\n    OP_REQUIRES(\n        ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n        errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n                                \" non-empty input values, got \",\n                                a_values.size(), \" and \", b_values.size()));\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape));\n    OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape));\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsVector(a_shape->shape()) &&\n                    TensorShapeUtils::IsVector(b_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shapes should be a vector but received shapes \",\n                    a_shape->shape().DebugString(), \" and \",\n                    b_shape->shape().DebugString()));\n    OP_REQUIRES(\n        ctx, a_shape->NumElements() == num_dims,\n        errors::InvalidArgument(\"Second dimension of a_indices and length of \"\n                                \"a_shape must match, got \",\n                                num_dims, \" and \", a_shape->NumElements()));\n    OP_REQUIRES(ctx, num_dims > 0,\n                errors::InvalidArgument(\"Tesors must not be empty\"));\n    OP_REQUIRES(\n        ctx, a_shape->IsSameSize(*b_shape),\n        errors::InvalidArgument(\n            \"Operands do not have the same ranks; got shapes: \",\n            a_shape->SummarizeValue(10), \" and \", b_shape->SummarizeValue(10)));\n    const auto a_shape_flat = a_shape->flat<int64>();\n    const auto b_shape_flat = b_shape->flat<int64>();\n    for (int i = 0; i < a_shape->NumElements(); ++i) {\n      OP_REQUIRES(ctx, a_shape_flat(i) == b_shape_flat(i),\n                  errors::InvalidArgument(\n                      \"Operands' shapes do not match: got \", a_shape_flat(i),\n                      \" and \", b_shape_flat(i), \" for dimension \", i));\n    }\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"thresh\", &thresh_t));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(thresh_t->shape()),\n                errors::InvalidArgument(\n                    \"The magnitude threshold must be a scalar: got shape \",\n                    thresh_t->shape().DebugString()));\n    // std::abs() so that it works for complex{64,128} values as well\n    const Treal thresh = thresh_t->scalar<Treal>()();\n\n    // (1) do a pass over inputs, and append values and indices to vectors\n    auto a_indices_mat = a_indices->matrix<int64>();\n    auto b_indices_mat = b_indices->matrix<int64>();\n    std::vector<std::pair<bool, int64>> entries_to_copy;  // from_a?, idx\n    entries_to_copy.reserve(a_nnz + b_nnz);\n    std::vector<T> out_values;\n\n    // The input and output sparse tensors are assumed to be ordered along\n    // increasing dimension number.\n    int64 i = 0, j = 0;\n    T s;\n    while (i < a_nnz && j < b_nnz) {\n      switch (sparse::DimComparator::cmp(a_indices_mat, b_indices_mat, i, j,\n                                         num_dims)) {\n        case -1:\n          entries_to_copy.emplace_back(true, i);\n          out_values.push_back(a_values(i));\n          ++i;\n          break;\n        case 0:\n          s = a_values(i) + b_values(j);\n          if (thresh <= std::abs(s)) {\n            entries_to_copy.emplace_back(true, i);\n            out_values.push_back(s);\n          }\n          ++i;\n          ++j;\n          break;\n        case 1:\n          entries_to_copy.emplace_back(false, j);\n          out_values.push_back(b_values(j));\n          ++j;\n          break;\n      }\n    }\n\n#define HANDLE_LEFTOVERS(A_OR_B, IDX, IS_A)     \\\n  while (IDX < A_OR_B##_nnz) {                  \\\n    entries_to_copy.emplace_back(IS_A, IDX);    \\\n    out_values.push_back(A_OR_B##_values(IDX)); \\\n    ++IDX;                                      \\\n  }\n\n    // at most one of these calls appends new values\n    HANDLE_LEFTOVERS(a, i, true);\n    HANDLE_LEFTOVERS(b, j, false);\n#undef HANDLE_LEFTOVERS\n\n    // (2) allocate and fill output tensors\n    const int64 sum_nnz = out_values.size();\n    Tensor *out_indices_t, *out_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                        &out_indices_t));\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &out_values_t));\n    auto out_indices_mat = out_indices_t->matrix<int64>();\n    auto out_values_flat = out_values_t->vec<T>();\n\n    for (i = 0; i < sum_nnz; ++i) {\n      const bool from_a = entries_to_copy[i].first;\n      const int64 idx = entries_to_copy[i].second;\n      out_indices_mat.chip<0>(i) =\n          from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n    }\n    if (sum_nnz > 0) {\n      std::copy_n(out_values.begin(), sum_nnz, &out_values_flat(0));\n    }\n    ctx->set_output(2, *a_shape);\n  }\n};\n\n#define REGISTER_KERNELS(type, thresh_type)                           \\\n  REGISTER_KERNEL_BUILDER(                                            \\\n      Name(\"SparseAdd\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      SparseAddOp<type, thresh_type>)\n\n// The list below is equivalent to TF_CALL_REAL_NUMBER_TYPES, minus uint8.  This\n// is because std::abs() on uint8 does not compile.\nREGISTER_KERNELS(float, float);\nREGISTER_KERNELS(double, double);\nREGISTER_KERNELS(int64, int64);\nREGISTER_KERNELS(int32, int32);\nREGISTER_KERNELS(int16, int16);\nREGISTER_KERNELS(int8, int8);\nREGISTER_KERNELS(complex64, float);\nREGISTER_KERNELS(complex128, double);\n#undef REGISTER_KERNELS\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/sparse_add_op.cc"], "buggy_code_start_loc": [46], "buggy_code_end_loc": [108], "fixing_code_start_loc": [47], "fixing_code_end_loc": [114], "type": "CWE-476", "message": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29609", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:15.850", "lastModified": "2021-05-20T16:45:48.893", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;Una comprobaci\u00f3n incompleta en \"SparseAdd\" resulta en que los atacantes puedan explotar el comportamiento indefinido (desreferenciar punteros nulls), as\u00ed como escribir fuera de l\u00edmites de los datos asignados a la pila.&#xa0;La implementaci\u00f3n (https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) presenta un gran conjunto de comprobaci\u00f3n para las dos entradas de tensor dispersas (6 tensores en total), pero no comprobar que los tensores no est\u00e9n vac\u00edos o que la segunda dimensi\u00f3n de \"*_indices\" coincida con el tama\u00f1o de \"*_shape\" correspondiente.&#xa0;Esto permite a los atacantes enviar triples de tensor que representan tensores dispersos no comprobados para abusar de supuestos de c\u00f3digo que no est\u00e1n protegidos por comprobaci\u00f3n.&#xa0;La correcci\u00f3n ser\u00e1 inclu\u00edda en TensorFlow versi\u00f3n 2.5.0. Tambi\u00e9n seleccionaremos este commits en TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 y TensorFlow 2.1.4, ya que tambi\u00e9n est\u00e1n afectadas y a\u00fan se encuentran en el rango compatible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}, {"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/41727ff06111117bdf86b37db198217fd7a143cc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/6fd02f44810754ae7481838b6a67c5df7f909ca3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-cjc7-49v2-jp64", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/41727ff06111117bdf86b37db198217fd7a143cc"}}