{"buggy_code": ["<?php\nnamespace PodloveSubscribeButton\\Model;\n\nabstract class Base {\n\t/**\n\t * Property dictionary for all tables\n\t */\n\tprivate static $properties = array();\n\t\n\tprivate $is_new = true;\n\t\n\t/**\n\t * Contains property values\n\t */\n\tprivate $data = array();\n\t\n\tpublic function __set( $name, $value ) {\n\t\tif ( static::has_property( $name ) ) {\n\t\t\t$this->set_property( $name, $value );\n\t\t} else {\n\t\t\t$this->$name = $value;\n\t\t}\n\t}\n\t\n\tprivate function set_property( $name, $value ) {\n\t\t$this->data[ $name ] = $value;\n\t}\n\t\n\tpublic function __get( $name ) {\n\t\tif ( static::has_property( $name ) ) {\n\t\t\treturn $this->get_property( $name );\n\t\t} elseif ( property_exists( $this, $name ) ) {\n\t\t\treturn $this->$name;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprivate function get_property( $name ) {\n\t\tif ( isset( $this->data[ $name ] ) ) {\n\t\t\treturn $this->data[ $name ];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static function unserialize_property($property) {\n\t\tif ( ! isset($property) )\n\t\t\treturn;\n\n\t\tif ( $unserialized_string = is_serialized($property) )\n\t\t\treturn unserialize($property);\n\n\t\treturn $property;\n\t}\n\n\t/**\n\t * Retrieves the database table name.\n\t * \n\t * The name is derived from the namespace an class name. Additionally, it\n\t * is prefixed with the global WordPress database table prefix.\n\t * @todo cache\n\t * \n\t * @return string database table name\n\t */\n\tpublic static function table_name() {\n\t\tglobal $wpdb;\n\t\t\n\t\t// prefix with $wpdb prefix\n\t\treturn $wpdb->prefix . static::name();\n\t}\n\t\n\t/**\n\t * Define a property with name and type.\n\t * \n\t * Currently only supports basics.\n\t * @todo enable additional options like NOT NULL, DEFAULT etc.\n\t * \n\t * @param string $name Name of the property / column\n\t * @param string $type mySQL column type \n\t */\n\tpublic static function property( $name, $type, $args = array() ) {\n\t\t$class = get_called_class();\n\t\t\n\t\tif ( ! isset( static::$properties[ $class ] ) ) {\n\t\t\tstatic::$properties[ $class ] = array();\n\t\t}\n\n\t\t// \"id\" columns and those ending on \"_id\" get an index by default\n\t\t$index = $name == 'id' || stripos( $name, '_id' );\n\t\t// but if the argument is set, it overrides the default\n\t\tif (isset($args['index'])) {\n\t\t\t$index = $args['index'];\n\t\t}\n\t\t\n\t\tstatic::$properties[ $class ][] = array(\n\t\t\t'name'  => $name,\n\t\t\t'type'  => $type,\n\t\t\t'index' => $index,\n\t\t\t'index_length' => isset($args['index_length']) ? $args['index_length'] : null,\n\t\t\t'unique' => isset($args['unique']) ? $args['unique'] : null\n\t\t);\n\t}\n\t\n\t/**\n\t * Return a list of property dictionaries.\n\t * \n\t * @return array property list\n\t */\n\tprivate static function properties() {\n\t\t$class = get_called_class();\n\t\t\n\t\tif ( ! isset( static::$properties[ $class ] ) ) {\n\t\t\tstatic::$properties[ $class ] = array();\n\t\t}\n\t\t\n\t\treturn static::$properties[ $class ];\n\t}\n\t\n\t/**\n\t * Does the given property exist?\n\t * \n\t * @param string $name name of the property to test\n\t * @return bool True if the property exists, else false.\n\t */\n\tpublic static function has_property( $name ) {\n\t\treturn in_array( $name, static::property_names() );\n\t}\n\t\n\t/**\n\t * Return a list of property names.\n\t * \n\t * @return array property names\n\t */\n\tpublic static function property_names() {\n\t\treturn array_map( function ( $p ) { return $p['name']; } , static::properties() );\n\t}\n\t\n\t/**\n\t * Does the table have any entries?\n\t * \n\t * @return bool True if there is at least one entry, else false.\n\t */\n\tpublic static function has_entries() {\n\t\treturn static::count() > 0;\n\t}\n\t\n\t/**\n\t * Return number of rows in the table.\n\t * \n\t * @return int number of rows\n\t */\n\tpublic static function count() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$sql = 'SELECT COUNT(*) FROM ' . static::table_name();\n\t\treturn (int) $wpdb->get_var( $sql );\n\t}\n\n\tpublic static function find_by_id( $id ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$model = new $class();\n\t\t$model->flag_as_not_new();\n\t\t\n\t\t$row = $wpdb->get_row( 'SELECT * FROM ' . static::table_name() . ' WHERE id = ' . (int) $id );\n\t\t\n\t\tif ( ! $row ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tforeach ( $row as $property => $value ) {\n\t\t\t$model->$property = static::unserialize_property($value);\n\t\t}\n\t\t\n\t\treturn $model;\n\t}\n\n\tpublic static function find_all_by_property( $property, $value ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$models = array();\n\t\t\n\t\t$rows = $wpdb->get_results(\n\t\t\t'SELECT * FROM ' . static::table_name() . ' WHERE ' . $property .  ' = \\'' . $value . '\\''\n\t\t);\n\t\t\n\t\tif ( ! $rows ) {\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\tforeach ( $rows as $row ) {\n\t\t\t$model = new $class();\n\t\t\t$model->flag_as_not_new();\n\t\t\tforeach ( $row as $property => $value ) {\n\t\t\t\t$model->$property = static::unserialize_property($value);\n\t\t\t}\n\t\t\t$models[] = $model;\n\t\t}\n\t\t\n\t\treturn $models;\n\t}\n\n\tpublic static function find_one_by_property( $property, $value ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$model = new $class();\n\t\t$model->flag_as_not_new();\n\t\t\n\t\t$row = $wpdb->get_row(\n\t\t\t'SELECT * FROM ' . static::table_name() . ' WHERE ' . $property .  ' = \\'' . $value . '\\' LIMIT 0,1'\n\t\t);\n\t\t\n\t\tif ( ! $row ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tforeach ( $row as $property => $value ) {\n\t\t\t$model->$property = static::unserialize_property($value);\n\t\t}\n\t\t\n\t\treturn $model;\n\t}\n\n\tpublic static function find_all_by_where( $where ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$models = array();\n\t\t\n\t\t$rows = $wpdb->get_results(\n\t\t\t'SELECT * FROM ' . static::table_name() . ' WHERE ' . $where\n\t\t);\n\t\t\n\t\tif ( ! $rows ) {\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\tforeach ( $rows as $row ) {\n\t\t\t$model = new $class();\n\t\t\t$model->flag_as_not_new();\n\t\t\tforeach ( $row as $property => $value ) {\n\t\t\t\t$model->$property = static::unserialize_property($value);\n\t\t\t}\n\t\t\t$models[] = $model;\n\t\t}\n\t\t\n\t\treturn $models;\n\t}\n\t\n\tpublic static function find_one_by_where( $where ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$model = new $class();\n\t\t$model->flag_as_not_new();\n\t\t\n\t\t$row = $wpdb->get_row(\n\t\t\t'SELECT * FROM ' . static::table_name() . ' WHERE ' . $where . ' LIMIT 0,1'\n\t\t);\n\t\t\n\t\tif ( ! $row ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tforeach ( $row as $property => $value ) {\n\t\t\t$model->$property = static::unserialize_property($value);\n\t\t}\n\t\t\n\t\treturn $model;\n\t}\n\t/**\n\t * Retrieve all entries from the table.\n\t *\n\t * @param  string $sql_suffix optional SQL, appended after FROM clause\n\t * @return array list of model objects\n\t */\n\tpublic static function all( $sql_suffix = '' ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$models = array();\n\t\t\n\t\t$rows = $wpdb->get_results( 'SELECT * FROM ' . static::table_name() . ' ' . $sql_suffix );\n\n\t\tforeach ( $rows as $row ) {\n\t\t\t$model = new $class();\n\t\t\t$model->flag_as_not_new();\n\t\t\tforeach ( $row as $property => $value ) {\n\t\t\t\t$model->$property = static::unserialize_property($value);\n\t\t\t}\n\t\t\t$models[] = $model;\n\t\t}\n\t\t\n\t\treturn $models;\n\t}\n\t\n\t/**\n\t * True if not yet saved to database. Else false.\n\t */\n\tpublic function is_new() {\n\t\treturn $this->is_new;\n\t}\n\t\n\tpublic function flag_as_not_new() {\n\t\t$this->is_new = false;\n\t}\n\n\t/**\n\t * Rails-ish update_attributes for easy form handling.\n\t *\n\t * Takes an array of form values and takes care of serializing it.\n\t * \n\t * @param  array $attributes\n\t * @return bool\n\t */\n\tpublic function update_attributes( $attributes ) {\n\n\t\tif ( ! is_array( $attributes ) )\n\t\t\treturn false;\n\n\t\t$request = filter_input_array(INPUT_POST); // Do this for security reasons\n\t\t\t\n\t\tforeach ( $attributes as $key => $value ) {\n\t\t\tif ( is_array($value) ) {\n\t\t\t\t$this->{$key} = serialize($value);\n\t\t\t} else {\n\t\t\t\t$this->{$key} = esc_sql($value);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( isset( $request['checkboxes'] ) && is_array( $request['checkboxes'] ) ) {\n\t\t\tforeach ( $request['checkboxes'] as $checkbox ) {\n\t\t\t\tif ( isset( $attributes[ $checkbox ] ) && $attributes[ $checkbox ] === 'on' ) {\n\t\t\t\t\t$this->$checkbox = 1;\n\t\t\t\t} else {\n\t\t\t\t\t$this->$checkbox = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// @todo this is the wrong place to do this!\n\t\t// The feed password is the only \"passphrase\" which is saved. It is not encrypted!\n\t\t// However, we keep this function for later use\n\t\tif ( isset( $request['passwords'] ) && is_array( $request['passwords'] ) ) {\n\t\t\tforeach ( $request['passwords'] as $password ) {\n\t\t\t\t$this->$password = $attributes[ $password ];\n\t\t\t}\n\t\t}\n\t\treturn $this->save();\n\t}\n\n\t/**\n\t * Update and save a single attribute.\n\t * \t\n\t * @param  string $attribute attribute name\n\t * @param  mixed  $value\n\t * @return (bool) query success\n\t */\n\tpublic function update_attribute($attribute, $value) {\n\t\tglobal $wpdb;\n\n\t\t$this->$attribute = $value;\n\n\t\t$sql = sprintf(\n\t\t\t\"UPDATE %s SET %s = '%s' WHERE id = %s\",\n\t\t\tstatic::table_name(),\n\t\t\t$attribute,\n\t\t\tmysqli_real_escape_string($value),\n\t\t\t$this->id\n\t\t);\n\n\t\treturn $wpdb->query( $sql );\n\t}\n\t\n\t/**\n\t * Saves changes to database.\n\t * \n\t * @todo use wpdb::insert()\n\t */\n\tpublic function save() {\n\t\tglobal $wpdb;\n\n\t\tif ( $this->is_new() ) {\n\n\t\t\t$this->set_defaults();\n\n\t\t\t$sql = 'INSERT INTO '\n\t\t\t     . static::table_name()\n\t\t\t     . ' ( '\n\t\t\t     . implode( ',', static::property_names() )\n\t\t\t     . ' ) '\n\t\t\t     . 'VALUES'\n\t\t\t     . ' ( '\n\t\t\t     . implode( ',', array_map( array( $this, 'property_name_to_sql_value' ), static::property_names() ) )\n\t\t\t     . ' );'\n\t\t\t;\n\t\t\t$success = $wpdb->query( $sql );\n\t\t\tif ( $success ) {\n\t\t\t\t$this->id = $wpdb->insert_id;\n\t\t\t}\n\t\t} else {\n\t\t\t$sql = 'UPDATE ' . static::table_name()\n\t\t\t     . ' SET '\n\t\t\t     . implode( ',', array_map( array( $this, 'property_name_to_sql_update_statement' ), static::property_names() ) )\n\t\t\t     . ' WHERE id = ' . $this->id\n\t\t\t;\n\n\t\t\t$success = $wpdb->query( $sql );\n\t\t}\n\n\t\t$this->is_new = false;\n\n\t\tdo_action('podlove_model_save', $this);\n\t\tdo_action('podlove_model_change', $this);\n\n\t\treturn $success;\n\t}\n\n\t/**\n\t * Sets default values.\n\t * \n\t * @return array\n\t */\n\tprivate function set_defaults() {\n\t\t\n\t\t$defaults = $this->default_values();\n\n\t\tif ( ! is_array( $defaults ) || empty( $defaults ) )\n\t\t\treturn;\n\n\t\tforeach ( $defaults as $property => $value ) {\n\t\t\tif ( $this->$property === null )\n\t\t\t\t$this->$property = $value;\n\t\t}\n\n\t}\n\n\t/**\n\t * Return default values for properties.\n\t * \n\t * Can be overridden by inheriting model classes.\n\t * \n\t * @return array\n\t */\n\tpublic function default_values() {\n\t\treturn array();\n\t}\n\t\n\tpublic function delete() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$sql = 'DELETE FROM '\n\t\t     . static::table_name()\n\t\t     . ' WHERE id = ' . $this->id;\n\n\t\t$rows_affected = $wpdb->query( $sql );\n\n\t    do_action('podlove_model_delete', $this);\n\t    do_action('podlove_model_change', $this);\n\n\t\treturn $rows_affected !== false;\n\t}\n\n\tprivate function property_name_to_sql_update_statement( $p ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $this->$p !== null && $this->$p !== '' ) {\n\t\t\treturn sprintf( \"%s = '%s'\", $p, ( is_array($this->$p) ? serialize($this->$p) : $this->$p ) );\n\t\t} else {\n\t\t\treturn \"$p = NULL\";\n\t\t}\n\t}\n\t\n\tprivate function property_name_to_sql_value( $p ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $this->$p !== null && $this->$p !== '' ) {\n\t\t\treturn sprintf( \"'%s'\", $this->$p );\n\t\t} else {\n\t\t\treturn 'NULL';\n\t\t}\n\t}\n\t\n\t/**\n\t * Create database table based on defined properties.\n\t * \n\t * Automatically includes an id column as auto incrementing primary key.\n\t * @todo allow model changes\n\t */\n\tpublic static function build() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$property_sql = array();\n\t\tforeach ( static::properties() as $property )\n\t\t\t$property_sql[] = \"`{$property['name']}` {$property['type']}\";\n\t\t\n\t\t$sql = 'CREATE TABLE IF NOT EXISTS '\n\t\t     . static::table_name()\n\t\t     . ' ('\n\t\t     . implode( ',', $property_sql )\n\t\t     . ' ) CHARACTER SET utf8;'\n\t\t;\n\t\t\n\t\t$wpdb->query( $sql );\n\n\t\tstatic::build_indices();\n\t}\n\t\n\t/**\n\t * Convention based index generation.\n\t *\n\t * Creates default indices for all columns matching both:\n\t * - equals \"id\" or contains \"_id\"\n\t * - doesn't have an index yet\n\t */\n\tpublic static function build_indices() {\n\t\tglobal $wpdb;\n\n\t\t$indices_sql = 'SHOW INDEX FROM `' . static::table_name() . '`';\n\t\t$indices = $wpdb->get_results( $indices_sql );\n\t\t$index_columns = array_map( function($index){ return $index->Column_name; }, $indices );\n\n\t\tforeach ( static::properties() as $property ) {\n\n\t\t\tif ( $property['index'] && ! in_array( $property['name'], $index_columns ) ) {\n\t\t\t\t$length = isset($property['index_length']) ? '(' . (int) $property['index_length'] . ')' : '';\n\t\t\t\t$unique = isset($property['unique']) && $property['unique'] ? 'UNIQUE' : '';\n\t\t\t\t$sql = 'ALTER TABLE `' . static::table_name() . '` ADD ' . $unique . ' INDEX `' . $property['name'] . '` (' . $property['name'] . $length . ')';\n\t\t\t\t$wpdb->query( $sql );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Model identifier.\n\t */\n\tpublic static function name() {\n\t\t// get name of implementing class\n\t\t$table_name = get_called_class();\n\t\t// replace backslashes from namespace by underscores\n\t\t$table_name = str_replace( '\\\\', '_', $table_name );\n\t\t// remove Models subnamespace from name\n\t\t$table_name = str_replace( 'Model_', '', $table_name );\n\t\t// all lowercase\n\t\t$table_name = strtolower( $table_name );\n\n\t\treturn $table_name;\n\t}\n}"], "fixing_code": ["<?php\nnamespace PodloveSubscribeButton\\Model;\n\nabstract class Base {\n\t/**\n\t * Property dictionary for all tables\n\t */\n\tprivate static $properties = array();\n\t\n\tprivate $is_new = true;\n\t\n\t/**\n\t * Contains property values\n\t */\n\tprivate $data = array();\n\t\n\tpublic function __set( $name, $value ) {\n\t\tif ( static::has_property( $name ) ) {\n\t\t\t$this->set_property( $name, $value );\n\t\t} else {\n\t\t\t$this->$name = $value;\n\t\t}\n\t}\n\t\n\tprivate function set_property( $name, $value ) {\n\t\t$this->data[ $name ] = $value;\n\t}\n\t\n\tpublic function __get( $name ) {\n\t\tif ( static::has_property( $name ) ) {\n\t\t\treturn $this->get_property( $name );\n\t\t} elseif ( property_exists( $this, $name ) ) {\n\t\t\treturn $this->$name;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tprivate function get_property( $name ) {\n\t\tif ( isset( $this->data[ $name ] ) ) {\n\t\t\treturn $this->data[ $name ];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static function unserialize_property($property) {\n\t\tif ( ! isset($property) )\n\t\t\treturn;\n\n\t\tif ( $unserialized_string = is_serialized($property) )\n\t\t\treturn unserialize($property);\n\n\t\treturn $property;\n\t}\n\n\t/**\n\t * Retrieves the database table name.\n\t * \n\t * The name is derived from the namespace an class name. Additionally, it\n\t * is prefixed with the global WordPress database table prefix.\n\t * @todo cache\n\t * \n\t * @return string database table name\n\t */\n\tpublic static function table_name() {\n\t\tglobal $wpdb;\n\t\t\n\t\t// prefix with $wpdb prefix\n\t\treturn $wpdb->prefix . static::name();\n\t}\n\t\n\t/**\n\t * Define a property with name and type.\n\t * \n\t * Currently only supports basics.\n\t * @todo enable additional options like NOT NULL, DEFAULT etc.\n\t * \n\t * @param string $name Name of the property / column\n\t * @param string $type mySQL column type \n\t */\n\tpublic static function property( $name, $type, $args = array() ) {\n\t\t$class = get_called_class();\n\t\t\n\t\tif ( ! isset( static::$properties[ $class ] ) ) {\n\t\t\tstatic::$properties[ $class ] = array();\n\t\t}\n\n\t\t// \"id\" columns and those ending on \"_id\" get an index by default\n\t\t$index = $name == 'id' || stripos( $name, '_id' );\n\t\t// but if the argument is set, it overrides the default\n\t\tif (isset($args['index'])) {\n\t\t\t$index = $args['index'];\n\t\t}\n\t\t\n\t\tstatic::$properties[ $class ][] = array(\n\t\t\t'name'  => $name,\n\t\t\t'type'  => $type,\n\t\t\t'index' => $index,\n\t\t\t'index_length' => isset($args['index_length']) ? $args['index_length'] : null,\n\t\t\t'unique' => isset($args['unique']) ? $args['unique'] : null\n\t\t);\n\t}\n\t\n\t/**\n\t * Return a list of property dictionaries.\n\t * \n\t * @return array property list\n\t */\n\tprivate static function properties() {\n\t\t$class = get_called_class();\n\t\t\n\t\tif ( ! isset( static::$properties[ $class ] ) ) {\n\t\t\tstatic::$properties[ $class ] = array();\n\t\t}\n\t\t\n\t\treturn static::$properties[ $class ];\n\t}\n\t\n\t/**\n\t * Does the given property exist?\n\t * \n\t * @param string $name name of the property to test\n\t * @return bool True if the property exists, else false.\n\t */\n\tpublic static function has_property( $name ) {\n\t\treturn in_array( $name, static::property_names() );\n\t}\n\t\n\t/**\n\t * Return a list of property names.\n\t * \n\t * @return array property names\n\t */\n\tpublic static function property_names() {\n\t\treturn array_map( function ( $p ) { return $p['name']; } , static::properties() );\n\t}\n\t\n\t/**\n\t * Does the table have any entries?\n\t * \n\t * @return bool True if there is at least one entry, else false.\n\t */\n\tpublic static function has_entries() {\n\t\treturn static::count() > 0;\n\t}\n\t\n\t/**\n\t * Return number of rows in the table.\n\t * \n\t * @return int number of rows\n\t */\n\tpublic static function count() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$sql = 'SELECT COUNT(*) FROM ' . static::table_name();\n\t\treturn (int) $wpdb->get_var( $sql );\n\t}\n\n\tpublic static function find_by_id( $id ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$model = new $class();\n\t\t$model->flag_as_not_new();\n\t\t\n\t\t$row = $wpdb->get_row( 'SELECT * FROM ' . static::table_name() . ' WHERE id = ' . (int) $id );\n\t\t\n\t\tif ( ! $row ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tforeach ( $row as $property => $value ) {\n\t\t\t$model->$property = static::unserialize_property($value);\n\t\t}\n\t\t\n\t\treturn $model;\n\t}\n\n\tpublic static function find_all_by_property( $property, $value ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$models = array();\n\t\t\n\t\t$rows = $wpdb->get_results(\n\t\t\t'SELECT * FROM ' . static::table_name() . ' WHERE ' . $property .  ' = \\'' . $value . '\\''\n\t\t);\n\t\t\n\t\tif ( ! $rows ) {\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\tforeach ( $rows as $row ) {\n\t\t\t$model = new $class();\n\t\t\t$model->flag_as_not_new();\n\t\t\tforeach ( $row as $property => $value ) {\n\t\t\t\t$model->$property = static::unserialize_property($value);\n\t\t\t}\n\t\t\t$models[] = $model;\n\t\t}\n\t\t\n\t\treturn $models;\n\t}\n\n\tpublic static function find_one_by_property( $property, $value ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$model = new $class();\n\t\t$model->flag_as_not_new();\n\t\t\n\t\t$query = $wpdb->prepare('SELECT * FROM ' . static::table_name() . ' WHERE ' . $property .  ' = \\'%s\\' LIMIT 0,1', $value);\n\t\t$row = $wpdb->get_row($query);\n\t\t\n\t\tif ( ! $row ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tforeach ( $row as $property => $value ) {\n\t\t\t$model->$property = static::unserialize_property($value);\n\t\t}\n\t\t\n\t\treturn $model;\n\t}\n\n\tpublic static function find_all_by_where( $where ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$models = array();\n\t\t\n\t\t$rows = $wpdb->get_results(\n\t\t\t'SELECT * FROM ' . static::table_name() . ' WHERE ' . $where\n\t\t);\n\t\t\n\t\tif ( ! $rows ) {\n\t\t\treturn array();\n\t\t}\n\t\t\n\t\tforeach ( $rows as $row ) {\n\t\t\t$model = new $class();\n\t\t\t$model->flag_as_not_new();\n\t\t\tforeach ( $row as $property => $value ) {\n\t\t\t\t$model->$property = static::unserialize_property($value);\n\t\t\t}\n\t\t\t$models[] = $model;\n\t\t}\n\t\t\n\t\treturn $models;\n\t}\n\t\n\tpublic static function find_one_by_where( $where ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$model = new $class();\n\t\t$model->flag_as_not_new();\n\t\t\n\t\t$row = $wpdb->get_row(\n\t\t\t'SELECT * FROM ' . static::table_name() . ' WHERE ' . $where . ' LIMIT 0,1'\n\t\t);\n\t\t\n\t\tif ( ! $row ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tforeach ( $row as $property => $value ) {\n\t\t\t$model->$property = static::unserialize_property($value);\n\t\t}\n\t\t\n\t\treturn $model;\n\t}\n\t/**\n\t * Retrieve all entries from the table.\n\t *\n\t * @param  string $sql_suffix optional SQL, appended after FROM clause\n\t * @return array list of model objects\n\t */\n\tpublic static function all( $sql_suffix = '' ) {\n\t\tglobal $wpdb;\n\t\t\n\t\t$class = get_called_class();\n\t\t$models = array();\n\t\t\n\t\t$rows = $wpdb->get_results( 'SELECT * FROM ' . static::table_name() . ' ' . $sql_suffix );\n\n\t\tforeach ( $rows as $row ) {\n\t\t\t$model = new $class();\n\t\t\t$model->flag_as_not_new();\n\t\t\tforeach ( $row as $property => $value ) {\n\t\t\t\t$model->$property = static::unserialize_property($value);\n\t\t\t}\n\t\t\t$models[] = $model;\n\t\t}\n\t\t\n\t\treturn $models;\n\t}\n\t\n\t/**\n\t * True if not yet saved to database. Else false.\n\t */\n\tpublic function is_new() {\n\t\treturn $this->is_new;\n\t}\n\t\n\tpublic function flag_as_not_new() {\n\t\t$this->is_new = false;\n\t}\n\n\t/**\n\t * Rails-ish update_attributes for easy form handling.\n\t *\n\t * Takes an array of form values and takes care of serializing it.\n\t * \n\t * @param  array $attributes\n\t * @return bool\n\t */\n\tpublic function update_attributes( $attributes ) {\n\n\t\tif ( ! is_array( $attributes ) )\n\t\t\treturn false;\n\n\t\t$request = filter_input_array(INPUT_POST); // Do this for security reasons\n\t\t\t\n\t\tforeach ( $attributes as $key => $value ) {\n\t\t\tif ( is_array($value) ) {\n\t\t\t\t$this->{$key} = serialize($value);\n\t\t\t} else {\n\t\t\t\t$this->{$key} = esc_sql($value);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( isset( $request['checkboxes'] ) && is_array( $request['checkboxes'] ) ) {\n\t\t\tforeach ( $request['checkboxes'] as $checkbox ) {\n\t\t\t\tif ( isset( $attributes[ $checkbox ] ) && $attributes[ $checkbox ] === 'on' ) {\n\t\t\t\t\t$this->$checkbox = 1;\n\t\t\t\t} else {\n\t\t\t\t\t$this->$checkbox = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// @todo this is the wrong place to do this!\n\t\t// The feed password is the only \"passphrase\" which is saved. It is not encrypted!\n\t\t// However, we keep this function for later use\n\t\tif ( isset( $request['passwords'] ) && is_array( $request['passwords'] ) ) {\n\t\t\tforeach ( $request['passwords'] as $password ) {\n\t\t\t\t$this->$password = $attributes[ $password ];\n\t\t\t}\n\t\t}\n\t\treturn $this->save();\n\t}\n\n\t/**\n\t * Update and save a single attribute.\n\t * \t\n\t * @param  string $attribute attribute name\n\t * @param  mixed  $value\n\t * @return (bool) query success\n\t */\n\tpublic function update_attribute($attribute, $value) {\n\t\tglobal $wpdb;\n\n\t\t$this->$attribute = $value;\n\n\t\t$sql = sprintf(\n\t\t\t\"UPDATE %s SET %s = '%s' WHERE id = %s\",\n\t\t\tstatic::table_name(),\n\t\t\t$attribute,\n\t\t\tmysqli_real_escape_string($value),\n\t\t\t$this->id\n\t\t);\n\n\t\treturn $wpdb->query( $sql );\n\t}\n\t\n\t/**\n\t * Saves changes to database.\n\t * \n\t * @todo use wpdb::insert()\n\t */\n\tpublic function save() {\n\t\tglobal $wpdb;\n\n\t\tif ( $this->is_new() ) {\n\n\t\t\t$this->set_defaults();\n\n\t\t\t$sql = 'INSERT INTO '\n\t\t\t     . static::table_name()\n\t\t\t     . ' ( '\n\t\t\t     . implode( ',', static::property_names() )\n\t\t\t     . ' ) '\n\t\t\t     . 'VALUES'\n\t\t\t     . ' ( '\n\t\t\t     . implode( ',', array_map( array( $this, 'property_name_to_sql_value' ), static::property_names() ) )\n\t\t\t     . ' );'\n\t\t\t;\n\t\t\t$success = $wpdb->query( $sql );\n\t\t\tif ( $success ) {\n\t\t\t\t$this->id = $wpdb->insert_id;\n\t\t\t}\n\t\t} else {\n\t\t\t$sql = 'UPDATE ' . static::table_name()\n\t\t\t     . ' SET '\n\t\t\t     . implode( ',', array_map( array( $this, 'property_name_to_sql_update_statement' ), static::property_names() ) )\n\t\t\t     . ' WHERE id = ' . $this->id\n\t\t\t;\n\n\t\t\t$success = $wpdb->query( $sql );\n\t\t}\n\n\t\t$this->is_new = false;\n\n\t\tdo_action('podlove_model_save', $this);\n\t\tdo_action('podlove_model_change', $this);\n\n\t\treturn $success;\n\t}\n\n\t/**\n\t * Sets default values.\n\t * \n\t * @return array\n\t */\n\tprivate function set_defaults() {\n\t\t\n\t\t$defaults = $this->default_values();\n\n\t\tif ( ! is_array( $defaults ) || empty( $defaults ) )\n\t\t\treturn;\n\n\t\tforeach ( $defaults as $property => $value ) {\n\t\t\tif ( $this->$property === null )\n\t\t\t\t$this->$property = $value;\n\t\t}\n\n\t}\n\n\t/**\n\t * Return default values for properties.\n\t * \n\t * Can be overridden by inheriting model classes.\n\t * \n\t * @return array\n\t */\n\tpublic function default_values() {\n\t\treturn array();\n\t}\n\t\n\tpublic function delete() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$sql = 'DELETE FROM '\n\t\t     . static::table_name()\n\t\t     . ' WHERE id = ' . $this->id;\n\n\t\t$rows_affected = $wpdb->query( $sql );\n\n\t    do_action('podlove_model_delete', $this);\n\t    do_action('podlove_model_change', $this);\n\n\t\treturn $rows_affected !== false;\n\t}\n\n\tprivate function property_name_to_sql_update_statement( $p ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $this->$p !== null && $this->$p !== '' ) {\n\t\t\treturn sprintf( \"%s = '%s'\", $p, ( is_array($this->$p) ? serialize($this->$p) : $this->$p ) );\n\t\t} else {\n\t\t\treturn \"$p = NULL\";\n\t\t}\n\t}\n\t\n\tprivate function property_name_to_sql_value( $p ) {\n\t\tglobal $wpdb;\n\n\t\tif ( $this->$p !== null && $this->$p !== '' ) {\n\t\t\treturn sprintf( \"'%s'\", $this->$p );\n\t\t} else {\n\t\t\treturn 'NULL';\n\t\t}\n\t}\n\t\n\t/**\n\t * Create database table based on defined properties.\n\t * \n\t * Automatically includes an id column as auto incrementing primary key.\n\t * @todo allow model changes\n\t */\n\tpublic static function build() {\n\t\tglobal $wpdb;\n\t\t\n\t\t$property_sql = array();\n\t\tforeach ( static::properties() as $property )\n\t\t\t$property_sql[] = \"`{$property['name']}` {$property['type']}\";\n\t\t\n\t\t$sql = 'CREATE TABLE IF NOT EXISTS '\n\t\t     . static::table_name()\n\t\t     . ' ('\n\t\t     . implode( ',', $property_sql )\n\t\t     . ' ) CHARACTER SET utf8;'\n\t\t;\n\t\t\n\t\t$wpdb->query( $sql );\n\n\t\tstatic::build_indices();\n\t}\n\t\n\t/**\n\t * Convention based index generation.\n\t *\n\t * Creates default indices for all columns matching both:\n\t * - equals \"id\" or contains \"_id\"\n\t * - doesn't have an index yet\n\t */\n\tpublic static function build_indices() {\n\t\tglobal $wpdb;\n\n\t\t$indices_sql = 'SHOW INDEX FROM `' . static::table_name() . '`';\n\t\t$indices = $wpdb->get_results( $indices_sql );\n\t\t$index_columns = array_map( function($index){ return $index->Column_name; }, $indices );\n\n\t\tforeach ( static::properties() as $property ) {\n\n\t\t\tif ( $property['index'] && ! in_array( $property['name'], $index_columns ) ) {\n\t\t\t\t$length = isset($property['index_length']) ? '(' . (int) $property['index_length'] . ')' : '';\n\t\t\t\t$unique = isset($property['unique']) && $property['unique'] ? 'UNIQUE' : '';\n\t\t\t\t$sql = 'ALTER TABLE `' . static::table_name() . '` ADD ' . $unique . ' INDEX `' . $property['name'] . '` (' . $property['name'] . $length . ')';\n\t\t\t\t$wpdb->query( $sql );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Model identifier.\n\t */\n\tpublic static function name() {\n\t\t// get name of implementing class\n\t\t$table_name = get_called_class();\n\t\t// replace backslashes from namespace by underscores\n\t\t$table_name = str_replace( '\\\\', '_', $table_name );\n\t\t// remove Models subnamespace from name\n\t\t$table_name = str_replace( 'Model_', '', $table_name );\n\t\t// all lowercase\n\t\t$table_name = strtolower( $table_name );\n\n\t\treturn $table_name;\n\t}\n}"], "filenames": ["model/base.php"], "buggy_code_start_loc": [213], "buggy_code_end_loc": [216], "fixing_code_start_loc": [213], "fixing_code_end_loc": [215], "type": "CWE-89", "message": "The Podlove Subscribe button plugin for WordPress is vulnerable to UNION-based SQL Injection via the 'button' attribute of the podlove-subscribe-button shortcode in all versions up to, and including, 1.3.10 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query.  This makes it possible for authenticated attackers, with contributor-level access and above, to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database.", "other": {"cve": {"id": "CVE-2024-1118", "sourceIdentifier": "security@wordfence.com", "published": "2024-02-07T11:15:09.247", "lastModified": "2024-02-10T04:13:01.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Podlove Subscribe button plugin for WordPress is vulnerable to UNION-based SQL Injection via the 'button' attribute of the podlove-subscribe-button shortcode in all versions up to, and including, 1.3.10 due to insufficient escaping on the user supplied parameter and lack of sufficient preparation on the existing SQL query.  This makes it possible for authenticated attackers, with contributor-level access and above, to append additional SQL queries into already existing queries that can be used to extract sensitive information from the database."}, {"lang": "es", "value": "El complemento Podlove Subscribe button para WordPress es vulnerable a la inyecci\u00f3n SQL basada en UNION a trav\u00e9s del atributo 'button' del c\u00f3digo abreviado podlove-subscribe-button en todas las versiones hasta la 1.3.10 incluida, debido a un escape insuficiente en el par\u00e1metro proporcionado por el usuario y a la falta de preparaci\u00f3n suficiente en la consulta SQL existente. Esto hace posible que los atacantes autenticados, con acceso de nivel de colaborador y superior, agreguen consultas SQL adicionales a consultas ya existentes que pueden usarse para extraer informaci\u00f3n confidencial de la base de datos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security@wordfence.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:podlove:podlove_subscribe_button:*:*:*:*:*:wordpress:*:*", "versionEndIncluding": "1.3.10", "matchCriteriaId": "0E559309-8CA4-423F-A125-A611F8CBE79B"}]}]}], "references": [{"url": "https://github.com/podlove/podlove-subscribe-button-wp-plugin/commit/b16b7a2e98db4c642ca671b0aede4dbfce4578b3", "source": "security@wordfence.com", "tags": ["Patch"]}, {"url": "https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=3032152%40podlove-subscribe-button&new=3032152%40podlove-subscribe-button&sfp_email=&sfph_mail=", "source": "security@wordfence.com", "tags": ["Patch"]}, {"url": "https://www.wordfence.com/threat-intel/vulnerabilities/id/f234f05f-e377-4e89-81e1-f47ff44eebc5?source=cve", "source": "security@wordfence.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/podlove/podlove-subscribe-button-wp-plugin/commit/b16b7a2e98db4c642ca671b0aede4dbfce4578b3"}}