{"buggy_code": ["### 1.0.4 (Next)\n\n#### Features\n\n* [#1759](https://github.com/ruby-grape/grape/pull/1759): Instrument serialization as `'format_response.grape'` - [@zvkemp](https://github.com/zvkemp).\n\n#### Fixes\n\n* [#1759](https://github.com/ruby-grape/grape/pull/1759): Update appraisal for rails_edge - [@zvkemp](https://github.com/zvkemp).\n* [#1758](https://github.com/ruby-grape/grape/pull/1758): Fix expanding load_path in gemspec - [@2maz](https://github.com/2maz).\n* Your contribution here.\n\n### 1.0.3 (4/23/2018)\n\n#### Fixes\n\n* [#1755](https://github.com/ruby-grape/grape/pull/1755): Fix shared params with exactly_one_of - [@milgner](https://github.com/milgner).\n* [#1740](https://github.com/ruby-grape/grape/pull/1740): Fix dependent parameter validation using `given` when parameter is a `Hash` - [@jvortmann](https://github.com/jvortmann).\n* [#1737](https://github.com/ruby-grape/grape/pull/1737): Fix translating error when passing symbols as params in custom validations - [@mlzhuyi](https://github.com/mlzhuyi).\n* [#1749](https://github.com/ruby-grape/grape/pull/1749): Allow rescue from non-`StandardError` exceptions - [@dm1try](https://github.com/dm1try).\n* [#1750](https://github.com/ruby-grape/grape/pull/1750): Fix a circular dependency warning due to router being loaded by API - [@salasrod](https://github.com/salasrod).\n* [#1752](https://github.com/ruby-grape/grape/pull/1752): Fix `include_missing` behavior for aliased parameters - [@jonasoberschweiber](https://github.com/jonasoberschweiber).\n* [#1754](https://github.com/ruby-grape/grape/pull/1754): Allow rescue from non-`StandardError` exceptions to use default error handling - [@jelkster](https://github.com/jelkster).\n* [#1756](https://github.com/ruby-grape/grape/pull/1756): Allow custom Grape exception handlers when the built-in exception handling is enabled - [@soylent](https://github.com/soylent).\n\n### 1.0.2 (1/10/2018)\n\n#### Features\n\n* [#1686](https://github.com/ruby-grape/grape/pull/1686): Avoid coercion of a value if it is valid - [@timothysu](https://github.com/timothysu).\n* [#1688](https://github.com/ruby-grape/grape/pull/1688): Removes yard docs - [@ramkumar-kr](https://github.com/ramkumar-kr).\n* [#1702](https://github.com/ruby-grape/grape/pull/1702): Added danger-toc, verify correct TOC in README - [@dblock](https://github.com/dblock).\n* [#1711](https://github.com/ruby-grape/grape/pull/1711): Automatically coerce arrays and sets of types that implement a `parse` method - [@dslh](https://github.com/dslh).\n\n#### Fixes\n\n* [#1710](https://github.com/ruby-grape/grape/pull/1710): Fix wrong transformation of empty Array in declared params - [@pablonahuelgomez](https://github.com/pablonahuelgomez).\n* [#1722](https://github.com/ruby-grape/grape/pull/1722): Fix catch-all hiding multiple versions of an endpoint after the first definition - [@zherr](https://github.com/zherr).\n* [#1724](https://github.com/ruby-grape/grape/pull/1724): Optional nested array validation - [@ericproulx](https://github.com/ericproulx).\n* [#1725](https://github.com/ruby-grape/grape/pull/1725): Fix `rescue_from :all` documentation - [@Jelkster](https://github.com/Jelkster).\n* [#1726](https://github.com/ruby-grape/grape/pull/1726): Improved startup performance during API method generation - [@jkowens](https://github.com/jkowens).\n* [#1727](https://github.com/ruby-grape/grape/pull/1727): Fix infinite loop when mounting endpoint with same superclass - [@jkowens](https://github.com/jkowens).\n\n### 1.0.1 (9/8/2017)\n\n#### Features\n\n* [#1652](https://github.com/ruby-grape/grape/pull/1652): Add the original exception to the error_formatter the original exception - [@dcsg](https://github.com/dcsg).\n* [#1665](https://github.com/ruby-grape/grape/pull/1665): Make helpers available in subclasses - [@pablonahuelgomez](https://github.com/pablonahuelgomez).\n* [#1674](https://github.com/ruby-grape/grape/pull/1674): Add parameter alias (`as`) - [@glaucocustodio](https://github.com/glaucocustodio).\n\n#### Fixes\n\n* [#1652](https://github.com/ruby-grape/grape/pull/1652): Fix missing backtrace that was not being bubbled up to the `error_formatter` - [@dcsg](https://github.com/dcsg).\n* [#1661](https://github.com/ruby-grape/grape/pull/1661): Handle deeply-nested dependencies correctly - [@rnubel](https://github.com/rnubel), [@jnardone](https://github.com/jnardone).\n* [#1679](https://github.com/ruby-grape/grape/pull/1679): Treat StandardError from explicit values validator proc as false - [@jlfaber](https://github.com/jlfaber).\n\n### 1.0.0 (7/3/2017)\n\n#### Features\n\n* [#1594](https://github.com/ruby-grape/grape/pull/1594): Replace `Hashie::Mash` parameters with `ActiveSupport::HashWithIndifferentAccess` - [@james2m](https://github.com/james2m), [@dblock](https://github.com/dblock).\n* [#1622](https://github.com/ruby-grape/grape/pull/1622): Add `except_values` validator to replace `except` option of `values` validator - [@jlfaber](https://github.com/jlfaber).\n* [#1635](https://github.com/ruby-grape/grape/pull/1635): Instrument validators with ActiveSupport::Notifications - [@ktimothy](https://github.com/ktimothy).\n* [#1646](https://github.com/ruby-grape/grape/pull/1646): Add ability to include an array of modules as helpers - [@pablonahuelgomez](https://github.com/pablonahuelgomez).\n* [#1623](https://github.com/ruby-grape/grape/pull/1623): Removed `multi_json` and `multi_xml` dependencies - [@dblock](https://github.com/dblock).\n* [#1650](https://github.com/ruby-grape/grape/pull/1650): Add extra specs for Boolean type field - [@tiarly](https://github.com/tiarly).\n\n#### Fixes\n\n* [#1648](https://github.com/ruby-grape/grape/pull/1631): Declared now returns declared options using the class that params is set to use - [@thogg4](https://github.com/thogg4).\n* [#1632](https://github.com/ruby-grape/grape/pull/1632): Silence warnings - [@thogg4](https://github.com/thogg4).\n* [#1615](https://github.com/ruby-grape/grape/pull/1615): Fix default and type validator when values is a Hash with no value attribute - [@jlfaber](https://github.com/jlfaber).\n* [#1625](https://github.com/ruby-grape/grape/pull/1625): Handle `given` correctly when nested in Array params - [@rnubel](https://github.com/rnubel), [@avellable](https://github.com/avellable).\n* [#1649](https://github.com/ruby-grape/grape/pull/1649): Don't share validator instances between requests - [@anakinj](https://github.com/anakinj).\n\n### 0.19.2 (4/12/2017)\n\n#### Features\n\n* [#1555](https://github.com/ruby-grape/grape/pull/1555): Added code coverage w/Coveralls - [@dblock](https://github.com/dblock).\n* [#1568](https://github.com/ruby-grape/grape/pull/1568): Add `proc` option to `values` validator to allow custom checks - [@jlfaber](https://github.com/jlfaber).\n* [#1575](https://github.com/ruby-grape/grape/pull/1575): Include nil values for missing nested params in declared - [@thogg4](https://github.com/thogg4).\n* [#1585](https://github.com/ruby-grape/grape/pull/1585): Bugs in declared method - make sure correct options var is used and respect include missing for non children params - [@thogg4](https://github.com/thogg4).\n\n#### Fixes\n\n* [#1570](https://github.com/ruby-grape/grape/pull/1570): Make versioner consider the mount destination path - [@namusyaka](https://github.com/namusyaka).\n* [#1579](https://github.com/ruby-grape/grape/pull/1579): Fix delete status with a return value - [@eproulx-petalmd](https://github.com/eproulx-petalmd).\n* [#1559](https://github.com/ruby-grape/grape/pull/1559): You can once again pass `nil` to optional attributes with `values` validation set - [@ghiculescu](https://github.com/ghiculescu).\n* [#1562](https://github.com/ruby-grape/grape/pull/1562): Fix rainbow gem installation failure above ruby 2.3.3 on travis-ci - [@brucehsu](https://github.com/brucehsu).\n* [#1561](https://github.com/ruby-grape/grape/pull/1561): Fix performance issue introduced by duplicated calls in StackableValue#[] - [@brucehsu](https://github.com/brucehsu).\n* [#1564](https://github.com/ruby-grape/grape/pull/1564): Fix declared params bug with nested namespaces - [@bmarini](https://github.com/bmarini).\n* [#1567](https://github.com/ruby-grape/grape/pull/1567): Fix values validator when value is empty array and apply except to input array - [@jlfaber](https://github.com/jlfaber).\n* [#1569](https://github.com/ruby-grape/grape/pull/1569), [#1511](https://github.com/ruby-grape/grape/issues/1511): Upgrade mustermann-grape to 1.0.0 - [@namusyaka](https://github.com/namusyaka).\n* [#1589](https://github.com/ruby-grape/grape/pull/1589): [#726](https://github.com/ruby-grape/grape/issues/726): Use default_format when Content-type is missing and respond with 406 when Content-type is invalid - [@inclooder](https://github.com/inclooder).\n\n### 0.19.1 (1/9/2017)\n\n#### Features\n\n* [#1536](https://github.com/ruby-grape/grape/pull/1536): Updated `invalid_versioner_option` translation - [@Lavode](https://github.com/Lavode).\n* [#1543](https://github.com/ruby-grape/grape/pull/1543): Added support for ruby 2.4 - [@LeFnord](https://github.com/LeFnord), [@namusyaka](https://github.com/namusyaka).\n\n#### Fixes\n\n* [#1548](https://github.com/ruby-grape/grape/pull/1548): Fix: avoid failing even if given path does not match with prefix - [@thomas-peyric](https://github.com/thomas-peyric), [@namusyaka](https://github.com/namusyaka).\n* [#1550](https://github.com/ruby-grape/grape/pull/1550): Fix: return 200 as default status for DELETE - [@jthornec](https://github.com/jthornec).\n\n### 0.19.0 (12/18/2016)\n\n#### Features\n\n* [#1503](https://github.com/ruby-grape/grape/pull/1503): Allowed use of regexp validator with arrays - [@akoltun](https://github.com/akoltun).\n* [#1507](https://github.com/ruby-grape/grape/pull/1507): Added group attributes for parameter definitions - [@304](https://github.com/304).\n* [#1532](https://github.com/ruby-grape/grape/pull/1532): Set 204 as default status for DELETE - [@LeFnord](https://github.com/LeFnord).\n\n#### Fixes\n\n* [#1505](https://github.com/ruby-grape/grape/pull/1505): Run `before` and `after` callbacks, but skip the rest when handling OPTIONS - [@jlfaber](https://github.com/jlfaber).\n* [#1517](https://github.com/ruby-grape/grape/pull/1517), [#1089](https://github.com/ruby-grape/grape/pull/1089): Fix: priority of ANY routes - [@namusyaka](https://github.com/namusyaka), [@wagenet](https://github.com/wagenet).\n* [#1512](https://github.com/ruby-grape/grape/pull/1512): Fix: deeply nested parameters are included within `#declared(params)` - [@krbs](https://github.com/krbs).\n* [#1510](https://github.com/ruby-grape/grape/pull/1510): Fix: inconsistent validation for multiple parameters - [@dgasper](https://github.com/dgasper).\n* [#1526](https://github.com/ruby-grape/grape/pull/1526): Reduced warnings caused by instance variables not initialized - [@cpetschnig](https://github.com/cpetschnig).\n\n### 0.18.0 (10/7/2016)\n\n#### Features\n\n* [#1480](https://github.com/ruby-grape/grape/pull/1480): Used the ruby-grape-danger gem for PR linting - [@dblock](https://github.com/dblock).\n* [#1486](https://github.com/ruby-grape/grape/pull/1486): Implemented except in values validator - [@jonmchan](https://github.com/jonmchan).\n* [#1470](https://github.com/ruby-grape/grape/pull/1470): Dropped support for Ruby 2.0 - [@namusyaka](https://github.com/namusyaka).\n* [#1490](https://github.com/ruby-grape/grape/pull/1490): Switched to Ruby-2.x+ syntax - [@namusyaka](https://github.com/namusyaka).\n* [#1499](https://github.com/ruby-grape/grape/pull/1499): Support `fail_fast` param validation option - [@dgasper](https://github.com/dgasper).\n\n#### Fixes\n\n* [#1498](https://github.com/ruby-grape/grape/pull/1498): Fix: skip validations in inactive given blocks - [@jlfaber](https://github.com/jlfaber).\n* [#1479](https://github.com/ruby-grape/grape/pull/1479): Fix: support inserting middleware before/after anonymous classes in the middleware stack - [@rosa](https://github.com/rosa).\n* [#1488](https://github.com/ruby-grape/grape/pull/1488): Fix: ensure calling before filters when receiving OPTIONS request - [@namusyaka](https://github.com/namusyaka), [@jlfaber](https://github.com/jlfaber).\n* [#1493](https://github.com/ruby-grape/grape/pull/1493): Fix: coercion and lambda fails params validation - [@jonmchan](https://github.com/jonmchan).\n\n### 0.17.0 (7/29/2016)\n\n#### Features\n\n* [#1393](https://github.com/ruby-grape/grape/pull/1393): Middleware can be inserted before or after default Grape middleware - [@ridiculous](https://github.com/ridiculous).\n* [#1390](https://github.com/ruby-grape/grape/pull/1390): Allowed inserting middleware at arbitrary points in the middleware stack - [@rosa](https://github.com/rosa).\n* [#1366](https://github.com/ruby-grape/grape/pull/1366): Stored `message_key` on `Grape::Exceptions::Validation` - [@mkou](https://github.com/mkou).\n* [#1398](https://github.com/ruby-grape/grape/pull/1398): Added `rescue_from :grape_exceptions` - allow Grape to use the built-in `Grape::Exception` handing and use `rescue :all` behavior for everything else - [@mmclead](https://github.com/mmclead).\n* [#1443](https://github.com/ruby-grape/grape/pull/1443): Extended `given` to receive a `Proc` - [@glaucocustodio](https://github.com/glaucocustodio).\n* [#1455](https://github.com/ruby-grape/grape/pull/1455): Added an automated PR linter - [@orta](https://github.com/orta).\n\n#### Fixes\n\n* [#1463](https://github.com/ruby-grape/grape/pull/1463): Fix array indicies in error messages - [@ffloyd](https://github.com/ffloyd).\n* [#1465](https://github.com/ruby-grape/grape/pull/1465): Fix 'before' being called twice when using not allowed method - [@jsteinberg](https://github.com/jsteinberg).\n* [#1446](https://github.com/ruby-grape/grape/pull/1446): Fix for `env` inside `before` when using not allowed method - [@leifg](https://github.com/leifg).\n* [#1438](https://github.com/ruby-grape/grape/pull/1439): Try to dup non-frozen default params with each use - [@jlfaber](https://github.com/jlfaber).\n* [#1430](https://github.com/ruby-grape/grape/pull/1430): Fix for `declared(params)` inside `route_param` - [@Arkanain](https://github.com/Arkanain).\n* [#1405](https://github.com/ruby-grape/grape/pull/1405): Fix priority of `rescue_from` clauses applying - [@hedgesky](https://github.com/hedgesky).\n* [#1365](https://github.com/ruby-grape/grape/pull/1365): Fix finding exception handler in error middleware - [@ktimothy](https://github.com/ktimothy).\n* [#1380](https://github.com/ruby-grape/grape/pull/1380): Fix `allow_blank: false` for `Time` attributes with valid values causes `NoMethodError` - [@ipkes](https://github.com/ipkes).\n* [#1384](https://github.com/ruby-grape/grape/pull/1384): Fix parameter validation with an empty optional nested `Array` - [@ipkes](https://github.com/ipkes).\n* [#1414](https://github.com/ruby-grape/grape/pull/1414): Fix multiple version definitions for path versioning - [@304](https://github.com/304).\n* [#1415](https://github.com/ruby-grape/grape/pull/1415): Fix `declared(params, include_parent_namespaces: false)` - [@304](https://github.com/304).\n* [#1421](https://github.com/ruby-grape/grape/pull/1421): Avoid polluting `Grape::Middleware::Error` - [@namusyaka](https://github.com/namusyaka).\n* [#1422](https://github.com/ruby-grape/grape/pull/1422): Concat parent declared params with current one - [@plukevdh](https://github.com/plukevdh), [@rnubel](https://github.com/rnubel), [@namusyaka](https://github.com/namusyaka).\n\n### 0.16.2 (4/12/2016)\n\n#### Features\n\n* [#1348](https://github.com/ruby-grape/grape/pull/1348): Fix global functions polluting Grape::API scope - [@dblock](https://github.com/dblock).\n* [#1357](https://github.com/ruby-grape/grape/pull/1357): Expose Route#options - [@namusyaka](https://github.com/namusyaka).\n\n#### Fixes\n\n* [#1357](https://github.com/ruby-grape/grape/pull/1357): Don't include fixed named captures as route params - [@namusyaka](https://github.com/namusyaka).\n* [#1359](https://github.com/ruby-grape/grape/pull/1359): Avoid evaluating the same route twice - [@namusyaka](https://github.com/namusyaka), [@dblock](https://github.com/dblock).\n* [#1361](https://github.com/ruby-grape/grape/pull/1361): Return 405 correctly even if version is using as header and wrong request method - [@namusyaka](https://github.com/namusyaka), [@dblock](https://github.com/dblock).\n\n### 0.16.1 (4/3/2016)\n\n#### Features\n\n* [#1276](https://github.com/ruby-grape/grape/pull/1276): Replace rack-mount with new router - [@namusyaka](https://github.com/namusyaka).\n* [#1321](https://github.com/ruby-grape/grape/pull/1321): Serve files without using FileStreamer-like object - [@lfidnl](https://github.com/lfidnl).\n* [#1339](https://github.com/ruby-grape/grape/pull/1339): Implement Grape::API.recognize_path - [@namusyaka](https://github.com/namusyaka).\n\n#### Fixes\n\n* [#1325](https://github.com/ruby-grape/grape/pull/1325): Params: Fix coerce_with helper with Array types - [@ngonzalez](https://github.com/ngonzalez).\n* [#1326](https://github.com/ruby-grape/grape/pull/1326): Fix wrong behavior for OPTIONS and HEAD requests with catch-all - [@ekampp](https://github.com/ekampp), [@namusyaka](https://github.com/namusyaka).\n* [#1330](https://github.com/ruby-grape/grape/pull/1330): Add `register` keyword for adding customized parsers and formatters - [@namusyaka](https://github.com/namusyaka).\n* [#1336](https://github.com/ruby-grape/grape/pull/1336): Do not modify Hash argument to `error!` - [@tjwp](https://github.com/tjwp).\n\n### 0.15.0 (3/8/2016)\n\n#### Features\n\n* [#1227](https://github.com/ruby-grape/grape/pull/1227): Store `message_key` on `Grape::Exceptions::Validation` - [@stjhimy](https://github.com/sthimy).\n* [#1232](https://github.com/ruby-grape/grape/pull/1232): Helpers are now available inside `rescue_from` - [@namusyaka](https://github.com/namusyaka).\n* [#1237](https://github.com/ruby-grape/grape/pull/1237): Allow multiple parameters in `given`, which behaves as if the scopes were nested in the inputted order - [@ochagata](https://github.com/ochagata).\n* [#1238](https://github.com/ruby-grape/grape/pull/1238): Call `after` of middleware on error - [@namusyaka](https://github.com/namusyaka).\n* [#1243](https://github.com/ruby-grape/grape/pull/1243): Add `header` support for middleware - [@namusyaka](https://github.com/namusyaka).\n* [#1252](https://github.com/ruby-grape/grape/pull/1252): Allow default to be a subset or equal to allowed values without raising IncompatibleOptionValues - [@jeradphelps](https://github.com/jeradphelps).\n* [#1255](https://github.com/ruby-grape/grape/pull/1255): Allow param type definition in `route_param` - [@namusyaka](https://github.com/namusyaka).\n* [#1257](https://github.com/ruby-grape/grape/pull/1257): Allow Proc, Symbol or String in `rescue_from with: ...` - [@namusyaka](https://github.com/namusyaka).\n* [#1280](https://github.com/ruby-grape/grape/pull/1280): Support `Rack::Sendfile` middleware - [@lfidnl](https://github.com/lfidnl).\n* [#1285](https://github.com/ruby-grape/grape/pull/1285): Add a warning for errors appearing in `after` callbacks - [@gregormelhorn](https://github.com/gregormelhorn).\n* [#1295](https://github.com/ruby-grape/grape/pull/1295): Add custom validation messages for parameter exceptions - [@railsmith](https://github.com/railsmith).\n\n#### Fixes\n\n* [#1216](https://github.com/ruby-grape/grape/pull/1142): Fix JSON error response when calling `error!` with non-Strings - [@jrforrest](https://github.com/jrforrest).\n* [#1225](https://github.com/ruby-grape/grape/pull/1225): Fix `given` with nested params not returning correct declared params - [@JanStevens](https://github.com/JanStevens).\n* [#1249](https://github.com/ruby-grape/grape/pull/1249): Don't fail even if invalid type value is passed to default validator - [@namusyaka](https://github.com/namusyaka).\n* [#1266](https://github.com/ruby-grape/grape/pull/1266): Fix `Allow` header including `OPTIONS` when `do_not_route_options!` is active - [@arempe93](https://github.com/arempe93).\n* [#1270](https://github.com/ruby-grape/grape/pull/1270): Fix `param` versioning with a custom parameter - [@wshatch](https://github.com/wshatch).\n* [#1282](https://github.com/ruby-grape/grape/pull/1282): Fix specs circular dependency - [@304](https://github.com/304).\n* [#1283](https://github.com/ruby-grape/grape/pull/1283): Fix 500 error for xml format when method is not allowed - [@304](https://github.com/304).\n* [#1197](https://github.com/ruby-grape/grape/pull/1290): Fix using JSON and Array[JSON] as groups when parameter is optional - [@lukeivers](https://github.com/lukeivers).\n\n### 0.14.0 (12/07/2015)\n\n#### Features\n\n* [#1218](https://github.com/ruby-grape/grape/pull/1218): Provide array index context in errors - [@towanda](https://github.com/towanda).\n* [#1196](https://github.com/ruby-grape/grape/pull/1196): Allow multiple `before_each` blocks - [@huynhquancam](https://github.com/huynhquancam).\n* [#1190](https://github.com/ruby-grape/grape/pull/1190): Bypass formatting for statuses with no entity-body - [@tylerdooling](https://github.com/tylerdooling).\n* [#1188](https://github.com/ruby-grape/grape/pull/1188): Allow parameters with more than one type - [@dslh](https://github.com/dslh).\n* [#1179](https://github.com/ruby-grape/grape/pull/1179): Allow all RFC6838 valid characters in header vendor - [@suan](https://github.com/suan).\n* [#1170](https://github.com/ruby-grape/grape/pull/1170): Allow dashes and periods in header vendor - [@suan](https://github.com/suan).\n* [#1167](https://github.com/ruby-grape/grape/pull/1167): Convenience wrapper `type: File` for validating multipart file parameters - [@dslh](https://github.com/dslh).\n* [#1167](https://github.com/ruby-grape/grape/pull/1167): Refactor and extend coercion and type validation system - [@dslh](https://github.com/dslh).\n* [#1163](https://github.com/ruby-grape/grape/pull/1163): First-class `JSON` parameter type - [@dslh](https://github.com/dslh).\n* [#1161](https://github.com/ruby-grape/grape/pull/1161): Custom parameter coercion using `coerce_with` - [@dslh](https://github.com/dslh).\n\n#### Fixes\n\n* [#1194](https://github.com/ruby-grape/grape/pull/1194): Redirect as plain text with message - [@tylerdooling](https://github.com/tylerdooling).\n* [#1185](https://github.com/ruby-grape/grape/pull/1185): Use formatters for custom vendored content types - [@tylerdooling](https://github.com/tylerdooling).\n* [#1156](https://github.com/ruby-grape/grape/pull/1156): Fixed `no implicit conversion of Symbol into Integer` with nested `values` validation - [@quickpay](https://github.com/quickpay).\n* [#1153](https://github.com/ruby-grape/grape/pull/1153): Fixes boolean declaration in an external file - [@towanda](https://github.com/towanda).\n* [#1142](https://github.com/ruby-grape/grape/pull/1142): Makes #declared unavailable to before filters - [@jrforrest](https://github.com/jrforrest).\n* [#1114](https://github.com/ruby-grape/grape/pull/1114): Fix regression which broke identical endpoints with different versions - [@suan](https://github.com/suan).\n* [#1109](https://github.com/ruby-grape/grape/pull/1109): Memoize Virtus attribute and fix memory leak - [@marshall-lee](https://github.com/marshall-lee).\n* [#1101](https://github.com/ruby-grape/grape/pull/1101): Fix: Incorrect media-type `Accept` header now correctly returns 406 with `strict: true` - [@elliotlarson](https://github.com/elliotlarson).\n* [#1108](https://github.com/ruby-grape/grape/pull/1039): Raise a warning when `desc` is called with options hash and block - [@rngtng](https://github.com/rngtng).\n\n### 0.13.0 (8/10/2015)\n\n#### Features\n\n* [#1039](https://github.com/ruby-grape/grape/pull/1039): Added support for custom parameter types - [@rnubel](https://github.com/rnubel).\n* [#1047](https://github.com/ruby-grape/grape/pull/1047): Adds `given` to DSL::Parameters, allowing for dependent params - [@rnubel](https://github.com/rnubel).\n* [#1064](https://github.com/ruby-grape/grape/pull/1064): Add public `Grape::Exception::ValidationErrors#full_messages` - [@romanlehnert](https://github.com/romanlehnert).\n* [#1079](https://github.com/ruby-grape/grape/pull/1079): Added `stream` method to take advantage of `Rack::Chunked` - [@zbelzer](https://github.com/zbelzer).\n* [#1086](https://github.com/ruby-grape/grape/pull/1086): Added `ActiveSupport::Notifications` instrumentation - [@wagenet](https://github.com/wagenet).\n\n#### Fixes\n\n* [#1062](https://github.com/ruby-grape/grape/issues/1062): Fix: `Grape::Exceptions::ValidationErrors` will include headers set by `header` - [@yairgo](https://github.com/yairgo).\n* [#1038](https://github.com/ruby-grape/grape/pull/1038): Avoid dup-ing the `String` class when used in inherited params - [@rnubel](https://github.com/rnubel).\n* [#1042](https://github.com/ruby-grape/grape/issues/1042): Fix coercion of complex arrays - [@dim](https://github.com/dim).\n* [#1045](https://github.com/ruby-grape/grape/pull/1045): Do not convert `Rack::Response` to `Rack::Response` in middleware - [@dmitry](https://github.com/dmitry).\n* [#1048](https://github.com/ruby-grape/grape/pull/1048): Only dup `InheritableValues`, remove support for `deep_dup` - [@toddmazierski](https://github.com/toddmazierski).\n* [#1052](https://github.com/ruby-grape/grape/pull/1052): Reset `description[:params]` when resetting validations - [@marshall-lee](https://github.com/marshall-lee).\n* [#1088](https://github.com/ruby-grape/grape/pull/1088): Support ActiveSupport 3.x by explicitly requiring `Hash#except` - [@wagenet](https://github.com/wagenet).\n* [#1096](https://github.com/ruby-grape/grape/pull/1096): Fix coercion on booleans - [@towanda](https://github.com/towanda).\n\n### 0.12.0 (6/18/2015)\n\n#### Features\n\n* [#995](https://github.com/ruby-grape/grape/issues/995): Added support for coercion to Set or Set[Other] - [@jordansexton](https://github.com/jordansexton) [@u2](https://github.com/u2).\n* [#980](https://github.com/ruby-grape/grape/issues/980): Grape is now eager-loaded - [@u2](https://github.com/u2).\n* [#956](https://github.com/ruby-grape/grape/issues/956): Support `present` with `Grape::Presenters::Presenter`  - [@u2](https://github.com/u2).\n* [#974](https://github.com/ruby-grape/grape/pull/974): Added `error!` to `rescue_from` blocks - [@whatasunnyday](https://github.com/whatasunnyday).\n* [#950](https://github.com/ruby-grape/grape/pull/950): Status method can now accept one of Rack::Utils status code symbols (:ok, :found, :bad_request, etc.) - [@dabrorius](https://github.com/dabrorius).\n* [#952](https://github.com/ruby-grape/grape/pull/952): Status method now raises error when called with invalid status code - [@dabrorius](https://github.com/dabrorius).\n* [#957](https://github.com/ruby-grape/grape/pull/957): Regexp validator now supports `allow_blank`, `nil` value behavior changed - [@calfzhou](https://github.com/calfzhou).\n* [#962](https://github.com/ruby-grape/grape/pull/962): The `default` attribute with `false` value is documented now - [@ajvondrak](https://github.com/ajvondrak).\n* [#1026](https://github.com/ruby-grape/grape/pull/1026): Added `file` method, explicitly setting a file-like response object - [@dblock](https://github.com/dblock).\n\n#### Fixes\n\n* [#994](https://github.com/ruby-grape/grape/pull/994): Fixed optional Array params default to Hash - [@u2](https://github.com/u2).\n* [#988](https://github.com/ruby-grape/grape/pull/988): Fixed duplicate identical endpoints - [@u2](https://github.com/u2).\n* [#936](https://github.com/ruby-grape/grape/pull/936): Fixed default params processing for optional groups - [@dm1try](https://github.com/dm1try).\n* [#942](https://github.com/ruby-grape/grape/pull/942): Fixed forced presence for optional params when based on a reused entity that was also required in another context - [@croeck](https://github.com/croeck).\n* [#1001](https://github.com/ruby-grape/grape/pull/1001): Fixed calling endpoint with specified format with format in its path - [@hodak](https://github.com/hodak).\n* [#1005](https://github.com/ruby-grape/grape/pull/1005): Fixed the Grape::Middleware::Globals - [@urkle](https://github.com/urkle).\n* [#1012](https://github.com/ruby-grape/grape/pull/1012): Fixed `allow_blank: false` with a Boolean value of `false` - [@mfunaro](https://github.com/mfunaro).\n* [#1023](https://github.com/ruby-grape/grape/issues/1023): Fixes unexpected behavior with `present` and an object that responds to `merge` but isn't a Hash - [@dblock](https://github.com/dblock).\n* [#1017](https://github.com/ruby-grape/grape/pull/1017): Fixed `undefined method stringify_keys` with nested mutual exclusive params - [@quickpay](https://github.com/quickpay).\n\n### 0.11.0 (2/23/2015)\n\n* [#925](https://github.com/ruby-grape/grape/pull/925): Fixed `toplevel constant DateTime referenced by Virtus::Attribute::DateTime` - [@u2](https://github.com/u2).\n* [#916](https://github.com/ruby-grape/grape/pull/916): Added `DateTime/Date/Numeric/Boolean` type support `allow_blank` - [@u2](https://github.com/u2).\n* [#871](https://github.com/ruby-grape/grape/pull/871): Fixed `Grape::Middleware::Base#response` - [@galathius](https://github.com/galathius).\n* [#559](https://github.com/ruby-grape/grape/issues/559): Added support for Rack 1.6.0, which parses requests larger than 128KB - [@myitcv](https://github.com/myitcv).\n* [#876](https://github.com/ruby-grape/grape/pull/876): Call to `declared(params)` now returns a `Hashie::Mash` - [@rodzyn](https://github.com/rodzyn).\n* [#879](https://github.com/ruby-grape/grape/pull/879): The `route_info` value is no longer included in `params` Hash - [@rodzyn](https://github.com/rodzyn).\n* [#881](https://github.com/ruby-grape/grape/issues/881): Fixed `Grape::Validations::ValuesValidator` support for `Range` type - [@ajvondrak](https://github.com/ajvondrak).\n* [#901](https://github.com/ruby-grape/grape/pull/901): Fix: callbacks defined in a version block are only called for the routes defined in that block - [@kushkella](https://github.com/kushkella).\n* [#886](https://github.com/ruby-grape/grape/pull/886): Group of parameters made to require an explicit type of Hash or Array - [@jrichter1](https://github.com/jrichter1).\n* [#912](https://github.com/ruby-grape/grape/pull/912): Extended the `:using` feature for param documentation to `optional` fields - [@croeck](https://github.com/croeck).\n* [#906](https://github.com/ruby-grape/grape/pull/906): Fix: invalid body parse errors are not rescued by handlers - [@croeck](https://github.com/croeck).\n* [#913](https://github.com/ruby-grape/grape/pull/913): Fix: Invalid accept headers are not processed by rescue handlers - [@croeck](https://github.com/croeck).\n* [#913](https://github.com/ruby-grape/grape/pull/913): Fix: Invalid accept headers cause internal processing errors (500) when http_codes are defined - [@croeck](https://github.com/croeck).\n* [#917](https://github.com/ruby-grape/grape/pull/917): Use HTTPS for rubygems.org - [@O-I](https://github.com/O-I).\n\n### 0.10.1 (12/28/2014)\n\n* [#868](https://github.com/ruby-grape/grape/pull/868), [#862](https://github.com/ruby-grape/grape/pull/862), [#861](https://github.com/ruby-grape/grape/pull/861): Fixed `version`, `prefix`, and other settings being overridden or changing scope when mounting API - [@yesmeck](https://github.com/yesmeck).\n* [#864](https://github.com/ruby-grape/grape/pull/864): Fixed `declared(params, include_missing: false)` now returning attributes with `nil` and `false` values - [@ppadron](https://github.com/ppadron).\n\n### 0.10.0 (12/19/2014)\n\n* [#803](https://github.com/ruby-grape/grape/pull/803), [#820](https://github.com/ruby-grape/grape/pull/820): Added `all_or_none_of` parameter validator - [@loveltyoic](https://github.com/loveltyoic), [@natecj](https://github.com/natecj).\n* [#774](https://github.com/ruby-grape/grape/pull/774): Extended `mutually_exclusive`, `exactly_one_of`, `at_least_one_of` to work inside any kind of group: `requires` or `optional`, `Hash` or `Array` - [@ShPakvel](https://github.com/ShPakvel).\n* [#743](https://github.com/ruby-grape/grape/pull/743): Added `allow_blank` parameter validator to validate non-empty strings - [@elado](https://github.com/elado).\n* [#745](https://github.com/ruby-grape/grape/pull/745): Removed `atom+xml`, `rss+xml`, and `jsonapi` content-types - [@akabraham](https://github.com/akabraham).\n* [#745](https://github.com/ruby-grape/grape/pull/745): Added `:binary, application/octet-stream` content-type - [@akabraham](https://github.com/akabraham).\n* [#757](https://github.com/ruby-grape/grape/pull/757): Changed `desc` can now be used with a block syntax - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#779](https://github.com/ruby-grape/grape/pull/779): Fixed using `values` with a `default` proc - [@ShPakvel](https://github.com/ShPakvel).\n* [#799](https://github.com/ruby-grape/grape/pull/799): Fixed custom validators with required `Hash`, `Array` types - [@bwalex](https://github.com/bwalex).\n* [#784](https://github.com/ruby-grape/grape/pull/784): Fixed `present` to not overwrite the previously added contents of the response body whebn called more than once - [@mfunaro](https://github.com/mfunaro).\n* [#809](https://github.com/ruby-grape/grape/pull/809): Removed automatic `(.:format)` suffix on paths if you're using only one format (e.g., with `format :json`, `/path` will respond with JSON but `/path.xml` will be a 404) - [@ajvondrak](https://github.com/ajvondrak).\n* [#816](https://github.com/ruby-grape/grape/pull/816): Added ability to filter out missing params if params is a nested hash with `declared(params, include_missing: false)` - [@georgimitev](https://github.com/georgimitev).\n* [#819](https://github.com/ruby-grape/grape/pull/819): Allowed both `desc` and `description` in the params DSL - [@mzikherman](https://github.com/mzikherman).\n* [#821](https://github.com/ruby-grape/grape/pull/821): Fixed passing string value when hash is expected in params - [@rebelact](https://github.com/rebelact).\n* [#824](https://github.com/ruby-grape/grape/pull/824): Validate array params against list of acceptable values - [@dnd](https://github.com/dnd).\n* [#813](https://github.com/ruby-grape/grape/pull/813): Routing methods dsl refactored to get rid of explicit `paths` parameter - [@AlexYankee](https://github.com/AlexYankee).\n* [#826](https://github.com/ruby-grape/grape/pull/826): Find `coerce_type` for `Array` when not specified - [@manovotn](https://github.com/manovotn).\n* [#645](https://github.com/ruby-grape/grape/issues/645): Invoking `body false` will return `204 No Content` - [@dblock](https://github.com/dblock).\n* [#801](https://github.com/ruby-grape/grape/issues/801): Only evaluate permitted parameter `values` and `default` lazily on each request when declared as a proc - [@dblock](https://github.com/dblock).\n* [#679](https://github.com/ruby-grape/grape/issues/679): Fixed `OPTIONS` method returning 404 when combined with `prefix` - [@dblock](https://github.com/dblock).\n* [#679](https://github.com/ruby-grape/grape/issues/679): Fixed unsupported methods returning 404 instead of 405 when combined with `prefix` - [@dblock](https://github.com/dblock).\n\n### 0.9.0 (8/27/2014)\n\n#### Features\n\n* [#691](https://github.com/ruby-grape/grape/issues/691): Added `at_least_one_of` parameter validator - [@dblock](https://github.com/dblock).\n* [#698](https://github.com/ruby-grape/grape/pull/698): `error!` sets `status` for `Endpoint` too - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Added support for Auth-Middleware extension - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Removed `Grape::Middleware::Auth::Basic` - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Removed `Grape::Middleware::Auth::Digest` - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Removed `Grape::Middleware::Auth::OAuth2` - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#719](https://github.com/ruby-grape/grape/pull/719): Allow passing options hash to a custom validator - [@elado](https://github.com/elado).\n* [#716](https://github.com/ruby-grape/grape/pull/716): Calling `content-type` will now return the current content-type - [@dblock](https://github.com/dblock).\n* [#705](https://github.com/ruby-grape/grape/pull/705): Errors can now be presented with a `Grape::Entity` class - [@dspaeth-faber](https://github.com/dspaeth-faber).\n\n#### Fixes\n\n* [#687](https://github.com/ruby-grape/grape/pull/687): Fix: `mutually_exclusive` and `exactly_one_of` validation error messages now label parameters as strings, consistently with `requires` and `optional` - [@dblock](https://github.com/dblock).\n\n### 0.8.0 (7/10/2014)\n\n#### Features\n\n* [#639](https://github.com/ruby-grape/grape/pull/639): Added support for blocks with reusable params - [@mibon](https://github.com/mibon).\n* [#637](https://github.com/ruby-grape/grape/pull/637): Added support for `exactly_one_of` parameter validation - [@Morred](https://github.com/Morred).\n* [#626](https://github.com/ruby-grape/grape/pull/626): Added support for `mutually_exclusive` parameters - [@oliverbarnes](https://github.com/oliverbarnes).\n* [#617](https://github.com/ruby-grape/grape/pull/617): Running tests on Ruby 2.1.1, Rubinius 2.1 and 2.2, Ruby and JRuby HEAD - [@dblock](https://github.com/dblock).\n* [#397](https://github.com/ruby-grape/grape/pull/397): Adds `Grape::Endpoint.before_each` to allow easy helper stubbing - [@mbleigh](https://github.com/mbleigh).\n* [#673](https://github.com/ruby-grape/grape/pull/673): Avoid requiring non-existent fields when using Grape::Entity documentation - [@qqshfox](https://github.com/qqshfox).\n\n#### Fixes\n\n* [#671](https://github.com/ruby-grape/grape/pull/671): Allow required param with predefined set of values to be nil inside optional group - [@dm1try](https://github.com/dm1try).\n* [#651](https://github.com/ruby-grape/grape/pull/651): The `rescue_from` keyword now properly defaults to rescuing subclasses of exceptions - [@xevix](https://github.com/xevix).\n* [#614](https://github.com/ruby-grape/grape/pull/614): Params with `nil` value are now refused by `RegexpValidator` - [@dm1try](https://github.com/dm1try).\n* [#494](https://github.com/ruby-grape/grape/issues/494): Fixed performance issue with requests carrying a large payload - [@dblock](https://github.com/dblock).\n* [#619](https://github.com/ruby-grape/grape/pull/619): Convert specs to RSpec 3 syntax with Transpec - [@danielspector](https://github.com/danielspector).\n* [#632](https://github.com/ruby-grape/grape/pull/632): `Grape::Endpoint#present` causes ActiveRecord to make an extra query during entity's detection - [@fixme](https://github.com/fixme).\n\n### 0.7.0 (4/2/2014)\n\n#### Features\n\n* [#558](https://github.com/ruby-grape/grape/pull/558): Support lambda-based values for params - [@wpschallenger](https://github.com/wpschallenger).\n* [#510](https://github.com/ruby-grape/grape/pull/510): Support lambda-based default values for params - [@myitcv](https://github.com/myitcv).\n* [#511](https://github.com/ruby-grape/grape/pull/511): Added `required` option for OAuth2 middleware - [@bcm](https://github.com/bcm).\n* [#520](https://github.com/ruby-grape/grape/pull/520): Use `default_error_status` to specify the default status code returned from `error!` - [@salimane](https://github.com/salimane).\n* [#525](https://github.com/ruby-grape/grape/pull/525): The default status code returned from `error!` has been changed from 403 to 500 - [@dblock](https://github.com/dblock).\n* [#526](https://github.com/ruby-grape/grape/pull/526): Allowed specifying headers in `error!` - [@dblock](https://github.com/dblock).\n* [#527](https://github.com/ruby-grape/grape/pull/527): The `before_validation` callback is now a distinct one - [@myitcv](https://github.com/myitcv).\n* [#530](https://github.com/ruby-grape/grape/pull/530): Added ability to restrict `declared(params)` to the local endpoint with `include_parent_namespaces: false` - [@myitcv](https://github.com/myitcv).\n* [#531](https://github.com/ruby-grape/grape/pull/531): Helpers are now available to auth middleware, executing in the context of the endpoint - [@joelvh](https://github.com/joelvh).\n* [#540](https://github.com/ruby-grape/grape/pull/540): Ruby 2.1.0 is now supported - [@salimane](https://github.com/salimane).\n* [#544](https://github.com/ruby-grape/grape/pull/544): The `rescue_from` keyword now handles subclasses of exceptions by default - [@xevix](https://github.com/xevix).\n* [#545](https://github.com/ruby-grape/grape/pull/545): Added `type` (`Array` or `Hash`) support to `requires`, `optional` and `group` - [@bwalex](https://github.com/bwalex).\n* [#550](https://github.com/ruby-grape/grape/pull/550): Added possibility to define reusable params - [@dm1try](https://github.com/dm1try).\n* [#560](https://github.com/ruby-grape/grape/pull/560): Use `Grape::Entity` documentation to define required and optional parameters with `requires using:` - [@reynardmh](https://github.com/reynardmh).\n* [#572](https://github.com/ruby-grape/grape/pull/572): Added `documentation` support to `requires`, `optional` and `group` parameters - [@johnallen3d](https://github.com/johnallen3d).\n\n#### Fixes\n\n* [#600](https://github.com/ruby-grape/grape/pull/600): Don't use an `Entity` constant that is available in the namespace as presenter - [@fuksito](https://github.com/fuksito).\n* [#590](https://github.com/ruby-grape/grape/pull/590): Fix issue where endpoint param of type `Integer` cannot set values array - [@xevix](https://github.com/xevix).\n* [#586](https://github.com/ruby-grape/grape/pull/586): Do not repeat the same validation error messages - [@kiela](https://github.com/kiela).\n* [#508](https://github.com/ruby-grape/grape/pull/508): Allow parameters, such as content encoding, in `content_type` - [@dm1try](https://github.com/dm1try).\n* [#492](https://github.com/ruby-grape/grape/pull/492): Don't allow to have nil value when a param is required and has a list of allowed values - [@Antti](https://github.com/Antti).\n* [#495](https://github.com/ruby-grape/grape/pull/495): Fixed `ParamsScope#params` for parameters nested inside arrays - [@asross](https://github.com/asross).\n* [#498](https://github.com/ruby-grape/grape/pull/498): Dry'ed up options and headers logic, allow headers to be passed to OPTIONS requests - [@karlfreeman](https://github.com/karlfreeman).\n* [#500](https://github.com/ruby-grape/grape/pull/500): Skip entity auto-detection when explicitely passed - [@yaneq](https://github.com/yaneq).\n* [#503](https://github.com/ruby-grape/grape/pull/503): Calling declared(params) from child namespace fails to include parent namespace defined params - [@myitcv](https://github.com/myitcv).\n* [#512](https://github.com/ruby-grape/grape/pull/512): Don't create `Grape::Request` multiple times - [@dblock](https://github.com/dblock).\n* [#538](https://github.com/ruby-grape/grape/pull/538): Fixed default values for grouped params - [@dm1try](https://github.com/dm1try).\n* [#549](https://github.com/ruby-grape/grape/pull/549): Fixed handling of invalid version headers to return 406 if a header cannot be parsed - [@bwalex](https://github.com/bwalex).\n* [#557](https://github.com/ruby-grape/grape/pull/557): Pass `content_types` option to `Grape::Middleware::Error` to fix the content-type header for custom formats - [@bernd](https://github.com/bernd).\n* [#585](https://github.com/ruby-grape/grape/pull/585): Fix after boot thread-safety issue - [@etehtsea](https://github.com/etehtsea).\n* [#587](https://github.com/ruby-grape/grape/pull/587): Fix oauth2 middleware compatibility with [draft-ietf-oauth-v2-31](http://tools.ietf.org/html/draft-ietf-oauth-v2-31) spec - [@etehtsea](https://github.com/etehtsea).\n* [#610](https://github.com/ruby-grape/grape/pull/610): Fixed group keyword was not working with type parameter - [@klausmeyer](https://github.com/klausmeyer).\n\n### 0.6.1 (10/19/2013)\n\n#### Features\n\n* [#475](https://github.com/ruby-grape/grape/pull/475): Added support for the `:jsonapi`, `application/vnd.api+json` media type registered at http://jsonapi.org - [@bcm](https://github.com/bcm).\n* [#471](https://github.com/ruby-grape/grape/issues/471): Added parameter validator for a list of allowed values - [@vickychijwani](https://github.com/vickychijwani).\n* [#488](https://github.com/ruby-grape/grape/issues/488): Upgraded to Virtus 1.0 - [@dblock](https://github.com/dblock).\n\n#### Fixes\n\n* [#477](https://github.com/ruby-grape/grape/pull/477): Fixed `default_error_formatter` which takes a format symbol - [@vad4msiu](https://github.com/vad4msiu).\n\n#### Development\n\n* Implemented Rubocop, a Ruby code static code analyzer - [@dblock](https://github.com/dblock).\n\n### 0.6.0 (9/16/2013)\n\n#### Features\n\n* Grape is no longer tested against Ruby 1.8.7 - [@dblock](https://github.com/dblock).\n* [#442](https://github.com/ruby-grape/grape/issues/442): Enable incrementally building on top of a previous API version - [@dblock](https://github.com/dblock).\n* [#442](https://github.com/ruby-grape/grape/issues/442): API `version` can now take an array of multiple versions - [@dblock](https://github.com/dblock).\n* [#444](https://github.com/ruby-grape/grape/issues/444): Added `:en` as fallback locale for I18n - [@aew](https://github.com/aew).\n* [#448](https://github.com/ruby-grape/grape/pull/448): Adding POST style parameters for DELETE requests - [@dquimper](https://github.com/dquimper).\n* [#450](https://github.com/ruby-grape/grape/pull/450): Added option to pass an exception handler lambda as an argument to `rescue_from` - [@robertopedroso](https://github.com/robertopedroso).\n* [#443](https://github.com/ruby-grape/grape/pull/443): Let `requires` and `optional` take blocks that initialize new scopes - [@asross](https://github.com/asross).\n* [#452](https://github.com/ruby-grape/grape/pull/452): Added `with` as a hash option to specify handlers for `rescue_from` and `error_formatter` - [@robertopedroso](https://github.com/robertopedroso).\n* [#433](https://github.com/ruby-grape/grape/issues/433), [#462](https://github.com/ruby-grape/grape/issues/462): Validation errors are now collected and `Grape::Exceptions::ValidationErrors` is raised - [@stevschmid](https://github.com/stevschmid).\n\n#### Fixes\n\n* [#428](https://github.com/ruby-grape/grape/issues/428): Removes memoization from `Grape::Request` params to prevent middleware from freezing parameter values before `Formatter` can get them - [@mbleigh](https://github.com/mbleigh).\n\n### 0.5.0 (6/14/2013)\n\n#### Features\n\n* [#344](https://github.com/ruby-grape/grape/pull/344): Added `parser :type, nil` which disables input parsing for a given content-type - [@dblock](https://github.com/dblock).\n* [#381](https://github.com/ruby-grape/grape/issues/381): Added `cascade false` option at API level to remove the `X-Cascade: true` header from the API response - [@dblock](https://github.com/dblock).\n* [#392](https://github.com/ruby-grape/grape/pull/392): Extracted headers and params from `Endpoint` to `Grape::Request` - [@niedhui](https://github.com/niedhui).\n* [#376](https://github.com/ruby-grape/grape/pull/376): Added `route_param`, syntax sugar for quick declaration of route parameters - [@mbleigh](https://github.com/mbleigh).\n* [#390](https://github.com/ruby-grape/grape/pull/390): Added default value for an `optional` parameter - [@oivoodoo](https://github.com/oivoodoo).\n* [#403](https://github.com/ruby-grape/grape/pull/403): Added support for versioning using the `Accept-Version` header - [@politician](https://github.com/politician).\n* [#407](https://github.com/ruby-grape/grape/issues/407): Specifying `default_format` will also set the default POST/PUT data parser to the given format - [@dblock](https://github.com/dblock).\n* [#241](https://github.com/ruby-grape/grape/issues/241): Present with multiple entities using an optional Symbol - [@niedhui](https://github.com/niedhui).\n\n#### Fixes\n\n* [#378](https://github.com/ruby-grape/grape/pull/378): Fix: stop rescuing all exceptions during formatting - [@kbarrette](https://github.com/kbarrette).\n* [#380](https://github.com/ruby-grape/grape/pull/380): Fix: `Formatter#read_body_input` when transfer encoding is chunked - [@paulnicholon](https://github.com/paulnicholson).\n* [#347](https://github.com/ruby-grape/grape/issues/347): Fix: handling non-hash body params - [@paulnicholon](https://github.com/paulnicholson).\n* [#394](https://github.com/ruby-grape/grape/pull/394): Fix: path version no longer overwrites a `version` parameter - [@tmornini](https://github.com/tmornini).\n* [#412](https://github.com/ruby-grape/grape/issues/412): Fix: specifying `content_type` will also override the selection of the data formatter - [@dblock](https://github.com/dblock).\n* [#383](https://github.com/ruby-grape/grape/issues/383): Fix: Mounted APIs aren't inheriting settings (including `before` and `after` filters) - [@seanmoon](https://github.com/seanmoon).\n* [#408](https://github.com/ruby-grape/grape/pull/408): Fix: Goliath passes request header keys as symbols not strings - [@bobek](https://github.com/bobek).\n* [#417](https://github.com/ruby-grape/grape/issues/417): Fix: Rails 4 does not rewind input, causes POSTed data to be empty - [@dblock](https://github.com/dblock).\n* [#423](https://github.com/ruby-grape/grape/pull/423): Fix: `Grape::Endpoint#declared` now correctly handles nested params (ie. declared with `group`) - [@jbarreneche](https://github.com/jbarreneche).\n* [#427](https://github.com/ruby-grape/grape/issues/427): Fix: `declared(params)` breaks when `params` contains array - [@timhabermaas](https://github.com/timhabermaas).\n\n### 0.4.1 (4/1/2013)\n\n* [#375](https://github.com/ruby-grape/grape/pull/375): Fix: throwing an `:error` inside a middleware doesn't respect the `format` settings - [@dblock](https://github.com/dblock).\n\n### 0.4.0 (3/17/2013)\n\n* [#356](https://github.com/ruby-grape/grape/pull/356): Fix: presenting collections other than `Array` (eg. `ActiveRecord::Relation`) - [@zimbatm](https://github.com/zimbatm).\n* [#352](https://github.com/ruby-grape/grape/pull/352): Fix: using `Rack::JSONP` with `Grape::Entity` responses - [@deckchair](https://github.com/deckchair).\n* [#347](https://github.com/ruby-grape/grape/issues/347): Grape will accept any valid JSON as PUT or POST, including strings, symbols and arrays - [@qqshfox](https://github.com/qqshfox), [@dblock](https://github.com/dblock).\n* [#347](https://github.com/ruby-grape/grape/issues/347): JSON format APIs always return valid JSON, eg. strings are now returned as `\"string\"` and no longer `string` - [@dblock](https://github.com/dblock).\n* Raw body input from POST and PUT requests (`env['rack.input'].read`) is now available in `api.request.input` - [@dblock](https://github.com/dblock).\n* Parsed body input from POST and PUT requests is now available in `api.request.body` - [@dblock](https://github.com/dblock).\n* [#343](https://github.com/ruby-grape/grape/pull/343): Fix: return `Content-Type: text/plain` with error 405 - [@gustavosaume](https://github.com/gustavosaume), [@wyattisimo](https://github.com/wyattisimo).\n* [#357](https://github.com/ruby-grape/grape/pull/357): Grape now requires Rack 1.3.0 or newer - [@jhecking](https://github.com/jhecking).\n* [#320](https://github.com/ruby-grape/grape/issues/320): API `namespace` now supports `requirements` - [@niedhui](https://github.com/niedhui).\n* [#353](https://github.com/ruby-grape/grape/issues/353): Revert to standard Ruby logger formatter, `require active_support/all` if you want old behavior - [@rhunter](https://github.com/rhunter), [@dblock](https://github.com/dblock).\n* Fix: `undefined method 'call' for nil:NilClass` for an API method implementation without a block, now returns an empty string - [@dblock](https://github.com/dblock).\n\n### 0.3.2 (2/28/2013)\n\n* [#355](https://github.com/ruby-grape/grape/issues/355): Relax dependency constraint on Hashie - [@reset](https://github.com/reset).\n\n### 0.3.1 (2/25/2013)\n\n* [#351](https://github.com/ruby-grape/grape/issues/351): Compatibility with Ruby 2.0 - [@mbleigh](https://github.com/mbleigh).\n\n### 0.3.0 (02/21/2013)\n\n* [#294](https://github.com/ruby-grape/grape/issues/294): Extracted `Grape::Entity` into a [grape-entity](https://github.com/agileanimal/grape-entity) gem - [@agileanimal](https://github.com/agileanimal).\n* [#340](https://github.com/ruby-grape/grape/pull/339), [#342](https://github.com/ruby-grape/grape/pull/342): Added `:cascade` option to `version` to allow disabling of rack/mount cascade behavior - [@dieb](https://github.com/dieb).\n* [#333](https://github.com/ruby-grape/grape/pull/333): Added support for validation of arrays in `params` - [@flyerhzm](https://github.com/flyerhzm).\n* [#306](https://github.com/ruby-grape/grape/issues/306): Added I18n support for all Grape exceptions - [@niedhui](https://github.com/niedhui).\n* [#309](https://github.com/ruby-grape/grape/pull/309): Added XML support to the entity presenter - [@johnnyiller](https://github.com/johnnyiller), [@dblock](https://github.com/dblock).\n* [#131](https://github.com/ruby-grape/grape/issues/131): Added instructions for Grape API reloading in Rails - [@jyn](https://github.com/jyn), [@dblock](https://github.com/dblock).\n* [#317](https://github.com/ruby-grape/grape/issues/317): Added `headers` that returns a hash of parsed HTTP request headers - [@dblock](https://github.com/dblock).\n* [#332](https://github.com/ruby-grape/grape/pull/332): `Grape::Exceptions::Validation` now contains full nested parameter names - [@alovak](https://github.com/alovak).\n* [#328](https://github.com/ruby-grape/grape/issues/328): API version can now be specified as both String and Symbol - [@dblock](https://github.com/dblock).\n* [#190](https://github.com/ruby-grape/grape/issues/190): When you add a `GET` route for a resource, a route for the `HEAD` method will also be added automatically. You can disable this behavior with `do_not_route_head!` - [@dblock](https://github.com/dblock).\n* Added `do_not_route_options!`, which disables the automatic creation of the `OPTIONS` route - [@dblock](https://github.com/dblock).\n* [#309](https://github.com/ruby-grape/grape/pull/309): An XML format API will return an error instead of returning a string representation of the response if the latter cannot be converted to XML - [@dblock](https://github.com/dblock).\n* A formatter that raises an exception will cause the API to return a 500 error - [@dblock](https://github.com/dblock).\n* [#322](https://github.com/ruby-grape/grape/issues/322): When returning a 406 status, Grape will include the requested format or content-type in the response body - [@dblock](https://github.com/dblock).\n* [#60](https://github.com/ruby-grape/grape/issues/60): Fix: mounting of a Grape API onto a path - [@dblock](https://github.com/dblock).\n* [#335](https://github.com/ruby-grape/grape/pull/335): Fix: request body parameters from a `PATCH` request not available in `params` - [@FreakenK](https://github.com/FreakenK).\n\n### 0.2.6 (01/11/2013)\n\n* Fix: support content-type with character set when parsing POST and PUT input - [@dblock](https://github.com/dblock).\n* Fix: CVE-2013-0175, multi_xml parse vulnerability, require multi_xml 0.5.2 - [@dblock](https://github.com/dblock).\n\n### 0.2.5 (01/10/2013)\n\n* Added support for custom parsers via `parser`, in addition to built-in multipart, JSON and XML parsers - [@dblock](https://github.com/dblock).\n* Removed `body_params`, data sent via a POST or PUT with a supported content-type is merged into `params` - [@dblock](https://github.com/dblock).\n* Setting `format` will automatically remove other content-types by calling `content_type` - [@dblock](https://github.com/dblock).\n* Setting `content_type` will prevent any input data other than the matching content-type or any Rack-supported form and parseable media types (`application/x-www-form-urlencoded`, `multipart/form-data`, `multipart/related` and `multipart/mixed`) from being parsed - [@dblock](https://github.com/dblock).\n* [#305](https://github.com/ruby-grape/grape/issues/305): Fix: presenting arrays of objects via `represent` or when auto-detecting an `Entity` constant in the objects being presented - [@brandonweiss](https://github.com/brandonweiss).\n* [#306](https://github.com/ruby-grape/grape/issues/306): Added i18n support for validation error messages - [@niedhui](https://github.com/niedhui).\n\n### 0.2.4 (01/06/2013)\n\n* [#297](https://github.com/ruby-grape/grape/issues/297): Added `default_error_formatter` - [@dblock](https://github.com/dblock).\n* [#297](https://github.com/ruby-grape/grape/issues/297): Setting `format` will automatically set `default_error_formatter` - [@dblock](https://github.com/dblock).\n* [#295](https://github.com/ruby-grape/grape/issues/295): Storing original API source block in endpoint's `source` attribute - [@dblock](https://github.com/dblock).\n* [#293](https://github.com/ruby-grape/grape/pull/293): Added options to `cookies.delete`, enables passing a path - [@inst](https://github.com/inst).\n* [#174](https://github.com/ruby-grape/grape/issues/174): The value of `env['PATH_INFO']` is no longer altered with `path` versioning - [@dblock](https://github.com/dblock).\n* [#296](https://github.com/ruby-grape/grape/issues/296): Fix: ArgumentError with default error formatter - [@dblock](https://github.com/dblock).\n* [#298](https://github.com/ruby-grape/grape/pull/298): Fix: subsequent calls to `body_params` would fail due to IO read - [@justinmcp](https://github.com/justinmcp).\n* [#301](https://github.com/ruby-grape/grape/issues/301): Fix: symbol memory leak in cookie and formatter middleware - [@dblock](https://github.com/dblock).\n* [#300](https://github.com/ruby-grape/grape/issues/300): Fix `Grape::API.routes` to include mounted api routes - [@aiwilliams](https://github.com/aiwilliams).\n* [#302](https://github.com/ruby-grape/grape/pull/302): Fix: removed redundant `autoload` entries - [@ugisozols](https://github.com/ugisozols).\n* [#172](https://github.com/ruby-grape/grape/issues/172): Fix: MultiJson deprecated methods warnings - [@dblock](https://github.com/dblock).\n* [#133](https://github.com/ruby-grape/grape/issues/133): Fix: header-based versioning with use of `prefix` - [@seanmoon](https://github.com/seanmoon), [@dblock](https://github.com/dblock).\n* [#280](https://github.com/ruby-grape/grape/issues/280): Fix: grouped parameters mangled in `route_params` hash - [@marcusg](https://github.com/marcusg), [@dblock](https://github.com/dblock).\n* [#304](https://github.com/ruby-grape/grape/issues/304): Fix: `present x, :with => Entity` returns class references with `format :json` - [@dblock](https://github.com/dblock).\n* [#196](https://github.com/ruby-grape/grape/issues/196): Fix: root requests don't work with `prefix` - [@dblock](https://github.com/dblock).\n\n### 0.2.3 (24/12/2012)\n\n* [#179](https://github.com/ruby-grape/grape/issues/178): Using `content_type` will remove all default content-types - [@dblock](https://github.com/dblock).\n* [#265](https://github.com/ruby-grape/grape/issues/264): Fix: Moved `ValidationError` into `Grape::Exceptions` - [@thepumpkin1979](https://github.com/thepumpkin1979).\n* [#269](https://github.com/ruby-grape/grape/pull/269): Fix: `LocalJumpError` will not be raised when using explict return in API methods - [@simulacre](https://github.com/simulacre).\n* [#86](https://github.com/ruby-grape/grape/issues/275): Fix Path-based versioning not recognizing `/` route - [@walski](https://github.com/walski).\n* [#273](https://github.com/ruby-grape/grape/pull/273): Disabled formatting via `serializable_hash` and added support for `format :serializable_hash` - [@dblock](https://github.com/dblock).\n* [#277](https://github.com/ruby-grape/grape/pull/277): Added a DSL to declare `formatter` in API settings - [@tim-vandecasteele](https://github.com/tim-vandecasteele).\n* [#284](https://github.com/ruby-grape/grape/pull/284): Added a DSL to declare `error_formatter` in API settings - [@dblock](https://github.com/dblock).\n* [#285](https://github.com/ruby-grape/grape/pull/285): Removed `error_format` from API settings, now matches request format - [@dblock](https://github.com/dblock).\n* [#290](https://github.com/ruby-grape/grape/pull/290): The default error format for XML is now `error/message` instead of `hash/error` - [@dpsk](https://github.com/dpsk).\n* [#44](https://github.com/ruby-grape/grape/issues/44): Pass `env` into formatters to enable templating - [@dblock](https://github.com/dblock).\n\n### 0.2.2 (12/10/2012)\n\n#### Features\n\n* [#201](https://github.com/ruby-grape/grape/pull/201), [#236](https://github.com/ruby-grape/grape/pull/236), [#221](https://github.com/ruby-grape/grape/pull/221): Added coercion and validations support to `params` DSL - [@schmurfy](https://github.com/schmurfy), [@tim-vandecasteele](https://github.com/tim-vandecasteele), [@adamgotterer](https://github.com/adamgotterer).\n* [#204](https://github.com/ruby-grape/grape/pull/204): Added ability to declare shared `params` at `namespace` level - [@tim-vandecasteele](https://github.com/tim-vandecasteele).\n* [#234](https://github.com/ruby-grape/grape/pull/234): Added a DSL for creating entities via mixin - [@mbleigh](https://github.com/mbleigh).\n* [#240](https://github.com/ruby-grape/grape/pull/240): Define API response format from a query string `format` parameter, if specified - [@neetiraj](https://github.com/neetiraj).\n* Adds Endpoint#declared to easily filter out unexpected params - [@mbleigh](https://github.com/mbleigh).\n\n#### Fixes\n\n* [#248](https://github.com/ruby-grape/grape/pull/248): Fix: API `version` returns last version set - [@narkoz](https://github.com/narkoz).\n* [#242](https://github.com/ruby-grape/grape/issues/242): Fix: permanent redirect status should be `301`, was `304` - [@adamgotterer](https://github.com/adamgotterer).\n* [#211](https://github.com/ruby-grape/grape/pull/211): Fix: custom validations are no longer triggered when optional and parameter is not present - [@adamgotterer](https://github.com/adamgotterer).\n* [#210](https://github.com/ruby-grape/grape/pull/210): Fix: `Endpoint#body_params` causing undefined method 'size' - [@adamgotterer](https://github.com/adamgotterer).\n* [#205](https://github.com/ruby-grape/grape/pull/205): Fix: Corrected parsing of empty JSON body on POST/PUT - [@tim-vandecasteele](https://github.com/tim-vandecasteele).\n* [#181](https://github.com/ruby-grape/grape/pull/181): Fix: Corrected JSON serialization of nested hashes containing `Grape::Entity` instances - [@benrosenblum](https://github.com/benrosenblum).\n* [#203](https://github.com/ruby-grape/grape/pull/203): Added a check to `Entity#serializable_hash` that verifies an entity exists on an object - [@adamgotterer](https://github.com/adamgotterer).\n* [#208](https://github.com/ruby-grape/grape/pull/208): `Entity#serializable_hash` must also check if attribute is generated by a user supplied block - [@ppadron](https://github.com/ppadron).\n* [#252](https://github.com/ruby-grape/grape/pull/252): Resources that don't respond to a requested HTTP method return 405 (Method Not Allowed) instead of 404 (Not Found) - [@simulacre](https://github.com/simulacre).\n\n### 0.2.1 (7/11/2012)\n\n* [#186](https://github.com/ruby-grape/grape/issues/186): Fix: helpers allow multiple calls with modules and blocks - [@ppadron](https://github.com/ppadron).\n* [#188](https://github.com/ruby-grape/grape/pull/188): Fix: multi-method routes append '(.:format)' only once - [@kainosnoema](https://github.com/kainosnoema).\n* [#64](https://github.com/ruby-grape/grape/issues/64), [#180](https://github.com/ruby-grape/grape/pull/180): Added support to `GET` request bodies as parameters - [@bobbytables](https://github.com/bobbytables).\n* [#175](https://github.com/ruby-grape/grape/pull/175): Added support for API versioning based on a request parameter - [@jackcasey](https://github.com/jackcasey).\n* [#168](https://github.com/ruby-grape/grape/pull/168): Fix: Formatter can parse symbol keys in the headers hash - [@netmask](https://github.com/netmask).\n* [#169](https://github.com/ruby-grape/grape/pull/169): Silence multi_json deprecation warnings - [@whiteley](https://github.com/whiteley).\n* [#166](https://github.com/ruby-grape/grape/pull/166): Added support for `redirect`, including permanent and temporary - [@allenwei](https://github.com/allenwei).\n* [#159](https://github.com/ruby-grape/grape/pull/159): Added `:requirements` to routes, allowing to use reserved characters in paths - [@gaiottino](https://github.com/gaiottino).\n* [#156](https://github.com/ruby-grape/grape/pull/156): Added support for adding formatters to entities - [@bobbytables](https://github.com/bobbytables).\n* [#183](https://github.com/ruby-grape/grape/pull/183): Added ability to include documentation in entities - [@flah00](https://github.com/flah00).\n* [#189](https://github.com/ruby-grape/grape/pull/189): `HEAD` requests no longer return a body - [@stephencelis](https://github.com/stephencelis).\n* [#97](https://github.com/ruby-grape/grape/issues/97): Allow overriding `Content-Type` - [@dblock](https://github.com/dblock).\n\n### 0.2.0 (3/28/2012)\n\n* Added support for inheriting exposures from entities - [@bobbytables](https://github.com/bobbytables).\n* Extended formatting with `default_format` - [@dblock](https://github.com/dblock).\n* Added support for cookies - [@lukaszsliwa](https://github.com/lukaszsliwa).\n* Added support for declaring additional content-types - [@joeyAghion](https://github.com/joeyAghion).\n* Added support for HTTP PATCH - [@LTe](https://github.com/LTe).\n* Added support for describing, documenting and reflecting APIs - [@dblock](https://github.com/dblock).\n* Added support for anchoring and vendoring - [@jwkoelewijn](https://github.com/jwkoelewijn).\n* Added support for HTTP OPTIONS - [@grimen](https://github.com/grimen).\n* Added support for silencing logger - [@evansj](https://github.com/evansj).\n* Added support for helper modules - [@freelancing-god](https://github.com/freelancing-god).\n* Added support for Accept header-based versioning - [@jch](https://github.com/jch), [@rodzyn](https://github.com/rodzyn).\n* Added support for mounting APIs and other Rack applications within APIs - [@mbleigh](https://github.com/mbleigh).\n* Added entities, multiple object representations - [@mbleigh](https://github.com/mbleigh).\n* Added ability to handle XML in the incoming request body - [@jwillis](https://github.com/jwillis).\n* Added support for a configurable logger - [@mbleigh](https://github.com/mbleigh).\n* Added support for before and after filters - [@mbleigh](https://github.com/mbleigh).\n* Extended `rescue_from`, which can now take a block - [@dblock](https://github.com/dblock).\n\n### 0.1.5 (6/14/2011)\n\n* Extended exception handling to all exceptions - [@dblock](https://github.com/dblock).\n* Added support for returning JSON objects from within error blocks - [@dblock](https://github.com/dblock).\n* Added support for handling incoming JSON in body - [@tedkulp](https://github.com/tedkulp).\n* Added support for HTTP digest authentication - [@daddz](https://github.com/daddz).\n\n### 0.1.4 (4/8/2011)\n\n* Allow multiple definitions of the same endpoint under multiple versions - [@chrisrhoden](https://github.com/chrisrhoden).\n* Added support for multipart URL parameters - [@mcastilho](https://github.com/mcastilho).\n* Added support for custom formatters - [@spraints](https://github.com/spraints).\n\n### 0.1.3 (1/10/2011)\n\n* Added support for JSON format in route matching - [@aiwilliams](https://github.com/aiwilliams).\n* Added suport for custom middleware - [@mbleigh](https://github.com/mbleigh).\n\n### 0.1.1 (11/14/2010)\n\n* Endpoints properly reset between each request - [@mbleigh](https://github.com/mbleigh).\n\n### 0.1.0 (11/13/2010)\n\n* Initial public release - [@mbleigh](https://github.com/mbleigh).\n", "require 'grape/middleware/base'\n\nmodule Grape\n  module Middleware\n    class Error < Base\n      def default_options\n        {\n          default_status: 500, # default status returned on error\n          default_message: '',\n          format: :txt,\n          helpers: nil,\n          formatters: {},\n          error_formatters: {},\n          rescue_all: false, # true to rescue all exceptions\n          rescue_grape_exceptions: false,\n          rescue_subclasses: true, # rescue subclasses of exceptions listed\n          rescue_options: {\n            backtrace: false, # true to display backtrace, true to let Grape handle Grape::Exceptions\n            original_exception: false, # true to display exception\n          },\n          rescue_handlers: {}, # rescue handler blocks\n          base_only_rescue_handlers: {}, # rescue handler blocks rescuing only the base class\n          all_rescue_handler: nil # rescue handler block to rescue from all exceptions\n        }\n      end\n\n      def initialize(app, **options)\n        super\n        self.class.send(:include, @options[:helpers]) if @options[:helpers]\n      end\n\n      def call!(env)\n        @env = env\n\n        begin\n          error_response(catch(:error) do\n            return @app.call(@env)\n          end)\n        rescue Exception => error # rubocop:disable Lint/RescueException\n          handler =\n            rescue_handler_for_base_only_class(error.class) ||\n            rescue_handler_for_class_or_its_ancestor(error.class) ||\n            rescue_handler_for_grape_exception(error.class) ||\n            rescue_handler_for_any_class(error.class) ||\n            raise\n\n          run_rescue_handler(handler, error)\n        end\n      end\n\n      def error!(message, status = options[:default_status], headers = {}, backtrace = [], original_exception = nil)\n        headers = headers.reverse_merge(Grape::Http::Headers::CONTENT_TYPE => content_type)\n        rack_response(format_message(message, backtrace, original_exception), status, headers)\n      end\n\n      def default_rescue_handler(e)\n        error_response(message: e.message, backtrace: e.backtrace, original_exception: e)\n      end\n\n      # TODO: This method is deprecated. Refactor out.\n      def error_response(error = {})\n        status = error[:status] || options[:default_status]\n        message = error[:message] || options[:default_message]\n        headers = { Grape::Http::Headers::CONTENT_TYPE => content_type }\n        headers.merge!(error[:headers]) if error[:headers].is_a?(Hash)\n        backtrace = error[:backtrace] || error[:original_exception] && error[:original_exception].backtrace || []\n        original_exception = error.is_a?(Exception) ? error : error[:original_exception] || nil\n        rack_response(format_message(message, backtrace, original_exception), status, headers)\n      end\n\n      def rack_response(message, status = options[:default_status], headers = { Grape::Http::Headers::CONTENT_TYPE => content_type })\n        Rack::Response.new([message], status, headers).finish\n      end\n\n      def format_message(message, backtrace, original_exception = nil)\n        format = env[Grape::Env::API_FORMAT] || options[:format]\n        formatter = Grape::ErrorFormatter.formatter_for(format, options)\n        throw :error,\n              status: 406,\n              message: \"The requested format '#{format}' is not supported.\",\n              backtrace: backtrace,\n              original_exception: original_exception unless formatter\n        formatter.call(message, backtrace, options, env, original_exception)\n      end\n\n      private\n\n      def rescue_handler_for_base_only_class(klass)\n        error, handler = options[:base_only_rescue_handlers].find { |err, _handler| klass == err }\n\n        return unless error\n\n        handler || :default_rescue_handler\n      end\n\n      def rescue_handler_for_class_or_its_ancestor(klass)\n        error, handler = options[:rescue_handlers].find { |err, _handler| klass <= err }\n\n        return unless error\n\n        handler || :default_rescue_handler\n      end\n\n      def rescue_handler_for_grape_exception(klass)\n        return unless klass <= Grape::Exceptions::Base\n        return :error_response if klass == Grape::Exceptions::InvalidVersionHeader\n        return unless options[:rescue_grape_exceptions] || !options[:rescue_all]\n\n        :error_response\n      end\n\n      def rescue_handler_for_any_class(klass)\n        return unless klass <= StandardError\n        return unless options[:rescue_all] || options[:rescue_grape_exceptions]\n\n        options[:all_rescue_handler] || :default_rescue_handler\n      end\n\n      def run_rescue_handler(handler, error)\n        if handler.instance_of?(Symbol)\n          raise NoMethodError, \"undefined method `#{handler}'\" unless respond_to?(handler)\n\n          handler = public_method(handler)\n        end\n\n        handler.arity.zero? ? instance_exec(&handler) : instance_exec(error, &handler)\n      end\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'shared/versioning_examples'\n\ndescribe Grape::API do\n  subject { Class.new(Grape::API) }\n\n  def app\n    subject\n  end\n\n  describe '.prefix' do\n    it 'routes root through with the prefix' do\n      subject.prefix 'awesome/sauce'\n      subject.get do\n        'Hello there.'\n      end\n\n      get 'awesome/sauce/'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'Hello there.'\n    end\n\n    it 'routes through with the prefix' do\n      subject.prefix 'awesome/sauce'\n      subject.get :hello do\n        'Hello there.'\n      end\n\n      get 'awesome/sauce/hello'\n      expect(last_response.body).to eql 'Hello there.'\n\n      get '/hello'\n      expect(last_response.status).to eql 404\n    end\n\n    it 'supports OPTIONS' do\n      subject.prefix 'awesome/sauce'\n      subject.get do\n        'Hello there.'\n      end\n\n      options 'awesome/sauce'\n      expect(last_response.status).to eql 204\n      expect(last_response.body).to be_blank\n    end\n\n    it 'disallows POST' do\n      subject.prefix 'awesome/sauce'\n      subject.get\n\n      post 'awesome/sauce'\n      expect(last_response.status).to eql 405\n    end\n  end\n\n  describe '.version' do\n    context 'when defined' do\n      it 'returns version value' do\n        subject.version 'v1'\n        expect(subject.version).to eq('v1')\n      end\n    end\n\n    context 'when not defined' do\n      it 'returns nil' do\n        expect(subject.version).to be_nil\n      end\n    end\n  end\n\n  describe '.version using path' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :path\n        }\n      end\n    end\n  end\n\n  describe '.version using param' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :param,\n          parameter: 'apiver'\n        }\n      end\n    end\n  end\n\n  describe '.version using header' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :header,\n          vendor: 'mycompany',\n          format: 'json'\n        }\n      end\n    end\n\n    # Behavior as defined by rfc2616 when no header is defined\n    # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\n    describe 'no specified accept header' do\n      # subject.version 'v1', using: :header\n      # subject.get '/hello' do\n      #   'hello'\n      # end\n\n      # it 'routes' do\n      #   get '/hello'\n      #   last_response.status.should eql 200\n      # end\n    end\n\n    # pending 'routes if any media type is allowed'\n  end\n\n  describe '.version using accept_version_header' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :accept_version_header\n        }\n      end\n    end\n  end\n\n  describe '.represent' do\n    it 'requires a :with option' do\n      expect { subject.represent Object, {} }.to raise_error(Grape::Exceptions::InvalidWithOptionForRepresent)\n    end\n\n    it 'adds the association to the :representations setting' do\n      klass = Class.new\n      subject.represent Object, with: klass\n      expect(subject.namespace_stackable_with_hash(:representations)[Object]).to eq(klass)\n    end\n  end\n\n  describe '.namespace' do\n    it 'is retrievable and converted to a path' do\n      internal_namespace = nil\n      subject.namespace :awesome do\n        internal_namespace = namespace\n      end\n      expect(internal_namespace).to eql('/awesome')\n    end\n\n    it 'comes after the prefix and version' do\n      subject.prefix :rad\n      subject.version 'v1', using: :path\n\n      subject.namespace :awesome do\n        get('/hello') { 'worked' }\n      end\n\n      get '/rad/v1/awesome/hello'\n      expect(last_response.body).to eq('worked')\n    end\n\n    it 'cancels itself after the block is over' do\n      internal_namespace = nil\n      subject.namespace :awesome do\n        internal_namespace = namespace\n      end\n      expect(subject.namespace).to eql('/')\n    end\n\n    it 'is stackable' do\n      internal_namespace = nil\n      internal_second_namespace = nil\n      subject.namespace :awesome do\n        internal_namespace = namespace\n        namespace :rad do\n          internal_second_namespace = namespace\n        end\n      end\n      expect(internal_namespace).to eq('/awesome')\n      expect(internal_second_namespace).to eq('/awesome/rad')\n    end\n\n    it 'accepts path segments correctly' do\n      inner_namespace = nil\n      subject.namespace :members do\n        namespace '/:member_id' do\n          inner_namespace = namespace\n          get '/' do\n            params[:member_id]\n          end\n        end\n      end\n      get '/members/23'\n      expect(last_response.body).to eq('23')\n      expect(inner_namespace).to eq('/members/:member_id')\n    end\n\n    it 'is callable with nil just to push onto the stack' do\n      subject.namespace do\n        version 'v2', using: :path\n        get('/hello') { 'inner' }\n      end\n      subject.get('/hello') { 'outer' }\n\n      get '/v2/hello'\n      expect(last_response.body).to eq('inner')\n      get '/hello'\n      expect(last_response.body).to eq('outer')\n    end\n\n    %w[group resource resources segment].each do |als|\n      it \"`.#{als}` is an alias\" do\n        inner_namespace = nil\n        subject.send(als, :awesome) do\n          inner_namespace = namespace\n        end\n        expect(inner_namespace).to eq '/awesome'\n      end\n    end\n  end\n\n  describe '.route_param' do\n    it 'adds a parameterized route segment namespace' do\n      subject.namespace :users do\n        route_param :id do\n          get do\n            params[:id]\n          end\n        end\n      end\n\n      get '/users/23'\n      expect(last_response.body).to eq('23')\n    end\n\n    it 'defines requirements with a single hash' do\n      subject.namespace :users do\n        route_param :id, requirements: /[0-9]+/ do\n          get do\n            params[:id]\n          end\n        end\n      end\n\n      get '/users/michael'\n      expect(last_response.status).to eq(404)\n      get '/users/23'\n      expect(last_response.status).to eq(200)\n    end\n\n    context 'with param type definitions' do\n      it 'is used by passing to options' do\n        subject.namespace :route_param do\n          route_param :foo, type: Integer do\n            get { params.to_json }\n          end\n        end\n        get '/route_param/1234'\n        expect(last_response.body).to eq('{\"foo\":1234}')\n      end\n    end\n  end\n\n  describe '.route' do\n    it 'allows for no path' do\n      subject.namespace :votes do\n        get do\n          'Votes'\n        end\n        post do\n          'Created a Vote'\n        end\n      end\n\n      get '/votes'\n      expect(last_response.body).to eql 'Votes'\n      post '/votes'\n      expect(last_response.body).to eql 'Created a Vote'\n    end\n\n    it 'handles empty calls' do\n      subject.get '/'\n      get '/'\n      expect(last_response.body).to eql ''\n    end\n\n    describe 'root routes should work with' do\n      before do\n        subject.format :txt\n        subject.content_type :json, 'application/json'\n        subject.formatter :json, ->(object, _env) { object }\n        def subject.enable_root_route!\n          get('/') { 'root' }\n        end\n      end\n\n      after do\n        expect(last_response.body).to eql 'root'\n      end\n\n      describe 'path versioned APIs' do\n        before do\n          subject.version version, using: :path\n          subject.enable_root_route!\n        end\n\n        context 'when a single version provided' do\n          let(:version) { 'v1' }\n\n          it 'without a format' do\n            versioned_get '/', 'v1', using: :path\n          end\n\n          it 'with a format' do\n            get '/v1/.json'\n          end\n        end\n\n        context 'when array of versions provided' do\n          let(:version) { %w[v1 v2] }\n\n          it { versioned_get '/', 'v1', using: :path }\n          it { versioned_get '/', 'v2', using: :path }\n        end\n      end\n\n      it 'header versioned APIs' do\n        subject.version 'v1', using: :header, vendor: 'test'\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :header, vendor: 'test'\n      end\n\n      it 'header versioned APIs with multiple headers' do\n        subject.version %w[v1 v2], using: :header, vendor: 'test'\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :header, vendor: 'test'\n        versioned_get '/', 'v2', using: :header, vendor: 'test'\n      end\n\n      it 'param versioned APIs' do\n        subject.version 'v1', using: :param\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :param\n      end\n\n      it 'Accept-Version header versioned APIs' do\n        subject.version 'v1', using: :accept_version_header\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :accept_version_header\n      end\n\n      it 'unversioned APIs' do\n        subject.enable_root_route!\n\n        get '/'\n      end\n    end\n\n    it 'allows for multiple paths' do\n      subject.get(['/abc', '/def']) do\n        'foo'\n      end\n\n      get '/abc'\n      expect(last_response.body).to eql 'foo'\n      get '/def'\n      expect(last_response.body).to eql 'foo'\n    end\n\n    context 'format' do\n      module ApiSpec\n        class DummyFormatClass\n        end\n      end\n\n      before(:each) do\n        allow_any_instance_of(ApiSpec::DummyFormatClass).to receive(:to_json).and_return('abc')\n        allow_any_instance_of(ApiSpec::DummyFormatClass).to receive(:to_txt).and_return('def')\n\n        subject.get('/abc') do\n          ApiSpec::DummyFormatClass.new\n        end\n      end\n\n      it 'allows .json' do\n        get '/abc.json'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eql 'abc' # json-encoded symbol\n      end\n\n      it 'allows .txt' do\n        get '/abc.txt'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eql 'def' # raw text\n      end\n    end\n\n    it 'allows for format without corrupting a param' do\n      subject.get('/:id') do\n        { 'id' => params[:id] }\n      end\n\n      get '/awesome.json'\n      expect(last_response.body).to eql '{\"id\":\"awesome\"}'\n    end\n\n    it 'allows for format in namespace with no path' do\n      subject.namespace :abc do\n        get do\n          ['json']\n        end\n      end\n\n      get '/abc.json'\n      expect(last_response.body).to eql '[\"json\"]'\n    end\n\n    it 'allows for multiple verbs' do\n      subject.route(%i[get post], '/abc') do\n        'hiya'\n      end\n\n      subject.endpoints.first.routes.each do |route|\n        expect(route.path).to eql '/abc(.:format)'\n      end\n\n      get '/abc'\n      expect(last_response.body).to eql 'hiya'\n      post '/abc'\n      expect(last_response.body).to eql 'hiya'\n    end\n\n    %i[put post].each do |verb|\n      context verb do\n        ['string', :symbol, 1, -1.1, {}, [], true, false, nil].each do |object|\n          it \"allows a(n) #{object.class} json object in params\" do\n            subject.format :json\n            subject.send(verb) do\n              env['api.request.body']\n            end\n            send verb, '/', ::Grape::Json.dump(object), 'CONTENT_TYPE' => 'application/json'\n            expect(last_response.status).to eq(verb == :post ? 201 : 200)\n            expect(last_response.body).to eql ::Grape::Json.dump(object)\n            expect(last_request.params).to eql({})\n          end\n          it 'stores input in api.request.input' do\n            subject.format :json\n            subject.send(verb) do\n              env['api.request.input']\n            end\n            send verb, '/', ::Grape::Json.dump(object), 'CONTENT_TYPE' => 'application/json'\n            expect(last_response.status).to eq(verb == :post ? 201 : 200)\n            expect(last_response.body).to eql ::Grape::Json.dump(object).to_json\n          end\n          context 'chunked transfer encoding' do\n            it 'stores input in api.request.input' do\n              subject.format :json\n              subject.send(verb) do\n                env['api.request.input']\n              end\n              send verb, '/', ::Grape::Json.dump(object), 'CONTENT_TYPE' => 'application/json', 'HTTP_TRANSFER_ENCODING' => 'chunked', 'CONTENT_LENGTH' => nil\n              expect(last_response.status).to eq(verb == :post ? 201 : 200)\n              expect(last_response.body).to eql ::Grape::Json.dump(object).to_json\n            end\n          end\n        end\n      end\n    end\n\n    it 'allows for multipart paths' do\n      subject.route(%i[get post], '/:id/first') do\n        'first'\n      end\n\n      subject.route(%i[get post], '/:id') do\n        'ola'\n      end\n      subject.route(%i[get post], '/:id/first/second') do\n        'second'\n      end\n\n      get '/1'\n      expect(last_response.body).to eql 'ola'\n      post '/1'\n      expect(last_response.body).to eql 'ola'\n      get '/1/first'\n      expect(last_response.body).to eql 'first'\n      post '/1/first'\n      expect(last_response.body).to eql 'first'\n      get '/1/first/second'\n      expect(last_response.body).to eql 'second'\n    end\n\n    it 'allows for :any as a verb' do\n      subject.route(:any, '/abc') do\n        'lol'\n      end\n\n      %w[get post put delete options patch].each do |m|\n        send(m, '/abc')\n        expect(last_response.body).to eql 'lol'\n      end\n    end\n\n    it 'allows for catch-all in a namespace' do\n      subject.namespace :nested do\n        get do\n          'root'\n        end\n\n        get 'something' do\n          'something'\n        end\n\n        route :any, '*path' do\n          'catch-all'\n        end\n      end\n\n      get 'nested'\n      expect(last_response.body).to eql 'root'\n\n      get 'nested/something'\n      expect(last_response.body).to eql 'something'\n\n      get 'nested/missing'\n      expect(last_response.body).to eql 'catch-all'\n\n      post 'nested'\n      expect(last_response.body).to eql 'catch-all'\n\n      post 'nested/something'\n      expect(last_response.body).to eql 'catch-all'\n    end\n\n    verbs = %w[post get head delete put options patch]\n    verbs.each do |verb|\n      it \"allows and properly constrain a #{verb.upcase} method\" do\n        subject.send(verb, '/example') do\n          verb\n        end\n        send(verb, '/example')\n        expect(last_response.body).to eql verb == 'head' ? '' : verb\n        # Call it with all methods other than the properly constrained one.\n        (verbs - [verb]).each do |other_verb|\n          send(other_verb, '/example')\n          expected_rc = if other_verb == 'options' then 204\n                        elsif other_verb == 'head' && verb == 'get' then 200\n                        else 405\n                        end\n          expect(last_response.status).to eql expected_rc\n        end\n      end\n    end\n\n    it 'returns a 201 response code for POST by default' do\n      subject.post('example') do\n        'Created'\n      end\n\n      post '/example'\n      expect(last_response.status).to eql 201\n      expect(last_response.body).to eql 'Created'\n    end\n\n    it 'returns a 405 for an unsupported method with an X-Custom-Header' do\n      subject.before { header 'X-Custom-Header', 'foo' }\n      subject.get 'example' do\n        'example'\n      end\n      put '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.body).to eql '405 Not Allowed'\n      expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n    end\n\n    it 'runs only the before filter on 405 bad method' do\n      subject.namespace :example do\n        before            { header 'X-Custom-Header', 'foo' }\n        before_validation { raise 'before_validation filter should not run' }\n        after_validation  { raise 'after_validation filter should not run' }\n        after             { raise 'after filter should not run' }\n        params { requires :only_for_get }\n        get\n      end\n\n      post '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n    end\n\n    it 'runs before filter exactly once on 405 bad method' do\n      already_run = false\n      subject.namespace :example do\n        before do\n          raise 'before filter ran twice' if already_run\n          already_run = true\n          header 'X-Custom-Header', 'foo'\n        end\n        get\n      end\n\n      post '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n    end\n\n    it 'runs all filters and body with a custom OPTIONS method' do\n      subject.namespace :example do\n        before            { header 'X-Custom-Header-1', 'foo' }\n        before_validation { header 'X-Custom-Header-2', 'foo' }\n        after_validation  { header 'X-Custom-Header-3', 'foo' }\n        after             { header 'X-Custom-Header-4', 'foo' }\n        options { 'yup' }\n        get\n      end\n\n      options '/example'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'yup'\n      expect(last_response.headers['Allow']).to be_nil\n      expect(last_response.headers['X-Custom-Header-1']).to eql 'foo'\n      expect(last_response.headers['X-Custom-Header-2']).to eql 'foo'\n      expect(last_response.headers['X-Custom-Header-3']).to eql 'foo'\n      expect(last_response.headers['X-Custom-Header-4']).to eql 'foo'\n    end\n\n    context 'when format is xml' do\n      it 'returns a 405 for an unsupported method' do\n        subject.format :xml\n        subject.get 'example' do\n          'example'\n        end\n\n        put '/example'\n        expect(last_response.status).to eql 405\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error>\n  <message>405 Not Allowed</message>\n</error>\nXML\n      end\n    end\n\n    context 'when accessing env' do\n      it 'returns a 405 for an unsupported method' do\n        subject.before do\n          _customheader1 = headers['X-Custom-Header']\n          _customheader2 = env['HTTP_X_CUSTOM_HEADER']\n        end\n        subject.get 'example' do\n          'example'\n        end\n        put '/example'\n        expect(last_response.status).to eql 405\n        expect(last_response.body).to eql '405 Not Allowed'\n      end\n    end\n\n    specify '405 responses includes an Allow header specifying supported methods' do\n      subject.get 'example' do\n        'example'\n      end\n      subject.post 'example' do\n        'example'\n      end\n      put '/example'\n      expect(last_response.headers['Allow']).to eql 'OPTIONS, GET, POST, HEAD'\n    end\n\n    specify '405 responses includes an Content-Type header' do\n      subject.get 'example' do\n        'example'\n      end\n      subject.post 'example' do\n        'example'\n      end\n      put '/example'\n      expect(last_response.headers['Content-Type']).to eql 'text/plain'\n    end\n\n    describe 'adds an OPTIONS route that' do\n      before do\n        subject.before            { header 'X-Custom-Header', 'foo' }\n        subject.before_validation { header 'X-Custom-Header-2', 'bar' }\n        subject.after_validation  { header 'X-Custom-Header-3', 'baz' }\n        subject.after             { header 'X-Custom-Header-4', 'bing' }\n        subject.params { requires :only_for_get }\n        subject.get 'example' do\n          'example'\n        end\n        subject.route :any, '*path' do\n          error! :not_found, 404\n        end\n        options '/example'\n      end\n\n      it 'returns a 204' do\n        expect(last_response.status).to eql 204\n      end\n\n      it 'has an empty body' do\n        expect(last_response.body).to be_blank\n      end\n\n      it 'has an Allow header' do\n        expect(last_response.headers['Allow']).to eql 'OPTIONS, GET, HEAD'\n      end\n\n      it 'calls before hook' do\n        expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n      end\n\n      it 'does not call before_validation hook' do\n        expect(last_response.headers.key?('X-Custom-Header-2')).to be false\n      end\n\n      it 'does not call after_validation hook' do\n        expect(last_response.headers.key?('X-Custom-Header-3')).to be false\n      end\n\n      it 'calls after hook' do\n        expect(last_response.headers['X-Custom-Header-4']).to eq 'bing'\n      end\n\n      it 'has no Content-Type' do\n        expect(last_response.content_type).to be_nil\n      end\n\n      it 'has no Content-Length' do\n        expect(last_response.content_length).to be_nil\n      end\n    end\n\n    describe 'adds an OPTIONS route for namespaced endpoints that' do\n      before do\n        subject.before { header 'X-Custom-Header', 'foo' }\n        subject.namespace :example do\n          before { header 'X-Custom-Header-2', 'foo' }\n          get :inner do\n            'example/inner'\n          end\n        end\n        options '/example/inner'\n      end\n\n      it 'returns a 204' do\n        expect(last_response.status).to eql 204\n      end\n\n      it 'has an empty body' do\n        expect(last_response.body).to be_blank\n      end\n\n      it 'has an Allow header' do\n        expect(last_response.headers['Allow']).to eql 'OPTIONS, GET, HEAD'\n      end\n\n      it 'calls the outer before filter' do\n        expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n      end\n\n      it 'calls the inner before filter' do\n        expect(last_response.headers['X-Custom-Header-2']).to eql 'foo'\n      end\n\n      it 'has no Content-Type' do\n        expect(last_response.content_type).to be_nil\n      end\n\n      it 'has no Content-Length' do\n        expect(last_response.content_length).to be_nil\n      end\n    end\n\n    describe 'adds a 405 Not Allowed route that' do\n      before do\n        subject.before { header 'X-Custom-Header', 'foo' }\n        subject.post :example do\n          'example'\n        end\n        get '/example'\n      end\n\n      it 'returns a 405' do\n        expect(last_response.status).to eql 405\n      end\n\n      it 'contains error message in body' do\n        expect(last_response.body).to eq '405 Not Allowed'\n      end\n\n      it 'has an Allow header' do\n        expect(last_response.headers['Allow']).to eql 'OPTIONS, POST'\n      end\n\n      it 'has a X-Custom-Header' do\n        expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n      end\n    end\n\n    context 'allows HEAD on a GET request that' do\n      before do\n        subject.get 'example' do\n          'example'\n        end\n        subject.route :any, '*path' do\n          error! :not_found, 404\n        end\n        head '/example'\n      end\n\n      it 'returns a 200' do\n        expect(last_response.status).to eql 200\n      end\n\n      it 'has an empty body' do\n        expect(last_response.body).to eql ''\n      end\n    end\n\n    it 'overwrites the default HEAD request' do\n      subject.head 'example' do\n        error! 'nothing to see here', 400\n      end\n      subject.get 'example' do\n        'example'\n      end\n      head '/example'\n      expect(last_response.status).to eql 400\n    end\n  end\n\n  context 'do_not_route_head!' do\n    before :each do\n      subject.do_not_route_head!\n      subject.get 'example' do\n        'example'\n      end\n    end\n    it 'options does not contain HEAD' do\n      options '/example'\n      expect(last_response.status).to eql 204\n      expect(last_response.body).to eql ''\n      expect(last_response.headers['Allow']).to eql 'OPTIONS, GET'\n    end\n    it 'does not allow HEAD on a GET request' do\n      head '/example'\n      expect(last_response.status).to eql 405\n    end\n  end\n\n  context 'do_not_route_options!' do\n    before :each do\n      subject.do_not_route_options!\n      subject.get 'example' do\n        'example'\n      end\n    end\n\n    it 'does not create an OPTIONS route' do\n      options '/example'\n      expect(last_response.status).to eql 405\n    end\n\n    it 'does not include OPTIONS in Allow header' do\n      options '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.headers['Allow']).to eql 'GET, HEAD'\n    end\n  end\n\n  describe 'filters' do\n    it 'adds a before filter' do\n      subject.before { @foo = 'first'  }\n      subject.before { @bar = 'second' }\n      subject.get '/' do\n        \"#{@foo} #{@bar}\"\n      end\n\n      get '/'\n      expect(last_response.body).to eql 'first second'\n    end\n\n    it 'adds a before filter to current and child namespaces only' do\n      subject.get '/' do\n        \"root - #{@foo}\"\n      end\n      subject.namespace :blah do\n        before { @foo = 'foo' }\n        get '/' do\n          \"blah - #{@foo}\"\n        end\n\n        namespace :bar do\n          get '/' do\n            \"blah - bar - #{@foo}\"\n          end\n        end\n      end\n\n      get '/'\n      expect(last_response.body).to eql 'root - '\n      get '/blah'\n      expect(last_response.body).to eql 'blah - foo'\n      get '/blah/bar'\n      expect(last_response.body).to eql 'blah - bar - foo'\n    end\n\n    it 'adds a after_validation filter' do\n      subject.after_validation { @foo = \"first #{params[:id]}:#{params[:id].class}\" }\n      subject.after_validation { @bar = 'second' }\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.get '/' do\n        \"#{@foo} #{@bar}\"\n      end\n\n      get '/', id: '32'\n      expect(last_response.body).to eql \"first 32:#{integer_class_name} second\"\n    end\n\n    it 'adds a after filter' do\n      m = double('after mock')\n      subject.after { m.do_something! }\n      subject.after { m.do_something! }\n      subject.get '/' do\n        @var ||= 'default'\n      end\n\n      expect(m).to receive(:do_something!).exactly(2).times\n      get '/'\n      expect(last_response.body).to eql 'default'\n    end\n\n    it 'calls all filters when validation passes' do\n      a = double('before mock')\n      b = double('before_validation mock')\n      c = double('after_validation mock')\n      d = double('after mock')\n\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.resource ':id' do\n        before { a.do_something! }\n        before_validation { b.do_something! }\n        after_validation { c.do_something! }\n        after { d.do_something! }\n        get do\n          'got it'\n        end\n      end\n\n      expect(a).to receive(:do_something!).exactly(1).times\n      expect(b).to receive(:do_something!).exactly(1).times\n      expect(c).to receive(:do_something!).exactly(1).times\n      expect(d).to receive(:do_something!).exactly(1).times\n\n      get '/123'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'got it'\n    end\n\n    it 'calls only before filters when validation fails' do\n      a = double('before mock')\n      b = double('before_validation mock')\n      c = double('after_validation mock')\n      d = double('after mock')\n\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.resource ':id' do\n        before { a.do_something! }\n        before_validation { b.do_something! }\n        after_validation { c.do_something! }\n        after { d.do_something! }\n        get do\n          'got it'\n        end\n      end\n\n      expect(a).to receive(:do_something!).exactly(1).times\n      expect(b).to receive(:do_something!).exactly(1).times\n      expect(c).to receive(:do_something!).exactly(0).times\n      expect(d).to receive(:do_something!).exactly(0).times\n\n      get '/abc'\n      expect(last_response.status).to eql 400\n      expect(last_response.body).to eql 'id is invalid'\n    end\n\n    it 'calls filters in the correct order' do\n      i = 0\n      a = double('before mock')\n      b = double('before_validation mock')\n      c = double('after_validation mock')\n      d = double('after mock')\n\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.resource ':id' do\n        before { a.here(i += 1) }\n        before_validation { b.here(i += 1) }\n        after_validation { c.here(i += 1) }\n        after { d.here(i += 1) }\n        get do\n          'got it'\n        end\n      end\n\n      expect(a).to receive(:here).with(1).exactly(1).times\n      expect(b).to receive(:here).with(2).exactly(1).times\n      expect(c).to receive(:here).with(3).exactly(1).times\n      expect(d).to receive(:here).with(4).exactly(1).times\n\n      get '/123'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'got it'\n    end\n  end\n\n  context 'format' do\n    before do\n      subject.get('/foo') { 'bar' }\n    end\n\n    it 'sets content type for txt format' do\n      get '/foo'\n      expect(last_response.headers['Content-Type']).to eq('text/plain')\n    end\n\n    it 'sets content type for xml' do\n      get '/foo.xml'\n      expect(last_response.headers['Content-Type']).to eq('application/xml')\n    end\n\n    it 'sets content type for json' do\n      get '/foo.json'\n      expect(last_response.headers['Content-Type']).to eq('application/json')\n    end\n\n    it 'sets content type for serializable hash format' do\n      get '/foo.serializable_hash'\n      expect(last_response.headers['Content-Type']).to eq('application/json')\n    end\n\n    it 'sets content type for binary format' do\n      get '/foo.binary'\n      expect(last_response.headers['Content-Type']).to eq('application/octet-stream')\n    end\n\n    it 'returns raw data when content type binary' do\n      image_filename = 'grape.png'\n      file = File.open(image_filename, 'rb', &:read)\n      subject.format :binary\n      subject.get('/binary_file') { File.binread(image_filename) }\n      get '/binary_file'\n      expect(last_response.headers['Content-Type']).to eq('application/octet-stream')\n      expect(last_response.body).to eq(file)\n    end\n\n    it 'returns the content of the file with file' do\n      file_content = 'This is some file content'\n      test_file = Tempfile.new('test')\n      test_file.write file_content\n      test_file.rewind\n\n      subject.get('/file') { file test_file }\n      get '/file'\n      expect(last_response.headers['Content-Length']).to eq('25')\n      expect(last_response.headers['Content-Type']).to eq('text/plain')\n      expect(last_response.body).to eq(file_content)\n    end\n\n    it 'streams the content of the file with stream' do\n      test_stream = Enumerator.new do |blk|\n        blk.yield 'This is some'\n        blk.yield ' file content'\n      end\n\n      subject.use Rack::Chunked\n      subject.get('/stream') { stream test_stream }\n      get '/stream', {}, 'HTTP_VERSION' => 'HTTP/1.1'\n\n      expect(last_response.headers['Content-Type']).to eq('text/plain')\n      expect(last_response.headers['Content-Length']).to eq(nil)\n      expect(last_response.headers['Cache-Control']).to eq('no-cache')\n      expect(last_response.headers['Transfer-Encoding']).to eq('chunked')\n\n      expect(last_response.body).to eq(\"c\\r\\nThis is some\\r\\nd\\r\\n file content\\r\\n0\\r\\n\\r\\n\")\n    end\n\n    it 'sets content type for error' do\n      subject.get('/error') { error!('error in plain text', 500) }\n      get '/error'\n      expect(last_response.headers['Content-Type']).to eql 'text/plain'\n    end\n\n    it 'sets content type for json error' do\n      subject.format :json\n      subject.get('/error') { error!('error in json', 500) }\n      get '/error.json'\n      expect(last_response.status).to eql 500\n      expect(last_response.headers['Content-Type']).to eql 'application/json'\n    end\n\n    it 'sets content type for xml error' do\n      subject.format :xml\n      subject.get('/error') { error!('error in xml', 500) }\n      get '/error'\n      expect(last_response.status).to eql 500\n      expect(last_response.headers['Content-Type']).to eql 'application/xml'\n    end\n\n    it 'includes extension in format' do\n      subject.get(':id') { params[:format] }\n\n      get '/baz.bar'\n      expect(last_response.status).to eq 200\n      expect(last_response.body).to eq 'bar'\n    end\n\n    it 'does not include extension in id' do\n      subject.format :json\n      subject.get(':id') { params }\n\n      get '/baz.bar'\n      expect(last_response.status).to eq 404\n    end\n\n    context 'with a custom content_type' do\n      before do\n        subject.content_type :custom, 'application/custom'\n        subject.formatter :custom, ->(_object, _env) { 'custom' }\n\n        subject.get('/custom') { 'bar' }\n        subject.get('/error') { error!('error in custom', 500) }\n      end\n\n      it 'sets content type' do\n        get '/custom.custom'\n        expect(last_response.headers['Content-Type']).to eql 'application/custom'\n      end\n\n      it 'sets content type for error' do\n        get '/error.custom'\n        expect(last_response.headers['Content-Type']).to eql 'application/custom'\n      end\n    end\n\n    context 'env[\"api.format\"]' do\n      before do\n        subject.post 'attachment' do\n          filename = params[:file][:filename]\n          content_type MIME::Types.type_for(filename)[0].to_s\n          env['api.format'] = :binary # there's no formatter for :binary, data will be returned \"as is\"\n          header 'Content-Disposition', \"attachment; filename*=UTF-8''#{CGI.escape(filename)}\"\n          params[:file][:tempfile].read\n        end\n      end\n\n      ['/attachment.png', 'attachment'].each do |url|\n        it \"uploads and downloads a PNG file via #{url}\" do\n          image_filename = 'grape.png'\n          post url, file: Rack::Test::UploadedFile.new(image_filename, 'image/png', true)\n          expect(last_response.status).to eq(201)\n          expect(last_response.headers['Content-Type']).to eq('image/png')\n          expect(last_response.headers['Content-Disposition']).to eq(\"attachment; filename*=UTF-8''grape.png\")\n          File.open(image_filename, 'rb') do |io|\n            expect(last_response.body).to eq io.read\n          end\n        end\n      end\n\n      it 'uploads and downloads a Ruby file' do\n        filename = __FILE__\n        post '/attachment.rb', file: Rack::Test::UploadedFile.new(filename, 'application/x-ruby', true)\n        expect(last_response.status).to eq(201)\n        expect(last_response.headers['Content-Type']).to eq('application/x-ruby')\n        expect(last_response.headers['Content-Disposition']).to eq(\"attachment; filename*=UTF-8''api_spec.rb\")\n        File.open(filename, 'rb') do |io|\n          expect(last_response.body).to eq io.read\n        end\n      end\n    end\n  end\n\n  context 'custom middleware' do\n    module ApiSpec\n      class PhonyMiddleware\n        def initialize(app, *args)\n          @args = args\n          @app = app\n          @block = block_given? ? true : nil\n        end\n\n        def call(env)\n          env['phony.args'] ||= []\n          env['phony.args'] << @args\n          env['phony.block'] = true if @block\n          @app.call(env)\n        end\n      end\n    end\n\n    describe '.middleware' do\n      it 'includes middleware arguments from settings' do\n        subject.use ApiSpec::PhonyMiddleware, 'abc', 123\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 'abc', 123]]\n      end\n\n      it 'includes all middleware from stacked settings' do\n        subject.use ApiSpec::PhonyMiddleware, 123\n        subject.use ApiSpec::PhonyMiddleware, 'abc'\n        subject.use ApiSpec::PhonyMiddleware, 'foo'\n\n        expect(subject.middleware).to eql [\n          [:use, ApiSpec::PhonyMiddleware, 123],\n          [:use, ApiSpec::PhonyMiddleware, 'abc'],\n          [:use, ApiSpec::PhonyMiddleware, 'foo']\n        ]\n      end\n    end\n\n    describe '.use' do\n      it 'adds middleware' do\n        subject.use ApiSpec::PhonyMiddleware, 123\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 123]]\n      end\n\n      it 'does not show up outside the namespace' do\n        inner_middleware = nil\n        subject.use ApiSpec::PhonyMiddleware, 123\n        subject.namespace :awesome do\n          use ApiSpec::PhonyMiddleware, 'abc'\n          inner_middleware = middleware\n        end\n\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 123]]\n        expect(inner_middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 123], [:use, ApiSpec::PhonyMiddleware, 'abc']]\n      end\n\n      it 'calls the middleware' do\n        subject.use ApiSpec::PhonyMiddleware, 'hello'\n        subject.get '/' do\n          env['phony.args'].first.first\n        end\n\n        get '/'\n        expect(last_response.body).to eql 'hello'\n      end\n\n      it 'adds a block if one is given' do\n        block = -> {}\n        subject.use ApiSpec::PhonyMiddleware, &block\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, block]]\n      end\n\n      it 'uses a block if one is given' do\n        block = -> {}\n        subject.use ApiSpec::PhonyMiddleware, &block\n        subject.get '/' do\n          env['phony.block'].inspect\n        end\n\n        get '/'\n        expect(last_response.body).to eq('true')\n      end\n\n      it 'does not destroy the middleware settings on multiple runs' do\n        block = -> {}\n        subject.use ApiSpec::PhonyMiddleware, &block\n        subject.get '/' do\n          env['phony.block'].inspect\n        end\n\n        2.times do\n          get '/'\n          expect(last_response.body).to eq('true')\n        end\n      end\n\n      it 'mounts behind error middleware' do\n        m = Class.new(Grape::Middleware::Base) do\n          def before\n            throw :error, message: 'Caught in the Net', status: 400\n          end\n        end\n        subject.use m\n        subject.get '/' do\n        end\n        get '/'\n        expect(last_response.status).to eq(400)\n        expect(last_response.body).to eq('Caught in the Net')\n      end\n    end\n\n    describe '.insert_before' do\n      it 'runs before a given middleware' do\n        m = Class.new(Grape::Middleware::Base) do\n          def call(env)\n            env['phony.args'] ||= []\n            env['phony.args'] << @options[:message]\n            @app.call(env)\n          end\n        end\n\n        subject.use ApiSpec::PhonyMiddleware, 'hello'\n        subject.insert_before ApiSpec::PhonyMiddleware, m, message: 'bye'\n        subject.get '/' do\n          env['phony.args'].join(' ')\n        end\n\n        get '/'\n        expect(last_response.body).to eql 'bye hello'\n      end\n    end\n\n    describe '.insert_after' do\n      it 'runs after a given middleware' do\n        m = Class.new(Grape::Middleware::Base) do\n          def call(env)\n            env['phony.args'] ||= []\n            env['phony.args'] << @options[:message]\n            @app.call(env)\n          end\n        end\n\n        subject.use ApiSpec::PhonyMiddleware, 'hello'\n        subject.insert_after ApiSpec::PhonyMiddleware, m, message: 'bye'\n        subject.get '/' do\n          env['phony.args'].join(' ')\n        end\n\n        get '/'\n        expect(last_response.body).to eql 'hello bye'\n      end\n    end\n  end\n\n  describe '.http_basic' do\n    it 'protects any resources on the same scope' do\n      subject.http_basic do |u, _p|\n        u == 'allow'\n      end\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello'\n      expect(last_response.status).to eql 401\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n    end\n\n    it 'is scopable' do\n      subject.get(:hello) { 'Hello, world.' }\n      subject.namespace :admin do\n        http_basic do |u, _p|\n          u == 'allow'\n        end\n\n        get(:hello) { 'Hello, world.' }\n      end\n\n      get '/hello'\n      expect(last_response.status).to eql 200\n      get '/admin/hello'\n      expect(last_response.status).to eql 401\n    end\n\n    it 'is callable via .auth as well' do\n      subject.auth :http_basic do |u, _p|\n        u == 'allow'\n      end\n\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello'\n      expect(last_response.status).to eql 401\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n    end\n\n    it 'has access to the current endpoint' do\n      basic_auth_context = nil\n\n      subject.http_basic do |u, _p|\n        basic_auth_context = self\n\n        u == 'allow'\n      end\n\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(basic_auth_context).to be_a_kind_of(Grape::Endpoint)\n    end\n\n    it 'has access to helper methods' do\n      subject.helpers do\n        def authorize(u, p)\n          u == 'allow' && p == 'whatever'\n        end\n      end\n\n      subject.http_basic do |u, p|\n        authorize(u, p)\n      end\n\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('disallow', 'whatever')\n      expect(last_response.status).to eql 401\n    end\n\n    it 'can set instance variables accessible to routes' do\n      subject.http_basic do |u, _p|\n        @hello = 'Hello, world.'\n\n        u == 'allow'\n      end\n\n      subject.get(:hello) { @hello }\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'Hello, world.'\n    end\n  end\n\n  describe '.logger' do\n    subject do\n      Class.new(Grape::API) do\n        def self.io\n          @io ||= StringIO.new\n        end\n        logger ::Logger.new(io)\n      end\n    end\n\n    it 'returns an instance of Logger class by default' do\n      expect(subject.logger.class).to eql Logger\n    end\n\n    it 'allows setting a custom logger' do\n      mylogger = Class.new\n      subject.logger mylogger\n      expect(mylogger).to receive(:info).exactly(1).times\n      subject.logger.info 'this will be logged'\n    end\n\n    it 'defaults to a standard logger log format' do\n      t = Time.at(100)\n      allow(Time).to receive(:now).and_return(t)\n      message = \"this will be logged\\n\"\n      message = \"I, [#{Logger::Formatter.new.send(:format_datetime, t)}\\##{Process.pid}]  INFO -- : #{message}\" if !defined?(Rails) || Gem::Version.new(Rails::VERSION::STRING) >= Gem::Version.new('4.0')\n      expect(subject.io).to receive(:write).with(message)\n      subject.logger.info 'this will be logged'\n    end\n  end\n\n  describe '.helpers' do\n    it 'is accessible from the endpoint' do\n      subject.helpers do\n        def hello\n          'Hello, world.'\n        end\n      end\n\n      subject.get '/howdy' do\n        hello\n      end\n\n      get '/howdy'\n      expect(last_response.body).to eql 'Hello, world.'\n    end\n\n    it 'is scopable' do\n      subject.helpers do\n        def generic\n          'always there'\n        end\n      end\n\n      subject.namespace :admin do\n        helpers do\n          def secret\n            'only in admin'\n          end\n        end\n\n        get '/secret' do\n          [generic, secret].join ':'\n        end\n      end\n\n      subject.get '/generic' do\n        [generic, respond_to?(:secret)].join ':'\n      end\n\n      get '/generic'\n      expect(last_response.body).to eql 'always there:false'\n      get '/admin/secret'\n      expect(last_response.body).to eql 'always there:only in admin'\n    end\n\n    it 'is reopenable' do\n      subject.helpers do\n        def one\n          1\n        end\n      end\n\n      subject.helpers do\n        def two\n          2\n        end\n      end\n\n      subject.get 'howdy' do\n        [one, two]\n      end\n\n      expect { get '/howdy' }.not_to raise_error\n    end\n\n    it 'allows for modules' do\n      mod = Module.new do\n        def hello\n          'Hello, world.'\n        end\n      end\n      subject.helpers mod\n\n      subject.get '/howdy' do\n        hello\n      end\n\n      get '/howdy'\n      expect(last_response.body).to eql 'Hello, world.'\n    end\n\n    it 'allows multiple calls with modules and blocks' do\n      subject.helpers Module.new do\n        def one\n          1\n        end\n      end\n      subject.helpers Module.new do\n        def two\n          2\n        end\n      end\n      subject.helpers do\n        def three\n          3\n        end\n      end\n      subject.get 'howdy' do\n        [one, two, three]\n      end\n      expect { get '/howdy' }.not_to raise_error\n    end\n  end\n\n  describe '.scope' do\n    # TODO: refactor this to not be tied to versioning. How about a generic\n    # .setting macro?\n    it 'scopes the various settings' do\n      subject.prefix 'new'\n\n      subject.scope :legacy do\n        prefix 'legacy'\n        get '/abc' do\n          'abc'\n        end\n      end\n\n      subject.get '/def' do\n        'def'\n      end\n\n      get '/new/abc'\n      expect(last_response.status).to eql 404\n      get '/legacy/abc'\n      expect(last_response.status).to eql 200\n      get '/legacy/def'\n      expect(last_response.status).to eql 404\n      get '/new/def'\n      expect(last_response.status).to eql 200\n    end\n  end\n\n  describe '.rescue_from' do\n    it 'does not rescue errors when rescue_from is not set' do\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      expect { get '/exception' }.to raise_error(RuntimeError, 'rain!')\n    end\n\n    it 'uses custom helpers defined by using #helpers method' do\n      subject.helpers do\n        def custom_error!(name)\n          error! \"hello #{name}\"\n        end\n      end\n      subject.rescue_from(ArgumentError) { custom_error! :bob }\n      subject.get '/custom_error' do\n        raise ArgumentError\n      end\n      get '/custom_error'\n      expect(last_response.body).to eq 'hello bob'\n    end\n\n    context 'with multiple apis' do\n      let(:a) { Class.new(Grape::API) }\n      let(:b) { Class.new(Grape::API) }\n\n      before do\n        a.helpers do\n          def foo\n            error!('foo', 401)\n          end\n        end\n        a.rescue_from(:all) { foo }\n        a.get { raise 'boo' }\n        b.helpers do\n          def foo\n            error!('bar', 401)\n          end\n        end\n        b.rescue_from(:all) { foo }\n        b.get { raise 'boo' }\n      end\n\n      it 'avoids polluting global namespace' do\n        env = Rack::MockRequest.env_for('/')\n\n        expect(a.call(env)[2].body).to eq(['foo'])\n        expect(b.call(env)[2].body).to eq(['bar'])\n        expect(a.call(env)[2].body).to eq(['foo'])\n      end\n    end\n\n    it 'rescues all errors if rescue_from :all is called' do\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 500\n      expect(last_response.body).to eq 'rain!'\n    end\n\n    it 'rescues all errors with a json formatter' do\n      subject.format :json\n      subject.default_format :json\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 500\n      expect(last_response.body).to eq({ error: 'rain!' }.to_json)\n    end\n\n    it 'rescues only certain errors if rescue_from is called with specific errors' do\n      subject.rescue_from ArgumentError\n      subject.get('/rescued') { raise ArgumentError }\n      subject.get('/unrescued') { raise 'beefcake' }\n\n      get '/rescued'\n      expect(last_response.status).to eql 500\n\n      expect { get '/unrescued' }.to raise_error(RuntimeError, 'beefcake')\n    end\n\n    context 'CustomError subclass of Grape::Exceptions::Base' do\n      before do\n        module ApiSpec\n          class CustomError < Grape::Exceptions::Base; end\n        end\n      end\n\n      it 'does not re-raise exceptions of type Grape::Exceptions::Base' do\n        subject.get('/custom_exception') { raise ApiSpec::CustomError }\n\n        expect { get '/custom_exception' }.not_to raise_error\n      end\n\n      it 'rescues custom grape exceptions' do\n        subject.rescue_from ApiSpec::CustomError do |e|\n          rack_response('New Error', e.status)\n        end\n        subject.get '/custom_error' do\n          raise ApiSpec::CustomError, status: 400, message: 'Custom Error'\n        end\n\n        get '/custom_error'\n        expect(last_response.status).to eq(400)\n        expect(last_response.body).to eq('New Error')\n      end\n    end\n\n    it 'can rescue exceptions raised in the formatter' do\n      formatter = double(:formatter)\n      allow(formatter).to receive(:call) { raise StandardError }\n      allow(Grape::Formatter).to receive(:formatter_for) { formatter }\n\n      subject.rescue_from :all do |_e|\n        rack_response('Formatter Error', 500)\n      end\n      subject.get('/formatter_exception') { 'Hello world' }\n\n      get '/formatter_exception'\n      expect(last_response.status).to eql 500\n      expect(last_response.body).to eq('Formatter Error')\n    end\n  end\n\n  describe '.rescue_from klass, block' do\n    it 'rescues Exception' do\n      subject.rescue_from RuntimeError do |e|\n        rack_response(\"rescued from #{e.message}\", 202)\n      end\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 202\n      expect(last_response.body).to eq('rescued from rain!')\n    end\n\n    context 'custom errors' do\n      before do\n        class ConnectionError < RuntimeError; end\n        class DatabaseError < RuntimeError; end\n        class CommunicationError < StandardError; end\n      end\n\n      it 'rescues an error via rescue_from :all' do\n        subject.rescue_from :all do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/exception' do\n          raise ConnectionError\n        end\n        get '/exception'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n      end\n      it 'rescues a specific error' do\n        subject.rescue_from ConnectionError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/exception' do\n          raise ConnectionError\n        end\n        get '/exception'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n      end\n      it 'rescues a subclass of an error by default' do\n        subject.rescue_from RuntimeError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/exception' do\n          raise ConnectionError\n        end\n        get '/exception'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n      end\n      it 'rescues multiple specific errors' do\n        subject.rescue_from ConnectionError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.rescue_from DatabaseError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/connection' do\n          raise ConnectionError\n        end\n        subject.get '/database' do\n          raise DatabaseError\n        end\n        get '/connection'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n        get '/database'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from DatabaseError')\n      end\n      it 'does not rescue a different error' do\n        subject.rescue_from RuntimeError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/uncaught' do\n          raise CommunicationError\n        end\n        expect { get '/uncaught' }.to raise_error(CommunicationError)\n      end\n    end\n  end\n\n  describe '.rescue_from klass, lambda' do\n    it 'rescues an error with the lambda' do\n      subject.rescue_from ArgumentError, lambda {\n        rack_response('rescued with a lambda', 400)\n      }\n      subject.get('/rescue_lambda') { raise ArgumentError }\n\n      get '/rescue_lambda'\n      expect(last_response.status).to eq(400)\n      expect(last_response.body).to eq('rescued with a lambda')\n    end\n\n    it 'can execute the lambda with an argument' do\n      subject.rescue_from ArgumentError, lambda { |e|\n        rack_response(e.message, 400)\n      }\n      subject.get('/rescue_lambda') { raise ArgumentError, 'lambda takes an argument' }\n\n      get '/rescue_lambda'\n      expect(last_response.status).to eq(400)\n      expect(last_response.body).to eq('lambda takes an argument')\n    end\n  end\n\n  describe '.rescue_from klass, with: :method_name' do\n    it 'rescues an error with the specified method name' do\n      subject.helpers do\n        def rescue_arg_error\n          error!('500 ArgumentError', 500)\n        end\n\n        def rescue_no_method_error\n          error!('500 NoMethodError', 500)\n        end\n      end\n      subject.rescue_from ArgumentError, with: :rescue_arg_error\n      subject.rescue_from NoMethodError, with: :rescue_no_method_error\n      subject.get('/rescue_arg_error') { raise ArgumentError }\n      subject.get('/rescue_no_method_error') { raise NoMethodError }\n\n      get '/rescue_arg_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 ArgumentError')\n\n      get '/rescue_no_method_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 NoMethodError')\n    end\n\n    it 'aborts if the specified method name does not exist' do\n      subject.rescue_from :all, with: :not_exist_method\n      subject.get('/rescue_method') { raise StandardError }\n\n      expect { get '/rescue_method' }.to raise_error(NoMethodError, 'undefined method `not_exist_method\\'')\n    end\n\n    it 'correctly chooses exception handler if :all handler is specified' do\n      subject.helpers do\n        def rescue_arg_error\n          error!('500 ArgumentError', 500)\n        end\n\n        def rescue_all_errors\n          error!('500 AnotherError', 500)\n        end\n      end\n\n      subject.rescue_from ArgumentError, with: :rescue_arg_error\n      subject.rescue_from :all, with: :rescue_all_errors\n      subject.get('/argument_error') { raise ArgumentError }\n      subject.get('/another_error') { raise NoMethodError }\n\n      get '/argument_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 ArgumentError')\n\n      get '/another_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 AnotherError')\n    end\n  end\n\n  describe '.rescue_from klass, rescue_subclasses: boolean' do\n    before do\n      module ApiSpec\n        module APIErrors\n          class ParentError < StandardError; end\n          class ChildError < ParentError; end\n        end\n      end\n    end\n\n    it 'rescues error as well as subclass errors with rescue_subclasses option set' do\n      subject.rescue_from ApiSpec::APIErrors::ParentError, rescue_subclasses: true do |e|\n        rack_response(\"rescued from #{e.class.name}\", 500)\n      end\n      subject.get '/caught_child' do\n        raise ApiSpec::APIErrors::ChildError\n      end\n      subject.get '/caught_parent' do\n        raise ApiSpec::APIErrors::ParentError\n      end\n      subject.get '/uncaught_parent' do\n        raise StandardError\n      end\n\n      get '/caught_child'\n      expect(last_response.status).to eql 500\n      get '/caught_parent'\n      expect(last_response.status).to eql 500\n      expect { get '/uncaught_parent' }.to raise_error(StandardError)\n    end\n\n    it 'sets rescue_subclasses to true by default' do\n      subject.rescue_from ApiSpec::APIErrors::ParentError do |e|\n        rack_response(\"rescued from #{e.class.name}\", 500)\n      end\n      subject.get '/caught_child' do\n        raise ApiSpec::APIErrors::ChildError\n      end\n\n      get '/caught_child'\n      expect(last_response.status).to eql 500\n    end\n\n    it 'does not rescue child errors if rescue_subclasses is false' do\n      subject.rescue_from ApiSpec::APIErrors::ParentError, rescue_subclasses: false do |e|\n        rack_response(\"rescued from #{e.class.name}\", 500)\n      end\n      subject.get '/uncaught' do\n        raise ApiSpec::APIErrors::ChildError\n      end\n      expect { get '/uncaught' }.to raise_error(ApiSpec::APIErrors::ChildError)\n    end\n  end\n\n  describe '.rescue_from :grape_exceptions' do\n    before do\n      subject.rescue_from :grape_exceptions\n    end\n\n    let(:grape_exception) do\n      Grape::Exceptions::Base.new(status: 400, message: 'Grape Error')\n    end\n\n    it 'rescues grape exceptions' do\n      exception = grape_exception\n      subject.get('/grape_exception') { raise exception }\n\n      get '/grape_exception'\n\n      expect(last_response.status).to eq(exception.status)\n      expect(last_response.body).to eq(exception.message)\n    end\n\n    it 'rescues grape exceptions with a user-defined handler' do\n      subject.rescue_from grape_exception.class do |_error|\n        rack_response('Redefined Error', 403)\n      end\n\n      exception = grape_exception\n      subject.get('/grape_exception') { raise exception }\n\n      get '/grape_exception'\n\n      expect(last_response.status).to eq(403)\n      expect(last_response.body).to eq('Redefined Error')\n    end\n  end\n\n  describe '.error_format' do\n    it 'rescues all errors and return :txt' do\n      subject.rescue_from :all\n      subject.format :txt\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.body).to eql 'rain!'\n    end\n\n    it 'rescues all errors and return :txt with backtrace' do\n      subject.rescue_from :all, backtrace: true\n      subject.format :txt\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.body.start_with?(\"rain!\\r\\n\")).to be true\n    end\n\n    it 'rescues all errors with a default formatter' do\n      subject.default_format :foo\n      subject.content_type :foo, 'text/foo'\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception.foo'\n      expect(last_response.body).to start_with 'rain!'\n    end\n\n    it 'defaults the error formatter to format' do\n      subject.format :json\n      subject.rescue_from :all\n      subject.content_type :json, 'application/json'\n      subject.content_type :foo, 'text/foo'\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception.json'\n      expect(last_response.body).to eq('{\"error\":\"rain!\"}')\n      get '/exception.foo'\n      expect(last_response.body).to eq('{\"error\":\"rain!\"}')\n    end\n\n    context 'class' do\n      before :each do\n        module ApiSpec\n          class CustomErrorFormatter\n            def self.call(message, _backtrace, _options, _env, _original_exception)\n              \"message: #{message} @backtrace\"\n            end\n          end\n        end\n      end\n      it 'returns a custom error format' do\n        subject.rescue_from :all, backtrace: true\n        subject.error_formatter :txt, ApiSpec::CustomErrorFormatter\n        subject.get '/exception' do\n          raise 'rain!'\n        end\n        get '/exception'\n        expect(last_response.body).to eq('message: rain! @backtrace')\n      end\n    end\n\n    describe 'with' do\n      context 'class' do\n        before :each do\n          module ApiSpec\n            class CustomErrorFormatter\n              def self.call(message, _backtrace, _option, _env, _original_exception)\n                \"message: #{message} @backtrace\"\n              end\n            end\n          end\n        end\n\n        it 'returns a custom error format' do\n          subject.rescue_from :all, backtrace: true\n          subject.error_formatter :txt, with: ApiSpec::CustomErrorFormatter\n          subject.get('/exception') { raise 'rain!' }\n\n          get '/exception'\n          expect(last_response.body).to eq('message: rain! @backtrace')\n        end\n      end\n    end\n\n    it 'rescues all errors and return :json' do\n      subject.rescue_from :all\n      subject.format :json\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.body).to eql '{\"error\":\"rain!\"}'\n    end\n    it 'rescues all errors and return :json with backtrace' do\n      subject.rescue_from :all, backtrace: true\n      subject.format :json\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      json = ::Grape::Json.load(last_response.body)\n      expect(json['error']).to eql 'rain!'\n      expect(json['backtrace'].length).to be > 0\n    end\n    it 'rescues error! and return txt' do\n      subject.format :txt\n      subject.get '/error' do\n        error!('Access Denied', 401)\n      end\n      get '/error'\n      expect(last_response.body).to eql 'Access Denied'\n    end\n    context 'with json format' do\n      before { subject.format :json }\n\n      it 'rescues error! called with a string and returns json' do\n        subject.get('/error') { error!(:failure, 401) }\n      end\n      it 'rescues error! called with a symbol and returns json' do\n        subject.get('/error') { error!(:failure, 401) }\n      end\n      it 'rescues error! called with a hash and returns json' do\n        subject.get('/error') { error!({ error: :failure }, 401) }\n      end\n\n      after do\n        get '/error'\n        expect(last_response.body).to eql('{\"error\":\"failure\"}')\n      end\n    end\n  end\n\n  describe '.content_type' do\n    it 'sets additional content-type' do\n      subject.content_type :xls, 'application/vnd.ms-excel'\n      subject.get :excel do\n        'some binary content'\n      end\n      get '/excel.xls'\n      expect(last_response.content_type).to eq('application/vnd.ms-excel')\n    end\n    it 'allows to override content-type' do\n      subject.get :content do\n        content_type 'text/javascript'\n        'var x = 1;'\n      end\n      get '/content'\n      expect(last_response.content_type).to eq('text/javascript')\n    end\n    it 'removes existing content types' do\n      subject.content_type :xls, 'application/vnd.ms-excel'\n      subject.get :excel do\n        'some binary content'\n      end\n      get '/excel.json'\n      expect(last_response.status).to eq(406)\n      expect(last_response.body).to eq(\"The requested format 'txt' is not supported.\")\n    end\n  end\n\n  describe '.formatter' do\n    context 'multiple formatters' do\n      before :each do\n        subject.formatter :json, ->(object, _env) { \"{\\\"custom_formatter\\\":\\\"#{object[:some]}\\\"}\" }\n        subject.formatter :txt, ->(object, _env) { \"custom_formatter: #{object[:some]}\" }\n        subject.get :simple do\n          { some: 'hash' }\n        end\n      end\n      it 'sets one formatter' do\n        get '/simple.json'\n        expect(last_response.body).to eql '{\"custom_formatter\":\"hash\"}'\n      end\n      it 'sets another formatter' do\n        get '/simple.txt'\n        expect(last_response.body).to eql 'custom_formatter: hash'\n      end\n    end\n    context 'custom formatter' do\n      before :each do\n        subject.content_type :json, 'application/json'\n        subject.content_type :custom, 'application/custom'\n        subject.formatter :custom, ->(object, _env) { \"{\\\"custom_formatter\\\":\\\"#{object[:some]}\\\"}\" }\n        subject.get :simple do\n          { some: 'hash' }\n        end\n      end\n      it 'uses json' do\n        get '/simple.json'\n        expect(last_response.body).to eql '{\"some\":\"hash\"}'\n      end\n      it 'uses custom formatter' do\n        get '/simple.custom', 'HTTP_ACCEPT' => 'application/custom'\n        expect(last_response.body).to eql '{\"custom_formatter\":\"hash\"}'\n      end\n    end\n    context 'custom formatter class' do\n      module ApiSpec\n        module CustomFormatter\n          def self.call(object, _env)\n            \"{\\\"custom_formatter\\\":\\\"#{object[:some]}\\\"}\"\n          end\n        end\n      end\n      before :each do\n        subject.content_type :json, 'application/json'\n        subject.content_type :custom, 'application/custom'\n        subject.formatter :custom, ApiSpec::CustomFormatter\n        subject.get :simple do\n          { some: 'hash' }\n        end\n      end\n      it 'uses json' do\n        get '/simple.json'\n        expect(last_response.body).to eql '{\"some\":\"hash\"}'\n      end\n      it 'uses custom formatter' do\n        get '/simple.custom', 'HTTP_ACCEPT' => 'application/custom'\n        expect(last_response.body).to eql '{\"custom_formatter\":\"hash\"}'\n      end\n    end\n  end\n\n  describe '.parser' do\n    it 'parses data in format requested by content-type' do\n      subject.format :json\n      subject.post '/data' do\n        { x: params[:x] }\n      end\n      post '/data', '{\"x\":42}', 'CONTENT_TYPE' => 'application/json'\n      expect(last_response.status).to eq(201)\n      expect(last_response.body).to eq('{\"x\":42}')\n    end\n    context 'lambda parser' do\n      before :each do\n        subject.content_type :txt, 'text/plain'\n        subject.content_type :custom, 'text/custom'\n        subject.parser :custom, ->(object, _env) { { object.to_sym => object.to_s.reverse } }\n        subject.put :simple do\n          params[:simple]\n        end\n      end\n      ['text/custom', 'text/custom; charset=UTF-8'].each do |content_type|\n        it \"uses parser for #{content_type}\" do\n          put '/simple', 'simple', 'CONTENT_TYPE' => content_type\n          expect(last_response.status).to eq(200)\n          expect(last_response.body).to eql 'elpmis'\n        end\n      end\n    end\n    context 'custom parser class' do\n      module ApiSpec\n        module CustomParser\n          def self.call(object, _env)\n            { object.to_sym => object.to_s.reverse }\n          end\n        end\n      end\n      before :each do\n        subject.content_type :txt, 'text/plain'\n        subject.content_type :custom, 'text/custom'\n        subject.parser :custom, ApiSpec::CustomParser\n        subject.put :simple do\n          params[:simple]\n        end\n      end\n      it 'uses custom parser' do\n        put '/simple', 'simple', 'CONTENT_TYPE' => 'text/custom'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eql 'elpmis'\n      end\n    end\n    if Object.const_defined? :MultiXml\n      context 'multi_xml' do\n        it \"doesn't parse yaml\" do\n          subject.put :yaml do\n            params[:tag]\n          end\n          put '/yaml', '<tag type=\"symbol\">a123</tag>', 'CONTENT_TYPE' => 'application/xml'\n          expect(last_response.status).to eq(400)\n          expect(last_response.body).to eql 'Disallowed type attribute: \"symbol\"'\n        end\n      end\n    else\n      context 'default xml parser' do\n        it 'parses symbols' do\n          subject.put :yaml do\n            params[:tag]\n          end\n          put '/yaml', '<tag type=\"symbol\">a123</tag>', 'CONTENT_TYPE' => 'application/xml'\n          expect(last_response.status).to eq(200)\n          expect(last_response.body).to eql '{\"type\"=>\"symbol\", \"__content__\"=>\"a123\"}'\n        end\n      end\n    end\n    context 'none parser class' do\n      before :each do\n        subject.parser :json, nil\n        subject.put 'data' do\n          \"body: #{env['api.request.body']}\"\n        end\n      end\n      it 'does not parse data' do\n        put '/data', 'not valid json', 'CONTENT_TYPE' => 'application/json'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('body: not valid json')\n      end\n    end\n  end\n\n  describe '.default_format' do\n    before :each do\n      subject.format :json\n      subject.default_format :json\n    end\n    it 'returns data in default format' do\n      subject.get '/data' do\n        { x: 42 }\n      end\n      get '/data'\n      expect(last_response.status).to eq(200)\n      expect(last_response.body).to eq('{\"x\":42}')\n    end\n    it 'parses data in default format' do\n      subject.post '/data' do\n        { x: params[:x] }\n      end\n      post '/data', '{\"x\":42}', 'CONTENT_TYPE' => ''\n      expect(last_response.status).to eq(201)\n      expect(last_response.body).to eq('{\"x\":42}')\n    end\n  end\n\n  describe '.default_error_status' do\n    it 'allows setting default_error_status' do\n      subject.rescue_from :all\n      subject.default_error_status 200\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 200\n    end\n    it 'has a default error status' do\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 500\n    end\n    it 'uses the default error status in error!' do\n      subject.rescue_from :all\n      subject.default_error_status 400\n      subject.get '/exception' do\n        error! 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 400\n    end\n  end\n\n  context 'http_codes' do\n    let(:error_presenter) do\n      Class.new(Grape::Entity) do\n        expose :code\n        expose :static\n\n        def static\n          'some static text'\n        end\n      end\n    end\n\n    it 'is used as presenter' do\n      subject.desc 'some desc', http_codes: [\n        [408, 'Unauthorized', error_presenter]\n      ]\n\n      subject.get '/exception' do\n        error!({ code: 408 }, 408)\n      end\n\n      get '/exception'\n      expect(last_response.status).to eql 408\n      expect(last_response.body).to eql({ code: 408, static: 'some static text' }.to_json)\n    end\n\n    it 'presented with' do\n      error = { code: 408, with: error_presenter }.freeze\n      subject.get '/exception' do\n        error! error, 408\n      end\n\n      get '/exception'\n      expect(last_response.status).to eql 408\n      expect(last_response.body).to eql({ code: 408, static: 'some static text' }.to_json)\n    end\n  end\n\n  context 'routes' do\n    describe 'empty api structure' do\n      it 'returns an empty array of routes' do\n        expect(subject.routes).to eq([])\n      end\n    end\n    describe 'single method api structure' do\n      before(:each) do\n        subject.get :ping do\n          'pong'\n        end\n      end\n      it 'returns one route' do\n        expect(subject.routes.size).to eq(1)\n        route = subject.routes[0]\n        expect(route.version).to be_nil\n        expect(route.path).to eq('/ping(.:format)')\n        expect(route.request_method).to eq('GET')\n      end\n    end\n    describe 'api structure with two versions and a namespace' do\n      before :each do\n        subject.version 'v1', using: :path\n        subject.get 'version' do\n          api.version\n        end\n        # version v2\n        subject.version 'v2', using: :path\n        subject.prefix 'p'\n        subject.namespace 'n1' do\n          namespace 'n2' do\n            get 'version' do\n              api.version\n            end\n          end\n        end\n      end\n      it 'returns the latest version set' do\n        expect(subject.version).to eq('v2')\n      end\n      it 'returns versions' do\n        expect(subject.versions).to eq(%w[v1 v2])\n      end\n      it 'sets route paths' do\n        expect(subject.routes.size).to be >= 2\n        expect(subject.routes[0].path).to eq('/:version/version(.:format)')\n        expect(subject.routes[1].path).to eq('/p/:version/n1/n2/version(.:format)')\n      end\n      it 'sets route versions' do\n        expect(subject.routes[0].version).to eq('v1')\n        expect(subject.routes[1].version).to eq('v2')\n      end\n      it 'sets a nested namespace' do\n        expect(subject.routes[1].namespace).to eq('/n1/n2')\n      end\n      it 'sets prefix' do\n        expect(subject.routes[1].prefix).to eq('p')\n      end\n    end\n    describe 'api structure with additional parameters' do\n      before(:each) do\n        subject.params do\n          requires :token, desc: 'a token'\n          optional :limit, desc: 'the limit'\n        end\n        subject.get 'split/:string' do\n          params[:string].split(params[:token], (params[:limit] || 0).to_i)\n        end\n      end\n      it 'splits a string' do\n        get '/split/a,b,c.json', token: ','\n        expect(last_response.body).to eq('[\"a\",\"b\",\"c\"]')\n      end\n      it 'splits a string with limit' do\n        get '/split/a,b,c.json', token: ',', limit: '2'\n        expect(last_response.body).to eq('[\"a\",\"b,c\"]')\n      end\n      it 'sets params' do\n        expect(subject.routes.map do |route|\n          { params: route.params }\n        end).to eq [\n          {\n            params: {\n              'string' => '',\n              'token' => { required: true, desc: 'a token' },\n              'limit' => { required: false, desc: 'the limit' }\n            }\n          }\n        ]\n      end\n    end\n    describe 'api structure with multiple apis' do\n      before(:each) do\n        subject.params do\n          requires :one, desc: 'a token'\n          optional :two, desc: 'the limit'\n        end\n        subject.get 'one' do\n        end\n\n        subject.params do\n          requires :three, desc: 'a token'\n          optional :four, desc: 'the limit'\n        end\n        subject.get 'two' do\n        end\n      end\n      it 'sets params' do\n        expect(subject.routes.map do |route|\n          { params: route.params }\n        end).to eq [\n          {\n            params: {\n              'one' => { required: true, desc: 'a token' },\n              'two' => { required: false, desc: 'the limit' }\n            }\n          },\n          {\n            params: {\n              'three' => { required: true, desc: 'a token' },\n              'four' => { required: false, desc: 'the limit' }\n            }\n          }\n        ]\n      end\n    end\n    describe 'api structure with an api without params' do\n      before(:each) do\n        subject.params do\n          requires :one, desc: 'a token'\n          optional :two, desc: 'the limit'\n        end\n        subject.get 'one' do\n        end\n\n        subject.get 'two' do\n        end\n      end\n      it 'sets params' do\n        expect(subject.routes.map do |route|\n          { params: route.params }\n        end).to eq [\n          {\n            params: {\n              'one' => { required: true, desc: 'a token' },\n              'two' => { required: false, desc: 'the limit' }\n            }\n          },\n          {\n            params: {}\n          }\n        ]\n      end\n    end\n    describe 'api with a custom route setting' do\n      before(:each) do\n        subject.route_setting :custom, key: 'value'\n        subject.get 'one'\n      end\n      it 'exposed' do\n        expect(subject.routes.count).to eq 1\n        route = subject.routes.first\n        expect(route.settings[:custom]).to eq(key: 'value')\n      end\n    end\n    describe 'status' do\n      it 'can be set to arbitrary Integer value' do\n        subject.get '/foo' do\n          status 210\n        end\n        get '/foo'\n        expect(last_response.status).to eq 210\n      end\n      it 'can be set with a status code symbol' do\n        subject.get '/foo' do\n          status :see_other\n        end\n        get '/foo'\n        expect(last_response.status).to eq 303\n      end\n    end\n  end\n\n  context 'desc' do\n    it 'empty array of routes' do\n      expect(subject.routes).to eq([])\n    end\n    it 'empty array of routes' do\n      subject.desc 'grape api'\n      expect(subject.routes).to eq([])\n    end\n    it 'describes a method' do\n      subject.desc 'first method'\n      subject.get :first\n      expect(subject.routes.length).to eq(1)\n      route = subject.routes.first\n      expect(route.description).to eq('first method')\n      expect(route.route_foo).to be_nil\n      expect(route.params).to eq({})\n      expect(route.options).to be_a_kind_of(Hash)\n    end\n    it 'has params which does not include format and version as named captures' do\n      subject.version :v1, using: :path\n      subject.get :first\n      param_keys = subject.routes.first.params.keys\n      expect(param_keys).not_to include('format')\n      expect(param_keys).not_to include('version')\n    end\n    it 'describes methods separately' do\n      subject.desc 'first method'\n      subject.get :first\n      subject.desc 'second method'\n      subject.get :second\n      expect(subject.routes.count).to eq(2)\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'first method', params: {} },\n        { description: 'second method', params: {} }\n      ]\n    end\n    it 'resets desc' do\n      subject.desc 'first method'\n      subject.get :first\n      subject.get :second\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'first method', params: {} },\n        { description: nil, params: {} }\n      ]\n    end\n    it 'namespaces and describe arbitrary parameters' do\n      subject.namespace 'ns' do\n        desc 'ns second', foo: 'bar'\n        get 'second'\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, foo: route.route_foo, params: route.params }\n      end).to eq [\n        { description: 'ns second', foo: 'bar', params: {} }\n      ]\n    end\n    it 'includes details' do\n      subject.desc 'method', details: 'method details'\n      subject.get 'method'\n      expect(subject.routes.map do |route|\n        { description: route.description, details: route.details, params: route.params }\n      end).to eq [\n        { description: 'method', details: 'method details', params: {} }\n      ]\n    end\n    it 'describes a method with parameters' do\n      subject.desc 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } }\n      subject.get 'reverse' do\n        params[:s].reverse\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } } }\n      ]\n    end\n    it 'does not inherit param descriptions in consequent namespaces' do\n      subject.desc 'global description'\n      subject.params do\n        requires :param1\n        optional :param2\n      end\n      subject.namespace 'ns1' do\n        get { ; }\n      end\n      subject.params do\n        optional :param2\n      end\n      subject.namespace 'ns2' do\n        get { ; }\n      end\n      routes_doc = subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end\n      expect(routes_doc).to eq [\n        { description: 'global description',\n          params: {\n            'param1' => { required: true },\n            'param2' => { required: false }\n          } },\n        { description: 'global description',\n          params: {\n            'param2' => { required: false }\n          } }\n      ]\n    end\n    it 'merges the parameters of the namespace with the parameters of the method' do\n      subject.desc 'namespace'\n      subject.params do\n        requires :ns_param, desc: 'namespace parameter'\n      end\n      subject.namespace 'ns' do\n        desc 'method'\n        params do\n          optional :method_param, desc: 'method parameter'\n        end\n        get 'method'\n      end\n\n      routes_doc = subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end\n      expect(routes_doc).to eq [\n        { description: 'method',\n          params: {\n            'ns_param' => { required: true, desc: 'namespace parameter' },\n            'method_param' => { required: false, desc: 'method parameter' }\n          } }\n      ]\n    end\n    it 'merges the parameters of nested namespaces' do\n      subject.desc 'ns1'\n      subject.params do\n        optional :ns_param, desc: 'ns param 1'\n        requires :ns1_param, desc: 'ns1 param'\n      end\n      subject.namespace 'ns1' do\n        desc 'ns2'\n        params do\n          requires :ns_param, desc: 'ns param 2'\n          requires :ns2_param, desc: 'ns2 param'\n        end\n        namespace 'ns2' do\n          desc 'method'\n          params do\n            optional :method_param, desc: 'method param'\n          end\n          get 'method'\n        end\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'method',\n          params: {\n            'ns_param' => { required: true, desc: 'ns param 2' },\n            'ns1_param' => { required: true, desc: 'ns1 param' },\n            'ns2_param' => { required: true, desc: 'ns2 param' },\n            'method_param' => { required: false, desc: 'method param' }\n          } }\n      ]\n    end\n    it 'groups nested params and prevents overwriting of params with same name in different groups' do\n      subject.desc 'method'\n      subject.params do\n        group :group1, type: Array do\n          optional :param1, desc: 'group1 param1 desc'\n          requires :param2, desc: 'group1 param2 desc'\n        end\n        group :group2, type: Array do\n          optional :param1, desc: 'group2 param1 desc'\n          requires :param2, desc: 'group2 param2 desc'\n        end\n      end\n      subject.get 'method'\n\n      expect(subject.routes.map(&:params)).to eq [{\n        'group1'         => { required: true, type: 'Array' },\n        'group1[param1]' => { required: false, desc: 'group1 param1 desc' },\n        'group1[param2]' => { required: true, desc: 'group1 param2 desc' },\n        'group2'         => { required: true, type: 'Array' },\n        'group2[param1]' => { required: false, desc: 'group2 param1 desc' },\n        'group2[param2]' => { required: true, desc: 'group2 param2 desc' }\n      }]\n    end\n    it 'uses full name of parameters in nested groups' do\n      subject.desc 'nesting'\n      subject.params do\n        requires :root_param, desc: 'root param'\n        group :nested, type: Array do\n          requires :nested_param, desc: 'nested param'\n        end\n      end\n      subject.get 'method'\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'nesting',\n          params: {\n            'root_param' => { required: true, desc: 'root param' },\n            'nested' => { required: true, type: 'Array' },\n            'nested[nested_param]' => { required: true, desc: 'nested param' }\n          } }\n      ]\n    end\n    it 'allows to set the type attribute on :group element' do\n      subject.params do\n        group :foo, type: Array do\n          optional :bar\n        end\n      end\n    end\n    it 'parses parameters when no description is given' do\n      subject.params do\n        requires :one_param, desc: 'one param'\n      end\n      subject.get 'method'\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: nil, params: { 'one_param' => { required: true, desc: 'one param' } } }\n      ]\n    end\n    it 'does not symbolize params' do\n      subject.desc 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } }\n      subject.get 'reverse/:s' do\n        params[:s].reverse\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } } }\n      ]\n    end\n  end\n\n  describe '.mount' do\n    let(:mounted_app) { ->(_env) { [200, {}, ['MOUNTED']] } }\n\n    context 'with a bare rack app' do\n      before do\n        subject.mount mounted_app => '/mounty'\n      end\n\n      it 'makes a bare Rack app available at the endpoint' do\n        get '/mounty'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n\n      it 'anchors the routes, passing all subroutes to it' do\n        get '/mounty/awesome'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n\n      it 'is able to cascade' do\n        subject.mount lambda { |env|\n          headers = {}\n          headers['X-Cascade'] == 'pass' unless env['PATH_INFO'].include?('boo')\n          [200, headers, ['Farfegnugen']]\n        } => '/'\n\n        get '/boo'\n        expect(last_response.body).to eq('Farfegnugen')\n        get '/mounty'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n    end\n\n    context 'without a hash' do\n      it 'calls through setting the route to \"/\"' do\n        subject.mount mounted_app\n        get '/'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n    end\n\n    context 'mounting an API' do\n      it 'applies the settings of the mounting api' do\n        subject.version 'v1', using: :path\n\n        subject.namespace :cool do\n          app = Class.new(Grape::API)\n          app.get('/awesome') do\n            'yo'\n          end\n\n          mount app\n        end\n\n        get '/v1/cool/awesome'\n        expect(last_response.body).to eq('yo')\n      end\n\n      it 'applies the settings to nested mounted apis' do\n        subject.version 'v1', using: :path\n\n        subject.namespace :cool do\n          inner_app = Class.new(Grape::API)\n          inner_app.get('/awesome') do\n            'yo'\n          end\n\n          app = Class.new(Grape::API)\n          app.mount inner_app\n          mount app\n        end\n\n        get '/v1/cool/awesome'\n        expect(last_response.body).to eq('yo')\n      end\n\n      context 'when some rescues are defined by mounted' do\n        it 'inherits parent rescues' do\n          subject.rescue_from :all do |e|\n            rack_response(\"rescued from #{e.message}\", 202)\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            app.rescue_from ArgumentError\n            app.get('/fail') { raise 'doh!' }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.status).to eql 202\n          expect(last_response.body).to eq('rescued from doh!')\n        end\n        it 'prefers rescues defined by mounted if they rescue similar error class' do\n          subject.rescue_from StandardError do\n            rack_response('outer rescue')\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            rescue_from StandardError do\n              rack_response('inner rescue')\n            end\n            app.get('/fail') { raise 'doh!' }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.body).to eq('inner rescue')\n        end\n        it 'prefers rescues defined by mounted even if outer is more specific' do\n          subject.rescue_from ArgumentError do\n            rack_response('outer rescue')\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            rescue_from StandardError do\n              rack_response('inner rescue')\n            end\n            app.get('/fail') { raise ArgumentError.new }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.body).to eq('inner rescue')\n        end\n        it 'prefers more specific rescues defined by mounted' do\n          subject.rescue_from StandardError do\n            rack_response('outer rescue')\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            rescue_from ArgumentError do\n              rack_response('inner rescue')\n            end\n            app.get('/fail') { raise ArgumentError.new }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.body).to eq('inner rescue')\n        end\n      end\n\n      it 'collects the routes of the mounted api' do\n        subject.namespace :cool do\n          app = Class.new(Grape::API)\n          app.get('/awesome') {}\n          app.post('/sauce') {}\n          mount app\n        end\n        expect(subject.routes.size).to eq(2)\n        expect(subject.routes.first.path).to match(%r{\\/cool\\/awesome})\n        expect(subject.routes.last.path).to match(%r{\\/cool\\/sauce})\n      end\n\n      it 'mounts on a path' do\n        subject.namespace :cool do\n          app = Class.new(Grape::API)\n          app.get '/awesome' do\n            'sauce'\n          end\n          mount app => '/mounted'\n        end\n        get '/mounted/cool/awesome'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('sauce')\n      end\n\n      it 'mounts on a nested path' do\n        APP1 = Class.new(Grape::API)\n        APP2 = Class.new(Grape::API)\n        APP2.get '/nice' do\n          'play'\n        end\n        # note that the reverse won't work, mount from outside-in\n        APP3 = subject\n        APP3.mount APP1 => '/app1'\n        APP1.mount APP2 => '/app2'\n        get '/app1/app2/nice'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('play')\n        options '/app1/app2/nice'\n        expect(last_response.status).to eq(204)\n      end\n\n      it 'responds to options' do\n        app = Class.new(Grape::API)\n        app.get '/colour' do\n          'red'\n        end\n        app.namespace :pears do\n          get '/colour' do\n            'green'\n          end\n        end\n        subject.namespace :apples do\n          mount app\n        end\n\n        get '/apples/colour'\n        expect(last_response.status).to eql 200\n        expect(last_response.body).to eq('red')\n        options '/apples/colour'\n        expect(last_response.status).to eql 204\n        get '/apples/pears/colour'\n        expect(last_response.status).to eql 200\n        expect(last_response.body).to eq('green')\n        options '/apples/pears/colour'\n        expect(last_response.status).to eql 204\n      end\n\n      it 'responds to options with path versioning' do\n        subject.version 'v1', using: :path\n        subject.namespace :apples do\n          app = Class.new(Grape::API)\n          app.get('/colour') do\n            'red'\n          end\n          mount app\n        end\n\n        get '/v1/apples/colour'\n        expect(last_response.status).to eql 200\n        expect(last_response.body).to eq('red')\n        options '/v1/apples/colour'\n        expect(last_response.status).to eql 204\n      end\n\n      it 'mounts a versioned API with nested resources' do\n        api = Class.new(Grape::API) do\n          version 'v1'\n          resources :users do\n            get :hello do\n              'hello users'\n            end\n          end\n        end\n        subject.mount api\n\n        get '/v1/users/hello'\n        expect(last_response.body).to eq('hello users')\n      end\n\n      it 'mounts a prefixed API with nested resources' do\n        api = Class.new(Grape::API) do\n          prefix 'api'\n          resources :users do\n            get :hello do\n              'hello users'\n            end\n          end\n        end\n        subject.mount api\n\n        get '/api/users/hello'\n        expect(last_response.body).to eq('hello users')\n      end\n\n      it 'applies format to a mounted API with nested resources' do\n        api = Class.new(Grape::API) do\n          format :json\n          resources :users do\n            get do\n              { users: true }\n            end\n          end\n        end\n        subject.mount api\n\n        get '/users'\n        expect(last_response.body).to eq({ users: true }.to_json)\n      end\n\n      it 'applies auth to a mounted API with nested resources' do\n        api = Class.new(Grape::API) do\n          format :json\n          http_basic do |username, password|\n            username == 'username' && password == 'password'\n          end\n          resources :users do\n            get do\n              { users: true }\n            end\n          end\n        end\n        subject.mount api\n\n        get '/users'\n        expect(last_response.status).to eq(401)\n\n        get '/users', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('username', 'password')\n        expect(last_response.body).to eq({ users: true }.to_json)\n      end\n\n      it 'mounts multiple versioned APIs with nested resources' do\n        api1 = Class.new(Grape::API) do\n          version 'one', using: :header, vendor: 'test'\n          resources :users do\n            get :hello do\n              'one'\n            end\n          end\n        end\n\n        api2 = Class.new(Grape::API) do\n          version 'two', using: :header, vendor: 'test'\n          resources :users do\n            get :hello do\n              'two'\n            end\n          end\n        end\n\n        subject.mount api1\n        subject.mount api2\n\n        versioned_get '/users/hello', 'one', using: :header, vendor: 'test'\n        expect(last_response.body).to eq('one')\n        versioned_get '/users/hello', 'two', using: :header, vendor: 'test'\n        expect(last_response.body).to eq('two')\n      end\n\n      it 'recognizes potential versions with mounted path' do\n        a = Class.new(Grape::API) do\n          version :v1, using: :path\n\n          get '/hello' do\n            'hello'\n          end\n        end\n\n        b = Class.new(Grape::API) do\n          version :v1, using: :path\n\n          get '/world' do\n            'world'\n          end\n        end\n\n        subject.mount a => '/one'\n        subject.mount b => '/two'\n\n        get '/one/v1/hello'\n        expect(last_response.status).to eq 200\n\n        get '/two/v1/world'\n        expect(last_response.status).to eq 200\n      end\n\n      context 'when mounting class extends a subclass of Grape::API' do\n        it 'mounts APIs with the same superclass' do\n          base_api = Class.new(Grape::API)\n          a = Class.new(base_api)\n          b = Class.new(base_api)\n\n          expect { a.mount b }.to_not raise_error\n        end\n      end\n    end\n  end\n\n  describe '.endpoints' do\n    it 'adds one for each route created' do\n      subject.get '/'\n      subject.post '/'\n      expect(subject.endpoints.size).to eq(2)\n    end\n  end\n\n  describe '.compile' do\n    it 'sets the instance' do\n      expect(subject.instance).to be_nil\n      subject.compile\n      expect(subject.instance).to be_kind_of(subject)\n    end\n  end\n\n  describe '.change!' do\n    it 'invalidates any compiled instance' do\n      subject.compile\n      subject.change!\n      expect(subject.instance).to be_nil\n    end\n  end\n\n  describe '.endpoint' do\n    before(:each) do\n      subject.format :json\n      subject.get '/endpoint/options' do\n        {\n          path: options[:path],\n          source_location: source.source_location\n        }\n      end\n    end\n    it 'path' do\n      get '/endpoint/options'\n      options = ::Grape::Json.load(last_response.body)\n      expect(options['path']).to eq(['/endpoint/options'])\n      expect(options['source_location'][0]).to include 'api_spec.rb'\n      expect(options['source_location'][1].to_i).to be > 0\n    end\n  end\n\n  describe '.route' do\n    context 'plain' do\n      before(:each) do\n        subject.get '/' do\n          route.path\n        end\n        subject.get '/path' do\n          route.path\n        end\n      end\n      it 'provides access to route info' do\n        get '/'\n        expect(last_response.body).to eq('/(.:format)')\n        get '/path'\n        expect(last_response.body).to eq('/path(.:format)')\n      end\n    end\n    context 'with desc' do\n      before(:each) do\n        subject.desc 'returns description'\n        subject.get '/description' do\n          route.description\n        end\n        subject.desc 'returns parameters', params: { 'x' => 'y' }\n        subject.get '/params/:id' do\n          route.params[params[:id]]\n        end\n      end\n      it 'returns route description' do\n        get '/description'\n        expect(last_response.body).to eq('returns description')\n      end\n      it 'returns route parameters' do\n        get '/params/x'\n        expect(last_response.body).to eq('y')\n      end\n    end\n  end\n  describe '.format' do\n    context ':txt' do\n      before(:each) do\n        subject.format :txt\n        subject.content_type :json, 'application/json'\n        subject.get '/meaning_of_life' do\n          { meaning_of_life: 42 }\n        end\n      end\n      it 'forces txt without an extension' do\n        get '/meaning_of_life'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'does not force txt with an extension' do\n        get '/meaning_of_life.json'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_json)\n      end\n      it 'forces txt from a non-accepting header' do\n        get '/meaning_of_life', {}, 'HTTP_ACCEPT' => 'application/json'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n    end\n    context ':txt only' do\n      before(:each) do\n        subject.format :txt\n        subject.get '/meaning_of_life' do\n          { meaning_of_life: 42 }\n        end\n      end\n      it 'forces txt without an extension' do\n        get '/meaning_of_life'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'accepts specified extension' do\n        get '/meaning_of_life.txt'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'does not accept extensions other than specified' do\n        get '/meaning_of_life.json'\n        expect(last_response.status).to eq(404)\n      end\n      it 'forces txt from a non-accepting header' do\n        get '/meaning_of_life', {}, 'HTTP_ACCEPT' => 'application/json'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n    end\n    context ':json' do\n      before(:each) do\n        subject.format :json\n        subject.content_type :txt, 'text/plain'\n        subject.get '/meaning_of_life' do\n          { meaning_of_life: 42 }\n        end\n      end\n      it 'forces json without an extension' do\n        get '/meaning_of_life'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_json)\n      end\n      it 'does not force json with an extension' do\n        get '/meaning_of_life.txt'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'forces json from a non-accepting header' do\n        get '/meaning_of_life', {}, 'HTTP_ACCEPT' => 'text/html'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_json)\n      end\n      it 'can be overwritten with an explicit content type' do\n        subject.get '/meaning_of_life_with_content_type' do\n          content_type 'text/plain'\n          { meaning_of_life: 42 }.to_s\n        end\n        get '/meaning_of_life_with_content_type'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'raised :error from middleware' do\n        middleware = Class.new(Grape::Middleware::Base) do\n          def before\n            throw :error, message: 'Unauthorized', status: 42\n          end\n        end\n        subject.use middleware\n        subject.get do\n        end\n        get '/'\n        expect(last_response.status).to eq(42)\n        expect(last_response.body).to eq({ error: 'Unauthorized' }.to_json)\n      end\n    end\n    context ':serializable_hash' do\n      before(:each) do\n        class SerializableHashExample\n          def serializable_hash\n            { abc: 'def' }\n          end\n        end\n        subject.format :serializable_hash\n      end\n      it 'instance' do\n        subject.get '/example' do\n          SerializableHashExample.new\n        end\n        get '/example'\n        expect(last_response.body).to eq('{\"abc\":\"def\"}')\n      end\n      it 'root' do\n        subject.get '/example' do\n          { 'root' => SerializableHashExample.new }\n        end\n        get '/example'\n        expect(last_response.body).to eq('{\"root\":{\"abc\":\"def\"}}')\n      end\n      it 'array' do\n        subject.get '/examples' do\n          [SerializableHashExample.new, SerializableHashExample.new]\n        end\n        get '/examples'\n        expect(last_response.body).to eq('[{\"abc\":\"def\"},{\"abc\":\"def\"}]')\n      end\n    end\n    context ':xml' do\n      before(:each) do\n        subject.format :xml\n      end\n      it 'string' do\n        subject.get '/example' do\n          'example'\n        end\n        get '/example'\n        expect(last_response.status).to eq(500)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error>\n  <message>cannot convert String to xml</message>\n</error>\nXML\n      end\n      it 'hash' do\n        subject.get '/example' do\n          {\n            example1: 'example1',\n            example2: 'example2'\n          }\n        end\n        get '/example'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<hash>\n  <example1>example1</example1>\n  <example2>example2</example2>\n</hash>\nXML\n      end\n      it 'array' do\n        subject.get '/example' do\n          %w[example1 example2]\n        end\n        get '/example'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<strings type=\"array\">\n  <string>example1</string>\n  <string>example2</string>\n</strings>\nXML\n      end\n      it 'raised :error from middleware' do\n        middleware = Class.new(Grape::Middleware::Base) do\n          def before\n            throw :error, message: 'Unauthorized', status: 42\n          end\n        end\n        subject.use middleware\n        subject.get do\n        end\n        get '/'\n        expect(last_response.status).to eq(42)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error>\n  <message>Unauthorized</message>\n</error>\nXML\n      end\n    end\n  end\n\n  context 'catch-all' do\n    before do\n      api1 = Class.new(Grape::API)\n      api1.version 'v1', using: :path\n      api1.get 'hello' do\n        'v1'\n      end\n      api2 = Class.new(Grape::API)\n      api2.version 'v2', using: :path\n      api2.get 'hello' do\n        'v2'\n      end\n      subject.mount api1\n      subject.mount api2\n    end\n    [true, false].each do |anchor|\n      it \"anchor=#{anchor}\" do\n        subject.route :any, '*path', anchor: anchor do\n          error!(\"Unrecognized request path: #{params[:path]} - #{env['PATH_INFO']}#{env['SCRIPT_NAME']}\", 404)\n        end\n        get '/v1/hello'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('v1')\n        get '/v2/hello'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('v2')\n        options '/v2/hello'\n        expect(last_response.status).to eq(204)\n        expect(last_response.body).to be_blank\n        head '/v2/hello'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to be_blank\n        get '/foobar'\n        expect(last_response.status).to eq(404)\n        expect(last_response.body).to eq('Unrecognized request path: foobar - /foobar')\n      end\n    end\n  end\n\n  context 'cascading' do\n    context 'via version' do\n      it 'cascades' do\n        subject.version 'v1', using: :path, cascade: true\n        get '/v1/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers['X-Cascade']).to eq('pass')\n      end\n      it 'does not cascade' do\n        subject.version 'v2', using: :path, cascade: false\n        get '/v2/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers.keys).not_to include 'X-Cascade'\n      end\n    end\n    context 'via endpoint' do\n      it 'cascades' do\n        subject.cascade true\n        get '/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers['X-Cascade']).to eq('pass')\n      end\n      it 'does not cascade' do\n        subject.cascade false\n        get '/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers.keys).not_to include 'X-Cascade'\n      end\n    end\n  end\n\n  context 'with json default_error_formatter' do\n    it 'returns json error' do\n      subject.content_type :json, 'application/json'\n      subject.default_error_formatter :json\n      subject.get '/something' do\n        'foo'\n      end\n      get '/something'\n      expect(last_response.status).to eq(406)\n      expect(last_response.body).to eq(\"{\\\"error\\\":\\\"The requested format 'txt' is not supported.\\\"}\")\n    end\n  end\n\n  context 'body' do\n    context 'false' do\n      before do\n        subject.get '/blank' do\n          body false\n        end\n      end\n      it 'returns blank body' do\n        get '/blank'\n        expect(last_response.status).to eq(204)\n        expect(last_response.body).to be_blank\n      end\n    end\n    context 'plain text' do\n      before do\n        subject.get '/text' do\n          content_type 'text/plain'\n          body 'Hello World'\n          'ignored'\n        end\n      end\n      it 'returns blank body' do\n        get '/text'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq 'Hello World'\n      end\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe Grape::Middleware::Error do\n  # raises a text exception\n  module ExceptionSpec\n    class ExceptionApp\n      class << self\n        def call(_env)\n          raise 'rain!'\n        end\n      end\n    end\n\n    # raises a non-StandardError (ScriptError) exception\n    class OtherExceptionApp\n      class << self\n        def call(_env)\n          raise NotImplementedError, 'snow!'\n        end\n      end\n    end\n\n    # raises a hash error\n    class ErrorHashApp\n      class << self\n        def error!(message, status)\n          throw :error, message: { error: message, detail: 'missing widget' }, status: status\n        end\n\n        def call(_env)\n          error!('rain!', 401)\n        end\n      end\n    end\n\n    # raises an error!\n    class AccessDeniedApp\n      class << self\n        def error!(message, status)\n          throw :error, message: message, status: status\n        end\n\n        def call(_env)\n          error!('Access Denied', 401)\n        end\n      end\n    end\n\n    # raises a custom error\n    class CustomError < Grape::Exceptions::Base\n    end\n\n    class CustomErrorApp\n      class << self\n        def call(_env)\n          raise CustomError, status: 400, message: 'failed validation'\n        end\n      end\n    end\n  end\n\n  def app\n    subject\n  end\n\n  context 'with defaults' do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'does not trap errors by default' do\n      expect { get '/' }.to raise_error(RuntimeError, 'rain!')\n    end\n  end\n\n  context 'with rescue_all' do\n    context 'StandardError exception' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_all: true\n          run ExceptionSpec::ExceptionApp\n        end\n      end\n      it 'sets the message appropriately' do\n        get '/'\n        expect(last_response.body).to eq('rain!')\n      end\n      it 'defaults to a 500 status' do\n        get '/'\n        expect(last_response.status).to eq(500)\n      end\n    end\n\n    context 'Non-StandardError exception' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_all: true\n          run ExceptionSpec::OtherExceptionApp\n        end\n      end\n      it 'does not trap errors other than StandardError' do\n        expect { get '/' }.to raise_error(NotImplementedError, 'snow!')\n      end\n    end\n  end\n\n  context 'Non-StandardError exception with a provided rescue handler' do\n    context 'default error response' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_handlers: { NotImplementedError => nil }\n          run ExceptionSpec::OtherExceptionApp\n        end\n      end\n      it 'rescues the exception using the default handler' do\n        get '/'\n        expect(last_response.body).to eq('snow!')\n      end\n    end\n\n    context 'custom error response' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_handlers: { NotImplementedError => -> { [200, {}, 'rescued'] } }\n          run ExceptionSpec::OtherExceptionApp\n        end\n      end\n      it 'rescues the exception using the provided handler' do\n        get '/'\n        expect(last_response.body).to eq('rescued')\n      end\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, default_status: 500\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to specify a different default status code' do\n      get '/'\n      expect(last_response.status).to eq(500)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :json\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return errors in json format' do\n      get '/'\n      expect(last_response.body).to eq('{\"error\":\"rain!\"}')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :json\n        run ExceptionSpec::ErrorHashApp\n      end\n    end\n    it 'is possible to return hash errors in json format' do\n      get '/'\n      expect(['{\"error\":\"rain!\",\"detail\":\"missing widget\"}',\n              '{\"detail\":\"missing widget\",\"error\":\"rain!\"}']).to include(last_response.body)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :jsonapi\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return errors in jsonapi format' do\n      get '/'\n      expect(last_response.body).to eq('{\"error\":\"rain!\"}')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :jsonapi\n        run ExceptionSpec::ErrorHashApp\n      end\n    end\n\n    it 'is possible to return hash errors in jsonapi format' do\n      get '/'\n      expect(['{\"error\":\"rain!\",\"detail\":\"missing widget\"}',\n              '{\"detail\":\"missing widget\",\"error\":\"rain!\"}']).to include(last_response.body)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :xml\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return errors in xml format' do\n      get '/'\n      expect(last_response.body).to eq(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<error>\\n  <message>rain!</message>\\n</error>\\n\")\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :xml\n        run ExceptionSpec::ErrorHashApp\n      end\n    end\n    it 'is possible to return hash errors in xml format' do\n      get '/'\n      expect([\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<error>\\n  <detail>missing widget</detail>\\n  <error>rain!</error>\\n</error>\\n\",\n              \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<error>\\n  <error>rain!</error>\\n  <detail>missing widget</detail>\\n</error>\\n\"]).to include(last_response.body)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :custom,\n            error_formatters: {\n              custom: lambda do |message, _backtrace, _options, _env, _original_exception|\n                { custom_formatter: message }.inspect\n              end\n            }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to specify a custom formatter' do\n      get '/'\n      expect(last_response.body).to eq('{:custom_formatter=>\"rain!\"}')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error\n        run ExceptionSpec::AccessDeniedApp\n      end\n    end\n    it 'does not trap regular error! codes' do\n      get '/'\n      expect(last_response.status).to eq(401)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: false\n        run ExceptionSpec::CustomErrorApp\n      end\n    end\n    it 'responds to custom Grape exceptions appropriately' do\n      get '/'\n      expect(last_response.status).to eq(400)\n      expect(last_response.body).to eq('failed validation')\n    end\n  end\n\n  context 'with rescue_options :backtrace and :exception set to true' do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :json,\n            rescue_options: { backtrace: true, original_exception: true }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return the backtrace and the original exception in json format' do\n      get '/'\n      expect(last_response.body).to include('error', 'rain!', 'backtrace', 'original_exception', 'RuntimeError')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :xml,\n            rescue_options: { backtrace: true, original_exception: true }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return the backtrace and the original exception in xml format' do\n      get '/'\n      expect(last_response.body).to include('error', 'rain!', 'backtrace', 'original-exception', 'RuntimeError')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :txt,\n            rescue_options: { backtrace: true, original_exception: true }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return the backtrace and the original exception in txt format' do\n      get '/'\n      expect(last_response.body).to include('error', 'rain!', 'backtrace', 'original exception', 'RuntimeError')\n    end\n  end\nend\n"], "fixing_code": ["### 1.0.4 (Next)\n\n#### Features\n\n* [#1759](https://github.com/ruby-grape/grape/pull/1759): Instrument serialization as `'format_response.grape'` - [@zvkemp](https://github.com/zvkemp).\n\n#### Fixes\n\n\n* [#1762](https://github.com/ruby-grape/grape/pull/1763): Fix unsafe HTML rendering on errors - [@ctennis](https://github.com/ctennis).\n* [#1759](https://github.com/ruby-grape/grape/pull/1759): Update appraisal for rails_edge - [@zvkemp](https://github.com/zvkemp).\n* [#1758](https://github.com/ruby-grape/grape/pull/1758): Fix expanding load_path in gemspec - [@2maz](https://github.com/2maz).\n* Your contribution here.\n\n### 1.0.3 (4/23/2018)\n\n#### Fixes\n\n* [#1755](https://github.com/ruby-grape/grape/pull/1755): Fix shared params with exactly_one_of - [@milgner](https://github.com/milgner).\n* [#1740](https://github.com/ruby-grape/grape/pull/1740): Fix dependent parameter validation using `given` when parameter is a `Hash` - [@jvortmann](https://github.com/jvortmann).\n* [#1737](https://github.com/ruby-grape/grape/pull/1737): Fix translating error when passing symbols as params in custom validations - [@mlzhuyi](https://github.com/mlzhuyi).\n* [#1749](https://github.com/ruby-grape/grape/pull/1749): Allow rescue from non-`StandardError` exceptions - [@dm1try](https://github.com/dm1try).\n* [#1750](https://github.com/ruby-grape/grape/pull/1750): Fix a circular dependency warning due to router being loaded by API - [@salasrod](https://github.com/salasrod).\n* [#1752](https://github.com/ruby-grape/grape/pull/1752): Fix `include_missing` behavior for aliased parameters - [@jonasoberschweiber](https://github.com/jonasoberschweiber).\n* [#1754](https://github.com/ruby-grape/grape/pull/1754): Allow rescue from non-`StandardError` exceptions to use default error handling - [@jelkster](https://github.com/jelkster).\n* [#1756](https://github.com/ruby-grape/grape/pull/1756): Allow custom Grape exception handlers when the built-in exception handling is enabled - [@soylent](https://github.com/soylent).\n\n### 1.0.2 (1/10/2018)\n\n#### Features\n\n* [#1686](https://github.com/ruby-grape/grape/pull/1686): Avoid coercion of a value if it is valid - [@timothysu](https://github.com/timothysu).\n* [#1688](https://github.com/ruby-grape/grape/pull/1688): Removes yard docs - [@ramkumar-kr](https://github.com/ramkumar-kr).\n* [#1702](https://github.com/ruby-grape/grape/pull/1702): Added danger-toc, verify correct TOC in README - [@dblock](https://github.com/dblock).\n* [#1711](https://github.com/ruby-grape/grape/pull/1711): Automatically coerce arrays and sets of types that implement a `parse` method - [@dslh](https://github.com/dslh).\n\n#### Fixes\n\n* [#1710](https://github.com/ruby-grape/grape/pull/1710): Fix wrong transformation of empty Array in declared params - [@pablonahuelgomez](https://github.com/pablonahuelgomez).\n* [#1722](https://github.com/ruby-grape/grape/pull/1722): Fix catch-all hiding multiple versions of an endpoint after the first definition - [@zherr](https://github.com/zherr).\n* [#1724](https://github.com/ruby-grape/grape/pull/1724): Optional nested array validation - [@ericproulx](https://github.com/ericproulx).\n* [#1725](https://github.com/ruby-grape/grape/pull/1725): Fix `rescue_from :all` documentation - [@Jelkster](https://github.com/Jelkster).\n* [#1726](https://github.com/ruby-grape/grape/pull/1726): Improved startup performance during API method generation - [@jkowens](https://github.com/jkowens).\n* [#1727](https://github.com/ruby-grape/grape/pull/1727): Fix infinite loop when mounting endpoint with same superclass - [@jkowens](https://github.com/jkowens).\n\n### 1.0.1 (9/8/2017)\n\n#### Features\n\n* [#1652](https://github.com/ruby-grape/grape/pull/1652): Add the original exception to the error_formatter the original exception - [@dcsg](https://github.com/dcsg).\n* [#1665](https://github.com/ruby-grape/grape/pull/1665): Make helpers available in subclasses - [@pablonahuelgomez](https://github.com/pablonahuelgomez).\n* [#1674](https://github.com/ruby-grape/grape/pull/1674): Add parameter alias (`as`) - [@glaucocustodio](https://github.com/glaucocustodio).\n\n#### Fixes\n\n* [#1652](https://github.com/ruby-grape/grape/pull/1652): Fix missing backtrace that was not being bubbled up to the `error_formatter` - [@dcsg](https://github.com/dcsg).\n* [#1661](https://github.com/ruby-grape/grape/pull/1661): Handle deeply-nested dependencies correctly - [@rnubel](https://github.com/rnubel), [@jnardone](https://github.com/jnardone).\n* [#1679](https://github.com/ruby-grape/grape/pull/1679): Treat StandardError from explicit values validator proc as false - [@jlfaber](https://github.com/jlfaber).\n\n### 1.0.0 (7/3/2017)\n\n#### Features\n\n* [#1594](https://github.com/ruby-grape/grape/pull/1594): Replace `Hashie::Mash` parameters with `ActiveSupport::HashWithIndifferentAccess` - [@james2m](https://github.com/james2m), [@dblock](https://github.com/dblock).\n* [#1622](https://github.com/ruby-grape/grape/pull/1622): Add `except_values` validator to replace `except` option of `values` validator - [@jlfaber](https://github.com/jlfaber).\n* [#1635](https://github.com/ruby-grape/grape/pull/1635): Instrument validators with ActiveSupport::Notifications - [@ktimothy](https://github.com/ktimothy).\n* [#1646](https://github.com/ruby-grape/grape/pull/1646): Add ability to include an array of modules as helpers - [@pablonahuelgomez](https://github.com/pablonahuelgomez).\n* [#1623](https://github.com/ruby-grape/grape/pull/1623): Removed `multi_json` and `multi_xml` dependencies - [@dblock](https://github.com/dblock).\n* [#1650](https://github.com/ruby-grape/grape/pull/1650): Add extra specs for Boolean type field - [@tiarly](https://github.com/tiarly).\n\n#### Fixes\n\n* [#1648](https://github.com/ruby-grape/grape/pull/1631): Declared now returns declared options using the class that params is set to use - [@thogg4](https://github.com/thogg4).\n* [#1632](https://github.com/ruby-grape/grape/pull/1632): Silence warnings - [@thogg4](https://github.com/thogg4).\n* [#1615](https://github.com/ruby-grape/grape/pull/1615): Fix default and type validator when values is a Hash with no value attribute - [@jlfaber](https://github.com/jlfaber).\n* [#1625](https://github.com/ruby-grape/grape/pull/1625): Handle `given` correctly when nested in Array params - [@rnubel](https://github.com/rnubel), [@avellable](https://github.com/avellable).\n* [#1649](https://github.com/ruby-grape/grape/pull/1649): Don't share validator instances between requests - [@anakinj](https://github.com/anakinj).\n\n### 0.19.2 (4/12/2017)\n\n#### Features\n\n* [#1555](https://github.com/ruby-grape/grape/pull/1555): Added code coverage w/Coveralls - [@dblock](https://github.com/dblock).\n* [#1568](https://github.com/ruby-grape/grape/pull/1568): Add `proc` option to `values` validator to allow custom checks - [@jlfaber](https://github.com/jlfaber).\n* [#1575](https://github.com/ruby-grape/grape/pull/1575): Include nil values for missing nested params in declared - [@thogg4](https://github.com/thogg4).\n* [#1585](https://github.com/ruby-grape/grape/pull/1585): Bugs in declared method - make sure correct options var is used and respect include missing for non children params - [@thogg4](https://github.com/thogg4).\n\n#### Fixes\n\n* [#1570](https://github.com/ruby-grape/grape/pull/1570): Make versioner consider the mount destination path - [@namusyaka](https://github.com/namusyaka).\n* [#1579](https://github.com/ruby-grape/grape/pull/1579): Fix delete status with a return value - [@eproulx-petalmd](https://github.com/eproulx-petalmd).\n* [#1559](https://github.com/ruby-grape/grape/pull/1559): You can once again pass `nil` to optional attributes with `values` validation set - [@ghiculescu](https://github.com/ghiculescu).\n* [#1562](https://github.com/ruby-grape/grape/pull/1562): Fix rainbow gem installation failure above ruby 2.3.3 on travis-ci - [@brucehsu](https://github.com/brucehsu).\n* [#1561](https://github.com/ruby-grape/grape/pull/1561): Fix performance issue introduced by duplicated calls in StackableValue#[] - [@brucehsu](https://github.com/brucehsu).\n* [#1564](https://github.com/ruby-grape/grape/pull/1564): Fix declared params bug with nested namespaces - [@bmarini](https://github.com/bmarini).\n* [#1567](https://github.com/ruby-grape/grape/pull/1567): Fix values validator when value is empty array and apply except to input array - [@jlfaber](https://github.com/jlfaber).\n* [#1569](https://github.com/ruby-grape/grape/pull/1569), [#1511](https://github.com/ruby-grape/grape/issues/1511): Upgrade mustermann-grape to 1.0.0 - [@namusyaka](https://github.com/namusyaka).\n* [#1589](https://github.com/ruby-grape/grape/pull/1589): [#726](https://github.com/ruby-grape/grape/issues/726): Use default_format when Content-type is missing and respond with 406 when Content-type is invalid - [@inclooder](https://github.com/inclooder).\n\n### 0.19.1 (1/9/2017)\n\n#### Features\n\n* [#1536](https://github.com/ruby-grape/grape/pull/1536): Updated `invalid_versioner_option` translation - [@Lavode](https://github.com/Lavode).\n* [#1543](https://github.com/ruby-grape/grape/pull/1543): Added support for ruby 2.4 - [@LeFnord](https://github.com/LeFnord), [@namusyaka](https://github.com/namusyaka).\n\n#### Fixes\n\n* [#1548](https://github.com/ruby-grape/grape/pull/1548): Fix: avoid failing even if given path does not match with prefix - [@thomas-peyric](https://github.com/thomas-peyric), [@namusyaka](https://github.com/namusyaka).\n* [#1550](https://github.com/ruby-grape/grape/pull/1550): Fix: return 200 as default status for DELETE - [@jthornec](https://github.com/jthornec).\n\n### 0.19.0 (12/18/2016)\n\n#### Features\n\n* [#1503](https://github.com/ruby-grape/grape/pull/1503): Allowed use of regexp validator with arrays - [@akoltun](https://github.com/akoltun).\n* [#1507](https://github.com/ruby-grape/grape/pull/1507): Added group attributes for parameter definitions - [@304](https://github.com/304).\n* [#1532](https://github.com/ruby-grape/grape/pull/1532): Set 204 as default status for DELETE - [@LeFnord](https://github.com/LeFnord).\n\n#### Fixes\n\n* [#1505](https://github.com/ruby-grape/grape/pull/1505): Run `before` and `after` callbacks, but skip the rest when handling OPTIONS - [@jlfaber](https://github.com/jlfaber).\n* [#1517](https://github.com/ruby-grape/grape/pull/1517), [#1089](https://github.com/ruby-grape/grape/pull/1089): Fix: priority of ANY routes - [@namusyaka](https://github.com/namusyaka), [@wagenet](https://github.com/wagenet).\n* [#1512](https://github.com/ruby-grape/grape/pull/1512): Fix: deeply nested parameters are included within `#declared(params)` - [@krbs](https://github.com/krbs).\n* [#1510](https://github.com/ruby-grape/grape/pull/1510): Fix: inconsistent validation for multiple parameters - [@dgasper](https://github.com/dgasper).\n* [#1526](https://github.com/ruby-grape/grape/pull/1526): Reduced warnings caused by instance variables not initialized - [@cpetschnig](https://github.com/cpetschnig).\n\n### 0.18.0 (10/7/2016)\n\n#### Features\n\n* [#1480](https://github.com/ruby-grape/grape/pull/1480): Used the ruby-grape-danger gem for PR linting - [@dblock](https://github.com/dblock).\n* [#1486](https://github.com/ruby-grape/grape/pull/1486): Implemented except in values validator - [@jonmchan](https://github.com/jonmchan).\n* [#1470](https://github.com/ruby-grape/grape/pull/1470): Dropped support for Ruby 2.0 - [@namusyaka](https://github.com/namusyaka).\n* [#1490](https://github.com/ruby-grape/grape/pull/1490): Switched to Ruby-2.x+ syntax - [@namusyaka](https://github.com/namusyaka).\n* [#1499](https://github.com/ruby-grape/grape/pull/1499): Support `fail_fast` param validation option - [@dgasper](https://github.com/dgasper).\n\n#### Fixes\n\n* [#1498](https://github.com/ruby-grape/grape/pull/1498): Fix: skip validations in inactive given blocks - [@jlfaber](https://github.com/jlfaber).\n* [#1479](https://github.com/ruby-grape/grape/pull/1479): Fix: support inserting middleware before/after anonymous classes in the middleware stack - [@rosa](https://github.com/rosa).\n* [#1488](https://github.com/ruby-grape/grape/pull/1488): Fix: ensure calling before filters when receiving OPTIONS request - [@namusyaka](https://github.com/namusyaka), [@jlfaber](https://github.com/jlfaber).\n* [#1493](https://github.com/ruby-grape/grape/pull/1493): Fix: coercion and lambda fails params validation - [@jonmchan](https://github.com/jonmchan).\n\n### 0.17.0 (7/29/2016)\n\n#### Features\n\n* [#1393](https://github.com/ruby-grape/grape/pull/1393): Middleware can be inserted before or after default Grape middleware - [@ridiculous](https://github.com/ridiculous).\n* [#1390](https://github.com/ruby-grape/grape/pull/1390): Allowed inserting middleware at arbitrary points in the middleware stack - [@rosa](https://github.com/rosa).\n* [#1366](https://github.com/ruby-grape/grape/pull/1366): Stored `message_key` on `Grape::Exceptions::Validation` - [@mkou](https://github.com/mkou).\n* [#1398](https://github.com/ruby-grape/grape/pull/1398): Added `rescue_from :grape_exceptions` - allow Grape to use the built-in `Grape::Exception` handing and use `rescue :all` behavior for everything else - [@mmclead](https://github.com/mmclead).\n* [#1443](https://github.com/ruby-grape/grape/pull/1443): Extended `given` to receive a `Proc` - [@glaucocustodio](https://github.com/glaucocustodio).\n* [#1455](https://github.com/ruby-grape/grape/pull/1455): Added an automated PR linter - [@orta](https://github.com/orta).\n\n#### Fixes\n\n* [#1463](https://github.com/ruby-grape/grape/pull/1463): Fix array indicies in error messages - [@ffloyd](https://github.com/ffloyd).\n* [#1465](https://github.com/ruby-grape/grape/pull/1465): Fix 'before' being called twice when using not allowed method - [@jsteinberg](https://github.com/jsteinberg).\n* [#1446](https://github.com/ruby-grape/grape/pull/1446): Fix for `env` inside `before` when using not allowed method - [@leifg](https://github.com/leifg).\n* [#1438](https://github.com/ruby-grape/grape/pull/1439): Try to dup non-frozen default params with each use - [@jlfaber](https://github.com/jlfaber).\n* [#1430](https://github.com/ruby-grape/grape/pull/1430): Fix for `declared(params)` inside `route_param` - [@Arkanain](https://github.com/Arkanain).\n* [#1405](https://github.com/ruby-grape/grape/pull/1405): Fix priority of `rescue_from` clauses applying - [@hedgesky](https://github.com/hedgesky).\n* [#1365](https://github.com/ruby-grape/grape/pull/1365): Fix finding exception handler in error middleware - [@ktimothy](https://github.com/ktimothy).\n* [#1380](https://github.com/ruby-grape/grape/pull/1380): Fix `allow_blank: false` for `Time` attributes with valid values causes `NoMethodError` - [@ipkes](https://github.com/ipkes).\n* [#1384](https://github.com/ruby-grape/grape/pull/1384): Fix parameter validation with an empty optional nested `Array` - [@ipkes](https://github.com/ipkes).\n* [#1414](https://github.com/ruby-grape/grape/pull/1414): Fix multiple version definitions for path versioning - [@304](https://github.com/304).\n* [#1415](https://github.com/ruby-grape/grape/pull/1415): Fix `declared(params, include_parent_namespaces: false)` - [@304](https://github.com/304).\n* [#1421](https://github.com/ruby-grape/grape/pull/1421): Avoid polluting `Grape::Middleware::Error` - [@namusyaka](https://github.com/namusyaka).\n* [#1422](https://github.com/ruby-grape/grape/pull/1422): Concat parent declared params with current one - [@plukevdh](https://github.com/plukevdh), [@rnubel](https://github.com/rnubel), [@namusyaka](https://github.com/namusyaka).\n\n### 0.16.2 (4/12/2016)\n\n#### Features\n\n* [#1348](https://github.com/ruby-grape/grape/pull/1348): Fix global functions polluting Grape::API scope - [@dblock](https://github.com/dblock).\n* [#1357](https://github.com/ruby-grape/grape/pull/1357): Expose Route#options - [@namusyaka](https://github.com/namusyaka).\n\n#### Fixes\n\n* [#1357](https://github.com/ruby-grape/grape/pull/1357): Don't include fixed named captures as route params - [@namusyaka](https://github.com/namusyaka).\n* [#1359](https://github.com/ruby-grape/grape/pull/1359): Avoid evaluating the same route twice - [@namusyaka](https://github.com/namusyaka), [@dblock](https://github.com/dblock).\n* [#1361](https://github.com/ruby-grape/grape/pull/1361): Return 405 correctly even if version is using as header and wrong request method - [@namusyaka](https://github.com/namusyaka), [@dblock](https://github.com/dblock).\n\n### 0.16.1 (4/3/2016)\n\n#### Features\n\n* [#1276](https://github.com/ruby-grape/grape/pull/1276): Replace rack-mount with new router - [@namusyaka](https://github.com/namusyaka).\n* [#1321](https://github.com/ruby-grape/grape/pull/1321): Serve files without using FileStreamer-like object - [@lfidnl](https://github.com/lfidnl).\n* [#1339](https://github.com/ruby-grape/grape/pull/1339): Implement Grape::API.recognize_path - [@namusyaka](https://github.com/namusyaka).\n\n#### Fixes\n\n* [#1325](https://github.com/ruby-grape/grape/pull/1325): Params: Fix coerce_with helper with Array types - [@ngonzalez](https://github.com/ngonzalez).\n* [#1326](https://github.com/ruby-grape/grape/pull/1326): Fix wrong behavior for OPTIONS and HEAD requests with catch-all - [@ekampp](https://github.com/ekampp), [@namusyaka](https://github.com/namusyaka).\n* [#1330](https://github.com/ruby-grape/grape/pull/1330): Add `register` keyword for adding customized parsers and formatters - [@namusyaka](https://github.com/namusyaka).\n* [#1336](https://github.com/ruby-grape/grape/pull/1336): Do not modify Hash argument to `error!` - [@tjwp](https://github.com/tjwp).\n\n### 0.15.0 (3/8/2016)\n\n#### Features\n\n* [#1227](https://github.com/ruby-grape/grape/pull/1227): Store `message_key` on `Grape::Exceptions::Validation` - [@stjhimy](https://github.com/sthimy).\n* [#1232](https://github.com/ruby-grape/grape/pull/1232): Helpers are now available inside `rescue_from` - [@namusyaka](https://github.com/namusyaka).\n* [#1237](https://github.com/ruby-grape/grape/pull/1237): Allow multiple parameters in `given`, which behaves as if the scopes were nested in the inputted order - [@ochagata](https://github.com/ochagata).\n* [#1238](https://github.com/ruby-grape/grape/pull/1238): Call `after` of middleware on error - [@namusyaka](https://github.com/namusyaka).\n* [#1243](https://github.com/ruby-grape/grape/pull/1243): Add `header` support for middleware - [@namusyaka](https://github.com/namusyaka).\n* [#1252](https://github.com/ruby-grape/grape/pull/1252): Allow default to be a subset or equal to allowed values without raising IncompatibleOptionValues - [@jeradphelps](https://github.com/jeradphelps).\n* [#1255](https://github.com/ruby-grape/grape/pull/1255): Allow param type definition in `route_param` - [@namusyaka](https://github.com/namusyaka).\n* [#1257](https://github.com/ruby-grape/grape/pull/1257): Allow Proc, Symbol or String in `rescue_from with: ...` - [@namusyaka](https://github.com/namusyaka).\n* [#1280](https://github.com/ruby-grape/grape/pull/1280): Support `Rack::Sendfile` middleware - [@lfidnl](https://github.com/lfidnl).\n* [#1285](https://github.com/ruby-grape/grape/pull/1285): Add a warning for errors appearing in `after` callbacks - [@gregormelhorn](https://github.com/gregormelhorn).\n* [#1295](https://github.com/ruby-grape/grape/pull/1295): Add custom validation messages for parameter exceptions - [@railsmith](https://github.com/railsmith).\n\n#### Fixes\n\n* [#1216](https://github.com/ruby-grape/grape/pull/1142): Fix JSON error response when calling `error!` with non-Strings - [@jrforrest](https://github.com/jrforrest).\n* [#1225](https://github.com/ruby-grape/grape/pull/1225): Fix `given` with nested params not returning correct declared params - [@JanStevens](https://github.com/JanStevens).\n* [#1249](https://github.com/ruby-grape/grape/pull/1249): Don't fail even if invalid type value is passed to default validator - [@namusyaka](https://github.com/namusyaka).\n* [#1266](https://github.com/ruby-grape/grape/pull/1266): Fix `Allow` header including `OPTIONS` when `do_not_route_options!` is active - [@arempe93](https://github.com/arempe93).\n* [#1270](https://github.com/ruby-grape/grape/pull/1270): Fix `param` versioning with a custom parameter - [@wshatch](https://github.com/wshatch).\n* [#1282](https://github.com/ruby-grape/grape/pull/1282): Fix specs circular dependency - [@304](https://github.com/304).\n* [#1283](https://github.com/ruby-grape/grape/pull/1283): Fix 500 error for xml format when method is not allowed - [@304](https://github.com/304).\n* [#1197](https://github.com/ruby-grape/grape/pull/1290): Fix using JSON and Array[JSON] as groups when parameter is optional - [@lukeivers](https://github.com/lukeivers).\n\n### 0.14.0 (12/07/2015)\n\n#### Features\n\n* [#1218](https://github.com/ruby-grape/grape/pull/1218): Provide array index context in errors - [@towanda](https://github.com/towanda).\n* [#1196](https://github.com/ruby-grape/grape/pull/1196): Allow multiple `before_each` blocks - [@huynhquancam](https://github.com/huynhquancam).\n* [#1190](https://github.com/ruby-grape/grape/pull/1190): Bypass formatting for statuses with no entity-body - [@tylerdooling](https://github.com/tylerdooling).\n* [#1188](https://github.com/ruby-grape/grape/pull/1188): Allow parameters with more than one type - [@dslh](https://github.com/dslh).\n* [#1179](https://github.com/ruby-grape/grape/pull/1179): Allow all RFC6838 valid characters in header vendor - [@suan](https://github.com/suan).\n* [#1170](https://github.com/ruby-grape/grape/pull/1170): Allow dashes and periods in header vendor - [@suan](https://github.com/suan).\n* [#1167](https://github.com/ruby-grape/grape/pull/1167): Convenience wrapper `type: File` for validating multipart file parameters - [@dslh](https://github.com/dslh).\n* [#1167](https://github.com/ruby-grape/grape/pull/1167): Refactor and extend coercion and type validation system - [@dslh](https://github.com/dslh).\n* [#1163](https://github.com/ruby-grape/grape/pull/1163): First-class `JSON` parameter type - [@dslh](https://github.com/dslh).\n* [#1161](https://github.com/ruby-grape/grape/pull/1161): Custom parameter coercion using `coerce_with` - [@dslh](https://github.com/dslh).\n\n#### Fixes\n\n* [#1194](https://github.com/ruby-grape/grape/pull/1194): Redirect as plain text with message - [@tylerdooling](https://github.com/tylerdooling).\n* [#1185](https://github.com/ruby-grape/grape/pull/1185): Use formatters for custom vendored content types - [@tylerdooling](https://github.com/tylerdooling).\n* [#1156](https://github.com/ruby-grape/grape/pull/1156): Fixed `no implicit conversion of Symbol into Integer` with nested `values` validation - [@quickpay](https://github.com/quickpay).\n* [#1153](https://github.com/ruby-grape/grape/pull/1153): Fixes boolean declaration in an external file - [@towanda](https://github.com/towanda).\n* [#1142](https://github.com/ruby-grape/grape/pull/1142): Makes #declared unavailable to before filters - [@jrforrest](https://github.com/jrforrest).\n* [#1114](https://github.com/ruby-grape/grape/pull/1114): Fix regression which broke identical endpoints with different versions - [@suan](https://github.com/suan).\n* [#1109](https://github.com/ruby-grape/grape/pull/1109): Memoize Virtus attribute and fix memory leak - [@marshall-lee](https://github.com/marshall-lee).\n* [#1101](https://github.com/ruby-grape/grape/pull/1101): Fix: Incorrect media-type `Accept` header now correctly returns 406 with `strict: true` - [@elliotlarson](https://github.com/elliotlarson).\n* [#1108](https://github.com/ruby-grape/grape/pull/1039): Raise a warning when `desc` is called with options hash and block - [@rngtng](https://github.com/rngtng).\n\n### 0.13.0 (8/10/2015)\n\n#### Features\n\n* [#1039](https://github.com/ruby-grape/grape/pull/1039): Added support for custom parameter types - [@rnubel](https://github.com/rnubel).\n* [#1047](https://github.com/ruby-grape/grape/pull/1047): Adds `given` to DSL::Parameters, allowing for dependent params - [@rnubel](https://github.com/rnubel).\n* [#1064](https://github.com/ruby-grape/grape/pull/1064): Add public `Grape::Exception::ValidationErrors#full_messages` - [@romanlehnert](https://github.com/romanlehnert).\n* [#1079](https://github.com/ruby-grape/grape/pull/1079): Added `stream` method to take advantage of `Rack::Chunked` - [@zbelzer](https://github.com/zbelzer).\n* [#1086](https://github.com/ruby-grape/grape/pull/1086): Added `ActiveSupport::Notifications` instrumentation - [@wagenet](https://github.com/wagenet).\n\n#### Fixes\n\n* [#1062](https://github.com/ruby-grape/grape/issues/1062): Fix: `Grape::Exceptions::ValidationErrors` will include headers set by `header` - [@yairgo](https://github.com/yairgo).\n* [#1038](https://github.com/ruby-grape/grape/pull/1038): Avoid dup-ing the `String` class when used in inherited params - [@rnubel](https://github.com/rnubel).\n* [#1042](https://github.com/ruby-grape/grape/issues/1042): Fix coercion of complex arrays - [@dim](https://github.com/dim).\n* [#1045](https://github.com/ruby-grape/grape/pull/1045): Do not convert `Rack::Response` to `Rack::Response` in middleware - [@dmitry](https://github.com/dmitry).\n* [#1048](https://github.com/ruby-grape/grape/pull/1048): Only dup `InheritableValues`, remove support for `deep_dup` - [@toddmazierski](https://github.com/toddmazierski).\n* [#1052](https://github.com/ruby-grape/grape/pull/1052): Reset `description[:params]` when resetting validations - [@marshall-lee](https://github.com/marshall-lee).\n* [#1088](https://github.com/ruby-grape/grape/pull/1088): Support ActiveSupport 3.x by explicitly requiring `Hash#except` - [@wagenet](https://github.com/wagenet).\n* [#1096](https://github.com/ruby-grape/grape/pull/1096): Fix coercion on booleans - [@towanda](https://github.com/towanda).\n\n### 0.12.0 (6/18/2015)\n\n#### Features\n\n* [#995](https://github.com/ruby-grape/grape/issues/995): Added support for coercion to Set or Set[Other] - [@jordansexton](https://github.com/jordansexton) [@u2](https://github.com/u2).\n* [#980](https://github.com/ruby-grape/grape/issues/980): Grape is now eager-loaded - [@u2](https://github.com/u2).\n* [#956](https://github.com/ruby-grape/grape/issues/956): Support `present` with `Grape::Presenters::Presenter`  - [@u2](https://github.com/u2).\n* [#974](https://github.com/ruby-grape/grape/pull/974): Added `error!` to `rescue_from` blocks - [@whatasunnyday](https://github.com/whatasunnyday).\n* [#950](https://github.com/ruby-grape/grape/pull/950): Status method can now accept one of Rack::Utils status code symbols (:ok, :found, :bad_request, etc.) - [@dabrorius](https://github.com/dabrorius).\n* [#952](https://github.com/ruby-grape/grape/pull/952): Status method now raises error when called with invalid status code - [@dabrorius](https://github.com/dabrorius).\n* [#957](https://github.com/ruby-grape/grape/pull/957): Regexp validator now supports `allow_blank`, `nil` value behavior changed - [@calfzhou](https://github.com/calfzhou).\n* [#962](https://github.com/ruby-grape/grape/pull/962): The `default` attribute with `false` value is documented now - [@ajvondrak](https://github.com/ajvondrak).\n* [#1026](https://github.com/ruby-grape/grape/pull/1026): Added `file` method, explicitly setting a file-like response object - [@dblock](https://github.com/dblock).\n\n#### Fixes\n\n* [#994](https://github.com/ruby-grape/grape/pull/994): Fixed optional Array params default to Hash - [@u2](https://github.com/u2).\n* [#988](https://github.com/ruby-grape/grape/pull/988): Fixed duplicate identical endpoints - [@u2](https://github.com/u2).\n* [#936](https://github.com/ruby-grape/grape/pull/936): Fixed default params processing for optional groups - [@dm1try](https://github.com/dm1try).\n* [#942](https://github.com/ruby-grape/grape/pull/942): Fixed forced presence for optional params when based on a reused entity that was also required in another context - [@croeck](https://github.com/croeck).\n* [#1001](https://github.com/ruby-grape/grape/pull/1001): Fixed calling endpoint with specified format with format in its path - [@hodak](https://github.com/hodak).\n* [#1005](https://github.com/ruby-grape/grape/pull/1005): Fixed the Grape::Middleware::Globals - [@urkle](https://github.com/urkle).\n* [#1012](https://github.com/ruby-grape/grape/pull/1012): Fixed `allow_blank: false` with a Boolean value of `false` - [@mfunaro](https://github.com/mfunaro).\n* [#1023](https://github.com/ruby-grape/grape/issues/1023): Fixes unexpected behavior with `present` and an object that responds to `merge` but isn't a Hash - [@dblock](https://github.com/dblock).\n* [#1017](https://github.com/ruby-grape/grape/pull/1017): Fixed `undefined method stringify_keys` with nested mutual exclusive params - [@quickpay](https://github.com/quickpay).\n\n### 0.11.0 (2/23/2015)\n\n* [#925](https://github.com/ruby-grape/grape/pull/925): Fixed `toplevel constant DateTime referenced by Virtus::Attribute::DateTime` - [@u2](https://github.com/u2).\n* [#916](https://github.com/ruby-grape/grape/pull/916): Added `DateTime/Date/Numeric/Boolean` type support `allow_blank` - [@u2](https://github.com/u2).\n* [#871](https://github.com/ruby-grape/grape/pull/871): Fixed `Grape::Middleware::Base#response` - [@galathius](https://github.com/galathius).\n* [#559](https://github.com/ruby-grape/grape/issues/559): Added support for Rack 1.6.0, which parses requests larger than 128KB - [@myitcv](https://github.com/myitcv).\n* [#876](https://github.com/ruby-grape/grape/pull/876): Call to `declared(params)` now returns a `Hashie::Mash` - [@rodzyn](https://github.com/rodzyn).\n* [#879](https://github.com/ruby-grape/grape/pull/879): The `route_info` value is no longer included in `params` Hash - [@rodzyn](https://github.com/rodzyn).\n* [#881](https://github.com/ruby-grape/grape/issues/881): Fixed `Grape::Validations::ValuesValidator` support for `Range` type - [@ajvondrak](https://github.com/ajvondrak).\n* [#901](https://github.com/ruby-grape/grape/pull/901): Fix: callbacks defined in a version block are only called for the routes defined in that block - [@kushkella](https://github.com/kushkella).\n* [#886](https://github.com/ruby-grape/grape/pull/886): Group of parameters made to require an explicit type of Hash or Array - [@jrichter1](https://github.com/jrichter1).\n* [#912](https://github.com/ruby-grape/grape/pull/912): Extended the `:using` feature for param documentation to `optional` fields - [@croeck](https://github.com/croeck).\n* [#906](https://github.com/ruby-grape/grape/pull/906): Fix: invalid body parse errors are not rescued by handlers - [@croeck](https://github.com/croeck).\n* [#913](https://github.com/ruby-grape/grape/pull/913): Fix: Invalid accept headers are not processed by rescue handlers - [@croeck](https://github.com/croeck).\n* [#913](https://github.com/ruby-grape/grape/pull/913): Fix: Invalid accept headers cause internal processing errors (500) when http_codes are defined - [@croeck](https://github.com/croeck).\n* [#917](https://github.com/ruby-grape/grape/pull/917): Use HTTPS for rubygems.org - [@O-I](https://github.com/O-I).\n\n### 0.10.1 (12/28/2014)\n\n* [#868](https://github.com/ruby-grape/grape/pull/868), [#862](https://github.com/ruby-grape/grape/pull/862), [#861](https://github.com/ruby-grape/grape/pull/861): Fixed `version`, `prefix`, and other settings being overridden or changing scope when mounting API - [@yesmeck](https://github.com/yesmeck).\n* [#864](https://github.com/ruby-grape/grape/pull/864): Fixed `declared(params, include_missing: false)` now returning attributes with `nil` and `false` values - [@ppadron](https://github.com/ppadron).\n\n### 0.10.0 (12/19/2014)\n\n* [#803](https://github.com/ruby-grape/grape/pull/803), [#820](https://github.com/ruby-grape/grape/pull/820): Added `all_or_none_of` parameter validator - [@loveltyoic](https://github.com/loveltyoic), [@natecj](https://github.com/natecj).\n* [#774](https://github.com/ruby-grape/grape/pull/774): Extended `mutually_exclusive`, `exactly_one_of`, `at_least_one_of` to work inside any kind of group: `requires` or `optional`, `Hash` or `Array` - [@ShPakvel](https://github.com/ShPakvel).\n* [#743](https://github.com/ruby-grape/grape/pull/743): Added `allow_blank` parameter validator to validate non-empty strings - [@elado](https://github.com/elado).\n* [#745](https://github.com/ruby-grape/grape/pull/745): Removed `atom+xml`, `rss+xml`, and `jsonapi` content-types - [@akabraham](https://github.com/akabraham).\n* [#745](https://github.com/ruby-grape/grape/pull/745): Added `:binary, application/octet-stream` content-type - [@akabraham](https://github.com/akabraham).\n* [#757](https://github.com/ruby-grape/grape/pull/757): Changed `desc` can now be used with a block syntax - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#779](https://github.com/ruby-grape/grape/pull/779): Fixed using `values` with a `default` proc - [@ShPakvel](https://github.com/ShPakvel).\n* [#799](https://github.com/ruby-grape/grape/pull/799): Fixed custom validators with required `Hash`, `Array` types - [@bwalex](https://github.com/bwalex).\n* [#784](https://github.com/ruby-grape/grape/pull/784): Fixed `present` to not overwrite the previously added contents of the response body whebn called more than once - [@mfunaro](https://github.com/mfunaro).\n* [#809](https://github.com/ruby-grape/grape/pull/809): Removed automatic `(.:format)` suffix on paths if you're using only one format (e.g., with `format :json`, `/path` will respond with JSON but `/path.xml` will be a 404) - [@ajvondrak](https://github.com/ajvondrak).\n* [#816](https://github.com/ruby-grape/grape/pull/816): Added ability to filter out missing params if params is a nested hash with `declared(params, include_missing: false)` - [@georgimitev](https://github.com/georgimitev).\n* [#819](https://github.com/ruby-grape/grape/pull/819): Allowed both `desc` and `description` in the params DSL - [@mzikherman](https://github.com/mzikherman).\n* [#821](https://github.com/ruby-grape/grape/pull/821): Fixed passing string value when hash is expected in params - [@rebelact](https://github.com/rebelact).\n* [#824](https://github.com/ruby-grape/grape/pull/824): Validate array params against list of acceptable values - [@dnd](https://github.com/dnd).\n* [#813](https://github.com/ruby-grape/grape/pull/813): Routing methods dsl refactored to get rid of explicit `paths` parameter - [@AlexYankee](https://github.com/AlexYankee).\n* [#826](https://github.com/ruby-grape/grape/pull/826): Find `coerce_type` for `Array` when not specified - [@manovotn](https://github.com/manovotn).\n* [#645](https://github.com/ruby-grape/grape/issues/645): Invoking `body false` will return `204 No Content` - [@dblock](https://github.com/dblock).\n* [#801](https://github.com/ruby-grape/grape/issues/801): Only evaluate permitted parameter `values` and `default` lazily on each request when declared as a proc - [@dblock](https://github.com/dblock).\n* [#679](https://github.com/ruby-grape/grape/issues/679): Fixed `OPTIONS` method returning 404 when combined with `prefix` - [@dblock](https://github.com/dblock).\n* [#679](https://github.com/ruby-grape/grape/issues/679): Fixed unsupported methods returning 404 instead of 405 when combined with `prefix` - [@dblock](https://github.com/dblock).\n\n### 0.9.0 (8/27/2014)\n\n#### Features\n\n* [#691](https://github.com/ruby-grape/grape/issues/691): Added `at_least_one_of` parameter validator - [@dblock](https://github.com/dblock).\n* [#698](https://github.com/ruby-grape/grape/pull/698): `error!` sets `status` for `Endpoint` too - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Added support for Auth-Middleware extension - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Removed `Grape::Middleware::Auth::Basic` - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Removed `Grape::Middleware::Auth::Digest` - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#703](https://github.com/ruby-grape/grape/pull/703): Removed `Grape::Middleware::Auth::OAuth2` - [@dspaeth-faber](https://github.com/dspaeth-faber).\n* [#719](https://github.com/ruby-grape/grape/pull/719): Allow passing options hash to a custom validator - [@elado](https://github.com/elado).\n* [#716](https://github.com/ruby-grape/grape/pull/716): Calling `content-type` will now return the current content-type - [@dblock](https://github.com/dblock).\n* [#705](https://github.com/ruby-grape/grape/pull/705): Errors can now be presented with a `Grape::Entity` class - [@dspaeth-faber](https://github.com/dspaeth-faber).\n\n#### Fixes\n\n* [#687](https://github.com/ruby-grape/grape/pull/687): Fix: `mutually_exclusive` and `exactly_one_of` validation error messages now label parameters as strings, consistently with `requires` and `optional` - [@dblock](https://github.com/dblock).\n\n### 0.8.0 (7/10/2014)\n\n#### Features\n\n* [#639](https://github.com/ruby-grape/grape/pull/639): Added support for blocks with reusable params - [@mibon](https://github.com/mibon).\n* [#637](https://github.com/ruby-grape/grape/pull/637): Added support for `exactly_one_of` parameter validation - [@Morred](https://github.com/Morred).\n* [#626](https://github.com/ruby-grape/grape/pull/626): Added support for `mutually_exclusive` parameters - [@oliverbarnes](https://github.com/oliverbarnes).\n* [#617](https://github.com/ruby-grape/grape/pull/617): Running tests on Ruby 2.1.1, Rubinius 2.1 and 2.2, Ruby and JRuby HEAD - [@dblock](https://github.com/dblock).\n* [#397](https://github.com/ruby-grape/grape/pull/397): Adds `Grape::Endpoint.before_each` to allow easy helper stubbing - [@mbleigh](https://github.com/mbleigh).\n* [#673](https://github.com/ruby-grape/grape/pull/673): Avoid requiring non-existent fields when using Grape::Entity documentation - [@qqshfox](https://github.com/qqshfox).\n\n#### Fixes\n\n* [#671](https://github.com/ruby-grape/grape/pull/671): Allow required param with predefined set of values to be nil inside optional group - [@dm1try](https://github.com/dm1try).\n* [#651](https://github.com/ruby-grape/grape/pull/651): The `rescue_from` keyword now properly defaults to rescuing subclasses of exceptions - [@xevix](https://github.com/xevix).\n* [#614](https://github.com/ruby-grape/grape/pull/614): Params with `nil` value are now refused by `RegexpValidator` - [@dm1try](https://github.com/dm1try).\n* [#494](https://github.com/ruby-grape/grape/issues/494): Fixed performance issue with requests carrying a large payload - [@dblock](https://github.com/dblock).\n* [#619](https://github.com/ruby-grape/grape/pull/619): Convert specs to RSpec 3 syntax with Transpec - [@danielspector](https://github.com/danielspector).\n* [#632](https://github.com/ruby-grape/grape/pull/632): `Grape::Endpoint#present` causes ActiveRecord to make an extra query during entity's detection - [@fixme](https://github.com/fixme).\n\n### 0.7.0 (4/2/2014)\n\n#### Features\n\n* [#558](https://github.com/ruby-grape/grape/pull/558): Support lambda-based values for params - [@wpschallenger](https://github.com/wpschallenger).\n* [#510](https://github.com/ruby-grape/grape/pull/510): Support lambda-based default values for params - [@myitcv](https://github.com/myitcv).\n* [#511](https://github.com/ruby-grape/grape/pull/511): Added `required` option for OAuth2 middleware - [@bcm](https://github.com/bcm).\n* [#520](https://github.com/ruby-grape/grape/pull/520): Use `default_error_status` to specify the default status code returned from `error!` - [@salimane](https://github.com/salimane).\n* [#525](https://github.com/ruby-grape/grape/pull/525): The default status code returned from `error!` has been changed from 403 to 500 - [@dblock](https://github.com/dblock).\n* [#526](https://github.com/ruby-grape/grape/pull/526): Allowed specifying headers in `error!` - [@dblock](https://github.com/dblock).\n* [#527](https://github.com/ruby-grape/grape/pull/527): The `before_validation` callback is now a distinct one - [@myitcv](https://github.com/myitcv).\n* [#530](https://github.com/ruby-grape/grape/pull/530): Added ability to restrict `declared(params)` to the local endpoint with `include_parent_namespaces: false` - [@myitcv](https://github.com/myitcv).\n* [#531](https://github.com/ruby-grape/grape/pull/531): Helpers are now available to auth middleware, executing in the context of the endpoint - [@joelvh](https://github.com/joelvh).\n* [#540](https://github.com/ruby-grape/grape/pull/540): Ruby 2.1.0 is now supported - [@salimane](https://github.com/salimane).\n* [#544](https://github.com/ruby-grape/grape/pull/544): The `rescue_from` keyword now handles subclasses of exceptions by default - [@xevix](https://github.com/xevix).\n* [#545](https://github.com/ruby-grape/grape/pull/545): Added `type` (`Array` or `Hash`) support to `requires`, `optional` and `group` - [@bwalex](https://github.com/bwalex).\n* [#550](https://github.com/ruby-grape/grape/pull/550): Added possibility to define reusable params - [@dm1try](https://github.com/dm1try).\n* [#560](https://github.com/ruby-grape/grape/pull/560): Use `Grape::Entity` documentation to define required and optional parameters with `requires using:` - [@reynardmh](https://github.com/reynardmh).\n* [#572](https://github.com/ruby-grape/grape/pull/572): Added `documentation` support to `requires`, `optional` and `group` parameters - [@johnallen3d](https://github.com/johnallen3d).\n\n#### Fixes\n\n* [#600](https://github.com/ruby-grape/grape/pull/600): Don't use an `Entity` constant that is available in the namespace as presenter - [@fuksito](https://github.com/fuksito).\n* [#590](https://github.com/ruby-grape/grape/pull/590): Fix issue where endpoint param of type `Integer` cannot set values array - [@xevix](https://github.com/xevix).\n* [#586](https://github.com/ruby-grape/grape/pull/586): Do not repeat the same validation error messages - [@kiela](https://github.com/kiela).\n* [#508](https://github.com/ruby-grape/grape/pull/508): Allow parameters, such as content encoding, in `content_type` - [@dm1try](https://github.com/dm1try).\n* [#492](https://github.com/ruby-grape/grape/pull/492): Don't allow to have nil value when a param is required and has a list of allowed values - [@Antti](https://github.com/Antti).\n* [#495](https://github.com/ruby-grape/grape/pull/495): Fixed `ParamsScope#params` for parameters nested inside arrays - [@asross](https://github.com/asross).\n* [#498](https://github.com/ruby-grape/grape/pull/498): Dry'ed up options and headers logic, allow headers to be passed to OPTIONS requests - [@karlfreeman](https://github.com/karlfreeman).\n* [#500](https://github.com/ruby-grape/grape/pull/500): Skip entity auto-detection when explicitely passed - [@yaneq](https://github.com/yaneq).\n* [#503](https://github.com/ruby-grape/grape/pull/503): Calling declared(params) from child namespace fails to include parent namespace defined params - [@myitcv](https://github.com/myitcv).\n* [#512](https://github.com/ruby-grape/grape/pull/512): Don't create `Grape::Request` multiple times - [@dblock](https://github.com/dblock).\n* [#538](https://github.com/ruby-grape/grape/pull/538): Fixed default values for grouped params - [@dm1try](https://github.com/dm1try).\n* [#549](https://github.com/ruby-grape/grape/pull/549): Fixed handling of invalid version headers to return 406 if a header cannot be parsed - [@bwalex](https://github.com/bwalex).\n* [#557](https://github.com/ruby-grape/grape/pull/557): Pass `content_types` option to `Grape::Middleware::Error` to fix the content-type header for custom formats - [@bernd](https://github.com/bernd).\n* [#585](https://github.com/ruby-grape/grape/pull/585): Fix after boot thread-safety issue - [@etehtsea](https://github.com/etehtsea).\n* [#587](https://github.com/ruby-grape/grape/pull/587): Fix oauth2 middleware compatibility with [draft-ietf-oauth-v2-31](http://tools.ietf.org/html/draft-ietf-oauth-v2-31) spec - [@etehtsea](https://github.com/etehtsea).\n* [#610](https://github.com/ruby-grape/grape/pull/610): Fixed group keyword was not working with type parameter - [@klausmeyer](https://github.com/klausmeyer).\n\n### 0.6.1 (10/19/2013)\n\n#### Features\n\n* [#475](https://github.com/ruby-grape/grape/pull/475): Added support for the `:jsonapi`, `application/vnd.api+json` media type registered at http://jsonapi.org - [@bcm](https://github.com/bcm).\n* [#471](https://github.com/ruby-grape/grape/issues/471): Added parameter validator for a list of allowed values - [@vickychijwani](https://github.com/vickychijwani).\n* [#488](https://github.com/ruby-grape/grape/issues/488): Upgraded to Virtus 1.0 - [@dblock](https://github.com/dblock).\n\n#### Fixes\n\n* [#477](https://github.com/ruby-grape/grape/pull/477): Fixed `default_error_formatter` which takes a format symbol - [@vad4msiu](https://github.com/vad4msiu).\n\n#### Development\n\n* Implemented Rubocop, a Ruby code static code analyzer - [@dblock](https://github.com/dblock).\n\n### 0.6.0 (9/16/2013)\n\n#### Features\n\n* Grape is no longer tested against Ruby 1.8.7 - [@dblock](https://github.com/dblock).\n* [#442](https://github.com/ruby-grape/grape/issues/442): Enable incrementally building on top of a previous API version - [@dblock](https://github.com/dblock).\n* [#442](https://github.com/ruby-grape/grape/issues/442): API `version` can now take an array of multiple versions - [@dblock](https://github.com/dblock).\n* [#444](https://github.com/ruby-grape/grape/issues/444): Added `:en` as fallback locale for I18n - [@aew](https://github.com/aew).\n* [#448](https://github.com/ruby-grape/grape/pull/448): Adding POST style parameters for DELETE requests - [@dquimper](https://github.com/dquimper).\n* [#450](https://github.com/ruby-grape/grape/pull/450): Added option to pass an exception handler lambda as an argument to `rescue_from` - [@robertopedroso](https://github.com/robertopedroso).\n* [#443](https://github.com/ruby-grape/grape/pull/443): Let `requires` and `optional` take blocks that initialize new scopes - [@asross](https://github.com/asross).\n* [#452](https://github.com/ruby-grape/grape/pull/452): Added `with` as a hash option to specify handlers for `rescue_from` and `error_formatter` - [@robertopedroso](https://github.com/robertopedroso).\n* [#433](https://github.com/ruby-grape/grape/issues/433), [#462](https://github.com/ruby-grape/grape/issues/462): Validation errors are now collected and `Grape::Exceptions::ValidationErrors` is raised - [@stevschmid](https://github.com/stevschmid).\n\n#### Fixes\n\n* [#428](https://github.com/ruby-grape/grape/issues/428): Removes memoization from `Grape::Request` params to prevent middleware from freezing parameter values before `Formatter` can get them - [@mbleigh](https://github.com/mbleigh).\n\n### 0.5.0 (6/14/2013)\n\n#### Features\n\n* [#344](https://github.com/ruby-grape/grape/pull/344): Added `parser :type, nil` which disables input parsing for a given content-type - [@dblock](https://github.com/dblock).\n* [#381](https://github.com/ruby-grape/grape/issues/381): Added `cascade false` option at API level to remove the `X-Cascade: true` header from the API response - [@dblock](https://github.com/dblock).\n* [#392](https://github.com/ruby-grape/grape/pull/392): Extracted headers and params from `Endpoint` to `Grape::Request` - [@niedhui](https://github.com/niedhui).\n* [#376](https://github.com/ruby-grape/grape/pull/376): Added `route_param`, syntax sugar for quick declaration of route parameters - [@mbleigh](https://github.com/mbleigh).\n* [#390](https://github.com/ruby-grape/grape/pull/390): Added default value for an `optional` parameter - [@oivoodoo](https://github.com/oivoodoo).\n* [#403](https://github.com/ruby-grape/grape/pull/403): Added support for versioning using the `Accept-Version` header - [@politician](https://github.com/politician).\n* [#407](https://github.com/ruby-grape/grape/issues/407): Specifying `default_format` will also set the default POST/PUT data parser to the given format - [@dblock](https://github.com/dblock).\n* [#241](https://github.com/ruby-grape/grape/issues/241): Present with multiple entities using an optional Symbol - [@niedhui](https://github.com/niedhui).\n\n#### Fixes\n\n* [#378](https://github.com/ruby-grape/grape/pull/378): Fix: stop rescuing all exceptions during formatting - [@kbarrette](https://github.com/kbarrette).\n* [#380](https://github.com/ruby-grape/grape/pull/380): Fix: `Formatter#read_body_input` when transfer encoding is chunked - [@paulnicholon](https://github.com/paulnicholson).\n* [#347](https://github.com/ruby-grape/grape/issues/347): Fix: handling non-hash body params - [@paulnicholon](https://github.com/paulnicholson).\n* [#394](https://github.com/ruby-grape/grape/pull/394): Fix: path version no longer overwrites a `version` parameter - [@tmornini](https://github.com/tmornini).\n* [#412](https://github.com/ruby-grape/grape/issues/412): Fix: specifying `content_type` will also override the selection of the data formatter - [@dblock](https://github.com/dblock).\n* [#383](https://github.com/ruby-grape/grape/issues/383): Fix: Mounted APIs aren't inheriting settings (including `before` and `after` filters) - [@seanmoon](https://github.com/seanmoon).\n* [#408](https://github.com/ruby-grape/grape/pull/408): Fix: Goliath passes request header keys as symbols not strings - [@bobek](https://github.com/bobek).\n* [#417](https://github.com/ruby-grape/grape/issues/417): Fix: Rails 4 does not rewind input, causes POSTed data to be empty - [@dblock](https://github.com/dblock).\n* [#423](https://github.com/ruby-grape/grape/pull/423): Fix: `Grape::Endpoint#declared` now correctly handles nested params (ie. declared with `group`) - [@jbarreneche](https://github.com/jbarreneche).\n* [#427](https://github.com/ruby-grape/grape/issues/427): Fix: `declared(params)` breaks when `params` contains array - [@timhabermaas](https://github.com/timhabermaas).\n\n### 0.4.1 (4/1/2013)\n\n* [#375](https://github.com/ruby-grape/grape/pull/375): Fix: throwing an `:error` inside a middleware doesn't respect the `format` settings - [@dblock](https://github.com/dblock).\n\n### 0.4.0 (3/17/2013)\n\n* [#356](https://github.com/ruby-grape/grape/pull/356): Fix: presenting collections other than `Array` (eg. `ActiveRecord::Relation`) - [@zimbatm](https://github.com/zimbatm).\n* [#352](https://github.com/ruby-grape/grape/pull/352): Fix: using `Rack::JSONP` with `Grape::Entity` responses - [@deckchair](https://github.com/deckchair).\n* [#347](https://github.com/ruby-grape/grape/issues/347): Grape will accept any valid JSON as PUT or POST, including strings, symbols and arrays - [@qqshfox](https://github.com/qqshfox), [@dblock](https://github.com/dblock).\n* [#347](https://github.com/ruby-grape/grape/issues/347): JSON format APIs always return valid JSON, eg. strings are now returned as `\"string\"` and no longer `string` - [@dblock](https://github.com/dblock).\n* Raw body input from POST and PUT requests (`env['rack.input'].read`) is now available in `api.request.input` - [@dblock](https://github.com/dblock).\n* Parsed body input from POST and PUT requests is now available in `api.request.body` - [@dblock](https://github.com/dblock).\n* [#343](https://github.com/ruby-grape/grape/pull/343): Fix: return `Content-Type: text/plain` with error 405 - [@gustavosaume](https://github.com/gustavosaume), [@wyattisimo](https://github.com/wyattisimo).\n* [#357](https://github.com/ruby-grape/grape/pull/357): Grape now requires Rack 1.3.0 or newer - [@jhecking](https://github.com/jhecking).\n* [#320](https://github.com/ruby-grape/grape/issues/320): API `namespace` now supports `requirements` - [@niedhui](https://github.com/niedhui).\n* [#353](https://github.com/ruby-grape/grape/issues/353): Revert to standard Ruby logger formatter, `require active_support/all` if you want old behavior - [@rhunter](https://github.com/rhunter), [@dblock](https://github.com/dblock).\n* Fix: `undefined method 'call' for nil:NilClass` for an API method implementation without a block, now returns an empty string - [@dblock](https://github.com/dblock).\n\n### 0.3.2 (2/28/2013)\n\n* [#355](https://github.com/ruby-grape/grape/issues/355): Relax dependency constraint on Hashie - [@reset](https://github.com/reset).\n\n### 0.3.1 (2/25/2013)\n\n* [#351](https://github.com/ruby-grape/grape/issues/351): Compatibility with Ruby 2.0 - [@mbleigh](https://github.com/mbleigh).\n\n### 0.3.0 (02/21/2013)\n\n* [#294](https://github.com/ruby-grape/grape/issues/294): Extracted `Grape::Entity` into a [grape-entity](https://github.com/agileanimal/grape-entity) gem - [@agileanimal](https://github.com/agileanimal).\n* [#340](https://github.com/ruby-grape/grape/pull/339), [#342](https://github.com/ruby-grape/grape/pull/342): Added `:cascade` option to `version` to allow disabling of rack/mount cascade behavior - [@dieb](https://github.com/dieb).\n* [#333](https://github.com/ruby-grape/grape/pull/333): Added support for validation of arrays in `params` - [@flyerhzm](https://github.com/flyerhzm).\n* [#306](https://github.com/ruby-grape/grape/issues/306): Added I18n support for all Grape exceptions - [@niedhui](https://github.com/niedhui).\n* [#309](https://github.com/ruby-grape/grape/pull/309): Added XML support to the entity presenter - [@johnnyiller](https://github.com/johnnyiller), [@dblock](https://github.com/dblock).\n* [#131](https://github.com/ruby-grape/grape/issues/131): Added instructions for Grape API reloading in Rails - [@jyn](https://github.com/jyn), [@dblock](https://github.com/dblock).\n* [#317](https://github.com/ruby-grape/grape/issues/317): Added `headers` that returns a hash of parsed HTTP request headers - [@dblock](https://github.com/dblock).\n* [#332](https://github.com/ruby-grape/grape/pull/332): `Grape::Exceptions::Validation` now contains full nested parameter names - [@alovak](https://github.com/alovak).\n* [#328](https://github.com/ruby-grape/grape/issues/328): API version can now be specified as both String and Symbol - [@dblock](https://github.com/dblock).\n* [#190](https://github.com/ruby-grape/grape/issues/190): When you add a `GET` route for a resource, a route for the `HEAD` method will also be added automatically. You can disable this behavior with `do_not_route_head!` - [@dblock](https://github.com/dblock).\n* Added `do_not_route_options!`, which disables the automatic creation of the `OPTIONS` route - [@dblock](https://github.com/dblock).\n* [#309](https://github.com/ruby-grape/grape/pull/309): An XML format API will return an error instead of returning a string representation of the response if the latter cannot be converted to XML - [@dblock](https://github.com/dblock).\n* A formatter that raises an exception will cause the API to return a 500 error - [@dblock](https://github.com/dblock).\n* [#322](https://github.com/ruby-grape/grape/issues/322): When returning a 406 status, Grape will include the requested format or content-type in the response body - [@dblock](https://github.com/dblock).\n* [#60](https://github.com/ruby-grape/grape/issues/60): Fix: mounting of a Grape API onto a path - [@dblock](https://github.com/dblock).\n* [#335](https://github.com/ruby-grape/grape/pull/335): Fix: request body parameters from a `PATCH` request not available in `params` - [@FreakenK](https://github.com/FreakenK).\n\n### 0.2.6 (01/11/2013)\n\n* Fix: support content-type with character set when parsing POST and PUT input - [@dblock](https://github.com/dblock).\n* Fix: CVE-2013-0175, multi_xml parse vulnerability, require multi_xml 0.5.2 - [@dblock](https://github.com/dblock).\n\n### 0.2.5 (01/10/2013)\n\n* Added support for custom parsers via `parser`, in addition to built-in multipart, JSON and XML parsers - [@dblock](https://github.com/dblock).\n* Removed `body_params`, data sent via a POST or PUT with a supported content-type is merged into `params` - [@dblock](https://github.com/dblock).\n* Setting `format` will automatically remove other content-types by calling `content_type` - [@dblock](https://github.com/dblock).\n* Setting `content_type` will prevent any input data other than the matching content-type or any Rack-supported form and parseable media types (`application/x-www-form-urlencoded`, `multipart/form-data`, `multipart/related` and `multipart/mixed`) from being parsed - [@dblock](https://github.com/dblock).\n* [#305](https://github.com/ruby-grape/grape/issues/305): Fix: presenting arrays of objects via `represent` or when auto-detecting an `Entity` constant in the objects being presented - [@brandonweiss](https://github.com/brandonweiss).\n* [#306](https://github.com/ruby-grape/grape/issues/306): Added i18n support for validation error messages - [@niedhui](https://github.com/niedhui).\n\n### 0.2.4 (01/06/2013)\n\n* [#297](https://github.com/ruby-grape/grape/issues/297): Added `default_error_formatter` - [@dblock](https://github.com/dblock).\n* [#297](https://github.com/ruby-grape/grape/issues/297): Setting `format` will automatically set `default_error_formatter` - [@dblock](https://github.com/dblock).\n* [#295](https://github.com/ruby-grape/grape/issues/295): Storing original API source block in endpoint's `source` attribute - [@dblock](https://github.com/dblock).\n* [#293](https://github.com/ruby-grape/grape/pull/293): Added options to `cookies.delete`, enables passing a path - [@inst](https://github.com/inst).\n* [#174](https://github.com/ruby-grape/grape/issues/174): The value of `env['PATH_INFO']` is no longer altered with `path` versioning - [@dblock](https://github.com/dblock).\n* [#296](https://github.com/ruby-grape/grape/issues/296): Fix: ArgumentError with default error formatter - [@dblock](https://github.com/dblock).\n* [#298](https://github.com/ruby-grape/grape/pull/298): Fix: subsequent calls to `body_params` would fail due to IO read - [@justinmcp](https://github.com/justinmcp).\n* [#301](https://github.com/ruby-grape/grape/issues/301): Fix: symbol memory leak in cookie and formatter middleware - [@dblock](https://github.com/dblock).\n* [#300](https://github.com/ruby-grape/grape/issues/300): Fix `Grape::API.routes` to include mounted api routes - [@aiwilliams](https://github.com/aiwilliams).\n* [#302](https://github.com/ruby-grape/grape/pull/302): Fix: removed redundant `autoload` entries - [@ugisozols](https://github.com/ugisozols).\n* [#172](https://github.com/ruby-grape/grape/issues/172): Fix: MultiJson deprecated methods warnings - [@dblock](https://github.com/dblock).\n* [#133](https://github.com/ruby-grape/grape/issues/133): Fix: header-based versioning with use of `prefix` - [@seanmoon](https://github.com/seanmoon), [@dblock](https://github.com/dblock).\n* [#280](https://github.com/ruby-grape/grape/issues/280): Fix: grouped parameters mangled in `route_params` hash - [@marcusg](https://github.com/marcusg), [@dblock](https://github.com/dblock).\n* [#304](https://github.com/ruby-grape/grape/issues/304): Fix: `present x, :with => Entity` returns class references with `format :json` - [@dblock](https://github.com/dblock).\n* [#196](https://github.com/ruby-grape/grape/issues/196): Fix: root requests don't work with `prefix` - [@dblock](https://github.com/dblock).\n\n### 0.2.3 (24/12/2012)\n\n* [#179](https://github.com/ruby-grape/grape/issues/178): Using `content_type` will remove all default content-types - [@dblock](https://github.com/dblock).\n* [#265](https://github.com/ruby-grape/grape/issues/264): Fix: Moved `ValidationError` into `Grape::Exceptions` - [@thepumpkin1979](https://github.com/thepumpkin1979).\n* [#269](https://github.com/ruby-grape/grape/pull/269): Fix: `LocalJumpError` will not be raised when using explict return in API methods - [@simulacre](https://github.com/simulacre).\n* [#86](https://github.com/ruby-grape/grape/issues/275): Fix Path-based versioning not recognizing `/` route - [@walski](https://github.com/walski).\n* [#273](https://github.com/ruby-grape/grape/pull/273): Disabled formatting via `serializable_hash` and added support for `format :serializable_hash` - [@dblock](https://github.com/dblock).\n* [#277](https://github.com/ruby-grape/grape/pull/277): Added a DSL to declare `formatter` in API settings - [@tim-vandecasteele](https://github.com/tim-vandecasteele).\n* [#284](https://github.com/ruby-grape/grape/pull/284): Added a DSL to declare `error_formatter` in API settings - [@dblock](https://github.com/dblock).\n* [#285](https://github.com/ruby-grape/grape/pull/285): Removed `error_format` from API settings, now matches request format - [@dblock](https://github.com/dblock).\n* [#290](https://github.com/ruby-grape/grape/pull/290): The default error format for XML is now `error/message` instead of `hash/error` - [@dpsk](https://github.com/dpsk).\n* [#44](https://github.com/ruby-grape/grape/issues/44): Pass `env` into formatters to enable templating - [@dblock](https://github.com/dblock).\n\n### 0.2.2 (12/10/2012)\n\n#### Features\n\n* [#201](https://github.com/ruby-grape/grape/pull/201), [#236](https://github.com/ruby-grape/grape/pull/236), [#221](https://github.com/ruby-grape/grape/pull/221): Added coercion and validations support to `params` DSL - [@schmurfy](https://github.com/schmurfy), [@tim-vandecasteele](https://github.com/tim-vandecasteele), [@adamgotterer](https://github.com/adamgotterer).\n* [#204](https://github.com/ruby-grape/grape/pull/204): Added ability to declare shared `params` at `namespace` level - [@tim-vandecasteele](https://github.com/tim-vandecasteele).\n* [#234](https://github.com/ruby-grape/grape/pull/234): Added a DSL for creating entities via mixin - [@mbleigh](https://github.com/mbleigh).\n* [#240](https://github.com/ruby-grape/grape/pull/240): Define API response format from a query string `format` parameter, if specified - [@neetiraj](https://github.com/neetiraj).\n* Adds Endpoint#declared to easily filter out unexpected params - [@mbleigh](https://github.com/mbleigh).\n\n#### Fixes\n\n* [#248](https://github.com/ruby-grape/grape/pull/248): Fix: API `version` returns last version set - [@narkoz](https://github.com/narkoz).\n* [#242](https://github.com/ruby-grape/grape/issues/242): Fix: permanent redirect status should be `301`, was `304` - [@adamgotterer](https://github.com/adamgotterer).\n* [#211](https://github.com/ruby-grape/grape/pull/211): Fix: custom validations are no longer triggered when optional and parameter is not present - [@adamgotterer](https://github.com/adamgotterer).\n* [#210](https://github.com/ruby-grape/grape/pull/210): Fix: `Endpoint#body_params` causing undefined method 'size' - [@adamgotterer](https://github.com/adamgotterer).\n* [#205](https://github.com/ruby-grape/grape/pull/205): Fix: Corrected parsing of empty JSON body on POST/PUT - [@tim-vandecasteele](https://github.com/tim-vandecasteele).\n* [#181](https://github.com/ruby-grape/grape/pull/181): Fix: Corrected JSON serialization of nested hashes containing `Grape::Entity` instances - [@benrosenblum](https://github.com/benrosenblum).\n* [#203](https://github.com/ruby-grape/grape/pull/203): Added a check to `Entity#serializable_hash` that verifies an entity exists on an object - [@adamgotterer](https://github.com/adamgotterer).\n* [#208](https://github.com/ruby-grape/grape/pull/208): `Entity#serializable_hash` must also check if attribute is generated by a user supplied block - [@ppadron](https://github.com/ppadron).\n* [#252](https://github.com/ruby-grape/grape/pull/252): Resources that don't respond to a requested HTTP method return 405 (Method Not Allowed) instead of 404 (Not Found) - [@simulacre](https://github.com/simulacre).\n\n### 0.2.1 (7/11/2012)\n\n* [#186](https://github.com/ruby-grape/grape/issues/186): Fix: helpers allow multiple calls with modules and blocks - [@ppadron](https://github.com/ppadron).\n* [#188](https://github.com/ruby-grape/grape/pull/188): Fix: multi-method routes append '(.:format)' only once - [@kainosnoema](https://github.com/kainosnoema).\n* [#64](https://github.com/ruby-grape/grape/issues/64), [#180](https://github.com/ruby-grape/grape/pull/180): Added support to `GET` request bodies as parameters - [@bobbytables](https://github.com/bobbytables).\n* [#175](https://github.com/ruby-grape/grape/pull/175): Added support for API versioning based on a request parameter - [@jackcasey](https://github.com/jackcasey).\n* [#168](https://github.com/ruby-grape/grape/pull/168): Fix: Formatter can parse symbol keys in the headers hash - [@netmask](https://github.com/netmask).\n* [#169](https://github.com/ruby-grape/grape/pull/169): Silence multi_json deprecation warnings - [@whiteley](https://github.com/whiteley).\n* [#166](https://github.com/ruby-grape/grape/pull/166): Added support for `redirect`, including permanent and temporary - [@allenwei](https://github.com/allenwei).\n* [#159](https://github.com/ruby-grape/grape/pull/159): Added `:requirements` to routes, allowing to use reserved characters in paths - [@gaiottino](https://github.com/gaiottino).\n* [#156](https://github.com/ruby-grape/grape/pull/156): Added support for adding formatters to entities - [@bobbytables](https://github.com/bobbytables).\n* [#183](https://github.com/ruby-grape/grape/pull/183): Added ability to include documentation in entities - [@flah00](https://github.com/flah00).\n* [#189](https://github.com/ruby-grape/grape/pull/189): `HEAD` requests no longer return a body - [@stephencelis](https://github.com/stephencelis).\n* [#97](https://github.com/ruby-grape/grape/issues/97): Allow overriding `Content-Type` - [@dblock](https://github.com/dblock).\n\n### 0.2.0 (3/28/2012)\n\n* Added support for inheriting exposures from entities - [@bobbytables](https://github.com/bobbytables).\n* Extended formatting with `default_format` - [@dblock](https://github.com/dblock).\n* Added support for cookies - [@lukaszsliwa](https://github.com/lukaszsliwa).\n* Added support for declaring additional content-types - [@joeyAghion](https://github.com/joeyAghion).\n* Added support for HTTP PATCH - [@LTe](https://github.com/LTe).\n* Added support for describing, documenting and reflecting APIs - [@dblock](https://github.com/dblock).\n* Added support for anchoring and vendoring - [@jwkoelewijn](https://github.com/jwkoelewijn).\n* Added support for HTTP OPTIONS - [@grimen](https://github.com/grimen).\n* Added support for silencing logger - [@evansj](https://github.com/evansj).\n* Added support for helper modules - [@freelancing-god](https://github.com/freelancing-god).\n* Added support for Accept header-based versioning - [@jch](https://github.com/jch), [@rodzyn](https://github.com/rodzyn).\n* Added support for mounting APIs and other Rack applications within APIs - [@mbleigh](https://github.com/mbleigh).\n* Added entities, multiple object representations - [@mbleigh](https://github.com/mbleigh).\n* Added ability to handle XML in the incoming request body - [@jwillis](https://github.com/jwillis).\n* Added support for a configurable logger - [@mbleigh](https://github.com/mbleigh).\n* Added support for before and after filters - [@mbleigh](https://github.com/mbleigh).\n* Extended `rescue_from`, which can now take a block - [@dblock](https://github.com/dblock).\n\n### 0.1.5 (6/14/2011)\n\n* Extended exception handling to all exceptions - [@dblock](https://github.com/dblock).\n* Added support for returning JSON objects from within error blocks - [@dblock](https://github.com/dblock).\n* Added support for handling incoming JSON in body - [@tedkulp](https://github.com/tedkulp).\n* Added support for HTTP digest authentication - [@daddz](https://github.com/daddz).\n\n### 0.1.4 (4/8/2011)\n\n* Allow multiple definitions of the same endpoint under multiple versions - [@chrisrhoden](https://github.com/chrisrhoden).\n* Added support for multipart URL parameters - [@mcastilho](https://github.com/mcastilho).\n* Added support for custom formatters - [@spraints](https://github.com/spraints).\n\n### 0.1.3 (1/10/2011)\n\n* Added support for JSON format in route matching - [@aiwilliams](https://github.com/aiwilliams).\n* Added suport for custom middleware - [@mbleigh](https://github.com/mbleigh).\n\n### 0.1.1 (11/14/2010)\n\n* Endpoints properly reset between each request - [@mbleigh](https://github.com/mbleigh).\n\n### 0.1.0 (11/13/2010)\n\n* Initial public release - [@mbleigh](https://github.com/mbleigh).\n", "require 'grape/middleware/base'\nrequire 'active_support/core_ext/string/output_safety'\n\nmodule Grape\n  module Middleware\n    class Error < Base\n      def default_options\n        {\n          default_status: 500, # default status returned on error\n          default_message: '',\n          format: :txt,\n          helpers: nil,\n          formatters: {},\n          error_formatters: {},\n          rescue_all: false, # true to rescue all exceptions\n          rescue_grape_exceptions: false,\n          rescue_subclasses: true, # rescue subclasses of exceptions listed\n          rescue_options: {\n            backtrace: false, # true to display backtrace, true to let Grape handle Grape::Exceptions\n            original_exception: false, # true to display exception\n          },\n          rescue_handlers: {}, # rescue handler blocks\n          base_only_rescue_handlers: {}, # rescue handler blocks rescuing only the base class\n          all_rescue_handler: nil # rescue handler block to rescue from all exceptions\n        }\n      end\n\n      def initialize(app, **options)\n        super\n        self.class.send(:include, @options[:helpers]) if @options[:helpers]\n      end\n\n      def call!(env)\n        @env = env\n\n        begin\n          error_response(catch(:error) do\n            return @app.call(@env)\n          end)\n        rescue Exception => error # rubocop:disable Lint/RescueException\n          handler =\n            rescue_handler_for_base_only_class(error.class) ||\n            rescue_handler_for_class_or_its_ancestor(error.class) ||\n            rescue_handler_for_grape_exception(error.class) ||\n            rescue_handler_for_any_class(error.class) ||\n            raise\n\n          run_rescue_handler(handler, error)\n        end\n      end\n\n      def error!(message, status = options[:default_status], headers = {}, backtrace = [], original_exception = nil)\n        headers = headers.reverse_merge(Grape::Http::Headers::CONTENT_TYPE => content_type)\n        rack_response(format_message(message, backtrace, original_exception), status, headers)\n      end\n\n      def default_rescue_handler(e)\n        error_response(message: e.message, backtrace: e.backtrace, original_exception: e)\n      end\n\n      # TODO: This method is deprecated. Refactor out.\n      def error_response(error = {})\n        status = error[:status] || options[:default_status]\n        message = error[:message] || options[:default_message]\n        headers = { Grape::Http::Headers::CONTENT_TYPE => content_type }\n        headers.merge!(error[:headers]) if error[:headers].is_a?(Hash)\n        backtrace = error[:backtrace] || error[:original_exception] && error[:original_exception].backtrace || []\n        original_exception = error.is_a?(Exception) ? error : error[:original_exception] || nil\n        rack_response(format_message(message, backtrace, original_exception), status, headers)\n      end\n\n      def rack_response(message, status = options[:default_status], headers = { Grape::Http::Headers::CONTENT_TYPE => content_type })\n        if headers[Grape::Http::Headers::CONTENT_TYPE] == TEXT_HTML\n          message = ERB::Util.html_escape(message)\n        end\n        Rack::Response.new([message], status, headers).finish\n      end\n\n      def format_message(message, backtrace, original_exception = nil)\n        format = env[Grape::Env::API_FORMAT] || options[:format]\n        formatter = Grape::ErrorFormatter.formatter_for(format, options)\n        throw :error,\n              status: 406,\n              message: \"The requested format '#{format}' is not supported.\",\n              backtrace: backtrace,\n              original_exception: original_exception unless formatter\n        formatter.call(message, backtrace, options, env, original_exception)\n      end\n\n      private\n\n      def rescue_handler_for_base_only_class(klass)\n        error, handler = options[:base_only_rescue_handlers].find { |err, _handler| klass == err }\n\n        return unless error\n\n        handler || :default_rescue_handler\n      end\n\n      def rescue_handler_for_class_or_its_ancestor(klass)\n        error, handler = options[:rescue_handlers].find { |err, _handler| klass <= err }\n\n        return unless error\n\n        handler || :default_rescue_handler\n      end\n\n      def rescue_handler_for_grape_exception(klass)\n        return unless klass <= Grape::Exceptions::Base\n        return :error_response if klass == Grape::Exceptions::InvalidVersionHeader\n        return unless options[:rescue_grape_exceptions] || !options[:rescue_all]\n\n        :error_response\n      end\n\n      def rescue_handler_for_any_class(klass)\n        return unless klass <= StandardError\n        return unless options[:rescue_all] || options[:rescue_grape_exceptions]\n\n        options[:all_rescue_handler] || :default_rescue_handler\n      end\n\n      def run_rescue_handler(handler, error)\n        if handler.instance_of?(Symbol)\n          raise NoMethodError, \"undefined method `#{handler}'\" unless respond_to?(handler)\n\n          handler = public_method(handler)\n        end\n\n        handler.arity.zero? ? instance_exec(&handler) : instance_exec(error, &handler)\n      end\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'shared/versioning_examples'\n\ndescribe Grape::API do\n  subject { Class.new(Grape::API) }\n\n  def app\n    subject\n  end\n\n  describe '.prefix' do\n    it 'routes root through with the prefix' do\n      subject.prefix 'awesome/sauce'\n      subject.get do\n        'Hello there.'\n      end\n\n      get 'awesome/sauce/'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'Hello there.'\n    end\n\n    it 'routes through with the prefix' do\n      subject.prefix 'awesome/sauce'\n      subject.get :hello do\n        'Hello there.'\n      end\n\n      get 'awesome/sauce/hello'\n      expect(last_response.body).to eql 'Hello there.'\n\n      get '/hello'\n      expect(last_response.status).to eql 404\n    end\n\n    it 'supports OPTIONS' do\n      subject.prefix 'awesome/sauce'\n      subject.get do\n        'Hello there.'\n      end\n\n      options 'awesome/sauce'\n      expect(last_response.status).to eql 204\n      expect(last_response.body).to be_blank\n    end\n\n    it 'disallows POST' do\n      subject.prefix 'awesome/sauce'\n      subject.get\n\n      post 'awesome/sauce'\n      expect(last_response.status).to eql 405\n    end\n  end\n\n  describe '.version' do\n    context 'when defined' do\n      it 'returns version value' do\n        subject.version 'v1'\n        expect(subject.version).to eq('v1')\n      end\n    end\n\n    context 'when not defined' do\n      it 'returns nil' do\n        expect(subject.version).to be_nil\n      end\n    end\n  end\n\n  describe '.version using path' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :path\n        }\n      end\n    end\n  end\n\n  describe '.version using param' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :param,\n          parameter: 'apiver'\n        }\n      end\n    end\n  end\n\n  describe '.version using header' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :header,\n          vendor: 'mycompany',\n          format: 'json'\n        }\n      end\n    end\n\n    # Behavior as defined by rfc2616 when no header is defined\n    # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\n    describe 'no specified accept header' do\n      # subject.version 'v1', using: :header\n      # subject.get '/hello' do\n      #   'hello'\n      # end\n\n      # it 'routes' do\n      #   get '/hello'\n      #   last_response.status.should eql 200\n      # end\n    end\n\n    # pending 'routes if any media type is allowed'\n  end\n\n  describe '.version using accept_version_header' do\n    it_should_behave_like 'versioning' do\n      let(:macro_options) do\n        {\n          using: :accept_version_header\n        }\n      end\n    end\n  end\n\n  describe '.represent' do\n    it 'requires a :with option' do\n      expect { subject.represent Object, {} }.to raise_error(Grape::Exceptions::InvalidWithOptionForRepresent)\n    end\n\n    it 'adds the association to the :representations setting' do\n      klass = Class.new\n      subject.represent Object, with: klass\n      expect(subject.namespace_stackable_with_hash(:representations)[Object]).to eq(klass)\n    end\n  end\n\n  describe '.namespace' do\n    it 'is retrievable and converted to a path' do\n      internal_namespace = nil\n      subject.namespace :awesome do\n        internal_namespace = namespace\n      end\n      expect(internal_namespace).to eql('/awesome')\n    end\n\n    it 'comes after the prefix and version' do\n      subject.prefix :rad\n      subject.version 'v1', using: :path\n\n      subject.namespace :awesome do\n        get('/hello') { 'worked' }\n      end\n\n      get '/rad/v1/awesome/hello'\n      expect(last_response.body).to eq('worked')\n    end\n\n    it 'cancels itself after the block is over' do\n      internal_namespace = nil\n      subject.namespace :awesome do\n        internal_namespace = namespace\n      end\n      expect(subject.namespace).to eql('/')\n    end\n\n    it 'is stackable' do\n      internal_namespace = nil\n      internal_second_namespace = nil\n      subject.namespace :awesome do\n        internal_namespace = namespace\n        namespace :rad do\n          internal_second_namespace = namespace\n        end\n      end\n      expect(internal_namespace).to eq('/awesome')\n      expect(internal_second_namespace).to eq('/awesome/rad')\n    end\n\n    it 'accepts path segments correctly' do\n      inner_namespace = nil\n      subject.namespace :members do\n        namespace '/:member_id' do\n          inner_namespace = namespace\n          get '/' do\n            params[:member_id]\n          end\n        end\n      end\n      get '/members/23'\n      expect(last_response.body).to eq('23')\n      expect(inner_namespace).to eq('/members/:member_id')\n    end\n\n    it 'is callable with nil just to push onto the stack' do\n      subject.namespace do\n        version 'v2', using: :path\n        get('/hello') { 'inner' }\n      end\n      subject.get('/hello') { 'outer' }\n\n      get '/v2/hello'\n      expect(last_response.body).to eq('inner')\n      get '/hello'\n      expect(last_response.body).to eq('outer')\n    end\n\n    %w[group resource resources segment].each do |als|\n      it \"`.#{als}` is an alias\" do\n        inner_namespace = nil\n        subject.send(als, :awesome) do\n          inner_namespace = namespace\n        end\n        expect(inner_namespace).to eq '/awesome'\n      end\n    end\n  end\n\n  describe '.route_param' do\n    it 'adds a parameterized route segment namespace' do\n      subject.namespace :users do\n        route_param :id do\n          get do\n            params[:id]\n          end\n        end\n      end\n\n      get '/users/23'\n      expect(last_response.body).to eq('23')\n    end\n\n    it 'defines requirements with a single hash' do\n      subject.namespace :users do\n        route_param :id, requirements: /[0-9]+/ do\n          get do\n            params[:id]\n          end\n        end\n      end\n\n      get '/users/michael'\n      expect(last_response.status).to eq(404)\n      get '/users/23'\n      expect(last_response.status).to eq(200)\n    end\n\n    context 'with param type definitions' do\n      it 'is used by passing to options' do\n        subject.namespace :route_param do\n          route_param :foo, type: Integer do\n            get { params.to_json }\n          end\n        end\n        get '/route_param/1234'\n        expect(last_response.body).to eq('{\"foo\":1234}')\n      end\n    end\n  end\n\n  describe '.route' do\n    it 'allows for no path' do\n      subject.namespace :votes do\n        get do\n          'Votes'\n        end\n        post do\n          'Created a Vote'\n        end\n      end\n\n      get '/votes'\n      expect(last_response.body).to eql 'Votes'\n      post '/votes'\n      expect(last_response.body).to eql 'Created a Vote'\n    end\n\n    it 'handles empty calls' do\n      subject.get '/'\n      get '/'\n      expect(last_response.body).to eql ''\n    end\n\n    describe 'root routes should work with' do\n      before do\n        subject.format :txt\n        subject.content_type :json, 'application/json'\n        subject.formatter :json, ->(object, _env) { object }\n        def subject.enable_root_route!\n          get('/') { 'root' }\n        end\n      end\n\n      after do\n        expect(last_response.body).to eql 'root'\n      end\n\n      describe 'path versioned APIs' do\n        before do\n          subject.version version, using: :path\n          subject.enable_root_route!\n        end\n\n        context 'when a single version provided' do\n          let(:version) { 'v1' }\n\n          it 'without a format' do\n            versioned_get '/', 'v1', using: :path\n          end\n\n          it 'with a format' do\n            get '/v1/.json'\n          end\n        end\n\n        context 'when array of versions provided' do\n          let(:version) { %w[v1 v2] }\n\n          it { versioned_get '/', 'v1', using: :path }\n          it { versioned_get '/', 'v2', using: :path }\n        end\n      end\n\n      it 'header versioned APIs' do\n        subject.version 'v1', using: :header, vendor: 'test'\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :header, vendor: 'test'\n      end\n\n      it 'header versioned APIs with multiple headers' do\n        subject.version %w[v1 v2], using: :header, vendor: 'test'\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :header, vendor: 'test'\n        versioned_get '/', 'v2', using: :header, vendor: 'test'\n      end\n\n      it 'param versioned APIs' do\n        subject.version 'v1', using: :param\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :param\n      end\n\n      it 'Accept-Version header versioned APIs' do\n        subject.version 'v1', using: :accept_version_header\n        subject.enable_root_route!\n\n        versioned_get '/', 'v1', using: :accept_version_header\n      end\n\n      it 'unversioned APIs' do\n        subject.enable_root_route!\n\n        get '/'\n      end\n    end\n\n    it 'allows for multiple paths' do\n      subject.get(['/abc', '/def']) do\n        'foo'\n      end\n\n      get '/abc'\n      expect(last_response.body).to eql 'foo'\n      get '/def'\n      expect(last_response.body).to eql 'foo'\n    end\n\n    context 'format' do\n      module ApiSpec\n        class DummyFormatClass\n        end\n      end\n\n      before(:each) do\n        allow_any_instance_of(ApiSpec::DummyFormatClass).to receive(:to_json).and_return('abc')\n        allow_any_instance_of(ApiSpec::DummyFormatClass).to receive(:to_txt).and_return('def')\n\n        subject.get('/abc') do\n          ApiSpec::DummyFormatClass.new\n        end\n      end\n\n      it 'allows .json' do\n        get '/abc.json'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eql 'abc' # json-encoded symbol\n      end\n\n      it 'allows .txt' do\n        get '/abc.txt'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eql 'def' # raw text\n      end\n    end\n\n    it 'allows for format without corrupting a param' do\n      subject.get('/:id') do\n        { 'id' => params[:id] }\n      end\n\n      get '/awesome.json'\n      expect(last_response.body).to eql '{\"id\":\"awesome\"}'\n    end\n\n    it 'allows for format in namespace with no path' do\n      subject.namespace :abc do\n        get do\n          ['json']\n        end\n      end\n\n      get '/abc.json'\n      expect(last_response.body).to eql '[\"json\"]'\n    end\n\n    it 'allows for multiple verbs' do\n      subject.route(%i[get post], '/abc') do\n        'hiya'\n      end\n\n      subject.endpoints.first.routes.each do |route|\n        expect(route.path).to eql '/abc(.:format)'\n      end\n\n      get '/abc'\n      expect(last_response.body).to eql 'hiya'\n      post '/abc'\n      expect(last_response.body).to eql 'hiya'\n    end\n\n    %i[put post].each do |verb|\n      context verb do\n        ['string', :symbol, 1, -1.1, {}, [], true, false, nil].each do |object|\n          it \"allows a(n) #{object.class} json object in params\" do\n            subject.format :json\n            subject.send(verb) do\n              env['api.request.body']\n            end\n            send verb, '/', ::Grape::Json.dump(object), 'CONTENT_TYPE' => 'application/json'\n            expect(last_response.status).to eq(verb == :post ? 201 : 200)\n            expect(last_response.body).to eql ::Grape::Json.dump(object)\n            expect(last_request.params).to eql({})\n          end\n          it 'stores input in api.request.input' do\n            subject.format :json\n            subject.send(verb) do\n              env['api.request.input']\n            end\n            send verb, '/', ::Grape::Json.dump(object), 'CONTENT_TYPE' => 'application/json'\n            expect(last_response.status).to eq(verb == :post ? 201 : 200)\n            expect(last_response.body).to eql ::Grape::Json.dump(object).to_json\n          end\n          context 'chunked transfer encoding' do\n            it 'stores input in api.request.input' do\n              subject.format :json\n              subject.send(verb) do\n                env['api.request.input']\n              end\n              send verb, '/', ::Grape::Json.dump(object), 'CONTENT_TYPE' => 'application/json', 'HTTP_TRANSFER_ENCODING' => 'chunked', 'CONTENT_LENGTH' => nil\n              expect(last_response.status).to eq(verb == :post ? 201 : 200)\n              expect(last_response.body).to eql ::Grape::Json.dump(object).to_json\n            end\n          end\n        end\n      end\n    end\n\n    it 'allows for multipart paths' do\n      subject.route(%i[get post], '/:id/first') do\n        'first'\n      end\n\n      subject.route(%i[get post], '/:id') do\n        'ola'\n      end\n      subject.route(%i[get post], '/:id/first/second') do\n        'second'\n      end\n\n      get '/1'\n      expect(last_response.body).to eql 'ola'\n      post '/1'\n      expect(last_response.body).to eql 'ola'\n      get '/1/first'\n      expect(last_response.body).to eql 'first'\n      post '/1/first'\n      expect(last_response.body).to eql 'first'\n      get '/1/first/second'\n      expect(last_response.body).to eql 'second'\n    end\n\n    it 'allows for :any as a verb' do\n      subject.route(:any, '/abc') do\n        'lol'\n      end\n\n      %w[get post put delete options patch].each do |m|\n        send(m, '/abc')\n        expect(last_response.body).to eql 'lol'\n      end\n    end\n\n    it 'allows for catch-all in a namespace' do\n      subject.namespace :nested do\n        get do\n          'root'\n        end\n\n        get 'something' do\n          'something'\n        end\n\n        route :any, '*path' do\n          'catch-all'\n        end\n      end\n\n      get 'nested'\n      expect(last_response.body).to eql 'root'\n\n      get 'nested/something'\n      expect(last_response.body).to eql 'something'\n\n      get 'nested/missing'\n      expect(last_response.body).to eql 'catch-all'\n\n      post 'nested'\n      expect(last_response.body).to eql 'catch-all'\n\n      post 'nested/something'\n      expect(last_response.body).to eql 'catch-all'\n    end\n\n    verbs = %w[post get head delete put options patch]\n    verbs.each do |verb|\n      it \"allows and properly constrain a #{verb.upcase} method\" do\n        subject.send(verb, '/example') do\n          verb\n        end\n        send(verb, '/example')\n        expect(last_response.body).to eql verb == 'head' ? '' : verb\n        # Call it with all methods other than the properly constrained one.\n        (verbs - [verb]).each do |other_verb|\n          send(other_verb, '/example')\n          expected_rc = if other_verb == 'options' then 204\n                        elsif other_verb == 'head' && verb == 'get' then 200\n                        else 405\n                        end\n          expect(last_response.status).to eql expected_rc\n        end\n      end\n    end\n\n    it 'returns a 201 response code for POST by default' do\n      subject.post('example') do\n        'Created'\n      end\n\n      post '/example'\n      expect(last_response.status).to eql 201\n      expect(last_response.body).to eql 'Created'\n    end\n\n    it 'returns a 405 for an unsupported method with an X-Custom-Header' do\n      subject.before { header 'X-Custom-Header', 'foo' }\n      subject.get 'example' do\n        'example'\n      end\n      put '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.body).to eql '405 Not Allowed'\n      expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n    end\n\n    it 'runs only the before filter on 405 bad method' do\n      subject.namespace :example do\n        before            { header 'X-Custom-Header', 'foo' }\n        before_validation { raise 'before_validation filter should not run' }\n        after_validation  { raise 'after_validation filter should not run' }\n        after             { raise 'after filter should not run' }\n        params { requires :only_for_get }\n        get\n      end\n\n      post '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n    end\n\n    it 'runs before filter exactly once on 405 bad method' do\n      already_run = false\n      subject.namespace :example do\n        before do\n          raise 'before filter ran twice' if already_run\n          already_run = true\n          header 'X-Custom-Header', 'foo'\n        end\n        get\n      end\n\n      post '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n    end\n\n    it 'runs all filters and body with a custom OPTIONS method' do\n      subject.namespace :example do\n        before            { header 'X-Custom-Header-1', 'foo' }\n        before_validation { header 'X-Custom-Header-2', 'foo' }\n        after_validation  { header 'X-Custom-Header-3', 'foo' }\n        after             { header 'X-Custom-Header-4', 'foo' }\n        options { 'yup' }\n        get\n      end\n\n      options '/example'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'yup'\n      expect(last_response.headers['Allow']).to be_nil\n      expect(last_response.headers['X-Custom-Header-1']).to eql 'foo'\n      expect(last_response.headers['X-Custom-Header-2']).to eql 'foo'\n      expect(last_response.headers['X-Custom-Header-3']).to eql 'foo'\n      expect(last_response.headers['X-Custom-Header-4']).to eql 'foo'\n    end\n\n    context 'when format is xml' do\n      it 'returns a 405 for an unsupported method' do\n        subject.format :xml\n        subject.get 'example' do\n          'example'\n        end\n\n        put '/example'\n        expect(last_response.status).to eql 405\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error>\n  <message>405 Not Allowed</message>\n</error>\nXML\n      end\n    end\n\n    context 'when accessing env' do\n      it 'returns a 405 for an unsupported method' do\n        subject.before do\n          _customheader1 = headers['X-Custom-Header']\n          _customheader2 = env['HTTP_X_CUSTOM_HEADER']\n        end\n        subject.get 'example' do\n          'example'\n        end\n        put '/example'\n        expect(last_response.status).to eql 405\n        expect(last_response.body).to eql '405 Not Allowed'\n      end\n    end\n\n    specify '405 responses includes an Allow header specifying supported methods' do\n      subject.get 'example' do\n        'example'\n      end\n      subject.post 'example' do\n        'example'\n      end\n      put '/example'\n      expect(last_response.headers['Allow']).to eql 'OPTIONS, GET, POST, HEAD'\n    end\n\n    specify '405 responses includes an Content-Type header' do\n      subject.get 'example' do\n        'example'\n      end\n      subject.post 'example' do\n        'example'\n      end\n      put '/example'\n      expect(last_response.headers['Content-Type']).to eql 'text/plain'\n    end\n\n    describe 'adds an OPTIONS route that' do\n      before do\n        subject.before            { header 'X-Custom-Header', 'foo' }\n        subject.before_validation { header 'X-Custom-Header-2', 'bar' }\n        subject.after_validation  { header 'X-Custom-Header-3', 'baz' }\n        subject.after             { header 'X-Custom-Header-4', 'bing' }\n        subject.params { requires :only_for_get }\n        subject.get 'example' do\n          'example'\n        end\n        subject.route :any, '*path' do\n          error! :not_found, 404\n        end\n        options '/example'\n      end\n\n      it 'returns a 204' do\n        expect(last_response.status).to eql 204\n      end\n\n      it 'has an empty body' do\n        expect(last_response.body).to be_blank\n      end\n\n      it 'has an Allow header' do\n        expect(last_response.headers['Allow']).to eql 'OPTIONS, GET, HEAD'\n      end\n\n      it 'calls before hook' do\n        expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n      end\n\n      it 'does not call before_validation hook' do\n        expect(last_response.headers.key?('X-Custom-Header-2')).to be false\n      end\n\n      it 'does not call after_validation hook' do\n        expect(last_response.headers.key?('X-Custom-Header-3')).to be false\n      end\n\n      it 'calls after hook' do\n        expect(last_response.headers['X-Custom-Header-4']).to eq 'bing'\n      end\n\n      it 'has no Content-Type' do\n        expect(last_response.content_type).to be_nil\n      end\n\n      it 'has no Content-Length' do\n        expect(last_response.content_length).to be_nil\n      end\n    end\n\n    describe 'adds an OPTIONS route for namespaced endpoints that' do\n      before do\n        subject.before { header 'X-Custom-Header', 'foo' }\n        subject.namespace :example do\n          before { header 'X-Custom-Header-2', 'foo' }\n          get :inner do\n            'example/inner'\n          end\n        end\n        options '/example/inner'\n      end\n\n      it 'returns a 204' do\n        expect(last_response.status).to eql 204\n      end\n\n      it 'has an empty body' do\n        expect(last_response.body).to be_blank\n      end\n\n      it 'has an Allow header' do\n        expect(last_response.headers['Allow']).to eql 'OPTIONS, GET, HEAD'\n      end\n\n      it 'calls the outer before filter' do\n        expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n      end\n\n      it 'calls the inner before filter' do\n        expect(last_response.headers['X-Custom-Header-2']).to eql 'foo'\n      end\n\n      it 'has no Content-Type' do\n        expect(last_response.content_type).to be_nil\n      end\n\n      it 'has no Content-Length' do\n        expect(last_response.content_length).to be_nil\n      end\n    end\n\n    describe 'adds a 405 Not Allowed route that' do\n      before do\n        subject.before { header 'X-Custom-Header', 'foo' }\n        subject.post :example do\n          'example'\n        end\n        get '/example'\n      end\n\n      it 'returns a 405' do\n        expect(last_response.status).to eql 405\n      end\n\n      it 'contains error message in body' do\n        expect(last_response.body).to eq '405 Not Allowed'\n      end\n\n      it 'has an Allow header' do\n        expect(last_response.headers['Allow']).to eql 'OPTIONS, POST'\n      end\n\n      it 'has a X-Custom-Header' do\n        expect(last_response.headers['X-Custom-Header']).to eql 'foo'\n      end\n    end\n\n    context 'allows HEAD on a GET request that' do\n      before do\n        subject.get 'example' do\n          'example'\n        end\n        subject.route :any, '*path' do\n          error! :not_found, 404\n        end\n        head '/example'\n      end\n\n      it 'returns a 200' do\n        expect(last_response.status).to eql 200\n      end\n\n      it 'has an empty body' do\n        expect(last_response.body).to eql ''\n      end\n    end\n\n    it 'overwrites the default HEAD request' do\n      subject.head 'example' do\n        error! 'nothing to see here', 400\n      end\n      subject.get 'example' do\n        'example'\n      end\n      head '/example'\n      expect(last_response.status).to eql 400\n    end\n  end\n\n  context 'do_not_route_head!' do\n    before :each do\n      subject.do_not_route_head!\n      subject.get 'example' do\n        'example'\n      end\n    end\n    it 'options does not contain HEAD' do\n      options '/example'\n      expect(last_response.status).to eql 204\n      expect(last_response.body).to eql ''\n      expect(last_response.headers['Allow']).to eql 'OPTIONS, GET'\n    end\n    it 'does not allow HEAD on a GET request' do\n      head '/example'\n      expect(last_response.status).to eql 405\n    end\n  end\n\n  context 'do_not_route_options!' do\n    before :each do\n      subject.do_not_route_options!\n      subject.get 'example' do\n        'example'\n      end\n    end\n\n    it 'does not create an OPTIONS route' do\n      options '/example'\n      expect(last_response.status).to eql 405\n    end\n\n    it 'does not include OPTIONS in Allow header' do\n      options '/example'\n      expect(last_response.status).to eql 405\n      expect(last_response.headers['Allow']).to eql 'GET, HEAD'\n    end\n  end\n\n  describe 'filters' do\n    it 'adds a before filter' do\n      subject.before { @foo = 'first'  }\n      subject.before { @bar = 'second' }\n      subject.get '/' do\n        \"#{@foo} #{@bar}\"\n      end\n\n      get '/'\n      expect(last_response.body).to eql 'first second'\n    end\n\n    it 'adds a before filter to current and child namespaces only' do\n      subject.get '/' do\n        \"root - #{@foo}\"\n      end\n      subject.namespace :blah do\n        before { @foo = 'foo' }\n        get '/' do\n          \"blah - #{@foo}\"\n        end\n\n        namespace :bar do\n          get '/' do\n            \"blah - bar - #{@foo}\"\n          end\n        end\n      end\n\n      get '/'\n      expect(last_response.body).to eql 'root - '\n      get '/blah'\n      expect(last_response.body).to eql 'blah - foo'\n      get '/blah/bar'\n      expect(last_response.body).to eql 'blah - bar - foo'\n    end\n\n    it 'adds a after_validation filter' do\n      subject.after_validation { @foo = \"first #{params[:id]}:#{params[:id].class}\" }\n      subject.after_validation { @bar = 'second' }\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.get '/' do\n        \"#{@foo} #{@bar}\"\n      end\n\n      get '/', id: '32'\n      expect(last_response.body).to eql \"first 32:#{integer_class_name} second\"\n    end\n\n    it 'adds a after filter' do\n      m = double('after mock')\n      subject.after { m.do_something! }\n      subject.after { m.do_something! }\n      subject.get '/' do\n        @var ||= 'default'\n      end\n\n      expect(m).to receive(:do_something!).exactly(2).times\n      get '/'\n      expect(last_response.body).to eql 'default'\n    end\n\n    it 'calls all filters when validation passes' do\n      a = double('before mock')\n      b = double('before_validation mock')\n      c = double('after_validation mock')\n      d = double('after mock')\n\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.resource ':id' do\n        before { a.do_something! }\n        before_validation { b.do_something! }\n        after_validation { c.do_something! }\n        after { d.do_something! }\n        get do\n          'got it'\n        end\n      end\n\n      expect(a).to receive(:do_something!).exactly(1).times\n      expect(b).to receive(:do_something!).exactly(1).times\n      expect(c).to receive(:do_something!).exactly(1).times\n      expect(d).to receive(:do_something!).exactly(1).times\n\n      get '/123'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'got it'\n    end\n\n    it 'calls only before filters when validation fails' do\n      a = double('before mock')\n      b = double('before_validation mock')\n      c = double('after_validation mock')\n      d = double('after mock')\n\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.resource ':id' do\n        before { a.do_something! }\n        before_validation { b.do_something! }\n        after_validation { c.do_something! }\n        after { d.do_something! }\n        get do\n          'got it'\n        end\n      end\n\n      expect(a).to receive(:do_something!).exactly(1).times\n      expect(b).to receive(:do_something!).exactly(1).times\n      expect(c).to receive(:do_something!).exactly(0).times\n      expect(d).to receive(:do_something!).exactly(0).times\n\n      get '/abc'\n      expect(last_response.status).to eql 400\n      expect(last_response.body).to eql 'id is invalid'\n    end\n\n    it 'calls filters in the correct order' do\n      i = 0\n      a = double('before mock')\n      b = double('before_validation mock')\n      c = double('after_validation mock')\n      d = double('after mock')\n\n      subject.params do\n        requires :id, type: Integer\n      end\n      subject.resource ':id' do\n        before { a.here(i += 1) }\n        before_validation { b.here(i += 1) }\n        after_validation { c.here(i += 1) }\n        after { d.here(i += 1) }\n        get do\n          'got it'\n        end\n      end\n\n      expect(a).to receive(:here).with(1).exactly(1).times\n      expect(b).to receive(:here).with(2).exactly(1).times\n      expect(c).to receive(:here).with(3).exactly(1).times\n      expect(d).to receive(:here).with(4).exactly(1).times\n\n      get '/123'\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'got it'\n    end\n  end\n\n  context 'format' do\n    before do\n      subject.get('/foo') { 'bar' }\n    end\n\n    it 'sets content type for txt format' do\n      get '/foo'\n      expect(last_response.headers['Content-Type']).to eq('text/plain')\n    end\n\n    it 'sets content type for xml' do\n      get '/foo.xml'\n      expect(last_response.headers['Content-Type']).to eq('application/xml')\n    end\n\n    it 'sets content type for json' do\n      get '/foo.json'\n      expect(last_response.headers['Content-Type']).to eq('application/json')\n    end\n\n    it 'sets content type for serializable hash format' do\n      get '/foo.serializable_hash'\n      expect(last_response.headers['Content-Type']).to eq('application/json')\n    end\n\n    it 'sets content type for binary format' do\n      get '/foo.binary'\n      expect(last_response.headers['Content-Type']).to eq('application/octet-stream')\n    end\n\n    it 'returns raw data when content type binary' do\n      image_filename = 'grape.png'\n      file = File.open(image_filename, 'rb', &:read)\n      subject.format :binary\n      subject.get('/binary_file') { File.binread(image_filename) }\n      get '/binary_file'\n      expect(last_response.headers['Content-Type']).to eq('application/octet-stream')\n      expect(last_response.body).to eq(file)\n    end\n\n    it 'returns the content of the file with file' do\n      file_content = 'This is some file content'\n      test_file = Tempfile.new('test')\n      test_file.write file_content\n      test_file.rewind\n\n      subject.get('/file') { file test_file }\n      get '/file'\n      expect(last_response.headers['Content-Length']).to eq('25')\n      expect(last_response.headers['Content-Type']).to eq('text/plain')\n      expect(last_response.body).to eq(file_content)\n    end\n\n    it 'streams the content of the file with stream' do\n      test_stream = Enumerator.new do |blk|\n        blk.yield 'This is some'\n        blk.yield ' file content'\n      end\n\n      subject.use Rack::Chunked\n      subject.get('/stream') { stream test_stream }\n      get '/stream', {}, 'HTTP_VERSION' => 'HTTP/1.1'\n\n      expect(last_response.headers['Content-Type']).to eq('text/plain')\n      expect(last_response.headers['Content-Length']).to eq(nil)\n      expect(last_response.headers['Cache-Control']).to eq('no-cache')\n      expect(last_response.headers['Transfer-Encoding']).to eq('chunked')\n\n      expect(last_response.body).to eq(\"c\\r\\nThis is some\\r\\nd\\r\\n file content\\r\\n0\\r\\n\\r\\n\")\n    end\n\n    it 'sets content type for error' do\n      subject.get('/error') { error!('error in plain text', 500) }\n      get '/error'\n      expect(last_response.headers['Content-Type']).to eql 'text/plain'\n    end\n\n    it 'sets content type for json error' do\n      subject.format :json\n      subject.get('/error') { error!('error in json', 500) }\n      get '/error.json'\n      expect(last_response.status).to eql 500\n      expect(last_response.headers['Content-Type']).to eql 'application/json'\n    end\n\n    it 'sets content type for xml error' do\n      subject.format :xml\n      subject.get('/error') { error!('error in xml', 500) }\n      get '/error'\n      expect(last_response.status).to eql 500\n      expect(last_response.headers['Content-Type']).to eql 'application/xml'\n    end\n\n    it 'includes extension in format' do\n      subject.get(':id') { params[:format] }\n\n      get '/baz.bar'\n      expect(last_response.status).to eq 200\n      expect(last_response.body).to eq 'bar'\n    end\n\n    it 'does not include extension in id' do\n      subject.format :json\n      subject.get(':id') { params }\n\n      get '/baz.bar'\n      expect(last_response.status).to eq 404\n    end\n\n    context 'with a custom content_type' do\n      before do\n        subject.content_type :custom, 'application/custom'\n        subject.formatter :custom, ->(_object, _env) { 'custom' }\n\n        subject.get('/custom') { 'bar' }\n        subject.get('/error') { error!('error in custom', 500) }\n      end\n\n      it 'sets content type' do\n        get '/custom.custom'\n        expect(last_response.headers['Content-Type']).to eql 'application/custom'\n      end\n\n      it 'sets content type for error' do\n        get '/error.custom'\n        expect(last_response.headers['Content-Type']).to eql 'application/custom'\n      end\n    end\n\n    context 'env[\"api.format\"]' do\n      before do\n        subject.post 'attachment' do\n          filename = params[:file][:filename]\n          content_type MIME::Types.type_for(filename)[0].to_s\n          env['api.format'] = :binary # there's no formatter for :binary, data will be returned \"as is\"\n          header 'Content-Disposition', \"attachment; filename*=UTF-8''#{CGI.escape(filename)}\"\n          params[:file][:tempfile].read\n        end\n      end\n\n      ['/attachment.png', 'attachment'].each do |url|\n        it \"uploads and downloads a PNG file via #{url}\" do\n          image_filename = 'grape.png'\n          post url, file: Rack::Test::UploadedFile.new(image_filename, 'image/png', true)\n          expect(last_response.status).to eq(201)\n          expect(last_response.headers['Content-Type']).to eq('image/png')\n          expect(last_response.headers['Content-Disposition']).to eq(\"attachment; filename*=UTF-8''grape.png\")\n          File.open(image_filename, 'rb') do |io|\n            expect(last_response.body).to eq io.read\n          end\n        end\n      end\n\n      it 'uploads and downloads a Ruby file' do\n        filename = __FILE__\n        post '/attachment.rb', file: Rack::Test::UploadedFile.new(filename, 'application/x-ruby', true)\n        expect(last_response.status).to eq(201)\n        expect(last_response.headers['Content-Type']).to eq('application/x-ruby')\n        expect(last_response.headers['Content-Disposition']).to eq(\"attachment; filename*=UTF-8''api_spec.rb\")\n        File.open(filename, 'rb') do |io|\n          expect(last_response.body).to eq io.read\n        end\n      end\n    end\n  end\n\n  context 'custom middleware' do\n    module ApiSpec\n      class PhonyMiddleware\n        def initialize(app, *args)\n          @args = args\n          @app = app\n          @block = block_given? ? true : nil\n        end\n\n        def call(env)\n          env['phony.args'] ||= []\n          env['phony.args'] << @args\n          env['phony.block'] = true if @block\n          @app.call(env)\n        end\n      end\n    end\n\n    describe '.middleware' do\n      it 'includes middleware arguments from settings' do\n        subject.use ApiSpec::PhonyMiddleware, 'abc', 123\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 'abc', 123]]\n      end\n\n      it 'includes all middleware from stacked settings' do\n        subject.use ApiSpec::PhonyMiddleware, 123\n        subject.use ApiSpec::PhonyMiddleware, 'abc'\n        subject.use ApiSpec::PhonyMiddleware, 'foo'\n\n        expect(subject.middleware).to eql [\n          [:use, ApiSpec::PhonyMiddleware, 123],\n          [:use, ApiSpec::PhonyMiddleware, 'abc'],\n          [:use, ApiSpec::PhonyMiddleware, 'foo']\n        ]\n      end\n    end\n\n    describe '.use' do\n      it 'adds middleware' do\n        subject.use ApiSpec::PhonyMiddleware, 123\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 123]]\n      end\n\n      it 'does not show up outside the namespace' do\n        inner_middleware = nil\n        subject.use ApiSpec::PhonyMiddleware, 123\n        subject.namespace :awesome do\n          use ApiSpec::PhonyMiddleware, 'abc'\n          inner_middleware = middleware\n        end\n\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 123]]\n        expect(inner_middleware).to eql [[:use, ApiSpec::PhonyMiddleware, 123], [:use, ApiSpec::PhonyMiddleware, 'abc']]\n      end\n\n      it 'calls the middleware' do\n        subject.use ApiSpec::PhonyMiddleware, 'hello'\n        subject.get '/' do\n          env['phony.args'].first.first\n        end\n\n        get '/'\n        expect(last_response.body).to eql 'hello'\n      end\n\n      it 'adds a block if one is given' do\n        block = -> {}\n        subject.use ApiSpec::PhonyMiddleware, &block\n        expect(subject.middleware).to eql [[:use, ApiSpec::PhonyMiddleware, block]]\n      end\n\n      it 'uses a block if one is given' do\n        block = -> {}\n        subject.use ApiSpec::PhonyMiddleware, &block\n        subject.get '/' do\n          env['phony.block'].inspect\n        end\n\n        get '/'\n        expect(last_response.body).to eq('true')\n      end\n\n      it 'does not destroy the middleware settings on multiple runs' do\n        block = -> {}\n        subject.use ApiSpec::PhonyMiddleware, &block\n        subject.get '/' do\n          env['phony.block'].inspect\n        end\n\n        2.times do\n          get '/'\n          expect(last_response.body).to eq('true')\n        end\n      end\n\n      it 'mounts behind error middleware' do\n        m = Class.new(Grape::Middleware::Base) do\n          def before\n            throw :error, message: 'Caught in the Net', status: 400\n          end\n        end\n        subject.use m\n        subject.get '/' do\n        end\n        get '/'\n        expect(last_response.status).to eq(400)\n        expect(last_response.body).to eq('Caught in the Net')\n      end\n    end\n\n    describe '.insert_before' do\n      it 'runs before a given middleware' do\n        m = Class.new(Grape::Middleware::Base) do\n          def call(env)\n            env['phony.args'] ||= []\n            env['phony.args'] << @options[:message]\n            @app.call(env)\n          end\n        end\n\n        subject.use ApiSpec::PhonyMiddleware, 'hello'\n        subject.insert_before ApiSpec::PhonyMiddleware, m, message: 'bye'\n        subject.get '/' do\n          env['phony.args'].join(' ')\n        end\n\n        get '/'\n        expect(last_response.body).to eql 'bye hello'\n      end\n    end\n\n    describe '.insert_after' do\n      it 'runs after a given middleware' do\n        m = Class.new(Grape::Middleware::Base) do\n          def call(env)\n            env['phony.args'] ||= []\n            env['phony.args'] << @options[:message]\n            @app.call(env)\n          end\n        end\n\n        subject.use ApiSpec::PhonyMiddleware, 'hello'\n        subject.insert_after ApiSpec::PhonyMiddleware, m, message: 'bye'\n        subject.get '/' do\n          env['phony.args'].join(' ')\n        end\n\n        get '/'\n        expect(last_response.body).to eql 'hello bye'\n      end\n    end\n  end\n\n  describe '.http_basic' do\n    it 'protects any resources on the same scope' do\n      subject.http_basic do |u, _p|\n        u == 'allow'\n      end\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello'\n      expect(last_response.status).to eql 401\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n    end\n\n    it 'is scopable' do\n      subject.get(:hello) { 'Hello, world.' }\n      subject.namespace :admin do\n        http_basic do |u, _p|\n          u == 'allow'\n        end\n\n        get(:hello) { 'Hello, world.' }\n      end\n\n      get '/hello'\n      expect(last_response.status).to eql 200\n      get '/admin/hello'\n      expect(last_response.status).to eql 401\n    end\n\n    it 'is callable via .auth as well' do\n      subject.auth :http_basic do |u, _p|\n        u == 'allow'\n      end\n\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello'\n      expect(last_response.status).to eql 401\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n    end\n\n    it 'has access to the current endpoint' do\n      basic_auth_context = nil\n\n      subject.http_basic do |u, _p|\n        basic_auth_context = self\n\n        u == 'allow'\n      end\n\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(basic_auth_context).to be_a_kind_of(Grape::Endpoint)\n    end\n\n    it 'has access to helper methods' do\n      subject.helpers do\n        def authorize(u, p)\n          u == 'allow' && p == 'whatever'\n        end\n      end\n\n      subject.http_basic do |u, p|\n        authorize(u, p)\n      end\n\n      subject.get(:hello) { 'Hello, world.' }\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('disallow', 'whatever')\n      expect(last_response.status).to eql 401\n    end\n\n    it 'can set instance variables accessible to routes' do\n      subject.http_basic do |u, _p|\n        @hello = 'Hello, world.'\n\n        u == 'allow'\n      end\n\n      subject.get(:hello) { @hello }\n      get '/hello', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('allow', 'whatever')\n      expect(last_response.status).to eql 200\n      expect(last_response.body).to eql 'Hello, world.'\n    end\n  end\n\n  describe '.logger' do\n    subject do\n      Class.new(Grape::API) do\n        def self.io\n          @io ||= StringIO.new\n        end\n        logger ::Logger.new(io)\n      end\n    end\n\n    it 'returns an instance of Logger class by default' do\n      expect(subject.logger.class).to eql Logger\n    end\n\n    it 'allows setting a custom logger' do\n      mylogger = Class.new\n      subject.logger mylogger\n      expect(mylogger).to receive(:info).exactly(1).times\n      subject.logger.info 'this will be logged'\n    end\n\n    it 'defaults to a standard logger log format' do\n      t = Time.at(100)\n      allow(Time).to receive(:now).and_return(t)\n      message = \"this will be logged\\n\"\n      message = \"I, [#{Logger::Formatter.new.send(:format_datetime, t)}\\##{Process.pid}]  INFO -- : #{message}\" if !defined?(Rails) || Gem::Version.new(Rails::VERSION::STRING) >= Gem::Version.new('4.0')\n      expect(subject.io).to receive(:write).with(message)\n      subject.logger.info 'this will be logged'\n    end\n  end\n\n  describe '.helpers' do\n    it 'is accessible from the endpoint' do\n      subject.helpers do\n        def hello\n          'Hello, world.'\n        end\n      end\n\n      subject.get '/howdy' do\n        hello\n      end\n\n      get '/howdy'\n      expect(last_response.body).to eql 'Hello, world.'\n    end\n\n    it 'is scopable' do\n      subject.helpers do\n        def generic\n          'always there'\n        end\n      end\n\n      subject.namespace :admin do\n        helpers do\n          def secret\n            'only in admin'\n          end\n        end\n\n        get '/secret' do\n          [generic, secret].join ':'\n        end\n      end\n\n      subject.get '/generic' do\n        [generic, respond_to?(:secret)].join ':'\n      end\n\n      get '/generic'\n      expect(last_response.body).to eql 'always there:false'\n      get '/admin/secret'\n      expect(last_response.body).to eql 'always there:only in admin'\n    end\n\n    it 'is reopenable' do\n      subject.helpers do\n        def one\n          1\n        end\n      end\n\n      subject.helpers do\n        def two\n          2\n        end\n      end\n\n      subject.get 'howdy' do\n        [one, two]\n      end\n\n      expect { get '/howdy' }.not_to raise_error\n    end\n\n    it 'allows for modules' do\n      mod = Module.new do\n        def hello\n          'Hello, world.'\n        end\n      end\n      subject.helpers mod\n\n      subject.get '/howdy' do\n        hello\n      end\n\n      get '/howdy'\n      expect(last_response.body).to eql 'Hello, world.'\n    end\n\n    it 'allows multiple calls with modules and blocks' do\n      subject.helpers Module.new do\n        def one\n          1\n        end\n      end\n      subject.helpers Module.new do\n        def two\n          2\n        end\n      end\n      subject.helpers do\n        def three\n          3\n        end\n      end\n      subject.get 'howdy' do\n        [one, two, three]\n      end\n      expect { get '/howdy' }.not_to raise_error\n    end\n  end\n\n  describe '.scope' do\n    # TODO: refactor this to not be tied to versioning. How about a generic\n    # .setting macro?\n    it 'scopes the various settings' do\n      subject.prefix 'new'\n\n      subject.scope :legacy do\n        prefix 'legacy'\n        get '/abc' do\n          'abc'\n        end\n      end\n\n      subject.get '/def' do\n        'def'\n      end\n\n      get '/new/abc'\n      expect(last_response.status).to eql 404\n      get '/legacy/abc'\n      expect(last_response.status).to eql 200\n      get '/legacy/def'\n      expect(last_response.status).to eql 404\n      get '/new/def'\n      expect(last_response.status).to eql 200\n    end\n  end\n\n  describe '.rescue_from' do\n    it 'does not rescue errors when rescue_from is not set' do\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      expect { get '/exception' }.to raise_error(RuntimeError, 'rain!')\n    end\n\n    it 'uses custom helpers defined by using #helpers method' do\n      subject.helpers do\n        def custom_error!(name)\n          error! \"hello #{name}\"\n        end\n      end\n      subject.rescue_from(ArgumentError) { custom_error! :bob }\n      subject.get '/custom_error' do\n        raise ArgumentError\n      end\n      get '/custom_error'\n      expect(last_response.body).to eq 'hello bob'\n    end\n\n    context 'with multiple apis' do\n      let(:a) { Class.new(Grape::API) }\n      let(:b) { Class.new(Grape::API) }\n\n      before do\n        a.helpers do\n          def foo\n            error!('foo', 401)\n          end\n        end\n        a.rescue_from(:all) { foo }\n        a.get { raise 'boo' }\n        b.helpers do\n          def foo\n            error!('bar', 401)\n          end\n        end\n        b.rescue_from(:all) { foo }\n        b.get { raise 'boo' }\n      end\n\n      it 'avoids polluting global namespace' do\n        env = Rack::MockRequest.env_for('/')\n\n        expect(a.call(env)[2].body).to eq(['foo'])\n        expect(b.call(env)[2].body).to eq(['bar'])\n        expect(a.call(env)[2].body).to eq(['foo'])\n      end\n    end\n\n    it 'rescues all errors if rescue_from :all is called' do\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 500\n      expect(last_response.body).to eq 'rain!'\n    end\n\n    it 'rescues all errors with a json formatter' do\n      subject.format :json\n      subject.default_format :json\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 500\n      expect(last_response.body).to eq({ error: 'rain!' }.to_json)\n    end\n\n    it 'rescues only certain errors if rescue_from is called with specific errors' do\n      subject.rescue_from ArgumentError\n      subject.get('/rescued') { raise ArgumentError }\n      subject.get('/unrescued') { raise 'beefcake' }\n\n      get '/rescued'\n      expect(last_response.status).to eql 500\n\n      expect { get '/unrescued' }.to raise_error(RuntimeError, 'beefcake')\n    end\n\n    context 'CustomError subclass of Grape::Exceptions::Base' do\n      before do\n        module ApiSpec\n          class CustomError < Grape::Exceptions::Base; end\n        end\n      end\n\n      it 'does not re-raise exceptions of type Grape::Exceptions::Base' do\n        subject.get('/custom_exception') { raise ApiSpec::CustomError }\n\n        expect { get '/custom_exception' }.not_to raise_error\n      end\n\n      it 'rescues custom grape exceptions' do\n        subject.rescue_from ApiSpec::CustomError do |e|\n          rack_response('New Error', e.status)\n        end\n        subject.get '/custom_error' do\n          raise ApiSpec::CustomError, status: 400, message: 'Custom Error'\n        end\n\n        get '/custom_error'\n        expect(last_response.status).to eq(400)\n        expect(last_response.body).to eq('New Error')\n      end\n    end\n\n    it 'can rescue exceptions raised in the formatter' do\n      formatter = double(:formatter)\n      allow(formatter).to receive(:call) { raise StandardError }\n      allow(Grape::Formatter).to receive(:formatter_for) { formatter }\n\n      subject.rescue_from :all do |_e|\n        rack_response('Formatter Error', 500)\n      end\n      subject.get('/formatter_exception') { 'Hello world' }\n\n      get '/formatter_exception'\n      expect(last_response.status).to eql 500\n      expect(last_response.body).to eq('Formatter Error')\n    end\n  end\n\n  describe '.rescue_from klass, block' do\n    it 'rescues Exception' do\n      subject.rescue_from RuntimeError do |e|\n        rack_response(\"rescued from #{e.message}\", 202)\n      end\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 202\n      expect(last_response.body).to eq('rescued from rain!')\n    end\n\n    context 'custom errors' do\n      before do\n        class ConnectionError < RuntimeError; end\n        class DatabaseError < RuntimeError; end\n        class CommunicationError < StandardError; end\n      end\n\n      it 'rescues an error via rescue_from :all' do\n        subject.rescue_from :all do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/exception' do\n          raise ConnectionError\n        end\n        get '/exception'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n      end\n      it 'rescues a specific error' do\n        subject.rescue_from ConnectionError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/exception' do\n          raise ConnectionError\n        end\n        get '/exception'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n      end\n      it 'rescues a subclass of an error by default' do\n        subject.rescue_from RuntimeError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/exception' do\n          raise ConnectionError\n        end\n        get '/exception'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n      end\n      it 'rescues multiple specific errors' do\n        subject.rescue_from ConnectionError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.rescue_from DatabaseError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/connection' do\n          raise ConnectionError\n        end\n        subject.get '/database' do\n          raise DatabaseError\n        end\n        get '/connection'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from ConnectionError')\n        get '/database'\n        expect(last_response.status).to eql 500\n        expect(last_response.body).to eq('rescued from DatabaseError')\n      end\n      it 'does not rescue a different error' do\n        subject.rescue_from RuntimeError do |e|\n          rack_response(\"rescued from #{e.class.name}\", 500)\n        end\n        subject.get '/uncaught' do\n          raise CommunicationError\n        end\n        expect { get '/uncaught' }.to raise_error(CommunicationError)\n      end\n    end\n  end\n\n  describe '.rescue_from klass, lambda' do\n    it 'rescues an error with the lambda' do\n      subject.rescue_from ArgumentError, lambda {\n        rack_response('rescued with a lambda', 400)\n      }\n      subject.get('/rescue_lambda') { raise ArgumentError }\n\n      get '/rescue_lambda'\n      expect(last_response.status).to eq(400)\n      expect(last_response.body).to eq('rescued with a lambda')\n    end\n\n    it 'can execute the lambda with an argument' do\n      subject.rescue_from ArgumentError, lambda { |e|\n        rack_response(e.message, 400)\n      }\n      subject.get('/rescue_lambda') { raise ArgumentError, 'lambda takes an argument' }\n\n      get '/rescue_lambda'\n      expect(last_response.status).to eq(400)\n      expect(last_response.body).to eq('lambda takes an argument')\n    end\n  end\n\n  describe '.rescue_from klass, with: :method_name' do\n    it 'rescues an error with the specified method name' do\n      subject.helpers do\n        def rescue_arg_error\n          error!('500 ArgumentError', 500)\n        end\n\n        def rescue_no_method_error\n          error!('500 NoMethodError', 500)\n        end\n      end\n      subject.rescue_from ArgumentError, with: :rescue_arg_error\n      subject.rescue_from NoMethodError, with: :rescue_no_method_error\n      subject.get('/rescue_arg_error') { raise ArgumentError }\n      subject.get('/rescue_no_method_error') { raise NoMethodError }\n\n      get '/rescue_arg_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 ArgumentError')\n\n      get '/rescue_no_method_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 NoMethodError')\n    end\n\n    it 'aborts if the specified method name does not exist' do\n      subject.rescue_from :all, with: :not_exist_method\n      subject.get('/rescue_method') { raise StandardError }\n\n      expect { get '/rescue_method' }.to raise_error(NoMethodError, 'undefined method `not_exist_method\\'')\n    end\n\n    it 'correctly chooses exception handler if :all handler is specified' do\n      subject.helpers do\n        def rescue_arg_error\n          error!('500 ArgumentError', 500)\n        end\n\n        def rescue_all_errors\n          error!('500 AnotherError', 500)\n        end\n      end\n\n      subject.rescue_from ArgumentError, with: :rescue_arg_error\n      subject.rescue_from :all, with: :rescue_all_errors\n      subject.get('/argument_error') { raise ArgumentError }\n      subject.get('/another_error') { raise NoMethodError }\n\n      get '/argument_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 ArgumentError')\n\n      get '/another_error'\n      expect(last_response.status).to eq(500)\n      expect(last_response.body).to eq('500 AnotherError')\n    end\n  end\n\n  describe '.rescue_from klass, rescue_subclasses: boolean' do\n    before do\n      module ApiSpec\n        module APIErrors\n          class ParentError < StandardError; end\n          class ChildError < ParentError; end\n        end\n      end\n    end\n\n    it 'rescues error as well as subclass errors with rescue_subclasses option set' do\n      subject.rescue_from ApiSpec::APIErrors::ParentError, rescue_subclasses: true do |e|\n        rack_response(\"rescued from #{e.class.name}\", 500)\n      end\n      subject.get '/caught_child' do\n        raise ApiSpec::APIErrors::ChildError\n      end\n      subject.get '/caught_parent' do\n        raise ApiSpec::APIErrors::ParentError\n      end\n      subject.get '/uncaught_parent' do\n        raise StandardError\n      end\n\n      get '/caught_child'\n      expect(last_response.status).to eql 500\n      get '/caught_parent'\n      expect(last_response.status).to eql 500\n      expect { get '/uncaught_parent' }.to raise_error(StandardError)\n    end\n\n    it 'sets rescue_subclasses to true by default' do\n      subject.rescue_from ApiSpec::APIErrors::ParentError do |e|\n        rack_response(\"rescued from #{e.class.name}\", 500)\n      end\n      subject.get '/caught_child' do\n        raise ApiSpec::APIErrors::ChildError\n      end\n\n      get '/caught_child'\n      expect(last_response.status).to eql 500\n    end\n\n    it 'does not rescue child errors if rescue_subclasses is false' do\n      subject.rescue_from ApiSpec::APIErrors::ParentError, rescue_subclasses: false do |e|\n        rack_response(\"rescued from #{e.class.name}\", 500)\n      end\n      subject.get '/uncaught' do\n        raise ApiSpec::APIErrors::ChildError\n      end\n      expect { get '/uncaught' }.to raise_error(ApiSpec::APIErrors::ChildError)\n    end\n  end\n\n  describe '.rescue_from :grape_exceptions' do\n    before do\n      subject.rescue_from :grape_exceptions\n    end\n\n    let(:grape_exception) do\n      Grape::Exceptions::Base.new(status: 400, message: 'Grape Error')\n    end\n\n    it 'rescues grape exceptions' do\n      exception = grape_exception\n      subject.get('/grape_exception') { raise exception }\n\n      get '/grape_exception'\n\n      expect(last_response.status).to eq(exception.status)\n      expect(last_response.body).to eq(exception.message)\n    end\n\n    it 'rescues grape exceptions with a user-defined handler' do\n      subject.rescue_from grape_exception.class do |_error|\n        rack_response('Redefined Error', 403)\n      end\n\n      exception = grape_exception\n      subject.get('/grape_exception') { raise exception }\n\n      get '/grape_exception'\n\n      expect(last_response.status).to eq(403)\n      expect(last_response.body).to eq('Redefined Error')\n    end\n  end\n\n  describe '.error_format' do\n    it 'rescues all errors and return :txt' do\n      subject.rescue_from :all\n      subject.format :txt\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.body).to eql 'rain!'\n    end\n\n    it 'rescues all errors and return :txt with backtrace' do\n      subject.rescue_from :all, backtrace: true\n      subject.format :txt\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.body.start_with?(\"rain!\\r\\n\")).to be true\n    end\n\n    it 'rescues all errors with a default formatter' do\n      subject.default_format :foo\n      subject.content_type :foo, 'text/foo'\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception.foo'\n      expect(last_response.body).to start_with 'rain!'\n    end\n\n    it 'defaults the error formatter to format' do\n      subject.format :json\n      subject.rescue_from :all\n      subject.content_type :json, 'application/json'\n      subject.content_type :foo, 'text/foo'\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception.json'\n      expect(last_response.body).to eq('{\"error\":\"rain!\"}')\n      get '/exception.foo'\n      expect(last_response.body).to eq('{\"error\":\"rain!\"}')\n    end\n\n    context 'class' do\n      before :each do\n        module ApiSpec\n          class CustomErrorFormatter\n            def self.call(message, _backtrace, _options, _env, _original_exception)\n              \"message: #{message} @backtrace\"\n            end\n          end\n        end\n      end\n      it 'returns a custom error format' do\n        subject.rescue_from :all, backtrace: true\n        subject.error_formatter :txt, ApiSpec::CustomErrorFormatter\n        subject.get '/exception' do\n          raise 'rain!'\n        end\n        get '/exception'\n        expect(last_response.body).to eq('message: rain! @backtrace')\n      end\n    end\n\n    describe 'with' do\n      context 'class' do\n        before :each do\n          module ApiSpec\n            class CustomErrorFormatter\n              def self.call(message, _backtrace, _option, _env, _original_exception)\n                \"message: #{message} @backtrace\"\n              end\n            end\n          end\n        end\n\n        it 'returns a custom error format' do\n          subject.rescue_from :all, backtrace: true\n          subject.error_formatter :txt, with: ApiSpec::CustomErrorFormatter\n          subject.get('/exception') { raise 'rain!' }\n\n          get '/exception'\n          expect(last_response.body).to eq('message: rain! @backtrace')\n        end\n      end\n    end\n\n    it 'rescues all errors and return :json' do\n      subject.rescue_from :all\n      subject.format :json\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.body).to eql '{\"error\":\"rain!\"}'\n    end\n    it 'rescues all errors and return :json with backtrace' do\n      subject.rescue_from :all, backtrace: true\n      subject.format :json\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      json = ::Grape::Json.load(last_response.body)\n      expect(json['error']).to eql 'rain!'\n      expect(json['backtrace'].length).to be > 0\n    end\n    it 'rescues error! and return txt' do\n      subject.format :txt\n      subject.get '/error' do\n        error!('Access Denied', 401)\n      end\n      get '/error'\n      expect(last_response.body).to eql 'Access Denied'\n    end\n    context 'with json format' do\n      before { subject.format :json }\n\n      it 'rescues error! called with a string and returns json' do\n        subject.get('/error') { error!(:failure, 401) }\n      end\n      it 'rescues error! called with a symbol and returns json' do\n        subject.get('/error') { error!(:failure, 401) }\n      end\n      it 'rescues error! called with a hash and returns json' do\n        subject.get('/error') { error!({ error: :failure }, 401) }\n      end\n\n      after do\n        get '/error'\n        expect(last_response.body).to eql('{\"error\":\"failure\"}')\n      end\n    end\n  end\n\n  describe '.content_type' do\n    it 'sets additional content-type' do\n      subject.content_type :xls, 'application/vnd.ms-excel'\n      subject.get :excel do\n        'some binary content'\n      end\n      get '/excel.xls'\n      expect(last_response.content_type).to eq('application/vnd.ms-excel')\n    end\n    it 'allows to override content-type' do\n      subject.get :content do\n        content_type 'text/javascript'\n        'var x = 1;'\n      end\n      get '/content'\n      expect(last_response.content_type).to eq('text/javascript')\n    end\n    it 'removes existing content types' do\n      subject.content_type :xls, 'application/vnd.ms-excel'\n      subject.get :excel do\n        'some binary content'\n      end\n      get '/excel.json'\n      expect(last_response.status).to eq(406)\n      if ActiveSupport::VERSION::MAJOR == 3\n        expect(last_response.body).to eq('The requested format &#x27;txt&#x27; is not supported.')\n      else\n        expect(last_response.body).to eq('The requested format &#39;txt&#39; is not supported.')\n      end\n    end\n  end\n\n  describe '.formatter' do\n    context 'multiple formatters' do\n      before :each do\n        subject.formatter :json, ->(object, _env) { \"{\\\"custom_formatter\\\":\\\"#{object[:some]}\\\"}\" }\n        subject.formatter :txt, ->(object, _env) { \"custom_formatter: #{object[:some]}\" }\n        subject.get :simple do\n          { some: 'hash' }\n        end\n      end\n      it 'sets one formatter' do\n        get '/simple.json'\n        expect(last_response.body).to eql '{\"custom_formatter\":\"hash\"}'\n      end\n      it 'sets another formatter' do\n        get '/simple.txt'\n        expect(last_response.body).to eql 'custom_formatter: hash'\n      end\n    end\n    context 'custom formatter' do\n      before :each do\n        subject.content_type :json, 'application/json'\n        subject.content_type :custom, 'application/custom'\n        subject.formatter :custom, ->(object, _env) { \"{\\\"custom_formatter\\\":\\\"#{object[:some]}\\\"}\" }\n        subject.get :simple do\n          { some: 'hash' }\n        end\n      end\n      it 'uses json' do\n        get '/simple.json'\n        expect(last_response.body).to eql '{\"some\":\"hash\"}'\n      end\n      it 'uses custom formatter' do\n        get '/simple.custom', 'HTTP_ACCEPT' => 'application/custom'\n        expect(last_response.body).to eql '{\"custom_formatter\":\"hash\"}'\n      end\n    end\n    context 'custom formatter class' do\n      module ApiSpec\n        module CustomFormatter\n          def self.call(object, _env)\n            \"{\\\"custom_formatter\\\":\\\"#{object[:some]}\\\"}\"\n          end\n        end\n      end\n      before :each do\n        subject.content_type :json, 'application/json'\n        subject.content_type :custom, 'application/custom'\n        subject.formatter :custom, ApiSpec::CustomFormatter\n        subject.get :simple do\n          { some: 'hash' }\n        end\n      end\n      it 'uses json' do\n        get '/simple.json'\n        expect(last_response.body).to eql '{\"some\":\"hash\"}'\n      end\n      it 'uses custom formatter' do\n        get '/simple.custom', 'HTTP_ACCEPT' => 'application/custom'\n        expect(last_response.body).to eql '{\"custom_formatter\":\"hash\"}'\n      end\n    end\n  end\n\n  describe '.parser' do\n    it 'parses data in format requested by content-type' do\n      subject.format :json\n      subject.post '/data' do\n        { x: params[:x] }\n      end\n      post '/data', '{\"x\":42}', 'CONTENT_TYPE' => 'application/json'\n      expect(last_response.status).to eq(201)\n      expect(last_response.body).to eq('{\"x\":42}')\n    end\n    context 'lambda parser' do\n      before :each do\n        subject.content_type :txt, 'text/plain'\n        subject.content_type :custom, 'text/custom'\n        subject.parser :custom, ->(object, _env) { { object.to_sym => object.to_s.reverse } }\n        subject.put :simple do\n          params[:simple]\n        end\n      end\n      ['text/custom', 'text/custom; charset=UTF-8'].each do |content_type|\n        it \"uses parser for #{content_type}\" do\n          put '/simple', 'simple', 'CONTENT_TYPE' => content_type\n          expect(last_response.status).to eq(200)\n          expect(last_response.body).to eql 'elpmis'\n        end\n      end\n    end\n    context 'custom parser class' do\n      module ApiSpec\n        module CustomParser\n          def self.call(object, _env)\n            { object.to_sym => object.to_s.reverse }\n          end\n        end\n      end\n      before :each do\n        subject.content_type :txt, 'text/plain'\n        subject.content_type :custom, 'text/custom'\n        subject.parser :custom, ApiSpec::CustomParser\n        subject.put :simple do\n          params[:simple]\n        end\n      end\n      it 'uses custom parser' do\n        put '/simple', 'simple', 'CONTENT_TYPE' => 'text/custom'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eql 'elpmis'\n      end\n    end\n    if Object.const_defined? :MultiXml\n      context 'multi_xml' do\n        it \"doesn't parse yaml\" do\n          subject.put :yaml do\n            params[:tag]\n          end\n          put '/yaml', '<tag type=\"symbol\">a123</tag>', 'CONTENT_TYPE' => 'application/xml'\n          expect(last_response.status).to eq(400)\n          expect(last_response.body).to eql 'Disallowed type attribute: \"symbol\"'\n        end\n      end\n    else\n      context 'default xml parser' do\n        it 'parses symbols' do\n          subject.put :yaml do\n            params[:tag]\n          end\n          put '/yaml', '<tag type=\"symbol\">a123</tag>', 'CONTENT_TYPE' => 'application/xml'\n          expect(last_response.status).to eq(200)\n          expect(last_response.body).to eql '{\"type\"=>\"symbol\", \"__content__\"=>\"a123\"}'\n        end\n      end\n    end\n    context 'none parser class' do\n      before :each do\n        subject.parser :json, nil\n        subject.put 'data' do\n          \"body: #{env['api.request.body']}\"\n        end\n      end\n      it 'does not parse data' do\n        put '/data', 'not valid json', 'CONTENT_TYPE' => 'application/json'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('body: not valid json')\n      end\n    end\n  end\n\n  describe '.default_format' do\n    before :each do\n      subject.format :json\n      subject.default_format :json\n    end\n    it 'returns data in default format' do\n      subject.get '/data' do\n        { x: 42 }\n      end\n      get '/data'\n      expect(last_response.status).to eq(200)\n      expect(last_response.body).to eq('{\"x\":42}')\n    end\n    it 'parses data in default format' do\n      subject.post '/data' do\n        { x: params[:x] }\n      end\n      post '/data', '{\"x\":42}', 'CONTENT_TYPE' => ''\n      expect(last_response.status).to eq(201)\n      expect(last_response.body).to eq('{\"x\":42}')\n    end\n  end\n\n  describe '.default_error_status' do\n    it 'allows setting default_error_status' do\n      subject.rescue_from :all\n      subject.default_error_status 200\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 200\n    end\n    it 'has a default error status' do\n      subject.rescue_from :all\n      subject.get '/exception' do\n        raise 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 500\n    end\n    it 'uses the default error status in error!' do\n      subject.rescue_from :all\n      subject.default_error_status 400\n      subject.get '/exception' do\n        error! 'rain!'\n      end\n      get '/exception'\n      expect(last_response.status).to eql 400\n    end\n  end\n\n  context 'http_codes' do\n    let(:error_presenter) do\n      Class.new(Grape::Entity) do\n        expose :code\n        expose :static\n\n        def static\n          'some static text'\n        end\n      end\n    end\n\n    it 'is used as presenter' do\n      subject.desc 'some desc', http_codes: [\n        [408, 'Unauthorized', error_presenter]\n      ]\n\n      subject.get '/exception' do\n        error!({ code: 408 }, 408)\n      end\n\n      get '/exception'\n      expect(last_response.status).to eql 408\n      expect(last_response.body).to eql({ code: 408, static: 'some static text' }.to_json)\n    end\n\n    it 'presented with' do\n      error = { code: 408, with: error_presenter }.freeze\n      subject.get '/exception' do\n        error! error, 408\n      end\n\n      get '/exception'\n      expect(last_response.status).to eql 408\n      expect(last_response.body).to eql({ code: 408, static: 'some static text' }.to_json)\n    end\n  end\n\n  context 'routes' do\n    describe 'empty api structure' do\n      it 'returns an empty array of routes' do\n        expect(subject.routes).to eq([])\n      end\n    end\n    describe 'single method api structure' do\n      before(:each) do\n        subject.get :ping do\n          'pong'\n        end\n      end\n      it 'returns one route' do\n        expect(subject.routes.size).to eq(1)\n        route = subject.routes[0]\n        expect(route.version).to be_nil\n        expect(route.path).to eq('/ping(.:format)')\n        expect(route.request_method).to eq('GET')\n      end\n    end\n    describe 'api structure with two versions and a namespace' do\n      before :each do\n        subject.version 'v1', using: :path\n        subject.get 'version' do\n          api.version\n        end\n        # version v2\n        subject.version 'v2', using: :path\n        subject.prefix 'p'\n        subject.namespace 'n1' do\n          namespace 'n2' do\n            get 'version' do\n              api.version\n            end\n          end\n        end\n      end\n      it 'returns the latest version set' do\n        expect(subject.version).to eq('v2')\n      end\n      it 'returns versions' do\n        expect(subject.versions).to eq(%w[v1 v2])\n      end\n      it 'sets route paths' do\n        expect(subject.routes.size).to be >= 2\n        expect(subject.routes[0].path).to eq('/:version/version(.:format)')\n        expect(subject.routes[1].path).to eq('/p/:version/n1/n2/version(.:format)')\n      end\n      it 'sets route versions' do\n        expect(subject.routes[0].version).to eq('v1')\n        expect(subject.routes[1].version).to eq('v2')\n      end\n      it 'sets a nested namespace' do\n        expect(subject.routes[1].namespace).to eq('/n1/n2')\n      end\n      it 'sets prefix' do\n        expect(subject.routes[1].prefix).to eq('p')\n      end\n    end\n    describe 'api structure with additional parameters' do\n      before(:each) do\n        subject.params do\n          requires :token, desc: 'a token'\n          optional :limit, desc: 'the limit'\n        end\n        subject.get 'split/:string' do\n          params[:string].split(params[:token], (params[:limit] || 0).to_i)\n        end\n      end\n      it 'splits a string' do\n        get '/split/a,b,c.json', token: ','\n        expect(last_response.body).to eq('[\"a\",\"b\",\"c\"]')\n      end\n      it 'splits a string with limit' do\n        get '/split/a,b,c.json', token: ',', limit: '2'\n        expect(last_response.body).to eq('[\"a\",\"b,c\"]')\n      end\n      it 'sets params' do\n        expect(subject.routes.map do |route|\n          { params: route.params }\n        end).to eq [\n          {\n            params: {\n              'string' => '',\n              'token' => { required: true, desc: 'a token' },\n              'limit' => { required: false, desc: 'the limit' }\n            }\n          }\n        ]\n      end\n    end\n    describe 'api structure with multiple apis' do\n      before(:each) do\n        subject.params do\n          requires :one, desc: 'a token'\n          optional :two, desc: 'the limit'\n        end\n        subject.get 'one' do\n        end\n\n        subject.params do\n          requires :three, desc: 'a token'\n          optional :four, desc: 'the limit'\n        end\n        subject.get 'two' do\n        end\n      end\n      it 'sets params' do\n        expect(subject.routes.map do |route|\n          { params: route.params }\n        end).to eq [\n          {\n            params: {\n              'one' => { required: true, desc: 'a token' },\n              'two' => { required: false, desc: 'the limit' }\n            }\n          },\n          {\n            params: {\n              'three' => { required: true, desc: 'a token' },\n              'four' => { required: false, desc: 'the limit' }\n            }\n          }\n        ]\n      end\n    end\n    describe 'api structure with an api without params' do\n      before(:each) do\n        subject.params do\n          requires :one, desc: 'a token'\n          optional :two, desc: 'the limit'\n        end\n        subject.get 'one' do\n        end\n\n        subject.get 'two' do\n        end\n      end\n      it 'sets params' do\n        expect(subject.routes.map do |route|\n          { params: route.params }\n        end).to eq [\n          {\n            params: {\n              'one' => { required: true, desc: 'a token' },\n              'two' => { required: false, desc: 'the limit' }\n            }\n          },\n          {\n            params: {}\n          }\n        ]\n      end\n    end\n    describe 'api with a custom route setting' do\n      before(:each) do\n        subject.route_setting :custom, key: 'value'\n        subject.get 'one'\n      end\n      it 'exposed' do\n        expect(subject.routes.count).to eq 1\n        route = subject.routes.first\n        expect(route.settings[:custom]).to eq(key: 'value')\n      end\n    end\n    describe 'status' do\n      it 'can be set to arbitrary Integer value' do\n        subject.get '/foo' do\n          status 210\n        end\n        get '/foo'\n        expect(last_response.status).to eq 210\n      end\n      it 'can be set with a status code symbol' do\n        subject.get '/foo' do\n          status :see_other\n        end\n        get '/foo'\n        expect(last_response.status).to eq 303\n      end\n    end\n  end\n\n  context 'desc' do\n    it 'empty array of routes' do\n      expect(subject.routes).to eq([])\n    end\n    it 'empty array of routes' do\n      subject.desc 'grape api'\n      expect(subject.routes).to eq([])\n    end\n    it 'describes a method' do\n      subject.desc 'first method'\n      subject.get :first\n      expect(subject.routes.length).to eq(1)\n      route = subject.routes.first\n      expect(route.description).to eq('first method')\n      expect(route.route_foo).to be_nil\n      expect(route.params).to eq({})\n      expect(route.options).to be_a_kind_of(Hash)\n    end\n    it 'has params which does not include format and version as named captures' do\n      subject.version :v1, using: :path\n      subject.get :first\n      param_keys = subject.routes.first.params.keys\n      expect(param_keys).not_to include('format')\n      expect(param_keys).not_to include('version')\n    end\n    it 'describes methods separately' do\n      subject.desc 'first method'\n      subject.get :first\n      subject.desc 'second method'\n      subject.get :second\n      expect(subject.routes.count).to eq(2)\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'first method', params: {} },\n        { description: 'second method', params: {} }\n      ]\n    end\n    it 'resets desc' do\n      subject.desc 'first method'\n      subject.get :first\n      subject.get :second\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'first method', params: {} },\n        { description: nil, params: {} }\n      ]\n    end\n    it 'namespaces and describe arbitrary parameters' do\n      subject.namespace 'ns' do\n        desc 'ns second', foo: 'bar'\n        get 'second'\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, foo: route.route_foo, params: route.params }\n      end).to eq [\n        { description: 'ns second', foo: 'bar', params: {} }\n      ]\n    end\n    it 'includes details' do\n      subject.desc 'method', details: 'method details'\n      subject.get 'method'\n      expect(subject.routes.map do |route|\n        { description: route.description, details: route.details, params: route.params }\n      end).to eq [\n        { description: 'method', details: 'method details', params: {} }\n      ]\n    end\n    it 'describes a method with parameters' do\n      subject.desc 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } }\n      subject.get 'reverse' do\n        params[:s].reverse\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } } }\n      ]\n    end\n    it 'does not inherit param descriptions in consequent namespaces' do\n      subject.desc 'global description'\n      subject.params do\n        requires :param1\n        optional :param2\n      end\n      subject.namespace 'ns1' do\n        get { ; }\n      end\n      subject.params do\n        optional :param2\n      end\n      subject.namespace 'ns2' do\n        get { ; }\n      end\n      routes_doc = subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end\n      expect(routes_doc).to eq [\n        { description: 'global description',\n          params: {\n            'param1' => { required: true },\n            'param2' => { required: false }\n          } },\n        { description: 'global description',\n          params: {\n            'param2' => { required: false }\n          } }\n      ]\n    end\n    it 'merges the parameters of the namespace with the parameters of the method' do\n      subject.desc 'namespace'\n      subject.params do\n        requires :ns_param, desc: 'namespace parameter'\n      end\n      subject.namespace 'ns' do\n        desc 'method'\n        params do\n          optional :method_param, desc: 'method parameter'\n        end\n        get 'method'\n      end\n\n      routes_doc = subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end\n      expect(routes_doc).to eq [\n        { description: 'method',\n          params: {\n            'ns_param' => { required: true, desc: 'namespace parameter' },\n            'method_param' => { required: false, desc: 'method parameter' }\n          } }\n      ]\n    end\n    it 'merges the parameters of nested namespaces' do\n      subject.desc 'ns1'\n      subject.params do\n        optional :ns_param, desc: 'ns param 1'\n        requires :ns1_param, desc: 'ns1 param'\n      end\n      subject.namespace 'ns1' do\n        desc 'ns2'\n        params do\n          requires :ns_param, desc: 'ns param 2'\n          requires :ns2_param, desc: 'ns2 param'\n        end\n        namespace 'ns2' do\n          desc 'method'\n          params do\n            optional :method_param, desc: 'method param'\n          end\n          get 'method'\n        end\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'method',\n          params: {\n            'ns_param' => { required: true, desc: 'ns param 2' },\n            'ns1_param' => { required: true, desc: 'ns1 param' },\n            'ns2_param' => { required: true, desc: 'ns2 param' },\n            'method_param' => { required: false, desc: 'method param' }\n          } }\n      ]\n    end\n    it 'groups nested params and prevents overwriting of params with same name in different groups' do\n      subject.desc 'method'\n      subject.params do\n        group :group1, type: Array do\n          optional :param1, desc: 'group1 param1 desc'\n          requires :param2, desc: 'group1 param2 desc'\n        end\n        group :group2, type: Array do\n          optional :param1, desc: 'group2 param1 desc'\n          requires :param2, desc: 'group2 param2 desc'\n        end\n      end\n      subject.get 'method'\n\n      expect(subject.routes.map(&:params)).to eq [{\n        'group1'         => { required: true, type: 'Array' },\n        'group1[param1]' => { required: false, desc: 'group1 param1 desc' },\n        'group1[param2]' => { required: true, desc: 'group1 param2 desc' },\n        'group2'         => { required: true, type: 'Array' },\n        'group2[param1]' => { required: false, desc: 'group2 param1 desc' },\n        'group2[param2]' => { required: true, desc: 'group2 param2 desc' }\n      }]\n    end\n    it 'uses full name of parameters in nested groups' do\n      subject.desc 'nesting'\n      subject.params do\n        requires :root_param, desc: 'root param'\n        group :nested, type: Array do\n          requires :nested_param, desc: 'nested param'\n        end\n      end\n      subject.get 'method'\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'nesting',\n          params: {\n            'root_param' => { required: true, desc: 'root param' },\n            'nested' => { required: true, type: 'Array' },\n            'nested[nested_param]' => { required: true, desc: 'nested param' }\n          } }\n      ]\n    end\n    it 'allows to set the type attribute on :group element' do\n      subject.params do\n        group :foo, type: Array do\n          optional :bar\n        end\n      end\n    end\n    it 'parses parameters when no description is given' do\n      subject.params do\n        requires :one_param, desc: 'one param'\n      end\n      subject.get 'method'\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: nil, params: { 'one_param' => { required: true, desc: 'one param' } } }\n      ]\n    end\n    it 'does not symbolize params' do\n      subject.desc 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } }\n      subject.get 'reverse/:s' do\n        params[:s].reverse\n      end\n      expect(subject.routes.map do |route|\n        { description: route.description, params: route.params }\n      end).to eq [\n        { description: 'Reverses a string.', params: { 's' => { desc: 'string to reverse', type: 'string' } } }\n      ]\n    end\n  end\n\n  describe '.mount' do\n    let(:mounted_app) { ->(_env) { [200, {}, ['MOUNTED']] } }\n\n    context 'with a bare rack app' do\n      before do\n        subject.mount mounted_app => '/mounty'\n      end\n\n      it 'makes a bare Rack app available at the endpoint' do\n        get '/mounty'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n\n      it 'anchors the routes, passing all subroutes to it' do\n        get '/mounty/awesome'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n\n      it 'is able to cascade' do\n        subject.mount lambda { |env|\n          headers = {}\n          headers['X-Cascade'] == 'pass' unless env['PATH_INFO'].include?('boo')\n          [200, headers, ['Farfegnugen']]\n        } => '/'\n\n        get '/boo'\n        expect(last_response.body).to eq('Farfegnugen')\n        get '/mounty'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n    end\n\n    context 'without a hash' do\n      it 'calls through setting the route to \"/\"' do\n        subject.mount mounted_app\n        get '/'\n        expect(last_response.body).to eq('MOUNTED')\n      end\n    end\n\n    context 'mounting an API' do\n      it 'applies the settings of the mounting api' do\n        subject.version 'v1', using: :path\n\n        subject.namespace :cool do\n          app = Class.new(Grape::API)\n          app.get('/awesome') do\n            'yo'\n          end\n\n          mount app\n        end\n\n        get '/v1/cool/awesome'\n        expect(last_response.body).to eq('yo')\n      end\n\n      it 'applies the settings to nested mounted apis' do\n        subject.version 'v1', using: :path\n\n        subject.namespace :cool do\n          inner_app = Class.new(Grape::API)\n          inner_app.get('/awesome') do\n            'yo'\n          end\n\n          app = Class.new(Grape::API)\n          app.mount inner_app\n          mount app\n        end\n\n        get '/v1/cool/awesome'\n        expect(last_response.body).to eq('yo')\n      end\n\n      context 'when some rescues are defined by mounted' do\n        it 'inherits parent rescues' do\n          subject.rescue_from :all do |e|\n            rack_response(\"rescued from #{e.message}\", 202)\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            app.rescue_from ArgumentError\n            app.get('/fail') { raise 'doh!' }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.status).to eql 202\n          expect(last_response.body).to eq('rescued from doh!')\n        end\n        it 'prefers rescues defined by mounted if they rescue similar error class' do\n          subject.rescue_from StandardError do\n            rack_response('outer rescue')\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            rescue_from StandardError do\n              rack_response('inner rescue')\n            end\n            app.get('/fail') { raise 'doh!' }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.body).to eq('inner rescue')\n        end\n        it 'prefers rescues defined by mounted even if outer is more specific' do\n          subject.rescue_from ArgumentError do\n            rack_response('outer rescue')\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            rescue_from StandardError do\n              rack_response('inner rescue')\n            end\n            app.get('/fail') { raise ArgumentError.new }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.body).to eq('inner rescue')\n        end\n        it 'prefers more specific rescues defined by mounted' do\n          subject.rescue_from StandardError do\n            rack_response('outer rescue')\n          end\n\n          app = Class.new(Grape::API)\n\n          subject.namespace :mounted do\n            rescue_from ArgumentError do\n              rack_response('inner rescue')\n            end\n            app.get('/fail') { raise ArgumentError.new }\n            mount app\n          end\n\n          get '/mounted/fail'\n          expect(last_response.body).to eq('inner rescue')\n        end\n      end\n\n      it 'collects the routes of the mounted api' do\n        subject.namespace :cool do\n          app = Class.new(Grape::API)\n          app.get('/awesome') {}\n          app.post('/sauce') {}\n          mount app\n        end\n        expect(subject.routes.size).to eq(2)\n        expect(subject.routes.first.path).to match(%r{\\/cool\\/awesome})\n        expect(subject.routes.last.path).to match(%r{\\/cool\\/sauce})\n      end\n\n      it 'mounts on a path' do\n        subject.namespace :cool do\n          app = Class.new(Grape::API)\n          app.get '/awesome' do\n            'sauce'\n          end\n          mount app => '/mounted'\n        end\n        get '/mounted/cool/awesome'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('sauce')\n      end\n\n      it 'mounts on a nested path' do\n        APP1 = Class.new(Grape::API)\n        APP2 = Class.new(Grape::API)\n        APP2.get '/nice' do\n          'play'\n        end\n        # note that the reverse won't work, mount from outside-in\n        APP3 = subject\n        APP3.mount APP1 => '/app1'\n        APP1.mount APP2 => '/app2'\n        get '/app1/app2/nice'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('play')\n        options '/app1/app2/nice'\n        expect(last_response.status).to eq(204)\n      end\n\n      it 'responds to options' do\n        app = Class.new(Grape::API)\n        app.get '/colour' do\n          'red'\n        end\n        app.namespace :pears do\n          get '/colour' do\n            'green'\n          end\n        end\n        subject.namespace :apples do\n          mount app\n        end\n\n        get '/apples/colour'\n        expect(last_response.status).to eql 200\n        expect(last_response.body).to eq('red')\n        options '/apples/colour'\n        expect(last_response.status).to eql 204\n        get '/apples/pears/colour'\n        expect(last_response.status).to eql 200\n        expect(last_response.body).to eq('green')\n        options '/apples/pears/colour'\n        expect(last_response.status).to eql 204\n      end\n\n      it 'responds to options with path versioning' do\n        subject.version 'v1', using: :path\n        subject.namespace :apples do\n          app = Class.new(Grape::API)\n          app.get('/colour') do\n            'red'\n          end\n          mount app\n        end\n\n        get '/v1/apples/colour'\n        expect(last_response.status).to eql 200\n        expect(last_response.body).to eq('red')\n        options '/v1/apples/colour'\n        expect(last_response.status).to eql 204\n      end\n\n      it 'mounts a versioned API with nested resources' do\n        api = Class.new(Grape::API) do\n          version 'v1'\n          resources :users do\n            get :hello do\n              'hello users'\n            end\n          end\n        end\n        subject.mount api\n\n        get '/v1/users/hello'\n        expect(last_response.body).to eq('hello users')\n      end\n\n      it 'mounts a prefixed API with nested resources' do\n        api = Class.new(Grape::API) do\n          prefix 'api'\n          resources :users do\n            get :hello do\n              'hello users'\n            end\n          end\n        end\n        subject.mount api\n\n        get '/api/users/hello'\n        expect(last_response.body).to eq('hello users')\n      end\n\n      it 'applies format to a mounted API with nested resources' do\n        api = Class.new(Grape::API) do\n          format :json\n          resources :users do\n            get do\n              { users: true }\n            end\n          end\n        end\n        subject.mount api\n\n        get '/users'\n        expect(last_response.body).to eq({ users: true }.to_json)\n      end\n\n      it 'applies auth to a mounted API with nested resources' do\n        api = Class.new(Grape::API) do\n          format :json\n          http_basic do |username, password|\n            username == 'username' && password == 'password'\n          end\n          resources :users do\n            get do\n              { users: true }\n            end\n          end\n        end\n        subject.mount api\n\n        get '/users'\n        expect(last_response.status).to eq(401)\n\n        get '/users', {}, 'HTTP_AUTHORIZATION' => encode_basic_auth('username', 'password')\n        expect(last_response.body).to eq({ users: true }.to_json)\n      end\n\n      it 'mounts multiple versioned APIs with nested resources' do\n        api1 = Class.new(Grape::API) do\n          version 'one', using: :header, vendor: 'test'\n          resources :users do\n            get :hello do\n              'one'\n            end\n          end\n        end\n\n        api2 = Class.new(Grape::API) do\n          version 'two', using: :header, vendor: 'test'\n          resources :users do\n            get :hello do\n              'two'\n            end\n          end\n        end\n\n        subject.mount api1\n        subject.mount api2\n\n        versioned_get '/users/hello', 'one', using: :header, vendor: 'test'\n        expect(last_response.body).to eq('one')\n        versioned_get '/users/hello', 'two', using: :header, vendor: 'test'\n        expect(last_response.body).to eq('two')\n      end\n\n      it 'recognizes potential versions with mounted path' do\n        a = Class.new(Grape::API) do\n          version :v1, using: :path\n\n          get '/hello' do\n            'hello'\n          end\n        end\n\n        b = Class.new(Grape::API) do\n          version :v1, using: :path\n\n          get '/world' do\n            'world'\n          end\n        end\n\n        subject.mount a => '/one'\n        subject.mount b => '/two'\n\n        get '/one/v1/hello'\n        expect(last_response.status).to eq 200\n\n        get '/two/v1/world'\n        expect(last_response.status).to eq 200\n      end\n\n      context 'when mounting class extends a subclass of Grape::API' do\n        it 'mounts APIs with the same superclass' do\n          base_api = Class.new(Grape::API)\n          a = Class.new(base_api)\n          b = Class.new(base_api)\n\n          expect { a.mount b }.to_not raise_error\n        end\n      end\n    end\n  end\n\n  describe '.endpoints' do\n    it 'adds one for each route created' do\n      subject.get '/'\n      subject.post '/'\n      expect(subject.endpoints.size).to eq(2)\n    end\n  end\n\n  describe '.compile' do\n    it 'sets the instance' do\n      expect(subject.instance).to be_nil\n      subject.compile\n      expect(subject.instance).to be_kind_of(subject)\n    end\n  end\n\n  describe '.change!' do\n    it 'invalidates any compiled instance' do\n      subject.compile\n      subject.change!\n      expect(subject.instance).to be_nil\n    end\n  end\n\n  describe '.endpoint' do\n    before(:each) do\n      subject.format :json\n      subject.get '/endpoint/options' do\n        {\n          path: options[:path],\n          source_location: source.source_location\n        }\n      end\n    end\n    it 'path' do\n      get '/endpoint/options'\n      options = ::Grape::Json.load(last_response.body)\n      expect(options['path']).to eq(['/endpoint/options'])\n      expect(options['source_location'][0]).to include 'api_spec.rb'\n      expect(options['source_location'][1].to_i).to be > 0\n    end\n  end\n\n  describe '.route' do\n    context 'plain' do\n      before(:each) do\n        subject.get '/' do\n          route.path\n        end\n        subject.get '/path' do\n          route.path\n        end\n      end\n      it 'provides access to route info' do\n        get '/'\n        expect(last_response.body).to eq('/(.:format)')\n        get '/path'\n        expect(last_response.body).to eq('/path(.:format)')\n      end\n    end\n    context 'with desc' do\n      before(:each) do\n        subject.desc 'returns description'\n        subject.get '/description' do\n          route.description\n        end\n        subject.desc 'returns parameters', params: { 'x' => 'y' }\n        subject.get '/params/:id' do\n          route.params[params[:id]]\n        end\n      end\n      it 'returns route description' do\n        get '/description'\n        expect(last_response.body).to eq('returns description')\n      end\n      it 'returns route parameters' do\n        get '/params/x'\n        expect(last_response.body).to eq('y')\n      end\n    end\n  end\n  describe '.format' do\n    context ':txt' do\n      before(:each) do\n        subject.format :txt\n        subject.content_type :json, 'application/json'\n        subject.get '/meaning_of_life' do\n          { meaning_of_life: 42 }\n        end\n      end\n      it 'forces txt without an extension' do\n        get '/meaning_of_life'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'does not force txt with an extension' do\n        get '/meaning_of_life.json'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_json)\n      end\n      it 'forces txt from a non-accepting header' do\n        get '/meaning_of_life', {}, 'HTTP_ACCEPT' => 'application/json'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n    end\n    context ':txt only' do\n      before(:each) do\n        subject.format :txt\n        subject.get '/meaning_of_life' do\n          { meaning_of_life: 42 }\n        end\n      end\n      it 'forces txt without an extension' do\n        get '/meaning_of_life'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'accepts specified extension' do\n        get '/meaning_of_life.txt'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'does not accept extensions other than specified' do\n        get '/meaning_of_life.json'\n        expect(last_response.status).to eq(404)\n      end\n      it 'forces txt from a non-accepting header' do\n        get '/meaning_of_life', {}, 'HTTP_ACCEPT' => 'application/json'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n    end\n    context ':json' do\n      before(:each) do\n        subject.format :json\n        subject.content_type :txt, 'text/plain'\n        subject.get '/meaning_of_life' do\n          { meaning_of_life: 42 }\n        end\n      end\n      it 'forces json without an extension' do\n        get '/meaning_of_life'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_json)\n      end\n      it 'does not force json with an extension' do\n        get '/meaning_of_life.txt'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'forces json from a non-accepting header' do\n        get '/meaning_of_life', {}, 'HTTP_ACCEPT' => 'text/html'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_json)\n      end\n      it 'can be overwritten with an explicit content type' do\n        subject.get '/meaning_of_life_with_content_type' do\n          content_type 'text/plain'\n          { meaning_of_life: 42 }.to_s\n        end\n        get '/meaning_of_life_with_content_type'\n        expect(last_response.body).to eq({ meaning_of_life: 42 }.to_s)\n      end\n      it 'raised :error from middleware' do\n        middleware = Class.new(Grape::Middleware::Base) do\n          def before\n            throw :error, message: 'Unauthorized', status: 42\n          end\n        end\n        subject.use middleware\n        subject.get do\n        end\n        get '/'\n        expect(last_response.status).to eq(42)\n        expect(last_response.body).to eq({ error: 'Unauthorized' }.to_json)\n      end\n    end\n    context ':serializable_hash' do\n      before(:each) do\n        class SerializableHashExample\n          def serializable_hash\n            { abc: 'def' }\n          end\n        end\n        subject.format :serializable_hash\n      end\n      it 'instance' do\n        subject.get '/example' do\n          SerializableHashExample.new\n        end\n        get '/example'\n        expect(last_response.body).to eq('{\"abc\":\"def\"}')\n      end\n      it 'root' do\n        subject.get '/example' do\n          { 'root' => SerializableHashExample.new }\n        end\n        get '/example'\n        expect(last_response.body).to eq('{\"root\":{\"abc\":\"def\"}}')\n      end\n      it 'array' do\n        subject.get '/examples' do\n          [SerializableHashExample.new, SerializableHashExample.new]\n        end\n        get '/examples'\n        expect(last_response.body).to eq('[{\"abc\":\"def\"},{\"abc\":\"def\"}]')\n      end\n    end\n    context ':xml' do\n      before(:each) do\n        subject.format :xml\n      end\n      it 'string' do\n        subject.get '/example' do\n          'example'\n        end\n        get '/example'\n        expect(last_response.status).to eq(500)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error>\n  <message>cannot convert String to xml</message>\n</error>\nXML\n      end\n      it 'hash' do\n        subject.get '/example' do\n          {\n            example1: 'example1',\n            example2: 'example2'\n          }\n        end\n        get '/example'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<hash>\n  <example1>example1</example1>\n  <example2>example2</example2>\n</hash>\nXML\n      end\n      it 'array' do\n        subject.get '/example' do\n          %w[example1 example2]\n        end\n        get '/example'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<strings type=\"array\">\n  <string>example1</string>\n  <string>example2</string>\n</strings>\nXML\n      end\n      it 'raised :error from middleware' do\n        middleware = Class.new(Grape::Middleware::Base) do\n          def before\n            throw :error, message: 'Unauthorized', status: 42\n          end\n        end\n        subject.use middleware\n        subject.get do\n        end\n        get '/'\n        expect(last_response.status).to eq(42)\n        expect(last_response.body).to eq <<-XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error>\n  <message>Unauthorized</message>\n</error>\nXML\n      end\n    end\n  end\n\n  context 'catch-all' do\n    before do\n      api1 = Class.new(Grape::API)\n      api1.version 'v1', using: :path\n      api1.get 'hello' do\n        'v1'\n      end\n      api2 = Class.new(Grape::API)\n      api2.version 'v2', using: :path\n      api2.get 'hello' do\n        'v2'\n      end\n      subject.mount api1\n      subject.mount api2\n    end\n    [true, false].each do |anchor|\n      it \"anchor=#{anchor}\" do\n        subject.route :any, '*path', anchor: anchor do\n          error!(\"Unrecognized request path: #{params[:path]} - #{env['PATH_INFO']}#{env['SCRIPT_NAME']}\", 404)\n        end\n        get '/v1/hello'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('v1')\n        get '/v2/hello'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq('v2')\n        options '/v2/hello'\n        expect(last_response.status).to eq(204)\n        expect(last_response.body).to be_blank\n        head '/v2/hello'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to be_blank\n        get '/foobar'\n        expect(last_response.status).to eq(404)\n        expect(last_response.body).to eq('Unrecognized request path: foobar - /foobar')\n      end\n    end\n  end\n\n  context 'cascading' do\n    context 'via version' do\n      it 'cascades' do\n        subject.version 'v1', using: :path, cascade: true\n        get '/v1/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers['X-Cascade']).to eq('pass')\n      end\n      it 'does not cascade' do\n        subject.version 'v2', using: :path, cascade: false\n        get '/v2/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers.keys).not_to include 'X-Cascade'\n      end\n    end\n    context 'via endpoint' do\n      it 'cascades' do\n        subject.cascade true\n        get '/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers['X-Cascade']).to eq('pass')\n      end\n      it 'does not cascade' do\n        subject.cascade false\n        get '/hello'\n        expect(last_response.status).to eq(404)\n        expect(last_response.headers.keys).not_to include 'X-Cascade'\n      end\n    end\n  end\n\n  context 'with json default_error_formatter' do\n    it 'returns json error' do\n      subject.content_type :json, 'application/json'\n      subject.default_error_formatter :json\n      subject.get '/something' do\n        'foo'\n      end\n      get '/something'\n      expect(last_response.status).to eq(406)\n      if ActiveSupport::VERSION::MAJOR == 3\n        expect(last_response.body).to eq('{&quot;error&quot;:&quot;The requested format &#x27;txt&#x27; is not supported.&quot;}')\n      else\n        expect(last_response.body).to eq('{&quot;error&quot;:&quot;The requested format &#39;txt&#39; is not supported.&quot;}')\n      end\n    end\n  end\n\n  context 'with unsafe HTML format specified' do\n    it 'escapes the HTML' do\n      subject.content_type :json, 'application/json'\n      subject.get '/something' do\n        'foo'\n      end\n      get '/something?format=<script>blah</script>'\n      expect(last_response.status).to eq(406)\n      if ActiveSupport::VERSION::MAJOR == 3\n        expect(last_response.body).to eq('The requested format &#x27;&lt;script&gt;blah&lt;/script&gt;&#x27; is not supported.')\n      else\n        expect(last_response.body).to eq('The requested format &#39;&lt;script&gt;blah&lt;/script&gt;&#39; is not supported.')\n      end\n    end\n  end\n\n  context 'body' do\n    context 'false' do\n      before do\n        subject.get '/blank' do\n          body false\n        end\n      end\n      it 'returns blank body' do\n        get '/blank'\n        expect(last_response.status).to eq(204)\n        expect(last_response.body).to be_blank\n      end\n    end\n    context 'plain text' do\n      before do\n        subject.get '/text' do\n          content_type 'text/plain'\n          body 'Hello World'\n          'ignored'\n        end\n      end\n      it 'returns blank body' do\n        get '/text'\n        expect(last_response.status).to eq(200)\n        expect(last_response.body).to eq 'Hello World'\n      end\n    end\n  end\nend\n", "require 'spec_helper'\n\ndescribe Grape::Middleware::Error do\n  # raises a text exception\n  module ExceptionSpec\n    class ExceptionApp\n      class << self\n        def call(_env)\n          raise 'rain!'\n        end\n      end\n    end\n\n    # raises a non-StandardError (ScriptError) exception\n    class OtherExceptionApp\n      class << self\n        def call(_env)\n          raise NotImplementedError, 'snow!'\n        end\n      end\n    end\n\n    # raises a hash error\n    class ErrorHashApp\n      class << self\n        def error!(message, status)\n          throw :error, message: { error: message, detail: 'missing widget' }, status: status\n        end\n\n        def call(_env)\n          error!('rain!', 401)\n        end\n      end\n    end\n\n    # raises an error!\n    class AccessDeniedApp\n      class << self\n        def error!(message, status)\n          throw :error, message: message, status: status\n        end\n\n        def call(_env)\n          error!('Access Denied', 401)\n        end\n      end\n    end\n\n    # raises a custom error\n    class CustomError < Grape::Exceptions::Base\n    end\n\n    class CustomErrorApp\n      class << self\n        def call(_env)\n          raise CustomError, status: 400, message: 'failed validation'\n        end\n      end\n    end\n  end\n\n  def app\n    subject\n  end\n\n  context 'with defaults' do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'does not trap errors by default' do\n      expect { get '/' }.to raise_error(RuntimeError, 'rain!')\n    end\n  end\n\n  context 'with rescue_all' do\n    context 'StandardError exception' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_all: true\n          run ExceptionSpec::ExceptionApp\n        end\n      end\n      it 'sets the message appropriately' do\n        get '/'\n        expect(last_response.body).to eq('rain!')\n      end\n      it 'defaults to a 500 status' do\n        get '/'\n        expect(last_response.status).to eq(500)\n      end\n    end\n\n    context 'Non-StandardError exception' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_all: true\n          run ExceptionSpec::OtherExceptionApp\n        end\n      end\n      it 'does not trap errors other than StandardError' do\n        expect { get '/' }.to raise_error(NotImplementedError, 'snow!')\n      end\n    end\n  end\n\n  context 'Non-StandardError exception with a provided rescue handler' do\n    context 'default error response' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_handlers: { NotImplementedError => nil }\n          run ExceptionSpec::OtherExceptionApp\n        end\n      end\n      it 'rescues the exception using the default handler' do\n        get '/'\n        expect(last_response.body).to eq('snow!')\n      end\n    end\n\n    context 'custom error response' do\n      subject do\n        Rack::Builder.app do\n          use Spec::Support::EndpointFaker\n          use Grape::Middleware::Error, rescue_handlers: { NotImplementedError => -> { [200, {}, 'rescued'] } }\n          run ExceptionSpec::OtherExceptionApp\n        end\n      end\n      it 'rescues the exception using the provided handler' do\n        get '/'\n        expect(last_response.body).to eq('rescued')\n      end\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, default_status: 500\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to specify a different default status code' do\n      get '/'\n      expect(last_response.status).to eq(500)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :json\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return errors in json format' do\n      get '/'\n      expect(last_response.body).to eq('{\"error\":\"rain!\"}')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :json\n        run ExceptionSpec::ErrorHashApp\n      end\n    end\n    it 'is possible to return hash errors in json format' do\n      get '/'\n      expect(['{\"error\":\"rain!\",\"detail\":\"missing widget\"}',\n              '{\"detail\":\"missing widget\",\"error\":\"rain!\"}']).to include(last_response.body)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :jsonapi\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return errors in jsonapi format' do\n      get '/'\n      expect(last_response.body).to eq('{&quot;error&quot;:&quot;rain!&quot;}')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :jsonapi\n        run ExceptionSpec::ErrorHashApp\n      end\n    end\n\n    it 'is possible to return hash errors in jsonapi format' do\n      get '/'\n      expect(['{&quot;error&quot;:&quot;rain!&quot;,&quot;detail&quot;:&quot;missing widget&quot;}',\n              '{&quot;detail&quot;:&quot;missing widget&quot;,&quot;error&quot;:&quot;rain!&quot;}']).to include(last_response.body)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :xml\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return errors in xml format' do\n      get '/'\n      expect(last_response.body).to eq(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<error>\\n  <message>rain!</message>\\n</error>\\n\")\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: true, format: :xml\n        run ExceptionSpec::ErrorHashApp\n      end\n    end\n    it 'is possible to return hash errors in xml format' do\n      get '/'\n      expect([\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<error>\\n  <detail>missing widget</detail>\\n  <error>rain!</error>\\n</error>\\n\",\n              \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<error>\\n  <error>rain!</error>\\n  <detail>missing widget</detail>\\n</error>\\n\"]).to include(last_response.body)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :custom,\n            error_formatters: {\n              custom: lambda do |message, _backtrace, _options, _env, _original_exception|\n                { custom_formatter: message }.inspect\n              end\n            }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to specify a custom formatter' do\n      get '/'\n      expect(last_response.body).to eq('{:custom_formatter=&gt;&quot;rain!&quot;}')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error\n        run ExceptionSpec::AccessDeniedApp\n      end\n    end\n    it 'does not trap regular error! codes' do\n      get '/'\n      expect(last_response.status).to eq(401)\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error, rescue_all: false\n        run ExceptionSpec::CustomErrorApp\n      end\n    end\n    it 'responds to custom Grape exceptions appropriately' do\n      get '/'\n      expect(last_response.status).to eq(400)\n      expect(last_response.body).to eq('failed validation')\n    end\n  end\n\n  context 'with rescue_options :backtrace and :exception set to true' do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :json,\n            rescue_options: { backtrace: true, original_exception: true }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return the backtrace and the original exception in json format' do\n      get '/'\n      expect(last_response.body).to include('error', 'rain!', 'backtrace', 'original_exception', 'RuntimeError')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :xml,\n            rescue_options: { backtrace: true, original_exception: true }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return the backtrace and the original exception in xml format' do\n      get '/'\n      expect(last_response.body).to include('error', 'rain!', 'backtrace', 'original-exception', 'RuntimeError')\n    end\n  end\n\n  context do\n    subject do\n      Rack::Builder.app do\n        use Spec::Support::EndpointFaker\n        use Grape::Middleware::Error,\n            rescue_all: true,\n            format: :txt,\n            rescue_options: { backtrace: true, original_exception: true }\n        run ExceptionSpec::ExceptionApp\n      end\n    end\n    it 'is possible to return the backtrace and the original exception in txt format' do\n      get '/'\n      expect(last_response.body).to include('error', 'rain!', 'backtrace', 'original exception', 'RuntimeError')\n    end\n  end\nend\n"], "filenames": ["CHANGELOG.md", "lib/grape/middleware/error.rb", "spec/grape/api_spec.rb", "spec/grape/middleware/exception_spec.rb"], "buggy_code_start_loc": [8, 1, 2145, 195], "buggy_code_end_loc": [8, 71, 3528, 262], "fixing_code_start_loc": [9, 2, 2145, 195], "fixing_code_end_loc": [11, 76, 3552, 262], "type": "CWE-79", "message": "ruby-grape ruby gem suffers from a cross-site scripting (XSS) vulnerability via \"format\" parameter.", "other": {"cve": {"id": "CVE-2018-3769", "sourceIdentifier": "support@hackerone.com", "published": "2018-07-05T16:29:00.733", "lastModified": "2023-02-28T17:54:27.553", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ruby-grape ruby gem suffers from a cross-site scripting (XSS) vulnerability via \"format\" parameter."}, {"lang": "es", "value": "La gema de ruby ruby-grape sufre de una vulnerabilidad de Cross-Site Scripting (XSS) mediante el par\u00e1metro \"format\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ruby-grape:grape:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.3", "matchCriteriaId": "2C377DBE-EBCB-45F8-B391-8D3118807CEC"}]}]}], "references": [{"url": "https://github.com/ruby-grape/grape/commit/6876b71efc7b03f7ce1be3f075eaa4e7e6de19af", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ruby-grape/grape/issues/1762", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ruby-grape/grape/pull/1763", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ruby-grape/grape/commit/6876b71efc7b03f7ce1be3f075eaa4e7e6de19af"}}