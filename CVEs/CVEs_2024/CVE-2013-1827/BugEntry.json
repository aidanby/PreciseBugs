{"buggy_code": ["#ifndef _CCID_H\n#define _CCID_H\n/*\n *  net/dccp/ccid.h\n *\n *  An implementation of the DCCP protocol\n *  Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n *  CCID infrastructure\n *\n *\tThis program is free software; you can redistribute it and/or modify it\n *\tunder the terms of the GNU General Public License version 2 as\n *\tpublished by the Free Software Foundation.\n */\n\n#include <net/sock.h>\n#include <linux/compiler.h>\n#include <linux/dccp.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n/* maximum value for a CCID (RFC 4340, 19.5) */\n#define CCID_MAX\t\t255\n#define CCID_SLAB_NAME_LENGTH\t32\n\nstruct tcp_info;\n\n/**\n *  struct ccid_operations  -  Interface to Congestion-Control Infrastructure\n *\n *  @ccid_id: numerical CCID ID (up to %CCID_MAX, cf. table 5 in RFC 4340, 10.)\n *  @ccid_ccmps: the CCMPS including network/transport headers (0 when disabled)\n *  @ccid_name: alphabetical identifier string for @ccid_id\n *  @ccid_hc_{r,t}x_slab: memory pool for the receiver/sender half-connection\n *  @ccid_hc_{r,t}x_obj_size: size of the receiver/sender half-connection socket\n *\n *  @ccid_hc_{r,t}x_init: CCID-specific initialisation routine (before startup)\n *  @ccid_hc_{r,t}x_exit: CCID-specific cleanup routine (before destruction)\n *  @ccid_hc_rx_packet_recv: implements the HC-receiver side\n *  @ccid_hc_{r,t}x_parse_options: parsing routine for CCID/HC-specific options\n *  @ccid_hc_{r,t}x_insert_options: insert routine for CCID/HC-specific options\n *  @ccid_hc_tx_packet_recv: implements feedback processing for the HC-sender\n *  @ccid_hc_tx_send_packet: implements the sending part of the HC-sender\n *  @ccid_hc_tx_packet_sent: does accounting for packets in flight by HC-sender\n *  @ccid_hc_{r,t}x_get_info: INET_DIAG information for HC-receiver/sender\n *  @ccid_hc_{r,t}x_getsockopt: socket options specific to HC-receiver/sender\n */\nstruct ccid_operations {\n\tunsigned char\t\tccid_id;\n\t__u32\t\t\tccid_ccmps;\n\tconst char\t\t*ccid_name;\n\tstruct kmem_cache\t*ccid_hc_rx_slab,\n\t\t\t\t*ccid_hc_tx_slab;\n\tchar\t\t\tccid_hc_rx_slab_name[CCID_SLAB_NAME_LENGTH];\n\tchar\t\t\tccid_hc_tx_slab_name[CCID_SLAB_NAME_LENGTH];\n\t__u32\t\t\tccid_hc_rx_obj_size,\n\t\t\t\tccid_hc_tx_obj_size;\n\t/* Interface Routines */\n\tint\t\t(*ccid_hc_rx_init)(struct ccid *ccid, struct sock *sk);\n\tint\t\t(*ccid_hc_tx_init)(struct ccid *ccid, struct sock *sk);\n\tvoid\t\t(*ccid_hc_rx_exit)(struct sock *sk);\n\tvoid\t\t(*ccid_hc_tx_exit)(struct sock *sk);\n\tvoid\t\t(*ccid_hc_rx_packet_recv)(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb);\n\tint\t\t(*ccid_hc_rx_parse_options)(struct sock *sk, u8 pkt,\n\t\t\t\t\t\t    u8 opt, u8 *val, u8 len);\n\tint\t\t(*ccid_hc_rx_insert_options)(struct sock *sk,\n\t\t\t\t\t\t     struct sk_buff *skb);\n\tvoid\t\t(*ccid_hc_tx_packet_recv)(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb);\n\tint\t\t(*ccid_hc_tx_parse_options)(struct sock *sk, u8 pkt,\n\t\t\t\t\t\t    u8 opt, u8 *val, u8 len);\n\tint\t\t(*ccid_hc_tx_send_packet)(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb);\n\tvoid\t\t(*ccid_hc_tx_packet_sent)(struct sock *sk,\n\t\t\t\t\t\t  unsigned int len);\n\tvoid\t\t(*ccid_hc_rx_get_info)(struct sock *sk,\n\t\t\t\t\t       struct tcp_info *info);\n\tvoid\t\t(*ccid_hc_tx_get_info)(struct sock *sk,\n\t\t\t\t\t       struct tcp_info *info);\n\tint\t\t(*ccid_hc_rx_getsockopt)(struct sock *sk,\n\t\t\t\t\t\t const int optname, int len,\n\t\t\t\t\t\t u32 __user *optval,\n\t\t\t\t\t\t int __user *optlen);\n\tint\t\t(*ccid_hc_tx_getsockopt)(struct sock *sk,\n\t\t\t\t\t\t const int optname, int len,\n\t\t\t\t\t\t u32 __user *optval,\n\t\t\t\t\t\t int __user *optlen);\n};\n\nextern struct ccid_operations ccid2_ops;\n#ifdef CONFIG_IP_DCCP_CCID3\nextern struct ccid_operations ccid3_ops;\n#endif\n\nextern int  ccid_initialize_builtins(void);\nextern void ccid_cleanup_builtins(void);\n\nstruct ccid {\n\tstruct ccid_operations *ccid_ops;\n\tchar\t\t       ccid_priv[0];\n};\n\nstatic inline void *ccid_priv(const struct ccid *ccid)\n{\n\treturn (void *)ccid->ccid_priv;\n}\n\nextern bool ccid_support_check(u8 const *ccid_array, u8 array_len);\nextern int  ccid_get_builtin_ccids(u8 **ccid_array, u8 *array_len);\nextern int  ccid_getsockopt_builtin_ccids(struct sock *sk, int len,\n\t\t\t\t\t  char __user *, int __user *);\n\nextern struct ccid *ccid_new(const u8 id, struct sock *sk, bool rx);\n\nstatic inline int ccid_get_current_rx_ccid(struct dccp_sock *dp)\n{\n\tstruct ccid *ccid = dp->dccps_hc_rx_ccid;\n\n\tif (ccid == NULL || ccid->ccid_ops == NULL)\n\t\treturn -1;\n\treturn ccid->ccid_ops->ccid_id;\n}\n\nstatic inline int ccid_get_current_tx_ccid(struct dccp_sock *dp)\n{\n\tstruct ccid *ccid = dp->dccps_hc_tx_ccid;\n\n\tif (ccid == NULL || ccid->ccid_ops == NULL)\n\t\treturn -1;\n\treturn ccid->ccid_ops->ccid_id;\n}\n\nextern void ccid_hc_rx_delete(struct ccid *ccid, struct sock *sk);\nextern void ccid_hc_tx_delete(struct ccid *ccid, struct sock *sk);\n\n/*\n * Congestion control of queued data packets via CCID decision.\n *\n * The TX CCID performs its congestion-control by indicating whether and when a\n * queued packet may be sent, using the return code of ccid_hc_tx_send_packet().\n * The following modes are supported via the symbolic constants below:\n * - timer-based pacing    (CCID returns a delay value in milliseconds);\n * - autonomous dequeueing (CCID internally schedules dccps_xmitlet).\n */\n\nenum ccid_dequeueing_decision {\n\tCCID_PACKET_SEND_AT_ONCE =\t 0x00000,  /* \"green light\": no delay */\n\tCCID_PACKET_DELAY_MAX =\t\t 0x0FFFF,  /* maximum delay in msecs  */\n\tCCID_PACKET_DELAY =\t\t 0x10000,  /* CCID msec-delay mode */\n\tCCID_PACKET_WILL_DEQUEUE_LATER = 0x20000,  /* CCID autonomous mode */\n\tCCID_PACKET_ERR =\t\t 0xF0000,  /* error condition */\n};\n\nstatic inline int ccid_packet_dequeue_eval(const int return_code)\n{\n\tif (return_code < 0)\n\t\treturn CCID_PACKET_ERR;\n\tif (return_code == 0)\n\t\treturn CCID_PACKET_SEND_AT_ONCE;\n\tif (return_code <= CCID_PACKET_DELAY_MAX)\n\t\treturn CCID_PACKET_DELAY;\n\treturn return_code;\n}\n\nstatic inline int ccid_hc_tx_send_packet(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_send_packet != NULL)\n\t\treturn ccid->ccid_ops->ccid_hc_tx_send_packet(sk, skb);\n\treturn CCID_PACKET_SEND_AT_ONCE;\n}\n\nstatic inline void ccid_hc_tx_packet_sent(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t  unsigned int len)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_packet_sent != NULL)\n\t\tccid->ccid_ops->ccid_hc_tx_packet_sent(sk, len);\n}\n\nstatic inline void ccid_hc_rx_packet_recv(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_packet_recv != NULL)\n\t\tccid->ccid_ops->ccid_hc_rx_packet_recv(sk, skb);\n}\n\nstatic inline void ccid_hc_tx_packet_recv(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_packet_recv != NULL)\n\t\tccid->ccid_ops->ccid_hc_tx_packet_recv(sk, skb);\n}\n\n/**\n * ccid_hc_tx_parse_options  -  Parse CCID-specific options sent by the receiver\n * @pkt: type of packet that @opt appears on (RFC 4340, 5.1)\n * @opt: the CCID-specific option type (RFC 4340, 5.8 and 10.3)\n * @val: value of @opt\n * @len: length of @val in bytes\n */\nstatic inline int ccid_hc_tx_parse_options(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t   u8 pkt, u8 opt, u8 *val, u8 len)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_parse_options == NULL)\n\t\treturn 0;\n\treturn ccid->ccid_ops->ccid_hc_tx_parse_options(sk, pkt, opt, val, len);\n}\n\n/**\n * ccid_hc_rx_parse_options  -  Parse CCID-specific options sent by the sender\n * Arguments are analogous to ccid_hc_tx_parse_options()\n */\nstatic inline int ccid_hc_rx_parse_options(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t   u8 pkt, u8 opt, u8 *val, u8 len)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_parse_options == NULL)\n\t\treturn 0;\n\treturn ccid->ccid_ops->ccid_hc_rx_parse_options(sk, pkt, opt, val, len);\n}\n\nstatic inline int ccid_hc_rx_insert_options(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_insert_options != NULL)\n\t\treturn ccid->ccid_ops->ccid_hc_rx_insert_options(sk, skb);\n\treturn 0;\n}\n\nstatic inline void ccid_hc_rx_get_info(struct ccid *ccid, struct sock *sk,\n\t\t\t\t       struct tcp_info *info)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_get_info != NULL)\n\t\tccid->ccid_ops->ccid_hc_rx_get_info(sk, info);\n}\n\nstatic inline void ccid_hc_tx_get_info(struct ccid *ccid, struct sock *sk,\n\t\t\t\t       struct tcp_info *info)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_get_info != NULL)\n\t\tccid->ccid_ops->ccid_hc_tx_get_info(sk, info);\n}\n\nstatic inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}\n\nstatic inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}\n#endif /* _CCID_H */\n"], "fixing_code": ["#ifndef _CCID_H\n#define _CCID_H\n/*\n *  net/dccp/ccid.h\n *\n *  An implementation of the DCCP protocol\n *  Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n *\n *  CCID infrastructure\n *\n *\tThis program is free software; you can redistribute it and/or modify it\n *\tunder the terms of the GNU General Public License version 2 as\n *\tpublished by the Free Software Foundation.\n */\n\n#include <net/sock.h>\n#include <linux/compiler.h>\n#include <linux/dccp.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n/* maximum value for a CCID (RFC 4340, 19.5) */\n#define CCID_MAX\t\t255\n#define CCID_SLAB_NAME_LENGTH\t32\n\nstruct tcp_info;\n\n/**\n *  struct ccid_operations  -  Interface to Congestion-Control Infrastructure\n *\n *  @ccid_id: numerical CCID ID (up to %CCID_MAX, cf. table 5 in RFC 4340, 10.)\n *  @ccid_ccmps: the CCMPS including network/transport headers (0 when disabled)\n *  @ccid_name: alphabetical identifier string for @ccid_id\n *  @ccid_hc_{r,t}x_slab: memory pool for the receiver/sender half-connection\n *  @ccid_hc_{r,t}x_obj_size: size of the receiver/sender half-connection socket\n *\n *  @ccid_hc_{r,t}x_init: CCID-specific initialisation routine (before startup)\n *  @ccid_hc_{r,t}x_exit: CCID-specific cleanup routine (before destruction)\n *  @ccid_hc_rx_packet_recv: implements the HC-receiver side\n *  @ccid_hc_{r,t}x_parse_options: parsing routine for CCID/HC-specific options\n *  @ccid_hc_{r,t}x_insert_options: insert routine for CCID/HC-specific options\n *  @ccid_hc_tx_packet_recv: implements feedback processing for the HC-sender\n *  @ccid_hc_tx_send_packet: implements the sending part of the HC-sender\n *  @ccid_hc_tx_packet_sent: does accounting for packets in flight by HC-sender\n *  @ccid_hc_{r,t}x_get_info: INET_DIAG information for HC-receiver/sender\n *  @ccid_hc_{r,t}x_getsockopt: socket options specific to HC-receiver/sender\n */\nstruct ccid_operations {\n\tunsigned char\t\tccid_id;\n\t__u32\t\t\tccid_ccmps;\n\tconst char\t\t*ccid_name;\n\tstruct kmem_cache\t*ccid_hc_rx_slab,\n\t\t\t\t*ccid_hc_tx_slab;\n\tchar\t\t\tccid_hc_rx_slab_name[CCID_SLAB_NAME_LENGTH];\n\tchar\t\t\tccid_hc_tx_slab_name[CCID_SLAB_NAME_LENGTH];\n\t__u32\t\t\tccid_hc_rx_obj_size,\n\t\t\t\tccid_hc_tx_obj_size;\n\t/* Interface Routines */\n\tint\t\t(*ccid_hc_rx_init)(struct ccid *ccid, struct sock *sk);\n\tint\t\t(*ccid_hc_tx_init)(struct ccid *ccid, struct sock *sk);\n\tvoid\t\t(*ccid_hc_rx_exit)(struct sock *sk);\n\tvoid\t\t(*ccid_hc_tx_exit)(struct sock *sk);\n\tvoid\t\t(*ccid_hc_rx_packet_recv)(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb);\n\tint\t\t(*ccid_hc_rx_parse_options)(struct sock *sk, u8 pkt,\n\t\t\t\t\t\t    u8 opt, u8 *val, u8 len);\n\tint\t\t(*ccid_hc_rx_insert_options)(struct sock *sk,\n\t\t\t\t\t\t     struct sk_buff *skb);\n\tvoid\t\t(*ccid_hc_tx_packet_recv)(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb);\n\tint\t\t(*ccid_hc_tx_parse_options)(struct sock *sk, u8 pkt,\n\t\t\t\t\t\t    u8 opt, u8 *val, u8 len);\n\tint\t\t(*ccid_hc_tx_send_packet)(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb);\n\tvoid\t\t(*ccid_hc_tx_packet_sent)(struct sock *sk,\n\t\t\t\t\t\t  unsigned int len);\n\tvoid\t\t(*ccid_hc_rx_get_info)(struct sock *sk,\n\t\t\t\t\t       struct tcp_info *info);\n\tvoid\t\t(*ccid_hc_tx_get_info)(struct sock *sk,\n\t\t\t\t\t       struct tcp_info *info);\n\tint\t\t(*ccid_hc_rx_getsockopt)(struct sock *sk,\n\t\t\t\t\t\t const int optname, int len,\n\t\t\t\t\t\t u32 __user *optval,\n\t\t\t\t\t\t int __user *optlen);\n\tint\t\t(*ccid_hc_tx_getsockopt)(struct sock *sk,\n\t\t\t\t\t\t const int optname, int len,\n\t\t\t\t\t\t u32 __user *optval,\n\t\t\t\t\t\t int __user *optlen);\n};\n\nextern struct ccid_operations ccid2_ops;\n#ifdef CONFIG_IP_DCCP_CCID3\nextern struct ccid_operations ccid3_ops;\n#endif\n\nextern int  ccid_initialize_builtins(void);\nextern void ccid_cleanup_builtins(void);\n\nstruct ccid {\n\tstruct ccid_operations *ccid_ops;\n\tchar\t\t       ccid_priv[0];\n};\n\nstatic inline void *ccid_priv(const struct ccid *ccid)\n{\n\treturn (void *)ccid->ccid_priv;\n}\n\nextern bool ccid_support_check(u8 const *ccid_array, u8 array_len);\nextern int  ccid_get_builtin_ccids(u8 **ccid_array, u8 *array_len);\nextern int  ccid_getsockopt_builtin_ccids(struct sock *sk, int len,\n\t\t\t\t\t  char __user *, int __user *);\n\nextern struct ccid *ccid_new(const u8 id, struct sock *sk, bool rx);\n\nstatic inline int ccid_get_current_rx_ccid(struct dccp_sock *dp)\n{\n\tstruct ccid *ccid = dp->dccps_hc_rx_ccid;\n\n\tif (ccid == NULL || ccid->ccid_ops == NULL)\n\t\treturn -1;\n\treturn ccid->ccid_ops->ccid_id;\n}\n\nstatic inline int ccid_get_current_tx_ccid(struct dccp_sock *dp)\n{\n\tstruct ccid *ccid = dp->dccps_hc_tx_ccid;\n\n\tif (ccid == NULL || ccid->ccid_ops == NULL)\n\t\treturn -1;\n\treturn ccid->ccid_ops->ccid_id;\n}\n\nextern void ccid_hc_rx_delete(struct ccid *ccid, struct sock *sk);\nextern void ccid_hc_tx_delete(struct ccid *ccid, struct sock *sk);\n\n/*\n * Congestion control of queued data packets via CCID decision.\n *\n * The TX CCID performs its congestion-control by indicating whether and when a\n * queued packet may be sent, using the return code of ccid_hc_tx_send_packet().\n * The following modes are supported via the symbolic constants below:\n * - timer-based pacing    (CCID returns a delay value in milliseconds);\n * - autonomous dequeueing (CCID internally schedules dccps_xmitlet).\n */\n\nenum ccid_dequeueing_decision {\n\tCCID_PACKET_SEND_AT_ONCE =\t 0x00000,  /* \"green light\": no delay */\n\tCCID_PACKET_DELAY_MAX =\t\t 0x0FFFF,  /* maximum delay in msecs  */\n\tCCID_PACKET_DELAY =\t\t 0x10000,  /* CCID msec-delay mode */\n\tCCID_PACKET_WILL_DEQUEUE_LATER = 0x20000,  /* CCID autonomous mode */\n\tCCID_PACKET_ERR =\t\t 0xF0000,  /* error condition */\n};\n\nstatic inline int ccid_packet_dequeue_eval(const int return_code)\n{\n\tif (return_code < 0)\n\t\treturn CCID_PACKET_ERR;\n\tif (return_code == 0)\n\t\treturn CCID_PACKET_SEND_AT_ONCE;\n\tif (return_code <= CCID_PACKET_DELAY_MAX)\n\t\treturn CCID_PACKET_DELAY;\n\treturn return_code;\n}\n\nstatic inline int ccid_hc_tx_send_packet(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_send_packet != NULL)\n\t\treturn ccid->ccid_ops->ccid_hc_tx_send_packet(sk, skb);\n\treturn CCID_PACKET_SEND_AT_ONCE;\n}\n\nstatic inline void ccid_hc_tx_packet_sent(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t  unsigned int len)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_packet_sent != NULL)\n\t\tccid->ccid_ops->ccid_hc_tx_packet_sent(sk, len);\n}\n\nstatic inline void ccid_hc_rx_packet_recv(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_packet_recv != NULL)\n\t\tccid->ccid_ops->ccid_hc_rx_packet_recv(sk, skb);\n}\n\nstatic inline void ccid_hc_tx_packet_recv(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_packet_recv != NULL)\n\t\tccid->ccid_ops->ccid_hc_tx_packet_recv(sk, skb);\n}\n\n/**\n * ccid_hc_tx_parse_options  -  Parse CCID-specific options sent by the receiver\n * @pkt: type of packet that @opt appears on (RFC 4340, 5.1)\n * @opt: the CCID-specific option type (RFC 4340, 5.8 and 10.3)\n * @val: value of @opt\n * @len: length of @val in bytes\n */\nstatic inline int ccid_hc_tx_parse_options(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t   u8 pkt, u8 opt, u8 *val, u8 len)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_parse_options == NULL)\n\t\treturn 0;\n\treturn ccid->ccid_ops->ccid_hc_tx_parse_options(sk, pkt, opt, val, len);\n}\n\n/**\n * ccid_hc_rx_parse_options  -  Parse CCID-specific options sent by the sender\n * Arguments are analogous to ccid_hc_tx_parse_options()\n */\nstatic inline int ccid_hc_rx_parse_options(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t   u8 pkt, u8 opt, u8 *val, u8 len)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_parse_options == NULL)\n\t\treturn 0;\n\treturn ccid->ccid_ops->ccid_hc_rx_parse_options(sk, pkt, opt, val, len);\n}\n\nstatic inline int ccid_hc_rx_insert_options(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_insert_options != NULL)\n\t\treturn ccid->ccid_ops->ccid_hc_rx_insert_options(sk, skb);\n\treturn 0;\n}\n\nstatic inline void ccid_hc_rx_get_info(struct ccid *ccid, struct sock *sk,\n\t\t\t\t       struct tcp_info *info)\n{\n\tif (ccid->ccid_ops->ccid_hc_rx_get_info != NULL)\n\t\tccid->ccid_ops->ccid_hc_rx_get_info(sk, info);\n}\n\nstatic inline void ccid_hc_tx_get_info(struct ccid *ccid, struct sock *sk,\n\t\t\t\t       struct tcp_info *info)\n{\n\tif (ccid->ccid_ops->ccid_hc_tx_get_info != NULL)\n\t\tccid->ccid_ops->ccid_hc_tx_get_info(sk, info);\n}\n\nstatic inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid != NULL && ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}\n\nstatic inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid != NULL && ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}\n#endif /* _CCID_H */\n"], "filenames": ["net/dccp/ccid.h"], "buggy_code_start_loc": [249], "buggy_code_end_loc": [261], "fixing_code_start_loc": [249], "fixing_code_end_loc": [261], "type": "NVD-CWE-Other", "message": "net/dccp/ccid.h in the Linux kernel before 3.5.4 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability for a certain (1) sender or (2) receiver getsockopt call.", "other": {"cve": {"id": "CVE-2013-1827", "sourceIdentifier": "secalert@redhat.com", "published": "2013-03-22T11:59:11.627", "lastModified": "2023-02-13T04:41:38.870", "vulnStatus": "Modified", "evaluatorComment": "Per: http://cwe.mitre.org/data/definitions/476.html\r\n\r\n'CWE-476: NULL Pointer Dereference'", "descriptions": [{"lang": "en", "value": "net/dccp/ccid.h in the Linux kernel before 3.5.4 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) by leveraging the CAP_NET_ADMIN capability for a certain (1) sender or (2) receiver getsockopt call."}, {"lang": "es", "value": "net/dccp/ccid.h en el kernel de Linux anterior a v3.5.4 permite a usuarios locales obtener privilegios o causar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda del sistema) mediante el aprovechamiento de la capacidad CAP_NET_ADMIN para cierto (1) remitente o (2) llamada getsockopt."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.5.3", "matchCriteriaId": "D897AD5A-6FDE-4550-AAFF-85F034746EAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=276bdb82dedb290511467a5a4fdbe9f0b52dce6f", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-0744.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.5.4", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/07/2", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=919164", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/276bdb82dedb290511467a5a4fdbe9f0b52dce6f", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/276bdb82dedb290511467a5a4fdbe9f0b52dce6f"}}