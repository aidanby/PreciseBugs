{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/io/async/AsyncSSLSocket.h>\n\n#include <folly/io/async/EventBase.h>\n#include <folly/portability/Sockets.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <chrono>\n#include <memory>\n\n#include <folly/Format.h>\n#include <folly/Indestructible.h>\n#include <folly/SocketAddress.h>\n#include <folly/SpinLock.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/IOBuf.h>\n#include <folly/io/async/ssl/BasicTransportCertificate.h>\n#include <folly/lang/Bits.h>\n#include <folly/portability/OpenSSL.h>\n\nusing folly::SocketAddress;\nusing folly::SSLContext;\nusing std::shared_ptr;\nusing std::string;\n\nusing folly::Endian;\nusing folly::IOBuf;\nusing folly::SpinLock;\nusing folly::SpinLockGuard;\nusing folly::io::Cursor;\nusing std::bind;\nusing std::unique_ptr;\n\nnamespace {\nusing folly::AsyncSocket;\nusing folly::AsyncSocketException;\nusing folly::AsyncSSLSocket;\nusing folly::Optional;\nusing folly::SSLContext;\n// For OpenSSL portability API\nusing namespace folly::ssl;\nusing folly::ssl::OpenSSLUtils;\n\n// We have one single dummy SSL context so that we can implement attach\n// and detach methods in a thread safe fashion without modifying opnessl.\nstatic SSLContext* dummyCtx = nullptr;\nstatic SpinLock dummyCtxLock;\n\n// If given min write size is less than this, buffer will be allocated on\n// stack, otherwise it is allocated on heap\nconst size_t MAX_STACK_BUF_SIZE = 2048;\n\n// This converts \"illegal\" shutdowns into ZERO_RETURN\ninline bool zero_return(int error, int rc, int errno_copy) {\n  if (error == SSL_ERROR_ZERO_RETURN || (rc == 0 && errno_copy == 0)) {\n    return true;\n  }\n#ifdef _WIN32\n  // on windows underlying TCP socket may error with this code\n  // if the sending/receiving client crashes or is killed\n  if (error == SSL_ERROR_SYSCALL && errno_copy == WSAECONNRESET) {\n    return true;\n  }\n#endif\n  return false;\n}\n\nclass AsyncSSLSocketConnector : public AsyncSocket::ConnectCallback,\n                                public AsyncSSLSocket::HandshakeCB {\n private:\n  AsyncSSLSocket* sslSocket_;\n  AsyncSSLSocket::ConnectCallback* callback_;\n  std::chrono::milliseconds timeout_;\n  std::chrono::steady_clock::time_point startTime_;\n\n protected:\n  ~AsyncSSLSocketConnector() override {}\n\n public:\n  AsyncSSLSocketConnector(\n      AsyncSSLSocket* sslSocket,\n      AsyncSocket::ConnectCallback* callback,\n      std::chrono::milliseconds timeout)\n      : sslSocket_(sslSocket),\n        callback_(callback),\n        timeout_(timeout),\n        startTime_(std::chrono::steady_clock::now()) {}\n\n  void preConnect(folly::NetworkSocket fd) override {\n    VLOG(7) << \"client preConnect hook is invoked\";\n    if (callback_) {\n      callback_->preConnect(fd);\n    }\n  }\n\n  void connectSuccess() noexcept override {\n    VLOG(7) << \"client socket connected\";\n\n    std::chrono::milliseconds timeoutLeft{0};\n    if (timeout_ > std::chrono::milliseconds::zero()) {\n      auto curTime = std::chrono::steady_clock::now();\n\n      timeoutLeft = std::chrono::duration_cast<std::chrono::milliseconds>(\n          timeout_ - (curTime - startTime_));\n      if (timeoutLeft <= std::chrono::milliseconds::zero()) {\n        AsyncSocketException ex(\n            AsyncSocketException::TIMED_OUT,\n            folly::sformat(\n                \"SSL connect timed out after {}ms\", timeout_.count()));\n        fail(ex);\n        delete this;\n        return;\n      }\n    }\n    sslSocket_->sslConn(this, timeoutLeft);\n  }\n\n  void connectErr(const AsyncSocketException& ex) noexcept override {\n    VLOG(1) << \"TCP connect failed: \" << ex.what();\n    fail(ex);\n    delete this;\n  }\n\n  void handshakeSuc(AsyncSSLSocket* /* sock */) noexcept override {\n    VLOG(7) << \"client handshake success\";\n    if (callback_) {\n      callback_->connectSuccess();\n    }\n    delete this;\n  }\n\n  void handshakeErr(\n      AsyncSSLSocket* /* socket */,\n      const AsyncSocketException& ex) noexcept override {\n    VLOG(1) << \"client handshakeErr: \" << ex.what();\n    fail(ex);\n    delete this;\n  }\n\n  void fail(const AsyncSocketException& ex) {\n    // fail is a noop if called twice\n    if (callback_) {\n      AsyncSSLSocket::ConnectCallback* cb = callback_;\n      callback_ = nullptr;\n\n      cb->connectErr(ex);\n      sslSocket_->closeNow();\n      // closeNow can call handshakeErr if it hasn't been called already.\n      // So this may have been deleted, no member variable access beyond this\n      // point\n      // Note that closeNow may invoke writeError callbacks if the socket had\n      // write data pending connection completion.\n    }\n  }\n};\n\nvoid setup_SSL_CTX(SSL_CTX* ctx) {\n#ifdef SSL_MODE_RELEASE_BUFFERS\n  SSL_CTX_set_mode(\n      ctx,\n      SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_ENABLE_PARTIAL_WRITE |\n          SSL_MODE_RELEASE_BUFFERS);\n#else\n  SSL_CTX_set_mode(\n      ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_ENABLE_PARTIAL_WRITE);\n#endif\n// SSL_CTX_set_mode is a Macro\n#ifdef SSL_MODE_WRITE_IOVEC\n  SSL_CTX_set_mode(ctx, SSL_CTX_get_mode(ctx) | SSL_MODE_WRITE_IOVEC);\n#endif\n}\n\n// Note: This is a Leaky Meyer's Singleton. The reason we can't use a non-leaky\n// thing is because we will be setting this BIO_METHOD* inside BIOs owned by\n// various SSL objects which may get callbacks even during teardown. We may\n// eventually try to fix this\nstatic BIO_METHOD* getSSLBioMethod() {\n  static auto const instance = OpenSSLUtils::newSocketBioMethod().release();\n  return instance;\n}\n\nvoid* initsslBioMethod() {\n  auto sslBioMethod = getSSLBioMethod();\n  // override the bwrite method for MSG_EOR support\n  OpenSSLUtils::setCustomBioWriteMethod(sslBioMethod, AsyncSSLSocket::bioWrite);\n  OpenSSLUtils::setCustomBioReadMethod(sslBioMethod, AsyncSSLSocket::bioRead);\n\n  // Note that the sslBioMethod.type and sslBioMethod.name are not\n  // set here. openssl code seems to be checking \".type == BIO_TYPE_SOCKET\" and\n  // then have specific handlings. The sslWriteBioWrite should be compatible\n  // with the one in openssl.\n\n  // Return something here to enable AsyncSSLSocket to call this method using\n  // a function-scoped static.\n  return nullptr;\n}\n\n} // namespace\n\nnamespace folly {\n\n/**\n * Create a client AsyncSSLSocket\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    bool deferSecurityNegotiation)\n    : AsyncSocket(evb),\n      ctx_(ctx),\n      handshakeTimeout_(this, evb),\n      connectionTimeout_(this, evb) {\n  init();\n  if (deferSecurityNegotiation) {\n    sslState_ = STATE_UNENCRYPTED;\n  }\n}\n\n/**\n * Create a server/client AsyncSSLSocket\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    NetworkSocket fd,\n    bool server,\n    bool deferSecurityNegotiation)\n    : AsyncSocket(evb, fd),\n      server_(server),\n      ctx_(ctx),\n      handshakeTimeout_(this, evb),\n      connectionTimeout_(this, evb) {\n  noTransparentTls_ = true;\n  init();\n  if (server) {\n    SSL_CTX_set_info_callback(\n        ctx_->getSSLCtx(), AsyncSSLSocket::sslInfoCallback);\n  }\n  if (deferSecurityNegotiation) {\n    sslState_ = STATE_UNENCRYPTED;\n  }\n}\n\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    AsyncSocket::UniquePtr oldAsyncSocket,\n    bool server,\n    bool deferSecurityNegotiation)\n    : AsyncSocket(std::move(oldAsyncSocket)),\n      server_(server),\n      ctx_(ctx),\n      handshakeTimeout_(this, AsyncSocket::getEventBase()),\n      connectionTimeout_(this, AsyncSocket::getEventBase()) {\n  noTransparentTls_ = true;\n  init();\n  if (server) {\n    SSL_CTX_set_info_callback(\n        ctx_->getSSLCtx(), AsyncSSLSocket::sslInfoCallback);\n  }\n  if (deferSecurityNegotiation) {\n    sslState_ = STATE_UNENCRYPTED;\n  }\n}\n\n#if FOLLY_OPENSSL_HAS_SNI\n/**\n * Create a client AsyncSSLSocket and allow tlsext_hostname\n * to be sent in Client Hello.\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    const std::string& serverName,\n    bool deferSecurityNegotiation)\n    : AsyncSSLSocket(ctx, evb, deferSecurityNegotiation) {\n  tlsextHostname_ = serverName;\n}\n\n/**\n * Create a client AsyncSSLSocket from an already connected fd\n * and allow tlsext_hostname to be sent in Client Hello.\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    NetworkSocket fd,\n    const std::string& serverName,\n    bool deferSecurityNegotiation)\n    : AsyncSSLSocket(ctx, evb, fd, false, deferSecurityNegotiation) {\n  tlsextHostname_ = serverName;\n}\n#endif // FOLLY_OPENSSL_HAS_SNI\n\nAsyncSSLSocket::~AsyncSSLSocket() {\n  VLOG(3) << \"actual destruction of AsyncSSLSocket(this=\" << this\n          << \", evb=\" << eventBase_ << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", sslState=\" << sslState_\n          << \", events=\" << eventFlags_ << \")\";\n}\n\nvoid AsyncSSLSocket::init() {\n  // Do this here to ensure we initialize this once before any use of\n  // AsyncSSLSocket instances and not as part of library load.\n  static const auto sslBioMethodInitializer = initsslBioMethod();\n  (void)sslBioMethodInitializer;\n\n  setup_SSL_CTX(ctx_->getSSLCtx());\n}\n\nvoid AsyncSSLSocket::closeNow() {\n  // Close the SSL connection.\n  if (ssl_ != nullptr && fd_ != NetworkSocket() && !waitingOnAccept_) {\n    int rc = SSL_shutdown(ssl_.get());\n    if (rc == 0) {\n      rc = SSL_shutdown(ssl_.get());\n    }\n    if (rc < 0) {\n      ERR_clear_error();\n    }\n  }\n\n  if (sslSession_ != nullptr) {\n    SSL_SESSION_free(sslSession_);\n    sslSession_ = nullptr;\n  }\n\n  sslState_ = STATE_CLOSED;\n\n  if (handshakeTimeout_.isScheduled()) {\n    handshakeTimeout_.cancelTimeout();\n  }\n\n  DestructorGuard dg(this);\n\n  static const Indestructible<AsyncSocketException> ex(\n      AsyncSocketException::END_OF_FILE, \"SSL connection closed locally\");\n  invokeHandshakeErr(*ex);\n\n  // Close the socket.\n  AsyncSocket::closeNow();\n}\n\nvoid AsyncSSLSocket::shutdownWrite() {\n  // SSL sockets do not support half-shutdown, so just perform a full shutdown.\n  //\n  // (Performing a full shutdown here is more desirable than doing nothing at\n  // all.  The purpose of shutdownWrite() is normally to notify the other end\n  // of the connection that no more data will be sent.  If we do nothing, the\n  // other end will never know that no more data is coming, and this may result\n  // in protocol deadlock.)\n  close();\n}\n\nvoid AsyncSSLSocket::shutdownWriteNow() {\n  closeNow();\n}\n\nbool AsyncSSLSocket::good() const {\n  return (\n      AsyncSocket::good() &&\n      (sslState_ == STATE_ACCEPTING || sslState_ == STATE_CONNECTING ||\n       sslState_ == STATE_ESTABLISHED || sslState_ == STATE_UNENCRYPTED ||\n       sslState_ == STATE_UNINIT));\n}\n\n// The TAsyncTransport definition of 'good' states that the transport is\n// ready to perform reads and writes, so sslState_ == UNINIT must report !good.\n// connecting can be true when the sslState_ == UNINIT because the AsyncSocket\n// is connected but we haven't initiated the call to SSL_connect.\nbool AsyncSSLSocket::connecting() const {\n  return (\n      !server_ &&\n      (AsyncSocket::connecting() ||\n       (AsyncSocket::good() &&\n        (sslState_ == STATE_UNINIT || sslState_ == STATE_CONNECTING))));\n}\n\nstd::string AsyncSSLSocket::getApplicationProtocol() const noexcept {\n  const unsigned char* protoName = nullptr;\n  unsigned protoLength;\n  if (getSelectedNextProtocolNoThrow(&protoName, &protoLength)) {\n    return std::string(reinterpret_cast<const char*>(protoName), protoLength);\n  }\n  return \"\";\n}\n\nvoid AsyncSSLSocket::setEorTracking(bool track) {\n  if (isEorTrackingEnabled() != track) {\n    AsyncSocket::setEorTracking(track);\n    appEorByteNo_ = 0;\n    appEorByteWriteFlags_ = {};\n    minEorRawByteNo_ = 0;\n  }\n}\n\nsize_t AsyncSSLSocket::getRawBytesWritten() const {\n  // The bio(s) in the write path are in a chain\n  // each bio flushes to the next and finally written into the socket\n  // to get the rawBytesWritten on the socket,\n  // get the write bytes of the last bio\n  BIO* b;\n  if (!ssl_ || !(b = SSL_get_wbio(ssl_.get()))) {\n    return 0;\n  }\n  BIO* next = BIO_next(b);\n  while (next != nullptr) {\n    b = next;\n    next = BIO_next(b);\n  }\n\n  return BIO_number_written(b);\n}\n\nsize_t AsyncSSLSocket::getRawBytesReceived() const {\n  BIO* b;\n  if (!ssl_ || !(b = SSL_get_rbio(ssl_.get()))) {\n    return 0;\n  }\n\n  return BIO_number_read(b);\n}\n\nvoid AsyncSSLSocket::invalidState(HandshakeCB* callback) {\n  LOG(ERROR) << \"AsyncSSLSocket(this=\" << this << \", fd=\" << fd_\n             << \", state=\" << int(state_) << \", sslState=\" << sslState_ << \", \"\n             << \"events=\" << eventFlags_ << \", server=\" << short(server_)\n             << \"): \"\n             << \"sslAccept/Connect() called in invalid \"\n             << \"state, handshake callback \" << handshakeCallback_\n             << \", new callback \" << callback;\n  assert(!handshakeTimeout_.isScheduled());\n  sslState_ = STATE_ERROR;\n\n  static const Indestructible<AsyncSocketException> ex(\n      AsyncSocketException::INVALID_STATE,\n      \"sslAccept() called with socket in invalid state\");\n\n  handshakeEndTime_ = std::chrono::steady_clock::now();\n  if (callback) {\n    callback->handshakeErr(this, *ex);\n  }\n\n  failHandshake(__func__, *ex);\n}\n\nvoid AsyncSSLSocket::sslAccept(\n    HandshakeCB* callback,\n    std::chrono::milliseconds timeout,\n    const SSLContext::SSLVerifyPeerEnum& verifyPeer) {\n  DestructorGuard dg(this);\n  eventBase_->dcheckIsInEventBaseThread();\n  verifyPeer_ = verifyPeer;\n\n  // Make sure we're in the uninitialized state\n  if (!server_ ||\n      (sslState_ != STATE_UNINIT && sslState_ != STATE_UNENCRYPTED) ||\n      handshakeCallback_ != nullptr) {\n    return invalidState(callback);\n  }\n\n  // Cache local and remote socket addresses to keep them available\n  // after socket file descriptor is closed.\n  if (cacheAddrOnFailure_) {\n    cacheAddresses();\n  }\n\n  handshakeStartTime_ = std::chrono::steady_clock::now();\n  // Make end time at least >= start time.\n  handshakeEndTime_ = handshakeStartTime_;\n\n  sslState_ = STATE_ACCEPTING;\n  handshakeCallback_ = callback;\n\n  if (timeout > std::chrono::milliseconds::zero()) {\n    handshakeTimeout_.scheduleTimeout(timeout);\n  }\n\n  /* register for a read operation (waiting for CLIENT HELLO) */\n  updateEventRegistration(EventHandler::READ, EventHandler::WRITE);\n\n  checkForImmediateRead();\n}\n\nvoid AsyncSSLSocket::attachSSLContext(const std::shared_ptr<SSLContext>& ctx) {\n  // Check to ensure we are in client mode. Changing a server's ssl\n  // context doesn't make sense since clients of that server would likely\n  // become confused when the server's context changes.\n  DCHECK(!server_);\n  DCHECK(!ctx_);\n  DCHECK(ctx);\n  DCHECK(ctx->getSSLCtx());\n  ctx_ = ctx;\n\n  // It's possible this could be attached before ssl_ is set up\n  if (!ssl_) {\n    return;\n  }\n\n  // In order to call attachSSLContext, detachSSLContext must have been\n  // previously called.\n  // We need to update the initial_ctx if necessary\n  // The 'initial_ctx' inside an SSL* points to the context that it was created\n  // with, which is also where session callbacks and servername callbacks\n  // happen.\n  // When we switch to a different SSL_CTX, we want to update the initial_ctx as\n  // well so that any callbacks don't go to a different object\n  // NOTE: this will only work if we have access to ssl_ internals, so it may\n  // not work on\n  // OpenSSL version >= 1.1.0\n  auto sslCtx = ctx->getSSLCtx();\n  OpenSSLUtils::setSSLInitialCtx(ssl_.get(), sslCtx);\n  // Detach sets the socket's context to the dummy context. Thus we must acquire\n  // this lock.\n  SpinLockGuard guard(dummyCtxLock);\n  SSL_set_SSL_CTX(ssl_.get(), sslCtx);\n}\n\nvoid AsyncSSLSocket::detachSSLContext() {\n  DCHECK(ctx_);\n  ctx_.reset();\n  // It's possible for this to be called before ssl_ has been\n  // set up\n  if (!ssl_) {\n    return;\n  }\n  // The 'initial_ctx' inside an SSL* points to the context that it was created\n  // with, which is also where session callbacks and servername callbacks\n  // happen.\n  // Detach the initial_ctx as well.  It will be reattached in attachSSLContext\n  // it is used for session info.\n  // NOTE: this will only work if we have access to ssl_ internals, so it may\n  // not work on\n  // OpenSSL version >= 1.1.0\n  SSL_CTX* initialCtx = OpenSSLUtils::getSSLInitialCtx(ssl_.get());\n  if (initialCtx) {\n    SSL_CTX_free(initialCtx);\n    OpenSSLUtils::setSSLInitialCtx(ssl_.get(), nullptr);\n  }\n\n  SpinLockGuard guard(dummyCtxLock);\n  if (nullptr == dummyCtx) {\n    // We need to lazily initialize the dummy context so we don't\n    // accidentally override any programmatic settings to openssl\n    dummyCtx = new SSLContext;\n  }\n  // We must remove this socket's references to its context right now\n  // since this socket could get passed to any thread. If the context has\n  // had its locking disabled, just doing a set in attachSSLContext()\n  // would not be thread safe.\n  SSL_set_SSL_CTX(ssl_.get(), dummyCtx->getSSLCtx());\n}\n\n#if FOLLY_OPENSSL_HAS_SNI\nvoid AsyncSSLSocket::switchServerSSLContext(\n    const std::shared_ptr<SSLContext>& handshakeCtx) {\n  CHECK(server_);\n  if (sslState_ != STATE_ACCEPTING) {\n    // We log it here and allow the switch.\n    // It should not affect our re-negotiation support (which\n    // is not supported now).\n    VLOG(6) << \"fd=\" << getNetworkSocket()\n            << \" renegotation detected when switching SSL_CTX\";\n  }\n\n  setup_SSL_CTX(handshakeCtx->getSSLCtx());\n  SSL_CTX_set_info_callback(\n      handshakeCtx->getSSLCtx(), AsyncSSLSocket::sslInfoCallback);\n  handshakeCtx_ = handshakeCtx;\n  SSL_set_SSL_CTX(ssl_.get(), handshakeCtx->getSSLCtx());\n}\n\nbool AsyncSSLSocket::isServerNameMatch() const {\n  CHECK(!server_);\n\n  if (!ssl_) {\n    return false;\n  }\n\n  SSL_SESSION* ss = SSL_get_session(ssl_.get());\n  if (!ss) {\n    return false;\n  }\n\n  auto tlsextHostname = SSL_SESSION_get0_hostname(ss);\n  return (tlsextHostname && !tlsextHostname_.compare(tlsextHostname));\n}\n\nvoid AsyncSSLSocket::setServerName(std::string serverName) noexcept {\n  tlsextHostname_ = std::move(serverName);\n}\n\n#endif // FOLLY_OPENSSL_HAS_SNI\n\nvoid AsyncSSLSocket::timeoutExpired(\n    std::chrono::milliseconds timeout) noexcept {\n  if (state_ == StateEnum::ESTABLISHED && sslState_ == STATE_ASYNC_PENDING) {\n    sslState_ = STATE_ERROR;\n    // We are expecting a callback in restartSSLAccept.  The cache lookup\n    // and rsa-call necessarily have pointers to this ssl socket, so delay\n    // the cleanup until he calls us back.\n  } else if (state_ == StateEnum::CONNECTING) {\n    assert(sslState_ == STATE_CONNECTING);\n    DestructorGuard dg(this);\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::TIMED_OUT,\n        \"Fallback connect timed out during TFO\");\n    failHandshake(__func__, *ex);\n  } else {\n    assert(\n        state_ == StateEnum::ESTABLISHED &&\n        (sslState_ == STATE_CONNECTING || sslState_ == STATE_ACCEPTING));\n    DestructorGuard dg(this);\n    AsyncSocketException ex(\n        AsyncSocketException::TIMED_OUT,\n        folly::sformat(\n            \"SSL {} timed out after {}ms\",\n            (sslState_ == STATE_CONNECTING) ? \"connect\" : \"accept\",\n            timeout.count()));\n    failHandshake(__func__, ex);\n  }\n}\n\nint AsyncSSLSocket::getSSLExDataIndex() {\n  static auto index = SSL_get_ex_new_index(\n      0, (void*)\"AsyncSSLSocket data index\", nullptr, nullptr, nullptr);\n  return index;\n}\n\nAsyncSSLSocket* AsyncSSLSocket::getFromSSL(const SSL* ssl) {\n  return static_cast<AsyncSSLSocket*>(\n      SSL_get_ex_data(ssl, getSSLExDataIndex()));\n}\n\nvoid AsyncSSLSocket::failHandshake(\n    const char* /* fn */,\n    const AsyncSocketException& ex) {\n  startFail();\n  if (handshakeTimeout_.isScheduled()) {\n    handshakeTimeout_.cancelTimeout();\n  }\n  invokeHandshakeErr(ex);\n  finishFail();\n}\n\nvoid AsyncSSLSocket::invokeHandshakeErr(const AsyncSocketException& ex) {\n  handshakeEndTime_ = std::chrono::steady_clock::now();\n  if (handshakeCallback_ != nullptr) {\n    HandshakeCB* callback = handshakeCallback_;\n    handshakeCallback_ = nullptr;\n    callback->handshakeErr(this, ex);\n  }\n}\n\nvoid AsyncSSLSocket::invokeHandshakeCB() {\n  handshakeEndTime_ = std::chrono::steady_clock::now();\n  if (handshakeTimeout_.isScheduled()) {\n    handshakeTimeout_.cancelTimeout();\n  }\n  if (handshakeCallback_) {\n    HandshakeCB* callback = handshakeCallback_;\n    handshakeCallback_ = nullptr;\n    callback->handshakeSuc(this);\n  }\n}\n\nvoid AsyncSSLSocket::connect(\n    ConnectCallback* callback,\n    const folly::SocketAddress& address,\n    int timeout,\n    const OptionMap& options,\n    const folly::SocketAddress& bindAddr) noexcept {\n  auto timeoutChrono = std::chrono::milliseconds(timeout);\n  connect(callback, address, timeoutChrono, timeoutChrono, options, bindAddr);\n}\n\nvoid AsyncSSLSocket::connect(\n    ConnectCallback* callback,\n    const folly::SocketAddress& address,\n    std::chrono::milliseconds connectTimeout,\n    std::chrono::milliseconds totalConnectTimeout,\n    const OptionMap& options,\n    const folly::SocketAddress& bindAddr) noexcept {\n  assert(!server_);\n  assert(state_ == StateEnum::UNINIT);\n  assert(sslState_ == STATE_UNINIT || sslState_ == STATE_UNENCRYPTED);\n  noTransparentTls_ = true;\n  totalConnectTimeout_ = totalConnectTimeout;\n  if (sslState_ != STATE_UNENCRYPTED) {\n    callback = new AsyncSSLSocketConnector(this, callback, totalConnectTimeout);\n  }\n  AsyncSocket::connect(\n      callback, address, int(connectTimeout.count()), options, bindAddr);\n}\n\nbool AsyncSSLSocket::needsPeerVerification() const {\n  if (verifyPeer_ == SSLContext::SSLVerifyPeerEnum::USE_CTX) {\n    return ctx_->needsPeerVerification();\n  }\n  return (\n      verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY ||\n      verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n}\n\nvoid AsyncSSLSocket::applyVerificationOptions(const ssl::SSLUniquePtr& ssl) {\n  // apply the settings specified in verifyPeer_\n  if (verifyPeer_ == SSLContext::SSLVerifyPeerEnum::USE_CTX) {\n    if (ctx_->needsPeerVerification()) {\n      SSL_set_verify(\n          ssl.get(),\n          ctx_->getVerificationMode(),\n          AsyncSSLSocket::sslVerifyCallback);\n    }\n  } else {\n    if (verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY ||\n        verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT) {\n      SSL_set_verify(\n          ssl.get(),\n          SSLContext::getVerificationMode(verifyPeer_),\n          AsyncSSLSocket::sslVerifyCallback);\n    }\n  }\n}\n\nbool AsyncSSLSocket::setupSSLBio() {\n  auto sslBio = BIO_new(getSSLBioMethod());\n\n  if (!sslBio) {\n    return false;\n  }\n\n  OpenSSLUtils::setBioAppData(sslBio, this);\n  OpenSSLUtils::setBioFd(sslBio, fd_, BIO_NOCLOSE);\n  SSL_set_bio(ssl_.get(), sslBio, sslBio);\n  return true;\n}\n\nvoid AsyncSSLSocket::sslConn(\n    HandshakeCB* callback,\n    std::chrono::milliseconds timeout,\n    const SSLContext::SSLVerifyPeerEnum& verifyPeer) {\n  DestructorGuard dg(this);\n  eventBase_->dcheckIsInEventBaseThread();\n\n  // Cache local and remote socket addresses to keep them available\n  // after socket file descriptor is closed.\n  if (cacheAddrOnFailure_) {\n    cacheAddresses();\n  }\n\n  verifyPeer_ = verifyPeer;\n\n  // Make sure we're in the uninitialized state\n  if (server_ ||\n      (sslState_ != STATE_UNINIT && sslState_ != STATE_UNENCRYPTED) ||\n      handshakeCallback_ != nullptr) {\n    return invalidState(callback);\n  }\n\n  sslState_ = STATE_CONNECTING;\n  handshakeCallback_ = callback;\n\n  try {\n    ssl_.reset(ctx_->createSSL());\n  } catch (std::exception& e) {\n    sslState_ = STATE_ERROR;\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::INTERNAL_ERROR,\n        \"error calling SSLContext::createSSL()\");\n    LOG(ERROR) << \"AsyncSSLSocket::sslConn(this=\" << this << \", fd=\" << fd_\n               << \"): \" << e.what();\n    return failHandshake(__func__, *ex);\n  }\n\n  if (!setupSSLBio()) {\n    sslState_ = STATE_ERROR;\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::INTERNAL_ERROR, \"error creating SSL bio\");\n    return failHandshake(__func__, *ex);\n  }\n\n  applyVerificationOptions(ssl_);\n\n  if (sslSession_ != nullptr) {\n    sessionResumptionAttempted_ = true;\n    SSL_set_session(ssl_.get(), sslSession_);\n    SSL_SESSION_free(sslSession_);\n    sslSession_ = nullptr;\n  }\n#if FOLLY_OPENSSL_HAS_SNI\n  if (tlsextHostname_.size()) {\n    SSL_set_tlsext_host_name(ssl_.get(), tlsextHostname_.c_str());\n  }\n#endif\n\n  SSL_set_ex_data(ssl_.get(), getSSLExDataIndex(), this);\n\n  handshakeConnectTimeout_ = timeout;\n  startSSLConnect();\n}\n\n// This could be called multiple times, during normal ssl connections\n// and after TFO fallback.\nvoid AsyncSSLSocket::startSSLConnect() {\n  handshakeStartTime_ = std::chrono::steady_clock::now();\n  // Make end time at least >= start time.\n  handshakeEndTime_ = handshakeStartTime_;\n  if (handshakeConnectTimeout_ > std::chrono::milliseconds::zero()) {\n    handshakeTimeout_.scheduleTimeout(handshakeConnectTimeout_);\n  }\n  handleConnect();\n}\n\nSSL_SESSION* AsyncSSLSocket::getSSLSession() {\n  if (ssl_ != nullptr && sslState_ == STATE_ESTABLISHED) {\n    return SSL_get1_session(ssl_.get());\n  }\n\n  return sslSession_;\n}\n\nconst SSL* AsyncSSLSocket::getSSL() const {\n  return ssl_.get();\n}\n\nvoid AsyncSSLSocket::setSSLSession(SSL_SESSION* session, bool takeOwnership) {\n  if (sslSession_) {\n    SSL_SESSION_free(sslSession_);\n  }\n  sslSession_ = session;\n  if (!takeOwnership && session != nullptr) {\n    // Increment the reference count\n    // This API exists in BoringSSL and OpenSSL 1.1.0\n    SSL_SESSION_up_ref(session);\n  }\n}\n\nvoid AsyncSSLSocket::getSelectedNextProtocol(\n    const unsigned char** protoName,\n    unsigned* protoLen) const {\n  if (!getSelectedNextProtocolNoThrow(protoName, protoLen)) {\n    throw AsyncSocketException(\n        AsyncSocketException::NOT_SUPPORTED, \"ALPN not supported\");\n  }\n}\n\nbool AsyncSSLSocket::getSelectedNextProtocolNoThrow(\n    const unsigned char** protoName,\n    unsigned* protoLen) const {\n  *protoName = nullptr;\n  *protoLen = 0;\n#if FOLLY_OPENSSL_HAS_ALPN\n  SSL_get0_alpn_selected(ssl_.get(), protoName, protoLen);\n  return true;\n#else\n  return false;\n#endif\n}\n\nbool AsyncSSLSocket::getSSLSessionReused() const {\n  if (ssl_ != nullptr && sslState_ == STATE_ESTABLISHED) {\n    return SSL_session_reused(ssl_.get());\n  }\n  return false;\n}\n\nconst char* AsyncSSLSocket::getNegotiatedCipherName() const {\n  return (ssl_ != nullptr) ? SSL_get_cipher_name(ssl_.get()) : nullptr;\n}\n\n/* static */\nconst char* AsyncSSLSocket::getSSLServerNameFromSSL(SSL* ssl) {\n  if (ssl == nullptr) {\n    return nullptr;\n  }\n#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n#else\n  return nullptr;\n#endif\n}\n\nconst char* AsyncSSLSocket::getSSLServerName() const {\n  if (clientHelloInfo_ && !clientHelloInfo_->clientHelloSNIHostname_.empty()) {\n    return clientHelloInfo_->clientHelloSNIHostname_.c_str();\n  }\n#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n  return getSSLServerNameFromSSL(ssl_.get());\n#else\n  throw AsyncSocketException(\n      AsyncSocketException::NOT_SUPPORTED, \"SNI not supported\");\n#endif\n}\n\nconst char* AsyncSSLSocket::getSSLServerNameNoThrow() const {\n  if (clientHelloInfo_ && !clientHelloInfo_->clientHelloSNIHostname_.empty()) {\n    return clientHelloInfo_->clientHelloSNIHostname_.c_str();\n  }\n  return getSSLServerNameFromSSL(ssl_.get());\n}\n\nint AsyncSSLSocket::getSSLVersion() const {\n  return (ssl_ != nullptr) ? SSL_version(ssl_.get()) : 0;\n}\n\nconst char* AsyncSSLSocket::getSSLCertSigAlgName() const {\n  X509* cert = (ssl_ != nullptr) ? SSL_get_certificate(ssl_.get()) : nullptr;\n  if (cert) {\n    int nid = X509_get_signature_nid(cert);\n    return OBJ_nid2ln(nid);\n  }\n  return nullptr;\n}\n\nint AsyncSSLSocket::getSSLCertSize() const {\n  int certSize = 0;\n  X509* cert = (ssl_ != nullptr) ? SSL_get_certificate(ssl_.get()) : nullptr;\n  if (cert) {\n    EVP_PKEY* key = X509_get_pubkey(cert);\n    certSize = EVP_PKEY_bits(key);\n    EVP_PKEY_free(key);\n  }\n  return certSize;\n}\n\nconst AsyncTransportCertificate* AsyncSSLSocket::getPeerCertificate() const {\n  if (peerCertData_) {\n    return peerCertData_.get();\n  }\n  if (ssl_ != nullptr) {\n    auto peerX509 = SSL_get_peer_certificate(ssl_.get());\n    if (peerX509) {\n      // already up ref'd\n      folly::ssl::X509UniquePtr peer(peerX509);\n      auto cn = OpenSSLUtils::getCommonName(peerX509);\n      peerCertData_ = std::make_unique<BasicTransportCertificate>(\n          std::move(cn), std::move(peer));\n    }\n  }\n  return peerCertData_.get();\n}\n\nconst AsyncTransportCertificate* AsyncSSLSocket::getSelfCertificate() const {\n  if (selfCertData_) {\n    return selfCertData_.get();\n  }\n  if (ssl_ != nullptr) {\n    auto selfX509 = SSL_get_certificate(ssl_.get());\n    if (selfX509) {\n      // need to upref\n      X509_up_ref(selfX509);\n      folly::ssl::X509UniquePtr peer(selfX509);\n      auto cn = OpenSSLUtils::getCommonName(selfX509);\n      selfCertData_ = std::make_unique<BasicTransportCertificate>(\n          std::move(cn), std::move(peer));\n    }\n  }\n  return selfCertData_.get();\n}\n\nbool AsyncSSLSocket::willBlock(\n    int ret,\n    int* sslErrorOut,\n    unsigned long* errErrorOut) noexcept {\n  *errErrorOut = 0;\n  int error = *sslErrorOut = SSL_get_error(ssl_.get(), ret);\n  if (error == SSL_ERROR_WANT_READ) {\n    // Register for read event if not already.\n    updateEventRegistration(EventHandler::READ, EventHandler::WRITE);\n    return true;\n  } else if (error == SSL_ERROR_WANT_WRITE) {\n    VLOG(3) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL_ERROR_WANT_WRITE\";\n    // Register for write event if not already.\n    updateEventRegistration(EventHandler::WRITE, EventHandler::READ);\n    return true;\n  } else if ((false\n#ifdef SSL_ERROR_WANT_ASYNC // OpenSSL 1.1.0 Async API\n              || error == SSL_ERROR_WANT_ASYNC\n#endif\n              )) {\n    // An asynchronous request has been kicked off. On completion, it will\n    // invoke a callback to re-call handleAccept\n    sslState_ = STATE_ASYNC_PENDING;\n\n    // Unregister for all events while blocked here\n    updateEventRegistration(\n        EventHandler::NONE, EventHandler::READ | EventHandler::WRITE);\n\n#ifdef SSL_ERROR_WANT_ASYNC\n    if (error == SSL_ERROR_WANT_ASYNC) {\n      size_t numfds;\n      if (SSL_get_all_async_fds(ssl_.get(), NULL, &numfds) <= 0) {\n        VLOG(4) << \"SSL_ERROR_WANT_ASYNC but no async FDs set!\";\n        return false;\n      }\n      if (numfds != 1) {\n        VLOG(4) << \"SSL_ERROR_WANT_ASYNC expected exactly 1 async fd, got \"\n                << numfds;\n        return false;\n      }\n      OSSL_ASYNC_FD ofd; // This should just be an int in POSIX\n      if (SSL_get_all_async_fds(ssl_.get(), &ofd, &numfds) <= 0) {\n        VLOG(4) << \"SSL_ERROR_WANT_ASYNC cant get async fd\";\n        return false;\n      }\n\n      // On POSIX systems, OSSL_ASYNC_FD is type int, but on win32\n      // it has type HANDLE.\n      // Our NetworkSocket::native_handle_type is type SOCKET on\n      // win32, which means that we need to explicitly construct\n      // a native handle type to pass to the constructor.\n      auto native_handle = NetworkSocket::native_handle_type(ofd);\n\n      auto asyncPipeReader =\n          AsyncPipeReader::newReader(eventBase_, NetworkSocket(native_handle));\n      auto asyncPipeReaderPtr = asyncPipeReader.get();\n      if (!asyncOperationFinishCallback_) {\n        asyncOperationFinishCallback_.reset(\n            new DefaultOpenSSLAsyncFinishCallback(\n                std::move(asyncPipeReader), this, DestructorGuard(this)));\n      }\n      asyncPipeReaderPtr->setReadCB(asyncOperationFinishCallback_.get());\n    }\n#endif\n\n    // The timeout (if set) keeps running here\n    return true;\n  } else {\n    unsigned long lastError = *errErrorOut = ERR_get_error();\n    VLOG(6) << \"AsyncSSLSocket(fd=\" << fd_ << \", \"\n            << \"state=\" << state_ << \", \"\n            << \"sslState=\" << sslState_ << \", \"\n            << \"events=\" << std::hex << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", \"\n            << \"errno: \" << errno << \", \"\n            << \"ret: \" << ret << \", \"\n            << \"read: \" << BIO_number_read(SSL_get_rbio(ssl_.get())) << \", \"\n            << \"written: \" << BIO_number_written(SSL_get_wbio(ssl_.get()))\n            << \", \"\n            << \"func: \" << ERR_func_error_string(lastError) << \", \"\n            << \"reason: \" << ERR_reason_error_string(lastError);\n    return false;\n  }\n}\n\nvoid AsyncSSLSocket::checkForImmediateRead() noexcept {\n  // openssl may have buffered data that it read from the socket already.\n  // In this case we have to process it immediately, rather than waiting for\n  // the socket to become readable again.\n  if (ssl_ != nullptr && SSL_pending(ssl_.get()) > 0) {\n    AsyncSocket::handleRead();\n  } else {\n    AsyncSocket::checkForImmediateRead();\n  }\n}\n\nvoid AsyncSSLSocket::restartSSLAccept() {\n  VLOG(3) << \"AsyncSSLSocket::restartSSLAccept() this=\" << this\n          << \", fd=\" << fd_ << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  DestructorGuard dg(this);\n  assert(\n      sslState_ == STATE_ASYNC_PENDING || sslState_ == STATE_ERROR ||\n      sslState_ == STATE_CLOSED);\n  if (sslState_ == STATE_CLOSED) {\n    // I sure hope whoever closed this socket didn't delete it already,\n    // but this is not strictly speaking an error\n    return;\n  }\n  if (sslState_ == STATE_ERROR) {\n    // go straight to fail if timeout expired during lookup\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::TIMED_OUT, \"SSL accept timed out\");\n    failHandshake(__func__, *ex);\n    return;\n  }\n  sslState_ = STATE_ACCEPTING;\n  this->handleAccept();\n}\n\nvoid AsyncSSLSocket::handleAccept() noexcept {\n  VLOG(3) << \"AsyncSSLSocket::handleAccept() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  assert(server_);\n  assert(state_ == StateEnum::ESTABLISHED && sslState_ == STATE_ACCEPTING);\n  if (!ssl_) {\n    /* lazily create the SSL structure */\n    try {\n      ssl_.reset(ctx_->createSSL());\n    } catch (std::exception& e) {\n      sslState_ = STATE_ERROR;\n      static const Indestructible<AsyncSocketException> ex(\n          AsyncSocketException::INTERNAL_ERROR,\n          \"error calling SSLContext::createSSL()\");\n      LOG(ERROR) << \"AsyncSSLSocket::handleAccept(this=\" << this\n                 << \", fd=\" << fd_ << \"): \" << e.what();\n      return failHandshake(__func__, *ex);\n    }\n\n    if (!setupSSLBio()) {\n      sslState_ = STATE_ERROR;\n      static const Indestructible<AsyncSocketException> ex(\n          AsyncSocketException::INTERNAL_ERROR, \"error creating write bio\");\n      return failHandshake(__func__, *ex);\n    }\n\n    SSL_set_ex_data(ssl_.get(), getSSLExDataIndex(), this);\n\n    applyVerificationOptions(ssl_);\n  }\n\n  if (server_ && parseClientHello_) {\n    SSL_set_msg_callback(\n        ssl_.get(), &AsyncSSLSocket::clientHelloParsingCallback);\n    SSL_set_msg_callback_arg(ssl_.get(), this);\n  }\n\n  DCHECK(ctx_->sslAcceptRunner());\n  updateEventRegistration(\n      EventHandler::NONE, EventHandler::READ | EventHandler::WRITE);\n  DelayedDestruction::DestructorGuard dg(this);\n  ctx_->sslAcceptRunner()->run(\n      [this, dg]() {\n        waitingOnAccept_ = true;\n        return SSL_accept(ssl_.get());\n      },\n      [this, dg](int ret) {\n        waitingOnAccept_ = false;\n        handleReturnFromSSLAccept(ret);\n      });\n}\n\nvoid AsyncSSLSocket::handleReturnFromSSLAccept(int ret) {\n  if (sslState_ != STATE_ACCEPTING) {\n    return;\n  }\n\n  if (ret <= 0) {\n    VLOG(3) << \"SSL_accept returned: \" << ret;\n    int sslError;\n    unsigned long errError;\n    int errnoCopy = errno;\n    if (willBlock(ret, &sslError, &errError)) {\n      return;\n    } else {\n      sslState_ = STATE_ERROR;\n      SSLException ex(sslError, errError, ret, errnoCopy);\n      return failHandshake(__func__, ex);\n    }\n  }\n\n  handshakeComplete_ = true;\n  updateEventRegistration(0, EventHandler::READ | EventHandler::WRITE);\n\n  // Move into STATE_ESTABLISHED in the normal case that we are in\n  // STATE_ACCEPTING.\n  sslState_ = STATE_ESTABLISHED;\n\n  VLOG(3) << \"AsyncSSLSocket \" << this << \": fd \" << fd_\n          << \" successfully accepted; state=\" << int(state_)\n          << \", sslState=\" << sslState_ << \", events=\" << eventFlags_;\n\n  // Remember the EventBase we are attached to, before we start invoking any\n  // callbacks (since the callbacks may call detachEventBase()).\n  EventBase* originalEventBase = eventBase_;\n\n  // Call the accept callback.\n  invokeHandshakeCB();\n\n  // Note that the accept callback may have changed our state.\n  // (set or unset the read callback, called write(), closed the socket, etc.)\n  // The following code needs to handle these situations correctly.\n  //\n  // If the socket has been closed, readCallback_ and writeReqHead_ will\n  // always be nullptr, so that will prevent us from trying to read or write.\n  //\n  // The main thing to check for is if eventBase_ is still originalEventBase.\n  // If not, we have been detached from this event base, so we shouldn't\n  // perform any more operations.\n  if (eventBase_ != originalEventBase) {\n    return;\n  }\n\n  AsyncSocket::handleInitialReadWrite();\n}\n\nvoid AsyncSSLSocket::handleConnect() noexcept {\n  VLOG(3) << \"AsyncSSLSocket::handleConnect() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  assert(!server_);\n  if (state_ < StateEnum::ESTABLISHED) {\n    return AsyncSocket::handleConnect();\n  }\n\n  assert(\n      (state_ == StateEnum::FAST_OPEN || state_ == StateEnum::ESTABLISHED) &&\n      sslState_ == STATE_CONNECTING);\n  assert(ssl_);\n\n  auto originalState = state_;\n  int ret = SSL_connect(ssl_.get());\n  if (ret <= 0) {\n    int sslError;\n    unsigned long errError;\n    int errnoCopy = errno;\n    if (willBlock(ret, &sslError, &errError)) {\n      // We fell back to connecting state due to TFO\n      if (state_ == StateEnum::CONNECTING) {\n        DCHECK_EQ(StateEnum::FAST_OPEN, originalState);\n        if (handshakeTimeout_.isScheduled()) {\n          handshakeTimeout_.cancelTimeout();\n        }\n      }\n      return;\n    } else {\n      sslState_ = STATE_ERROR;\n      SSLException ex(sslError, errError, ret, errnoCopy);\n      return failHandshake(__func__, ex);\n    }\n  }\n\n  handshakeComplete_ = true;\n  updateEventRegistration(0, EventHandler::READ | EventHandler::WRITE);\n\n  // Move into STATE_ESTABLISHED in the normal case that we are in\n  // STATE_CONNECTING.\n  sslState_ = STATE_ESTABLISHED;\n\n  VLOG(3) << \"AsyncSSLSocket \" << this << \": \"\n          << \"fd \" << fd_ << \" successfully connected; \"\n          << \"state=\" << int(state_) << \", sslState=\" << sslState_\n          << \", events=\" << eventFlags_;\n\n  // Remember the EventBase we are attached to, before we start invoking any\n  // callbacks (since the callbacks may call detachEventBase()).\n  EventBase* originalEventBase = eventBase_;\n\n  // Call the handshake callback.\n  invokeHandshakeCB();\n\n  // Note that the connect callback may have changed our state.\n  // (set or unset the read callback, called write(), closed the socket, etc.)\n  // The following code needs to handle these situations correctly.\n  //\n  // If the socket has been closed, readCallback_ and writeReqHead_ will\n  // always be nullptr, so that will prevent us from trying to read or write.\n  //\n  // The main thing to check for is if eventBase_ is still originalEventBase.\n  // If not, we have been detached from this event base, so we shouldn't\n  // perform any more operations.\n  if (eventBase_ != originalEventBase) {\n    return;\n  }\n\n  AsyncSocket::handleInitialReadWrite();\n}\n\nvoid AsyncSSLSocket::invokeConnectErr(const AsyncSocketException& ex) {\n  connectionTimeout_.cancelTimeout();\n  AsyncSocket::invokeConnectErr(ex);\n  if (sslState_ == SSLStateEnum::STATE_CONNECTING) {\n    if (handshakeTimeout_.isScheduled()) {\n      handshakeTimeout_.cancelTimeout();\n    }\n    // If we fell back to connecting state during TFO and the connection\n    // failed, it would be an SSL failure as well.\n    invokeHandshakeErr(ex);\n  }\n}\n\nvoid AsyncSSLSocket::invokeConnectSuccess() {\n  connectionTimeout_.cancelTimeout();\n  if (sslState_ == SSLStateEnum::STATE_CONNECTING) {\n    assert(tfoAttempted_);\n    // If we failed TFO, we'd fall back to trying to connect the socket,\n    // to setup things like timeouts.\n    startSSLConnect();\n  }\n  // still invoke the base class since it re-sets the connect time.\n  AsyncSocket::invokeConnectSuccess();\n}\n\nvoid AsyncSSLSocket::scheduleConnectTimeout() {\n  if (sslState_ == SSLStateEnum::STATE_CONNECTING) {\n    // We fell back from TFO, and need to set the timeouts.\n    // We will not have a connect callback in this case, thus if the timer\n    // expires we would have no-one to notify.\n    // Thus we should reset even the connect timers to point to the handshake\n    // timeouts.\n    assert(connectCallback_ == nullptr);\n    // We use a different connect timeout here than the handshake timeout, so\n    // that we can disambiguate the 2 timers.\n    if (connectTimeout_.count() > 0) {\n      if (!connectionTimeout_.scheduleTimeout(connectTimeout_)) {\n        throw AsyncSocketException(\n            AsyncSocketException::INTERNAL_ERROR,\n            withAddr(\"failed to schedule AsyncSSLSocket connect timeout\"));\n      }\n    }\n    return;\n  }\n  AsyncSocket::scheduleConnectTimeout();\n}\n\nvoid AsyncSSLSocket::handleRead() noexcept {\n  VLOG(5) << \"AsyncSSLSocket::handleRead() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  if (state_ < StateEnum::ESTABLISHED) {\n    return AsyncSocket::handleRead();\n  }\n\n  if (sslState_ == STATE_ACCEPTING) {\n    assert(server_);\n    handleAccept();\n    return;\n  } else if (sslState_ == STATE_CONNECTING) {\n    assert(!server_);\n    handleConnect();\n    return;\n  }\n\n  // Normal read\n  AsyncSocket::handleRead();\n}\n\nAsyncSocket::ReadResult\nAsyncSSLSocket::performRead(void** buf, size_t* buflen, size_t* offset) {\n  VLOG(4) << \"AsyncSSLSocket::performRead() this=\" << this << \", buf=\" << *buf\n          << \", buflen=\" << *buflen;\n\n  if (sslState_ == STATE_UNENCRYPTED) {\n    return AsyncSocket::performRead(buf, buflen, offset);\n  }\n\n  int numToRead = 0;\n  if (*buflen > std::numeric_limits<int>::max()) {\n    numToRead = std::numeric_limits<int>::max();\n    VLOG(4) << \"Clamping SSL_read to \" << numToRead;\n  } else {\n    numToRead = int(*buflen);\n  }\n  int bytes = SSL_read(ssl_.get(), *buf, numToRead);\n\n  if (server_ && renegotiateAttempted_) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslstate=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): client intitiated SSL renegotiation not permitted\";\n    return ReadResult(\n        READ_ERROR,\n        std::make_unique<SSLException>(SSLError::CLIENT_RENEGOTIATION));\n  }\n  if (bytes <= 0) {\n    int error = SSL_get_error(ssl_.get(), bytes);\n    if (error == SSL_ERROR_WANT_READ) {\n      // The caller will register for read event if not already.\n      if (errno == EWOULDBLOCK || errno == EAGAIN) {\n        return ReadResult(READ_BLOCKING);\n      } else {\n        return ReadResult(READ_ERROR);\n      }\n    } else if (error == SSL_ERROR_WANT_WRITE) {\n      // TODO: Even though we are attempting to read data, SSL_read() may\n      // need to write data if renegotiation is being performed.  We currently\n      // don't support this and just fail the read.\n      LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n                 << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n                 << \"): unsupported SSL renegotiation during read\";\n      return ReadResult(\n          READ_ERROR,\n          std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n    } else {\n      if (zero_return(error, bytes, errno)) {\n        return ReadResult(bytes);\n      }\n      auto errError = ERR_get_error();\n      VLOG(6) << \"AsyncSSLSocket(fd=\" << fd_ << \", \"\n              << \"state=\" << state_ << \", \"\n              << \"sslState=\" << sslState_ << \", \"\n              << \"events=\" << std::hex << eventFlags_ << \"): \"\n              << \"bytes: \" << bytes << \", \"\n              << \"error: \" << error << \", \"\n              << \"errno: \" << errno << \", \"\n              << \"func: \" << ERR_func_error_string(errError) << \", \"\n              << \"reason: \" << ERR_reason_error_string(errError);\n      return ReadResult(\n          READ_ERROR,\n          std::make_unique<SSLException>(error, errError, bytes, errno));\n    }\n  } else {\n    appBytesReceived_ += bytes;\n    return ReadResult(bytes);\n  }\n}\n\nvoid AsyncSSLSocket::handleWrite() noexcept {\n  VLOG(5) << \"AsyncSSLSocket::handleWrite() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  if (state_ < StateEnum::ESTABLISHED) {\n    return AsyncSocket::handleWrite();\n  }\n\n  if (sslState_ == STATE_ACCEPTING) {\n    assert(server_);\n    handleAccept();\n    return;\n  }\n\n  if (sslState_ == STATE_CONNECTING) {\n    assert(!server_);\n    handleConnect();\n    return;\n  }\n\n  // Normal write\n  AsyncSocket::handleWrite();\n}\n\nAsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    // Even though we are attempting to write data, SSL_write() may\n    // need to read data if renegotiation is being performed.  We currently\n    // don't support this and just fail the write.\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}\n\nAsyncSocket::WriteResult AsyncSSLSocket::performWrite(\n    const iovec* vec,\n    uint32_t count,\n    WriteFlags flags,\n    uint32_t* countWritten,\n    uint32_t* partialWritten) {\n  if (sslState_ == STATE_UNENCRYPTED) {\n    return AsyncSocket::performWrite(\n        vec, count, flags, countWritten, partialWritten);\n  }\n  if (sslState_ != STATE_ESTABLISHED) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"TODO: AsyncSSLSocket currently does not support calling \"\n               << \"write() before the handshake has fully completed\";\n    return WriteResult(\n        WRITE_ERROR, std::make_unique<SSLException>(SSLError::EARLY_WRITE));\n  }\n\n  // Declare a buffer used to hold small write requests.  It could point to a\n  // memory block either on stack or on heap. If it is on heap, we release it\n  // manually when scope exits\n  char* combinedBuf{nullptr};\n  SCOPE_EXIT {\n    // Note, always keep this check consistent with what we do below\n    if (combinedBuf != nullptr && minWriteSize_ > MAX_STACK_BUF_SIZE) {\n      delete[] combinedBuf;\n    }\n  };\n\n  *countWritten = 0;\n  *partialWritten = 0;\n  ssize_t totalWritten = 0;\n  size_t bytesStolenFromNextBuffer = 0;\n  for (uint32_t i = 0; i < count; i++) {\n    const iovec* v = vec + i;\n    size_t offset = bytesStolenFromNextBuffer;\n    bytesStolenFromNextBuffer = 0;\n    size_t len = v->iov_len - offset;\n    const void* buf;\n    if (len == 0) {\n      (*countWritten)++;\n      continue;\n    }\n    buf = ((const char*)v->iov_base) + offset;\n\n    ssize_t bytes;\n    uint32_t buffersStolen = 0;\n    auto sslWriteBuf = buf;\n    if ((len < minWriteSize_) && ((i + 1) < count)) {\n      // Combine this buffer with part or all of the next buffers in\n      // order to avoid really small-grained calls to SSL_write().\n      // Each call to SSL_write() produces a separate record in\n      // the egress SSL stream, and we've found that some low-end\n      // mobile clients can't handle receiving an HTTP response\n      // header and the first part of the response body in two\n      // separate SSL records (even if those two records are in\n      // the same TCP packet).\n\n      if (combinedBuf == nullptr) {\n        if (minWriteSize_ > MAX_STACK_BUF_SIZE) {\n          // Allocate the buffer on heap\n          combinedBuf = new char[minWriteSize_];\n        } else {\n          // Allocate the buffer on stack\n          combinedBuf = (char*)alloca(minWriteSize_);\n        }\n      }\n      assert(combinedBuf != nullptr);\n      sslWriteBuf = combinedBuf;\n\n      memcpy(combinedBuf, buf, len);\n      do {\n        // INVARIANT: i + buffersStolen == complete chunks serialized\n        uint32_t nextIndex = i + buffersStolen + 1;\n        bytesStolenFromNextBuffer =\n            std::min(vec[nextIndex].iov_len, minWriteSize_ - len);\n        if (bytesStolenFromNextBuffer > 0) {\n          assert(vec[nextIndex].iov_base != nullptr);\n          ::memcpy(\n              combinedBuf + len,\n              vec[nextIndex].iov_base,\n              bytesStolenFromNextBuffer);\n        }\n        len += bytesStolenFromNextBuffer;\n        if (bytesStolenFromNextBuffer < vec[nextIndex].iov_len) {\n          // couldn't steal the whole buffer\n          break;\n        } else {\n          bytesStolenFromNextBuffer = 0;\n          buffersStolen++;\n        }\n      } while ((i + buffersStolen + 1) < count && (len < minWriteSize_));\n    }\n\n    // Advance any empty buffers immediately after.\n    if (bytesStolenFromNextBuffer == 0) {\n      while ((i + buffersStolen + 1) < count &&\n             vec[i + buffersStolen + 1].iov_len == 0) {\n        buffersStolen++;\n      }\n    }\n\n    // cork the current write if the original flags included CORK or if there\n    // are remaining iovec to write\n    corkCurrentWrite_ =\n        isSet(flags, WriteFlags::CORK) || (i + buffersStolen + 1 < count);\n\n    // track the EoR if:\n    //  (1) there are write flags that require EoR tracking (EOR / TIMESTAMP_TX)\n    //  (2) if the buffer includes the EOR byte\n    appEorByteWriteFlags_ = flags & kEorRelevantWriteFlags;\n    bool trackEor = appEorByteWriteFlags_ != folly::WriteFlags::NONE &&\n        (i + buffersStolen + 1 == count);\n    bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);\n\n    if (bytes <= 0) {\n      int error = SSL_get_error(ssl_.get(), int(bytes));\n      if (error == SSL_ERROR_WANT_WRITE) {\n        // The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      auto writeResult = interpretSSLError(int(bytes), error);\n      if (writeResult.writeReturn < 0) {\n        return writeResult;\n      } // else fall through to below to correctly record totalWritten\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {\n      // The full iovec is written.\n      (*countWritten) += 1 + buffersStolen;\n      i += buffersStolen;\n      // continue\n    } else {\n      bytes += offset; // adjust bytes to account for all of v\n      while (bytes >= (ssize_t)v->iov_len) {\n        // We combined this buf with part or all of the next one, and\n        // we managed to write all of this buf but not all of the bytes\n        // from the next one that we'd hoped to write.\n        bytes -= v->iov_len;\n        (*countWritten)++;\n        v = &(vec[++i]);\n      }\n      *partialWritten = uint32_t(bytes);\n      return WriteResult(totalWritten);\n    }\n  }\n\n  return WriteResult(totalWritten);\n}\n\nint AsyncSSLSocket::eorAwareSSLWrite(\n    const ssl::SSLUniquePtr& ssl,\n    const void* buf,\n    int n,\n    bool eor) {\n  if (eor && isEorTrackingEnabled()) {\n    if (appEorByteNo_) {\n      // cannot track for more than one app byte EOR\n      CHECK(appEorByteNo_ == appBytesWritten_ + n);\n    } else {\n      appEorByteNo_ = appBytesWritten_ + n;\n    }\n\n    // 1. It is fine to keep updating minEorRawByteNo_.\n    // 2. It is _min_ in the sense that SSL record will add some overhead.\n    minEorRawByteNo_ = getRawBytesWritten() + n;\n  }\n\n  n = sslWriteImpl(ssl.get(), buf, n);\n  if (n > 0) {\n    appBytesWritten_ += n;\n    if (appEorByteNo_) {\n      if (getRawBytesWritten() >= minEorRawByteNo_) {\n        minEorRawByteNo_ = 0;\n      }\n      if (appBytesWritten_ == appEorByteNo_) {\n        appEorByteNo_ = 0;\n        appEorByteWriteFlags_ = {};\n      } else {\n        CHECK(appBytesWritten_ < appEorByteNo_);\n      }\n    }\n  }\n  return n;\n}\n\nvoid AsyncSSLSocket::sslInfoCallback(const SSL* ssl, int where, int ret) {\n  AsyncSSLSocket* sslSocket = AsyncSSLSocket::getFromSSL(ssl);\n  if (sslSocket->handshakeComplete_ && (where & SSL_CB_HANDSHAKE_START)) {\n    sslSocket->renegotiateAttempted_ = true;\n  }\n  if (sslSocket->handshakeComplete_ && (where & SSL_CB_WRITE_ALERT)) {\n    const char* desc = SSL_alert_desc_string(ret);\n    if (desc && strcmp(desc, \"NR\") == 0) {\n      sslSocket->renegotiateAttempted_ = true;\n    }\n  }\n  if (where & SSL_CB_READ_ALERT) {\n    const char* type = SSL_alert_type_string(ret);\n    if (type) {\n      const char* desc = SSL_alert_desc_string(ret);\n      sslSocket->alertsReceived_.emplace_back(\n          *type, StringPiece(desc, std::strlen(desc)));\n    }\n  }\n}\n\nint AsyncSSLSocket::bioWrite(BIO* b, const char* in, int inl) {\n  struct msghdr msg;\n  struct iovec iov;\n  AsyncSSLSocket* tsslSock;\n\n  iov.iov_base = const_cast<char*>(in);\n  iov.iov_len = size_t(inl);\n  memset(&msg, 0, sizeof(msg));\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  auto appData = OpenSSLUtils::getBioAppData(b);\n  CHECK(appData);\n\n  tsslSock = reinterpret_cast<AsyncSSLSocket*>(appData);\n  CHECK(tsslSock);\n\n  WriteFlags flags = WriteFlags::NONE;\n  if (tsslSock->isEorTrackingEnabled() && tsslSock->minEorRawByteNo_ &&\n      tsslSock->minEorRawByteNo_ <= BIO_number_written(b) + inl) {\n    flags |= tsslSock->appEorByteWriteFlags_;\n  }\n\n  if (tsslSock->corkCurrentWrite_) {\n    flags |= WriteFlags::CORK;\n  }\n\n  int msg_flags = tsslSock->getSendMsgParamsCB()->getFlags(\n      flags, false /*zeroCopyEnabled*/);\n  msg.msg_controllen =\n      tsslSock->getSendMsgParamsCB()->getAncillaryDataSize(flags);\n  CHECK_GE(\n      AsyncSocket::SendMsgParamsCallback::maxAncillaryDataSize,\n      msg.msg_controllen);\n  if (msg.msg_controllen != 0) {\n    msg.msg_control = reinterpret_cast<char*>(alloca(msg.msg_controllen));\n    tsslSock->getSendMsgParamsCB()->getAncillaryData(flags, msg.msg_control);\n  }\n\n  auto result =\n      tsslSock->sendSocketMessage(OpenSSLUtils::getBioFd(b), &msg, msg_flags);\n  BIO_clear_retry_flags(b);\n  if (!result.exception && result.writeReturn <= 0) {\n    if (OpenSSLUtils::getBioShouldRetryWrite(int(result.writeReturn))) {\n      BIO_set_retry_write(b);\n    }\n  }\n  return int(result.writeReturn);\n}\n\nint AsyncSSLSocket::bioRead(BIO* b, char* out, int outl) {\n  if (!out) {\n    return 0;\n  }\n  BIO_clear_retry_flags(b);\n\n  auto appData = OpenSSLUtils::getBioAppData(b);\n  CHECK(appData);\n  auto sslSock = reinterpret_cast<AsyncSSLSocket*>(appData);\n\n  if (sslSock->preReceivedData_ && !sslSock->preReceivedData_->empty()) {\n    VLOG(5) << \"AsyncSSLSocket::bioRead() this=\" << sslSock\n            << \", reading pre-received data\";\n\n    Cursor cursor(sslSock->preReceivedData_.get());\n    auto len = cursor.pullAtMost(out, outl);\n\n    IOBufQueue queue;\n    queue.append(std::move(sslSock->preReceivedData_));\n    queue.trimStart(len);\n    sslSock->preReceivedData_ = queue.move();\n    return static_cast<int>(len);\n  } else {\n    auto result = int(netops::recv(OpenSSLUtils::getBioFd(b), out, outl, 0));\n    if (result <= 0 && OpenSSLUtils::getBioShouldRetryWrite(result)) {\n      BIO_set_retry_read(b);\n    }\n    return result;\n  }\n}\n\nint AsyncSSLSocket::sslVerifyCallback(\n    int preverifyOk,\n    X509_STORE_CTX* x509Ctx) {\n  SSL* ssl = (SSL*)X509_STORE_CTX_get_ex_data(\n      x509Ctx, SSL_get_ex_data_X509_STORE_CTX_idx());\n  AsyncSSLSocket* self = AsyncSSLSocket::getFromSSL(ssl);\n\n  VLOG(3) << \"AsyncSSLSocket::sslVerifyCallback() this=\" << self << \", \"\n          << \"fd=\" << self->fd_ << \", preverifyOk=\" << preverifyOk;\n  return (self->handshakeCallback_)\n      ? self->handshakeCallback_->handshakeVer(self, preverifyOk, x509Ctx)\n      : preverifyOk;\n}\n\nvoid AsyncSSLSocket::enableClientHelloParsing() {\n  parseClientHello_ = true;\n  clientHelloInfo_ = std::make_unique<ssl::ClientHelloInfo>();\n}\n\nvoid AsyncSSLSocket::resetClientHelloParsing(SSL* ssl) {\n  SSL_set_msg_callback(ssl, nullptr);\n  SSL_set_msg_callback_arg(ssl, nullptr);\n  clientHelloInfo_->clientHelloBuf_.clear();\n}\n\nvoid AsyncSSLSocket::clientHelloParsingCallback(\n    int written,\n    int /* version */,\n    int contentType,\n    const void* buf,\n    size_t len,\n    SSL* ssl,\n    void* arg) {\n  AsyncSSLSocket* sock = static_cast<AsyncSSLSocket*>(arg);\n  if (written != 0) {\n    sock->resetClientHelloParsing(ssl);\n    return;\n  }\n  if (contentType != SSL3_RT_HANDSHAKE) {\n    return;\n  }\n  if (len == 0) {\n    return;\n  }\n\n  auto& clientHelloBuf = sock->clientHelloInfo_->clientHelloBuf_;\n  clientHelloBuf.append(IOBuf::wrapBuffer(buf, len));\n  try {\n    Cursor cursor(clientHelloBuf.front());\n    if (cursor.read<uint8_t>() != SSL3_MT_CLIENT_HELLO) {\n      sock->resetClientHelloParsing(ssl);\n      return;\n    }\n\n    if (cursor.totalLength() < 3) {\n      clientHelloBuf.trimEnd(len);\n      clientHelloBuf.append(IOBuf::copyBuffer(buf, len));\n      return;\n    }\n\n    uint32_t messageLength = cursor.read<uint8_t>();\n    messageLength <<= 8;\n    messageLength |= cursor.read<uint8_t>();\n    messageLength <<= 8;\n    messageLength |= cursor.read<uint8_t>();\n    if (cursor.totalLength() < messageLength) {\n      clientHelloBuf.trimEnd(len);\n      clientHelloBuf.append(IOBuf::copyBuffer(buf, len));\n      return;\n    }\n\n    sock->clientHelloInfo_->clientHelloMajorVersion_ = cursor.read<uint8_t>();\n    sock->clientHelloInfo_->clientHelloMinorVersion_ = cursor.read<uint8_t>();\n\n    cursor.skip(4); // gmt_unix_time\n    cursor.skip(28); // random_bytes\n\n    cursor.skip(cursor.read<uint8_t>()); // session_id\n\n    uint16_t cipherSuitesLength = cursor.readBE<uint16_t>();\n    for (int i = 0; i < cipherSuitesLength; i += 2) {\n      sock->clientHelloInfo_->clientHelloCipherSuites_.push_back(\n          cursor.readBE<uint16_t>());\n    }\n\n    uint8_t compressionMethodsLength = cursor.read<uint8_t>();\n    for (int i = 0; i < compressionMethodsLength; ++i) {\n      sock->clientHelloInfo_->clientHelloCompressionMethods_.push_back(\n          cursor.readBE<uint8_t>());\n    }\n\n    if (cursor.totalLength() > 0) {\n      uint16_t extensionsLength = cursor.readBE<uint16_t>();\n      while (extensionsLength) {\n        ssl::TLSExtension extensionType =\n            static_cast<ssl::TLSExtension>(cursor.readBE<uint16_t>());\n        sock->clientHelloInfo_->clientHelloExtensions_.push_back(extensionType);\n        extensionsLength -= 2;\n        uint16_t extensionDataLength = cursor.readBE<uint16_t>();\n        extensionsLength -= 2;\n        extensionsLength -= extensionDataLength;\n\n        if (extensionType == ssl::TLSExtension::SIGNATURE_ALGORITHMS) {\n          cursor.skip(2);\n          extensionDataLength -= 2;\n          while (extensionDataLength) {\n            ssl::HashAlgorithm hashAlg =\n                static_cast<ssl::HashAlgorithm>(cursor.readBE<uint8_t>());\n            ssl::SignatureAlgorithm sigAlg =\n                static_cast<ssl::SignatureAlgorithm>(cursor.readBE<uint8_t>());\n            extensionDataLength -= 2;\n            sock->clientHelloInfo_->clientHelloSigAlgs_.emplace_back(\n                hashAlg, sigAlg);\n          }\n        } else if (extensionType == ssl::TLSExtension::SUPPORTED_VERSIONS) {\n          cursor.skip(1);\n          extensionDataLength -= 1;\n          while (extensionDataLength) {\n            sock->clientHelloInfo_->clientHelloSupportedVersions_.push_back(\n                cursor.readBE<uint16_t>());\n            extensionDataLength -= 2;\n          }\n        } else if (extensionType == ssl::TLSExtension::SERVER_NAME) {\n          cursor.skip(2);\n          extensionDataLength -= 2;\n          while (extensionDataLength) {\n            static_assert(\n                std::is_same<\n                    typename std::underlying_type<ssl::NameType>::type,\n                    uint8_t>::value,\n                \"unexpected underlying type\");\n\n            ssl::NameType typ =\n                static_cast<ssl::NameType>(cursor.readBE<uint8_t>());\n            uint16_t nameLength = cursor.readBE<uint16_t>();\n\n            if (typ == NameType::HOST_NAME &&\n                sock->clientHelloInfo_->clientHelloSNIHostname_.empty() &&\n                cursor.canAdvance(nameLength)) {\n              sock->clientHelloInfo_->clientHelloSNIHostname_ =\n                  cursor.readFixedString(nameLength);\n            } else {\n              // Must attempt to skip |nameLength| in order to keep cursor\n              // in sync. If the remaining buffer length is smaller than\n              // nameLength, this will throw.\n              cursor.skip(nameLength);\n            }\n            extensionDataLength -=\n                sizeof(typ) + sizeof(nameLength) + nameLength;\n          }\n        } else {\n          cursor.skip(extensionDataLength);\n        }\n      }\n    }\n  } catch (std::out_of_range&) {\n    // we'll use what we found and cleanup below.\n    VLOG(4) << \"AsyncSSLSocket::clientHelloParsingCallback(): \"\n            << \"buffer finished unexpectedly.\"\n            << \" AsyncSSLSocket socket=\" << sock;\n  }\n\n  sock->resetClientHelloParsing(ssl);\n}\n\nvoid AsyncSSLSocket::getSSLClientCiphers(\n    std::string& clientCiphers,\n    bool convertToString) const {\n  std::string ciphers;\n\n  if (parseClientHello_ == false ||\n      clientHelloInfo_->clientHelloCipherSuites_.empty()) {\n    clientCiphers = \"\";\n    return;\n  }\n\n  bool first = true;\n  for (auto originalCipherCode : clientHelloInfo_->clientHelloCipherSuites_) {\n    if (first) {\n      first = false;\n    } else {\n      ciphers += \":\";\n    }\n\n    bool nameFound = convertToString;\n\n    if (convertToString) {\n      const auto& name = OpenSSLUtils::getCipherName(originalCipherCode);\n      if (name.empty()) {\n        nameFound = false;\n      } else {\n        ciphers += name;\n      }\n    }\n\n    if (!nameFound) {\n      folly::hexlify(\n          std::array<uint8_t, 2>{\n              {static_cast<uint8_t>((originalCipherCode >> 8) & 0xffL),\n               static_cast<uint8_t>(originalCipherCode & 0x00ffL)}},\n          ciphers,\n          /* append to ciphers = */ true);\n    }\n  }\n\n  clientCiphers = std::move(ciphers);\n}\n\nstd::string AsyncSSLSocket::getSSLClientComprMethods() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n  return folly::join(\":\", clientHelloInfo_->clientHelloCompressionMethods_);\n}\n\nstd::string AsyncSSLSocket::getSSLClientExts() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n  return folly::join(\":\", clientHelloInfo_->clientHelloExtensions_);\n}\n\nstd::string AsyncSSLSocket::getSSLClientSigAlgs() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n\n  std::string sigAlgs;\n  sigAlgs.reserve(clientHelloInfo_->clientHelloSigAlgs_.size() * 4);\n  for (size_t i = 0; i < clientHelloInfo_->clientHelloSigAlgs_.size(); i++) {\n    if (i) {\n      sigAlgs.push_back(':');\n    }\n    sigAlgs.append(\n        folly::to<std::string>(clientHelloInfo_->clientHelloSigAlgs_[i].first));\n    sigAlgs.push_back(',');\n    sigAlgs.append(folly::to<std::string>(\n        clientHelloInfo_->clientHelloSigAlgs_[i].second));\n  }\n\n  return sigAlgs;\n}\n\nstd::string AsyncSSLSocket::getSSLClientSupportedVersions() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n  return folly::join(\":\", clientHelloInfo_->clientHelloSupportedVersions_);\n}\n\nstd::string AsyncSSLSocket::getSSLAlertsReceived() const {\n  std::string ret;\n\n  for (const auto& alert : alertsReceived_) {\n    if (!ret.empty()) {\n      ret.append(\",\");\n    }\n    ret.append(folly::to<std::string>(alert.first, \": \", alert.second));\n  }\n\n  return ret;\n}\n\nvoid AsyncSSLSocket::setSSLCertVerificationAlert(std::string alert) {\n  sslVerificationAlert_ = std::move(alert);\n}\n\nstd::string AsyncSSLSocket::getSSLCertVerificationAlert() const {\n  return sslVerificationAlert_;\n}\n\nvoid AsyncSSLSocket::getSSLSharedCiphers(std::string& sharedCiphers) const {\n  char ciphersBuffer[1024];\n  ciphersBuffer[0] = '\\0';\n  SSL_get_shared_ciphers(ssl_.get(), ciphersBuffer, sizeof(ciphersBuffer) - 1);\n  sharedCiphers = ciphersBuffer;\n}\n\nvoid AsyncSSLSocket::getSSLServerCiphers(std::string& serverCiphers) const {\n  serverCiphers = SSL_get_cipher_list(ssl_.get(), 0);\n  int i = 1;\n  const char* cipher;\n  while ((cipher = SSL_get_cipher_list(ssl_.get(), i)) != nullptr) {\n    serverCiphers.append(\":\");\n    serverCiphers.append(cipher);\n    i++;\n  }\n}\n\n} // namespace folly\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/io/async/test/AsyncSSLSocketTest.h>\n\n#include <folly/SocketAddress.h>\n#include <folly/String.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/async/AsyncPipe.h>\n#include <folly/io/async/AsyncSSLSocket.h>\n#include <folly/io/async/EventBase.h>\n#include <folly/io/async/ScopedEventBaseThread.h>\n#include <folly/net/NetOps.h>\n#include <folly/net/NetworkSocket.h>\n#include <folly/portability/GMock.h>\n#include <folly/portability/GTest.h>\n#include <folly/portability/OpenSSL.h>\n#include <folly/portability/Unistd.h>\n#include <folly/ssl/Init.h>\n\n#include <folly/io/async/test/BlockingSocket.h>\n\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/types.h>\n\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <set>\n#include <thread>\n\n#ifdef __linux__\n#include <dlfcn.h>\n#endif\n\n#if FOLLY_OPENSSL_IS_110\n#include <openssl/async.h>\n#endif\n\n#ifdef FOLLY_HAVE_MSG_ERRQUEUE\n#include <sys/utsname.h>\n#endif\n\nusing std::cerr;\nusing std::endl;\nusing std::list;\nusing std::min;\nusing std::string;\nusing std::vector;\n\nusing namespace testing;\n\n#if defined __linux__\nnamespace {\n\n// to store libc's original setsockopt()\ntypedef int (*setsockopt_ptr)(int, int, int, const void*, socklen_t);\nsetsockopt_ptr real_setsockopt_ = nullptr;\n\n// global struct to initialize before main runs. we can init within a test,\n// or in main, but this method seems to be least intrsive and universal\nstruct GlobalStatic {\n  GlobalStatic() {\n    real_setsockopt_ = (setsockopt_ptr)dlsym(RTLD_NEXT, \"setsockopt\");\n  }\n  void reset() noexcept {\n    ttlsDisabledSet.clear();\n  }\n  // for each fd, tracks whether TTLS is disabled or not\n  std::unordered_set<folly::NetworkSocket /* fd */> ttlsDisabledSet;\n};\n\n// the constructor will be called before main() which is all we care about\nGlobalStatic globalStatic;\n\n} // namespace\n\n// we intercept setsoctopt to test setting NO_TRANSPARENT_TLS opt\n// this name has to be global\nint setsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    const void* optval,\n    socklen_t optlen) {\n  if (optname == SO_NO_TRANSPARENT_TLS) {\n    globalStatic.ttlsDisabledSet.insert(folly::NetworkSocket::fromFd(sockfd));\n    return 0;\n  }\n  return real_setsockopt_(sockfd, level, optname, optval, optlen);\n}\n#endif\n\nnamespace folly {\nconstexpr size_t SSLClient::kMaxReadBufferSz;\nconstexpr size_t SSLClient::kMaxReadsPerEvent;\n\nvoid getfds(NetworkSocket fds[2]) {\n  if (netops::socketpair(PF_LOCAL, SOCK_STREAM, 0, fds) != 0) {\n    FAIL() << \"failed to create socketpair: \" << errnoStr(errno);\n  }\n  for (int idx = 0; idx < 2; ++idx) {\n    if (netops::set_socket_non_blocking(fds[idx]) != 0) {\n      FAIL() << \"failed to put socket \" << idx\n             << \" in non-blocking mode: \" << errnoStr(errno);\n    }\n  }\n}\n\nvoid getctx(\n    std::shared_ptr<folly::SSLContext> clientCtx,\n    std::shared_ptr<folly::SSLContext> serverCtx) {\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadPrivateKey(kTestKey);\n}\n\nvoid sslsocketpair(\n    EventBase* eventBase,\n    AsyncSSLSocket::UniquePtr* clientSock,\n    AsyncSSLSocket::UniquePtr* serverSock) {\n  auto clientCtx = std::make_shared<folly::SSLContext>();\n  auto serverCtx = std::make_shared<folly::SSLContext>();\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, serverCtx);\n  clientSock->reset(new AsyncSSLSocket(clientCtx, eventBase, fds[0], false));\n  serverSock->reset(new AsyncSSLSocket(serverCtx, eventBase, fds[1], true));\n\n  // (*clientSock)->setSendTimeout(100);\n  // (*serverSock)->setSendTimeout(100);\n}\n\n// client protocol filters\nbool clientProtoFilterPickPony(\n    unsigned char** client,\n    unsigned int* client_len,\n    const unsigned char*,\n    unsigned int) {\n  // the protocol string in length prefixed byte string. the\n  // length byte is not included in the length\n  static unsigned char p[7] = {6, 'p', 'o', 'n', 'i', 'e', 's'};\n  *client = p;\n  *client_len = 7;\n  return true;\n}\n\nbool clientProtoFilterPickNone(\n    unsigned char**,\n    unsigned int*,\n    const unsigned char*,\n    unsigned int) {\n  return false;\n}\n\nstd::string getFileAsBuf(const char* fileName) {\n  std::string buffer;\n  folly::readFile(fileName, buffer);\n  return buffer;\n}\n\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadClose) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  // sslContext->loadTrustedCertificates(\"./trusted-ca-certificate.pem\");\n  // sslContext->authenticate(true, false);\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open(std::chrono::milliseconds(10000));\n\n  // write()\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  // read()\n  uint8_t readbuf[128];\n  uint32_t bytesRead = socket->readAll(readbuf, sizeof(readbuf));\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf, readbuf, bytesRead), 0);\n\n  // close()\n  socket->close();\n\n  cerr << \"ConnectWriteReadClose test completed\" << endl;\n  EXPECT_EQ(socket->getSSLSocket()->getTotalConnectTimeout().count(), 10000);\n}\n\n/**\n * Same as above simple test, but with a large read len to test\n * clamping behavior.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadLargeClose) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  // sslContext->loadTrustedCertificates(\"./trusted-ca-certificate.pem\");\n  // sslContext->authenticate(true, false);\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open(std::chrono::milliseconds(10000));\n\n  // write()\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  // read()\n  uint8_t readbuf[128];\n  // we will fake the read len but that should be fine\n  size_t readLen = 1L << 33;\n  uint32_t bytesRead = socket->read(readbuf, readLen);\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf, readbuf, bytesRead), 0);\n\n  // close()\n  socket->close();\n\n  cerr << \"ConnectWriteReadClose test completed\" << endl;\n  EXPECT_EQ(socket->getSSLSocket()->getTotalConnectTimeout().count(), 10000);\n}\n\n/**\n * Test reading after server close.\n */\nTEST(AsyncSSLSocketTest, ReadAfterClose) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadEOFCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  auto server = std::make_unique<TestSSLServer>(&acceptCallback);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  auto socket =\n      std::make_shared<BlockingSocket>(server->getAddress(), sslContext);\n  socket->open();\n\n  // This should trigger an EOF on the client.\n  auto evb = handshakeCallback.getSocket()->getEventBase();\n  evb->runInEventBaseThreadAndWait([&]() { handshakeCallback.closeSocket(); });\n  std::array<uint8_t, 128> readbuf;\n  auto bytesRead = socket->read(readbuf.data(), readbuf.size());\n  EXPECT_EQ(0, bytesRead);\n}\n\n/**\n * Test bad renegotiation\n */\n#if !defined(OPENSSL_IS_BORINGSSL)\nTEST(AsyncSSLSocketTest, Renegotiate) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  RenegotiatingServer server(std::move(serverSock));\n\n  while (!client.handshakeSuccess_ && !client.handshakeError_) {\n    eventBase.loopOnce();\n  }\n\n  ASSERT_TRUE(client.handshakeSuccess_);\n\n  auto sslSock = std::move(client).moveSocket();\n  sslSock->detachEventBase();\n  // This is nasty, however we don't want to add support for\n  // renegotiation in AsyncSSLSocket.\n  SSL_renegotiate(const_cast<SSL*>(sslSock->getSSL()));\n\n  auto socket = std::make_shared<BlockingSocket>(std::move(sslSock));\n\n  std::thread t([&]() { eventBase.loopForever(); });\n\n  // Trigger the renegotiation.\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  try {\n    socket->write(buf.data(), buf.size());\n  } catch (AsyncSocketException& e) {\n    LOG(INFO) << \"client got error \" << e.what();\n  }\n  eventBase.terminateLoopSoon();\n  t.join();\n\n  eventBase.loop();\n  ASSERT_TRUE(server.renegotiationError_);\n}\n#endif\n\n/**\n * Negative test for handshakeError().\n */\nTEST(AsyncSSLSocketTest, HandshakeError) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  HandshakeErrorCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  // read()\n  bool ex = false;\n  try {\n    socket->open();\n\n    uint8_t readbuf[128];\n    uint32_t bytesRead = socket->readAll(readbuf, sizeof(readbuf));\n    LOG(ERROR) << \"readAll returned \" << bytesRead << \" instead of throwing\";\n  } catch (AsyncSocketException&) {\n    ex = true;\n  }\n  EXPECT_TRUE(ex);\n\n  // close()\n  socket->close();\n  cerr << \"HandshakeError test completed\" << endl;\n}\n\n/**\n * Negative test for readError().\n */\nTEST(AsyncSSLSocketTest, ReadError) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // write something to trigger ssl handshake\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  socket->close();\n  cerr << \"ReadError test completed\" << endl;\n}\n\n/**\n * Negative test for writeError().\n */\nTEST(AsyncSSLSocketTest, WriteError) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // write something to trigger ssl handshake\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  socket->close();\n  cerr << \"WriteError test completed\" << endl;\n}\n\n/**\n * Test a socket with TCP_NODELAY unset.\n */\nTEST(AsyncSSLSocketTest, SocketWithDelay) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallbackDelay acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // write()\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  // read()\n  uint8_t readbuf[128];\n  uint32_t bytesRead = socket->readAll(readbuf, sizeof(readbuf));\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf, readbuf, bytesRead), 0);\n\n  // close()\n  socket->close();\n\n  cerr << \"SocketWithDelay test completed\" << endl;\n}\n\n#if FOLLY_OPENSSL_HAS_ALPN\nclass NextProtocolTest : public Test {\n  // For matching protos\n public:\n  void SetUp() override {\n    getctx(clientCtx, serverCtx);\n  }\n\n  void connect(bool unset = false) {\n    getfds(fds);\n\n    if (unset) {\n      // unsetting NPN for any of [client, server] is enough to make NPN not\n      // work\n      clientCtx->unsetNextProtocols();\n    }\n\n    AsyncSSLSocket::UniquePtr clientSock(\n        new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n    AsyncSSLSocket::UniquePtr serverSock(\n        new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n    client = std::make_unique<AlpnClient>(std::move(clientSock));\n    server = std::make_unique<AlpnServer>(std::move(serverSock));\n\n    eventBase.loop();\n  }\n\n  void expectProtocol(const std::string& proto) {\n    expectHandshakeSuccess();\n    EXPECT_NE(client->nextProtoLength, 0);\n    EXPECT_EQ(client->nextProtoLength, server->nextProtoLength);\n    EXPECT_EQ(\n        memcmp(client->nextProto, server->nextProto, server->nextProtoLength),\n        0);\n    string selected((const char*)client->nextProto, client->nextProtoLength);\n    EXPECT_EQ(proto, selected);\n  }\n\n  void expectNoProtocol() {\n    expectHandshakeSuccess();\n    EXPECT_EQ(client->nextProtoLength, 0);\n    EXPECT_EQ(server->nextProtoLength, 0);\n    EXPECT_EQ(client->nextProto, nullptr);\n    EXPECT_EQ(server->nextProto, nullptr);\n  }\n\n  void expectHandshakeSuccess() {\n    EXPECT_FALSE(client->except.hasValue())\n        << \"client handshake error: \" << client->except->what();\n    EXPECT_FALSE(server->except.hasValue())\n        << \"server handshake error: \" << server->except->what();\n  }\n\n  void expectHandshakeError() {\n    EXPECT_TRUE(client->except.hasValue())\n        << \"Expected client handshake error!\";\n    EXPECT_TRUE(server->except.hasValue())\n        << \"Expected server handshake error!\";\n  }\n\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx{std::make_shared<SSLContext>()};\n  std::shared_ptr<SSLContext> serverCtx{std::make_shared<SSLContext>()};\n  NetworkSocket fds[2];\n  std::unique_ptr<AlpnClient> client;\n  std::unique_ptr<AlpnServer> server;\n};\n\nTEST_F(NextProtocolTest, AlpnTestOverlap) {\n  clientCtx->setAdvertisedNextProtocols({\"blub\", \"baz\"});\n  serverCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n\n  connect();\n\n  expectProtocol(\"baz\");\n}\n\nTEST_F(NextProtocolTest, AlpnTestUnset) {\n  // Identical to above test, except that we want unset NPN before\n  // looping.\n  clientCtx->setAdvertisedNextProtocols({\"blub\", \"baz\"});\n  serverCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n\n  connect(true /* unset */);\n\n  expectNoProtocol();\n}\n\nTEST_F(NextProtocolTest, AlpnTestNoOverlap) {\n  clientCtx->setAdvertisedNextProtocols({\"blub\"});\n  serverCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n  connect();\n\n  expectNoProtocol();\n}\n\nTEST_F(NextProtocolTest, RandomizedAlpnTest) {\n  // Probability that this test will fail is 2^-64, which could be considered\n  // as negligible.\n  const int kTries = 64;\n\n  clientCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n  serverCtx->setRandomizedAdvertisedNextProtocols({{1, {\"foo\"}}, {1, {\"bar\"}}});\n\n  std::set<string> selectedProtocols;\n  for (int i = 0; i < kTries; ++i) {\n    connect();\n\n    EXPECT_NE(client->nextProtoLength, 0);\n    EXPECT_EQ(client->nextProtoLength, server->nextProtoLength);\n    EXPECT_EQ(\n        memcmp(client->nextProto, server->nextProto, server->nextProtoLength),\n        0);\n    string selected((const char*)client->nextProto, client->nextProtoLength);\n    selectedProtocols.insert(selected);\n    expectHandshakeSuccess();\n  }\n  EXPECT_EQ(selectedProtocols.size(), 2);\n}\n#endif\n\n#ifndef OPENSSL_NO_TLSEXT\n/**\n * 1. Client sends TLSEXT_HOSTNAME in client hello.\n * 2. Server found a match SSL_CTX and use this SSL_CTX to\n *    continue the SSL handshake.\n * 3. Server sends back TLSEXT_HOSTNAME in server hello.\n */\nTEST(AsyncSSLSocketTest, SNITestMatch) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string serverName(\"xyz.newdev.facebook.com\");\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], serverName));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock), dfServerCtx, hskServerCtx, serverName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.serverNameMatch);\n  EXPECT_TRUE(server.serverNameMatch);\n}\n\n/**\n * 1. Client sends TLSEXT_HOSTNAME in client hello.\n * 2. Server cannot find a matching SSL_CTX and continue to use\n *    the current SSL_CTX to do the handshake.\n * 3. Server does not send back TLSEXT_HOSTNAME in server hello.\n */\nTEST(AsyncSSLSocketTest, SNITestNotMatch) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string clientRequestingServerName(\"foo.com\");\n  const std::string serverExpectedServerName(\"xyz.newdev.facebook.com\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(new AsyncSSLSocket(\n      clientCtx, &eventBase, fds[0], clientRequestingServerName));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock),\n      dfServerCtx,\n      hskServerCtx,\n      serverExpectedServerName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.serverNameMatch);\n  EXPECT_TRUE(!server.serverNameMatch);\n}\n/**\n * 1. Client sends TLSEXT_HOSTNAME in client hello.\n * 2. We then change the serverName.\n * 3. We expect that we get 'false' as the result for serNameMatch.\n */\n\nTEST(AsyncSSLSocketTest, SNITestChangeServerName) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string serverName(\"xyz.newdev.facebook.com\");\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], serverName));\n  // Change the server name\n  std::string newName(\"new.com\");\n  clientSock->setServerName(newName);\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock), dfServerCtx, hskServerCtx, serverName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.serverNameMatch);\n}\n\n/**\n * 1. Client does not send TLSEXT_HOSTNAME in client hello.\n * 2. Server does not send back TLSEXT_HOSTNAME in server hello.\n */\nTEST(AsyncSSLSocketTest, SNITestClientHelloNoHostname) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string serverExpectedServerName(\"xyz.newdev.facebook.com\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock),\n      dfServerCtx,\n      hskServerCtx,\n      serverExpectedServerName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.serverNameMatch);\n  EXPECT_TRUE(!server.serverNameMatch);\n}\n\n#endif\n/**\n * Test SSL client socket\n */\nTEST(AsyncSSLSocketTest, SSLClientTest) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallbackDelay acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL client\n  EventBase eventBase;\n  auto client = std::make_shared<SSLClient>(&eventBase, server.getAddress(), 1);\n\n  client->connect();\n  EventBaseAborter eba(&eventBase, 3000);\n  eventBase.loop();\n\n  EXPECT_EQ(client->getMiss(), 1);\n  EXPECT_EQ(client->getHit(), 0);\n\n  cerr << \"SSLClientTest test completed\" << endl;\n}\n\n/**\n * Test SSL client socket session re-use\n */\nTEST(AsyncSSLSocketTest, SSLClientTestReuse) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallbackDelay acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL client\n  EventBase eventBase;\n  auto client =\n      std::make_shared<SSLClient>(&eventBase, server.getAddress(), 10);\n\n  client->connect();\n  EventBaseAborter eba(&eventBase, 3000);\n  eventBase.loop();\n\n  EXPECT_EQ(client->getMiss(), 1);\n  EXPECT_EQ(client->getHit(), 9);\n\n  cerr << \"SSLClientTestReuse test completed\" << endl;\n}\n\n/**\n * Test SSL client socket timeout\n */\nTEST(AsyncSSLSocketTest, SSLClientTimeoutTest) {\n  // Start listening on a local port\n  EmptyReadCallback readCallback;\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  HandshakeTimeoutCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL client\n  EventBase eventBase;\n  auto client =\n      std::make_shared<SSLClient>(&eventBase, server.getAddress(), 1, 10);\n  client->connect(true /* write before connect completes */);\n  EventBaseAborter eba(&eventBase, 3000);\n  eventBase.loop();\n\n  usleep(100000);\n  // This is checking that the connectError callback precedes any queued\n  // writeError callbacks.  This matches AsyncSocket's behavior\n  EXPECT_EQ(client->getWriteAfterConnectErrors(), 1);\n  EXPECT_EQ(client->getErrors(), 1);\n  EXPECT_EQ(client->getMiss(), 0);\n  EXPECT_EQ(client->getHit(), 0);\n\n  cerr << \"SSLClientTimeoutTest test completed\" << endl;\n}\n\n/**\n * Verify Client Ciphers obtained using SSL MSG Callback.\n */\nTEST(AsyncSSLSocketTest, SSLParseClientHelloSuccess) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  serverCtx->ciphers(\"ECDHE-RSA-AES128-SHA:AES128-SHA:AES256-SHA\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"AES256-SHA:AES128-SHA\");\n  clientCtx->loadPrivateKey(kTestKey);\n  clientCtx->loadCertificate(kTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServerParseClientHello server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n#if defined(OPENSSL_IS_BORINGSSL)\n  EXPECT_EQ(server.clientCiphers_, \"AES256-SHA:AES128-SHA\");\n#else\n  EXPECT_EQ(server.clientCiphers_, \"AES256-SHA:AES128-SHA:00ff\");\n#endif\n  EXPECT_EQ(server.chosenCipher_, \"AES256-SHA\");\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_TRUE(server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n}\n\n/**\n * Verify that server is able to get client cert by getPeerCert() API.\n */\nTEST(AsyncSSLSocketTest, GetClientCertificate) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  serverCtx->ciphers(\"ECDHE-RSA-AES128-SHA:AES128-SHA:AES256-SHA\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kClientTestCA);\n  serverCtx->loadClientCAList(kClientTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"AES256-SHA:AES128-SHA\");\n  clientCtx->loadPrivateKey(kClientTestKey);\n  clientCtx->loadCertificate(kClientTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServerParseClientHello server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  // Handshake should succeed.\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n\n  // Reclaim the sockets from SSLHandshakeBase.\n  auto cliSocket = std::move(client).moveSocket();\n  auto srvSocket = std::move(server).moveSocket();\n\n  // Client cert retrieved from server side.\n  auto serverPeerCert = srvSocket->getPeerCertificate();\n  CHECK(serverPeerCert);\n\n  // Client cert retrieved from client side.\n  auto clientSelfCert = cliSocket->getSelfCertificate();\n  CHECK(clientSelfCert);\n\n  auto serverX509 = serverPeerCert->getX509();\n  auto clientX509 = clientSelfCert->getX509();\n  CHECK(serverX509);\n  CHECK(clientX509);\n\n  // The two certs should be the same.\n  EXPECT_EQ(0, X509_cmp(clientX509.get(), serverX509.get()));\n}\n\nTEST(AsyncSSLSocketTest, SSLParseClientHelloOnePacket) {\n  EventBase eventBase;\n  auto ctx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  int bufLen = 42;\n  uint8_t majorVersion = 18;\n  uint8_t minorVersion = 25;\n\n  // Create callback buf\n  auto buf = IOBuf::create(bufLen);\n  buf->append(bufLen);\n  folly::io::RWPrivateCursor cursor(buf.get());\n  cursor.write<uint8_t>(SSL3_MT_CLIENT_HELLO);\n  cursor.write<uint16_t>(0);\n  cursor.write<uint8_t>(38);\n  cursor.write<uint8_t>(majorVersion);\n  cursor.write<uint8_t>(minorVersion);\n  cursor.skip(32);\n  cursor.write<uint32_t>(0);\n\n  SSL* ssl = ctx->createSSL();\n  SCOPE_EXIT {\n    SSL_free(ssl);\n  };\n  AsyncSSLSocket::UniquePtr sock(\n      new AsyncSSLSocket(ctx, &eventBase, fds[0], true));\n  sock->enableClientHelloParsing();\n\n  // Test client hello parsing in one packet\n  AsyncSSLSocket::clientHelloParsingCallback(\n      0, 0, SSL3_RT_HANDSHAKE, buf->data(), buf->length(), ssl, sock.get());\n  buf.reset();\n\n  auto parsedClientHello = sock->getClientHelloInfo();\n  EXPECT_TRUE(parsedClientHello != nullptr);\n  EXPECT_EQ(parsedClientHello->clientHelloMajorVersion_, majorVersion);\n  EXPECT_EQ(parsedClientHello->clientHelloMinorVersion_, minorVersion);\n}\n\nTEST(AsyncSSLSocketTest, SSLParseClientHelloTwoPackets) {\n  EventBase eventBase;\n  auto ctx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  int bufLen = 42;\n  uint8_t majorVersion = 18;\n  uint8_t minorVersion = 25;\n\n  // Create callback buf\n  auto buf = IOBuf::create(bufLen);\n  buf->append(bufLen);\n  folly::io::RWPrivateCursor cursor(buf.get());\n  cursor.write<uint8_t>(SSL3_MT_CLIENT_HELLO);\n  cursor.write<uint16_t>(0);\n  cursor.write<uint8_t>(38);\n  cursor.write<uint8_t>(majorVersion);\n  cursor.write<uint8_t>(minorVersion);\n  cursor.skip(32);\n  cursor.write<uint32_t>(0);\n\n  SSL* ssl = ctx->createSSL();\n  SCOPE_EXIT {\n    SSL_free(ssl);\n  };\n  AsyncSSLSocket::UniquePtr sock(\n      new AsyncSSLSocket(ctx, &eventBase, fds[0], true));\n  sock->enableClientHelloParsing();\n\n  // Test parsing with two packets with first packet size < 3\n  auto bufCopy = folly::IOBuf::copyBuffer(buf->data(), 2);\n  AsyncSSLSocket::clientHelloParsingCallback(\n      0,\n      0,\n      SSL3_RT_HANDSHAKE,\n      bufCopy->data(),\n      bufCopy->length(),\n      ssl,\n      sock.get());\n  bufCopy.reset();\n  bufCopy = folly::IOBuf::copyBuffer(buf->data() + 2, buf->length() - 2);\n  AsyncSSLSocket::clientHelloParsingCallback(\n      0,\n      0,\n      SSL3_RT_HANDSHAKE,\n      bufCopy->data(),\n      bufCopy->length(),\n      ssl,\n      sock.get());\n  bufCopy.reset();\n\n  auto parsedClientHello = sock->getClientHelloInfo();\n  EXPECT_TRUE(parsedClientHello != nullptr);\n  EXPECT_EQ(parsedClientHello->clientHelloMajorVersion_, majorVersion);\n  EXPECT_EQ(parsedClientHello->clientHelloMinorVersion_, minorVersion);\n}\n\nTEST(AsyncSSLSocketTest, SSLParseClientHelloMultiplePackets) {\n  EventBase eventBase;\n  auto ctx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  int bufLen = 42;\n  uint8_t majorVersion = 18;\n  uint8_t minorVersion = 25;\n\n  // Create callback buf\n  auto buf = IOBuf::create(bufLen);\n  buf->append(bufLen);\n  folly::io::RWPrivateCursor cursor(buf.get());\n  cursor.write<uint8_t>(SSL3_MT_CLIENT_HELLO);\n  cursor.write<uint16_t>(0);\n  cursor.write<uint8_t>(38);\n  cursor.write<uint8_t>(majorVersion);\n  cursor.write<uint8_t>(minorVersion);\n  cursor.skip(32);\n  cursor.write<uint32_t>(0);\n\n  SSL* ssl = ctx->createSSL();\n  SCOPE_EXIT {\n    SSL_free(ssl);\n  };\n  AsyncSSLSocket::UniquePtr sock(\n      new AsyncSSLSocket(ctx, &eventBase, fds[0], true));\n  sock->enableClientHelloParsing();\n\n  // Test parsing with multiple small packets\n  for (std::size_t i = 0; i < buf->length(); i += 3) {\n    auto bufCopy = folly::IOBuf::copyBuffer(\n        buf->data() + i, std::min((std::size_t)3, buf->length() - i));\n    AsyncSSLSocket::clientHelloParsingCallback(\n        0,\n        0,\n        SSL3_RT_HANDSHAKE,\n        bufCopy->data(),\n        bufCopy->length(),\n        ssl,\n        sock.get());\n    bufCopy.reset();\n  }\n\n  auto parsedClientHello = sock->getClientHelloInfo();\n  EXPECT_TRUE(parsedClientHello != nullptr);\n  EXPECT_EQ(parsedClientHello->clientHelloMajorVersion_, majorVersion);\n  EXPECT_EQ(parsedClientHello->clientHelloMinorVersion_, minorVersion);\n}\n\n/**\n * Verify sucessful behavior of SSL certificate validation.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationSuccess) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the client's verification callback is able to fail SSL\n * connection establishment.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationFailure) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, false);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(!client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(!server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the options in SSLContext can be overridden in\n * sslConnect/Accept.i.e specifying that no validation should be performed\n * allows an otherwise-invalid certificate to be accepted and doesn't fire\n * the validation callback.\n */\nTEST(AsyncSSLSocketTest, OverrideSSLCtxDisableVerify) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClientNoVerify client(std::move(clientSock), false, false);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  SSLHandshakeServerNoVerify server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the options in SSLContext can be overridden in\n * sslConnect/Accept. Enable verification even if context says otherwise.\n * Test requireClientCert with client cert\n */\nTEST(AsyncSSLSocketTest, OverrideSSLCtxEnableVerify) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadPrivateKey(kTestKey);\n  clientCtx->loadCertificate(kTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClientDoVerify client(std::move(clientSock), true, true);\n  SSLHandshakeServerDoVerify server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the client's verification callback is able to override\n * the preverification failure and allow a successful connection.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationOverride) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that specifying that no validation should be performed allows an\n * otherwise-invalid certificate to be accepted and doesn't fire the validation\n * callback.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationSkip) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Test requireClientCert with client cert\n */\nTEST(AsyncSSLSocketTest, ClientCertHandshakeSuccess) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(\n      SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadPrivateKey(kTestKey);\n  clientCtx->loadCertificate(kTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n\n  // check certificates\n  auto clientSsl = std::move(client).moveSocket();\n  auto serverSsl = std::move(server).moveSocket();\n\n  auto clientPeer = clientSsl->getPeerCertificate();\n  auto clientSelf = clientSsl->getSelfCertificate();\n  auto serverPeer = serverSsl->getPeerCertificate();\n  auto serverSelf = serverSsl->getSelfCertificate();\n\n  EXPECT_NE(clientPeer, nullptr);\n  EXPECT_NE(clientSelf, nullptr);\n  EXPECT_NE(serverPeer, nullptr);\n  EXPECT_NE(serverSelf, nullptr);\n\n  EXPECT_EQ(clientPeer->getIdentity(), serverSelf->getIdentity());\n  EXPECT_EQ(clientSelf->getIdentity(), serverPeer->getIdentity());\n}\n\n/**\n * Test requireClientCert with no client cert\n */\nTEST(AsyncSSLSocketTest, NoClientCertHandshakeError) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(\n      SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_FALSE(server.handshakeVerify_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Test OpenSSL 1.1.0's async functionality\n */\n#if FOLLY_OPENSSL_IS_110\n\nstatic void makeNonBlockingPipe(int pipefds[2]) {\n  if (pipe(pipefds) != 0) {\n    throw std::runtime_error(\"Cannot create pipe\");\n  }\n  if (::fcntl(pipefds[0], F_SETFL, O_NONBLOCK) != 0) {\n    throw std::runtime_error(\"Cannot set pipe to nonblocking\");\n  }\n  if (::fcntl(pipefds[1], F_SETFL, O_NONBLOCK) != 0) {\n    throw std::runtime_error(\"Cannot set pipe to nonblocking\");\n  }\n}\n\n// Custom RSA private key encryption method\nstatic int kRSAExIndex = -1;\nstatic int kRSAEvbExIndex = -1;\nstatic int kRSASocketExIndex = -1;\nstatic constexpr StringPiece kEngineId = \"AsyncSSLSocketTest\";\n\nstatic int customRsaPrivEnc(\n    int flen,\n    const unsigned char* from,\n    unsigned char* to,\n    RSA* rsa,\n    int padding) {\n  LOG(INFO) << \"rsa_priv_enc\";\n  EventBase* asyncJobEvb =\n      reinterpret_cast<EventBase*>(RSA_get_ex_data(rsa, kRSAEvbExIndex));\n  CHECK(asyncJobEvb);\n\n  RSA* actualRSA = reinterpret_cast<RSA*>(RSA_get_ex_data(rsa, kRSAExIndex));\n  CHECK(actualRSA);\n\n  AsyncSSLSocket* socket = reinterpret_cast<AsyncSSLSocket*>(\n      RSA_get_ex_data(rsa, kRSASocketExIndex));\n\n  ASYNC_JOB* job = ASYNC_get_current_job();\n  if (job == nullptr) {\n    throw std::runtime_error(\"Expected call in job context\");\n  }\n  ASYNC_WAIT_CTX* waitctx = ASYNC_get_wait_ctx(job);\n  OSSL_ASYNC_FD pipefds[2] = {0, 0};\n  makeNonBlockingPipe(pipefds);\n  if (!ASYNC_WAIT_CTX_set_wait_fd(\n          waitctx, kEngineId.data(), pipefds[0], nullptr, nullptr)) {\n    throw std::runtime_error(\"Cannot set wait fd\");\n  }\n  int ret = 0;\n  int* retptr = &ret;\n\n  auto hand = folly::NetworkSocket::native_handle_type(pipefds[1]);\n  auto asyncPipeWriter = folly::AsyncPipeWriter::newWriter(\n      asyncJobEvb, folly::NetworkSocket(hand));\n\n  asyncJobEvb->runInEventBaseThread([retptr = retptr,\n                                     flen = flen,\n                                     from = from,\n                                     to = to,\n                                     padding = padding,\n                                     actualRSA = actualRSA,\n                                     writer = std::move(asyncPipeWriter),\n                                     socket = socket]() {\n    LOG(INFO) << \"Running job\";\n    if (socket) {\n      LOG(INFO) << \"Got a socket passed in, closing it...\";\n      socket->closeNow();\n    }\n    *retptr = RSA_meth_get_priv_enc(RSA_PKCS1_OpenSSL())(\n        flen, from, to, actualRSA, padding);\n    LOG(INFO) << \"Finished job, writing to pipe\";\n    uint8_t byte = *retptr > 0 ? 1 : 0;\n    writer->write(nullptr, &byte, 1);\n  });\n\n  LOG(INFO) << \"About to pause job\";\n\n  ASYNC_pause_job();\n  LOG(INFO) << \"Resumed job with ret: \" << ret;\n  return ret;\n}\n\nvoid rsaFree(void*, void* ptr, CRYPTO_EX_DATA*, int, long, void*) {\n  LOG(INFO) << \"RSA_free is called with ptr \" << std::hex << ptr;\n  if (ptr == nullptr) {\n    LOG(INFO) << \"Returning early from rsaFree because ptr is null\";\n    return;\n  }\n  RSA* rsa = (RSA*)ptr;\n  auto meth = RSA_get_method(rsa);\n  if (meth != RSA_get_default_method()) {\n    auto nonconst = const_cast<RSA_METHOD*>(meth);\n    RSA_meth_free(nonconst);\n    RSA_set_method(rsa, RSA_get_default_method());\n  }\n  RSA_free(rsa);\n}\n\nstruct RSAPointers {\n  RSA* actualrsa{nullptr};\n  RSA* dummyrsa{nullptr};\n  RSA_METHOD* meth{nullptr};\n};\n\ninline void RSAPointersFree(RSAPointers* p) {\n  if (p->meth && p->dummyrsa && RSA_get_method(p->dummyrsa) == p->meth) {\n    RSA_set_method(p->dummyrsa, RSA_get_default_method());\n  }\n\n  if (p->meth) {\n    LOG(INFO) << \"Freeing meth\";\n    RSA_meth_free(p->meth);\n  }\n\n  if (p->actualrsa) {\n    LOG(INFO) << \"Freeing actualrsa\";\n    RSA_free(p->actualrsa);\n  }\n\n  if (p->dummyrsa) {\n    LOG(INFO) << \"Freeing dummyrsa\";\n    RSA_free(p->dummyrsa);\n  }\n\n  delete p;\n}\n\nusing RSAPointersDeleter =\n    folly::static_function_deleter<RSAPointers, RSAPointersFree>;\n\nstd::unique_ptr<RSAPointers, RSAPointersDeleter>\nsetupCustomRSA(const char* certPath, const char* keyPath, EventBase* jobEvb) {\n  auto certPEM = getFileAsBuf(certPath);\n  auto keyPEM = getFileAsBuf(keyPath);\n\n  ssl::BioUniquePtr certBio(\n      BIO_new_mem_buf((void*)certPEM.data(), certPEM.size()));\n  ssl::BioUniquePtr keyBio(\n      BIO_new_mem_buf((void*)keyPEM.data(), keyPEM.size()));\n\n  ssl::X509UniquePtr cert(\n      PEM_read_bio_X509(certBio.get(), nullptr, nullptr, nullptr));\n  ssl::EvpPkeyUniquePtr evpPkey(\n      PEM_read_bio_PrivateKey(keyBio.get(), nullptr, nullptr, nullptr));\n  ssl::EvpPkeyUniquePtr publicEvpPkey(X509_get_pubkey(cert.get()));\n\n  std::unique_ptr<RSAPointers, RSAPointersDeleter> ret(new RSAPointers());\n\n  RSA* actualrsa = EVP_PKEY_get1_RSA(evpPkey.get());\n  LOG(INFO) << \"actualrsa ptr \" << std::hex << (void*)actualrsa;\n  RSA* dummyrsa = EVP_PKEY_get1_RSA(publicEvpPkey.get());\n  if (dummyrsa == nullptr) {\n    throw std::runtime_error(\"Couldn't get RSA cert public factors\");\n  }\n  RSA_METHOD* meth = RSA_meth_dup(RSA_get_default_method());\n  if (meth == nullptr || RSA_meth_set1_name(meth, \"Async RSA method\") == 0 ||\n      RSA_meth_set_priv_enc(meth, customRsaPrivEnc) == 0 ||\n      RSA_meth_set_flags(meth, RSA_METHOD_FLAG_NO_CHECK) == 0) {\n    throw std::runtime_error(\"Cannot create async RSA_METHOD\");\n  }\n  RSA_set_method(dummyrsa, meth);\n  RSA_set_flags(dummyrsa, RSA_FLAG_EXT_PKEY);\n\n  kRSAExIndex = RSA_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);\n  kRSAEvbExIndex = RSA_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);\n  kRSASocketExIndex =\n      RSA_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);\n  CHECK_NE(kRSAExIndex, -1);\n  CHECK_NE(kRSAEvbExIndex, -1);\n  CHECK_NE(kRSASocketExIndex, -1);\n  RSA_set_ex_data(dummyrsa, kRSAExIndex, actualrsa);\n  RSA_set_ex_data(dummyrsa, kRSAEvbExIndex, jobEvb);\n\n  ret->actualrsa = actualrsa;\n  ret->dummyrsa = dummyrsa;\n  ret->meth = meth;\n\n  return ret;\n}\n\n// TODO: disabled with ASAN doesn't play nice with ASYNC for some reason\n#ifndef FOLLY_SANITIZE_ADDRESS\nTEST(AsyncSSLSocketTest, OpenSSL110AsyncTest) {\n  ASYNC_init_thread(1, 1);\n  EventBase eventBase;\n  ScopedEventBaseThread jobEvbThread;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  auto rsaPointers =\n      setupCustomRSA(kTestCert, kTestKey, jobEvbThread.getEventBase());\n  CHECK(rsaPointers->dummyrsa);\n  // up-refs dummyrsa\n  SSL_CTX_use_RSAPrivateKey(serverCtx->getSSLCtx(), rsaPointers->dummyrsa);\n  SSL_CTX_set_mode(serverCtx->getSSLCtx(), SSL_MODE_ASYNC);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  ASYNC_cleanup_thread();\n}\n\nTEST(AsyncSSLSocketTest, OpenSSL110AsyncTestFailure) {\n  ASYNC_init_thread(1, 1);\n  EventBase eventBase;\n  ScopedEventBaseThread jobEvbThread;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n  // Set the wrong key for the cert\n  auto rsaPointers =\n      setupCustomRSA(kTestCert, kClientTestKey, jobEvbThread.getEventBase());\n  CHECK(rsaPointers->dummyrsa);\n  SSL_CTX_use_RSAPrivateKey(serverCtx->getSSLCtx(), rsaPointers->dummyrsa);\n  SSL_CTX_set_mode(serverCtx->getSSLCtx(), SSL_MODE_ASYNC);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_TRUE(client.handshakeError_);\n  ASYNC_cleanup_thread();\n}\n\nTEST(AsyncSSLSocketTest, OpenSSL110AsyncTestClosedWithCallbackPending) {\n  ASYNC_init_thread(1, 1);\n  EventBase eventBase;\n  ScopedEventBaseThread jobEvbThread;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  auto rsaPointers =\n      setupCustomRSA(kTestCert, kTestKey, jobEvbThread.getEventBase());\n  CHECK(rsaPointers->dummyrsa);\n  // up-refs dummyrsa\n  SSL_CTX_use_RSAPrivateKey(serverCtx->getSSLCtx(), rsaPointers->dummyrsa);\n  SSL_CTX_set_mode(serverCtx->getSSLCtx(), SSL_MODE_ASYNC);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  RSA_set_ex_data(rsaPointers->dummyrsa, kRSASocketExIndex, serverSock.get());\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_TRUE(client.handshakeError_);\n  ASYNC_cleanup_thread();\n}\n#endif // FOLLY_SANITIZE_ADDRESS\n\n#endif // FOLLY_OPENSSL_IS_110\n\nTEST(AsyncSSLSocketTest, LoadCertFromMemory) {\n  using folly::ssl::OpenSSLUtils;\n  auto cert = getFileAsBuf(kTestCert);\n  auto key = getFileAsBuf(kTestKey);\n\n  ssl::BioUniquePtr certBio(BIO_new(BIO_s_mem()));\n  BIO_write(certBio.get(), cert.data(), cert.size());\n  ssl::BioUniquePtr keyBio(BIO_new(BIO_s_mem()));\n  BIO_write(keyBio.get(), key.data(), key.size());\n\n  // Create SSL structs from buffers to get properties\n  ssl::X509UniquePtr certStruct(\n      PEM_read_bio_X509(certBio.get(), nullptr, nullptr, nullptr));\n  ssl::EvpPkeyUniquePtr keyStruct(\n      PEM_read_bio_PrivateKey(keyBio.get(), nullptr, nullptr, nullptr));\n  certBio = nullptr;\n  keyBio = nullptr;\n\n  auto origCommonName = OpenSSLUtils::getCommonName(certStruct.get());\n  auto origKeySize = EVP_PKEY_bits(keyStruct.get());\n  certStruct = nullptr;\n  keyStruct = nullptr;\n\n  auto ctx = std::make_shared<SSLContext>();\n  ctx->loadPrivateKeyFromBufferPEM(key);\n  ctx->loadCertificateFromBufferPEM(cert);\n  ctx->loadTrustedCertificates(kTestCA);\n\n  ssl::SSLUniquePtr ssl(ctx->createSSL());\n\n  auto newCert = SSL_get_certificate(ssl.get());\n  auto newKey = SSL_get_privatekey(ssl.get());\n\n  // Get properties from SSL struct\n  auto newCommonName = OpenSSLUtils::getCommonName(newCert);\n  auto newKeySize = EVP_PKEY_bits(newKey);\n\n  // Check that the key and cert have the expected properties\n  EXPECT_EQ(origCommonName, newCommonName);\n  EXPECT_EQ(origKeySize, newKeySize);\n}\n\nTEST(AsyncSSLSocketTest, MinWriteSizeTest) {\n  EventBase eb;\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // create SSL socket\n  AsyncSSLSocket::UniquePtr socket(new AsyncSSLSocket(sslContext, &eb));\n\n  EXPECT_EQ(1500, socket->getMinWriteSize());\n\n  socket->setMinWriteSize(0);\n  EXPECT_EQ(0, socket->getMinWriteSize());\n  socket->setMinWriteSize(50000);\n  EXPECT_EQ(50000, socket->getMinWriteSize());\n}\n\nclass ReadCallbackTerminator : public ReadCallback {\n public:\n  ReadCallbackTerminator(EventBase* base, WriteCallbackBase* wcb)\n      : ReadCallback(wcb), base_(base) {}\n\n  // Do not write data back, terminate the loop.\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n\n    socket_->setReadCB(nullptr);\n    base_->terminateLoopSoon();\n  }\n\n private:\n  EventBase* base_;\n};\n\n/**\n * Test a full unencrypted codepath\n */\nTEST(AsyncSSLSocketTest, UnencryptedTest) {\n  EventBase base;\n\n  auto clientCtx = std::make_shared<folly::SSLContext>();\n  auto serverCtx = std::make_shared<folly::SSLContext>();\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, serverCtx);\n  auto client =\n      AsyncSSLSocket::newSocket(clientCtx, &base, fds[0], false, true);\n  auto server = AsyncSSLSocket::newSocket(serverCtx, &base, fds[1], true, true);\n\n  ReadCallbackTerminator readCallback(&base, nullptr);\n  server->setReadCB(&readCallback);\n  readCallback.setSocket(server);\n\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  client->write(nullptr, buf, sizeof(buf));\n\n  // Check that bytes are unencrypted\n  char c;\n  EXPECT_EQ(1, netops::recv(fds[1], &c, 1, MSG_PEEK));\n  EXPECT_EQ('a', c);\n\n  EventBaseAborter eba(&base, 3000);\n  base.loop();\n\n  EXPECT_EQ(1, readCallback.buffers.size());\n  EXPECT_EQ(AsyncSSLSocket::STATE_UNENCRYPTED, client->getSSLState());\n\n  server->setReadCB(&readCallback);\n\n  // Unencrypted\n  server->sslAccept(nullptr);\n  client->sslConn(nullptr);\n\n  // Do NOT wait for handshake, writing should be queued and happen after\n\n  client->write(nullptr, buf, sizeof(buf));\n\n  // Check that bytes are *not* unencrypted\n  char c2;\n  EXPECT_EQ(1, netops::recv(fds[1], &c2, 1, MSG_PEEK));\n  EXPECT_NE('a', c2);\n\n  base.loop();\n\n  EXPECT_EQ(2, readCallback.buffers.size());\n  EXPECT_EQ(AsyncSSLSocket::STATE_ESTABLISHED, client->getSSLState());\n}\n\nTEST(AsyncSSLSocketTest, ConnectUnencryptedTest) {\n  auto clientCtx = std::make_shared<folly::SSLContext>();\n  auto serverCtx = std::make_shared<folly::SSLContext>();\n  getctx(clientCtx, serverCtx);\n\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  EventBase evb;\n  std::shared_ptr<AsyncSSLSocket> socket =\n      AsyncSSLSocket::newSocket(clientCtx, &evb, true);\n  socket->connect(nullptr, server.getAddress(), 0);\n\n  evb.loop();\n\n  EXPECT_EQ(AsyncSSLSocket::STATE_UNENCRYPTED, socket->getSSLState());\n  socket->sslConn(nullptr);\n  evb.loop();\n  EXPECT_EQ(AsyncSSLSocket::STATE_ESTABLISHED, socket->getSSLState());\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(nullptr, buf.data(), buf.size());\n\n  socket->close();\n}\n\n/**\n * Test acceptrunner in various situations\n */\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerBasic) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  serverCtx->sslAcceptRunner(std::make_unique<SSLAcceptEvbRunner>(&eventBase));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerAcceptError) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptErrorRunner>(&eventBase));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_FALSE(client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerAcceptClose) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptCloseRunner>(&eventBase, serverSock.get()));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_FALSE(client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerAcceptDestroy) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptDestroyRunner>(&eventBase, &server));\n\n  eventBase.loop();\n\n  EXPECT_FALSE(client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerFiber) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptFiberRunner>(&eventBase));\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n}\n\nstatic int newCloseCb(SSL* ssl, SSL_SESSION*) {\n  AsyncSSLSocket::getFromSSL(ssl)->closeNow();\n  return 1;\n}\n\n#if FOLLY_OPENSSL_IS_110\nstatic SSL_SESSION* getCloseCb(SSL* ssl, const unsigned char*, int, int*) {\n#else\nstatic SSL_SESSION* getCloseCb(SSL* ssl, unsigned char*, int, int*) {\n#endif\n  AsyncSSLSocket::getFromSSL(ssl)->closeNow();\n  return nullptr;\n} // namespace folly\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerFiberCloseSessionCb) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  SSL_CTX_set_session_cache_mode(\n      serverCtx->getSSLCtx(),\n      SSL_SESS_CACHE_NO_INTERNAL | SSL_SESS_CACHE_SERVER);\n  SSL_CTX_sess_set_new_cb(serverCtx->getSSLCtx(), &newCloseCb);\n  SSL_CTX_sess_set_get_cb(serverCtx->getSSLCtx(), &getCloseCb);\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptFiberRunner>(&eventBase));\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"AES128-SHA256\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n  clientCtx->setOptions(SSL_OP_NO_TICKET);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  // As close() is called during session callbacks, client sees it as a\n  // successful connection\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, ConnResetErrorString) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  auto socket = std::make_shared<BlockingSocket>(server.getAddress(), nullptr);\n  socket->open();\n  uint8_t buf[3] = {0x16, 0x03, 0x01};\n  socket->write(buf, sizeof(buf));\n  socket->closeWithReset();\n\n  handshakeCallback.waitForHandshake();\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"Network error\"), std::string::npos);\n  EXPECT_NE(handshakeCallback.errorString_.find(\"104\"), std::string::npos);\n}\n\nTEST(AsyncSSLSocketTest, ConnEOFErrorString) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  auto socket = std::make_shared<BlockingSocket>(server.getAddress(), nullptr);\n  socket->open();\n  uint8_t buf[3] = {0x16, 0x03, 0x01};\n  socket->write(buf, sizeof(buf));\n  socket->close();\n\n  handshakeCallback.waitForHandshake();\n#if FOLLY_OPENSSL_IS_110\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"Network error\"), std::string::npos);\n#else\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"Connection EOF\"), std::string::npos);\n#endif\n}\n\nTEST(AsyncSSLSocketTest, ConnOpenSSLErrorString) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  auto socket = std::make_shared<BlockingSocket>(server.getAddress(), nullptr);\n  socket->open();\n  uint8_t buf[256] = {0x16, 0x03};\n  memset(buf + 2, 'a', sizeof(buf) - 2);\n  socket->write(buf, sizeof(buf));\n  socket->close();\n\n  handshakeCallback.waitForHandshake();\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"SSL routines\"), std::string::npos);\n#if defined(OPENSSL_IS_BORINGSSL)\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"ENCRYPTED_LENGTH_TOO_LONG\"),\n      std::string::npos);\n#elif FOLLY_OPENSSL_IS_110\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"packet length too long\"),\n      std::string::npos);\n#else\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"unknown protocol\"),\n      std::string::npos);\n#endif\n}\n\nTEST(AsyncSSLSocketTest, TestSSLCipherCodeToNameMap) {\n  using folly::ssl::OpenSSLUtils;\n  EXPECT_EQ(\n      OpenSSLUtils::getCipherName(0xc02c), \"ECDHE-ECDSA-AES256-GCM-SHA384\");\n  // TLS_DHE_RSA_WITH_DES_CBC_SHA - We shouldn't be building with this\n  EXPECT_EQ(OpenSSLUtils::getCipherName(0x0015), \"\");\n  // This indicates TLS_EMPTY_RENEGOTIATION_INFO_SCSV, no name expected\n  EXPECT_EQ(OpenSSLUtils::getCipherName(0x00ff), \"\");\n}\n\n#if defined __linux__\n/**\n * Ensure TransparentTLS flag is disabled with AsyncSSLSocket\n */\nTEST(AsyncSSLSocketTest, TTLSDisabled) {\n  // clear all setsockopt tracking history\n  globalStatic.reset();\n\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, false);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  EXPECT_EQ(1, globalStatic.ttlsDisabledSet.count(socket->getNetworkSocket()));\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // close()\n  socket->close();\n}\n#endif\n\n#if FOLLY_ALLOW_TFO\n\nclass MockAsyncTFOSSLSocket : public AsyncSSLSocket {\n public:\n  using UniquePtr = std::unique_ptr<MockAsyncTFOSSLSocket, Destructor>;\n\n  explicit MockAsyncTFOSSLSocket(\n      std::shared_ptr<folly::SSLContext> sslCtx,\n      EventBase* evb)\n      : AsyncSocket(evb), AsyncSSLSocket(sslCtx, evb) {}\n\n  MOCK_METHOD3(\n      tfoSendMsg,\n      ssize_t(NetworkSocket fd, struct msghdr* msg, int msg_flags));\n};\n\n#if defined __linux__\n/**\n * Ensure TransparentTLS flag is disabled with AsyncSSLSocket + TFO\n */\nTEST(AsyncSSLSocketTest, TTLSDisabledWithTFO) {\n  // clear all setsockopt tracking history\n  globalStatic.reset();\n\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  socket->open();\n\n  EXPECT_EQ(1, globalStatic.ttlsDisabledSet.count(socket->getNetworkSocket()));\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // close()\n  socket->close();\n}\n#endif\n\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server with TFO.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadCloseTFO) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  socket->open();\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // read()\n  std::array<uint8_t, 128> readbuf;\n  uint32_t bytesRead = socket->readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf.data(), readbuf.data(), bytesRead), 0);\n\n  // close()\n  socket->close();\n}\n\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server with TFO.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadCloseTFOWithTFOServerDisabled) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, false);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  socket->open();\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // read()\n  std::array<uint8_t, 128> readbuf;\n  uint32_t bytesRead = socket->readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf.data(), readbuf.data(), bytesRead), 0);\n\n  // close()\n  socket->close();\n}\n\nclass ConnCallback : public AsyncSocket::ConnectCallback {\n public:\n  void connectSuccess() noexcept override {\n    state = State::SUCCESS;\n  }\n\n  void connectErr(const AsyncSocketException& ex) noexcept override {\n    state = State::ERROR;\n    error = ex.what();\n  }\n\n  enum class State { WAITING, SUCCESS, ERROR };\n\n  State state{State::WAITING};\n  std::string error;\n};\n\ntemplate <class Cardinality>\nMockAsyncTFOSSLSocket::UniquePtr setupSocketWithFallback(\n    EventBase* evb,\n    const SocketAddress& address,\n    Cardinality cardinality) {\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket = MockAsyncTFOSSLSocket::UniquePtr(\n      new MockAsyncTFOSSLSocket(sslContext, evb));\n  socket->enableTFO();\n\n  EXPECT_CALL(*socket, tfoSendMsg(_, _, _))\n      .Times(cardinality)\n      .WillOnce(Invoke([&](NetworkSocket fd, struct msghdr*, int) {\n        sockaddr_storage addr;\n        auto len = address.getAddress(&addr);\n        return netops::connect(fd, (const struct sockaddr*)&addr, len);\n      }));\n  return socket;\n}\n\nTEST(AsyncSSLSocketTest, ConnectWriteReadCloseTFOFallback) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  EventBase evb;\n\n  auto socket = setupSocketWithFallback(&evb, server.getAddress(), 1);\n  ConnCallback ccb;\n  socket->connect(&ccb, server.getAddress(), 30);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::SUCCESS, ccb.state);\n\n  evb.runInEventBaseThread([&] { socket->detachEventBase(); });\n  evb.loop();\n\n  BlockingSocket sock(std::move(socket));\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  sock.write(buf.data(), buf.size());\n\n  // read()\n  std::array<uint8_t, 128> readbuf;\n  uint32_t bytesRead = sock.readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf.data(), readbuf.data(), bytesRead), 0);\n\n  // close()\n  sock.close();\n}\n\n#if !defined(OPENSSL_IS_BORINGSSL)\nTEST(AsyncSSLSocketTest, ConnectTFOTimeout) {\n  // Start listening on a local port\n  ConnectTimeoutCallback acceptCallback;\n  TestSSLServer server(&acceptCallback, true);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  EXPECT_THROW(\n      socket->open(std::chrono::milliseconds(20)), AsyncSocketException);\n}\n#endif\n\n#if !defined(OPENSSL_IS_BORINGSSL)\nTEST(AsyncSSLSocketTest, ConnectTFOFallbackTimeout) {\n  // Start listening on a local port\n  ConnectTimeoutCallback acceptCallback;\n  TestSSLServer server(&acceptCallback, true);\n\n  EventBase evb;\n\n  auto socket = setupSocketWithFallback(&evb, server.getAddress(), AtMost(1));\n  ConnCallback ccb;\n  // Set a short timeout\n  socket->connect(&ccb, server.getAddress(), 1);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::ERROR, ccb.state);\n}\n#endif\n\nTEST(AsyncSSLSocketTest, HandshakeTFOFallbackTimeout) {\n  // Start listening on a local port\n  EmptyReadCallback readCallback;\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  HandshakeTimeoutCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  EventBase evb;\n\n  auto socket = setupSocketWithFallback(&evb, server.getAddress(), AtMost(1));\n  ConnCallback ccb;\n  socket->connect(&ccb, server.getAddress(), 100);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::ERROR, ccb.state);\n  EXPECT_THAT(ccb.error, testing::HasSubstr(\"SSL connect timed out\"));\n}\n\nTEST(AsyncSSLSocketTest, HandshakeTFORefused) {\n  // Start listening on a local port\n  EventBase evb;\n\n  // Hopefully nothing is listening on this address\n  SocketAddress addr(\"127.0.0.1\", 65535);\n  auto socket = setupSocketWithFallback(&evb, addr, AtMost(1));\n  ConnCallback ccb;\n  socket->connect(&ccb, addr, 100);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::ERROR, ccb.state);\n  EXPECT_THAT(ccb.error, testing::HasSubstr(\"refused\"));\n}\n\nTEST(AsyncSSLSocketTest, TestPreReceivedData) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSockPtr(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSockPtr(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  auto clientSock = clientSockPtr.get();\n  auto serverSock = serverSockPtr.get();\n  SSLHandshakeClient client(std::move(clientSockPtr), true, true);\n\n  // Steal some data from the server.\n  std::array<uint8_t, 10> buf;\n  auto bytesReceived = netops::recv(fds[1], buf.data(), buf.size(), 0);\n  checkUnixError(bytesReceived, \"recv failed\");\n\n  serverSock->setPreReceivedData(\n      IOBuf::wrapBuffer(ByteRange(buf.data(), bytesReceived)));\n  SSLHandshakeServer server(std::move(serverSockPtr), true, true);\n  while (!client.handshakeSuccess_ && !client.handshakeError_) {\n    eventBase.loopOnce();\n  }\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_EQ(\n      serverSock->getRawBytesReceived(), clientSock->getRawBytesWritten());\n}\n\nTEST(AsyncSSLSocketTest, TestMoveFromAsyncSocket) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSockPtr(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSocket::UniquePtr serverSockPtr(new AsyncSocket(&eventBase, fds[1]));\n  auto clientSock = clientSockPtr.get();\n  auto serverSock = serverSockPtr.get();\n  SSLHandshakeClient client(std::move(clientSockPtr), true, true);\n\n  // Steal some data from the server.\n  std::array<uint8_t, 10> buf;\n  auto bytesReceived = netops::recv(fds[1], buf.data(), buf.size(), 0);\n  checkUnixError(bytesReceived, \"recv failed\");\n\n  serverSock->setPreReceivedData(\n      IOBuf::wrapBuffer(ByteRange(buf.data(), bytesReceived)));\n  AsyncSSLSocket::UniquePtr serverSSLSockPtr(\n      new AsyncSSLSocket(dfServerCtx, std::move(serverSockPtr), true));\n  auto serverSSLSock = serverSSLSockPtr.get();\n  SSLHandshakeServer server(std::move(serverSSLSockPtr), true, true);\n  while (!client.handshakeSuccess_ && !client.handshakeError_) {\n    eventBase.loopOnce();\n  }\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_EQ(\n      serverSSLSock->getRawBytesReceived(), clientSock->getRawBytesWritten());\n}\n\n/**\n * Test overriding the flags passed to \"sendmsg()\" system call,\n * and verifying that write requests fail properly.\n */\nTEST(AsyncSSLSocketTest, SendMsgParamsCallback) {\n  // Start listening on a local port\n  SendMsgFlagsCallback msgCallback;\n  ExpectWriteErrorCallback writeCallback(&msgCallback);\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // Setting flags to \"-1\" to trigger \"Invalid argument\" error\n  // on attempt to use this flags in sendmsg() system call.\n  msgCallback.resetFlags(-1);\n\n  // write()\n  std::vector<uint8_t> buf(128, 'a');\n  ASSERT_EQ(socket->write(buf.data(), buf.size()), buf.size());\n\n  // close()\n  socket->close();\n\n  cerr << \"SendMsgParamsCallback test completed\" << endl;\n}\n\n#ifdef FOLLY_HAVE_MSG_ERRQUEUE\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server with ancillary data from the application.\n */\nTEST(AsyncSSLSocketTest, SendMsgDataCallback) {\n  // This test requires Linux kernel v4.6 or later\n  struct utsname s_uname;\n  memset(&s_uname, 0, sizeof(s_uname));\n  ASSERT_EQ(uname(&s_uname), 0);\n  int major, minor;\n  folly::StringPiece extra;\n  if (folly::split<false>(\n          '.', std::string(s_uname.release) + \".\", major, minor, extra)) {\n    if (major < 4 || (major == 4 && minor < 6)) {\n      LOG(INFO) << \"Kernel version: 4.6 and newer required for this test (\"\n                << \"kernel ver. \" << s_uname.release << \" detected).\";\n      return;\n    }\n  }\n\n  // Start listening on a local port\n  SendMsgAncillaryDataCallback msgCallback;\n  WriteCheckTimestampCallback writeCallback(&msgCallback);\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // we'll pass the EOR and TIMESTAMP_TX flags with the write back\n  // EOR tracking must be enabled for WriteFlags be passed\n  const auto writeFlags =\n      folly::WriteFlags::EOR | folly::WriteFlags::TIMESTAMP_TX;\n  readCallback.setWriteFlags(writeFlags);\n  msgCallback.setEorTracking(true);\n\n  // Init ancillary data buffer to trigger timestamp notification\n  //\n  // We generate the same ancillary data regardless of the specific WriteFlags,\n  // we verify that the WriteFlags are observed as expected below.\n  union {\n    uint8_t ctrl_data[CMSG_LEN(sizeof(uint32_t))];\n    struct cmsghdr cmsg;\n  } u;\n  u.cmsg.cmsg_level = SOL_SOCKET;\n  u.cmsg.cmsg_type = SO_TIMESTAMPING;\n  u.cmsg.cmsg_len = CMSG_LEN(sizeof(uint32_t));\n  uint32_t flags = SOF_TIMESTAMPING_TX_SCHED | SOF_TIMESTAMPING_TX_SOFTWARE |\n      SOF_TIMESTAMPING_TX_ACK;\n  memcpy(CMSG_DATA(&u.cmsg), &flags, sizeof(uint32_t));\n  std::vector<char> ctrl(CMSG_LEN(sizeof(uint32_t)));\n  memcpy(ctrl.data(), u.ctrl_data, CMSG_LEN(sizeof(uint32_t)));\n  msgCallback.resetData(std::move(ctrl));\n\n  // write(), including flags\n  std::vector<uint8_t> buf(128, 'a');\n  socket->write(buf.data(), buf.size(), writeFlags);\n\n  // read()\n  std::vector<uint8_t> readbuf(buf.size());\n  uint32_t bytesRead = socket->readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, buf.size());\n  EXPECT_TRUE(std::equal(buf.begin(), buf.end(), readbuf.begin()));\n\n  // should receive three timestamps (schedule, TX/SND, ACK)\n  // may take some time for all to arrive, so loop to wait\n  //\n  // socket error queue does not have the equivalent of an EOF, so we must\n  // loop on it unless we want to use libevent for this test...\n  const std::vector<int32_t> timestampsExpected = {\n      SCM_TSTAMP_SCHED, SCM_TSTAMP_SND, SCM_TSTAMP_ACK};\n  std::vector<int32_t> timestampsReceived;\n  while (timestampsExpected.size() != timestampsReceived.size()) {\n    const auto timestamps = writeCallback.getTimestampNotifications();\n    timestampsReceived.insert(\n        timestampsReceived.end(), timestamps.begin(), timestamps.end());\n  }\n  EXPECT_THAT(timestampsReceived, ElementsAreArray(timestampsExpected));\n\n  // check the observed write flags\n  EXPECT_EQ(\n      static_cast<std::underlying_type<folly::WriteFlags>::type>(\n          msgCallback.getObservedWriteFlags()),\n      static_cast<std::underlying_type<folly::WriteFlags>::type>(writeFlags));\n\n  // close()\n  socket->close();\n  cerr << \"SendMsgDataCallback test completed\" << endl;\n}\n#endif // FOLLY_HAVE_MSG_ERRQUEUE\n\n#endif\n\nTEST(AsyncSSLSocketTest, TestSNIClientHelloBehavior) {\n  EventBase eventBase;\n  auto serverCtx = std::make_shared<SSLContext>();\n  auto clientCtx = std::make_shared<SSLContext>();\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setSessionCacheContext(\"test context\");\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  SSL_SESSION* resumptionSession = nullptr;\n\n  {\n    std::array<NetworkSocket, 2> fds;\n    getfds(fds.data());\n\n    AsyncSSLSocket::UniquePtr clientSock(\n        new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n    AsyncSSLSocket::UniquePtr serverSock(\n        new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n    // Client sends SNI that doesn't match anything the server cert advertises\n    clientSock->setServerName(\"Foobar\");\n\n    SSLHandshakeServerParseClientHello server(\n        std::move(serverSock), true, true);\n    SSLHandshakeClient client(std::move(clientSock), true, true);\n    eventBase.loop();\n\n    serverSock = std::move(server).moveSocket();\n    auto chi = serverSock->getClientHelloInfo();\n    ASSERT_NE(chi, nullptr);\n    EXPECT_EQ(\n        std::string(\"Foobar\"), std::string(serverSock->getSSLServerName()));\n\n    // create another client, resuming with the prior session, but under a\n    // different common name.\n    clientSock = std::move(client).moveSocket();\n    resumptionSession = clientSock->getSSLSession();\n  }\n\n  {\n    std::array<NetworkSocket, 2> fds;\n    getfds(fds.data());\n\n    AsyncSSLSocket::UniquePtr clientSock(\n        new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n    AsyncSSLSocket::UniquePtr serverSock(\n        new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n    clientSock->setSSLSession(resumptionSession, true);\n    clientSock->setServerName(\"Baz\");\n    SSLHandshakeServerParseClientHello server(\n        std::move(serverSock), true, true);\n    SSLHandshakeClient client(std::move(clientSock), true, true);\n    eventBase.loop();\n\n    serverSock = std::move(server).moveSocket();\n    clientSock = std::move(client).moveSocket();\n    EXPECT_TRUE(clientSock->getSSLSessionReused());\n\n    // OpenSSL 1.1.1 changes the semantics of SSL_get_servername\n    // in\n    // https://github.com/openssl/openssl/commit/1c4aa31d79821dee9be98e915159d52cc30d8403\n    //\n    // Previously, the SNI would be taken from the ClientHello.\n    // Now, the SNI will be taken from the established session.\n    //\n    // But the session that was established with the client (prior handshake)\n    // would not have set the server name field because the SNI that the client\n    // requested (\"Foobar\") did not match any of the SANs that the server was\n    // presenting (\"127.0.0.1\")\n    //\n    // To preserve this 1.1.0 behavior, getSSLServerName() should return the\n    // parsed ClientHello servername. This test asserts this behavior.\n    auto sni = serverSock->getSSLServerName();\n    ASSERT_NE(sni, nullptr);\n\n    std::string sniStr(sni);\n    EXPECT_EQ(sniStr, std::string(\"Baz\"));\n  }\n}\n} // namespace folly\n\n#ifdef SIGPIPE\n///////////////////////////////////////////////////////////////////////////\n// init_unit_test_suite\n///////////////////////////////////////////////////////////////////////////\nnamespace {\nstruct Initializer {\n  Initializer() {\n    signal(SIGPIPE, SIG_IGN);\n  }\n};\nInitializer initializer;\n} // namespace\n#endif\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n#include <signal.h>\n\n#include <folly/ExceptionWrapper.h>\n#include <folly/SocketAddress.h>\n#include <folly/experimental/TestUtil.h>\n#include <folly/fibers/FiberManagerMap.h>\n#include <folly/io/async/AsyncSSLSocket.h>\n#include <folly/io/async/AsyncServerSocket.h>\n#include <folly/io/async/AsyncSocket.h>\n#include <folly/io/async/AsyncTimeout.h>\n#include <folly/io/async/AsyncTransport.h>\n#include <folly/io/async/EventBase.h>\n#include <folly/io/async/ssl/SSLErrors.h>\n#include <folly/io/async/test/TestSSLServer.h>\n#include <folly/portability/GTest.h>\n#include <folly/portability/PThread.h>\n#include <folly/portability/Sockets.h>\n#include <folly/portability/Unistd.h>\n\n#include <fcntl.h>\n#include <sys/types.h>\n#include <condition_variable>\n#include <iostream>\n#include <list>\n#include <memory>\n\nnamespace folly {\n\n// The destructors of all callback classes assert that the state is\n// STATE_SUCCEEDED, for both possitive and negative tests. The tests\n// are responsible for setting the succeeded state properly before the\n// destructors are called.\n\nclass SendMsgParamsCallbackBase\n    : public folly::AsyncSocket::SendMsgParamsCallback {\n public:\n  SendMsgParamsCallbackBase() {}\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n    oldCallback_ = socket_->getSendMsgParamsCB();\n    socket_->setSendMsgParamCB(this);\n    socket_->setEorTracking(trackEor_);\n  }\n\n  void setEorTracking(bool track) {\n    CHECK(!socket_); // should only be called during setup\n    trackEor_ = track;\n  }\n\n  int getFlagsImpl(\n      folly::WriteFlags flags,\n      int /*defaultFlags*/) noexcept override {\n    return oldCallback_->getFlags(flags, false /*zeroCopyEnabled*/);\n  }\n\n  void getAncillaryData(folly::WriteFlags flags, void* data) noexcept override {\n    oldCallback_->getAncillaryData(flags, data);\n  }\n\n  uint32_t getAncillaryDataSize(folly::WriteFlags flags) noexcept override {\n    return oldCallback_->getAncillaryDataSize(flags);\n  }\n\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  bool trackEor_{false};\n  folly::AsyncSocket::SendMsgParamsCallback* oldCallback_{nullptr};\n};\n\nclass SendMsgFlagsCallback : public SendMsgParamsCallbackBase {\n public:\n  SendMsgFlagsCallback() {}\n\n  void resetFlags(int flags) {\n    flags_ = flags;\n  }\n\n  int getFlagsImpl(\n      folly::WriteFlags flags,\n      int /*defaultFlags*/) noexcept override {\n    if (flags_) {\n      return flags_;\n    } else {\n      return oldCallback_->getFlags(flags, false /*zeroCopyEnabled*/);\n    }\n  }\n\n  int flags_{0};\n};\n\nclass SendMsgAncillaryDataCallback : public SendMsgParamsCallbackBase {\n public:\n  SendMsgAncillaryDataCallback() {}\n\n  /**\n   * This data will be returned on calls to getAncillaryData.\n   */\n  void resetData(std::vector<char>&& data) {\n    ancillaryData_.swap(data);\n  }\n\n  /**\n   * These flags were observed on the last call to getAncillaryData.\n   */\n  folly::WriteFlags getObservedWriteFlags() {\n    return observedWriteFlags_;\n  }\n\n  void getAncillaryData(folly::WriteFlags flags, void* data) noexcept override {\n    // getAncillaryData is called through a long chain of functions after send\n    // record the observed write flags so we can compare later\n    observedWriteFlags_ = flags;\n\n    if (ancillaryData_.size()) {\n      std::cerr << \"getAncillaryData: copying data\" << std::endl;\n      memcpy(data, ancillaryData_.data(), ancillaryData_.size());\n    } else {\n      oldCallback_->getAncillaryData(flags, data);\n    }\n  }\n\n  uint32_t getAncillaryDataSize(folly::WriteFlags flags) noexcept override {\n    if (ancillaryData_.size()) {\n      std::cerr << \"getAncillaryDataSize: returning size\" << std::endl;\n      return ancillaryData_.size();\n    } else {\n      return oldCallback_->getAncillaryDataSize(flags);\n    }\n  }\n\n  folly::WriteFlags observedWriteFlags_{};\n  std::vector<char> ancillaryData_;\n};\n\nclass WriteCallbackBase : public AsyncTransportWrapper::WriteCallback {\n public:\n  explicit WriteCallbackBase(SendMsgParamsCallbackBase* mcb = nullptr)\n      : state(STATE_WAITING),\n        bytesWritten(0),\n        exception(AsyncSocketException::UNKNOWN, \"none\"),\n        mcb_(mcb) {}\n\n  ~WriteCallbackBase() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  virtual void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n    if (mcb_) {\n      mcb_->setSocket(socket);\n    }\n  }\n\n  void writeSuccess() noexcept override {\n    std::cerr << \"writeSuccess\" << std::endl;\n    state = STATE_SUCCEEDED;\n  }\n\n  void writeErr(\n      size_t nBytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"writeError: bytesWritten \" << nBytesWritten << \", exception \"\n              << ex.what() << std::endl;\n\n    state = STATE_FAILED;\n    this->bytesWritten = nBytesWritten;\n    exception = ex;\n    socket_->close();\n  }\n\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  StateEnum state;\n  size_t bytesWritten;\n  AsyncSocketException exception;\n  SendMsgParamsCallbackBase* mcb_;\n};\n\nclass ExpectWriteErrorCallback : public WriteCallbackBase {\n public:\n  explicit ExpectWriteErrorCallback(SendMsgParamsCallbackBase* mcb = nullptr)\n      : WriteCallbackBase(mcb) {}\n\n  ~ExpectWriteErrorCallback() override {\n    EXPECT_EQ(STATE_FAILED, state);\n    EXPECT_EQ(\n        exception.getType(),\n        AsyncSocketException::AsyncSocketExceptionType::NETWORK_ERROR);\n    EXPECT_EQ(exception.getErrno(), 22);\n    // Suppress the assert in  ~WriteCallbackBase()\n    state = STATE_SUCCEEDED;\n  }\n};\n\n#ifdef FOLLY_HAVE_MSG_ERRQUEUE\n/* copied from include/uapi/linux/net_tstamp.h */\n/* SO_TIMESTAMPING gets an integer bit field comprised of these values */\nenum SOF_TIMESTAMPING {\n  SOF_TIMESTAMPING_TX_SOFTWARE = (1 << 1),\n  SOF_TIMESTAMPING_SOFTWARE = (1 << 4),\n  SOF_TIMESTAMPING_OPT_ID = (1 << 7),\n  SOF_TIMESTAMPING_TX_SCHED = (1 << 8),\n  SOF_TIMESTAMPING_TX_ACK = (1 << 9),\n  SOF_TIMESTAMPING_OPT_TSONLY = (1 << 11),\n};\n\nclass WriteCheckTimestampCallback : public WriteCallbackBase {\n public:\n  explicit WriteCheckTimestampCallback(SendMsgParamsCallbackBase* mcb = nullptr)\n      : WriteCallbackBase(mcb) {}\n\n  ~WriteCheckTimestampCallback() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) override {\n    WriteCallbackBase::setSocket(socket);\n\n    EXPECT_NE(socket_->getNetworkSocket(), NetworkSocket());\n    int flags = SOF_TIMESTAMPING_OPT_ID | SOF_TIMESTAMPING_OPT_TSONLY |\n        SOF_TIMESTAMPING_SOFTWARE;\n    AsyncSocket::OptionKey tstampingOpt = {SOL_SOCKET, SO_TIMESTAMPING};\n    int ret = tstampingOpt.apply(socket_->getNetworkSocket(), flags);\n    EXPECT_EQ(ret, 0);\n  }\n\n  std::vector<int32_t> getTimestampNotifications() noexcept {\n    auto fd = socket_->getNetworkSocket();\n    std::vector<char> ctrl(1024, 0);\n    unsigned char data;\n    struct msghdr msg;\n    iovec entry;\n\n    memset(&msg, 0, sizeof(msg));\n    entry.iov_base = &data;\n    entry.iov_len = sizeof(data);\n    msg.msg_iov = &entry;\n    msg.msg_iovlen = 1;\n    msg.msg_control = ctrl.data();\n    msg.msg_controllen = ctrl.size();\n\n    std::vector<int32_t> timestampsFound;\n\n    folly::Optional<int32_t> timestampType;\n    bool gotTimestamp = false;\n    bool gotByteSeq = false;\n    int ret;\n    while (true) {\n      ret = netops::recvmsg(fd, &msg, MSG_ERRQUEUE);\n      if (ret < 0) {\n        if (errno != EAGAIN) {\n          auto errnoCopy = errno;\n          std::cerr << \"::recvmsg exited with code \" << ret\n                    << \", errno: \" << errnoCopy << std::endl;\n          AsyncSocketException ex(\n              AsyncSocketException::INTERNAL_ERROR,\n              \"recvmsg() failed\",\n              errnoCopy);\n          exception = ex;\n        }\n        return timestampsFound;\n      }\n\n      for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);\n           cmsg != nullptr && cmsg->cmsg_len != 0;\n           cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        if (cmsg->cmsg_level == SOL_SOCKET &&\n            cmsg->cmsg_type == SCM_TIMESTAMPING) {\n          CHECK(!gotTimestamp); // shouldn't already be set\n          gotTimestamp = true;\n        }\n\n        if ((cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVERR) ||\n            (cmsg->cmsg_level == SOL_IPV6 && cmsg->cmsg_type == IPV6_RECVERR)) {\n          const struct cmsghdr& cmsgh = *cmsg;\n          const auto serr = reinterpret_cast<const struct sock_extended_err*>(\n              CMSG_DATA(&cmsgh));\n          if (serr->ee_errno != ENOMSG ||\n              serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {\n            // not a timestamp\n            continue;\n          }\n\n          CHECK(!timestampType); // shouldn't already be set\n          CHECK(!gotByteSeq); // shouldn't already be set\n          gotByteSeq = true;\n          timestampType = serr->ee_info;\n        }\n\n        // check if we have both a timestamp and byte sequence\n        if (gotTimestamp && gotByteSeq) {\n          timestampsFound.push_back(*timestampType);\n          timestampType = folly::none;\n          gotTimestamp = false;\n          gotByteSeq = false;\n        }\n      } // for(...)\n    } // while(true)\n\n    return timestampsFound;\n  }\n};\n#endif // FOLLY_HAVE_MSG_ERRQUEUE\n\nclass ReadCallbackBase : public AsyncTransportWrapper::ReadCallback {\n public:\n  explicit ReadCallbackBase(WriteCallbackBase* wcb)\n      : wcb_(wcb), state(STATE_WAITING) {}\n\n  ~ReadCallbackBase() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n  }\n\n  void setState(StateEnum s) {\n    state = s;\n    if (wcb_) {\n      wcb_->state = s;\n    }\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"readError \" << ex.what() << std::endl;\n    state = STATE_FAILED;\n    socket_->close();\n  }\n\n  void readEOF() noexcept override {\n    std::cerr << \"readEOF\" << std::endl;\n\n    socket_->close();\n  }\n\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  WriteCallbackBase* wcb_;\n  StateEnum state;\n};\n\n/**\n * ReadCallback reads data from the socket and then writes it back.\n *\n * It includes any folly::WriteFlags set via setWriteFlags(...) in its write\n * back operation.\n */\nclass ReadCallback : public ReadCallbackBase {\n public:\n  explicit ReadCallback(WriteCallbackBase* wcb)\n      : ReadCallbackBase(wcb), buffers(), writeFlags(folly::WriteFlags::NONE) {}\n\n  ~ReadCallback() override {\n    for (std::vector<Buffer>::iterator it = buffers.begin();\n         it != buffers.end();\n         ++it) {\n      it->free();\n    }\n    currentBuffer.free();\n  }\n\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    if (!currentBuffer.buffer) {\n      currentBuffer.allocate(4096);\n    }\n    *bufReturn = currentBuffer.buffer;\n    *lenReturn = currentBuffer.length;\n  }\n\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    wcb_->setSocket(socket_);\n\n    // Write back the same data.\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }\n\n  /**\n   * These flags will be used when writing the read data back to the socket.\n   */\n  void setWriteFlags(folly::WriteFlags flags) {\n    writeFlags = flags;\n  }\n\n  class Buffer {\n   public:\n    Buffer() : buffer(nullptr), length(0) {}\n    Buffer(char* buf, size_t len) : buffer(buf), length(len) {}\n\n    void reset() {\n      buffer = nullptr;\n      length = 0;\n    }\n    void allocate(size_t len) {\n      assert(buffer == nullptr);\n      this->buffer = static_cast<char*>(malloc(len));\n      this->length = len;\n    }\n    void free() {\n      ::free(buffer);\n      reset();\n    }\n\n    char* buffer;\n    size_t length;\n  };\n\n  std::vector<Buffer> buffers;\n  Buffer currentBuffer;\n  folly::WriteFlags writeFlags;\n};\n\nclass ReadErrorCallback : public ReadCallbackBase {\n public:\n  explicit ReadErrorCallback(WriteCallbackBase* wcb) : ReadCallbackBase(wcb) {}\n\n  // Return nullptr buffer to trigger readError()\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = nullptr;\n    *lenReturn = 0;\n  }\n\n  void readDataAvailable(size_t /* len */) noexcept override {\n    // This should never to called.\n    FAIL();\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ReadCallbackBase::readErr(ex);\n    std::cerr << \"ReadErrorCallback::readError\" << std::endl;\n    setState(STATE_SUCCEEDED);\n  }\n};\n\nclass ReadEOFCallback : public ReadCallbackBase {\n public:\n  explicit ReadEOFCallback(WriteCallbackBase* wcb) : ReadCallbackBase(wcb) {}\n\n  // Return nullptr buffer to trigger readError()\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = nullptr;\n    *lenReturn = 0;\n  }\n\n  void readDataAvailable(size_t /* len */) noexcept override {\n    // This should never to called.\n    FAIL();\n  }\n\n  void readEOF() noexcept override {\n    ReadCallbackBase::readEOF();\n    setState(STATE_SUCCEEDED);\n  }\n};\n\nclass WriteErrorCallback : public ReadCallback {\n public:\n  explicit WriteErrorCallback(WriteCallbackBase* wcb) : ReadCallback(wcb) {}\n\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    // close the socket before writing to trigger writeError().\n    netops::close(socket_->getNetworkSocket());\n\n    wcb_->setSocket(socket_);\n\n    // Write back the same data.\n    folly::test::msvcSuppressAbortOnInvalidParams(\n        [&] { socket_->write(wcb_, currentBuffer.buffer, len); });\n\n    if (wcb_->state == STATE_FAILED) {\n      setState(STATE_SUCCEEDED);\n    } else {\n      state = STATE_FAILED;\n    }\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"readError \" << ex.what() << std::endl;\n    // do nothing since this is expected\n  }\n};\n\nclass EmptyReadCallback : public ReadCallback {\n public:\n  explicit EmptyReadCallback() : ReadCallback(nullptr) {}\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"readError \" << ex.what() << std::endl;\n    state = STATE_FAILED;\n    if (tcpSocket_) {\n      tcpSocket_->close();\n    }\n  }\n\n  void readEOF() noexcept override {\n    std::cerr << \"readEOF\" << std::endl;\n    if (tcpSocket_) {\n      tcpSocket_->close();\n    }\n    state = STATE_SUCCEEDED;\n  }\n\n  std::shared_ptr<AsyncSocket> tcpSocket_;\n};\n\nclass HandshakeCallback : public AsyncSSLSocket::HandshakeCB {\n public:\n  enum ExpectType { EXPECT_SUCCESS, EXPECT_ERROR };\n\n  explicit HandshakeCallback(\n      ReadCallbackBase* rcb,\n      ExpectType expect = EXPECT_SUCCESS)\n      : state(STATE_WAITING), rcb_(rcb), expect_(expect) {}\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n  }\n\n  void setState(StateEnum s) {\n    state = s;\n    rcb_->setState(s);\n  }\n\n  // Functions inherited from AsyncSSLSocketHandshakeCallback\n  void handshakeSuc(AsyncSSLSocket* sock) noexcept override {\n    std::lock_guard<std::mutex> g(mutex_);\n    cv_.notify_all();\n    EXPECT_EQ(sock, socket_.get());\n    std::cerr << \"HandshakeCallback::connectionAccepted\" << std::endl;\n    rcb_->setSocket(socket_);\n    sock->setReadCB(rcb_);\n    state = (expect_ == EXPECT_SUCCESS) ? STATE_SUCCEEDED : STATE_FAILED;\n  }\n  void handshakeErr(\n      AsyncSSLSocket* /* sock */,\n      const AsyncSocketException& ex) noexcept override {\n    std::lock_guard<std::mutex> g(mutex_);\n    cv_.notify_all();\n    std::cerr << \"HandshakeCallback::handshakeError \" << ex.what() << std::endl;\n    state = (expect_ == EXPECT_ERROR) ? STATE_SUCCEEDED : STATE_FAILED;\n    if (expect_ == EXPECT_ERROR) {\n      // rcb will never be invoked\n      rcb_->setState(STATE_SUCCEEDED);\n    }\n    errorString_ = ex.what();\n  }\n\n  void waitForHandshake() {\n    std::unique_lock<std::mutex> lock(mutex_);\n    cv_.wait(lock, [this] { return state != STATE_WAITING; });\n  }\n\n  ~HandshakeCallback() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  void closeSocket() {\n    socket_->close();\n    state = STATE_SUCCEEDED;\n  }\n\n  std::shared_ptr<AsyncSSLSocket> getSocket() {\n    return socket_;\n  }\n\n  StateEnum state;\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  ReadCallbackBase* rcb_;\n  ExpectType expect_;\n  std::mutex mutex_;\n  std::condition_variable cv_;\n  std::string errorString_;\n};\n\nclass SSLServerAcceptCallback : public SSLServerAcceptCallbackBase {\n public:\n  uint32_t timeout_;\n\n  explicit SSLServerAcceptCallback(HandshakeCallback* hcb, uint32_t timeout = 0)\n      : SSLServerAcceptCallbackBase(hcb), timeout_(timeout) {}\n\n  ~SSLServerAcceptCallback() override {\n    if (timeout_ > 0) {\n      // if we set a timeout, we expect failure\n      EXPECT_EQ(hcb_->state, STATE_FAILED);\n      hcb_->setState(STATE_SUCCEEDED);\n    }\n  }\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n    std::cerr << \"SSLServerAcceptCallback::connAccepted\" << std::endl;\n\n    hcb_->setSocket(sock);\n    sock->sslAccept(hcb_, std::chrono::milliseconds(timeout_));\n    EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ACCEPTING);\n\n    state = STATE_SUCCEEDED;\n  }\n};\n\nclass SSLServerAcceptCallbackDelay : public SSLServerAcceptCallback {\n public:\n  explicit SSLServerAcceptCallbackDelay(HandshakeCallback* hcb)\n      : SSLServerAcceptCallback(hcb) {}\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n\n    std::cerr << \"SSLServerAcceptCallbackDelay::connAccepted\" << std::endl;\n    auto fd = sock->getNetworkSocket();\n\n#ifndef TCP_NOPUSH\n    {\n      // The accepted connection should already have TCP_NODELAY set\n      int value;\n      socklen_t valueLength = sizeof(value);\n      int rc = netops::getsockopt(\n          fd, IPPROTO_TCP, TCP_NODELAY, &value, &valueLength);\n      EXPECT_EQ(rc, 0);\n      EXPECT_EQ(value, 1);\n    }\n#endif\n\n    // Unset the TCP_NODELAY option.\n    int value = 0;\n    socklen_t valueLength = sizeof(value);\n    int rc =\n        netops::setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &value, valueLength);\n    EXPECT_EQ(rc, 0);\n\n    rc = netops::getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &value, &valueLength);\n    EXPECT_EQ(rc, 0);\n    EXPECT_EQ(value, 0);\n\n    SSLServerAcceptCallback::connAccepted(sock);\n  }\n};\n\nclass HandshakeErrorCallback : public SSLServerAcceptCallbackBase {\n public:\n  explicit HandshakeErrorCallback(HandshakeCallback* hcb)\n      : SSLServerAcceptCallbackBase(hcb) {}\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n\n    std::cerr << \"HandshakeErrorCallback::connAccepted\" << std::endl;\n\n    // The first call to sslAccept() should succeed.\n    hcb_->setSocket(sock);\n    sock->sslAccept(hcb_);\n    EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ACCEPTING);\n\n    // The second call to sslAccept() should fail.\n    HandshakeCallback callback2(hcb_->rcb_);\n    callback2.setSocket(sock);\n    sock->sslAccept(&callback2);\n    EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ERROR);\n\n    // Both callbacks should be in the error state.\n    EXPECT_EQ(hcb_->state, STATE_FAILED);\n    EXPECT_EQ(callback2.state, STATE_FAILED);\n\n    state = STATE_SUCCEEDED;\n    hcb_->setState(STATE_SUCCEEDED);\n    callback2.setState(STATE_SUCCEEDED);\n  }\n};\n\nclass HandshakeTimeoutCallback : public SSLServerAcceptCallbackBase {\n public:\n  explicit HandshakeTimeoutCallback(HandshakeCallback* hcb)\n      : SSLServerAcceptCallbackBase(hcb) {}\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    std::cerr << \"HandshakeErrorCallback::connAccepted\" << std::endl;\n\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n\n    hcb_->setSocket(sock);\n    sock->getEventBase()->tryRunAfterDelay(\n        [=] {\n          std::cerr << \"Delayed SSL accept, client will have close by now\"\n                    << std::endl;\n          // SSL accept will fail\n          EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_UNINIT);\n          hcb_->socket_->sslAccept(hcb_);\n          // This registers for an event\n          EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ACCEPTING);\n\n          state = STATE_SUCCEEDED;\n        },\n        100);\n  }\n};\n\nclass ConnectTimeoutCallback : public SSLServerAcceptCallbackBase {\n public:\n  ConnectTimeoutCallback() : SSLServerAcceptCallbackBase(nullptr) {\n    // We don't care if we get invoked or not.\n    // The client may time out and give up before connAccepted() is even\n    // called.\n    state = STATE_SUCCEEDED;\n  }\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    std::cerr << \"ConnectTimeoutCallback::connAccepted\" << std::endl;\n\n    // Just wait a while before closing the socket, so the client\n    // will time out waiting for the handshake to complete.\n    s->getEventBase()->tryRunAfterDelay([=] { s->close(); }, 100);\n  }\n};\n\nvoid getfds(NetworkSocket fds[2]);\n\nvoid getctx(\n    std::shared_ptr<folly::SSLContext> clientCtx,\n    std::shared_ptr<folly::SSLContext> serverCtx);\n\nvoid sslsocketpair(\n    EventBase* eventBase,\n    AsyncSSLSocket::UniquePtr* clientSock,\n    AsyncSSLSocket::UniquePtr* serverSock);\n\nclass BlockingWriteClient : private AsyncSSLSocket::HandshakeCB,\n                            private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit BlockingWriteClient(AsyncSSLSocket::UniquePtr socket)\n      : socket_(std::move(socket)), bufLen_(2500), iovCount_(2000) {\n    // Fill buf_\n    buf_ = std::make_unique<uint8_t[]>(bufLen_);\n    for (uint32_t n = 0; n < sizeof(buf_); ++n) {\n      buf_[n] = n % 0xff;\n    }\n\n    // Initialize iov_\n    iov_ = std::make_unique<struct iovec[]>(iovCount_);\n    for (uint32_t n = 0; n < iovCount_; ++n) {\n      iov_[n].iov_base = buf_.get() + n;\n      if (n & 0x1) {\n        iov_[n].iov_len = n % bufLen_;\n      } else {\n        iov_[n].iov_len = bufLen_ - (n % bufLen_);\n      }\n    }\n\n    socket_->sslConn(this, std::chrono::milliseconds(100));\n  }\n\n  struct iovec* getIovec() const {\n    return iov_.get();\n  }\n  uint32_t getIovecCount() const {\n    return iovCount_;\n  }\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    socket_->writev(this, iov_.get(), iovCount_);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client handshake error: \" << ex.what();\n  }\n  void writeSuccess() noexcept override {\n    socket_->close();\n  }\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  uint32_t bufLen_;\n  uint32_t iovCount_;\n  std::unique_ptr<uint8_t[]> buf_;\n  std::unique_ptr<struct iovec[]> iov_;\n};\n\nclass BlockingWriteServer : private AsyncSSLSocket::HandshakeCB,\n                            private AsyncTransportWrapper::ReadCallback {\n public:\n  explicit BlockingWriteServer(AsyncSSLSocket::UniquePtr socket)\n      : socket_(std::move(socket)), bufSize_(2500 * 2000), bytesRead_(0) {\n    buf_ = std::make_unique<uint8_t[]>(bufSize_);\n    socket_->sslAccept(this, std::chrono::milliseconds(100));\n  }\n\n  void checkBuffer(struct iovec* iov, uint32_t count) const {\n    uint32_t idx = 0;\n    for (uint32_t n = 0; n < count; ++n) {\n      size_t bytesLeft = bytesRead_ - idx;\n      int rc = memcmp(\n          buf_.get() + idx,\n          iov[n].iov_base,\n          std::min(iov[n].iov_len, bytesLeft));\n      if (rc != 0) {\n        FAIL() << \"buffer mismatch at iovec \" << n << \"/\" << count\n               << \": rc=\" << rc;\n      }\n      if (iov[n].iov_len > bytesLeft) {\n        FAIL() << \"server did not read enough data: \"\n               << \"ended at byte \" << bytesLeft << \"/\" << iov[n].iov_len\n               << \" in iovec \" << n << \"/\" << count;\n      }\n\n      idx += iov[n].iov_len;\n    }\n    if (idx != bytesRead_) {\n      ADD_FAILURE() << \"server read extra data: \" << bytesRead_\n                    << \" bytes read; expected \" << idx;\n    }\n  }\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    // Wait 10ms before reading, so the client's writes will initially block.\n    socket_->getEventBase()->tryRunAfterDelay(\n        [this] { socket_->setReadCB(this); }, 10);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server handshake error: \" << ex.what();\n  }\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.get() + bytesRead_;\n    *lenReturn = bufSize_ - bytesRead_;\n  }\n  void readDataAvailable(size_t len) noexcept override {\n    bytesRead_ += len;\n    socket_->setReadCB(nullptr);\n    socket_->getEventBase()->tryRunAfterDelay(\n        [this] { socket_->setReadCB(this); }, 2);\n  }\n  void readEOF() noexcept override {\n    socket_->close();\n  }\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server read error: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  uint32_t bufSize_;\n  uint32_t bytesRead_;\n  std::unique_ptr<uint8_t[]> buf_;\n};\n\nclass AlpnClient : private AsyncSSLSocket::HandshakeCB,\n                   private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit AlpnClient(AsyncSSLSocket::UniquePtr socket)\n      : nextProto(nullptr), nextProtoLength(0), socket_(std::move(socket)) {\n    socket_->sslConn(this);\n  }\n\n  const unsigned char* nextProto;\n  unsigned nextProtoLength;\n  folly::Optional<AsyncSocketException> except;\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    socket_->getSelectedNextProtocol(&nextProto, &nextProtoLength);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    except = ex;\n  }\n  void writeSuccess() noexcept override {\n    socket_->close();\n  }\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n};\n\nclass AlpnServer : private AsyncSSLSocket::HandshakeCB,\n                   private AsyncTransportWrapper::ReadCallback {\n public:\n  explicit AlpnServer(AsyncSSLSocket::UniquePtr socket)\n      : nextProto(nullptr), nextProtoLength(0), socket_(std::move(socket)) {\n    socket_->sslAccept(this);\n  }\n\n  const unsigned char* nextProto;\n  unsigned nextProtoLength;\n  folly::Optional<AsyncSocketException> except;\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    socket_->getSelectedNextProtocol(&nextProto, &nextProtoLength);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    except = ex;\n  }\n  void getReadBuffer(void** /* bufReturn */, size_t* lenReturn) override {\n    *lenReturn = 0;\n  }\n  void readDataAvailable(size_t /* len */) noexcept override {}\n  void readEOF() noexcept override {\n    socket_->close();\n  }\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server read error: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n};\n\nclass RenegotiatingServer : public AsyncSSLSocket::HandshakeCB,\n                            public AsyncTransportWrapper::ReadCallback {\n public:\n  explicit RenegotiatingServer(AsyncSSLSocket::UniquePtr socket)\n      : socket_(std::move(socket)) {\n    socket_->sslAccept(this);\n  }\n\n  ~RenegotiatingServer() override {\n    socket_->setReadCB(nullptr);\n  }\n\n  void handshakeSuc(AsyncSSLSocket* /* socket */) noexcept override {\n    LOG(INFO) << \"Renegotiating server handshake success\";\n    socket_->setReadCB(this);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"Renegotiating server handshake error: \" << ex.what();\n  }\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *lenReturn = sizeof(buf);\n    *bufReturn = buf;\n  }\n  void readDataAvailable(size_t /* len */) noexcept override {}\n  void readEOF() noexcept override {}\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    LOG(INFO) << \"server got read error \" << ex.what();\n    auto exPtr = dynamic_cast<const SSLException*>(&ex);\n    ASSERT_NE(nullptr, exPtr);\n    std::string exStr(ex.what());\n    SSLException sslEx(SSLError::CLIENT_RENEGOTIATION);\n    ASSERT_NE(std::string::npos, exStr.find(sslEx.what()));\n    renegotiationError_ = true;\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  unsigned char buf[128];\n  bool renegotiationError_{false};\n};\n\n#ifndef OPENSSL_NO_TLSEXT\nclass SNIClient : private AsyncSSLSocket::HandshakeCB,\n                  private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit SNIClient(AsyncSSLSocket::UniquePtr socket)\n      : serverNameMatch(false), socket_(std::move(socket)) {\n    socket_->sslConn(this);\n  }\n\n  bool serverNameMatch;\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    serverNameMatch = socket_->isServerNameMatch();\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client handshake error: \" << ex.what();\n  }\n  void writeSuccess() noexcept override {\n    socket_->close();\n  }\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n};\n\nclass SNIServer : private AsyncSSLSocket::HandshakeCB,\n                  private AsyncTransportWrapper::ReadCallback {\n public:\n  explicit SNIServer(\n      AsyncSSLSocket::UniquePtr socket,\n      const std::shared_ptr<folly::SSLContext>& ctx,\n      const std::shared_ptr<folly::SSLContext>& sniCtx,\n      const std::string& expectedServerName)\n      : serverNameMatch(false),\n        socket_(std::move(socket)),\n        sniCtx_(sniCtx),\n        expectedServerName_(expectedServerName) {\n    ctx->setServerNameCallback(\n        std::bind(&SNIServer::serverNameCallback, this, std::placeholders::_1));\n    socket_->sslAccept(this);\n  }\n\n  bool serverNameMatch;\n\n private:\n  void handshakeSuc(AsyncSSLSocket* /* ssl */) noexcept override {}\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server handshake error: \" << ex.what();\n  }\n  void getReadBuffer(void** /* bufReturn */, size_t* lenReturn) override {\n    *lenReturn = 0;\n  }\n  void readDataAvailable(size_t /* len */) noexcept override {}\n  void readEOF() noexcept override {\n    socket_->close();\n  }\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server read error: \" << ex.what();\n  }\n\n  folly::SSLContext::ServerNameCallbackResult serverNameCallback(SSL* ssl) {\n    const char* sn = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n    if (sniCtx_ && sn && !strcasecmp(expectedServerName_.c_str(), sn)) {\n      AsyncSSLSocket* sslSocket = AsyncSSLSocket::getFromSSL(ssl);\n      sslSocket->switchServerSSLContext(sniCtx_);\n      serverNameMatch = true;\n      return folly::SSLContext::SERVER_NAME_FOUND;\n    } else {\n      serverNameMatch = false;\n      return folly::SSLContext::SERVER_NAME_NOT_FOUND;\n    }\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  std::shared_ptr<folly::SSLContext> sniCtx_;\n  std::string expectedServerName_;\n};\n#endif\n\nclass SSLClient : public AsyncSocket::ConnectCallback,\n                  public AsyncTransportWrapper::WriteCallback,\n                  public AsyncTransportWrapper::ReadCallback {\n private:\n  EventBase* eventBase_;\n  std::shared_ptr<AsyncSSLSocket> sslSocket_;\n  SSL_SESSION* session_;\n  std::shared_ptr<folly::SSLContext> ctx_;\n  uint32_t requests_;\n  folly::SocketAddress address_;\n  uint32_t timeout_;\n  char buf_[128];\n  char readbuf_[128];\n  uint32_t bytesRead_;\n  uint32_t hit_;\n  uint32_t miss_;\n  uint32_t errors_;\n  uint32_t writeAfterConnectErrors_;\n\n  // These settings test that we eventually drain the\n  // socket, even if the maxReadsPerEvent_ is hit during\n  // a event loop iteration.\n  static constexpr size_t kMaxReadsPerEvent = 2;\n  // 2 event loop iterations\n  static constexpr size_t kMaxReadBufferSz =\n      sizeof(decltype(readbuf_)) / kMaxReadsPerEvent / 2;\n\n public:\n  SSLClient(\n      EventBase* eventBase,\n      const folly::SocketAddress& address,\n      uint32_t requests,\n      uint32_t timeout = 0)\n      : eventBase_(eventBase),\n        session_(nullptr),\n        requests_(requests),\n        address_(address),\n        timeout_(timeout),\n        bytesRead_(0),\n        hit_(0),\n        miss_(0),\n        errors_(0),\n        writeAfterConnectErrors_(0) {\n    ctx_.reset(new folly::SSLContext());\n    ctx_->setOptions(SSL_OP_NO_TICKET);\n    ctx_->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n    memset(buf_, 'a', sizeof(buf_));\n  }\n\n  ~SSLClient() override {\n    if (session_) {\n      SSL_SESSION_free(session_);\n    }\n    if (errors_ == 0) {\n      EXPECT_EQ(bytesRead_, sizeof(buf_));\n    }\n  }\n\n  uint32_t getHit() const {\n    return hit_;\n  }\n\n  uint32_t getMiss() const {\n    return miss_;\n  }\n\n  uint32_t getErrors() const {\n    return errors_;\n  }\n\n  uint32_t getWriteAfterConnectErrors() const {\n    return writeAfterConnectErrors_;\n  }\n\n  void connect(bool writeNow = false) {\n    sslSocket_ = AsyncSSLSocket::newSocket(ctx_, eventBase_);\n    if (session_ != nullptr) {\n      sslSocket_->setSSLSession(session_);\n    }\n    requests_--;\n    sslSocket_->connect(this, address_, timeout_);\n    if (sslSocket_ && writeNow) {\n      // write some junk, used in an error test\n      sslSocket_->write(this, buf_, sizeof(buf_));\n    }\n  }\n\n  void connectSuccess() noexcept override {\n    std::cerr << \"client SSL socket connected\" << std::endl;\n    if (sslSocket_->getSSLSessionReused()) {\n      hit_++;\n    } else {\n      miss_++;\n      if (session_ != nullptr) {\n        SSL_SESSION_free(session_);\n      }\n      session_ = sslSocket_->getSSLSession();\n    }\n\n    // write()\n    sslSocket_->setMaxReadsPerEvent(kMaxReadsPerEvent);\n    sslSocket_->write(this, buf_, sizeof(buf_));\n    sslSocket_->setReadCB(this);\n    memset(readbuf_, 'b', sizeof(readbuf_));\n    bytesRead_ = 0;\n  }\n\n  void connectErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"SSLClient::connectError: \" << ex.what() << std::endl;\n    errors_++;\n    sslSocket_.reset();\n  }\n\n  void writeSuccess() noexcept override {\n    std::cerr << \"client write success\" << std::endl;\n  }\n\n  void writeErr(\n      size_t /* bytesWritten */,\n      const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"client writeError: \" << ex.what() << std::endl;\n    if (!sslSocket_) {\n      writeAfterConnectErrors_++;\n    }\n  }\n\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = readbuf_ + bytesRead_;\n    *lenReturn = std::min(kMaxReadBufferSz, sizeof(readbuf_) - bytesRead_);\n  }\n\n  void readEOF() noexcept override {\n    std::cerr << \"client readEOF\" << std::endl;\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"client readError: \" << ex.what() << std::endl;\n  }\n\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"client read data: \" << len << std::endl;\n    bytesRead_ += len;\n    if (bytesRead_ == sizeof(buf_)) {\n      EXPECT_EQ(memcmp(buf_, readbuf_, bytesRead_), 0);\n      sslSocket_->closeNow();\n      sslSocket_.reset();\n      if (requests_ != 0) {\n        connect();\n      }\n    }\n  }\n};\n\nclass SSLHandshakeBase : public AsyncSSLSocket::HandshakeCB,\n                         private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit SSLHandshakeBase(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : handshakeVerify_(false),\n        handshakeSuccess_(false),\n        handshakeError_(false),\n        socket_(std::move(socket)),\n        preverifyResult_(preverifyResult),\n        verifyResult_(verifyResult) {}\n\n  AsyncSSLSocket::UniquePtr moveSocket() && {\n    return std::move(socket_);\n  }\n\n  bool handshakeVerify_;\n  bool handshakeSuccess_;\n  bool handshakeError_;\n  std::chrono::nanoseconds handshakeTime;\n\n protected:\n  AsyncSSLSocket::UniquePtr socket_;\n  bool preverifyResult_;\n  bool verifyResult_;\n\n  // HandshakeCallback\n  bool handshakeVer(\n      AsyncSSLSocket* /* sock */,\n      bool preverifyOk,\n      X509_STORE_CTX* /* ctx */) noexcept override {\n    handshakeVerify_ = true;\n\n    EXPECT_EQ(preverifyResult_, preverifyOk);\n    return verifyResult_;\n  }\n\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    LOG(INFO) << \"Handshake success\";\n    handshakeSuccess_ = true;\n    if (socket_) {\n      handshakeTime = socket_->getHandshakeTime();\n    }\n  }\n\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    LOG(INFO) << \"Handshake error \" << ex.what();\n    handshakeError_ = true;\n    if (socket_) {\n      handshakeTime = socket_->getHandshakeTime();\n    }\n  }\n\n  // WriteCallback\n  void writeSuccess() noexcept override {\n    if (socket_) {\n      socket_->close();\n    }\n  }\n\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n};\n\nclass SSLHandshakeClient : public SSLHandshakeBase {\n public:\n  SSLHandshakeClient(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslConn(this, std::chrono::milliseconds::zero());\n  }\n};\n\nclass SSLHandshakeClientNoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeClientNoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslConn(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  }\n};\n\nclass SSLHandshakeClientDoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeClientDoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslConn(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::VERIFY);\n  }\n};\n\nclass SSLHandshakeServer : public SSLHandshakeBase {\n public:\n  SSLHandshakeServer(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslAccept(this, std::chrono::milliseconds::zero());\n  }\n};\n\nclass SSLHandshakeServerParseClientHello : public SSLHandshakeBase {\n public:\n  SSLHandshakeServerParseClientHello(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->enableClientHelloParsing();\n    socket_->sslAccept(this, std::chrono::milliseconds::zero());\n  }\n\n  std::string clientCiphers_, sharedCiphers_, serverCiphers_, chosenCipher_;\n\n protected:\n  void handshakeSuc(AsyncSSLSocket* sock) noexcept override {\n    handshakeSuccess_ = true;\n    sock->getSSLSharedCiphers(sharedCiphers_);\n    sock->getSSLServerCiphers(serverCiphers_);\n    sock->getSSLClientCiphers(clientCiphers_);\n    chosenCipher_ = sock->getNegotiatedCipherName();\n  }\n};\n\nclass SSLHandshakeServerNoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeServerNoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslAccept(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  }\n};\n\nclass SSLHandshakeServerDoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeServerDoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslAccept(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n  }\n};\n\nclass EventBaseAborter : public AsyncTimeout {\n public:\n  EventBaseAborter(EventBase* eventBase, uint32_t timeoutMS)\n      : AsyncTimeout(eventBase, AsyncTimeout::InternalEnum::INTERNAL),\n        eventBase_(eventBase) {\n    scheduleTimeout(timeoutMS);\n  }\n\n  void timeoutExpired() noexcept override {\n    FAIL() << \"test timed out\";\n    eventBase_->terminateLoopSoon();\n  }\n\n private:\n  EventBase* eventBase_;\n};\n\nclass SSLAcceptEvbRunner : public SSLAcceptRunner {\n public:\n  explicit SSLAcceptEvbRunner(EventBase* evb) : evb_(evb) {}\n  ~SSLAcceptEvbRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop([acceptFunc = std::move(acceptFunc),\n                     finallyFunc = std::move(finallyFunc)]() mutable {\n      finallyFunc(acceptFunc());\n    });\n  }\n\n protected:\n  EventBase* evb_;\n};\n\nclass SSLAcceptErrorRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptErrorRunner(EventBase* evb) : SSLAcceptEvbRunner(evb) {}\n  ~SSLAcceptErrorRunner() override = default;\n\n  void run(Function<int()> /*acceptFunc*/, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop(\n        [finallyFunc = std::move(finallyFunc)]() mutable { finallyFunc(-1); });\n  }\n};\n\nclass SSLAcceptCloseRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptCloseRunner(EventBase* evb, folly::AsyncSSLSocket* sock)\n      : SSLAcceptEvbRunner(evb), socket_(sock) {}\n  ~SSLAcceptCloseRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop([acceptFunc = std::move(acceptFunc),\n                     finallyFunc = std::move(finallyFunc),\n                     sock = socket_]() mutable {\n      auto ret = acceptFunc();\n      sock->closeNow();\n      finallyFunc(ret);\n    });\n  }\n\n private:\n  folly::AsyncSSLSocket* socket_;\n};\n\nclass SSLAcceptDestroyRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptDestroyRunner(EventBase* evb, SSLHandshakeBase* base)\n      : SSLAcceptEvbRunner(evb), sslBase_(base) {}\n  ~SSLAcceptDestroyRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop([acceptFunc = std::move(acceptFunc),\n                     finallyFunc = std::move(finallyFunc),\n                     sslBase = sslBase_]() mutable {\n      auto ret = acceptFunc();\n      std::move(*sslBase).moveSocket();\n      finallyFunc(ret);\n    });\n  }\n\n private:\n  SSLHandshakeBase* sslBase_;\n};\n\nclass SSLAcceptFiberRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptFiberRunner(EventBase* evb) : SSLAcceptEvbRunner(evb) {}\n  ~SSLAcceptFiberRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    auto& fiberManager = folly::fibers::getFiberManager(*evb_);\n    fiberManager.addTaskFinally(\n        std::move(acceptFunc),\n        [finally = std::move(finallyFunc)](folly::Try<int>&& res) mutable {\n          finally(res.value());\n        });\n  }\n};\n} // namespace folly\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/io/async/AsyncSSLSocket.h>\n\n#include <folly/io/async/EventBase.h>\n#include <folly/portability/Sockets.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <chrono>\n#include <memory>\n\n#include <folly/Format.h>\n#include <folly/Indestructible.h>\n#include <folly/SocketAddress.h>\n#include <folly/SpinLock.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/IOBuf.h>\n#include <folly/io/async/ssl/BasicTransportCertificate.h>\n#include <folly/lang/Bits.h>\n#include <folly/portability/OpenSSL.h>\n\nusing folly::SocketAddress;\nusing folly::SSLContext;\nusing std::shared_ptr;\nusing std::string;\n\nusing folly::Endian;\nusing folly::IOBuf;\nusing folly::SpinLock;\nusing folly::SpinLockGuard;\nusing folly::io::Cursor;\nusing std::bind;\nusing std::unique_ptr;\n\nnamespace {\nusing folly::AsyncSocket;\nusing folly::AsyncSocketException;\nusing folly::AsyncSSLSocket;\nusing folly::Optional;\nusing folly::SSLContext;\n// For OpenSSL portability API\nusing namespace folly::ssl;\nusing folly::ssl::OpenSSLUtils;\n\n// We have one single dummy SSL context so that we can implement attach\n// and detach methods in a thread safe fashion without modifying opnessl.\nstatic SSLContext* dummyCtx = nullptr;\nstatic SpinLock dummyCtxLock;\n\n// If given min write size is less than this, buffer will be allocated on\n// stack, otherwise it is allocated on heap\nconst size_t MAX_STACK_BUF_SIZE = 2048;\n\n// This converts \"illegal\" shutdowns into ZERO_RETURN\ninline bool zero_return(int error, int rc, int errno_copy) {\n  if (error == SSL_ERROR_ZERO_RETURN || (rc == 0 && errno_copy == 0)) {\n    return true;\n  }\n#ifdef _WIN32\n  // on windows underlying TCP socket may error with this code\n  // if the sending/receiving client crashes or is killed\n  if (error == SSL_ERROR_SYSCALL && errno_copy == WSAECONNRESET) {\n    return true;\n  }\n#endif\n  return false;\n}\n\nclass AsyncSSLSocketConnector : public AsyncSocket::ConnectCallback,\n                                public AsyncSSLSocket::HandshakeCB {\n private:\n  AsyncSSLSocket* sslSocket_;\n  AsyncSSLSocket::ConnectCallback* callback_;\n  std::chrono::milliseconds timeout_;\n  std::chrono::steady_clock::time_point startTime_;\n\n protected:\n  ~AsyncSSLSocketConnector() override {}\n\n public:\n  AsyncSSLSocketConnector(\n      AsyncSSLSocket* sslSocket,\n      AsyncSocket::ConnectCallback* callback,\n      std::chrono::milliseconds timeout)\n      : sslSocket_(sslSocket),\n        callback_(callback),\n        timeout_(timeout),\n        startTime_(std::chrono::steady_clock::now()) {}\n\n  void preConnect(folly::NetworkSocket fd) override {\n    VLOG(7) << \"client preConnect hook is invoked\";\n    if (callback_) {\n      callback_->preConnect(fd);\n    }\n  }\n\n  void connectSuccess() noexcept override {\n    VLOG(7) << \"client socket connected\";\n\n    std::chrono::milliseconds timeoutLeft{0};\n    if (timeout_ > std::chrono::milliseconds::zero()) {\n      auto curTime = std::chrono::steady_clock::now();\n\n      timeoutLeft = std::chrono::duration_cast<std::chrono::milliseconds>(\n          timeout_ - (curTime - startTime_));\n      if (timeoutLeft <= std::chrono::milliseconds::zero()) {\n        AsyncSocketException ex(\n            AsyncSocketException::TIMED_OUT,\n            folly::sformat(\n                \"SSL connect timed out after {}ms\", timeout_.count()));\n        fail(ex);\n        delete this;\n        return;\n      }\n    }\n    sslSocket_->sslConn(this, timeoutLeft);\n  }\n\n  void connectErr(const AsyncSocketException& ex) noexcept override {\n    VLOG(1) << \"TCP connect failed: \" << ex.what();\n    fail(ex);\n    delete this;\n  }\n\n  void handshakeSuc(AsyncSSLSocket* /* sock */) noexcept override {\n    VLOG(7) << \"client handshake success\";\n    if (callback_) {\n      callback_->connectSuccess();\n    }\n    delete this;\n  }\n\n  void handshakeErr(\n      AsyncSSLSocket* /* socket */,\n      const AsyncSocketException& ex) noexcept override {\n    VLOG(1) << \"client handshakeErr: \" << ex.what();\n    fail(ex);\n    delete this;\n  }\n\n  void fail(const AsyncSocketException& ex) {\n    // fail is a noop if called twice\n    if (callback_) {\n      AsyncSSLSocket::ConnectCallback* cb = callback_;\n      callback_ = nullptr;\n\n      cb->connectErr(ex);\n      sslSocket_->closeNow();\n      // closeNow can call handshakeErr if it hasn't been called already.\n      // So this may have been deleted, no member variable access beyond this\n      // point\n      // Note that closeNow may invoke writeError callbacks if the socket had\n      // write data pending connection completion.\n    }\n  }\n};\n\nvoid setup_SSL_CTX(SSL_CTX* ctx) {\n#ifdef SSL_MODE_RELEASE_BUFFERS\n  SSL_CTX_set_mode(\n      ctx,\n      SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_ENABLE_PARTIAL_WRITE |\n          SSL_MODE_RELEASE_BUFFERS);\n#else\n  SSL_CTX_set_mode(\n      ctx, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_ENABLE_PARTIAL_WRITE);\n#endif\n// SSL_CTX_set_mode is a Macro\n#ifdef SSL_MODE_WRITE_IOVEC\n  SSL_CTX_set_mode(ctx, SSL_CTX_get_mode(ctx) | SSL_MODE_WRITE_IOVEC);\n#endif\n}\n\n// Note: This is a Leaky Meyer's Singleton. The reason we can't use a non-leaky\n// thing is because we will be setting this BIO_METHOD* inside BIOs owned by\n// various SSL objects which may get callbacks even during teardown. We may\n// eventually try to fix this\nstatic BIO_METHOD* getSSLBioMethod() {\n  static auto const instance = OpenSSLUtils::newSocketBioMethod().release();\n  return instance;\n}\n\nvoid* initsslBioMethod() {\n  auto sslBioMethod = getSSLBioMethod();\n  // override the bwrite method for MSG_EOR support\n  OpenSSLUtils::setCustomBioWriteMethod(sslBioMethod, AsyncSSLSocket::bioWrite);\n  OpenSSLUtils::setCustomBioReadMethod(sslBioMethod, AsyncSSLSocket::bioRead);\n\n  // Note that the sslBioMethod.type and sslBioMethod.name are not\n  // set here. openssl code seems to be checking \".type == BIO_TYPE_SOCKET\" and\n  // then have specific handlings. The sslWriteBioWrite should be compatible\n  // with the one in openssl.\n\n  // Return something here to enable AsyncSSLSocket to call this method using\n  // a function-scoped static.\n  return nullptr;\n}\n\n} // namespace\n\nnamespace folly {\n\n/**\n * Create a client AsyncSSLSocket\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    bool deferSecurityNegotiation)\n    : AsyncSocket(evb),\n      ctx_(ctx),\n      handshakeTimeout_(this, evb),\n      connectionTimeout_(this, evb) {\n  init();\n  if (deferSecurityNegotiation) {\n    sslState_ = STATE_UNENCRYPTED;\n  }\n}\n\n/**\n * Create a server/client AsyncSSLSocket\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    NetworkSocket fd,\n    bool server,\n    bool deferSecurityNegotiation)\n    : AsyncSocket(evb, fd),\n      server_(server),\n      ctx_(ctx),\n      handshakeTimeout_(this, evb),\n      connectionTimeout_(this, evb) {\n  noTransparentTls_ = true;\n  init();\n  if (server) {\n    SSL_CTX_set_info_callback(\n        ctx_->getSSLCtx(), AsyncSSLSocket::sslInfoCallback);\n  }\n  if (deferSecurityNegotiation) {\n    sslState_ = STATE_UNENCRYPTED;\n  }\n}\n\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    AsyncSocket::UniquePtr oldAsyncSocket,\n    bool server,\n    bool deferSecurityNegotiation)\n    : AsyncSocket(std::move(oldAsyncSocket)),\n      server_(server),\n      ctx_(ctx),\n      handshakeTimeout_(this, AsyncSocket::getEventBase()),\n      connectionTimeout_(this, AsyncSocket::getEventBase()) {\n  noTransparentTls_ = true;\n  init();\n  if (server) {\n    SSL_CTX_set_info_callback(\n        ctx_->getSSLCtx(), AsyncSSLSocket::sslInfoCallback);\n  }\n  if (deferSecurityNegotiation) {\n    sslState_ = STATE_UNENCRYPTED;\n  }\n}\n\n#if FOLLY_OPENSSL_HAS_SNI\n/**\n * Create a client AsyncSSLSocket and allow tlsext_hostname\n * to be sent in Client Hello.\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    const std::string& serverName,\n    bool deferSecurityNegotiation)\n    : AsyncSSLSocket(ctx, evb, deferSecurityNegotiation) {\n  tlsextHostname_ = serverName;\n}\n\n/**\n * Create a client AsyncSSLSocket from an already connected fd\n * and allow tlsext_hostname to be sent in Client Hello.\n */\nAsyncSSLSocket::AsyncSSLSocket(\n    const shared_ptr<SSLContext>& ctx,\n    EventBase* evb,\n    NetworkSocket fd,\n    const std::string& serverName,\n    bool deferSecurityNegotiation)\n    : AsyncSSLSocket(ctx, evb, fd, false, deferSecurityNegotiation) {\n  tlsextHostname_ = serverName;\n}\n#endif // FOLLY_OPENSSL_HAS_SNI\n\nAsyncSSLSocket::~AsyncSSLSocket() {\n  VLOG(3) << \"actual destruction of AsyncSSLSocket(this=\" << this\n          << \", evb=\" << eventBase_ << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", sslState=\" << sslState_\n          << \", events=\" << eventFlags_ << \")\";\n}\n\nvoid AsyncSSLSocket::init() {\n  // Do this here to ensure we initialize this once before any use of\n  // AsyncSSLSocket instances and not as part of library load.\n  static const auto sslBioMethodInitializer = initsslBioMethod();\n  (void)sslBioMethodInitializer;\n\n  setup_SSL_CTX(ctx_->getSSLCtx());\n}\n\nvoid AsyncSSLSocket::closeNow() {\n  // Close the SSL connection.\n  if (ssl_ != nullptr && fd_ != NetworkSocket() && !waitingOnAccept_) {\n    int rc = SSL_shutdown(ssl_.get());\n    if (rc == 0) {\n      rc = SSL_shutdown(ssl_.get());\n    }\n    if (rc < 0) {\n      ERR_clear_error();\n    }\n  }\n\n  if (sslSession_ != nullptr) {\n    SSL_SESSION_free(sslSession_);\n    sslSession_ = nullptr;\n  }\n\n  sslState_ = STATE_CLOSED;\n\n  if (handshakeTimeout_.isScheduled()) {\n    handshakeTimeout_.cancelTimeout();\n  }\n\n  DestructorGuard dg(this);\n\n  static const Indestructible<AsyncSocketException> ex(\n      AsyncSocketException::END_OF_FILE, \"SSL connection closed locally\");\n  invokeHandshakeErr(*ex);\n\n  // Close the socket.\n  AsyncSocket::closeNow();\n}\n\nvoid AsyncSSLSocket::shutdownWrite() {\n  // SSL sockets do not support half-shutdown, so just perform a full shutdown.\n  //\n  // (Performing a full shutdown here is more desirable than doing nothing at\n  // all.  The purpose of shutdownWrite() is normally to notify the other end\n  // of the connection that no more data will be sent.  If we do nothing, the\n  // other end will never know that no more data is coming, and this may result\n  // in protocol deadlock.)\n  close();\n}\n\nvoid AsyncSSLSocket::shutdownWriteNow() {\n  closeNow();\n}\n\nbool AsyncSSLSocket::good() const {\n  return (\n      AsyncSocket::good() &&\n      (sslState_ == STATE_ACCEPTING || sslState_ == STATE_CONNECTING ||\n       sslState_ == STATE_ESTABLISHED || sslState_ == STATE_UNENCRYPTED ||\n       sslState_ == STATE_UNINIT));\n}\n\n// The TAsyncTransport definition of 'good' states that the transport is\n// ready to perform reads and writes, so sslState_ == UNINIT must report !good.\n// connecting can be true when the sslState_ == UNINIT because the AsyncSocket\n// is connected but we haven't initiated the call to SSL_connect.\nbool AsyncSSLSocket::connecting() const {\n  return (\n      !server_ &&\n      (AsyncSocket::connecting() ||\n       (AsyncSocket::good() &&\n        (sslState_ == STATE_UNINIT || sslState_ == STATE_CONNECTING))));\n}\n\nstd::string AsyncSSLSocket::getApplicationProtocol() const noexcept {\n  const unsigned char* protoName = nullptr;\n  unsigned protoLength;\n  if (getSelectedNextProtocolNoThrow(&protoName, &protoLength)) {\n    return std::string(reinterpret_cast<const char*>(protoName), protoLength);\n  }\n  return \"\";\n}\n\nvoid AsyncSSLSocket::setEorTracking(bool track) {\n  if (isEorTrackingEnabled() != track) {\n    AsyncSocket::setEorTracking(track);\n    appEorByteNo_ = 0;\n    appEorByteWriteFlags_ = {};\n    minEorRawByteNo_ = 0;\n  }\n}\n\nsize_t AsyncSSLSocket::getRawBytesWritten() const {\n  // The bio(s) in the write path are in a chain\n  // each bio flushes to the next and finally written into the socket\n  // to get the rawBytesWritten on the socket,\n  // get the write bytes of the last bio\n  BIO* b;\n  if (!ssl_ || !(b = SSL_get_wbio(ssl_.get()))) {\n    return 0;\n  }\n  BIO* next = BIO_next(b);\n  while (next != nullptr) {\n    b = next;\n    next = BIO_next(b);\n  }\n\n  return BIO_number_written(b);\n}\n\nsize_t AsyncSSLSocket::getRawBytesReceived() const {\n  BIO* b;\n  if (!ssl_ || !(b = SSL_get_rbio(ssl_.get()))) {\n    return 0;\n  }\n\n  return BIO_number_read(b);\n}\n\nvoid AsyncSSLSocket::invalidState(HandshakeCB* callback) {\n  LOG(ERROR) << \"AsyncSSLSocket(this=\" << this << \", fd=\" << fd_\n             << \", state=\" << int(state_) << \", sslState=\" << sslState_ << \", \"\n             << \"events=\" << eventFlags_ << \", server=\" << short(server_)\n             << \"): \"\n             << \"sslAccept/Connect() called in invalid \"\n             << \"state, handshake callback \" << handshakeCallback_\n             << \", new callback \" << callback;\n  assert(!handshakeTimeout_.isScheduled());\n  sslState_ = STATE_ERROR;\n\n  static const Indestructible<AsyncSocketException> ex(\n      AsyncSocketException::INVALID_STATE,\n      \"sslAccept() called with socket in invalid state\");\n\n  handshakeEndTime_ = std::chrono::steady_clock::now();\n  if (callback) {\n    callback->handshakeErr(this, *ex);\n  }\n\n  failHandshake(__func__, *ex);\n}\n\nvoid AsyncSSLSocket::sslAccept(\n    HandshakeCB* callback,\n    std::chrono::milliseconds timeout,\n    const SSLContext::SSLVerifyPeerEnum& verifyPeer) {\n  DestructorGuard dg(this);\n  eventBase_->dcheckIsInEventBaseThread();\n  verifyPeer_ = verifyPeer;\n\n  // Make sure we're in the uninitialized state\n  if (!server_ ||\n      (sslState_ != STATE_UNINIT && sslState_ != STATE_UNENCRYPTED) ||\n      handshakeCallback_ != nullptr) {\n    return invalidState(callback);\n  }\n\n  // Cache local and remote socket addresses to keep them available\n  // after socket file descriptor is closed.\n  if (cacheAddrOnFailure_) {\n    cacheAddresses();\n  }\n\n  handshakeStartTime_ = std::chrono::steady_clock::now();\n  // Make end time at least >= start time.\n  handshakeEndTime_ = handshakeStartTime_;\n\n  sslState_ = STATE_ACCEPTING;\n  handshakeCallback_ = callback;\n\n  if (timeout > std::chrono::milliseconds::zero()) {\n    handshakeTimeout_.scheduleTimeout(timeout);\n  }\n\n  /* register for a read operation (waiting for CLIENT HELLO) */\n  updateEventRegistration(EventHandler::READ, EventHandler::WRITE);\n\n  checkForImmediateRead();\n}\n\nvoid AsyncSSLSocket::attachSSLContext(const std::shared_ptr<SSLContext>& ctx) {\n  // Check to ensure we are in client mode. Changing a server's ssl\n  // context doesn't make sense since clients of that server would likely\n  // become confused when the server's context changes.\n  DCHECK(!server_);\n  DCHECK(!ctx_);\n  DCHECK(ctx);\n  DCHECK(ctx->getSSLCtx());\n  ctx_ = ctx;\n\n  // It's possible this could be attached before ssl_ is set up\n  if (!ssl_) {\n    return;\n  }\n\n  // In order to call attachSSLContext, detachSSLContext must have been\n  // previously called.\n  // We need to update the initial_ctx if necessary\n  // The 'initial_ctx' inside an SSL* points to the context that it was created\n  // with, which is also where session callbacks and servername callbacks\n  // happen.\n  // When we switch to a different SSL_CTX, we want to update the initial_ctx as\n  // well so that any callbacks don't go to a different object\n  // NOTE: this will only work if we have access to ssl_ internals, so it may\n  // not work on\n  // OpenSSL version >= 1.1.0\n  auto sslCtx = ctx->getSSLCtx();\n  OpenSSLUtils::setSSLInitialCtx(ssl_.get(), sslCtx);\n  // Detach sets the socket's context to the dummy context. Thus we must acquire\n  // this lock.\n  SpinLockGuard guard(dummyCtxLock);\n  SSL_set_SSL_CTX(ssl_.get(), sslCtx);\n}\n\nvoid AsyncSSLSocket::detachSSLContext() {\n  DCHECK(ctx_);\n  ctx_.reset();\n  // It's possible for this to be called before ssl_ has been\n  // set up\n  if (!ssl_) {\n    return;\n  }\n  // The 'initial_ctx' inside an SSL* points to the context that it was created\n  // with, which is also where session callbacks and servername callbacks\n  // happen.\n  // Detach the initial_ctx as well.  It will be reattached in attachSSLContext\n  // it is used for session info.\n  // NOTE: this will only work if we have access to ssl_ internals, so it may\n  // not work on\n  // OpenSSL version >= 1.1.0\n  SSL_CTX* initialCtx = OpenSSLUtils::getSSLInitialCtx(ssl_.get());\n  if (initialCtx) {\n    SSL_CTX_free(initialCtx);\n    OpenSSLUtils::setSSLInitialCtx(ssl_.get(), nullptr);\n  }\n\n  SpinLockGuard guard(dummyCtxLock);\n  if (nullptr == dummyCtx) {\n    // We need to lazily initialize the dummy context so we don't\n    // accidentally override any programmatic settings to openssl\n    dummyCtx = new SSLContext;\n  }\n  // We must remove this socket's references to its context right now\n  // since this socket could get passed to any thread. If the context has\n  // had its locking disabled, just doing a set in attachSSLContext()\n  // would not be thread safe.\n  SSL_set_SSL_CTX(ssl_.get(), dummyCtx->getSSLCtx());\n}\n\n#if FOLLY_OPENSSL_HAS_SNI\nvoid AsyncSSLSocket::switchServerSSLContext(\n    const std::shared_ptr<SSLContext>& handshakeCtx) {\n  CHECK(server_);\n  if (sslState_ != STATE_ACCEPTING) {\n    // We log it here and allow the switch.\n    // It should not affect our re-negotiation support (which\n    // is not supported now).\n    VLOG(6) << \"fd=\" << getNetworkSocket()\n            << \" renegotation detected when switching SSL_CTX\";\n  }\n\n  setup_SSL_CTX(handshakeCtx->getSSLCtx());\n  SSL_CTX_set_info_callback(\n      handshakeCtx->getSSLCtx(), AsyncSSLSocket::sslInfoCallback);\n  handshakeCtx_ = handshakeCtx;\n  SSL_set_SSL_CTX(ssl_.get(), handshakeCtx->getSSLCtx());\n}\n\nbool AsyncSSLSocket::isServerNameMatch() const {\n  CHECK(!server_);\n\n  if (!ssl_) {\n    return false;\n  }\n\n  SSL_SESSION* ss = SSL_get_session(ssl_.get());\n  if (!ss) {\n    return false;\n  }\n\n  auto tlsextHostname = SSL_SESSION_get0_hostname(ss);\n  return (tlsextHostname && !tlsextHostname_.compare(tlsextHostname));\n}\n\nvoid AsyncSSLSocket::setServerName(std::string serverName) noexcept {\n  tlsextHostname_ = std::move(serverName);\n}\n\n#endif // FOLLY_OPENSSL_HAS_SNI\n\nvoid AsyncSSLSocket::timeoutExpired(\n    std::chrono::milliseconds timeout) noexcept {\n  if (state_ == StateEnum::ESTABLISHED && sslState_ == STATE_ASYNC_PENDING) {\n    sslState_ = STATE_ERROR;\n    // We are expecting a callback in restartSSLAccept.  The cache lookup\n    // and rsa-call necessarily have pointers to this ssl socket, so delay\n    // the cleanup until he calls us back.\n  } else if (state_ == StateEnum::CONNECTING) {\n    assert(sslState_ == STATE_CONNECTING);\n    DestructorGuard dg(this);\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::TIMED_OUT,\n        \"Fallback connect timed out during TFO\");\n    failHandshake(__func__, *ex);\n  } else {\n    assert(\n        state_ == StateEnum::ESTABLISHED &&\n        (sslState_ == STATE_CONNECTING || sslState_ == STATE_ACCEPTING));\n    DestructorGuard dg(this);\n    AsyncSocketException ex(\n        AsyncSocketException::TIMED_OUT,\n        folly::sformat(\n            \"SSL {} timed out after {}ms\",\n            (sslState_ == STATE_CONNECTING) ? \"connect\" : \"accept\",\n            timeout.count()));\n    failHandshake(__func__, ex);\n  }\n}\n\nint AsyncSSLSocket::getSSLExDataIndex() {\n  static auto index = SSL_get_ex_new_index(\n      0, (void*)\"AsyncSSLSocket data index\", nullptr, nullptr, nullptr);\n  return index;\n}\n\nAsyncSSLSocket* AsyncSSLSocket::getFromSSL(const SSL* ssl) {\n  return static_cast<AsyncSSLSocket*>(\n      SSL_get_ex_data(ssl, getSSLExDataIndex()));\n}\n\nvoid AsyncSSLSocket::failHandshake(\n    const char* /* fn */,\n    const AsyncSocketException& ex) {\n  startFail();\n  if (handshakeTimeout_.isScheduled()) {\n    handshakeTimeout_.cancelTimeout();\n  }\n  invokeHandshakeErr(ex);\n  finishFail();\n}\n\nvoid AsyncSSLSocket::invokeHandshakeErr(const AsyncSocketException& ex) {\n  handshakeEndTime_ = std::chrono::steady_clock::now();\n  if (handshakeCallback_ != nullptr) {\n    HandshakeCB* callback = handshakeCallback_;\n    handshakeCallback_ = nullptr;\n    callback->handshakeErr(this, ex);\n  }\n}\n\nvoid AsyncSSLSocket::invokeHandshakeCB() {\n  handshakeEndTime_ = std::chrono::steady_clock::now();\n  if (handshakeTimeout_.isScheduled()) {\n    handshakeTimeout_.cancelTimeout();\n  }\n  if (handshakeCallback_) {\n    HandshakeCB* callback = handshakeCallback_;\n    handshakeCallback_ = nullptr;\n    callback->handshakeSuc(this);\n  }\n}\n\nvoid AsyncSSLSocket::connect(\n    ConnectCallback* callback,\n    const folly::SocketAddress& address,\n    int timeout,\n    const OptionMap& options,\n    const folly::SocketAddress& bindAddr) noexcept {\n  auto timeoutChrono = std::chrono::milliseconds(timeout);\n  connect(callback, address, timeoutChrono, timeoutChrono, options, bindAddr);\n}\n\nvoid AsyncSSLSocket::connect(\n    ConnectCallback* callback,\n    const folly::SocketAddress& address,\n    std::chrono::milliseconds connectTimeout,\n    std::chrono::milliseconds totalConnectTimeout,\n    const OptionMap& options,\n    const folly::SocketAddress& bindAddr) noexcept {\n  assert(!server_);\n  assert(state_ == StateEnum::UNINIT);\n  assert(sslState_ == STATE_UNINIT || sslState_ == STATE_UNENCRYPTED);\n  noTransparentTls_ = true;\n  totalConnectTimeout_ = totalConnectTimeout;\n  if (sslState_ != STATE_UNENCRYPTED) {\n    callback = new AsyncSSLSocketConnector(this, callback, totalConnectTimeout);\n  }\n  AsyncSocket::connect(\n      callback, address, int(connectTimeout.count()), options, bindAddr);\n}\n\nbool AsyncSSLSocket::needsPeerVerification() const {\n  if (verifyPeer_ == SSLContext::SSLVerifyPeerEnum::USE_CTX) {\n    return ctx_->needsPeerVerification();\n  }\n  return (\n      verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY ||\n      verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n}\n\nvoid AsyncSSLSocket::applyVerificationOptions(const ssl::SSLUniquePtr& ssl) {\n  // apply the settings specified in verifyPeer_\n  if (verifyPeer_ == SSLContext::SSLVerifyPeerEnum::USE_CTX) {\n    if (ctx_->needsPeerVerification()) {\n      SSL_set_verify(\n          ssl.get(),\n          ctx_->getVerificationMode(),\n          AsyncSSLSocket::sslVerifyCallback);\n    }\n  } else {\n    if (verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY ||\n        verifyPeer_ == SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT) {\n      SSL_set_verify(\n          ssl.get(),\n          SSLContext::getVerificationMode(verifyPeer_),\n          AsyncSSLSocket::sslVerifyCallback);\n    }\n  }\n}\n\nbool AsyncSSLSocket::setupSSLBio() {\n  auto sslBio = BIO_new(getSSLBioMethod());\n\n  if (!sslBio) {\n    return false;\n  }\n\n  OpenSSLUtils::setBioAppData(sslBio, this);\n  OpenSSLUtils::setBioFd(sslBio, fd_, BIO_NOCLOSE);\n  SSL_set_bio(ssl_.get(), sslBio, sslBio);\n  return true;\n}\n\nvoid AsyncSSLSocket::sslConn(\n    HandshakeCB* callback,\n    std::chrono::milliseconds timeout,\n    const SSLContext::SSLVerifyPeerEnum& verifyPeer) {\n  DestructorGuard dg(this);\n  eventBase_->dcheckIsInEventBaseThread();\n\n  // Cache local and remote socket addresses to keep them available\n  // after socket file descriptor is closed.\n  if (cacheAddrOnFailure_) {\n    cacheAddresses();\n  }\n\n  verifyPeer_ = verifyPeer;\n\n  // Make sure we're in the uninitialized state\n  if (server_ ||\n      (sslState_ != STATE_UNINIT && sslState_ != STATE_UNENCRYPTED) ||\n      handshakeCallback_ != nullptr) {\n    return invalidState(callback);\n  }\n\n  sslState_ = STATE_CONNECTING;\n  handshakeCallback_ = callback;\n\n  try {\n    ssl_.reset(ctx_->createSSL());\n  } catch (std::exception& e) {\n    sslState_ = STATE_ERROR;\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::INTERNAL_ERROR,\n        \"error calling SSLContext::createSSL()\");\n    LOG(ERROR) << \"AsyncSSLSocket::sslConn(this=\" << this << \", fd=\" << fd_\n               << \"): \" << e.what();\n    return failHandshake(__func__, *ex);\n  }\n\n  if (!setupSSLBio()) {\n    sslState_ = STATE_ERROR;\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::INTERNAL_ERROR, \"error creating SSL bio\");\n    return failHandshake(__func__, *ex);\n  }\n\n  applyVerificationOptions(ssl_);\n\n  if (sslSession_ != nullptr) {\n    sessionResumptionAttempted_ = true;\n    SSL_set_session(ssl_.get(), sslSession_);\n    SSL_SESSION_free(sslSession_);\n    sslSession_ = nullptr;\n  }\n#if FOLLY_OPENSSL_HAS_SNI\n  if (tlsextHostname_.size()) {\n    SSL_set_tlsext_host_name(ssl_.get(), tlsextHostname_.c_str());\n  }\n#endif\n\n  SSL_set_ex_data(ssl_.get(), getSSLExDataIndex(), this);\n\n  handshakeConnectTimeout_ = timeout;\n  startSSLConnect();\n}\n\n// This could be called multiple times, during normal ssl connections\n// and after TFO fallback.\nvoid AsyncSSLSocket::startSSLConnect() {\n  handshakeStartTime_ = std::chrono::steady_clock::now();\n  // Make end time at least >= start time.\n  handshakeEndTime_ = handshakeStartTime_;\n  if (handshakeConnectTimeout_ > std::chrono::milliseconds::zero()) {\n    handshakeTimeout_.scheduleTimeout(handshakeConnectTimeout_);\n  }\n  handleConnect();\n}\n\nSSL_SESSION* AsyncSSLSocket::getSSLSession() {\n  if (ssl_ != nullptr && sslState_ == STATE_ESTABLISHED) {\n    return SSL_get1_session(ssl_.get());\n  }\n\n  return sslSession_;\n}\n\nconst SSL* AsyncSSLSocket::getSSL() const {\n  return ssl_.get();\n}\n\nvoid AsyncSSLSocket::setSSLSession(SSL_SESSION* session, bool takeOwnership) {\n  if (sslSession_) {\n    SSL_SESSION_free(sslSession_);\n  }\n  sslSession_ = session;\n  if (!takeOwnership && session != nullptr) {\n    // Increment the reference count\n    // This API exists in BoringSSL and OpenSSL 1.1.0\n    SSL_SESSION_up_ref(session);\n  }\n}\n\nvoid AsyncSSLSocket::getSelectedNextProtocol(\n    const unsigned char** protoName,\n    unsigned* protoLen) const {\n  if (!getSelectedNextProtocolNoThrow(protoName, protoLen)) {\n    throw AsyncSocketException(\n        AsyncSocketException::NOT_SUPPORTED, \"ALPN not supported\");\n  }\n}\n\nbool AsyncSSLSocket::getSelectedNextProtocolNoThrow(\n    const unsigned char** protoName,\n    unsigned* protoLen) const {\n  *protoName = nullptr;\n  *protoLen = 0;\n#if FOLLY_OPENSSL_HAS_ALPN\n  SSL_get0_alpn_selected(ssl_.get(), protoName, protoLen);\n  return true;\n#else\n  return false;\n#endif\n}\n\nbool AsyncSSLSocket::getSSLSessionReused() const {\n  if (ssl_ != nullptr && sslState_ == STATE_ESTABLISHED) {\n    return SSL_session_reused(ssl_.get());\n  }\n  return false;\n}\n\nconst char* AsyncSSLSocket::getNegotiatedCipherName() const {\n  return (ssl_ != nullptr) ? SSL_get_cipher_name(ssl_.get()) : nullptr;\n}\n\n/* static */\nconst char* AsyncSSLSocket::getSSLServerNameFromSSL(SSL* ssl) {\n  if (ssl == nullptr) {\n    return nullptr;\n  }\n#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n#else\n  return nullptr;\n#endif\n}\n\nconst char* AsyncSSLSocket::getSSLServerName() const {\n  if (clientHelloInfo_ && !clientHelloInfo_->clientHelloSNIHostname_.empty()) {\n    return clientHelloInfo_->clientHelloSNIHostname_.c_str();\n  }\n#ifdef SSL_CTRL_SET_TLSEXT_SERVERNAME_CB\n  return getSSLServerNameFromSSL(ssl_.get());\n#else\n  throw AsyncSocketException(\n      AsyncSocketException::NOT_SUPPORTED, \"SNI not supported\");\n#endif\n}\n\nconst char* AsyncSSLSocket::getSSLServerNameNoThrow() const {\n  if (clientHelloInfo_ && !clientHelloInfo_->clientHelloSNIHostname_.empty()) {\n    return clientHelloInfo_->clientHelloSNIHostname_.c_str();\n  }\n  return getSSLServerNameFromSSL(ssl_.get());\n}\n\nint AsyncSSLSocket::getSSLVersion() const {\n  return (ssl_ != nullptr) ? SSL_version(ssl_.get()) : 0;\n}\n\nconst char* AsyncSSLSocket::getSSLCertSigAlgName() const {\n  X509* cert = (ssl_ != nullptr) ? SSL_get_certificate(ssl_.get()) : nullptr;\n  if (cert) {\n    int nid = X509_get_signature_nid(cert);\n    return OBJ_nid2ln(nid);\n  }\n  return nullptr;\n}\n\nint AsyncSSLSocket::getSSLCertSize() const {\n  int certSize = 0;\n  X509* cert = (ssl_ != nullptr) ? SSL_get_certificate(ssl_.get()) : nullptr;\n  if (cert) {\n    EVP_PKEY* key = X509_get_pubkey(cert);\n    certSize = EVP_PKEY_bits(key);\n    EVP_PKEY_free(key);\n  }\n  return certSize;\n}\n\nconst AsyncTransportCertificate* AsyncSSLSocket::getPeerCertificate() const {\n  if (peerCertData_) {\n    return peerCertData_.get();\n  }\n  if (ssl_ != nullptr) {\n    auto peerX509 = SSL_get_peer_certificate(ssl_.get());\n    if (peerX509) {\n      // already up ref'd\n      folly::ssl::X509UniquePtr peer(peerX509);\n      auto cn = OpenSSLUtils::getCommonName(peerX509);\n      peerCertData_ = std::make_unique<BasicTransportCertificate>(\n          std::move(cn), std::move(peer));\n    }\n  }\n  return peerCertData_.get();\n}\n\nconst AsyncTransportCertificate* AsyncSSLSocket::getSelfCertificate() const {\n  if (selfCertData_) {\n    return selfCertData_.get();\n  }\n  if (ssl_ != nullptr) {\n    auto selfX509 = SSL_get_certificate(ssl_.get());\n    if (selfX509) {\n      // need to upref\n      X509_up_ref(selfX509);\n      folly::ssl::X509UniquePtr peer(selfX509);\n      auto cn = OpenSSLUtils::getCommonName(selfX509);\n      selfCertData_ = std::make_unique<BasicTransportCertificate>(\n          std::move(cn), std::move(peer));\n    }\n  }\n  return selfCertData_.get();\n}\n\nbool AsyncSSLSocket::willBlock(\n    int ret,\n    int* sslErrorOut,\n    unsigned long* errErrorOut) noexcept {\n  *errErrorOut = 0;\n  int error = *sslErrorOut = SSL_get_error(ssl_.get(), ret);\n  if (error == SSL_ERROR_WANT_READ) {\n    // Register for read event if not already.\n    updateEventRegistration(EventHandler::READ, EventHandler::WRITE);\n    return true;\n  } else if (error == SSL_ERROR_WANT_WRITE) {\n    VLOG(3) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL_ERROR_WANT_WRITE\";\n    // Register for write event if not already.\n    updateEventRegistration(EventHandler::WRITE, EventHandler::READ);\n    return true;\n  } else if ((false\n#ifdef SSL_ERROR_WANT_ASYNC // OpenSSL 1.1.0 Async API\n              || error == SSL_ERROR_WANT_ASYNC\n#endif\n              )) {\n    // An asynchronous request has been kicked off. On completion, it will\n    // invoke a callback to re-call handleAccept\n    sslState_ = STATE_ASYNC_PENDING;\n\n    // Unregister for all events while blocked here\n    updateEventRegistration(\n        EventHandler::NONE, EventHandler::READ | EventHandler::WRITE);\n\n#ifdef SSL_ERROR_WANT_ASYNC\n    if (error == SSL_ERROR_WANT_ASYNC) {\n      size_t numfds;\n      if (SSL_get_all_async_fds(ssl_.get(), NULL, &numfds) <= 0) {\n        VLOG(4) << \"SSL_ERROR_WANT_ASYNC but no async FDs set!\";\n        return false;\n      }\n      if (numfds != 1) {\n        VLOG(4) << \"SSL_ERROR_WANT_ASYNC expected exactly 1 async fd, got \"\n                << numfds;\n        return false;\n      }\n      OSSL_ASYNC_FD ofd; // This should just be an int in POSIX\n      if (SSL_get_all_async_fds(ssl_.get(), &ofd, &numfds) <= 0) {\n        VLOG(4) << \"SSL_ERROR_WANT_ASYNC cant get async fd\";\n        return false;\n      }\n\n      // On POSIX systems, OSSL_ASYNC_FD is type int, but on win32\n      // it has type HANDLE.\n      // Our NetworkSocket::native_handle_type is type SOCKET on\n      // win32, which means that we need to explicitly construct\n      // a native handle type to pass to the constructor.\n      auto native_handle = NetworkSocket::native_handle_type(ofd);\n\n      auto asyncPipeReader =\n          AsyncPipeReader::newReader(eventBase_, NetworkSocket(native_handle));\n      auto asyncPipeReaderPtr = asyncPipeReader.get();\n      if (!asyncOperationFinishCallback_) {\n        asyncOperationFinishCallback_.reset(\n            new DefaultOpenSSLAsyncFinishCallback(\n                std::move(asyncPipeReader), this, DestructorGuard(this)));\n      }\n      asyncPipeReaderPtr->setReadCB(asyncOperationFinishCallback_.get());\n    }\n#endif\n\n    // The timeout (if set) keeps running here\n    return true;\n  } else {\n    unsigned long lastError = *errErrorOut = ERR_get_error();\n    VLOG(6) << \"AsyncSSLSocket(fd=\" << fd_ << \", \"\n            << \"state=\" << state_ << \", \"\n            << \"sslState=\" << sslState_ << \", \"\n            << \"events=\" << std::hex << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", \"\n            << \"errno: \" << errno << \", \"\n            << \"ret: \" << ret << \", \"\n            << \"read: \" << BIO_number_read(SSL_get_rbio(ssl_.get())) << \", \"\n            << \"written: \" << BIO_number_written(SSL_get_wbio(ssl_.get()))\n            << \", \"\n            << \"func: \" << ERR_func_error_string(lastError) << \", \"\n            << \"reason: \" << ERR_reason_error_string(lastError);\n    return false;\n  }\n}\n\nvoid AsyncSSLSocket::checkForImmediateRead() noexcept {\n  // openssl may have buffered data that it read from the socket already.\n  // In this case we have to process it immediately, rather than waiting for\n  // the socket to become readable again.\n  if (ssl_ != nullptr && SSL_pending(ssl_.get()) > 0) {\n    AsyncSocket::handleRead();\n  } else {\n    AsyncSocket::checkForImmediateRead();\n  }\n}\n\nvoid AsyncSSLSocket::restartSSLAccept() {\n  VLOG(3) << \"AsyncSSLSocket::restartSSLAccept() this=\" << this\n          << \", fd=\" << fd_ << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  DestructorGuard dg(this);\n  assert(\n      sslState_ == STATE_ASYNC_PENDING || sslState_ == STATE_ERROR ||\n      sslState_ == STATE_CLOSED);\n  if (sslState_ == STATE_CLOSED) {\n    // I sure hope whoever closed this socket didn't delete it already,\n    // but this is not strictly speaking an error\n    return;\n  }\n  if (sslState_ == STATE_ERROR) {\n    // go straight to fail if timeout expired during lookup\n    static const Indestructible<AsyncSocketException> ex(\n        AsyncSocketException::TIMED_OUT, \"SSL accept timed out\");\n    failHandshake(__func__, *ex);\n    return;\n  }\n  sslState_ = STATE_ACCEPTING;\n  this->handleAccept();\n}\n\nvoid AsyncSSLSocket::handleAccept() noexcept {\n  VLOG(3) << \"AsyncSSLSocket::handleAccept() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  assert(server_);\n  assert(state_ == StateEnum::ESTABLISHED && sslState_ == STATE_ACCEPTING);\n  if (!ssl_) {\n    /* lazily create the SSL structure */\n    try {\n      ssl_.reset(ctx_->createSSL());\n    } catch (std::exception& e) {\n      sslState_ = STATE_ERROR;\n      static const Indestructible<AsyncSocketException> ex(\n          AsyncSocketException::INTERNAL_ERROR,\n          \"error calling SSLContext::createSSL()\");\n      LOG(ERROR) << \"AsyncSSLSocket::handleAccept(this=\" << this\n                 << \", fd=\" << fd_ << \"): \" << e.what();\n      return failHandshake(__func__, *ex);\n    }\n\n    if (!setupSSLBio()) {\n      sslState_ = STATE_ERROR;\n      static const Indestructible<AsyncSocketException> ex(\n          AsyncSocketException::INTERNAL_ERROR, \"error creating write bio\");\n      return failHandshake(__func__, *ex);\n    }\n\n    SSL_set_ex_data(ssl_.get(), getSSLExDataIndex(), this);\n\n    applyVerificationOptions(ssl_);\n  }\n\n  if (server_ && parseClientHello_) {\n    SSL_set_msg_callback(\n        ssl_.get(), &AsyncSSLSocket::clientHelloParsingCallback);\n    SSL_set_msg_callback_arg(ssl_.get(), this);\n  }\n\n  DCHECK(ctx_->sslAcceptRunner());\n  updateEventRegistration(\n      EventHandler::NONE, EventHandler::READ | EventHandler::WRITE);\n  DelayedDestruction::DestructorGuard dg(this);\n  ctx_->sslAcceptRunner()->run(\n      [this, dg]() {\n        waitingOnAccept_ = true;\n        return SSL_accept(ssl_.get());\n      },\n      [this, dg](int ret) {\n        waitingOnAccept_ = false;\n        handleReturnFromSSLAccept(ret);\n      });\n}\n\nvoid AsyncSSLSocket::handleReturnFromSSLAccept(int ret) {\n  if (sslState_ != STATE_ACCEPTING) {\n    return;\n  }\n\n  if (ret <= 0) {\n    VLOG(3) << \"SSL_accept returned: \" << ret;\n    int sslError;\n    unsigned long errError;\n    int errnoCopy = errno;\n    if (willBlock(ret, &sslError, &errError)) {\n      return;\n    } else {\n      sslState_ = STATE_ERROR;\n      SSLException ex(sslError, errError, ret, errnoCopy);\n      return failHandshake(__func__, ex);\n    }\n  }\n\n  handshakeComplete_ = true;\n  updateEventRegistration(0, EventHandler::READ | EventHandler::WRITE);\n\n  // Move into STATE_ESTABLISHED in the normal case that we are in\n  // STATE_ACCEPTING.\n  sslState_ = STATE_ESTABLISHED;\n\n  VLOG(3) << \"AsyncSSLSocket \" << this << \": fd \" << fd_\n          << \" successfully accepted; state=\" << int(state_)\n          << \", sslState=\" << sslState_ << \", events=\" << eventFlags_;\n\n  // Remember the EventBase we are attached to, before we start invoking any\n  // callbacks (since the callbacks may call detachEventBase()).\n  EventBase* originalEventBase = eventBase_;\n\n  // Call the accept callback.\n  invokeHandshakeCB();\n\n  // Note that the accept callback may have changed our state.\n  // (set or unset the read callback, called write(), closed the socket, etc.)\n  // The following code needs to handle these situations correctly.\n  //\n  // If the socket has been closed, readCallback_ and writeReqHead_ will\n  // always be nullptr, so that will prevent us from trying to read or write.\n  //\n  // The main thing to check for is if eventBase_ is still originalEventBase.\n  // If not, we have been detached from this event base, so we shouldn't\n  // perform any more operations.\n  if (eventBase_ != originalEventBase) {\n    return;\n  }\n\n  AsyncSocket::handleInitialReadWrite();\n}\n\nvoid AsyncSSLSocket::handleConnect() noexcept {\n  VLOG(3) << \"AsyncSSLSocket::handleConnect() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  assert(!server_);\n  if (state_ < StateEnum::ESTABLISHED) {\n    return AsyncSocket::handleConnect();\n  }\n\n  assert(\n      (state_ == StateEnum::FAST_OPEN || state_ == StateEnum::ESTABLISHED) &&\n      sslState_ == STATE_CONNECTING);\n  assert(ssl_);\n\n  auto originalState = state_;\n  int ret = SSL_connect(ssl_.get());\n  if (ret <= 0) {\n    int sslError;\n    unsigned long errError;\n    int errnoCopy = errno;\n    if (willBlock(ret, &sslError, &errError)) {\n      // We fell back to connecting state due to TFO\n      if (state_ == StateEnum::CONNECTING) {\n        DCHECK_EQ(StateEnum::FAST_OPEN, originalState);\n        if (handshakeTimeout_.isScheduled()) {\n          handshakeTimeout_.cancelTimeout();\n        }\n      }\n      return;\n    } else {\n      sslState_ = STATE_ERROR;\n      SSLException ex(sslError, errError, ret, errnoCopy);\n      return failHandshake(__func__, ex);\n    }\n  }\n\n  handshakeComplete_ = true;\n  updateEventRegistration(0, EventHandler::READ | EventHandler::WRITE);\n\n  // Move into STATE_ESTABLISHED in the normal case that we are in\n  // STATE_CONNECTING.\n  sslState_ = STATE_ESTABLISHED;\n\n  VLOG(3) << \"AsyncSSLSocket \" << this << \": \"\n          << \"fd \" << fd_ << \" successfully connected; \"\n          << \"state=\" << int(state_) << \", sslState=\" << sslState_\n          << \", events=\" << eventFlags_;\n\n  // Remember the EventBase we are attached to, before we start invoking any\n  // callbacks (since the callbacks may call detachEventBase()).\n  EventBase* originalEventBase = eventBase_;\n\n  // Call the handshake callback.\n  invokeHandshakeCB();\n\n  // Note that the connect callback may have changed our state.\n  // (set or unset the read callback, called write(), closed the socket, etc.)\n  // The following code needs to handle these situations correctly.\n  //\n  // If the socket has been closed, readCallback_ and writeReqHead_ will\n  // always be nullptr, so that will prevent us from trying to read or write.\n  //\n  // The main thing to check for is if eventBase_ is still originalEventBase.\n  // If not, we have been detached from this event base, so we shouldn't\n  // perform any more operations.\n  if (eventBase_ != originalEventBase) {\n    return;\n  }\n\n  AsyncSocket::handleInitialReadWrite();\n}\n\nvoid AsyncSSLSocket::invokeConnectErr(const AsyncSocketException& ex) {\n  connectionTimeout_.cancelTimeout();\n  AsyncSocket::invokeConnectErr(ex);\n  if (sslState_ == SSLStateEnum::STATE_CONNECTING) {\n    if (handshakeTimeout_.isScheduled()) {\n      handshakeTimeout_.cancelTimeout();\n    }\n    // If we fell back to connecting state during TFO and the connection\n    // failed, it would be an SSL failure as well.\n    invokeHandshakeErr(ex);\n  }\n}\n\nvoid AsyncSSLSocket::invokeConnectSuccess() {\n  connectionTimeout_.cancelTimeout();\n  if (sslState_ == SSLStateEnum::STATE_CONNECTING) {\n    assert(tfoAttempted_);\n    // If we failed TFO, we'd fall back to trying to connect the socket,\n    // to setup things like timeouts.\n    startSSLConnect();\n  }\n  // still invoke the base class since it re-sets the connect time.\n  AsyncSocket::invokeConnectSuccess();\n}\n\nvoid AsyncSSLSocket::scheduleConnectTimeout() {\n  if (sslState_ == SSLStateEnum::STATE_CONNECTING) {\n    // We fell back from TFO, and need to set the timeouts.\n    // We will not have a connect callback in this case, thus if the timer\n    // expires we would have no-one to notify.\n    // Thus we should reset even the connect timers to point to the handshake\n    // timeouts.\n    assert(connectCallback_ == nullptr);\n    // We use a different connect timeout here than the handshake timeout, so\n    // that we can disambiguate the 2 timers.\n    if (connectTimeout_.count() > 0) {\n      if (!connectionTimeout_.scheduleTimeout(connectTimeout_)) {\n        throw AsyncSocketException(\n            AsyncSocketException::INTERNAL_ERROR,\n            withAddr(\"failed to schedule AsyncSSLSocket connect timeout\"));\n      }\n    }\n    return;\n  }\n  AsyncSocket::scheduleConnectTimeout();\n}\n\nvoid AsyncSSLSocket::handleRead() noexcept {\n  VLOG(5) << \"AsyncSSLSocket::handleRead() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  if (state_ < StateEnum::ESTABLISHED) {\n    return AsyncSocket::handleRead();\n  }\n\n  if (sslState_ == STATE_ACCEPTING) {\n    assert(server_);\n    handleAccept();\n    return;\n  } else if (sslState_ == STATE_CONNECTING) {\n    assert(!server_);\n    handleConnect();\n    return;\n  }\n\n  // Normal read\n  AsyncSocket::handleRead();\n}\n\nAsyncSocket::ReadResult\nAsyncSSLSocket::performRead(void** buf, size_t* buflen, size_t* offset) {\n  VLOG(4) << \"AsyncSSLSocket::performRead() this=\" << this << \", buf=\" << *buf\n          << \", buflen=\" << *buflen;\n\n  if (sslState_ == STATE_UNENCRYPTED) {\n    return AsyncSocket::performRead(buf, buflen, offset);\n  }\n\n  int numToRead = 0;\n  if (*buflen > std::numeric_limits<int>::max()) {\n    numToRead = std::numeric_limits<int>::max();\n    VLOG(4) << \"Clamping SSL_read to \" << numToRead;\n  } else {\n    numToRead = int(*buflen);\n  }\n  int bytes = SSL_read(ssl_.get(), *buf, numToRead);\n\n  if (server_ && renegotiateAttempted_) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslstate=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): client intitiated SSL renegotiation not permitted\";\n    return ReadResult(\n        READ_ERROR,\n        std::make_unique<SSLException>(SSLError::CLIENT_RENEGOTIATION));\n  }\n  if (bytes <= 0) {\n    int error = SSL_get_error(ssl_.get(), bytes);\n    if (error == SSL_ERROR_WANT_READ) {\n      // The caller will register for read event if not already.\n      if (errno == EWOULDBLOCK || errno == EAGAIN) {\n        return ReadResult(READ_BLOCKING);\n      } else {\n        return ReadResult(READ_ERROR);\n      }\n    } else if (error == SSL_ERROR_WANT_WRITE) {\n      // TODO: Even though we are attempting to read data, SSL_read() may\n      // need to write data if renegotiation is being performed.  We currently\n      // don't support this and just fail the read.\n      LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n                 << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n                 << \"): unsupported SSL renegotiation during read\";\n      return ReadResult(\n          READ_ERROR,\n          std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n    } else {\n      if (zero_return(error, bytes, errno)) {\n        return ReadResult(bytes);\n      }\n      auto errError = ERR_get_error();\n      VLOG(6) << \"AsyncSSLSocket(fd=\" << fd_ << \", \"\n              << \"state=\" << state_ << \", \"\n              << \"sslState=\" << sslState_ << \", \"\n              << \"events=\" << std::hex << eventFlags_ << \"): \"\n              << \"bytes: \" << bytes << \", \"\n              << \"error: \" << error << \", \"\n              << \"errno: \" << errno << \", \"\n              << \"func: \" << ERR_func_error_string(errError) << \", \"\n              << \"reason: \" << ERR_reason_error_string(errError);\n      return ReadResult(\n          READ_ERROR,\n          std::make_unique<SSLException>(error, errError, bytes, errno));\n    }\n  } else {\n    appBytesReceived_ += bytes;\n    return ReadResult(bytes);\n  }\n}\n\nvoid AsyncSSLSocket::handleWrite() noexcept {\n  VLOG(5) << \"AsyncSSLSocket::handleWrite() this=\" << this << \", fd=\" << fd_\n          << \", state=\" << int(state_) << \", \"\n          << \"sslState=\" << sslState_ << \", events=\" << eventFlags_;\n  if (state_ < StateEnum::ESTABLISHED) {\n    return AsyncSocket::handleWrite();\n  }\n\n  if (sslState_ == STATE_ACCEPTING) {\n    assert(server_);\n    handleAccept();\n    return;\n  }\n\n  if (sslState_ == STATE_CONNECTING) {\n    assert(!server_);\n    handleConnect();\n    return;\n  }\n\n  // Normal write\n  AsyncSocket::handleWrite();\n}\n\nAsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    // Even though we are attempting to write data, SSL_write() may\n    // need to read data if renegotiation is being performed.  We currently\n    // don't support this and just fail the write.\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}\n\nAsyncSocket::WriteResult AsyncSSLSocket::performWrite(\n    const iovec* vec,\n    uint32_t count,\n    WriteFlags flags,\n    uint32_t* countWritten,\n    uint32_t* partialWritten) {\n  if (sslState_ == STATE_UNENCRYPTED) {\n    return AsyncSocket::performWrite(\n        vec, count, flags, countWritten, partialWritten);\n  }\n  if (sslState_ != STATE_ESTABLISHED) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"TODO: AsyncSSLSocket currently does not support calling \"\n               << \"write() before the handshake has fully completed\";\n    return WriteResult(\n        WRITE_ERROR, std::make_unique<SSLException>(SSLError::EARLY_WRITE));\n  }\n\n  // Declare a buffer used to hold small write requests.  It could point to a\n  // memory block either on stack or on heap. If it is on heap, we release it\n  // manually when scope exits\n  char* combinedBuf{nullptr};\n  SCOPE_EXIT {\n    // Note, always keep this check consistent with what we do below\n    if (combinedBuf != nullptr && minWriteSize_ > MAX_STACK_BUF_SIZE) {\n      delete[] combinedBuf;\n    }\n  };\n\n  *countWritten = 0;\n  *partialWritten = 0;\n  ssize_t totalWritten = 0;\n  size_t bytesStolenFromNextBuffer = 0;\n  for (uint32_t i = 0; i < count; i++) {\n    const iovec* v = vec + i;\n    size_t offset = bytesStolenFromNextBuffer;\n    bytesStolenFromNextBuffer = 0;\n    size_t len = v->iov_len - offset;\n    const void* buf;\n    if (len == 0) {\n      (*countWritten)++;\n      continue;\n    }\n    buf = ((const char*)v->iov_base) + offset;\n\n    ssize_t bytes;\n    uint32_t buffersStolen = 0;\n    auto sslWriteBuf = buf;\n    if ((len < minWriteSize_) && ((i + 1) < count)) {\n      // Combine this buffer with part or all of the next buffers in\n      // order to avoid really small-grained calls to SSL_write().\n      // Each call to SSL_write() produces a separate record in\n      // the egress SSL stream, and we've found that some low-end\n      // mobile clients can't handle receiving an HTTP response\n      // header and the first part of the response body in two\n      // separate SSL records (even if those two records are in\n      // the same TCP packet).\n\n      if (combinedBuf == nullptr) {\n        if (minWriteSize_ > MAX_STACK_BUF_SIZE) {\n          // Allocate the buffer on heap\n          combinedBuf = new char[minWriteSize_];\n        } else {\n          // Allocate the buffer on stack\n          combinedBuf = (char*)alloca(minWriteSize_);\n        }\n      }\n      assert(combinedBuf != nullptr);\n      sslWriteBuf = combinedBuf;\n\n      memcpy(combinedBuf, buf, len);\n      do {\n        // INVARIANT: i + buffersStolen == complete chunks serialized\n        uint32_t nextIndex = i + buffersStolen + 1;\n        bytesStolenFromNextBuffer =\n            std::min(vec[nextIndex].iov_len, minWriteSize_ - len);\n        if (bytesStolenFromNextBuffer > 0) {\n          assert(vec[nextIndex].iov_base != nullptr);\n          ::memcpy(\n              combinedBuf + len,\n              vec[nextIndex].iov_base,\n              bytesStolenFromNextBuffer);\n        }\n        len += bytesStolenFromNextBuffer;\n        if (bytesStolenFromNextBuffer < vec[nextIndex].iov_len) {\n          // couldn't steal the whole buffer\n          break;\n        } else {\n          bytesStolenFromNextBuffer = 0;\n          buffersStolen++;\n        }\n      } while ((i + buffersStolen + 1) < count && (len < minWriteSize_));\n    }\n\n    // Advance any empty buffers immediately after.\n    if (bytesStolenFromNextBuffer == 0) {\n      while ((i + buffersStolen + 1) < count &&\n             vec[i + buffersStolen + 1].iov_len == 0) {\n        buffersStolen++;\n      }\n    }\n\n    // cork the current write if the original flags included CORK or if there\n    // are remaining iovec to write\n    corkCurrentWrite_ =\n        isSet(flags, WriteFlags::CORK) || (i + buffersStolen + 1 < count);\n\n    // track the EoR if:\n    //  (1) there are write flags that require EoR tracking (EOR / TIMESTAMP_TX)\n    //  (2) if the buffer includes the EOR byte\n    appEorByteWriteFlags_ = flags & kEorRelevantWriteFlags;\n    bool trackEor = appEorByteWriteFlags_ != folly::WriteFlags::NONE &&\n        (i + buffersStolen + 1 == count);\n    bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);\n\n    if (bytes <= 0) {\n      int error = SSL_get_error(ssl_.get(), int(bytes));\n      if (error == SSL_ERROR_WANT_WRITE) {\n        // The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      return interpretSSLError(int(bytes), error);\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {\n      // The full iovec is written.\n      (*countWritten) += 1 + buffersStolen;\n      i += buffersStolen;\n      // continue\n    } else {\n      bytes += offset; // adjust bytes to account for all of v\n      while (bytes >= (ssize_t)v->iov_len) {\n        // We combined this buf with part or all of the next one, and\n        // we managed to write all of this buf but not all of the bytes\n        // from the next one that we'd hoped to write.\n        bytes -= v->iov_len;\n        (*countWritten)++;\n        v = &(vec[++i]);\n      }\n      *partialWritten = uint32_t(bytes);\n      return WriteResult(totalWritten);\n    }\n  }\n\n  return WriteResult(totalWritten);\n}\n\nint AsyncSSLSocket::eorAwareSSLWrite(\n    const ssl::SSLUniquePtr& ssl,\n    const void* buf,\n    int n,\n    bool eor) {\n  if (eor && isEorTrackingEnabled()) {\n    if (appEorByteNo_) {\n      // cannot track for more than one app byte EOR\n      CHECK(appEorByteNo_ == appBytesWritten_ + n);\n    } else {\n      appEorByteNo_ = appBytesWritten_ + n;\n    }\n\n    // 1. It is fine to keep updating minEorRawByteNo_.\n    // 2. It is _min_ in the sense that SSL record will add some overhead.\n    minEorRawByteNo_ = getRawBytesWritten() + n;\n  }\n\n  n = sslWriteImpl(ssl.get(), buf, n);\n  if (n > 0) {\n    appBytesWritten_ += n;\n    if (appEorByteNo_) {\n      if (getRawBytesWritten() >= minEorRawByteNo_) {\n        minEorRawByteNo_ = 0;\n      }\n      if (appBytesWritten_ == appEorByteNo_) {\n        appEorByteNo_ = 0;\n        appEorByteWriteFlags_ = {};\n      } else {\n        CHECK(appBytesWritten_ < appEorByteNo_);\n      }\n    }\n  }\n  return n;\n}\n\nvoid AsyncSSLSocket::sslInfoCallback(const SSL* ssl, int where, int ret) {\n  AsyncSSLSocket* sslSocket = AsyncSSLSocket::getFromSSL(ssl);\n  if (sslSocket->handshakeComplete_ && (where & SSL_CB_HANDSHAKE_START)) {\n    sslSocket->renegotiateAttempted_ = true;\n  }\n  if (sslSocket->handshakeComplete_ && (where & SSL_CB_WRITE_ALERT)) {\n    const char* desc = SSL_alert_desc_string(ret);\n    if (desc && strcmp(desc, \"NR\") == 0) {\n      sslSocket->renegotiateAttempted_ = true;\n    }\n  }\n  if (where & SSL_CB_READ_ALERT) {\n    const char* type = SSL_alert_type_string(ret);\n    if (type) {\n      const char* desc = SSL_alert_desc_string(ret);\n      sslSocket->alertsReceived_.emplace_back(\n          *type, StringPiece(desc, std::strlen(desc)));\n    }\n  }\n}\n\nint AsyncSSLSocket::bioWrite(BIO* b, const char* in, int inl) {\n  struct msghdr msg;\n  struct iovec iov;\n  AsyncSSLSocket* tsslSock;\n\n  iov.iov_base = const_cast<char*>(in);\n  iov.iov_len = size_t(inl);\n  memset(&msg, 0, sizeof(msg));\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n\n  auto appData = OpenSSLUtils::getBioAppData(b);\n  CHECK(appData);\n\n  tsslSock = reinterpret_cast<AsyncSSLSocket*>(appData);\n  CHECK(tsslSock);\n\n  WriteFlags flags = WriteFlags::NONE;\n  if (tsslSock->isEorTrackingEnabled() && tsslSock->minEorRawByteNo_ &&\n      tsslSock->minEorRawByteNo_ <= BIO_number_written(b) + inl) {\n    flags |= tsslSock->appEorByteWriteFlags_;\n  }\n\n  if (tsslSock->corkCurrentWrite_) {\n    flags |= WriteFlags::CORK;\n  }\n\n  int msg_flags = tsslSock->getSendMsgParamsCB()->getFlags(\n      flags, false /*zeroCopyEnabled*/);\n  msg.msg_controllen =\n      tsslSock->getSendMsgParamsCB()->getAncillaryDataSize(flags);\n  CHECK_GE(\n      AsyncSocket::SendMsgParamsCallback::maxAncillaryDataSize,\n      msg.msg_controllen);\n  if (msg.msg_controllen != 0) {\n    msg.msg_control = reinterpret_cast<char*>(alloca(msg.msg_controllen));\n    tsslSock->getSendMsgParamsCB()->getAncillaryData(flags, msg.msg_control);\n  }\n\n  auto result =\n      tsslSock->sendSocketMessage(OpenSSLUtils::getBioFd(b), &msg, msg_flags);\n  BIO_clear_retry_flags(b);\n  if (!result.exception && result.writeReturn <= 0) {\n    if (OpenSSLUtils::getBioShouldRetryWrite(int(result.writeReturn))) {\n      BIO_set_retry_write(b);\n    }\n  }\n  return int(result.writeReturn);\n}\n\nint AsyncSSLSocket::bioRead(BIO* b, char* out, int outl) {\n  if (!out) {\n    return 0;\n  }\n  BIO_clear_retry_flags(b);\n\n  auto appData = OpenSSLUtils::getBioAppData(b);\n  CHECK(appData);\n  auto sslSock = reinterpret_cast<AsyncSSLSocket*>(appData);\n\n  if (sslSock->preReceivedData_ && !sslSock->preReceivedData_->empty()) {\n    VLOG(5) << \"AsyncSSLSocket::bioRead() this=\" << sslSock\n            << \", reading pre-received data\";\n\n    Cursor cursor(sslSock->preReceivedData_.get());\n    auto len = cursor.pullAtMost(out, outl);\n\n    IOBufQueue queue;\n    queue.append(std::move(sslSock->preReceivedData_));\n    queue.trimStart(len);\n    sslSock->preReceivedData_ = queue.move();\n    return static_cast<int>(len);\n  } else {\n    auto result = int(netops::recv(OpenSSLUtils::getBioFd(b), out, outl, 0));\n    if (result <= 0 && OpenSSLUtils::getBioShouldRetryWrite(result)) {\n      BIO_set_retry_read(b);\n    }\n    return result;\n  }\n}\n\nint AsyncSSLSocket::sslVerifyCallback(\n    int preverifyOk,\n    X509_STORE_CTX* x509Ctx) {\n  SSL* ssl = (SSL*)X509_STORE_CTX_get_ex_data(\n      x509Ctx, SSL_get_ex_data_X509_STORE_CTX_idx());\n  AsyncSSLSocket* self = AsyncSSLSocket::getFromSSL(ssl);\n\n  VLOG(3) << \"AsyncSSLSocket::sslVerifyCallback() this=\" << self << \", \"\n          << \"fd=\" << self->fd_ << \", preverifyOk=\" << preverifyOk;\n  return (self->handshakeCallback_)\n      ? self->handshakeCallback_->handshakeVer(self, preverifyOk, x509Ctx)\n      : preverifyOk;\n}\n\nvoid AsyncSSLSocket::enableClientHelloParsing() {\n  parseClientHello_ = true;\n  clientHelloInfo_ = std::make_unique<ssl::ClientHelloInfo>();\n}\n\nvoid AsyncSSLSocket::resetClientHelloParsing(SSL* ssl) {\n  SSL_set_msg_callback(ssl, nullptr);\n  SSL_set_msg_callback_arg(ssl, nullptr);\n  clientHelloInfo_->clientHelloBuf_.clear();\n}\n\nvoid AsyncSSLSocket::clientHelloParsingCallback(\n    int written,\n    int /* version */,\n    int contentType,\n    const void* buf,\n    size_t len,\n    SSL* ssl,\n    void* arg) {\n  AsyncSSLSocket* sock = static_cast<AsyncSSLSocket*>(arg);\n  if (written != 0) {\n    sock->resetClientHelloParsing(ssl);\n    return;\n  }\n  if (contentType != SSL3_RT_HANDSHAKE) {\n    return;\n  }\n  if (len == 0) {\n    return;\n  }\n\n  auto& clientHelloBuf = sock->clientHelloInfo_->clientHelloBuf_;\n  clientHelloBuf.append(IOBuf::wrapBuffer(buf, len));\n  try {\n    Cursor cursor(clientHelloBuf.front());\n    if (cursor.read<uint8_t>() != SSL3_MT_CLIENT_HELLO) {\n      sock->resetClientHelloParsing(ssl);\n      return;\n    }\n\n    if (cursor.totalLength() < 3) {\n      clientHelloBuf.trimEnd(len);\n      clientHelloBuf.append(IOBuf::copyBuffer(buf, len));\n      return;\n    }\n\n    uint32_t messageLength = cursor.read<uint8_t>();\n    messageLength <<= 8;\n    messageLength |= cursor.read<uint8_t>();\n    messageLength <<= 8;\n    messageLength |= cursor.read<uint8_t>();\n    if (cursor.totalLength() < messageLength) {\n      clientHelloBuf.trimEnd(len);\n      clientHelloBuf.append(IOBuf::copyBuffer(buf, len));\n      return;\n    }\n\n    sock->clientHelloInfo_->clientHelloMajorVersion_ = cursor.read<uint8_t>();\n    sock->clientHelloInfo_->clientHelloMinorVersion_ = cursor.read<uint8_t>();\n\n    cursor.skip(4); // gmt_unix_time\n    cursor.skip(28); // random_bytes\n\n    cursor.skip(cursor.read<uint8_t>()); // session_id\n\n    uint16_t cipherSuitesLength = cursor.readBE<uint16_t>();\n    for (int i = 0; i < cipherSuitesLength; i += 2) {\n      sock->clientHelloInfo_->clientHelloCipherSuites_.push_back(\n          cursor.readBE<uint16_t>());\n    }\n\n    uint8_t compressionMethodsLength = cursor.read<uint8_t>();\n    for (int i = 0; i < compressionMethodsLength; ++i) {\n      sock->clientHelloInfo_->clientHelloCompressionMethods_.push_back(\n          cursor.readBE<uint8_t>());\n    }\n\n    if (cursor.totalLength() > 0) {\n      uint16_t extensionsLength = cursor.readBE<uint16_t>();\n      while (extensionsLength) {\n        ssl::TLSExtension extensionType =\n            static_cast<ssl::TLSExtension>(cursor.readBE<uint16_t>());\n        sock->clientHelloInfo_->clientHelloExtensions_.push_back(extensionType);\n        extensionsLength -= 2;\n        uint16_t extensionDataLength = cursor.readBE<uint16_t>();\n        extensionsLength -= 2;\n        extensionsLength -= extensionDataLength;\n\n        if (extensionType == ssl::TLSExtension::SIGNATURE_ALGORITHMS) {\n          cursor.skip(2);\n          extensionDataLength -= 2;\n          while (extensionDataLength) {\n            ssl::HashAlgorithm hashAlg =\n                static_cast<ssl::HashAlgorithm>(cursor.readBE<uint8_t>());\n            ssl::SignatureAlgorithm sigAlg =\n                static_cast<ssl::SignatureAlgorithm>(cursor.readBE<uint8_t>());\n            extensionDataLength -= 2;\n            sock->clientHelloInfo_->clientHelloSigAlgs_.emplace_back(\n                hashAlg, sigAlg);\n          }\n        } else if (extensionType == ssl::TLSExtension::SUPPORTED_VERSIONS) {\n          cursor.skip(1);\n          extensionDataLength -= 1;\n          while (extensionDataLength) {\n            sock->clientHelloInfo_->clientHelloSupportedVersions_.push_back(\n                cursor.readBE<uint16_t>());\n            extensionDataLength -= 2;\n          }\n        } else if (extensionType == ssl::TLSExtension::SERVER_NAME) {\n          cursor.skip(2);\n          extensionDataLength -= 2;\n          while (extensionDataLength) {\n            static_assert(\n                std::is_same<\n                    typename std::underlying_type<ssl::NameType>::type,\n                    uint8_t>::value,\n                \"unexpected underlying type\");\n\n            ssl::NameType typ =\n                static_cast<ssl::NameType>(cursor.readBE<uint8_t>());\n            uint16_t nameLength = cursor.readBE<uint16_t>();\n\n            if (typ == NameType::HOST_NAME &&\n                sock->clientHelloInfo_->clientHelloSNIHostname_.empty() &&\n                cursor.canAdvance(nameLength)) {\n              sock->clientHelloInfo_->clientHelloSNIHostname_ =\n                  cursor.readFixedString(nameLength);\n            } else {\n              // Must attempt to skip |nameLength| in order to keep cursor\n              // in sync. If the remaining buffer length is smaller than\n              // nameLength, this will throw.\n              cursor.skip(nameLength);\n            }\n            extensionDataLength -=\n                sizeof(typ) + sizeof(nameLength) + nameLength;\n          }\n        } else {\n          cursor.skip(extensionDataLength);\n        }\n      }\n    }\n  } catch (std::out_of_range&) {\n    // we'll use what we found and cleanup below.\n    VLOG(4) << \"AsyncSSLSocket::clientHelloParsingCallback(): \"\n            << \"buffer finished unexpectedly.\"\n            << \" AsyncSSLSocket socket=\" << sock;\n  }\n\n  sock->resetClientHelloParsing(ssl);\n}\n\nvoid AsyncSSLSocket::getSSLClientCiphers(\n    std::string& clientCiphers,\n    bool convertToString) const {\n  std::string ciphers;\n\n  if (parseClientHello_ == false ||\n      clientHelloInfo_->clientHelloCipherSuites_.empty()) {\n    clientCiphers = \"\";\n    return;\n  }\n\n  bool first = true;\n  for (auto originalCipherCode : clientHelloInfo_->clientHelloCipherSuites_) {\n    if (first) {\n      first = false;\n    } else {\n      ciphers += \":\";\n    }\n\n    bool nameFound = convertToString;\n\n    if (convertToString) {\n      const auto& name = OpenSSLUtils::getCipherName(originalCipherCode);\n      if (name.empty()) {\n        nameFound = false;\n      } else {\n        ciphers += name;\n      }\n    }\n\n    if (!nameFound) {\n      folly::hexlify(\n          std::array<uint8_t, 2>{\n              {static_cast<uint8_t>((originalCipherCode >> 8) & 0xffL),\n               static_cast<uint8_t>(originalCipherCode & 0x00ffL)}},\n          ciphers,\n          /* append to ciphers = */ true);\n    }\n  }\n\n  clientCiphers = std::move(ciphers);\n}\n\nstd::string AsyncSSLSocket::getSSLClientComprMethods() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n  return folly::join(\":\", clientHelloInfo_->clientHelloCompressionMethods_);\n}\n\nstd::string AsyncSSLSocket::getSSLClientExts() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n  return folly::join(\":\", clientHelloInfo_->clientHelloExtensions_);\n}\n\nstd::string AsyncSSLSocket::getSSLClientSigAlgs() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n\n  std::string sigAlgs;\n  sigAlgs.reserve(clientHelloInfo_->clientHelloSigAlgs_.size() * 4);\n  for (size_t i = 0; i < clientHelloInfo_->clientHelloSigAlgs_.size(); i++) {\n    if (i) {\n      sigAlgs.push_back(':');\n    }\n    sigAlgs.append(\n        folly::to<std::string>(clientHelloInfo_->clientHelloSigAlgs_[i].first));\n    sigAlgs.push_back(',');\n    sigAlgs.append(folly::to<std::string>(\n        clientHelloInfo_->clientHelloSigAlgs_[i].second));\n  }\n\n  return sigAlgs;\n}\n\nstd::string AsyncSSLSocket::getSSLClientSupportedVersions() const {\n  if (!parseClientHello_) {\n    return \"\";\n  }\n  return folly::join(\":\", clientHelloInfo_->clientHelloSupportedVersions_);\n}\n\nstd::string AsyncSSLSocket::getSSLAlertsReceived() const {\n  std::string ret;\n\n  for (const auto& alert : alertsReceived_) {\n    if (!ret.empty()) {\n      ret.append(\",\");\n    }\n    ret.append(folly::to<std::string>(alert.first, \": \", alert.second));\n  }\n\n  return ret;\n}\n\nvoid AsyncSSLSocket::setSSLCertVerificationAlert(std::string alert) {\n  sslVerificationAlert_ = std::move(alert);\n}\n\nstd::string AsyncSSLSocket::getSSLCertVerificationAlert() const {\n  return sslVerificationAlert_;\n}\n\nvoid AsyncSSLSocket::getSSLSharedCiphers(std::string& sharedCiphers) const {\n  char ciphersBuffer[1024];\n  ciphersBuffer[0] = '\\0';\n  SSL_get_shared_ciphers(ssl_.get(), ciphersBuffer, sizeof(ciphersBuffer) - 1);\n  sharedCiphers = ciphersBuffer;\n}\n\nvoid AsyncSSLSocket::getSSLServerCiphers(std::string& serverCiphers) const {\n  serverCiphers = SSL_get_cipher_list(ssl_.get(), 0);\n  int i = 1;\n  const char* cipher;\n  while ((cipher = SSL_get_cipher_list(ssl_.get(), i)) != nullptr) {\n    serverCiphers.append(\":\");\n    serverCiphers.append(cipher);\n    i++;\n  }\n}\n\n} // namespace folly\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <folly/io/async/test/AsyncSSLSocketTest.h>\n\n#include <folly/SocketAddress.h>\n#include <folly/String.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/async/AsyncPipe.h>\n#include <folly/io/async/AsyncSSLSocket.h>\n#include <folly/io/async/EventBase.h>\n#include <folly/io/async/ScopedEventBaseThread.h>\n#include <folly/net/NetOps.h>\n#include <folly/net/NetworkSocket.h>\n#include <folly/portability/GMock.h>\n#include <folly/portability/GTest.h>\n#include <folly/portability/OpenSSL.h>\n#include <folly/portability/Unistd.h>\n#include <folly/ssl/Init.h>\n\n#include <folly/io/async/test/BlockingSocket.h>\n\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/types.h>\n\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <set>\n#include <thread>\n\n#ifdef __linux__\n#include <dlfcn.h>\n#endif\n\n#if FOLLY_OPENSSL_IS_110\n#include <openssl/async.h>\n#endif\n\n#ifdef FOLLY_HAVE_MSG_ERRQUEUE\n#include <sys/utsname.h>\n#endif\n\nusing std::cerr;\nusing std::endl;\nusing std::list;\nusing std::min;\nusing std::string;\nusing std::vector;\n\nusing namespace testing;\n\n#if defined __linux__\nnamespace {\n\n// to store libc's original setsockopt()\ntypedef int (*setsockopt_ptr)(int, int, int, const void*, socklen_t);\nsetsockopt_ptr real_setsockopt_ = nullptr;\n\n// global struct to initialize before main runs. we can init within a test,\n// or in main, but this method seems to be least intrsive and universal\nstruct GlobalStatic {\n  GlobalStatic() {\n    real_setsockopt_ = (setsockopt_ptr)dlsym(RTLD_NEXT, \"setsockopt\");\n  }\n  void reset() noexcept {\n    ttlsDisabledSet.clear();\n  }\n  // for each fd, tracks whether TTLS is disabled or not\n  std::unordered_set<folly::NetworkSocket /* fd */> ttlsDisabledSet;\n};\n\n// the constructor will be called before main() which is all we care about\nGlobalStatic globalStatic;\n\n} // namespace\n\n// we intercept setsoctopt to test setting NO_TRANSPARENT_TLS opt\n// this name has to be global\nint setsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    const void* optval,\n    socklen_t optlen) {\n  if (optname == SO_NO_TRANSPARENT_TLS) {\n    globalStatic.ttlsDisabledSet.insert(folly::NetworkSocket::fromFd(sockfd));\n    return 0;\n  }\n  return real_setsockopt_(sockfd, level, optname, optval, optlen);\n}\n#endif\n\nnamespace folly {\nconstexpr size_t SSLClient::kMaxReadBufferSz;\nconstexpr size_t SSLClient::kMaxReadsPerEvent;\n\nvoid getfds(NetworkSocket fds[2]) {\n  if (netops::socketpair(PF_LOCAL, SOCK_STREAM, 0, fds) != 0) {\n    FAIL() << \"failed to create socketpair: \" << errnoStr(errno);\n  }\n  for (int idx = 0; idx < 2; ++idx) {\n    if (netops::set_socket_non_blocking(fds[idx]) != 0) {\n      FAIL() << \"failed to put socket \" << idx\n             << \" in non-blocking mode: \" << errnoStr(errno);\n    }\n  }\n}\n\nvoid getctx(\n    std::shared_ptr<folly::SSLContext> clientCtx,\n    std::shared_ptr<folly::SSLContext> serverCtx) {\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadPrivateKey(kTestKey);\n}\n\nvoid sslsocketpair(\n    EventBase* eventBase,\n    AsyncSSLSocket::UniquePtr* clientSock,\n    AsyncSSLSocket::UniquePtr* serverSock) {\n  auto clientCtx = std::make_shared<folly::SSLContext>();\n  auto serverCtx = std::make_shared<folly::SSLContext>();\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, serverCtx);\n  clientSock->reset(new AsyncSSLSocket(clientCtx, eventBase, fds[0], false));\n  serverSock->reset(new AsyncSSLSocket(serverCtx, eventBase, fds[1], true));\n\n  // (*clientSock)->setSendTimeout(100);\n  // (*serverSock)->setSendTimeout(100);\n}\n\n// client protocol filters\nbool clientProtoFilterPickPony(\n    unsigned char** client,\n    unsigned int* client_len,\n    const unsigned char*,\n    unsigned int) {\n  // the protocol string in length prefixed byte string. the\n  // length byte is not included in the length\n  static unsigned char p[7] = {6, 'p', 'o', 'n', 'i', 'e', 's'};\n  *client = p;\n  *client_len = 7;\n  return true;\n}\n\nbool clientProtoFilterPickNone(\n    unsigned char**,\n    unsigned int*,\n    const unsigned char*,\n    unsigned int) {\n  return false;\n}\n\nstd::string getFileAsBuf(const char* fileName) {\n  std::string buffer;\n  folly::readFile(fileName, buffer);\n  return buffer;\n}\n\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadClose) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  // sslContext->loadTrustedCertificates(\"./trusted-ca-certificate.pem\");\n  // sslContext->authenticate(true, false);\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open(std::chrono::milliseconds(10000));\n\n  // write()\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  // read()\n  uint8_t readbuf[128];\n  uint32_t bytesRead = socket->readAll(readbuf, sizeof(readbuf));\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf, readbuf, bytesRead), 0);\n\n  // close()\n  socket->close();\n\n  cerr << \"ConnectWriteReadClose test completed\" << endl;\n  EXPECT_EQ(socket->getSSLSocket()->getTotalConnectTimeout().count(), 10000);\n}\n\n/**\n * Same as above simple test, but with a large read len to test\n * clamping behavior.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadLargeClose) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  // sslContext->loadTrustedCertificates(\"./trusted-ca-certificate.pem\");\n  // sslContext->authenticate(true, false);\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open(std::chrono::milliseconds(10000));\n\n  // write()\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  // read()\n  uint8_t readbuf[128];\n  // we will fake the read len but that should be fine\n  size_t readLen = 1L << 33;\n  uint32_t bytesRead = socket->read(readbuf, readLen);\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf, readbuf, bytesRead), 0);\n\n  // close()\n  socket->close();\n\n  cerr << \"ConnectWriteReadClose test completed\" << endl;\n  EXPECT_EQ(socket->getSSLSocket()->getTotalConnectTimeout().count(), 10000);\n}\n\n/**\n * Test reading after server close.\n */\nTEST(AsyncSSLSocketTest, ReadAfterClose) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadEOFCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  auto server = std::make_unique<TestSSLServer>(&acceptCallback);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  auto socket =\n      std::make_shared<BlockingSocket>(server->getAddress(), sslContext);\n  socket->open();\n\n  // This should trigger an EOF on the client.\n  auto evb = handshakeCallback.getSocket()->getEventBase();\n  evb->runInEventBaseThreadAndWait([&]() { handshakeCallback.closeSocket(); });\n  std::array<uint8_t, 128> readbuf;\n  auto bytesRead = socket->read(readbuf.data(), readbuf.size());\n  EXPECT_EQ(0, bytesRead);\n}\n\n/**\n * Test bad renegotiation\n */\n#if !defined(OPENSSL_IS_BORINGSSL)\nTEST(AsyncSSLSocketTest, Renegotiate) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  RenegotiatingServer server(std::move(serverSock));\n\n  while (!client.handshakeSuccess_ && !client.handshakeError_) {\n    eventBase.loopOnce();\n  }\n\n  ASSERT_TRUE(client.handshakeSuccess_);\n\n  auto sslSock = std::move(client).moveSocket();\n  sslSock->detachEventBase();\n  // This is nasty, however we don't want to add support for\n  // renegotiation in AsyncSSLSocket.\n  SSL_renegotiate(const_cast<SSL*>(sslSock->getSSL()));\n\n  auto socket = std::make_shared<BlockingSocket>(std::move(sslSock));\n\n  std::thread t([&]() { eventBase.loopForever(); });\n\n  // Trigger the renegotiation.\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  try {\n    socket->write(buf.data(), buf.size());\n  } catch (AsyncSocketException& e) {\n    LOG(INFO) << \"client got error \" << e.what();\n  }\n  eventBase.terminateLoopSoon();\n  t.join();\n\n  eventBase.loop();\n  ASSERT_TRUE(server.renegotiationError_);\n}\n#endif\n\n/**\n * Negative test for handshakeError().\n */\nTEST(AsyncSSLSocketTest, HandshakeError) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  HandshakeErrorCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  // read()\n  bool ex = false;\n  try {\n    socket->open();\n\n    uint8_t readbuf[128];\n    uint32_t bytesRead = socket->readAll(readbuf, sizeof(readbuf));\n    LOG(ERROR) << \"readAll returned \" << bytesRead << \" instead of throwing\";\n  } catch (AsyncSocketException&) {\n    ex = true;\n  }\n  EXPECT_TRUE(ex);\n\n  // close()\n  socket->close();\n  cerr << \"HandshakeError test completed\" << endl;\n}\n\n/**\n * Negative test for readError().\n */\nTEST(AsyncSSLSocketTest, ReadError) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // write something to trigger ssl handshake\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  socket->close();\n  cerr << \"ReadError test completed\" << endl;\n}\n\n/**\n * Negative test for writeError().\n */\nTEST(AsyncSSLSocketTest, WriteError) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // write something to trigger ssl handshake\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  socket->close();\n  cerr << \"WriteError test completed\" << endl;\n}\n\n/**\n * Test a socket with TCP_NODELAY unset.\n */\nTEST(AsyncSSLSocketTest, SocketWithDelay) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallbackDelay acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  std::shared_ptr<SSLContext> sslContext(new SSLContext());\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // write()\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  socket->write(buf, sizeof(buf));\n\n  // read()\n  uint8_t readbuf[128];\n  uint32_t bytesRead = socket->readAll(readbuf, sizeof(readbuf));\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf, readbuf, bytesRead), 0);\n\n  // close()\n  socket->close();\n\n  cerr << \"SocketWithDelay test completed\" << endl;\n}\n\n#if FOLLY_OPENSSL_HAS_ALPN\nclass NextProtocolTest : public Test {\n  // For matching protos\n public:\n  void SetUp() override {\n    getctx(clientCtx, serverCtx);\n  }\n\n  void connect(bool unset = false) {\n    getfds(fds);\n\n    if (unset) {\n      // unsetting NPN for any of [client, server] is enough to make NPN not\n      // work\n      clientCtx->unsetNextProtocols();\n    }\n\n    AsyncSSLSocket::UniquePtr clientSock(\n        new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n    AsyncSSLSocket::UniquePtr serverSock(\n        new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n    client = std::make_unique<AlpnClient>(std::move(clientSock));\n    server = std::make_unique<AlpnServer>(std::move(serverSock));\n\n    eventBase.loop();\n  }\n\n  void expectProtocol(const std::string& proto) {\n    expectHandshakeSuccess();\n    EXPECT_NE(client->nextProtoLength, 0);\n    EXPECT_EQ(client->nextProtoLength, server->nextProtoLength);\n    EXPECT_EQ(\n        memcmp(client->nextProto, server->nextProto, server->nextProtoLength),\n        0);\n    string selected((const char*)client->nextProto, client->nextProtoLength);\n    EXPECT_EQ(proto, selected);\n  }\n\n  void expectNoProtocol() {\n    expectHandshakeSuccess();\n    EXPECT_EQ(client->nextProtoLength, 0);\n    EXPECT_EQ(server->nextProtoLength, 0);\n    EXPECT_EQ(client->nextProto, nullptr);\n    EXPECT_EQ(server->nextProto, nullptr);\n  }\n\n  void expectHandshakeSuccess() {\n    EXPECT_FALSE(client->except.hasValue())\n        << \"client handshake error: \" << client->except->what();\n    EXPECT_FALSE(server->except.hasValue())\n        << \"server handshake error: \" << server->except->what();\n  }\n\n  void expectHandshakeError() {\n    EXPECT_TRUE(client->except.hasValue())\n        << \"Expected client handshake error!\";\n    EXPECT_TRUE(server->except.hasValue())\n        << \"Expected server handshake error!\";\n  }\n\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx{std::make_shared<SSLContext>()};\n  std::shared_ptr<SSLContext> serverCtx{std::make_shared<SSLContext>()};\n  NetworkSocket fds[2];\n  std::unique_ptr<AlpnClient> client;\n  std::unique_ptr<AlpnServer> server;\n};\n\nTEST_F(NextProtocolTest, AlpnTestOverlap) {\n  clientCtx->setAdvertisedNextProtocols({\"blub\", \"baz\"});\n  serverCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n\n  connect();\n\n  expectProtocol(\"baz\");\n}\n\nTEST_F(NextProtocolTest, AlpnTestUnset) {\n  // Identical to above test, except that we want unset NPN before\n  // looping.\n  clientCtx->setAdvertisedNextProtocols({\"blub\", \"baz\"});\n  serverCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n\n  connect(true /* unset */);\n\n  expectNoProtocol();\n}\n\nTEST_F(NextProtocolTest, AlpnTestNoOverlap) {\n  clientCtx->setAdvertisedNextProtocols({\"blub\"});\n  serverCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n  connect();\n\n  expectNoProtocol();\n}\n\nTEST_F(NextProtocolTest, RandomizedAlpnTest) {\n  // Probability that this test will fail is 2^-64, which could be considered\n  // as negligible.\n  const int kTries = 64;\n\n  clientCtx->setAdvertisedNextProtocols({\"foo\", \"bar\", \"baz\"});\n  serverCtx->setRandomizedAdvertisedNextProtocols({{1, {\"foo\"}}, {1, {\"bar\"}}});\n\n  std::set<string> selectedProtocols;\n  for (int i = 0; i < kTries; ++i) {\n    connect();\n\n    EXPECT_NE(client->nextProtoLength, 0);\n    EXPECT_EQ(client->nextProtoLength, server->nextProtoLength);\n    EXPECT_EQ(\n        memcmp(client->nextProto, server->nextProto, server->nextProtoLength),\n        0);\n    string selected((const char*)client->nextProto, client->nextProtoLength);\n    selectedProtocols.insert(selected);\n    expectHandshakeSuccess();\n  }\n  EXPECT_EQ(selectedProtocols.size(), 2);\n}\n#endif\n\n#ifndef OPENSSL_NO_TLSEXT\n/**\n * 1. Client sends TLSEXT_HOSTNAME in client hello.\n * 2. Server found a match SSL_CTX and use this SSL_CTX to\n *    continue the SSL handshake.\n * 3. Server sends back TLSEXT_HOSTNAME in server hello.\n */\nTEST(AsyncSSLSocketTest, SNITestMatch) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string serverName(\"xyz.newdev.facebook.com\");\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], serverName));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock), dfServerCtx, hskServerCtx, serverName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.serverNameMatch);\n  EXPECT_TRUE(server.serverNameMatch);\n}\n\n/**\n * 1. Client sends TLSEXT_HOSTNAME in client hello.\n * 2. Server cannot find a matching SSL_CTX and continue to use\n *    the current SSL_CTX to do the handshake.\n * 3. Server does not send back TLSEXT_HOSTNAME in server hello.\n */\nTEST(AsyncSSLSocketTest, SNITestNotMatch) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string clientRequestingServerName(\"foo.com\");\n  const std::string serverExpectedServerName(\"xyz.newdev.facebook.com\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(new AsyncSSLSocket(\n      clientCtx, &eventBase, fds[0], clientRequestingServerName));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock),\n      dfServerCtx,\n      hskServerCtx,\n      serverExpectedServerName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.serverNameMatch);\n  EXPECT_TRUE(!server.serverNameMatch);\n}\n/**\n * 1. Client sends TLSEXT_HOSTNAME in client hello.\n * 2. We then change the serverName.\n * 3. We expect that we get 'false' as the result for serNameMatch.\n */\n\nTEST(AsyncSSLSocketTest, SNITestChangeServerName) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string serverName(\"xyz.newdev.facebook.com\");\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], serverName));\n  // Change the server name\n  std::string newName(\"new.com\");\n  clientSock->setServerName(newName);\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock), dfServerCtx, hskServerCtx, serverName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.serverNameMatch);\n}\n\n/**\n * 1. Client does not send TLSEXT_HOSTNAME in client hello.\n * 2. Server does not send back TLSEXT_HOSTNAME in server hello.\n */\nTEST(AsyncSSLSocketTest, SNITestClientHelloNoHostname) {\n  EventBase eventBase;\n  std::shared_ptr<SSLContext> clientCtx(new SSLContext);\n  std::shared_ptr<SSLContext> dfServerCtx(new SSLContext);\n  // Use the same SSLContext to continue the handshake after\n  // tlsext_hostname match.\n  std::shared_ptr<SSLContext> hskServerCtx(dfServerCtx);\n  const std::string serverExpectedServerName(\"xyz.newdev.facebook.com\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  SNIClient client(std::move(clientSock));\n  SNIServer server(\n      std::move(serverSock),\n      dfServerCtx,\n      hskServerCtx,\n      serverExpectedServerName);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.serverNameMatch);\n  EXPECT_TRUE(!server.serverNameMatch);\n}\n\n#endif\n/**\n * Test SSL client socket\n */\nTEST(AsyncSSLSocketTest, SSLClientTest) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallbackDelay acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL client\n  EventBase eventBase;\n  auto client = std::make_shared<SSLClient>(&eventBase, server.getAddress(), 1);\n\n  client->connect();\n  EventBaseAborter eba(&eventBase, 3000);\n  eventBase.loop();\n\n  EXPECT_EQ(client->getMiss(), 1);\n  EXPECT_EQ(client->getHit(), 0);\n\n  cerr << \"SSLClientTest test completed\" << endl;\n}\n\n/**\n * Test SSL client socket session re-use\n */\nTEST(AsyncSSLSocketTest, SSLClientTestReuse) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallbackDelay acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL client\n  EventBase eventBase;\n  auto client =\n      std::make_shared<SSLClient>(&eventBase, server.getAddress(), 10);\n\n  client->connect();\n  EventBaseAborter eba(&eventBase, 3000);\n  eventBase.loop();\n\n  EXPECT_EQ(client->getMiss(), 1);\n  EXPECT_EQ(client->getHit(), 9);\n\n  cerr << \"SSLClientTestReuse test completed\" << endl;\n}\n\n/**\n * Test SSL client socket timeout\n */\nTEST(AsyncSSLSocketTest, SSLClientTimeoutTest) {\n  // Start listening on a local port\n  EmptyReadCallback readCallback;\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  HandshakeTimeoutCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL client\n  EventBase eventBase;\n  auto client =\n      std::make_shared<SSLClient>(&eventBase, server.getAddress(), 1, 10);\n  client->connect(true /* write before connect completes */);\n  EventBaseAborter eba(&eventBase, 3000);\n  eventBase.loop();\n\n  usleep(100000);\n  // This is checking that the connectError callback precedes any queued\n  // writeError callbacks.  This matches AsyncSocket's behavior\n  EXPECT_EQ(client->getWriteAfterConnectErrors(), 1);\n  EXPECT_EQ(client->getErrors(), 1);\n  EXPECT_EQ(client->getMiss(), 0);\n  EXPECT_EQ(client->getHit(), 0);\n\n  cerr << \"SSLClientTimeoutTest test completed\" << endl;\n}\n\nclass PerLoopReadCallback : public AsyncTransportWrapper::ReadCallback {\n public:\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }\n\n  void readDataAvailable(size_t len) noexcept override {\n    VLOG(3) << \"Read of size: \" << len;\n    s_->setReadCB(nullptr);\n    s_->getEventBase()->runInLoop([this]() { s_->setReadCB(this); });\n  }\n\n  void readErr(const AsyncSocketException&) noexcept override {}\n\n  void readEOF() noexcept override {}\n\n  void setSocket(AsyncSocket* s) {\n    s_ = s;\n  }\n\n private:\n  AsyncSocket* s_;\n  std::array<uint8_t, 1000> buf_;\n};\n\nclass CloseNotifyConnector : public AsyncSocket::ConnectCallback {\n public:\n  CloseNotifyConnector(EventBase* evb, const SocketAddress& addr) {\n    evb_ = evb;\n    ssl_ = AsyncSSLSocket::newSocket(std::make_shared<SSLContext>(), evb_);\n    ssl_->connect(this, addr);\n  }\n\n  void connectSuccess() noexcept override {\n    ssl_->writeChain(nullptr, IOBuf::copyBuffer(\"hi\"));\n    auto ssl = const_cast<SSL*>(ssl_->getSSL());\n    SSL_shutdown(ssl);\n    auto fd = ssl_->detachNetworkSocket();\n    tcp_.reset(new AsyncSocket(evb_, fd), AsyncSocket::Destructor());\n    evb_->runAfterDelay(\n        [this]() {\n          perLoopReads_.setSocket(tcp_.get());\n          tcp_->setReadCB(&perLoopReads_);\n          evb_->runAfterDelay([this]() { tcp_->closeNow(); }, 10);\n        },\n        100);\n  }\n\n  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }\n\n private:\n  EventBase* evb_;\n  std::shared_ptr<AsyncSSLSocket> ssl_;\n  std::shared_ptr<AsyncSocket> tcp_;\n  PerLoopReadCallback perLoopReads_;\n};\n\nclass ErrorCheckingWriteCallback : public AsyncSocket::WriteCallback {\n public:\n  void writeSuccess() noexcept override {}\n\n  void writeErr(size_t, const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << \"write error: \" << ex.what();\n    EXPECT_NE(\n        ex.getType(),\n        AsyncSocketException::AsyncSocketExceptionType::SSL_ERROR);\n  }\n};\n\nclass WriteOnEofReadCallback : public ReadCallback {\n public:\n  using ReadCallback::ReadCallback;\n\n  void readEOF() noexcept override {\n    LOG(INFO) << \"Got EOF\";\n    auto chain = IOBuf::create(0);\n    for (size_t i = 0; i < 1000 * 1000; i++) {\n      auto buf = IOBuf::create(10);\n      buf->append(10);\n      memset(buf->writableData(), 'x', 10);\n      chain->prependChain(std::move(buf));\n    }\n    socket_->writeChain(&writeCallback_, std::move(chain));\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << ex.what();\n  }\n\n private:\n  ErrorCheckingWriteCallback writeCallback_;\n};\n\nTEST(AsyncSSLSocketTest, EarlyCloseNotify) {\n  WriteOnEofReadCallback readCallback(nullptr);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  EventBase eventBase;\n  CloseNotifyConnector cnc(&eventBase, server.getAddress());\n\n  eventBase.loop();\n}\n\n/**\n * Verify Client Ciphers obtained using SSL MSG Callback.\n */\nTEST(AsyncSSLSocketTest, SSLParseClientHelloSuccess) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  serverCtx->ciphers(\"ECDHE-RSA-AES128-SHA:AES128-SHA:AES256-SHA\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"AES256-SHA:AES128-SHA\");\n  clientCtx->loadPrivateKey(kTestKey);\n  clientCtx->loadCertificate(kTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServerParseClientHello server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n#if defined(OPENSSL_IS_BORINGSSL)\n  EXPECT_EQ(server.clientCiphers_, \"AES256-SHA:AES128-SHA\");\n#else\n  EXPECT_EQ(server.clientCiphers_, \"AES256-SHA:AES128-SHA:00ff\");\n#endif\n  EXPECT_EQ(server.chosenCipher_, \"AES256-SHA\");\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_TRUE(server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n}\n\n/**\n * Verify that server is able to get client cert by getPeerCert() API.\n */\nTEST(AsyncSSLSocketTest, GetClientCertificate) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  serverCtx->ciphers(\"ECDHE-RSA-AES128-SHA:AES128-SHA:AES256-SHA\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kClientTestCA);\n  serverCtx->loadClientCAList(kClientTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"AES256-SHA:AES128-SHA\");\n  clientCtx->loadPrivateKey(kClientTestKey);\n  clientCtx->loadCertificate(kClientTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServerParseClientHello server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  // Handshake should succeed.\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n\n  // Reclaim the sockets from SSLHandshakeBase.\n  auto cliSocket = std::move(client).moveSocket();\n  auto srvSocket = std::move(server).moveSocket();\n\n  // Client cert retrieved from server side.\n  auto serverPeerCert = srvSocket->getPeerCertificate();\n  CHECK(serverPeerCert);\n\n  // Client cert retrieved from client side.\n  auto clientSelfCert = cliSocket->getSelfCertificate();\n  CHECK(clientSelfCert);\n\n  auto serverX509 = serverPeerCert->getX509();\n  auto clientX509 = clientSelfCert->getX509();\n  CHECK(serverX509);\n  CHECK(clientX509);\n\n  // The two certs should be the same.\n  EXPECT_EQ(0, X509_cmp(clientX509.get(), serverX509.get()));\n}\n\nTEST(AsyncSSLSocketTest, SSLParseClientHelloOnePacket) {\n  EventBase eventBase;\n  auto ctx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  int bufLen = 42;\n  uint8_t majorVersion = 18;\n  uint8_t minorVersion = 25;\n\n  // Create callback buf\n  auto buf = IOBuf::create(bufLen);\n  buf->append(bufLen);\n  folly::io::RWPrivateCursor cursor(buf.get());\n  cursor.write<uint8_t>(SSL3_MT_CLIENT_HELLO);\n  cursor.write<uint16_t>(0);\n  cursor.write<uint8_t>(38);\n  cursor.write<uint8_t>(majorVersion);\n  cursor.write<uint8_t>(minorVersion);\n  cursor.skip(32);\n  cursor.write<uint32_t>(0);\n\n  SSL* ssl = ctx->createSSL();\n  SCOPE_EXIT {\n    SSL_free(ssl);\n  };\n  AsyncSSLSocket::UniquePtr sock(\n      new AsyncSSLSocket(ctx, &eventBase, fds[0], true));\n  sock->enableClientHelloParsing();\n\n  // Test client hello parsing in one packet\n  AsyncSSLSocket::clientHelloParsingCallback(\n      0, 0, SSL3_RT_HANDSHAKE, buf->data(), buf->length(), ssl, sock.get());\n  buf.reset();\n\n  auto parsedClientHello = sock->getClientHelloInfo();\n  EXPECT_TRUE(parsedClientHello != nullptr);\n  EXPECT_EQ(parsedClientHello->clientHelloMajorVersion_, majorVersion);\n  EXPECT_EQ(parsedClientHello->clientHelloMinorVersion_, minorVersion);\n}\n\nTEST(AsyncSSLSocketTest, SSLParseClientHelloTwoPackets) {\n  EventBase eventBase;\n  auto ctx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  int bufLen = 42;\n  uint8_t majorVersion = 18;\n  uint8_t minorVersion = 25;\n\n  // Create callback buf\n  auto buf = IOBuf::create(bufLen);\n  buf->append(bufLen);\n  folly::io::RWPrivateCursor cursor(buf.get());\n  cursor.write<uint8_t>(SSL3_MT_CLIENT_HELLO);\n  cursor.write<uint16_t>(0);\n  cursor.write<uint8_t>(38);\n  cursor.write<uint8_t>(majorVersion);\n  cursor.write<uint8_t>(minorVersion);\n  cursor.skip(32);\n  cursor.write<uint32_t>(0);\n\n  SSL* ssl = ctx->createSSL();\n  SCOPE_EXIT {\n    SSL_free(ssl);\n  };\n  AsyncSSLSocket::UniquePtr sock(\n      new AsyncSSLSocket(ctx, &eventBase, fds[0], true));\n  sock->enableClientHelloParsing();\n\n  // Test parsing with two packets with first packet size < 3\n  auto bufCopy = folly::IOBuf::copyBuffer(buf->data(), 2);\n  AsyncSSLSocket::clientHelloParsingCallback(\n      0,\n      0,\n      SSL3_RT_HANDSHAKE,\n      bufCopy->data(),\n      bufCopy->length(),\n      ssl,\n      sock.get());\n  bufCopy.reset();\n  bufCopy = folly::IOBuf::copyBuffer(buf->data() + 2, buf->length() - 2);\n  AsyncSSLSocket::clientHelloParsingCallback(\n      0,\n      0,\n      SSL3_RT_HANDSHAKE,\n      bufCopy->data(),\n      bufCopy->length(),\n      ssl,\n      sock.get());\n  bufCopy.reset();\n\n  auto parsedClientHello = sock->getClientHelloInfo();\n  EXPECT_TRUE(parsedClientHello != nullptr);\n  EXPECT_EQ(parsedClientHello->clientHelloMajorVersion_, majorVersion);\n  EXPECT_EQ(parsedClientHello->clientHelloMinorVersion_, minorVersion);\n}\n\nTEST(AsyncSSLSocketTest, SSLParseClientHelloMultiplePackets) {\n  EventBase eventBase;\n  auto ctx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  int bufLen = 42;\n  uint8_t majorVersion = 18;\n  uint8_t minorVersion = 25;\n\n  // Create callback buf\n  auto buf = IOBuf::create(bufLen);\n  buf->append(bufLen);\n  folly::io::RWPrivateCursor cursor(buf.get());\n  cursor.write<uint8_t>(SSL3_MT_CLIENT_HELLO);\n  cursor.write<uint16_t>(0);\n  cursor.write<uint8_t>(38);\n  cursor.write<uint8_t>(majorVersion);\n  cursor.write<uint8_t>(minorVersion);\n  cursor.skip(32);\n  cursor.write<uint32_t>(0);\n\n  SSL* ssl = ctx->createSSL();\n  SCOPE_EXIT {\n    SSL_free(ssl);\n  };\n  AsyncSSLSocket::UniquePtr sock(\n      new AsyncSSLSocket(ctx, &eventBase, fds[0], true));\n  sock->enableClientHelloParsing();\n\n  // Test parsing with multiple small packets\n  for (std::size_t i = 0; i < buf->length(); i += 3) {\n    auto bufCopy = folly::IOBuf::copyBuffer(\n        buf->data() + i, std::min((std::size_t)3, buf->length() - i));\n    AsyncSSLSocket::clientHelloParsingCallback(\n        0,\n        0,\n        SSL3_RT_HANDSHAKE,\n        bufCopy->data(),\n        bufCopy->length(),\n        ssl,\n        sock.get());\n    bufCopy.reset();\n  }\n\n  auto parsedClientHello = sock->getClientHelloInfo();\n  EXPECT_TRUE(parsedClientHello != nullptr);\n  EXPECT_EQ(parsedClientHello->clientHelloMajorVersion_, majorVersion);\n  EXPECT_EQ(parsedClientHello->clientHelloMinorVersion_, minorVersion);\n}\n\n/**\n * Verify sucessful behavior of SSL certificate validation.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationSuccess) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the client's verification callback is able to fail SSL\n * connection establishment.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationFailure) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, false);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(!client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(!server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the options in SSLContext can be overridden in\n * sslConnect/Accept.i.e specifying that no validation should be performed\n * allows an otherwise-invalid certificate to be accepted and doesn't fire\n * the validation callback.\n */\nTEST(AsyncSSLSocketTest, OverrideSSLCtxDisableVerify) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClientNoVerify client(std::move(clientSock), false, false);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  SSLHandshakeServerNoVerify server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the options in SSLContext can be overridden in\n * sslConnect/Accept. Enable verification even if context says otherwise.\n * Test requireClientCert with client cert\n */\nTEST(AsyncSSLSocketTest, OverrideSSLCtxEnableVerify) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadPrivateKey(kTestKey);\n  clientCtx->loadCertificate(kTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClientDoVerify client(std::move(clientSock), true, true);\n  SSLHandshakeServerDoVerify server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that the client's verification callback is able to override\n * the preverification failure and allow a successful connection.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationOverride) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Verify that specifying that no validation should be performed allows an\n * otherwise-invalid certificate to be accepted and doesn't fire the validation\n * callback.\n */\nTEST(AsyncSSLSocketTest, SSLHandshakeValidationSkip) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, dfServerCtx);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  dfServerCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(!client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(!client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(!server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(!server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Test requireClientCert with client cert\n */\nTEST(AsyncSSLSocketTest, ClientCertHandshakeSuccess) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(\n      SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadPrivateKey(kTestKey);\n  clientCtx->loadCertificate(kTestCert);\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeVerify_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(server.handshakeVerify_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n\n  // check certificates\n  auto clientSsl = std::move(client).moveSocket();\n  auto serverSsl = std::move(server).moveSocket();\n\n  auto clientPeer = clientSsl->getPeerCertificate();\n  auto clientSelf = clientSsl->getSelfCertificate();\n  auto serverPeer = serverSsl->getPeerCertificate();\n  auto serverSelf = serverSsl->getSelfCertificate();\n\n  EXPECT_NE(clientPeer, nullptr);\n  EXPECT_NE(clientSelf, nullptr);\n  EXPECT_NE(serverPeer, nullptr);\n  EXPECT_NE(serverSelf, nullptr);\n\n  EXPECT_EQ(clientPeer->getIdentity(), serverSelf->getIdentity());\n  EXPECT_EQ(clientSelf->getIdentity(), serverPeer->getIdentity());\n}\n\n/**\n * Test requireClientCert with no client cert\n */\nTEST(AsyncSSLSocketTest, NoClientCertHandshakeError) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->setVerificationOption(\n      SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_FALSE(server.handshakeVerify_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\n/**\n * Test OpenSSL 1.1.0's async functionality\n */\n#if FOLLY_OPENSSL_IS_110\n\nstatic void makeNonBlockingPipe(int pipefds[2]) {\n  if (pipe(pipefds) != 0) {\n    throw std::runtime_error(\"Cannot create pipe\");\n  }\n  if (::fcntl(pipefds[0], F_SETFL, O_NONBLOCK) != 0) {\n    throw std::runtime_error(\"Cannot set pipe to nonblocking\");\n  }\n  if (::fcntl(pipefds[1], F_SETFL, O_NONBLOCK) != 0) {\n    throw std::runtime_error(\"Cannot set pipe to nonblocking\");\n  }\n}\n\n// Custom RSA private key encryption method\nstatic int kRSAExIndex = -1;\nstatic int kRSAEvbExIndex = -1;\nstatic int kRSASocketExIndex = -1;\nstatic constexpr StringPiece kEngineId = \"AsyncSSLSocketTest\";\n\nstatic int customRsaPrivEnc(\n    int flen,\n    const unsigned char* from,\n    unsigned char* to,\n    RSA* rsa,\n    int padding) {\n  LOG(INFO) << \"rsa_priv_enc\";\n  EventBase* asyncJobEvb =\n      reinterpret_cast<EventBase*>(RSA_get_ex_data(rsa, kRSAEvbExIndex));\n  CHECK(asyncJobEvb);\n\n  RSA* actualRSA = reinterpret_cast<RSA*>(RSA_get_ex_data(rsa, kRSAExIndex));\n  CHECK(actualRSA);\n\n  AsyncSSLSocket* socket = reinterpret_cast<AsyncSSLSocket*>(\n      RSA_get_ex_data(rsa, kRSASocketExIndex));\n\n  ASYNC_JOB* job = ASYNC_get_current_job();\n  if (job == nullptr) {\n    throw std::runtime_error(\"Expected call in job context\");\n  }\n  ASYNC_WAIT_CTX* waitctx = ASYNC_get_wait_ctx(job);\n  OSSL_ASYNC_FD pipefds[2] = {0, 0};\n  makeNonBlockingPipe(pipefds);\n  if (!ASYNC_WAIT_CTX_set_wait_fd(\n          waitctx, kEngineId.data(), pipefds[0], nullptr, nullptr)) {\n    throw std::runtime_error(\"Cannot set wait fd\");\n  }\n  int ret = 0;\n  int* retptr = &ret;\n\n  auto hand = folly::NetworkSocket::native_handle_type(pipefds[1]);\n  auto asyncPipeWriter = folly::AsyncPipeWriter::newWriter(\n      asyncJobEvb, folly::NetworkSocket(hand));\n\n  asyncJobEvb->runInEventBaseThread([retptr = retptr,\n                                     flen = flen,\n                                     from = from,\n                                     to = to,\n                                     padding = padding,\n                                     actualRSA = actualRSA,\n                                     writer = std::move(asyncPipeWriter),\n                                     socket = socket]() {\n    LOG(INFO) << \"Running job\";\n    if (socket) {\n      LOG(INFO) << \"Got a socket passed in, closing it...\";\n      socket->closeNow();\n    }\n    *retptr = RSA_meth_get_priv_enc(RSA_PKCS1_OpenSSL())(\n        flen, from, to, actualRSA, padding);\n    LOG(INFO) << \"Finished job, writing to pipe\";\n    uint8_t byte = *retptr > 0 ? 1 : 0;\n    writer->write(nullptr, &byte, 1);\n  });\n\n  LOG(INFO) << \"About to pause job\";\n\n  ASYNC_pause_job();\n  LOG(INFO) << \"Resumed job with ret: \" << ret;\n  return ret;\n}\n\nvoid rsaFree(void*, void* ptr, CRYPTO_EX_DATA*, int, long, void*) {\n  LOG(INFO) << \"RSA_free is called with ptr \" << std::hex << ptr;\n  if (ptr == nullptr) {\n    LOG(INFO) << \"Returning early from rsaFree because ptr is null\";\n    return;\n  }\n  RSA* rsa = (RSA*)ptr;\n  auto meth = RSA_get_method(rsa);\n  if (meth != RSA_get_default_method()) {\n    auto nonconst = const_cast<RSA_METHOD*>(meth);\n    RSA_meth_free(nonconst);\n    RSA_set_method(rsa, RSA_get_default_method());\n  }\n  RSA_free(rsa);\n}\n\nstruct RSAPointers {\n  RSA* actualrsa{nullptr};\n  RSA* dummyrsa{nullptr};\n  RSA_METHOD* meth{nullptr};\n};\n\ninline void RSAPointersFree(RSAPointers* p) {\n  if (p->meth && p->dummyrsa && RSA_get_method(p->dummyrsa) == p->meth) {\n    RSA_set_method(p->dummyrsa, RSA_get_default_method());\n  }\n\n  if (p->meth) {\n    LOG(INFO) << \"Freeing meth\";\n    RSA_meth_free(p->meth);\n  }\n\n  if (p->actualrsa) {\n    LOG(INFO) << \"Freeing actualrsa\";\n    RSA_free(p->actualrsa);\n  }\n\n  if (p->dummyrsa) {\n    LOG(INFO) << \"Freeing dummyrsa\";\n    RSA_free(p->dummyrsa);\n  }\n\n  delete p;\n}\n\nusing RSAPointersDeleter =\n    folly::static_function_deleter<RSAPointers, RSAPointersFree>;\n\nstd::unique_ptr<RSAPointers, RSAPointersDeleter>\nsetupCustomRSA(const char* certPath, const char* keyPath, EventBase* jobEvb) {\n  auto certPEM = getFileAsBuf(certPath);\n  auto keyPEM = getFileAsBuf(keyPath);\n\n  ssl::BioUniquePtr certBio(\n      BIO_new_mem_buf((void*)certPEM.data(), certPEM.size()));\n  ssl::BioUniquePtr keyBio(\n      BIO_new_mem_buf((void*)keyPEM.data(), keyPEM.size()));\n\n  ssl::X509UniquePtr cert(\n      PEM_read_bio_X509(certBio.get(), nullptr, nullptr, nullptr));\n  ssl::EvpPkeyUniquePtr evpPkey(\n      PEM_read_bio_PrivateKey(keyBio.get(), nullptr, nullptr, nullptr));\n  ssl::EvpPkeyUniquePtr publicEvpPkey(X509_get_pubkey(cert.get()));\n\n  std::unique_ptr<RSAPointers, RSAPointersDeleter> ret(new RSAPointers());\n\n  RSA* actualrsa = EVP_PKEY_get1_RSA(evpPkey.get());\n  LOG(INFO) << \"actualrsa ptr \" << std::hex << (void*)actualrsa;\n  RSA* dummyrsa = EVP_PKEY_get1_RSA(publicEvpPkey.get());\n  if (dummyrsa == nullptr) {\n    throw std::runtime_error(\"Couldn't get RSA cert public factors\");\n  }\n  RSA_METHOD* meth = RSA_meth_dup(RSA_get_default_method());\n  if (meth == nullptr || RSA_meth_set1_name(meth, \"Async RSA method\") == 0 ||\n      RSA_meth_set_priv_enc(meth, customRsaPrivEnc) == 0 ||\n      RSA_meth_set_flags(meth, RSA_METHOD_FLAG_NO_CHECK) == 0) {\n    throw std::runtime_error(\"Cannot create async RSA_METHOD\");\n  }\n  RSA_set_method(dummyrsa, meth);\n  RSA_set_flags(dummyrsa, RSA_FLAG_EXT_PKEY);\n\n  kRSAExIndex = RSA_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);\n  kRSAEvbExIndex = RSA_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);\n  kRSASocketExIndex =\n      RSA_get_ex_new_index(0, nullptr, nullptr, nullptr, nullptr);\n  CHECK_NE(kRSAExIndex, -1);\n  CHECK_NE(kRSAEvbExIndex, -1);\n  CHECK_NE(kRSASocketExIndex, -1);\n  RSA_set_ex_data(dummyrsa, kRSAExIndex, actualrsa);\n  RSA_set_ex_data(dummyrsa, kRSAEvbExIndex, jobEvb);\n\n  ret->actualrsa = actualrsa;\n  ret->dummyrsa = dummyrsa;\n  ret->meth = meth;\n\n  return ret;\n}\n\n// TODO: disabled with ASAN doesn't play nice with ASYNC for some reason\n#ifndef FOLLY_SANITIZE_ADDRESS\nTEST(AsyncSSLSocketTest, OpenSSL110AsyncTest) {\n  ASYNC_init_thread(1, 1);\n  EventBase eventBase;\n  ScopedEventBaseThread jobEvbThread;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  auto rsaPointers =\n      setupCustomRSA(kTestCert, kTestKey, jobEvbThread.getEventBase());\n  CHECK(rsaPointers->dummyrsa);\n  // up-refs dummyrsa\n  SSL_CTX_use_RSAPrivateKey(serverCtx->getSSLCtx(), rsaPointers->dummyrsa);\n  SSL_CTX_set_mode(serverCtx->getSSLCtx(), SSL_MODE_ASYNC);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeSuccess_);\n  ASYNC_cleanup_thread();\n}\n\nTEST(AsyncSSLSocketTest, OpenSSL110AsyncTestFailure) {\n  ASYNC_init_thread(1, 1);\n  EventBase eventBase;\n  ScopedEventBaseThread jobEvbThread;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n  // Set the wrong key for the cert\n  auto rsaPointers =\n      setupCustomRSA(kTestCert, kClientTestKey, jobEvbThread.getEventBase());\n  CHECK(rsaPointers->dummyrsa);\n  SSL_CTX_use_RSAPrivateKey(serverCtx->getSSLCtx(), rsaPointers->dummyrsa);\n  SSL_CTX_set_mode(serverCtx->getSSLCtx(), SSL_MODE_ASYNC);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_TRUE(client.handshakeError_);\n  ASYNC_cleanup_thread();\n}\n\nTEST(AsyncSSLSocketTest, OpenSSL110AsyncTestClosedWithCallbackPending) {\n  ASYNC_init_thread(1, 1);\n  EventBase eventBase;\n  ScopedEventBaseThread jobEvbThread;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadCertificate(kTestCert);\n  serverCtx->loadTrustedCertificates(kTestCA);\n  serverCtx->loadClientCAList(kTestCA);\n\n  auto rsaPointers =\n      setupCustomRSA(kTestCert, kTestKey, jobEvbThread.getEventBase());\n  CHECK(rsaPointers->dummyrsa);\n  // up-refs dummyrsa\n  SSL_CTX_use_RSAPrivateKey(serverCtx->getSSLCtx(), rsaPointers->dummyrsa);\n  SSL_CTX_set_mode(serverCtx->getSSLCtx(), SSL_MODE_ASYNC);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  RSA_set_ex_data(rsaPointers->dummyrsa, kRSASocketExIndex, serverSock.get());\n\n  SSLHandshakeClient client(std::move(clientSock), false, false);\n  SSLHandshakeServer server(std::move(serverSock), false, false);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(server.handshakeError_);\n  EXPECT_TRUE(client.handshakeError_);\n  ASYNC_cleanup_thread();\n}\n#endif // FOLLY_SANITIZE_ADDRESS\n\n#endif // FOLLY_OPENSSL_IS_110\n\nTEST(AsyncSSLSocketTest, LoadCertFromMemory) {\n  using folly::ssl::OpenSSLUtils;\n  auto cert = getFileAsBuf(kTestCert);\n  auto key = getFileAsBuf(kTestKey);\n\n  ssl::BioUniquePtr certBio(BIO_new(BIO_s_mem()));\n  BIO_write(certBio.get(), cert.data(), cert.size());\n  ssl::BioUniquePtr keyBio(BIO_new(BIO_s_mem()));\n  BIO_write(keyBio.get(), key.data(), key.size());\n\n  // Create SSL structs from buffers to get properties\n  ssl::X509UniquePtr certStruct(\n      PEM_read_bio_X509(certBio.get(), nullptr, nullptr, nullptr));\n  ssl::EvpPkeyUniquePtr keyStruct(\n      PEM_read_bio_PrivateKey(keyBio.get(), nullptr, nullptr, nullptr));\n  certBio = nullptr;\n  keyBio = nullptr;\n\n  auto origCommonName = OpenSSLUtils::getCommonName(certStruct.get());\n  auto origKeySize = EVP_PKEY_bits(keyStruct.get());\n  certStruct = nullptr;\n  keyStruct = nullptr;\n\n  auto ctx = std::make_shared<SSLContext>();\n  ctx->loadPrivateKeyFromBufferPEM(key);\n  ctx->loadCertificateFromBufferPEM(cert);\n  ctx->loadTrustedCertificates(kTestCA);\n\n  ssl::SSLUniquePtr ssl(ctx->createSSL());\n\n  auto newCert = SSL_get_certificate(ssl.get());\n  auto newKey = SSL_get_privatekey(ssl.get());\n\n  // Get properties from SSL struct\n  auto newCommonName = OpenSSLUtils::getCommonName(newCert);\n  auto newKeySize = EVP_PKEY_bits(newKey);\n\n  // Check that the key and cert have the expected properties\n  EXPECT_EQ(origCommonName, newCommonName);\n  EXPECT_EQ(origKeySize, newKeySize);\n}\n\nTEST(AsyncSSLSocketTest, MinWriteSizeTest) {\n  EventBase eb;\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // create SSL socket\n  AsyncSSLSocket::UniquePtr socket(new AsyncSSLSocket(sslContext, &eb));\n\n  EXPECT_EQ(1500, socket->getMinWriteSize());\n\n  socket->setMinWriteSize(0);\n  EXPECT_EQ(0, socket->getMinWriteSize());\n  socket->setMinWriteSize(50000);\n  EXPECT_EQ(50000, socket->getMinWriteSize());\n}\n\nclass ReadCallbackTerminator : public ReadCallback {\n public:\n  ReadCallbackTerminator(EventBase* base, WriteCallbackBase* wcb)\n      : ReadCallback(wcb), base_(base) {}\n\n  // Do not write data back, terminate the loop.\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n\n    socket_->setReadCB(nullptr);\n    base_->terminateLoopSoon();\n  }\n\n private:\n  EventBase* base_;\n};\n\n/**\n * Test a full unencrypted codepath\n */\nTEST(AsyncSSLSocketTest, UnencryptedTest) {\n  EventBase base;\n\n  auto clientCtx = std::make_shared<folly::SSLContext>();\n  auto serverCtx = std::make_shared<folly::SSLContext>();\n  NetworkSocket fds[2];\n  getfds(fds);\n  getctx(clientCtx, serverCtx);\n  auto client =\n      AsyncSSLSocket::newSocket(clientCtx, &base, fds[0], false, true);\n  auto server = AsyncSSLSocket::newSocket(serverCtx, &base, fds[1], true, true);\n\n  ReadCallbackTerminator readCallback(&base, nullptr);\n  server->setReadCB(&readCallback);\n  readCallback.setSocket(server);\n\n  uint8_t buf[128];\n  memset(buf, 'a', sizeof(buf));\n  client->write(nullptr, buf, sizeof(buf));\n\n  // Check that bytes are unencrypted\n  char c;\n  EXPECT_EQ(1, netops::recv(fds[1], &c, 1, MSG_PEEK));\n  EXPECT_EQ('a', c);\n\n  EventBaseAborter eba(&base, 3000);\n  base.loop();\n\n  EXPECT_EQ(1, readCallback.buffers.size());\n  EXPECT_EQ(AsyncSSLSocket::STATE_UNENCRYPTED, client->getSSLState());\n\n  server->setReadCB(&readCallback);\n\n  // Unencrypted\n  server->sslAccept(nullptr);\n  client->sslConn(nullptr);\n\n  // Do NOT wait for handshake, writing should be queued and happen after\n\n  client->write(nullptr, buf, sizeof(buf));\n\n  // Check that bytes are *not* unencrypted\n  char c2;\n  EXPECT_EQ(1, netops::recv(fds[1], &c2, 1, MSG_PEEK));\n  EXPECT_NE('a', c2);\n\n  base.loop();\n\n  EXPECT_EQ(2, readCallback.buffers.size());\n  EXPECT_EQ(AsyncSSLSocket::STATE_ESTABLISHED, client->getSSLState());\n}\n\nTEST(AsyncSSLSocketTest, ConnectUnencryptedTest) {\n  auto clientCtx = std::make_shared<folly::SSLContext>();\n  auto serverCtx = std::make_shared<folly::SSLContext>();\n  getctx(clientCtx, serverCtx);\n\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  EventBase evb;\n  std::shared_ptr<AsyncSSLSocket> socket =\n      AsyncSSLSocket::newSocket(clientCtx, &evb, true);\n  socket->connect(nullptr, server.getAddress(), 0);\n\n  evb.loop();\n\n  EXPECT_EQ(AsyncSSLSocket::STATE_UNENCRYPTED, socket->getSSLState());\n  socket->sslConn(nullptr);\n  evb.loop();\n  EXPECT_EQ(AsyncSSLSocket::STATE_ESTABLISHED, socket->getSSLState());\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(nullptr, buf.data(), buf.size());\n\n  socket->close();\n}\n\n/**\n * Test acceptrunner in various situations\n */\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerBasic) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  serverCtx->sslAcceptRunner(std::make_unique<SSLAcceptEvbRunner>(&eventBase));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_LE(0, client.handshakeTime.count());\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n  EXPECT_LE(0, server.handshakeTime.count());\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerAcceptError) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptErrorRunner>(&eventBase));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_FALSE(client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerAcceptClose) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptCloseRunner>(&eventBase, serverSock.get()));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  EXPECT_FALSE(client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerAcceptDestroy) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptDestroyRunner>(&eventBase, &server));\n\n  eventBase.loop();\n\n  EXPECT_FALSE(client.handshakeSuccess_);\n  EXPECT_TRUE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerFiber) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptFiberRunner>(&eventBase));\n\n  eventBase.loop();\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_FALSE(server.handshakeError_);\n}\n\nstatic int newCloseCb(SSL* ssl, SSL_SESSION*) {\n  AsyncSSLSocket::getFromSSL(ssl)->closeNow();\n  return 1;\n}\n\n#if FOLLY_OPENSSL_IS_110\nstatic SSL_SESSION* getCloseCb(SSL* ssl, const unsigned char*, int, int*) {\n#else\nstatic SSL_SESSION* getCloseCb(SSL* ssl, unsigned char*, int, int*) {\n#endif\n  AsyncSSLSocket::getFromSSL(ssl)->closeNow();\n  return nullptr;\n} // namespace folly\n\nTEST(AsyncSSLSocketTest, SSLAcceptRunnerFiberCloseSessionCb) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto serverCtx = std::make_shared<SSLContext>();\n  serverCtx->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n  SSL_CTX_set_session_cache_mode(\n      serverCtx->getSSLCtx(),\n      SSL_SESS_CACHE_NO_INTERNAL | SSL_SESS_CACHE_SERVER);\n  SSL_CTX_sess_set_new_cb(serverCtx->getSSLCtx(), &newCloseCb);\n  SSL_CTX_sess_set_get_cb(serverCtx->getSSLCtx(), &getCloseCb);\n  serverCtx->sslAcceptRunner(\n      std::make_unique<SSLAcceptFiberRunner>(&eventBase));\n\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::VERIFY);\n  clientCtx->ciphers(\"AES128-SHA256\");\n  clientCtx->loadTrustedCertificates(kTestCA);\n  clientCtx->setOptions(SSL_OP_NO_TICKET);\n\n  NetworkSocket fds[2];\n  getfds(fds);\n\n  AsyncSSLSocket::UniquePtr clientSock(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSock(\n      new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n  SSLHandshakeClient client(std::move(clientSock), true, true);\n  SSLHandshakeServer server(std::move(serverSock), true, true);\n\n  eventBase.loop();\n\n  // As close() is called during session callbacks, client sees it as a\n  // successful connection\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_FALSE(client.handshakeError_);\n  EXPECT_FALSE(server.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeError_);\n}\n\nTEST(AsyncSSLSocketTest, ConnResetErrorString) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  auto socket = std::make_shared<BlockingSocket>(server.getAddress(), nullptr);\n  socket->open();\n  uint8_t buf[3] = {0x16, 0x03, 0x01};\n  socket->write(buf, sizeof(buf));\n  socket->closeWithReset();\n\n  handshakeCallback.waitForHandshake();\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"Network error\"), std::string::npos);\n  EXPECT_NE(handshakeCallback.errorString_.find(\"104\"), std::string::npos);\n}\n\nTEST(AsyncSSLSocketTest, ConnEOFErrorString) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  auto socket = std::make_shared<BlockingSocket>(server.getAddress(), nullptr);\n  socket->open();\n  uint8_t buf[3] = {0x16, 0x03, 0x01};\n  socket->write(buf, sizeof(buf));\n  socket->close();\n\n  handshakeCallback.waitForHandshake();\n#if FOLLY_OPENSSL_IS_110\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"Network error\"), std::string::npos);\n#else\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"Connection EOF\"), std::string::npos);\n#endif\n}\n\nTEST(AsyncSSLSocketTest, ConnOpenSSLErrorString) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  WriteErrorCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  auto socket = std::make_shared<BlockingSocket>(server.getAddress(), nullptr);\n  socket->open();\n  uint8_t buf[256] = {0x16, 0x03};\n  memset(buf + 2, 'a', sizeof(buf) - 2);\n  socket->write(buf, sizeof(buf));\n  socket->close();\n\n  handshakeCallback.waitForHandshake();\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"SSL routines\"), std::string::npos);\n#if defined(OPENSSL_IS_BORINGSSL)\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"ENCRYPTED_LENGTH_TOO_LONG\"),\n      std::string::npos);\n#elif FOLLY_OPENSSL_IS_110\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"packet length too long\"),\n      std::string::npos);\n#else\n  EXPECT_NE(\n      handshakeCallback.errorString_.find(\"unknown protocol\"),\n      std::string::npos);\n#endif\n}\n\nTEST(AsyncSSLSocketTest, TestSSLCipherCodeToNameMap) {\n  using folly::ssl::OpenSSLUtils;\n  EXPECT_EQ(\n      OpenSSLUtils::getCipherName(0xc02c), \"ECDHE-ECDSA-AES256-GCM-SHA384\");\n  // TLS_DHE_RSA_WITH_DES_CBC_SHA - We shouldn't be building with this\n  EXPECT_EQ(OpenSSLUtils::getCipherName(0x0015), \"\");\n  // This indicates TLS_EMPTY_RENEGOTIATION_INFO_SCSV, no name expected\n  EXPECT_EQ(OpenSSLUtils::getCipherName(0x00ff), \"\");\n}\n\n#if defined __linux__\n/**\n * Ensure TransparentTLS flag is disabled with AsyncSSLSocket\n */\nTEST(AsyncSSLSocketTest, TTLSDisabled) {\n  // clear all setsockopt tracking history\n  globalStatic.reset();\n\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, false);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  EXPECT_EQ(1, globalStatic.ttlsDisabledSet.count(socket->getNetworkSocket()));\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // close()\n  socket->close();\n}\n#endif\n\n#if FOLLY_ALLOW_TFO\n\nclass MockAsyncTFOSSLSocket : public AsyncSSLSocket {\n public:\n  using UniquePtr = std::unique_ptr<MockAsyncTFOSSLSocket, Destructor>;\n\n  explicit MockAsyncTFOSSLSocket(\n      std::shared_ptr<folly::SSLContext> sslCtx,\n      EventBase* evb)\n      : AsyncSocket(evb), AsyncSSLSocket(sslCtx, evb) {}\n\n  MOCK_METHOD3(\n      tfoSendMsg,\n      ssize_t(NetworkSocket fd, struct msghdr* msg, int msg_flags));\n};\n\n#if defined __linux__\n/**\n * Ensure TransparentTLS flag is disabled with AsyncSSLSocket + TFO\n */\nTEST(AsyncSSLSocketTest, TTLSDisabledWithTFO) {\n  // clear all setsockopt tracking history\n  globalStatic.reset();\n\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  socket->open();\n\n  EXPECT_EQ(1, globalStatic.ttlsDisabledSet.count(socket->getNetworkSocket()));\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // close()\n  socket->close();\n}\n#endif\n\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server with TFO.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadCloseTFO) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  socket->open();\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // read()\n  std::array<uint8_t, 128> readbuf;\n  uint32_t bytesRead = socket->readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf.data(), readbuf.data(), bytesRead), 0);\n\n  // close()\n  socket->close();\n}\n\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server with TFO.\n */\nTEST(AsyncSSLSocketTest, ConnectWriteReadCloseTFOWithTFOServerDisabled) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, false);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  socket->open();\n\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  socket->write(buf.data(), buf.size());\n\n  // read()\n  std::array<uint8_t, 128> readbuf;\n  uint32_t bytesRead = socket->readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf.data(), readbuf.data(), bytesRead), 0);\n\n  // close()\n  socket->close();\n}\n\nclass ConnCallback : public AsyncSocket::ConnectCallback {\n public:\n  void connectSuccess() noexcept override {\n    state = State::SUCCESS;\n  }\n\n  void connectErr(const AsyncSocketException& ex) noexcept override {\n    state = State::ERROR;\n    error = ex.what();\n  }\n\n  enum class State { WAITING, SUCCESS, ERROR };\n\n  State state{State::WAITING};\n  std::string error;\n};\n\ntemplate <class Cardinality>\nMockAsyncTFOSSLSocket::UniquePtr setupSocketWithFallback(\n    EventBase* evb,\n    const SocketAddress& address,\n    Cardinality cardinality) {\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket = MockAsyncTFOSSLSocket::UniquePtr(\n      new MockAsyncTFOSSLSocket(sslContext, evb));\n  socket->enableTFO();\n\n  EXPECT_CALL(*socket, tfoSendMsg(_, _, _))\n      .Times(cardinality)\n      .WillOnce(Invoke([&](NetworkSocket fd, struct msghdr*, int) {\n        sockaddr_storage addr;\n        auto len = address.getAddress(&addr);\n        return netops::connect(fd, (const struct sockaddr*)&addr, len);\n      }));\n  return socket;\n}\n\nTEST(AsyncSSLSocketTest, ConnectWriteReadCloseTFOFallback) {\n  // Start listening on a local port\n  WriteCallbackBase writeCallback;\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  EventBase evb;\n\n  auto socket = setupSocketWithFallback(&evb, server.getAddress(), 1);\n  ConnCallback ccb;\n  socket->connect(&ccb, server.getAddress(), 30);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::SUCCESS, ccb.state);\n\n  evb.runInEventBaseThread([&] { socket->detachEventBase(); });\n  evb.loop();\n\n  BlockingSocket sock(std::move(socket));\n  // write()\n  std::array<uint8_t, 128> buf;\n  memset(buf.data(), 'a', buf.size());\n  sock.write(buf.data(), buf.size());\n\n  // read()\n  std::array<uint8_t, 128> readbuf;\n  uint32_t bytesRead = sock.readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, 128);\n  EXPECT_EQ(memcmp(buf.data(), readbuf.data(), bytesRead), 0);\n\n  // close()\n  sock.close();\n}\n\n#if !defined(OPENSSL_IS_BORINGSSL)\nTEST(AsyncSSLSocketTest, ConnectTFOTimeout) {\n  // Start listening on a local port\n  ConnectTimeoutCallback acceptCallback;\n  TestSSLServer server(&acceptCallback, true);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->enableTFO();\n  EXPECT_THROW(\n      socket->open(std::chrono::milliseconds(20)), AsyncSocketException);\n}\n#endif\n\n#if !defined(OPENSSL_IS_BORINGSSL)\nTEST(AsyncSSLSocketTest, ConnectTFOFallbackTimeout) {\n  // Start listening on a local port\n  ConnectTimeoutCallback acceptCallback;\n  TestSSLServer server(&acceptCallback, true);\n\n  EventBase evb;\n\n  auto socket = setupSocketWithFallback(&evb, server.getAddress(), AtMost(1));\n  ConnCallback ccb;\n  // Set a short timeout\n  socket->connect(&ccb, server.getAddress(), 1);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::ERROR, ccb.state);\n}\n#endif\n\nTEST(AsyncSSLSocketTest, HandshakeTFOFallbackTimeout) {\n  // Start listening on a local port\n  EmptyReadCallback readCallback;\n  HandshakeCallback handshakeCallback(\n      &readCallback, HandshakeCallback::EXPECT_ERROR);\n  HandshakeTimeoutCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback, true);\n\n  EventBase evb;\n\n  auto socket = setupSocketWithFallback(&evb, server.getAddress(), AtMost(1));\n  ConnCallback ccb;\n  socket->connect(&ccb, server.getAddress(), 100);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::ERROR, ccb.state);\n  EXPECT_THAT(ccb.error, testing::HasSubstr(\"SSL connect timed out\"));\n}\n\nTEST(AsyncSSLSocketTest, HandshakeTFORefused) {\n  // Start listening on a local port\n  EventBase evb;\n\n  // Hopefully nothing is listening on this address\n  SocketAddress addr(\"127.0.0.1\", 65535);\n  auto socket = setupSocketWithFallback(&evb, addr, AtMost(1));\n  ConnCallback ccb;\n  socket->connect(&ccb, addr, 100);\n\n  evb.loop();\n  EXPECT_EQ(ConnCallback::State::ERROR, ccb.state);\n  EXPECT_THAT(ccb.error, testing::HasSubstr(\"refused\"));\n}\n\nTEST(AsyncSSLSocketTest, TestPreReceivedData) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSockPtr(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSSLSocket::UniquePtr serverSockPtr(\n      new AsyncSSLSocket(dfServerCtx, &eventBase, fds[1], true));\n  auto clientSock = clientSockPtr.get();\n  auto serverSock = serverSockPtr.get();\n  SSLHandshakeClient client(std::move(clientSockPtr), true, true);\n\n  // Steal some data from the server.\n  std::array<uint8_t, 10> buf;\n  auto bytesReceived = netops::recv(fds[1], buf.data(), buf.size(), 0);\n  checkUnixError(bytesReceived, \"recv failed\");\n\n  serverSock->setPreReceivedData(\n      IOBuf::wrapBuffer(ByteRange(buf.data(), bytesReceived)));\n  SSLHandshakeServer server(std::move(serverSockPtr), true, true);\n  while (!client.handshakeSuccess_ && !client.handshakeError_) {\n    eventBase.loopOnce();\n  }\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_EQ(\n      serverSock->getRawBytesReceived(), clientSock->getRawBytesWritten());\n}\n\nTEST(AsyncSSLSocketTest, TestMoveFromAsyncSocket) {\n  EventBase eventBase;\n  auto clientCtx = std::make_shared<SSLContext>();\n  auto dfServerCtx = std::make_shared<SSLContext>();\n  std::array<NetworkSocket, 2> fds;\n  getfds(fds.data());\n  getctx(clientCtx, dfServerCtx);\n\n  AsyncSSLSocket::UniquePtr clientSockPtr(\n      new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n  AsyncSocket::UniquePtr serverSockPtr(new AsyncSocket(&eventBase, fds[1]));\n  auto clientSock = clientSockPtr.get();\n  auto serverSock = serverSockPtr.get();\n  SSLHandshakeClient client(std::move(clientSockPtr), true, true);\n\n  // Steal some data from the server.\n  std::array<uint8_t, 10> buf;\n  auto bytesReceived = netops::recv(fds[1], buf.data(), buf.size(), 0);\n  checkUnixError(bytesReceived, \"recv failed\");\n\n  serverSock->setPreReceivedData(\n      IOBuf::wrapBuffer(ByteRange(buf.data(), bytesReceived)));\n  AsyncSSLSocket::UniquePtr serverSSLSockPtr(\n      new AsyncSSLSocket(dfServerCtx, std::move(serverSockPtr), true));\n  auto serverSSLSock = serverSSLSockPtr.get();\n  SSLHandshakeServer server(std::move(serverSSLSockPtr), true, true);\n  while (!client.handshakeSuccess_ && !client.handshakeError_) {\n    eventBase.loopOnce();\n  }\n\n  EXPECT_TRUE(client.handshakeSuccess_);\n  EXPECT_TRUE(server.handshakeSuccess_);\n  EXPECT_EQ(\n      serverSSLSock->getRawBytesReceived(), clientSock->getRawBytesWritten());\n}\n\n/**\n * Test overriding the flags passed to \"sendmsg()\" system call,\n * and verifying that write requests fail properly.\n */\nTEST(AsyncSSLSocketTest, SendMsgParamsCallback) {\n  // Start listening on a local port\n  SendMsgFlagsCallback msgCallback;\n  ExpectWriteErrorCallback writeCallback(&msgCallback);\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // Setting flags to \"-1\" to trigger \"Invalid argument\" error\n  // on attempt to use this flags in sendmsg() system call.\n  msgCallback.resetFlags(-1);\n\n  // write()\n  std::vector<uint8_t> buf(128, 'a');\n  ASSERT_EQ(socket->write(buf.data(), buf.size()), buf.size());\n\n  // close()\n  socket->close();\n\n  cerr << \"SendMsgParamsCallback test completed\" << endl;\n}\n\n#ifdef FOLLY_HAVE_MSG_ERRQUEUE\n/**\n * Test connecting to, writing to, reading from, and closing the\n * connection to the SSL server with ancillary data from the application.\n */\nTEST(AsyncSSLSocketTest, SendMsgDataCallback) {\n  // This test requires Linux kernel v4.6 or later\n  struct utsname s_uname;\n  memset(&s_uname, 0, sizeof(s_uname));\n  ASSERT_EQ(uname(&s_uname), 0);\n  int major, minor;\n  folly::StringPiece extra;\n  if (folly::split<false>(\n          '.', std::string(s_uname.release) + \".\", major, minor, extra)) {\n    if (major < 4 || (major == 4 && minor < 6)) {\n      LOG(INFO) << \"Kernel version: 4.6 and newer required for this test (\"\n                << \"kernel ver. \" << s_uname.release << \" detected).\";\n      return;\n    }\n  }\n\n  // Start listening on a local port\n  SendMsgAncillaryDataCallback msgCallback;\n  WriteCheckTimestampCallback writeCallback(&msgCallback);\n  ReadCallback readCallback(&writeCallback);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n\n  // Set up SSL context.\n  auto sslContext = std::make_shared<SSLContext>();\n  sslContext->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n\n  // connect\n  auto socket =\n      std::make_shared<BlockingSocket>(server.getAddress(), sslContext);\n  socket->open();\n\n  // we'll pass the EOR and TIMESTAMP_TX flags with the write back\n  // EOR tracking must be enabled for WriteFlags be passed\n  const auto writeFlags =\n      folly::WriteFlags::EOR | folly::WriteFlags::TIMESTAMP_TX;\n  readCallback.setWriteFlags(writeFlags);\n  msgCallback.setEorTracking(true);\n\n  // Init ancillary data buffer to trigger timestamp notification\n  //\n  // We generate the same ancillary data regardless of the specific WriteFlags,\n  // we verify that the WriteFlags are observed as expected below.\n  union {\n    uint8_t ctrl_data[CMSG_LEN(sizeof(uint32_t))];\n    struct cmsghdr cmsg;\n  } u;\n  u.cmsg.cmsg_level = SOL_SOCKET;\n  u.cmsg.cmsg_type = SO_TIMESTAMPING;\n  u.cmsg.cmsg_len = CMSG_LEN(sizeof(uint32_t));\n  uint32_t flags = SOF_TIMESTAMPING_TX_SCHED | SOF_TIMESTAMPING_TX_SOFTWARE |\n      SOF_TIMESTAMPING_TX_ACK;\n  memcpy(CMSG_DATA(&u.cmsg), &flags, sizeof(uint32_t));\n  std::vector<char> ctrl(CMSG_LEN(sizeof(uint32_t)));\n  memcpy(ctrl.data(), u.ctrl_data, CMSG_LEN(sizeof(uint32_t)));\n  msgCallback.resetData(std::move(ctrl));\n\n  // write(), including flags\n  std::vector<uint8_t> buf(128, 'a');\n  socket->write(buf.data(), buf.size(), writeFlags);\n\n  // read()\n  std::vector<uint8_t> readbuf(buf.size());\n  uint32_t bytesRead = socket->readAll(readbuf.data(), readbuf.size());\n  EXPECT_EQ(bytesRead, buf.size());\n  EXPECT_TRUE(std::equal(buf.begin(), buf.end(), readbuf.begin()));\n\n  // should receive three timestamps (schedule, TX/SND, ACK)\n  // may take some time for all to arrive, so loop to wait\n  //\n  // socket error queue does not have the equivalent of an EOF, so we must\n  // loop on it unless we want to use libevent for this test...\n  const std::vector<int32_t> timestampsExpected = {\n      SCM_TSTAMP_SCHED, SCM_TSTAMP_SND, SCM_TSTAMP_ACK};\n  std::vector<int32_t> timestampsReceived;\n  while (timestampsExpected.size() != timestampsReceived.size()) {\n    const auto timestamps = writeCallback.getTimestampNotifications();\n    timestampsReceived.insert(\n        timestampsReceived.end(), timestamps.begin(), timestamps.end());\n  }\n  EXPECT_THAT(timestampsReceived, ElementsAreArray(timestampsExpected));\n\n  // check the observed write flags\n  EXPECT_EQ(\n      static_cast<std::underlying_type<folly::WriteFlags>::type>(\n          msgCallback.getObservedWriteFlags()),\n      static_cast<std::underlying_type<folly::WriteFlags>::type>(writeFlags));\n\n  // close()\n  socket->close();\n  cerr << \"SendMsgDataCallback test completed\" << endl;\n}\n#endif // FOLLY_HAVE_MSG_ERRQUEUE\n\n#endif\n\nTEST(AsyncSSLSocketTest, TestSNIClientHelloBehavior) {\n  EventBase eventBase;\n  auto serverCtx = std::make_shared<SSLContext>();\n  auto clientCtx = std::make_shared<SSLContext>();\n  serverCtx->loadPrivateKey(kTestKey);\n  serverCtx->loadCertificate(kTestCert);\n\n  clientCtx->setSessionCacheContext(\"test context\");\n  clientCtx->setVerificationOption(SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  SSL_SESSION* resumptionSession = nullptr;\n\n  {\n    std::array<NetworkSocket, 2> fds;\n    getfds(fds.data());\n\n    AsyncSSLSocket::UniquePtr clientSock(\n        new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n    AsyncSSLSocket::UniquePtr serverSock(\n        new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n    // Client sends SNI that doesn't match anything the server cert advertises\n    clientSock->setServerName(\"Foobar\");\n\n    SSLHandshakeServerParseClientHello server(\n        std::move(serverSock), true, true);\n    SSLHandshakeClient client(std::move(clientSock), true, true);\n    eventBase.loop();\n\n    serverSock = std::move(server).moveSocket();\n    auto chi = serverSock->getClientHelloInfo();\n    ASSERT_NE(chi, nullptr);\n    EXPECT_EQ(\n        std::string(\"Foobar\"), std::string(serverSock->getSSLServerName()));\n\n    // create another client, resuming with the prior session, but under a\n    // different common name.\n    clientSock = std::move(client).moveSocket();\n    resumptionSession = clientSock->getSSLSession();\n  }\n\n  {\n    std::array<NetworkSocket, 2> fds;\n    getfds(fds.data());\n\n    AsyncSSLSocket::UniquePtr clientSock(\n        new AsyncSSLSocket(clientCtx, &eventBase, fds[0], false));\n    AsyncSSLSocket::UniquePtr serverSock(\n        new AsyncSSLSocket(serverCtx, &eventBase, fds[1], true));\n\n    clientSock->setSSLSession(resumptionSession, true);\n    clientSock->setServerName(\"Baz\");\n    SSLHandshakeServerParseClientHello server(\n        std::move(serverSock), true, true);\n    SSLHandshakeClient client(std::move(clientSock), true, true);\n    eventBase.loop();\n\n    serverSock = std::move(server).moveSocket();\n    clientSock = std::move(client).moveSocket();\n    EXPECT_TRUE(clientSock->getSSLSessionReused());\n\n    // OpenSSL 1.1.1 changes the semantics of SSL_get_servername\n    // in\n    // https://github.com/openssl/openssl/commit/1c4aa31d79821dee9be98e915159d52cc30d8403\n    //\n    // Previously, the SNI would be taken from the ClientHello.\n    // Now, the SNI will be taken from the established session.\n    //\n    // But the session that was established with the client (prior handshake)\n    // would not have set the server name field because the SNI that the client\n    // requested (\"Foobar\") did not match any of the SANs that the server was\n    // presenting (\"127.0.0.1\")\n    //\n    // To preserve this 1.1.0 behavior, getSSLServerName() should return the\n    // parsed ClientHello servername. This test asserts this behavior.\n    auto sni = serverSock->getSSLServerName();\n    ASSERT_NE(sni, nullptr);\n\n    std::string sniStr(sni);\n    EXPECT_EQ(sniStr, std::string(\"Baz\"));\n  }\n}\n} // namespace folly\n\n#ifdef SIGPIPE\n///////////////////////////////////////////////////////////////////////////\n// init_unit_test_suite\n///////////////////////////////////////////////////////////////////////////\nnamespace {\nstruct Initializer {\n  Initializer() {\n    signal(SIGPIPE, SIG_IGN);\n  }\n};\nInitializer initializer;\n} // namespace\n#endif\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n#include <signal.h>\n\n#include <folly/ExceptionWrapper.h>\n#include <folly/SocketAddress.h>\n#include <folly/experimental/TestUtil.h>\n#include <folly/fibers/FiberManagerMap.h>\n#include <folly/io/async/AsyncSSLSocket.h>\n#include <folly/io/async/AsyncServerSocket.h>\n#include <folly/io/async/AsyncSocket.h>\n#include <folly/io/async/AsyncTimeout.h>\n#include <folly/io/async/AsyncTransport.h>\n#include <folly/io/async/EventBase.h>\n#include <folly/io/async/ssl/SSLErrors.h>\n#include <folly/io/async/test/TestSSLServer.h>\n#include <folly/portability/GTest.h>\n#include <folly/portability/PThread.h>\n#include <folly/portability/Sockets.h>\n#include <folly/portability/Unistd.h>\n\n#include <fcntl.h>\n#include <sys/types.h>\n#include <condition_variable>\n#include <iostream>\n#include <list>\n#include <memory>\n\nnamespace folly {\n\n// The destructors of all callback classes assert that the state is\n// STATE_SUCCEEDED, for both possitive and negative tests. The tests\n// are responsible for setting the succeeded state properly before the\n// destructors are called.\n\nclass SendMsgParamsCallbackBase\n    : public folly::AsyncSocket::SendMsgParamsCallback {\n public:\n  SendMsgParamsCallbackBase() {}\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n    oldCallback_ = socket_->getSendMsgParamsCB();\n    socket_->setSendMsgParamCB(this);\n    socket_->setEorTracking(trackEor_);\n  }\n\n  void setEorTracking(bool track) {\n    CHECK(!socket_); // should only be called during setup\n    trackEor_ = track;\n  }\n\n  int getFlagsImpl(\n      folly::WriteFlags flags,\n      int /*defaultFlags*/) noexcept override {\n    return oldCallback_->getFlags(flags, false /*zeroCopyEnabled*/);\n  }\n\n  void getAncillaryData(folly::WriteFlags flags, void* data) noexcept override {\n    oldCallback_->getAncillaryData(flags, data);\n  }\n\n  uint32_t getAncillaryDataSize(folly::WriteFlags flags) noexcept override {\n    return oldCallback_->getAncillaryDataSize(flags);\n  }\n\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  bool trackEor_{false};\n  folly::AsyncSocket::SendMsgParamsCallback* oldCallback_{nullptr};\n};\n\nclass SendMsgFlagsCallback : public SendMsgParamsCallbackBase {\n public:\n  SendMsgFlagsCallback() {}\n\n  void resetFlags(int flags) {\n    flags_ = flags;\n  }\n\n  int getFlagsImpl(\n      folly::WriteFlags flags,\n      int /*defaultFlags*/) noexcept override {\n    if (flags_) {\n      return flags_;\n    } else {\n      return oldCallback_->getFlags(flags, false /*zeroCopyEnabled*/);\n    }\n  }\n\n  int flags_{0};\n};\n\nclass SendMsgAncillaryDataCallback : public SendMsgParamsCallbackBase {\n public:\n  SendMsgAncillaryDataCallback() {}\n\n  /**\n   * This data will be returned on calls to getAncillaryData.\n   */\n  void resetData(std::vector<char>&& data) {\n    ancillaryData_.swap(data);\n  }\n\n  /**\n   * These flags were observed on the last call to getAncillaryData.\n   */\n  folly::WriteFlags getObservedWriteFlags() {\n    return observedWriteFlags_;\n  }\n\n  void getAncillaryData(folly::WriteFlags flags, void* data) noexcept override {\n    // getAncillaryData is called through a long chain of functions after send\n    // record the observed write flags so we can compare later\n    observedWriteFlags_ = flags;\n\n    if (ancillaryData_.size()) {\n      std::cerr << \"getAncillaryData: copying data\" << std::endl;\n      memcpy(data, ancillaryData_.data(), ancillaryData_.size());\n    } else {\n      oldCallback_->getAncillaryData(flags, data);\n    }\n  }\n\n  uint32_t getAncillaryDataSize(folly::WriteFlags flags) noexcept override {\n    if (ancillaryData_.size()) {\n      std::cerr << \"getAncillaryDataSize: returning size\" << std::endl;\n      return ancillaryData_.size();\n    } else {\n      return oldCallback_->getAncillaryDataSize(flags);\n    }\n  }\n\n  folly::WriteFlags observedWriteFlags_{};\n  std::vector<char> ancillaryData_;\n};\n\nclass WriteCallbackBase : public AsyncTransportWrapper::WriteCallback {\n public:\n  explicit WriteCallbackBase(SendMsgParamsCallbackBase* mcb = nullptr)\n      : state(STATE_WAITING),\n        bytesWritten(0),\n        exception(AsyncSocketException::UNKNOWN, \"none\"),\n        mcb_(mcb) {}\n\n  ~WriteCallbackBase() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  virtual void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n    if (mcb_) {\n      mcb_->setSocket(socket);\n    }\n  }\n\n  void writeSuccess() noexcept override {\n    std::cerr << \"writeSuccess\" << std::endl;\n    state = STATE_SUCCEEDED;\n  }\n\n  void writeErr(\n      size_t nBytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"writeError: bytesWritten \" << nBytesWritten << \", exception \"\n              << ex.what() << std::endl;\n\n    state = STATE_FAILED;\n    this->bytesWritten = nBytesWritten;\n    exception = ex;\n    socket_->close();\n  }\n\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  StateEnum state;\n  size_t bytesWritten;\n  AsyncSocketException exception;\n  SendMsgParamsCallbackBase* mcb_;\n};\n\nclass ExpectWriteErrorCallback : public WriteCallbackBase {\n public:\n  explicit ExpectWriteErrorCallback(SendMsgParamsCallbackBase* mcb = nullptr)\n      : WriteCallbackBase(mcb) {}\n\n  ~ExpectWriteErrorCallback() override {\n    EXPECT_EQ(STATE_FAILED, state);\n    EXPECT_EQ(\n        exception.getType(),\n        AsyncSocketException::AsyncSocketExceptionType::NETWORK_ERROR);\n    EXPECT_EQ(exception.getErrno(), 22);\n    // Suppress the assert in  ~WriteCallbackBase()\n    state = STATE_SUCCEEDED;\n  }\n};\n\n#ifdef FOLLY_HAVE_MSG_ERRQUEUE\n/* copied from include/uapi/linux/net_tstamp.h */\n/* SO_TIMESTAMPING gets an integer bit field comprised of these values */\nenum SOF_TIMESTAMPING {\n  SOF_TIMESTAMPING_TX_SOFTWARE = (1 << 1),\n  SOF_TIMESTAMPING_SOFTWARE = (1 << 4),\n  SOF_TIMESTAMPING_OPT_ID = (1 << 7),\n  SOF_TIMESTAMPING_TX_SCHED = (1 << 8),\n  SOF_TIMESTAMPING_TX_ACK = (1 << 9),\n  SOF_TIMESTAMPING_OPT_TSONLY = (1 << 11),\n};\n\nclass WriteCheckTimestampCallback : public WriteCallbackBase {\n public:\n  explicit WriteCheckTimestampCallback(SendMsgParamsCallbackBase* mcb = nullptr)\n      : WriteCallbackBase(mcb) {}\n\n  ~WriteCheckTimestampCallback() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) override {\n    WriteCallbackBase::setSocket(socket);\n\n    EXPECT_NE(socket_->getNetworkSocket(), NetworkSocket());\n    int flags = SOF_TIMESTAMPING_OPT_ID | SOF_TIMESTAMPING_OPT_TSONLY |\n        SOF_TIMESTAMPING_SOFTWARE;\n    AsyncSocket::OptionKey tstampingOpt = {SOL_SOCKET, SO_TIMESTAMPING};\n    int ret = tstampingOpt.apply(socket_->getNetworkSocket(), flags);\n    EXPECT_EQ(ret, 0);\n  }\n\n  std::vector<int32_t> getTimestampNotifications() noexcept {\n    auto fd = socket_->getNetworkSocket();\n    std::vector<char> ctrl(1024, 0);\n    unsigned char data;\n    struct msghdr msg;\n    iovec entry;\n\n    memset(&msg, 0, sizeof(msg));\n    entry.iov_base = &data;\n    entry.iov_len = sizeof(data);\n    msg.msg_iov = &entry;\n    msg.msg_iovlen = 1;\n    msg.msg_control = ctrl.data();\n    msg.msg_controllen = ctrl.size();\n\n    std::vector<int32_t> timestampsFound;\n\n    folly::Optional<int32_t> timestampType;\n    bool gotTimestamp = false;\n    bool gotByteSeq = false;\n    int ret;\n    while (true) {\n      ret = netops::recvmsg(fd, &msg, MSG_ERRQUEUE);\n      if (ret < 0) {\n        if (errno != EAGAIN) {\n          auto errnoCopy = errno;\n          std::cerr << \"::recvmsg exited with code \" << ret\n                    << \", errno: \" << errnoCopy << std::endl;\n          AsyncSocketException ex(\n              AsyncSocketException::INTERNAL_ERROR,\n              \"recvmsg() failed\",\n              errnoCopy);\n          exception = ex;\n        }\n        return timestampsFound;\n      }\n\n      for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);\n           cmsg != nullptr && cmsg->cmsg_len != 0;\n           cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        if (cmsg->cmsg_level == SOL_SOCKET &&\n            cmsg->cmsg_type == SCM_TIMESTAMPING) {\n          CHECK(!gotTimestamp); // shouldn't already be set\n          gotTimestamp = true;\n        }\n\n        if ((cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_RECVERR) ||\n            (cmsg->cmsg_level == SOL_IPV6 && cmsg->cmsg_type == IPV6_RECVERR)) {\n          const struct cmsghdr& cmsgh = *cmsg;\n          const auto serr = reinterpret_cast<const struct sock_extended_err*>(\n              CMSG_DATA(&cmsgh));\n          if (serr->ee_errno != ENOMSG ||\n              serr->ee_origin != SO_EE_ORIGIN_TIMESTAMPING) {\n            // not a timestamp\n            continue;\n          }\n\n          CHECK(!timestampType); // shouldn't already be set\n          CHECK(!gotByteSeq); // shouldn't already be set\n          gotByteSeq = true;\n          timestampType = serr->ee_info;\n        }\n\n        // check if we have both a timestamp and byte sequence\n        if (gotTimestamp && gotByteSeq) {\n          timestampsFound.push_back(*timestampType);\n          timestampType = folly::none;\n          gotTimestamp = false;\n          gotByteSeq = false;\n        }\n      } // for(...)\n    } // while(true)\n\n    return timestampsFound;\n  }\n};\n#endif // FOLLY_HAVE_MSG_ERRQUEUE\n\nclass ReadCallbackBase : public AsyncTransportWrapper::ReadCallback {\n public:\n  explicit ReadCallbackBase(WriteCallbackBase* wcb)\n      : wcb_(wcb), state(STATE_WAITING) {}\n\n  ~ReadCallbackBase() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n  }\n\n  void setState(StateEnum s) {\n    state = s;\n    if (wcb_) {\n      wcb_->state = s;\n    }\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"readError \" << ex.what() << std::endl;\n    state = STATE_FAILED;\n    socket_->close();\n  }\n\n  void readEOF() noexcept override {\n    std::cerr << \"readEOF\" << std::endl;\n\n    socket_->close();\n  }\n\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  WriteCallbackBase* wcb_;\n  StateEnum state;\n};\n\n/**\n * ReadCallback reads data from the socket and then writes it back.\n *\n * It includes any folly::WriteFlags set via setWriteFlags(...) in its write\n * back operation.\n */\nclass ReadCallback : public ReadCallbackBase {\n public:\n  explicit ReadCallback(WriteCallbackBase* wcb)\n      : ReadCallbackBase(wcb), buffers(), writeFlags(folly::WriteFlags::NONE) {}\n\n  ~ReadCallback() override {\n    for (std::vector<Buffer>::iterator it = buffers.begin();\n         it != buffers.end();\n         ++it) {\n      it->free();\n    }\n    currentBuffer.free();\n  }\n\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    if (!currentBuffer.buffer) {\n      currentBuffer.allocate(4096);\n    }\n    *bufReturn = currentBuffer.buffer;\n    *lenReturn = currentBuffer.length;\n  }\n\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    if (wcb_) {\n      wcb_->setSocket(socket_);\n    }\n\n    // Write back the same data.\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }\n\n  /**\n   * These flags will be used when writing the read data back to the socket.\n   */\n  void setWriteFlags(folly::WriteFlags flags) {\n    writeFlags = flags;\n  }\n\n  class Buffer {\n   public:\n    Buffer() : buffer(nullptr), length(0) {}\n    Buffer(char* buf, size_t len) : buffer(buf), length(len) {}\n\n    void reset() {\n      buffer = nullptr;\n      length = 0;\n    }\n    void allocate(size_t len) {\n      assert(buffer == nullptr);\n      this->buffer = static_cast<char*>(malloc(len));\n      this->length = len;\n    }\n    void free() {\n      ::free(buffer);\n      reset();\n    }\n\n    char* buffer;\n    size_t length;\n  };\n\n  std::vector<Buffer> buffers;\n  Buffer currentBuffer;\n  folly::WriteFlags writeFlags;\n};\n\nclass ReadErrorCallback : public ReadCallbackBase {\n public:\n  explicit ReadErrorCallback(WriteCallbackBase* wcb) : ReadCallbackBase(wcb) {}\n\n  // Return nullptr buffer to trigger readError()\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = nullptr;\n    *lenReturn = 0;\n  }\n\n  void readDataAvailable(size_t /* len */) noexcept override {\n    // This should never to called.\n    FAIL();\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ReadCallbackBase::readErr(ex);\n    std::cerr << \"ReadErrorCallback::readError\" << std::endl;\n    setState(STATE_SUCCEEDED);\n  }\n};\n\nclass ReadEOFCallback : public ReadCallbackBase {\n public:\n  explicit ReadEOFCallback(WriteCallbackBase* wcb) : ReadCallbackBase(wcb) {}\n\n  // Return nullptr buffer to trigger readError()\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = nullptr;\n    *lenReturn = 0;\n  }\n\n  void readDataAvailable(size_t /* len */) noexcept override {\n    // This should never to called.\n    FAIL();\n  }\n\n  void readEOF() noexcept override {\n    ReadCallbackBase::readEOF();\n    setState(STATE_SUCCEEDED);\n  }\n};\n\nclass WriteErrorCallback : public ReadCallback {\n public:\n  explicit WriteErrorCallback(WriteCallbackBase* wcb) : ReadCallback(wcb) {}\n\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    // close the socket before writing to trigger writeError().\n    netops::close(socket_->getNetworkSocket());\n\n    wcb_->setSocket(socket_);\n\n    // Write back the same data.\n    folly::test::msvcSuppressAbortOnInvalidParams(\n        [&] { socket_->write(wcb_, currentBuffer.buffer, len); });\n\n    if (wcb_->state == STATE_FAILED) {\n      setState(STATE_SUCCEEDED);\n    } else {\n      state = STATE_FAILED;\n    }\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"readError \" << ex.what() << std::endl;\n    // do nothing since this is expected\n  }\n};\n\nclass EmptyReadCallback : public ReadCallback {\n public:\n  explicit EmptyReadCallback() : ReadCallback(nullptr) {}\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"readError \" << ex.what() << std::endl;\n    state = STATE_FAILED;\n    if (tcpSocket_) {\n      tcpSocket_->close();\n    }\n  }\n\n  void readEOF() noexcept override {\n    std::cerr << \"readEOF\" << std::endl;\n    if (tcpSocket_) {\n      tcpSocket_->close();\n    }\n    state = STATE_SUCCEEDED;\n  }\n\n  std::shared_ptr<AsyncSocket> tcpSocket_;\n};\n\nclass HandshakeCallback : public AsyncSSLSocket::HandshakeCB {\n public:\n  enum ExpectType { EXPECT_SUCCESS, EXPECT_ERROR };\n\n  explicit HandshakeCallback(\n      ReadCallbackBase* rcb,\n      ExpectType expect = EXPECT_SUCCESS)\n      : state(STATE_WAITING), rcb_(rcb), expect_(expect) {}\n\n  void setSocket(const std::shared_ptr<AsyncSSLSocket>& socket) {\n    socket_ = socket;\n  }\n\n  void setState(StateEnum s) {\n    state = s;\n    rcb_->setState(s);\n  }\n\n  // Functions inherited from AsyncSSLSocketHandshakeCallback\n  void handshakeSuc(AsyncSSLSocket* sock) noexcept override {\n    std::lock_guard<std::mutex> g(mutex_);\n    cv_.notify_all();\n    EXPECT_EQ(sock, socket_.get());\n    std::cerr << \"HandshakeCallback::connectionAccepted\" << std::endl;\n    rcb_->setSocket(socket_);\n    sock->setReadCB(rcb_);\n    state = (expect_ == EXPECT_SUCCESS) ? STATE_SUCCEEDED : STATE_FAILED;\n  }\n  void handshakeErr(\n      AsyncSSLSocket* /* sock */,\n      const AsyncSocketException& ex) noexcept override {\n    std::lock_guard<std::mutex> g(mutex_);\n    cv_.notify_all();\n    std::cerr << \"HandshakeCallback::handshakeError \" << ex.what() << std::endl;\n    state = (expect_ == EXPECT_ERROR) ? STATE_SUCCEEDED : STATE_FAILED;\n    if (expect_ == EXPECT_ERROR) {\n      // rcb will never be invoked\n      rcb_->setState(STATE_SUCCEEDED);\n    }\n    errorString_ = ex.what();\n  }\n\n  void waitForHandshake() {\n    std::unique_lock<std::mutex> lock(mutex_);\n    cv_.wait(lock, [this] { return state != STATE_WAITING; });\n  }\n\n  ~HandshakeCallback() override {\n    EXPECT_EQ(STATE_SUCCEEDED, state);\n  }\n\n  void closeSocket() {\n    socket_->close();\n    state = STATE_SUCCEEDED;\n  }\n\n  std::shared_ptr<AsyncSSLSocket> getSocket() {\n    return socket_;\n  }\n\n  StateEnum state;\n  std::shared_ptr<AsyncSSLSocket> socket_;\n  ReadCallbackBase* rcb_;\n  ExpectType expect_;\n  std::mutex mutex_;\n  std::condition_variable cv_;\n  std::string errorString_;\n};\n\nclass SSLServerAcceptCallback : public SSLServerAcceptCallbackBase {\n public:\n  uint32_t timeout_;\n\n  explicit SSLServerAcceptCallback(HandshakeCallback* hcb, uint32_t timeout = 0)\n      : SSLServerAcceptCallbackBase(hcb), timeout_(timeout) {}\n\n  ~SSLServerAcceptCallback() override {\n    if (timeout_ > 0) {\n      // if we set a timeout, we expect failure\n      EXPECT_EQ(hcb_->state, STATE_FAILED);\n      hcb_->setState(STATE_SUCCEEDED);\n    }\n  }\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n    std::cerr << \"SSLServerAcceptCallback::connAccepted\" << std::endl;\n\n    hcb_->setSocket(sock);\n    sock->sslAccept(hcb_, std::chrono::milliseconds(timeout_));\n    EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ACCEPTING);\n\n    state = STATE_SUCCEEDED;\n  }\n};\n\nclass SSLServerAcceptCallbackDelay : public SSLServerAcceptCallback {\n public:\n  explicit SSLServerAcceptCallbackDelay(HandshakeCallback* hcb)\n      : SSLServerAcceptCallback(hcb) {}\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n\n    std::cerr << \"SSLServerAcceptCallbackDelay::connAccepted\" << std::endl;\n    auto fd = sock->getNetworkSocket();\n\n#ifndef TCP_NOPUSH\n    {\n      // The accepted connection should already have TCP_NODELAY set\n      int value;\n      socklen_t valueLength = sizeof(value);\n      int rc = netops::getsockopt(\n          fd, IPPROTO_TCP, TCP_NODELAY, &value, &valueLength);\n      EXPECT_EQ(rc, 0);\n      EXPECT_EQ(value, 1);\n    }\n#endif\n\n    // Unset the TCP_NODELAY option.\n    int value = 0;\n    socklen_t valueLength = sizeof(value);\n    int rc =\n        netops::setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &value, valueLength);\n    EXPECT_EQ(rc, 0);\n\n    rc = netops::getsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &value, &valueLength);\n    EXPECT_EQ(rc, 0);\n    EXPECT_EQ(value, 0);\n\n    SSLServerAcceptCallback::connAccepted(sock);\n  }\n};\n\nclass HandshakeErrorCallback : public SSLServerAcceptCallbackBase {\n public:\n  explicit HandshakeErrorCallback(HandshakeCallback* hcb)\n      : SSLServerAcceptCallbackBase(hcb) {}\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n\n    std::cerr << \"HandshakeErrorCallback::connAccepted\" << std::endl;\n\n    // The first call to sslAccept() should succeed.\n    hcb_->setSocket(sock);\n    sock->sslAccept(hcb_);\n    EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ACCEPTING);\n\n    // The second call to sslAccept() should fail.\n    HandshakeCallback callback2(hcb_->rcb_);\n    callback2.setSocket(sock);\n    sock->sslAccept(&callback2);\n    EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ERROR);\n\n    // Both callbacks should be in the error state.\n    EXPECT_EQ(hcb_->state, STATE_FAILED);\n    EXPECT_EQ(callback2.state, STATE_FAILED);\n\n    state = STATE_SUCCEEDED;\n    hcb_->setState(STATE_SUCCEEDED);\n    callback2.setState(STATE_SUCCEEDED);\n  }\n};\n\nclass HandshakeTimeoutCallback : public SSLServerAcceptCallbackBase {\n public:\n  explicit HandshakeTimeoutCallback(HandshakeCallback* hcb)\n      : SSLServerAcceptCallbackBase(hcb) {}\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    std::cerr << \"HandshakeErrorCallback::connAccepted\" << std::endl;\n\n    auto sock = std::static_pointer_cast<AsyncSSLSocket>(s);\n\n    hcb_->setSocket(sock);\n    sock->getEventBase()->tryRunAfterDelay(\n        [=] {\n          std::cerr << \"Delayed SSL accept, client will have close by now\"\n                    << std::endl;\n          // SSL accept will fail\n          EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_UNINIT);\n          hcb_->socket_->sslAccept(hcb_);\n          // This registers for an event\n          EXPECT_EQ(sock->getSSLState(), AsyncSSLSocket::STATE_ACCEPTING);\n\n          state = STATE_SUCCEEDED;\n        },\n        100);\n  }\n};\n\nclass ConnectTimeoutCallback : public SSLServerAcceptCallbackBase {\n public:\n  ConnectTimeoutCallback() : SSLServerAcceptCallbackBase(nullptr) {\n    // We don't care if we get invoked or not.\n    // The client may time out and give up before connAccepted() is even\n    // called.\n    state = STATE_SUCCEEDED;\n  }\n\n  void connAccepted(\n      const std::shared_ptr<folly::AsyncSSLSocket>& s) noexcept override {\n    std::cerr << \"ConnectTimeoutCallback::connAccepted\" << std::endl;\n\n    // Just wait a while before closing the socket, so the client\n    // will time out waiting for the handshake to complete.\n    s->getEventBase()->tryRunAfterDelay([=] { s->close(); }, 100);\n  }\n};\n\nvoid getfds(NetworkSocket fds[2]);\n\nvoid getctx(\n    std::shared_ptr<folly::SSLContext> clientCtx,\n    std::shared_ptr<folly::SSLContext> serverCtx);\n\nvoid sslsocketpair(\n    EventBase* eventBase,\n    AsyncSSLSocket::UniquePtr* clientSock,\n    AsyncSSLSocket::UniquePtr* serverSock);\n\nclass BlockingWriteClient : private AsyncSSLSocket::HandshakeCB,\n                            private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit BlockingWriteClient(AsyncSSLSocket::UniquePtr socket)\n      : socket_(std::move(socket)), bufLen_(2500), iovCount_(2000) {\n    // Fill buf_\n    buf_ = std::make_unique<uint8_t[]>(bufLen_);\n    for (uint32_t n = 0; n < sizeof(buf_); ++n) {\n      buf_[n] = n % 0xff;\n    }\n\n    // Initialize iov_\n    iov_ = std::make_unique<struct iovec[]>(iovCount_);\n    for (uint32_t n = 0; n < iovCount_; ++n) {\n      iov_[n].iov_base = buf_.get() + n;\n      if (n & 0x1) {\n        iov_[n].iov_len = n % bufLen_;\n      } else {\n        iov_[n].iov_len = bufLen_ - (n % bufLen_);\n      }\n    }\n\n    socket_->sslConn(this, std::chrono::milliseconds(100));\n  }\n\n  struct iovec* getIovec() const {\n    return iov_.get();\n  }\n  uint32_t getIovecCount() const {\n    return iovCount_;\n  }\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    socket_->writev(this, iov_.get(), iovCount_);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client handshake error: \" << ex.what();\n  }\n  void writeSuccess() noexcept override {\n    socket_->close();\n  }\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  uint32_t bufLen_;\n  uint32_t iovCount_;\n  std::unique_ptr<uint8_t[]> buf_;\n  std::unique_ptr<struct iovec[]> iov_;\n};\n\nclass BlockingWriteServer : private AsyncSSLSocket::HandshakeCB,\n                            private AsyncTransportWrapper::ReadCallback {\n public:\n  explicit BlockingWriteServer(AsyncSSLSocket::UniquePtr socket)\n      : socket_(std::move(socket)), bufSize_(2500 * 2000), bytesRead_(0) {\n    buf_ = std::make_unique<uint8_t[]>(bufSize_);\n    socket_->sslAccept(this, std::chrono::milliseconds(100));\n  }\n\n  void checkBuffer(struct iovec* iov, uint32_t count) const {\n    uint32_t idx = 0;\n    for (uint32_t n = 0; n < count; ++n) {\n      size_t bytesLeft = bytesRead_ - idx;\n      int rc = memcmp(\n          buf_.get() + idx,\n          iov[n].iov_base,\n          std::min(iov[n].iov_len, bytesLeft));\n      if (rc != 0) {\n        FAIL() << \"buffer mismatch at iovec \" << n << \"/\" << count\n               << \": rc=\" << rc;\n      }\n      if (iov[n].iov_len > bytesLeft) {\n        FAIL() << \"server did not read enough data: \"\n               << \"ended at byte \" << bytesLeft << \"/\" << iov[n].iov_len\n               << \" in iovec \" << n << \"/\" << count;\n      }\n\n      idx += iov[n].iov_len;\n    }\n    if (idx != bytesRead_) {\n      ADD_FAILURE() << \"server read extra data: \" << bytesRead_\n                    << \" bytes read; expected \" << idx;\n    }\n  }\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    // Wait 10ms before reading, so the client's writes will initially block.\n    socket_->getEventBase()->tryRunAfterDelay(\n        [this] { socket_->setReadCB(this); }, 10);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server handshake error: \" << ex.what();\n  }\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.get() + bytesRead_;\n    *lenReturn = bufSize_ - bytesRead_;\n  }\n  void readDataAvailable(size_t len) noexcept override {\n    bytesRead_ += len;\n    socket_->setReadCB(nullptr);\n    socket_->getEventBase()->tryRunAfterDelay(\n        [this] { socket_->setReadCB(this); }, 2);\n  }\n  void readEOF() noexcept override {\n    socket_->close();\n  }\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server read error: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  uint32_t bufSize_;\n  uint32_t bytesRead_;\n  std::unique_ptr<uint8_t[]> buf_;\n};\n\nclass AlpnClient : private AsyncSSLSocket::HandshakeCB,\n                   private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit AlpnClient(AsyncSSLSocket::UniquePtr socket)\n      : nextProto(nullptr), nextProtoLength(0), socket_(std::move(socket)) {\n    socket_->sslConn(this);\n  }\n\n  const unsigned char* nextProto;\n  unsigned nextProtoLength;\n  folly::Optional<AsyncSocketException> except;\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    socket_->getSelectedNextProtocol(&nextProto, &nextProtoLength);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    except = ex;\n  }\n  void writeSuccess() noexcept override {\n    socket_->close();\n  }\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n};\n\nclass AlpnServer : private AsyncSSLSocket::HandshakeCB,\n                   private AsyncTransportWrapper::ReadCallback {\n public:\n  explicit AlpnServer(AsyncSSLSocket::UniquePtr socket)\n      : nextProto(nullptr), nextProtoLength(0), socket_(std::move(socket)) {\n    socket_->sslAccept(this);\n  }\n\n  const unsigned char* nextProto;\n  unsigned nextProtoLength;\n  folly::Optional<AsyncSocketException> except;\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    socket_->getSelectedNextProtocol(&nextProto, &nextProtoLength);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    except = ex;\n  }\n  void getReadBuffer(void** /* bufReturn */, size_t* lenReturn) override {\n    *lenReturn = 0;\n  }\n  void readDataAvailable(size_t /* len */) noexcept override {}\n  void readEOF() noexcept override {\n    socket_->close();\n  }\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server read error: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n};\n\nclass RenegotiatingServer : public AsyncSSLSocket::HandshakeCB,\n                            public AsyncTransportWrapper::ReadCallback {\n public:\n  explicit RenegotiatingServer(AsyncSSLSocket::UniquePtr socket)\n      : socket_(std::move(socket)) {\n    socket_->sslAccept(this);\n  }\n\n  ~RenegotiatingServer() override {\n    socket_->setReadCB(nullptr);\n  }\n\n  void handshakeSuc(AsyncSSLSocket* /* socket */) noexcept override {\n    LOG(INFO) << \"Renegotiating server handshake success\";\n    socket_->setReadCB(this);\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"Renegotiating server handshake error: \" << ex.what();\n  }\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *lenReturn = sizeof(buf);\n    *bufReturn = buf;\n  }\n  void readDataAvailable(size_t /* len */) noexcept override {}\n  void readEOF() noexcept override {}\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    LOG(INFO) << \"server got read error \" << ex.what();\n    auto exPtr = dynamic_cast<const SSLException*>(&ex);\n    ASSERT_NE(nullptr, exPtr);\n    std::string exStr(ex.what());\n    SSLException sslEx(SSLError::CLIENT_RENEGOTIATION);\n    ASSERT_NE(std::string::npos, exStr.find(sslEx.what()));\n    renegotiationError_ = true;\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  unsigned char buf[128];\n  bool renegotiationError_{false};\n};\n\n#ifndef OPENSSL_NO_TLSEXT\nclass SNIClient : private AsyncSSLSocket::HandshakeCB,\n                  private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit SNIClient(AsyncSSLSocket::UniquePtr socket)\n      : serverNameMatch(false), socket_(std::move(socket)) {\n    socket_->sslConn(this);\n  }\n\n  bool serverNameMatch;\n\n private:\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    serverNameMatch = socket_->isServerNameMatch();\n  }\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client handshake error: \" << ex.what();\n  }\n  void writeSuccess() noexcept override {\n    socket_->close();\n  }\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n};\n\nclass SNIServer : private AsyncSSLSocket::HandshakeCB,\n                  private AsyncTransportWrapper::ReadCallback {\n public:\n  explicit SNIServer(\n      AsyncSSLSocket::UniquePtr socket,\n      const std::shared_ptr<folly::SSLContext>& ctx,\n      const std::shared_ptr<folly::SSLContext>& sniCtx,\n      const std::string& expectedServerName)\n      : serverNameMatch(false),\n        socket_(std::move(socket)),\n        sniCtx_(sniCtx),\n        expectedServerName_(expectedServerName) {\n    ctx->setServerNameCallback(\n        std::bind(&SNIServer::serverNameCallback, this, std::placeholders::_1));\n    socket_->sslAccept(this);\n  }\n\n  bool serverNameMatch;\n\n private:\n  void handshakeSuc(AsyncSSLSocket* /* ssl */) noexcept override {}\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server handshake error: \" << ex.what();\n  }\n  void getReadBuffer(void** /* bufReturn */, size_t* lenReturn) override {\n    *lenReturn = 0;\n  }\n  void readDataAvailable(size_t /* len */) noexcept override {}\n  void readEOF() noexcept override {\n    socket_->close();\n  }\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"server read error: \" << ex.what();\n  }\n\n  folly::SSLContext::ServerNameCallbackResult serverNameCallback(SSL* ssl) {\n    const char* sn = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);\n    if (sniCtx_ && sn && !strcasecmp(expectedServerName_.c_str(), sn)) {\n      AsyncSSLSocket* sslSocket = AsyncSSLSocket::getFromSSL(ssl);\n      sslSocket->switchServerSSLContext(sniCtx_);\n      serverNameMatch = true;\n      return folly::SSLContext::SERVER_NAME_FOUND;\n    } else {\n      serverNameMatch = false;\n      return folly::SSLContext::SERVER_NAME_NOT_FOUND;\n    }\n  }\n\n  AsyncSSLSocket::UniquePtr socket_;\n  std::shared_ptr<folly::SSLContext> sniCtx_;\n  std::string expectedServerName_;\n};\n#endif\n\nclass SSLClient : public AsyncSocket::ConnectCallback,\n                  public AsyncTransportWrapper::WriteCallback,\n                  public AsyncTransportWrapper::ReadCallback {\n private:\n  EventBase* eventBase_;\n  std::shared_ptr<AsyncSSLSocket> sslSocket_;\n  SSL_SESSION* session_;\n  std::shared_ptr<folly::SSLContext> ctx_;\n  uint32_t requests_;\n  folly::SocketAddress address_;\n  uint32_t timeout_;\n  char buf_[128];\n  char readbuf_[128];\n  uint32_t bytesRead_;\n  uint32_t hit_;\n  uint32_t miss_;\n  uint32_t errors_;\n  uint32_t writeAfterConnectErrors_;\n\n  // These settings test that we eventually drain the\n  // socket, even if the maxReadsPerEvent_ is hit during\n  // a event loop iteration.\n  static constexpr size_t kMaxReadsPerEvent = 2;\n  // 2 event loop iterations\n  static constexpr size_t kMaxReadBufferSz =\n      sizeof(decltype(readbuf_)) / kMaxReadsPerEvent / 2;\n\n public:\n  SSLClient(\n      EventBase* eventBase,\n      const folly::SocketAddress& address,\n      uint32_t requests,\n      uint32_t timeout = 0)\n      : eventBase_(eventBase),\n        session_(nullptr),\n        requests_(requests),\n        address_(address),\n        timeout_(timeout),\n        bytesRead_(0),\n        hit_(0),\n        miss_(0),\n        errors_(0),\n        writeAfterConnectErrors_(0) {\n    ctx_.reset(new folly::SSLContext());\n    ctx_->setOptions(SSL_OP_NO_TICKET);\n    ctx_->ciphers(\"ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH\");\n    memset(buf_, 'a', sizeof(buf_));\n  }\n\n  ~SSLClient() override {\n    if (session_) {\n      SSL_SESSION_free(session_);\n    }\n    if (errors_ == 0) {\n      EXPECT_EQ(bytesRead_, sizeof(buf_));\n    }\n  }\n\n  uint32_t getHit() const {\n    return hit_;\n  }\n\n  uint32_t getMiss() const {\n    return miss_;\n  }\n\n  uint32_t getErrors() const {\n    return errors_;\n  }\n\n  uint32_t getWriteAfterConnectErrors() const {\n    return writeAfterConnectErrors_;\n  }\n\n  void connect(bool writeNow = false) {\n    sslSocket_ = AsyncSSLSocket::newSocket(ctx_, eventBase_);\n    if (session_ != nullptr) {\n      sslSocket_->setSSLSession(session_);\n    }\n    requests_--;\n    sslSocket_->connect(this, address_, timeout_);\n    if (sslSocket_ && writeNow) {\n      // write some junk, used in an error test\n      sslSocket_->write(this, buf_, sizeof(buf_));\n    }\n  }\n\n  void connectSuccess() noexcept override {\n    std::cerr << \"client SSL socket connected\" << std::endl;\n    if (sslSocket_->getSSLSessionReused()) {\n      hit_++;\n    } else {\n      miss_++;\n      if (session_ != nullptr) {\n        SSL_SESSION_free(session_);\n      }\n      session_ = sslSocket_->getSSLSession();\n    }\n\n    // write()\n    sslSocket_->setMaxReadsPerEvent(kMaxReadsPerEvent);\n    sslSocket_->write(this, buf_, sizeof(buf_));\n    sslSocket_->setReadCB(this);\n    memset(readbuf_, 'b', sizeof(readbuf_));\n    bytesRead_ = 0;\n  }\n\n  void connectErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"SSLClient::connectError: \" << ex.what() << std::endl;\n    errors_++;\n    sslSocket_.reset();\n  }\n\n  void writeSuccess() noexcept override {\n    std::cerr << \"client write success\" << std::endl;\n  }\n\n  void writeErr(\n      size_t /* bytesWritten */,\n      const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"client writeError: \" << ex.what() << std::endl;\n    if (!sslSocket_) {\n      writeAfterConnectErrors_++;\n    }\n  }\n\n  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = readbuf_ + bytesRead_;\n    *lenReturn = std::min(kMaxReadBufferSz, sizeof(readbuf_) - bytesRead_);\n  }\n\n  void readEOF() noexcept override {\n    std::cerr << \"client readEOF\" << std::endl;\n  }\n\n  void readErr(const AsyncSocketException& ex) noexcept override {\n    std::cerr << \"client readError: \" << ex.what() << std::endl;\n  }\n\n  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"client read data: \" << len << std::endl;\n    bytesRead_ += len;\n    if (bytesRead_ == sizeof(buf_)) {\n      EXPECT_EQ(memcmp(buf_, readbuf_, bytesRead_), 0);\n      sslSocket_->closeNow();\n      sslSocket_.reset();\n      if (requests_ != 0) {\n        connect();\n      }\n    }\n  }\n};\n\nclass SSLHandshakeBase : public AsyncSSLSocket::HandshakeCB,\n                         private AsyncTransportWrapper::WriteCallback {\n public:\n  explicit SSLHandshakeBase(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : handshakeVerify_(false),\n        handshakeSuccess_(false),\n        handshakeError_(false),\n        socket_(std::move(socket)),\n        preverifyResult_(preverifyResult),\n        verifyResult_(verifyResult) {}\n\n  AsyncSSLSocket::UniquePtr moveSocket() && {\n    return std::move(socket_);\n  }\n\n  bool handshakeVerify_;\n  bool handshakeSuccess_;\n  bool handshakeError_;\n  std::chrono::nanoseconds handshakeTime;\n\n protected:\n  AsyncSSLSocket::UniquePtr socket_;\n  bool preverifyResult_;\n  bool verifyResult_;\n\n  // HandshakeCallback\n  bool handshakeVer(\n      AsyncSSLSocket* /* sock */,\n      bool preverifyOk,\n      X509_STORE_CTX* /* ctx */) noexcept override {\n    handshakeVerify_ = true;\n\n    EXPECT_EQ(preverifyResult_, preverifyOk);\n    return verifyResult_;\n  }\n\n  void handshakeSuc(AsyncSSLSocket*) noexcept override {\n    LOG(INFO) << \"Handshake success\";\n    handshakeSuccess_ = true;\n    if (socket_) {\n      handshakeTime = socket_->getHandshakeTime();\n    }\n  }\n\n  void handshakeErr(\n      AsyncSSLSocket*,\n      const AsyncSocketException& ex) noexcept override {\n    LOG(INFO) << \"Handshake error \" << ex.what();\n    handshakeError_ = true;\n    if (socket_) {\n      handshakeTime = socket_->getHandshakeTime();\n    }\n  }\n\n  // WriteCallback\n  void writeSuccess() noexcept override {\n    if (socket_) {\n      socket_->close();\n    }\n  }\n\n  void writeErr(\n      size_t bytesWritten,\n      const AsyncSocketException& ex) noexcept override {\n    ADD_FAILURE() << \"client write error after \" << bytesWritten\n                  << \" bytes: \" << ex.what();\n  }\n};\n\nclass SSLHandshakeClient : public SSLHandshakeBase {\n public:\n  SSLHandshakeClient(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslConn(this, std::chrono::milliseconds::zero());\n  }\n};\n\nclass SSLHandshakeClientNoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeClientNoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslConn(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  }\n};\n\nclass SSLHandshakeClientDoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeClientDoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslConn(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::VERIFY);\n  }\n};\n\nclass SSLHandshakeServer : public SSLHandshakeBase {\n public:\n  SSLHandshakeServer(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslAccept(this, std::chrono::milliseconds::zero());\n  }\n};\n\nclass SSLHandshakeServerParseClientHello : public SSLHandshakeBase {\n public:\n  SSLHandshakeServerParseClientHello(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->enableClientHelloParsing();\n    socket_->sslAccept(this, std::chrono::milliseconds::zero());\n  }\n\n  std::string clientCiphers_, sharedCiphers_, serverCiphers_, chosenCipher_;\n\n protected:\n  void handshakeSuc(AsyncSSLSocket* sock) noexcept override {\n    handshakeSuccess_ = true;\n    sock->getSSLSharedCiphers(sharedCiphers_);\n    sock->getSSLServerCiphers(serverCiphers_);\n    sock->getSSLClientCiphers(clientCiphers_);\n    chosenCipher_ = sock->getNegotiatedCipherName();\n  }\n};\n\nclass SSLHandshakeServerNoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeServerNoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslAccept(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::NO_VERIFY);\n  }\n};\n\nclass SSLHandshakeServerDoVerify : public SSLHandshakeBase {\n public:\n  SSLHandshakeServerDoVerify(\n      AsyncSSLSocket::UniquePtr socket,\n      bool preverifyResult,\n      bool verifyResult)\n      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {\n    socket_->sslAccept(\n        this,\n        std::chrono::milliseconds::zero(),\n        folly::SSLContext::SSLVerifyPeerEnum::VERIFY_REQ_CLIENT_CERT);\n  }\n};\n\nclass EventBaseAborter : public AsyncTimeout {\n public:\n  EventBaseAborter(EventBase* eventBase, uint32_t timeoutMS)\n      : AsyncTimeout(eventBase, AsyncTimeout::InternalEnum::INTERNAL),\n        eventBase_(eventBase) {\n    scheduleTimeout(timeoutMS);\n  }\n\n  void timeoutExpired() noexcept override {\n    FAIL() << \"test timed out\";\n    eventBase_->terminateLoopSoon();\n  }\n\n private:\n  EventBase* eventBase_;\n};\n\nclass SSLAcceptEvbRunner : public SSLAcceptRunner {\n public:\n  explicit SSLAcceptEvbRunner(EventBase* evb) : evb_(evb) {}\n  ~SSLAcceptEvbRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop([acceptFunc = std::move(acceptFunc),\n                     finallyFunc = std::move(finallyFunc)]() mutable {\n      finallyFunc(acceptFunc());\n    });\n  }\n\n protected:\n  EventBase* evb_;\n};\n\nclass SSLAcceptErrorRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptErrorRunner(EventBase* evb) : SSLAcceptEvbRunner(evb) {}\n  ~SSLAcceptErrorRunner() override = default;\n\n  void run(Function<int()> /*acceptFunc*/, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop(\n        [finallyFunc = std::move(finallyFunc)]() mutable { finallyFunc(-1); });\n  }\n};\n\nclass SSLAcceptCloseRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptCloseRunner(EventBase* evb, folly::AsyncSSLSocket* sock)\n      : SSLAcceptEvbRunner(evb), socket_(sock) {}\n  ~SSLAcceptCloseRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop([acceptFunc = std::move(acceptFunc),\n                     finallyFunc = std::move(finallyFunc),\n                     sock = socket_]() mutable {\n      auto ret = acceptFunc();\n      sock->closeNow();\n      finallyFunc(ret);\n    });\n  }\n\n private:\n  folly::AsyncSSLSocket* socket_;\n};\n\nclass SSLAcceptDestroyRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptDestroyRunner(EventBase* evb, SSLHandshakeBase* base)\n      : SSLAcceptEvbRunner(evb), sslBase_(base) {}\n  ~SSLAcceptDestroyRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    evb_->runInLoop([acceptFunc = std::move(acceptFunc),\n                     finallyFunc = std::move(finallyFunc),\n                     sslBase = sslBase_]() mutable {\n      auto ret = acceptFunc();\n      std::move(*sslBase).moveSocket();\n      finallyFunc(ret);\n    });\n  }\n\n private:\n  SSLHandshakeBase* sslBase_;\n};\n\nclass SSLAcceptFiberRunner : public SSLAcceptEvbRunner {\n public:\n  explicit SSLAcceptFiberRunner(EventBase* evb) : SSLAcceptEvbRunner(evb) {}\n  ~SSLAcceptFiberRunner() override = default;\n\n  void run(Function<int()> acceptFunc, Function<void(int)> finallyFunc)\n      const override {\n    auto& fiberManager = folly::fibers::getFiberManager(*evb_);\n    fiberManager.addTaskFinally(\n        std::move(acceptFunc),\n        [finally = std::move(finallyFunc)](folly::Try<int>&& res) mutable {\n          finally(res.value());\n        });\n  }\n};\n} // namespace folly\n"], "filenames": ["folly/io/async/AsyncSSLSocket.cpp", "folly/io/async/test/AsyncSSLSocketTest.cpp", "folly/io/async/test/AsyncSSLSocketTest.h"], "buggy_code_start_loc": [1453, 808, 392], "buggy_code_end_loc": [1596, 808, 393], "fixing_code_start_loc": [1452, 809, 392], "fixing_code_end_loc": [1590, 917, 395], "type": "CWE-125", "message": "Improper handling of close_notify alerts can result in an out-of-bounds read in AsyncSSLSocket. This issue affects folly prior to v2019.11.04.00.", "other": {"cve": {"id": "CVE-2019-11934", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-12-04T17:16:43.180", "lastModified": "2019-12-13T19:28:19.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper handling of close_notify alerts can result in an out-of-bounds read in AsyncSSLSocket. This issue affects folly prior to v2019.11.04.00."}, {"lang": "es", "value": "Un manejo inapropiado de las alertas de close_notify puede resultar en una lectura fuera de l\u00edmites en AsyncSSLSocket. Este problema afecta a folly anterior a la versi\u00f3n v2019.11.04.00."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:folly:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.11.04.00", "matchCriteriaId": "736329E0-780E-46BE-9B50-A71072D1C6DC"}]}]}], "references": [{"url": "https://github.com/facebook/folly/commit/c321eb588909646c15aefde035fd3133ba32cdee", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11934", "source": "cve-assign@fb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/facebook/folly/commit/c321eb588909646c15aefde035fd3133ba32cdee"}}