{"buggy_code": ["#include <math.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"lua.h\"\n#include \"lauxlib.h\"\n\n#define LUACMSGPACK_NAME        \"cmsgpack\"\n#define LUACMSGPACK_SAFE_NAME   \"cmsgpack_safe\"\n#define LUACMSGPACK_VERSION     \"lua-cmsgpack 0.4.0\"\n#define LUACMSGPACK_COPYRIGHT   \"Copyright (C) 2012, Salvatore Sanfilippo\"\n#define LUACMSGPACK_DESCRIPTION \"MessagePack C implementation for Lua\"\n\n/* Allows a preprocessor directive to override MAX_NESTING */\n#ifndef LUACMSGPACK_MAX_NESTING\n    #define LUACMSGPACK_MAX_NESTING  16 /* Max tables nesting. */\n#endif\n\n/* Check if float or double can be an integer without loss of precision */\n#define IS_INT_TYPE_EQUIVALENT(x, T) (!isinf(x) && (T)(x) == (x))\n\n#define IS_INT64_EQUIVALENT(x) IS_INT_TYPE_EQUIVALENT(x, int64_t)\n#define IS_INT_EQUIVALENT(x) IS_INT_TYPE_EQUIVALENT(x, int)\n\n/* If size of pointer is equal to a 4 byte integer, we're on 32 bits. */\n#if UINTPTR_MAX == UINT_MAX\n    #define BITS_32 1\n#else\n    #define BITS_32 0\n#endif\n\n#if BITS_32\n    #define lua_pushunsigned(L, n) lua_pushnumber(L, n)\n#else\n    #define lua_pushunsigned(L, n) lua_pushinteger(L, n)\n#endif\n\n/* =============================================================================\n * MessagePack implementation and bindings for Lua 5.1/5.2.\n * Copyright(C) 2012 Salvatore Sanfilippo <antirez@gmail.com>\n *\n * http://github.com/antirez/lua-cmsgpack\n *\n * For MessagePack specification check the following web site:\n * http://wiki.msgpack.org/display/MSGPACK/Format+specification\n *\n * See Copyright Notice at the end of this file.\n *\n * CHANGELOG:\n * 19-Feb-2012 (ver 0.1.0): Initial release.\n * 20-Feb-2012 (ver 0.2.0): Tables encoding improved.\n * 20-Feb-2012 (ver 0.2.1): Minor bug fixing.\n * 20-Feb-2012 (ver 0.3.0): Module renamed lua-cmsgpack (was lua-msgpack).\n * 04-Apr-2014 (ver 0.3.1): Lua 5.2 support and minor bug fix.\n * 07-Apr-2014 (ver 0.4.0): Multiple pack/unpack, lua allocator, efficiency.\n * ========================================================================== */\n\n/* -------------------------- Endian conversion --------------------------------\n * We use it only for floats and doubles, all the other conversions performed\n * in an endian independent fashion. So the only thing we need is a function\n * that swaps a binary string if arch is little endian (and left it untouched\n * otherwise). */\n\n/* Reverse memory bytes if arch is little endian. Given the conceptual\n * simplicity of the Lua build system we prefer check for endianess at runtime.\n * The performance difference should be acceptable. */\nvoid memrevifle(void *ptr, size_t len) {\n    unsigned char   *p = (unsigned char *)ptr,\n                    *e = (unsigned char *)p+len-1,\n                    aux;\n    int test = 1;\n    unsigned char *testp = (unsigned char*) &test;\n\n    if (testp[0] == 0) return; /* Big endian, nothing to do. */\n    len /= 2;\n    while(len--) {\n        aux = *p;\n        *p = *e;\n        *e = aux;\n        p++;\n        e--;\n    }\n}\n\n/* ---------------------------- String buffer ----------------------------------\n * This is a simple implementation of string buffers. The only operation\n * supported is creating empty buffers and appending bytes to it.\n * The string buffer uses 2x preallocation on every realloc for O(N) append\n * behavior.  */\n\ntypedef struct mp_buf {\n    unsigned char *b;\n    size_t len, free;\n} mp_buf;\n\nvoid *mp_realloc(lua_State *L, void *target, size_t osize,size_t nsize) {\n    void *(*local_realloc) (void *, void *, size_t osize, size_t nsize) = NULL;\n    void *ud;\n\n    local_realloc = lua_getallocf(L, &ud);\n\n    return local_realloc(ud, target, osize, nsize);\n}\n\nmp_buf *mp_buf_new(lua_State *L) {\n    mp_buf *buf = NULL;\n\n    /* Old size = 0; new size = sizeof(*buf) */\n    buf = (mp_buf*)mp_realloc(L, NULL, 0, sizeof(*buf));\n\n    buf->b = NULL;\n    buf->len = buf->free = 0;\n    return buf;\n}\n\nvoid mp_buf_append(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {\n    if (buf->free < len) {\n        size_t newsize = (buf->len+len)*2;\n\n        buf->b = (unsigned char*)mp_realloc(L, buf->b, buf->len + buf->free, newsize);\n        buf->free = newsize - buf->len;\n    }\n    memcpy(buf->b+buf->len,s,len);\n    buf->len += len;\n    buf->free -= len;\n}\n\nvoid mp_buf_free(lua_State *L, mp_buf *buf) {\n    mp_realloc(L, buf->b, buf->len + buf->free, 0); /* realloc to 0 = free */\n    mp_realloc(L, buf, sizeof(*buf), 0);\n}\n\n/* ---------------------------- String cursor ----------------------------------\n * This simple data structure is used for parsing. Basically you create a cursor\n * using a string pointer and a length, then it is possible to access the\n * current string position with cursor->p, check the remaining length\n * in cursor->left, and finally consume more string using\n * mp_cur_consume(cursor,len), to advance 'p' and subtract 'left'.\n * An additional field cursor->error is set to zero on initialization and can\n * be used to report errors. */\n\n#define MP_CUR_ERROR_NONE   0\n#define MP_CUR_ERROR_EOF    1   /* Not enough data to complete operation. */\n#define MP_CUR_ERROR_BADFMT 2   /* Bad data format */\n\ntypedef struct mp_cur {\n    const unsigned char *p;\n    size_t left;\n    int err;\n} mp_cur;\n\nvoid mp_cur_init(mp_cur *cursor, const unsigned char *s, size_t len) {\n    cursor->p = s;\n    cursor->left = len;\n    cursor->err = MP_CUR_ERROR_NONE;\n}\n\n#define mp_cur_consume(_c,_len) do { _c->p += _len; _c->left -= _len; } while(0)\n\n/* When there is not enough room we set an error in the cursor and return. This\n * is very common across the code so we have a macro to make the code look\n * a bit simpler. */\n#define mp_cur_need(_c,_len) do { \\\n    if (_c->left < _len) { \\\n        _c->err = MP_CUR_ERROR_EOF; \\\n        return; \\\n    } \\\n} while(0)\n\n/* ------------------------- Low level MP encoding -------------------------- */\n\nvoid mp_encode_bytes(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {\n    unsigned char hdr[5];\n    int hdrlen;\n\n    if (len < 32) {\n        hdr[0] = 0xa0 | (len&0xff); /* fix raw */\n        hdrlen = 1;\n    } else if (len <= 0xff) {\n        hdr[0] = 0xd9;\n        hdr[1] = len;\n        hdrlen = 2;\n    } else if (len <= 0xffff) {\n        hdr[0] = 0xda;\n        hdr[1] = (len&0xff00)>>8;\n        hdr[2] = len&0xff;\n        hdrlen = 3;\n    } else {\n        hdr[0] = 0xdb;\n        hdr[1] = (len&0xff000000)>>24;\n        hdr[2] = (len&0xff0000)>>16;\n        hdr[3] = (len&0xff00)>>8;\n        hdr[4] = len&0xff;\n        hdrlen = 5;\n    }\n    mp_buf_append(L,buf,hdr,hdrlen);\n    mp_buf_append(L,buf,s,len);\n}\n\n/* we assume IEEE 754 internal format for single and double precision floats. */\nvoid mp_encode_double(lua_State *L, mp_buf *buf, double d) {\n    unsigned char b[9];\n    float f = d;\n\n    assert(sizeof(f) == 4 && sizeof(d) == 8);\n    if (d == (double)f) {\n        b[0] = 0xca;    /* float IEEE 754 */\n        memcpy(b+1,&f,4);\n        memrevifle(b+1,4);\n        mp_buf_append(L,buf,b,5);\n    } else if (sizeof(d) == 8) {\n        b[0] = 0xcb;    /* double IEEE 754 */\n        memcpy(b+1,&d,8);\n        memrevifle(b+1,8);\n        mp_buf_append(L,buf,b,9);\n    }\n}\n\nvoid mp_encode_int(lua_State *L, mp_buf *buf, int64_t n) {\n    unsigned char b[9];\n    int enclen;\n\n    if (n >= 0) {\n        if (n <= 127) {\n            b[0] = n & 0x7f;    /* positive fixnum */\n            enclen = 1;\n        } else if (n <= 0xff) {\n            b[0] = 0xcc;        /* uint 8 */\n            b[1] = n & 0xff;\n            enclen = 2;\n        } else if (n <= 0xffff) {\n            b[0] = 0xcd;        /* uint 16 */\n            b[1] = (n & 0xff00) >> 8;\n            b[2] = n & 0xff;\n            enclen = 3;\n        } else if (n <= 0xffffffffLL) {\n            b[0] = 0xce;        /* uint 32 */\n            b[1] = (n & 0xff000000) >> 24;\n            b[2] = (n & 0xff0000) >> 16;\n            b[3] = (n & 0xff00) >> 8;\n            b[4] = n & 0xff;\n            enclen = 5;\n        } else {\n            b[0] = 0xcf;        /* uint 64 */\n            b[1] = (n & 0xff00000000000000LL) >> 56;\n            b[2] = (n & 0xff000000000000LL) >> 48;\n            b[3] = (n & 0xff0000000000LL) >> 40;\n            b[4] = (n & 0xff00000000LL) >> 32;\n            b[5] = (n & 0xff000000) >> 24;\n            b[6] = (n & 0xff0000) >> 16;\n            b[7] = (n & 0xff00) >> 8;\n            b[8] = n & 0xff;\n            enclen = 9;\n        }\n    } else {\n        if (n >= -32) {\n            b[0] = ((signed char)n);   /* negative fixnum */\n            enclen = 1;\n        } else if (n >= -128) {\n            b[0] = 0xd0;        /* int 8 */\n            b[1] = n & 0xff;\n            enclen = 2;\n        } else if (n >= -32768) {\n            b[0] = 0xd1;        /* int 16 */\n            b[1] = (n & 0xff00) >> 8;\n            b[2] = n & 0xff;\n            enclen = 3;\n        } else if (n >= -2147483648LL) {\n            b[0] = 0xd2;        /* int 32 */\n            b[1] = (n & 0xff000000) >> 24;\n            b[2] = (n & 0xff0000) >> 16;\n            b[3] = (n & 0xff00) >> 8;\n            b[4] = n & 0xff;\n            enclen = 5;\n        } else {\n            b[0] = 0xd3;        /* int 64 */\n            b[1] = (n & 0xff00000000000000LL) >> 56;\n            b[2] = (n & 0xff000000000000LL) >> 48;\n            b[3] = (n & 0xff0000000000LL) >> 40;\n            b[4] = (n & 0xff00000000LL) >> 32;\n            b[5] = (n & 0xff000000) >> 24;\n            b[6] = (n & 0xff0000) >> 16;\n            b[7] = (n & 0xff00) >> 8;\n            b[8] = n & 0xff;\n            enclen = 9;\n        }\n    }\n    mp_buf_append(L,buf,b,enclen);\n}\n\nvoid mp_encode_array(lua_State *L, mp_buf *buf, int64_t n) {\n    unsigned char b[5];\n    int enclen;\n\n    if (n <= 15) {\n        b[0] = 0x90 | (n & 0xf);    /* fix array */\n        enclen = 1;\n    } else if (n <= 65535) {\n        b[0] = 0xdc;                /* array 16 */\n        b[1] = (n & 0xff00) >> 8;\n        b[2] = n & 0xff;\n        enclen = 3;\n    } else {\n        b[0] = 0xdd;                /* array 32 */\n        b[1] = (n & 0xff000000) >> 24;\n        b[2] = (n & 0xff0000) >> 16;\n        b[3] = (n & 0xff00) >> 8;\n        b[4] = n & 0xff;\n        enclen = 5;\n    }\n    mp_buf_append(L,buf,b,enclen);\n}\n\nvoid mp_encode_map(lua_State *L, mp_buf *buf, int64_t n) {\n    unsigned char b[5];\n    int enclen;\n\n    if (n <= 15) {\n        b[0] = 0x80 | (n & 0xf);    /* fix map */\n        enclen = 1;\n    } else if (n <= 65535) {\n        b[0] = 0xde;                /* map 16 */\n        b[1] = (n & 0xff00) >> 8;\n        b[2] = n & 0xff;\n        enclen = 3;\n    } else {\n        b[0] = 0xdf;                /* map 32 */\n        b[1] = (n & 0xff000000) >> 24;\n        b[2] = (n & 0xff0000) >> 16;\n        b[3] = (n & 0xff00) >> 8;\n        b[4] = n & 0xff;\n        enclen = 5;\n    }\n    mp_buf_append(L,buf,b,enclen);\n}\n\n/* --------------------------- Lua types encoding --------------------------- */\n\nvoid mp_encode_lua_string(lua_State *L, mp_buf *buf) {\n    size_t len;\n    const char *s;\n\n    s = lua_tolstring(L,-1,&len);\n    mp_encode_bytes(L,buf,(const unsigned char*)s,len);\n}\n\nvoid mp_encode_lua_bool(lua_State *L, mp_buf *buf) {\n    unsigned char b = lua_toboolean(L,-1) ? 0xc3 : 0xc2;\n    mp_buf_append(L,buf,&b,1);\n}\n\n/* Lua 5.3 has a built in 64-bit integer type */\nvoid mp_encode_lua_integer(lua_State *L, mp_buf *buf) {\n#if (LUA_VERSION_NUM < 503) && BITS_32\n    lua_Number i = lua_tonumber(L,-1);\n#else\n    lua_Integer i = lua_tointeger(L,-1);\n#endif\n    mp_encode_int(L, buf, (int64_t)i);\n}\n\n/* Lua 5.2 and lower only has 64-bit doubles, so we need to\n * detect if the double may be representable as an int\n * for Lua < 5.3 */\nvoid mp_encode_lua_number(lua_State *L, mp_buf *buf) {\n    lua_Number n = lua_tonumber(L,-1);\n\n    if (IS_INT64_EQUIVALENT(n)) {\n        mp_encode_lua_integer(L, buf);\n    } else {\n        mp_encode_double(L,buf,(double)n);\n    }\n}\n\nvoid mp_encode_lua_type(lua_State *L, mp_buf *buf, int level);\n\n/* Convert a lua table into a message pack list. */\nvoid mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {\n#if LUA_VERSION_NUM < 502\n    size_t len = lua_objlen(L,-1), j;\n#else\n    size_t len = lua_rawlen(L,-1), j;\n#endif\n\n    mp_encode_array(L,buf,len);\n    for (j = 1; j <= len; j++) {\n        lua_pushnumber(L,j);\n        lua_gettable(L,-2);\n        mp_encode_lua_type(L,buf,level+1);\n    }\n}\n\n/* Convert a lua table into a message pack key-value map. */\nvoid mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n     * Lua API, we need to iterate a first time. Note that an alternative\n     * would be to do a single run, and then hack the buffer to insert the\n     * map opcodes for message pack. Too hackish for this lib. */\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}\n\n/* Returns true if the Lua table on top of the stack is exclusively composed\n * of keys from numerical keys from 1 up to N, with N being the total number\n * of elements, without any hole in the middle. */\nint table_is_an_array(lua_State *L) {\n    int count = 0, max = 0;\n#if LUA_VERSION_NUM < 503\n    lua_Number n;\n#else\n    lua_Integer n;\n#endif\n\n    /* Stack top on function entry */\n    int stacktop;\n\n    stacktop = lua_gettop(L);\n\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pop(L,1); /* Stack: ... key */\n        /* The <= 0 check is valid here because we're comparing indexes. */\n#if LUA_VERSION_NUM < 503\n        if ((LUA_TNUMBER != lua_type(L,-1)) || (n = lua_tonumber(L, -1)) <= 0 ||\n            !IS_INT_EQUIVALENT(n))\n#else\n        if (!lua_isinteger(L,-1) || (n = lua_tointeger(L, -1)) <= 0)\n#endif\n        {\n            lua_settop(L, stacktop);\n            return 0;\n        }\n        max = (n > max ? n : max);\n        count++;\n    }\n    /* We have the total number of elements in \"count\". Also we have\n     * the max index encountered in \"max\". We can't reach this code\n     * if there are indexes <= 0. If you also note that there can not be\n     * repeated keys into a table, you have that if max==count you are sure\n     * that there are all the keys form 1 to count (both included). */\n    lua_settop(L, stacktop);\n    return max == count;\n}\n\n/* If the length operator returns non-zero, that is, there is at least\n * an object at key '1', we serialize to message pack list. Otherwise\n * we use a map. */\nvoid mp_encode_lua_table(lua_State *L, mp_buf *buf, int level) {\n    if (table_is_an_array(L))\n        mp_encode_lua_table_as_array(L,buf,level);\n    else\n        mp_encode_lua_table_as_map(L,buf,level);\n}\n\nvoid mp_encode_lua_null(lua_State *L, mp_buf *buf) {\n    unsigned char b[1];\n\n    b[0] = 0xc0;\n    mp_buf_append(L,buf,b,1);\n}\n\nvoid mp_encode_lua_type(lua_State *L, mp_buf *buf, int level) {\n    int t = lua_type(L,-1);\n\n    /* Limit the encoding of nested tables to a specified maximum depth, so that\n     * we survive when called against circular references in tables. */\n    if (t == LUA_TTABLE && level == LUACMSGPACK_MAX_NESTING) t = LUA_TNIL;\n    switch(t) {\n    case LUA_TSTRING: mp_encode_lua_string(L,buf); break;\n    case LUA_TBOOLEAN: mp_encode_lua_bool(L,buf); break;\n    case LUA_TNUMBER:\n    #if LUA_VERSION_NUM < 503\n        mp_encode_lua_number(L,buf); break;\n    #else\n        if (lua_isinteger(L, -1)) {\n            mp_encode_lua_integer(L, buf);\n        } else {\n            mp_encode_lua_number(L, buf);\n        }\n        break;\n    #endif\n    case LUA_TTABLE: mp_encode_lua_table(L,buf,level); break;\n    default: mp_encode_lua_null(L,buf); break;\n    }\n    lua_pop(L,1);\n}\n\n/*\n * Packs all arguments as a stream for multiple upacking later.\n * Returns error if no arguments provided.\n */\nint mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        /* Copy argument i to top of stack for _encode processing;\n         * the encode function pops it from the stack when complete. */\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        /* Reuse the buffer for the next operation by\n         * setting its free count to the total buffer size\n         * and the current position to zero. */\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    /* Concatenate all nargs buffers together */\n    lua_concat(L, nargs);\n    return 1;\n}\n\n/* ------------------------------- Decoding --------------------------------- */\n\nvoid mp_decode_to_lua_type(lua_State *L, mp_cur *c);\n\nvoid mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    int index = 1;\n\n    lua_newtable(L);\n    while(len--) {\n        lua_pushnumber(L,index++);\n        mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}\n\nvoid mp_decode_to_lua_hash(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    lua_newtable(L);\n    while(len--) {\n        mp_decode_to_lua_type(L,c); /* key */\n        if (c->err) return;\n        mp_decode_to_lua_type(L,c); /* value */\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}\n\n/* Decode a Message Pack raw object pointed by the string cursor 'c' to\n * a Lua type, that is left as the only result on the stack. */\nvoid mp_decode_to_lua_type(lua_State *L, mp_cur *c) {\n    mp_cur_need(c,1);\n\n    /* If we return more than 18 elements, we must resize the stack to\n     * fit all our return values.  But, there is no way to\n     * determine how many objects a msgpack will unpack to up front, so\n     * we request a +1 larger stack on each iteration (noop if stack is\n     * big enough, and when stack does require resize it doubles in size) */\n    luaL_checkstack(L, 1,\n        \"too many return values at once; \"\n        \"use unpack_one or unpack_limit instead.\");\n\n    switch(c->p[0]) {\n    case 0xcc:  /* uint 8 */\n        mp_cur_need(c,2);\n        lua_pushunsigned(L,c->p[1]);\n        mp_cur_consume(c,2);\n        break;\n    case 0xd0:  /* int 8 */\n        mp_cur_need(c,2);\n        lua_pushinteger(L,(signed char)c->p[1]);\n        mp_cur_consume(c,2);\n        break;\n    case 0xcd:  /* uint 16 */\n        mp_cur_need(c,3);\n        lua_pushunsigned(L,\n            (c->p[1] << 8) |\n             c->p[2]);\n        mp_cur_consume(c,3);\n        break;\n    case 0xd1:  /* int 16 */\n        mp_cur_need(c,3);\n        lua_pushinteger(L,(int16_t)\n            (c->p[1] << 8) |\n             c->p[2]);\n        mp_cur_consume(c,3);\n        break;\n    case 0xce:  /* uint 32 */\n        mp_cur_need(c,5);\n        lua_pushunsigned(L,\n            ((uint32_t)c->p[1] << 24) |\n            ((uint32_t)c->p[2] << 16) |\n            ((uint32_t)c->p[3] << 8) |\n             (uint32_t)c->p[4]);\n        mp_cur_consume(c,5);\n        break;\n    case 0xd2:  /* int 32 */\n        mp_cur_need(c,5);\n        lua_pushinteger(L,\n            ((int32_t)c->p[1] << 24) |\n            ((int32_t)c->p[2] << 16) |\n            ((int32_t)c->p[3] << 8) |\n             (int32_t)c->p[4]);\n        mp_cur_consume(c,5);\n        break;\n    case 0xcf:  /* uint 64 */\n        mp_cur_need(c,9);\n        lua_pushunsigned(L,\n            ((uint64_t)c->p[1] << 56) |\n            ((uint64_t)c->p[2] << 48) |\n            ((uint64_t)c->p[3] << 40) |\n            ((uint64_t)c->p[4] << 32) |\n            ((uint64_t)c->p[5] << 24) |\n            ((uint64_t)c->p[6] << 16) |\n            ((uint64_t)c->p[7] << 8) |\n             (uint64_t)c->p[8]);\n        mp_cur_consume(c,9);\n        break;\n    case 0xd3:  /* int 64 */\n        mp_cur_need(c,9);\n#if LUA_VERSION_NUM < 503\n        lua_pushnumber(L,\n#else\n        lua_pushinteger(L,\n#endif\n            ((int64_t)c->p[1] << 56) |\n            ((int64_t)c->p[2] << 48) |\n            ((int64_t)c->p[3] << 40) |\n            ((int64_t)c->p[4] << 32) |\n            ((int64_t)c->p[5] << 24) |\n            ((int64_t)c->p[6] << 16) |\n            ((int64_t)c->p[7] << 8) |\n             (int64_t)c->p[8]);\n        mp_cur_consume(c,9);\n        break;\n    case 0xc0:  /* nil */\n        lua_pushnil(L);\n        mp_cur_consume(c,1);\n        break;\n    case 0xc3:  /* true */\n        lua_pushboolean(L,1);\n        mp_cur_consume(c,1);\n        break;\n    case 0xc2:  /* false */\n        lua_pushboolean(L,0);\n        mp_cur_consume(c,1);\n        break;\n    case 0xca:  /* float */\n        mp_cur_need(c,5);\n        assert(sizeof(float) == 4);\n        {\n            float f;\n            memcpy(&f,c->p+1,4);\n            memrevifle(&f,4);\n            lua_pushnumber(L,f);\n            mp_cur_consume(c,5);\n        }\n        break;\n    case 0xcb:  /* double */\n        mp_cur_need(c,9);\n        assert(sizeof(double) == 8);\n        {\n            double d;\n            memcpy(&d,c->p+1,8);\n            memrevifle(&d,8);\n            lua_pushnumber(L,d);\n            mp_cur_consume(c,9);\n        }\n        break;\n    case 0xd9:  /* raw 8 */\n        mp_cur_need(c,2);\n        {\n            size_t l = c->p[1];\n            mp_cur_need(c,2+l);\n            lua_pushlstring(L,(char*)c->p+2,l);\n            mp_cur_consume(c,2+l);\n        }\n        break;\n    case 0xda:  /* raw 16 */\n        mp_cur_need(c,3);\n        {\n            size_t l = (c->p[1] << 8) | c->p[2];\n            mp_cur_need(c,3+l);\n            lua_pushlstring(L,(char*)c->p+3,l);\n            mp_cur_consume(c,3+l);\n        }\n        break;\n    case 0xdb:  /* raw 32 */\n        mp_cur_need(c,5);\n        {\n            size_t l = ((size_t)c->p[1] << 24) |\n                       ((size_t)c->p[2] << 16) |\n                       ((size_t)c->p[3] << 8) |\n                       (size_t)c->p[4];\n            mp_cur_consume(c,5);\n            mp_cur_need(c,l);\n            lua_pushlstring(L,(char*)c->p,l);\n            mp_cur_consume(c,l);\n        }\n        break;\n    case 0xdc:  /* array 16 */\n        mp_cur_need(c,3);\n        {\n            size_t l = (c->p[1] << 8) | c->p[2];\n            mp_cur_consume(c,3);\n            mp_decode_to_lua_array(L,c,l);\n        }\n        break;\n    case 0xdd:  /* array 32 */\n        mp_cur_need(c,5);\n        {\n            size_t l = ((size_t)c->p[1] << 24) |\n                       ((size_t)c->p[2] << 16) |\n                       ((size_t)c->p[3] << 8) |\n                       (size_t)c->p[4];\n            mp_cur_consume(c,5);\n            mp_decode_to_lua_array(L,c,l);\n        }\n        break;\n    case 0xde:  /* map 16 */\n        mp_cur_need(c,3);\n        {\n            size_t l = (c->p[1] << 8) | c->p[2];\n            mp_cur_consume(c,3);\n            mp_decode_to_lua_hash(L,c,l);\n        }\n        break;\n    case 0xdf:  /* map 32 */\n        mp_cur_need(c,5);\n        {\n            size_t l = ((size_t)c->p[1] << 24) |\n                       ((size_t)c->p[2] << 16) |\n                       ((size_t)c->p[3] << 8) |\n                       (size_t)c->p[4];\n            mp_cur_consume(c,5);\n            mp_decode_to_lua_hash(L,c,l);\n        }\n        break;\n    default:    /* types that can't be idenitified by first byte value. */\n        if ((c->p[0] & 0x80) == 0) {   /* positive fixnum */\n            lua_pushunsigned(L,c->p[0]);\n            mp_cur_consume(c,1);\n        } else if ((c->p[0] & 0xe0) == 0xe0) {  /* negative fixnum */\n            lua_pushinteger(L,(signed char)c->p[0]);\n            mp_cur_consume(c,1);\n        } else if ((c->p[0] & 0xe0) == 0xa0) {  /* fix raw */\n            size_t l = c->p[0] & 0x1f;\n            mp_cur_need(c,1+l);\n            lua_pushlstring(L,(char*)c->p+1,l);\n            mp_cur_consume(c,1+l);\n        } else if ((c->p[0] & 0xf0) == 0x90) {  /* fix map */\n            size_t l = c->p[0] & 0xf;\n            mp_cur_consume(c,1);\n            mp_decode_to_lua_array(L,c,l);\n        } else if ((c->p[0] & 0xf0) == 0x80) {  /* fix map */\n            size_t l = c->p[0] & 0xf;\n            mp_cur_consume(c,1);\n            mp_decode_to_lua_hash(L,c,l);\n        } else {\n            c->err = MP_CUR_ERROR_BADFMT;\n        }\n    }\n}\n\nint mp_unpack_full(lua_State *L, int limit, int offset) {\n    size_t len;\n    const char *s;\n    mp_cur c;\n    int cnt; /* Number of objects unpacked */\n    int decode_all = (!limit && !offset);\n\n    s = luaL_checklstring(L,1,&len); /* if no match, exits */\n\n    if (offset < 0 || limit < 0) /* requesting negative off or lim is invalid */\n        return luaL_error(L,\n            \"Invalid request to unpack with offset of %d and limit of %d.\",\n            offset, len);\n    else if (offset > len)\n        return luaL_error(L,\n            \"Start offset %d greater than input length %d.\", offset, len);\n\n    if (decode_all) limit = INT_MAX;\n\n    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);\n\n    /* We loop over the decode because this could be a stream\n     * of multiple top-level values serialized together */\n    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {\n        mp_decode_to_lua_type(L,&c);\n\n        if (c.err == MP_CUR_ERROR_EOF) {\n            return luaL_error(L,\"Missing bytes in input.\");\n        } else if (c.err == MP_CUR_ERROR_BADFMT) {\n            return luaL_error(L,\"Bad data format in input.\");\n        }\n    }\n\n    if (!decode_all) {\n        /* c->left is the remaining size of the input buffer.\n         * subtract the entire buffer size from the unprocessed size\n         * to get our next start offset */\n        int offset = len - c.left;\n        /* Return offset -1 when we have have processed the entire buffer. */\n        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n        /* Results are returned with the arg elements still\n         * in place. Lua takes care of only returning\n         * elements above the args for us.\n         * In this case, we have one arg on the stack\n         * for this function, so we insert our first return\n         * value at position 2. */\n        lua_insert(L, 2);\n        cnt += 1; /* increase return count by one to make room for offset */\n    }\n\n    return cnt;\n}\n\nint mp_unpack(lua_State *L) {\n    return mp_unpack_full(L, 0, 0);\n}\n\nint mp_unpack_one(lua_State *L) {\n    int offset = luaL_optinteger(L, 2, 0);\n    /* Variable pop because offset may not exist */\n    lua_pop(L, lua_gettop(L)-1);\n    return mp_unpack_full(L, 1, offset);\n}\n\nint mp_unpack_limit(lua_State *L) {\n    int limit = luaL_checkinteger(L, 2);\n    int offset = luaL_optinteger(L, 3, 0);\n    /* Variable pop because offset may not exist */\n    lua_pop(L, lua_gettop(L)-1);\n\n    return mp_unpack_full(L, limit, offset);\n}\n\nint mp_safe(lua_State *L) {\n    int argc, err, total_results;\n\n    argc = lua_gettop(L);\n\n    /* This adds our function to the bottom of the stack\n     * (the \"call this function\" position) */\n    lua_pushvalue(L, lua_upvalueindex(1));\n    lua_insert(L, 1);\n\n    err = lua_pcall(L, argc, LUA_MULTRET, 0);\n    total_results = lua_gettop(L);\n\n    if (!err) {\n        return total_results;\n    } else {\n        lua_pushnil(L);\n        lua_insert(L,-2);\n        return 2;\n    }\n}\n\n/* -------------------------------------------------------------------------- */\nconst struct luaL_Reg cmds[] = {\n    {\"pack\", mp_pack},\n    {\"unpack\", mp_unpack},\n    {\"unpack_one\", mp_unpack_one},\n    {\"unpack_limit\", mp_unpack_limit},\n    {0}\n};\n\nint luaopen_create(lua_State *L) {\n    int i;\n    /* Manually construct our module table instead of\n     * relying on _register or _newlib */\n    lua_newtable(L);\n\n    for (i = 0; i < (sizeof(cmds)/sizeof(*cmds) - 1); i++) {\n        lua_pushcfunction(L, cmds[i].func);\n        lua_setfield(L, -2, cmds[i].name);\n    }\n\n    /* Add metadata */\n    lua_pushliteral(L, LUACMSGPACK_NAME);\n    lua_setfield(L, -2, \"_NAME\");\n    lua_pushliteral(L, LUACMSGPACK_VERSION);\n    lua_setfield(L, -2, \"_VERSION\");\n    lua_pushliteral(L, LUACMSGPACK_COPYRIGHT);\n    lua_setfield(L, -2, \"_COPYRIGHT\");\n    lua_pushliteral(L, LUACMSGPACK_DESCRIPTION);\n    lua_setfield(L, -2, \"_DESCRIPTION\");\n    return 1;\n}\n\nLUALIB_API int luaopen_cmsgpack(lua_State *L) {\n    luaopen_create(L);\n\n#if LUA_VERSION_NUM < 502\n    /* Register name globally for 5.1 */\n    lua_pushvalue(L, -1);\n    lua_setglobal(L, LUACMSGPACK_NAME);\n#endif\n\n    return 1;\n}\n\nLUALIB_API int luaopen_cmsgpack_safe(lua_State *L) {\n    int i;\n\n    luaopen_cmsgpack(L);\n\n    /* Wrap all functions in the safe handler */\n    for (i = 0; i < (sizeof(cmds)/sizeof(*cmds) - 1); i++) {\n        lua_getfield(L, -1, cmds[i].name);\n        lua_pushcclosure(L, mp_safe, 1);\n        lua_setfield(L, -2, cmds[i].name);\n    }\n\n#if LUA_VERSION_NUM < 502\n    /* Register name globally for 5.1 */\n    lua_pushvalue(L, -1);\n    lua_setglobal(L, LUACMSGPACK_SAFE_NAME);\n#endif\n\n    return 1;\n}\n\n/******************************************************************************\n* Copyright (C) 2012 Salvatore Sanfilippo.  All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining\n* a copy of this software and associated documentation files (the\n* \"Software\"), to deal in the Software without restriction, including\n* without limitation the rights to use, copy, modify, merge, publish,\n* distribute, sublicense, and/or sell copies of the Software, and to\n* permit persons to whom the Software is furnished to do so, subject to\n* the following conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n******************************************************************************/\n"], "fixing_code": ["#include <math.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"lua.h\"\n#include \"lauxlib.h\"\n\n#define LUACMSGPACK_NAME        \"cmsgpack\"\n#define LUACMSGPACK_SAFE_NAME   \"cmsgpack_safe\"\n#define LUACMSGPACK_VERSION     \"lua-cmsgpack 0.4.0\"\n#define LUACMSGPACK_COPYRIGHT   \"Copyright (C) 2012, Salvatore Sanfilippo\"\n#define LUACMSGPACK_DESCRIPTION \"MessagePack C implementation for Lua\"\n\n/* Allows a preprocessor directive to override MAX_NESTING */\n#ifndef LUACMSGPACK_MAX_NESTING\n    #define LUACMSGPACK_MAX_NESTING  16 /* Max tables nesting. */\n#endif\n\n/* Check if float or double can be an integer without loss of precision */\n#define IS_INT_TYPE_EQUIVALENT(x, T) (!isinf(x) && (T)(x) == (x))\n\n#define IS_INT64_EQUIVALENT(x) IS_INT_TYPE_EQUIVALENT(x, int64_t)\n#define IS_INT_EQUIVALENT(x) IS_INT_TYPE_EQUIVALENT(x, int)\n\n/* If size of pointer is equal to a 4 byte integer, we're on 32 bits. */\n#if UINTPTR_MAX == UINT_MAX\n    #define BITS_32 1\n#else\n    #define BITS_32 0\n#endif\n\n#if BITS_32\n    #define lua_pushunsigned(L, n) lua_pushnumber(L, n)\n#else\n    #define lua_pushunsigned(L, n) lua_pushinteger(L, n)\n#endif\n\n/* =============================================================================\n * MessagePack implementation and bindings for Lua 5.1/5.2.\n * Copyright(C) 2012 Salvatore Sanfilippo <antirez@gmail.com>\n *\n * http://github.com/antirez/lua-cmsgpack\n *\n * For MessagePack specification check the following web site:\n * http://wiki.msgpack.org/display/MSGPACK/Format+specification\n *\n * See Copyright Notice at the end of this file.\n *\n * CHANGELOG:\n * 19-Feb-2012 (ver 0.1.0): Initial release.\n * 20-Feb-2012 (ver 0.2.0): Tables encoding improved.\n * 20-Feb-2012 (ver 0.2.1): Minor bug fixing.\n * 20-Feb-2012 (ver 0.3.0): Module renamed lua-cmsgpack (was lua-msgpack).\n * 04-Apr-2014 (ver 0.3.1): Lua 5.2 support and minor bug fix.\n * 07-Apr-2014 (ver 0.4.0): Multiple pack/unpack, lua allocator, efficiency.\n * ========================================================================== */\n\n/* -------------------------- Endian conversion --------------------------------\n * We use it only for floats and doubles, all the other conversions performed\n * in an endian independent fashion. So the only thing we need is a function\n * that swaps a binary string if arch is little endian (and left it untouched\n * otherwise). */\n\n/* Reverse memory bytes if arch is little endian. Given the conceptual\n * simplicity of the Lua build system we prefer check for endianess at runtime.\n * The performance difference should be acceptable. */\nvoid memrevifle(void *ptr, size_t len) {\n    unsigned char   *p = (unsigned char *)ptr,\n                    *e = (unsigned char *)p+len-1,\n                    aux;\n    int test = 1;\n    unsigned char *testp = (unsigned char*) &test;\n\n    if (testp[0] == 0) return; /* Big endian, nothing to do. */\n    len /= 2;\n    while(len--) {\n        aux = *p;\n        *p = *e;\n        *e = aux;\n        p++;\n        e--;\n    }\n}\n\n/* ---------------------------- String buffer ----------------------------------\n * This is a simple implementation of string buffers. The only operation\n * supported is creating empty buffers and appending bytes to it.\n * The string buffer uses 2x preallocation on every realloc for O(N) append\n * behavior.  */\n\ntypedef struct mp_buf {\n    unsigned char *b;\n    size_t len, free;\n} mp_buf;\n\nvoid *mp_realloc(lua_State *L, void *target, size_t osize,size_t nsize) {\n    void *(*local_realloc) (void *, void *, size_t osize, size_t nsize) = NULL;\n    void *ud;\n\n    local_realloc = lua_getallocf(L, &ud);\n\n    return local_realloc(ud, target, osize, nsize);\n}\n\nmp_buf *mp_buf_new(lua_State *L) {\n    mp_buf *buf = NULL;\n\n    /* Old size = 0; new size = sizeof(*buf) */\n    buf = (mp_buf*)mp_realloc(L, NULL, 0, sizeof(*buf));\n\n    buf->b = NULL;\n    buf->len = buf->free = 0;\n    return buf;\n}\n\nvoid mp_buf_append(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {\n    if (buf->free < len) {\n        size_t newsize = (buf->len+len)*2;\n\n        buf->b = (unsigned char*)mp_realloc(L, buf->b, buf->len + buf->free, newsize);\n        buf->free = newsize - buf->len;\n    }\n    memcpy(buf->b+buf->len,s,len);\n    buf->len += len;\n    buf->free -= len;\n}\n\nvoid mp_buf_free(lua_State *L, mp_buf *buf) {\n    mp_realloc(L, buf->b, buf->len + buf->free, 0); /* realloc to 0 = free */\n    mp_realloc(L, buf, sizeof(*buf), 0);\n}\n\n/* ---------------------------- String cursor ----------------------------------\n * This simple data structure is used for parsing. Basically you create a cursor\n * using a string pointer and a length, then it is possible to access the\n * current string position with cursor->p, check the remaining length\n * in cursor->left, and finally consume more string using\n * mp_cur_consume(cursor,len), to advance 'p' and subtract 'left'.\n * An additional field cursor->error is set to zero on initialization and can\n * be used to report errors. */\n\n#define MP_CUR_ERROR_NONE   0\n#define MP_CUR_ERROR_EOF    1   /* Not enough data to complete operation. */\n#define MP_CUR_ERROR_BADFMT 2   /* Bad data format */\n\ntypedef struct mp_cur {\n    const unsigned char *p;\n    size_t left;\n    int err;\n} mp_cur;\n\nvoid mp_cur_init(mp_cur *cursor, const unsigned char *s, size_t len) {\n    cursor->p = s;\n    cursor->left = len;\n    cursor->err = MP_CUR_ERROR_NONE;\n}\n\n#define mp_cur_consume(_c,_len) do { _c->p += _len; _c->left -= _len; } while(0)\n\n/* When there is not enough room we set an error in the cursor and return. This\n * is very common across the code so we have a macro to make the code look\n * a bit simpler. */\n#define mp_cur_need(_c,_len) do { \\\n    if (_c->left < _len) { \\\n        _c->err = MP_CUR_ERROR_EOF; \\\n        return; \\\n    } \\\n} while(0)\n\n/* ------------------------- Low level MP encoding -------------------------- */\n\nvoid mp_encode_bytes(lua_State *L, mp_buf *buf, const unsigned char *s, size_t len) {\n    unsigned char hdr[5];\n    int hdrlen;\n\n    if (len < 32) {\n        hdr[0] = 0xa0 | (len&0xff); /* fix raw */\n        hdrlen = 1;\n    } else if (len <= 0xff) {\n        hdr[0] = 0xd9;\n        hdr[1] = len;\n        hdrlen = 2;\n    } else if (len <= 0xffff) {\n        hdr[0] = 0xda;\n        hdr[1] = (len&0xff00)>>8;\n        hdr[2] = len&0xff;\n        hdrlen = 3;\n    } else {\n        hdr[0] = 0xdb;\n        hdr[1] = (len&0xff000000)>>24;\n        hdr[2] = (len&0xff0000)>>16;\n        hdr[3] = (len&0xff00)>>8;\n        hdr[4] = len&0xff;\n        hdrlen = 5;\n    }\n    mp_buf_append(L,buf,hdr,hdrlen);\n    mp_buf_append(L,buf,s,len);\n}\n\n/* we assume IEEE 754 internal format for single and double precision floats. */\nvoid mp_encode_double(lua_State *L, mp_buf *buf, double d) {\n    unsigned char b[9];\n    float f = d;\n\n    assert(sizeof(f) == 4 && sizeof(d) == 8);\n    if (d == (double)f) {\n        b[0] = 0xca;    /* float IEEE 754 */\n        memcpy(b+1,&f,4);\n        memrevifle(b+1,4);\n        mp_buf_append(L,buf,b,5);\n    } else if (sizeof(d) == 8) {\n        b[0] = 0xcb;    /* double IEEE 754 */\n        memcpy(b+1,&d,8);\n        memrevifle(b+1,8);\n        mp_buf_append(L,buf,b,9);\n    }\n}\n\nvoid mp_encode_int(lua_State *L, mp_buf *buf, int64_t n) {\n    unsigned char b[9];\n    int enclen;\n\n    if (n >= 0) {\n        if (n <= 127) {\n            b[0] = n & 0x7f;    /* positive fixnum */\n            enclen = 1;\n        } else if (n <= 0xff) {\n            b[0] = 0xcc;        /* uint 8 */\n            b[1] = n & 0xff;\n            enclen = 2;\n        } else if (n <= 0xffff) {\n            b[0] = 0xcd;        /* uint 16 */\n            b[1] = (n & 0xff00) >> 8;\n            b[2] = n & 0xff;\n            enclen = 3;\n        } else if (n <= 0xffffffffLL) {\n            b[0] = 0xce;        /* uint 32 */\n            b[1] = (n & 0xff000000) >> 24;\n            b[2] = (n & 0xff0000) >> 16;\n            b[3] = (n & 0xff00) >> 8;\n            b[4] = n & 0xff;\n            enclen = 5;\n        } else {\n            b[0] = 0xcf;        /* uint 64 */\n            b[1] = (n & 0xff00000000000000LL) >> 56;\n            b[2] = (n & 0xff000000000000LL) >> 48;\n            b[3] = (n & 0xff0000000000LL) >> 40;\n            b[4] = (n & 0xff00000000LL) >> 32;\n            b[5] = (n & 0xff000000) >> 24;\n            b[6] = (n & 0xff0000) >> 16;\n            b[7] = (n & 0xff00) >> 8;\n            b[8] = n & 0xff;\n            enclen = 9;\n        }\n    } else {\n        if (n >= -32) {\n            b[0] = ((signed char)n);   /* negative fixnum */\n            enclen = 1;\n        } else if (n >= -128) {\n            b[0] = 0xd0;        /* int 8 */\n            b[1] = n & 0xff;\n            enclen = 2;\n        } else if (n >= -32768) {\n            b[0] = 0xd1;        /* int 16 */\n            b[1] = (n & 0xff00) >> 8;\n            b[2] = n & 0xff;\n            enclen = 3;\n        } else if (n >= -2147483648LL) {\n            b[0] = 0xd2;        /* int 32 */\n            b[1] = (n & 0xff000000) >> 24;\n            b[2] = (n & 0xff0000) >> 16;\n            b[3] = (n & 0xff00) >> 8;\n            b[4] = n & 0xff;\n            enclen = 5;\n        } else {\n            b[0] = 0xd3;        /* int 64 */\n            b[1] = (n & 0xff00000000000000LL) >> 56;\n            b[2] = (n & 0xff000000000000LL) >> 48;\n            b[3] = (n & 0xff0000000000LL) >> 40;\n            b[4] = (n & 0xff00000000LL) >> 32;\n            b[5] = (n & 0xff000000) >> 24;\n            b[6] = (n & 0xff0000) >> 16;\n            b[7] = (n & 0xff00) >> 8;\n            b[8] = n & 0xff;\n            enclen = 9;\n        }\n    }\n    mp_buf_append(L,buf,b,enclen);\n}\n\nvoid mp_encode_array(lua_State *L, mp_buf *buf, int64_t n) {\n    unsigned char b[5];\n    int enclen;\n\n    if (n <= 15) {\n        b[0] = 0x90 | (n & 0xf);    /* fix array */\n        enclen = 1;\n    } else if (n <= 65535) {\n        b[0] = 0xdc;                /* array 16 */\n        b[1] = (n & 0xff00) >> 8;\n        b[2] = n & 0xff;\n        enclen = 3;\n    } else {\n        b[0] = 0xdd;                /* array 32 */\n        b[1] = (n & 0xff000000) >> 24;\n        b[2] = (n & 0xff0000) >> 16;\n        b[3] = (n & 0xff00) >> 8;\n        b[4] = n & 0xff;\n        enclen = 5;\n    }\n    mp_buf_append(L,buf,b,enclen);\n}\n\nvoid mp_encode_map(lua_State *L, mp_buf *buf, int64_t n) {\n    unsigned char b[5];\n    int enclen;\n\n    if (n <= 15) {\n        b[0] = 0x80 | (n & 0xf);    /* fix map */\n        enclen = 1;\n    } else if (n <= 65535) {\n        b[0] = 0xde;                /* map 16 */\n        b[1] = (n & 0xff00) >> 8;\n        b[2] = n & 0xff;\n        enclen = 3;\n    } else {\n        b[0] = 0xdf;                /* map 32 */\n        b[1] = (n & 0xff000000) >> 24;\n        b[2] = (n & 0xff0000) >> 16;\n        b[3] = (n & 0xff00) >> 8;\n        b[4] = n & 0xff;\n        enclen = 5;\n    }\n    mp_buf_append(L,buf,b,enclen);\n}\n\n/* --------------------------- Lua types encoding --------------------------- */\n\nvoid mp_encode_lua_string(lua_State *L, mp_buf *buf) {\n    size_t len;\n    const char *s;\n\n    s = lua_tolstring(L,-1,&len);\n    mp_encode_bytes(L,buf,(const unsigned char*)s,len);\n}\n\nvoid mp_encode_lua_bool(lua_State *L, mp_buf *buf) {\n    unsigned char b = lua_toboolean(L,-1) ? 0xc3 : 0xc2;\n    mp_buf_append(L,buf,&b,1);\n}\n\n/* Lua 5.3 has a built in 64-bit integer type */\nvoid mp_encode_lua_integer(lua_State *L, mp_buf *buf) {\n#if (LUA_VERSION_NUM < 503) && BITS_32\n    lua_Number i = lua_tonumber(L,-1);\n#else\n    lua_Integer i = lua_tointeger(L,-1);\n#endif\n    mp_encode_int(L, buf, (int64_t)i);\n}\n\n/* Lua 5.2 and lower only has 64-bit doubles, so we need to\n * detect if the double may be representable as an int\n * for Lua < 5.3 */\nvoid mp_encode_lua_number(lua_State *L, mp_buf *buf) {\n    lua_Number n = lua_tonumber(L,-1);\n\n    if (IS_INT64_EQUIVALENT(n)) {\n        mp_encode_lua_integer(L, buf);\n    } else {\n        mp_encode_double(L,buf,(double)n);\n    }\n}\n\nvoid mp_encode_lua_type(lua_State *L, mp_buf *buf, int level);\n\n/* Convert a lua table into a message pack list. */\nvoid mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {\n#if LUA_VERSION_NUM < 502\n    size_t len = lua_objlen(L,-1), j;\n#else\n    size_t len = lua_rawlen(L,-1), j;\n#endif\n\n    mp_encode_array(L,buf,len);\n    for (j = 1; j <= len; j++) {\n        lua_pushnumber(L,j);\n        lua_gettable(L,-2);\n        mp_encode_lua_type(L,buf,level+1);\n    }\n}\n\n/* Convert a lua table into a message pack key-value map. */\nvoid mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n     * Lua API, we need to iterate a first time. Note that an alternative\n     * would be to do a single run, and then hack the buffer to insert the\n     * map opcodes for message pack. Too hackish for this lib. */\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}\n\n/* Returns true if the Lua table on top of the stack is exclusively composed\n * of keys from numerical keys from 1 up to N, with N being the total number\n * of elements, without any hole in the middle. */\nint table_is_an_array(lua_State *L) {\n    int count = 0, max = 0;\n#if LUA_VERSION_NUM < 503\n    lua_Number n;\n#else\n    lua_Integer n;\n#endif\n\n    /* Stack top on function entry */\n    int stacktop;\n\n    stacktop = lua_gettop(L);\n\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pop(L,1); /* Stack: ... key */\n        /* The <= 0 check is valid here because we're comparing indexes. */\n#if LUA_VERSION_NUM < 503\n        if ((LUA_TNUMBER != lua_type(L,-1)) || (n = lua_tonumber(L, -1)) <= 0 ||\n            !IS_INT_EQUIVALENT(n))\n#else\n        if (!lua_isinteger(L,-1) || (n = lua_tointeger(L, -1)) <= 0)\n#endif\n        {\n            lua_settop(L, stacktop);\n            return 0;\n        }\n        max = (n > max ? n : max);\n        count++;\n    }\n    /* We have the total number of elements in \"count\". Also we have\n     * the max index encountered in \"max\". We can't reach this code\n     * if there are indexes <= 0. If you also note that there can not be\n     * repeated keys into a table, you have that if max==count you are sure\n     * that there are all the keys form 1 to count (both included). */\n    lua_settop(L, stacktop);\n    return max == count;\n}\n\n/* If the length operator returns non-zero, that is, there is at least\n * an object at key '1', we serialize to message pack list. Otherwise\n * we use a map. */\nvoid mp_encode_lua_table(lua_State *L, mp_buf *buf, int level) {\n    if (table_is_an_array(L))\n        mp_encode_lua_table_as_array(L,buf,level);\n    else\n        mp_encode_lua_table_as_map(L,buf,level);\n}\n\nvoid mp_encode_lua_null(lua_State *L, mp_buf *buf) {\n    unsigned char b[1];\n\n    b[0] = 0xc0;\n    mp_buf_append(L,buf,b,1);\n}\n\nvoid mp_encode_lua_type(lua_State *L, mp_buf *buf, int level) {\n    int t = lua_type(L,-1);\n\n    /* Limit the encoding of nested tables to a specified maximum depth, so that\n     * we survive when called against circular references in tables. */\n    if (t == LUA_TTABLE && level == LUACMSGPACK_MAX_NESTING) t = LUA_TNIL;\n    switch(t) {\n    case LUA_TSTRING: mp_encode_lua_string(L,buf); break;\n    case LUA_TBOOLEAN: mp_encode_lua_bool(L,buf); break;\n    case LUA_TNUMBER:\n    #if LUA_VERSION_NUM < 503\n        mp_encode_lua_number(L,buf); break;\n    #else\n        if (lua_isinteger(L, -1)) {\n            mp_encode_lua_integer(L, buf);\n        } else {\n            mp_encode_lua_number(L, buf);\n        }\n        break;\n    #endif\n    case LUA_TTABLE: mp_encode_lua_table(L,buf,level); break;\n    default: mp_encode_lua_null(L,buf); break;\n    }\n    lua_pop(L,1);\n}\n\n/*\n * Packs all arguments as a stream for multiple upacking later.\n * Returns error if no arguments provided.\n */\nint mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        /* Copy argument i to top of stack for _encode processing;\n         * the encode function pops it from the stack when complete. */\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        /* Reuse the buffer for the next operation by\n         * setting its free count to the total buffer size\n         * and the current position to zero. */\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    /* Concatenate all nargs buffers together */\n    lua_concat(L, nargs);\n    return 1;\n}\n\n/* ------------------------------- Decoding --------------------------------- */\n\nvoid mp_decode_to_lua_type(lua_State *L, mp_cur *c);\n\nvoid mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    int index = 1;\n\n    lua_newtable(L);\n    while(len--) {\n        lua_pushnumber(L,index++);\n        mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}\n\nvoid mp_decode_to_lua_hash(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    lua_newtable(L);\n    while(len--) {\n        mp_decode_to_lua_type(L,c); /* key */\n        if (c->err) return;\n        mp_decode_to_lua_type(L,c); /* value */\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}\n\n/* Decode a Message Pack raw object pointed by the string cursor 'c' to\n * a Lua type, that is left as the only result on the stack. */\nvoid mp_decode_to_lua_type(lua_State *L, mp_cur *c) {\n    mp_cur_need(c,1);\n\n    /* If we return more than 18 elements, we must resize the stack to\n     * fit all our return values.  But, there is no way to\n     * determine how many objects a msgpack will unpack to up front, so\n     * we request a +1 larger stack on each iteration (noop if stack is\n     * big enough, and when stack does require resize it doubles in size) */\n    luaL_checkstack(L, 1,\n        \"too many return values at once; \"\n        \"use unpack_one or unpack_limit instead.\");\n\n    switch(c->p[0]) {\n    case 0xcc:  /* uint 8 */\n        mp_cur_need(c,2);\n        lua_pushunsigned(L,c->p[1]);\n        mp_cur_consume(c,2);\n        break;\n    case 0xd0:  /* int 8 */\n        mp_cur_need(c,2);\n        lua_pushinteger(L,(signed char)c->p[1]);\n        mp_cur_consume(c,2);\n        break;\n    case 0xcd:  /* uint 16 */\n        mp_cur_need(c,3);\n        lua_pushunsigned(L,\n            (c->p[1] << 8) |\n             c->p[2]);\n        mp_cur_consume(c,3);\n        break;\n    case 0xd1:  /* int 16 */\n        mp_cur_need(c,3);\n        lua_pushinteger(L,(int16_t)\n            (c->p[1] << 8) |\n             c->p[2]);\n        mp_cur_consume(c,3);\n        break;\n    case 0xce:  /* uint 32 */\n        mp_cur_need(c,5);\n        lua_pushunsigned(L,\n            ((uint32_t)c->p[1] << 24) |\n            ((uint32_t)c->p[2] << 16) |\n            ((uint32_t)c->p[3] << 8) |\n             (uint32_t)c->p[4]);\n        mp_cur_consume(c,5);\n        break;\n    case 0xd2:  /* int 32 */\n        mp_cur_need(c,5);\n        lua_pushinteger(L,\n            ((int32_t)c->p[1] << 24) |\n            ((int32_t)c->p[2] << 16) |\n            ((int32_t)c->p[3] << 8) |\n             (int32_t)c->p[4]);\n        mp_cur_consume(c,5);\n        break;\n    case 0xcf:  /* uint 64 */\n        mp_cur_need(c,9);\n        lua_pushunsigned(L,\n            ((uint64_t)c->p[1] << 56) |\n            ((uint64_t)c->p[2] << 48) |\n            ((uint64_t)c->p[3] << 40) |\n            ((uint64_t)c->p[4] << 32) |\n            ((uint64_t)c->p[5] << 24) |\n            ((uint64_t)c->p[6] << 16) |\n            ((uint64_t)c->p[7] << 8) |\n             (uint64_t)c->p[8]);\n        mp_cur_consume(c,9);\n        break;\n    case 0xd3:  /* int 64 */\n        mp_cur_need(c,9);\n#if LUA_VERSION_NUM < 503\n        lua_pushnumber(L,\n#else\n        lua_pushinteger(L,\n#endif\n            ((int64_t)c->p[1] << 56) |\n            ((int64_t)c->p[2] << 48) |\n            ((int64_t)c->p[3] << 40) |\n            ((int64_t)c->p[4] << 32) |\n            ((int64_t)c->p[5] << 24) |\n            ((int64_t)c->p[6] << 16) |\n            ((int64_t)c->p[7] << 8) |\n             (int64_t)c->p[8]);\n        mp_cur_consume(c,9);\n        break;\n    case 0xc0:  /* nil */\n        lua_pushnil(L);\n        mp_cur_consume(c,1);\n        break;\n    case 0xc3:  /* true */\n        lua_pushboolean(L,1);\n        mp_cur_consume(c,1);\n        break;\n    case 0xc2:  /* false */\n        lua_pushboolean(L,0);\n        mp_cur_consume(c,1);\n        break;\n    case 0xca:  /* float */\n        mp_cur_need(c,5);\n        assert(sizeof(float) == 4);\n        {\n            float f;\n            memcpy(&f,c->p+1,4);\n            memrevifle(&f,4);\n            lua_pushnumber(L,f);\n            mp_cur_consume(c,5);\n        }\n        break;\n    case 0xcb:  /* double */\n        mp_cur_need(c,9);\n        assert(sizeof(double) == 8);\n        {\n            double d;\n            memcpy(&d,c->p+1,8);\n            memrevifle(&d,8);\n            lua_pushnumber(L,d);\n            mp_cur_consume(c,9);\n        }\n        break;\n    case 0xd9:  /* raw 8 */\n        mp_cur_need(c,2);\n        {\n            size_t l = c->p[1];\n            mp_cur_need(c,2+l);\n            lua_pushlstring(L,(char*)c->p+2,l);\n            mp_cur_consume(c,2+l);\n        }\n        break;\n    case 0xda:  /* raw 16 */\n        mp_cur_need(c,3);\n        {\n            size_t l = (c->p[1] << 8) | c->p[2];\n            mp_cur_need(c,3+l);\n            lua_pushlstring(L,(char*)c->p+3,l);\n            mp_cur_consume(c,3+l);\n        }\n        break;\n    case 0xdb:  /* raw 32 */\n        mp_cur_need(c,5);\n        {\n            size_t l = ((size_t)c->p[1] << 24) |\n                       ((size_t)c->p[2] << 16) |\n                       ((size_t)c->p[3] << 8) |\n                       (size_t)c->p[4];\n            mp_cur_consume(c,5);\n            mp_cur_need(c,l);\n            lua_pushlstring(L,(char*)c->p,l);\n            mp_cur_consume(c,l);\n        }\n        break;\n    case 0xdc:  /* array 16 */\n        mp_cur_need(c,3);\n        {\n            size_t l = (c->p[1] << 8) | c->p[2];\n            mp_cur_consume(c,3);\n            mp_decode_to_lua_array(L,c,l);\n        }\n        break;\n    case 0xdd:  /* array 32 */\n        mp_cur_need(c,5);\n        {\n            size_t l = ((size_t)c->p[1] << 24) |\n                       ((size_t)c->p[2] << 16) |\n                       ((size_t)c->p[3] << 8) |\n                       (size_t)c->p[4];\n            mp_cur_consume(c,5);\n            mp_decode_to_lua_array(L,c,l);\n        }\n        break;\n    case 0xde:  /* map 16 */\n        mp_cur_need(c,3);\n        {\n            size_t l = (c->p[1] << 8) | c->p[2];\n            mp_cur_consume(c,3);\n            mp_decode_to_lua_hash(L,c,l);\n        }\n        break;\n    case 0xdf:  /* map 32 */\n        mp_cur_need(c,5);\n        {\n            size_t l = ((size_t)c->p[1] << 24) |\n                       ((size_t)c->p[2] << 16) |\n                       ((size_t)c->p[3] << 8) |\n                       (size_t)c->p[4];\n            mp_cur_consume(c,5);\n            mp_decode_to_lua_hash(L,c,l);\n        }\n        break;\n    default:    /* types that can't be idenitified by first byte value. */\n        if ((c->p[0] & 0x80) == 0) {   /* positive fixnum */\n            lua_pushunsigned(L,c->p[0]);\n            mp_cur_consume(c,1);\n        } else if ((c->p[0] & 0xe0) == 0xe0) {  /* negative fixnum */\n            lua_pushinteger(L,(signed char)c->p[0]);\n            mp_cur_consume(c,1);\n        } else if ((c->p[0] & 0xe0) == 0xa0) {  /* fix raw */\n            size_t l = c->p[0] & 0x1f;\n            mp_cur_need(c,1+l);\n            lua_pushlstring(L,(char*)c->p+1,l);\n            mp_cur_consume(c,1+l);\n        } else if ((c->p[0] & 0xf0) == 0x90) {  /* fix map */\n            size_t l = c->p[0] & 0xf;\n            mp_cur_consume(c,1);\n            mp_decode_to_lua_array(L,c,l);\n        } else if ((c->p[0] & 0xf0) == 0x80) {  /* fix map */\n            size_t l = c->p[0] & 0xf;\n            mp_cur_consume(c,1);\n            mp_decode_to_lua_hash(L,c,l);\n        } else {\n            c->err = MP_CUR_ERROR_BADFMT;\n        }\n    }\n}\n\nint mp_unpack_full(lua_State *L, int limit, int offset) {\n    size_t len;\n    const char *s;\n    mp_cur c;\n    int cnt; /* Number of objects unpacked */\n    int decode_all = (!limit && !offset);\n\n    s = luaL_checklstring(L,1,&len); /* if no match, exits */\n\n    if (offset < 0 || limit < 0) /* requesting negative off or lim is invalid */\n        return luaL_error(L,\n            \"Invalid request to unpack with offset of %d and limit of %d.\",\n            offset, len);\n    else if (offset > len)\n        return luaL_error(L,\n            \"Start offset %d greater than input length %d.\", offset, len);\n\n    if (decode_all) limit = INT_MAX;\n\n    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);\n\n    /* We loop over the decode because this could be a stream\n     * of multiple top-level values serialized together */\n    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {\n        mp_decode_to_lua_type(L,&c);\n\n        if (c.err == MP_CUR_ERROR_EOF) {\n            return luaL_error(L,\"Missing bytes in input.\");\n        } else if (c.err == MP_CUR_ERROR_BADFMT) {\n            return luaL_error(L,\"Bad data format in input.\");\n        }\n    }\n\n    if (!decode_all) {\n        /* c->left is the remaining size of the input buffer.\n         * subtract the entire buffer size from the unprocessed size\n         * to get our next start offset */\n        int offset = len - c.left;\n        /* Return offset -1 when we have have processed the entire buffer. */\n        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n        /* Results are returned with the arg elements still\n         * in place. Lua takes care of only returning\n         * elements above the args for us.\n         * In this case, we have one arg on the stack\n         * for this function, so we insert our first return\n         * value at position 2. */\n        lua_insert(L, 2);\n        cnt += 1; /* increase return count by one to make room for offset */\n    }\n\n    return cnt;\n}\n\nint mp_unpack(lua_State *L) {\n    return mp_unpack_full(L, 0, 0);\n}\n\nint mp_unpack_one(lua_State *L) {\n    int offset = luaL_optinteger(L, 2, 0);\n    /* Variable pop because offset may not exist */\n    lua_pop(L, lua_gettop(L)-1);\n    return mp_unpack_full(L, 1, offset);\n}\n\nint mp_unpack_limit(lua_State *L) {\n    int limit = luaL_checkinteger(L, 2);\n    int offset = luaL_optinteger(L, 3, 0);\n    /* Variable pop because offset may not exist */\n    lua_pop(L, lua_gettop(L)-1);\n\n    return mp_unpack_full(L, limit, offset);\n}\n\nint mp_safe(lua_State *L) {\n    int argc, err, total_results;\n\n    argc = lua_gettop(L);\n\n    /* This adds our function to the bottom of the stack\n     * (the \"call this function\" position) */\n    lua_pushvalue(L, lua_upvalueindex(1));\n    lua_insert(L, 1);\n\n    err = lua_pcall(L, argc, LUA_MULTRET, 0);\n    total_results = lua_gettop(L);\n\n    if (!err) {\n        return total_results;\n    } else {\n        lua_pushnil(L);\n        lua_insert(L,-2);\n        return 2;\n    }\n}\n\n/* -------------------------------------------------------------------------- */\nconst struct luaL_Reg cmds[] = {\n    {\"pack\", mp_pack},\n    {\"unpack\", mp_unpack},\n    {\"unpack_one\", mp_unpack_one},\n    {\"unpack_limit\", mp_unpack_limit},\n    {0}\n};\n\nint luaopen_create(lua_State *L) {\n    int i;\n    /* Manually construct our module table instead of\n     * relying on _register or _newlib */\n    lua_newtable(L);\n\n    for (i = 0; i < (sizeof(cmds)/sizeof(*cmds) - 1); i++) {\n        lua_pushcfunction(L, cmds[i].func);\n        lua_setfield(L, -2, cmds[i].name);\n    }\n\n    /* Add metadata */\n    lua_pushliteral(L, LUACMSGPACK_NAME);\n    lua_setfield(L, -2, \"_NAME\");\n    lua_pushliteral(L, LUACMSGPACK_VERSION);\n    lua_setfield(L, -2, \"_VERSION\");\n    lua_pushliteral(L, LUACMSGPACK_COPYRIGHT);\n    lua_setfield(L, -2, \"_COPYRIGHT\");\n    lua_pushliteral(L, LUACMSGPACK_DESCRIPTION);\n    lua_setfield(L, -2, \"_DESCRIPTION\");\n    return 1;\n}\n\nLUALIB_API int luaopen_cmsgpack(lua_State *L) {\n    luaopen_create(L);\n\n#if LUA_VERSION_NUM < 502\n    /* Register name globally for 5.1 */\n    lua_pushvalue(L, -1);\n    lua_setglobal(L, LUACMSGPACK_NAME);\n#endif\n\n    return 1;\n}\n\nLUALIB_API int luaopen_cmsgpack_safe(lua_State *L) {\n    int i;\n\n    luaopen_cmsgpack(L);\n\n    /* Wrap all functions in the safe handler */\n    for (i = 0; i < (sizeof(cmds)/sizeof(*cmds) - 1); i++) {\n        lua_getfield(L, -1, cmds[i].name);\n        lua_pushcclosure(L, mp_safe, 1);\n        lua_setfield(L, -2, cmds[i].name);\n    }\n\n#if LUA_VERSION_NUM < 502\n    /* Register name globally for 5.1 */\n    lua_pushvalue(L, -1);\n    lua_setglobal(L, LUACMSGPACK_SAFE_NAME);\n#endif\n\n    return 1;\n}\n\n/******************************************************************************\n* Copyright (C) 2012 Salvatore Sanfilippo.  All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining\n* a copy of this software and associated documentation files (the\n* \"Software\"), to deal in the Software without restriction, including\n* without limitation the rights to use, copy, modify, merge, publish,\n* distribute, sublicense, and/or sell copies of the Software, and to\n* permit persons to whom the Software is furnished to do so, subject to\n* the following conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n******************************************************************************/\n"], "filenames": ["deps/lua/src/lua_cmsgpack.c"], "buggy_code_start_loc": [517], "buggy_code_end_loc": [517], "fixing_code_start_loc": [518], "fixing_code_end_loc": [521], "type": "CWE-787", "message": "Memory Corruption was discovered in the cmsgpack library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2 because of stack-based buffer overflows.", "other": {"cve": {"id": "CVE-2018-11218", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-17T17:29:00.277", "lastModified": "2021-08-04T17:14:46.777", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory Corruption was discovered in the cmsgpack library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2 because of stack-based buffer overflows."}, {"lang": "es", "value": "Se ha descubierto una corrupci\u00f3n de memoria en la biblioteca cmsgpack en el subsistema Lua en Redis en versiones anteriores a la 3.2.12, versiones 4.x anteriores a la 4.0.10 y versiones 5.x anteriores a la 5.0 RC2 debido a desbordamientos de b\u00fafer basados en pila."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.12", "matchCriteriaId": "A638FE37-0FA9-40E6-90AD-5241977EE2E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.0.10", "matchCriteriaId": "2E46FE4D-C1EC-4270-A5B1-349DD726AF87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redislabs:redis:5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "E6037E16-4EE7-44F6-9045-DA6B705B0F5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "D52F557F-D0A0-43D3-85F1-F10B6EBFAEDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "E3517A27-E6EE-497C-9996-F78171BBE90F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:10:*:*:*:*:*:*:*", "matchCriteriaId": "E722FEF7-58A6-47AD-B1D0-DB0B71B0C7AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openstack:13:*:*:*:*:*:*:*", "matchCriteriaId": "704CFA1A-953E-4105-BFBE-406034B83DED"}]}]}], "references": [{"url": "http://antirez.com/news/119", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/104553", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0052", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0094", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1860", "source": "cve@mitre.org"}, {"url": "https://github.com/antirez/redis/commit/52a00201fca331217c3b4b8b634f6a0f57d6b7d3", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/antirez/redis/commit/5ccb6f7a791bf3490357b00a898885759d98bab0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/antirez/redis/issues/5017", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/antirez/redis/4.0/00-RELEASENOTES", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://raw.githubusercontent.com/antirez/redis/5.0/00-RELEASENOTES", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201908-04", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4230", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "Patch"]}]}, "github_commit_url": "https://github.com/antirez/redis/commit/52a00201fca331217c3b4b8b634f6a0f57d6b7d3"}}