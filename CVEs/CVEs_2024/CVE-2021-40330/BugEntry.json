{"buggy_code": ["#include \"git-compat-util.h\"\n#include \"cache.h\"\n#include \"config.h\"\n#include \"pkt-line.h\"\n#include \"quote.h\"\n#include \"refs.h\"\n#include \"run-command.h\"\n#include \"remote.h\"\n#include \"connect.h\"\n#include \"url.h\"\n#include \"string-list.h\"\n#include \"sha1-array.h\"\n#include \"transport.h\"\n#include \"strbuf.h\"\n#include \"version.h\"\n#include \"protocol.h\"\n#include \"alias.h\"\n\nstatic char *server_capabilities_v1;\nstatic struct argv_array server_capabilities_v2 = ARGV_ARRAY_INIT;\nstatic const char *parse_feature_value(const char *, const char *, int *);\n\nstatic int check_ref(const char *name, unsigned int flags)\n{\n\tif (!flags)\n\t\treturn 1;\n\n\tif (!skip_prefix(name, \"refs/\", &name))\n\t\treturn 0;\n\n\t/* REF_NORMAL means that we don't want the magic fake tag refs */\n\tif ((flags & REF_NORMAL) && check_refname_format(name, 0))\n\t\treturn 0;\n\n\t/* REF_HEADS means that we want regular branch heads */\n\tif ((flags & REF_HEADS) && starts_with(name, \"heads/\"))\n\t\treturn 1;\n\n\t/* REF_TAGS means that we want tags */\n\tif ((flags & REF_TAGS) && starts_with(name, \"tags/\"))\n\t\treturn 1;\n\n\t/* All type bits clear means that we are ok with anything */\n\treturn !(flags & ~REF_NORMAL);\n}\n\nint check_ref_type(const struct ref *ref, int flags)\n{\n\treturn check_ref(ref->name, flags);\n}\n\nstatic NORETURN void die_initial_contact(int unexpected)\n{\n\t/*\n\t * A hang-up after seeing some response from the other end\n\t * means that it is unexpected, as we know the other end is\n\t * willing to talk to us.  A hang-up before seeing any\n\t * response does not necessarily mean an ACL problem, though.\n\t */\n\tif (unexpected)\n\t\tdie(_(\"the remote end hung up upon initial contact\"));\n\telse\n\t\tdie(_(\"Could not read from remote repository.\\n\\n\"\n\t\t      \"Please make sure you have the correct access rights\\n\"\n\t\t      \"and the repository exists.\"));\n}\n\n/* Checks if the server supports the capability 'c' */\nint server_supports_v2(const char *c, int die_on_error)\n{\n\tint i;\n\n\tfor (i = 0; i < server_capabilities_v2.argc; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.argv[i], c, &out) &&\n\t\t    (!*out || *out == '='))\n\t\t\treturn 1;\n\t}\n\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support '%s'\"), c);\n\n\treturn 0;\n}\n\nint server_supports_feature(const char *c, const char *feature,\n\t\t\t    int die_on_error)\n{\n\tint i;\n\n\tfor (i = 0; i < server_capabilities_v2.argc; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.argv[i], c, &out) &&\n\t\t    (!*out || *(out++) == '=')) {\n\t\t\tif (parse_feature_request(out, feature))\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support feature '%s'\"), feature);\n\n\treturn 0;\n}\n\nstatic void process_capabilities_v2(struct packet_reader *reader)\n{\n\twhile (packet_reader_read(reader) == PACKET_READ_NORMAL)\n\t\targv_array_push(&server_capabilities_v2, reader->line);\n\n\tif (reader->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"expected flush after capabilities\"));\n}\n\nenum protocol_version discover_version(struct packet_reader *reader)\n{\n\tenum protocol_version version = protocol_unknown_version;\n\n\t/*\n\t * Peek the first line of the server's response to\n\t * determine the protocol version the server is speaking.\n\t */\n\tswitch (packet_reader_peek(reader)) {\n\tcase PACKET_READ_EOF:\n\t\tdie_initial_contact(0);\n\tcase PACKET_READ_FLUSH:\n\tcase PACKET_READ_DELIM:\n\t\tversion = protocol_v0;\n\t\tbreak;\n\tcase PACKET_READ_NORMAL:\n\t\tversion = determine_protocol_version_client(reader->line);\n\t\tbreak;\n\t}\n\n\tswitch (version) {\n\tcase protocol_v2:\n\t\tprocess_capabilities_v2(reader);\n\t\tbreak;\n\tcase protocol_v1:\n\t\t/* Read the peeked version line */\n\t\tpacket_reader_read(reader);\n\t\tbreak;\n\tcase protocol_v0:\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\n\treturn version;\n}\n\nstatic void parse_one_symref_info(struct string_list *symref, const char *val, int len)\n{\n\tchar *sym, *target;\n\tstruct string_list_item *item;\n\n\tif (!len)\n\t\treturn; /* just \"symref\" */\n\t/* e.g. \"symref=HEAD:refs/heads/master\" */\n\tsym = xmemdupz(val, len);\n\ttarget = strchr(sym, ':');\n\tif (!target)\n\t\t/* just \"symref=something\" */\n\t\tgoto reject;\n\t*(target++) = '\\0';\n\tif (check_refname_format(sym, REFNAME_ALLOW_ONELEVEL) ||\n\t    check_refname_format(target, REFNAME_ALLOW_ONELEVEL))\n\t\t/* \"symref=bogus:pair */\n\t\tgoto reject;\n\titem = string_list_append_nodup(symref, sym);\n\titem->util = target;\n\treturn;\nreject:\n\tfree(sym);\n\treturn;\n}\n\nstatic void annotate_refs_with_symref_info(struct ref *ref)\n{\n\tstruct string_list symref = STRING_LIST_INIT_DUP;\n\tconst char *feature_list = server_capabilities_v1;\n\n\twhile (feature_list) {\n\t\tint len;\n\t\tconst char *val;\n\n\t\tval = parse_feature_value(feature_list, \"symref\", &len);\n\t\tif (!val)\n\t\t\tbreak;\n\t\tparse_one_symref_info(&symref, val, len);\n\t\tfeature_list = val + 1;\n\t}\n\tstring_list_sort(&symref);\n\n\tfor (; ref; ref = ref->next) {\n\t\tstruct string_list_item *item;\n\t\titem = string_list_lookup(&symref, ref->name);\n\t\tif (!item)\n\t\t\tcontinue;\n\t\tref->symref = xstrdup((char *)item->util);\n\t}\n\tstring_list_clear(&symref, 0);\n}\n\nstatic void process_capabilities(const char *line, int *len)\n{\n\tint nul_location = strlen(line);\n\tif (nul_location == *len)\n\t\treturn;\n\tserver_capabilities_v1 = xstrdup(line + nul_location + 1);\n\t*len = nul_location;\n}\n\nstatic int process_dummy_ref(const char *line)\n{\n\tstruct object_id oid;\n\tconst char *name;\n\n\tif (parse_oid_hex(line, &oid, &name))\n\t\treturn 0;\n\tif (*name != ' ')\n\t\treturn 0;\n\tname++;\n\n\treturn oideq(&null_oid, &oid) && !strcmp(name, \"capabilities^{}\");\n}\n\nstatic void check_no_capabilities(const char *line, int len)\n{\n\tif (strlen(line) != len)\n\t\twarning(_(\"ignoring capabilities after first line '%s'\"),\n\t\t\tline + strlen(line));\n}\n\nstatic int process_ref(const char *line, int len, struct ref ***list,\n\t\t       unsigned int flags, struct oid_array *extra_have)\n{\n\tstruct object_id old_oid;\n\tconst char *name;\n\n\tif (parse_oid_hex(line, &old_oid, &name))\n\t\treturn 0;\n\tif (*name != ' ')\n\t\treturn 0;\n\tname++;\n\n\tif (extra_have && !strcmp(name, \".have\")) {\n\t\toid_array_append(extra_have, &old_oid);\n\t} else if (!strcmp(name, \"capabilities^{}\")) {\n\t\tdie(_(\"protocol error: unexpected capabilities^{}\"));\n\t} else if (check_ref(name, flags)) {\n\t\tstruct ref *ref = alloc_ref(name);\n\t\toidcpy(&ref->old_oid, &old_oid);\n\t\t**list = ref;\n\t\t*list = &ref->next;\n\t}\n\tcheck_no_capabilities(line, len);\n\treturn 1;\n}\n\nstatic int process_shallow(const char *line, int len,\n\t\t\t   struct oid_array *shallow_points)\n{\n\tconst char *arg;\n\tstruct object_id old_oid;\n\n\tif (!skip_prefix(line, \"shallow \", &arg))\n\t\treturn 0;\n\n\tif (get_oid_hex(arg, &old_oid))\n\t\tdie(_(\"protocol error: expected shallow sha-1, got '%s'\"), arg);\n\tif (!shallow_points)\n\t\tdie(_(\"repository on the other end cannot be shallow\"));\n\toid_array_append(shallow_points, &old_oid);\n\tcheck_no_capabilities(line, len);\n\treturn 1;\n}\n\nenum get_remote_heads_state {\n\tEXPECTING_FIRST_REF = 0,\n\tEXPECTING_REF,\n\tEXPECTING_SHALLOW,\n\tEXPECTING_DONE,\n};\n\n/*\n * Read all the refs from the other end\n */\nstruct ref **get_remote_heads(struct packet_reader *reader,\n\t\t\t      struct ref **list, unsigned int flags,\n\t\t\t      struct oid_array *extra_have,\n\t\t\t      struct oid_array *shallow_points)\n{\n\tstruct ref **orig_list = list;\n\tint len = 0;\n\tenum get_remote_heads_state state = EXPECTING_FIRST_REF;\n\tconst char *arg;\n\n\t*list = NULL;\n\n\twhile (state != EXPECTING_DONE) {\n\t\tswitch (packet_reader_read(reader)) {\n\t\tcase PACKET_READ_EOF:\n\t\t\tdie_initial_contact(1);\n\t\tcase PACKET_READ_NORMAL:\n\t\t\tlen = reader->pktlen;\n\t\t\tif (len > 4 && skip_prefix(reader->line, \"ERR \", &arg))\n\t\t\t\tdie(_(\"remote error: %s\"), arg);\n\t\t\tbreak;\n\t\tcase PACKET_READ_FLUSH:\n\t\t\tstate = EXPECTING_DONE;\n\t\t\tbreak;\n\t\tcase PACKET_READ_DELIM:\n\t\t\tdie(_(\"invalid packet\"));\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase EXPECTING_FIRST_REF:\n\t\t\tprocess_capabilities(reader->line, &len);\n\t\t\tif (process_dummy_ref(reader->line)) {\n\t\t\t\tstate = EXPECTING_SHALLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = EXPECTING_REF;\n\t\t\t/* fallthrough */\n\t\tcase EXPECTING_REF:\n\t\t\tif (process_ref(reader->line, len, &list, flags, extra_have))\n\t\t\t\tbreak;\n\t\t\tstate = EXPECTING_SHALLOW;\n\t\t\t/* fallthrough */\n\t\tcase EXPECTING_SHALLOW:\n\t\t\tif (process_shallow(reader->line, len, shallow_points))\n\t\t\t\tbreak;\n\t\t\tdie(_(\"protocol error: unexpected '%s'\"), reader->line);\n\t\tcase EXPECTING_DONE:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tannotate_refs_with_symref_info(*orig_list);\n\n\treturn list;\n}\n\n/* Returns 1 when a valid ref has been added to `list`, 0 otherwise */\nstatic int process_ref_v2(const char *line, struct ref ***list)\n{\n\tint ret = 1;\n\tint i = 0;\n\tstruct object_id old_oid;\n\tstruct ref *ref;\n\tstruct string_list line_sections = STRING_LIST_INIT_DUP;\n\tconst char *end;\n\n\t/*\n\t * Ref lines have a number of fields which are space deliminated.  The\n\t * first field is the OID of the ref.  The second field is the ref\n\t * name.  Subsequent fields (symref-target and peeled) are optional and\n\t * don't have a particular order.\n\t */\n\tif (string_list_split(&line_sections, line, ' ', -1) < 2) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (parse_oid_hex(line_sections.items[i++].string, &old_oid, &end) ||\n\t    *end) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tref = alloc_ref(line_sections.items[i++].string);\n\n\toidcpy(&ref->old_oid, &old_oid);\n\t**list = ref;\n\t*list = &ref->next;\n\n\tfor (; i < line_sections.nr; i++) {\n\t\tconst char *arg = line_sections.items[i].string;\n\t\tif (skip_prefix(arg, \"symref-target:\", &arg))\n\t\t\tref->symref = xstrdup(arg);\n\n\t\tif (skip_prefix(arg, \"peeled:\", &arg)) {\n\t\t\tstruct object_id peeled_oid;\n\t\t\tchar *peeled_name;\n\t\t\tstruct ref *peeled;\n\t\t\tif (parse_oid_hex(arg, &peeled_oid, &end) || *end) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tpeeled_name = xstrfmt(\"%s^{}\", ref->name);\n\t\t\tpeeled = alloc_ref(peeled_name);\n\n\t\t\toidcpy(&peeled->old_oid, &peeled_oid);\n\t\t\t**list = peeled;\n\t\t\t*list = &peeled->next;\n\n\t\t\tfree(peeled_name);\n\t\t}\n\t}\n\nout:\n\tstring_list_clear(&line_sections, 0);\n\treturn ret;\n}\n\nstruct ref **get_remote_refs(int fd_out, struct packet_reader *reader,\n\t\t\t     struct ref **list, int for_push,\n\t\t\t     const struct argv_array *ref_prefixes,\n\t\t\t     const struct string_list *server_options)\n{\n\tint i;\n\t*list = NULL;\n\n\tif (server_supports_v2(\"ls-refs\", 1))\n\t\tpacket_write_fmt(fd_out, \"command=ls-refs\\n\");\n\n\tif (server_supports_v2(\"agent\", 0))\n\t\tpacket_write_fmt(fd_out, \"agent=%s\", git_user_agent_sanitized());\n\n\tif (server_options && server_options->nr &&\n\t    server_supports_v2(\"server-option\", 1))\n\t\tfor (i = 0; i < server_options->nr; i++)\n\t\t\tpacket_write_fmt(fd_out, \"server-option=%s\",\n\t\t\t\t\t server_options->items[i].string);\n\n\tpacket_delim(fd_out);\n\t/* When pushing we don't want to request the peeled tags */\n\tif (!for_push)\n\t\tpacket_write_fmt(fd_out, \"peel\\n\");\n\tpacket_write_fmt(fd_out, \"symrefs\\n\");\n\tfor (i = 0; ref_prefixes && i < ref_prefixes->argc; i++) {\n\t\tpacket_write_fmt(fd_out, \"ref-prefix %s\\n\",\n\t\t\t\t ref_prefixes->argv[i]);\n\t}\n\tpacket_flush(fd_out);\n\n\t/* Process response from server */\n\twhile (packet_reader_read(reader) == PACKET_READ_NORMAL) {\n\t\tif (!process_ref_v2(reader->line, &list))\n\t\t\tdie(_(\"invalid ls-refs response: %s\"), reader->line);\n\t}\n\n\tif (reader->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"expected flush after ref listing\"));\n\n\treturn list;\n}\n\nstatic const char *parse_feature_value(const char *feature_list, const char *feature, int *lenp)\n{\n\tint len;\n\n\tif (!feature_list)\n\t\treturn NULL;\n\n\tlen = strlen(feature);\n\twhile (*feature_list) {\n\t\tconst char *found = strstr(feature_list, feature);\n\t\tif (!found)\n\t\t\treturn NULL;\n\t\tif (feature_list == found || isspace(found[-1])) {\n\t\t\tconst char *value = found + len;\n\t\t\t/* feature with no value (e.g., \"thin-pack\") */\n\t\t\tif (!*value || isspace(*value)) {\n\t\t\t\tif (lenp)\n\t\t\t\t\t*lenp = 0;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t/* feature with a value (e.g., \"agent=git/1.2.3\") */\n\t\t\telse if (*value == '=') {\n\t\t\t\tvalue++;\n\t\t\t\tif (lenp)\n\t\t\t\t\t*lenp = strcspn(value, \" \\t\\n\");\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t/*\n\t\t\t * otherwise we matched a substring of another feature;\n\t\t\t * keep looking\n\t\t\t */\n\t\t}\n\t\tfeature_list = found + 1;\n\t}\n\treturn NULL;\n}\n\nint parse_feature_request(const char *feature_list, const char *feature)\n{\n\treturn !!parse_feature_value(feature_list, feature, NULL);\n}\n\nconst char *server_feature_value(const char *feature, int *len)\n{\n\treturn parse_feature_value(server_capabilities_v1, feature, len);\n}\n\nint server_supports(const char *feature)\n{\n\treturn !!server_feature_value(feature, NULL);\n}\n\nenum protocol {\n\tPROTO_LOCAL = 1,\n\tPROTO_FILE,\n\tPROTO_SSH,\n\tPROTO_GIT\n};\n\nint url_is_local_not_ssh(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon) ||\n\t\t(has_dos_drive_prefix(url) && is_valid_path(url));\n}\n\nstatic const char *prot_name(enum protocol protocol)\n{\n\tswitch (protocol) {\n\t\tcase PROTO_LOCAL:\n\t\tcase PROTO_FILE:\n\t\t\treturn \"file\";\n\t\tcase PROTO_SSH:\n\t\t\treturn \"ssh\";\n\t\tcase PROTO_GIT:\n\t\t\treturn \"git\";\n\t\tdefault:\n\t\t\treturn \"unknown protocol\";\n\t}\n}\n\nstatic enum protocol get_protocol(const char *name)\n{\n\tif (!strcmp(name, \"ssh\"))\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"git\"))\n\t\treturn PROTO_GIT;\n\tif (!strcmp(name, \"git+ssh\")) /* deprecated - do not use */\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"ssh+git\")) /* deprecated - do not use */\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"file\"))\n\t\treturn PROTO_FILE;\n\tdie(_(\"protocol '%s' is not supported\"), name);\n}\n\nstatic char *host_end(char **hoststart, int removebrackets)\n{\n\tchar *host = *hoststart;\n\tchar *end;\n\tchar *start = strstr(host, \"@[\");\n\tif (start)\n\t\tstart++; /* Jump over '@' */\n\telse\n\t\tstart = host;\n\tif (start[0] == '[') {\n\t\tend = strchr(start + 1, ']');\n\t\tif (end) {\n\t\t\tif (removebrackets) {\n\t\t\t\t*end = 0;\n\t\t\t\tmemmove(start, start + 1, end - start);\n\t\t\t\tend++;\n\t\t\t}\n\t\t} else\n\t\t\tend = host;\n\t} else\n\t\tend = host;\n\treturn end;\n}\n\n#define STR_(s)\t# s\n#define STR(s)\tSTR_(s)\n\nstatic void get_host_and_port(char **host, const char **port)\n{\n\tchar *colon, *end;\n\tend = host_end(host, 1);\n\tcolon = strchr(end, ':');\n\tif (colon) {\n\t\tlong portnr = strtol(colon + 1, &end, 10);\n\t\tif (end != colon + 1 && *end == '\\0' && 0 <= portnr && portnr < 65536) {\n\t\t\t*colon = 0;\n\t\t\t*port = colon + 1;\n\t\t} else if (!colon[1]) {\n\t\t\t*colon = 0;\n\t\t}\n\t}\n}\n\nstatic void enable_keepalive(int sockfd)\n{\n\tint ka = 1;\n\n\tif (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &ka, sizeof(ka)) < 0)\n\t\terror_errno(_(\"unable to set SO_KEEPALIVE on socket\"));\n}\n\n#ifndef NO_IPV6\n\nstatic const char *ai_name(const struct addrinfo *ai)\n{\n\tstatic char addr[NI_MAXHOST];\n\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, addr, sizeof(addr), NULL, 0,\n\t\t\tNI_NUMERICHOST) != 0)\n\t\txsnprintf(addr, sizeof(addr), \"(unknown)\");\n\n\treturn addr;\n}\n\n/*\n * Returns a connected socket() fd, or else die()s.\n */\nstatic int git_tcp_connect_sock(char *host, int flags)\n{\n\tstruct strbuf error_message = STRBUF_INIT;\n\tint sockfd = -1;\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tstruct addrinfo hints, *ai0, *ai;\n\tint gai;\n\tint cnt = 0;\n\n\tget_host_and_port(&host, &port);\n\tif (!*port)\n\t\tport = \"<none>\";\n\n\tmemset(&hints, 0, sizeof(hints));\n\tif (flags & CONNECT_IPV4)\n\t\thints.ai_family = AF_INET;\n\telse if (flags & CONNECT_IPV6)\n\t\thints.ai_family = AF_INET6;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\tif (flags & CONNECT_VERBOSE)\n\t\tfprintf(stderr, _(\"Looking up %s ... \"), host);\n\n\tgai = getaddrinfo(host, port, &hints, &ai);\n\tif (gai)\n\t\tdie(_(\"unable to look up %s (port %s) (%s)\"), host, port, gai_strerror(gai));\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Looking up %s ... \" */\n\t\tfprintf(stderr, _(\"done.\\nConnecting to %s (port %s) ... \"), host, port);\n\n\tfor (ai0 = ai; ai; ai = ai->ai_next, cnt++) {\n\t\tsockfd = socket(ai->ai_family,\n\t\t\t\tai->ai_socktype, ai->ai_protocol);\n\t\tif ((sockfd < 0) ||\n\t\t    (connect(sockfd, ai->ai_addr, ai->ai_addrlen) < 0)) {\n\t\t\tstrbuf_addf(&error_message, \"%s[%d: %s]: errno=%s\\n\",\n\t\t\t\t    host, cnt, ai_name(ai), strerror(errno));\n\t\t\tif (0 <= sockfd)\n\t\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags & CONNECT_VERBOSE)\n\t\t\tfprintf(stderr, \"%s \", ai_name(ai));\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo(ai0);\n\n\tif (sockfd < 0)\n\t\tdie(_(\"unable to connect to %s:\\n%s\"), host, error_message.buf);\n\n\tenable_keepalive(sockfd);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Connecting to %s (port %s) ... \" */\n\t\tfprintf_ln(stderr, _(\"done.\"));\n\n\tstrbuf_release(&error_message);\n\n\treturn sockfd;\n}\n\n#else /* NO_IPV6 */\n\n/*\n * Returns a connected socket() fd, or else die()s.\n */\nstatic int git_tcp_connect_sock(char *host, int flags)\n{\n\tstruct strbuf error_message = STRBUF_INIT;\n\tint sockfd = -1;\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tchar *ep;\n\tstruct hostent *he;\n\tstruct sockaddr_in sa;\n\tchar **ap;\n\tunsigned int nport;\n\tint cnt;\n\n\tget_host_and_port(&host, &port);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\tfprintf(stderr, _(\"Looking up %s ... \"), host);\n\n\the = gethostbyname(host);\n\tif (!he)\n\t\tdie(_(\"unable to look up %s (%s)\"), host, hstrerror(h_errno));\n\tnport = strtoul(port, &ep, 10);\n\tif ( ep == port || *ep ) {\n\t\t/* Not numeric */\n\t\tstruct servent *se = getservbyname(port,\"tcp\");\n\t\tif ( !se )\n\t\t\tdie(_(\"unknown port %s\"), port);\n\t\tnport = se->s_port;\n\t}\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Looking up %s ... \" */\n\t\tfprintf(stderr, _(\"done.\\nConnecting to %s (port %s) ... \"), host, port);\n\n\tfor (cnt = 0, ap = he->h_addr_list; *ap; ap++, cnt++) {\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sin_family = he->h_addrtype;\n\t\tsa.sin_port = htons(nport);\n\t\tmemcpy(&sa.sin_addr, *ap, he->h_length);\n\n\t\tsockfd = socket(he->h_addrtype, SOCK_STREAM, 0);\n\t\tif ((sockfd < 0) ||\n\t\t    connect(sockfd, (struct sockaddr *)&sa, sizeof sa) < 0) {\n\t\t\tstrbuf_addf(&error_message, \"%s[%d: %s]: errno=%s\\n\",\n\t\t\t\thost,\n\t\t\t\tcnt,\n\t\t\t\tinet_ntoa(*(struct in_addr *)&sa.sin_addr),\n\t\t\t\tstrerror(errno));\n\t\t\tif (0 <= sockfd)\n\t\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags & CONNECT_VERBOSE)\n\t\t\tfprintf(stderr, \"%s \",\n\t\t\t\tinet_ntoa(*(struct in_addr *)&sa.sin_addr));\n\t\tbreak;\n\t}\n\n\tif (sockfd < 0)\n\t\tdie(_(\"unable to connect to %s:\\n%s\"), host, error_message.buf);\n\n\tenable_keepalive(sockfd);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Connecting to %s (port %s) ... \" */\n\t\tfprintf_ln(stderr, _(\"done.\"));\n\n\treturn sockfd;\n}\n\n#endif /* NO_IPV6 */\n\n\n/*\n * Dummy child_process returned by git_connect() if the transport protocol\n * does not need fork(2).\n */\nstatic struct child_process no_fork = CHILD_PROCESS_INIT;\n\nint git_connection_is_socket(struct child_process *conn)\n{\n\treturn conn == &no_fork;\n}\n\nstatic struct child_process *git_tcp_connect(int fd[2], char *host, int flags)\n{\n\tint sockfd = git_tcp_connect_sock(host, flags);\n\n\tfd[0] = sockfd;\n\tfd[1] = dup(sockfd);\n\n\treturn &no_fork;\n}\n\n\nstatic char *git_proxy_command;\n\nstatic int git_proxy_command_options(const char *var, const char *value,\n\t\tvoid *cb)\n{\n\tif (!strcmp(var, \"core.gitproxy\")) {\n\t\tconst char *for_pos;\n\t\tint matchlen = -1;\n\t\tint hostlen;\n\t\tconst char *rhost_name = cb;\n\t\tint rhost_len = strlen(rhost_name);\n\n\t\tif (git_proxy_command)\n\t\t\treturn 0;\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\t/* [core]\n\t\t * ;# matches www.kernel.org as well\n\t\t * gitproxy = netcatter-1 for kernel.org\n\t\t * gitproxy = netcatter-2 for sample.xz\n\t\t * gitproxy = netcatter-default\n\t\t */\n\t\tfor_pos = strstr(value, \" for \");\n\t\tif (!for_pos)\n\t\t\t/* matches everybody */\n\t\t\tmatchlen = strlen(value);\n\t\telse {\n\t\t\thostlen = strlen(for_pos + 5);\n\t\t\tif (rhost_len < hostlen)\n\t\t\t\tmatchlen = -1;\n\t\t\telse if (!strncmp(for_pos + 5,\n\t\t\t\t\t  rhost_name + rhost_len - hostlen,\n\t\t\t\t\t  hostlen) &&\n\t\t\t\t ((rhost_len == hostlen) ||\n\t\t\t\t  rhost_name[rhost_len - hostlen -1] == '.'))\n\t\t\t\tmatchlen = for_pos - value;\n\t\t\telse\n\t\t\t\tmatchlen = -1;\n\t\t}\n\t\tif (0 <= matchlen) {\n\t\t\t/* core.gitproxy = none for kernel.org */\n\t\t\tif (matchlen == 4 &&\n\t\t\t    !memcmp(value, \"none\", 4))\n\t\t\t\tmatchlen = 0;\n\t\t\tgit_proxy_command = xmemdupz(value, matchlen);\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int git_use_proxy(const char *host)\n{\n\tgit_proxy_command = getenv(\"GIT_PROXY_COMMAND\");\n\tgit_config(git_proxy_command_options, (void*)host);\n\treturn (git_proxy_command && *git_proxy_command);\n}\n\nstatic struct child_process *git_proxy_connect(int fd[2], char *host)\n{\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tstruct child_process *proxy;\n\n\tget_host_and_port(&host, &port);\n\n\tif (looks_like_command_line_option(host))\n\t\tdie(_(\"strange hostname '%s' blocked\"), host);\n\tif (looks_like_command_line_option(port))\n\t\tdie(_(\"strange port '%s' blocked\"), port);\n\n\tproxy = xmalloc(sizeof(*proxy));\n\tchild_process_init(proxy);\n\targv_array_push(&proxy->args, git_proxy_command);\n\targv_array_push(&proxy->args, host);\n\targv_array_push(&proxy->args, port);\n\tproxy->in = -1;\n\tproxy->out = -1;\n\tif (start_command(proxy))\n\t\tdie(_(\"cannot start proxy %s\"), git_proxy_command);\n\tfd[0] = proxy->out; /* read from proxy stdout */\n\tfd[1] = proxy->in;  /* write to proxy stdin */\n\treturn proxy;\n}\n\nstatic char *get_port(char *host)\n{\n\tchar *end;\n\tchar *p = strchr(host, ':');\n\n\tif (p) {\n\t\tlong port = strtol(p + 1, &end, 10);\n\t\tif (end != p + 1 && *end == '\\0' && 0 <= port && port < 65536) {\n\t\t\t*p = '\\0';\n\t\t\treturn p+1;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Extract protocol and relevant parts from the specified connection URL.\n * The caller must free() the returned strings.\n */\nstatic enum protocol parse_connect_url(const char *url_orig, char **ret_host,\n\t\t\t\t       char **ret_path)\n{\n\tchar *url;\n\tchar *host, *path;\n\tchar *end;\n\tint separator = '/';\n\tenum protocol protocol = PROTO_LOCAL;\n\n\tif (is_url(url_orig))\n\t\turl = url_decode(url_orig);\n\telse\n\t\turl = xstrdup(url_orig);\n\n\thost = strstr(url, \"://\");\n\tif (host) {\n\t\t*host = '\\0';\n\t\tprotocol = get_protocol(url);\n\t\thost += 3;\n\t} else {\n\t\thost = url;\n\t\tif (!url_is_local_not_ssh(url)) {\n\t\t\tprotocol = PROTO_SSH;\n\t\t\tseparator = ':';\n\t\t}\n\t}\n\n\t/*\n\t * Don't do destructive transforms as protocol code does\n\t * '[]' unwrapping in get_host_and_port()\n\t */\n\tend = host_end(&host, 0);\n\n\tif (protocol == PROTO_LOCAL)\n\t\tpath = end;\n\telse if (protocol == PROTO_FILE && has_dos_drive_prefix(end))\n\t\tpath = end; /* \"file://$(pwd)\" may be \"file://C:/projects/repo\" */\n\telse\n\t\tpath = strchr(end, separator);\n\n\tif (!path || !*path)\n\t\tdie(_(\"no path specified; see 'git help pull' for valid url syntax\"));\n\n\t/*\n\t * null-terminate hostname and point path to ~ for URL's like this:\n\t *    ssh://host.xz/~user/repo\n\t */\n\n\tend = path; /* Need to \\0 terminate host here */\n\tif (separator == ':')\n\t\tpath++; /* path starts after ':' */\n\tif (protocol == PROTO_GIT || protocol == PROTO_SSH) {\n\t\tif (path[1] == '~')\n\t\t\tpath++;\n\t}\n\n\tpath = xstrdup(path);\n\t*end = '\\0';\n\n\t*ret_host = xstrdup(host);\n\t*ret_path = path;\n\tfree(url);\n\treturn protocol;\n}\n\nstatic const char *get_ssh_command(void)\n{\n\tconst char *ssh;\n\n\tif ((ssh = getenv(\"GIT_SSH_COMMAND\")))\n\t\treturn ssh;\n\n\tif (!git_config_get_string_const(\"core.sshcommand\", &ssh))\n\t\treturn ssh;\n\n\treturn NULL;\n}\n\nenum ssh_variant {\n\tVARIANT_AUTO,\n\tVARIANT_SIMPLE,\n\tVARIANT_SSH,\n\tVARIANT_PLINK,\n\tVARIANT_PUTTY,\n\tVARIANT_TORTOISEPLINK,\n};\n\nstatic void override_ssh_variant(enum ssh_variant *ssh_variant)\n{\n\tconst char *variant = getenv(\"GIT_SSH_VARIANT\");\n\n\tif (!variant && git_config_get_string_const(\"ssh.variant\", &variant))\n\t\treturn;\n\n\tif (!strcmp(variant, \"auto\"))\n\t\t*ssh_variant = VARIANT_AUTO;\n\telse if (!strcmp(variant, \"plink\"))\n\t\t*ssh_variant = VARIANT_PLINK;\n\telse if (!strcmp(variant, \"putty\"))\n\t\t*ssh_variant = VARIANT_PUTTY;\n\telse if (!strcmp(variant, \"tortoiseplink\"))\n\t\t*ssh_variant = VARIANT_TORTOISEPLINK;\n\telse if (!strcmp(variant, \"simple\"))\n\t\t*ssh_variant = VARIANT_SIMPLE;\n\telse\n\t\t*ssh_variant = VARIANT_SSH;\n}\n\nstatic enum ssh_variant determine_ssh_variant(const char *ssh_command,\n\t\t\t\t\t      int is_cmdline)\n{\n\tenum ssh_variant ssh_variant = VARIANT_AUTO;\n\tconst char *variant;\n\tchar *p = NULL;\n\n\toverride_ssh_variant(&ssh_variant);\n\n\tif (ssh_variant != VARIANT_AUTO)\n\t\treturn ssh_variant;\n\n\tif (!is_cmdline) {\n\t\tp = xstrdup(ssh_command);\n\t\tvariant = basename(p);\n\t} else {\n\t\tconst char **ssh_argv;\n\n\t\tp = xstrdup(ssh_command);\n\t\tif (split_cmdline(p, &ssh_argv) > 0) {\n\t\t\tvariant = basename((char *)ssh_argv[0]);\n\t\t\t/*\n\t\t\t * At this point, variant points into the buffer\n\t\t\t * referenced by p, hence we do not need ssh_argv\n\t\t\t * any longer.\n\t\t\t */\n\t\t\tfree(ssh_argv);\n\t\t} else {\n\t\t\tfree(p);\n\t\t\treturn ssh_variant;\n\t\t}\n\t}\n\n\tif (!strcasecmp(variant, \"ssh\") ||\n\t    !strcasecmp(variant, \"ssh.exe\"))\n\t\tssh_variant = VARIANT_SSH;\n\telse if (!strcasecmp(variant, \"plink\") ||\n\t\t !strcasecmp(variant, \"plink.exe\"))\n\t\tssh_variant = VARIANT_PLINK;\n\telse if (!strcasecmp(variant, \"tortoiseplink\") ||\n\t\t !strcasecmp(variant, \"tortoiseplink.exe\"))\n\t\tssh_variant = VARIANT_TORTOISEPLINK;\n\n\tfree(p);\n\treturn ssh_variant;\n}\n\n/*\n * Open a connection using Git's native protocol.\n *\n * The caller is responsible for freeing hostandport, but this function may\n * modify it (for example, to truncate it to remove the port part).\n */\nstatic struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\t/*\n\t * Set up virtual host information based on where we will\n\t * connect, unless the user has overridden us in\n\t * the environment.\n\t */\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\n\ttransport_check_allowed(\"git\");\n\n\t/*\n\t * These underlying connection commands die() if they\n\t * cannot connect.\n\t */\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\t/*\n\t * Separate original protocol components prog and path\n\t * from extended host header with a NUL byte.\n\t *\n\t * Note: Do not add any other headers here!  Doing so\n\t * will cause older git-daemon servers to crash.\n\t */\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\n\t/* If using a new version put that stuff here after a second null byte */\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\n\tpacket_write(fd[1], request.buf, request.len);\n\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}\n\n/*\n * Append the appropriate environment variables to `env` and options to\n * `args` for running ssh in Git's SSH-tunneled transport.\n */\nstatic void push_ssh_options(struct argv_array *args, struct argv_array *env,\n\t\t\t     enum ssh_variant variant, const char *port,\n\t\t\t     enum protocol_version version, int flags)\n{\n\tif (variant == VARIANT_SSH &&\n\t    version > 0) {\n\t\targv_array_push(args, \"-o\");\n\t\targv_array_push(args, \"SendEnv=\" GIT_PROTOCOL_ENVIRONMENT);\n\t\targv_array_pushf(env, GIT_PROTOCOL_ENVIRONMENT \"=version=%d\",\n\t\t\t\t version);\n\t}\n\n\tif (flags & CONNECT_IPV4) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support -4\"));\n\t\tcase VARIANT_SSH:\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\targv_array_push(args, \"-4\");\n\t\t}\n\t} else if (flags & CONNECT_IPV6) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support -6\"));\n\t\tcase VARIANT_SSH:\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\targv_array_push(args, \"-6\");\n\t\t}\n\t}\n\n\tif (variant == VARIANT_TORTOISEPLINK)\n\t\targv_array_push(args, \"-batch\");\n\n\tif (port) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support setting port\"));\n\t\tcase VARIANT_SSH:\n\t\t\targv_array_push(args, \"-p\");\n\t\t\tbreak;\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\targv_array_push(args, \"-P\");\n\t\t}\n\n\t\targv_array_push(args, port);\n\t}\n}\n\n/* Prepare a child_process for use by Git's SSH-tunneled transport. */\nstatic void fill_ssh_args(struct child_process *conn, const char *ssh_host,\n\t\t\t  const char *port, enum protocol_version version,\n\t\t\t  int flags)\n{\n\tconst char *ssh;\n\tenum ssh_variant variant;\n\n\tif (looks_like_command_line_option(ssh_host))\n\t\tdie(_(\"strange hostname '%s' blocked\"), ssh_host);\n\n\tssh = get_ssh_command();\n\tif (ssh) {\n\t\tvariant = determine_ssh_variant(ssh, 1);\n\t} else {\n\t\t/*\n\t\t * GIT_SSH is the no-shell version of\n\t\t * GIT_SSH_COMMAND (and must remain so for\n\t\t * historical compatibility).\n\t\t */\n\t\tconn->use_shell = 0;\n\n\t\tssh = getenv(\"GIT_SSH\");\n\t\tif (!ssh)\n\t\t\tssh = \"ssh\";\n\t\tvariant = determine_ssh_variant(ssh, 0);\n\t}\n\n\tif (variant == VARIANT_AUTO) {\n\t\tstruct child_process detect = CHILD_PROCESS_INIT;\n\n\t\tdetect.use_shell = conn->use_shell;\n\t\tdetect.no_stdin = detect.no_stdout = detect.no_stderr = 1;\n\n\t\targv_array_push(&detect.args, ssh);\n\t\targv_array_push(&detect.args, \"-G\");\n\t\tpush_ssh_options(&detect.args, &detect.env_array,\n\t\t\t\t VARIANT_SSH, port, version, flags);\n\t\targv_array_push(&detect.args, ssh_host);\n\n\t\tvariant = run_command(&detect) ? VARIANT_SIMPLE : VARIANT_SSH;\n\t}\n\n\targv_array_push(&conn->args, ssh);\n\tpush_ssh_options(&conn->args, &conn->env_array, variant, port, version, flags);\n\targv_array_push(&conn->args, ssh_host);\n}\n\n/*\n * This returns the dummy child_process `no_fork` if the transport protocol\n * does not need fork(2), or a struct child_process object if it does.  Once\n * done, finish the connection with finish_connect() with the value returned\n * from this function (it is safe to call finish_connect() with NULL to\n * support the former case).\n *\n * If it returns, the connect is successful; it just dies on errors (this\n * will hopefully be changed in a libification effort, to return NULL when\n * the connection failed).\n */\nstruct child_process *git_connect(int fd[2], const char *url,\n\t\t\t\t  const char *prog, int flags)\n{\n\tchar *hostandport, *path;\n\tstruct child_process *conn;\n\tenum protocol protocol;\n\tenum protocol_version version = get_protocol_version_config();\n\n\t/*\n\t * NEEDSWORK: If we are trying to use protocol v2 and we are planning\n\t * to perform a push, then fallback to v0 since the client doesn't know\n\t * how to push yet using v2.\n\t */\n\tif (version == protocol_v2 && !strcmp(\"git-receive-pack\", prog))\n\t\tversion = protocol_v0;\n\n\t/* Without this we cannot rely on waitpid() to tell\n\t * what happened to our children.\n\t */\n\tsignal(SIGCHLD, SIG_DFL);\n\n\tprotocol = parse_connect_url(url, &hostandport, &path);\n\tif ((flags & CONNECT_DIAG_URL) && (protocol != PROTO_SSH)) {\n\t\tprintf(\"Diag: url=%s\\n\", url ? url : \"NULL\");\n\t\tprintf(\"Diag: protocol=%s\\n\", prot_name(protocol));\n\t\tprintf(\"Diag: hostandport=%s\\n\", hostandport ? hostandport : \"NULL\");\n\t\tprintf(\"Diag: path=%s\\n\", path ? path : \"NULL\");\n\t\tconn = NULL;\n\t} else if (protocol == PROTO_GIT) {\n\t\tconn = git_connect_git(fd, hostandport, path, prog, version, flags);\n\t} else {\n\t\tstruct strbuf cmd = STRBUF_INIT;\n\t\tconst char *const *var;\n\n\t\tconn = xmalloc(sizeof(*conn));\n\t\tchild_process_init(conn);\n\n\t\tif (looks_like_command_line_option(path))\n\t\t\tdie(_(\"strange pathname '%s' blocked\"), path);\n\n\t\tstrbuf_addstr(&cmd, prog);\n\t\tstrbuf_addch(&cmd, ' ');\n\t\tsq_quote_buf(&cmd, path);\n\n\t\t/* remove repo-local variables from the environment */\n\t\tfor (var = local_repo_env; *var; var++)\n\t\t\targv_array_push(&conn->env_array, *var);\n\n\t\tconn->use_shell = 1;\n\t\tconn->in = conn->out = -1;\n\t\tif (protocol == PROTO_SSH) {\n\t\t\tchar *ssh_host = hostandport;\n\t\t\tconst char *port = NULL;\n\t\t\ttransport_check_allowed(\"ssh\");\n\t\t\tget_host_and_port(&ssh_host, &port);\n\n\t\t\tif (!port)\n\t\t\t\tport = get_port(ssh_host);\n\n\t\t\tif (flags & CONNECT_DIAG_URL) {\n\t\t\t\tprintf(\"Diag: url=%s\\n\", url ? url : \"NULL\");\n\t\t\t\tprintf(\"Diag: protocol=%s\\n\", prot_name(protocol));\n\t\t\t\tprintf(\"Diag: userandhost=%s\\n\", ssh_host ? ssh_host : \"NULL\");\n\t\t\t\tprintf(\"Diag: port=%s\\n\", port ? port : \"NONE\");\n\t\t\t\tprintf(\"Diag: path=%s\\n\", path ? path : \"NULL\");\n\n\t\t\t\tfree(hostandport);\n\t\t\t\tfree(path);\n\t\t\t\tfree(conn);\n\t\t\t\tstrbuf_release(&cmd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfill_ssh_args(conn, ssh_host, port, version, flags);\n\t\t} else {\n\t\t\ttransport_check_allowed(\"file\");\n\t\t\tif (version > 0) {\n\t\t\t\targv_array_pushf(&conn->env_array, GIT_PROTOCOL_ENVIRONMENT \"=version=%d\",\n\t\t\t\t\t\t version);\n\t\t\t}\n\t\t}\n\t\targv_array_push(&conn->args, cmd.buf);\n\n\t\tif (start_command(conn))\n\t\t\tdie(_(\"unable to fork\"));\n\n\t\tfd[0] = conn->out; /* read from child's stdout */\n\t\tfd[1] = conn->in;  /* write to child's stdin */\n\t\tstrbuf_release(&cmd);\n\t}\n\tfree(hostandport);\n\tfree(path);\n\treturn conn;\n}\n\nint finish_connect(struct child_process *conn)\n{\n\tint code;\n\tif (!conn || git_connection_is_socket(conn))\n\t\treturn 0;\n\n\tcode = finish_command(conn);\n\tfree(conn);\n\treturn code;\n}\n", "#!/bin/sh\n\ntest_description='test fetching over git protocol'\n. ./test-lib.sh\n\n. \"$TEST_DIRECTORY\"/lib-git-daemon.sh\nstart_git_daemon\n\ncheck_verbose_connect () {\n\ttest_i18ngrep -F \"Looking up 127.0.0.1 ...\" stderr &&\n\ttest_i18ngrep -F \"Connecting to 127.0.0.1 (port \" stderr &&\n\ttest_i18ngrep -F \"done.\" stderr\n}\n\ntest_expect_success 'setup repository' '\n\tgit config push.default matching &&\n\techo content >file &&\n\tgit add file &&\n\tgit commit -m one\n'\n\ntest_expect_success 'create git-accessible bare repository' '\n\tmkdir \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t git --bare init &&\n\t : >git-daemon-export-ok\n\t) &&\n\tgit remote add public \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\" &&\n\tgit push public master:master\n'\n\ntest_expect_success 'clone git repository' '\n\tgit clone -v \"$GIT_DAEMON_URL/repo.git\" clone 2>stderr &&\n\tcheck_verbose_connect &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'fetch changes via git protocol' '\n\techo content >>file &&\n\tgit commit -a -m two &&\n\tgit push public &&\n\t(cd clone && git pull -v) 2>stderr &&\n\tcheck_verbose_connect &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'no-op fetch -v stderr is as expected' '\n\t(cd clone && git fetch -v) 2>stderr &&\n\tcheck_verbose_connect\n'\n\ntest_expect_success 'no-op fetch without \"-v\" is quiet' '\n\t(cd clone && git fetch 2>../stderr) &&\n\ttest_must_be_empty stderr\n'\n\ntest_expect_success 'remote detects correct HEAD' '\n\tgit push public master:other &&\n\t(cd clone &&\n\t git remote set-head -d origin &&\n\t git remote set-head -a origin &&\n\t git symbolic-ref refs/remotes/origin/HEAD > output &&\n\t echo refs/remotes/origin/master > expect &&\n\t test_cmp expect output\n\t)\n'\n\ntest_expect_success 'prepare pack objects' '\n\tcp -R \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo.git \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t git --bare repack -a -d\n\t)\n'\n\ntest_expect_success 'fetch notices corrupt pack' '\n\tcp -R \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t p=$(ls objects/pack/pack-*.pack) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad1.git &&\n\t(cd repo_bad1.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch \"$GIT_DAEMON_URL/repo_bad1.git\" &&\n\t test 0 = $(ls objects/pack/pack-*.pack | wc -l)\n\t)\n'\n\ntest_expect_success 'fetch notices corrupt idx' '\n\tcp -R \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t p=$(ls objects/pack/pack-*.idx) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad2.git &&\n\t(cd repo_bad2.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch \"$GIT_DAEMON_URL/repo_bad2.git\" &&\n\t test 0 = $(ls objects/pack | wc -l)\n\t)\n'\n\ntest_remote_error()\n{\n\tdo_export=YesPlease\n\twhile test $# -gt 0\n\tdo\n\t\tcase $1 in\n\t\t-x)\n\t\t\tshift\n\t\t\tchmod -x \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\"\n\t\t\t;;\n\t\t-n)\n\t\t\tshift\n\t\t\tdo_export=\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\tesac\n\tdone\n\n\tmsg=$1\n\tshift\n\tcmd=$1\n\tshift\n\trepo=$1\n\tshift || error \"invalid number of arguments\"\n\n\tif test -x \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/$repo\"\n\tthen\n\t\tif test -n \"$do_export\"\n\t\tthen\n\t\t\t: >\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/$repo/git-daemon-export-ok\"\n\t\telse\n\t\t\trm -f \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/$repo/git-daemon-export-ok\"\n\t\tfi\n\tfi\n\n\ttest_must_fail git \"$cmd\" \"$GIT_DAEMON_URL/$repo\" \"$@\" 2>output &&\n\ttest_i18ngrep \"fatal: remote error: $msg: /$repo\" output &&\n\tret=$?\n\tchmod +x \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\"\n\t(exit $ret)\n}\n\nmsg=\"access denied or repository not exported\"\ntest_expect_success 'clone non-existent' \"test_remote_error    '$msg' clone nowhere.git    \"\ntest_expect_success 'push disabled'      \"test_remote_error    '$msg' push  repo.git master\"\ntest_expect_success 'read access denied' \"test_remote_error -x '$msg' fetch repo.git       \"\ntest_expect_success 'not exported'       \"test_remote_error -n '$msg' fetch repo.git       \"\n\nstop_git_daemon\nstart_git_daemon --informative-errors\n\ntest_expect_success 'clone non-existent' \"test_remote_error    'no such repository'      clone nowhere.git    \"\ntest_expect_success 'push disabled'      \"test_remote_error    'service not enabled'     push  repo.git master\"\ntest_expect_success 'read access denied' \"test_remote_error -x 'no such repository'      fetch repo.git       \"\ntest_expect_success 'not exported'       \"test_remote_error -n 'repository not exported' fetch repo.git       \"\n\nstop_git_daemon\nstart_git_daemon --interpolated-path=\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/%H%D\"\n\ntest_expect_success 'access repo via interpolated hostname' '\n\trepo=\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/localhost/interp.git\" &&\n\tgit init --bare \"$repo\" &&\n\tgit push \"$repo\" HEAD &&\n\t>\"$repo\"/git-daemon-export-ok &&\n\tGIT_OVERRIDE_VIRTUAL_HOST=localhost \\\n\t\tgit ls-remote \"$GIT_DAEMON_URL/interp.git\" &&\n\tGIT_OVERRIDE_VIRTUAL_HOST=LOCALHOST \\\n\t\tgit ls-remote \"$GIT_DAEMON_URL/interp.git\"\n'\n\ntest_expect_success 'hostname cannot break out of directory' '\n\trepo=\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/../escape.git\" &&\n\tgit init --bare \"$repo\" &&\n\tgit push \"$repo\" HEAD &&\n\t>\"$repo\"/git-daemon-export-ok &&\n\ttest_must_fail \\\n\t\tenv GIT_OVERRIDE_VIRTUAL_HOST=.. \\\n\t\tgit ls-remote \"$GIT_DAEMON_URL/escape.git\"\n'\n\ntest_expect_success 'daemon log records all attributes' '\n\tcat >expect <<-\\EOF &&\n\tExtended attribute \"host\": localhost\n\tExtended attribute \"protocol\": version=1\n\tEOF\n\t>daemon.log &&\n\tGIT_OVERRIDE_VIRTUAL_HOST=localhost \\\n\t\tgit -c protocol.version=1 \\\n\t\t\tls-remote \"$GIT_DAEMON_URL/interp.git\" &&\n\tgrep -i extended.attribute daemon.log | cut -d\" \" -f2- >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success FAKENC 'hostname interpolation works after LF-stripping' '\n\t{\n\t\tprintf \"git-upload-pack /interp.git\\n\\0host=localhost\" | packetize\n\t\tprintf \"0000\"\n\t} >input &&\n\tfake_nc \"$GIT_DAEMON_HOST_PORT\" <input >output &&\n\tdepacketize <output >output.raw &&\n\n\t# just pick out the value of master, which avoids any protocol\n\t# particulars\n\tperl -lne \"print \\$1 if m{^(\\\\S+) refs/heads/master}\" <output.raw >actual &&\n\tgit -C \"$repo\" rev-parse master >expect &&\n\ttest_cmp expect actual\n'\n\nstop_git_daemon\ntest_done\n"], "fixing_code": ["#include \"git-compat-util.h\"\n#include \"cache.h\"\n#include \"config.h\"\n#include \"pkt-line.h\"\n#include \"quote.h\"\n#include \"refs.h\"\n#include \"run-command.h\"\n#include \"remote.h\"\n#include \"connect.h\"\n#include \"url.h\"\n#include \"string-list.h\"\n#include \"sha1-array.h\"\n#include \"transport.h\"\n#include \"strbuf.h\"\n#include \"version.h\"\n#include \"protocol.h\"\n#include \"alias.h\"\n\nstatic char *server_capabilities_v1;\nstatic struct argv_array server_capabilities_v2 = ARGV_ARRAY_INIT;\nstatic const char *parse_feature_value(const char *, const char *, int *);\n\nstatic int check_ref(const char *name, unsigned int flags)\n{\n\tif (!flags)\n\t\treturn 1;\n\n\tif (!skip_prefix(name, \"refs/\", &name))\n\t\treturn 0;\n\n\t/* REF_NORMAL means that we don't want the magic fake tag refs */\n\tif ((flags & REF_NORMAL) && check_refname_format(name, 0))\n\t\treturn 0;\n\n\t/* REF_HEADS means that we want regular branch heads */\n\tif ((flags & REF_HEADS) && starts_with(name, \"heads/\"))\n\t\treturn 1;\n\n\t/* REF_TAGS means that we want tags */\n\tif ((flags & REF_TAGS) && starts_with(name, \"tags/\"))\n\t\treturn 1;\n\n\t/* All type bits clear means that we are ok with anything */\n\treturn !(flags & ~REF_NORMAL);\n}\n\nint check_ref_type(const struct ref *ref, int flags)\n{\n\treturn check_ref(ref->name, flags);\n}\n\nstatic NORETURN void die_initial_contact(int unexpected)\n{\n\t/*\n\t * A hang-up after seeing some response from the other end\n\t * means that it is unexpected, as we know the other end is\n\t * willing to talk to us.  A hang-up before seeing any\n\t * response does not necessarily mean an ACL problem, though.\n\t */\n\tif (unexpected)\n\t\tdie(_(\"the remote end hung up upon initial contact\"));\n\telse\n\t\tdie(_(\"Could not read from remote repository.\\n\\n\"\n\t\t      \"Please make sure you have the correct access rights\\n\"\n\t\t      \"and the repository exists.\"));\n}\n\n/* Checks if the server supports the capability 'c' */\nint server_supports_v2(const char *c, int die_on_error)\n{\n\tint i;\n\n\tfor (i = 0; i < server_capabilities_v2.argc; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.argv[i], c, &out) &&\n\t\t    (!*out || *out == '='))\n\t\t\treturn 1;\n\t}\n\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support '%s'\"), c);\n\n\treturn 0;\n}\n\nint server_supports_feature(const char *c, const char *feature,\n\t\t\t    int die_on_error)\n{\n\tint i;\n\n\tfor (i = 0; i < server_capabilities_v2.argc; i++) {\n\t\tconst char *out;\n\t\tif (skip_prefix(server_capabilities_v2.argv[i], c, &out) &&\n\t\t    (!*out || *(out++) == '=')) {\n\t\t\tif (parse_feature_request(out, feature))\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (die_on_error)\n\t\tdie(_(\"server doesn't support feature '%s'\"), feature);\n\n\treturn 0;\n}\n\nstatic void process_capabilities_v2(struct packet_reader *reader)\n{\n\twhile (packet_reader_read(reader) == PACKET_READ_NORMAL)\n\t\targv_array_push(&server_capabilities_v2, reader->line);\n\n\tif (reader->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"expected flush after capabilities\"));\n}\n\nenum protocol_version discover_version(struct packet_reader *reader)\n{\n\tenum protocol_version version = protocol_unknown_version;\n\n\t/*\n\t * Peek the first line of the server's response to\n\t * determine the protocol version the server is speaking.\n\t */\n\tswitch (packet_reader_peek(reader)) {\n\tcase PACKET_READ_EOF:\n\t\tdie_initial_contact(0);\n\tcase PACKET_READ_FLUSH:\n\tcase PACKET_READ_DELIM:\n\t\tversion = protocol_v0;\n\t\tbreak;\n\tcase PACKET_READ_NORMAL:\n\t\tversion = determine_protocol_version_client(reader->line);\n\t\tbreak;\n\t}\n\n\tswitch (version) {\n\tcase protocol_v2:\n\t\tprocess_capabilities_v2(reader);\n\t\tbreak;\n\tcase protocol_v1:\n\t\t/* Read the peeked version line */\n\t\tpacket_reader_read(reader);\n\t\tbreak;\n\tcase protocol_v0:\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\n\treturn version;\n}\n\nstatic void parse_one_symref_info(struct string_list *symref, const char *val, int len)\n{\n\tchar *sym, *target;\n\tstruct string_list_item *item;\n\n\tif (!len)\n\t\treturn; /* just \"symref\" */\n\t/* e.g. \"symref=HEAD:refs/heads/master\" */\n\tsym = xmemdupz(val, len);\n\ttarget = strchr(sym, ':');\n\tif (!target)\n\t\t/* just \"symref=something\" */\n\t\tgoto reject;\n\t*(target++) = '\\0';\n\tif (check_refname_format(sym, REFNAME_ALLOW_ONELEVEL) ||\n\t    check_refname_format(target, REFNAME_ALLOW_ONELEVEL))\n\t\t/* \"symref=bogus:pair */\n\t\tgoto reject;\n\titem = string_list_append_nodup(symref, sym);\n\titem->util = target;\n\treturn;\nreject:\n\tfree(sym);\n\treturn;\n}\n\nstatic void annotate_refs_with_symref_info(struct ref *ref)\n{\n\tstruct string_list symref = STRING_LIST_INIT_DUP;\n\tconst char *feature_list = server_capabilities_v1;\n\n\twhile (feature_list) {\n\t\tint len;\n\t\tconst char *val;\n\n\t\tval = parse_feature_value(feature_list, \"symref\", &len);\n\t\tif (!val)\n\t\t\tbreak;\n\t\tparse_one_symref_info(&symref, val, len);\n\t\tfeature_list = val + 1;\n\t}\n\tstring_list_sort(&symref);\n\n\tfor (; ref; ref = ref->next) {\n\t\tstruct string_list_item *item;\n\t\titem = string_list_lookup(&symref, ref->name);\n\t\tif (!item)\n\t\t\tcontinue;\n\t\tref->symref = xstrdup((char *)item->util);\n\t}\n\tstring_list_clear(&symref, 0);\n}\n\nstatic void process_capabilities(const char *line, int *len)\n{\n\tint nul_location = strlen(line);\n\tif (nul_location == *len)\n\t\treturn;\n\tserver_capabilities_v1 = xstrdup(line + nul_location + 1);\n\t*len = nul_location;\n}\n\nstatic int process_dummy_ref(const char *line)\n{\n\tstruct object_id oid;\n\tconst char *name;\n\n\tif (parse_oid_hex(line, &oid, &name))\n\t\treturn 0;\n\tif (*name != ' ')\n\t\treturn 0;\n\tname++;\n\n\treturn oideq(&null_oid, &oid) && !strcmp(name, \"capabilities^{}\");\n}\n\nstatic void check_no_capabilities(const char *line, int len)\n{\n\tif (strlen(line) != len)\n\t\twarning(_(\"ignoring capabilities after first line '%s'\"),\n\t\t\tline + strlen(line));\n}\n\nstatic int process_ref(const char *line, int len, struct ref ***list,\n\t\t       unsigned int flags, struct oid_array *extra_have)\n{\n\tstruct object_id old_oid;\n\tconst char *name;\n\n\tif (parse_oid_hex(line, &old_oid, &name))\n\t\treturn 0;\n\tif (*name != ' ')\n\t\treturn 0;\n\tname++;\n\n\tif (extra_have && !strcmp(name, \".have\")) {\n\t\toid_array_append(extra_have, &old_oid);\n\t} else if (!strcmp(name, \"capabilities^{}\")) {\n\t\tdie(_(\"protocol error: unexpected capabilities^{}\"));\n\t} else if (check_ref(name, flags)) {\n\t\tstruct ref *ref = alloc_ref(name);\n\t\toidcpy(&ref->old_oid, &old_oid);\n\t\t**list = ref;\n\t\t*list = &ref->next;\n\t}\n\tcheck_no_capabilities(line, len);\n\treturn 1;\n}\n\nstatic int process_shallow(const char *line, int len,\n\t\t\t   struct oid_array *shallow_points)\n{\n\tconst char *arg;\n\tstruct object_id old_oid;\n\n\tif (!skip_prefix(line, \"shallow \", &arg))\n\t\treturn 0;\n\n\tif (get_oid_hex(arg, &old_oid))\n\t\tdie(_(\"protocol error: expected shallow sha-1, got '%s'\"), arg);\n\tif (!shallow_points)\n\t\tdie(_(\"repository on the other end cannot be shallow\"));\n\toid_array_append(shallow_points, &old_oid);\n\tcheck_no_capabilities(line, len);\n\treturn 1;\n}\n\nenum get_remote_heads_state {\n\tEXPECTING_FIRST_REF = 0,\n\tEXPECTING_REF,\n\tEXPECTING_SHALLOW,\n\tEXPECTING_DONE,\n};\n\n/*\n * Read all the refs from the other end\n */\nstruct ref **get_remote_heads(struct packet_reader *reader,\n\t\t\t      struct ref **list, unsigned int flags,\n\t\t\t      struct oid_array *extra_have,\n\t\t\t      struct oid_array *shallow_points)\n{\n\tstruct ref **orig_list = list;\n\tint len = 0;\n\tenum get_remote_heads_state state = EXPECTING_FIRST_REF;\n\tconst char *arg;\n\n\t*list = NULL;\n\n\twhile (state != EXPECTING_DONE) {\n\t\tswitch (packet_reader_read(reader)) {\n\t\tcase PACKET_READ_EOF:\n\t\t\tdie_initial_contact(1);\n\t\tcase PACKET_READ_NORMAL:\n\t\t\tlen = reader->pktlen;\n\t\t\tif (len > 4 && skip_prefix(reader->line, \"ERR \", &arg))\n\t\t\t\tdie(_(\"remote error: %s\"), arg);\n\t\t\tbreak;\n\t\tcase PACKET_READ_FLUSH:\n\t\t\tstate = EXPECTING_DONE;\n\t\t\tbreak;\n\t\tcase PACKET_READ_DELIM:\n\t\t\tdie(_(\"invalid packet\"));\n\t\t}\n\n\t\tswitch (state) {\n\t\tcase EXPECTING_FIRST_REF:\n\t\t\tprocess_capabilities(reader->line, &len);\n\t\t\tif (process_dummy_ref(reader->line)) {\n\t\t\t\tstate = EXPECTING_SHALLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate = EXPECTING_REF;\n\t\t\t/* fallthrough */\n\t\tcase EXPECTING_REF:\n\t\t\tif (process_ref(reader->line, len, &list, flags, extra_have))\n\t\t\t\tbreak;\n\t\t\tstate = EXPECTING_SHALLOW;\n\t\t\t/* fallthrough */\n\t\tcase EXPECTING_SHALLOW:\n\t\t\tif (process_shallow(reader->line, len, shallow_points))\n\t\t\t\tbreak;\n\t\t\tdie(_(\"protocol error: unexpected '%s'\"), reader->line);\n\t\tcase EXPECTING_DONE:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tannotate_refs_with_symref_info(*orig_list);\n\n\treturn list;\n}\n\n/* Returns 1 when a valid ref has been added to `list`, 0 otherwise */\nstatic int process_ref_v2(const char *line, struct ref ***list)\n{\n\tint ret = 1;\n\tint i = 0;\n\tstruct object_id old_oid;\n\tstruct ref *ref;\n\tstruct string_list line_sections = STRING_LIST_INIT_DUP;\n\tconst char *end;\n\n\t/*\n\t * Ref lines have a number of fields which are space deliminated.  The\n\t * first field is the OID of the ref.  The second field is the ref\n\t * name.  Subsequent fields (symref-target and peeled) are optional and\n\t * don't have a particular order.\n\t */\n\tif (string_list_split(&line_sections, line, ' ', -1) < 2) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (parse_oid_hex(line_sections.items[i++].string, &old_oid, &end) ||\n\t    *end) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tref = alloc_ref(line_sections.items[i++].string);\n\n\toidcpy(&ref->old_oid, &old_oid);\n\t**list = ref;\n\t*list = &ref->next;\n\n\tfor (; i < line_sections.nr; i++) {\n\t\tconst char *arg = line_sections.items[i].string;\n\t\tif (skip_prefix(arg, \"symref-target:\", &arg))\n\t\t\tref->symref = xstrdup(arg);\n\n\t\tif (skip_prefix(arg, \"peeled:\", &arg)) {\n\t\t\tstruct object_id peeled_oid;\n\t\t\tchar *peeled_name;\n\t\t\tstruct ref *peeled;\n\t\t\tif (parse_oid_hex(arg, &peeled_oid, &end) || *end) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tpeeled_name = xstrfmt(\"%s^{}\", ref->name);\n\t\t\tpeeled = alloc_ref(peeled_name);\n\n\t\t\toidcpy(&peeled->old_oid, &peeled_oid);\n\t\t\t**list = peeled;\n\t\t\t*list = &peeled->next;\n\n\t\t\tfree(peeled_name);\n\t\t}\n\t}\n\nout:\n\tstring_list_clear(&line_sections, 0);\n\treturn ret;\n}\n\nstruct ref **get_remote_refs(int fd_out, struct packet_reader *reader,\n\t\t\t     struct ref **list, int for_push,\n\t\t\t     const struct argv_array *ref_prefixes,\n\t\t\t     const struct string_list *server_options)\n{\n\tint i;\n\t*list = NULL;\n\n\tif (server_supports_v2(\"ls-refs\", 1))\n\t\tpacket_write_fmt(fd_out, \"command=ls-refs\\n\");\n\n\tif (server_supports_v2(\"agent\", 0))\n\t\tpacket_write_fmt(fd_out, \"agent=%s\", git_user_agent_sanitized());\n\n\tif (server_options && server_options->nr &&\n\t    server_supports_v2(\"server-option\", 1))\n\t\tfor (i = 0; i < server_options->nr; i++)\n\t\t\tpacket_write_fmt(fd_out, \"server-option=%s\",\n\t\t\t\t\t server_options->items[i].string);\n\n\tpacket_delim(fd_out);\n\t/* When pushing we don't want to request the peeled tags */\n\tif (!for_push)\n\t\tpacket_write_fmt(fd_out, \"peel\\n\");\n\tpacket_write_fmt(fd_out, \"symrefs\\n\");\n\tfor (i = 0; ref_prefixes && i < ref_prefixes->argc; i++) {\n\t\tpacket_write_fmt(fd_out, \"ref-prefix %s\\n\",\n\t\t\t\t ref_prefixes->argv[i]);\n\t}\n\tpacket_flush(fd_out);\n\n\t/* Process response from server */\n\twhile (packet_reader_read(reader) == PACKET_READ_NORMAL) {\n\t\tif (!process_ref_v2(reader->line, &list))\n\t\t\tdie(_(\"invalid ls-refs response: %s\"), reader->line);\n\t}\n\n\tif (reader->status != PACKET_READ_FLUSH)\n\t\tdie(_(\"expected flush after ref listing\"));\n\n\treturn list;\n}\n\nstatic const char *parse_feature_value(const char *feature_list, const char *feature, int *lenp)\n{\n\tint len;\n\n\tif (!feature_list)\n\t\treturn NULL;\n\n\tlen = strlen(feature);\n\twhile (*feature_list) {\n\t\tconst char *found = strstr(feature_list, feature);\n\t\tif (!found)\n\t\t\treturn NULL;\n\t\tif (feature_list == found || isspace(found[-1])) {\n\t\t\tconst char *value = found + len;\n\t\t\t/* feature with no value (e.g., \"thin-pack\") */\n\t\t\tif (!*value || isspace(*value)) {\n\t\t\t\tif (lenp)\n\t\t\t\t\t*lenp = 0;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t/* feature with a value (e.g., \"agent=git/1.2.3\") */\n\t\t\telse if (*value == '=') {\n\t\t\t\tvalue++;\n\t\t\t\tif (lenp)\n\t\t\t\t\t*lenp = strcspn(value, \" \\t\\n\");\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\t/*\n\t\t\t * otherwise we matched a substring of another feature;\n\t\t\t * keep looking\n\t\t\t */\n\t\t}\n\t\tfeature_list = found + 1;\n\t}\n\treturn NULL;\n}\n\nint parse_feature_request(const char *feature_list, const char *feature)\n{\n\treturn !!parse_feature_value(feature_list, feature, NULL);\n}\n\nconst char *server_feature_value(const char *feature, int *len)\n{\n\treturn parse_feature_value(server_capabilities_v1, feature, len);\n}\n\nint server_supports(const char *feature)\n{\n\treturn !!server_feature_value(feature, NULL);\n}\n\nenum protocol {\n\tPROTO_LOCAL = 1,\n\tPROTO_FILE,\n\tPROTO_SSH,\n\tPROTO_GIT\n};\n\nint url_is_local_not_ssh(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon) ||\n\t\t(has_dos_drive_prefix(url) && is_valid_path(url));\n}\n\nstatic const char *prot_name(enum protocol protocol)\n{\n\tswitch (protocol) {\n\t\tcase PROTO_LOCAL:\n\t\tcase PROTO_FILE:\n\t\t\treturn \"file\";\n\t\tcase PROTO_SSH:\n\t\t\treturn \"ssh\";\n\t\tcase PROTO_GIT:\n\t\t\treturn \"git\";\n\t\tdefault:\n\t\t\treturn \"unknown protocol\";\n\t}\n}\n\nstatic enum protocol get_protocol(const char *name)\n{\n\tif (!strcmp(name, \"ssh\"))\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"git\"))\n\t\treturn PROTO_GIT;\n\tif (!strcmp(name, \"git+ssh\")) /* deprecated - do not use */\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"ssh+git\")) /* deprecated - do not use */\n\t\treturn PROTO_SSH;\n\tif (!strcmp(name, \"file\"))\n\t\treturn PROTO_FILE;\n\tdie(_(\"protocol '%s' is not supported\"), name);\n}\n\nstatic char *host_end(char **hoststart, int removebrackets)\n{\n\tchar *host = *hoststart;\n\tchar *end;\n\tchar *start = strstr(host, \"@[\");\n\tif (start)\n\t\tstart++; /* Jump over '@' */\n\telse\n\t\tstart = host;\n\tif (start[0] == '[') {\n\t\tend = strchr(start + 1, ']');\n\t\tif (end) {\n\t\t\tif (removebrackets) {\n\t\t\t\t*end = 0;\n\t\t\t\tmemmove(start, start + 1, end - start);\n\t\t\t\tend++;\n\t\t\t}\n\t\t} else\n\t\t\tend = host;\n\t} else\n\t\tend = host;\n\treturn end;\n}\n\n#define STR_(s)\t# s\n#define STR(s)\tSTR_(s)\n\nstatic void get_host_and_port(char **host, const char **port)\n{\n\tchar *colon, *end;\n\tend = host_end(host, 1);\n\tcolon = strchr(end, ':');\n\tif (colon) {\n\t\tlong portnr = strtol(colon + 1, &end, 10);\n\t\tif (end != colon + 1 && *end == '\\0' && 0 <= portnr && portnr < 65536) {\n\t\t\t*colon = 0;\n\t\t\t*port = colon + 1;\n\t\t} else if (!colon[1]) {\n\t\t\t*colon = 0;\n\t\t}\n\t}\n}\n\nstatic void enable_keepalive(int sockfd)\n{\n\tint ka = 1;\n\n\tif (setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, &ka, sizeof(ka)) < 0)\n\t\terror_errno(_(\"unable to set SO_KEEPALIVE on socket\"));\n}\n\n#ifndef NO_IPV6\n\nstatic const char *ai_name(const struct addrinfo *ai)\n{\n\tstatic char addr[NI_MAXHOST];\n\tif (getnameinfo(ai->ai_addr, ai->ai_addrlen, addr, sizeof(addr), NULL, 0,\n\t\t\tNI_NUMERICHOST) != 0)\n\t\txsnprintf(addr, sizeof(addr), \"(unknown)\");\n\n\treturn addr;\n}\n\n/*\n * Returns a connected socket() fd, or else die()s.\n */\nstatic int git_tcp_connect_sock(char *host, int flags)\n{\n\tstruct strbuf error_message = STRBUF_INIT;\n\tint sockfd = -1;\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tstruct addrinfo hints, *ai0, *ai;\n\tint gai;\n\tint cnt = 0;\n\n\tget_host_and_port(&host, &port);\n\tif (!*port)\n\t\tport = \"<none>\";\n\n\tmemset(&hints, 0, sizeof(hints));\n\tif (flags & CONNECT_IPV4)\n\t\thints.ai_family = AF_INET;\n\telse if (flags & CONNECT_IPV6)\n\t\thints.ai_family = AF_INET6;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\tif (flags & CONNECT_VERBOSE)\n\t\tfprintf(stderr, _(\"Looking up %s ... \"), host);\n\n\tgai = getaddrinfo(host, port, &hints, &ai);\n\tif (gai)\n\t\tdie(_(\"unable to look up %s (port %s) (%s)\"), host, port, gai_strerror(gai));\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Looking up %s ... \" */\n\t\tfprintf(stderr, _(\"done.\\nConnecting to %s (port %s) ... \"), host, port);\n\n\tfor (ai0 = ai; ai; ai = ai->ai_next, cnt++) {\n\t\tsockfd = socket(ai->ai_family,\n\t\t\t\tai->ai_socktype, ai->ai_protocol);\n\t\tif ((sockfd < 0) ||\n\t\t    (connect(sockfd, ai->ai_addr, ai->ai_addrlen) < 0)) {\n\t\t\tstrbuf_addf(&error_message, \"%s[%d: %s]: errno=%s\\n\",\n\t\t\t\t    host, cnt, ai_name(ai), strerror(errno));\n\t\t\tif (0 <= sockfd)\n\t\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags & CONNECT_VERBOSE)\n\t\t\tfprintf(stderr, \"%s \", ai_name(ai));\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo(ai0);\n\n\tif (sockfd < 0)\n\t\tdie(_(\"unable to connect to %s:\\n%s\"), host, error_message.buf);\n\n\tenable_keepalive(sockfd);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Connecting to %s (port %s) ... \" */\n\t\tfprintf_ln(stderr, _(\"done.\"));\n\n\tstrbuf_release(&error_message);\n\n\treturn sockfd;\n}\n\n#else /* NO_IPV6 */\n\n/*\n * Returns a connected socket() fd, or else die()s.\n */\nstatic int git_tcp_connect_sock(char *host, int flags)\n{\n\tstruct strbuf error_message = STRBUF_INIT;\n\tint sockfd = -1;\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tchar *ep;\n\tstruct hostent *he;\n\tstruct sockaddr_in sa;\n\tchar **ap;\n\tunsigned int nport;\n\tint cnt;\n\n\tget_host_and_port(&host, &port);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\tfprintf(stderr, _(\"Looking up %s ... \"), host);\n\n\the = gethostbyname(host);\n\tif (!he)\n\t\tdie(_(\"unable to look up %s (%s)\"), host, hstrerror(h_errno));\n\tnport = strtoul(port, &ep, 10);\n\tif ( ep == port || *ep ) {\n\t\t/* Not numeric */\n\t\tstruct servent *se = getservbyname(port,\"tcp\");\n\t\tif ( !se )\n\t\t\tdie(_(\"unknown port %s\"), port);\n\t\tnport = se->s_port;\n\t}\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Looking up %s ... \" */\n\t\tfprintf(stderr, _(\"done.\\nConnecting to %s (port %s) ... \"), host, port);\n\n\tfor (cnt = 0, ap = he->h_addr_list; *ap; ap++, cnt++) {\n\t\tmemset(&sa, 0, sizeof sa);\n\t\tsa.sin_family = he->h_addrtype;\n\t\tsa.sin_port = htons(nport);\n\t\tmemcpy(&sa.sin_addr, *ap, he->h_length);\n\n\t\tsockfd = socket(he->h_addrtype, SOCK_STREAM, 0);\n\t\tif ((sockfd < 0) ||\n\t\t    connect(sockfd, (struct sockaddr *)&sa, sizeof sa) < 0) {\n\t\t\tstrbuf_addf(&error_message, \"%s[%d: %s]: errno=%s\\n\",\n\t\t\t\thost,\n\t\t\t\tcnt,\n\t\t\t\tinet_ntoa(*(struct in_addr *)&sa.sin_addr),\n\t\t\t\tstrerror(errno));\n\t\t\tif (0 <= sockfd)\n\t\t\t\tclose(sockfd);\n\t\t\tsockfd = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (flags & CONNECT_VERBOSE)\n\t\t\tfprintf(stderr, \"%s \",\n\t\t\t\tinet_ntoa(*(struct in_addr *)&sa.sin_addr));\n\t\tbreak;\n\t}\n\n\tif (sockfd < 0)\n\t\tdie(_(\"unable to connect to %s:\\n%s\"), host, error_message.buf);\n\n\tenable_keepalive(sockfd);\n\n\tif (flags & CONNECT_VERBOSE)\n\t\t/* TRANSLATORS: this is the end of \"Connecting to %s (port %s) ... \" */\n\t\tfprintf_ln(stderr, _(\"done.\"));\n\n\treturn sockfd;\n}\n\n#endif /* NO_IPV6 */\n\n\n/*\n * Dummy child_process returned by git_connect() if the transport protocol\n * does not need fork(2).\n */\nstatic struct child_process no_fork = CHILD_PROCESS_INIT;\n\nint git_connection_is_socket(struct child_process *conn)\n{\n\treturn conn == &no_fork;\n}\n\nstatic struct child_process *git_tcp_connect(int fd[2], char *host, int flags)\n{\n\tint sockfd = git_tcp_connect_sock(host, flags);\n\n\tfd[0] = sockfd;\n\tfd[1] = dup(sockfd);\n\n\treturn &no_fork;\n}\n\n\nstatic char *git_proxy_command;\n\nstatic int git_proxy_command_options(const char *var, const char *value,\n\t\tvoid *cb)\n{\n\tif (!strcmp(var, \"core.gitproxy\")) {\n\t\tconst char *for_pos;\n\t\tint matchlen = -1;\n\t\tint hostlen;\n\t\tconst char *rhost_name = cb;\n\t\tint rhost_len = strlen(rhost_name);\n\n\t\tif (git_proxy_command)\n\t\t\treturn 0;\n\t\tif (!value)\n\t\t\treturn config_error_nonbool(var);\n\t\t/* [core]\n\t\t * ;# matches www.kernel.org as well\n\t\t * gitproxy = netcatter-1 for kernel.org\n\t\t * gitproxy = netcatter-2 for sample.xz\n\t\t * gitproxy = netcatter-default\n\t\t */\n\t\tfor_pos = strstr(value, \" for \");\n\t\tif (!for_pos)\n\t\t\t/* matches everybody */\n\t\t\tmatchlen = strlen(value);\n\t\telse {\n\t\t\thostlen = strlen(for_pos + 5);\n\t\t\tif (rhost_len < hostlen)\n\t\t\t\tmatchlen = -1;\n\t\t\telse if (!strncmp(for_pos + 5,\n\t\t\t\t\t  rhost_name + rhost_len - hostlen,\n\t\t\t\t\t  hostlen) &&\n\t\t\t\t ((rhost_len == hostlen) ||\n\t\t\t\t  rhost_name[rhost_len - hostlen -1] == '.'))\n\t\t\t\tmatchlen = for_pos - value;\n\t\t\telse\n\t\t\t\tmatchlen = -1;\n\t\t}\n\t\tif (0 <= matchlen) {\n\t\t\t/* core.gitproxy = none for kernel.org */\n\t\t\tif (matchlen == 4 &&\n\t\t\t    !memcmp(value, \"none\", 4))\n\t\t\t\tmatchlen = 0;\n\t\t\tgit_proxy_command = xmemdupz(value, matchlen);\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn git_default_config(var, value, cb);\n}\n\nstatic int git_use_proxy(const char *host)\n{\n\tgit_proxy_command = getenv(\"GIT_PROXY_COMMAND\");\n\tgit_config(git_proxy_command_options, (void*)host);\n\treturn (git_proxy_command && *git_proxy_command);\n}\n\nstatic struct child_process *git_proxy_connect(int fd[2], char *host)\n{\n\tconst char *port = STR(DEFAULT_GIT_PORT);\n\tstruct child_process *proxy;\n\n\tget_host_and_port(&host, &port);\n\n\tif (looks_like_command_line_option(host))\n\t\tdie(_(\"strange hostname '%s' blocked\"), host);\n\tif (looks_like_command_line_option(port))\n\t\tdie(_(\"strange port '%s' blocked\"), port);\n\n\tproxy = xmalloc(sizeof(*proxy));\n\tchild_process_init(proxy);\n\targv_array_push(&proxy->args, git_proxy_command);\n\targv_array_push(&proxy->args, host);\n\targv_array_push(&proxy->args, port);\n\tproxy->in = -1;\n\tproxy->out = -1;\n\tif (start_command(proxy))\n\t\tdie(_(\"cannot start proxy %s\"), git_proxy_command);\n\tfd[0] = proxy->out; /* read from proxy stdout */\n\tfd[1] = proxy->in;  /* write to proxy stdin */\n\treturn proxy;\n}\n\nstatic char *get_port(char *host)\n{\n\tchar *end;\n\tchar *p = strchr(host, ':');\n\n\tif (p) {\n\t\tlong port = strtol(p + 1, &end, 10);\n\t\tif (end != p + 1 && *end == '\\0' && 0 <= port && port < 65536) {\n\t\t\t*p = '\\0';\n\t\t\treturn p+1;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Extract protocol and relevant parts from the specified connection URL.\n * The caller must free() the returned strings.\n */\nstatic enum protocol parse_connect_url(const char *url_orig, char **ret_host,\n\t\t\t\t       char **ret_path)\n{\n\tchar *url;\n\tchar *host, *path;\n\tchar *end;\n\tint separator = '/';\n\tenum protocol protocol = PROTO_LOCAL;\n\n\tif (is_url(url_orig))\n\t\turl = url_decode(url_orig);\n\telse\n\t\turl = xstrdup(url_orig);\n\n\thost = strstr(url, \"://\");\n\tif (host) {\n\t\t*host = '\\0';\n\t\tprotocol = get_protocol(url);\n\t\thost += 3;\n\t} else {\n\t\thost = url;\n\t\tif (!url_is_local_not_ssh(url)) {\n\t\t\tprotocol = PROTO_SSH;\n\t\t\tseparator = ':';\n\t\t}\n\t}\n\n\t/*\n\t * Don't do destructive transforms as protocol code does\n\t * '[]' unwrapping in get_host_and_port()\n\t */\n\tend = host_end(&host, 0);\n\n\tif (protocol == PROTO_LOCAL)\n\t\tpath = end;\n\telse if (protocol == PROTO_FILE && has_dos_drive_prefix(end))\n\t\tpath = end; /* \"file://$(pwd)\" may be \"file://C:/projects/repo\" */\n\telse\n\t\tpath = strchr(end, separator);\n\n\tif (!path || !*path)\n\t\tdie(_(\"no path specified; see 'git help pull' for valid url syntax\"));\n\n\t/*\n\t * null-terminate hostname and point path to ~ for URL's like this:\n\t *    ssh://host.xz/~user/repo\n\t */\n\n\tend = path; /* Need to \\0 terminate host here */\n\tif (separator == ':')\n\t\tpath++; /* path starts after ':' */\n\tif (protocol == PROTO_GIT || protocol == PROTO_SSH) {\n\t\tif (path[1] == '~')\n\t\t\tpath++;\n\t}\n\n\tpath = xstrdup(path);\n\t*end = '\\0';\n\n\t*ret_host = xstrdup(host);\n\t*ret_path = path;\n\tfree(url);\n\treturn protocol;\n}\n\nstatic const char *get_ssh_command(void)\n{\n\tconst char *ssh;\n\n\tif ((ssh = getenv(\"GIT_SSH_COMMAND\")))\n\t\treturn ssh;\n\n\tif (!git_config_get_string_const(\"core.sshcommand\", &ssh))\n\t\treturn ssh;\n\n\treturn NULL;\n}\n\nenum ssh_variant {\n\tVARIANT_AUTO,\n\tVARIANT_SIMPLE,\n\tVARIANT_SSH,\n\tVARIANT_PLINK,\n\tVARIANT_PUTTY,\n\tVARIANT_TORTOISEPLINK,\n};\n\nstatic void override_ssh_variant(enum ssh_variant *ssh_variant)\n{\n\tconst char *variant = getenv(\"GIT_SSH_VARIANT\");\n\n\tif (!variant && git_config_get_string_const(\"ssh.variant\", &variant))\n\t\treturn;\n\n\tif (!strcmp(variant, \"auto\"))\n\t\t*ssh_variant = VARIANT_AUTO;\n\telse if (!strcmp(variant, \"plink\"))\n\t\t*ssh_variant = VARIANT_PLINK;\n\telse if (!strcmp(variant, \"putty\"))\n\t\t*ssh_variant = VARIANT_PUTTY;\n\telse if (!strcmp(variant, \"tortoiseplink\"))\n\t\t*ssh_variant = VARIANT_TORTOISEPLINK;\n\telse if (!strcmp(variant, \"simple\"))\n\t\t*ssh_variant = VARIANT_SIMPLE;\n\telse\n\t\t*ssh_variant = VARIANT_SSH;\n}\n\nstatic enum ssh_variant determine_ssh_variant(const char *ssh_command,\n\t\t\t\t\t      int is_cmdline)\n{\n\tenum ssh_variant ssh_variant = VARIANT_AUTO;\n\tconst char *variant;\n\tchar *p = NULL;\n\n\toverride_ssh_variant(&ssh_variant);\n\n\tif (ssh_variant != VARIANT_AUTO)\n\t\treturn ssh_variant;\n\n\tif (!is_cmdline) {\n\t\tp = xstrdup(ssh_command);\n\t\tvariant = basename(p);\n\t} else {\n\t\tconst char **ssh_argv;\n\n\t\tp = xstrdup(ssh_command);\n\t\tif (split_cmdline(p, &ssh_argv) > 0) {\n\t\t\tvariant = basename((char *)ssh_argv[0]);\n\t\t\t/*\n\t\t\t * At this point, variant points into the buffer\n\t\t\t * referenced by p, hence we do not need ssh_argv\n\t\t\t * any longer.\n\t\t\t */\n\t\t\tfree(ssh_argv);\n\t\t} else {\n\t\t\tfree(p);\n\t\t\treturn ssh_variant;\n\t\t}\n\t}\n\n\tif (!strcasecmp(variant, \"ssh\") ||\n\t    !strcasecmp(variant, \"ssh.exe\"))\n\t\tssh_variant = VARIANT_SSH;\n\telse if (!strcasecmp(variant, \"plink\") ||\n\t\t !strcasecmp(variant, \"plink.exe\"))\n\t\tssh_variant = VARIANT_PLINK;\n\telse if (!strcasecmp(variant, \"tortoiseplink\") ||\n\t\t !strcasecmp(variant, \"tortoiseplink.exe\"))\n\t\tssh_variant = VARIANT_TORTOISEPLINK;\n\n\tfree(p);\n\treturn ssh_variant;\n}\n\n/*\n * Open a connection using Git's native protocol.\n *\n * The caller is responsible for freeing hostandport, but this function may\n * modify it (for example, to truncate it to remove the port part).\n */\nstatic struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\t/*\n\t * Set up virtual host information based on where we will\n\t * connect, unless the user has overridden us in\n\t * the environment.\n\t */\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\n\ttransport_check_allowed(\"git\");\n\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))\n\t\tdie(_(\"newline is forbidden in git:// hosts and repo paths\"));\n\n\t/*\n\t * These underlying connection commands die() if they\n\t * cannot connect.\n\t */\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\t/*\n\t * Separate original protocol components prog and path\n\t * from extended host header with a NUL byte.\n\t *\n\t * Note: Do not add any other headers here!  Doing so\n\t * will cause older git-daemon servers to crash.\n\t */\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\n\t/* If using a new version put that stuff here after a second null byte */\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\n\tpacket_write(fd[1], request.buf, request.len);\n\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}\n\n/*\n * Append the appropriate environment variables to `env` and options to\n * `args` for running ssh in Git's SSH-tunneled transport.\n */\nstatic void push_ssh_options(struct argv_array *args, struct argv_array *env,\n\t\t\t     enum ssh_variant variant, const char *port,\n\t\t\t     enum protocol_version version, int flags)\n{\n\tif (variant == VARIANT_SSH &&\n\t    version > 0) {\n\t\targv_array_push(args, \"-o\");\n\t\targv_array_push(args, \"SendEnv=\" GIT_PROTOCOL_ENVIRONMENT);\n\t\targv_array_pushf(env, GIT_PROTOCOL_ENVIRONMENT \"=version=%d\",\n\t\t\t\t version);\n\t}\n\n\tif (flags & CONNECT_IPV4) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support -4\"));\n\t\tcase VARIANT_SSH:\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\targv_array_push(args, \"-4\");\n\t\t}\n\t} else if (flags & CONNECT_IPV6) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support -6\"));\n\t\tcase VARIANT_SSH:\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\targv_array_push(args, \"-6\");\n\t\t}\n\t}\n\n\tif (variant == VARIANT_TORTOISEPLINK)\n\t\targv_array_push(args, \"-batch\");\n\n\tif (port) {\n\t\tswitch (variant) {\n\t\tcase VARIANT_AUTO:\n\t\t\tBUG(\"VARIANT_AUTO passed to push_ssh_options\");\n\t\tcase VARIANT_SIMPLE:\n\t\t\tdie(_(\"ssh variant 'simple' does not support setting port\"));\n\t\tcase VARIANT_SSH:\n\t\t\targv_array_push(args, \"-p\");\n\t\t\tbreak;\n\t\tcase VARIANT_PLINK:\n\t\tcase VARIANT_PUTTY:\n\t\tcase VARIANT_TORTOISEPLINK:\n\t\t\targv_array_push(args, \"-P\");\n\t\t}\n\n\t\targv_array_push(args, port);\n\t}\n}\n\n/* Prepare a child_process for use by Git's SSH-tunneled transport. */\nstatic void fill_ssh_args(struct child_process *conn, const char *ssh_host,\n\t\t\t  const char *port, enum protocol_version version,\n\t\t\t  int flags)\n{\n\tconst char *ssh;\n\tenum ssh_variant variant;\n\n\tif (looks_like_command_line_option(ssh_host))\n\t\tdie(_(\"strange hostname '%s' blocked\"), ssh_host);\n\n\tssh = get_ssh_command();\n\tif (ssh) {\n\t\tvariant = determine_ssh_variant(ssh, 1);\n\t} else {\n\t\t/*\n\t\t * GIT_SSH is the no-shell version of\n\t\t * GIT_SSH_COMMAND (and must remain so for\n\t\t * historical compatibility).\n\t\t */\n\t\tconn->use_shell = 0;\n\n\t\tssh = getenv(\"GIT_SSH\");\n\t\tif (!ssh)\n\t\t\tssh = \"ssh\";\n\t\tvariant = determine_ssh_variant(ssh, 0);\n\t}\n\n\tif (variant == VARIANT_AUTO) {\n\t\tstruct child_process detect = CHILD_PROCESS_INIT;\n\n\t\tdetect.use_shell = conn->use_shell;\n\t\tdetect.no_stdin = detect.no_stdout = detect.no_stderr = 1;\n\n\t\targv_array_push(&detect.args, ssh);\n\t\targv_array_push(&detect.args, \"-G\");\n\t\tpush_ssh_options(&detect.args, &detect.env_array,\n\t\t\t\t VARIANT_SSH, port, version, flags);\n\t\targv_array_push(&detect.args, ssh_host);\n\n\t\tvariant = run_command(&detect) ? VARIANT_SIMPLE : VARIANT_SSH;\n\t}\n\n\targv_array_push(&conn->args, ssh);\n\tpush_ssh_options(&conn->args, &conn->env_array, variant, port, version, flags);\n\targv_array_push(&conn->args, ssh_host);\n}\n\n/*\n * This returns the dummy child_process `no_fork` if the transport protocol\n * does not need fork(2), or a struct child_process object if it does.  Once\n * done, finish the connection with finish_connect() with the value returned\n * from this function (it is safe to call finish_connect() with NULL to\n * support the former case).\n *\n * If it returns, the connect is successful; it just dies on errors (this\n * will hopefully be changed in a libification effort, to return NULL when\n * the connection failed).\n */\nstruct child_process *git_connect(int fd[2], const char *url,\n\t\t\t\t  const char *prog, int flags)\n{\n\tchar *hostandport, *path;\n\tstruct child_process *conn;\n\tenum protocol protocol;\n\tenum protocol_version version = get_protocol_version_config();\n\n\t/*\n\t * NEEDSWORK: If we are trying to use protocol v2 and we are planning\n\t * to perform a push, then fallback to v0 since the client doesn't know\n\t * how to push yet using v2.\n\t */\n\tif (version == protocol_v2 && !strcmp(\"git-receive-pack\", prog))\n\t\tversion = protocol_v0;\n\n\t/* Without this we cannot rely on waitpid() to tell\n\t * what happened to our children.\n\t */\n\tsignal(SIGCHLD, SIG_DFL);\n\n\tprotocol = parse_connect_url(url, &hostandport, &path);\n\tif ((flags & CONNECT_DIAG_URL) && (protocol != PROTO_SSH)) {\n\t\tprintf(\"Diag: url=%s\\n\", url ? url : \"NULL\");\n\t\tprintf(\"Diag: protocol=%s\\n\", prot_name(protocol));\n\t\tprintf(\"Diag: hostandport=%s\\n\", hostandport ? hostandport : \"NULL\");\n\t\tprintf(\"Diag: path=%s\\n\", path ? path : \"NULL\");\n\t\tconn = NULL;\n\t} else if (protocol == PROTO_GIT) {\n\t\tconn = git_connect_git(fd, hostandport, path, prog, version, flags);\n\t} else {\n\t\tstruct strbuf cmd = STRBUF_INIT;\n\t\tconst char *const *var;\n\n\t\tconn = xmalloc(sizeof(*conn));\n\t\tchild_process_init(conn);\n\n\t\tif (looks_like_command_line_option(path))\n\t\t\tdie(_(\"strange pathname '%s' blocked\"), path);\n\n\t\tstrbuf_addstr(&cmd, prog);\n\t\tstrbuf_addch(&cmd, ' ');\n\t\tsq_quote_buf(&cmd, path);\n\n\t\t/* remove repo-local variables from the environment */\n\t\tfor (var = local_repo_env; *var; var++)\n\t\t\targv_array_push(&conn->env_array, *var);\n\n\t\tconn->use_shell = 1;\n\t\tconn->in = conn->out = -1;\n\t\tif (protocol == PROTO_SSH) {\n\t\t\tchar *ssh_host = hostandport;\n\t\t\tconst char *port = NULL;\n\t\t\ttransport_check_allowed(\"ssh\");\n\t\t\tget_host_and_port(&ssh_host, &port);\n\n\t\t\tif (!port)\n\t\t\t\tport = get_port(ssh_host);\n\n\t\t\tif (flags & CONNECT_DIAG_URL) {\n\t\t\t\tprintf(\"Diag: url=%s\\n\", url ? url : \"NULL\");\n\t\t\t\tprintf(\"Diag: protocol=%s\\n\", prot_name(protocol));\n\t\t\t\tprintf(\"Diag: userandhost=%s\\n\", ssh_host ? ssh_host : \"NULL\");\n\t\t\t\tprintf(\"Diag: port=%s\\n\", port ? port : \"NONE\");\n\t\t\t\tprintf(\"Diag: path=%s\\n\", path ? path : \"NULL\");\n\n\t\t\t\tfree(hostandport);\n\t\t\t\tfree(path);\n\t\t\t\tfree(conn);\n\t\t\t\tstrbuf_release(&cmd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfill_ssh_args(conn, ssh_host, port, version, flags);\n\t\t} else {\n\t\t\ttransport_check_allowed(\"file\");\n\t\t\tif (version > 0) {\n\t\t\t\targv_array_pushf(&conn->env_array, GIT_PROTOCOL_ENVIRONMENT \"=version=%d\",\n\t\t\t\t\t\t version);\n\t\t\t}\n\t\t}\n\t\targv_array_push(&conn->args, cmd.buf);\n\n\t\tif (start_command(conn))\n\t\t\tdie(_(\"unable to fork\"));\n\n\t\tfd[0] = conn->out; /* read from child's stdout */\n\t\tfd[1] = conn->in;  /* write to child's stdin */\n\t\tstrbuf_release(&cmd);\n\t}\n\tfree(hostandport);\n\tfree(path);\n\treturn conn;\n}\n\nint finish_connect(struct child_process *conn)\n{\n\tint code;\n\tif (!conn || git_connection_is_socket(conn))\n\t\treturn 0;\n\n\tcode = finish_command(conn);\n\tfree(conn);\n\treturn code;\n}\n", "#!/bin/sh\n\ntest_description='test fetching over git protocol'\n. ./test-lib.sh\n\n. \"$TEST_DIRECTORY\"/lib-git-daemon.sh\nstart_git_daemon\n\ncheck_verbose_connect () {\n\ttest_i18ngrep -F \"Looking up 127.0.0.1 ...\" stderr &&\n\ttest_i18ngrep -F \"Connecting to 127.0.0.1 (port \" stderr &&\n\ttest_i18ngrep -F \"done.\" stderr\n}\n\ntest_expect_success 'setup repository' '\n\tgit config push.default matching &&\n\techo content >file &&\n\tgit add file &&\n\tgit commit -m one\n'\n\ntest_expect_success 'create git-accessible bare repository' '\n\tmkdir \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\" &&\n\t git --bare init &&\n\t : >git-daemon-export-ok\n\t) &&\n\tgit remote add public \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\" &&\n\tgit push public master:master\n'\n\ntest_expect_success 'clone git repository' '\n\tgit clone -v \"$GIT_DAEMON_URL/repo.git\" clone 2>stderr &&\n\tcheck_verbose_connect &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'fetch changes via git protocol' '\n\techo content >>file &&\n\tgit commit -a -m two &&\n\tgit push public &&\n\t(cd clone && git pull -v) 2>stderr &&\n\tcheck_verbose_connect &&\n\ttest_cmp file clone/file\n'\n\ntest_expect_success 'no-op fetch -v stderr is as expected' '\n\t(cd clone && git fetch -v) 2>stderr &&\n\tcheck_verbose_connect\n'\n\ntest_expect_success 'no-op fetch without \"-v\" is quiet' '\n\t(cd clone && git fetch 2>../stderr) &&\n\ttest_must_be_empty stderr\n'\n\ntest_expect_success 'remote detects correct HEAD' '\n\tgit push public master:other &&\n\t(cd clone &&\n\t git remote set-head -d origin &&\n\t git remote set-head -a origin &&\n\t git symbolic-ref refs/remotes/origin/HEAD > output &&\n\t echo refs/remotes/origin/master > expect &&\n\t test_cmp expect output\n\t)\n'\n\ntest_expect_success 'prepare pack objects' '\n\tcp -R \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo.git \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git &&\n\t git --bare repack -a -d\n\t)\n'\n\ntest_expect_success 'fetch notices corrupt pack' '\n\tcp -R \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad1.git &&\n\t p=$(ls objects/pack/pack-*.pack) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad1.git &&\n\t(cd repo_bad1.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch \"$GIT_DAEMON_URL/repo_bad1.git\" &&\n\t test 0 = $(ls objects/pack/pack-*.pack | wc -l)\n\t)\n'\n\ntest_expect_success 'fetch notices corrupt idx' '\n\tcp -R \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_pack.git \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t(cd \"$GIT_DAEMON_DOCUMENT_ROOT_PATH\"/repo_bad2.git &&\n\t p=$(ls objects/pack/pack-*.idx) &&\n\t chmod u+w $p &&\n\t printf %0256d 0 | dd of=$p bs=256 count=1 seek=1 conv=notrunc\n\t) &&\n\tmkdir repo_bad2.git &&\n\t(cd repo_bad2.git &&\n\t git --bare init &&\n\t test_must_fail git --bare fetch \"$GIT_DAEMON_URL/repo_bad2.git\" &&\n\t test 0 = $(ls objects/pack | wc -l)\n\t)\n'\n\ntest_expect_success 'client refuses to ask for repo with newline' '\n\ttest_must_fail git clone \"$GIT_DAEMON_URL/repo$LF.git\" dst 2>stderr &&\n\ttest_i18ngrep newline.is.forbidden stderr\n'\n\ntest_remote_error()\n{\n\tdo_export=YesPlease\n\twhile test $# -gt 0\n\tdo\n\t\tcase $1 in\n\t\t-x)\n\t\t\tshift\n\t\t\tchmod -x \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\"\n\t\t\t;;\n\t\t-n)\n\t\t\tshift\n\t\t\tdo_export=\n\t\t\t;;\n\t\t*)\n\t\t\tbreak\n\t\tesac\n\tdone\n\n\tmsg=$1\n\tshift\n\tcmd=$1\n\tshift\n\trepo=$1\n\tshift || error \"invalid number of arguments\"\n\n\tif test -x \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/$repo\"\n\tthen\n\t\tif test -n \"$do_export\"\n\t\tthen\n\t\t\t: >\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/$repo/git-daemon-export-ok\"\n\t\telse\n\t\t\trm -f \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/$repo/git-daemon-export-ok\"\n\t\tfi\n\tfi\n\n\ttest_must_fail git \"$cmd\" \"$GIT_DAEMON_URL/$repo\" \"$@\" 2>output &&\n\ttest_i18ngrep \"fatal: remote error: $msg: /$repo\" output &&\n\tret=$?\n\tchmod +x \"$GIT_DAEMON_DOCUMENT_ROOT_PATH/repo.git\"\n\t(exit $ret)\n}\n\nmsg=\"access denied or repository not exported\"\ntest_expect_success 'clone non-existent' \"test_remote_error    '$msg' clone nowhere.git    \"\ntest_expect_success 'push disabled'      \"test_remote_error    '$msg' push  repo.git master\"\ntest_expect_success 'read access denied' \"test_remote_error -x '$msg' fetch repo.git       \"\ntest_expect_success 'not exported'       \"test_remote_error -n '$msg' fetch repo.git       \"\n\nstop_git_daemon\nstart_git_daemon --informative-errors\n\ntest_expect_success 'clone non-existent' \"test_remote_error    'no such repository'      clone nowhere.git    \"\ntest_expect_success 'push disabled'      \"test_remote_error    'service not enabled'     push  repo.git master\"\ntest_expect_success 'read access denied' \"test_remote_error -x 'no such repository'      fetch repo.git       \"\ntest_expect_success 'not exported'       \"test_remote_error -n 'repository not exported' fetch repo.git       \"\n\nstop_git_daemon\nstart_git_daemon --interpolated-path=\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/%H%D\"\n\ntest_expect_success 'access repo via interpolated hostname' '\n\trepo=\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/localhost/interp.git\" &&\n\tgit init --bare \"$repo\" &&\n\tgit push \"$repo\" HEAD &&\n\t>\"$repo\"/git-daemon-export-ok &&\n\tGIT_OVERRIDE_VIRTUAL_HOST=localhost \\\n\t\tgit ls-remote \"$GIT_DAEMON_URL/interp.git\" &&\n\tGIT_OVERRIDE_VIRTUAL_HOST=LOCALHOST \\\n\t\tgit ls-remote \"$GIT_DAEMON_URL/interp.git\"\n'\n\ntest_expect_success 'hostname cannot break out of directory' '\n\trepo=\"$GIT_DAEMON_DOCUMENT_ROOT_PATH/../escape.git\" &&\n\tgit init --bare \"$repo\" &&\n\tgit push \"$repo\" HEAD &&\n\t>\"$repo\"/git-daemon-export-ok &&\n\ttest_must_fail \\\n\t\tenv GIT_OVERRIDE_VIRTUAL_HOST=.. \\\n\t\tgit ls-remote \"$GIT_DAEMON_URL/escape.git\"\n'\n\ntest_expect_success 'daemon log records all attributes' '\n\tcat >expect <<-\\EOF &&\n\tExtended attribute \"host\": localhost\n\tExtended attribute \"protocol\": version=1\n\tEOF\n\t>daemon.log &&\n\tGIT_OVERRIDE_VIRTUAL_HOST=localhost \\\n\t\tgit -c protocol.version=1 \\\n\t\t\tls-remote \"$GIT_DAEMON_URL/interp.git\" &&\n\tgrep -i extended.attribute daemon.log | cut -d\" \" -f2- >actual &&\n\ttest_cmp expect actual\n'\n\ntest_expect_success FAKENC 'hostname interpolation works after LF-stripping' '\n\t{\n\t\tprintf \"git-upload-pack /interp.git\\n\\0host=localhost\" | packetize\n\t\tprintf \"0000\"\n\t} >input &&\n\tfake_nc \"$GIT_DAEMON_HOST_PORT\" <input >output &&\n\tdepacketize <output >output.raw &&\n\n\t# just pick out the value of master, which avoids any protocol\n\t# particulars\n\tperl -lne \"print \\$1 if m{^(\\\\S+) refs/heads/master}\" <output.raw >actual &&\n\tgit -C \"$repo\" rev-parse master >expect &&\n\ttest_cmp expect actual\n'\n\nstop_git_daemon\ntest_done\n"], "filenames": ["connect.c", "t/t5570-git-daemon.sh"], "buggy_code_start_loc": [1065, 102], "buggy_code_end_loc": [1065, 102], "fixing_code_start_loc": [1066, 103], "fixing_code_end_loc": [1068, 108], "type": "NVD-CWE-noinfo", "message": "git_connect_git in connect.c in Git before 2.30.1 allows a repository path to contain a newline character, which may result in unexpected cross-protocol requests, as demonstrated by the git://localhost:1234/%0d%0a%0d%0aGET%20/%20HTTP/1.1 substring.", "other": {"cve": {"id": "CVE-2021-40330", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-31T04:15:10.667", "lastModified": "2022-11-07T18:37:36.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "git_connect_git in connect.c in Git before 2.30.1 allows a repository path to contain a newline character, which may result in unexpected cross-protocol requests, as demonstrated by the git://localhost:1234/%0d%0a%0d%0aGET%20/%20HTTP/1.1 substring."}, {"lang": "es", "value": "La funci\u00f3n git_connect_git en el archivo connect.c en Git versiones anteriores a 2.30.1, permite que la ruta de un repositorio contenga un car\u00e1cter de nueva l\u00ednea, que puede resultar en peticiones inesperadas entre protocolos, como es demostrado en la subcadena git://localhost:1234/%0d%0a%0d%0aGET%20/%20HTTP/1.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-scm:git:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.30.1", "matchCriteriaId": "12210C13-4B94-4F02-B7F3-ACE1ECD2F54B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/git/git/commit/a02ea577174ab8ed18f847cf1693f213e0b9c473", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/git/git/compare/v2.30.0...v2.30.1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/git/git/commit/a02ea577174ab8ed18f847cf1693f213e0b9c473"}}