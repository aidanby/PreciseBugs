{"buggy_code": ["\"\"\"\nDefines helper methods useful for setting up ports, launching servers, and handling `ngrok`\n\"\"\"\n\nimport os\nimport socket\nimport threading\nfrom flask import Flask, request, session, jsonify, abort, send_file, render_template, redirect\nfrom flask_cachebuster import CacheBuster\nfrom flask_login import LoginManager, login_user, current_user, login_required\nfrom flask_cors import CORS\nimport threading\nimport pkg_resources\nimport datetime\nimport time\nimport json\nimport urllib.request\nfrom shutil import copyfile\nimport requests\nimport sys\nimport csv\nimport logging\nfrom gradio.tunneling import create_tunnel\nfrom gradio import encryptor\nfrom gradio import queue\nfrom functools import wraps\nimport io\nimport inspect\nimport traceback\nfrom werkzeug.security import safe_join\n\nINITIAL_PORT_VALUE = int(os.getenv(\n    'GRADIO_SERVER_PORT', \"7860\"))  # The http server will try to open on port 7860. If not available, 7861, 7862, etc.\nTRY_NUM_PORTS = int(os.getenv(\n    'GRADIO_NUM_PORTS', \"100\"))  # Number of ports to try before giving up and throwing an exception.\nLOCALHOST_NAME = os.getenv(\n    'GRADIO_SERVER_NAME', \"127.0.0.1\")\nGRADIO_API_SERVER = \"https://api.gradio.app/v1/tunnel-request\"\nGRADIO_FEATURE_ANALYTICS_URL = \"https://api.gradio.app/gradio-feature-analytics/\"\n\nSTATIC_TEMPLATE_LIB = pkg_resources.resource_filename(\"gradio\", \"templates/\")\nSTATIC_PATH_LIB = pkg_resources.resource_filename(\"gradio\", \"templates/frontend/static\")\nVERSION_FILE = pkg_resources.resource_filename(\"gradio\", \"version.txt\")\nwith open(VERSION_FILE) as version_file:\n    GRADIO_STATIC_ROOT = \"https://gradio.s3-us-west-2.amazonaws.com/\" + \\\n        version_file.read().strip() + \"/static/\"\n\napp = Flask(__name__,\n            template_folder=STATIC_TEMPLATE_LIB,\n            static_folder=\"\",\n            static_url_path=\"/none/\")\napp.url_map.strict_slashes = False\n\nCORS(app)\ncache_buster = CacheBuster(\n    config={'extensions': ['.js', '.css'], 'hash_size': 5})\ncache_buster.init_app(app)\napp.secret_key = os.getenv(\"GRADIO_KEY\", \"secret\")\nlogin_manager = LoginManager()\nlogin_manager.login_view = 'login'\nlogin_manager.init_app(app)\n\n# Hide Flask default message\ncli = sys.modules['flask.cli']\ncli.show_server_banner = lambda *x: None\n\n\nclass User:\n    def __init__(self, id):\n        self.is_authenticated = True\n        self.is_active = True\n        self.is_anonymous = False\n        self.id = id\n\n    def get_id(self):\n        return self.id\n\n\n@login_manager.user_loader\ndef load_user(_id):\n    return User(_id)\n\n\ndef login_check(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if app.auth:\n            @login_required\n            def func2(*args, **kwargs):\n                return func(*args, **kwargs)\n\n            return func2(*args, **kwargs)\n        else:\n            return func(*args, **kwargs)\n    return wrapper\n\n\ndef get_local_ip_address():\n    try:\n        ip_address = requests.get('https://api.ipify.org', timeout=3).text\n    except (requests.ConnectionError, requests.exceptions.ReadTimeout):\n        ip_address = \"No internet connection\"\n    return ip_address\n\n\nIP_ADDRESS = get_local_ip_address()\n\n\ndef get_first_available_port(initial, final):\n    \"\"\"\n    Gets the first open port in a specified range of port numbers\n    :param initial: the initial value in the range of port numbers\n    :param final: final (exclusive) value in the range of port numbers, should be greater than `initial`\n    :return:\n    \"\"\"\n    for port in range(initial, final):\n        try:\n            s = socket.socket()  # create a socket object\n            s.bind((LOCALHOST_NAME, port))  # Bind to the port\n            s.close()\n            return port\n        except OSError:\n            pass\n    raise OSError(\n        \"All ports from {} to {} are in use. Please close a port.\".format(\n            initial, final\n        )\n    )\n\n\n@app.route(\"/\", methods=[\"GET\"])\n@login_check\ndef main():\n    session[\"state\"] = None\n    return render_template(\"frontend/index.html\", config=app.interface.config)\n\n\n@app.route(\"/static/<path:path>\", methods=[\"GET\"])\ndef static_resource(path):\n    if app.interface.share:\n        return redirect(GRADIO_STATIC_ROOT + path)\n    else:\n        return send_file(safe_join(STATIC_PATH_LIB, path))\n\n\n# TODO(@aliabid94): this throws a 500 error if app.auth is None (should probalbly just redirect to '/')\n@app.route('/login', methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"GET\":\n        config = get_config()\n        return render_template(\"frontend/index.html\", config=config)\n    elif request.method == \"POST\":\n        username = request.form.get(\"username\")\n        password = request.form.get(\"password\")\n        if ((not callable(app.auth) and username in app.auth and app.auth[username] == password)\n                or (callable(app.auth) and app.auth.__call__(username, password))):\n            login_user(User(username))\n            return redirect(\"/\")\n        else:\n            return abort(401)\n\n\n@app.route(\"/config/\", methods=[\"GET\"])\ndef get_config():\n    if app.interface.auth is None or current_user.is_authenticated:\n        return jsonify(app.interface.config)\n    else:\n        return {\"auth_required\": True, \"auth_message\": app.interface.auth_message}\n\n\n@app.route(\"/enable_sharing/<path:path>\", methods=[\"GET\"])\n@login_check\ndef enable_sharing(path):\n    if path == \"None\":\n        path = None\n    app.interface.config[\"share_url\"] = path\n    return jsonify(success=True)\n\n\n@app.route(\"/shutdown\", methods=['GET'])\ndef shutdown():\n    shutdown_func = request.environ.get('werkzeug.server.shutdown')\n    if shutdown_func is None:\n        raise RuntimeError('Not running werkzeug')\n    shutdown_func()\n    return \"Shutting down...\"\n\n\n@app.route(\"/api/predict/\", methods=[\"POST\"])\n@login_check\ndef predict():\n    raw_input = request.json[\"data\"]\n    # Capture any errors made and pipe to front end\n    if app.interface.show_error:\n        try:\n            prediction, durations = app.interface.process(raw_input)\n        except BaseException as error:\n            traceback.print_exc()\n            return jsonify({\"error\": str(error)}), 500\n    else:\n        prediction, durations = app.interface.process(raw_input)\n    avg_durations = []\n    for i, duration in enumerate(durations):\n        app.interface.predict_durations[i][0] += duration\n        app.interface.predict_durations[i][1] += 1\n        avg_durations.append(app.interface.predict_durations[i][0] \n            / app.interface.predict_durations[i][1])\n    app.interface.config[\"avg_durations\"] = avg_durations\n    output = {\"data\": prediction, \"durations\": durations, \"avg_durations\": avg_durations}\n    if app.interface.allow_flagging == \"auto\":\n        try:\n            flag_index = flag_data(raw_input, prediction, \n                flag_option=(None if app.interface.flagging_options is None else \"\"), \n                username=current_user.id if current_user.is_authenticated else None)\n            output[\"flag_index\"] = flag_index\n        except Exception as e:\n            print(str(e))\n            pass\n    return jsonify(output)\n\n\ndef get_types(cls_set, component):\n    docset = []\n    types = []\n    if component == \"input\":\n        for cls in cls_set:\n            doc = inspect.getdoc(cls.preprocess)\n            doc_lines = doc.split(\"\\n\")\n            docset.append(doc_lines[1].split(\":\")[-1])\n            types.append(doc_lines[1].split(\")\")[0].split(\"(\")[-1])\n    else:\n        for cls in cls_set:\n            doc = inspect.getdoc(cls.postprocess)\n            doc_lines = doc.split(\"\\n\")\n            docset.append(doc_lines[-1].split(\":\")[-1])\n            types.append(doc_lines[-1].split(\")\")[0].split(\"(\")[-1])\n    return docset, types\n\n\n@app.route(\"/api/\", methods=[\"GET\"])\ndef api_docs():\n    inputs = [type(inp) for inp in app.interface.input_components]\n    outputs = [type(out) for out in app.interface.output_components]\n    input_types_doc, input_types = get_types(inputs, \"input\")\n    output_types_doc, output_types = get_types(outputs, \"output\")\n    input_names = [type(inp).__name__ for inp in app.interface.input_components]\n    output_names = [type(out).__name__ for out in app.interface.output_components]\n    sample_inputs = [inp.generate_sample() for inp in app.interface.input_components]\n    docs = {\n        \"inputs\": input_names,\n        \"outputs\": output_names,\n        \"len_inputs\": len(inputs),\n        \"len_outputs\": len(outputs),\n        \"inputs_lower\": [name.lower() for name in input_names],\n        \"outputs_lower\": [name.lower() for name in output_names],\n        \"input_types\": input_types,\n        \"output_types\": output_types,\n        \"input_types_doc\": input_types_doc,\n        \"output_types_doc\": output_types_doc,\n        \"sample_inputs\": sample_inputs\n    }\n    return render_template(\"api_docs.html\", **docs)\n\n\ndef log_feature_analytics(feature):\n    if app.interface.analytics_enabled:\n        try:\n            requests.post(GRADIO_FEATURE_ANALYTICS_URL,\n                          data={\n                              'ip_address': IP_ADDRESS,\n                              'feature': feature}, timeout=3)\n        except (requests.ConnectionError, requests.exceptions.ReadTimeout):\n            pass  # do not push analytics if no network\n\n\ndef flag_data(input_data, output_data, flag_option=None, flag_index=None, username=None, flag_path=None):\n    if flag_path is None:\n        flag_path = os.path.join(app.cwd, app.interface.flagging_dir)\n    log_fp = \"{}/log.csv\".format(flag_path)\n    encryption_key = app.interface.encryption_key if app.interface.encrypt else None\n    is_new = not os.path.exists(log_fp)\n\n    if flag_index is None:\n        csv_data = []\n        for i, interface in enumerate(app.interface.input_components):\n            csv_data.append(interface.save_flagged(\n                flag_path, app.interface.config[\"input_components\"][i][\"label\"], input_data[i], encryption_key))\n        for i, interface in enumerate(app.interface.output_components):\n            csv_data.append(interface.save_flagged(\n                flag_path, app.interface.config[\"output_components\"][i][\"label\"], output_data[i], encryption_key) if output_data[i] is not None else \"\")\n        if flag_option is not None:\n            csv_data.append(flag_option)\n        if username is not None:\n            csv_data.append(username)\n        csv_data.append(str(datetime.datetime.now()))\n        if is_new:\n            headers = [interface[\"label\"]\n                    for interface in app.interface.config[\"input_components\"]]\n            headers += [interface[\"label\"]\n                        for interface in app.interface.config[\"output_components\"]]\n            if app.interface.flagging_options is not None:\n                headers.append(\"flag\")\n            if username is not None:\n                headers.append(\"username\")\n            headers.append(\"timestamp\")\n\n    def replace_flag_at_index(file_content):\n        file_content = io.StringIO(file_content)\n        content = list(csv.reader(file_content))\n        header = content[0]\n        flag_col_index = header.index(\"flag\")\n        content[flag_index][flag_col_index] = flag_option\n        output = io.StringIO()\n        writer = csv.writer(output)\n        writer.writerows(content)\n        return output.getvalue()\n\n    if app.interface.encrypt:\n        output = io.StringIO()\n        if not is_new:\n            with open(log_fp, \"rb\") as csvfile:\n                encrypted_csv = csvfile.read()\n                decrypted_csv = encryptor.decrypt(\n                    app.interface.encryption_key, encrypted_csv)\n                file_content = decrypted_csv.decode()\n                if flag_index is not None:\n                    file_content = replace_flag_at_index(file_content)\n                output.write(file_content)\n        writer = csv.writer(output)\n        if flag_index is None:\n            if is_new:\n                writer.writerow(headers)\n            writer.writerow(csv_data)\n        with open(log_fp, \"wb\") as csvfile:\n            csvfile.write(encryptor.encrypt(\n                app.interface.encryption_key, output.getvalue().encode()))\n    else:\n        if flag_index is None:\n            with open(log_fp, \"a\", newline=\"\") as csvfile:\n                writer = csv.writer(csvfile)\n                if is_new:\n                    writer.writerow(headers)\n                writer.writerow(csv_data)\n        else:\n            with open(log_fp) as csvfile:\n                file_content = csvfile.read()\n                file_content = replace_flag_at_index(file_content)\n            with open(log_fp, \"w\", newline=\"\") as csvfile:  # newline parameter needed for Windows\n                csvfile.write(file_content)\n    with open(log_fp, \"r\") as csvfile:\n        line_count = len([None for row in csv.reader(csvfile)]) - 1\n    return line_count\n\n@app.route(\"/api/flag/\", methods=[\"POST\"])\n@login_check\ndef flag():\n    log_feature_analytics('flag')\n    data = request.json['data']\n    flag_data(data['input_data'], data['output_data'], data.get(\"flag_option\"), data.get(\"flag_index\"), \n        current_user.id if current_user.is_authenticated else None)\n    return jsonify(success=True)\n\n\n@app.route(\"/api/interpret/\", methods=[\"POST\"])\n@login_check\ndef interpret():\n    log_feature_analytics('interpret')\n    raw_input = request.json[\"data\"]\n    interpretation_scores, alternative_outputs = app.interface.interpret(\n        raw_input)\n    return jsonify({\n        \"interpretation_scores\": interpretation_scores,\n        \"alternative_outputs\": alternative_outputs\n    })\n\n\n@app.route(\"/file/<path:path>\", methods=[\"GET\"])\n@login_check\ndef file(path):\n    path = secure_filename(path)\n    if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):\n        with open(os.path.join(app.cwd, path), \"rb\") as encrypted_file:\n            encrypted_data = encrypted_file.read()\n        file_data = encryptor.decrypt(\n            app.interface.encryption_key, encrypted_data)\n        return send_file(io.BytesIO(file_data), attachment_filename=os.path.basename(path))\n    else:\n        return send_file(os.path.join(app.cwd, path))\n\n\n@app.route(\"/api/queue/push/\", methods=[\"POST\"])\n@login_check\ndef queue_push():\n    data = request.json[\"data\"]\n    action = request.json[\"action\"]\n    job_hash, queue_position = queue.push({\"data\": data}, action)\n    return {\"hash\": job_hash, \"queue_position\": queue_position}\n\n\n@app.route(\"/api/queue/status/\", methods=[\"POST\"])\n@login_check\ndef queue_status():\n    hash = request.json['hash']\n    status, data = queue.get_status(hash)\n    return {\"status\": status, \"data\": data}\n\n\ndef queue_thread(path_to_local_server, test_mode=False):\n    while True:\n        try:\n            next_job = queue.pop()\n            if next_job is not None:\n                _, hash, input_data, task_type = next_job\n                queue.start_job(hash)\n                response = requests.post(\n                    path_to_local_server + \"/api/\" + task_type + \"/\", json=input_data)\n                if response.status_code == 200:\n                    queue.pass_job(hash, response.json())\n                else:\n                    queue.fail_job(hash, response.text)\n            else:\n                time.sleep(1)\n        except Exception as e:\n            time.sleep(1)\n            pass\n        if test_mode:\n            break\n\n\ndef start_server(interface, server_name, server_port=None, auth=None, ssl=None):\n    if server_port is None:\n        server_port = INITIAL_PORT_VALUE\n    port = get_first_available_port(\n        server_port, server_port + TRY_NUM_PORTS\n    )\n    path_to_local_server = \"http://{}:{}/\".format(server_name, port)\n    if auth is not None:\n        if not callable(auth):\n            app.auth = {account[0]: account[1] for account in auth}\n        else:\n            app.auth = auth\n    else:\n        app.auth = None\n    app.interface = interface\n    app.cwd = os.getcwd()\n    log = logging.getLogger('werkzeug')\n    log.setLevel(logging.ERROR)\n    if app.interface.enable_queue:\n        if auth is not None or app.interface.encrypt:\n            raise ValueError(\"Cannot queue with encryption or authentication enabled.\")\n        queue.init()\n        app.queue_thread = threading.Thread(target=queue_thread, args=(path_to_local_server,))\n        app.queue_thread.start()\n    if interface.save_to is not None:\n        interface.save_to[\"port\"] = port\n    app_kwargs = {\"port\": port, \"host\": server_name}\n    if ssl:\n        app_kwargs[\"ssl_context\"] = ssl\n    thread = threading.Thread(target=app.run,\n                              kwargs=app_kwargs,\n                              daemon=True)\n    thread.start()\n\n    return port, path_to_local_server, app, thread\n\ndef get_state():\n    return session.get(\"state\")\n\ndef set_state(value):\n    session[\"state\"] = value\n\ndef close_server(process):\n    process.terminate()\n    process.join()\n\n\ndef url_request(url):\n    try:\n        req = urllib.request.Request(\n            url=url, headers={\"content-type\": \"application/json\"}\n        )\n        res = urllib.request.urlopen(req, timeout=10)\n        return res\n    except Exception as e:\n        raise RuntimeError(str(e))\n\n\ndef setup_tunnel(local_server_port, endpoint):\n    response = url_request(\n        endpoint + '/v1/tunnel-request' if endpoint is not None else GRADIO_API_SERVER)\n    if response and response.code == 200:\n        try:\n            payload = json.loads(response.read().decode(\"utf-8\"))[0]\n            return create_tunnel(payload, LOCALHOST_NAME, local_server_port)\n\n        except Exception as e:\n            raise RuntimeError(str(e))\n\n\ndef url_ok(url):\n    try:\n        for _ in range(5):\n            time.sleep(.500)\n            r = requests.head(url, timeout=3)\n            if r.status_code in (200, 401, 302):  # 401 or 302 if auth is set\n                return True\n    except (ConnectionError, requests.exceptions.ConnectionError):\n        return False\n"], "fixing_code": ["\"\"\"\nDefines helper methods useful for setting up ports, launching servers, and handling `ngrok`\n\"\"\"\n\nimport os\nimport socket\nimport threading\nfrom flask import Flask, request, session, jsonify, abort, send_file, render_template, redirect\nfrom flask_cachebuster import CacheBuster\nfrom flask_login import LoginManager, login_user, current_user, login_required\nfrom flask_cors import CORS\nimport threading\nimport pkg_resources\nimport datetime\nimport time\nimport json\nimport urllib.request\nfrom shutil import copyfile\nimport requests\nimport sys\nimport csv\nimport logging\nfrom gradio.tunneling import create_tunnel\nfrom gradio import encryptor\nfrom gradio import queue\nfrom functools import wraps\nimport io\nimport inspect\nimport traceback\nfrom werkzeug.security import safe_join\n\nINITIAL_PORT_VALUE = int(os.getenv(\n    'GRADIO_SERVER_PORT', \"7860\"))  # The http server will try to open on port 7860. If not available, 7861, 7862, etc.\nTRY_NUM_PORTS = int(os.getenv(\n    'GRADIO_NUM_PORTS', \"100\"))  # Number of ports to try before giving up and throwing an exception.\nLOCALHOST_NAME = os.getenv(\n    'GRADIO_SERVER_NAME', \"127.0.0.1\")\nGRADIO_API_SERVER = \"https://api.gradio.app/v1/tunnel-request\"\nGRADIO_FEATURE_ANALYTICS_URL = \"https://api.gradio.app/gradio-feature-analytics/\"\n\nSTATIC_TEMPLATE_LIB = pkg_resources.resource_filename(\"gradio\", \"templates/\")\nSTATIC_PATH_LIB = pkg_resources.resource_filename(\"gradio\", \"templates/frontend/static\")\nVERSION_FILE = pkg_resources.resource_filename(\"gradio\", \"version.txt\")\nwith open(VERSION_FILE) as version_file:\n    GRADIO_STATIC_ROOT = \"https://gradio.s3-us-west-2.amazonaws.com/\" + \\\n        version_file.read().strip() + \"/static/\"\n\napp = Flask(__name__,\n            template_folder=STATIC_TEMPLATE_LIB,\n            static_folder=\"\",\n            static_url_path=\"/none/\")\napp.url_map.strict_slashes = False\n\nCORS(app)\ncache_buster = CacheBuster(\n    config={'extensions': ['.js', '.css'], 'hash_size': 5})\ncache_buster.init_app(app)\napp.secret_key = os.getenv(\"GRADIO_KEY\", \"secret\")\nlogin_manager = LoginManager()\nlogin_manager.login_view = 'login'\nlogin_manager.init_app(app)\n\n# Hide Flask default message\ncli = sys.modules['flask.cli']\ncli.show_server_banner = lambda *x: None\n\n\nclass User:\n    def __init__(self, id):\n        self.is_authenticated = True\n        self.is_active = True\n        self.is_anonymous = False\n        self.id = id\n\n    def get_id(self):\n        return self.id\n\n\n@login_manager.user_loader\ndef load_user(_id):\n    return User(_id)\n\n\ndef login_check(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if app.auth:\n            @login_required\n            def func2(*args, **kwargs):\n                return func(*args, **kwargs)\n\n            return func2(*args, **kwargs)\n        else:\n            return func(*args, **kwargs)\n    return wrapper\n\n\ndef get_local_ip_address():\n    try:\n        ip_address = requests.get('https://api.ipify.org', timeout=3).text\n    except (requests.ConnectionError, requests.exceptions.ReadTimeout):\n        ip_address = \"No internet connection\"\n    return ip_address\n\n\nIP_ADDRESS = get_local_ip_address()\n\n\ndef get_first_available_port(initial, final):\n    \"\"\"\n    Gets the first open port in a specified range of port numbers\n    :param initial: the initial value in the range of port numbers\n    :param final: final (exclusive) value in the range of port numbers, should be greater than `initial`\n    :return:\n    \"\"\"\n    for port in range(initial, final):\n        try:\n            s = socket.socket()  # create a socket object\n            s.bind((LOCALHOST_NAME, port))  # Bind to the port\n            s.close()\n            return port\n        except OSError:\n            pass\n    raise OSError(\n        \"All ports from {} to {} are in use. Please close a port.\".format(\n            initial, final\n        )\n    )\n\n\n@app.route(\"/\", methods=[\"GET\"])\n@login_check\ndef main():\n    session[\"state\"] = None\n    return render_template(\"frontend/index.html\", config=app.interface.config)\n\n\n@app.route(\"/static/<path:path>\", methods=[\"GET\"])\ndef static_resource(path):\n    if app.interface.share:\n        return redirect(GRADIO_STATIC_ROOT + path)\n    else:\n        return send_file(safe_join(STATIC_PATH_LIB, path))\n\n\n# TODO(@aliabid94): this throws a 500 error if app.auth is None (should probalbly just redirect to '/')\n@app.route('/login', methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"GET\":\n        config = get_config()\n        return render_template(\"frontend/index.html\", config=config)\n    elif request.method == \"POST\":\n        username = request.form.get(\"username\")\n        password = request.form.get(\"password\")\n        if ((not callable(app.auth) and username in app.auth and app.auth[username] == password)\n                or (callable(app.auth) and app.auth.__call__(username, password))):\n            login_user(User(username))\n            return redirect(\"/\")\n        else:\n            return abort(401)\n\n\n@app.route(\"/config/\", methods=[\"GET\"])\ndef get_config():\n    if app.interface.auth is None or current_user.is_authenticated:\n        return jsonify(app.interface.config)\n    else:\n        return {\"auth_required\": True, \"auth_message\": app.interface.auth_message}\n\n\n@app.route(\"/enable_sharing/<path:path>\", methods=[\"GET\"])\n@login_check\ndef enable_sharing(path):\n    if path == \"None\":\n        path = None\n    app.interface.config[\"share_url\"] = path\n    return jsonify(success=True)\n\n\n@app.route(\"/shutdown\", methods=['GET'])\ndef shutdown():\n    shutdown_func = request.environ.get('werkzeug.server.shutdown')\n    if shutdown_func is None:\n        raise RuntimeError('Not running werkzeug')\n    shutdown_func()\n    return \"Shutting down...\"\n\n\n@app.route(\"/api/predict/\", methods=[\"POST\"])\n@login_check\ndef predict():\n    raw_input = request.json[\"data\"]\n    # Capture any errors made and pipe to front end\n    if app.interface.show_error:\n        try:\n            prediction, durations = app.interface.process(raw_input)\n        except BaseException as error:\n            traceback.print_exc()\n            return jsonify({\"error\": str(error)}), 500\n    else:\n        prediction, durations = app.interface.process(raw_input)\n    avg_durations = []\n    for i, duration in enumerate(durations):\n        app.interface.predict_durations[i][0] += duration\n        app.interface.predict_durations[i][1] += 1\n        avg_durations.append(app.interface.predict_durations[i][0] \n            / app.interface.predict_durations[i][1])\n    app.interface.config[\"avg_durations\"] = avg_durations\n    output = {\"data\": prediction, \"durations\": durations, \"avg_durations\": avg_durations}\n    if app.interface.allow_flagging == \"auto\":\n        try:\n            flag_index = flag_data(raw_input, prediction, \n                flag_option=(None if app.interface.flagging_options is None else \"\"), \n                username=current_user.id if current_user.is_authenticated else None)\n            output[\"flag_index\"] = flag_index\n        except Exception as e:\n            print(str(e))\n            pass\n    return jsonify(output)\n\n\ndef get_types(cls_set, component):\n    docset = []\n    types = []\n    if component == \"input\":\n        for cls in cls_set:\n            doc = inspect.getdoc(cls.preprocess)\n            doc_lines = doc.split(\"\\n\")\n            docset.append(doc_lines[1].split(\":\")[-1])\n            types.append(doc_lines[1].split(\")\")[0].split(\"(\")[-1])\n    else:\n        for cls in cls_set:\n            doc = inspect.getdoc(cls.postprocess)\n            doc_lines = doc.split(\"\\n\")\n            docset.append(doc_lines[-1].split(\":\")[-1])\n            types.append(doc_lines[-1].split(\")\")[0].split(\"(\")[-1])\n    return docset, types\n\n\n@app.route(\"/api/\", methods=[\"GET\"])\ndef api_docs():\n    inputs = [type(inp) for inp in app.interface.input_components]\n    outputs = [type(out) for out in app.interface.output_components]\n    input_types_doc, input_types = get_types(inputs, \"input\")\n    output_types_doc, output_types = get_types(outputs, \"output\")\n    input_names = [type(inp).__name__ for inp in app.interface.input_components]\n    output_names = [type(out).__name__ for out in app.interface.output_components]\n    sample_inputs = [inp.generate_sample() for inp in app.interface.input_components]\n    docs = {\n        \"inputs\": input_names,\n        \"outputs\": output_names,\n        \"len_inputs\": len(inputs),\n        \"len_outputs\": len(outputs),\n        \"inputs_lower\": [name.lower() for name in input_names],\n        \"outputs_lower\": [name.lower() for name in output_names],\n        \"input_types\": input_types,\n        \"output_types\": output_types,\n        \"input_types_doc\": input_types_doc,\n        \"output_types_doc\": output_types_doc,\n        \"sample_inputs\": sample_inputs\n    }\n    return render_template(\"api_docs.html\", **docs)\n\n\ndef log_feature_analytics(feature):\n    if app.interface.analytics_enabled:\n        try:\n            requests.post(GRADIO_FEATURE_ANALYTICS_URL,\n                          data={\n                              'ip_address': IP_ADDRESS,\n                              'feature': feature}, timeout=3)\n        except (requests.ConnectionError, requests.exceptions.ReadTimeout):\n            pass  # do not push analytics if no network\n\n\ndef flag_data(input_data, output_data, flag_option=None, flag_index=None, username=None, flag_path=None):\n    if flag_path is None:\n        flag_path = os.path.join(app.cwd, app.interface.flagging_dir)\n    log_fp = \"{}/log.csv\".format(flag_path)\n    encryption_key = app.interface.encryption_key if app.interface.encrypt else None\n    is_new = not os.path.exists(log_fp)\n\n    if flag_index is None:\n        csv_data = []\n        for i, interface in enumerate(app.interface.input_components):\n            csv_data.append(interface.save_flagged(\n                flag_path, app.interface.config[\"input_components\"][i][\"label\"], input_data[i], encryption_key))\n        for i, interface in enumerate(app.interface.output_components):\n            csv_data.append(interface.save_flagged(\n                flag_path, app.interface.config[\"output_components\"][i][\"label\"], output_data[i], encryption_key) if output_data[i] is not None else \"\")\n        if flag_option is not None:\n            csv_data.append(flag_option)\n        if username is not None:\n            csv_data.append(username)\n        csv_data.append(str(datetime.datetime.now()))\n        if is_new:\n            headers = [interface[\"label\"]\n                    for interface in app.interface.config[\"input_components\"]]\n            headers += [interface[\"label\"]\n                        for interface in app.interface.config[\"output_components\"]]\n            if app.interface.flagging_options is not None:\n                headers.append(\"flag\")\n            if username is not None:\n                headers.append(\"username\")\n            headers.append(\"timestamp\")\n\n    def replace_flag_at_index(file_content):\n        file_content = io.StringIO(file_content)\n        content = list(csv.reader(file_content))\n        header = content[0]\n        flag_col_index = header.index(\"flag\")\n        content[flag_index][flag_col_index] = flag_option\n        output = io.StringIO()\n        writer = csv.writer(output)\n        writer.writerows(content)\n        return output.getvalue()\n\n    if app.interface.encrypt:\n        output = io.StringIO()\n        if not is_new:\n            with open(log_fp, \"rb\") as csvfile:\n                encrypted_csv = csvfile.read()\n                decrypted_csv = encryptor.decrypt(\n                    app.interface.encryption_key, encrypted_csv)\n                file_content = decrypted_csv.decode()\n                if flag_index is not None:\n                    file_content = replace_flag_at_index(file_content)\n                output.write(file_content)\n        writer = csv.writer(output)\n        if flag_index is None:\n            if is_new:\n                writer.writerow(headers)\n            writer.writerow(csv_data)\n        with open(log_fp, \"wb\") as csvfile:\n            csvfile.write(encryptor.encrypt(\n                app.interface.encryption_key, output.getvalue().encode()))\n    else:\n        if flag_index is None:\n            with open(log_fp, \"a\", newline=\"\") as csvfile:\n                writer = csv.writer(csvfile)\n                if is_new:\n                    writer.writerow(headers)\n                writer.writerow(csv_data)\n        else:\n            with open(log_fp) as csvfile:\n                file_content = csvfile.read()\n                file_content = replace_flag_at_index(file_content)\n            with open(log_fp, \"w\", newline=\"\") as csvfile:  # newline parameter needed for Windows\n                csvfile.write(file_content)\n    with open(log_fp, \"r\") as csvfile:\n        line_count = len([None for row in csv.reader(csvfile)]) - 1\n    return line_count\n\n@app.route(\"/api/flag/\", methods=[\"POST\"])\n@login_check\ndef flag():\n    log_feature_analytics('flag')\n    data = request.json['data']\n    flag_data(data['input_data'], data['output_data'], data.get(\"flag_option\"), data.get(\"flag_index\"), \n        current_user.id if current_user.is_authenticated else None)\n    return jsonify(success=True)\n\n\n@app.route(\"/api/interpret/\", methods=[\"POST\"])\n@login_check\ndef interpret():\n    log_feature_analytics('interpret')\n    raw_input = request.json[\"data\"]\n    interpretation_scores, alternative_outputs = app.interface.interpret(\n        raw_input)\n    return jsonify({\n        \"interpretation_scores\": interpretation_scores,\n        \"alternative_outputs\": alternative_outputs\n    })\n\n\n@app.route(\"/file/<path:path>\", methods=[\"GET\"])\n@login_check\ndef file(path):\n    if app.interface.encrypt and isinstance(app.interface.examples, str) and path.startswith(app.interface.examples):\n        with open(safe_join(app.cwd, path), \"rb\") as encrypted_file:\n            encrypted_data = encrypted_file.read()\n        file_data = encryptor.decrypt(\n            app.interface.encryption_key, encrypted_data)\n        return send_file(io.BytesIO(file_data), attachment_filename=os.path.basename(path))\n    else:\n        return send_file(safe_join(app.cwd, path))\n\n\n@app.route(\"/api/queue/push/\", methods=[\"POST\"])\n@login_check\ndef queue_push():\n    data = request.json[\"data\"]\n    action = request.json[\"action\"]\n    job_hash, queue_position = queue.push({\"data\": data}, action)\n    return {\"hash\": job_hash, \"queue_position\": queue_position}\n\n\n@app.route(\"/api/queue/status/\", methods=[\"POST\"])\n@login_check\ndef queue_status():\n    hash = request.json['hash']\n    status, data = queue.get_status(hash)\n    return {\"status\": status, \"data\": data}\n\n\ndef queue_thread(path_to_local_server, test_mode=False):\n    while True:\n        try:\n            next_job = queue.pop()\n            if next_job is not None:\n                _, hash, input_data, task_type = next_job\n                queue.start_job(hash)\n                response = requests.post(\n                    path_to_local_server + \"/api/\" + task_type + \"/\", json=input_data)\n                if response.status_code == 200:\n                    queue.pass_job(hash, response.json())\n                else:\n                    queue.fail_job(hash, response.text)\n            else:\n                time.sleep(1)\n        except Exception as e:\n            time.sleep(1)\n            pass\n        if test_mode:\n            break\n\n\ndef start_server(interface, server_name, server_port=None, auth=None, ssl=None):\n    if server_port is None:\n        server_port = INITIAL_PORT_VALUE\n    port = get_first_available_port(\n        server_port, server_port + TRY_NUM_PORTS\n    )\n    path_to_local_server = \"http://{}:{}/\".format(server_name, port)\n    if auth is not None:\n        if not callable(auth):\n            app.auth = {account[0]: account[1] for account in auth}\n        else:\n            app.auth = auth\n    else:\n        app.auth = None\n    app.interface = interface\n    app.cwd = os.getcwd()\n    log = logging.getLogger('werkzeug')\n    log.setLevel(logging.ERROR)\n    if app.interface.enable_queue:\n        if auth is not None or app.interface.encrypt:\n            raise ValueError(\"Cannot queue with encryption or authentication enabled.\")\n        queue.init()\n        app.queue_thread = threading.Thread(target=queue_thread, args=(path_to_local_server,))\n        app.queue_thread.start()\n    if interface.save_to is not None:\n        interface.save_to[\"port\"] = port\n    app_kwargs = {\"port\": port, \"host\": server_name}\n    if ssl:\n        app_kwargs[\"ssl_context\"] = ssl\n    thread = threading.Thread(target=app.run,\n                              kwargs=app_kwargs,\n                              daemon=True)\n    thread.start()\n\n    return port, path_to_local_server, app, thread\n\ndef get_state():\n    return session.get(\"state\")\n\ndef set_state(value):\n    session[\"state\"] = value\n\ndef close_server(process):\n    process.terminate()\n    process.join()\n\n\ndef url_request(url):\n    try:\n        req = urllib.request.Request(\n            url=url, headers={\"content-type\": \"application/json\"}\n        )\n        res = urllib.request.urlopen(req, timeout=10)\n        return res\n    except Exception as e:\n        raise RuntimeError(str(e))\n\n\ndef setup_tunnel(local_server_port, endpoint):\n    response = url_request(\n        endpoint + '/v1/tunnel-request' if endpoint is not None else GRADIO_API_SERVER)\n    if response and response.code == 200:\n        try:\n            payload = json.loads(response.read().decode(\"utf-8\"))[0]\n            return create_tunnel(payload, LOCALHOST_NAME, local_server_port)\n\n        except Exception as e:\n            raise RuntimeError(str(e))\n\n\ndef url_ok(url):\n    try:\n        for _ in range(5):\n            time.sleep(.500)\n            r = requests.head(url, timeout=3)\n            if r.status_code in (200, 401, 302):  # 401 or 302 if auth is set\n                return True\n    except (ConnectionError, requests.exceptions.ConnectionError):\n        return False\n"], "filenames": ["gradio/networking.py"], "buggy_code_start_loc": [380], "buggy_code_end_loc": [389], "fixing_code_start_loc": [379], "fixing_code_end_loc": [388], "type": "CWE-22", "message": "Gradio is an open source framework for building interactive machine learning models and demos. In versions prior to 2.5.0 there is a vulnerability that affects anyone who creates and publicly shares Gradio interfaces. File paths are not restricted and users who receive a Gradio link can access any files on the host computer if they know the file names or file paths. This is limited only by the host operating system. Paths are opened in read only mode. The problem has been patched in gradio 2.5.0.", "other": {"cve": {"id": "CVE-2021-43831", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-15T20:15:08.620", "lastModified": "2021-12-21T15:43:51.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Gradio is an open source framework for building interactive machine learning models and demos. In versions prior to 2.5.0 there is a vulnerability that affects anyone who creates and publicly shares Gradio interfaces. File paths are not restricted and users who receive a Gradio link can access any files on the host computer if they know the file names or file paths. This is limited only by the host operating system. Paths are opened in read only mode. The problem has been patched in gradio 2.5.0."}, {"lang": "es", "value": "Gradio es un marco de trabajo de c\u00f3digo abierto para la construcci\u00f3n de modelos y demostraciones interactivas de aprendizaje autom\u00e1tico. En las versiones anteriores a 2.5.0, se presenta una vulnerabilidad que afecta a cualquiera que cree y comparta p\u00fablicamente interfaces de Gradio. Las rutas de los archivos no est\u00e1n restringidas y los usuarios que reciben un enlace de Gradio pueden acceder a cualquier archivo del ordenador anfitri\u00f3n si conocen los nombres o las rutas de los archivos. Esto est\u00e1 limitado \u00fanicamente por el sistema operativo del host. Las rutas son abiertas en modo de s\u00f3lo lectura. El problema ha sido parcheado en gradio versi\u00f3n 2.5.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gradio_project:gradio:*:*:*:*:*:python:*:*", "versionEndExcluding": "2.5.0", "matchCriteriaId": "508FA58D-C2C5-4F4D-9935-8B8771781E56"}]}]}], "references": [{"url": "https://github.com/gradio-app/gradio/commit/41bd3645bdb616e1248b2167ca83636a2653f781", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gradio-app/gradio/security/advisories/GHSA-rhq2-3vr9-6mcr", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gradio-app/gradio/commit/41bd3645bdb616e1248b2167ca83636a2653f781"}}