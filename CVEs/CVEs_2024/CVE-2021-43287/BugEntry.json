{"buggy_code": ["/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.addon.businesscontinuity.primary.controller;\n\nimport com.google.gson.Gson;\nimport com.thoughtworks.go.addon.businesscontinuity.ConfigFileType;\nimport com.thoughtworks.go.addon.businesscontinuity.DatabaseStatusProvider;\nimport com.thoughtworks.go.addon.businesscontinuity.FileDetails;\nimport com.thoughtworks.go.addon.businesscontinuity.PluginsList;\nimport com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;\nimport com.thoughtworks.go.addon.businesscontinuity.primary.service.GoFilesStatusProvider;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.apache.commons.io.IOUtils.copy;\nimport static org.apache.commons.lang3.StringUtils.isBlank;\nimport static org.apache.commons.lang3.StringUtils.isEmpty;\n\n@Controller\n@SuppressWarnings(\"WeakerAccess\")\n@RequestMapping(value = \"/add-on/business-continuity/api\")\npublic class PrimaryStatusProviderController {\n\n    private GoFilesStatusProvider goFilesStatusProvider;\n    private DatabaseStatusProvider databaseStatusProvider;\n    private final SystemEnvironment systemEnvironment;\n    private PluginsList pluginsList;\n\n    @Autowired\n    public PrimaryStatusProviderController(GoFilesStatusProvider goFilesStatusProvider, DatabaseStatusProvider databaseStatusProvider, PluginsList pluginsList, SystemEnvironment systemEnvironment) {\n        this.goFilesStatusProvider = goFilesStatusProvider;\n        this.databaseStatusProvider = databaseStatusProvider;\n        this.pluginsList = pluginsList;\n        this.systemEnvironment = systemEnvironment;\n    }\n\n    @RequestMapping(value = \"/health-check\", method = RequestMethod.GET)\n    @ResponseBody\n    public String healthCheck() {\n        return \"OK!\";\n    }\n\n    @RequestMapping(value = \"/latest_database_wal_location\", method = RequestMethod.GET)\n    @ResponseBody\n    public String latestDatabaseWalLocation() {\n        return databaseStatusProvider.latestWalLocation();\n    }\n\n    @RequestMapping(value = \"/config_files_status\", method = RequestMethod.GET)\n    public void latestStatus(HttpServletResponse response) throws IOException {\n        Map<ConfigFileType, String> latestFileStatusMap = goFilesStatusProvider.getLatestStatusMap();\n\n        Map<ConfigFileType, FileDetails> fileDetailsMap = new HashMap<>();\n        for (ConfigFileType configFileType : latestFileStatusMap.keySet()) {\n            if (!isEmpty(latestFileStatusMap.get(configFileType))) {\n                fileDetailsMap.put(configFileType, new FileDetails(latestFileStatusMap.get(configFileType)));\n            }\n        }\n\n        ServerStatusResponse serverStatusResponse = new ServerStatusResponse(goFilesStatusProvider.updateInterval(), goFilesStatusProvider.getLastUpdateTime(), fileDetailsMap);\n        String responseBody = new Gson().toJson(serverStatusResponse);\n        response.setContentType(\"application/json\");\n        response.getOutputStream().print(responseBody);\n    }\n\n    @RequestMapping(value = \"/cruise_config\", method = RequestMethod.GET)\n    public void getLatestCruiseConfigXML(HttpServletResponse response) {\n        serveFile(ConfigFileType.CRUISE_CONFIG_XML.load(systemEnvironment), response, \"text/xml\");\n    }\n\n    @RequestMapping(value = \"/user_feature_toggle\", method = RequestMethod.GET)\n    public void geUserFeatureToggleFile(HttpServletResponse response) {\n        serveFile(ConfigFileType.USER_FEATURE_TOGGLE.load(systemEnvironment), response, \"text/json\");\n    }\n\n    @RequestMapping(value = \"/cipher.aes\", method = RequestMethod.GET)\n    public void getLatestAESCipher(HttpServletResponse response) {\n        serveFile(ConfigFileType.AES_CIPHER.load(systemEnvironment), response, \"text/plain\");\n    }\n\n    @RequestMapping(value = \"/jetty_config\", method = RequestMethod.GET)\n    public void getLatestJettyXML(HttpServletResponse response) {\n        serveFile(ConfigFileType.JETTY_XML.load(systemEnvironment), response, \"text/xml\");\n    }\n\n    @RequestMapping(value = \"/plugin_files_status\", method = RequestMethod.GET)\n    public void latest(HttpServletResponse response) throws IOException {\n        String pluginsJSON = pluginsList.getPluginsJSON();\n        response.setContentType(\"application/json\");\n        response.getOutputStream().print(pluginsJSON);\n    }\n\n    @RequestMapping(value = \"/plugin\", method = RequestMethod.GET)\n    public void getPluginFile(\n            @RequestParam(\"folderName\") String folderName,\n            @RequestParam(\"pluginName\") String pluginName,\n            HttpServletResponse response) {\n        String pluginFolderPath = isBlank(folderName) || folderName.equalsIgnoreCase(\"bundled\") ? systemEnvironment.getBundledPluginAbsolutePath() : systemEnvironment.getExternalPluginAbsolutePath();\n        File pluginFile = new File(pluginFolderPath, pluginName);\n        serveFile(pluginFile, response, \"application/octet-stream\");\n    }\n\n    private void serveFile(File file, HttpServletResponse response, String contentType) {\n        try (FileInputStream inputStream = new FileInputStream(file)) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.setCharacterEncoding(\"UTF-8\");\n            response.setContentType(contentType);\n            copy(inputStream, response.getOutputStream());\n            response.flushBuffer();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.addon.businesscontinuity.standby.controller;\n\nimport com.google.common.collect.Sets;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.thoughtworks.go.CurrentGoCDVersion;\nimport com.thoughtworks.go.addon.businesscontinuity.*;\nimport com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;\nimport com.thoughtworks.go.addon.businesscontinuity.standby.service.PrimaryServerCommunicationService;\nimport com.thoughtworks.go.addon.businesscontinuity.standby.service.StandbyFileSyncService;\nimport com.thoughtworks.go.server.newsecurity.models.UsernamePassword;\nimport com.thoughtworks.go.server.service.RailsAssetsService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.stream.Collectors;\n\nimport static com.thoughtworks.go.server.newsecurity.utils.BasicAuthHeaderExtractor.extractBasicAuthenticationCredentials;\nimport static java.lang.String.format;\nimport static org.apache.commons.lang3.StringUtils.join;\n\n@Controller\npublic class DashBoardController {\n\n    private final AuthToken authToken;\n    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardHTML;\n    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardJSON;\n    private AddOnConfiguration addOnConfiguration;\n    private PrimaryServerCommunicationService primaryServerCommunicationService;\n    private StandbyFileSyncService standbyFileSyncService;\n    private ViewResolver viewResolver;\n    private DatabaseStatusProvider databaseStatusProvider;\n    private RailsAssetsService railsAssetsService;\n    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().setDateFormat(\"MMM d, YYYY HH:mm:ss\").create();\n\n    private static final String CREDENTIALS_KEY = DashBoardController.class.getName() + \".existing-credentials\";\n\n    @Autowired\n    public DashBoardController(AddOnConfiguration addOnConfiguration, PrimaryServerCommunicationService primaryServerCommunicationService,\n                               StandbyFileSyncService standbyFileSyncService,\n                               ViewResolver viewResolver, DatabaseStatusProvider databaseStatusProvider, RailsAssetsService railsAssetsService, AuthToken authToken) {\n        this.addOnConfiguration = addOnConfiguration;\n        this.primaryServerCommunicationService = primaryServerCommunicationService;\n        this.standbyFileSyncService = standbyFileSyncService;\n        this.viewResolver = viewResolver;\n        this.databaseStatusProvider = databaseStatusProvider;\n        this.railsAssetsService = railsAssetsService;\n        this.authToken = authToken;\n        this.dashboardHTML = this::showStatusPage;\n        this.dashboardJSON = this::showStatusJSON;\n    }\n\n    @RequestMapping(value = \"/add-on/business-continuity/admin/dashboard\", method = RequestMethod.GET)\n    @ResponseBody\n    public String dashboard(HttpServletRequest request, HttpServletResponse response) {\n        return renderAfterAuthentication(request, response, dashboardHTML);\n    }\n\n    @RequestMapping(value = \"/add-on/business-continuity/admin/dashboard.json\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    @ResponseBody\n    public String dashboardData(HttpServletRequest request, HttpServletResponse response) {\n        return renderAfterAuthentication(request, response, dashboardJSON);\n    }\n\n    private String renderAfterAuthentication(HttpServletRequest request, HttpServletResponse response, BiFunction<HttpServletRequest, HttpServletResponse, String> renderer) {\n        if (!authToken.isValid()) {\n            response.setStatus(422);\n            return \"Please setup business continuity according to the documentation at https://extensions-docs.gocd.org/business-continuity/\" + CurrentGoCDVersion.getInstance().goVersion();\n        }\n        HttpSession session = request.getSession();\n\n        UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));\n        UsernamePassword credentialsOnDisk = authToken.toUsernamePassword();\n        UsernamePassword existingCredentialsInSession = (UsernamePassword) session.getAttribute(CREDENTIALS_KEY);\n\n        HashSet<UsernamePassword> submittedPasswords = Sets.newHashSet(usernamePassword, existingCredentialsInSession);\n        submittedPasswords.remove(null);\n\n        if (submittedPasswords.isEmpty()) {\n            return forceBasicAuth(request, response);\n        }\n\n        if (submittedPasswords.stream().allMatch(up -> up.equals(credentialsOnDisk))) {\n            return renderer.apply(request, response);\n        }\n\n        if (credentialsOnDisk.equals(usernamePassword)) {\n            session.invalidate();\n            loginCurrentUser(request, request.getSession(true), usernamePassword);\n            return renderer.apply(request, response);\n        }\n\n        return forceBasicAuth(request, response);\n    }\n\n    private void loginCurrentUser(HttpServletRequest request, HttpSession session, UsernamePassword usernamePassword) {\n        session.invalidate();\n        session = request.getSession(true);\n        session.setAttribute(CREDENTIALS_KEY, usernamePassword);\n    }\n\n    private String showStatusPage(HttpServletRequest request, HttpServletResponse response) {\n        Map<String, String> modelMap = new HashMap<>();\n        modelMap.put(\"REPLACED_BY_GO:application.css\", railsAssetsService.getAssetPath(\"application.css\"));\n        modelMap.put(\"REPLACED_BY_GO:patterns/application.css\", railsAssetsService.getAssetPath(\"patterns/application.css\"));\n        modelMap.put(\"REPLACED_BY_GO:application.js\", railsAssetsService.getAssetPath(\"application.js\"));\n        modelMap.put(\"REPLACED_BY_GO:cruise.ico\", railsAssetsService.getAssetPath(\"cruise.ico\"));\n        if (addOnConfiguration.isServerInStandby()) {\n            return viewResolver.resolveView(\"standby_dashboard\", modelMap);\n        } else {\n            return viewResolver.resolveView(\"error\", modelMap);\n        }\n    }\n\n    private String forceBasicAuth(HttpServletRequest request, HttpServletResponse response) {\n        response.addHeader(\"WWW-Authenticate\", \"Basic realm=\\\"GoCD Business Continuity\\\"\");\n        response.setStatus(401);\n        return \"bad credentials!\";\n    }\n\n    private String showStatusJSON(HttpServletRequest request, HttpServletResponse response) {\n        response.setContentType(\"application/json\");\n        if (addOnConfiguration.isServerInStandby()) {\n\n            Map<String, Object> dashboardContent = new HashMap<>();\n            UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));\n            dashboardContent.put(\"userName\", usernamePassword.getUsername());\n            if (!primaryServerCommunicationService.ableToConnect()) {\n                dashboardContent.put(\"setupStatus\", \"incomplete\");\n                dashboardContent.put(\"syncErrors\", Collections.singletonList(\"Unable to connect to primary, please check that the business-continuity-token file is identical on primary and secondary, and that this server can connect to the primary server.\"));\n            } else {\n                dashboardContent.put(\"setupStatus\", \"success\");\n                dashboardContent.put(\"primaryServerDetails\", primaryServerDetails());\n                dashboardContent.put(\"standbyServerDetails\", standbyServerDetails());\n                dashboardContent.put(\"syncErrors\", standbyFileSyncService.syncErrors());\n            }\n            return GSON.toJson(dashboardContent);\n        }\n        throw new RuntimeException(\"This information only available for standby server\");\n    }\n\n    Map<String, Object> standbyServerDetails() {\n        Map<String, Object> details = new HashMap<>();\n        details.put(\"primaryStatusCheckInterval\", standbyFileSyncService.primaryStatusCheckInterval());\n        details.put(\"lastUpdateTime\", new Date(standbyFileSyncService.lastUpdateTime()));\n        details.put(\"latestReceivedDatabaseWalLocation\", databaseStatusProvider.latestReceivedWalLocation());\n        Map<ConfigFileType, String> currentFileStatus = standbyFileSyncService.getCurrentFileStatus();\n        for (ConfigFileType configFileType : currentFileStatus.keySet()) {\n            details.put(configFileType.name(), currentFileStatus.get(configFileType));\n        }\n        details.put(\"pluginStatus\", standbyPluginStatus());\n        return details;\n    }\n\n    Map<String, Object> primaryServerDetails() {\n        Map<String, Object> details = new HashMap<>();\n\n        String primaryServerUrl = primaryServerCommunicationService.primaryServerUrl();\n        details.put(\"url\", primaryServerUrl);\n\n\n        try {\n            details.put(\"latestDatabaseWalLocation\", primaryServerCommunicationService.latestDatabaseWalLocation());\n            ServerStatusResponse latestFileStatus = primaryServerCommunicationService.getLatestFileStatus();\n            details.put(\"configFilesUpdateInterval\", latestFileStatus.getConfigFilesUpdateInterval());\n            details.put(\"lastConfigUpdateTime\", new Date(latestFileStatus.getLastConfigFilesUpdateTime()));\n            Map<ConfigFileType, FileDetails> fileDetailsMap = latestFileStatus.getFileDetailsMap();\n            for (ConfigFileType fileType : fileDetailsMap.keySet()) {\n                details.put(fileType.name(), fileDetailsMap.get(fileType));\n            }\n\n            details.put(\"pluginStatus\", primaryPluginStatus());\n        } catch (Exception e) {\n            details.put(\"error\", format(\"Could not fetch latest file status from master, Reason, %s\", e.getMessage()));\n        }\n        return details;\n    }\n\n    private String standbyPluginStatus() {\n        final Map<String, String> currentExternalPluginsStatus = standbyFileSyncService.getCurrentExternalPluginsStatus();\n        List<String> pluginsMd5 = currentExternalPluginsStatus.keySet().stream().map(pluginName -> format(\"%s=%s\", pluginName, currentExternalPluginsStatus.get(pluginName))).sorted().collect(Collectors.toList());\n\n        return join(pluginsMd5, \", \");\n    }\n\n    private String primaryPluginStatus() {\n        List<Map> externalPlugins = (List<Map>) primaryServerCommunicationService.getLatestPluginsStatus().get(\"external\");\n        return externalPlugins.stream().map(map -> format(\"%s=%s\", map.get(\"name\"), map.get(\"md5\"))).collect(Collectors.joining(\", \"));\n    }\n\n}\n"], "fixing_code": ["/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.addon.businesscontinuity.primary.controller;\n\nimport com.google.gson.Gson;\nimport com.thoughtworks.go.addon.businesscontinuity.ConfigFileType;\nimport com.thoughtworks.go.addon.businesscontinuity.DatabaseStatusProvider;\nimport com.thoughtworks.go.addon.businesscontinuity.FileDetails;\nimport com.thoughtworks.go.addon.businesscontinuity.PluginsList;\nimport com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;\nimport com.thoughtworks.go.addon.businesscontinuity.primary.service.GoFilesStatusProvider;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.apache.commons.io.IOUtils.copy;\nimport static org.apache.commons.lang3.StringUtils.isBlank;\nimport static org.apache.commons.lang3.StringUtils.isEmpty;\n\n@Controller\n@SuppressWarnings(\"WeakerAccess\")\npublic class PrimaryStatusProviderController {\n\n    private GoFilesStatusProvider goFilesStatusProvider;\n    private DatabaseStatusProvider databaseStatusProvider;\n    private final SystemEnvironment systemEnvironment;\n    private PluginsList pluginsList;\n\n    @Autowired\n    public PrimaryStatusProviderController(GoFilesStatusProvider goFilesStatusProvider, DatabaseStatusProvider databaseStatusProvider, PluginsList pluginsList, SystemEnvironment systemEnvironment) {\n        this.goFilesStatusProvider = goFilesStatusProvider;\n        this.databaseStatusProvider = databaseStatusProvider;\n        this.pluginsList = pluginsList;\n        this.systemEnvironment = systemEnvironment;\n    }\n\n    @RequestMapping(value = \"/health-check\", method = RequestMethod.GET)\n    @ResponseBody\n    public String healthCheck() {\n        return \"OK!\";\n    }\n\n    @RequestMapping(value = \"/latest_database_wal_location\", method = RequestMethod.GET)\n    @ResponseBody\n    public String latestDatabaseWalLocation() {\n        return databaseStatusProvider.latestWalLocation();\n    }\n\n    @RequestMapping(value = \"/config_files_status\", method = RequestMethod.GET)\n    public void latestStatus(HttpServletResponse response) throws IOException {\n        Map<ConfigFileType, String> latestFileStatusMap = goFilesStatusProvider.getLatestStatusMap();\n\n        Map<ConfigFileType, FileDetails> fileDetailsMap = new HashMap<>();\n        for (ConfigFileType configFileType : latestFileStatusMap.keySet()) {\n            if (!isEmpty(latestFileStatusMap.get(configFileType))) {\n                fileDetailsMap.put(configFileType, new FileDetails(latestFileStatusMap.get(configFileType)));\n            }\n        }\n\n        ServerStatusResponse serverStatusResponse = new ServerStatusResponse(goFilesStatusProvider.updateInterval(), goFilesStatusProvider.getLastUpdateTime(), fileDetailsMap);\n        String responseBody = new Gson().toJson(serverStatusResponse);\n        response.setContentType(\"application/json\");\n        response.getOutputStream().print(responseBody);\n    }\n\n    @RequestMapping(value = \"/cruise_config\", method = RequestMethod.GET)\n    public void getLatestCruiseConfigXML(HttpServletResponse response) {\n        serveFile(ConfigFileType.CRUISE_CONFIG_XML.load(systemEnvironment), response, \"text/xml\");\n    }\n\n    @RequestMapping(value = \"/user_feature_toggle\", method = RequestMethod.GET)\n    public void geUserFeatureToggleFile(HttpServletResponse response) {\n        serveFile(ConfigFileType.USER_FEATURE_TOGGLE.load(systemEnvironment), response, \"text/json\");\n    }\n\n    @RequestMapping(value = \"/cipher.aes\", method = RequestMethod.GET)\n    public void getLatestAESCipher(HttpServletResponse response) {\n        serveFile(ConfigFileType.AES_CIPHER.load(systemEnvironment), response, \"text/plain\");\n    }\n\n    @RequestMapping(value = \"/jetty_config\", method = RequestMethod.GET)\n    public void getLatestJettyXML(HttpServletResponse response) {\n        serveFile(ConfigFileType.JETTY_XML.load(systemEnvironment), response, \"text/xml\");\n    }\n\n    @RequestMapping(value = \"/plugin_files_status\", method = RequestMethod.GET)\n    public void latest(HttpServletResponse response) throws IOException {\n        String pluginsJSON = pluginsList.getPluginsJSON();\n        response.setContentType(\"application/json\");\n        response.getOutputStream().print(pluginsJSON);\n    }\n\n    @RequestMapping(value = \"/plugin\", method = RequestMethod.GET)\n    public void getPluginFile(\n            @RequestParam(\"folderName\") String folderName,\n            @RequestParam(\"pluginName\") String pluginName,\n            HttpServletResponse response) {\n        String pluginFolderPath = isBlank(folderName) || folderName.equalsIgnoreCase(\"bundled\") ? systemEnvironment.getBundledPluginAbsolutePath() : systemEnvironment.getExternalPluginAbsolutePath();\n        File pluginFile = new File(pluginFolderPath, pluginName);\n        serveFile(pluginFile, response, \"application/octet-stream\");\n    }\n\n    private void serveFile(File file, HttpServletResponse response, String contentType) {\n        try (FileInputStream inputStream = new FileInputStream(file)) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.setCharacterEncoding(\"UTF-8\");\n            response.setContentType(contentType);\n            copy(inputStream, response.getOutputStream());\n            response.flushBuffer();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.addon.businesscontinuity.standby.controller;\n\nimport com.google.common.collect.Sets;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport com.thoughtworks.go.CurrentGoCDVersion;\nimport com.thoughtworks.go.addon.businesscontinuity.*;\nimport com.thoughtworks.go.addon.businesscontinuity.primary.ServerStatusResponse;\nimport com.thoughtworks.go.addon.businesscontinuity.standby.service.PrimaryServerCommunicationService;\nimport com.thoughtworks.go.addon.businesscontinuity.standby.service.StandbyFileSyncService;\nimport com.thoughtworks.go.server.newsecurity.models.UsernamePassword;\nimport com.thoughtworks.go.server.service.RailsAssetsService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.stream.Collectors;\n\nimport static com.thoughtworks.go.server.newsecurity.utils.BasicAuthHeaderExtractor.extractBasicAuthenticationCredentials;\nimport static java.lang.String.format;\nimport static org.apache.commons.lang3.StringUtils.join;\n\n@Controller\npublic class DashBoardController {\n\n    private final AuthToken authToken;\n    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardHTML;\n    private final BiFunction<HttpServletRequest, HttpServletResponse, String> dashboardJSON;\n    private AddOnConfiguration addOnConfiguration;\n    private PrimaryServerCommunicationService primaryServerCommunicationService;\n    private StandbyFileSyncService standbyFileSyncService;\n    private ViewResolver viewResolver;\n    private DatabaseStatusProvider databaseStatusProvider;\n    private RailsAssetsService railsAssetsService;\n    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().setDateFormat(\"MMM d, YYYY HH:mm:ss\").create();\n\n    private static final String CREDENTIALS_KEY = DashBoardController.class.getName() + \".existing-credentials\";\n\n    @Autowired\n    public DashBoardController(AddOnConfiguration addOnConfiguration, PrimaryServerCommunicationService primaryServerCommunicationService,\n                               StandbyFileSyncService standbyFileSyncService,\n                               ViewResolver viewResolver, DatabaseStatusProvider databaseStatusProvider, RailsAssetsService railsAssetsService, AuthToken authToken) {\n        this.addOnConfiguration = addOnConfiguration;\n        this.primaryServerCommunicationService = primaryServerCommunicationService;\n        this.standbyFileSyncService = standbyFileSyncService;\n        this.viewResolver = viewResolver;\n        this.databaseStatusProvider = databaseStatusProvider;\n        this.railsAssetsService = railsAssetsService;\n        this.authToken = authToken;\n        this.dashboardHTML = this::showStatusPage;\n        this.dashboardJSON = this::showStatusJSON;\n    }\n\n    @ResponseBody\n    public String dashboard(HttpServletRequest request, HttpServletResponse response) {\n        return renderAfterAuthentication(request, response, dashboardHTML);\n    }\n\n    @ResponseBody\n    public String dashboardData(HttpServletRequest request, HttpServletResponse response) {\n        return renderAfterAuthentication(request, response, dashboardJSON);\n    }\n\n    private String renderAfterAuthentication(HttpServletRequest request, HttpServletResponse response, BiFunction<HttpServletRequest, HttpServletResponse, String> renderer) {\n        if (!authToken.isValid()) {\n            response.setStatus(422);\n            return \"Please setup business continuity according to the documentation at https://extensions-docs.gocd.org/business-continuity/\" + CurrentGoCDVersion.getInstance().goVersion();\n        }\n        HttpSession session = request.getSession();\n\n        UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));\n        UsernamePassword credentialsOnDisk = authToken.toUsernamePassword();\n        UsernamePassword existingCredentialsInSession = (UsernamePassword) session.getAttribute(CREDENTIALS_KEY);\n\n        HashSet<UsernamePassword> submittedPasswords = Sets.newHashSet(usernamePassword, existingCredentialsInSession);\n        submittedPasswords.remove(null);\n\n        if (submittedPasswords.isEmpty()) {\n            return forceBasicAuth(request, response);\n        }\n\n        if (submittedPasswords.stream().allMatch(up -> up.equals(credentialsOnDisk))) {\n            return renderer.apply(request, response);\n        }\n\n        if (credentialsOnDisk.equals(usernamePassword)) {\n            session.invalidate();\n            loginCurrentUser(request, request.getSession(true), usernamePassword);\n            return renderer.apply(request, response);\n        }\n\n        return forceBasicAuth(request, response);\n    }\n\n    private void loginCurrentUser(HttpServletRequest request, HttpSession session, UsernamePassword usernamePassword) {\n        session.invalidate();\n        session = request.getSession(true);\n        session.setAttribute(CREDENTIALS_KEY, usernamePassword);\n    }\n\n    private String showStatusPage(HttpServletRequest request, HttpServletResponse response) {\n        Map<String, String> modelMap = new HashMap<>();\n        modelMap.put(\"REPLACED_BY_GO:application.css\", railsAssetsService.getAssetPath(\"application.css\"));\n        modelMap.put(\"REPLACED_BY_GO:patterns/application.css\", railsAssetsService.getAssetPath(\"patterns/application.css\"));\n        modelMap.put(\"REPLACED_BY_GO:application.js\", railsAssetsService.getAssetPath(\"application.js\"));\n        modelMap.put(\"REPLACED_BY_GO:cruise.ico\", railsAssetsService.getAssetPath(\"cruise.ico\"));\n        if (addOnConfiguration.isServerInStandby()) {\n            return viewResolver.resolveView(\"standby_dashboard\", modelMap);\n        } else {\n            return viewResolver.resolveView(\"error\", modelMap);\n        }\n    }\n\n    private String forceBasicAuth(HttpServletRequest request, HttpServletResponse response) {\n        response.addHeader(\"WWW-Authenticate\", \"Basic realm=\\\"GoCD Business Continuity\\\"\");\n        response.setStatus(401);\n        return \"bad credentials!\";\n    }\n\n    private String showStatusJSON(HttpServletRequest request, HttpServletResponse response) {\n        response.setContentType(\"application/json\");\n        if (addOnConfiguration.isServerInStandby()) {\n\n            Map<String, Object> dashboardContent = new HashMap<>();\n            UsernamePassword usernamePassword = extractBasicAuthenticationCredentials(request.getHeader(\"Authorization\"));\n            dashboardContent.put(\"userName\", usernamePassword.getUsername());\n            if (!primaryServerCommunicationService.ableToConnect()) {\n                dashboardContent.put(\"setupStatus\", \"incomplete\");\n                dashboardContent.put(\"syncErrors\", Collections.singletonList(\"Unable to connect to primary, please check that the business-continuity-token file is identical on primary and secondary, and that this server can connect to the primary server.\"));\n            } else {\n                dashboardContent.put(\"setupStatus\", \"success\");\n                dashboardContent.put(\"primaryServerDetails\", primaryServerDetails());\n                dashboardContent.put(\"standbyServerDetails\", standbyServerDetails());\n                dashboardContent.put(\"syncErrors\", standbyFileSyncService.syncErrors());\n            }\n            return GSON.toJson(dashboardContent);\n        }\n        throw new RuntimeException(\"This information only available for standby server\");\n    }\n\n    Map<String, Object> standbyServerDetails() {\n        Map<String, Object> details = new HashMap<>();\n        details.put(\"primaryStatusCheckInterval\", standbyFileSyncService.primaryStatusCheckInterval());\n        details.put(\"lastUpdateTime\", new Date(standbyFileSyncService.lastUpdateTime()));\n        details.put(\"latestReceivedDatabaseWalLocation\", databaseStatusProvider.latestReceivedWalLocation());\n        Map<ConfigFileType, String> currentFileStatus = standbyFileSyncService.getCurrentFileStatus();\n        for (ConfigFileType configFileType : currentFileStatus.keySet()) {\n            details.put(configFileType.name(), currentFileStatus.get(configFileType));\n        }\n        details.put(\"pluginStatus\", standbyPluginStatus());\n        return details;\n    }\n\n    Map<String, Object> primaryServerDetails() {\n        Map<String, Object> details = new HashMap<>();\n\n        String primaryServerUrl = primaryServerCommunicationService.primaryServerUrl();\n        details.put(\"url\", primaryServerUrl);\n\n\n        try {\n            details.put(\"latestDatabaseWalLocation\", primaryServerCommunicationService.latestDatabaseWalLocation());\n            ServerStatusResponse latestFileStatus = primaryServerCommunicationService.getLatestFileStatus();\n            details.put(\"configFilesUpdateInterval\", latestFileStatus.getConfigFilesUpdateInterval());\n            details.put(\"lastConfigUpdateTime\", new Date(latestFileStatus.getLastConfigFilesUpdateTime()));\n            Map<ConfigFileType, FileDetails> fileDetailsMap = latestFileStatus.getFileDetailsMap();\n            for (ConfigFileType fileType : fileDetailsMap.keySet()) {\n                details.put(fileType.name(), fileDetailsMap.get(fileType));\n            }\n\n            details.put(\"pluginStatus\", primaryPluginStatus());\n        } catch (Exception e) {\n            details.put(\"error\", format(\"Could not fetch latest file status from master, Reason, %s\", e.getMessage()));\n        }\n        return details;\n    }\n\n    private String standbyPluginStatus() {\n        final Map<String, String> currentExternalPluginsStatus = standbyFileSyncService.getCurrentExternalPluginsStatus();\n        List<String> pluginsMd5 = currentExternalPluginsStatus.keySet().stream().map(pluginName -> format(\"%s=%s\", pluginName, currentExternalPluginsStatus.get(pluginName))).sorted().collect(Collectors.toList());\n\n        return join(pluginsMd5, \", \");\n    }\n\n    private String primaryPluginStatus() {\n        List<Map> externalPlugins = (List<Map>) primaryServerCommunicationService.getLatestPluginsStatus().get(\"external\");\n        return externalPlugins.stream().map(map -> format(\"%s=%s\", map.get(\"name\"), map.get(\"md5\"))).collect(Collectors.joining(\", \"));\n    }\n\n}\n"], "filenames": ["server/src/main/java/com/thoughtworks/go/addon/businesscontinuity/primary/controller/PrimaryStatusProviderController.java", "server/src/main/java/com/thoughtworks/go/addon/businesscontinuity/standby/controller/DashBoardController.java"], "buggy_code_start_loc": [47, 78], "buggy_code_end_loc": [48, 85], "fixing_code_start_loc": [46, 77], "fixing_code_end_loc": [46, 82], "type": "CWE-200", "message": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. The business continuity add-on, which is enabled by default, leaks all secrets known to the GoCD server to unauthenticated attackers.", "other": {"cve": {"id": "CVE-2021-43287", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-14T12:15:07.717", "lastModified": "2022-04-21T20:33:12.833", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ThoughtWorks GoCD before 21.3.0. The business continuity add-on, which is enabled by default, leaks all secrets known to the GoCD server to unauthenticated attackers."}, {"lang": "es", "value": "Se ha detectado un problema en ThoughtWorks GoCD versiones anteriores a 21.3.0. El complemento de continuidad del negocio, que est\u00e1 habilitado por defecto, filtra todos los secretos conocidos por el servidor GoCD a atacantes no autenticados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thoughtworks:gocd:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.3.0", "matchCriteriaId": "96C28DAA-9A8B-46E3-9443-656B378A26D8"}]}]}], "references": [{"url": "https://blog.sonarsource.com/gocd-pre-auth-pipeline-takeover", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/gocd/gocd/commit/41abc210ac4e8cfa184483c9ff1c0cc04fb3511c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.gocd.org/releases/#21-3-0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gocd/gocd/commit/41abc210ac4e8cfa184483c9ff1c0cc04fb3511c"}}