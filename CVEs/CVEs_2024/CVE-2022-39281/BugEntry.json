{"buggy_code": ["# frozen_string_literal: true\n\n# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\n# == Schema Information\n#\n# Table name: tasks\n#\n#  id              :integer         not null, primary key\n#  user_id         :integer\n#  assigned_to     :integer\n#  completed_by    :integer\n#  name            :string(255)     default(\"\"), not null\n#  asset_id        :integer\n#  asset_type      :string(255)\n#  priority        :string(32)\n#  category        :string(32)\n#  bucket          :string(32)\n#  due_at          :datetime\n#  completed_at    :datetime\n#  deleted_at      :datetime\n#  created_at      :datetime\n#  updated_at      :datetime\n#  background_info :string(255)\n#\n\nclass Task < ActiveRecord::Base\n  include ActiveModel::Serializers::Xml\n\n  attr_accessor :calendar\n\n  ALLOWED_VIEWS = %w[pending assigned completed]\n\n  belongs_to :user\n  belongs_to :assignee, class_name: \"User\", foreign_key: :assigned_to, optional: true # TODO: Is this really optional?\n  belongs_to :completor, class_name: \"User\", foreign_key: :completed_by, optional: true # TODO: Is this really optional?\n  belongs_to :asset, polymorphic: true, optional: true # TODO: Is this really optional?\n\n  serialize :subscribed_users, Array\n\n  # Tasks created by the user for herself, or assigned to her by others. That's\n  # what gets shown on Tasks/Pending and Tasks/Completed pages.\n  scope :my, lambda { |*args|\n    options = args[0] || {}\n    user_option = (options.is_a?(Hash) ? options[:user] : options) || User.current_user\n    includes(:assignee)\n      .where('(user_id = ? AND assigned_to IS NULL) OR assigned_to = ?', user_option, user_option)\n      .order(options[:order] || 'name ASC')\n      .limit(options[:limit]) # nil selects all records\n  }\n\n  scope :created_by,  ->(user) { where(user_id: user.id) }\n  scope :assigned_to, ->(user) { where(assigned_to: user.id) }\n\n  # Tasks assigned by the user to others. That's what we see on Tasks/Assigned.\n  scope :assigned_by, lambda { |user|\n    includes(:assignee)\n      .where('user_id = ? AND assigned_to IS NOT NULL AND assigned_to != ?', user.id, user.id)\n  }\n\n  # Tasks created by the user or assigned to the user, i.e. the union of the two\n  # scopes above. That's the tasks the user is allowed to see and track.\n  scope :tracked_by, lambda { |user|\n    includes(:assignee)\n      .where('user_id = ? OR assigned_to = ?', user.id, user.id)\n  }\n\n  # Show tasks which either belong to the user and are unassigned, or are assigned to the user\n  scope :visible_on_dashboard, lambda { |user|\n    where('(user_id = :user_id AND assigned_to IS NULL) OR assigned_to = :user_id', user_id: user.id).where('completed_at IS NULL')\n  }\n\n  scope :by_due_at, lambda {\n    order({\n      \"MySQL\"      => \"due_at NOT NULL, due_at ASC\",\n      \"PostgreSQL\" => \"due_at ASC NULLS FIRST\"\n    }[ActiveRecord::Base.connection.adapter_name] || :due_at)\n  }\n\n  # Status based scopes to be combined with the due date and completion time.\n  scope :pending,       -> { where('completed_at IS NULL').order('tasks.due_at, tasks.id') }\n  scope :assigned,      -> { where('completed_at IS NULL AND assigned_to IS NOT NULL').order('tasks.due_at, tasks.id') }\n  scope :completed,     -> { where('completed_at IS NOT NULL').order('tasks.completed_at DESC') }\n\n  # Due date scopes.\n  scope :due_asap,      -> { where(\"due_at IS NULL AND bucket = 'due_asap'\").order('tasks.id DESC') }\n  scope :overdue,       -> { where('due_at IS NOT NULL AND due_at < ?', Time.zone.now.midnight.utc).order('tasks.id DESC') }\n  scope :due_today,     -> { where('due_at >= ? AND due_at < ?', Time.zone.now.midnight.utc, Time.zone.now.midnight.tomorrow.utc).order('tasks.id DESC') }\n  scope :due_tomorrow,  -> { where('due_at >= ? AND due_at < ?', Time.zone.now.midnight.tomorrow.utc, Time.zone.now.midnight.tomorrow.utc + 1.day).order('tasks.id DESC') }\n  scope :due_this_week, -> { where('due_at >= ? AND due_at < ?', Time.zone.now.midnight.tomorrow.utc + 1.day, Time.zone.now.next_week.utc).order('tasks.id DESC') }\n  scope :due_next_week, -> { where('due_at >= ? AND due_at < ?', Time.zone.now.next_week.utc, Time.zone.now.next_week.end_of_week.utc + 1.day).order('tasks.id DESC') }\n  scope :due_later,     -> { where(\"(due_at IS NULL AND bucket = 'due_later') OR due_at >= ?\", Time.zone.now.next_week.end_of_week.utc + 1.day).order('tasks.id DESC') }\n\n  # Completion time scopes.\n  scope :completed_today,      -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.midnight.utc, Time.zone.now.midnight.tomorrow.utc) }\n  scope :completed_yesterday,  -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.midnight.yesterday.utc, Time.zone.now.midnight.utc) }\n  scope :completed_this_week,  -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.beginning_of_week.utc, Time.zone.now.midnight.yesterday.utc) }\n  scope :completed_last_week,  -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.beginning_of_week.utc - 7.days, Time.zone.now.beginning_of_week.utc) }\n  scope :completed_this_month, -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.beginning_of_month.utc, Time.zone.now.beginning_of_week.utc - 7.days) }\n  scope :completed_last_month, -> { where('completed_at >= ? AND completed_at < ?', (Time.zone.now.beginning_of_month.utc - 1.day).beginning_of_month.utc, Time.zone.now.beginning_of_month.utc) }\n\n  scope :text_search, lambda { |query|\n    query = query.gsub(/[^\\w\\s\\-\\.'\\p{L}]/u, '').strip\n    where('upper(name) LIKE upper(?)', \"%#{query}%\")\n  }\n\n  acts_as_commentable\n  has_paper_trail versions: { class_name: 'Version' }, meta: { related: :asset },\n                  ignore: [:subscribed_users]\n  has_fields\n  exportable\n\n  validates_presence_of :user\n  validates_presence_of :name, message: :missing_task_name\n  validates_presence_of :calendar, if: -> { bucket == 'specific_time' && !completed_at }\n  validate :specific_time, unless: :completed?\n\n  before_create :set_due_date\n  before_update :set_due_date, unless: :completed?\n  before_save :notify_assignee\n\n  # Matcher for the :my named scope.\n  #----------------------------------------------------------------------------\n  def my?(user)\n    (self.user == user && assignee.nil?) || assignee == user\n  end\n\n  # Matcher for the :assigned_by named scope.\n  #----------------------------------------------------------------------------\n  def assigned_by?(user)\n    self.user == user && assignee && assignee != user\n  end\n\n  #----------------------------------------------------------------------------\n  def completed?\n    !!completed_at\n  end\n\n  # Matcher for the :tracked_by? named scope.\n  #----------------------------------------------------------------------------\n  def tracked_by?(user)\n    self.user == user || assignee == user\n  end\n\n  # Check whether the due date has specific time ignoring 23:59:59 timestamp\n  # set by Time.now.end_of_week.\n  #----------------------------------------------------------------------------\n  def at_specific_time?\n    due_at.present? && !due_end_of_day? && !due_beginning_of_day?\n  end\n\n  # Convert specific due_date to \"due_today\", \"due_tomorrow\", etc. bucket name.\n  #----------------------------------------------------------------------------\n  def computed_bucket\n    return bucket if bucket != \"specific_time\"\n\n    if overdue?\n      \"overdue\"\n    elsif due_today?\n      \"due_today\"\n    elsif due_tomorrow?\n      \"due_tomorrow\"\n    elsif due_this_week? && !due_today? && !due_tomorrow?\n      \"due_this_week\"\n    elsif due_next_week?\n      \"due_next_week\"\n    else\n      \"due_later\"\n    end\n  end\n\n  # Returns list of tasks grouping them by due date as required by tasks/index.\n  #----------------------------------------------------------------------------\n  def self.find_all_grouped(user, view)\n    return {} unless ALLOWED_VIEWS.include?(view)\n\n    settings = (view == \"completed\" ? Setting.task_completed : Setting.task_bucket)\n    Hash[\n      settings.map do |key, _value|\n        [key, view == \"assigned\" ? assigned_by(user).send(key).pending : my(user).send(key).send(view)]\n      end\n    ]\n  end\n\n  # Returns bucket if it's empty (i.e. we have to hide it), nil otherwise.\n  #----------------------------------------------------------------------------\n  def self.bucket_empty?(bucket, user, view = \"pending\")\n    return false if bucket.blank? || !ALLOWED_VIEWS.include?(view)\n\n    if view == \"assigned\"\n      assigned_by(user).send(bucket).pending.count\n    else\n      my(user).send(bucket).send(view).count\n    end == 0\n  end\n\n  # Returns task totals for each of the views as needed by tasks sidebar.\n  #----------------------------------------------------------------------------\n  def self.totals(user, view = \"pending\")\n    return {} unless ALLOWED_VIEWS.include?(view)\n\n    settings = (view == \"completed\" ? Setting.task_completed : Setting.task_bucket)\n    settings.each_with_object(HashWithIndifferentAccess[all: 0]) do |key, hash|\n      hash[key] = (view == \"assigned\" ? assigned_by(user).send(key).pending.count : my(user).send(key).send(view).count)\n      hash[:all] += hash[key]\n      hash\n    end\n  end\n\n  private\n\n  #----------------------------------------------------------------------------\n  def set_due_date\n    self.due_at = case bucket\n                  when \"overdue\"\n                    due_at || Time.zone.now.midnight.yesterday\n                  when \"due_today\"\n                    Time.zone.now.midnight\n                  when \"due_tomorrow\"\n                    Time.zone.now.midnight.tomorrow\n                  when \"due_this_week\"\n                    Time.zone.now.end_of_week\n                  when \"due_next_week\"\n                    Time.zone.now.next_week.end_of_week\n                  when \"due_later\"\n                    Time.zone.now.midnight + 100.years\n                  when \"specific_time\"\n                    calendar ? parse_calendar_date : nil\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def due_end_of_day?\n    due_at.present? && (due_at.change(usec: 0) == due_at.end_of_day.change(usec: 0))\n  end\n\n  #----------------------------------------------------------------------------\n  def due_beginning_of_day?\n    due_at.present? && (due_at == due_at.beginning_of_day)\n  end\n\n  #----------------------------------------------------------------------------\n  def overdue?\n    due_at < Time.zone.now.midnight\n  end\n\n  #----------------------------------------------------------------------------\n  def due_today?\n    due_at.between?(Time.zone.now.midnight, Time.zone.now.end_of_day)\n  end\n\n  #----------------------------------------------------------------------------\n  def due_tomorrow?\n    due_at.between?(Time.zone.now.midnight.tomorrow, Time.zone.now.tomorrow.end_of_day)\n  end\n\n  #----------------------------------------------------------------------------\n  def due_this_week?\n    due_at.between?(Time.zone.now.beginning_of_week, Time.zone.now.end_of_week)\n  end\n\n  #----------------------------------------------------------------------------\n  def due_next_week?\n    due_at.between?(Time.zone.now.next_week, Time.zone.now.next_week.end_of_week)\n  end\n\n  #----------------------------------------------------------------------------\n  def notify_assignee\n    if assigned_to\n      # Notify assignee.\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def specific_time\n    parse_calendar_date if bucket == \"specific_time\"\n  rescue ArgumentError\n    errors.add(:calendar, :invalid_date)\n  end\n\n  #----------------------------------------------------------------------------\n  def parse_calendar_date\n    # always in 2012-10-28 06:28 format regardless of language\n    Time.parse(calendar)\n  end\n\n  ActiveSupport.run_load_hooks(:fat_free_crm_task, self)\nend\n", "# frozen_string_literal: true\n\n# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nmodule FatFreeCRM\n  module VERSION # :nodoc:\n    MAJOR = 0\n    MINOR = 20\n    TINY  = 0\n    PRE   = nil\n\n    STRING = [MAJOR, MINOR, TINY, PRE].compact.join('.')\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\n# == Schema Information\n#\n# Table name: tasks\n#\n#  id              :integer         not null, primary key\n#  user_id         :integer\n#  assigned_to     :integer\n#  completed_by    :integer\n#  name            :string(255)     default(\"\"), not null\n#  asset_id        :integer\n#  asset_type      :string(255)\n#  priority        :string(32)\n#  category        :string(32)\n#  bucket          :string(32)\n#  due_at          :datetime\n#  completed_at    :datetime\n#  deleted_at      :datetime\n#  created_at      :datetime\n#  updated_at      :datetime\n#  background_info :string(255)\n#\n\nclass Task < ActiveRecord::Base\n  include ActiveModel::Serializers::Xml\n\n  attr_accessor :calendar\n\n  ALLOWED_VIEWS = %w[pending assigned completed]\n\n  belongs_to :user\n  belongs_to :assignee, class_name: \"User\", foreign_key: :assigned_to, optional: true # TODO: Is this really optional?\n  belongs_to :completor, class_name: \"User\", foreign_key: :completed_by, optional: true # TODO: Is this really optional?\n  belongs_to :asset, polymorphic: true, optional: true # TODO: Is this really optional?\n\n  serialize :subscribed_users, Array\n\n  # Tasks created by the user for herself, or assigned to her by others. That's\n  # what gets shown on Tasks/Pending and Tasks/Completed pages.\n  scope :my, lambda { |*args|\n    options = args[0] || {}\n    user_option = (options.is_a?(Hash) ? options[:user] : options) || User.current_user\n    includes(:assignee)\n      .where('(user_id = ? AND assigned_to IS NULL) OR assigned_to = ?', user_option, user_option)\n      .order(options[:order] || 'name ASC')\n      .limit(options[:limit]) # nil selects all records\n  }\n\n  scope :created_by,  ->(user) { where(user_id: user.id) }\n  scope :assigned_to, ->(user) { where(assigned_to: user.id) }\n\n  # Tasks assigned by the user to others. That's what we see on Tasks/Assigned.\n  scope :assigned_by, lambda { |user|\n    includes(:assignee)\n      .where('user_id = ? AND assigned_to IS NOT NULL AND assigned_to != ?', user.id, user.id)\n  }\n\n  # Tasks created by the user or assigned to the user, i.e. the union of the two\n  # scopes above. That's the tasks the user is allowed to see and track.\n  scope :tracked_by, lambda { |user|\n    includes(:assignee)\n      .where('user_id = ? OR assigned_to = ?', user.id, user.id)\n  }\n\n  # Show tasks which either belong to the user and are unassigned, or are assigned to the user\n  scope :visible_on_dashboard, lambda { |user|\n    where('(user_id = :user_id AND assigned_to IS NULL) OR assigned_to = :user_id', user_id: user.id).where('completed_at IS NULL')\n  }\n\n  scope :by_due_at, lambda {\n    order({\n      \"MySQL\"      => \"due_at NOT NULL, due_at ASC\",\n      \"PostgreSQL\" => \"due_at ASC NULLS FIRST\"\n    }[ActiveRecord::Base.connection.adapter_name] || :due_at)\n  }\n\n  # Status based scopes to be combined with the due date and completion time.\n  scope :pending,       -> { where('completed_at IS NULL').order('tasks.due_at, tasks.id') }\n  scope :assigned,      -> { where('completed_at IS NULL AND assigned_to IS NOT NULL').order('tasks.due_at, tasks.id') }\n  scope :completed,     -> { where('completed_at IS NOT NULL').order('tasks.completed_at DESC') }\n\n  # Due date scopes.\n  scope :due_asap,      -> { where(\"due_at IS NULL AND bucket = 'due_asap'\").order('tasks.id DESC') }\n  scope :overdue,       -> { where('due_at IS NOT NULL AND due_at < ?', Time.zone.now.midnight.utc).order('tasks.id DESC') }\n  scope :due_today,     -> { where('due_at >= ? AND due_at < ?', Time.zone.now.midnight.utc, Time.zone.now.midnight.tomorrow.utc).order('tasks.id DESC') }\n  scope :due_tomorrow,  -> { where('due_at >= ? AND due_at < ?', Time.zone.now.midnight.tomorrow.utc, Time.zone.now.midnight.tomorrow.utc + 1.day).order('tasks.id DESC') }\n  scope :due_this_week, -> { where('due_at >= ? AND due_at < ?', Time.zone.now.midnight.tomorrow.utc + 1.day, Time.zone.now.next_week.utc).order('tasks.id DESC') }\n  scope :due_next_week, -> { where('due_at >= ? AND due_at < ?', Time.zone.now.next_week.utc, Time.zone.now.next_week.end_of_week.utc + 1.day).order('tasks.id DESC') }\n  scope :due_later,     -> { where(\"(due_at IS NULL AND bucket = 'due_later') OR due_at >= ?\", Time.zone.now.next_week.end_of_week.utc + 1.day).order('tasks.id DESC') }\n\n  # Completion time scopes.\n  scope :completed_today,      -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.midnight.utc, Time.zone.now.midnight.tomorrow.utc) }\n  scope :completed_yesterday,  -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.midnight.yesterday.utc, Time.zone.now.midnight.utc) }\n  scope :completed_this_week,  -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.beginning_of_week.utc, Time.zone.now.midnight.yesterday.utc) }\n  scope :completed_last_week,  -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.beginning_of_week.utc - 7.days, Time.zone.now.beginning_of_week.utc) }\n  scope :completed_this_month, -> { where('completed_at >= ? AND completed_at < ?', Time.zone.now.beginning_of_month.utc, Time.zone.now.beginning_of_week.utc - 7.days) }\n  scope :completed_last_month, -> { where('completed_at >= ? AND completed_at < ?', (Time.zone.now.beginning_of_month.utc - 1.day).beginning_of_month.utc, Time.zone.now.beginning_of_month.utc) }\n\n  scope :text_search, lambda { |query|\n    query = query.gsub(/[^\\w\\s\\-\\.'\\p{L}]/u, '').strip\n    where('upper(name) LIKE upper(?)', \"%#{query}%\")\n  }\n\n  acts_as_commentable\n  has_paper_trail versions: { class_name: 'Version' }, meta: { related: :asset },\n                  ignore: [:subscribed_users]\n  has_fields\n  exportable\n\n  validates_presence_of :user\n  validates_presence_of :name, message: :missing_task_name\n  validates_presence_of :calendar, if: -> { bucket == 'specific_time' && !completed_at }\n  validate :specific_time, unless: :completed?\n\n  before_create :set_due_date\n  before_update :set_due_date, unless: :completed?\n  before_save :notify_assignee\n\n  # Matcher for the :my named scope.\n  #----------------------------------------------------------------------------\n  def my?(user)\n    (self.user == user && assignee.nil?) || assignee == user\n  end\n\n  # Matcher for the :assigned_by named scope.\n  #----------------------------------------------------------------------------\n  def assigned_by?(user)\n    self.user == user && assignee && assignee != user\n  end\n\n  #----------------------------------------------------------------------------\n  def completed?\n    !!completed_at\n  end\n\n  # Matcher for the :tracked_by? named scope.\n  #----------------------------------------------------------------------------\n  def tracked_by?(user)\n    self.user == user || assignee == user\n  end\n\n  # Check whether the due date has specific time ignoring 23:59:59 timestamp\n  # set by Time.now.end_of_week.\n  #----------------------------------------------------------------------------\n  def at_specific_time?\n    due_at.present? && !due_end_of_day? && !due_beginning_of_day?\n  end\n\n  # Convert specific due_date to \"due_today\", \"due_tomorrow\", etc. bucket name.\n  #----------------------------------------------------------------------------\n  def computed_bucket\n    return bucket if bucket != \"specific_time\"\n\n    if overdue?\n      \"overdue\"\n    elsif due_today?\n      \"due_today\"\n    elsif due_tomorrow?\n      \"due_tomorrow\"\n    elsif due_this_week? && !due_today? && !due_tomorrow?\n      \"due_this_week\"\n    elsif due_next_week?\n      \"due_next_week\"\n    else\n      \"due_later\"\n    end\n  end\n\n  # Returns list of tasks grouping them by due date as required by tasks/index.\n  #----------------------------------------------------------------------------\n  def self.find_all_grouped(user, view)\n    return {} unless ALLOWED_VIEWS.include?(view)\n\n    settings = (view == \"completed\" ? Setting.task_completed : Setting.task_bucket)\n    Hash[\n      settings.map do |key, _value|\n        [key, view == \"assigned\" ? assigned_by(user).send(key).pending : my(user).send(key).send(view)]\n      end\n    ]\n  end\n\n  # Returns bucket if it's empty (i.e. we have to hide it), nil otherwise.\n  #----------------------------------------------------------------------------\n  def self.bucket_empty?(bucket, user, view = \"pending\")\n    return false if bucket.blank? || !ALLOWED_VIEWS.include?(view)\n    return false unless Setting.task_bucket.map(&:to_s).include?(bucket.to_s)\n\n    if view == \"assigned\"\n      assigned_by(user).send(bucket).pending.count\n    else\n      my(user).send(bucket).send(view).count\n    end == 0\n  end\n\n  # Returns task totals for each of the views as needed by tasks sidebar.\n  #----------------------------------------------------------------------------\n  def self.totals(user, view = \"pending\")\n    return {} unless ALLOWED_VIEWS.include?(view)\n\n    settings = (view == \"completed\" ? Setting.task_completed : Setting.task_bucket)\n    settings.each_with_object(HashWithIndifferentAccess[all: 0]) do |key, hash|\n      hash[key] = (view == \"assigned\" ? assigned_by(user).send(key).pending.count : my(user).send(key).send(view).count)\n      hash[:all] += hash[key]\n      hash\n    end\n  end\n\n  private\n\n  #----------------------------------------------------------------------------\n  def set_due_date\n    self.due_at = case bucket\n                  when \"overdue\"\n                    due_at || Time.zone.now.midnight.yesterday\n                  when \"due_today\"\n                    Time.zone.now.midnight\n                  when \"due_tomorrow\"\n                    Time.zone.now.midnight.tomorrow\n                  when \"due_this_week\"\n                    Time.zone.now.end_of_week\n                  when \"due_next_week\"\n                    Time.zone.now.next_week.end_of_week\n                  when \"due_later\"\n                    Time.zone.now.midnight + 100.years\n                  when \"specific_time\"\n                    calendar ? parse_calendar_date : nil\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def due_end_of_day?\n    due_at.present? && (due_at.change(usec: 0) == due_at.end_of_day.change(usec: 0))\n  end\n\n  #----------------------------------------------------------------------------\n  def due_beginning_of_day?\n    due_at.present? && (due_at == due_at.beginning_of_day)\n  end\n\n  #----------------------------------------------------------------------------\n  def overdue?\n    due_at < Time.zone.now.midnight\n  end\n\n  #----------------------------------------------------------------------------\n  def due_today?\n    due_at.between?(Time.zone.now.midnight, Time.zone.now.end_of_day)\n  end\n\n  #----------------------------------------------------------------------------\n  def due_tomorrow?\n    due_at.between?(Time.zone.now.midnight.tomorrow, Time.zone.now.tomorrow.end_of_day)\n  end\n\n  #----------------------------------------------------------------------------\n  def due_this_week?\n    due_at.between?(Time.zone.now.beginning_of_week, Time.zone.now.end_of_week)\n  end\n\n  #----------------------------------------------------------------------------\n  def due_next_week?\n    due_at.between?(Time.zone.now.next_week, Time.zone.now.next_week.end_of_week)\n  end\n\n  #----------------------------------------------------------------------------\n  def notify_assignee\n    if assigned_to\n      # Notify assignee.\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def specific_time\n    parse_calendar_date if bucket == \"specific_time\"\n  rescue ArgumentError\n    errors.add(:calendar, :invalid_date)\n  end\n\n  #----------------------------------------------------------------------------\n  def parse_calendar_date\n    # always in 2012-10-28 06:28 format regardless of language\n    Time.parse(calendar)\n  end\n\n  ActiveSupport.run_load_hooks(:fat_free_crm_task, self)\nend\n", "# frozen_string_literal: true\n\n# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nmodule FatFreeCRM\n  module VERSION # :nodoc:\n    MAJOR = 0\n    MINOR = 20\n    TINY  = 1\n    PRE   = nil\n\n    STRING = [MAJOR, MINOR, TINY, PRE].compact.join('.')\n  end\nend\n"], "filenames": ["app/models/polymorphic/task.rb", "lib/fat_free_crm/version.rb"], "buggy_code_start_loc": [191, 12], "buggy_code_end_loc": [191, 13], "fixing_code_start_loc": [192, 12], "fixing_code_end_loc": [193, 13], "type": "NVD-CWE-noinfo", "message": "fat_free_crm is a an open source, Ruby on Rails customer relationship management platform (CRM). In versions prior to 0.20.1 an authenticated user can perform a remote Denial of Service attack against Fat Free CRM via bucket access. The vulnerability has been patched in commit `c85a254` and will be available in release `0.20.1`. Users are advised to upgrade or to manually apply patch `c85a254`. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-39281", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-08T01:15:08.953", "lastModified": "2022-10-11T15:30:43.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fat_free_crm is a an open source, Ruby on Rails customer relationship management platform (CRM). In versions prior to 0.20.1 an authenticated user can perform a remote Denial of Service attack against Fat Free CRM via bucket access. The vulnerability has been patched in commit `c85a254` and will be available in release `0.20.1`. Users are advised to upgrade or to manually apply patch `c85a254`. There are no known workarounds for this issue."}, {"lang": "es", "value": "fat_free_crm es una plataforma de administraci\u00f3n de las relaciones con los clientes (CRM) de c\u00f3digo abierto, basada en Ruby on Rails. En versiones anteriores a 0.20.1 un usuario autenticado puede llevar a cabo un ataque remoto de denegaci\u00f3n de servicio contra Fat Free CRM por medio de un acceso a un cubo. La vulnerabilidad ha sido parcheada en el commit \"c85a254\" y estar\u00e1 disponible en versi\u00f3n \"0.20.1\". Es recomendado a usuarios actualizar o aplicar manualmente el parche \"c85a254\". No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fatfreecrm:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "0.20.1", "matchCriteriaId": "AEB07D02-D688-48FE-A772-AB6014D1B77D"}]}]}], "references": [{"url": "https://github.com/fatfreecrm/fat_free_crm/commit/c85a2546348c2692d32f952c753f7f0b43d1ca71", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fatfreecrm/fat_free_crm/releases/tag/v0.20.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/fatfreecrm/fat_free_crm/security/advisories/GHSA-p75c-5x3h-cxcg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fatfreecrm/fat_free_crm/commit/c85a2546348c2692d32f952c753f7f0b43d1ca71"}}