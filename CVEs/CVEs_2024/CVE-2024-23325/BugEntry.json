{"buggy_code": ["date: Pending\n\nbehavior_changes:\n# *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nminor_behavior_changes:\n# *Changes that may cause incompatibilities for some users, but should not for most*\n- area: adaptive concurrency filter stats\n  change: |\n    Multiply the gradient value stat by 1000 to make it more granular (values will range between 500 and 2000).\n- area: dns\n  change: |\n    Allowing <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_min_refresh_rate>` to go as low as 1s.\n- area: upstream\n  change: |\n    Upstream now excludes hosts set to ``DRAINING`` state via EDS from load balancing and panic routing\n    threshold calculation. This feature can be disabled by setting\n    ``envoy.reloadable_features.exclude_host_in_eds_status_draining`` to false.\n- area: golang\n  change: |\n    Change ``RegisterHttpFilterConfigFactoryAndParser`` to ``RegisterHttpFilterFactoryAndConfigParser``.\n- area: QUIC\n  change: |\n    Port migration is default turned off. QUIC client connections will no longer attempt to migrate to a new port when connections\n    is degrading. Can be manually turned on via\n    :ref:`port_migration <envoy_v3_api_field_config.core.v3.QuicProtocolOptions.num_timeouts_to_trigger_port_migration>`.\n- area: aws\n  change: |\n    AWS region string is now retrieved from environment and profile consistently within aws_request_signer and\n    grpc_credentials/aws_iam extensions. Region field in aws_request_signer is now optional, explicitly configured\n    xDS region will take preference. aws_request_signer documentation now reflects the region chain.\n\nbug_fixes:\n# *Changes expected to improve the state of the world and are unlikely to have negative effects*\n- area: tracers\n  change: |\n    use unary RPC calls for OpenTelemetry trace exports, rather than client-side streaming connections.\n- area: load balancing\n  change: |\n    Added randomization in locality load-balancing initialization. This helps desynchronizing Envoys across\n    a fleet by randomizing the scheduler starting point. This can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.edf_lb_locality_scheduler_init_fix`` to false.\n- area: UDP and TCP tunneling\n  change: |\n    fixed a bug where second HTTP response headers received would cause Envoy to crash in cases where\n    ``propagate_response_headers`` and retry configurations are enabled at the same time, and an upstream\n    request is retried multiple times.\n- area: tracing\n  change: |\n    Prevent Envoy from crashing at start up when the OpenTelemetry environment resource detector cannot detect any attributes.\n- area: proxy protocol\n  change: |\n    Fixed a crash when Envoy is configured for PROXY protocol on both a listener and cluster, and the listener receives\n    a PROXY protocol header with address type LOCAL (typically used for health checks).\n- area: url matching\n  change: |\n    Fixed excessive CPU utilization when using regex URL template matcher.\n- area: http\n  change: |\n    Fixed crash when HTTP request idle and per try timeouts occurs within backoff interval.\n\nremoved_config_or_runtime:\n# *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n- area: http\n  change: |\n    Removed ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` runtime flag and legacy code paths.\n- area: active health check\n  change: |\n    Removed ``envoy.reloadable_features.keep_endpoint_active_hc_status_on_locality_update`` runtime flag and legacy code paths.\n- area: http1\n  change: |\n    Removed ``envoy.reloadable_features.http1_allow_codec_error_response_after_1xx_headers`` runtime flag and legacy code paths.\n- area: overload manager\n  change: |\n    removed ``envoy.reloadable_features.overload_manager_error_unknown_action`` and legacy code paths.\n- area: http\n  change: |\n    Removed ``envoy_reloadable_features_append_xfh_idempotent`` runtime flag and legacy code paths.\n- area: resource_monitors\n  change: |\n    removed ``envoy.reloadable_features.count_unused_mapped_pages_as_free`` runtime flag  and legacy code paths.\n\nnew_features:\n- area: aws_request_signing\n  change: |\n    Update ``aws_request_signing`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: aws_lambda\n  change: |\n    Update ``aws_lambda`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: grpc reverse bridge\n  change: |\n    Change HTTP status to 200 to respect the gRPC protocol. This may cause problems for incorrect gRPC clients expecting the filter\n    to preserve HTTP 1.1 responses.  This behavioral change can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.grpc_http1_reverse_bridge_change_http_status`` to false.\n- area: quic\n  change: |\n    Added QUIC protocol option :ref:`send_disable_active_migration\n    <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.send_disable_active_migration>` to make the server send clients a transport\n    parameter to discourage client endpoints from active migration.\n- area: ext_proc\n  change: |\n    implemented\n    :ref:`request_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.request_attributes>`\n    and\n    :ref:`response_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.response_attributes>`\n    config APIs to enable sending and receiving attributes to/from the external processing server.\n- area: access log\n  change: |\n    added support for :ref:`%UPSTREAM_CONNECTION_ID% <config_access_log_format_upstream_connection_id>` for the upstream connection\n    identifier.\n- area: aws_lambda\n  change: |\n    Added :ref:`host_rewrite <envoy_v3_api_field_extensions.filters.http.aws_lambda.v3.Config.host_rewrite>` config to be used\n    during signature.\n- area: ext_proc\n  change: |\n    added\n    :ref:`metadata_options <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.metadata_options>`\n    config API to enable sending and receiving metadata from/to the external processing server. Both typed and untyped dynamic\n    metadata may be sent to the server. If\n    :ref:`receiving_namespaces <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.MetadataOptions.receiving_namespaces>`\n    is defined, returned metadata may be written to the specified allowed namespaces.\n- area: monitoring\n  change: |\n    Add ``Envoy::ExecutionContext``, which is notified by ``ScopeTrackerScopeState``'s constructor and destructor. This feature is\n    disabled by default, it can be enabled by runtime feature flag ``envoy.restart_features.enable_execution_context``. For more details,\n    please see https://github.com/envoyproxy/envoy/issues/32012.\n- area: rbac\n  change: |\n    Added :ref:`uri_template<envoy_v3_api_field_config.rbac.v3.Permission.uri_template>` which uses existing\n    :ref:`UriTemplateMatchConfig<envoy_v3_api_msg_extensions.path.match.uri_template.v3.UriTemplateMatchConfig>`\n    to allow use of glob patterns for URI path matching in RBAC.\n- area: upstream\n  change: |\n    Added :ref:`selection_method <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    option to the least request load balancer. If set to ``FULL_SCAN``,\n    Envoy will select the host with the fewest active requests from the entire host set rather than\n    :ref:`choice_count <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    random choices.\n\ndeprecated:\n", "load(\n    \"@envoy_build_config//:extensions_build_config.bzl\",\n    \"LEGACY_ALWAYSLINK\",\n)\nload(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_library\",\n    \"envoy_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_package()\n\nenvoy_cc_library(\n    name = \"address_lib\",\n    srcs = [\"address_impl.cc\"],\n    hdrs = [\"address_impl.h\"],\n    deps = [\n        \":socket_interface_lib\",\n        \"//envoy/network:address_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:safe_memcpy_lib\",\n        \"//source/common/common:statusor_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"application_protocol_lib\",\n    srcs = [\"application_protocol.cc\"],\n    hdrs = [\"application_protocol.h\"],\n    deps = [\n        \"//envoy/registry\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"cidr_range_interface\",\n    hdrs = [\"cidr_range.h\"],\n    deps = [\n        \"//envoy/network:address_interface\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"cidr_range_lib\",\n    srcs = [\"cidr_range.cc\"],\n    hdrs = [\"cidr_range.h\"],\n    deps = [\n        \":address_lib\",\n        \":utility_lib\",\n        \"//envoy/network:address_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:safe_memcpy_lib\",\n        \"//source/common/common:utility_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_balancer_lib\",\n    srcs = [\"connection_balancer_impl.cc\"],\n    hdrs = [\"connection_balancer_impl.h\"],\n    deps = [\n        \"//envoy/network:connection_balancer_interface\",\n        \"//envoy/registry\",\n        \"//envoy/server:filter_config_interface\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_base_lib\",\n    srcs = [\"connection_impl_base.cc\"],\n    hdrs = [\"connection_impl_base.h\"],\n    deps = [\n        \":common_connection_filter_states_lib\",\n        \":connection_socket_lib\",\n        \":filter_manager_lib\",\n        \"//envoy/common:scope_tracker_interface\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:dump_state_utils\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_lib\",\n    deps = [\n        \":connection_impl\",\n        \":default_client_connection_factory\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_impl\",\n    srcs = [\"connection_impl.cc\"],\n    hdrs = [\"connection_impl.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":address_lib\",\n        \":connection_base_lib\",\n        \":raw_buffer_socket_lib\",\n        \":utility_lib\",\n        \"//envoy/event:timer_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/network:socket_interface\",\n        \"//envoy/server/overload:thread_local_overload_state\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/buffer:watermark_buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:empty_string\",\n        \"//source/common/common:enum_to_int\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/common/event:libevent_lib\",\n        \"//source/common/network:socket_option_factory_lib\",\n        \"//source/common/runtime:runtime_features_lib\",\n        \"//source/common/stream_info:stream_info_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"happy_eyeballs_connection_impl_lib\",\n    srcs = [\"happy_eyeballs_connection_impl.cc\"],\n    hdrs = [\"happy_eyeballs_connection_impl.h\"],\n    deps = [\n        \":connection_base_lib\",\n        \":connection_lib\",\n        \":multi_connection_base_impl_lib\",\n        \"//envoy/upstream:upstream_interface\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"multi_connection_base_impl_lib\",\n    srcs = [\"multi_connection_base_impl.cc\"],\n    hdrs = [\"multi_connection_base_impl.h\"],\n    deps = [\n        \":connection_base_lib\",\n        \":connection_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"default_client_connection_factory\",\n    srcs = [\n        \"default_client_connection_factory.cc\",\n    ],\n    hdrs = [\n        \"default_client_connection_factory.h\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":connection_base_lib\",\n        \":connection_impl\",\n        \"//envoy/network:client_connection_factory\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:transport_socket_interface\",\n        \"//envoy/registry\",\n    ],\n    alwayslink = LEGACY_ALWAYSLINK,\n)\n\nenvoy_cc_library(\n    name = \"filter_lib\",\n    hdrs = [\"filter_impl.h\"],\n    deps = [\n        \"//envoy/network:filter_interface\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_manager_lib\",\n    srcs = [\"filter_manager_impl.cc\"],\n    hdrs = [\"filter_manager_impl.h\"],\n    deps = [\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/runtime:runtime_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"hash_policy_lib\",\n    srcs = [\"hash_policy.cc\"],\n    hdrs = [\"hash_policy.h\"],\n    deps = [\n        \"//envoy/common:hashable_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:hash_policy_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:hash_lib\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"io_socket_error_lib\",\n    srcs = [\"io_socket_error_impl.cc\"],\n    hdrs = [\"io_socket_error_impl.h\"],\n    deps = [\n        \"//envoy/api:io_error_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"lc_trie_lib\",\n    hdrs = [\"lc_trie.h\"],\n    external_deps = [\n        \"abseil_node_hash_set\",\n        \"abseil_int128\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":cidr_range_lib\",\n        \":utility_lib\",\n        \"//source/common/common:assert_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"socket_interface_lib\",\n    hdrs = [\"socket_interface.h\"],\n    deps = [\n        \"//envoy/config:typed_config_interface\",\n        \"//envoy/network:socket_interface_interface\",\n        \"//envoy/registry\",\n        \"//envoy/server:bootstrap_extension_config_interface\",\n    ],\n    alwayslink = LEGACY_ALWAYSLINK,\n)\n\nenvoy_cc_library(\n    name = \"default_socket_interface_lib\",\n    srcs = [\n        \"io_socket_handle_base_impl.cc\",\n        \"io_socket_handle_impl.cc\",\n        \"socket_interface_impl.cc\",\n        \"win32_socket_handle_impl.cc\",\n    ],\n    hdrs = [\n        \"io_socket_handle_base_impl.h\",\n        \"io_socket_handle_impl.h\",\n        \"socket_interface_impl.h\",\n        \"win32_socket_handle_impl.h\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":io_socket_error_lib\",\n        \":socket_interface_lib\",\n        \":socket_lib\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/network:io_handle_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"@envoy_api//envoy/extensions/network/socket_interface/v3:pkg_cc_proto\",\n    ],\n    alwayslink = LEGACY_ALWAYSLINK,\n)\n\nenvoy_cc_library(\n    name = \"socket_lib\",\n    srcs = [\"socket_impl.cc\"],\n    hdrs = [\"socket_impl.h\"],\n    deps = [\n        \"//envoy/network:listener_interface\",\n        \"//envoy/network:socket_interface\",\n        \"//envoy/network:socket_interface_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:dump_state_utils\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_socket_lib\",\n    hdrs = [\"connection_socket_impl.h\"],\n    deps = [\n        \":socket_lib\",\n        \":utility_lib\",\n        \"//envoy/network:exception_interface\",\n        \"//source/common/common:assert_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"listen_socket_lib\",\n    srcs = [\"listen_socket_impl.cc\"],\n    hdrs = [\"listen_socket_impl.h\"],\n    deps = [\n        \":connection_socket_lib\",\n        \":socket_lib\",\n        \":utility_lib\",\n        \"//envoy/network:exception_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/common:assert_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"listener_filter_buffer_lib\",\n    srcs = [\"listener_filter_buffer_impl.cc\"],\n    hdrs = [\"listener_filter_buffer_impl.h\"],\n    deps = [\n        \"//envoy/network:io_handle_interface\",\n        \"//envoy/network:listener_filter_buffer_interface\",\n        \"//source/common/buffer:buffer_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"listener_lib\",\n    srcs = [\n        \"base_listener_impl.cc\",\n        \"tcp_listener_impl.cc\",\n        \"udp_listener_impl.cc\",\n    ],\n    hdrs = [\n        \"base_listener_impl.h\",\n        \"tcp_listener_impl.h\",\n        \"udp_listener_impl.h\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":default_socket_interface_lib\",\n        \":listen_socket_lib\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/event:file_event_interface\",\n        \"//envoy/network:exception_interface\",\n        \"//envoy/network:listener_interface\",\n        \"//envoy/runtime:runtime_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/stats:stats_macros\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:empty_string\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/runtime:runtime_keys_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"raw_buffer_socket_lib\",\n    srcs = [\"raw_buffer_socket.cc\"],\n    hdrs = [\"raw_buffer_socket.h\"],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:transport_socket_interface\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:empty_string\",\n        \"//source/common/http:headers_lib\",\n        \"//source/common/network:transport_socket_options_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"resolver_lib\",\n    srcs = [\"resolver_impl.cc\"],\n    hdrs = [\"resolver_impl.h\"],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/network:address_interface\",\n        \"//envoy/network:resolver_interface\",\n        \"//envoy/registry\",\n        \"//source/common/config:well_known_names\",\n        \"//source/common/network:address_lib\",\n        \"//source/common/protobuf\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"socket_option_lib\",\n    srcs = [\"socket_option_impl.cc\"],\n    hdrs = [\"socket_option_impl.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":address_lib\",\n        \"//envoy/api:os_sys_calls_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/common/common:scalar_to_byte_vector_lib\",\n        \"//source/common/common:utility_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"addr_family_aware_socket_option_lib\",\n    srcs = [\"addr_family_aware_socket_option_impl.cc\"],\n    hdrs = [\"addr_family_aware_socket_option_impl.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":address_lib\",\n        \":socket_lib\",\n        \":socket_option_lib\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:logger_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"win32_redirect_records_option_lib\",\n    srcs = [\"win32_redirect_records_option_impl.cc\"],\n    hdrs = [\"win32_redirect_records_option_impl.h\"],\n    deps = [\n        \":address_lib\",\n        \":socket_lib\",\n        \":socket_option_lib\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:logger_lib\",\n        \"//source/common/common:scalar_to_byte_vector_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"socket_option_factory_lib\",\n    srcs = [\"socket_option_factory.cc\"],\n    hdrs = [\"socket_option_factory.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":addr_family_aware_socket_option_lib\",\n        \":address_lib\",\n        \":socket_option_lib\",\n        \":win32_redirect_records_option_lib\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/common:logger_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"utility_lib\",\n    srcs = [\"utility.cc\"],\n    hdrs = [\"utility.h\"],\n    deps = [\n        \":address_lib\",\n        \":default_socket_interface_lib\",\n        \":socket_lib\",\n        \":socket_option_lib\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:listener_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:cleanup_lib\",\n        \"//source/common/common:utility_lib\",\n        \"//source/common/protobuf\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"transport_socket_options_lib\",\n    srcs = [\"transport_socket_options_impl.cc\"],\n    hdrs = [\"transport_socket_options_impl.h\"],\n    deps = [\n        \":application_protocol_lib\",\n        \":filter_state_proxy_info_lib\",\n        \":proxy_protocol_filter_state_lib\",\n        \":upstream_server_name_lib\",\n        \":upstream_subject_alt_names_lib\",\n        \"//envoy/common:hashable_interface\",\n        \"//envoy/common:optref_lib\",\n        \"//envoy/network:proxy_protocol_options_lib\",\n        \"//envoy/network:transport_socket_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:scalar_to_byte_vector_lib\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_state_proxy_info_lib\",\n    srcs = [\"filter_state_proxy_info.cc\"],\n    hdrs = [\"filter_state_proxy_info.h\"],\n    deps = [\n        \"//envoy/network:address_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_state_dst_address_lib\",\n    srcs = [\"filter_state_dst_address.cc\"],\n    hdrs = [\"filter_state_dst_address.h\"],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/common:hashable_interface\",\n        \"//envoy/network:address_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:hash_lib\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"upstream_server_name_lib\",\n    srcs = [\"upstream_server_name.cc\"],\n    hdrs = [\"upstream_server_name.h\"],\n    deps = [\n        \"//envoy/registry\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"upstream_subject_alt_names_lib\",\n    srcs = [\"upstream_subject_alt_names.cc\"],\n    hdrs = [\"upstream_subject_alt_names.h\"],\n    deps = [\n        \"//envoy/registry\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_matcher_lib\",\n    srcs = [\n        \"filter_matcher.cc\",\n    ],\n    hdrs = [\"filter_matcher.h\"],\n    external_deps = [\n        \"abseil_str_format\",\n    ],\n    deps = [\n        \"//envoy/network:filter_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"udp_packet_writer_handler_lib\",\n    srcs = [\"udp_packet_writer_handler_impl.cc\"],\n    hdrs = [\"udp_packet_writer_handler_impl.h\"],\n    deps = [\n        \":io_socket_error_lib\",\n        \":utility_lib\",\n        \"//envoy/network:socket_interface\",\n        \"//envoy/network:udp_packet_writer_handler_interface\",\n        \"//source/common/buffer:buffer_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"proxy_protocol_filter_state_lib\",\n    srcs = [\"proxy_protocol_filter_state.cc\"],\n    hdrs = [\"proxy_protocol_filter_state.h\"],\n    deps = [\n        \"//envoy/network:proxy_protocol_options_lib\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"upstream_socket_options_filter_state_lib\",\n    srcs = [\"upstream_socket_options_filter_state.cc\"],\n    hdrs = [\"upstream_socket_options_filter_state.h\"],\n    deps = [\n        \":socket_interface_lib\",\n        \":socket_option_factory_lib\",\n        \"//envoy/network:io_handle_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"generic_listener_filter_impl_base_lib\",\n    hdrs = [\"generic_listener_filter_impl_base.h\"],\n    deps = [\n        \"//envoy/network:filter_interface\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"common_connection_filter_states_lib\",\n    srcs = [\"common_connection_filter_states.cc\"],\n    hdrs = [\"common_connection_filter_states.h\"],\n    deps = [\n        \"//envoy/common:execution_context\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n    ],\n)\n", "#include \"source/common/network/address_impl.h\"\n\n#include <array>\n#include <cstdint>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/thread.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/socket_interface.h\"\n#include \"source/common/runtime/runtime_features.h\"\n\nnamespace Envoy {\nnamespace Network {\nnamespace Address {\n\nnamespace {\n\n// Constructs a readable string with the embedded nulls in the abstract path replaced with '@'.\nstd::string friendlyNameFromAbstractPath(absl::string_view path) {\n  std::string friendly_name(path.data(), path.size());\n  std::replace(friendly_name.begin(), friendly_name.end(), '\\0', '@');\n  return friendly_name;\n}\n\nconst SocketInterface* sockInterfaceOrDefault(const SocketInterface* sock_interface) {\n  return sock_interface == nullptr ? &SocketInterfaceSingleton::get() : sock_interface;\n}\n\nvoid throwOnError(absl::Status status) {\n  if (!status.ok()) {\n    throwEnvoyExceptionOrPanic(status.ToString());\n  }\n}\n\nInstanceConstSharedPtr throwOnError(StatusOr<InstanceConstSharedPtr> address) {\n  if (!address.ok()) {\n    throwOnError(address.status());\n  }\n  return *address;\n}\n\n} // namespace\n\nbool forceV6() {\n#if defined(__APPLE__) || defined(__ANDROID_API__)\n  return Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.always_use_v6\");\n#else\n  return false;\n#endif\n}\n\nvoid ipv6ToIpv4CompatibleAddress(const struct sockaddr_in6* sin6, struct sockaddr_in* sin) {\n#if defined(__APPLE__)\n  *sin = {{}, AF_INET, sin6->sin6_port, {sin6->sin6_addr.__u6_addr.__u6_addr32[3]}, {}};\n#elif defined(WIN32)\n  struct in_addr in_v4 = {};\n  in_v4.S_un.S_addr = reinterpret_cast<const uint32_t*>(sin6->sin6_addr.u.Byte)[3];\n  *sin = {AF_INET, sin6->sin6_port, in_v4, {}};\n#else\n  *sin = {AF_INET, sin6->sin6_port, {sin6->sin6_addr.s6_addr32[3]}, {}};\n#endif\n}\n\nStatusOr<Address::InstanceConstSharedPtr> addressFromSockAddr(const sockaddr_storage& ss,\n                                                              socklen_t ss_len, bool v6only) {\n  RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) >= sizeof(sa_family_t), \"\");\n  if (forceV6()) {\n    v6only = false;\n  }\n  switch (ss.ss_family) {\n  case AF_INET: {\n    RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) == sizeof(sockaddr_in), \"\");\n    const struct sockaddr_in* sin = reinterpret_cast<const struct sockaddr_in*>(&ss);\n    ASSERT(AF_INET == sin->sin_family);\n    return Address::InstanceFactory::createInstancePtr<Address::Ipv4Instance>(sin);\n  }\n  case AF_INET6: {\n    RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) == sizeof(sockaddr_in6), \"\");\n    const struct sockaddr_in6* sin6 = reinterpret_cast<const struct sockaddr_in6*>(&ss);\n    ASSERT(AF_INET6 == sin6->sin6_family);\n    if (!v6only && IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {\n      struct sockaddr_in sin;\n      ipv6ToIpv4CompatibleAddress(sin6, &sin);\n      return Address::InstanceFactory::createInstancePtr<Address::Ipv4Instance>(&sin);\n    } else {\n      return Address::InstanceFactory::createInstancePtr<Address::Ipv6Instance>(*sin6, v6only);\n    }\n  }\n  case AF_UNIX: {\n    const struct sockaddr_un* sun = reinterpret_cast<const struct sockaddr_un*>(&ss);\n    ASSERT(AF_UNIX == sun->sun_family);\n    RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) >=\n                                      offsetof(struct sockaddr_un, sun_path) + 1,\n                   \"\");\n    return Address::InstanceFactory::createInstancePtr<Address::PipeInstance>(sun, ss_len);\n  }\n  default:\n    return absl::InvalidArgumentError(fmt::format(\"Unexpected sockaddr family: {}\", ss.ss_family));\n  }\n}\n\nAddress::InstanceConstSharedPtr addressFromSockAddrOrThrow(const sockaddr_storage& ss,\n                                                           socklen_t ss_len, bool v6only) {\n  // Though we don't have any test coverage where address validation in addressFromSockAddr() fails,\n  // this code is called in worker thread and can throw in theory. In that case, the program will\n  // crash due to uncaught exception. In practice, we don't expect any address validation in\n  // addressFromSockAddr() to fail in worker thread.\n  StatusOr<InstanceConstSharedPtr> address = addressFromSockAddr(ss, ss_len, v6only);\n  return throwOnError(address);\n}\n\nAddress::InstanceConstSharedPtr\naddressFromSockAddrOrDie(const sockaddr_storage& ss, socklen_t ss_len, os_fd_t fd, bool v6only) {\n  // Set v6only to false so that mapped-v6 address can be normalize to v4\n  // address. Though dual stack may be disabled, it's still okay to assume the\n  // address is from a dual stack socket. This is because mapped-v6 address\n  // must come from a dual stack socket. An actual v6 address can come from\n  // both dual stack socket and v6 only socket. If |peer_addr| is an actual v6\n  // address and the socket is actually v6 only, the returned address will be\n  // regarded as a v6 address from dual stack socket. However, this address is not going to be\n  // used to create socket. Wrong knowledge of dual stack support won't hurt.\n  StatusOr<Address::InstanceConstSharedPtr> address =\n      Address::addressFromSockAddr(ss, ss_len, v6only);\n  if (!address.ok()) {\n    PANIC(fmt::format(\"Invalid address for fd: {}, error: {}\", fd, address.status().ToString()));\n  }\n  return *address;\n}\n\nIpv4Instance::Ipv4Instance(const sockaddr_in* address, const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  initHelper(address);\n}\n\nIpv4Instance::Ipv4Instance(const std::string& address, const SocketInterface* sock_interface)\n    : Ipv4Instance(address, 0, sockInterfaceOrDefault(sock_interface)) {}\n\nIpv4Instance::Ipv4Instance(const std::string& address, uint32_t port,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  memset(&ip_.ipv4_.address_, 0, sizeof(ip_.ipv4_.address_));\n  ip_.ipv4_.address_.sin_family = AF_INET;\n  ip_.ipv4_.address_.sin_port = htons(port);\n  int rc = inet_pton(AF_INET, address.c_str(), &ip_.ipv4_.address_.sin_addr);\n  if (1 != rc) {\n    throwEnvoyExceptionOrPanic(fmt::format(\"invalid ipv4 address '{}'\", address));\n  }\n\n  friendly_name_ = absl::StrCat(address, \":\", port);\n  ip_.friendly_address_ = address;\n}\n\nIpv4Instance::Ipv4Instance(uint32_t port, const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  memset(&ip_.ipv4_.address_, 0, sizeof(ip_.ipv4_.address_));\n  ip_.ipv4_.address_.sin_family = AF_INET;\n  ip_.ipv4_.address_.sin_port = htons(port);\n  ip_.ipv4_.address_.sin_addr.s_addr = INADDR_ANY;\n  friendly_name_ = absl::StrCat(\"0.0.0.0:\", port);\n  ip_.friendly_address_ = \"0.0.0.0\";\n}\n\nIpv4Instance::Ipv4Instance(absl::Status& status, const sockaddr_in* address,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  status = validateProtocolSupported();\n  if (!status.ok()) {\n    return;\n  }\n  initHelper(address);\n}\n\nbool Ipv4Instance::operator==(const Instance& rhs) const {\n  const Ipv4Instance* rhs_casted = dynamic_cast<const Ipv4Instance*>(&rhs);\n  return (rhs_casted && (ip_.ipv4_.address() == rhs_casted->ip_.ipv4_.address()) &&\n          (ip_.port() == rhs_casted->ip_.port()));\n}\n\nstd::string Ipv4Instance::sockaddrToString(const sockaddr_in& addr) {\n  static constexpr size_t BufferSize = 16; // enough space to hold an IPv4 address in string form\n  char str[BufferSize];\n  // Write backwards from the end of the buffer for simplicity.\n  char* start = str + BufferSize;\n  uint32_t ipv4_addr = ntohl(addr.sin_addr.s_addr);\n  for (unsigned i = 4; i != 0; i--, ipv4_addr >>= 8) {\n    uint32_t octet = ipv4_addr & 0xff;\n    if (octet == 0) {\n      ASSERT(start > str);\n      *--start = '0';\n    } else {\n      do {\n        ASSERT(start > str);\n        *--start = '0' + (octet % 10);\n        octet /= 10;\n      } while (octet != 0);\n    }\n    if (i != 1) {\n      ASSERT(start > str);\n      *--start = '.';\n    }\n  }\n  const std::string::size_type end = str + BufferSize - start;\n  return {start, end};\n}\n\nabsl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}\n\nvoid Ipv4Instance::initHelper(const sockaddr_in* address) {\n  memset(&ip_.ipv4_.address_, 0, sizeof(ip_.ipv4_.address_));\n  ip_.ipv4_.address_ = *address;\n  ip_.friendly_address_ = sockaddrToString(*address);\n\n  // Based on benchmark testing, this reserve+append implementation runs faster than absl::StrCat.\n  fmt::format_int port(ntohs(address->sin_port));\n  friendly_name_.reserve(ip_.friendly_address_.size() + 1 + port.size());\n  friendly_name_.append(ip_.friendly_address_);\n  friendly_name_.push_back(':');\n  friendly_name_.append(port.data(), port.size());\n}\n\nabsl::uint128 Ipv6Instance::Ipv6Helper::address() const {\n  absl::uint128 result{0};\n  static_assert(sizeof(absl::uint128) == 16, \"The size of absl::uint128 is not 16.\");\n  safeMemcpyUnsafeSrc(&result, &address_.sin6_addr.s6_addr[0]);\n  return result;\n}\n\nuint32_t Ipv6Instance::Ipv6Helper::scopeId() const { return address_.sin6_scope_id; }\n\nuint32_t Ipv6Instance::Ipv6Helper::port() const { return ntohs(address_.sin6_port); }\n\nbool Ipv6Instance::Ipv6Helper::v6only() const { return v6only_; };\n\nstd::string Ipv6Instance::Ipv6Helper::makeFriendlyAddress() const {\n  char str[INET6_ADDRSTRLEN];\n  const char* ptr = inet_ntop(AF_INET6, &address_.sin6_addr, str, INET6_ADDRSTRLEN);\n  ASSERT(str == ptr);\n  if (address_.sin6_scope_id != 0) {\n    // Note that here we don't use the `if_indextoname` that will give a more user friendly\n    // output just because in the past created a performance bottleneck if the machine had a\n    // lot of IPv6 Link local addresses.\n    return absl::StrCat(ptr, \"%\", scopeId());\n  }\n  return ptr;\n}\n\nInstanceConstSharedPtr Ipv6Instance::Ipv6Helper::v4CompatibleAddress() const {\n  if (!v6only_ && IN6_IS_ADDR_V4MAPPED(&address_.sin6_addr)) {\n    struct sockaddr_in sin;\n    ipv6ToIpv4CompatibleAddress(&address_, &sin);\n    auto addr = Address::InstanceFactory::createInstancePtr<Address::Ipv4Instance>(&sin);\n    return addr.ok() ? addr.value() : nullptr;\n  }\n  return nullptr;\n}\n\nInstanceConstSharedPtr Ipv6Instance::Ipv6Helper::addressWithoutScopeId() const {\n  struct sockaddr_in6 ret_addr = address_;\n  ret_addr.sin6_scope_id = 0;\n  auto addr = Address::InstanceFactory::createInstancePtr<Address::Ipv6Instance>(ret_addr, v6only_);\n  return addr.ok() ? addr.value() : nullptr;\n}\n\nIpv6Instance::Ipv6Instance(const sockaddr_in6& address, bool v6only,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  initHelper(address, v6only);\n}\n\nIpv6Instance::Ipv6Instance(const std::string& address, const SocketInterface* sock_interface)\n    : Ipv6Instance(address, 0, sockInterfaceOrDefault(sock_interface)) {}\n\nIpv6Instance::Ipv6Instance(const std::string& address, uint32_t port,\n                           const SocketInterface* sock_interface, bool v6only)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  sockaddr_in6 addr_in;\n  memset(&addr_in, 0, sizeof(addr_in));\n  addr_in.sin6_family = AF_INET6;\n  addr_in.sin6_port = htons(port);\n  if (!address.empty()) {\n    if (1 != inet_pton(AF_INET6, address.c_str(), &addr_in.sin6_addr)) {\n      throwEnvoyExceptionOrPanic(fmt::format(\"invalid ipv6 address '{}'\", address));\n    }\n  } else {\n    addr_in.sin6_addr = in6addr_any;\n  }\n  initHelper(addr_in, v6only);\n}\n\nIpv6Instance::Ipv6Instance(uint32_t port, const SocketInterface* sock_interface)\n    : Ipv6Instance(\"\", port, sockInterfaceOrDefault(sock_interface)) {}\n\nbool Ipv6Instance::operator==(const Instance& rhs) const {\n  const auto* rhs_casted = dynamic_cast<const Ipv6Instance*>(&rhs);\n  return (rhs_casted && (ip_.ipv6_.address() == rhs_casted->ip_.ipv6_.address()) &&\n          (ip_.port() == rhs_casted->ip_.port()) &&\n          (ip_.ipv6_.scopeId() == rhs_casted->ip_.ipv6_.scopeId()));\n}\n\nIpv6Instance::Ipv6Instance(absl::Status& status, const sockaddr_in6& address, bool v6only,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  status = validateProtocolSupported();\n  if (!status.ok()) {\n    return;\n  }\n  initHelper(address, v6only);\n}\n\nabsl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}\n\nvoid Ipv6Instance::initHelper(const sockaddr_in6& address, bool v6only) {\n  ip_.ipv6_.address_ = address;\n  ip_.friendly_address_ = ip_.ipv6_.makeFriendlyAddress();\n  ip_.ipv6_.v6only_ = v6only;\n  friendly_name_ = fmt::format(\"[{}]:{}\", ip_.friendly_address_, ip_.port());\n}\n\nPipeInstance::PipeInstance(const sockaddr_un* address, socklen_t ss_len, mode_t mode,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Pipe, sockInterfaceOrDefault(sock_interface)) {\n  if (address->sun_path[0] == '\\0') {\n#if !defined(__linux__)\n    throwEnvoyExceptionOrPanic(\"Abstract AF_UNIX sockets are only supported on linux.\");\n#endif\n    RELEASE_ASSERT(static_cast<unsigned int>(ss_len) >= offsetof(struct sockaddr_un, sun_path) + 1,\n                   \"\");\n    pipe_.abstract_namespace_ = true;\n    pipe_.address_length_ = ss_len - offsetof(struct sockaddr_un, sun_path);\n  }\n  absl::Status status = initHelper(address, mode);\n  throwOnError(status);\n}\n\nPipeInstance::PipeInstance(const std::string& pipe_path, mode_t mode,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Pipe, sockInterfaceOrDefault(sock_interface)) {\n  if (pipe_path.size() >= sizeof(pipe_.address_.sun_path)) {\n    throwEnvoyExceptionOrPanic(\n        fmt::format(\"Path \\\"{}\\\" exceeds maximum UNIX domain socket path size of {}.\", pipe_path,\n                    sizeof(pipe_.address_.sun_path)));\n  }\n  memset(&pipe_.address_, 0, sizeof(pipe_.address_));\n  pipe_.address_.sun_family = AF_UNIX;\n  if (pipe_path[0] == '@') {\n    // This indicates an abstract namespace.\n    // In this case, null bytes in the name have no special significance, and so we copy all\n    // characters of pipe_path to sun_path, including null bytes in the name. The pathname must also\n    // be null terminated. The friendly name is the address path with embedded nulls replaced with\n    // '@' for consistency with the first character.\n#if !defined(__linux__)\n    throwEnvoyExceptionOrPanic(\"Abstract AF_UNIX sockets are only supported on linux.\");\n#endif\n    if (mode != 0) {\n      throwEnvoyExceptionOrPanic(\"Cannot set mode for Abstract AF_UNIX sockets\");\n    }\n    pipe_.abstract_namespace_ = true;\n    pipe_.address_length_ = pipe_path.size();\n    // The following statement is safe since pipe_path size was checked at the beginning of this\n    // function\n    memcpy(&pipe_.address_.sun_path[0], pipe_path.data(), pipe_path.size()); // NOLINT(safe-memcpy)\n    pipe_.address_.sun_path[0] = '\\0';\n    pipe_.address_.sun_path[pipe_path.size()] = '\\0';\n    friendly_name_ = friendlyNameFromAbstractPath(\n        absl::string_view(pipe_.address_.sun_path, pipe_.address_length_));\n  } else {\n    // Throw an error if the pipe path has an embedded null character.\n    if (pipe_path.size() != strlen(pipe_path.c_str())) {\n      throwEnvoyExceptionOrPanic(\"UNIX domain socket pathname contains embedded null characters\");\n    }\n    StringUtil::strlcpy(&pipe_.address_.sun_path[0], pipe_path.c_str(),\n                        sizeof(pipe_.address_.sun_path));\n    friendly_name_ = pipe_.address_.sun_path;\n  }\n  pipe_.mode_ = mode;\n}\n\nPipeInstance::PipeInstance(absl::Status& error, const sockaddr_un* address, socklen_t ss_len,\n                           mode_t mode, const SocketInterface* sock_interface)\n    : InstanceBase(Type::Pipe, sockInterfaceOrDefault(sock_interface)) {\n  if (address->sun_path[0] == '\\0') {\n#if !defined(__linux__)\n    error = absl::FailedPreconditionError(\"Abstract AF_UNIX sockets are only supported on linux.\");\n    return;\n#endif\n    RELEASE_ASSERT(static_cast<unsigned int>(ss_len) >= offsetof(struct sockaddr_un, sun_path) + 1,\n                   \"\");\n    pipe_.abstract_namespace_ = true;\n    pipe_.address_length_ = ss_len - offsetof(struct sockaddr_un, sun_path);\n  }\n  error = initHelper(address, mode);\n}\n\nbool PipeInstance::operator==(const Instance& rhs) const { return asString() == rhs.asString(); }\n\nabsl::Status PipeInstance::initHelper(const sockaddr_un* address, mode_t mode) {\n  pipe_.address_ = *address;\n  if (pipe_.abstract_namespace_) {\n    if (mode != 0) {\n      return absl::FailedPreconditionError(\"Cannot set mode for Abstract AF_UNIX sockets\");\n    }\n    // Replace all null characters with '@' in friendly_name_.\n    friendly_name_ = friendlyNameFromAbstractPath(\n        absl::string_view(pipe_.address_.sun_path, pipe_.address_length_));\n  } else {\n    friendly_name_ = address->sun_path;\n  }\n  pipe_.mode_ = mode;\n  return absl::OkStatus();\n}\n\nEnvoyInternalInstance::EnvoyInternalInstance(const std::string& address_id,\n                                             const std::string& endpoint_id,\n                                             const SocketInterface* sock_interface)\n    : InstanceBase(Type::EnvoyInternal, sockInterfaceOrDefault(sock_interface)),\n      internal_address_(address_id, endpoint_id) {\n  friendly_name_ = absl::StrCat(\"envoy://\", address_id, \"/\", endpoint_id);\n}\n\nbool EnvoyInternalInstance::operator==(const Instance& rhs) const {\n  return rhs.type() == Type::EnvoyInternal && asString() == rhs.asString();\n}\n\n} // namespace Address\n} // namespace Network\n} // namespace Envoy\n", "#pragma once\n\n#include <sys/types.h>\n\n#include <array>\n#include <cstdint>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/network/address.h\"\n#include \"envoy/network/socket.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/statusor.h\"\n\nnamespace Envoy {\nnamespace Network {\nnamespace Address {\n\n/**\n * Check whether we are a) on Android or an Apple platform and b) configured via runtime to always\n * use v6 sockets.\n * This appears to be what Android OS does for all platform sockets.\n */\nbool forceV6();\n\n/**\n * Convert an address in the form of the socket address struct defined by Posix, Linux, etc. into\n * a Network::Address::Instance and return a pointer to it. Raises an EnvoyException on failure.\n * @param ss a valid address with family AF_INET, AF_INET6 or AF_UNIX.\n * @param len length of the address (e.g. from accept, getsockname or getpeername). If len > 0,\n *        it is used to validate the structure contents; else if len == 0, it is ignored.\n * @param v6only disable IPv4-IPv6 mapping for IPv6 addresses?\n * @return InstanceConstSharedPtr the address.\n */\nStatusOr<InstanceConstSharedPtr> addressFromSockAddr(const sockaddr_storage& ss, socklen_t len,\n                                                     bool v6only = true);\nInstanceConstSharedPtr addressFromSockAddrOrThrow(const sockaddr_storage& ss, socklen_t len,\n                                                  bool v6only = true);\n\n/**\n * Convert an address in the form of the socket address struct defined by Posix, Linux, etc. into\n * a Network::Address::Instance and return a pointer to it. Die on failure.\n * @param ss a valid address with family AF_INET, AF_INET6 or AF_UNIX.\n * @param len length of the address (e.g. from accept, getsockname or getpeername). If len > 0,\n *        it is used to validate the structure contents; else if len == 0, it is ignored.\n * @param fd the file descriptor for the created address instance.\n * @param v6only disable IPv4-IPv6 mapping for IPv6 addresses?\n * @return InstanceConstSharedPtr the address.\n */\nInstanceConstSharedPtr addressFromSockAddrOrDie(const sockaddr_storage& ss, socklen_t ss_len,\n                                                os_fd_t fd, bool v6only = true);\n\n/**\n * Base class for all address types.\n */\nclass InstanceBase : public Instance {\npublic:\n  // Network::Address::Instance\n  const std::string& asString() const override { return friendly_name_; }\n  absl::string_view asStringView() const override { return friendly_name_; }\n  // Default logical name is the human-readable name.\n  const std::string& logicalName() const override { return asString(); }\n  Type type() const override { return type_; }\n\n  const SocketInterface& socketInterface() const override { return socket_interface_; }\n\nprotected:\n  InstanceBase(Type type, const SocketInterface* sock_interface)\n      : socket_interface_(*sock_interface), type_(type) {}\n\n  std::string friendly_name_;\n  const SocketInterface& socket_interface_;\n\nprivate:\n  const Type type_;\n};\n\n// Create an address instance. Upon failure, return an error status without throwing.\nclass InstanceFactory {\npublic:\n  template <typename InstanceType, typename... Args>\n  static StatusOr<InstanceConstSharedPtr> createInstancePtr(Args&&... args) {\n    absl::Status status;\n    // Use new instead of make_shared here because the instance constructors are private and must be\n    // called directly here.\n    std::shared_ptr<InstanceType> instance(new InstanceType(status, std::forward<Args>(args)...));\n    if (!status.ok()) {\n      return status;\n    }\n    return instance;\n  }\n};\n\n/**\n * Implementation of an IPv4 address.\n */\nclass Ipv4Instance : public InstanceBase {\npublic:\n  /**\n   * Construct from an existing unix IPv4 socket address (IP v4 address and port).\n   */\n  explicit Ipv4Instance(const sockaddr_in* address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv4 address such as \"1.2.3.4\". Port will be unset/0.\n   */\n  explicit Ipv4Instance(const std::string& address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv4 address such as \"1.2.3.4\" as well as a port.\n   */\n  Ipv4Instance(const std::string& address, uint32_t port,\n               const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a port. The IPv4 address will be set to \"any\" and is suitable for binding\n   * a port to any available address.\n   */\n  explicit Ipv4Instance(uint32_t port, const SocketInterface* sock_interface = nullptr);\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return &ip_; }\n  const Pipe* pipe() const override { return nullptr; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return nullptr; }\n  const sockaddr* sockAddr() const override {\n    return reinterpret_cast<const sockaddr*>(&ip_.ipv4_.address_);\n  }\n  socklen_t sockAddrLen() const override { return sizeof(sockaddr_in); }\n  absl::string_view addressType() const override { return \"default\"; }\n\n  /**\n   * Convenience function to convert an IPv4 address to canonical string format.\n   * @note This works similarly to inet_ntop() but is faster.\n   * @param addr address to format.\n   * @return the address in dotted-decimal string format.\n   */\n  static std::string sockaddrToString(const sockaddr_in& addr);\n\n  // Validate that IPv4 is supported on this platform, raise an exception for the\n  // given address if not.\n  static absl::Status validateProtocolSupported();\n\nprivate:\n  /**\n   * Construct from an existing unix IPv4 socket address (IP v4 address and port).\n   * Store the status code in passed in parameter instead of throwing.\n   * It is called by the factory method and the partially constructed instance will be discarded\n   * upon error.\n   */\n  explicit Ipv4Instance(absl::Status& error, const sockaddr_in* address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  struct Ipv4Helper : public Ipv4 {\n    uint32_t address() const override { return address_.sin_addr.s_addr; }\n\n    sockaddr_in address_;\n  };\n\n  struct IpHelper : public Ip {\n    const std::string& addressAsString() const override { return friendly_address_; }\n    bool isAnyAddress() const override { return ipv4_.address_.sin_addr.s_addr == INADDR_ANY; }\n    bool isUnicastAddress() const override {\n      return !isAnyAddress() && (ipv4_.address_.sin_addr.s_addr != INADDR_BROADCAST) &&\n             // inlined IN_MULTICAST() to avoid byte swapping\n             !((ipv4_.address_.sin_addr.s_addr & htonl(0xf0000000)) == htonl(0xe0000000));\n    }\n    const Ipv4* ipv4() const override { return &ipv4_; }\n    const Ipv6* ipv6() const override { return nullptr; }\n    uint32_t port() const override { return ntohs(ipv4_.address_.sin_port); }\n    IpVersion version() const override { return IpVersion::v4; }\n\n    Ipv4Helper ipv4_;\n    std::string friendly_address_;\n  };\n\n  void initHelper(const sockaddr_in* address);\n\n  IpHelper ip_;\n  friend class InstanceFactory;\n};\n\n/**\n * Implementation of an IPv6 address.\n */\nclass Ipv6Instance : public InstanceBase {\npublic:\n  /**\n   * Construct from an existing unix IPv6 socket address (IP v6 address and port).\n   */\n  Ipv6Instance(const sockaddr_in6& address, bool v6only = true,\n               const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv6 address such as \"12:34::5\". Port will be unset/0.\n   */\n  explicit Ipv6Instance(const std::string& address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv6 address such as \"12:34::5\" as well as a port.\n   */\n  Ipv6Instance(const std::string& address, uint32_t port,\n               const SocketInterface* sock_interface = nullptr, bool v6only = true);\n\n  /**\n   * Construct from a port. The IPv6 address will be set to \"any\" and is suitable for binding\n   * a port to any available address.\n   */\n  explicit Ipv6Instance(uint32_t port, const SocketInterface* sock_interface = nullptr);\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return &ip_; }\n  const Pipe* pipe() const override { return nullptr; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return nullptr; }\n  const sockaddr* sockAddr() const override {\n    return reinterpret_cast<const sockaddr*>(&ip_.ipv6_.address_);\n  }\n  socklen_t sockAddrLen() const override { return sizeof(sockaddr_in6); }\n  absl::string_view addressType() const override { return \"default\"; }\n\n  // Validate that IPv6 is supported on this platform\n  static absl::Status validateProtocolSupported();\n\nprivate:\n  /**\n   * Construct from an existing unix IPv6 socket address (IP v6 address and port).\n   * Store the status code in passed in parameter instead of throwing.\n   * It is called by the factory method and the partially constructed instance will be discarded\n   * upon error.\n   */\n  Ipv6Instance(absl::Status& error, const sockaddr_in6& address, bool v6only = true,\n               const SocketInterface* sock_interface = nullptr);\n\n  struct Ipv6Helper : public Ipv6 {\n    Ipv6Helper() { memset(&address_, 0, sizeof(address_)); }\n    absl::uint128 address() const override;\n    bool v6only() const override;\n    uint32_t scopeId() const override;\n    uint32_t port() const;\n    InstanceConstSharedPtr v4CompatibleAddress() const override;\n    InstanceConstSharedPtr addressWithoutScopeId() const override;\n\n    std::string makeFriendlyAddress() const;\n\n    sockaddr_in6 address_;\n    // Is IPv4 compatibility (https://tools.ietf.org/html/rfc3493#page-11) disabled?\n    // Default initialized to true to preserve extant Envoy behavior where we don't explicitly set\n    // this in the constructor.\n    bool v6only_{true};\n  };\n\n  struct IpHelper : public Ip {\n    const std::string& addressAsString() const override { return friendly_address_; }\n    bool isAnyAddress() const override {\n      return 0 == memcmp(&ipv6_.address_.sin6_addr, &in6addr_any, sizeof(struct in6_addr));\n    }\n    bool isUnicastAddress() const override {\n      return !isAnyAddress() && !IN6_IS_ADDR_MULTICAST(&ipv6_.address_.sin6_addr);\n    }\n    const Ipv4* ipv4() const override { return nullptr; }\n    const Ipv6* ipv6() const override { return &ipv6_; }\n    uint32_t port() const override { return ipv6_.port(); }\n    IpVersion version() const override { return IpVersion::v6; }\n\n    Ipv6Helper ipv6_;\n    std::string friendly_address_;\n  };\n\n  void initHelper(const sockaddr_in6& address, bool v6only);\n\n  IpHelper ip_;\n  friend class InstanceFactory;\n};\n\n/**\n * Implementation of a pipe address (unix domain socket on unix).\n */\nclass PipeInstance : public InstanceBase {\npublic:\n  /**\n   * Construct from an existing unix address.\n   */\n  explicit PipeInstance(const sockaddr_un* address, socklen_t ss_len, mode_t mode = 0,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string pipe path.\n   */\n  explicit PipeInstance(const std::string& pipe_path, mode_t mode = 0,\n                        const SocketInterface* sock_interface = nullptr);\n\n  static absl::Status validateProtocolSupported() { return absl::OkStatus(); }\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return nullptr; }\n  const Pipe* pipe() const override { return &pipe_; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return nullptr; }\n  const sockaddr* sockAddr() const override {\n    return reinterpret_cast<const sockaddr*>(&pipe_.address_);\n  }\n  const sockaddr_un& getSockAddr() const { return pipe_.address_; }\n  socklen_t sockAddrLen() const override {\n    if (pipe_.abstract_namespace_) {\n      return offsetof(struct sockaddr_un, sun_path) + pipe_.address_length_;\n    }\n    return sizeof(pipe_.address_);\n  }\n  absl::string_view addressType() const override { return \"default\"; }\n\nprivate:\n  /**\n   * Construct from an existing unix address.\n   * Store the error status code in passed in parameter instead of throwing.\n   * It is called by the factory method and the partially constructed instance will be discarded\n   * upon error.\n   */\n  PipeInstance(absl::Status& error, const sockaddr_un* address, socklen_t ss_len, mode_t mode = 0,\n               const SocketInterface* sock_interface = nullptr);\n\n  struct PipeHelper : public Pipe {\n\n    bool abstractNamespace() const override { return abstract_namespace_; }\n    mode_t mode() const override { return mode_; }\n\n    sockaddr_un address_;\n    // For abstract namespaces.\n    bool abstract_namespace_{false};\n    uint32_t address_length_{0};\n    mode_t mode_{0};\n  };\n\n  absl::Status initHelper(const sockaddr_un* address, mode_t mode);\n\n  PipeHelper pipe_;\n  friend class InstanceFactory;\n};\n\nclass EnvoyInternalInstance : public InstanceBase {\npublic:\n  /**\n   * Construct from a string name.\n   */\n  explicit EnvoyInternalInstance(const std::string& address_id, const std::string& endpoint_id = \"\",\n                                 const SocketInterface* sock_interface = nullptr);\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return nullptr; }\n  const Pipe* pipe() const override { return nullptr; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return &internal_address_; }\n  // TODO(lambdai): Verify all callers accepts nullptr.\n  const sockaddr* sockAddr() const override { return nullptr; }\n  socklen_t sockAddrLen() const override { return 0; }\n  absl::string_view addressType() const override { return \"envoy_internal\"; }\n\nprivate:\n  struct EnvoyInternalAddressImpl : public EnvoyInternalAddress {\n    explicit EnvoyInternalAddressImpl(const std::string& address_id, const std::string& endpoint_id)\n        : address_id_(address_id), endpoint_id_(endpoint_id) {}\n    ~EnvoyInternalAddressImpl() override = default;\n    const std::string& addressId() const override { return address_id_; }\n    const std::string& endpointId() const override { return endpoint_id_; }\n    const std::string address_id_;\n    const std::string endpoint_id_;\n  };\n  EnvoyInternalAddressImpl internal_address_;\n};\n\n} // namespace Address\n} // namespace Network\n} // namespace Envoy\n", "#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/listen_socket.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_HEADER_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_LOCAL;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ONBEHALF_OF;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_DGRAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_STREAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_VERSION;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\n\nConfig::Config(\n    Stats::Scope& scope,\n    const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol& proto_config)\n    : stats_{ALL_PROXY_PROTOCOL_STATS(POOL_COUNTER(scope))},\n      allow_requests_without_proxy_protocol_(proto_config.allow_requests_without_proxy_protocol()),\n      pass_all_tlvs_(proto_config.has_pass_through_tlvs()\n                         ? proto_config.pass_through_tlvs().match_type() ==\n                               ProxyProtocolPassThroughTLVs::INCLUDE_ALL\n                         : false) {\n  for (const auto& rule : proto_config.rules()) {\n    tlv_types_[0xFF & rule.tlv_type()] = rule.on_tlv_present();\n  }\n\n  if (proto_config.has_pass_through_tlvs() &&\n      proto_config.pass_through_tlvs().match_type() == ProxyProtocolPassThroughTLVs::INCLUDE) {\n    for (const auto& tlv_type : proto_config.pass_through_tlvs().tlv_type()) {\n      pass_through_tlvs_.insert(0xFF & tlv_type);\n    }\n  }\n}\n\nconst KeyValuePair* Config::isTlvTypeNeeded(uint8_t type) const {\n  auto tlv_type = tlv_types_.find(type);\n  if (tlv_types_.end() != tlv_type) {\n    return &tlv_type->second;\n  }\n\n  return nullptr;\n}\n\nbool Config::isPassThroughTlvTypeNeeded(uint8_t tlv_type) const {\n  if (pass_all_tlvs_) {\n    return true;\n  }\n  return pass_through_tlvs_.contains(tlv_type);\n}\n\nsize_t Config::numberOfNeededTlvTypes() const { return tlv_types_.size(); }\n\nbool Config::allowRequestsWithoutProxyProtocol() const {\n  return allow_requests_without_proxy_protocol_;\n}\n\nNetwork::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {\n  ENVOY_LOG(debug, \"proxy_protocol: New connection accepted\");\n  cb_ = &cb;\n  // Waiting for data.\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Filter::onData(Network::ListenerFilterBuffer& buffer) {\n  const ReadOrParseState read_state = parseBuffer(buffer);\n  switch (read_state) {\n  case ReadOrParseState::Error:\n    config_->stats_.downstream_cx_proxy_proto_error_.inc();\n    cb_->socket().ioHandle().close();\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::TryAgainLater:\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::SkipFilter:\n    return Network::FilterStatus::Continue;\n  case ReadOrParseState::Done:\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::Continue;\n}\n\nReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n    if (proxy_protocol_header_.value().local_command_) {\n      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                proxy_protocol_header_.value().wholeHeaderLength(),\n                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              socket.connectionInfoProvider().remoteAddress(),\n              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              proxy_protocol_header_.value().remote_address_,\n              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}\n\nabsl::optional<size_t> Filter::lenV2Address(const char* buf) {\n  const uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  size_t len;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // According to the spec there is no address encoded, len=0, and we must ignore\n    return 0;\n  }\n\n  switch ((proto_family & 0xf0) >> 4) {\n  case PROXY_PROTO_V2_AF_INET:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET;\n    break;\n  case PROXY_PROTO_V2_AF_INET6:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET6;\n    break;\n  default:\n    ENVOY_LOG(debug, \"Unsupported V2 proxy protocol address family\");\n    return absl::nullopt;\n  }\n  return len;\n}\n\nbool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n        proxy_protocol_header_.emplace(\n            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        proxy_protocol_header_.emplace(WireHeader{\n            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n            std::make_shared<Network::Address::Ipv6Instance>(ra6),\n            std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}\n\nbool Filter::parseV1Header(const char* buf, size_t len) {\n  std::string proxy_line;\n  proxy_line.assign(buf, len);\n  const auto trimmed_proxy_line = StringUtil::rtrim(proxy_line);\n\n  // Parse proxy protocol line with format: PROXY TCP4/TCP6/UNKNOWN SOURCE_ADDRESS\n  // DESTINATION_ADDRESS SOURCE_PORT DESTINATION_PORT.\n  const auto line_parts = StringUtil::splitToken(trimmed_proxy_line, \" \", true);\n  if (line_parts.size() < 2 || line_parts[0] != \"PROXY\") {\n    ENVOY_LOG(debug, \"failed to read proxy protocol\");\n    return false;\n  }\n\n  // If the line starts with UNKNOWN we know it's a proxy protocol line, so we can remove it from\n  // the socket and continue. According to spec \"real connection's parameters\" should be used, so\n  // we should NOT restore the addresses in this case.\n  if (line_parts[1] != \"UNKNOWN\") {\n    // If protocol not UNKNOWN, src and dst addresses have to be present.\n    if (line_parts.size() != 6) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n\n    // TODO(gsagula): parseInternetAddressAndPortNoThrow() could be modified to take two string_view\n    // arguments, so we can eliminate allocation here.\n    if (line_parts[1] == \"TCP4\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[2]} + \":\" +\n                                                               std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[3]} + \":\" +\n                                                               std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v4, remote_address, local_address});\n      return true;\n    } else if (line_parts[1] == \"TCP6\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[2]} +\n                                                               \"]:\" + std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[3]} +\n                                                               \"]:\" + std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v6, remote_address, local_address});\n      return true;\n    } else {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n  }\n  proxy_protocol_header_.emplace(WireHeader{len, 0, 0, 0});\n  return true;\n}\n\n/**\n * @note  A TLV is arranged in the following format:\n *        struct pp2_tlv {\n *          uint8_t type;\n *          uint8_t length_hi;\n *          uint8_t length_lo;\n *          uint8_t value[0];\n *        };\n *        See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details\n */\nbool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}\n\nReadOrParseState Filter::readExtensions(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  // waiting for more data if there is no enough data for extensions.\n  if (raw_slice.len_ < (proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.value().local_command_) {\n    // Ignores the extensions if this is a local command.\n    // Those will drained from the buffer in the end.\n    return ReadOrParseState::Done;\n  }\n\n  const uint8_t* buf = static_cast<const uint8_t*>(raw_slice.mem_) +\n                       proxy_protocol_header_.value().headerLengthWithoutExtension();\n  if (!parseTlvs(buf, proxy_protocol_header_.value().extensions_length_)) {\n    return ReadOrParseState::Error;\n  }\n\n  return ReadOrParseState::Done;\n}\n\nReadOrParseState Filter::readProxyHeader(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  const char* buf = static_cast<const char*>(raw_slice.mem_);\n\n  if (config_.get()->allowRequestsWithoutProxyProtocol()) {\n    auto matchv2 = !memcmp(buf, PROXY_PROTO_V2_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V2_SIGNATURE_LEN, raw_slice.len_));\n    auto matchv1 = !memcmp(buf, PROXY_PROTO_V1_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V1_SIGNATURE_LEN, raw_slice.len_));\n    if (!matchv2 && !matchv1) {\n      // The bytes we have seen so far do not match v1 or v2 proxy protocol, so we can safely\n      // short-circuit\n      ENVOY_LOG(trace, \"request does not use v1 or v2 proxy protocol, forwarding as is\");\n      return ReadOrParseState::SkipFilter;\n    }\n  }\n\n  if (raw_slice.len_ >= PROXY_PROTO_V2_HEADER_LEN) {\n    const char* sig = PROXY_PROTO_V2_SIGNATURE;\n    if (!memcmp(buf, sig, PROXY_PROTO_V2_SIGNATURE_LEN)) {\n      header_version_ = V2;\n    } else if (memcmp(buf, PROXY_PROTO_V1_SIGNATURE, PROXY_PROTO_V1_SIGNATURE_LEN)) {\n      // It is not v2, and can't be v1, so no sense hanging around: it is invalid\n      ENVOY_LOG(debug, \"failed to read proxy protocol (exceed max v1 header len)\");\n      return ReadOrParseState::Error;\n    }\n  }\n\n  if (header_version_ == V2) {\n    const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n    if (((ver_cmd & 0xf0) >> 4) != PROXY_PROTO_V2_VERSION) {\n      ENVOY_LOG(debug, \"Unsupported V2 proxy protocol version\");\n      return ReadOrParseState::Error;\n    }\n    absl::optional<ssize_t> addr_len_opt = lenV2Address(buf);\n    if (!addr_len_opt.has_value()) {\n      return ReadOrParseState::Error;\n    }\n    ssize_t addr_len = addr_len_opt.value();\n    uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n    uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n    ssize_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n    if (hdr_addr_len < addr_len) {\n      ENVOY_LOG(debug,\n                \"incorrect address length, address length = {}, the expected address length = {}\",\n                hdr_addr_len, addr_len);\n      return ReadOrParseState::Error;\n    }\n    // waiting for more data if there is no enough data for address.\n    if (raw_slice.len_ >= static_cast<size_t>(PROXY_PROTO_V2_HEADER_LEN + addr_len)) {\n      // The TLV remain, they are parsed in `parseTlvs()` which is called from the\n      // parent (if needed).\n      if (parseV2Header(buf)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  } else {\n    // continue searching buffer from where we left off\n    for (; search_index_ < raw_slice.len_; search_index_++) {\n      if (buf[search_index_] == '\\n' && buf[search_index_ - 1] == '\\r') {\n        if (search_index_ == 1) {\n          // There is not enough data to determine if it contains the v2 protocol signature, so wait\n          // for more data.\n          break;\n        } else {\n          header_version_ = V1;\n          search_index_++;\n        }\n        break;\n      }\n    }\n\n    if (search_index_ > MAX_PROXY_PROTO_LEN_V1) {\n      return ReadOrParseState::Error;\n    }\n\n    if (header_version_ == V1) {\n      if (parseV1Header(buf, search_index_)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  }\n\n  return ReadOrParseState::TryAgainLater;\n}\n\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/transport_sockets/tls/connection_info_impl_base.h\"\n\n#include \"source/common/common/hex.h\"\n\n#include \"absl/strings/str_replace.h\"\n#include \"openssl/err.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nbool ConnectionInfoImplBase::peerCertificatePresented() const {\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  return cert != nullptr;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::uriSanLocalCertificate() const {\n  if (!cached_uri_san_local_certificate_.empty()) {\n    return cached_uri_san_local_certificate_;\n  }\n\n  // The cert object is not owned.\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_uri_san_local_certificate_.empty());\n    return cached_uri_san_local_certificate_;\n  }\n  cached_uri_san_local_certificate_ = Utility::getSubjectAltNames(*cert, GEN_URI);\n  return cached_uri_san_local_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::dnsSansLocalCertificate() const {\n  if (!cached_dns_san_local_certificate_.empty()) {\n    return cached_dns_san_local_certificate_;\n  }\n\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_dns_san_local_certificate_.empty());\n    return cached_dns_san_local_certificate_;\n  }\n  cached_dns_san_local_certificate_ = Utility::getSubjectAltNames(*cert, GEN_DNS);\n  return cached_dns_san_local_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::ipSansLocalCertificate() const {\n  if (!cached_ip_san_local_certificate_.empty()) {\n    return cached_ip_san_local_certificate_;\n  }\n\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_ip_san_local_certificate_.empty());\n    return cached_ip_san_local_certificate_;\n  }\n  cached_ip_san_local_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_local_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::sha256PeerCertificateDigest() const {\n  if (!cached_sha_256_peer_certificate_digest_.empty()) {\n    return cached_sha_256_peer_certificate_digest_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_sha_256_peer_certificate_digest_.empty());\n    return cached_sha_256_peer_certificate_digest_;\n  }\n\n  std::vector<uint8_t> computed_hash(SHA256_DIGEST_LENGTH);\n  unsigned int n;\n  X509_digest(cert.get(), EVP_sha256(), computed_hash.data(), &n);\n  RELEASE_ASSERT(n == computed_hash.size(), \"\");\n  cached_sha_256_peer_certificate_digest_ = Hex::encode(computed_hash);\n  return cached_sha_256_peer_certificate_digest_;\n}\n\nconst std::string& ConnectionInfoImplBase::sha1PeerCertificateDigest() const {\n  if (!cached_sha_1_peer_certificate_digest_.empty()) {\n    return cached_sha_1_peer_certificate_digest_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_sha_1_peer_certificate_digest_.empty());\n    return cached_sha_1_peer_certificate_digest_;\n  }\n\n  std::vector<uint8_t> computed_hash(SHA_DIGEST_LENGTH);\n  unsigned int n;\n  X509_digest(cert.get(), EVP_sha1(), computed_hash.data(), &n);\n  RELEASE_ASSERT(n == computed_hash.size(), \"\");\n  cached_sha_1_peer_certificate_digest_ = Hex::encode(computed_hash);\n  return cached_sha_1_peer_certificate_digest_;\n}\n\nconst std::string& ConnectionInfoImplBase::urlEncodedPemEncodedPeerCertificate() const {\n  if (!cached_url_encoded_pem_encoded_peer_certificate_.empty()) {\n    return cached_url_encoded_pem_encoded_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_url_encoded_pem_encoded_peer_certificate_.empty());\n    return cached_url_encoded_pem_encoded_peer_certificate_;\n  }\n\n  bssl::UniquePtr<BIO> buf(BIO_new(BIO_s_mem()));\n  RELEASE_ASSERT(buf != nullptr, \"\");\n  RELEASE_ASSERT(PEM_write_bio_X509(buf.get(), cert.get()) == 1, \"\");\n  const uint8_t* output;\n  size_t length;\n  RELEASE_ASSERT(BIO_mem_contents(buf.get(), &output, &length) == 1, \"\");\n  absl::string_view pem(reinterpret_cast<const char*>(output), length);\n  cached_url_encoded_pem_encoded_peer_certificate_ = absl::StrReplaceAll(\n      pem, {{\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}});\n  return cached_url_encoded_pem_encoded_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::urlEncodedPemEncodedPeerCertificateChain() const {\n  if (!cached_url_encoded_pem_encoded_peer_cert_chain_.empty()) {\n    return cached_url_encoded_pem_encoded_peer_cert_chain_;\n  }\n\n  STACK_OF(X509)* cert_chain = SSL_get_peer_full_cert_chain(ssl());\n  if (cert_chain == nullptr) {\n    ASSERT(cached_url_encoded_pem_encoded_peer_cert_chain_.empty());\n    return cached_url_encoded_pem_encoded_peer_cert_chain_;\n  }\n\n  for (uint64_t i = 0; i < sk_X509_num(cert_chain); i++) {\n    X509* cert = sk_X509_value(cert_chain, i);\n\n    bssl::UniquePtr<BIO> buf(BIO_new(BIO_s_mem()));\n    RELEASE_ASSERT(buf != nullptr, \"\");\n    RELEASE_ASSERT(PEM_write_bio_X509(buf.get(), cert) == 1, \"\");\n    const uint8_t* output;\n    size_t length;\n    RELEASE_ASSERT(BIO_mem_contents(buf.get(), &output, &length) == 1, \"\");\n\n    absl::string_view pem(reinterpret_cast<const char*>(output), length);\n    cached_url_encoded_pem_encoded_peer_cert_chain_ = absl::StrCat(\n        cached_url_encoded_pem_encoded_peer_cert_chain_,\n        absl::StrReplaceAll(\n            pem, {{\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}}));\n  }\n  return cached_url_encoded_pem_encoded_peer_cert_chain_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::uriSanPeerCertificate() const {\n  if (!cached_uri_san_peer_certificate_.empty()) {\n    return cached_uri_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_uri_san_peer_certificate_.empty());\n    return cached_uri_san_peer_certificate_;\n  }\n  cached_uri_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_URI);\n  return cached_uri_san_peer_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::dnsSansPeerCertificate() const {\n  if (!cached_dns_san_peer_certificate_.empty()) {\n    return cached_dns_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_dns_san_peer_certificate_.empty());\n    return cached_dns_san_peer_certificate_;\n  }\n  cached_dns_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_DNS);\n  return cached_dns_san_peer_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}\n\nuint16_t ConnectionInfoImplBase::ciphersuiteId() const {\n  const SSL_CIPHER* cipher = SSL_get_current_cipher(ssl());\n  if (cipher == nullptr) {\n    return 0xffff;\n  }\n\n  // From the OpenSSL docs:\n  //    SSL_CIPHER_get_id returns |cipher|'s id. It may be cast to a |uint16_t| to\n  //    get the cipher suite value.\n  return static_cast<uint16_t>(SSL_CIPHER_get_id(cipher));\n}\n\nstd::string ConnectionInfoImplBase::ciphersuiteString() const {\n  const SSL_CIPHER* cipher = SSL_get_current_cipher(ssl());\n  if (cipher == nullptr) {\n    return {};\n  }\n\n  return SSL_CIPHER_get_name(cipher);\n}\n\nconst std::string& ConnectionInfoImplBase::tlsVersion() const {\n  if (!cached_tls_version_.empty()) {\n    return cached_tls_version_;\n  }\n  cached_tls_version_ = SSL_get_version(ssl());\n  return cached_tls_version_;\n}\n\nconst std::string& ConnectionInfoImplBase::alpn() const {\n  if (alpn_.empty()) {\n    const unsigned char* proto;\n    unsigned int proto_len;\n    SSL_get0_alpn_selected(ssl(), &proto, &proto_len);\n    if (proto != nullptr) {\n      alpn_ = std::string(reinterpret_cast<const char*>(proto), proto_len);\n    }\n  }\n  return alpn_;\n}\n\nconst std::string& ConnectionInfoImplBase::sni() const {\n  if (sni_.empty()) {\n    const char* proto = SSL_get_servername(ssl(), TLSEXT_NAMETYPE_host_name);\n    if (proto != nullptr) {\n      sni_ = std::string(proto);\n    }\n  }\n  return sni_;\n}\n\nconst std::string& ConnectionInfoImplBase::serialNumberPeerCertificate() const {\n  if (!cached_serial_number_peer_certificate_.empty()) {\n    return cached_serial_number_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_serial_number_peer_certificate_.empty());\n    return cached_serial_number_peer_certificate_;\n  }\n  cached_serial_number_peer_certificate_ = Utility::getSerialNumberFromCertificate(*cert.get());\n  return cached_serial_number_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::issuerPeerCertificate() const {\n  if (!cached_issuer_peer_certificate_.empty()) {\n    return cached_issuer_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_issuer_peer_certificate_.empty());\n    return cached_issuer_peer_certificate_;\n  }\n  cached_issuer_peer_certificate_ = Utility::getIssuerFromCertificate(*cert);\n  return cached_issuer_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::subjectPeerCertificate() const {\n  if (!cached_subject_peer_certificate_.empty()) {\n    return cached_subject_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_subject_peer_certificate_.empty());\n    return cached_subject_peer_certificate_;\n  }\n  cached_subject_peer_certificate_ = Utility::getSubjectFromCertificate(*cert);\n  return cached_subject_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::subjectLocalCertificate() const {\n  if (!cached_subject_local_certificate_.empty()) {\n    return cached_subject_local_certificate_;\n  }\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_subject_local_certificate_.empty());\n    return cached_subject_local_certificate_;\n  }\n  cached_subject_local_certificate_ = Utility::getSubjectFromCertificate(*cert);\n  return cached_subject_local_certificate_;\n}\n\nabsl::optional<SystemTime> ConnectionInfoImplBase::validFromPeerCertificate() const {\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    return absl::nullopt;\n  }\n  return Utility::getValidFrom(*cert);\n}\n\nabsl::optional<SystemTime> ConnectionInfoImplBase::expirationPeerCertificate() const {\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    return absl::nullopt;\n  }\n  return Utility::getExpirationTime(*cert);\n}\n\nconst std::string& ConnectionInfoImplBase::sessionId() const {\n  if (!cached_session_id_.empty()) {\n    return cached_session_id_;\n  }\n  SSL_SESSION* session = SSL_get_session(ssl());\n  if (session == nullptr) {\n    ASSERT(cached_session_id_.empty());\n    return cached_session_id_;\n  }\n\n  unsigned int session_id_length = 0;\n  const uint8_t* session_id = SSL_SESSION_get_id(session, &session_id_length);\n  cached_session_id_ = Hex::encode(session_id, session_id_length);\n  return cached_session_id_;\n}\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/transport_sockets/tls/utility.h\"\n\n#include <cstdint>\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"absl/strings/str_join.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nstatic constexpr absl::string_view SSL_ERROR_UNKNOWN_ERROR_MESSAGE = \"UNKNOWN_ERROR\";\n\nEnvoy::Ssl::CertificateDetailsPtr Utility::certificateDetails(X509* cert, const std::string& path,\n                                                              TimeSource& time_source) {\n  Envoy::Ssl::CertificateDetailsPtr certificate_details =\n      std::make_unique<envoy::admin::v3::CertificateDetails>();\n  certificate_details->set_path(path);\n  certificate_details->set_serial_number(Utility::getSerialNumberFromCertificate(*cert));\n  const auto days_until_expiry = Utility::getDaysUntilExpiration(cert, time_source).value_or(0);\n  certificate_details->set_days_until_expiration(days_until_expiry);\n\n  ProtobufWkt::Timestamp* valid_from = certificate_details->mutable_valid_from();\n  TimestampUtil::systemClockToTimestamp(Utility::getValidFrom(*cert), *valid_from);\n  ProtobufWkt::Timestamp* expiration_time = certificate_details->mutable_expiration_time();\n  TimestampUtil::systemClockToTimestamp(Utility::getExpirationTime(*cert), *expiration_time);\n\n  for (auto& dns_san : Utility::getSubjectAltNames(*cert, GEN_DNS)) {\n    envoy::admin::v3::SubjectAlternateName& subject_alt_name =\n        *certificate_details->add_subject_alt_names();\n    subject_alt_name.set_dns(dns_san);\n  }\n  for (auto& uri_san : Utility::getSubjectAltNames(*cert, GEN_URI)) {\n    envoy::admin::v3::SubjectAlternateName& subject_alt_name =\n        *certificate_details->add_subject_alt_names();\n    subject_alt_name.set_uri(uri_san);\n  }\n  for (auto& ip_san : Utility::getSubjectAltNames(*cert, GEN_IPADD)) {\n    envoy::admin::v3::SubjectAlternateName& subject_alt_name =\n        *certificate_details->add_subject_alt_names();\n    subject_alt_name.set_ip_address(ip_san);\n  }\n  return certificate_details;\n}\n\nbool Utility::labelWildcardMatch(absl::string_view dns_label, absl::string_view pattern) {\n  constexpr char glob = '*';\n  // Check the special case of a single * pattern, as it's common.\n  if (pattern.size() == 1 && pattern[0] == glob) {\n    return true;\n  }\n  // Only valid if wildcard character appear once.\n  if (std::count(pattern.begin(), pattern.end(), glob) == 1) {\n    std::vector<absl::string_view> split_pattern = absl::StrSplit(pattern, glob);\n    return (pattern.size() <= dns_label.size() + 1) &&\n           absl::StartsWith(dns_label, split_pattern[0]) &&\n           absl::EndsWith(dns_label, split_pattern[1]);\n  }\n  return false;\n}\n\nbool Utility::dnsNameMatch(absl::string_view dns_name, absl::string_view pattern) {\n  // A-label ACE prefix https://www.rfc-editor.org/rfc/rfc5890#section-2.3.2.5.\n  constexpr absl::string_view ACE_prefix = \"xn--\";\n  const std::string lower_case_dns_name = absl::AsciiStrToLower(dns_name);\n  const std::string lower_case_pattern = absl::AsciiStrToLower(pattern);\n  if (lower_case_dns_name == lower_case_pattern) {\n    return true;\n  }\n\n  std::vector<absl::string_view> split_pattern =\n      absl::StrSplit(lower_case_pattern, absl::MaxSplits('.', 1));\n  std::vector<absl::string_view> split_dns_name =\n      absl::StrSplit(lower_case_dns_name, absl::MaxSplits('.', 1));\n\n  // dns name and pattern should contain more than 1 label to match.\n  if (split_pattern.size() < 2 || split_dns_name.size() < 2) {\n    return false;\n  }\n  // Only the left-most label in the pattern contains wildcard '*' and is not an A-label.\n  if ((split_pattern[0].find('*') != absl::string_view::npos) &&\n      (split_pattern[1].find('*') == absl::string_view::npos) &&\n      (!absl::StartsWith(split_pattern[0], ACE_prefix))) {\n    return (split_dns_name[1] == split_pattern[1]) &&\n           labelWildcardMatch(split_dns_name[0], split_pattern[0]);\n  }\n\n  return false;\n}\n\nnamespace {\n\nenum class CertName { Issuer, Subject };\n\n/**\n * Retrieves a name from a certificate and formats it as an RFC 2253 name.\n * @param cert the certificate.\n * @param desired_name the desired name (Issuer or Subject) to retrieve from the certificate.\n * @return std::string returns the desired name formatted as an RFC 2253 name.\n */\nstd::string getRFC2253NameFromCertificate(X509& cert, CertName desired_name) {\n  bssl::UniquePtr<BIO> buf(BIO_new(BIO_s_mem()));\n  RELEASE_ASSERT(buf != nullptr, \"\");\n\n  X509_NAME* name = nullptr;\n  switch (desired_name) {\n  case CertName::Issuer:\n    name = X509_get_issuer_name(&cert);\n    break;\n  case CertName::Subject:\n    name = X509_get_subject_name(&cert);\n    break;\n  }\n\n  // flags=XN_FLAG_RFC2253 is the documented parameter for single-line output in RFC 2253 format.\n  // Example from the RFC:\n  //   * Single value per Relative Distinguished Name (RDN): CN=Steve Kille,O=Isode Limited,C=GB\n  //   * Multivalue output in first RDN: OU=Sales+CN=J. Smith,O=Widget Inc.,C=US\n  //   * Quoted comma in Organization: CN=L. Eagle,O=Sue\\, Grabbit and Runn,C=GB\n  X509_NAME_print_ex(buf.get(), name, 0 /* indent */, XN_FLAG_RFC2253);\n\n  const uint8_t* data;\n  size_t data_len;\n  int rc = BIO_mem_contents(buf.get(), &data, &data_len);\n  ASSERT(rc == 1);\n  return {reinterpret_cast<const char*>(data), data_len};\n}\n\n} // namespace\n\nconst ASN1_TIME& epochASN1Time() {\n  static ASN1_TIME* e = []() -> ASN1_TIME* {\n    ASN1_TIME* epoch = ASN1_TIME_new();\n    const time_t epoch_time = 0;\n    RELEASE_ASSERT(ASN1_TIME_set(epoch, epoch_time) != nullptr, \"\");\n    return epoch;\n  }();\n  return *e;\n}\n\ninline bssl::UniquePtr<ASN1_TIME> currentASN1Time(TimeSource& time_source) {\n  bssl::UniquePtr<ASN1_TIME> current_asn_time(ASN1_TIME_new());\n  const time_t current_time = std::chrono::system_clock::to_time_t(time_source.systemTime());\n  RELEASE_ASSERT(ASN1_TIME_set(current_asn_time.get(), current_time) != nullptr, \"\");\n  return current_asn_time;\n}\n\nstd::string Utility::getSerialNumberFromCertificate(X509& cert) {\n  ASN1_INTEGER* serial_number = X509_get_serialNumber(&cert);\n  BIGNUM num_bn;\n  BN_init(&num_bn);\n  ASN1_INTEGER_to_BN(serial_number, &num_bn);\n  char* char_serial_number = BN_bn2hex(&num_bn);\n  BN_free(&num_bn);\n  if (char_serial_number != nullptr) {\n    std::string serial_number(char_serial_number);\n    OPENSSL_free(char_serial_number);\n    return serial_number;\n  }\n  return \"\";\n}\n\nstd::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      subject_alt_names.push_back(generalNameAsString(san));\n    }\n  }\n  return subject_alt_names;\n}\n\nstd::string Utility::generalNameAsString(const GENERAL_NAME* general_name) {\n  std::string san;\n  switch (general_name->type) {\n  case GEN_DNS: {\n    ASN1_STRING* str = general_name->d.dNSName;\n    san.assign(reinterpret_cast<const char*>(ASN1_STRING_data(str)), ASN1_STRING_length(str));\n    break;\n  }\n  case GEN_URI: {\n    ASN1_STRING* str = general_name->d.uniformResourceIdentifier;\n    san.assign(reinterpret_cast<const char*>(ASN1_STRING_data(str)), ASN1_STRING_length(str));\n    break;\n  }\n  case GEN_EMAIL: {\n    ASN1_STRING* str = general_name->d.rfc822Name;\n    san.assign(reinterpret_cast<const char*>(ASN1_STRING_data(str)), ASN1_STRING_length(str));\n    break;\n  }\n  case GEN_IPADD: {\n    if (general_name->d.ip->length == 4) {\n      sockaddr_in sin;\n      memset(&sin, 0, sizeof(sin));\n      sin.sin_port = 0;\n      sin.sin_family = AF_INET;\n      safeMemcpyUnsafeSrc(&sin.sin_addr, general_name->d.ip->data);\n      Network::Address::Ipv4Instance addr(&sin);\n      san = addr.ip()->addressAsString();\n    } else if (general_name->d.ip->length == 16) {\n      sockaddr_in6 sin6;\n      memset(&sin6, 0, sizeof(sin6));\n      sin6.sin6_port = 0;\n      sin6.sin6_family = AF_INET6;\n      safeMemcpyUnsafeSrc(&sin6.sin6_addr, general_name->d.ip->data);\n      Network::Address::Ipv6Instance addr(sin6);\n      san = addr.ip()->addressAsString();\n    }\n    break;\n  }\n  }\n  return san;\n}\n\nstd::string Utility::getIssuerFromCertificate(X509& cert) {\n  return getRFC2253NameFromCertificate(cert, CertName::Issuer);\n}\n\nstd::string Utility::getSubjectFromCertificate(X509& cert) {\n  return getRFC2253NameFromCertificate(cert, CertName::Subject);\n}\n\nabsl::optional<uint32_t> Utility::getDaysUntilExpiration(const X509* cert,\n                                                         TimeSource& time_source) {\n  if (cert == nullptr) {\n    return absl::make_optional(std::numeric_limits<uint32_t>::max());\n  }\n  int days, seconds;\n  if (ASN1_TIME_diff(&days, &seconds, currentASN1Time(time_source).get(),\n                     X509_get0_notAfter(cert))) {\n    if (days >= 0 && seconds >= 0) {\n      return absl::make_optional(days);\n    }\n  }\n  return absl::nullopt;\n}\n\nabsl::string_view Utility::getCertificateExtensionValue(X509& cert,\n                                                        absl::string_view extension_name) {\n  bssl::UniquePtr<ASN1_OBJECT> oid(\n      OBJ_txt2obj(std::string(extension_name).c_str(), 1 /* don't search names */));\n  if (oid == nullptr) {\n    return {};\n  }\n\n  int pos = X509_get_ext_by_OBJ(&cert, oid.get(), -1);\n  if (pos < 0) {\n    return {};\n  }\n\n  X509_EXTENSION* extension = X509_get_ext(&cert, pos);\n  if (extension == nullptr) {\n    return {};\n  }\n\n  const ASN1_OCTET_STRING* octet_string = X509_EXTENSION_get_data(extension);\n  RELEASE_ASSERT(octet_string != nullptr, \"\");\n\n  // Return the entire DER-encoded value for this extension. Correct decoding depends on\n  // knowledge of the expected structure of the extension's value.\n  const unsigned char* octet_string_data = ASN1_STRING_get0_data(octet_string);\n  const int octet_string_length = ASN1_STRING_length(octet_string);\n\n  return {reinterpret_cast<const char*>(octet_string_data),\n          static_cast<absl::string_view::size_type>(octet_string_length)};\n}\n\nSystemTime Utility::getValidFrom(const X509& cert) {\n  int days, seconds;\n  int rc = ASN1_TIME_diff(&days, &seconds, &epochASN1Time(), X509_get0_notBefore(&cert));\n  ASSERT(rc == 1);\n  // Casting to <time_t (64bit)> to prevent multiplication overflow when certificate valid-from date\n  // beyond 2038-01-19T03:14:08Z.\n  return std::chrono::system_clock::from_time_t(static_cast<time_t>(days) * 24 * 60 * 60 + seconds);\n}\n\nSystemTime Utility::getExpirationTime(const X509& cert) {\n  int days, seconds;\n  int rc = ASN1_TIME_diff(&days, &seconds, &epochASN1Time(), X509_get0_notAfter(&cert));\n  ASSERT(rc == 1);\n  // Casting to <time_t (64bit)> to prevent multiplication overflow when certificate not-after date\n  // beyond 2038-01-19T03:14:08Z.\n  return std::chrono::system_clock::from_time_t(static_cast<time_t>(days) * 24 * 60 * 60 + seconds);\n}\n\nabsl::optional<std::string> Utility::getLastCryptoError() {\n  auto err = ERR_get_error();\n\n  if (err != 0) {\n    char errbuf[256];\n\n    ERR_error_string_n(err, errbuf, sizeof(errbuf));\n    return std::string(errbuf);\n  }\n\n  return absl::nullopt;\n}\n\nabsl::string_view Utility::getErrorDescription(int err) {\n  const char* description = SSL_error_description(err);\n  if (description) {\n    return description;\n  }\n\n  IS_ENVOY_BUG(\"BoringSSL error had occurred: SSL_error_description() returned nullptr\");\n  return SSL_ERROR_UNKNOWN_ERROR_MESSAGE;\n}\n\nstd::string Utility::getX509VerificationErrorInfo(X509_STORE_CTX* ctx) {\n  const int n = X509_STORE_CTX_get_error(ctx);\n  const int depth = X509_STORE_CTX_get_error_depth(ctx);\n  std::string error_details =\n      absl::StrCat(\"X509_verify_cert: certificate verification error at depth \", depth, \": \",\n                   X509_verify_cert_error_string(n));\n  return error_details;\n}\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <string>\n#include <vector>\n\n#include \"envoy/ssl/context.h\"\n\n#include \"source/common/common/utility.h\"\n\n#include \"absl/types/optional.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\nnamespace Utility {\n\nEnvoy::Ssl::CertificateDetailsPtr certificateDetails(X509* cert, const std::string& path,\n                                                     TimeSource& time_source);\n\n/**\n * Determines whether the given name matches 'pattern' which may optionally begin with a wildcard\n * or contain a wildcard inside the pattern's first label.\n * See: https://www.rfc-editor.org/rfc/rfc6125#section-6.4.3.\n * @param dns_name the DNS name to match\n * @param pattern the pattern to match against (*.example.com) or (test*.example.com)\n * @return true if the san matches pattern\n */\nbool dnsNameMatch(absl::string_view dns_name, absl::string_view pattern);\n\n/**\n * Determines whether the given DNS label matches 'pattern' which may contain a wildcard. e.g.,\n * patterns \"baz*\" and \"*baz\" and \"b*z\" would match DNS labels \"baz1\" and \"foobaz\" and \"buzz\",\n * respectively.\n * @param dns_label the DNS name label to match in lower case\n * @param pattern the pattern to match against in lower case\n * @return true if the dns_label matches pattern\n */\nbool labelWildcardMatch(absl::string_view dns_label, absl::string_view pattern);\n\n/**\n * Retrieves the serial number of a certificate.\n * @param cert the certificate\n * @return std::string the serial number field of the certificate. Returns \"\" if\n *         there is no serial number.\n */\nstd::string getSerialNumberFromCertificate(X509& cert);\n\n/**\n * Retrieves the subject alternate names of a certificate.\n * @param cert the certificate\n * @param type type of subject alternate name\n * @return std::vector returns the list of subject alternate names.\n */\nstd::vector<std::string> getSubjectAltNames(X509& cert, int type);\n\n/**\n * Converts the Subject Alternate Name to string.\n * @param general_name the subject alternate name\n * @return std::string returns the string representation of subject alt names.\n */\nstd::string generalNameAsString(const GENERAL_NAME* general_name);\n\n/**\n * Retrieves the issuer from certificate.\n * @param cert the certificate\n * @return std::string the issuer field for the certificate.\n */\nstd::string getIssuerFromCertificate(X509& cert);\n\n/**\n * Retrieves the subject from certificate.\n * @param cert the certificate\n * @return std::string the subject field for the certificate.\n */\nstd::string getSubjectFromCertificate(X509& cert);\n\n/**\n * Retrieves the value of a specific X509 extension from the cert, if present.\n * @param cert the certificate.\n * @param extension_name the name of the extension to extract in dotted number format\n * @return absl::string_view the DER-encoded value of the extension field or empty if not present.\n */\nabsl::string_view getCertificateExtensionValue(X509& cert, absl::string_view extension_name);\n\n/**\n * Returns the days until this certificate is valid.\n * @param cert the certificate\n * @param time_source the time source to use for current time calculation.\n * @return the number of days till this certificate is valid, the value is set when not expired.\n */\nabsl::optional<uint32_t> getDaysUntilExpiration(const X509* cert, TimeSource& time_source);\n\n/**\n * Returns the time from when this certificate is valid.\n * @param cert the certificate.\n * @return time from when this certificate is valid.\n */\nSystemTime getValidFrom(const X509& cert);\n\n/**\n * Returns the time when this certificate expires.\n * @param cert the certificate.\n * @return time after which the certificate expires.\n */\nSystemTime getExpirationTime(const X509& cert);\n\n/**\n * Returns the last crypto error from ERR_get_error(), or `absl::nullopt`\n * if the error stack is empty.\n * @return std::string error message\n */\nabsl::optional<std::string> getLastCryptoError();\n\n/**\n * Returns error string corresponding error code derived from OpenSSL.\n * @param err error code\n * @return string message corresponding error code.\n */\nabsl::string_view getErrorDescription(int err);\n\n/**\n * Extracts the X509 certificate validation error information.\n *\n * @param ctx the store context\n * @return the error details\n */\nstd::string getX509VerificationErrorInfo(X509_STORE_CTX* ctx);\n\n} // namespace Utility\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = v3_req\n\n[req_distinguished_name]\ncountryName = US\ncountryName_default = US\nstateOrProvinceName = California\nstateOrProvinceName_default = California\nlocalityName = San Francisco\nlocalityName_default = San Francisco\norganizationName = Lyft\norganizationName_default = Lyft\norganizationalUnitName = Lyft Engineering\norganizationalUnitName_default = Lyft Engineering\ncommonName = Test Frontend Team\ncommonName_default = Test Frontend Team\ncommonName_max  = 64\nemailAddress = frontend-team@lyft.com\nemailAddress_default = frontend-team@lyft.com\n\n[v3_req]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = clientAuth, serverAuth\nsubjectAltName = @alt_names\nsubjectKeyIdentifier = hash\n\n[v3_ca]\nbasicConstraints = critical, CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = clientAuth, serverAuth\nsubjectAltName = @alt_names\nsubjectKeyIdentifier = hash\nauthorityKeyIdentifier = keyid:always\n\n[alt_names]\nURI.1 = spiffe://lyft.com/frontend-team\nURI.2 = http://frontend.lyft.com\nDNS.1 = lyft.com\nDNS.2 = www.lyft.com\n", "-----BEGIN CERTIFICATE-----\nMIIEiTCCA3GgAwIBAgIUT9Wze0Fvw/pMvqAmPJjlD7HNjZAwDQYJKoZIhvcNAQEL\nBQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM\nDVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsMEEx5ZnQgRW5n\naW5lZXJpbmcxEDAOBgNVBAMMB1Rlc3QgQ0EwHhcNMjIwNDA3MTY0NjM1WhcNMjQw\nNDA2MTY0NjM1WjCBqDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx\nFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsM\nEEx5ZnQgRW5naW5lZXJpbmcxGzAZBgNVBAMMElRlc3QgRnJvbnRlbmQgVGVhbTEl\nMCMGCSqGSIb3DQEJARYWZnJvbnRlbmQtdGVhbUBseWZ0LmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAOwOQ96U2nYcA+lV5eFmHqwkUVH/b5wn/FXg\nALBfT2qSn2pzMmqj3RHebqN4I7uiRGPmk7eVHxktW/ytFDdk+AwbGEOP8vWl9zR7\n3pveKchHVSdSNJ4RkXpgDLZYDDDj/JQxNzDwPD43eIUw9SKj+Mw9nTRv0hm39hhh\nhjBmvOfbdWjQPMsuSDqEAPGE06PpirTdwZNSsuBjfvo6zdnJxTgzd/Cf1KINda4P\nxklw9M9CuKQMeLwVfwMDNeI2uJ7kn1dpsOhSDBU7LEleSWGGAlcycDzLuy/5/rKc\ndON9MKUK+82rJ+cME6I+DYqS1Nz+wY9t8farXLuGK41n0G4qr1MCAwEAAaOB2zCB\n2DAMBgNVHRMBAf8EAjAAMAsGA1UdDwQEAwIF4DAdBgNVHSUEFjAUBggrBgEFBQcD\nAgYIKwYBBQUHAwEwXAYDVR0RBFUwU4Yfc3BpZmZlOi8vbHlmdC5jb20vZnJvbnRl\nbmQtdGVhbYYYaHR0cDovL2Zyb250ZW5kLmx5ZnQuY29tgghseWZ0LmNvbYIMd3d3\nLmx5ZnQuY29tMB0GA1UdDgQWBBROWpBWXFbgQUweTJcDDdEtGxJ6wzAfBgNVHSME\nGDAWgBQdDTmYdOz7TqwMpoOli3Dmj78ygjANBgkqhkiG9w0BAQsFAAOCAQEALyDC\nCJ2V30VRqf/vHnv4hocaNvkbg2XqSczsNsXQB9Oh15y2nrTu8nIlktJeMCwgYKB3\ntyuIYADw2c0HKmFshOiNM3P1taM+Gljx/OeyhMq/dgKTF0rX7w3vOoWrvW7o0cDJ\ngBzDAmPJegrIlAqfb97MOcLtBlk9vjh7ukh8BSRI+5Hdj5Gb8Y6tQvmiqzm5yx5L\nSwz7im1BIGwk4Hq82JO20egDYCn9zhmuDIEJGtRbl0ymcfdaC4oKqiqU/CrynaAo\nSkNXfca8Sqk1tvbfDzNkOAnLN572vkbhUnLfcqcfouRXlUl2DYmG+dCoYuWw4/co\nahwsslCKM3xGY4ax9Q==\n-----END CERTIFICATE-----\n", "#pragma once\n\n// NOLINT(namespace-envoy)\nconstexpr char TEST_CLIENT_CERT_HASH[] = \"4A:FD:3A:AE:4B:36:08:A6:CB:41:4F:20:8A:86:1F:3B:43:6F:2F:\"\n                                         \"12:49:82:8D:9F:F6:FA:53:4D:23:26:FB:43\";\n", "-----BEGIN RSA PRIVATE KEY-----\nMIIEpAIBAAKCAQEA7A5D3pTadhwD6VXl4WYerCRRUf9vnCf8VeAAsF9PapKfanMy\naqPdEd5uo3gju6JEY+aTt5UfGS1b/K0UN2T4DBsYQ4/y9aX3NHvem94pyEdVJ1I0\nnhGRemAMtlgMMOP8lDE3MPA8Pjd4hTD1IqP4zD2dNG/SGbf2GGGGMGa859t1aNA8\nyy5IOoQA8YTTo+mKtN3Bk1Ky4GN++jrN2cnFODN38J/Uog11rg/GSXD0z0K4pAx4\nvBV/AwM14ja4nuSfV2mw6FIMFTssSV5JYYYCVzJwPMu7L/n+spx0430wpQr7zasn\n5wwToj4NipLU3P7Bj23x9qtcu4YrjWfQbiqvUwIDAQABAoIBAQDKY5ixODLuXSrF\nXo6QaLwXn7PReA67dlUVU8+DaNRwbXIdFNO/NuuOLIXzxkfs0j2M4d744fQd5BQg\nWk0hCYLa7kgpdTw8faWr7CB6x0pPm0lZQ1Q1yp5OrBd6J5ecO30NmfzWCsO8HFdK\n6yTiJHBmvNUSZmVfA6kOUl95FD0XFB7J/4MPmE0UqEg5IhoWxpH9cEV8yll/bZZL\nFHzA1cfwjtcHp5kHm/7IYlWqpShpdsquMmZt8vHFaoGvT5pms/AtAFjjDcW5dFpZ\nGipS5D/3oPMXWbhrzMoIe8ERVBmlKPVoUmxUNIomgRSTP6/+mgcgojRRqcLW3l0W\nKXi4i1dhAoGBAPmgVd+2K5vox09EbYaD1KAZpwuW61PQ6RI3wU5YCf84FoNAzK+e\nKHSI+5Vo7JkwwiP7MSIJhiODG9VRnfou06NPEY4jllcMXp73PVGhOzsnHTqsbgps\nYg9tXsX5jQDx60yIOHf7halAz3vpEldQ6YecLscYV0Oz5i84gl/jee5JAoGBAPIV\nOfuf88WjErvuAxqIJWx85afr4B8YfChKHIVEx1eI6o89xuB16FjFzKAhHe9SJdfk\nYVOwYD/9MRZ5+ZZAsRrKTHbD3VX20c0ECX9++/Sz2LGMewgvqiscpfGzDTsTJIVA\nEp31IAXmAUsmBAQAbuXxtbpKgU8Wi3mSp4nFzKC7AoGAUlpgGkbqSixYnMERdSBG\n5G6yGnO2vVcdnWIBhwwqeCWT38df/8wowpFylo8gB0X7to0nX3hO5aZaZ1zexmvu\nbGEohIEfFybAjKc6dpS/irtTvEiooQ2yqC5H5v52U0p8eyoxnvu+0+DK0rFI2L+b\n255eHFbeazqNhSSadnIAhukCgYEAtfKAPv/sb0nupbLxQDq9rfl9fqVJMPXtMzbo\nkr2r+b2dVgW/eSsFc9tOvbfGUP50FPzAre7tmIqLH3KTxXtf4VvU9pqlu5uj+iwj\nm2Dsq/GUV3XXbsKsanTAwJWrxw/PLhuHIpN++w/xPvMWp49PyqHNzXN8Ft5B/CDe\nrS0ubEsCgYA5kvmEDFYLF4TU7xg3QJ08+6+tJ+HZdvCBzE7RGJD8l5ZfpJuE6s9E\naW09E+65hSMaE85MpiM/s08quiMQeR6i7UWeN4GwoQznH1f9zUAuyP1J1Iv2knj7\nlZ+oGk0EgnjkiIxo3ppAoKGz2/9Oi09lsEbdIBHvC56DAu44uOP50A==\n-----END RSA PRIVATE KEY-----\n", "#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/listener_manager/connection_handler_impl.h\"\n#include \"source/common/network/connection_balancer_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/raw_buffer_socket.h\"\n#include \"source/common/network/tcp_listener_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include \"test/mocks/api/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/listener_factory_context.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/threadsafe_singleton_injector.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::ElementsAre;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\nnamespace {\n\n// Build again on the basis of the connection_handler_test.cc\n\nclass ProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                          public Network::ListenerConfig,\n                          public Network::FilterChainManager,\n                          protected Logger::Loggable<Logger::Id::main> {\npublic:\n  ProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getCanonicalLoopbackAddress(GetParam()))),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                                Network::Address::InstanceConstSharedPtr(),\n                                                Network::Test::createRawBufferSocket(), nullptr,\n                                                nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect(bool read = true,\n               const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol*\n                   proto_config = nullptr) {\n    int expected_callbacks = 2;\n    auto maybeExitDispatcher = [&]() -> void {\n      expected_callbacks--;\n      if (expected_callbacks == 0) {\n        dispatcher_->exit();\n      }\n    };\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr, std::make_unique<Filter>(std::make_shared<Config>(\n                           listenerScope(), (nullptr != proto_config)\n                                                ? *proto_config\n                                                : envoy::extensions::filters::listener::\n                                                      proxy_protocol::v3::ProxyProtocol())));\n          maybeExitDispatcher();\n          return true;\n        }));\n    conn_->connect();\n    if (read) {\n      read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n      EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n          .WillOnce(Invoke([&](Network::Connection& connection,\n                               const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n            server_connection_ = &connection;\n            connection.addConnectionCallbacks(server_callbacks_);\n            connection.addReadFilter(read_filter_);\n            return true;\n          }));\n    }\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { maybeExitDispatcher(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const uint8_t* s, ssize_t l) {\n    Buffer::OwnedImpl buf(s, l);\n    conn_->write(buf, false);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void expectConnectionError() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n  void expectProxyProtoError() {\n    expectConnectionError();\n    EXPECT_EQ(stats_store_.counter(\"downstream_cx_proxy_proto_error\").value(), 1);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::TestUtil::TestStore stats_store_;\n  Api::ApiPtr api_;\n  BasicResourceLimitImpl open_connections_;\n  Event::DispatcherPtr dispatcher_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  Api::OsSysCallsImpl os_sys_calls_actual_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(ProxyProtocolTest, V1Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocol) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"data\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN,\n            msg.length()); // Ensure we attempt parsing byte by byte using `search_index_`\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV1First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v1, second two bytes are proxy protocol v2.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"PR\\r\\n\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV2First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v2, second two bytes are proxy protocol v1.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"\\r\\nOX\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowLargeNoProxyProtocol) {\n  // Allows a large request (more bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"more data more data more data\";\n  ASSERT_GT(msg.length(),\n            PROXY_PROTO_V2_HEADER_LEN); // Ensure we attempt parsing as v2 proxy protocol up front\n                                        // rather than parsing byte by byte using `search_index_`\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V1Minimal) {\n  connect();\n  write(\"PROXY UNKNOWN\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  } else {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Basic) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2BasicV6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedAF) {\n  // A well-formed message with an unsupported address family\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x41, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_2) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv (e.g. socket close)\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n// TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_1) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2NotLocalOrOnBehalf) {\n  // An illegal command type: neither 'local' nor 'proxy' command\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x23, 0x1f, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnection) {\n  // A 'local' connection, e.g. health-checking, no address, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionExtension) {\n  // A 'local' connection, e.g. health-checking, no address, 1 TLV (0x00,0x00,0x01,0xff) is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xff,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  // A well-formed local proxy protocol v2 header sampled from an AWS NLB healthcheck request,\n  // no address, 1 TLV is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4) {\n  // An ipv4/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4WithAllowNoProxyProtocol) {\n  // An ipv4/tcp PROXY header that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV4) {\n  // An ipv4/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0b, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV6) {\n  // An ipv6/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV6) {\n  // An ipv6/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x23, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2AF_UNIX) {\n  // A well-formed AF_UNIX (0x32 in b14) connection is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2BadCommand) {\n  // A non local/proxy command (0x29 in b13) is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x29, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongVersion) {\n  // A non '2' version is rejected (0x93 in b13)\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x93, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLong) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLongWithAllowNoProxyProtocol) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsRecvError) {\n  // A well-formed ipv4/tcp with a TLV extension. An error is returned on tlv recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n  bool header_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int iovcnt) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, iovcnt);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  header_writed = true;\n  write(tlv, sizeof(tlv));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsFrag) {\n  // A well-formed ipv4/tcp header with 2 TLV/extensions, these are fragmented on delivery\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, Fragmented) {\n  connect();\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  // If there is no data after the PROXY line, the read filter does not receive even the\n  // onNewConnection() callback. We need this in order to run the dispatcher in blocking\n  // mode to make sure that proxy protocol processing is completed before we start testing\n  // the results. Since we must have data we might as well check that we get it.\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented1) {\n  // A well-formed ipv4/tcp message, delivering part of the signature, then part of\n  // the address, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 10, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 20, 17);\n\n  expectData(\"more data\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented2) {\n  // A well-formed ipv4/tcp message, delivering all of the header + 1, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 17, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 27, 10);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented3) {\n  // A well-formed ipv4/tcp message, delivering all of the header, then the remainder.\n  // Do not mistakenly consider that remote has closed when it happens to only read the\n  // header of the message. See: https://github.com/envoyproxy/envoy/pull/18304\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 16);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 16, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 26, 11);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented4Error) {\n  // A well-formed ipv4/tcp message, delivering all of the header +1, w/ an error\n  // simulated in recv() on the +1\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_writed = true;\n  write(buffer, 11);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented5Error) {\n  // A well-formed ipv4/tcp message, part of the signature with an error introduced\n  // in recv() on the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_write = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_write = true;\n  write(buffer + 10, 10);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, PartialRead) {\n  connect();\n\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PROXY TCP4\"); // Intentionally larger than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PRO\"); // Intentionally smaller than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"XY TCP4 25\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"4.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2PartialRead) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  connect();\n\n  for (size_t i = 0; i < sizeof(buffer); i += 9) {\n    write(&buffer[i], 9);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 18 intentionally as it is larger than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 18;\n  ASSERT_LT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 3 intentionally as it is smaller than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 3;\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nconst std::string ProxyProtocol = \"envoy.filters.listener.proxy_protocol\";\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsLargeThanInitMaxReadBytes) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // The TLV has 65520 size data.\n  constexpr uint8_t tlv_begin[] = {0x02, 0xff, 0xf0};\n  std::string tlv_data(65520, 'a');\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv_begin, sizeof(tlv_begin));\n  write(tlv_data);\n\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  EXPECT_EQ(tlv_data, value_s);\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterestAndEmitWithSpecifiedMetadataNamespace) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n  rule->mutable_on_tlv_present()->set_metadata_namespace(\"We need a different metadata namespace\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(\"We need a different metadata namespace\"));\n\n  auto fields = metadata.at(\"We need a different metadata namespace\").fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0xea with size of 25 bytes (22 bytes are value)\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0x32, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, 0x32, 0x35, 0x74, 0x65, 0x73, 0x74,\n                          0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WillNotOverwriteTLV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x2a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority1[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                             0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0x02 (again) with size of 10 bytes (7 bytes are value) and different values\n  constexpr uint8_t tlv_type_authority2[] = {0x02, 0x00, 0x07, 0x62, 0x61,\n                                             0x72, 0x2e, 0x6e, 0x65, 0x74};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority1, sizeof(tlv_type_authority1));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_type_authority2, sizeof(tlv_type_authority2));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongTLVLength) {\n  // A well-formed ipv4/tcp with buffer[14]15] being 0x00 and 0x10. It says we should have 16 bytes\n  // following.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // tlv[2] should be 0x1 since there's only one byte for tlv value.\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x2, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv, sizeof(tlv));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2IncompleteTLV) {\n  // A ipv4/tcp with buffer[14]15] being 0x00 and 0x11. It says we should have 17 bytes following,\n  // however we have 20.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x11, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  // a TLV of type 0x01 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv2[] = {0x1, 0x0, 0x1, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  auto rule_01 = proto_config.add_rules();\n  rule_01->set_tlv_type(0x01);\n  rule_01->mutable_on_tlv_present()->set_key(\"01\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv1, sizeof(tlv1));\n  write(tlv2, sizeof(tlv2));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterState) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(2, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x0, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(0xFF, proxy_proto_data.tlv_vector_[0].value[0]);\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_[0].value.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[1].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[1].value.begin(),\n                                   proxy_proto_data.tlv_vector_[1].value.end()));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeEmpty) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(0, proxy_proto_data.tlv_vector_.size());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeTlV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n  pass_through_tlvs->add_tlv_type(0x02);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[0].value.begin(),\n                                   proxy_proto_data.tlv_vector_[0].value.end()));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, MalformedProxyLine) {\n  connect(false);\n\n  write(\"BOGUS\\r\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(\"\\n\");\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ProxyLineTooLarge) {\n  connect(false);\n  write(\"012345678901234567890123456789012345678901234567890123456789\"\n        \"012345678901234567890123456789012345678901234567890123456789\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NotEnoughFields) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, UnsupportedProto) {\n  connect(false);\n  write(\"PROXY UDP6 1:2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidSrcAddress) {\n  connect(false);\n  write(\"PROXY TCP4 230.0.0.1 10.1.1.3 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidDstAddress) {\n  connect(false);\n  write(\"PROXY TCP4 10.1.1.2 0.0.0.0 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadPort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234 abc\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NegativePort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 -1 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, PortOutOfRange) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 66776 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadAddress) {\n  connect(false);\n  write(\"PROXY TCP6 1::2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch) {\n  connect(false);\n  write(\"PROXY TCP4 [1:2:3::4] 1.2.3.4 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch2) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 [1:2:3: 1234 4]:5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, Truncated) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 5.6.7.8 1234 5678\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, Closed) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, ClosedEmpty) {\n  // We may or may not get these, depending on the operating system timing.\n  EXPECT_CALL(factory_, createListenerFilterChain(_)).Times(AtLeast(0));\n  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).Times(AtLeast(0));\n  conn_->connect();\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n}\n\n// There is no chance to have error for Windows since it emulate the drain\n// from a memory buffer.\n#ifndef WIN32\nTEST_P(ProxyProtocolTest, DrainError) {\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        if (flags != MSG_PEEK) {\n          return Api::SysCallSizeResult{-1, 0};\n        } else {\n          const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n          return x;\n        }\n      }));\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectProxyProtoError();\n}\n#endif\n\nclass WildcardProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                  public Network::ListenerConfig,\n                                  public Network::FilterChainManager,\n                                  protected Logger::Loggable<Logger::Id::main> {\npublic:\n  WildcardProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getAnyAddress(GetParam()))),\n        local_dst_address_(Network::Utility::getAddressWithPort(\n            *Network::Test::getCanonicalLoopbackAddress(GetParam()),\n            socket_->connectionInfoProvider().localAddress()->ip()->port())),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(\n        local_dst_address_, Network::Address::InstanceConstSharedPtr(),\n        Network::Test::createRawBufferSocket(), nullptr, nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr,\n              std::make_unique<Filter>(std::make_shared<Config>(\n                  listenerScope(),\n                  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol())));\n          return true;\n        }));\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect() {\n    conn_->connect();\n    read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n    EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n        .WillOnce(Invoke([&](Network::Connection& connection,\n                             const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n          server_connection_ = &connection;\n          connection.addConnectionCallbacks(server_callbacks_);\n          connection.addReadFilter(read_filter_);\n          return true;\n        }));\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::IsolatedStoreImpl stats_store_;\n  Api::ApiPtr api_;\n  Event::DispatcherPtr dispatcher_;\n  BasicResourceLimitImpl open_connections_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  Network::Address::InstanceConstSharedPtr local_dst_address_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, WildcardProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(WildcardProxyProtocolTest, Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 254.254.254.254 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"1.2.3.4:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"254.254.254.254:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(WildcardProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"[1:2:3::4]:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"[5:6::7:8]:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST(ProxyProtocolConfigFactoryTest, TestCreateFactory) {\n  Server::Configuration::NamedListenerFilterConfigFactory* factory = Registry::FactoryRegistry<\n      Server::Configuration::NamedListenerFilterConfigFactory>::getFactory(ProxyProtocol);\n\n  EXPECT_EQ(factory->name(), ProxyProtocol);\n\n  const std::string yaml = R\"EOF(\n      rules:\n        - tlv_type: 0x01\n          on_tlv_present:\n            key: \"PP2_TYPE_ALPN\"\n        - tlv_type: 0x1a\n          on_tlv_present:\n            key: \"PP2_TYPE_CUSTOMER_A\"\n)EOF\";\n\n  ProtobufTypes::MessagePtr proto_config = factory->createEmptyConfigProto();\n  TestUtility::loadFromYaml(yaml, *proto_config);\n\n  Server::Configuration::MockListenerFactoryContext context;\n  EXPECT_CALL(context, scope());\n  EXPECT_CALL(context, messageValidationVisitor());\n  Network::ListenerFilterFactoryCb cb =\n      factory->createListenerFilterFactoryFromProto(*proto_config, nullptr, context);\n\n  Network::MockListenerFilterManager manager;\n  Network::ListenerFilterPtr added_filter;\n  EXPECT_CALL(manager, addAcceptFilter_(_, _))\n      .WillOnce(Invoke([&added_filter](const Network::ListenerFilterMatcherSharedPtr&,\n                                       Network::ListenerFilterPtr& filter) {\n        added_filter = std::move(filter);\n      }));\n  cb(manager);\n\n  // Make sure we actually create the correct type!\n  EXPECT_NE(dynamic_cast<ProxyProtocol::Filter*>(added_filter.get()), nullptr);\n}\n\n} // namespace\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"ssl_integration_test.h\"\n\n#include <memory>\n#include <string>\n\n#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/config/core/v3/address.pb.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/network/connection_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/transport_sockets/tls/context_config_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_manager_impl.h\"\n#include \"source/extensions/transport_sockets/tls/ssl_handshaker.h\"\n#include \"source/extensions/transport_sockets/tls/ssl_socket.h\"\n\n#include \"test/common/config/dummy_config.pb.h\"\n#include \"test/extensions/transport_sockets/tls/cert_validator/timed_cert_validator.h\"\n#include \"test/integration/autonomous_upstream.h\"\n#include \"test/integration/integration.h\"\n#include \"test/integration/ssl_utility.h\"\n#include \"test/integration/utility.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/match.h\"\n#include \"absl/time/clock.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\n#ifdef ENVOY_ADMIN_FUNCTIONALITY\n#include \"envoy/config/tap/v3/common.pb.h\"\n#include \"envoy/data/tap/v3/wrapper.pb.h\"\n#include \"envoy/extensions/transport_sockets/tap/v3/tap.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"test/extensions/common/tap/common.h\"\n#endif\n\nusing testing::StartsWith;\n\nnamespace Envoy {\n\nusing Extensions::TransportSockets::Tls::ContextImplPeer;\n\nnamespace Ssl {\n\nvoid SslIntegrationTestBase::initialize() {\n  config_helper_.addSslConfig(ConfigHelper::ServerSslOptions()\n                                  .setRsaCert(server_rsa_cert_)\n                                  .setRsaCertOcspStaple(server_rsa_cert_ocsp_staple_)\n                                  .setEcdsaCert(server_ecdsa_cert_)\n                                  .setEcdsaCertOcspStaple(server_ecdsa_cert_ocsp_staple_)\n                                  .setOcspStapleRequired(ocsp_staple_required_)\n                                  .setTlsV13(server_tlsv1_3_)\n                                  .setCurves(server_curves_)\n                                  .setExpectClientEcdsaCert(client_ecdsa_cert_)\n                                  .setTlsKeyLogFilter(keylog_local_, keylog_remote_,\n                                                      keylog_local_negative_,\n                                                      keylog_remote_negative_, keylog_path_,\n                                                      keylog_multiple_ips_, version_));\n\n  HttpIntegrationTest::initialize();\n\n  context_manager_ =\n      std::make_unique<Extensions::TransportSockets::Tls::ContextManagerImpl>(timeSystem());\n\n  registerTestServerPorts({\"http\"});\n}\n\nvoid SslIntegrationTestBase::TearDown() {\n  HttpIntegrationTest::cleanupUpstreamAndDownstream();\n  codec_client_.reset();\n  context_manager_.reset();\n}\n\nNetwork::ClientConnectionPtr\nSslIntegrationTestBase::makeSslClientConnection(const ClientSslTransportOptions& options) {\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  if (debug_with_s_client_) {\n    const std::string s_client_cmd = TestEnvironment::substitute(\n        \"openssl s_client -connect \" + address->asString() +\n            \" -showcerts -debug -msg -CAfile \"\n            \"{{ test_rundir }}/test/config/integration/certs/cacert.pem \"\n            \"-servername lyft.com -cert \"\n            \"{{ test_rundir }}/test/config/integration/certs/clientcert.pem \"\n            \"-key \"\n            \"{{ test_rundir }}/test/config/integration/certs/clientkey.pem \",\n        version_);\n    ENVOY_LOG_MISC(debug, \"Executing {}\", s_client_cmd);\n    RELEASE_ASSERT(::system(s_client_cmd.c_str()) == 0, \"\");\n  }\n  auto client_transport_socket_factory_ptr =\n      createClientSslTransportSocketFactory(options, *context_manager_, *api_);\n  return dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n}\n\nvoid SslIntegrationTestBase::checkStats() {\n  const uint32_t expected_handshakes = debug_with_s_client_ ? 2 : 1;\n  Stats::CounterSharedPtr counter = test_server_->counter(listenerStatPrefix(\"ssl.handshake\"));\n  EXPECT_EQ(expected_handshakes, counter->value());\n  counter->reset();\n}\n\nclass SslKeyLogTest : public SslIntegrationTest {\npublic:\n  void setLogPath() {\n    keylog_path_ = TestEnvironment::temporaryPath(TestUtility::uniqueFilename());\n  }\n  void setLocalFilter() {\n    keylog_local_ = true;\n    keylog_remote_ = false;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setRemoteFilter() {\n    keylog_remote_ = true;\n    keylog_local_ = false;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setBothLocalAndRemoteFilter() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setNeitherLocalNorRemoteFilter() {\n    keylog_remote_ = false;\n    keylog_local_ = false;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setNegative() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = true;\n    keylog_remote_negative_ = true;\n  }\n  void setLocalNegative() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = true;\n  }\n  void setRemoteNegative() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = true;\n    keylog_remote_negative_ = false;\n  }\n  void setMultipleIps() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n    keylog_multiple_ips_ = true;\n  }\n  void logCheck() {\n    EXPECT_TRUE(api_->fileSystem().fileExists(keylog_path_));\n    std::string log = waitForAccessLog(keylog_path_);\n    if (server_tlsv1_3_) {\n      /** The key log for TLS1.3 is as follows:\n       * CLIENT_HANDSHAKE_TRAFFIC_SECRET\n         c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         b335f2ce9079d824a7d2f5ef9af6572d43942d6803bac1ae9de1e840c15c993ae4efdf4ac087877031d1936d5bb858e3\n         SERVER_HANDSHAKE_TRAFFIC_SECRET\n         c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         f498c03446c936d8a17f31669dd54cee2d9bc8d5b7e1a658f677b5cd6e0965111c2331fcc337c01895ec9a0ed12be34a\n         CLIENT_TRAFFIC_SECRET_0 c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         0bbbb2056f3d35a3b610c5cc8ae0b9b63a120912ff25054ee52b853fefc59e12e9fdfebc409347c737394457bfd36bde\n         SERVER_TRAFFIC_SECRET_0 c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         bd3e1757174d82c308515a0c02b981084edda53e546df551ddcf78043bff831c07ff93c7ab3e8ef9e2206c8319c25331\n         EXPORTER_SECRET c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         6bd19fbdd12e6710159bcb406fd42a580c41236e2d53072dba3064f9b3ff214662081f023e9b22325e31fee5bb11b172\n       */\n      EXPECT_THAT(log, testing::HasSubstr(\"CLIENT_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"SERVER_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"CLIENT_HANDSHAKE_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"SERVER_HANDSHAKE_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"EXPORTER_SECRET\"));\n    } else {\n      /** The key log for TLS1.1/1.2 is as follows:\n       * CLIENT_RANDOM 5a479a50fe3e85295840b84e298aeb184cecc34ced22d963e16b01dc48c9530f\n         d6840f8100e4ceeb282946cdd72fe403b8d0724ee816ab2d0824b6d6b5033d333ec4b2e77f515226f5d829e137855ef1\n       */\n      EXPECT_THAT(log, testing::HasSubstr(\"CLIENT_RANDOM\"));\n    }\n  }\n  void negativeCheck() {\n    EXPECT_TRUE(api_->fileSystem().fileExists(keylog_path_));\n    auto size = api_->fileSystem().fileSize(keylog_path_);\n    EXPECT_EQ(size, 0);\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Test that Envoy behaves correctly when receiving an SSLAlert for an unspecified code. The codes\n// are defined in the standard, and assigned codes have a string associated with them in BoringSSL,\n// which is included in logs. For an unknown code, verify that no crash occurs.\nTEST_P(SslIntegrationTest, UnknownSslAlert) {\n  initialize();\n  Network::ClientConnectionPtr connection = makeSslClientConnection({});\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  while (!callbacks.connected()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n\n  Ssl::ConnectionInfoConstSharedPtr ssl_info = connection->ssl();\n  SSL* ssl =\n      dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(ssl_info.get())\n          ->ssl();\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  ASSERT_NE(ssl, nullptr);\n  SSL_send_fatal_alert(ssl, 255);\n  while (!callbacks.closed()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  connection->close(Network::ConnectionCloseType::NoFlush);\n}\n\n// Test that stats produced by the tls transport socket have correct tag extraction.\nTEST_P(SslIntegrationTest, StatsTagExtraction) {\n  // Configure TLS to use specific parameters so the exact metrics the test expects are created.\n  // TLSv1.3 doesn't allow specifying the cipher suites, so use TLSv1.2 to force a specific cipher\n  // suite to simplify the test.\n  // Use P-256 to test the regex on a curve containing a hyphen (instead of X25519).\n\n  // Configure test-client to Envoy connection.\n  server_curves_.push_back(\"P-256\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(\n        ClientSslTransportOptions{}\n            .setTlsVersion(envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2)\n            .setCipherSuites({\"ECDHE-RSA-AES128-GCM-SHA256\"})\n            .setSigningAlgorithms({\"rsa_pss_rsae_sha256\"}));\n  };\n\n  // Configure Envoy to fake-upstream connection.\n  upstream_tls_ = true;\n  setUpstreamProtocol(Http::CodecType::HTTP2);\n  config_helper_.configureUpstreamTls(\n      false, false, absl::nullopt,\n      [](envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& ctx) {\n        auto& params = *ctx.mutable_tls_params();\n        params.set_tls_minimum_protocol_version(\n            envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n        params.set_tls_maximum_protocol_version(\n            envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n        params.add_ecdh_curves(\"P-256\");\n        params.add_signature_algorithms(\"rsa_pss_rsae_sha256\");\n        params.add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n      });\n\n  testRouterRequestAndResponseWithBody(1024, 1024, false, false, &creator);\n  checkStats();\n\n  using ExpectedResultsMap =\n      absl::node_hash_map<std::string, std::pair<std::string, Stats::TagVector>>;\n  ExpectedResultsMap base_expected_counters = {\n      {\"ssl.ciphers.ECDHE-RSA-AES128-GCM-SHA256\",\n       {\"ssl.ciphers\", {{\"envoy.ssl_cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\"}}}},\n      {\"ssl.versions.TLSv1.2\", {\"ssl.versions\", {{\"envoy.ssl_version\", \"TLSv1.2\"}}}},\n      {\"ssl.curves.P-256\", {\"ssl.curves\", {{\"envoy.ssl_curve\", \"P-256\"}}}},\n      {\"ssl.sigalgs.rsa_pss_rsae_sha256\",\n       {\"ssl.sigalgs\", {{\"envoy.ssl_sigalg\", \"rsa_pss_rsae_sha256\"}}}},\n  };\n\n  // Expect all the stats for both listeners and clusters.\n  ExpectedResultsMap expected_counters;\n  for (const auto& entry : base_expected_counters) {\n    expected_counters[listenerStatPrefix(entry.first)] = {\n        absl::StrCat(\"listener.\", entry.second.first), entry.second.second};\n    expected_counters[absl::StrCat(\"cluster.cluster_0.\", entry.first)] = {\n        absl::StrCat(\"cluster.\", entry.second.first), entry.second.second};\n  }\n\n  // The cipher suite extractor is written as two rules for listener and cluster, and they don't\n  // match unfortunately, but it's left this way for backwards compatibility.\n  expected_counters[\"cluster.cluster_0.ssl.ciphers.ECDHE-RSA-AES128-GCM-SHA256\"].second = {\n      {\"cipher_suite\", \"ECDHE-RSA-AES128-GCM-SHA256\"}};\n\n  for (const Stats::CounterSharedPtr& counter : test_server_->counters()) {\n    // Useful for debugging when the test is failing.\n    if (counter->name().find(\"ssl\") != std::string::npos) {\n      ENVOY_LOG_MISC(critical, \"Found ssl metric: {}\", counter->name());\n    }\n    auto it = expected_counters.find(counter->name());\n    if (it != expected_counters.end()) {\n      EXPECT_EQ(counter->tagExtractedName(), it->second.first);\n\n      // There are other extracted tags such as listener and cluster name, hence ``IsSupersetOf``.\n      EXPECT_THAT(counter->tags(), ::testing::IsSupersetOf(it->second.second));\n      expected_counters.erase(it);\n    }\n  }\n\n  EXPECT_THAT(expected_counters, ::testing::IsEmpty());\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithGiantBodyBuffer) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(16 * 1024 * 1024, 16 * 1024 * 1024, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, Http1StreamInfoDownstreamHandshakeTiming) {\n  ASSERT_TRUE(downstreamProtocol() == Http::CodecType::HTTP1);\n  config_helper_.prependFilter(fmt::format(R\"EOF(\n  name: stream-info-to-headers-filter\n)EOF\"));\n\n  initialize();\n  codec_client_ = makeHttpConnection(makeSslClientConnection({}));\n  auto response =\n      sendRequestAndWaitForResponse(default_request_headers_, 0, default_response_headers_, 0);\n\n  ASSERT_FALSE(\n      response->headers().get(Http::LowerCaseString(\"downstream_handshake_complete\")).empty());\n}\n\nTEST_P(SslIntegrationTest, Http2StreamInfoDownstreamHandshakeTiming) {\n  // See MultiplexedIntegrationTest for equivalent test for HTTP/3.\n  setDownstreamProtocol(Http::CodecType::HTTP2);\n  config_helper_.prependFilter(fmt::format(R\"EOF(\n  name: stream-info-to-headers-filter\n)EOF\"));\n\n  initialize();\n  codec_client_ = makeHttpConnection(makeSslClientConnection({}));\n  auto response =\n      sendRequestAndWaitForResponse(default_request_headers_, 0, default_response_headers_, 0);\n\n  ASSERT_FALSE(\n      response->headers().get(Http::LowerCaseString(\"downstream_handshake_complete\")).empty());\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBuffer) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBufferHttp2) {\n  setDownstreamProtocol(Http::CodecType::HTTP2);\n  config_helper_.setClientCodec(envoy::extensions::filters::network::http_connection_manager::v3::\n                                    HttpConnectionManager::AUTO);\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setAlpn(true));\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBufferVerifySAN) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSan(san_to_match_));\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBufferHttp2VerifySAN) {\n  setDownstreamProtocol(Http::CodecType::HTTP2);\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setAlpn(true).setSan(san_to_match_));\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterHeaderOnlyRequestAndResponse) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterHeaderOnlyRequestAndResponse(&creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterUpstreamDisconnectBeforeResponseComplete) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterUpstreamDisconnectBeforeResponseComplete(&creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterDownstreamDisconnectBeforeRequestComplete) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterDownstreamDisconnectBeforeRequestComplete(&creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterDownstreamDisconnectBeforeResponseComplete) {\n#if defined(__APPLE__) || defined(WIN32)\n  // Skip this test on OS X + Windows: we can't detect the early close on non-Linux, and we\n  // won't clean up the upstream connection until it times out. See #4294.\n  if (downstream_protocol_ == Http::CodecType::HTTP1) {\n    return;\n  }\n#endif\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterDownstreamDisconnectBeforeResponseComplete(&creator);\n  checkStats();\n}\n\n// This test must be here vs integration_admin_test so that it tests a server with loaded certs.\nTEST_P(SslIntegrationTest, AdminCertEndpoint) {\n  DISABLE_IF_ADMIN_DISABLED; // Admin functionality.\n  initialize();\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"admin\"), \"GET\", \"/certs\", \"\", downstreamProtocol(), version_);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\nTEST_P(SslIntegrationTest, RouterHeaderOnlyRequestAndResponseWithSni) {\n  config_helper_.addFilter(\"name: sni-to-header-filter\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSni(\"host.com\"));\n  };\n  initialize();\n  codec_client_ = makeHttpConnection(\n      makeSslClientConnection(ClientSslTransportOptions().setSni(\"www.host.com\")));\n  Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/\"}, {\":scheme\", \"https\"}, {\":authority\", \"host.com\"}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  waitForNextUpstreamRequest();\n\n  EXPECT_EQ(\"www.host.com\", upstream_request_->headers()\n                                .get(Http::LowerCaseString(\"x-envoy-client-sni\"))[0]\n                                ->value()\n                                .getStringView());\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, true);\n  RELEASE_ASSERT(response->waitForEndStream(), \"unexpected timeout\");\n\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationSucceeds) {\n  // Config client to use an async cert validator which defer the actual validation by 5ms.\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  initialize();\n\n  Network::ClientConnectionPtr connection = makeSslClientConnection(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()));\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  while (!callbacks.connected()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  connection->close(Network::ConnectionCloseType::NoFlush);\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationSucceedsWithLocalAddress) {\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  auto* cert_validator_factory =\n      Registry::FactoryRegistry<Extensions::TransportSockets::Tls::CertValidatorFactory>::\n          getFactory(\"envoy.tls.cert_validator.timed_cert_validator\");\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->resetForTest();\n  initialize();\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  auto client_transport_socket_factory_ptr = createClientSslTransportSocketFactory(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()),\n      *context_manager_, *api_);\n  Network::ClientConnectionPtr connection = dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n\n  // Get the `TimedCertValidator` object and set its expected local address.\n  Envoy::Ssl::ClientContextSharedPtr client_ssl_ctx =\n      static_cast<Extensions::TransportSockets::Tls::ClientSslSocketFactory&>(\n          *client_transport_socket_factory_ptr)\n          .sslCtx();\n  Extensions::TransportSockets::Tls::TimedCertValidator& cert_validator =\n      static_cast<Extensions::TransportSockets::Tls::TimedCertValidator&>(\n          ContextImplPeer::getMutableCertValidator(\n              static_cast<Extensions::TransportSockets::Tls::ClientContextImpl&>(*client_ssl_ctx)));\n  ASSERT_TRUE(connection->connectionInfoProvider().localAddress() != nullptr);\n  cert_validator.setExpectedLocalAddress(\n      connection->connectionInfoProvider().localAddress()->asString());\n\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  while (!callbacks.connected()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  connection->close(Network::ConnectionCloseType::NoFlush);\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationAfterTearDown) {\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  auto* cert_validator_factory =\n      Registry::FactoryRegistry<Extensions::TransportSockets::Tls::CertValidatorFactory>::\n          getFactory(\"envoy.tls.cert_validator.timed_cert_validator\");\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->resetForTest();\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->setValidationTimeOutMs(std::chrono::milliseconds(1000));\n  initialize();\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  auto client_transport_socket_factory_ptr = createClientSslTransportSocketFactory(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()),\n      *context_manager_, *api_);\n  Network::ClientConnectionPtr connection = dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  Envoy::Ssl::ClientContextSharedPtr client_ssl_ctx =\n      static_cast<Extensions::TransportSockets::Tls::ClientSslSocketFactory&>(\n          *client_transport_socket_factory_ptr)\n          .sslCtx();\n  auto& cert_validator = static_cast<const Extensions::TransportSockets::Tls::TimedCertValidator&>(\n      ContextImplPeer::getCertValidator(\n          static_cast<Extensions::TransportSockets::Tls::ClientContextImpl&>(*client_ssl_ctx)));\n  EXPECT_TRUE(cert_validator.validationPending());\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  connection->close(Network::ConnectionCloseType::NoFlush);\n  connection.reset();\n  while (cert_validator.validationPending()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationAfterSslShutdown) {\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  auto* cert_validator_factory =\n      Registry::FactoryRegistry<Extensions::TransportSockets::Tls::CertValidatorFactory>::\n          getFactory(\"envoy.tls.cert_validator.timed_cert_validator\");\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->resetForTest();\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->setValidationTimeOutMs(std::chrono::milliseconds(1000));\n  initialize();\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  auto client_transport_socket_factory_ptr = createClientSslTransportSocketFactory(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()),\n      *context_manager_, *api_);\n  Network::ClientConnectionPtr connection = dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  Envoy::Ssl::ClientContextSharedPtr client_ssl_ctx =\n      static_cast<Extensions::TransportSockets::Tls::ClientSslSocketFactory&>(\n          *client_transport_socket_factory_ptr)\n          .sslCtx();\n  auto& cert_validator = static_cast<const Extensions::TransportSockets::Tls::TimedCertValidator&>(\n      ContextImplPeer::getCertValidator(\n          static_cast<Extensions::TransportSockets::Tls::ClientContextImpl&>(*client_ssl_ctx)));\n  EXPECT_TRUE(cert_validator.validationPending());\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  connection->close(Network::ConnectionCloseType::NoFlush);\n  while (cert_validator.validationPending()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  connection.reset();\n}\n\nclass RawWriteSslIntegrationTest : public SslIntegrationTest {\nprotected:\n  std::unique_ptr<Http::TestRequestHeaderMapImpl>\n  testFragmentedRequestWithBufferLimit(std::list<std::string> request_chunks,\n                                       uint32_t buffer_limit) {\n    autonomous_upstream_ = true;\n    config_helper_.setBufferLimits(buffer_limit, buffer_limit);\n    initialize();\n\n    // write_request_cb will write each of the items in request_chunks as a separate SSL_write.\n    auto write_request_cb = [&request_chunks](Buffer::Instance& buffer) {\n      if (!request_chunks.empty()) {\n        buffer.add(request_chunks.front());\n        request_chunks.pop_front();\n      }\n      return false;\n    };\n\n    auto client_transport_socket_factory_ptr =\n        createClientSslTransportSocketFactory({}, *context_manager_, *api_);\n    std::string response;\n    auto connection = createConnectionDriver(\n        lookupPort(\"http\"), write_request_cb,\n        [&](Network::ClientConnection&, const Buffer::Instance& data) -> void {\n          response.append(data.toString());\n        },\n        client_transport_socket_factory_ptr->createTransportSocket({}, nullptr));\n\n    // Drive the connection until we get a response.\n    while (response.empty()) {\n      EXPECT_TRUE(connection->run(Event::Dispatcher::RunType::NonBlock));\n    }\n    EXPECT_THAT(response, testing::HasSubstr(\"HTTP/1.1 200 OK\\r\\n\"));\n\n    connection->close();\n    return reinterpret_cast<AutonomousUpstream*>(fake_upstreams_.front().get())\n        ->lastRequestHeaders();\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, RawWriteSslIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/12304\nTEST_P(RawWriteSslIntegrationTest, HighWatermarkReadResumptionProcessingHeaders) {\n  // The raw writer will perform a separate SSL_write for each of the chunks below. Chunk sizes were\n  // picked such that the connection's high watermark will trigger while processing the last SSL\n  // record containing the request headers. Verify that read resumption works correctly after\n  // hitting the receive buffer high watermark.\n  std::list<std::string> request_chunks = {\n      \"GET / HTTP/1.1\\r\\nHost: host\\r\\n\",\n      \"key1:\" + std::string(14000, 'a') + \"\\r\\n\",\n      \"key2:\" + std::string(16000, 'b') + \"\\r\\n\\r\\n\",\n  };\n\n  std::unique_ptr<Http::TestRequestHeaderMapImpl> upstream_headers =\n      testFragmentedRequestWithBufferLimit(request_chunks, 15 * 1024);\n  ASSERT_TRUE(upstream_headers != nullptr);\n  EXPECT_EQ(upstream_headers->Host()->value(), \"host\");\n  EXPECT_EQ(\n      std::string(14000, 'a'),\n      upstream_headers->get(Envoy::Http::LowerCaseString(\"key1\"))[0]->value().getStringView());\n  EXPECT_EQ(\n      std::string(16000, 'b'),\n      upstream_headers->get(Envoy::Http::LowerCaseString(\"key2\"))[0]->value().getStringView());\n}\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/12304\nTEST_P(RawWriteSslIntegrationTest, HighWatermarkReadResumptionProcesingBody) {\n  // The raw writer will perform a separate SSL_write for each of the chunks below. Chunk sizes were\n  // picked such that the connection's high watermark will trigger while processing the last SSL\n  // record containing the POST body. Verify that read resumption works correctly after hitting the\n  // receive buffer high watermark.\n  std::list<std::string> request_chunks = {\n      \"POST / HTTP/1.1\\r\\nHost: host\\r\\ncontent-length: 30000\\r\\n\\r\\n\",\n      std::string(14000, 'a'),\n      std::string(16000, 'a'),\n  };\n\n  std::unique_ptr<Http::TestRequestHeaderMapImpl> upstream_headers =\n      testFragmentedRequestWithBufferLimit(request_chunks, 15 * 1024);\n  ASSERT_TRUE(upstream_headers != nullptr);\n}\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/12304\nTEST_P(RawWriteSslIntegrationTest, HighWatermarkReadResumptionProcesingLargerBody) {\n  std::list<std::string> request_chunks = {\n      \"POST / HTTP/1.1\\r\\nHost: host\\r\\ncontent-length: 150000\\r\\n\\r\\n\",\n  };\n  for (int i = 0; i < 10; ++i) {\n    request_chunks.push_back(std::string(15000, 'a'));\n  }\n\n  std::unique_ptr<Http::TestRequestHeaderMapImpl> upstream_headers =\n      testFragmentedRequestWithBufferLimit(request_chunks, 16 * 1024);\n  ASSERT_TRUE(upstream_headers != nullptr);\n}\n\n// Validate certificate selection across different certificate types and client TLS versions.\nclass SslCertficateIntegrationTest\n    : public testing::TestWithParam<\n          std::tuple<Network::Address::IpVersion,\n                     envoy::extensions::transport_sockets::tls::v3::TlsParameters::TlsProtocol>>,\n      public SslIntegrationTestBase {\npublic:\n  SslCertficateIntegrationTest() : SslIntegrationTestBase(std::get<0>(GetParam())) {\n    server_tlsv1_3_ = true;\n  }\n\n  Network::ClientConnectionPtr\n  makeSslClientConnection(const ClientSslTransportOptions& options) override {\n    ClientSslTransportOptions modified_options{options};\n    modified_options.setTlsVersion(tls_version_);\n    return SslIntegrationTestBase::makeSslClientConnection(modified_options);\n  }\n\n  void TearDown() override { SslIntegrationTestBase::TearDown(); };\n\n  ClientSslTransportOptions rsaOnlyClientOptions() {\n    if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n      return ClientSslTransportOptions().setSigningAlgorithms({\"rsa_pss_rsae_sha256\"});\n    } else {\n      return ClientSslTransportOptions().setCipherSuites({\"ECDHE-RSA-AES128-GCM-SHA256\"});\n    }\n  }\n\n  ClientSslTransportOptions ecdsaOnlyClientOptions() {\n    auto options = ClientSslTransportOptions().setClientEcdsaCert(true);\n    if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n      return options.setSigningAlgorithms({\"ecdsa_secp256r1_sha256\"});\n    } else {\n      return options.setCipherSuites({\"ECDHE-ECDSA-AES128-GCM-SHA256\"});\n    }\n  }\n\n  static std::string ipClientVersionTestParamsToString(\n      const ::testing::TestParamInfo<\n          std::tuple<Network::Address::IpVersion,\n                     envoy::extensions::transport_sockets::tls::v3::TlsParameters::TlsProtocol>>&\n          params) {\n    return fmt::format(\"{}_TLSv1_{}\", TestUtility::ipVersionToString(std::get<0>(params.param)),\n                       std::get<1>(params.param) - 1);\n  }\n\n  const envoy::extensions::transport_sockets::tls::v3::TlsParameters::TlsProtocol tls_version_{\n      std::get<1>(GetParam())};\n};\n\nINSTANTIATE_TEST_SUITE_P(\n    IpVersionsClientVersions, SslCertficateIntegrationTest,\n    testing::Combine(\n        testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n        testing::Values(envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2,\n                        envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3)),\n    SslCertficateIntegrationTest::ipClientVersionTestParamsToString);\n\n// Server with an RSA certificate and a client with RSA/ECDSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerRsa) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server with an ECDSA certificate and a client with RSA/ECDSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsa) {\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server with RSA/`ECDSAs` certificates and a client with RSA/ECDSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsa) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server with an RSA certificate and a client with only RSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ClientRsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has only an ECDSA certificate, client is only RSA capable, leads to a connection fail.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientRsaOnly) {\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  initialize();\n  auto codec_client =\n      makeRawHttpConnection(makeSslClientConnection(rsaOnlyClientOptions()), absl::nullopt);\n  EXPECT_FALSE(codec_client->connected());\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  EXPECT_EQ(1U, counter->value());\n  counter->reset();\n}\n\n// Server has only an ECDSA certificate, client is only RSA capable, leads to a connection fail.\n// Test the access log.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientRsaOnlyWithAccessLog) {\n  TestScopedRuntime scoped_runtime;\n  scoped_runtime.mergeValues(\n      {{\"envoy.reloadable_features.ssl_transport_failure_reason_format\", \"true\"}});\n  useListenerAccessLog(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=%DOWNSTREAM_TRANSPORT_FAILURE_REASON% \"\n                       \"FILTER_CHAIN_NAME=%FILTER_CHAIN_NAME%\");\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  initialize();\n  auto codec_client =\n      makeRawHttpConnection(makeSslClientConnection(rsaOnlyClientOptions()), absl::nullopt);\n  EXPECT_FALSE(codec_client->connected());\n\n  auto log_result = waitForAccessLog(listener_access_log_name_);\n  if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n    EXPECT_THAT(log_result,\n                StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:|268435709:SSL_routines:\"\n                           \"OPENSSL_internal:NO_COMMON_SIGNATURE_ALGORITHMS:TLS_error_end\"));\n  } else {\n    EXPECT_THAT(log_result,\n                StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:|268435640:\"\n                           \"SSL_routines:OPENSSL_internal:NO_SHARED_CIPHER:TLS_error_end\"));\n  }\n}\n\n// Server has only an ECDSA certificate, client is only RSA capable, leads to a connection fail.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientRsaOnlyWithAccessLogOriginalFormat) {\n  TestScopedRuntime scoped_runtime;\n  scoped_runtime.mergeValues(\n      {{\"envoy.reloadable_features.ssl_transport_failure_reason_format\", \"false\"}});\n  useListenerAccessLog(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=%DOWNSTREAM_TRANSPORT_FAILURE_REASON% \"\n                       \"FILTER_CHAIN_NAME=%FILTER_CHAIN_NAME%\");\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  initialize();\n  auto codec_client =\n      makeRawHttpConnection(makeSslClientConnection(rsaOnlyClientOptions()), absl::nullopt);\n  EXPECT_FALSE(codec_client->connected());\n\n  auto log_result = waitForAccessLog(listener_access_log_name_);\n  if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n    EXPECT_THAT(log_result,\n                StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:_268435709:SSL_routines:\"\n                           \"OPENSSL_internal:NO_COMMON_SIGNATURE_ALGORITHMS\"));\n  } else {\n    EXPECT_THAT(log_result, StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:_268435640:\"\n                                       \"SSL_routines:OPENSSL_internal:NO_SHARED_CIPHER\"));\n  }\n}\n\n// Server with RSA/ECDSA certificates and a client with only RSA cipher suites works.\n// Test empty access log with successful connection.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsaClientRsaOnlyWithAccessLog) {\n  useListenerAccessLog(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=%DOWNSTREAM_TRANSPORT_FAILURE_REASON% \"\n                       \"FILTER_CHAIN_NAME=%FILTER_CHAIN_NAME%\");\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  auto log_result = waitForAccessLog(listener_access_log_name_);\n  EXPECT_THAT(log_result, StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=- FILTER_CHAIN_NAME=-\"));\n}\n\n// Server with RSA/ECDSA certificates and a client with only RSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsaClientRsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has only an RSA certificate, client is only ECDSA capable, leads to connection fail.\nTEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  client_ecdsa_cert_ = true;\n  initialize();\n  EXPECT_FALSE(\n      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()), absl::nullopt)\n          ->connected());\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  EXPECT_EQ(1U, counter->value());\n  counter->reset();\n}\n\n// Server has only an ECDSA certificate, client is only ECDSA capable works.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientEcdsaOnly) {\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has RSA/ECDSA certificates, client is only ECDSA capable works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsaClientEcdsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has an RSA certificate with an OCSP response works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaOnlyOcspResponse) {\n  server_rsa_cert_ = true;\n  server_rsa_cert_ocsp_staple_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has an ECDSA certificate with an OCSP response works.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaOnlyOcspResponse) {\n  server_ecdsa_cert_ = true;\n  server_ecdsa_cert_ocsp_staple_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has two certificates one with and one without OCSP response works under optional policy.\nTEST_P(SslCertficateIntegrationTest, BothEcdsaAndRsaOnlyRsaOcspResponse) {\n  server_rsa_cert_ = true;\n  server_rsa_cert_ocsp_staple_ = true;\n  server_ecdsa_cert_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has two certificates, but only ECDSA has OCSP, which should be returned.\nTEST_P(SslCertficateIntegrationTest, BothEcdsaAndRsaOnlyEcdsaOcspResponse) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  server_ecdsa_cert_ocsp_staple_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    // Enable OCSP\n    auto client = makeSslClientConnection(ecdsaOnlyClientOptions());\n    const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n        client->ssl().get());\n    SSL_enable_ocsp_stapling(socket->ssl());\n    return client;\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n  // Check that there is an OCSP response\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      codec_client_->connection()->ssl().get());\n  const uint8_t* resp;\n  size_t resp_len;\n  SSL_get0_ocsp_response(socket->ssl(), &resp, &resp_len);\n  EXPECT_NE(0, resp_len);\n}\n\n// Server has ECDSA and RSA certificates with OCSP responses and stapling required policy works.\nTEST_P(SslCertficateIntegrationTest, BothEcdsaAndRsaWithOcspResponseStaplingRequired) {\n  server_rsa_cert_ = true;\n  server_rsa_cert_ocsp_staple_ = true;\n  server_ecdsa_cert_ = true;\n  server_ecdsa_cert_ocsp_staple_ = true;\n  ocsp_staple_required_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n#ifdef ENVOY_ADMIN_FUNCTIONALITY\n// TODO(zuercher): write an additional OCSP integration test that validates behavior with an\n// expired OCSP response. (Requires OCSP client-side support in upstream TLS.)\n\n// TODO(mattklein123): Move this into a dedicated integration test for the tap transport socket as\n// well as add more tests.\nclass SslTapIntegrationTest : public SslIntegrationTest {\npublic:\n  void initialize() override {\n    // TODO(mattklein123): Merge/use the code in ConfigHelper::setTapTransportSocket().\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      // The test supports tapping either the downstream or upstream connection, but not both.\n      if (upstream_tap_) {\n        setupUpstreamTap(bootstrap);\n      } else {\n        setupDownstreamTap(bootstrap);\n      }\n    });\n    SslIntegrationTest::initialize();\n    // This confuses our socket counting.\n    debug_with_s_client_ = false;\n  }\n\n  void setupUpstreamTap(envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* transport_socket =\n        bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n    transport_socket->set_name(\"envoy.transport_sockets.tap\");\n    envoy::config::core::v3::TransportSocket raw_transport_socket;\n    raw_transport_socket.set_name(\"envoy.transport_sockets.raw_buffer\");\n    envoy::extensions::transport_sockets::tap::v3::Tap tap_config =\n        createTapConfig(raw_transport_socket);\n    tap_config.mutable_transport_socket()->MergeFrom(raw_transport_socket);\n    transport_socket->mutable_typed_config()->PackFrom(tap_config);\n  }\n\n  void setupDownstreamTap(envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* filter_chain =\n        bootstrap.mutable_static_resources()->mutable_listeners(0)->mutable_filter_chains(0);\n    // Configure inner SSL transport socket based on existing config.\n    envoy::config::core::v3::TransportSocket ssl_transport_socket;\n    auto* transport_socket = filter_chain->mutable_transport_socket();\n    ssl_transport_socket.Swap(transport_socket);\n    // Configure outer tap transport socket.\n    transport_socket->set_name(\"envoy.transport_sockets.tap\");\n    envoy::extensions::transport_sockets::tap::v3::Tap tap_config =\n        createTapConfig(ssl_transport_socket);\n    tap_config.mutable_transport_socket()->MergeFrom(ssl_transport_socket);\n    transport_socket->mutable_typed_config()->PackFrom(tap_config);\n  }\n\n  envoy::extensions::transport_sockets::tap::v3::Tap\n  createTapConfig(const envoy::config::core::v3::TransportSocket& inner_transport) {\n    envoy::extensions::transport_sockets::tap::v3::Tap tap_config;\n    tap_config.mutable_common_config()->mutable_static_config()->mutable_match()->set_any_match(\n        true);\n    auto* output_config =\n        tap_config.mutable_common_config()->mutable_static_config()->mutable_output_config();\n    if (max_rx_bytes_.has_value()) {\n      output_config->mutable_max_buffered_rx_bytes()->set_value(max_rx_bytes_.value());\n    }\n    if (max_tx_bytes_.has_value()) {\n      output_config->mutable_max_buffered_tx_bytes()->set_value(max_tx_bytes_.value());\n    }\n    output_config->set_streaming(streaming_tap_);\n\n    auto* output_sink = output_config->mutable_sinks()->Add();\n    output_sink->set_format(format_);\n    output_sink->mutable_file_per_tap()->set_path_prefix(path_prefix_);\n    tap_config.mutable_transport_socket()->MergeFrom(inner_transport);\n    return tap_config;\n  }\n\n  std::string path_prefix_ = TestEnvironment::temporaryPath(\"ssl_trace\");\n  envoy::config::tap::v3::OutputSink::Format format_{\n      envoy::config::tap::v3::OutputSink::PROTO_BINARY};\n  absl::optional<uint64_t> max_rx_bytes_;\n  absl::optional<uint64_t> max_tx_bytes_;\n  bool upstream_tap_{};\n  bool streaming_tap_{};\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslTapIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Validate two back-to-back requests with binary proto output.\nTEST_P(SslTapIntegrationTest, TwoRequestsWithBinaryProto) {\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // First request (ID will be +1 since the client will also bump).\n  const uint64_t first_id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  codec_client_ = makeHttpConnection(creator());\n  Http::TestRequestHeaderMapImpl post_request_headers{\n      {\":method\", \"POST\"},       {\":path\", \"/test/long/url\"},\n      {\":scheme\", \"http\"},       {\":authority\", \"sni.lyft.com\"},\n      {\"x-lyft-user-id\", \"123\"}, {\"x-forwarded-for\", \"10.0.0.1\"}};\n  auto response =\n      sendRequestAndWaitForResponse(post_request_headers, 128, default_response_headers_, 256);\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(128, upstream_request_->bodyLength());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(256, response->body().size());\n  checkStats();\n  envoy::config::core::v3::Address expected_local_address;\n  Network::Utility::addressToProtobufAddress(\n      *codec_client_->connection()->connectionInfoProvider().remoteAddress(),\n      expected_local_address);\n  envoy::config::core::v3::Address expected_remote_address;\n  Network::Utility::addressToProtobufAddress(\n      *codec_client_->connection()->connectionInfoProvider().localAddress(),\n      expected_remote_address);\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb\", path_prefix_, first_id), trace, *api_);\n  // Validate general expected properties in the trace.\n  EXPECT_EQ(first_id, trace.socket_buffered_trace().trace_id());\n  EXPECT_THAT(expected_local_address,\n              ProtoEq(trace.socket_buffered_trace().connection().local_address()));\n  EXPECT_THAT(expected_remote_address,\n              ProtoEq(trace.socket_buffered_trace().connection().remote_address()));\n  ASSERT_GE(trace.socket_buffered_trace().events().size(), 2);\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(0).read().data().as_bytes(),\n                               \"POST /test/long/url HTTP/1.1\"));\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(1).write().data().as_bytes(),\n                               \"HTTP/1.1 200 OK\"));\n  EXPECT_FALSE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_FALSE(trace.socket_buffered_trace().write_truncated());\n\n  // Verify a second request hits a different file.\n  const uint64_t second_id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  codec_client_ = makeHttpConnection(creator());\n  Http::TestRequestHeaderMapImpl get_request_headers{\n      {\":method\", \"GET\"},        {\":path\", \"/test/long/url\"},\n      {\":scheme\", \"http\"},       {\":authority\", \"sni.lyft.com\"},\n      {\"x-lyft-user-id\", \"123\"}, {\"x-forwarded-for\", \"10.0.0.1\"}};\n  response =\n      sendRequestAndWaitForResponse(get_request_headers, 128, default_response_headers_, 256);\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(128, upstream_request_->bodyLength());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(256, response->body().size());\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 2);\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb\", path_prefix_, second_id), trace, *api_);\n  // Validate second connection ID.\n  EXPECT_EQ(second_id, trace.socket_buffered_trace().trace_id());\n  ASSERT_GE(trace.socket_buffered_trace().events().size(), 2);\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(0).read().data().as_bytes(),\n                               \"GET /test/long/url HTTP/1.1\"));\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(1).write().data().as_bytes(),\n                               \"HTTP/1.1 200 OK\"));\n  EXPECT_FALSE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_FALSE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Verify that truncation works correctly across multiple transport socket frames.\nTEST_P(SslTapIntegrationTest, TruncationWithMultipleDataFrames) {\n  max_rx_bytes_ = 4;\n  max_tx_bytes_ = 5;\n\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n                                                       {\":path\", \"/test/long/url\"},\n                                                       {\":scheme\", \"http\"},\n                                                       {\":authority\", \"sni.lyft.com\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  auto response = std::move(result.second);\n  Buffer::OwnedImpl data1(\"one\");\n  result.first.encodeData(data1, false);\n  Buffer::OwnedImpl data2(\"two\");\n  result.first.encodeData(data2, true);\n  waitForNextUpstreamRequest();\n  const Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, false);\n  Buffer::OwnedImpl data3(\"three\");\n  upstream_request_->encodeData(data3, false);\n  response->waitForBodyData(5);\n  Buffer::OwnedImpl data4(\"four\");\n  upstream_request_->encodeData(data4, true);\n  ASSERT_TRUE(response->waitForEndStream());\n\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb\", path_prefix_, id), trace, *api_);\n\n  ASSERT_EQ(trace.socket_buffered_trace().events().size(), 2);\n  EXPECT_TRUE(trace.socket_buffered_trace().events(0).read().data().truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().events(1).write().data().truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Validate a single request with text proto output.\nTEST_P(SslTapIntegrationTest, RequestWithTextProto) {\n  format_ = envoy::config::tap::v3::OutputSink::PROTO_TEXT;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // Disable for this test because it uses connection IDs, which disrupts the accounting below\n  // leading to the wrong path for the `pb_text` being used.\n  skip_tag_extraction_rule_check_ = true;\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb_text\", path_prefix_, id), trace, *api_);\n  // Test some obvious properties.\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(0).read().data().as_bytes(),\n                               \"GET /test/long/url HTTP/1.1\"));\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(1).write().data().as_bytes(),\n                               \"HTTP/1.1 200 OK\"));\n  EXPECT_TRUE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_FALSE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Validate a single request with JSON (body as string) output. This test uses an upstream tap.\nTEST_P(SslTapIntegrationTest, RequestWithJsonBodyAsStringUpstreamTap) {\n  upstream_tap_ = true;\n  max_rx_bytes_ = 5;\n  max_tx_bytes_ = 4;\n\n  format_ = envoy::config::tap::v3::OutputSink::JSON_BODY_AS_STRING;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // Disable for this test because it uses connection IDs, which disrupts the accounting below\n  // leading to the wrong path for the `pb_text` being used.\n  skip_tag_extraction_rule_check_ = true;\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 2;\n  testRouterRequestAndResponseWithBody(512, 1024, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  test_server_.reset();\n\n  // This must be done after server shutdown so that connection pool connections are closed and\n  // the tap written.\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.json\", path_prefix_, id), trace, *api_);\n\n  // Test some obvious properties.\n  EXPECT_EQ(trace.socket_buffered_trace().events(0).write().data().as_string(), \"GET \");\n  EXPECT_EQ(trace.socket_buffered_trace().events(1).read().data().as_string(), \"HTTP/\");\n  EXPECT_TRUE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Validate a single request with length delimited binary proto output. This test uses an upstream\n// tap.\nTEST_P(SslTapIntegrationTest, RequestWithStreamingUpstreamTap) {\n  upstream_tap_ = true;\n  streaming_tap_ = true;\n  max_rx_bytes_ = 5;\n  max_tx_bytes_ = 4;\n\n  format_ = envoy::config::tap::v3::OutputSink::PROTO_BINARY_LENGTH_DELIMITED;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // Disable for this test because it uses connection IDs, which disrupts the accounting below\n  // leading to the wrong path for the `pb_text` being used.\n  skip_tag_extraction_rule_check_ = true;\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 2;\n  testRouterRequestAndResponseWithBody(512, 1024, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  test_server_.reset();\n\n  // This must be done after server shutdown so that connection pool connections are closed and\n  // the tap written.\n  std::vector<envoy::data::tap::v3::TraceWrapper> traces =\n      Extensions::Common::Tap::readTracesFromFile(\n          fmt::format(\"{}_{}.pb_length_delimited\", path_prefix_, id));\n  ASSERT_GE(traces.size(), 4);\n\n  // The initial connection message has no local address, but has a remote address (not connected\n  // yet).\n  EXPECT_TRUE(traces[0].socket_streamed_trace_segment().has_connection());\n  EXPECT_FALSE(traces[0].socket_streamed_trace_segment().connection().has_local_address());\n  EXPECT_TRUE(traces[0].socket_streamed_trace_segment().connection().has_remote_address());\n\n  // Verify truncated request/response data.\n  EXPECT_EQ(traces[1].socket_streamed_trace_segment().event().write().data().as_bytes(), \"GET \");\n  EXPECT_TRUE(traces[1].socket_streamed_trace_segment().event().write().data().truncated());\n  EXPECT_EQ(traces[2].socket_streamed_trace_segment().event().read().data().as_bytes(), \"HTTP/\");\n  EXPECT_TRUE(traces[2].socket_streamed_trace_segment().event().read().data().truncated());\n}\n#endif\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslKeyLogTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(SslKeyLogTest, SetLocalFilter) {\n  setLogPath();\n  setLocalFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetRemoteFilter) {\n  setLogPath();\n  setRemoteFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetLocalAndRemoteFilter) {\n  setLogPath();\n  setBothLocalAndRemoteFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetNeitherLocalNorRemoteFilter) {\n  setLogPath();\n  setNeitherLocalNorRemoteFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetLocalAndRemoteFilterNegative) {\n  setLogPath();\n  setNegative();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  negativeCheck();\n}\n\nTEST_P(SslKeyLogTest, SetLocalNegative) {\n  setLogPath();\n  setLocalNegative();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  negativeCheck();\n}\n\nTEST_P(SslKeyLogTest, SetRemoteNegative) {\n  setLogPath();\n  setRemoteNegative();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  negativeCheck();\n}\n\nTEST_P(SslKeyLogTest, SetMultipleIps) {\n  setLogPath();\n  setMultipleIps();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\n} // namespace Ssl\n} // namespace Envoy\n"], "fixing_code": ["date: Pending\n\nbehavior_changes:\n# *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nminor_behavior_changes:\n# *Changes that may cause incompatibilities for some users, but should not for most*\n- area: adaptive concurrency filter stats\n  change: |\n    Multiply the gradient value stat by 1000 to make it more granular (values will range between 500 and 2000).\n- area: dns\n  change: |\n    Allowing <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_min_refresh_rate>` to go as low as 1s.\n- area: upstream\n  change: |\n    Upstream now excludes hosts set to ``DRAINING`` state via EDS from load balancing and panic routing\n    threshold calculation. This feature can be disabled by setting\n    ``envoy.reloadable_features.exclude_host_in_eds_status_draining`` to false.\n- area: golang\n  change: |\n    Change ``RegisterHttpFilterConfigFactoryAndParser`` to ``RegisterHttpFilterFactoryAndConfigParser``.\n- area: QUIC\n  change: |\n    Port migration is default turned off. QUIC client connections will no longer attempt to migrate to a new port when connections\n    is degrading. Can be manually turned on via\n    :ref:`port_migration <envoy_v3_api_field_config.core.v3.QuicProtocolOptions.num_timeouts_to_trigger_port_migration>`.\n- area: aws\n  change: |\n    AWS region string is now retrieved from environment and profile consistently within aws_request_signer and\n    grpc_credentials/aws_iam extensions. Region field in aws_request_signer is now optional, explicitly configured\n    xDS region will take preference. aws_request_signer documentation now reflects the region chain.\n\nbug_fixes:\n# *Changes expected to improve the state of the world and are unlikely to have negative effects*\n- area: tracers\n  change: |\n    use unary RPC calls for OpenTelemetry trace exports, rather than client-side streaming connections.\n- area: load balancing\n  change: |\n    Added randomization in locality load-balancing initialization. This helps desynchronizing Envoys across\n    a fleet by randomizing the scheduler starting point. This can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.edf_lb_locality_scheduler_init_fix`` to false.\n- area: UDP and TCP tunneling\n  change: |\n    fixed a bug where second HTTP response headers received would cause Envoy to crash in cases where\n    ``propagate_response_headers`` and retry configurations are enabled at the same time, and an upstream\n    request is retried multiple times.\n- area: tracing\n  change: |\n    Prevent Envoy from crashing at start up when the OpenTelemetry environment resource detector cannot detect any attributes.\n- area: proxy protocol\n  change: |\n    Fixed a crash when Envoy is configured for PROXY protocol on both a listener and cluster, and the listener receives\n    a PROXY protocol header with address type LOCAL (typically used for health checks).\n- area: url matching\n  change: |\n    Fixed excessive CPU utilization when using regex URL template matcher.\n- area: http\n  change: |\n    Fixed crash when HTTP request idle and per try timeouts occurs within backoff interval.\n- area: proxy_protocol\n  change: |\n    Fix crash due to uncaught exception when the operating system does not support an address type (such as IPv6) that is\n    received in a proxy protocol header. Connections will instead be dropped/reset.\n- area: tls\n  change: |\n    Fix crash due to uncaught exception when the operating system does not support an address type (such as IPv6) that is\n    received in an mTLS client cert IP SAN. These SANs will be ignored. This applies only when using formatter\n    ``%DOWNSTREAM_PEER_IP_SAN%``.\n\nremoved_config_or_runtime:\n# *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n- area: http\n  change: |\n    Removed ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` runtime flag and legacy code paths.\n- area: active health check\n  change: |\n    Removed ``envoy.reloadable_features.keep_endpoint_active_hc_status_on_locality_update`` runtime flag and legacy code paths.\n- area: http1\n  change: |\n    Removed ``envoy.reloadable_features.http1_allow_codec_error_response_after_1xx_headers`` runtime flag and legacy code paths.\n- area: overload manager\n  change: |\n    removed ``envoy.reloadable_features.overload_manager_error_unknown_action`` and legacy code paths.\n- area: http\n  change: |\n    Removed ``envoy_reloadable_features_append_xfh_idempotent`` runtime flag and legacy code paths.\n- area: resource_monitors\n  change: |\n    removed ``envoy.reloadable_features.count_unused_mapped_pages_as_free`` runtime flag  and legacy code paths.\n\nnew_features:\n- area: aws_request_signing\n  change: |\n    Update ``aws_request_signing`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: aws_lambda\n  change: |\n    Update ``aws_lambda`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: grpc reverse bridge\n  change: |\n    Change HTTP status to 200 to respect the gRPC protocol. This may cause problems for incorrect gRPC clients expecting the filter\n    to preserve HTTP 1.1 responses.  This behavioral change can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.grpc_http1_reverse_bridge_change_http_status`` to false.\n- area: quic\n  change: |\n    Added QUIC protocol option :ref:`send_disable_active_migration\n    <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.send_disable_active_migration>` to make the server send clients a transport\n    parameter to discourage client endpoints from active migration.\n- area: ext_proc\n  change: |\n    implemented\n    :ref:`request_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.request_attributes>`\n    and\n    :ref:`response_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.response_attributes>`\n    config APIs to enable sending and receiving attributes to/from the external processing server.\n- area: access log\n  change: |\n    added support for :ref:`%UPSTREAM_CONNECTION_ID% <config_access_log_format_upstream_connection_id>` for the upstream connection\n    identifier.\n- area: aws_lambda\n  change: |\n    Added :ref:`host_rewrite <envoy_v3_api_field_extensions.filters.http.aws_lambda.v3.Config.host_rewrite>` config to be used\n    during signature.\n- area: ext_proc\n  change: |\n    added\n    :ref:`metadata_options <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.metadata_options>`\n    config API to enable sending and receiving metadata from/to the external processing server. Both typed and untyped dynamic\n    metadata may be sent to the server. If\n    :ref:`receiving_namespaces <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.MetadataOptions.receiving_namespaces>`\n    is defined, returned metadata may be written to the specified allowed namespaces.\n- area: monitoring\n  change: |\n    Add ``Envoy::ExecutionContext``, which is notified by ``ScopeTrackerScopeState``'s constructor and destructor. This feature is\n    disabled by default, it can be enabled by runtime feature flag ``envoy.restart_features.enable_execution_context``. For more details,\n    please see https://github.com/envoyproxy/envoy/issues/32012.\n- area: rbac\n  change: |\n    Added :ref:`uri_template<envoy_v3_api_field_config.rbac.v3.Permission.uri_template>` which uses existing\n    :ref:`UriTemplateMatchConfig<envoy_v3_api_msg_extensions.path.match.uri_template.v3.UriTemplateMatchConfig>`\n    to allow use of glob patterns for URI path matching in RBAC.\n- area: upstream\n  change: |\n    Added :ref:`selection_method <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    option to the least request load balancer. If set to ``FULL_SCAN``,\n    Envoy will select the host with the fewest active requests from the entire host set rather than\n    :ref:`choice_count <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    random choices.\n\ndeprecated:\n", "load(\n    \"@envoy_build_config//:extensions_build_config.bzl\",\n    \"LEGACY_ALWAYSLINK\",\n)\nload(\n    \"//bazel:envoy_build_system.bzl\",\n    \"envoy_cc_library\",\n    \"envoy_package\",\n)\n\nlicenses([\"notice\"])  # Apache 2\n\nenvoy_package()\n\nenvoy_cc_library(\n    name = \"address_lib\",\n    srcs = [\"address_impl.cc\"],\n    hdrs = [\"address_impl.h\"],\n    deps = [\n        \":socket_interface_lib\",\n        \"//envoy/network:address_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:cleanup_lib\",\n        \"//source/common/common:safe_memcpy_lib\",\n        \"//source/common/common:statusor_lib\",\n        \"//source/common/common:thread_lib\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"application_protocol_lib\",\n    srcs = [\"application_protocol.cc\"],\n    hdrs = [\"application_protocol.h\"],\n    deps = [\n        \"//envoy/registry\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"cidr_range_interface\",\n    hdrs = [\"cidr_range.h\"],\n    deps = [\n        \"//envoy/network:address_interface\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"cidr_range_lib\",\n    srcs = [\"cidr_range.cc\"],\n    hdrs = [\"cidr_range.h\"],\n    deps = [\n        \":address_lib\",\n        \":utility_lib\",\n        \"//envoy/network:address_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:safe_memcpy_lib\",\n        \"//source/common/common:utility_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_balancer_lib\",\n    srcs = [\"connection_balancer_impl.cc\"],\n    hdrs = [\"connection_balancer_impl.h\"],\n    deps = [\n        \"//envoy/network:connection_balancer_interface\",\n        \"//envoy/registry\",\n        \"//envoy/server:filter_config_interface\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_base_lib\",\n    srcs = [\"connection_impl_base.cc\"],\n    hdrs = [\"connection_impl_base.h\"],\n    deps = [\n        \":common_connection_filter_states_lib\",\n        \":connection_socket_lib\",\n        \":filter_manager_lib\",\n        \"//envoy/common:scope_tracker_interface\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:dump_state_utils\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_lib\",\n    deps = [\n        \":connection_impl\",\n        \":default_client_connection_factory\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_impl\",\n    srcs = [\"connection_impl.cc\"],\n    hdrs = [\"connection_impl.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":address_lib\",\n        \":connection_base_lib\",\n        \":raw_buffer_socket_lib\",\n        \":utility_lib\",\n        \"//envoy/event:timer_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//envoy/network:socket_interface\",\n        \"//envoy/server/overload:thread_local_overload_state\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/buffer:watermark_buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:empty_string\",\n        \"//source/common/common:enum_to_int\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/common/event:libevent_lib\",\n        \"//source/common/network:socket_option_factory_lib\",\n        \"//source/common/runtime:runtime_features_lib\",\n        \"//source/common/stream_info:stream_info_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"happy_eyeballs_connection_impl_lib\",\n    srcs = [\"happy_eyeballs_connection_impl.cc\"],\n    hdrs = [\"happy_eyeballs_connection_impl.h\"],\n    deps = [\n        \":connection_base_lib\",\n        \":connection_lib\",\n        \":multi_connection_base_impl_lib\",\n        \"//envoy/upstream:upstream_interface\",\n        \"@envoy_api//envoy/config/cluster/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"multi_connection_base_impl_lib\",\n    srcs = [\"multi_connection_base_impl.cc\"],\n    hdrs = [\"multi_connection_base_impl.h\"],\n    deps = [\n        \":connection_base_lib\",\n        \":connection_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"default_client_connection_factory\",\n    srcs = [\n        \"default_client_connection_factory.cc\",\n    ],\n    hdrs = [\n        \"default_client_connection_factory.h\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":connection_base_lib\",\n        \":connection_impl\",\n        \"//envoy/network:client_connection_factory\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:transport_socket_interface\",\n        \"//envoy/registry\",\n    ],\n    alwayslink = LEGACY_ALWAYSLINK,\n)\n\nenvoy_cc_library(\n    name = \"filter_lib\",\n    hdrs = [\"filter_impl.h\"],\n    deps = [\n        \"//envoy/network:filter_interface\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_manager_lib\",\n    srcs = [\"filter_manager_impl.cc\"],\n    hdrs = [\"filter_manager_impl.h\"],\n    deps = [\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:filter_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/runtime:runtime_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"hash_policy_lib\",\n    srcs = [\"hash_policy.cc\"],\n    hdrs = [\"hash_policy.h\"],\n    deps = [\n        \"//envoy/common:hashable_interface\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:hash_policy_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:hash_lib\",\n        \"@envoy_api//envoy/type/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"io_socket_error_lib\",\n    srcs = [\"io_socket_error_impl.cc\"],\n    hdrs = [\"io_socket_error_impl.h\"],\n    deps = [\n        \"//envoy/api:io_error_interface\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"lc_trie_lib\",\n    hdrs = [\"lc_trie.h\"],\n    external_deps = [\n        \"abseil_node_hash_set\",\n        \"abseil_int128\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":cidr_range_lib\",\n        \":utility_lib\",\n        \"//source/common/common:assert_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"socket_interface_lib\",\n    hdrs = [\"socket_interface.h\"],\n    deps = [\n        \"//envoy/config:typed_config_interface\",\n        \"//envoy/network:socket_interface_interface\",\n        \"//envoy/registry\",\n        \"//envoy/server:bootstrap_extension_config_interface\",\n    ],\n    alwayslink = LEGACY_ALWAYSLINK,\n)\n\nenvoy_cc_library(\n    name = \"default_socket_interface_lib\",\n    srcs = [\n        \"io_socket_handle_base_impl.cc\",\n        \"io_socket_handle_impl.cc\",\n        \"socket_interface_impl.cc\",\n        \"win32_socket_handle_impl.cc\",\n    ],\n    hdrs = [\n        \"io_socket_handle_base_impl.h\",\n        \"io_socket_handle_impl.h\",\n        \"socket_interface_impl.h\",\n        \"win32_socket_handle_impl.h\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":io_socket_error_lib\",\n        \":socket_interface_lib\",\n        \":socket_lib\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/network:io_handle_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/event:dispatcher_includes\",\n        \"@envoy_api//envoy/extensions/network/socket_interface/v3:pkg_cc_proto\",\n    ],\n    alwayslink = LEGACY_ALWAYSLINK,\n)\n\nenvoy_cc_library(\n    name = \"socket_lib\",\n    srcs = [\"socket_impl.cc\"],\n    hdrs = [\"socket_impl.h\"],\n    deps = [\n        \"//envoy/network:listener_interface\",\n        \"//envoy/network:socket_interface\",\n        \"//envoy/network:socket_interface_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:dump_state_utils\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"connection_socket_lib\",\n    hdrs = [\"connection_socket_impl.h\"],\n    deps = [\n        \":socket_lib\",\n        \":utility_lib\",\n        \"//envoy/network:exception_interface\",\n        \"//source/common/common:assert_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"listen_socket_lib\",\n    srcs = [\"listen_socket_impl.cc\"],\n    hdrs = [\"listen_socket_impl.h\"],\n    deps = [\n        \":connection_socket_lib\",\n        \":socket_lib\",\n        \":utility_lib\",\n        \"//envoy/network:exception_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/common:assert_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"listener_filter_buffer_lib\",\n    srcs = [\"listener_filter_buffer_impl.cc\"],\n    hdrs = [\"listener_filter_buffer_impl.h\"],\n    deps = [\n        \"//envoy/network:io_handle_interface\",\n        \"//envoy/network:listener_filter_buffer_interface\",\n        \"//source/common/buffer:buffer_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"listener_lib\",\n    srcs = [\n        \"base_listener_impl.cc\",\n        \"tcp_listener_impl.cc\",\n        \"udp_listener_impl.cc\",\n    ],\n    hdrs = [\n        \"base_listener_impl.h\",\n        \"tcp_listener_impl.h\",\n        \"udp_listener_impl.h\",\n    ],\n    deps = [\n        \":address_lib\",\n        \":default_socket_interface_lib\",\n        \":listen_socket_lib\",\n        \"//envoy/event:dispatcher_interface\",\n        \"//envoy/event:file_event_interface\",\n        \"//envoy/network:exception_interface\",\n        \"//envoy/network:listener_interface\",\n        \"//envoy/runtime:runtime_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//envoy/stats:stats_macros\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:empty_string\",\n        \"//source/common/common:linked_object\",\n        \"//source/common/event:dispatcher_includes\",\n        \"//source/common/runtime:runtime_keys_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"raw_buffer_socket_lib\",\n    srcs = [\"raw_buffer_socket.cc\"],\n    hdrs = [\"raw_buffer_socket.h\"],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:transport_socket_interface\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:empty_string\",\n        \"//source/common/http:headers_lib\",\n        \"//source/common/network:transport_socket_options_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"resolver_lib\",\n    srcs = [\"resolver_impl.cc\"],\n    hdrs = [\"resolver_impl.h\"],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/network:address_interface\",\n        \"//envoy/network:resolver_interface\",\n        \"//envoy/registry\",\n        \"//source/common/config:well_known_names\",\n        \"//source/common/network:address_lib\",\n        \"//source/common/protobuf\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"socket_option_lib\",\n    srcs = [\"socket_option_impl.cc\"],\n    hdrs = [\"socket_option_impl.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":address_lib\",\n        \"//envoy/api:os_sys_calls_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:minimal_logger_lib\",\n        \"//source/common/common:scalar_to_byte_vector_lib\",\n        \"//source/common/common:utility_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"addr_family_aware_socket_option_lib\",\n    srcs = [\"addr_family_aware_socket_option_impl.cc\"],\n    hdrs = [\"addr_family_aware_socket_option_impl.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":address_lib\",\n        \":socket_lib\",\n        \":socket_option_lib\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:logger_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"win32_redirect_records_option_lib\",\n    srcs = [\"win32_redirect_records_option_impl.cc\"],\n    hdrs = [\"win32_redirect_records_option_impl.h\"],\n    deps = [\n        \":address_lib\",\n        \":socket_lib\",\n        \":socket_option_lib\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:logger_lib\",\n        \"//source/common/common:scalar_to_byte_vector_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"socket_option_factory_lib\",\n    srcs = [\"socket_option_factory.cc\"],\n    hdrs = [\"socket_option_factory.h\"],\n    external_deps = [\"abseil_optional\"],\n    deps = [\n        \":addr_family_aware_socket_option_lib\",\n        \":address_lib\",\n        \":socket_option_lib\",\n        \":win32_redirect_records_option_lib\",\n        \"//envoy/network:listen_socket_interface\",\n        \"//source/common/common:logger_lib\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"utility_lib\",\n    srcs = [\"utility.cc\"],\n    hdrs = [\"utility.h\"],\n    deps = [\n        \":address_lib\",\n        \":default_socket_interface_lib\",\n        \":socket_lib\",\n        \":socket_option_lib\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/network:listener_interface\",\n        \"//envoy/stats:stats_interface\",\n        \"//source/common/api:os_sys_calls_lib\",\n        \"//source/common/buffer:buffer_lib\",\n        \"//source/common/common:assert_lib\",\n        \"//source/common/common:cleanup_lib\",\n        \"//source/common/common:utility_lib\",\n        \"//source/common/protobuf\",\n        \"@envoy_api//envoy/config/core/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"transport_socket_options_lib\",\n    srcs = [\"transport_socket_options_impl.cc\"],\n    hdrs = [\"transport_socket_options_impl.h\"],\n    deps = [\n        \":application_protocol_lib\",\n        \":filter_state_proxy_info_lib\",\n        \":proxy_protocol_filter_state_lib\",\n        \":upstream_server_name_lib\",\n        \":upstream_subject_alt_names_lib\",\n        \"//envoy/common:hashable_interface\",\n        \"//envoy/common:optref_lib\",\n        \"//envoy/network:proxy_protocol_options_lib\",\n        \"//envoy/network:transport_socket_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:scalar_to_byte_vector_lib\",\n        \"//source/common/common:utility_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_state_proxy_info_lib\",\n    srcs = [\"filter_state_proxy_info.cc\"],\n    hdrs = [\"filter_state_proxy_info.h\"],\n    deps = [\n        \"//envoy/network:address_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_state_dst_address_lib\",\n    srcs = [\"filter_state_dst_address.cc\"],\n    hdrs = [\"filter_state_dst_address.h\"],\n    deps = [\n        \":utility_lib\",\n        \"//envoy/common:hashable_interface\",\n        \"//envoy/network:address_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:hash_lib\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"upstream_server_name_lib\",\n    srcs = [\"upstream_server_name.cc\"],\n    hdrs = [\"upstream_server_name.h\"],\n    deps = [\n        \"//envoy/registry\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"upstream_subject_alt_names_lib\",\n    srcs = [\"upstream_subject_alt_names.cc\"],\n    hdrs = [\"upstream_subject_alt_names.h\"],\n    deps = [\n        \"//envoy/registry\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"filter_matcher_lib\",\n    srcs = [\n        \"filter_matcher.cc\",\n    ],\n    hdrs = [\"filter_matcher.h\"],\n    external_deps = [\n        \"abseil_str_format\",\n    ],\n    deps = [\n        \"//envoy/network:filter_interface\",\n        \"//envoy/network:listen_socket_interface\",\n        \"@envoy_api//envoy/config/listener/v3:pkg_cc_proto\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"udp_packet_writer_handler_lib\",\n    srcs = [\"udp_packet_writer_handler_impl.cc\"],\n    hdrs = [\"udp_packet_writer_handler_impl.h\"],\n    deps = [\n        \":io_socket_error_lib\",\n        \":utility_lib\",\n        \"//envoy/network:socket_interface\",\n        \"//envoy/network:udp_packet_writer_handler_interface\",\n        \"//source/common/buffer:buffer_lib\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"proxy_protocol_filter_state_lib\",\n    srcs = [\"proxy_protocol_filter_state.cc\"],\n    hdrs = [\"proxy_protocol_filter_state.h\"],\n    deps = [\n        \"//envoy/network:proxy_protocol_options_lib\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"upstream_socket_options_filter_state_lib\",\n    srcs = [\"upstream_socket_options_filter_state.cc\"],\n    hdrs = [\"upstream_socket_options_filter_state.h\"],\n    deps = [\n        \":socket_interface_lib\",\n        \":socket_option_factory_lib\",\n        \"//envoy/network:io_handle_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n        \"//source/common/common:macros\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"generic_listener_filter_impl_base_lib\",\n    hdrs = [\"generic_listener_filter_impl_base.h\"],\n    deps = [\n        \"//envoy/network:filter_interface\",\n    ],\n)\n\nenvoy_cc_library(\n    name = \"common_connection_filter_states_lib\",\n    srcs = [\"common_connection_filter_states.cc\"],\n    hdrs = [\"common_connection_filter_states.h\"],\n    deps = [\n        \"//envoy/common:execution_context\",\n        \"//envoy/network:connection_interface\",\n        \"//envoy/stream_info:filter_state_interface\",\n    ],\n)\n", "#include \"source/common/network/address_impl.h\"\n\n#include <array>\n#include <cstdint>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/thread.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/socket_interface.h\"\n#include \"source/common/runtime/runtime_features.h\"\n\nnamespace Envoy {\nnamespace Network {\nnamespace Address {\n\nnamespace {\n\n// Constructs a readable string with the embedded nulls in the abstract path replaced with '@'.\nstd::string friendlyNameFromAbstractPath(absl::string_view path) {\n  std::string friendly_name(path.data(), path.size());\n  std::replace(friendly_name.begin(), friendly_name.end(), '\\0', '@');\n  return friendly_name;\n}\n\nconst SocketInterface* sockInterfaceOrDefault(const SocketInterface* sock_interface) {\n  return sock_interface == nullptr ? &SocketInterfaceSingleton::get() : sock_interface;\n}\n\nvoid throwOnError(absl::Status status) {\n  if (!status.ok()) {\n    throwEnvoyExceptionOrPanic(status.ToString());\n  }\n}\n\nInstanceConstSharedPtr throwOnError(StatusOr<InstanceConstSharedPtr> address) {\n  if (!address.ok()) {\n    throwOnError(address.status());\n  }\n  return *address;\n}\n\n} // namespace\n\nbool forceV6() {\n#if defined(__APPLE__) || defined(__ANDROID_API__)\n  return Runtime::runtimeFeatureEnabled(\"envoy.reloadable_features.always_use_v6\");\n#else\n  return false;\n#endif\n}\n\nvoid ipv6ToIpv4CompatibleAddress(const struct sockaddr_in6* sin6, struct sockaddr_in* sin) {\n#if defined(__APPLE__)\n  *sin = {{}, AF_INET, sin6->sin6_port, {sin6->sin6_addr.__u6_addr.__u6_addr32[3]}, {}};\n#elif defined(WIN32)\n  struct in_addr in_v4 = {};\n  in_v4.S_un.S_addr = reinterpret_cast<const uint32_t*>(sin6->sin6_addr.u.Byte)[3];\n  *sin = {AF_INET, sin6->sin6_port, in_v4, {}};\n#else\n  *sin = {AF_INET, sin6->sin6_port, {sin6->sin6_addr.s6_addr32[3]}, {}};\n#endif\n}\n\nStatusOr<Address::InstanceConstSharedPtr> addressFromSockAddr(const sockaddr_storage& ss,\n                                                              socklen_t ss_len, bool v6only) {\n  RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) >= sizeof(sa_family_t), \"\");\n  if (forceV6()) {\n    v6only = false;\n  }\n  switch (ss.ss_family) {\n  case AF_INET: {\n    RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) == sizeof(sockaddr_in), \"\");\n    const struct sockaddr_in* sin = reinterpret_cast<const struct sockaddr_in*>(&ss);\n    ASSERT(AF_INET == sin->sin_family);\n    return Address::InstanceFactory::createInstancePtr<Address::Ipv4Instance>(sin);\n  }\n  case AF_INET6: {\n    RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) == sizeof(sockaddr_in6), \"\");\n    const struct sockaddr_in6* sin6 = reinterpret_cast<const struct sockaddr_in6*>(&ss);\n    ASSERT(AF_INET6 == sin6->sin6_family);\n    if (!v6only && IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {\n      struct sockaddr_in sin;\n      ipv6ToIpv4CompatibleAddress(sin6, &sin);\n      return Address::InstanceFactory::createInstancePtr<Address::Ipv4Instance>(&sin);\n    } else {\n      return Address::InstanceFactory::createInstancePtr<Address::Ipv6Instance>(*sin6, v6only);\n    }\n  }\n  case AF_UNIX: {\n    const struct sockaddr_un* sun = reinterpret_cast<const struct sockaddr_un*>(&ss);\n    ASSERT(AF_UNIX == sun->sun_family);\n    RELEASE_ASSERT(ss_len == 0 || static_cast<unsigned int>(ss_len) >=\n                                      offsetof(struct sockaddr_un, sun_path) + 1,\n                   \"\");\n    return Address::InstanceFactory::createInstancePtr<Address::PipeInstance>(sun, ss_len);\n  }\n  default:\n    return absl::InvalidArgumentError(fmt::format(\"Unexpected sockaddr family: {}\", ss.ss_family));\n  }\n}\n\nAddress::InstanceConstSharedPtr addressFromSockAddrOrThrow(const sockaddr_storage& ss,\n                                                           socklen_t ss_len, bool v6only) {\n  // Though we don't have any test coverage where address validation in addressFromSockAddr() fails,\n  // this code is called in worker thread and can throw in theory. In that case, the program will\n  // crash due to uncaught exception. In practice, we don't expect any address validation in\n  // addressFromSockAddr() to fail in worker thread.\n  StatusOr<InstanceConstSharedPtr> address = addressFromSockAddr(ss, ss_len, v6only);\n  return throwOnError(address);\n}\n\nAddress::InstanceConstSharedPtr\naddressFromSockAddrOrDie(const sockaddr_storage& ss, socklen_t ss_len, os_fd_t fd, bool v6only) {\n  // Set v6only to false so that mapped-v6 address can be normalize to v4\n  // address. Though dual stack may be disabled, it's still okay to assume the\n  // address is from a dual stack socket. This is because mapped-v6 address\n  // must come from a dual stack socket. An actual v6 address can come from\n  // both dual stack socket and v6 only socket. If |peer_addr| is an actual v6\n  // address and the socket is actually v6 only, the returned address will be\n  // regarded as a v6 address from dual stack socket. However, this address is not going to be\n  // used to create socket. Wrong knowledge of dual stack support won't hurt.\n  StatusOr<Address::InstanceConstSharedPtr> address =\n      Address::addressFromSockAddr(ss, ss_len, v6only);\n  if (!address.ok()) {\n    PANIC(fmt::format(\"Invalid address for fd: {}, error: {}\", fd, address.status().ToString()));\n  }\n  return *address;\n}\n\nIpv4Instance::Ipv4Instance(const sockaddr_in* address, const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  initHelper(address);\n}\n\nIpv4Instance::Ipv4Instance(const std::string& address, const SocketInterface* sock_interface)\n    : Ipv4Instance(address, 0, sockInterfaceOrDefault(sock_interface)) {}\n\nIpv4Instance::Ipv4Instance(const std::string& address, uint32_t port,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  memset(&ip_.ipv4_.address_, 0, sizeof(ip_.ipv4_.address_));\n  ip_.ipv4_.address_.sin_family = AF_INET;\n  ip_.ipv4_.address_.sin_port = htons(port);\n  int rc = inet_pton(AF_INET, address.c_str(), &ip_.ipv4_.address_.sin_addr);\n  if (1 != rc) {\n    throwEnvoyExceptionOrPanic(fmt::format(\"invalid ipv4 address '{}'\", address));\n  }\n\n  friendly_name_ = absl::StrCat(address, \":\", port);\n  ip_.friendly_address_ = address;\n}\n\nIpv4Instance::Ipv4Instance(uint32_t port, const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  memset(&ip_.ipv4_.address_, 0, sizeof(ip_.ipv4_.address_));\n  ip_.ipv4_.address_.sin_family = AF_INET;\n  ip_.ipv4_.address_.sin_port = htons(port);\n  ip_.ipv4_.address_.sin_addr.s_addr = INADDR_ANY;\n  friendly_name_ = absl::StrCat(\"0.0.0.0:\", port);\n  ip_.friendly_address_ = \"0.0.0.0\";\n}\n\nIpv4Instance::Ipv4Instance(absl::Status& status, const sockaddr_in* address,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  status = validateProtocolSupported();\n  if (!status.ok()) {\n    return;\n  }\n  initHelper(address);\n}\n\nbool Ipv4Instance::operator==(const Instance& rhs) const {\n  const Ipv4Instance* rhs_casted = dynamic_cast<const Ipv4Instance*>(&rhs);\n  return (rhs_casted && (ip_.ipv4_.address() == rhs_casted->ip_.ipv4_.address()) &&\n          (ip_.port() == rhs_casted->ip_.port()));\n}\n\nstd::string Ipv4Instance::sockaddrToString(const sockaddr_in& addr) {\n  static constexpr size_t BufferSize = 16; // enough space to hold an IPv4 address in string form\n  char str[BufferSize];\n  // Write backwards from the end of the buffer for simplicity.\n  char* start = str + BufferSize;\n  uint32_t ipv4_addr = ntohl(addr.sin_addr.s_addr);\n  for (unsigned i = 4; i != 0; i--, ipv4_addr >>= 8) {\n    uint32_t octet = ipv4_addr & 0xff;\n    if (octet == 0) {\n      ASSERT(start > str);\n      *--start = '0';\n    } else {\n      do {\n        ASSERT(start > str);\n        *--start = '0' + (octet % 10);\n        octet /= 10;\n      } while (octet != 0);\n    }\n    if (i != 1) {\n      ASSERT(start > str);\n      *--start = '.';\n    }\n  }\n  const std::string::size_type end = str + BufferSize - start;\n  return {start, end};\n}\n\nnamespace {\nbool force_ipv4_unsupported_for_test = false;\n}\n\nCleanup Ipv4Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv4_unsupported_for_test;\n  force_ipv4_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv4_unsupported_for_test = old_val; });\n}\n\nabsl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported && !force_ipv4_unsupported_for_test) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}\n\nvoid Ipv4Instance::initHelper(const sockaddr_in* address) {\n  memset(&ip_.ipv4_.address_, 0, sizeof(ip_.ipv4_.address_));\n  ip_.ipv4_.address_ = *address;\n  ip_.friendly_address_ = sockaddrToString(*address);\n\n  // Based on benchmark testing, this reserve+append implementation runs faster than absl::StrCat.\n  fmt::format_int port(ntohs(address->sin_port));\n  friendly_name_.reserve(ip_.friendly_address_.size() + 1 + port.size());\n  friendly_name_.append(ip_.friendly_address_);\n  friendly_name_.push_back(':');\n  friendly_name_.append(port.data(), port.size());\n}\n\nabsl::uint128 Ipv6Instance::Ipv6Helper::address() const {\n  absl::uint128 result{0};\n  static_assert(sizeof(absl::uint128) == 16, \"The size of absl::uint128 is not 16.\");\n  safeMemcpyUnsafeSrc(&result, &address_.sin6_addr.s6_addr[0]);\n  return result;\n}\n\nuint32_t Ipv6Instance::Ipv6Helper::scopeId() const { return address_.sin6_scope_id; }\n\nuint32_t Ipv6Instance::Ipv6Helper::port() const { return ntohs(address_.sin6_port); }\n\nbool Ipv6Instance::Ipv6Helper::v6only() const { return v6only_; };\n\nstd::string Ipv6Instance::Ipv6Helper::makeFriendlyAddress() const {\n  char str[INET6_ADDRSTRLEN];\n  const char* ptr = inet_ntop(AF_INET6, &address_.sin6_addr, str, INET6_ADDRSTRLEN);\n  ASSERT(str == ptr);\n  if (address_.sin6_scope_id != 0) {\n    // Note that here we don't use the `if_indextoname` that will give a more user friendly\n    // output just because in the past created a performance bottleneck if the machine had a\n    // lot of IPv6 Link local addresses.\n    return absl::StrCat(ptr, \"%\", scopeId());\n  }\n  return ptr;\n}\n\nInstanceConstSharedPtr Ipv6Instance::Ipv6Helper::v4CompatibleAddress() const {\n  if (!v6only_ && IN6_IS_ADDR_V4MAPPED(&address_.sin6_addr)) {\n    struct sockaddr_in sin;\n    ipv6ToIpv4CompatibleAddress(&address_, &sin);\n    auto addr = Address::InstanceFactory::createInstancePtr<Address::Ipv4Instance>(&sin);\n    return addr.ok() ? addr.value() : nullptr;\n  }\n  return nullptr;\n}\n\nInstanceConstSharedPtr Ipv6Instance::Ipv6Helper::addressWithoutScopeId() const {\n  struct sockaddr_in6 ret_addr = address_;\n  ret_addr.sin6_scope_id = 0;\n  auto addr = Address::InstanceFactory::createInstancePtr<Address::Ipv6Instance>(ret_addr, v6only_);\n  return addr.ok() ? addr.value() : nullptr;\n}\n\nIpv6Instance::Ipv6Instance(const sockaddr_in6& address, bool v6only,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  initHelper(address, v6only);\n}\n\nIpv6Instance::Ipv6Instance(const std::string& address, const SocketInterface* sock_interface)\n    : Ipv6Instance(address, 0, sockInterfaceOrDefault(sock_interface)) {}\n\nIpv6Instance::Ipv6Instance(const std::string& address, uint32_t port,\n                           const SocketInterface* sock_interface, bool v6only)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  throwOnError(validateProtocolSupported());\n  sockaddr_in6 addr_in;\n  memset(&addr_in, 0, sizeof(addr_in));\n  addr_in.sin6_family = AF_INET6;\n  addr_in.sin6_port = htons(port);\n  if (!address.empty()) {\n    if (1 != inet_pton(AF_INET6, address.c_str(), &addr_in.sin6_addr)) {\n      throwEnvoyExceptionOrPanic(fmt::format(\"invalid ipv6 address '{}'\", address));\n    }\n  } else {\n    addr_in.sin6_addr = in6addr_any;\n  }\n  initHelper(addr_in, v6only);\n}\n\nIpv6Instance::Ipv6Instance(uint32_t port, const SocketInterface* sock_interface)\n    : Ipv6Instance(\"\", port, sockInterfaceOrDefault(sock_interface)) {}\n\nbool Ipv6Instance::operator==(const Instance& rhs) const {\n  const auto* rhs_casted = dynamic_cast<const Ipv6Instance*>(&rhs);\n  return (rhs_casted && (ip_.ipv6_.address() == rhs_casted->ip_.ipv6_.address()) &&\n          (ip_.port() == rhs_casted->ip_.port()) &&\n          (ip_.ipv6_.scopeId() == rhs_casted->ip_.ipv6_.scopeId()));\n}\n\nIpv6Instance::Ipv6Instance(absl::Status& status, const sockaddr_in6& address, bool v6only,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Ip, sockInterfaceOrDefault(sock_interface)) {\n  status = validateProtocolSupported();\n  if (!status.ok()) {\n    return;\n  }\n  initHelper(address, v6only);\n}\n\nnamespace {\nbool force_ipv6_unsupported_for_test = false;\n}\n\nCleanup Ipv6Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv6_unsupported_for_test;\n  force_ipv6_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv6_unsupported_for_test = old_val; });\n}\n\nabsl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported && !force_ipv6_unsupported_for_test) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}\n\nvoid Ipv6Instance::initHelper(const sockaddr_in6& address, bool v6only) {\n  ip_.ipv6_.address_ = address;\n  ip_.friendly_address_ = ip_.ipv6_.makeFriendlyAddress();\n  ip_.ipv6_.v6only_ = v6only;\n  friendly_name_ = fmt::format(\"[{}]:{}\", ip_.friendly_address_, ip_.port());\n}\n\nPipeInstance::PipeInstance(const sockaddr_un* address, socklen_t ss_len, mode_t mode,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Pipe, sockInterfaceOrDefault(sock_interface)) {\n  if (address->sun_path[0] == '\\0') {\n#if !defined(__linux__)\n    throwEnvoyExceptionOrPanic(\"Abstract AF_UNIX sockets are only supported on linux.\");\n#endif\n    RELEASE_ASSERT(static_cast<unsigned int>(ss_len) >= offsetof(struct sockaddr_un, sun_path) + 1,\n                   \"\");\n    pipe_.abstract_namespace_ = true;\n    pipe_.address_length_ = ss_len - offsetof(struct sockaddr_un, sun_path);\n  }\n  absl::Status status = initHelper(address, mode);\n  throwOnError(status);\n}\n\nPipeInstance::PipeInstance(const std::string& pipe_path, mode_t mode,\n                           const SocketInterface* sock_interface)\n    : InstanceBase(Type::Pipe, sockInterfaceOrDefault(sock_interface)) {\n  if (pipe_path.size() >= sizeof(pipe_.address_.sun_path)) {\n    throwEnvoyExceptionOrPanic(\n        fmt::format(\"Path \\\"{}\\\" exceeds maximum UNIX domain socket path size of {}.\", pipe_path,\n                    sizeof(pipe_.address_.sun_path)));\n  }\n  memset(&pipe_.address_, 0, sizeof(pipe_.address_));\n  pipe_.address_.sun_family = AF_UNIX;\n  if (pipe_path[0] == '@') {\n    // This indicates an abstract namespace.\n    // In this case, null bytes in the name have no special significance, and so we copy all\n    // characters of pipe_path to sun_path, including null bytes in the name. The pathname must also\n    // be null terminated. The friendly name is the address path with embedded nulls replaced with\n    // '@' for consistency with the first character.\n#if !defined(__linux__)\n    throwEnvoyExceptionOrPanic(\"Abstract AF_UNIX sockets are only supported on linux.\");\n#endif\n    if (mode != 0) {\n      throwEnvoyExceptionOrPanic(\"Cannot set mode for Abstract AF_UNIX sockets\");\n    }\n    pipe_.abstract_namespace_ = true;\n    pipe_.address_length_ = pipe_path.size();\n    // The following statement is safe since pipe_path size was checked at the beginning of this\n    // function\n    memcpy(&pipe_.address_.sun_path[0], pipe_path.data(), pipe_path.size()); // NOLINT(safe-memcpy)\n    pipe_.address_.sun_path[0] = '\\0';\n    pipe_.address_.sun_path[pipe_path.size()] = '\\0';\n    friendly_name_ = friendlyNameFromAbstractPath(\n        absl::string_view(pipe_.address_.sun_path, pipe_.address_length_));\n  } else {\n    // Throw an error if the pipe path has an embedded null character.\n    if (pipe_path.size() != strlen(pipe_path.c_str())) {\n      throwEnvoyExceptionOrPanic(\"UNIX domain socket pathname contains embedded null characters\");\n    }\n    StringUtil::strlcpy(&pipe_.address_.sun_path[0], pipe_path.c_str(),\n                        sizeof(pipe_.address_.sun_path));\n    friendly_name_ = pipe_.address_.sun_path;\n  }\n  pipe_.mode_ = mode;\n}\n\nPipeInstance::PipeInstance(absl::Status& error, const sockaddr_un* address, socklen_t ss_len,\n                           mode_t mode, const SocketInterface* sock_interface)\n    : InstanceBase(Type::Pipe, sockInterfaceOrDefault(sock_interface)) {\n  if (address->sun_path[0] == '\\0') {\n#if !defined(__linux__)\n    error = absl::FailedPreconditionError(\"Abstract AF_UNIX sockets are only supported on linux.\");\n    return;\n#endif\n    RELEASE_ASSERT(static_cast<unsigned int>(ss_len) >= offsetof(struct sockaddr_un, sun_path) + 1,\n                   \"\");\n    pipe_.abstract_namespace_ = true;\n    pipe_.address_length_ = ss_len - offsetof(struct sockaddr_un, sun_path);\n  }\n  error = initHelper(address, mode);\n}\n\nbool PipeInstance::operator==(const Instance& rhs) const { return asString() == rhs.asString(); }\n\nabsl::Status PipeInstance::initHelper(const sockaddr_un* address, mode_t mode) {\n  pipe_.address_ = *address;\n  if (pipe_.abstract_namespace_) {\n    if (mode != 0) {\n      return absl::FailedPreconditionError(\"Cannot set mode for Abstract AF_UNIX sockets\");\n    }\n    // Replace all null characters with '@' in friendly_name_.\n    friendly_name_ = friendlyNameFromAbstractPath(\n        absl::string_view(pipe_.address_.sun_path, pipe_.address_length_));\n  } else {\n    friendly_name_ = address->sun_path;\n  }\n  pipe_.mode_ = mode;\n  return absl::OkStatus();\n}\n\nEnvoyInternalInstance::EnvoyInternalInstance(const std::string& address_id,\n                                             const std::string& endpoint_id,\n                                             const SocketInterface* sock_interface)\n    : InstanceBase(Type::EnvoyInternal, sockInterfaceOrDefault(sock_interface)),\n      internal_address_(address_id, endpoint_id) {\n  friendly_name_ = absl::StrCat(\"envoy://\", address_id, \"/\", endpoint_id);\n}\n\nbool EnvoyInternalInstance::operator==(const Instance& rhs) const {\n  return rhs.type() == Type::EnvoyInternal && asString() == rhs.asString();\n}\n\n} // namespace Address\n} // namespace Network\n} // namespace Envoy\n", "#pragma once\n\n#include <sys/types.h>\n\n#include <array>\n#include <cstdint>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/network/address.h\"\n#include \"envoy/network/socket.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/cleanup.h\"\n#include \"source/common/common/statusor.h\"\n\nnamespace Envoy {\nnamespace Network {\nnamespace Address {\n\n// Add an address-specific version for easier searching.\n#define TRY_NEEDS_AUDIT_ADDRESS TRY_NEEDS_AUDIT\n\n/**\n * Check whether we are a) on Android or an Apple platform and b) configured via runtime to always\n * use v6 sockets.\n * This appears to be what Android OS does for all platform sockets.\n */\nbool forceV6();\n\n/**\n * Convert an address in the form of the socket address struct defined by Posix, Linux, etc. into\n * a Network::Address::Instance and return a pointer to it. Raises an EnvoyException on failure.\n * @param ss a valid address with family AF_INET, AF_INET6 or AF_UNIX.\n * @param len length of the address (e.g. from accept, getsockname or getpeername). If len > 0,\n *        it is used to validate the structure contents; else if len == 0, it is ignored.\n * @param v6only disable IPv4-IPv6 mapping for IPv6 addresses?\n * @return InstanceConstSharedPtr the address.\n */\nStatusOr<InstanceConstSharedPtr> addressFromSockAddr(const sockaddr_storage& ss, socklen_t len,\n                                                     bool v6only = true);\nInstanceConstSharedPtr addressFromSockAddrOrThrow(const sockaddr_storage& ss, socklen_t len,\n                                                  bool v6only = true);\n\n/**\n * Convert an address in the form of the socket address struct defined by Posix, Linux, etc. into\n * a Network::Address::Instance and return a pointer to it. Die on failure.\n * @param ss a valid address with family AF_INET, AF_INET6 or AF_UNIX.\n * @param len length of the address (e.g. from accept, getsockname or getpeername). If len > 0,\n *        it is used to validate the structure contents; else if len == 0, it is ignored.\n * @param fd the file descriptor for the created address instance.\n * @param v6only disable IPv4-IPv6 mapping for IPv6 addresses?\n * @return InstanceConstSharedPtr the address.\n */\nInstanceConstSharedPtr addressFromSockAddrOrDie(const sockaddr_storage& ss, socklen_t ss_len,\n                                                os_fd_t fd, bool v6only = true);\n\n/**\n * Base class for all address types.\n */\nclass InstanceBase : public Instance {\npublic:\n  // Network::Address::Instance\n  const std::string& asString() const override { return friendly_name_; }\n  absl::string_view asStringView() const override { return friendly_name_; }\n  // Default logical name is the human-readable name.\n  const std::string& logicalName() const override { return asString(); }\n  Type type() const override { return type_; }\n\n  const SocketInterface& socketInterface() const override { return socket_interface_; }\n\nprotected:\n  InstanceBase(Type type, const SocketInterface* sock_interface)\n      : socket_interface_(*sock_interface), type_(type) {}\n\n  std::string friendly_name_;\n  const SocketInterface& socket_interface_;\n\nprivate:\n  const Type type_;\n};\n\n// Create an address instance. Upon failure, return an error status without throwing.\nclass InstanceFactory {\npublic:\n  template <typename InstanceType, typename... Args>\n  static StatusOr<InstanceConstSharedPtr> createInstancePtr(Args&&... args) {\n    absl::Status status;\n    // Use new instead of make_shared here because the instance constructors are private and must be\n    // called directly here.\n    std::shared_ptr<InstanceType> instance(new InstanceType(status, std::forward<Args>(args)...));\n    if (!status.ok()) {\n      return status;\n    }\n    return instance;\n  }\n};\n\n/**\n * Implementation of an IPv4 address.\n */\nclass Ipv4Instance : public InstanceBase {\npublic:\n  /**\n   * Construct from an existing unix IPv4 socket address (IP v4 address and port).\n   */\n  explicit Ipv4Instance(const sockaddr_in* address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv4 address such as \"1.2.3.4\". Port will be unset/0.\n   */\n  explicit Ipv4Instance(const std::string& address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv4 address such as \"1.2.3.4\" as well as a port.\n   */\n  Ipv4Instance(const std::string& address, uint32_t port,\n               const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a port. The IPv4 address will be set to \"any\" and is suitable for binding\n   * a port to any available address.\n   */\n  explicit Ipv4Instance(uint32_t port, const SocketInterface* sock_interface = nullptr);\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return &ip_; }\n  const Pipe* pipe() const override { return nullptr; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return nullptr; }\n  const sockaddr* sockAddr() const override {\n    return reinterpret_cast<const sockaddr*>(&ip_.ipv4_.address_);\n  }\n  socklen_t sockAddrLen() const override { return sizeof(sockaddr_in); }\n  absl::string_view addressType() const override { return \"default\"; }\n\n  /**\n   * Convenience function to convert an IPv4 address to canonical string format.\n   * @note This works similarly to inet_ntop() but is faster.\n   * @param addr address to format.\n   * @return the address in dotted-decimal string format.\n   */\n  static std::string sockaddrToString(const sockaddr_in& addr);\n\n  // Validate that IPv4 is supported on this platform, raise an exception for the\n  // given address if not.\n  static absl::Status validateProtocolSupported();\n\n  /**\n   * For use in tests only.\n   * Force validateProtocolSupported() to return false for IPv4.\n   */\n  static Envoy::Cleanup forceProtocolUnsupportedForTest(bool new_val);\n\nprivate:\n  /**\n   * Construct from an existing unix IPv4 socket address (IP v4 address and port).\n   * Store the status code in passed in parameter instead of throwing.\n   * It is called by the factory method and the partially constructed instance will be discarded\n   * upon error.\n   */\n  explicit Ipv4Instance(absl::Status& error, const sockaddr_in* address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  struct Ipv4Helper : public Ipv4 {\n    uint32_t address() const override { return address_.sin_addr.s_addr; }\n\n    sockaddr_in address_;\n  };\n\n  struct IpHelper : public Ip {\n    const std::string& addressAsString() const override { return friendly_address_; }\n    bool isAnyAddress() const override { return ipv4_.address_.sin_addr.s_addr == INADDR_ANY; }\n    bool isUnicastAddress() const override {\n      return !isAnyAddress() && (ipv4_.address_.sin_addr.s_addr != INADDR_BROADCAST) &&\n             // inlined IN_MULTICAST() to avoid byte swapping\n             !((ipv4_.address_.sin_addr.s_addr & htonl(0xf0000000)) == htonl(0xe0000000));\n    }\n    const Ipv4* ipv4() const override { return &ipv4_; }\n    const Ipv6* ipv6() const override { return nullptr; }\n    uint32_t port() const override { return ntohs(ipv4_.address_.sin_port); }\n    IpVersion version() const override { return IpVersion::v4; }\n\n    Ipv4Helper ipv4_;\n    std::string friendly_address_;\n  };\n\n  void initHelper(const sockaddr_in* address);\n\n  IpHelper ip_;\n  friend class InstanceFactory;\n};\n\n/**\n * Implementation of an IPv6 address.\n */\nclass Ipv6Instance : public InstanceBase {\npublic:\n  /**\n   * Construct from an existing unix IPv6 socket address (IP v6 address and port).\n   */\n  Ipv6Instance(const sockaddr_in6& address, bool v6only = true,\n               const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv6 address such as \"12:34::5\". Port will be unset/0.\n   */\n  explicit Ipv6Instance(const std::string& address,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string IPv6 address such as \"12:34::5\" as well as a port.\n   */\n  Ipv6Instance(const std::string& address, uint32_t port,\n               const SocketInterface* sock_interface = nullptr, bool v6only = true);\n\n  /**\n   * Construct from a port. The IPv6 address will be set to \"any\" and is suitable for binding\n   * a port to any available address.\n   */\n  explicit Ipv6Instance(uint32_t port, const SocketInterface* sock_interface = nullptr);\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return &ip_; }\n  const Pipe* pipe() const override { return nullptr; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return nullptr; }\n  const sockaddr* sockAddr() const override {\n    return reinterpret_cast<const sockaddr*>(&ip_.ipv6_.address_);\n  }\n  socklen_t sockAddrLen() const override { return sizeof(sockaddr_in6); }\n  absl::string_view addressType() const override { return \"default\"; }\n\n  // Validate that IPv6 is supported on this platform\n  static absl::Status validateProtocolSupported();\n\n  /**\n   * For use in tests only.\n   * Force validateProtocolSupported() to return false for IPv6.\n   */\n  static Envoy::Cleanup forceProtocolUnsupportedForTest(bool new_val);\n\nprivate:\n  /**\n   * Construct from an existing unix IPv6 socket address (IP v6 address and port).\n   * Store the status code in passed in parameter instead of throwing.\n   * It is called by the factory method and the partially constructed instance will be discarded\n   * upon error.\n   */\n  Ipv6Instance(absl::Status& error, const sockaddr_in6& address, bool v6only = true,\n               const SocketInterface* sock_interface = nullptr);\n\n  struct Ipv6Helper : public Ipv6 {\n    Ipv6Helper() { memset(&address_, 0, sizeof(address_)); }\n    absl::uint128 address() const override;\n    bool v6only() const override;\n    uint32_t scopeId() const override;\n    uint32_t port() const;\n    InstanceConstSharedPtr v4CompatibleAddress() const override;\n    InstanceConstSharedPtr addressWithoutScopeId() const override;\n\n    std::string makeFriendlyAddress() const;\n\n    sockaddr_in6 address_;\n    // Is IPv4 compatibility (https://tools.ietf.org/html/rfc3493#page-11) disabled?\n    // Default initialized to true to preserve extant Envoy behavior where we don't explicitly set\n    // this in the constructor.\n    bool v6only_{true};\n  };\n\n  struct IpHelper : public Ip {\n    const std::string& addressAsString() const override { return friendly_address_; }\n    bool isAnyAddress() const override {\n      return 0 == memcmp(&ipv6_.address_.sin6_addr, &in6addr_any, sizeof(struct in6_addr));\n    }\n    bool isUnicastAddress() const override {\n      return !isAnyAddress() && !IN6_IS_ADDR_MULTICAST(&ipv6_.address_.sin6_addr);\n    }\n    const Ipv4* ipv4() const override { return nullptr; }\n    const Ipv6* ipv6() const override { return &ipv6_; }\n    uint32_t port() const override { return ipv6_.port(); }\n    IpVersion version() const override { return IpVersion::v6; }\n\n    Ipv6Helper ipv6_;\n    std::string friendly_address_;\n  };\n\n  void initHelper(const sockaddr_in6& address, bool v6only);\n\n  IpHelper ip_;\n  friend class InstanceFactory;\n};\n\n/**\n * Implementation of a pipe address (unix domain socket on unix).\n */\nclass PipeInstance : public InstanceBase {\npublic:\n  /**\n   * Construct from an existing unix address.\n   */\n  explicit PipeInstance(const sockaddr_un* address, socklen_t ss_len, mode_t mode = 0,\n                        const SocketInterface* sock_interface = nullptr);\n\n  /**\n   * Construct from a string pipe path.\n   */\n  explicit PipeInstance(const std::string& pipe_path, mode_t mode = 0,\n                        const SocketInterface* sock_interface = nullptr);\n\n  static absl::Status validateProtocolSupported() { return absl::OkStatus(); }\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return nullptr; }\n  const Pipe* pipe() const override { return &pipe_; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return nullptr; }\n  const sockaddr* sockAddr() const override {\n    return reinterpret_cast<const sockaddr*>(&pipe_.address_);\n  }\n  const sockaddr_un& getSockAddr() const { return pipe_.address_; }\n  socklen_t sockAddrLen() const override {\n    if (pipe_.abstract_namespace_) {\n      return offsetof(struct sockaddr_un, sun_path) + pipe_.address_length_;\n    }\n    return sizeof(pipe_.address_);\n  }\n  absl::string_view addressType() const override { return \"default\"; }\n\nprivate:\n  /**\n   * Construct from an existing unix address.\n   * Store the error status code in passed in parameter instead of throwing.\n   * It is called by the factory method and the partially constructed instance will be discarded\n   * upon error.\n   */\n  PipeInstance(absl::Status& error, const sockaddr_un* address, socklen_t ss_len, mode_t mode = 0,\n               const SocketInterface* sock_interface = nullptr);\n\n  struct PipeHelper : public Pipe {\n\n    bool abstractNamespace() const override { return abstract_namespace_; }\n    mode_t mode() const override { return mode_; }\n\n    sockaddr_un address_;\n    // For abstract namespaces.\n    bool abstract_namespace_{false};\n    uint32_t address_length_{0};\n    mode_t mode_{0};\n  };\n\n  absl::Status initHelper(const sockaddr_un* address, mode_t mode);\n\n  PipeHelper pipe_;\n  friend class InstanceFactory;\n};\n\nclass EnvoyInternalInstance : public InstanceBase {\npublic:\n  /**\n   * Construct from a string name.\n   */\n  explicit EnvoyInternalInstance(const std::string& address_id, const std::string& endpoint_id = \"\",\n                                 const SocketInterface* sock_interface = nullptr);\n\n  // Network::Address::Instance\n  bool operator==(const Instance& rhs) const override;\n  const Ip* ip() const override { return nullptr; }\n  const Pipe* pipe() const override { return nullptr; }\n  const EnvoyInternalAddress* envoyInternalAddress() const override { return &internal_address_; }\n  // TODO(lambdai): Verify all callers accepts nullptr.\n  const sockaddr* sockAddr() const override { return nullptr; }\n  socklen_t sockAddrLen() const override { return 0; }\n  absl::string_view addressType() const override { return \"envoy_internal\"; }\n\nprivate:\n  struct EnvoyInternalAddressImpl : public EnvoyInternalAddress {\n    explicit EnvoyInternalAddressImpl(const std::string& address_id, const std::string& endpoint_id)\n        : address_id_(address_id), endpoint_id_(endpoint_id) {}\n    ~EnvoyInternalAddressImpl() override = default;\n    const std::string& addressId() const override { return address_id_; }\n    const std::string& endpointId() const override { return endpoint_id_; }\n    const std::string address_id_;\n    const std::string endpoint_id_;\n  };\n  EnvoyInternalAddressImpl internal_address_;\n};\n\n} // namespace Address\n} // namespace Network\n} // namespace Envoy\n", "#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/listen_socket.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_HEADER_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_LOCAL;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ONBEHALF_OF;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_DGRAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_STREAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_VERSION;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\n\nConfig::Config(\n    Stats::Scope& scope,\n    const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol& proto_config)\n    : stats_{ALL_PROXY_PROTOCOL_STATS(POOL_COUNTER(scope))},\n      allow_requests_without_proxy_protocol_(proto_config.allow_requests_without_proxy_protocol()),\n      pass_all_tlvs_(proto_config.has_pass_through_tlvs()\n                         ? proto_config.pass_through_tlvs().match_type() ==\n                               ProxyProtocolPassThroughTLVs::INCLUDE_ALL\n                         : false) {\n  for (const auto& rule : proto_config.rules()) {\n    tlv_types_[0xFF & rule.tlv_type()] = rule.on_tlv_present();\n  }\n\n  if (proto_config.has_pass_through_tlvs() &&\n      proto_config.pass_through_tlvs().match_type() == ProxyProtocolPassThroughTLVs::INCLUDE) {\n    for (const auto& tlv_type : proto_config.pass_through_tlvs().tlv_type()) {\n      pass_through_tlvs_.insert(0xFF & tlv_type);\n    }\n  }\n}\n\nconst KeyValuePair* Config::isTlvTypeNeeded(uint8_t type) const {\n  auto tlv_type = tlv_types_.find(type);\n  if (tlv_types_.end() != tlv_type) {\n    return &tlv_type->second;\n  }\n\n  return nullptr;\n}\n\nbool Config::isPassThroughTlvTypeNeeded(uint8_t tlv_type) const {\n  if (pass_all_tlvs_) {\n    return true;\n  }\n  return pass_through_tlvs_.contains(tlv_type);\n}\n\nsize_t Config::numberOfNeededTlvTypes() const { return tlv_types_.size(); }\n\nbool Config::allowRequestsWithoutProxyProtocol() const {\n  return allow_requests_without_proxy_protocol_;\n}\n\nNetwork::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {\n  ENVOY_LOG(debug, \"proxy_protocol: New connection accepted\");\n  cb_ = &cb;\n  // Waiting for data.\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Filter::onData(Network::ListenerFilterBuffer& buffer) {\n  const ReadOrParseState read_state = parseBuffer(buffer);\n  switch (read_state) {\n  case ReadOrParseState::Error:\n    config_->stats_.downstream_cx_proxy_proto_error_.inc();\n    cb_->socket().ioHandle().close();\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::TryAgainLater:\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::SkipFilter:\n    return Network::FilterStatus::Continue;\n  case ReadOrParseState::Done:\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::Continue;\n}\n\nReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n    if (proxy_protocol_header_.value().local_command_) {\n      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                proxy_protocol_header_.value().wholeHeaderLength(),\n                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              socket.connectionInfoProvider().remoteAddress(),\n              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              proxy_protocol_header_.value().remote_address_,\n              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}\n\nabsl::optional<size_t> Filter::lenV2Address(const char* buf) {\n  const uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  size_t len;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // According to the spec there is no address encoded, len=0, and we must ignore\n    return 0;\n  }\n\n  switch ((proto_family & 0xf0) >> 4) {\n  case PROXY_PROTO_V2_AF_INET:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET;\n    break;\n  case PROXY_PROTO_V2_AF_INET6:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET6;\n    break;\n  default:\n    ENVOY_LOG(debug, \"Unsupported V2 proxy protocol address family\");\n    return absl::nullopt;\n  }\n  return len;\n}\n\nbool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}\n\nbool Filter::parseV1Header(const char* buf, size_t len) {\n  std::string proxy_line;\n  proxy_line.assign(buf, len);\n  const auto trimmed_proxy_line = StringUtil::rtrim(proxy_line);\n\n  // Parse proxy protocol line with format: PROXY TCP4/TCP6/UNKNOWN SOURCE_ADDRESS\n  // DESTINATION_ADDRESS SOURCE_PORT DESTINATION_PORT.\n  const auto line_parts = StringUtil::splitToken(trimmed_proxy_line, \" \", true);\n  if (line_parts.size() < 2 || line_parts[0] != \"PROXY\") {\n    ENVOY_LOG(debug, \"failed to read proxy protocol\");\n    return false;\n  }\n\n  // If the line starts with UNKNOWN we know it's a proxy protocol line, so we can remove it from\n  // the socket and continue. According to spec \"real connection's parameters\" should be used, so\n  // we should NOT restore the addresses in this case.\n  if (line_parts[1] != \"UNKNOWN\") {\n    // If protocol not UNKNOWN, src and dst addresses have to be present.\n    if (line_parts.size() != 6) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n\n    // TODO(gsagula): parseInternetAddressAndPortNoThrow() could be modified to take two string_view\n    // arguments, so we can eliminate allocation here.\n    if (line_parts[1] == \"TCP4\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[2]} + \":\" +\n                                                               std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[3]} + \":\" +\n                                                               std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v4, remote_address, local_address});\n      return true;\n    } else if (line_parts[1] == \"TCP6\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[2]} +\n                                                               \"]:\" + std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[3]} +\n                                                               \"]:\" + std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v6, remote_address, local_address});\n      return true;\n    } else {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n  }\n  proxy_protocol_header_.emplace(WireHeader{len, 0, 0, 0});\n  return true;\n}\n\n/**\n * @note  A TLV is arranged in the following format:\n *        struct pp2_tlv {\n *          uint8_t type;\n *          uint8_t length_hi;\n *          uint8_t length_lo;\n *          uint8_t value[0];\n *        };\n *        See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details\n */\nbool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}\n\nReadOrParseState Filter::readExtensions(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  // waiting for more data if there is no enough data for extensions.\n  if (raw_slice.len_ < (proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.value().local_command_) {\n    // Ignores the extensions if this is a local command.\n    // Those will drained from the buffer in the end.\n    return ReadOrParseState::Done;\n  }\n\n  const uint8_t* buf = static_cast<const uint8_t*>(raw_slice.mem_) +\n                       proxy_protocol_header_.value().headerLengthWithoutExtension();\n  if (!parseTlvs(buf, proxy_protocol_header_.value().extensions_length_)) {\n    return ReadOrParseState::Error;\n  }\n\n  return ReadOrParseState::Done;\n}\n\nReadOrParseState Filter::readProxyHeader(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  const char* buf = static_cast<const char*>(raw_slice.mem_);\n\n  if (config_.get()->allowRequestsWithoutProxyProtocol()) {\n    auto matchv2 = !memcmp(buf, PROXY_PROTO_V2_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V2_SIGNATURE_LEN, raw_slice.len_));\n    auto matchv1 = !memcmp(buf, PROXY_PROTO_V1_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V1_SIGNATURE_LEN, raw_slice.len_));\n    if (!matchv2 && !matchv1) {\n      // The bytes we have seen so far do not match v1 or v2 proxy protocol, so we can safely\n      // short-circuit\n      ENVOY_LOG(trace, \"request does not use v1 or v2 proxy protocol, forwarding as is\");\n      return ReadOrParseState::SkipFilter;\n    }\n  }\n\n  if (raw_slice.len_ >= PROXY_PROTO_V2_HEADER_LEN) {\n    const char* sig = PROXY_PROTO_V2_SIGNATURE;\n    if (!memcmp(buf, sig, PROXY_PROTO_V2_SIGNATURE_LEN)) {\n      header_version_ = V2;\n    } else if (memcmp(buf, PROXY_PROTO_V1_SIGNATURE, PROXY_PROTO_V1_SIGNATURE_LEN)) {\n      // It is not v2, and can't be v1, so no sense hanging around: it is invalid\n      ENVOY_LOG(debug, \"failed to read proxy protocol (exceed max v1 header len)\");\n      return ReadOrParseState::Error;\n    }\n  }\n\n  if (header_version_ == V2) {\n    const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n    if (((ver_cmd & 0xf0) >> 4) != PROXY_PROTO_V2_VERSION) {\n      ENVOY_LOG(debug, \"Unsupported V2 proxy protocol version\");\n      return ReadOrParseState::Error;\n    }\n    absl::optional<ssize_t> addr_len_opt = lenV2Address(buf);\n    if (!addr_len_opt.has_value()) {\n      return ReadOrParseState::Error;\n    }\n    ssize_t addr_len = addr_len_opt.value();\n    uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n    uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n    ssize_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n    if (hdr_addr_len < addr_len) {\n      ENVOY_LOG(debug,\n                \"incorrect address length, address length = {}, the expected address length = {}\",\n                hdr_addr_len, addr_len);\n      return ReadOrParseState::Error;\n    }\n    // waiting for more data if there is no enough data for address.\n    if (raw_slice.len_ >= static_cast<size_t>(PROXY_PROTO_V2_HEADER_LEN + addr_len)) {\n      // The TLV remain, they are parsed in `parseTlvs()` which is called from the\n      // parent (if needed).\n      if (parseV2Header(buf)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  } else {\n    // continue searching buffer from where we left off\n    for (; search_index_ < raw_slice.len_; search_index_++) {\n      if (buf[search_index_] == '\\n' && buf[search_index_ - 1] == '\\r') {\n        if (search_index_ == 1) {\n          // There is not enough data to determine if it contains the v2 protocol signature, so wait\n          // for more data.\n          break;\n        } else {\n          header_version_ = V1;\n          search_index_++;\n        }\n        break;\n      }\n    }\n\n    if (search_index_ > MAX_PROXY_PROTO_LEN_V1) {\n      return ReadOrParseState::Error;\n    }\n\n    if (header_version_ == V1) {\n      if (parseV1Header(buf, search_index_)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  }\n\n  return ReadOrParseState::TryAgainLater;\n}\n\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/transport_sockets/tls/connection_info_impl_base.h\"\n\n#include \"source/common/common/hex.h\"\n\n#include \"absl/strings/str_replace.h\"\n#include \"openssl/err.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nbool ConnectionInfoImplBase::peerCertificatePresented() const {\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  return cert != nullptr;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::uriSanLocalCertificate() const {\n  if (!cached_uri_san_local_certificate_.empty()) {\n    return cached_uri_san_local_certificate_;\n  }\n\n  // The cert object is not owned.\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_uri_san_local_certificate_.empty());\n    return cached_uri_san_local_certificate_;\n  }\n  cached_uri_san_local_certificate_ = Utility::getSubjectAltNames(*cert, GEN_URI);\n  return cached_uri_san_local_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::dnsSansLocalCertificate() const {\n  if (!cached_dns_san_local_certificate_.empty()) {\n    return cached_dns_san_local_certificate_;\n  }\n\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_dns_san_local_certificate_.empty());\n    return cached_dns_san_local_certificate_;\n  }\n  cached_dns_san_local_certificate_ = Utility::getSubjectAltNames(*cert, GEN_DNS);\n  return cached_dns_san_local_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::ipSansLocalCertificate() const {\n  if (!cached_ip_san_local_certificate_.empty()) {\n    return cached_ip_san_local_certificate_;\n  }\n\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_ip_san_local_certificate_.empty());\n    return cached_ip_san_local_certificate_;\n  }\n  cached_ip_san_local_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_local_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::sha256PeerCertificateDigest() const {\n  if (!cached_sha_256_peer_certificate_digest_.empty()) {\n    return cached_sha_256_peer_certificate_digest_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_sha_256_peer_certificate_digest_.empty());\n    return cached_sha_256_peer_certificate_digest_;\n  }\n\n  std::vector<uint8_t> computed_hash(SHA256_DIGEST_LENGTH);\n  unsigned int n;\n  X509_digest(cert.get(), EVP_sha256(), computed_hash.data(), &n);\n  RELEASE_ASSERT(n == computed_hash.size(), \"\");\n  cached_sha_256_peer_certificate_digest_ = Hex::encode(computed_hash);\n  return cached_sha_256_peer_certificate_digest_;\n}\n\nconst std::string& ConnectionInfoImplBase::sha1PeerCertificateDigest() const {\n  if (!cached_sha_1_peer_certificate_digest_.empty()) {\n    return cached_sha_1_peer_certificate_digest_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_sha_1_peer_certificate_digest_.empty());\n    return cached_sha_1_peer_certificate_digest_;\n  }\n\n  std::vector<uint8_t> computed_hash(SHA_DIGEST_LENGTH);\n  unsigned int n;\n  X509_digest(cert.get(), EVP_sha1(), computed_hash.data(), &n);\n  RELEASE_ASSERT(n == computed_hash.size(), \"\");\n  cached_sha_1_peer_certificate_digest_ = Hex::encode(computed_hash);\n  return cached_sha_1_peer_certificate_digest_;\n}\n\nconst std::string& ConnectionInfoImplBase::urlEncodedPemEncodedPeerCertificate() const {\n  if (!cached_url_encoded_pem_encoded_peer_certificate_.empty()) {\n    return cached_url_encoded_pem_encoded_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_url_encoded_pem_encoded_peer_certificate_.empty());\n    return cached_url_encoded_pem_encoded_peer_certificate_;\n  }\n\n  bssl::UniquePtr<BIO> buf(BIO_new(BIO_s_mem()));\n  RELEASE_ASSERT(buf != nullptr, \"\");\n  RELEASE_ASSERT(PEM_write_bio_X509(buf.get(), cert.get()) == 1, \"\");\n  const uint8_t* output;\n  size_t length;\n  RELEASE_ASSERT(BIO_mem_contents(buf.get(), &output, &length) == 1, \"\");\n  absl::string_view pem(reinterpret_cast<const char*>(output), length);\n  cached_url_encoded_pem_encoded_peer_certificate_ = absl::StrReplaceAll(\n      pem, {{\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}});\n  return cached_url_encoded_pem_encoded_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::urlEncodedPemEncodedPeerCertificateChain() const {\n  if (!cached_url_encoded_pem_encoded_peer_cert_chain_.empty()) {\n    return cached_url_encoded_pem_encoded_peer_cert_chain_;\n  }\n\n  STACK_OF(X509)* cert_chain = SSL_get_peer_full_cert_chain(ssl());\n  if (cert_chain == nullptr) {\n    ASSERT(cached_url_encoded_pem_encoded_peer_cert_chain_.empty());\n    return cached_url_encoded_pem_encoded_peer_cert_chain_;\n  }\n\n  for (uint64_t i = 0; i < sk_X509_num(cert_chain); i++) {\n    X509* cert = sk_X509_value(cert_chain, i);\n\n    bssl::UniquePtr<BIO> buf(BIO_new(BIO_s_mem()));\n    RELEASE_ASSERT(buf != nullptr, \"\");\n    RELEASE_ASSERT(PEM_write_bio_X509(buf.get(), cert) == 1, \"\");\n    const uint8_t* output;\n    size_t length;\n    RELEASE_ASSERT(BIO_mem_contents(buf.get(), &output, &length) == 1, \"\");\n\n    absl::string_view pem(reinterpret_cast<const char*>(output), length);\n    cached_url_encoded_pem_encoded_peer_cert_chain_ = absl::StrCat(\n        cached_url_encoded_pem_encoded_peer_cert_chain_,\n        absl::StrReplaceAll(\n            pem, {{\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}}));\n  }\n  return cached_url_encoded_pem_encoded_peer_cert_chain_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::uriSanPeerCertificate() const {\n  if (!cached_uri_san_peer_certificate_.empty()) {\n    return cached_uri_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_uri_san_peer_certificate_.empty());\n    return cached_uri_san_peer_certificate_;\n  }\n  cached_uri_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_URI);\n  return cached_uri_san_peer_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::dnsSansPeerCertificate() const {\n  if (!cached_dns_san_peer_certificate_.empty()) {\n    return cached_dns_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_dns_san_peer_certificate_.empty());\n    return cached_dns_san_peer_certificate_;\n  }\n  cached_dns_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_DNS);\n  return cached_dns_san_peer_certificate_;\n}\n\nabsl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD, true);\n  return cached_ip_san_peer_certificate_;\n}\n\nuint16_t ConnectionInfoImplBase::ciphersuiteId() const {\n  const SSL_CIPHER* cipher = SSL_get_current_cipher(ssl());\n  if (cipher == nullptr) {\n    return 0xffff;\n  }\n\n  // From the OpenSSL docs:\n  //    SSL_CIPHER_get_id returns |cipher|'s id. It may be cast to a |uint16_t| to\n  //    get the cipher suite value.\n  return static_cast<uint16_t>(SSL_CIPHER_get_id(cipher));\n}\n\nstd::string ConnectionInfoImplBase::ciphersuiteString() const {\n  const SSL_CIPHER* cipher = SSL_get_current_cipher(ssl());\n  if (cipher == nullptr) {\n    return {};\n  }\n\n  return SSL_CIPHER_get_name(cipher);\n}\n\nconst std::string& ConnectionInfoImplBase::tlsVersion() const {\n  if (!cached_tls_version_.empty()) {\n    return cached_tls_version_;\n  }\n  cached_tls_version_ = SSL_get_version(ssl());\n  return cached_tls_version_;\n}\n\nconst std::string& ConnectionInfoImplBase::alpn() const {\n  if (alpn_.empty()) {\n    const unsigned char* proto;\n    unsigned int proto_len;\n    SSL_get0_alpn_selected(ssl(), &proto, &proto_len);\n    if (proto != nullptr) {\n      alpn_ = std::string(reinterpret_cast<const char*>(proto), proto_len);\n    }\n  }\n  return alpn_;\n}\n\nconst std::string& ConnectionInfoImplBase::sni() const {\n  if (sni_.empty()) {\n    const char* proto = SSL_get_servername(ssl(), TLSEXT_NAMETYPE_host_name);\n    if (proto != nullptr) {\n      sni_ = std::string(proto);\n    }\n  }\n  return sni_;\n}\n\nconst std::string& ConnectionInfoImplBase::serialNumberPeerCertificate() const {\n  if (!cached_serial_number_peer_certificate_.empty()) {\n    return cached_serial_number_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_serial_number_peer_certificate_.empty());\n    return cached_serial_number_peer_certificate_;\n  }\n  cached_serial_number_peer_certificate_ = Utility::getSerialNumberFromCertificate(*cert.get());\n  return cached_serial_number_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::issuerPeerCertificate() const {\n  if (!cached_issuer_peer_certificate_.empty()) {\n    return cached_issuer_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_issuer_peer_certificate_.empty());\n    return cached_issuer_peer_certificate_;\n  }\n  cached_issuer_peer_certificate_ = Utility::getIssuerFromCertificate(*cert);\n  return cached_issuer_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::subjectPeerCertificate() const {\n  if (!cached_subject_peer_certificate_.empty()) {\n    return cached_subject_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_subject_peer_certificate_.empty());\n    return cached_subject_peer_certificate_;\n  }\n  cached_subject_peer_certificate_ = Utility::getSubjectFromCertificate(*cert);\n  return cached_subject_peer_certificate_;\n}\n\nconst std::string& ConnectionInfoImplBase::subjectLocalCertificate() const {\n  if (!cached_subject_local_certificate_.empty()) {\n    return cached_subject_local_certificate_;\n  }\n  X509* cert = SSL_get_certificate(ssl());\n  if (!cert) {\n    ASSERT(cached_subject_local_certificate_.empty());\n    return cached_subject_local_certificate_;\n  }\n  cached_subject_local_certificate_ = Utility::getSubjectFromCertificate(*cert);\n  return cached_subject_local_certificate_;\n}\n\nabsl::optional<SystemTime> ConnectionInfoImplBase::validFromPeerCertificate() const {\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    return absl::nullopt;\n  }\n  return Utility::getValidFrom(*cert);\n}\n\nabsl::optional<SystemTime> ConnectionInfoImplBase::expirationPeerCertificate() const {\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    return absl::nullopt;\n  }\n  return Utility::getExpirationTime(*cert);\n}\n\nconst std::string& ConnectionInfoImplBase::sessionId() const {\n  if (!cached_session_id_.empty()) {\n    return cached_session_id_;\n  }\n  SSL_SESSION* session = SSL_get_session(ssl());\n  if (session == nullptr) {\n    ASSERT(cached_session_id_.empty());\n    return cached_session_id_;\n  }\n\n  unsigned int session_id_length = 0;\n  const uint8_t* session_id = SSL_SESSION_get_id(session, &session_id_length);\n  cached_session_id_ = Hex::encode(session_id, session_id_length);\n  return cached_session_id_;\n}\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/transport_sockets/tls/utility.h\"\n\n#include <cstdint>\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n\n#include \"absl/strings/str_join.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nstatic constexpr absl::string_view SSL_ERROR_UNKNOWN_ERROR_MESSAGE = \"UNKNOWN_ERROR\";\n\nEnvoy::Ssl::CertificateDetailsPtr Utility::certificateDetails(X509* cert, const std::string& path,\n                                                              TimeSource& time_source) {\n  Envoy::Ssl::CertificateDetailsPtr certificate_details =\n      std::make_unique<envoy::admin::v3::CertificateDetails>();\n  certificate_details->set_path(path);\n  certificate_details->set_serial_number(Utility::getSerialNumberFromCertificate(*cert));\n  const auto days_until_expiry = Utility::getDaysUntilExpiration(cert, time_source).value_or(0);\n  certificate_details->set_days_until_expiration(days_until_expiry);\n\n  ProtobufWkt::Timestamp* valid_from = certificate_details->mutable_valid_from();\n  TimestampUtil::systemClockToTimestamp(Utility::getValidFrom(*cert), *valid_from);\n  ProtobufWkt::Timestamp* expiration_time = certificate_details->mutable_expiration_time();\n  TimestampUtil::systemClockToTimestamp(Utility::getExpirationTime(*cert), *expiration_time);\n\n  for (auto& dns_san : Utility::getSubjectAltNames(*cert, GEN_DNS)) {\n    envoy::admin::v3::SubjectAlternateName& subject_alt_name =\n        *certificate_details->add_subject_alt_names();\n    subject_alt_name.set_dns(dns_san);\n  }\n  for (auto& uri_san : Utility::getSubjectAltNames(*cert, GEN_URI)) {\n    envoy::admin::v3::SubjectAlternateName& subject_alt_name =\n        *certificate_details->add_subject_alt_names();\n    subject_alt_name.set_uri(uri_san);\n  }\n  for (auto& ip_san : Utility::getSubjectAltNames(*cert, GEN_IPADD)) {\n    envoy::admin::v3::SubjectAlternateName& subject_alt_name =\n        *certificate_details->add_subject_alt_names();\n    subject_alt_name.set_ip_address(ip_san);\n  }\n  return certificate_details;\n}\n\nbool Utility::labelWildcardMatch(absl::string_view dns_label, absl::string_view pattern) {\n  constexpr char glob = '*';\n  // Check the special case of a single * pattern, as it's common.\n  if (pattern.size() == 1 && pattern[0] == glob) {\n    return true;\n  }\n  // Only valid if wildcard character appear once.\n  if (std::count(pattern.begin(), pattern.end(), glob) == 1) {\n    std::vector<absl::string_view> split_pattern = absl::StrSplit(pattern, glob);\n    return (pattern.size() <= dns_label.size() + 1) &&\n           absl::StartsWith(dns_label, split_pattern[0]) &&\n           absl::EndsWith(dns_label, split_pattern[1]);\n  }\n  return false;\n}\n\nbool Utility::dnsNameMatch(absl::string_view dns_name, absl::string_view pattern) {\n  // A-label ACE prefix https://www.rfc-editor.org/rfc/rfc5890#section-2.3.2.5.\n  constexpr absl::string_view ACE_prefix = \"xn--\";\n  const std::string lower_case_dns_name = absl::AsciiStrToLower(dns_name);\n  const std::string lower_case_pattern = absl::AsciiStrToLower(pattern);\n  if (lower_case_dns_name == lower_case_pattern) {\n    return true;\n  }\n\n  std::vector<absl::string_view> split_pattern =\n      absl::StrSplit(lower_case_pattern, absl::MaxSplits('.', 1));\n  std::vector<absl::string_view> split_dns_name =\n      absl::StrSplit(lower_case_dns_name, absl::MaxSplits('.', 1));\n\n  // dns name and pattern should contain more than 1 label to match.\n  if (split_pattern.size() < 2 || split_dns_name.size() < 2) {\n    return false;\n  }\n  // Only the left-most label in the pattern contains wildcard '*' and is not an A-label.\n  if ((split_pattern[0].find('*') != absl::string_view::npos) &&\n      (split_pattern[1].find('*') == absl::string_view::npos) &&\n      (!absl::StartsWith(split_pattern[0], ACE_prefix))) {\n    return (split_dns_name[1] == split_pattern[1]) &&\n           labelWildcardMatch(split_dns_name[0], split_pattern[0]);\n  }\n\n  return false;\n}\n\nnamespace {\n\nenum class CertName { Issuer, Subject };\n\n/**\n * Retrieves a name from a certificate and formats it as an RFC 2253 name.\n * @param cert the certificate.\n * @param desired_name the desired name (Issuer or Subject) to retrieve from the certificate.\n * @return std::string returns the desired name formatted as an RFC 2253 name.\n */\nstd::string getRFC2253NameFromCertificate(X509& cert, CertName desired_name) {\n  bssl::UniquePtr<BIO> buf(BIO_new(BIO_s_mem()));\n  RELEASE_ASSERT(buf != nullptr, \"\");\n\n  X509_NAME* name = nullptr;\n  switch (desired_name) {\n  case CertName::Issuer:\n    name = X509_get_issuer_name(&cert);\n    break;\n  case CertName::Subject:\n    name = X509_get_subject_name(&cert);\n    break;\n  }\n\n  // flags=XN_FLAG_RFC2253 is the documented parameter for single-line output in RFC 2253 format.\n  // Example from the RFC:\n  //   * Single value per Relative Distinguished Name (RDN): CN=Steve Kille,O=Isode Limited,C=GB\n  //   * Multivalue output in first RDN: OU=Sales+CN=J. Smith,O=Widget Inc.,C=US\n  //   * Quoted comma in Organization: CN=L. Eagle,O=Sue\\, Grabbit and Runn,C=GB\n  X509_NAME_print_ex(buf.get(), name, 0 /* indent */, XN_FLAG_RFC2253);\n\n  const uint8_t* data;\n  size_t data_len;\n  int rc = BIO_mem_contents(buf.get(), &data, &data_len);\n  ASSERT(rc == 1);\n  return {reinterpret_cast<const char*>(data), data_len};\n}\n\n} // namespace\n\nconst ASN1_TIME& epochASN1Time() {\n  static ASN1_TIME* e = []() -> ASN1_TIME* {\n    ASN1_TIME* epoch = ASN1_TIME_new();\n    const time_t epoch_time = 0;\n    RELEASE_ASSERT(ASN1_TIME_set(epoch, epoch_time) != nullptr, \"\");\n    return epoch;\n  }();\n  return *e;\n}\n\ninline bssl::UniquePtr<ASN1_TIME> currentASN1Time(TimeSource& time_source) {\n  bssl::UniquePtr<ASN1_TIME> current_asn_time(ASN1_TIME_new());\n  const time_t current_time = std::chrono::system_clock::to_time_t(time_source.systemTime());\n  RELEASE_ASSERT(ASN1_TIME_set(current_asn_time.get(), current_time) != nullptr, \"\");\n  return current_asn_time;\n}\n\nstd::string Utility::getSerialNumberFromCertificate(X509& cert) {\n  ASN1_INTEGER* serial_number = X509_get_serialNumber(&cert);\n  BIGNUM num_bn;\n  BN_init(&num_bn);\n  ASN1_INTEGER_to_BN(serial_number, &num_bn);\n  char* char_serial_number = BN_bn2hex(&num_bn);\n  BN_free(&num_bn);\n  if (char_serial_number != nullptr) {\n    std::string serial_number(char_serial_number);\n    OPENSSL_free(char_serial_number);\n    return serial_number;\n  }\n  return \"\";\n}\n\nstd::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type, bool skip_unsupported) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      if (skip_unsupported) {\n        // An IP SAN for an unsupported IP version will throw an exception.\n        // TODO(ggreenway): remove this when IP address construction no longer throws.\n        TRY_NEEDS_AUDIT_ADDRESS { subject_alt_names.push_back(generalNameAsString(san)); }\n        END_TRY CATCH(const EnvoyException& e,\n                      { ENVOY_LOG_MISC(debug, \"Error reading SAN, value skipped: {}\", e.what()); });\n      } else {\n        subject_alt_names.push_back(generalNameAsString(san));\n      }\n    }\n  }\n  return subject_alt_names;\n}\n\nstd::string Utility::generalNameAsString(const GENERAL_NAME* general_name) {\n  std::string san;\n  switch (general_name->type) {\n  case GEN_DNS: {\n    ASN1_STRING* str = general_name->d.dNSName;\n    san.assign(reinterpret_cast<const char*>(ASN1_STRING_data(str)), ASN1_STRING_length(str));\n    break;\n  }\n  case GEN_URI: {\n    ASN1_STRING* str = general_name->d.uniformResourceIdentifier;\n    san.assign(reinterpret_cast<const char*>(ASN1_STRING_data(str)), ASN1_STRING_length(str));\n    break;\n  }\n  case GEN_EMAIL: {\n    ASN1_STRING* str = general_name->d.rfc822Name;\n    san.assign(reinterpret_cast<const char*>(ASN1_STRING_data(str)), ASN1_STRING_length(str));\n    break;\n  }\n  case GEN_IPADD: {\n    if (general_name->d.ip->length == 4) {\n      sockaddr_in sin;\n      memset(&sin, 0, sizeof(sin));\n      sin.sin_port = 0;\n      sin.sin_family = AF_INET;\n      safeMemcpyUnsafeSrc(&sin.sin_addr, general_name->d.ip->data);\n      Network::Address::Ipv4Instance addr(&sin);\n      san = addr.ip()->addressAsString();\n    } else if (general_name->d.ip->length == 16) {\n      sockaddr_in6 sin6;\n      memset(&sin6, 0, sizeof(sin6));\n      sin6.sin6_port = 0;\n      sin6.sin6_family = AF_INET6;\n      safeMemcpyUnsafeSrc(&sin6.sin6_addr, general_name->d.ip->data);\n      Network::Address::Ipv6Instance addr(sin6);\n      san = addr.ip()->addressAsString();\n    }\n    break;\n  }\n  }\n  return san;\n}\n\nstd::string Utility::getIssuerFromCertificate(X509& cert) {\n  return getRFC2253NameFromCertificate(cert, CertName::Issuer);\n}\n\nstd::string Utility::getSubjectFromCertificate(X509& cert) {\n  return getRFC2253NameFromCertificate(cert, CertName::Subject);\n}\n\nabsl::optional<uint32_t> Utility::getDaysUntilExpiration(const X509* cert,\n                                                         TimeSource& time_source) {\n  if (cert == nullptr) {\n    return absl::make_optional(std::numeric_limits<uint32_t>::max());\n  }\n  int days, seconds;\n  if (ASN1_TIME_diff(&days, &seconds, currentASN1Time(time_source).get(),\n                     X509_get0_notAfter(cert))) {\n    if (days >= 0 && seconds >= 0) {\n      return absl::make_optional(days);\n    }\n  }\n  return absl::nullopt;\n}\n\nabsl::string_view Utility::getCertificateExtensionValue(X509& cert,\n                                                        absl::string_view extension_name) {\n  bssl::UniquePtr<ASN1_OBJECT> oid(\n      OBJ_txt2obj(std::string(extension_name).c_str(), 1 /* don't search names */));\n  if (oid == nullptr) {\n    return {};\n  }\n\n  int pos = X509_get_ext_by_OBJ(&cert, oid.get(), -1);\n  if (pos < 0) {\n    return {};\n  }\n\n  X509_EXTENSION* extension = X509_get_ext(&cert, pos);\n  if (extension == nullptr) {\n    return {};\n  }\n\n  const ASN1_OCTET_STRING* octet_string = X509_EXTENSION_get_data(extension);\n  RELEASE_ASSERT(octet_string != nullptr, \"\");\n\n  // Return the entire DER-encoded value for this extension. Correct decoding depends on\n  // knowledge of the expected structure of the extension's value.\n  const unsigned char* octet_string_data = ASN1_STRING_get0_data(octet_string);\n  const int octet_string_length = ASN1_STRING_length(octet_string);\n\n  return {reinterpret_cast<const char*>(octet_string_data),\n          static_cast<absl::string_view::size_type>(octet_string_length)};\n}\n\nSystemTime Utility::getValidFrom(const X509& cert) {\n  int days, seconds;\n  int rc = ASN1_TIME_diff(&days, &seconds, &epochASN1Time(), X509_get0_notBefore(&cert));\n  ASSERT(rc == 1);\n  // Casting to <time_t (64bit)> to prevent multiplication overflow when certificate valid-from date\n  // beyond 2038-01-19T03:14:08Z.\n  return std::chrono::system_clock::from_time_t(static_cast<time_t>(days) * 24 * 60 * 60 + seconds);\n}\n\nSystemTime Utility::getExpirationTime(const X509& cert) {\n  int days, seconds;\n  int rc = ASN1_TIME_diff(&days, &seconds, &epochASN1Time(), X509_get0_notAfter(&cert));\n  ASSERT(rc == 1);\n  // Casting to <time_t (64bit)> to prevent multiplication overflow when certificate not-after date\n  // beyond 2038-01-19T03:14:08Z.\n  return std::chrono::system_clock::from_time_t(static_cast<time_t>(days) * 24 * 60 * 60 + seconds);\n}\n\nabsl::optional<std::string> Utility::getLastCryptoError() {\n  auto err = ERR_get_error();\n\n  if (err != 0) {\n    char errbuf[256];\n\n    ERR_error_string_n(err, errbuf, sizeof(errbuf));\n    return std::string(errbuf);\n  }\n\n  return absl::nullopt;\n}\n\nabsl::string_view Utility::getErrorDescription(int err) {\n  const char* description = SSL_error_description(err);\n  if (description) {\n    return description;\n  }\n\n  IS_ENVOY_BUG(\"BoringSSL error had occurred: SSL_error_description() returned nullptr\");\n  return SSL_ERROR_UNKNOWN_ERROR_MESSAGE;\n}\n\nstd::string Utility::getX509VerificationErrorInfo(X509_STORE_CTX* ctx) {\n  const int n = X509_STORE_CTX_get_error(ctx);\n  const int depth = X509_STORE_CTX_get_error_depth(ctx);\n  std::string error_details =\n      absl::StrCat(\"X509_verify_cert: certificate verification error at depth \", depth, \": \",\n                   X509_verify_cert_error_string(n));\n  return error_details;\n}\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#pragma once\n\n#include <string>\n#include <vector>\n\n#include \"envoy/ssl/context.h\"\n\n#include \"source/common/common/utility.h\"\n\n#include \"absl/types/optional.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\nnamespace Utility {\n\nEnvoy::Ssl::CertificateDetailsPtr certificateDetails(X509* cert, const std::string& path,\n                                                     TimeSource& time_source);\n\n/**\n * Determines whether the given name matches 'pattern' which may optionally begin with a wildcard\n * or contain a wildcard inside the pattern's first label.\n * See: https://www.rfc-editor.org/rfc/rfc6125#section-6.4.3.\n * @param dns_name the DNS name to match\n * @param pattern the pattern to match against (*.example.com) or (test*.example.com)\n * @return true if the san matches pattern\n */\nbool dnsNameMatch(absl::string_view dns_name, absl::string_view pattern);\n\n/**\n * Determines whether the given DNS label matches 'pattern' which may contain a wildcard. e.g.,\n * patterns \"baz*\" and \"*baz\" and \"b*z\" would match DNS labels \"baz1\" and \"foobaz\" and \"buzz\",\n * respectively.\n * @param dns_label the DNS name label to match in lower case\n * @param pattern the pattern to match against in lower case\n * @return true if the dns_label matches pattern\n */\nbool labelWildcardMatch(absl::string_view dns_label, absl::string_view pattern);\n\n/**\n * Retrieves the serial number of a certificate.\n * @param cert the certificate\n * @return std::string the serial number field of the certificate. Returns \"\" if\n *         there is no serial number.\n */\nstd::string getSerialNumberFromCertificate(X509& cert);\n\n/**\n * Retrieves the subject alternate names of a certificate.\n * @param cert the certificate\n * @param type type of subject alternate name\n * @param skip_unsupported If true and a name is for an unsupported (on this host) IP version,\n *   omit that name from the return value. If false, an exception will be thrown in this situation.\n * @return std::vector returns the list of subject alternate names.\n */\nstd::vector<std::string> getSubjectAltNames(X509& cert, int type, bool skip_unsupported = false);\n\n/**\n * Converts the Subject Alternate Name to string.\n * @param general_name the subject alternate name\n * @return std::string returns the string representation of subject alt names.\n */\nstd::string generalNameAsString(const GENERAL_NAME* general_name);\n\n/**\n * Retrieves the issuer from certificate.\n * @param cert the certificate\n * @return std::string the issuer field for the certificate.\n */\nstd::string getIssuerFromCertificate(X509& cert);\n\n/**\n * Retrieves the subject from certificate.\n * @param cert the certificate\n * @return std::string the subject field for the certificate.\n */\nstd::string getSubjectFromCertificate(X509& cert);\n\n/**\n * Retrieves the value of a specific X509 extension from the cert, if present.\n * @param cert the certificate.\n * @param extension_name the name of the extension to extract in dotted number format\n * @return absl::string_view the DER-encoded value of the extension field or empty if not present.\n */\nabsl::string_view getCertificateExtensionValue(X509& cert, absl::string_view extension_name);\n\n/**\n * Returns the days until this certificate is valid.\n * @param cert the certificate\n * @param time_source the time source to use for current time calculation.\n * @return the number of days till this certificate is valid, the value is set when not expired.\n */\nabsl::optional<uint32_t> getDaysUntilExpiration(const X509* cert, TimeSource& time_source);\n\n/**\n * Returns the time from when this certificate is valid.\n * @param cert the certificate.\n * @return time from when this certificate is valid.\n */\nSystemTime getValidFrom(const X509& cert);\n\n/**\n * Returns the time when this certificate expires.\n * @param cert the certificate.\n * @return time after which the certificate expires.\n */\nSystemTime getExpirationTime(const X509& cert);\n\n/**\n * Returns the last crypto error from ERR_get_error(), or `absl::nullopt`\n * if the error stack is empty.\n * @return std::string error message\n */\nabsl::optional<std::string> getLastCryptoError();\n\n/**\n * Returns error string corresponding error code derived from OpenSSL.\n * @param err error code\n * @return string message corresponding error code.\n */\nabsl::string_view getErrorDescription(int err);\n\n/**\n * Extracts the X509 certificate validation error information.\n *\n * @param ctx the store context\n * @return the error details\n */\nstd::string getX509VerificationErrorInfo(X509_STORE_CTX* ctx);\n\n} // namespace Utility\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = v3_req\n\n[req_distinguished_name]\ncountryName = US\ncountryName_default = US\nstateOrProvinceName = California\nstateOrProvinceName_default = California\nlocalityName = San Francisco\nlocalityName_default = San Francisco\norganizationName = Lyft\norganizationName_default = Lyft\norganizationalUnitName = Lyft Engineering\norganizationalUnitName_default = Lyft Engineering\ncommonName = Test Frontend Team\ncommonName_default = Test Frontend Team\ncommonName_max  = 64\nemailAddress = frontend-team@lyft.com\nemailAddress_default = frontend-team@lyft.com\n\n[v3_req]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = clientAuth, serverAuth\nsubjectAltName = @alt_names\nsubjectKeyIdentifier = hash\n\n[v3_ca]\nbasicConstraints = critical, CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nextendedKeyUsage = clientAuth, serverAuth\nsubjectAltName = @alt_names\nsubjectKeyIdentifier = hash\nauthorityKeyIdentifier = keyid:always\n\n[alt_names]\nURI.1 = spiffe://lyft.com/frontend-team\nURI.2 = http://frontend.lyft.com\nDNS.1 = lyft.com\nDNS.2 = www.lyft.com\nIP.1 = 1.2.3.4\nIP.2 = 0:1:2:3::4\n", "-----BEGIN CERTIFICATE-----\nMIIEoTCCA4mgAwIBAgIUfOq/vQ8mjLRgSYL45lUeRsi92lQwDQYJKoZIhvcNAQEL\nBQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM\nDVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsMEEx5ZnQgRW5n\naW5lZXJpbmcxEDAOBgNVBAMMB1Rlc3QgQ0EwHhcNMjMxMTE0MjMxODQwWhcNMjUx\nMTEzMjMxODQwWjCBqDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx\nFjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsM\nEEx5ZnQgRW5naW5lZXJpbmcxGzAZBgNVBAMMElRlc3QgRnJvbnRlbmQgVGVhbTEl\nMCMGCSqGSIb3DQEJARYWZnJvbnRlbmQtdGVhbUBseWZ0LmNvbTCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAL0rleTUkmUs7g/PA9skuWZoa6RoK/NfwwfC\nWniKgiX+yRZcBy9//6HlOD3jLezD6tp+smh1UzIu3r69/r0eDjA+PsxQKDFH69LJ\n74CaFtx9rjapY3VNwuE3jNclcKzDnjNVHrvND+YAIkLhRbXyBqg3n7T1C2wtVIs5\nzOy79iu97vVuX744IDsIuWUWPpFImfgdELeAByRq8IN333jljTf3pN3GfjDf9aKL\nM6jTGRitNVPY2mOe6LpkUntHs42weUBCZ2B39c8olXWeEoCJL35ENuJ/JlxpamP+\nOlK/eShorsFE+UH8tYRMeNkb8ZEdFHohYQGO8WJ5VBw4d47loRsCAwEAAaOB8zCB\n8DAMBgNVHRMBAf8EAjAAMAsGA1UdDwQEAwIF4DAdBgNVHSUEFjAUBggrBgEFBQcD\nAgYIKwYBBQUHAwEwdAYDVR0RBG0wa4Yfc3BpZmZlOi8vbHlmdC5jb20vZnJvbnRl\nbmQtdGVhbYYYaHR0cDovL2Zyb250ZW5kLmx5ZnQuY29tgghseWZ0LmNvbYIMd3d3\nLmx5ZnQuY29thwQBAgMEhxAAAAABAAIAAwAAAAAAAAAEMB0GA1UdDgQWBBTl8J5P\nCF97S4cY6TytejTb3sngmTAfBgNVHSMEGDAWgBQdDTmYdOz7TqwMpoOli3Dmj78y\ngjANBgkqhkiG9w0BAQsFAAOCAQEAsMuSPKvSx/uDRIHWNQhUWSHfa4nfonyGBmnV\nVvC7Xatq3kZ1MCedzxHbqOOdlO4cSVq+eOHlVzWJUsJSj1J8hcVh3vZp6GFoRZgU\nF93g2dlgkmEEqEFB4qI71PwjC6amEV+xY21v/QPEouI1VumUnMnAV81G5uJDzPtn\ngmNyM6hnvKGufpaovZFeXsB0ZUnYPz+4QdKwHTErsV8uUdeJUhFHg1NjCmrqQAmm\nPG0G9JOi/dY/X5/LfGomAb7E+wuJFKHFP7gE6JvWi5M1Y1IlW1tCgN3dSCdCaUZm\nJPKWR3x+gYOFHfKNpdG/zRwOrClgISmDzZiXXFSHCn95tFocXA==\n-----END CERTIFICATE-----\n", "#pragma once\n\n// NOLINT(namespace-envoy)\nconstexpr char TEST_CLIENT_CERT_HASH[] = \"F6:31:41:AA:8E:E3:D7:AC:AE:A8:AF:AD:C9:11:CD:0A:83:72:03:\"\n                                         \"6D:4B:B3:72:4F:6F:71:E1:ED:18:5B:92:AA\";\n", "-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC9K5Xk1JJlLO4P\nzwPbJLlmaGukaCvzX8MHwlp4ioIl/skWXAcvf/+h5Tg94y3sw+rafrJodVMyLt6+\nvf69Hg4wPj7MUCgxR+vSye+Amhbcfa42qWN1TcLhN4zXJXCsw54zVR67zQ/mACJC\n4UW18gaoN5+09QtsLVSLOczsu/Yrve71bl++OCA7CLllFj6RSJn4HRC3gAckavCD\nd9945Y0396Tdxn4w3/WiizOo0xkYrTVT2Npjnui6ZFJ7R7ONsHlAQmdgd/XPKJV1\nnhKAiS9+RDbifyZcaWpj/jpSv3koaK7BRPlB/LWETHjZG/GRHRR6IWEBjvFieVQc\nOHeO5aEbAgMBAAECggEARVEny2KDRFSq5RsPyCjUUOy5aNSNKlBwSDMU8K+cUizi\n5XESZvrpopq6OZ850FTYBXlAiZtYQX7AOzemlQji3RWp8Db9C1XV2XcKbl7IOsJI\n6Jm4Kp80Zk9zKdD70SqbGSc7LEjPZxGsfEJMx4donhJH0MisB1cy8BNdfm+/nDYK\nNsezfOYAD4UkX1NcrdfwLsWimZHPifwxL+va5cV3FiWO3S861/aE0pLhh+AJFYGI\n3lEZxr6Gh+uaARcV4YNZPogYbrc8wJWP/6uR8pDwjqS8aUTBfyo1wUDd6bTvlQDv\n+nKBiVjmWPgY6TlZ/Okp+H28fO3zqoXExE6KJamxmQKBgQDzV5jIemNDUrxodc1i\nAQIchTbchvGiSpLyS2PY1W0vyYpyc5mugvzgaHPVEtaQTtR+QHWrYEFksOBZeIqX\nrQGTDk6jGWBzI7qa/itqr9jydZsMYgJ7eqGpiSsiD0ka65xO+Ho6FkZAV11+qPyE\nQmPD3Izj/58pSod4PADFQSP18wKBgQDHAp9Sd9fGCn/RHRVyf1nao2ZeKCQUDyyj\ng+uCIswhE8lT7C5K76FPxZrV6enpTkLjEnMdRrPl4fQ5xl0SPAR/gaZXhM1U4sjo\nw0dWITeMHwR7HqwbpumNbMccZMGA7o1Ua/k7GPIyD2UE7hiJyJRNyfeN09/cC18p\nEjHcSs4qOQKBgCwU0jh+8zxe4IKL1IjMZfWErEuGpn8fwz7hKVU+VGkzuUDCcDSM\nxgJg6ZrPrs61eQjl5GsHJNF4uSt8Cp8vV/mrvdMN5cr1zfgF0xegg0xowY2cs5Zq\nwJ5Vmtqwqi2WQNqNaJbdMhy1ttobAqNy41+3tE4ZIFv6hE/jjsAs7LbBAoGAXy64\n5uec0wKYiXqglGemoTS/tE78mn97eSWSUWa1PSjKhRIUPhEIlS/M030SPF0LDrH3\nTsxPJKcCeVOPljYQbK+k0H0a+/uP3gvwJZiziZgYO467AGq/j720Kbdi+XifLf6K\ncKKIzDqitU3vfI7rp5zugu4QRp1FwU4LfPJmUrkCgYAzzBz3K7jg4JPdY7Od22SQ\nF/eToChPu60B9uQciR6gGwR1ry2sVSlK0Y1DMFMBCFEqPfJFO4OwZP0NWbRd13X1\n9nUvpVoGxxJ51fIdMrPPm0G6f8HS79JhOGUp9tYsQ+LPCcnrrH2ZDGQYxZsSXqbe\n5qc2rk4Sgt8Ua/oVrxghzA==\n-----END PRIVATE KEY-----\n", "#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/listener_manager/connection_handler_impl.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/connection_balancer_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/raw_buffer_socket.h\"\n#include \"source/common/network/tcp_listener_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include \"test/mocks/api/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/listener_factory_context.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/threadsafe_singleton_injector.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::ElementsAre;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\nnamespace {\n\n// Build again on the basis of the connection_handler_test.cc\n\nclass ProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                          public Network::ListenerConfig,\n                          public Network::FilterChainManager,\n                          protected Logger::Loggable<Logger::Id::main> {\npublic:\n  ProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getCanonicalLoopbackAddress(GetParam()))),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                                Network::Address::InstanceConstSharedPtr(),\n                                                Network::Test::createRawBufferSocket(), nullptr,\n                                                nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect(bool read = true,\n               const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol*\n                   proto_config = nullptr) {\n    int expected_callbacks = 2;\n    auto maybeExitDispatcher = [&]() -> void {\n      expected_callbacks--;\n      if (expected_callbacks == 0) {\n        dispatcher_->exit();\n      }\n    };\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr, std::make_unique<Filter>(std::make_shared<Config>(\n                           listenerScope(), (nullptr != proto_config)\n                                                ? *proto_config\n                                                : envoy::extensions::filters::listener::\n                                                      proxy_protocol::v3::ProxyProtocol())));\n          maybeExitDispatcher();\n          return true;\n        }));\n    conn_->connect();\n    if (read) {\n      read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n      EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n          .WillOnce(Invoke([&](Network::Connection& connection,\n                               const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n            server_connection_ = &connection;\n            connection.addConnectionCallbacks(server_callbacks_);\n            connection.addReadFilter(read_filter_);\n            return true;\n          }));\n    }\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { maybeExitDispatcher(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const uint8_t* s, ssize_t l) {\n    Buffer::OwnedImpl buf(s, l);\n    conn_->write(buf, false);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void expectConnectionError() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n  void expectProxyProtoError() {\n    expectConnectionError();\n    EXPECT_EQ(stats_store_.counter(\"downstream_cx_proxy_proto_error\").value(), 1);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::TestUtil::TestStore stats_store_;\n  Api::ApiPtr api_;\n  BasicResourceLimitImpl open_connections_;\n  Event::DispatcherPtr dispatcher_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  Api::OsSysCallsImpl os_sys_calls_actual_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(ProxyProtocolTest, V1UnsupportedIPv4) {\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest(true);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1UnsupportedIPv6) {\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest(true);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocol) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"data\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN,\n            msg.length()); // Ensure we attempt parsing byte by byte using `search_index_`\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV1First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v1, second two bytes are proxy protocol v2.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"PR\\r\\n\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV2First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v2, second two bytes are proxy protocol v1.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"\\r\\nOX\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowLargeNoProxyProtocol) {\n  // Allows a large request (more bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"more data more data more data\";\n  ASSERT_GT(msg.length(),\n            PROXY_PROTO_V2_HEADER_LEN); // Ensure we attempt parsing as v2 proxy protocol up front\n                                        // rather than parsing byte by byte using `search_index_`\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V1Minimal) {\n  connect();\n  write(\"PROXY UNKNOWN\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  } else {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Basic) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2BasicV6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedIPv4) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest(true);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedIPv6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest(true);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedAF) {\n  // A well-formed message with an unsupported address family\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x41, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_2) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv (e.g. socket close)\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n// TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_1) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2NotLocalOrOnBehalf) {\n  // An illegal command type: neither 'local' nor 'proxy' command\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x23, 0x1f, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnection) {\n  // A 'local' connection, e.g. health-checking, no address, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionExtension) {\n  // A 'local' connection, e.g. health-checking, no address, 1 TLV (0x00,0x00,0x01,0xff) is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xff,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  // A well-formed local proxy protocol v2 header sampled from an AWS NLB healthcheck request,\n  // no address, 1 TLV is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4) {\n  // An ipv4/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4WithAllowNoProxyProtocol) {\n  // An ipv4/tcp PROXY header that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV4) {\n  // An ipv4/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0b, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV6) {\n  // An ipv6/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV6) {\n  // An ipv6/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x23, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2AF_UNIX) {\n  // A well-formed AF_UNIX (0x32 in b14) connection is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2BadCommand) {\n  // A non local/proxy command (0x29 in b13) is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x29, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongVersion) {\n  // A non '2' version is rejected (0x93 in b13)\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x93, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLong) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLongWithAllowNoProxyProtocol) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsRecvError) {\n  // A well-formed ipv4/tcp with a TLV extension. An error is returned on tlv recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n  bool header_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int iovcnt) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, iovcnt);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  header_writed = true;\n  write(tlv, sizeof(tlv));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsFrag) {\n  // A well-formed ipv4/tcp header with 2 TLV/extensions, these are fragmented on delivery\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, Fragmented) {\n  connect();\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  // If there is no data after the PROXY line, the read filter does not receive even the\n  // onNewConnection() callback. We need this in order to run the dispatcher in blocking\n  // mode to make sure that proxy protocol processing is completed before we start testing\n  // the results. Since we must have data we might as well check that we get it.\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented1) {\n  // A well-formed ipv4/tcp message, delivering part of the signature, then part of\n  // the address, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 10, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 20, 17);\n\n  expectData(\"more data\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented2) {\n  // A well-formed ipv4/tcp message, delivering all of the header + 1, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 17, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 27, 10);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented3) {\n  // A well-formed ipv4/tcp message, delivering all of the header, then the remainder.\n  // Do not mistakenly consider that remote has closed when it happens to only read the\n  // header of the message. See: https://github.com/envoyproxy/envoy/pull/18304\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 16);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 16, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 26, 11);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented4Error) {\n  // A well-formed ipv4/tcp message, delivering all of the header +1, w/ an error\n  // simulated in recv() on the +1\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_writed = true;\n  write(buffer, 11);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented5Error) {\n  // A well-formed ipv4/tcp message, part of the signature with an error introduced\n  // in recv() on the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_write = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_write = true;\n  write(buffer + 10, 10);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, PartialRead) {\n  connect();\n\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PROXY TCP4\"); // Intentionally larger than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PRO\"); // Intentionally smaller than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"XY TCP4 25\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"4.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2PartialRead) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  connect();\n\n  for (size_t i = 0; i < sizeof(buffer); i += 9) {\n    write(&buffer[i], 9);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 18 intentionally as it is larger than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 18;\n  ASSERT_LT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 3 intentionally as it is smaller than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 3;\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nconst std::string ProxyProtocol = \"envoy.filters.listener.proxy_protocol\";\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsLargeThanInitMaxReadBytes) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // The TLV has 65520 size data.\n  constexpr uint8_t tlv_begin[] = {0x02, 0xff, 0xf0};\n  std::string tlv_data(65520, 'a');\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv_begin, sizeof(tlv_begin));\n  write(tlv_data);\n\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  EXPECT_EQ(tlv_data, value_s);\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterestAndEmitWithSpecifiedMetadataNamespace) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n  rule->mutable_on_tlv_present()->set_metadata_namespace(\"We need a different metadata namespace\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(\"We need a different metadata namespace\"));\n\n  auto fields = metadata.at(\"We need a different metadata namespace\").fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0xea with size of 25 bytes (22 bytes are value)\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0x32, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, 0x32, 0x35, 0x74, 0x65, 0x73, 0x74,\n                          0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WillNotOverwriteTLV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x2a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority1[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                             0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0x02 (again) with size of 10 bytes (7 bytes are value) and different values\n  constexpr uint8_t tlv_type_authority2[] = {0x02, 0x00, 0x07, 0x62, 0x61,\n                                             0x72, 0x2e, 0x6e, 0x65, 0x74};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority1, sizeof(tlv_type_authority1));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_type_authority2, sizeof(tlv_type_authority2));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongTLVLength) {\n  // A well-formed ipv4/tcp with buffer[14]15] being 0x00 and 0x10. It says we should have 16 bytes\n  // following.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // tlv[2] should be 0x1 since there's only one byte for tlv value.\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x2, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv, sizeof(tlv));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2IncompleteTLV) {\n  // A ipv4/tcp with buffer[14]15] being 0x00 and 0x11. It says we should have 17 bytes following,\n  // however we have 20.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x11, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  // a TLV of type 0x01 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv2[] = {0x1, 0x0, 0x1, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  auto rule_01 = proto_config.add_rules();\n  rule_01->set_tlv_type(0x01);\n  rule_01->mutable_on_tlv_present()->set_key(\"01\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv1, sizeof(tlv1));\n  write(tlv2, sizeof(tlv2));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterState) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(2, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x0, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(0xFF, proxy_proto_data.tlv_vector_[0].value[0]);\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_[0].value.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[1].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[1].value.begin(),\n                                   proxy_proto_data.tlv_vector_[1].value.end()));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeEmpty) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(0, proxy_proto_data.tlv_vector_.size());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeTlV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n  pass_through_tlvs->add_tlv_type(0x02);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[0].value.begin(),\n                                   proxy_proto_data.tlv_vector_[0].value.end()));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, MalformedProxyLine) {\n  connect(false);\n\n  write(\"BOGUS\\r\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(\"\\n\");\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ProxyLineTooLarge) {\n  connect(false);\n  write(\"012345678901234567890123456789012345678901234567890123456789\"\n        \"012345678901234567890123456789012345678901234567890123456789\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NotEnoughFields) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, UnsupportedProto) {\n  connect(false);\n  write(\"PROXY UDP6 1:2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidSrcAddress) {\n  connect(false);\n  write(\"PROXY TCP4 230.0.0.1 10.1.1.3 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidDstAddress) {\n  connect(false);\n  write(\"PROXY TCP4 10.1.1.2 0.0.0.0 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadPort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234 abc\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NegativePort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 -1 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, PortOutOfRange) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 66776 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadAddress) {\n  connect(false);\n  write(\"PROXY TCP6 1::2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch) {\n  connect(false);\n  write(\"PROXY TCP4 [1:2:3::4] 1.2.3.4 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch2) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 [1:2:3: 1234 4]:5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, Truncated) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 5.6.7.8 1234 5678\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, Closed) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, ClosedEmpty) {\n  // We may or may not get these, depending on the operating system timing.\n  EXPECT_CALL(factory_, createListenerFilterChain(_)).Times(AtLeast(0));\n  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).Times(AtLeast(0));\n  conn_->connect();\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n}\n\n// There is no chance to have error for Windows since it emulate the drain\n// from a memory buffer.\n#ifndef WIN32\nTEST_P(ProxyProtocolTest, DrainError) {\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        if (flags != MSG_PEEK) {\n          return Api::SysCallSizeResult{-1, 0};\n        } else {\n          const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n          return x;\n        }\n      }));\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectProxyProtoError();\n}\n#endif\n\nclass WildcardProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                  public Network::ListenerConfig,\n                                  public Network::FilterChainManager,\n                                  protected Logger::Loggable<Logger::Id::main> {\npublic:\n  WildcardProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getAnyAddress(GetParam()))),\n        local_dst_address_(Network::Utility::getAddressWithPort(\n            *Network::Test::getCanonicalLoopbackAddress(GetParam()),\n            socket_->connectionInfoProvider().localAddress()->ip()->port())),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(\n        local_dst_address_, Network::Address::InstanceConstSharedPtr(),\n        Network::Test::createRawBufferSocket(), nullptr, nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr,\n              std::make_unique<Filter>(std::make_shared<Config>(\n                  listenerScope(),\n                  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol())));\n          return true;\n        }));\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect() {\n    conn_->connect();\n    read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n    EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n        .WillOnce(Invoke([&](Network::Connection& connection,\n                             const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n          server_connection_ = &connection;\n          connection.addConnectionCallbacks(server_callbacks_);\n          connection.addReadFilter(read_filter_);\n          return true;\n        }));\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::IsolatedStoreImpl stats_store_;\n  Api::ApiPtr api_;\n  Event::DispatcherPtr dispatcher_;\n  BasicResourceLimitImpl open_connections_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  Network::Address::InstanceConstSharedPtr local_dst_address_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, WildcardProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(WildcardProxyProtocolTest, Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 254.254.254.254 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"1.2.3.4:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"254.254.254.254:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(WildcardProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"[1:2:3::4]:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"[5:6::7:8]:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST(ProxyProtocolConfigFactoryTest, TestCreateFactory) {\n  Server::Configuration::NamedListenerFilterConfigFactory* factory = Registry::FactoryRegistry<\n      Server::Configuration::NamedListenerFilterConfigFactory>::getFactory(ProxyProtocol);\n\n  EXPECT_EQ(factory->name(), ProxyProtocol);\n\n  const std::string yaml = R\"EOF(\n      rules:\n        - tlv_type: 0x01\n          on_tlv_present:\n            key: \"PP2_TYPE_ALPN\"\n        - tlv_type: 0x1a\n          on_tlv_present:\n            key: \"PP2_TYPE_CUSTOMER_A\"\n)EOF\";\n\n  ProtobufTypes::MessagePtr proto_config = factory->createEmptyConfigProto();\n  TestUtility::loadFromYaml(yaml, *proto_config);\n\n  Server::Configuration::MockListenerFactoryContext context;\n  EXPECT_CALL(context, scope());\n  EXPECT_CALL(context, messageValidationVisitor());\n  Network::ListenerFilterFactoryCb cb =\n      factory->createListenerFilterFactoryFromProto(*proto_config, nullptr, context);\n\n  Network::MockListenerFilterManager manager;\n  Network::ListenerFilterPtr added_filter;\n  EXPECT_CALL(manager, addAcceptFilter_(_, _))\n      .WillOnce(Invoke([&added_filter](const Network::ListenerFilterMatcherSharedPtr&,\n                                       Network::ListenerFilterPtr& filter) {\n        added_filter = std::move(filter);\n      }));\n  cb(manager);\n\n  // Make sure we actually create the correct type!\n  EXPECT_NE(dynamic_cast<ProxyProtocol::Filter*>(added_filter.get()), nullptr);\n}\n\n} // namespace\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"ssl_integration_test.h\"\n\n#include <memory>\n#include <string>\n\n#include \"envoy/config/bootstrap/v3/bootstrap.pb.h\"\n#include \"envoy/config/core/v3/address.pb.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.pb.h\"\n\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/network/connection_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/transport_sockets/tls/context_config_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_manager_impl.h\"\n#include \"source/extensions/transport_sockets/tls/ssl_handshaker.h\"\n#include \"source/extensions/transport_sockets/tls/ssl_socket.h\"\n\n#include \"test/common/config/dummy_config.pb.h\"\n#include \"test/extensions/transport_sockets/tls/cert_validator/timed_cert_validator.h\"\n#include \"test/integration/autonomous_upstream.h\"\n#include \"test/integration/integration.h\"\n#include \"test/integration/ssl_utility.h\"\n#include \"test/integration/utility.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/match.h\"\n#include \"absl/time/clock.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\n#ifdef ENVOY_ADMIN_FUNCTIONALITY\n#include \"envoy/config/tap/v3/common.pb.h\"\n#include \"envoy/data/tap/v3/wrapper.pb.h\"\n#include \"envoy/extensions/transport_sockets/tap/v3/tap.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"test/extensions/common/tap/common.h\"\n#endif\n\nusing testing::StartsWith;\n\nnamespace Envoy {\n\nusing Extensions::TransportSockets::Tls::ContextImplPeer;\n\nnamespace Ssl {\n\nvoid SslIntegrationTestBase::initialize() {\n  config_helper_.addSslConfig(ConfigHelper::ServerSslOptions()\n                                  .setRsaCert(server_rsa_cert_)\n                                  .setRsaCertOcspStaple(server_rsa_cert_ocsp_staple_)\n                                  .setEcdsaCert(server_ecdsa_cert_)\n                                  .setEcdsaCertOcspStaple(server_ecdsa_cert_ocsp_staple_)\n                                  .setOcspStapleRequired(ocsp_staple_required_)\n                                  .setTlsV13(server_tlsv1_3_)\n                                  .setCurves(server_curves_)\n                                  .setExpectClientEcdsaCert(client_ecdsa_cert_)\n                                  .setTlsKeyLogFilter(keylog_local_, keylog_remote_,\n                                                      keylog_local_negative_,\n                                                      keylog_remote_negative_, keylog_path_,\n                                                      keylog_multiple_ips_, version_));\n\n  HttpIntegrationTest::initialize();\n\n  context_manager_ =\n      std::make_unique<Extensions::TransportSockets::Tls::ContextManagerImpl>(timeSystem());\n\n  registerTestServerPorts({\"http\"});\n}\n\nvoid SslIntegrationTestBase::TearDown() {\n  HttpIntegrationTest::cleanupUpstreamAndDownstream();\n  codec_client_.reset();\n  context_manager_.reset();\n}\n\nNetwork::ClientConnectionPtr\nSslIntegrationTestBase::makeSslClientConnection(const ClientSslTransportOptions& options) {\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  if (debug_with_s_client_) {\n    const std::string s_client_cmd = TestEnvironment::substitute(\n        \"openssl s_client -connect \" + address->asString() +\n            \" -showcerts -debug -msg -CAfile \"\n            \"{{ test_rundir }}/test/config/integration/certs/cacert.pem \"\n            \"-servername lyft.com -cert \"\n            \"{{ test_rundir }}/test/config/integration/certs/clientcert.pem \"\n            \"-key \"\n            \"{{ test_rundir }}/test/config/integration/certs/clientkey.pem \",\n        version_);\n    ENVOY_LOG_MISC(debug, \"Executing {}\", s_client_cmd);\n    RELEASE_ASSERT(::system(s_client_cmd.c_str()) == 0, \"\");\n  }\n  auto client_transport_socket_factory_ptr =\n      createClientSslTransportSocketFactory(options, *context_manager_, *api_);\n  return dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n}\n\nvoid SslIntegrationTestBase::checkStats() {\n  const uint32_t expected_handshakes = debug_with_s_client_ ? 2 : 1;\n  Stats::CounterSharedPtr counter = test_server_->counter(listenerStatPrefix(\"ssl.handshake\"));\n  EXPECT_EQ(expected_handshakes, counter->value());\n  counter->reset();\n}\n\nclass SslKeyLogTest : public SslIntegrationTest {\npublic:\n  void setLogPath() {\n    keylog_path_ = TestEnvironment::temporaryPath(TestUtility::uniqueFilename());\n  }\n  void setLocalFilter() {\n    keylog_local_ = true;\n    keylog_remote_ = false;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setRemoteFilter() {\n    keylog_remote_ = true;\n    keylog_local_ = false;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setBothLocalAndRemoteFilter() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setNeitherLocalNorRemoteFilter() {\n    keylog_remote_ = false;\n    keylog_local_ = false;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n  }\n  void setNegative() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = true;\n    keylog_remote_negative_ = true;\n  }\n  void setLocalNegative() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = true;\n  }\n  void setRemoteNegative() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = true;\n    keylog_remote_negative_ = false;\n  }\n  void setMultipleIps() {\n    keylog_local_ = true;\n    keylog_remote_ = true;\n    keylog_local_negative_ = false;\n    keylog_remote_negative_ = false;\n    keylog_multiple_ips_ = true;\n  }\n  void logCheck() {\n    EXPECT_TRUE(api_->fileSystem().fileExists(keylog_path_));\n    std::string log = waitForAccessLog(keylog_path_);\n    if (server_tlsv1_3_) {\n      /** The key log for TLS1.3 is as follows:\n       * CLIENT_HANDSHAKE_TRAFFIC_SECRET\n         c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         b335f2ce9079d824a7d2f5ef9af6572d43942d6803bac1ae9de1e840c15c993ae4efdf4ac087877031d1936d5bb858e3\n         SERVER_HANDSHAKE_TRAFFIC_SECRET\n         c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         f498c03446c936d8a17f31669dd54cee2d9bc8d5b7e1a658f677b5cd6e0965111c2331fcc337c01895ec9a0ed12be34a\n         CLIENT_TRAFFIC_SECRET_0 c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         0bbbb2056f3d35a3b610c5cc8ae0b9b63a120912ff25054ee52b853fefc59e12e9fdfebc409347c737394457bfd36bde\n         SERVER_TRAFFIC_SECRET_0 c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         bd3e1757174d82c308515a0c02b981084edda53e546df551ddcf78043bff831c07ff93c7ab3e8ef9e2206c8319c25331\n         EXPORTER_SECRET c62fe86cb3a714451abc7496062251e16862ca3dfc1487c97ab4b291b83a1787\n         6bd19fbdd12e6710159bcb406fd42a580c41236e2d53072dba3064f9b3ff214662081f023e9b22325e31fee5bb11b172\n       */\n      EXPECT_THAT(log, testing::HasSubstr(\"CLIENT_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"SERVER_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"CLIENT_HANDSHAKE_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"SERVER_HANDSHAKE_TRAFFIC_SECRET\"));\n      EXPECT_THAT(log, testing::HasSubstr(\"EXPORTER_SECRET\"));\n    } else {\n      /** The key log for TLS1.1/1.2 is as follows:\n       * CLIENT_RANDOM 5a479a50fe3e85295840b84e298aeb184cecc34ced22d963e16b01dc48c9530f\n         d6840f8100e4ceeb282946cdd72fe403b8d0724ee816ab2d0824b6d6b5033d333ec4b2e77f515226f5d829e137855ef1\n       */\n      EXPECT_THAT(log, testing::HasSubstr(\"CLIENT_RANDOM\"));\n    }\n  }\n  void negativeCheck() {\n    EXPECT_TRUE(api_->fileSystem().fileExists(keylog_path_));\n    auto size = api_->fileSystem().fileSize(keylog_path_);\n    EXPECT_EQ(size, 0);\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Test that Envoy behaves correctly when receiving an SSLAlert for an unspecified code. The codes\n// are defined in the standard, and assigned codes have a string associated with them in BoringSSL,\n// which is included in logs. For an unknown code, verify that no crash occurs.\nTEST_P(SslIntegrationTest, UnknownSslAlert) {\n  initialize();\n  Network::ClientConnectionPtr connection = makeSslClientConnection({});\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  while (!callbacks.connected()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n\n  Ssl::ConnectionInfoConstSharedPtr ssl_info = connection->ssl();\n  SSL* ssl =\n      dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(ssl_info.get())\n          ->ssl();\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  ASSERT_NE(ssl, nullptr);\n  SSL_send_fatal_alert(ssl, 255);\n  while (!callbacks.closed()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  connection->close(Network::ConnectionCloseType::NoFlush);\n}\n\n// Test that stats produced by the tls transport socket have correct tag extraction.\nTEST_P(SslIntegrationTest, StatsTagExtraction) {\n  // Configure TLS to use specific parameters so the exact metrics the test expects are created.\n  // TLSv1.3 doesn't allow specifying the cipher suites, so use TLSv1.2 to force a specific cipher\n  // suite to simplify the test.\n  // Use P-256 to test the regex on a curve containing a hyphen (instead of X25519).\n\n  // Configure test-client to Envoy connection.\n  server_curves_.push_back(\"P-256\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(\n        ClientSslTransportOptions{}\n            .setTlsVersion(envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2)\n            .setCipherSuites({\"ECDHE-RSA-AES128-GCM-SHA256\"})\n            .setSigningAlgorithms({\"rsa_pss_rsae_sha256\"}));\n  };\n\n  // Configure Envoy to fake-upstream connection.\n  upstream_tls_ = true;\n  setUpstreamProtocol(Http::CodecType::HTTP2);\n  config_helper_.configureUpstreamTls(\n      false, false, absl::nullopt,\n      [](envoy::extensions::transport_sockets::tls::v3::CommonTlsContext& ctx) {\n        auto& params = *ctx.mutable_tls_params();\n        params.set_tls_minimum_protocol_version(\n            envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n        params.set_tls_maximum_protocol_version(\n            envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n        params.add_ecdh_curves(\"P-256\");\n        params.add_signature_algorithms(\"rsa_pss_rsae_sha256\");\n        params.add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n      });\n\n  testRouterRequestAndResponseWithBody(1024, 1024, false, false, &creator);\n  checkStats();\n\n  using ExpectedResultsMap =\n      absl::node_hash_map<std::string, std::pair<std::string, Stats::TagVector>>;\n  ExpectedResultsMap base_expected_counters = {\n      {\"ssl.ciphers.ECDHE-RSA-AES128-GCM-SHA256\",\n       {\"ssl.ciphers\", {{\"envoy.ssl_cipher\", \"ECDHE-RSA-AES128-GCM-SHA256\"}}}},\n      {\"ssl.versions.TLSv1.2\", {\"ssl.versions\", {{\"envoy.ssl_version\", \"TLSv1.2\"}}}},\n      {\"ssl.curves.P-256\", {\"ssl.curves\", {{\"envoy.ssl_curve\", \"P-256\"}}}},\n      {\"ssl.sigalgs.rsa_pss_rsae_sha256\",\n       {\"ssl.sigalgs\", {{\"envoy.ssl_sigalg\", \"rsa_pss_rsae_sha256\"}}}},\n  };\n\n  // Expect all the stats for both listeners and clusters.\n  ExpectedResultsMap expected_counters;\n  for (const auto& entry : base_expected_counters) {\n    expected_counters[listenerStatPrefix(entry.first)] = {\n        absl::StrCat(\"listener.\", entry.second.first), entry.second.second};\n    expected_counters[absl::StrCat(\"cluster.cluster_0.\", entry.first)] = {\n        absl::StrCat(\"cluster.\", entry.second.first), entry.second.second};\n  }\n\n  // The cipher suite extractor is written as two rules for listener and cluster, and they don't\n  // match unfortunately, but it's left this way for backwards compatibility.\n  expected_counters[\"cluster.cluster_0.ssl.ciphers.ECDHE-RSA-AES128-GCM-SHA256\"].second = {\n      {\"cipher_suite\", \"ECDHE-RSA-AES128-GCM-SHA256\"}};\n\n  for (const Stats::CounterSharedPtr& counter : test_server_->counters()) {\n    // Useful for debugging when the test is failing.\n    if (counter->name().find(\"ssl\") != std::string::npos) {\n      ENVOY_LOG_MISC(critical, \"Found ssl metric: {}\", counter->name());\n    }\n    auto it = expected_counters.find(counter->name());\n    if (it != expected_counters.end()) {\n      EXPECT_EQ(counter->tagExtractedName(), it->second.first);\n\n      // There are other extracted tags such as listener and cluster name, hence ``IsSupersetOf``.\n      EXPECT_THAT(counter->tags(), ::testing::IsSupersetOf(it->second.second));\n      expected_counters.erase(it);\n    }\n  }\n\n  EXPECT_THAT(expected_counters, ::testing::IsEmpty());\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithGiantBodyBuffer) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(16 * 1024 * 1024, 16 * 1024 * 1024, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, Http1StreamInfoDownstreamHandshakeTiming) {\n  ASSERT_TRUE(downstreamProtocol() == Http::CodecType::HTTP1);\n  config_helper_.prependFilter(fmt::format(R\"EOF(\n  name: stream-info-to-headers-filter\n)EOF\"));\n\n  initialize();\n  codec_client_ = makeHttpConnection(makeSslClientConnection({}));\n  auto response =\n      sendRequestAndWaitForResponse(default_request_headers_, 0, default_response_headers_, 0);\n\n  ASSERT_FALSE(\n      response->headers().get(Http::LowerCaseString(\"downstream_handshake_complete\")).empty());\n}\n\nTEST_P(SslIntegrationTest, Http2StreamInfoDownstreamHandshakeTiming) {\n  // See MultiplexedIntegrationTest for equivalent test for HTTP/3.\n  setDownstreamProtocol(Http::CodecType::HTTP2);\n  config_helper_.prependFilter(fmt::format(R\"EOF(\n  name: stream-info-to-headers-filter\n)EOF\"));\n\n  initialize();\n  codec_client_ = makeHttpConnection(makeSslClientConnection({}));\n  auto response =\n      sendRequestAndWaitForResponse(default_request_headers_, 0, default_response_headers_, 0);\n\n  ASSERT_FALSE(\n      response->headers().get(Http::LowerCaseString(\"downstream_handshake_complete\")).empty());\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBuffer) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBufferHttp2) {\n  setDownstreamProtocol(Http::CodecType::HTTP2);\n  config_helper_.setClientCodec(envoy::extensions::filters::network::http_connection_manager::v3::\n                                    HttpConnectionManager::AUTO);\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setAlpn(true));\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBufferVerifySAN) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSan(san_to_match_));\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterRequestAndResponseWithBodyNoBufferHttp2VerifySAN) {\n  setDownstreamProtocol(Http::CodecType::HTTP2);\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setAlpn(true).setSan(san_to_match_));\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterHeaderOnlyRequestAndResponse) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterHeaderOnlyRequestAndResponse(&creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterUpstreamDisconnectBeforeResponseComplete) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterUpstreamDisconnectBeforeResponseComplete(&creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterDownstreamDisconnectBeforeRequestComplete) {\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterDownstreamDisconnectBeforeRequestComplete(&creator);\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, RouterDownstreamDisconnectBeforeResponseComplete) {\n#if defined(__APPLE__) || defined(WIN32)\n  // Skip this test on OS X + Windows: we can't detect the early close on non-Linux, and we\n  // won't clean up the upstream connection until it times out. See #4294.\n  if (downstream_protocol_ == Http::CodecType::HTTP1) {\n    return;\n  }\n#endif\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterDownstreamDisconnectBeforeResponseComplete(&creator);\n  checkStats();\n}\n\n// This test must be here vs integration_admin_test so that it tests a server with loaded certs.\nTEST_P(SslIntegrationTest, AdminCertEndpoint) {\n  DISABLE_IF_ADMIN_DISABLED; // Admin functionality.\n  initialize();\n  BufferingStreamDecoderPtr response = IntegrationUtil::makeSingleRequest(\n      lookupPort(\"admin\"), \"GET\", \"/certs\", \"\", downstreamProtocol(), version_);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}\n\nTEST_P(SslIntegrationTest, RouterHeaderOnlyRequestAndResponseWithSni) {\n  config_helper_.addFilter(\"name: sni-to-header-filter\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSni(\"host.com\"));\n  };\n  initialize();\n  codec_client_ = makeHttpConnection(\n      makeSslClientConnection(ClientSslTransportOptions().setSni(\"www.host.com\")));\n  Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/\"}, {\":scheme\", \"https\"}, {\":authority\", \"host.com\"}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  waitForNextUpstreamRequest();\n\n  EXPECT_EQ(\"www.host.com\", upstream_request_->headers()\n                                .get(Http::LowerCaseString(\"x-envoy-client-sni\"))[0]\n                                ->value()\n                                .getStringView());\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, true);\n  RELEASE_ASSERT(response->waitForEndStream(), \"unexpected timeout\");\n\n  checkStats();\n}\n\nTEST_P(SslIntegrationTest, LogPeerIpSanUnsupportedIpVersion) {\n  useListenerAccessLog(\"%DOWNSTREAM_PEER_IP_SAN%\");\n  config_helper_.addFilter(\"name: sni-to-header-filter\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSni(\"host.com\"));\n  };\n  initialize();\n  codec_client_ = makeHttpConnection(\n      makeSslClientConnection(ClientSslTransportOptions().setSni(\"www.host.com\")));\n\n  // Disable IP version for the alternate type from the test. The client cert has both an ipv4 and\n  // an ipv6 SAN. This must happen after the client has loaded the cert to send as the client cert.\n  auto disabler = (version_ == Network::Address::IpVersion::v4)\n                      ? Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest\n                      : Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest;\n  Cleanup cleaner(disabler(true));\n\n  Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/\"}, {\":scheme\", \"https\"}, {\":authority\", \"host.com\"}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  waitForNextUpstreamRequest();\n\n  EXPECT_EQ(\"www.host.com\", upstream_request_->headers()\n                                .get(Http::LowerCaseString(\"x-envoy-client-sni\"))[0]\n                                ->value()\n                                .getStringView());\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, true);\n  RELEASE_ASSERT(response->waitForEndStream(), \"unexpected timeout\");\n  codec_client_->close();\n\n  checkStats();\n  auto result = waitForAccessLog(listener_access_log_name_);\n  if (version_ == Network::Address::IpVersion::v4) {\n    EXPECT_EQ(result, \"1.2.3.4\");\n  } else {\n    EXPECT_EQ(result, \"0:1:2:3::4\");\n  }\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationSucceeds) {\n  // Config client to use an async cert validator which defer the actual validation by 5ms.\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  initialize();\n\n  Network::ClientConnectionPtr connection = makeSslClientConnection(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()));\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  while (!callbacks.connected()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  connection->close(Network::ConnectionCloseType::NoFlush);\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationSucceedsWithLocalAddress) {\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  auto* cert_validator_factory =\n      Registry::FactoryRegistry<Extensions::TransportSockets::Tls::CertValidatorFactory>::\n          getFactory(\"envoy.tls.cert_validator.timed_cert_validator\");\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->resetForTest();\n  initialize();\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  auto client_transport_socket_factory_ptr = createClientSslTransportSocketFactory(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()),\n      *context_manager_, *api_);\n  Network::ClientConnectionPtr connection = dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n\n  // Get the `TimedCertValidator` object and set its expected local address.\n  Envoy::Ssl::ClientContextSharedPtr client_ssl_ctx =\n      static_cast<Extensions::TransportSockets::Tls::ClientSslSocketFactory&>(\n          *client_transport_socket_factory_ptr)\n          .sslCtx();\n  Extensions::TransportSockets::Tls::TimedCertValidator& cert_validator =\n      static_cast<Extensions::TransportSockets::Tls::TimedCertValidator&>(\n          ContextImplPeer::getMutableCertValidator(\n              static_cast<Extensions::TransportSockets::Tls::ClientContextImpl&>(*client_ssl_ctx)));\n  ASSERT_TRUE(connection->connectionInfoProvider().localAddress() != nullptr);\n  cert_validator.setExpectedLocalAddress(\n      connection->connectionInfoProvider().localAddress()->asString());\n\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  while (!callbacks.connected()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  connection->close(Network::ConnectionCloseType::NoFlush);\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationAfterTearDown) {\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  auto* cert_validator_factory =\n      Registry::FactoryRegistry<Extensions::TransportSockets::Tls::CertValidatorFactory>::\n          getFactory(\"envoy.tls.cert_validator.timed_cert_validator\");\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->resetForTest();\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->setValidationTimeOutMs(std::chrono::milliseconds(1000));\n  initialize();\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  auto client_transport_socket_factory_ptr = createClientSslTransportSocketFactory(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()),\n      *context_manager_, *api_);\n  Network::ClientConnectionPtr connection = dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  Envoy::Ssl::ClientContextSharedPtr client_ssl_ctx =\n      static_cast<Extensions::TransportSockets::Tls::ClientSslSocketFactory&>(\n          *client_transport_socket_factory_ptr)\n          .sslCtx();\n  auto& cert_validator = static_cast<const Extensions::TransportSockets::Tls::TimedCertValidator&>(\n      ContextImplPeer::getCertValidator(\n          static_cast<Extensions::TransportSockets::Tls::ClientContextImpl&>(*client_ssl_ctx)));\n  EXPECT_TRUE(cert_validator.validationPending());\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  connection->close(Network::ConnectionCloseType::NoFlush);\n  connection.reset();\n  while (cert_validator.validationPending()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n}\n\nTEST_P(SslIntegrationTest, AsyncCertValidationAfterSslShutdown) {\n  auto custom_validator_config = std::make_unique<envoy::config::core::v3::TypedExtensionConfig>(\n      envoy::config::core::v3::TypedExtensionConfig());\n  TestUtility::loadFromYaml(TestEnvironment::substitute(R\"EOF(\nname: \"envoy.tls.cert_validator.timed_cert_validator\"\ntyped_config:\n  \"@type\": type.googleapis.com/test.common.config.DummyConfig\n  )EOF\"),\n                            *custom_validator_config);\n  auto* cert_validator_factory =\n      Registry::FactoryRegistry<Extensions::TransportSockets::Tls::CertValidatorFactory>::\n          getFactory(\"envoy.tls.cert_validator.timed_cert_validator\");\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->resetForTest();\n  static_cast<Extensions::TransportSockets::Tls::TimedCertValidatorFactory*>(cert_validator_factory)\n      ->setValidationTimeOutMs(std::chrono::milliseconds(1000));\n  initialize();\n  Network::Address::InstanceConstSharedPtr address = getSslAddress(version_, lookupPort(\"http\"));\n  auto client_transport_socket_factory_ptr = createClientSslTransportSocketFactory(\n      ClientSslTransportOptions().setCustomCertValidatorConfig(custom_validator_config.get()),\n      *context_manager_, *api_);\n  Network::ClientConnectionPtr connection = dispatcher_->createClientConnection(\n      address, Network::Address::InstanceConstSharedPtr(),\n      client_transport_socket_factory_ptr->createTransportSocket({}, nullptr), nullptr, nullptr);\n  ConnectionStatusCallbacks callbacks;\n  connection->addConnectionCallbacks(callbacks);\n  connection->connect();\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      connection->ssl().get());\n  ASSERT(socket);\n  while (socket->state() == Ssl::SocketState::PreHandshake) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  Envoy::Ssl::ClientContextSharedPtr client_ssl_ctx =\n      static_cast<Extensions::TransportSockets::Tls::ClientSslSocketFactory&>(\n          *client_transport_socket_factory_ptr)\n          .sslCtx();\n  auto& cert_validator = static_cast<const Extensions::TransportSockets::Tls::TimedCertValidator&>(\n      ContextImplPeer::getCertValidator(\n          static_cast<Extensions::TransportSockets::Tls::ClientContextImpl&>(*client_ssl_ctx)));\n  EXPECT_TRUE(cert_validator.validationPending());\n  ASSERT_EQ(connection->state(), Network::Connection::State::Open);\n  connection->close(Network::ConnectionCloseType::NoFlush);\n  while (cert_validator.validationPending()) {\n    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  }\n  connection.reset();\n}\n\nclass RawWriteSslIntegrationTest : public SslIntegrationTest {\nprotected:\n  std::unique_ptr<Http::TestRequestHeaderMapImpl>\n  testFragmentedRequestWithBufferLimit(std::list<std::string> request_chunks,\n                                       uint32_t buffer_limit) {\n    autonomous_upstream_ = true;\n    config_helper_.setBufferLimits(buffer_limit, buffer_limit);\n    initialize();\n\n    // write_request_cb will write each of the items in request_chunks as a separate SSL_write.\n    auto write_request_cb = [&request_chunks](Buffer::Instance& buffer) {\n      if (!request_chunks.empty()) {\n        buffer.add(request_chunks.front());\n        request_chunks.pop_front();\n      }\n      return false;\n    };\n\n    auto client_transport_socket_factory_ptr =\n        createClientSslTransportSocketFactory({}, *context_manager_, *api_);\n    std::string response;\n    auto connection = createConnectionDriver(\n        lookupPort(\"http\"), write_request_cb,\n        [&](Network::ClientConnection&, const Buffer::Instance& data) -> void {\n          response.append(data.toString());\n        },\n        client_transport_socket_factory_ptr->createTransportSocket({}, nullptr));\n\n    // Drive the connection until we get a response.\n    while (response.empty()) {\n      EXPECT_TRUE(connection->run(Event::Dispatcher::RunType::NonBlock));\n    }\n    EXPECT_THAT(response, testing::HasSubstr(\"HTTP/1.1 200 OK\\r\\n\"));\n\n    connection->close();\n    return reinterpret_cast<AutonomousUpstream*>(fake_upstreams_.front().get())\n        ->lastRequestHeaders();\n  }\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, RawWriteSslIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/12304\nTEST_P(RawWriteSslIntegrationTest, HighWatermarkReadResumptionProcessingHeaders) {\n  // The raw writer will perform a separate SSL_write for each of the chunks below. Chunk sizes were\n  // picked such that the connection's high watermark will trigger while processing the last SSL\n  // record containing the request headers. Verify that read resumption works correctly after\n  // hitting the receive buffer high watermark.\n  std::list<std::string> request_chunks = {\n      \"GET / HTTP/1.1\\r\\nHost: host\\r\\n\",\n      \"key1:\" + std::string(14000, 'a') + \"\\r\\n\",\n      \"key2:\" + std::string(16000, 'b') + \"\\r\\n\\r\\n\",\n  };\n\n  std::unique_ptr<Http::TestRequestHeaderMapImpl> upstream_headers =\n      testFragmentedRequestWithBufferLimit(request_chunks, 15 * 1024);\n  ASSERT_TRUE(upstream_headers != nullptr);\n  EXPECT_EQ(upstream_headers->Host()->value(), \"host\");\n  EXPECT_EQ(\n      std::string(14000, 'a'),\n      upstream_headers->get(Envoy::Http::LowerCaseString(\"key1\"))[0]->value().getStringView());\n  EXPECT_EQ(\n      std::string(16000, 'b'),\n      upstream_headers->get(Envoy::Http::LowerCaseString(\"key2\"))[0]->value().getStringView());\n}\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/12304\nTEST_P(RawWriteSslIntegrationTest, HighWatermarkReadResumptionProcesingBody) {\n  // The raw writer will perform a separate SSL_write for each of the chunks below. Chunk sizes were\n  // picked such that the connection's high watermark will trigger while processing the last SSL\n  // record containing the POST body. Verify that read resumption works correctly after hitting the\n  // receive buffer high watermark.\n  std::list<std::string> request_chunks = {\n      \"POST / HTTP/1.1\\r\\nHost: host\\r\\ncontent-length: 30000\\r\\n\\r\\n\",\n      std::string(14000, 'a'),\n      std::string(16000, 'a'),\n  };\n\n  std::unique_ptr<Http::TestRequestHeaderMapImpl> upstream_headers =\n      testFragmentedRequestWithBufferLimit(request_chunks, 15 * 1024);\n  ASSERT_TRUE(upstream_headers != nullptr);\n}\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/12304\nTEST_P(RawWriteSslIntegrationTest, HighWatermarkReadResumptionProcesingLargerBody) {\n  std::list<std::string> request_chunks = {\n      \"POST / HTTP/1.1\\r\\nHost: host\\r\\ncontent-length: 150000\\r\\n\\r\\n\",\n  };\n  for (int i = 0; i < 10; ++i) {\n    request_chunks.push_back(std::string(15000, 'a'));\n  }\n\n  std::unique_ptr<Http::TestRequestHeaderMapImpl> upstream_headers =\n      testFragmentedRequestWithBufferLimit(request_chunks, 16 * 1024);\n  ASSERT_TRUE(upstream_headers != nullptr);\n}\n\n// Validate certificate selection across different certificate types and client TLS versions.\nclass SslCertficateIntegrationTest\n    : public testing::TestWithParam<\n          std::tuple<Network::Address::IpVersion,\n                     envoy::extensions::transport_sockets::tls::v3::TlsParameters::TlsProtocol>>,\n      public SslIntegrationTestBase {\npublic:\n  SslCertficateIntegrationTest() : SslIntegrationTestBase(std::get<0>(GetParam())) {\n    server_tlsv1_3_ = true;\n  }\n\n  Network::ClientConnectionPtr\n  makeSslClientConnection(const ClientSslTransportOptions& options) override {\n    ClientSslTransportOptions modified_options{options};\n    modified_options.setTlsVersion(tls_version_);\n    return SslIntegrationTestBase::makeSslClientConnection(modified_options);\n  }\n\n  void TearDown() override { SslIntegrationTestBase::TearDown(); };\n\n  ClientSslTransportOptions rsaOnlyClientOptions() {\n    if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n      return ClientSslTransportOptions().setSigningAlgorithms({\"rsa_pss_rsae_sha256\"});\n    } else {\n      return ClientSslTransportOptions().setCipherSuites({\"ECDHE-RSA-AES128-GCM-SHA256\"});\n    }\n  }\n\n  ClientSslTransportOptions ecdsaOnlyClientOptions() {\n    auto options = ClientSslTransportOptions().setClientEcdsaCert(true);\n    if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n      return options.setSigningAlgorithms({\"ecdsa_secp256r1_sha256\"});\n    } else {\n      return options.setCipherSuites({\"ECDHE-ECDSA-AES128-GCM-SHA256\"});\n    }\n  }\n\n  static std::string ipClientVersionTestParamsToString(\n      const ::testing::TestParamInfo<\n          std::tuple<Network::Address::IpVersion,\n                     envoy::extensions::transport_sockets::tls::v3::TlsParameters::TlsProtocol>>&\n          params) {\n    return fmt::format(\"{}_TLSv1_{}\", TestUtility::ipVersionToString(std::get<0>(params.param)),\n                       std::get<1>(params.param) - 1);\n  }\n\n  const envoy::extensions::transport_sockets::tls::v3::TlsParameters::TlsProtocol tls_version_{\n      std::get<1>(GetParam())};\n};\n\nINSTANTIATE_TEST_SUITE_P(\n    IpVersionsClientVersions, SslCertficateIntegrationTest,\n    testing::Combine(\n        testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n        testing::Values(envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2,\n                        envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3)),\n    SslCertficateIntegrationTest::ipClientVersionTestParamsToString);\n\n// Server with an RSA certificate and a client with RSA/ECDSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerRsa) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server with an ECDSA certificate and a client with RSA/ECDSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsa) {\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server with RSA/`ECDSAs` certificates and a client with RSA/ECDSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsa) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server with an RSA certificate and a client with only RSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ClientRsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has only an ECDSA certificate, client is only RSA capable, leads to a connection fail.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientRsaOnly) {\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  initialize();\n  auto codec_client =\n      makeRawHttpConnection(makeSslClientConnection(rsaOnlyClientOptions()), absl::nullopt);\n  EXPECT_FALSE(codec_client->connected());\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  EXPECT_EQ(1U, counter->value());\n  counter->reset();\n}\n\n// Server has only an ECDSA certificate, client is only RSA capable, leads to a connection fail.\n// Test the access log.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientRsaOnlyWithAccessLog) {\n  TestScopedRuntime scoped_runtime;\n  scoped_runtime.mergeValues(\n      {{\"envoy.reloadable_features.ssl_transport_failure_reason_format\", \"true\"}});\n  useListenerAccessLog(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=%DOWNSTREAM_TRANSPORT_FAILURE_REASON% \"\n                       \"FILTER_CHAIN_NAME=%FILTER_CHAIN_NAME%\");\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  initialize();\n  auto codec_client =\n      makeRawHttpConnection(makeSslClientConnection(rsaOnlyClientOptions()), absl::nullopt);\n  EXPECT_FALSE(codec_client->connected());\n\n  auto log_result = waitForAccessLog(listener_access_log_name_);\n  if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n    EXPECT_THAT(log_result,\n                StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:|268435709:SSL_routines:\"\n                           \"OPENSSL_internal:NO_COMMON_SIGNATURE_ALGORITHMS:TLS_error_end\"));\n  } else {\n    EXPECT_THAT(log_result,\n                StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:|268435640:\"\n                           \"SSL_routines:OPENSSL_internal:NO_SHARED_CIPHER:TLS_error_end\"));\n  }\n}\n\n// Server has only an ECDSA certificate, client is only RSA capable, leads to a connection fail.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientRsaOnlyWithAccessLogOriginalFormat) {\n  TestScopedRuntime scoped_runtime;\n  scoped_runtime.mergeValues(\n      {{\"envoy.reloadable_features.ssl_transport_failure_reason_format\", \"false\"}});\n  useListenerAccessLog(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=%DOWNSTREAM_TRANSPORT_FAILURE_REASON% \"\n                       \"FILTER_CHAIN_NAME=%FILTER_CHAIN_NAME%\");\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  initialize();\n  auto codec_client =\n      makeRawHttpConnection(makeSslClientConnection(rsaOnlyClientOptions()), absl::nullopt);\n  EXPECT_FALSE(codec_client->connected());\n\n  auto log_result = waitForAccessLog(listener_access_log_name_);\n  if (tls_version_ == envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3) {\n    EXPECT_THAT(log_result,\n                StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:_268435709:SSL_routines:\"\n                           \"OPENSSL_internal:NO_COMMON_SIGNATURE_ALGORITHMS\"));\n  } else {\n    EXPECT_THAT(log_result, StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=TLS_error:_268435640:\"\n                                       \"SSL_routines:OPENSSL_internal:NO_SHARED_CIPHER\"));\n  }\n}\n\n// Server with RSA/ECDSA certificates and a client with only RSA cipher suites works.\n// Test empty access log with successful connection.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsaClientRsaOnlyWithAccessLog) {\n  useListenerAccessLog(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=%DOWNSTREAM_TRANSPORT_FAILURE_REASON% \"\n                       \"FILTER_CHAIN_NAME=%FILTER_CHAIN_NAME%\");\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  auto log_result = waitForAccessLog(listener_access_log_name_);\n  EXPECT_THAT(log_result, StartsWith(\"DOWNSTREAM_TRANSPORT_FAILURE_REASON=- FILTER_CHAIN_NAME=-\"));\n}\n\n// Server with RSA/ECDSA certificates and a client with only RSA cipher suites works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsaClientRsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has only an RSA certificate, client is only ECDSA capable, leads to connection fail.\nTEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  client_ecdsa_cert_ = true;\n  initialize();\n  EXPECT_FALSE(\n      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()), absl::nullopt)\n          ->connected());\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  EXPECT_EQ(1U, counter->value());\n  counter->reset();\n}\n\n// Server has only an ECDSA certificate, client is only ECDSA capable works.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaClientEcdsaOnly) {\n  server_rsa_cert_ = false;\n  server_ecdsa_cert_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has RSA/ECDSA certificates, client is only ECDSA capable works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaEcdsaClientEcdsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has an RSA certificate with an OCSP response works.\nTEST_P(SslCertficateIntegrationTest, ServerRsaOnlyOcspResponse) {\n  server_rsa_cert_ = true;\n  server_rsa_cert_ocsp_staple_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(rsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has an ECDSA certificate with an OCSP response works.\nTEST_P(SslCertficateIntegrationTest, ServerEcdsaOnlyOcspResponse) {\n  server_ecdsa_cert_ = true;\n  server_ecdsa_cert_ocsp_staple_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has two certificates one with and one without OCSP response works under optional policy.\nTEST_P(SslCertficateIntegrationTest, BothEcdsaAndRsaOnlyRsaOcspResponse) {\n  server_rsa_cert_ = true;\n  server_rsa_cert_ocsp_staple_ = true;\n  server_ecdsa_cert_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n// Server has two certificates, but only ECDSA has OCSP, which should be returned.\nTEST_P(SslCertficateIntegrationTest, BothEcdsaAndRsaOnlyEcdsaOcspResponse) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = true;\n  server_ecdsa_cert_ocsp_staple_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    // Enable OCSP\n    auto client = makeSslClientConnection(ecdsaOnlyClientOptions());\n    const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n        client->ssl().get());\n    SSL_enable_ocsp_stapling(socket->ssl());\n    return client;\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n  // Check that there is an OCSP response\n  const auto* socket = dynamic_cast<const Extensions::TransportSockets::Tls::SslHandshakerImpl*>(\n      codec_client_->connection()->ssl().get());\n  const uint8_t* resp;\n  size_t resp_len;\n  SSL_get0_ocsp_response(socket->ssl(), &resp, &resp_len);\n  EXPECT_NE(0, resp_len);\n}\n\n// Server has ECDSA and RSA certificates with OCSP responses and stapling required policy works.\nTEST_P(SslCertficateIntegrationTest, BothEcdsaAndRsaWithOcspResponseStaplingRequired) {\n  server_rsa_cert_ = true;\n  server_rsa_cert_ocsp_staple_ = true;\n  server_ecdsa_cert_ = true;\n  server_ecdsa_cert_ocsp_staple_ = true;\n  ocsp_staple_required_ = true;\n  client_ecdsa_cert_ = true;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ecdsaOnlyClientOptions());\n  };\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n}\n\n#ifdef ENVOY_ADMIN_FUNCTIONALITY\n// TODO(zuercher): write an additional OCSP integration test that validates behavior with an\n// expired OCSP response. (Requires OCSP client-side support in upstream TLS.)\n\n// TODO(mattklein123): Move this into a dedicated integration test for the tap transport socket as\n// well as add more tests.\nclass SslTapIntegrationTest : public SslIntegrationTest {\npublic:\n  void initialize() override {\n    // TODO(mattklein123): Merge/use the code in ConfigHelper::setTapTransportSocket().\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      // The test supports tapping either the downstream or upstream connection, but not both.\n      if (upstream_tap_) {\n        setupUpstreamTap(bootstrap);\n      } else {\n        setupDownstreamTap(bootstrap);\n      }\n    });\n    SslIntegrationTest::initialize();\n    // This confuses our socket counting.\n    debug_with_s_client_ = false;\n  }\n\n  void setupUpstreamTap(envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* transport_socket =\n        bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n    transport_socket->set_name(\"envoy.transport_sockets.tap\");\n    envoy::config::core::v3::TransportSocket raw_transport_socket;\n    raw_transport_socket.set_name(\"envoy.transport_sockets.raw_buffer\");\n    envoy::extensions::transport_sockets::tap::v3::Tap tap_config =\n        createTapConfig(raw_transport_socket);\n    tap_config.mutable_transport_socket()->MergeFrom(raw_transport_socket);\n    transport_socket->mutable_typed_config()->PackFrom(tap_config);\n  }\n\n  void setupDownstreamTap(envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* filter_chain =\n        bootstrap.mutable_static_resources()->mutable_listeners(0)->mutable_filter_chains(0);\n    // Configure inner SSL transport socket based on existing config.\n    envoy::config::core::v3::TransportSocket ssl_transport_socket;\n    auto* transport_socket = filter_chain->mutable_transport_socket();\n    ssl_transport_socket.Swap(transport_socket);\n    // Configure outer tap transport socket.\n    transport_socket->set_name(\"envoy.transport_sockets.tap\");\n    envoy::extensions::transport_sockets::tap::v3::Tap tap_config =\n        createTapConfig(ssl_transport_socket);\n    tap_config.mutable_transport_socket()->MergeFrom(ssl_transport_socket);\n    transport_socket->mutable_typed_config()->PackFrom(tap_config);\n  }\n\n  envoy::extensions::transport_sockets::tap::v3::Tap\n  createTapConfig(const envoy::config::core::v3::TransportSocket& inner_transport) {\n    envoy::extensions::transport_sockets::tap::v3::Tap tap_config;\n    tap_config.mutable_common_config()->mutable_static_config()->mutable_match()->set_any_match(\n        true);\n    auto* output_config =\n        tap_config.mutable_common_config()->mutable_static_config()->mutable_output_config();\n    if (max_rx_bytes_.has_value()) {\n      output_config->mutable_max_buffered_rx_bytes()->set_value(max_rx_bytes_.value());\n    }\n    if (max_tx_bytes_.has_value()) {\n      output_config->mutable_max_buffered_tx_bytes()->set_value(max_tx_bytes_.value());\n    }\n    output_config->set_streaming(streaming_tap_);\n\n    auto* output_sink = output_config->mutable_sinks()->Add();\n    output_sink->set_format(format_);\n    output_sink->mutable_file_per_tap()->set_path_prefix(path_prefix_);\n    tap_config.mutable_transport_socket()->MergeFrom(inner_transport);\n    return tap_config;\n  }\n\n  std::string path_prefix_ = TestEnvironment::temporaryPath(\"ssl_trace\");\n  envoy::config::tap::v3::OutputSink::Format format_{\n      envoy::config::tap::v3::OutputSink::PROTO_BINARY};\n  absl::optional<uint64_t> max_rx_bytes_;\n  absl::optional<uint64_t> max_tx_bytes_;\n  bool upstream_tap_{};\n  bool streaming_tap_{};\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslTapIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Validate two back-to-back requests with binary proto output.\nTEST_P(SslTapIntegrationTest, TwoRequestsWithBinaryProto) {\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // First request (ID will be +1 since the client will also bump).\n  const uint64_t first_id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  codec_client_ = makeHttpConnection(creator());\n  Http::TestRequestHeaderMapImpl post_request_headers{\n      {\":method\", \"POST\"},       {\":path\", \"/test/long/url\"},\n      {\":scheme\", \"http\"},       {\":authority\", \"sni.lyft.com\"},\n      {\"x-lyft-user-id\", \"123\"}, {\"x-forwarded-for\", \"10.0.0.1\"}};\n  auto response =\n      sendRequestAndWaitForResponse(post_request_headers, 128, default_response_headers_, 256);\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(128, upstream_request_->bodyLength());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(256, response->body().size());\n  checkStats();\n  envoy::config::core::v3::Address expected_local_address;\n  Network::Utility::addressToProtobufAddress(\n      *codec_client_->connection()->connectionInfoProvider().remoteAddress(),\n      expected_local_address);\n  envoy::config::core::v3::Address expected_remote_address;\n  Network::Utility::addressToProtobufAddress(\n      *codec_client_->connection()->connectionInfoProvider().localAddress(),\n      expected_remote_address);\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb\", path_prefix_, first_id), trace, *api_);\n  // Validate general expected properties in the trace.\n  EXPECT_EQ(first_id, trace.socket_buffered_trace().trace_id());\n  EXPECT_THAT(expected_local_address,\n              ProtoEq(trace.socket_buffered_trace().connection().local_address()));\n  EXPECT_THAT(expected_remote_address,\n              ProtoEq(trace.socket_buffered_trace().connection().remote_address()));\n  ASSERT_GE(trace.socket_buffered_trace().events().size(), 2);\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(0).read().data().as_bytes(),\n                               \"POST /test/long/url HTTP/1.1\"));\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(1).write().data().as_bytes(),\n                               \"HTTP/1.1 200 OK\"));\n  EXPECT_FALSE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_FALSE(trace.socket_buffered_trace().write_truncated());\n\n  // Verify a second request hits a different file.\n  const uint64_t second_id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  codec_client_ = makeHttpConnection(creator());\n  Http::TestRequestHeaderMapImpl get_request_headers{\n      {\":method\", \"GET\"},        {\":path\", \"/test/long/url\"},\n      {\":scheme\", \"http\"},       {\":authority\", \"sni.lyft.com\"},\n      {\"x-lyft-user-id\", \"123\"}, {\"x-forwarded-for\", \"10.0.0.1\"}};\n  response =\n      sendRequestAndWaitForResponse(get_request_headers, 128, default_response_headers_, 256);\n  EXPECT_TRUE(upstream_request_->complete());\n  EXPECT_EQ(128, upstream_request_->bodyLength());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  EXPECT_EQ(256, response->body().size());\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 2);\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb\", path_prefix_, second_id), trace, *api_);\n  // Validate second connection ID.\n  EXPECT_EQ(second_id, trace.socket_buffered_trace().trace_id());\n  ASSERT_GE(trace.socket_buffered_trace().events().size(), 2);\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(0).read().data().as_bytes(),\n                               \"GET /test/long/url HTTP/1.1\"));\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(1).write().data().as_bytes(),\n                               \"HTTP/1.1 200 OK\"));\n  EXPECT_FALSE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_FALSE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Verify that truncation works correctly across multiple transport socket frames.\nTEST_P(SslTapIntegrationTest, TruncationWithMultipleDataFrames) {\n  max_rx_bytes_ = 4;\n  max_tx_bytes_ = 5;\n\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"GET\"},\n                                                       {\":path\", \"/test/long/url\"},\n                                                       {\":scheme\", \"http\"},\n                                                       {\":authority\", \"sni.lyft.com\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  auto response = std::move(result.second);\n  Buffer::OwnedImpl data1(\"one\");\n  result.first.encodeData(data1, false);\n  Buffer::OwnedImpl data2(\"two\");\n  result.first.encodeData(data2, true);\n  waitForNextUpstreamRequest();\n  const Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, false);\n  Buffer::OwnedImpl data3(\"three\");\n  upstream_request_->encodeData(data3, false);\n  response->waitForBodyData(5);\n  Buffer::OwnedImpl data4(\"four\");\n  upstream_request_->encodeData(data4, true);\n  ASSERT_TRUE(response->waitForEndStream());\n\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb\", path_prefix_, id), trace, *api_);\n\n  ASSERT_EQ(trace.socket_buffered_trace().events().size(), 2);\n  EXPECT_TRUE(trace.socket_buffered_trace().events(0).read().data().truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().events(1).write().data().truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Validate a single request with text proto output.\nTEST_P(SslTapIntegrationTest, RequestWithTextProto) {\n  format_ = envoy::config::tap::v3::OutputSink::PROTO_TEXT;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // Disable for this test because it uses connection IDs, which disrupts the accounting below\n  // leading to the wrong path for the `pb_text` being used.\n  skip_tag_extraction_rule_check_ = true;\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 1;\n  testRouterRequestAndResponseWithBody(1024, 512, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.pb_text\", path_prefix_, id), trace, *api_);\n  // Test some obvious properties.\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(0).read().data().as_bytes(),\n                               \"GET /test/long/url HTTP/1.1\"));\n  EXPECT_TRUE(absl::StartsWith(trace.socket_buffered_trace().events(1).write().data().as_bytes(),\n                               \"HTTP/1.1 200 OK\"));\n  EXPECT_TRUE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_FALSE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Validate a single request with JSON (body as string) output. This test uses an upstream tap.\nTEST_P(SslTapIntegrationTest, RequestWithJsonBodyAsStringUpstreamTap) {\n  upstream_tap_ = true;\n  max_rx_bytes_ = 5;\n  max_tx_bytes_ = 4;\n\n  format_ = envoy::config::tap::v3::OutputSink::JSON_BODY_AS_STRING;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // Disable for this test because it uses connection IDs, which disrupts the accounting below\n  // leading to the wrong path for the `pb_text` being used.\n  skip_tag_extraction_rule_check_ = true;\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 2;\n  testRouterRequestAndResponseWithBody(512, 1024, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  test_server_.reset();\n\n  // This must be done after server shutdown so that connection pool connections are closed and\n  // the tap written.\n  envoy::data::tap::v3::TraceWrapper trace;\n  TestUtility::loadFromFile(fmt::format(\"{}_{}.json\", path_prefix_, id), trace, *api_);\n\n  // Test some obvious properties.\n  EXPECT_EQ(trace.socket_buffered_trace().events(0).write().data().as_string(), \"GET \");\n  EXPECT_EQ(trace.socket_buffered_trace().events(1).read().data().as_string(), \"HTTP/\");\n  EXPECT_TRUE(trace.socket_buffered_trace().read_truncated());\n  EXPECT_TRUE(trace.socket_buffered_trace().write_truncated());\n}\n\n// Validate a single request with length delimited binary proto output. This test uses an upstream\n// tap.\nTEST_P(SslTapIntegrationTest, RequestWithStreamingUpstreamTap) {\n  upstream_tap_ = true;\n  streaming_tap_ = true;\n  max_rx_bytes_ = 5;\n  max_tx_bytes_ = 4;\n\n  format_ = envoy::config::tap::v3::OutputSink::PROTO_BINARY_LENGTH_DELIMITED;\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n\n  // Disable for this test because it uses connection IDs, which disrupts the accounting below\n  // leading to the wrong path for the `pb_text` being used.\n  skip_tag_extraction_rule_check_ = true;\n\n  const uint64_t id = Network::ConnectionImpl::nextGlobalIdForTest() + 2;\n  testRouterRequestAndResponseWithBody(512, 1024, false, false, &creator);\n  checkStats();\n  codec_client_->close();\n  test_server_->waitForCounterGe(\"http.config_test.downstream_cx_destroy\", 1);\n  test_server_.reset();\n\n  // This must be done after server shutdown so that connection pool connections are closed and\n  // the tap written.\n  std::vector<envoy::data::tap::v3::TraceWrapper> traces =\n      Extensions::Common::Tap::readTracesFromFile(\n          fmt::format(\"{}_{}.pb_length_delimited\", path_prefix_, id));\n  ASSERT_GE(traces.size(), 4);\n\n  // The initial connection message has no local address, but has a remote address (not connected\n  // yet).\n  EXPECT_TRUE(traces[0].socket_streamed_trace_segment().has_connection());\n  EXPECT_FALSE(traces[0].socket_streamed_trace_segment().connection().has_local_address());\n  EXPECT_TRUE(traces[0].socket_streamed_trace_segment().connection().has_remote_address());\n\n  // Verify truncated request/response data.\n  EXPECT_EQ(traces[1].socket_streamed_trace_segment().event().write().data().as_bytes(), \"GET \");\n  EXPECT_TRUE(traces[1].socket_streamed_trace_segment().event().write().data().truncated());\n  EXPECT_EQ(traces[2].socket_streamed_trace_segment().event().read().data().as_bytes(), \"HTTP/\");\n  EXPECT_TRUE(traces[2].socket_streamed_trace_segment().event().read().data().truncated());\n}\n#endif\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslKeyLogTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(SslKeyLogTest, SetLocalFilter) {\n  setLogPath();\n  setLocalFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetRemoteFilter) {\n  setLogPath();\n  setRemoteFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetLocalAndRemoteFilter) {\n  setLogPath();\n  setBothLocalAndRemoteFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetNeitherLocalNorRemoteFilter) {\n  setLogPath();\n  setNeitherLocalNorRemoteFilter();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\nTEST_P(SslKeyLogTest, SetLocalAndRemoteFilterNegative) {\n  setLogPath();\n  setNegative();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  negativeCheck();\n}\n\nTEST_P(SslKeyLogTest, SetLocalNegative) {\n  setLogPath();\n  setLocalNegative();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  negativeCheck();\n}\n\nTEST_P(SslKeyLogTest, SetRemoteNegative) {\n  setLogPath();\n  setRemoteNegative();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  negativeCheck();\n}\n\nTEST_P(SslKeyLogTest, SetMultipleIps) {\n  setLogPath();\n  setMultipleIps();\n  initialize();\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection({});\n  };\n  codec_client_ = makeHttpConnection(creator());\n  const Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  auto result = codec_client_->startRequest(request_headers);\n  codec_client_->close();\n  logCheck();\n}\n\n} // namespace Ssl\n} // namespace Envoy\n"], "filenames": ["changelogs/current.yaml", "source/common/network/BUILD", "source/common/network/address_impl.cc", "source/common/network/address_impl.h", "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc", "source/extensions/transport_sockets/tls/connection_info_impl_base.cc", "source/extensions/transport_sockets/tls/utility.cc", "source/extensions/transport_sockets/tls/utility.h", "test/config/integration/certs/clientcert.cfg", "test/config/integration/certs/clientcert.pem", "test/config/integration/certs/clientcert_hash.h", "test/config/integration/certs/clientkey.pem", "test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc", "test/extensions/transport_sockets/tls/integration/ssl_integration_test.cc"], "buggy_code_start_loc": [60, 22, 214, 13, 279, 188, 170, 54, 41, 2, 4, 1, 13, 464], "buggy_code_end_loc": [60, 22, 330, 227, 310, 189, 180, 58, 41, 27, 6, 28, 390, 464], "fixing_code_start_loc": [61, 23, 215, 14, 279, 188, 170, 55, 42, 2, 4, 1, 14, 465], "fixing_code_end_loc": [70, 24, 350, 244, 328, 189, 188, 60, 44, 27, 6, 29, 434, 506], "type": "CWE-755", "message": "Envoy is a high-performance edge/middle/service proxy. Envoy crashes in Proxy protocol when using an address type that isn\u2019t supported by the OS. Envoy is susceptible to crashing on a host with IPv6 disabled and a listener config with proxy protocol enabled when it receives a request where the client presents its IPv6 address.  It is valid for a client to present its IPv6 address to a target server even though the whole chain is connected via IPv4. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2024-23325", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-09T23:15:09.437", "lastModified": "2024-02-15T04:46:07.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is a high-performance edge/middle/service proxy. Envoy crashes in Proxy protocol when using an address type that isn\u2019t supported by the OS. Envoy is susceptible to crashing on a host with IPv6 disabled and a listener config with proxy protocol enabled when it receives a request where the client presents its IPv6 address.  It is valid for a client to present its IPv6 address to a target server even though the whole chain is connected via IPv4. This issue has been addressed in released 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Envoy es un proxy de servicio/intermedio/perimetral de alto rendimiento. Envoy falla en el protocolo Proxy cuando usa un tipo de direcci\u00f3n que no es compatible con el sistema operativo. Envoy es susceptible de fallar en un host con IPv6 deshabilitado y una configuraci\u00f3n de escucha con protocolo proxy habilitado cuando recibe una solicitud en la que el cliente presenta su direcci\u00f3n IPv6. Es v\u00e1lido que un cliente presente su direcci\u00f3n IPv6 a un servidor de destino aunque toda la cadena est\u00e9 conectada a trav\u00e9s de IPv4. Este problema se solucion\u00f3 en las versiones 1.29.1, 1.28.1, 1.27.3 y 1.26.7. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-248"}, {"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.26.0", "versionEndExcluding": "1.26.7", "matchCriteriaId": "0324E095-98B4-4B78-9242-989EC45E011F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.27.0", "versionEndExcluding": "1.27.3", "matchCriteriaId": "2E838B16-C6DC-4701-B955-D96D4CAEF4F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.28.0", "versionEndExcluding": "1.28.1", "matchCriteriaId": "770D5713-48E3-4F9B-B05C-9CB9C6B272E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.29.0", "versionEndExcluding": "1.29.1", "matchCriteriaId": "638F3351-3ACD-47C8-9B8F-568A930FAECA"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-5m7c-mrwr-pm26", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/bacd3107455b8d387889467725eb72aa0d5b5237"}}