{"buggy_code": ["/*\n * CCM: Counter with CBC-MAC\n *\n * (C) Copyright IBM Corp. 2007 - Joy Latten <latten@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/internal/aead.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\nstruct ccm_instance_ctx {\n\tstruct crypto_skcipher_spawn ctr;\n\tstruct crypto_ahash_spawn mac;\n};\n\nstruct crypto_ccm_ctx {\n\tstruct crypto_ahash *mac;\n\tstruct crypto_skcipher *ctr;\n};\n\nstruct crypto_rfc4309_ctx {\n\tstruct crypto_aead *child;\n\tu8 nonce[3];\n};\n\nstruct crypto_rfc4309_req_ctx {\n\tstruct scatterlist src[3];\n\tstruct scatterlist dst[3];\n\tstruct aead_request subreq;\n};\n\nstruct crypto_ccm_req_priv_ctx {\n\tu8 odata[16];\n\tu8 auth_tag[16];\n\tu32 flags;\n\tstruct scatterlist src[3];\n\tstruct scatterlist dst[3];\n\tstruct skcipher_request skreq;\n};\n\nstruct cbcmac_tfm_ctx {\n\tstruct crypto_cipher *child;\n};\n\nstruct cbcmac_desc_ctx {\n\tunsigned int len;\n};\n\nstatic inline struct crypto_ccm_req_priv_ctx *crypto_ccm_reqctx(\n\tstruct aead_request *req)\n{\n\tunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\n\n\treturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\n}\n\nstatic int set_msg_len(u8 *block, unsigned int msglen, int csize)\n{\n\t__be32 data;\n\n\tmemset(block, 0, csize);\n\tblock += csize;\n\n\tif (csize >= 4)\n\t\tcsize = 4;\n\telse if (msglen > (1 << (8 * csize)))\n\t\treturn -EOVERFLOW;\n\n\tdata = cpu_to_be32(msglen);\n\tmemcpy(block - csize, (u8 *)&data + 4 - csize, csize);\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_skcipher *ctr = ctx->ctr;\n\tstruct crypto_ahash *mac = ctx->mac;\n\tint err = 0;\n\n\tcrypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\n\t\t\t\t       CRYPTO_TFM_REQ_MASK);\n\terr = crypto_skcipher_setkey(ctr, key, keylen);\n\tcrypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &\n\t\t\t      CRYPTO_TFM_RES_MASK);\n\tif (err)\n\t\tgoto out;\n\n\tcrypto_ahash_clear_flags(mac, CRYPTO_TFM_REQ_MASK);\n\tcrypto_ahash_set_flags(mac, crypto_aead_get_flags(aead) &\n\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\terr = crypto_ahash_setkey(mac, key, keylen);\n\tcrypto_aead_set_flags(aead, crypto_ahash_get_flags(mac) &\n\t\t\t      CRYPTO_TFM_RES_MASK);\n\nout:\n\treturn err;\n}\n\nstatic int crypto_ccm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t  unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int format_input(u8 *info, struct aead_request *req,\n\t\t\tunsigned int cryptlen)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int lp = req->iv[0];\n\tunsigned int l = lp + 1;\n\tunsigned int m;\n\n\tm = crypto_aead_authsize(aead);\n\n\tmemcpy(info, req->iv, 16);\n\n\t/* format control info per RFC 3610 and\n\t * NIST Special Publication 800-38C\n\t */\n\t*info |= (8 * ((m - 2) / 2));\n\tif (req->assoclen)\n\t\t*info |= 64;\n\n\treturn set_msg_len(info + 16 - l, cryptlen, l);\n}\n\nstatic int format_adata(u8 *adata, unsigned int a)\n{\n\tint len = 0;\n\n\t/* add control info for associated data\n\t * RFC 3610 and NIST Special Publication 800-38C\n\t */\n\tif (a < 65280) {\n\t\t*(__be16 *)adata = cpu_to_be16(a);\n\t\tlen = 2;\n\t} else  {\n\t\t*(__be16 *)adata = cpu_to_be16(0xfffe);\n\t\t*(__be32 *)&adata[2] = cpu_to_be32(a);\n\t\tlen = 6;\n\t}\n\n\treturn len;\n}\n\nstatic int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n\tint ilen, err;\n\n\t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}\n\nstatic void crypto_ccm_encrypt_done(struct crypto_async_request *areq, int err)\n{\n\tstruct aead_request *req = areq->data;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tu8 *odata = pctx->odata;\n\n\tif (!err)\n\t\tscatterwalk_map_and_copy(odata, req->dst,\n\t\t\t\t\t req->assoclen + req->cryptlen,\n\t\t\t\t\t crypto_aead_authsize(aead), 1);\n\taead_request_complete(req, err);\n}\n\nstatic inline int crypto_ccm_check_iv(const u8 *iv)\n{\n\t/* 2 <= L <= 8, so 1 <= L' <= 7. */\n\tif (1 > iv[0] || iv[0] > 7)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_init_crypt(struct aead_request *req, u8 *tag)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct scatterlist *sg;\n\tu8 *iv = req->iv;\n\tint err;\n\n\terr = crypto_ccm_check_iv(iv);\n\tif (err)\n\t\treturn err;\n\n\tpctx->flags = aead_request_flags(req);\n\n\t /* Note: rfc 3610 and NIST 800-38C require counter of\n\t * zero to encrypt auth tag.\n\t */\n\tmemset(iv + 15 - iv[0], 0, iv[0] + 1);\n\n\tsg_init_table(pctx->src, 3);\n\tsg_set_buf(pctx->src, tag, 16);\n\tsg = scatterwalk_ffwd(pctx->src + 1, req->src, req->assoclen);\n\tif (sg != pctx->src + 1)\n\t\tsg_chain(pctx->src, 2, sg);\n\n\tif (req->src != req->dst) {\n\t\tsg_init_table(pctx->dst, 3);\n\t\tsg_set_buf(pctx->dst, tag, 16);\n\t\tsg = scatterwalk_ffwd(pctx->dst + 1, req->dst, req->assoclen);\n\t\tif (sg != pctx->dst + 1)\n\t\t\tsg_chain(pctx->dst, 2, sg);\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct skcipher_request *skreq = &pctx->skreq;\n\tstruct scatterlist *dst;\n\tunsigned int cryptlen = req->cryptlen;\n\tu8 *odata = pctx->odata;\n\tu8 *iv = req->iv;\n\tint err;\n\n\terr = crypto_ccm_init_crypt(req, odata);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_ccm_auth(req, sg_next(pctx->src), cryptlen);\n\tif (err)\n\t\treturn err;\n\n\tdst = pctx->src;\n\tif (req->src != req->dst)\n\t\tdst = pctx->dst;\n\n\tskcipher_request_set_tfm(skreq, ctx->ctr);\n\tskcipher_request_set_callback(skreq, pctx->flags,\n\t\t\t\t      crypto_ccm_encrypt_done, req);\n\tskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\n\terr = crypto_skcipher_encrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\t/* copy authtag to end of dst */\n\tscatterwalk_map_and_copy(odata, sg_next(dst), cryptlen,\n\t\t\t\t crypto_aead_authsize(aead), 1);\n\treturn err;\n}\n\nstatic void crypto_ccm_decrypt_done(struct crypto_async_request *areq,\n\t\t\t\t   int err)\n{\n\tstruct aead_request *req = areq->data;\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tunsigned int cryptlen = req->cryptlen - authsize;\n\tstruct scatterlist *dst;\n\n\tpctx->flags = 0;\n\n\tdst = sg_next(req->src == req->dst ? pctx->src : pctx->dst);\n\n\tif (!err) {\n\t\terr = crypto_ccm_auth(req, dst, cryptlen);\n\t\tif (!err && crypto_memneq(pctx->auth_tag, pctx->odata, authsize))\n\t\t\terr = -EBADMSG;\n\t}\n\taead_request_complete(req, err);\n}\n\nstatic int crypto_ccm_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct skcipher_request *skreq = &pctx->skreq;\n\tstruct scatterlist *dst;\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tunsigned int cryptlen = req->cryptlen;\n\tu8 *authtag = pctx->auth_tag;\n\tu8 *odata = pctx->odata;\n\tu8 *iv = req->iv;\n\tint err;\n\n\tcryptlen -= authsize;\n\n\terr = crypto_ccm_init_crypt(req, authtag);\n\tif (err)\n\t\treturn err;\n\n\tscatterwalk_map_and_copy(authtag, sg_next(pctx->src), cryptlen,\n\t\t\t\t authsize, 0);\n\n\tdst = pctx->src;\n\tif (req->src != req->dst)\n\t\tdst = pctx->dst;\n\n\tskcipher_request_set_tfm(skreq, ctx->ctr);\n\tskcipher_request_set_callback(skreq, pctx->flags,\n\t\t\t\t      crypto_ccm_decrypt_done, req);\n\tskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\n\terr = crypto_skcipher_decrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_ccm_auth(req, sg_next(dst), cryptlen);\n\tif (err)\n\t\treturn err;\n\n\t/* verify */\n\tif (crypto_memneq(authtag, odata, authsize))\n\t\treturn -EBADMSG;\n\n\treturn err;\n}\n\nstatic int crypto_ccm_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct ccm_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_ahash *mac;\n\tstruct crypto_skcipher *ctr;\n\tunsigned long align;\n\tint err;\n\n\tmac = crypto_spawn_ahash(&ictx->mac);\n\tif (IS_ERR(mac))\n\t\treturn PTR_ERR(mac);\n\n\tctr = crypto_spawn_skcipher(&ictx->ctr);\n\terr = PTR_ERR(ctr);\n\tif (IS_ERR(ctr))\n\t\tgoto err_free_mac;\n\n\tctx->mac = mac;\n\tctx->ctr = ctr;\n\n\talign = crypto_aead_alignmask(tfm);\n\talign &= ~(crypto_tfm_ctx_alignment() - 1);\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\talign + sizeof(struct crypto_ccm_req_priv_ctx) +\n\t\tcrypto_skcipher_reqsize(ctr));\n\n\treturn 0;\n\nerr_free_mac:\n\tcrypto_free_ahash(mac);\n\treturn err;\n}\n\nstatic void crypto_ccm_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_ahash(ctx->mac);\n\tcrypto_free_skcipher(ctx->ctr);\n}\n\nstatic void crypto_ccm_free(struct aead_instance *inst)\n{\n\tstruct ccm_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_ahash(&ctx->mac);\n\tcrypto_drop_skcipher(&ctx->ctr);\n\tkfree(inst);\n}\n\nstatic int crypto_ccm_create_common(struct crypto_template *tmpl,\n\t\t\t\t    struct rtattr **tb,\n\t\t\t\t    const char *full_name,\n\t\t\t\t    const char *ctr_name,\n\t\t\t\t    const char *mac_name)\n{\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct skcipher_alg *ctr;\n\tstruct crypto_alg *mac_alg;\n\tstruct hash_alg_common *mac;\n\tstruct ccm_instance_ctx *ictx;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\n\t\treturn -EINVAL;\n\n\tmac_alg = crypto_find_alg(mac_name, &crypto_ahash_type,\n\t\t\t\t  CRYPTO_ALG_TYPE_HASH,\n\t\t\t\t  CRYPTO_ALG_TYPE_AHASH_MASK |\n\t\t\t\t  CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(mac_alg))\n\t\treturn PTR_ERR(mac_alg);\n\n\tmac = __crypto_hash_alg_common(mac_alg);\n\terr = -EINVAL;\n\tif (mac->digestsize != 16)\n\t\tgoto out_put_mac;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ictx), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!inst)\n\t\tgoto out_put_mac;\n\n\tictx = aead_instance_ctx(inst);\n\terr = crypto_init_ahash_spawn(&ictx->mac, mac,\n\t\t\t\t      aead_crypto_instance(inst));\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tcrypto_set_skcipher_spawn(&ictx->ctr, aead_crypto_instance(inst));\n\terr = crypto_grab_skcipher(&ictx->ctr, ctr_name, 0,\n\t\t\t\t   crypto_requires_sync(algt->type,\n\t\t\t\t\t\t\talgt->mask));\n\tif (err)\n\t\tgoto err_drop_mac;\n\n\tctr = crypto_spawn_skcipher_alg(&ictx->ctr);\n\n\t/* Not a stream cipher? */\n\terr = -EINVAL;\n\tif (ctr->base.cra_blocksize != 1)\n\t\tgoto err_drop_ctr;\n\n\t/* We want the real thing! */\n\tif (crypto_skcipher_alg_ivsize(ctr) != 16)\n\t\tgoto err_drop_ctr;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"ccm_base(%s,%s)\", ctr->base.cra_driver_name,\n\t\t     mac->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_drop_ctr;\n\n\tmemcpy(inst->alg.base.cra_name, full_name, CRYPTO_MAX_ALG_NAME);\n\n\tinst->alg.base.cra_flags = ctr->base.cra_flags & CRYPTO_ALG_ASYNC;\n\tinst->alg.base.cra_priority = (mac->base.cra_priority +\n\t\t\t\t       ctr->base.cra_priority) / 2;\n\tinst->alg.base.cra_blocksize = 1;\n\tinst->alg.base.cra_alignmask = mac->base.cra_alignmask |\n\t\t\t\t       ctr->base.cra_alignmask;\n\tinst->alg.ivsize = 16;\n\tinst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);\n\tinst->alg.maxauthsize = 16;\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_ccm_ctx);\n\tinst->alg.init = crypto_ccm_init_tfm;\n\tinst->alg.exit = crypto_ccm_exit_tfm;\n\tinst->alg.setkey = crypto_ccm_setkey;\n\tinst->alg.setauthsize = crypto_ccm_setauthsize;\n\tinst->alg.encrypt = crypto_ccm_encrypt;\n\tinst->alg.decrypt = crypto_ccm_decrypt;\n\n\tinst->free = crypto_ccm_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto err_drop_ctr;\n\nout_put_mac:\n\tcrypto_mod_put(mac_alg);\n\treturn err;\n\nerr_drop_ctr:\n\tcrypto_drop_skcipher(&ictx->ctr);\nerr_drop_mac:\n\tcrypto_drop_ahash(&ictx->mac);\nerr_free_inst:\n\tkfree(inst);\n\tgoto out_put_mac;\n}\n\nstatic int crypto_ccm_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tconst char *cipher_name;\n\tchar ctr_name[CRYPTO_MAX_ALG_NAME];\n\tchar mac_name[CRYPTO_MAX_ALG_NAME];\n\tchar full_name[CRYPTO_MAX_ALG_NAME];\n\n\tcipher_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(cipher_name))\n\t\treturn PTR_ERR(cipher_name);\n\n\tif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, \"ctr(%s)\",\n\t\t     cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\tif (snprintf(mac_name, CRYPTO_MAX_ALG_NAME, \"cbcmac(%s)\",\n\t\t     cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\tif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, \"ccm(%s)\", cipher_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\treturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\n\t\t\t\t\tmac_name);\n}\n\nstatic struct crypto_template crypto_ccm_tmpl = {\n\t.name = \"ccm\",\n\t.create = crypto_ccm_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int crypto_ccm_base_create(struct crypto_template *tmpl,\n\t\t\t\t  struct rtattr **tb)\n{\n\tconst char *ctr_name;\n\tconst char *cipher_name;\n\tchar full_name[CRYPTO_MAX_ALG_NAME];\n\n\tctr_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(ctr_name))\n\t\treturn PTR_ERR(ctr_name);\n\n\tcipher_name = crypto_attr_alg_name(tb[2]);\n\tif (IS_ERR(cipher_name))\n\t\treturn PTR_ERR(cipher_name);\n\n\tif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, \"ccm_base(%s,%s)\",\n\t\t     ctr_name, cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\treturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\n\t\t\t\t\tcipher_name);\n}\n\nstatic struct crypto_template crypto_ccm_base_tmpl = {\n\t.name = \"ccm_base\",\n\t.create = crypto_ccm_base_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\n\tstruct crypto_aead *child = ctx->child;\n\tint err;\n\n\tif (keylen < 3)\n\t\treturn -EINVAL;\n\n\tkeylen -= 3;\n\tmemcpy(ctx->nonce, key + keylen, 3);\n\n\tcrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\n\t\t\t\t     CRYPTO_TFM_REQ_MASK);\n\terr = crypto_aead_setkey(child, key, keylen);\n\tcrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\n\t\t\t\t      CRYPTO_TFM_RES_MASK);\n\n\treturn err;\n}\n\nstatic int crypto_rfc4309_setauthsize(struct crypto_aead *parent,\n\t\t\t\t      unsigned int authsize)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\n\n\tswitch (authsize) {\n\tcase 8:\n\tcase 12:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn crypto_aead_setauthsize(ctx->child, authsize);\n}\n\nstatic struct aead_request *crypto_rfc4309_crypt(struct aead_request *req)\n{\n\tstruct crypto_rfc4309_req_ctx *rctx = aead_request_ctx(req);\n\tstruct aead_request *subreq = &rctx->subreq;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_aead *child = ctx->child;\n\tstruct scatterlist *sg;\n\tu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\n\t\t\t   crypto_aead_alignmask(child) + 1);\n\n\t/* L' */\n\tiv[0] = 3;\n\n\tmemcpy(iv + 1, ctx->nonce, 3);\n\tmemcpy(iv + 4, req->iv, 8);\n\n\tscatterwalk_map_and_copy(iv + 16, req->src, 0, req->assoclen - 8, 0);\n\n\tsg_init_table(rctx->src, 3);\n\tsg_set_buf(rctx->src, iv + 16, req->assoclen - 8);\n\tsg = scatterwalk_ffwd(rctx->src + 1, req->src, req->assoclen);\n\tif (sg != rctx->src + 1)\n\t\tsg_chain(rctx->src, 2, sg);\n\n\tif (req->src != req->dst) {\n\t\tsg_init_table(rctx->dst, 3);\n\t\tsg_set_buf(rctx->dst, iv + 16, req->assoclen - 8);\n\t\tsg = scatterwalk_ffwd(rctx->dst + 1, req->dst, req->assoclen);\n\t\tif (sg != rctx->dst + 1)\n\t\t\tsg_chain(rctx->dst, 2, sg);\n\t}\n\n\taead_request_set_tfm(subreq, child);\n\taead_request_set_callback(subreq, req->base.flags, req->base.complete,\n\t\t\t\t  req->base.data);\n\taead_request_set_crypt(subreq, rctx->src,\n\t\t\t       req->src == req->dst ? rctx->src : rctx->dst,\n\t\t\t       req->cryptlen, iv);\n\taead_request_set_ad(subreq, req->assoclen - 8);\n\n\treturn subreq;\n}\n\nstatic int crypto_rfc4309_encrypt(struct aead_request *req)\n{\n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treq = crypto_rfc4309_crypt(req);\n\n\treturn crypto_aead_encrypt(req);\n}\n\nstatic int crypto_rfc4309_decrypt(struct aead_request *req)\n{\n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treq = crypto_rfc4309_crypt(req);\n\n\treturn crypto_aead_decrypt(req);\n}\n\nstatic int crypto_rfc4309_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct crypto_aead_spawn *spawn = aead_instance_ctx(inst);\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_aead *aead;\n\tunsigned long align;\n\n\taead = crypto_spawn_aead(spawn);\n\tif (IS_ERR(aead))\n\t\treturn PTR_ERR(aead);\n\n\tctx->child = aead;\n\n\talign = crypto_aead_alignmask(aead);\n\talign &= ~(crypto_tfm_ctx_alignment() - 1);\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\tsizeof(struct crypto_rfc4309_req_ctx) +\n\t\tALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +\n\t\talign + 32);\n\n\treturn 0;\n}\n\nstatic void crypto_rfc4309_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_aead(ctx->child);\n}\n\nstatic void crypto_rfc4309_free(struct aead_instance *inst)\n{\n\tcrypto_drop_aead(aead_instance_ctx(inst));\n\tkfree(inst);\n}\n\nstatic int crypto_rfc4309_create(struct crypto_template *tmpl,\n\t\t\t\t struct rtattr **tb)\n{\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct crypto_aead_spawn *spawn;\n\tstruct aead_alg *alg;\n\tconst char *ccm_name;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\n\t\treturn -EINVAL;\n\n\tccm_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(ccm_name))\n\t\treturn PTR_ERR(ccm_name);\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tspawn = aead_instance_ctx(inst);\n\tcrypto_set_aead_spawn(spawn, aead_crypto_instance(inst));\n\terr = crypto_grab_aead(spawn, ccm_name, 0,\n\t\t\t       crypto_requires_sync(algt->type, algt->mask));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\talg = crypto_spawn_aead_alg(spawn);\n\n\terr = -EINVAL;\n\n\t/* We only support 16-byte blocks. */\n\tif (crypto_aead_alg_ivsize(alg) != 16)\n\t\tgoto out_drop_alg;\n\n\t/* Not a stream cipher? */\n\tif (alg->base.cra_blocksize != 1)\n\t\tgoto out_drop_alg;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4309(%s)\", alg->base.cra_name) >=\n\t    CRYPTO_MAX_ALG_NAME ||\n\t    snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4309(%s)\", alg->base.cra_driver_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_drop_alg;\n\n\tinst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\n\tinst->alg.base.cra_priority = alg->base.cra_priority;\n\tinst->alg.base.cra_blocksize = 1;\n\tinst->alg.base.cra_alignmask = alg->base.cra_alignmask;\n\n\tinst->alg.ivsize = 8;\n\tinst->alg.chunksize = crypto_aead_alg_chunksize(alg);\n\tinst->alg.maxauthsize = 16;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc4309_ctx);\n\n\tinst->alg.init = crypto_rfc4309_init_tfm;\n\tinst->alg.exit = crypto_rfc4309_exit_tfm;\n\n\tinst->alg.setkey = crypto_rfc4309_setkey;\n\tinst->alg.setauthsize = crypto_rfc4309_setauthsize;\n\tinst->alg.encrypt = crypto_rfc4309_encrypt;\n\tinst->alg.decrypt = crypto_rfc4309_decrypt;\n\n\tinst->free = crypto_rfc4309_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto out_drop_alg;\n\nout:\n\treturn err;\n\nout_drop_alg:\n\tcrypto_drop_aead(spawn);\nout_free_inst:\n\tkfree(inst);\n\tgoto out;\n}\n\nstatic struct crypto_template crypto_rfc4309_tmpl = {\n\t.name = \"rfc4309\",\n\t.create = crypto_rfc4309_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int crypto_cbcmac_digest_setkey(struct crypto_shash *parent,\n\t\t\t\t     const u8 *inkey, unsigned int keylen)\n{\n\tstruct cbcmac_tfm_ctx *ctx = crypto_shash_ctx(parent);\n\n\treturn crypto_cipher_setkey(ctx->child, inkey, keylen);\n}\n\nstatic int crypto_cbcmac_digest_init(struct shash_desc *pdesc)\n{\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tint bs = crypto_shash_digestsize(pdesc->tfm);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(pdesc->tfm) - bs;\n\n\tctx->len = 0;\n\tmemset(dg, 0, bs);\n\n\treturn 0;\n}\n\nstatic int crypto_cbcmac_digest_update(struct shash_desc *pdesc, const u8 *p,\n\t\t\t\t       unsigned int len)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\twhile (len > 0) {\n\t\tunsigned int l = min(len, bs - ctx->len);\n\n\t\tcrypto_xor(dg + ctx->len, p, l);\n\t\tctx->len +=l;\n\t\tlen -= l;\n\t\tp += l;\n\n\t\tif (ctx->len == bs) {\n\t\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\t\t\tctx->len = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_cbcmac_digest_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\tif (ctx->len)\n\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\n\tmemcpy(out, dg, bs);\n\treturn 0;\n}\n\nstatic int cbcmac_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_instance *inst = (void *)tfm->__crt_alg;\n\tstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\n\tstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcipher = crypto_spawn_cipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n};\n\nstatic void cbcmac_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\tcrypto_free_cipher(ctx->child);\n}\n\nstatic int cbcmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\n\talg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\n\t\t\t\t  CRYPTO_ALG_TYPE_MASK);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tinst = shash_alloc_instance(\"cbcmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\terr = crypto_init_spawn(shash_instance_ctx(inst), alg,\n\t\t\t\tshash_crypto_instance(inst),\n\t\t\t\tCRYPTO_ALG_TYPE_MASK);\n\tif (err)\n\t\tgoto out_free_inst;\n\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = 1;\n\n\tinst->alg.digestsize = alg->cra_blocksize;\n\tinst->alg.descsize = ALIGN(sizeof(struct cbcmac_desc_ctx),\n\t\t\t\t   alg->cra_alignmask + 1) +\n\t\t\t     alg->cra_blocksize;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct cbcmac_tfm_ctx);\n\tinst->alg.base.cra_init = cbcmac_init_tfm;\n\tinst->alg.base.cra_exit = cbcmac_exit_tfm;\n\n\tinst->alg.init = crypto_cbcmac_digest_init;\n\tinst->alg.update = crypto_cbcmac_digest_update;\n\tinst->alg.final = crypto_cbcmac_digest_final;\n\tinst->alg.setkey = crypto_cbcmac_digest_setkey;\n\n\terr = shash_register_instance(tmpl, inst);\n\nout_free_inst:\n\tif (err)\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n\nstatic struct crypto_template crypto_cbcmac_tmpl = {\n\t.name = \"cbcmac\",\n\t.create = cbcmac_create,\n\t.free = shash_free_instance,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_ccm_module_init(void)\n{\n\tint err;\n\n\terr = crypto_register_template(&crypto_cbcmac_tmpl);\n\tif (err)\n\t\tgoto out;\n\n\terr = crypto_register_template(&crypto_ccm_base_tmpl);\n\tif (err)\n\t\tgoto out_undo_cbcmac;\n\n\terr = crypto_register_template(&crypto_ccm_tmpl);\n\tif (err)\n\t\tgoto out_undo_base;\n\n\terr = crypto_register_template(&crypto_rfc4309_tmpl);\n\tif (err)\n\t\tgoto out_undo_ccm;\n\nout:\n\treturn err;\n\nout_undo_ccm:\n\tcrypto_unregister_template(&crypto_ccm_tmpl);\nout_undo_base:\n\tcrypto_unregister_template(&crypto_ccm_base_tmpl);\nout_undo_cbcmac:\n\tcrypto_register_template(&crypto_cbcmac_tmpl);\n\tgoto out;\n}\n\nstatic void __exit crypto_ccm_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_rfc4309_tmpl);\n\tcrypto_unregister_template(&crypto_ccm_tmpl);\n\tcrypto_unregister_template(&crypto_ccm_base_tmpl);\n\tcrypto_unregister_template(&crypto_cbcmac_tmpl);\n}\n\nmodule_init(crypto_ccm_module_init);\nmodule_exit(crypto_ccm_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Counter with CBC MAC\");\nMODULE_ALIAS_CRYPTO(\"ccm_base\");\nMODULE_ALIAS_CRYPTO(\"rfc4309\");\nMODULE_ALIAS_CRYPTO(\"ccm\");\n"], "fixing_code": ["/*\n * CCM: Counter with CBC-MAC\n *\n * (C) Copyright IBM Corp. 2007 - Joy Latten <latten@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/internal/aead.h>\n#include <crypto/internal/hash.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/scatterwalk.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"internal.h\"\n\nstruct ccm_instance_ctx {\n\tstruct crypto_skcipher_spawn ctr;\n\tstruct crypto_ahash_spawn mac;\n};\n\nstruct crypto_ccm_ctx {\n\tstruct crypto_ahash *mac;\n\tstruct crypto_skcipher *ctr;\n};\n\nstruct crypto_rfc4309_ctx {\n\tstruct crypto_aead *child;\n\tu8 nonce[3];\n};\n\nstruct crypto_rfc4309_req_ctx {\n\tstruct scatterlist src[3];\n\tstruct scatterlist dst[3];\n\tstruct aead_request subreq;\n};\n\nstruct crypto_ccm_req_priv_ctx {\n\tu8 odata[16];\n\tu8 idata[16];\n\tu8 auth_tag[16];\n\tu32 flags;\n\tstruct scatterlist src[3];\n\tstruct scatterlist dst[3];\n\tstruct skcipher_request skreq;\n};\n\nstruct cbcmac_tfm_ctx {\n\tstruct crypto_cipher *child;\n};\n\nstruct cbcmac_desc_ctx {\n\tunsigned int len;\n};\n\nstatic inline struct crypto_ccm_req_priv_ctx *crypto_ccm_reqctx(\n\tstruct aead_request *req)\n{\n\tunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\n\n\treturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\n}\n\nstatic int set_msg_len(u8 *block, unsigned int msglen, int csize)\n{\n\t__be32 data;\n\n\tmemset(block, 0, csize);\n\tblock += csize;\n\n\tif (csize >= 4)\n\t\tcsize = 4;\n\telse if (msglen > (1 << (8 * csize)))\n\t\treturn -EOVERFLOW;\n\n\tdata = cpu_to_be32(msglen);\n\tmemcpy(block - csize, (u8 *)&data + 4 - csize, csize);\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_skcipher *ctr = ctx->ctr;\n\tstruct crypto_ahash *mac = ctx->mac;\n\tint err = 0;\n\n\tcrypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\n\tcrypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\n\t\t\t\t       CRYPTO_TFM_REQ_MASK);\n\terr = crypto_skcipher_setkey(ctr, key, keylen);\n\tcrypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &\n\t\t\t      CRYPTO_TFM_RES_MASK);\n\tif (err)\n\t\tgoto out;\n\n\tcrypto_ahash_clear_flags(mac, CRYPTO_TFM_REQ_MASK);\n\tcrypto_ahash_set_flags(mac, crypto_aead_get_flags(aead) &\n\t\t\t\t    CRYPTO_TFM_REQ_MASK);\n\terr = crypto_ahash_setkey(mac, key, keylen);\n\tcrypto_aead_set_flags(aead, crypto_ahash_get_flags(mac) &\n\t\t\t      CRYPTO_TFM_RES_MASK);\n\nout:\n\treturn err;\n}\n\nstatic int crypto_ccm_setauthsize(struct crypto_aead *tfm,\n\t\t\t\t  unsigned int authsize)\n{\n\tswitch (authsize) {\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\tcase 10:\n\tcase 12:\n\tcase 14:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int format_input(u8 *info, struct aead_request *req,\n\t\t\tunsigned int cryptlen)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int lp = req->iv[0];\n\tunsigned int l = lp + 1;\n\tunsigned int m;\n\n\tm = crypto_aead_authsize(aead);\n\n\tmemcpy(info, req->iv, 16);\n\n\t/* format control info per RFC 3610 and\n\t * NIST Special Publication 800-38C\n\t */\n\t*info |= (8 * ((m - 2) / 2));\n\tif (req->assoclen)\n\t\t*info |= 64;\n\n\treturn set_msg_len(info + 16 - l, cryptlen, l);\n}\n\nstatic int format_adata(u8 *adata, unsigned int a)\n{\n\tint len = 0;\n\n\t/* add control info for associated data\n\t * RFC 3610 and NIST Special Publication 800-38C\n\t */\n\tif (a < 65280) {\n\t\t*(__be16 *)adata = cpu_to_be16(a);\n\t\tlen = 2;\n\t} else  {\n\t\t*(__be16 *)adata = cpu_to_be16(0xfffe);\n\t\t*(__be32 *)&adata[2] = cpu_to_be32(a);\n\t\tlen = 6;\n\t}\n\n\treturn len;\n}\n\nstatic int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 *odata = pctx->odata;\n\tu8 *idata = pctx->idata;\n\tint ilen, err;\n\n\t/* format control data for input */\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\n\t/* format associated data and compute into mac */\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\n\t/* we need to pad the MAC input to a round multiple of the block size */\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}\n\nstatic void crypto_ccm_encrypt_done(struct crypto_async_request *areq, int err)\n{\n\tstruct aead_request *req = areq->data;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tu8 *odata = pctx->odata;\n\n\tif (!err)\n\t\tscatterwalk_map_and_copy(odata, req->dst,\n\t\t\t\t\t req->assoclen + req->cryptlen,\n\t\t\t\t\t crypto_aead_authsize(aead), 1);\n\taead_request_complete(req, err);\n}\n\nstatic inline int crypto_ccm_check_iv(const u8 *iv)\n{\n\t/* 2 <= L <= 8, so 1 <= L' <= 7. */\n\tif (1 > iv[0] || iv[0] > 7)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_init_crypt(struct aead_request *req, u8 *tag)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct scatterlist *sg;\n\tu8 *iv = req->iv;\n\tint err;\n\n\terr = crypto_ccm_check_iv(iv);\n\tif (err)\n\t\treturn err;\n\n\tpctx->flags = aead_request_flags(req);\n\n\t /* Note: rfc 3610 and NIST 800-38C require counter of\n\t * zero to encrypt auth tag.\n\t */\n\tmemset(iv + 15 - iv[0], 0, iv[0] + 1);\n\n\tsg_init_table(pctx->src, 3);\n\tsg_set_buf(pctx->src, tag, 16);\n\tsg = scatterwalk_ffwd(pctx->src + 1, req->src, req->assoclen);\n\tif (sg != pctx->src + 1)\n\t\tsg_chain(pctx->src, 2, sg);\n\n\tif (req->src != req->dst) {\n\t\tsg_init_table(pctx->dst, 3);\n\t\tsg_set_buf(pctx->dst, tag, 16);\n\t\tsg = scatterwalk_ffwd(pctx->dst + 1, req->dst, req->assoclen);\n\t\tif (sg != pctx->dst + 1)\n\t\t\tsg_chain(pctx->dst, 2, sg);\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_ccm_encrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct skcipher_request *skreq = &pctx->skreq;\n\tstruct scatterlist *dst;\n\tunsigned int cryptlen = req->cryptlen;\n\tu8 *odata = pctx->odata;\n\tu8 *iv = req->iv;\n\tint err;\n\n\terr = crypto_ccm_init_crypt(req, odata);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_ccm_auth(req, sg_next(pctx->src), cryptlen);\n\tif (err)\n\t\treturn err;\n\n\tdst = pctx->src;\n\tif (req->src != req->dst)\n\t\tdst = pctx->dst;\n\n\tskcipher_request_set_tfm(skreq, ctx->ctr);\n\tskcipher_request_set_callback(skreq, pctx->flags,\n\t\t\t\t      crypto_ccm_encrypt_done, req);\n\tskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\n\terr = crypto_skcipher_encrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\t/* copy authtag to end of dst */\n\tscatterwalk_map_and_copy(odata, sg_next(dst), cryptlen,\n\t\t\t\t crypto_aead_authsize(aead), 1);\n\treturn err;\n}\n\nstatic void crypto_ccm_decrypt_done(struct crypto_async_request *areq,\n\t\t\t\t   int err)\n{\n\tstruct aead_request *req = areq->data;\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tunsigned int cryptlen = req->cryptlen - authsize;\n\tstruct scatterlist *dst;\n\n\tpctx->flags = 0;\n\n\tdst = sg_next(req->src == req->dst ? pctx->src : pctx->dst);\n\n\tif (!err) {\n\t\terr = crypto_ccm_auth(req, dst, cryptlen);\n\t\tif (!err && crypto_memneq(pctx->auth_tag, pctx->odata, authsize))\n\t\t\terr = -EBADMSG;\n\t}\n\taead_request_complete(req, err);\n}\n\nstatic int crypto_ccm_decrypt(struct aead_request *req)\n{\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct skcipher_request *skreq = &pctx->skreq;\n\tstruct scatterlist *dst;\n\tunsigned int authsize = crypto_aead_authsize(aead);\n\tunsigned int cryptlen = req->cryptlen;\n\tu8 *authtag = pctx->auth_tag;\n\tu8 *odata = pctx->odata;\n\tu8 *iv = req->iv;\n\tint err;\n\n\tcryptlen -= authsize;\n\n\terr = crypto_ccm_init_crypt(req, authtag);\n\tif (err)\n\t\treturn err;\n\n\tscatterwalk_map_and_copy(authtag, sg_next(pctx->src), cryptlen,\n\t\t\t\t authsize, 0);\n\n\tdst = pctx->src;\n\tif (req->src != req->dst)\n\t\tdst = pctx->dst;\n\n\tskcipher_request_set_tfm(skreq, ctx->ctr);\n\tskcipher_request_set_callback(skreq, pctx->flags,\n\t\t\t\t      crypto_ccm_decrypt_done, req);\n\tskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\n\terr = crypto_skcipher_decrypt(skreq);\n\tif (err)\n\t\treturn err;\n\n\terr = crypto_ccm_auth(req, sg_next(dst), cryptlen);\n\tif (err)\n\t\treturn err;\n\n\t/* verify */\n\tif (crypto_memneq(authtag, odata, authsize))\n\t\treturn -EBADMSG;\n\n\treturn err;\n}\n\nstatic int crypto_ccm_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct ccm_instance_ctx *ictx = aead_instance_ctx(inst);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_ahash *mac;\n\tstruct crypto_skcipher *ctr;\n\tunsigned long align;\n\tint err;\n\n\tmac = crypto_spawn_ahash(&ictx->mac);\n\tif (IS_ERR(mac))\n\t\treturn PTR_ERR(mac);\n\n\tctr = crypto_spawn_skcipher(&ictx->ctr);\n\terr = PTR_ERR(ctr);\n\tif (IS_ERR(ctr))\n\t\tgoto err_free_mac;\n\n\tctx->mac = mac;\n\tctx->ctr = ctr;\n\n\talign = crypto_aead_alignmask(tfm);\n\talign &= ~(crypto_tfm_ctx_alignment() - 1);\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\talign + sizeof(struct crypto_ccm_req_priv_ctx) +\n\t\tcrypto_skcipher_reqsize(ctr));\n\n\treturn 0;\n\nerr_free_mac:\n\tcrypto_free_ahash(mac);\n\treturn err;\n}\n\nstatic void crypto_ccm_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_ahash(ctx->mac);\n\tcrypto_free_skcipher(ctx->ctr);\n}\n\nstatic void crypto_ccm_free(struct aead_instance *inst)\n{\n\tstruct ccm_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_ahash(&ctx->mac);\n\tcrypto_drop_skcipher(&ctx->ctr);\n\tkfree(inst);\n}\n\nstatic int crypto_ccm_create_common(struct crypto_template *tmpl,\n\t\t\t\t    struct rtattr **tb,\n\t\t\t\t    const char *full_name,\n\t\t\t\t    const char *ctr_name,\n\t\t\t\t    const char *mac_name)\n{\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct skcipher_alg *ctr;\n\tstruct crypto_alg *mac_alg;\n\tstruct hash_alg_common *mac;\n\tstruct ccm_instance_ctx *ictx;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\n\t\treturn -EINVAL;\n\n\tmac_alg = crypto_find_alg(mac_name, &crypto_ahash_type,\n\t\t\t\t  CRYPTO_ALG_TYPE_HASH,\n\t\t\t\t  CRYPTO_ALG_TYPE_AHASH_MASK |\n\t\t\t\t  CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(mac_alg))\n\t\treturn PTR_ERR(mac_alg);\n\n\tmac = __crypto_hash_alg_common(mac_alg);\n\terr = -EINVAL;\n\tif (mac->digestsize != 16)\n\t\tgoto out_put_mac;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ictx), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!inst)\n\t\tgoto out_put_mac;\n\n\tictx = aead_instance_ctx(inst);\n\terr = crypto_init_ahash_spawn(&ictx->mac, mac,\n\t\t\t\t      aead_crypto_instance(inst));\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tcrypto_set_skcipher_spawn(&ictx->ctr, aead_crypto_instance(inst));\n\terr = crypto_grab_skcipher(&ictx->ctr, ctr_name, 0,\n\t\t\t\t   crypto_requires_sync(algt->type,\n\t\t\t\t\t\t\talgt->mask));\n\tif (err)\n\t\tgoto err_drop_mac;\n\n\tctr = crypto_spawn_skcipher_alg(&ictx->ctr);\n\n\t/* Not a stream cipher? */\n\terr = -EINVAL;\n\tif (ctr->base.cra_blocksize != 1)\n\t\tgoto err_drop_ctr;\n\n\t/* We want the real thing! */\n\tif (crypto_skcipher_alg_ivsize(ctr) != 16)\n\t\tgoto err_drop_ctr;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"ccm_base(%s,%s)\", ctr->base.cra_driver_name,\n\t\t     mac->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_drop_ctr;\n\n\tmemcpy(inst->alg.base.cra_name, full_name, CRYPTO_MAX_ALG_NAME);\n\n\tinst->alg.base.cra_flags = ctr->base.cra_flags & CRYPTO_ALG_ASYNC;\n\tinst->alg.base.cra_priority = (mac->base.cra_priority +\n\t\t\t\t       ctr->base.cra_priority) / 2;\n\tinst->alg.base.cra_blocksize = 1;\n\tinst->alg.base.cra_alignmask = mac->base.cra_alignmask |\n\t\t\t\t       ctr->base.cra_alignmask;\n\tinst->alg.ivsize = 16;\n\tinst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);\n\tinst->alg.maxauthsize = 16;\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_ccm_ctx);\n\tinst->alg.init = crypto_ccm_init_tfm;\n\tinst->alg.exit = crypto_ccm_exit_tfm;\n\tinst->alg.setkey = crypto_ccm_setkey;\n\tinst->alg.setauthsize = crypto_ccm_setauthsize;\n\tinst->alg.encrypt = crypto_ccm_encrypt;\n\tinst->alg.decrypt = crypto_ccm_decrypt;\n\n\tinst->free = crypto_ccm_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto err_drop_ctr;\n\nout_put_mac:\n\tcrypto_mod_put(mac_alg);\n\treturn err;\n\nerr_drop_ctr:\n\tcrypto_drop_skcipher(&ictx->ctr);\nerr_drop_mac:\n\tcrypto_drop_ahash(&ictx->mac);\nerr_free_inst:\n\tkfree(inst);\n\tgoto out_put_mac;\n}\n\nstatic int crypto_ccm_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tconst char *cipher_name;\n\tchar ctr_name[CRYPTO_MAX_ALG_NAME];\n\tchar mac_name[CRYPTO_MAX_ALG_NAME];\n\tchar full_name[CRYPTO_MAX_ALG_NAME];\n\n\tcipher_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(cipher_name))\n\t\treturn PTR_ERR(cipher_name);\n\n\tif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, \"ctr(%s)\",\n\t\t     cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\tif (snprintf(mac_name, CRYPTO_MAX_ALG_NAME, \"cbcmac(%s)\",\n\t\t     cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\tif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, \"ccm(%s)\", cipher_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\treturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\n\t\t\t\t\tmac_name);\n}\n\nstatic struct crypto_template crypto_ccm_tmpl = {\n\t.name = \"ccm\",\n\t.create = crypto_ccm_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int crypto_ccm_base_create(struct crypto_template *tmpl,\n\t\t\t\t  struct rtattr **tb)\n{\n\tconst char *ctr_name;\n\tconst char *cipher_name;\n\tchar full_name[CRYPTO_MAX_ALG_NAME];\n\n\tctr_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(ctr_name))\n\t\treturn PTR_ERR(ctr_name);\n\n\tcipher_name = crypto_attr_alg_name(tb[2]);\n\tif (IS_ERR(cipher_name))\n\t\treturn PTR_ERR(cipher_name);\n\n\tif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, \"ccm_base(%s,%s)\",\n\t\t     ctr_name, cipher_name) >= CRYPTO_MAX_ALG_NAME)\n\t\treturn -ENAMETOOLONG;\n\n\treturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\n\t\t\t\t\tcipher_name);\n}\n\nstatic struct crypto_template crypto_ccm_base_tmpl = {\n\t.name = \"ccm_base\",\n\t.create = crypto_ccm_base_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,\n\t\t\t\t unsigned int keylen)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\n\tstruct crypto_aead *child = ctx->child;\n\tint err;\n\n\tif (keylen < 3)\n\t\treturn -EINVAL;\n\n\tkeylen -= 3;\n\tmemcpy(ctx->nonce, key + keylen, 3);\n\n\tcrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\n\t\t\t\t     CRYPTO_TFM_REQ_MASK);\n\terr = crypto_aead_setkey(child, key, keylen);\n\tcrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\n\t\t\t\t      CRYPTO_TFM_RES_MASK);\n\n\treturn err;\n}\n\nstatic int crypto_rfc4309_setauthsize(struct crypto_aead *parent,\n\t\t\t\t      unsigned int authsize)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\n\n\tswitch (authsize) {\n\tcase 8:\n\tcase 12:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn crypto_aead_setauthsize(ctx->child, authsize);\n}\n\nstatic struct aead_request *crypto_rfc4309_crypt(struct aead_request *req)\n{\n\tstruct crypto_rfc4309_req_ctx *rctx = aead_request_ctx(req);\n\tstruct aead_request *subreq = &rctx->subreq;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);\n\tstruct crypto_aead *child = ctx->child;\n\tstruct scatterlist *sg;\n\tu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\n\t\t\t   crypto_aead_alignmask(child) + 1);\n\n\t/* L' */\n\tiv[0] = 3;\n\n\tmemcpy(iv + 1, ctx->nonce, 3);\n\tmemcpy(iv + 4, req->iv, 8);\n\n\tscatterwalk_map_and_copy(iv + 16, req->src, 0, req->assoclen - 8, 0);\n\n\tsg_init_table(rctx->src, 3);\n\tsg_set_buf(rctx->src, iv + 16, req->assoclen - 8);\n\tsg = scatterwalk_ffwd(rctx->src + 1, req->src, req->assoclen);\n\tif (sg != rctx->src + 1)\n\t\tsg_chain(rctx->src, 2, sg);\n\n\tif (req->src != req->dst) {\n\t\tsg_init_table(rctx->dst, 3);\n\t\tsg_set_buf(rctx->dst, iv + 16, req->assoclen - 8);\n\t\tsg = scatterwalk_ffwd(rctx->dst + 1, req->dst, req->assoclen);\n\t\tif (sg != rctx->dst + 1)\n\t\t\tsg_chain(rctx->dst, 2, sg);\n\t}\n\n\taead_request_set_tfm(subreq, child);\n\taead_request_set_callback(subreq, req->base.flags, req->base.complete,\n\t\t\t\t  req->base.data);\n\taead_request_set_crypt(subreq, rctx->src,\n\t\t\t       req->src == req->dst ? rctx->src : rctx->dst,\n\t\t\t       req->cryptlen, iv);\n\taead_request_set_ad(subreq, req->assoclen - 8);\n\n\treturn subreq;\n}\n\nstatic int crypto_rfc4309_encrypt(struct aead_request *req)\n{\n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treq = crypto_rfc4309_crypt(req);\n\n\treturn crypto_aead_encrypt(req);\n}\n\nstatic int crypto_rfc4309_decrypt(struct aead_request *req)\n{\n\tif (req->assoclen != 16 && req->assoclen != 20)\n\t\treturn -EINVAL;\n\n\treq = crypto_rfc4309_crypt(req);\n\n\treturn crypto_aead_decrypt(req);\n}\n\nstatic int crypto_rfc4309_init_tfm(struct crypto_aead *tfm)\n{\n\tstruct aead_instance *inst = aead_alg_instance(tfm);\n\tstruct crypto_aead_spawn *spawn = aead_instance_ctx(inst);\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\n\tstruct crypto_aead *aead;\n\tunsigned long align;\n\n\taead = crypto_spawn_aead(spawn);\n\tif (IS_ERR(aead))\n\t\treturn PTR_ERR(aead);\n\n\tctx->child = aead;\n\n\talign = crypto_aead_alignmask(aead);\n\talign &= ~(crypto_tfm_ctx_alignment() - 1);\n\tcrypto_aead_set_reqsize(\n\t\ttfm,\n\t\tsizeof(struct crypto_rfc4309_req_ctx) +\n\t\tALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +\n\t\talign + 32);\n\n\treturn 0;\n}\n\nstatic void crypto_rfc4309_exit_tfm(struct crypto_aead *tfm)\n{\n\tstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\n\n\tcrypto_free_aead(ctx->child);\n}\n\nstatic void crypto_rfc4309_free(struct aead_instance *inst)\n{\n\tcrypto_drop_aead(aead_instance_ctx(inst));\n\tkfree(inst);\n}\n\nstatic int crypto_rfc4309_create(struct crypto_template *tmpl,\n\t\t\t\t struct rtattr **tb)\n{\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct crypto_aead_spawn *spawn;\n\tstruct aead_alg *alg;\n\tconst char *ccm_name;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\n\tif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\n\t\treturn -EINVAL;\n\n\tccm_name = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(ccm_name))\n\t\treturn PTR_ERR(ccm_name);\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\n\tspawn = aead_instance_ctx(inst);\n\tcrypto_set_aead_spawn(spawn, aead_crypto_instance(inst));\n\terr = crypto_grab_aead(spawn, ccm_name, 0,\n\t\t\t       crypto_requires_sync(algt->type, algt->mask));\n\tif (err)\n\t\tgoto out_free_inst;\n\n\talg = crypto_spawn_aead_alg(spawn);\n\n\terr = -EINVAL;\n\n\t/* We only support 16-byte blocks. */\n\tif (crypto_aead_alg_ivsize(alg) != 16)\n\t\tgoto out_drop_alg;\n\n\t/* Not a stream cipher? */\n\tif (alg->base.cra_blocksize != 1)\n\t\tgoto out_drop_alg;\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4309(%s)\", alg->base.cra_name) >=\n\t    CRYPTO_MAX_ALG_NAME ||\n\t    snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"rfc4309(%s)\", alg->base.cra_driver_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto out_drop_alg;\n\n\tinst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\n\tinst->alg.base.cra_priority = alg->base.cra_priority;\n\tinst->alg.base.cra_blocksize = 1;\n\tinst->alg.base.cra_alignmask = alg->base.cra_alignmask;\n\n\tinst->alg.ivsize = 8;\n\tinst->alg.chunksize = crypto_aead_alg_chunksize(alg);\n\tinst->alg.maxauthsize = 16;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc4309_ctx);\n\n\tinst->alg.init = crypto_rfc4309_init_tfm;\n\tinst->alg.exit = crypto_rfc4309_exit_tfm;\n\n\tinst->alg.setkey = crypto_rfc4309_setkey;\n\tinst->alg.setauthsize = crypto_rfc4309_setauthsize;\n\tinst->alg.encrypt = crypto_rfc4309_encrypt;\n\tinst->alg.decrypt = crypto_rfc4309_decrypt;\n\n\tinst->free = crypto_rfc4309_free;\n\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto out_drop_alg;\n\nout:\n\treturn err;\n\nout_drop_alg:\n\tcrypto_drop_aead(spawn);\nout_free_inst:\n\tkfree(inst);\n\tgoto out;\n}\n\nstatic struct crypto_template crypto_rfc4309_tmpl = {\n\t.name = \"rfc4309\",\n\t.create = crypto_rfc4309_create,\n\t.module = THIS_MODULE,\n};\n\nstatic int crypto_cbcmac_digest_setkey(struct crypto_shash *parent,\n\t\t\t\t     const u8 *inkey, unsigned int keylen)\n{\n\tstruct cbcmac_tfm_ctx *ctx = crypto_shash_ctx(parent);\n\n\treturn crypto_cipher_setkey(ctx->child, inkey, keylen);\n}\n\nstatic int crypto_cbcmac_digest_init(struct shash_desc *pdesc)\n{\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tint bs = crypto_shash_digestsize(pdesc->tfm);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(pdesc->tfm) - bs;\n\n\tctx->len = 0;\n\tmemset(dg, 0, bs);\n\n\treturn 0;\n}\n\nstatic int crypto_cbcmac_digest_update(struct shash_desc *pdesc, const u8 *p,\n\t\t\t\t       unsigned int len)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\twhile (len > 0) {\n\t\tunsigned int l = min(len, bs - ctx->len);\n\n\t\tcrypto_xor(dg + ctx->len, p, l);\n\t\tctx->len +=l;\n\t\tlen -= l;\n\t\tp += l;\n\n\t\tif (ctx->len == bs) {\n\t\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\t\t\tctx->len = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int crypto_cbcmac_digest_final(struct shash_desc *pdesc, u8 *out)\n{\n\tstruct crypto_shash *parent = pdesc->tfm;\n\tstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\n\tstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\n\tstruct crypto_cipher *tfm = tctx->child;\n\tint bs = crypto_shash_digestsize(parent);\n\tu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\n\n\tif (ctx->len)\n\t\tcrypto_cipher_encrypt_one(tfm, dg, dg);\n\n\tmemcpy(out, dg, bs);\n\treturn 0;\n}\n\nstatic int cbcmac_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_cipher *cipher;\n\tstruct crypto_instance *inst = (void *)tfm->__crt_alg;\n\tstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\n\tstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tcipher = crypto_spawn_cipher(spawn);\n\tif (IS_ERR(cipher))\n\t\treturn PTR_ERR(cipher);\n\n\tctx->child = cipher;\n\n\treturn 0;\n};\n\nstatic void cbcmac_exit_tfm(struct crypto_tfm *tfm)\n{\n\tstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n\tcrypto_free_cipher(ctx->child);\n}\n\nstatic int cbcmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tint err;\n\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\n\talg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\n\t\t\t\t  CRYPTO_ALG_TYPE_MASK);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tinst = shash_alloc_instance(\"cbcmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\n\terr = crypto_init_spawn(shash_instance_ctx(inst), alg,\n\t\t\t\tshash_crypto_instance(inst),\n\t\t\t\tCRYPTO_ALG_TYPE_MASK);\n\tif (err)\n\t\tgoto out_free_inst;\n\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = 1;\n\n\tinst->alg.digestsize = alg->cra_blocksize;\n\tinst->alg.descsize = ALIGN(sizeof(struct cbcmac_desc_ctx),\n\t\t\t\t   alg->cra_alignmask + 1) +\n\t\t\t     alg->cra_blocksize;\n\n\tinst->alg.base.cra_ctxsize = sizeof(struct cbcmac_tfm_ctx);\n\tinst->alg.base.cra_init = cbcmac_init_tfm;\n\tinst->alg.base.cra_exit = cbcmac_exit_tfm;\n\n\tinst->alg.init = crypto_cbcmac_digest_init;\n\tinst->alg.update = crypto_cbcmac_digest_update;\n\tinst->alg.final = crypto_cbcmac_digest_final;\n\tinst->alg.setkey = crypto_cbcmac_digest_setkey;\n\n\terr = shash_register_instance(tmpl, inst);\n\nout_free_inst:\n\tif (err)\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n\nstatic struct crypto_template crypto_cbcmac_tmpl = {\n\t.name = \"cbcmac\",\n\t.create = cbcmac_create,\n\t.free = shash_free_instance,\n\t.module = THIS_MODULE,\n};\n\nstatic int __init crypto_ccm_module_init(void)\n{\n\tint err;\n\n\terr = crypto_register_template(&crypto_cbcmac_tmpl);\n\tif (err)\n\t\tgoto out;\n\n\terr = crypto_register_template(&crypto_ccm_base_tmpl);\n\tif (err)\n\t\tgoto out_undo_cbcmac;\n\n\terr = crypto_register_template(&crypto_ccm_tmpl);\n\tif (err)\n\t\tgoto out_undo_base;\n\n\terr = crypto_register_template(&crypto_rfc4309_tmpl);\n\tif (err)\n\t\tgoto out_undo_ccm;\n\nout:\n\treturn err;\n\nout_undo_ccm:\n\tcrypto_unregister_template(&crypto_ccm_tmpl);\nout_undo_base:\n\tcrypto_unregister_template(&crypto_ccm_base_tmpl);\nout_undo_cbcmac:\n\tcrypto_register_template(&crypto_cbcmac_tmpl);\n\tgoto out;\n}\n\nstatic void __exit crypto_ccm_module_exit(void)\n{\n\tcrypto_unregister_template(&crypto_rfc4309_tmpl);\n\tcrypto_unregister_template(&crypto_ccm_tmpl);\n\tcrypto_unregister_template(&crypto_ccm_base_tmpl);\n\tcrypto_unregister_template(&crypto_cbcmac_tmpl);\n}\n\nmodule_init(crypto_ccm_module_init);\nmodule_exit(crypto_ccm_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Counter with CBC MAC\");\nMODULE_ALIAS_CRYPTO(\"ccm_base\");\nMODULE_ALIAS_CRYPTO(\"rfc4309\");\nMODULE_ALIAS_CRYPTO(\"ccm\");\n"], "filenames": ["crypto/ccm.c"], "buggy_code_start_loc": [47], "buggy_code_end_loc": [188], "fixing_code_start_loc": [48], "fixing_code_end_loc": [189], "type": "CWE-119", "message": "crypto/ccm.c in the Linux kernel 4.9.x and 4.10.x through 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.", "other": {"cve": {"id": "CVE-2017-8065", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.347", "lastModified": "2017-04-27T16:50:23.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "crypto/ccm.c in the Linux kernel 4.9.x and 4.10.x through 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."}, {"lang": "es", "value": "crypto/ccm.c en el kernel de Linux 4.9.x y 4.10.x hasta la versi\u00f3n 4.10.12 interact\u00faa incorrectamente con la opci\u00f3n CONFIG_VMAP_STACK, que permite a usuarios locales provocar una denegaci\u00f3n de servicio (bloqueo del sistema o corrupci\u00f3n de memoria) o posiblemente tiene otro impacto no especificado aprovechando el uso de m\u00e1s de una p\u00e1gina virtual para la lista de dispersi\u00f3n DMA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "8A944C6C-C1BF-472D-8BC2-B112EEDF3BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "29F4F9E6-4EE0-43C4-9B72-03D773AF5719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "D249C5D2-9186-498C-9AF7-100162D856EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "783F5C9D-D179-4194-965E-F9A153EAE3B1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "79EC10DA-54C8-405F-B0AC-A0E8130B5AA2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.12:*:*:*:*:*:*:*", "matchCriteriaId": "7AD95130-C8F6-4372-BB45-15C664D4E941"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.13:*:*:*:*:*:*:*", "matchCriteriaId": "BBB9620C-F4B3-47D1-951F-33E8CD39D516"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.14:*:*:*:*:*:*:*", "matchCriteriaId": "99E1E52C-8A19-4D3D-B890-8A7DE0745E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.15:*:*:*:*:*:*:*", "matchCriteriaId": "341DB6BF-E05C-478B-86E7-4466B9A64745"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.16:*:*:*:*:*:*:*", "matchCriteriaId": "26B28AFB-C8D8-401F-A7A1-F47A66B74CD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.17:*:*:*:*:*:*:*", "matchCriteriaId": "70525107-9C8E-4694-B7F3-98E0FA401C0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.18:*:*:*:*:*:*:*", "matchCriteriaId": "E41C688F-5EE3-4C71-9A76-3A7E12769335"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.19:*:*:*:*:*:*:*", "matchCriteriaId": "C3B8B635-4125-4BB7-92FE-E5AEBBB3730A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10:*:*:*:*:*:*:*", "matchCriteriaId": "1DCB26E2-5F19-4F9C-9FF3-184EF7262D6D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "3B614F17-FC57-4689-B875-33C2915432CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "4F8E178C-5E11-4335-94B5-8FBBF1EA0634"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "E171DDAB-2D18-4318-AA0A-CC23DEC41561"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "6B0C1F4E-9C54-4FC2-AD07-0D3B26CC2B6F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "C386C15E-74D2-47C7-802D-87B67D9EE1F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "59169334-1EA3-4E94-BBDD-49DAC1EC2CC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "1AF5D1AA-B343-49EE-AA1D-6B1C24E7DA14"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "1FA196D2-A89F-4134-9B68-9A953F25FA29"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "2176CA12-5033-49DB-AE06-B2E811C3D9D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "7219DEF7-93BC-49E8-A2AB-F8B2DE8262CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "F44EC694-C56F-4593-81A0-F373A1F9B65B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "C9DC765D-24D0-4866-AE56-98C53FF75660"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97994", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3b30460c5b0ed762be75a004e924ec3f8711e032", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/3b30460c5b0ed762be75a004e924ec3f8711e032", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/3b30460c5b0ed762be75a004e924ec3f8711e032"}}