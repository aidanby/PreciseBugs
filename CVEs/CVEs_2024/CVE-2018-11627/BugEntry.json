{"buggy_code": ["# coding: utf-8\n# frozen_string_literal: true\n\n# external dependencies\nrequire 'rack'\nrequire 'tilt'\nrequire 'rack/protection'\nrequire 'mustermann'\nrequire 'mustermann/sinatra'\nrequire 'mustermann/regular'\n\n# stdlib dependencies\nrequire 'thread'\nrequire 'time'\nrequire 'uri'\n\n# other files we need\nrequire 'sinatra/indifferent_hash'\nrequire 'sinatra/show_exceptions'\nrequire 'sinatra/version'\n\nmodule Sinatra\n  # The request object. See Rack::Request for more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Request\n  class Request < Rack::Request\n    HEADER_PARAM = /\\s*[\\w.]+=(?:[\\w.]+|\"(?:[^\"\\\\]|\\\\.)*\")?\\s*/\n    HEADER_VALUE_WITH_PARAMS = /(?:(?:\\w+|\\*)\\/(?:\\w+(?:\\.|\\-|\\+)?|\\*)*)\\s*(?:;#{HEADER_PARAM})*/\n\n    # Returns an array of acceptable media types for the response\n    def accept\n      @env['sinatra.accept'] ||= begin\n        if @env.include? 'HTTP_ACCEPT' and @env['HTTP_ACCEPT'].to_s != ''\n          @env['HTTP_ACCEPT'].to_s.scan(HEADER_VALUE_WITH_PARAMS).\n            map! { |e| AcceptEntry.new(e) }.sort\n        else\n          [AcceptEntry.new('*/*')]\n        end\n      end\n    end\n\n    def accept?(type)\n      preferred_type(type).to_s.include?(type)\n    end\n\n    def preferred_type(*types)\n      accepts = accept # just evaluate once\n      return accepts.first if types.empty?\n      types.flatten!\n      return types.first if accepts.empty?\n      accepts.detect do |pattern|\n        type = types.detect { |t| File.fnmatch(pattern, t) }\n        return type if type\n      end\n    end\n\n    alias secure? ssl?\n\n    def forwarded?\n      @env.include? \"HTTP_X_FORWARDED_HOST\"\n    end\n\n    def safe?\n      get? or head? or options? or trace?\n    end\n\n    def idempotent?\n      safe? or put? or delete? or link? or unlink?\n    end\n\n    def link?\n      request_method == \"LINK\"\n    end\n\n    def unlink?\n      request_method == \"UNLINK\"\n    end\n\n    def params\n      super\n    rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e\n      raise BadRequest, \"Invalid query parameters: #{e.message}\"\n    end\n\n    private\n\n    class AcceptEntry\n      attr_accessor :params\n      attr_reader :entry\n\n      def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @entry  = entry\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = Hash[params]\n        @q      = @params.delete('q') { 1.0 }.to_f\n      end\n\n      def <=>(other)\n        other.priority <=> self.priority\n      end\n\n      def priority\n        # We sort in descending order; better matches should be higher.\n        [ @q, -@type.count('*'), @params.size ]\n      end\n\n      def to_str\n        @type\n      end\n\n      def to_s(full = false)\n        full ? entry : to_str\n      end\n\n      def respond_to?(*args)\n        super or to_str.respond_to?(*args)\n      end\n\n      def method_missing(*args, &block)\n        to_str.send(*args, &block)\n      end\n    end\n  end\n\n  # The response object. See Rack::Response and Rack::Response::Helpers for\n  # more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response/Helpers\n  class Response < Rack::Response\n    DROP_BODY_RESPONSES = [204, 304]\n    def initialize(*)\n      super\n      headers['Content-Type'] ||= 'text/html'\n    end\n\n    def body=(value)\n      value = value.body while Rack::Response === value\n      @body = String === value ? [value.to_str] : value\n    end\n\n    def each\n      block_given? ? super : enum_for(:each)\n    end\n\n    def finish\n      result = body\n\n      if drop_content_info?\n        headers.delete \"Content-Length\"\n        headers.delete \"Content-Type\"\n      end\n\n      if drop_body?\n        close\n        result = []\n      end\n\n      if calculate_content_length?\n        # if some other code has already set Content-Length, don't muck with it\n        # currently, this would be the static file-handler\n        headers[\"Content-Length\"] = body.inject(0) { |l, p| l + p.bytesize }.to_s\n      end\n\n      [status.to_i, headers, result]\n    end\n\n    private\n\n    def calculate_content_length?\n      headers[\"Content-Type\"] and not headers[\"Content-Length\"] and Array === body\n    end\n\n    def drop_content_info?\n      status.to_i / 100 == 1 or drop_body?\n    end\n\n    def drop_body?\n      DROP_BODY_RESPONSES.include?(status.to_i)\n    end\n  end\n\n  # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however,\n  # some middleware (namely Rack::Lint) will break it by not mirroring the methods in question.\n  # This middleware will detect an extended body object and will make sure it reaches the\n  # handler directly. We do this here, so our middleware and middleware set up by the app will\n  # still be able to run.\n  class ExtendedRack < Struct.new(:app)\n    def call(env)\n      result, callback = app.call(env), env['async.callback']\n      return result unless callback and async?(*result)\n      after_response { callback.call result }\n      setup_close(env, *result)\n      throw :async\n    end\n\n    private\n\n    def setup_close(env, status, headers, body)\n      return unless body.respond_to? :close and env.include? 'async.close'\n      env['async.close'].callback { body.close }\n      env['async.close'].errback { body.close }\n    end\n\n    def after_response(&block)\n      raise NotImplementedError, \"only supports EventMachine at the moment\" unless defined? EventMachine\n      EventMachine.next_tick(&block)\n    end\n\n    def async?(status, headers, body)\n      return true if status == -1\n      body.respond_to? :callback and body.respond_to? :errback\n    end\n  end\n\n  # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing,\n  # if another CommonLogger is already in the middleware chain.\n  class CommonLogger < Rack::CommonLogger\n    def call(env)\n      env['sinatra.commonlogger'] ? @app.call(env) : super\n    end\n\n    superclass.class_eval do\n      alias call_without_check call unless method_defined? :call_without_check\n      def call(env)\n        env['sinatra.commonlogger'] = true\n        call_without_check(env)\n      end\n    end\n  end\n\n  class BadRequest < TypeError #:nodoc:\n    def http_status; 400 end\n  end\n\n  class NotFound < NameError #:nodoc:\n    def http_status; 404 end\n  end\n\n  # Methods available to routes, before/after filters, and views.\n  module Helpers\n    # Set or retrieve the response status code.\n    def status(value = nil)\n      response.status = Rack::Utils.status_code(value) if value\n      response.status\n    end\n\n    # Set or retrieve the response body. When a block is given,\n    # evaluation is deferred until the body is read with #each.\n    def body(value = nil, &block)\n      if block_given?\n        def block.each; yield(call) end\n        response.body = block\n      elsif value\n        # Rack 2.0 returns a Rack::File::Iterator here instead of\n        # Rack::File as it was in the previous API.\n        unless request.head? || value.is_a?(Rack::File::Iterator) || value.is_a?(Stream)\n          headers.delete 'Content-Length'\n        end\n        response.body = value\n      else\n        response.body\n      end\n    end\n\n    # Halt processing and redirect to the URI provided.\n    def redirect(uri, *args)\n      if env['HTTP_VERSION'] == 'HTTP/1.1' and env[\"REQUEST_METHOD\"] != 'GET'\n        status 303\n      else\n        status 302\n      end\n\n      # According to RFC 2616 section 14.30, \"the field value consists of a\n      # single absolute URI\"\n      response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?)\n      halt(*args)\n    end\n\n    # Generates the absolute URI for a given path in the app.\n    # Takes Rack routers and reverse proxies into account.\n    def uri(addr = nil, absolute = true, add_script_name = true)\n      return addr if addr =~ /\\A[a-z][a-z0-9\\+\\.\\-]*:/i\n      uri = [host = String.new]\n      if absolute\n        host << \"http#{'s' if request.secure?}://\"\n        if request.forwarded? or request.port != (request.secure? ? 443 : 80)\n          host << request.host_with_port\n        else\n          host << request.host\n        end\n      end\n      uri << request.script_name.to_s if add_script_name\n      uri << (addr ? addr : request.path_info).to_s\n      File.join uri\n    end\n\n    alias url uri\n    alias to uri\n\n    # Halt processing and return the error status provided.\n    def error(code, body = nil)\n      code, body    = 500, code.to_str if code.respond_to? :to_str\n      response.body = body unless body.nil?\n      halt code\n    end\n\n    # Halt processing and return a 404 Not Found.\n    def not_found(body = nil)\n      error 404, body\n    end\n\n    # Set multiple response headers with Hash.\n    def headers(hash = nil)\n      response.headers.merge! hash if hash\n      response.headers\n    end\n\n    # Access the underlying Rack session.\n    def session\n      request.session\n    end\n\n    # Access shared logger object.\n    def logger\n      request.logger\n    end\n\n    # Look up a media type by file extension in Rack's mime registry.\n    def mime_type(type)\n      Base.mime_type(type)\n    end\n\n    # Set the Content-Type of the response body given a media type or file\n    # extension.\n    def content_type(type = nil, params = {})\n      return response['Content-Type'] unless type\n      default = params.delete :default\n      mime_type = mime_type(type) || default\n      fail \"Unknown media type: %p\" % type if mime_type.nil?\n      mime_type = mime_type.dup\n      unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type }\n        params[:charset] = params.delete('charset') || settings.default_encoding\n      end\n      params.delete :charset if mime_type.include? 'charset'\n      unless params.empty?\n        mime_type << (mime_type.include?(';') ? ', ' : ';')\n        mime_type << params.map do |key, val|\n          val = val.inspect if val =~ /[\";,]/\n          \"#{key}=#{val}\"\n        end.join(', ')\n      end\n      response['Content-Type'] = mime_type\n    end\n\n    # Set the Content-Disposition to \"attachment\" with the specified filename,\n    # instructing the user agents to prompt to save.\n    def attachment(filename = nil, disposition = :attachment)\n      response['Content-Disposition'] = disposition.to_s\n      if filename\n        params = '; filename=\"%s\"' % File.basename(filename)\n        response['Content-Disposition'] << params\n        ext = File.extname(filename)\n        content_type(ext) unless response['Content-Type'] or ext.empty?\n      end\n    end\n\n    # Use the contents of the file at +path+ as the response body.\n    def send_file(path, opts = {})\n      if opts[:type] or not response['Content-Type']\n        content_type opts[:type] || File.extname(path), :default => 'application/octet-stream'\n      end\n\n      disposition = opts[:disposition]\n      filename    = opts[:filename]\n      disposition = :attachment if disposition.nil? and filename\n      filename    = path        if filename.nil?\n      attachment(filename, disposition) if disposition\n\n      last_modified opts[:last_modified] if opts[:last_modified]\n\n      file   = Rack::File.new(File.dirname(settings.app_file))\n      result = file.serving(request, path)\n\n      result[1].each { |k,v| headers[k] ||= v }\n      headers['Content-Length'] = result[1]['Content-Length']\n      opts[:status] &&= Integer(opts[:status])\n      halt (opts[:status] || result[0]), result[2]\n    rescue Errno::ENOENT\n      not_found\n    end\n\n    # Class of the response body in case you use #stream.\n    #\n    # Three things really matter: The front and back block (back being the\n    # block generating content, front the one sending it to the client) and\n    # the scheduler, integrating with whatever concurrency feature the Rack\n    # handler is using.\n    #\n    # Scheduler has to respond to defer and schedule.\n    class Stream\n      def self.schedule(*) yield end\n      def self.defer(*)    yield end\n\n      def initialize(scheduler = self.class, keep_open = false, &back)\n        @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open\n        @callbacks, @closed = [], false\n      end\n\n      def close\n        return if closed?\n        @closed = true\n        @scheduler.schedule { @callbacks.each { |c| c.call } }\n      end\n\n      def each(&front)\n        @front = front\n        @scheduler.defer do\n          begin\n            @back.call(self)\n          rescue Exception => e\n            @scheduler.schedule { raise e }\n          end\n          close unless @keep_open\n        end\n      end\n\n      def <<(data)\n        @scheduler.schedule { @front.call(data.to_s) }\n        self\n      end\n\n      def callback(&block)\n        return yield if closed?\n        @callbacks << block\n      end\n\n      alias errback callback\n\n      def closed?\n        @closed\n      end\n    end\n\n    # Allows to start sending data to the client even though later parts of\n    # the response body have not yet been generated.\n    #\n    # The close parameter specifies whether Stream#close should be called\n    # after the block has been executed. This is only relevant for evented\n    # servers like Thin or Rainbows.\n    def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } }\n    end\n\n    # Specify response freshness policy for HTTP caches (Cache-Control header).\n    # Any number of non-value directives (:public, :private, :no_cache,\n    # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with\n    # a Hash of value directives (:max_age, :s_maxage).\n    #\n    #   cache_control :public, :must_revalidate, :max_age => 60\n    #   => Cache-Control: public, must-revalidate, max-age=60\n    #\n    # See RFC 2616 / 14.9 for more on standard cache control directives:\n    # http://tools.ietf.org/html/rfc2616#section-14.9.1\n    def cache_control(*values)\n      if values.last.kind_of?(Hash)\n        hash = values.pop\n        hash.reject! { |k, v| v == false }\n        hash.reject! { |k, v| values << k if v == true }\n      else\n        hash = {}\n      end\n\n      values.map! { |value| value.to_s.tr('_','-') }\n      hash.each do |key, value|\n        key = key.to_s.tr('_', '-')\n        value = value.to_i if ['max-age', 's-maxage'].include? key\n        values << \"#{key}=#{value}\"\n      end\n\n      response['Cache-Control'] = values.join(', ') if values.any?\n    end\n\n    # Set the Expires header and Cache-Control/max-age directive. Amount\n    # can be an integer number of seconds in the future or a Time object\n    # indicating when the response should be considered \"stale\". The remaining\n    # \"values\" arguments are passed to the #cache_control helper:\n    #\n    #   expires 500, :public, :must_revalidate\n    #   => Cache-Control: public, must-revalidate, max-age=500\n    #   => Expires: Mon, 08 Jun 2009 08:50:17 GMT\n    #\n    def expires(amount, *values)\n      values << {} unless values.last.kind_of?(Hash)\n\n      if amount.is_a? Integer\n        time    = Time.now + amount.to_i\n        max_age = amount\n      else\n        time    = time_for amount\n        max_age = time - Time.now\n      end\n\n      values.last.merge!(:max_age => max_age)\n      cache_control(*values)\n\n      response['Expires'] = time.httpdate\n    end\n\n    # Set the last modified time of the resource (HTTP 'Last-Modified' header)\n    # and halt if conditional GET matches. The +time+ argument is a Time,\n    # DateTime, or other object that responds to +to_time+.\n    #\n    # When the current request includes an 'If-Modified-Since' header that is\n    # equal or later than the time specified, execution is immediately halted\n    # with a '304 Not Modified' response.\n    def last_modified(time)\n      return unless time\n      time = time_for time\n      response['Last-Modified'] = time.httpdate\n      return if env['HTTP_IF_NONE_MATCH']\n\n      if status == 200 and env['HTTP_IF_MODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i\n        halt 304 if since >= time.to_i\n      end\n\n      if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i\n        halt 412 if since < time.to_i\n      end\n    rescue ArgumentError\n    end\n\n    ETAG_KINDS = [:strong, :weak]\n    # Set the response entity tag (HTTP 'ETag' header) and halt if conditional\n    # GET matches. The +value+ argument is an identifier that uniquely\n    # identifies the current version of the resource. The +kind+ argument\n    # indicates whether the etag should be used as a :strong (default) or :weak\n    # cache validator.\n    #\n    # When the current request includes an 'If-None-Match' header with a\n    # matching etag, execution is immediately halted. If the request method is\n    # GET or HEAD, a '304 Not Modified' response is sent.\n    def etag(value, options = {})\n      # Before touching this code, please double check RFC 2616 14.24 and 14.26.\n      options      = {:kind => options} unless Hash === options\n      kind         = options[:kind] || :strong\n      new_resource = options.fetch(:new_resource) { request.post? }\n\n      unless ETAG_KINDS.include?(kind)\n        raise ArgumentError, \":strong or :weak expected\"\n      end\n\n      value = '\"%s\"' % value\n      value = \"W/#{value}\" if kind == :weak\n      response['ETag'] = value\n\n      if success? or status == 304\n        if etag_matches? env['HTTP_IF_NONE_MATCH'], new_resource\n          halt(request.safe? ? 304 : 412)\n        end\n\n        if env['HTTP_IF_MATCH']\n          halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource\n        end\n      end\n    end\n\n    # Sugar for redirect (example:  redirect back)\n    def back\n      request.referer\n    end\n\n    # whether or not the status is set to 1xx\n    def informational?\n      status.between? 100, 199\n    end\n\n    # whether or not the status is set to 2xx\n    def success?\n      status.between? 200, 299\n    end\n\n    # whether or not the status is set to 3xx\n    def redirect?\n      status.between? 300, 399\n    end\n\n    # whether or not the status is set to 4xx\n    def client_error?\n      status.between? 400, 499\n    end\n\n    # whether or not the status is set to 5xx\n    def server_error?\n      status.between? 500, 599\n    end\n\n    # whether or not the status is set to 404\n    def not_found?\n      status == 404\n    end\n\n    # whether or not the status is set to 400\n    def bad_request?\n      status == 400\n    end\n\n    # Generates a Time object from the given value.\n    # Used by #expires and #last_modified.\n    def time_for(value)\n      if value.is_a? Numeric\n        Time.at value\n      elsif value.respond_to? :to_s\n        Time.parse value.to_s\n      else\n        value.to_time\n      end\n    rescue ArgumentError => boom\n      raise boom\n    rescue Exception\n      raise ArgumentError, \"unable to convert #{value.inspect} to a Time object\"\n    end\n\n    private\n\n    # Helper method checking if a ETag value list includes the current ETag.\n    def etag_matches?(list, new_resource = request.post?)\n      return !new_resource if list == '*'\n      list.to_s.split(/\\s*,\\s*/).include? response['ETag']\n    end\n\n    def with_params(temp_params)\n      original, @params = @params, temp_params\n      yield\n    ensure\n      @params = original if original\n    end\n  end\n\n  private\n\n  # Template rendering methods. Each method takes the name of a template\n  # to render as a Symbol and returns a String with the rendered output,\n  # as well as an optional hash with additional options.\n  #\n  # `template` is either the name or path of the template as symbol\n  # (Use `:'subdir/myview'` for views in subdirectories), or a string\n  # that will be rendered.\n  #\n  # Possible options are:\n  #   :content_type   The content type to use, same arguments as content_type.\n  #   :layout         If set to something falsy, no layout is rendered, otherwise\n  #                   the specified layout is used (Ignored for `sass` and `less`)\n  #   :layout_engine  Engine to use for rendering the layout.\n  #   :locals         A hash with local variables that should be available\n  #                   in the template\n  #   :scope          If set, template is evaluate with the binding of the given\n  #                   object rather than the application instance.\n  #   :views          Views directory to use.\n  module Templates\n    module ContentTyped\n      attr_accessor :content_type\n    end\n\n    def initialize\n      super\n      @default_layout = :layout\n      @preferred_extension = nil\n    end\n\n    def erb(template, options = {}, locals = {}, &block)\n      render(:erb, template, options, locals, &block)\n    end\n\n    def erubis(template, options = {}, locals = {})\n      warn \"Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\\n\" \\\n        \"If you have Erubis installed, it will be used automatically.\"\n      render :erubis, template, options, locals\n    end\n\n    def haml(template, options = {}, locals = {}, &block)\n      render(:haml, template, options, locals, &block)\n    end\n\n    def sass(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :sass, template, options, locals\n    end\n\n    def scss(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :scss, template, options, locals\n    end\n\n    def less(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :less, template, options, locals\n    end\n\n    def stylus(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :styl, template, options, locals\n    end\n\n    def builder(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:builder, template, options, locals, &block)\n    end\n\n    def liquid(template, options = {}, locals = {}, &block)\n      render(:liquid, template, options, locals, &block)\n    end\n\n    def markdown(template, options = {}, locals = {})\n      render :markdown, template, options, locals\n    end\n\n    def textile(template, options = {}, locals = {})\n      render :textile, template, options, locals\n    end\n\n    def rdoc(template, options = {}, locals = {})\n      render :rdoc, template, options, locals\n    end\n\n    def asciidoc(template, options = {}, locals = {})\n      render :asciidoc, template, options, locals\n    end\n\n    def radius(template, options = {}, locals = {})\n      render :radius, template, options, locals\n    end\n\n    def markaby(template = nil, options = {}, locals = {}, &block)\n      render_ruby(:mab, template, options, locals, &block)\n    end\n\n    def coffee(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :js\n      render :coffee, template, options, locals\n    end\n\n    def nokogiri(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:nokogiri, template, options, locals, &block)\n    end\n\n    def slim(template, options = {}, locals = {}, &block)\n      render(:slim, template, options, locals, &block)\n    end\n\n    def creole(template, options = {}, locals = {})\n      render :creole, template, options, locals\n    end\n\n    def mediawiki(template, options = {}, locals = {})\n      render :mediawiki, template, options, locals\n    end\n\n    def wlang(template, options = {}, locals = {}, &block)\n      render(:wlang, template, options, locals, &block)\n    end\n\n    def yajl(template, options = {}, locals = {})\n      options[:default_content_type] = :json\n      render :yajl, template, options, locals\n    end\n\n    def rabl(template, options = {}, locals = {})\n      Rabl.register!\n      render :rabl, template, options, locals\n    end\n\n    # Calls the given block for every possible template file in views,\n    # named name.ext, where ext is registered on engine.\n    def find_template(views, name, engine)\n      yield ::File.join(views, \"#{name}.#{@preferred_extension}\")\n\n      if Tilt.respond_to?(:mappings)\n        Tilt.mappings.each do |ext, engines|\n          next unless ext != @preferred_extension and engines.include? engine\n          yield ::File.join(views, \"#{name}.#{ext}\")\n        end\n      else\n        Tilt.default_mapping.extensions_for(engine).each do |ext|\n          yield ::File.join(views, \"#{name}.#{ext}\") unless ext == @preferred_extension\n        end\n      end\n    end\n\n    private\n\n    # logic shared between builder and nokogiri\n    def render_ruby(engine, template, options = {}, locals = {}, &block)\n      options, template = template, nil if template.is_a?(Hash)\n      template = Proc.new { block } if template.nil?\n      render engine, template, options, locals\n    end\n\n    def render(engine, data, options = {}, locals = {}, &block)\n      # merge app-level options\n      engine_options = settings.respond_to?(engine) ? settings.send(engine) : {}\n      options.merge!(engine_options) { |key, v1, v2| v1 }\n\n      # extract generic options\n      locals          = options.delete(:locals) || locals         || {}\n      views           = options.delete(:views)  || settings.views || \"./views\"\n      layout          = options[:layout]\n      layout          = false if layout.nil? && options.include?(:layout)\n      eat_errors      = layout.nil?\n      layout          = engine_options[:layout] if layout.nil? or (layout == true && engine_options[:layout] != false)\n      layout          = @default_layout         if layout.nil? or layout == true\n      layout_options  = options.delete(:layout_options) || {}\n      content_type    = options.delete(:default_content_type)\n      content_type    = options.delete(:content_type)   || content_type\n      layout_engine   = options.delete(:layout_engine)  || engine\n      scope           = options.delete(:scope)          || self\n      options.delete(:layout)\n\n      # set some defaults\n      options[:outvar]           ||= '@_out_buf'\n      options[:default_encoding] ||= settings.default_encoding\n\n      # compile and render template\n      begin\n        layout_was      = @default_layout\n        @default_layout = false\n        template        = compile_template(engine, data, options, views)\n        output          = template.render(scope, locals, &block)\n      ensure\n        @default_layout = layout_was\n      end\n\n      # render layout\n      if layout\n        options = options.merge(:views => views, :layout => false, :eat_errors => eat_errors, :scope => scope).\n                merge!(layout_options)\n        catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } }\n      end\n\n      output.extend(ContentTyped).content_type = content_type if content_type\n      output\n    end\n\n    def compile_template(engine, data, options, views)\n      eat_errors = options.delete :eat_errors\n      template_cache.fetch engine, data, options, views do\n        template = Tilt[engine]\n        raise \"Template engine not found: #{engine}\" if template.nil?\n\n        case data\n        when Symbol\n          body, path, line = settings.templates[data]\n          if body\n            body = body.call if body.respond_to?(:call)\n            template.new(path, line.to_i, options) { body }\n          else\n            found = false\n            @preferred_extension = engine.to_s\n            find_template(views, data, template) do |file|\n              path ||= file # keep the initial path rather than the last one\n              if found = File.exist?(file)\n                path = file\n                break\n              end\n            end\n            throw :layout_missing if eat_errors and not found\n            template.new(path, 1, options)\n          end\n        when Proc, String\n          body = data.is_a?(String) ? Proc.new { data } : data\n          caller = settings.caller_locations.first\n          path = options[:path] || caller[0]\n          line = options[:line] || caller[1]\n          template.new(path, line.to_i, options, &body)\n        else\n          raise ArgumentError, \"Sorry, don't know how to render #{data.inspect}.\"\n        end\n      end\n    end\n  end\n\n  # Base class for all Sinatra applications and middleware.\n  class Base\n    include Rack::Utils\n    include Helpers\n    include Templates\n\n    URI_INSTANCE = URI::Parser.new\n\n    attr_accessor :app, :env, :request, :response, :params\n    attr_reader   :template_cache\n\n    def initialize(app = nil)\n      super()\n      @app = app\n      @template_cache = Tilt::Cache.new\n      yield self if block_given?\n    end\n\n    # Rack call interface.\n    def call(env)\n      dup.call!(env)\n    end\n\n    def call!(env) # :nodoc:\n      @env      = env\n      @params   = IndifferentHash.new\n      @request  = Request.new(env)\n      @response = Response.new\n      template_cache.clear if settings.reload_templates\n\n      @response['Content-Type'] = nil\n      invoke { dispatch! }\n      invoke { error_block!(response.status) } unless @env['sinatra.error']\n\n      unless @response['Content-Type']\n        if Array === body and body[0].respond_to? :content_type\n          content_type body[0].content_type\n        else\n          content_type :html\n        end\n      end\n\n      @response.finish\n    end\n\n    # Access settings defined with Base.set.\n    def self.settings\n      self\n    end\n\n    # Access settings defined with Base.set.\n    def settings\n      self.class.settings\n    end\n\n    def options\n      warn \"Sinatra::Base#options is deprecated and will be removed, \" \\\n        \"use #settings instead.\"\n      settings\n    end\n\n    # Exit the current block, halts any further processing\n    # of the request, and returns the specified response.\n    def halt(*response)\n      response = response.first if response.length == 1\n      throw :halt, response\n    end\n\n    # Pass control to the next matching route.\n    # If there are no more matching routes, Sinatra will\n    # return a 404 response.\n    def pass(&block)\n      throw :pass, block\n    end\n\n    # Forward the request to the downstream app -- middleware only.\n    def forward\n      fail \"downstream app not set\" unless @app.respond_to? :call\n      status, headers, body = @app.call env\n      @response.status = status\n      @response.body = body\n      @response.headers.merge! headers\n      nil\n    end\n\n    private\n\n    # Run filters defined on the class and all superclasses.\n    def filter!(type, base = settings)\n      filter! type, base.superclass if base.superclass.respond_to?(:filters)\n      base.filters[type].each { |args| process_route(*args) }\n    end\n\n    # Run routes defined on the class and all superclasses.\n    def route!(base = settings, pass_block = nil)\n      if routes = base.routes[@request.request_method]\n        routes.each do |pattern, conditions, block|\n          returned_pass_block = process_route(pattern, conditions) do |*args|\n            env['sinatra.route'] = \"#{@request.request_method} #{pattern}\"\n            route_eval { block[*args] }\n          end\n\n          # don't wipe out pass_block in superclass\n          pass_block = returned_pass_block if returned_pass_block\n        end\n      end\n\n      # Run routes defined in superclass.\n      if base.superclass.respond_to?(:routes)\n        return route!(base.superclass, pass_block)\n      end\n\n      route_eval(&pass_block) if pass_block\n      route_missing\n    end\n\n    # Run a route block and throw :halt with the result.\n    def route_eval\n      throw :halt, yield\n    end\n\n    # If the current request matches pattern and conditions, fill params\n    # with keys and call the given block.\n    # Revert params afterwards.\n    #\n    # Returns pass block.\n    def process_route(pattern, conditions, block = nil, values = [])\n      route = @request.path_info\n      route = '/' if route.empty? and not settings.empty_path_info?\n      route = route[0..-2] if !settings.strict_paths? && route != '/' && route.end_with?('/')\n      return unless params = pattern.params(route)\n\n      params.delete(\"ignore\") # TODO: better params handling, maybe turn it into \"smart\" object or detect changes\n      force_encoding(params)\n      original, @params = @params, @params.merge(params) if params.any?\n\n      regexp_exists = pattern.is_a?(Mustermann::Regular) || (pattern.respond_to?(:patterns) && pattern.patterns.any? {|subpattern| subpattern.is_a?(Mustermann::Regular)} )\n      if regexp_exists\n        captures           = pattern.match(route).captures\n        values            += captures\n        @params[:captures] = force_encoding(captures) unless captures.nil? || captures.empty?\n      else\n        values += params.values.flatten\n      end\n\n      catch(:pass) do\n        conditions.each { |c| throw :pass if c.bind(self).call == false }\n        block ? block[self, values] : yield(self, values)\n      end\n    rescue\n      @env['sinatra.error.params'] = @params\n      raise\n    ensure\n      @params = original if original\n    end\n\n    # No matching route was found or all routes passed. The default\n    # implementation is to forward the request downstream when running\n    # as middleware (@app is non-nil); when no downstream app is set, raise\n    # a NotFound exception. Subclasses can override this method to perform\n    # custom route miss logic.\n    def route_missing\n      if @app\n        forward\n      else\n        raise NotFound\n      end\n    end\n\n    # Attempt to serve static files from public directory. Throws :halt when\n    # a matching file is found, returns nil otherwise.\n    def static!(options = {})\n      return if (public_dir = settings.public_folder).nil?\n      path = File.expand_path(\"#{public_dir}#{URI_INSTANCE.unescape(request.path_info)}\" )\n      return unless File.file?(path)\n\n      env['sinatra.static_file'] = path\n      cache_control(*settings.static_cache_control) if settings.static_cache_control?\n      send_file path, options.merge(:disposition => nil)\n    end\n\n    # Run the block with 'throw :halt' support and apply result to the response.\n    def invoke\n      res = catch(:halt) { yield }\n\n      res = [res] if Integer === res or String === res\n      if Array === res and Integer === res.first\n        res = res.dup\n        status(res.shift)\n        body(res.pop)\n        headers(*res)\n      elsif res.respond_to? :each\n        body res\n      end\n      nil # avoid double setting the same response tuple twice\n    end\n\n    # Dispatch a request with error handling.\n    def dispatch!\n      force_encoding(@params.merge!(@request.params))\n\n      invoke do\n        static! if settings.static? && (request.get? || request.head?)\n        filter! :before\n        route!\n      end\n    rescue ::Exception => boom\n      invoke { handle_exception!(boom) }\n    ensure\n      begin\n        filter! :after unless env['sinatra.static_file']\n      rescue ::Exception => boom\n        invoke { handle_exception!(boom) } unless @env['sinatra.error']\n      end\n    end\n\n    # Error handling during requests.\n    def handle_exception!(boom)\n      if error_params = @env['sinatra.error.params']\n        @params = @params.merge(error_params)\n      end\n      @env['sinatra.error'] = boom\n\n      if boom.respond_to? :http_status\n        status(boom.http_status)\n      elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599\n        status(boom.code)\n      else\n        status(500)\n      end\n\n      status(500) unless status.between? 400, 599\n\n      boom_message = boom.message if boom.message && boom.message != boom.class.name\n      if server_error?\n        dump_errors! boom if settings.dump_errors?\n        raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler\n      elsif not_found?\n        headers['X-Cascade'] = 'pass' if settings.x_cascade?\n        body boom_message || '<h1>Not Found</h1>'\n      elsif bad_request?\n        body boom_message || '<h1>Bad Request</h1>'\n      end\n\n      res = error_block!(boom.class, boom) || error_block!(status, boom)\n      return res if res or not server_error?\n      raise boom if settings.raise_errors? or settings.show_exceptions?\n      error_block! Exception, boom\n    end\n\n    # Find an custom error block for the key(s) specified.\n    def error_block!(key, *block_params)\n      base = settings\n      while base.respond_to?(:errors)\n        next base = base.superclass unless args_array = base.errors[key]\n        args_array.reverse_each do |args|\n          first = args == args_array.first\n          args += [block_params]\n          resp = process_route(*args)\n          return resp unless resp.nil? && !first\n        end\n      end\n      return false unless key.respond_to? :superclass and key.superclass < Exception\n      error_block!(key.superclass, *block_params)\n    end\n\n    def dump_errors!(boom)\n      msg = [\"#{Time.now.strftime(\"%Y-%m-%d %H:%M:%S\")} - #{boom.class} - #{boom.message}:\", *boom.backtrace].join(\"\\n\\t\")\n      @env['rack.errors'].puts(msg)\n    end\n\n    class << self\n      CALLERS_TO_IGNORE = [ # :nodoc:\n        /\\/sinatra(\\/(base|main|show_exceptions))?\\.rb$/,   # all sinatra code\n        /lib\\/tilt.*\\.rb$/,                                 # all tilt code\n        /^\\(.*\\)$/,                                         # generated code\n        /rubygems\\/(custom|core_ext\\/kernel)_require\\.rb$/, # rubygems require hacks\n        /active_support/,                                   # active_support require hacks\n        /bundler(\\/runtime)?\\.rb/,                          # bundler require hacks\n        /<internal:/,                                       # internal in ruby >= 1.9.2\n        /src\\/kernel\\/bootstrap\\/[A-Z]/                     # maglev kernel files\n      ]\n\n      # contrary to what the comment said previously, rubinius never supported this\n      if defined?(RUBY_IGNORE_CALLERS)\n        warn \"RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0\"\n        CALLERS_TO_IGNORE.concat(RUBY_IGNORE_CALLERS)\n      end\n\n      attr_reader :routes, :filters, :templates, :errors\n\n      # Removes all routes, filters, middleware and extension hooks from the\n      # current class (not routes/filters/... defined by its superclass).\n      def reset!\n        @conditions     = []\n        @routes         = {}\n        @filters        = {:before => [], :after => []}\n        @errors         = {}\n        @middleware     = []\n        @prototype      = nil\n        @extensions     = []\n\n        if superclass.respond_to?(:templates)\n          @templates = Hash.new { |hash, key| superclass.templates[key] }\n        else\n          @templates = {}\n        end\n      end\n\n      # Extension modules registered on this class and all superclasses.\n      def extensions\n        if superclass.respond_to?(:extensions)\n          (@extensions + superclass.extensions).uniq\n        else\n          @extensions\n        end\n      end\n\n      # Middleware used in this class and all superclasses.\n      def middleware\n        if superclass.respond_to?(:middleware)\n          superclass.middleware + @middleware\n        else\n          @middleware\n        end\n      end\n\n      # Sets an option to the given value.  If the value is a proc,\n      # the proc will be called every time the option is accessed.\n      def set(option, value = (not_set = true), ignore_setter = false, &block)\n        raise ArgumentError if block and !not_set\n        value, not_set = block, false if block\n\n        if not_set\n          raise ArgumentError unless option.respond_to?(:each)\n          option.each { |k,v| set(k, v) }\n          return self\n        end\n\n        if respond_to?(\"#{option}=\") and not ignore_setter\n          return __send__(\"#{option}=\", value)\n        end\n\n        setter = proc { |val| set option, val, true }\n        getter = proc { value }\n\n        case value\n        when Proc\n          getter = value\n        when Symbol, Integer, FalseClass, TrueClass, NilClass\n          getter = value.inspect\n        when Hash\n          setter = proc do |val|\n            val = value.merge val if Hash === val\n            set option, val, true\n          end\n        end\n\n        define_singleton(\"#{option}=\", setter)\n        define_singleton(option, getter)\n        define_singleton(\"#{option}?\", \"!!#{option}\") unless method_defined? \"#{option}?\"\n        self\n      end\n\n      # Same as calling `set :option, true` for each of the given options.\n      def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end\n\n      # Same as calling `set :option, false` for each of the given options.\n      def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end\n\n      # Define a custom error handler. Optionally takes either an Exception\n      # class, or an HTTP status code to specify which errors should be\n      # handled.\n      def error(*codes, &block)\n        args  = compile! \"ERROR\", /.*/, block\n        codes = codes.flat_map(&method(:Array))\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n        codes.each { |c| (@errors[c] ||= []) << args }\n      end\n\n      # Sugar for `error(404) { ... }`\n      def not_found(&block)\n        error(404, &block)\n      end\n\n      # Define a named template. The block must return the template source.\n      def template(name, &block)\n        filename, line = caller_locations.first\n        templates[name] = [block, filename, line.to_i]\n      end\n\n      # Define the layout template. The block must return the template source.\n      def layout(name = :layout, &block)\n        template name, &block\n      end\n\n      # Load embedded templates from the file; uses the caller's __FILE__\n      # when no file is specified.\n      def inline_templates=(file = nil)\n        file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file\n\n        begin\n          io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file)\n          app, data = io.gsub(\"\\r\\n\", \"\\n\").split(/^__END__$/, 2)\n        rescue Errno::ENOENT\n          app, data = nil\n        end\n\n        if data\n          if app and app =~ /([^\\n]*\\n)?#[^\\n]*coding: *(\\S+)/m\n            encoding = $2\n          else\n            encoding = settings.default_encoding\n          end\n          lines = app.count(\"\\n\") + 1\n          template = nil\n          force_encoding data, encoding\n          data.each_line do |line|\n            lines += 1\n            if line =~ /^@@\\s*(.*\\S)\\s*$/\n              template = force_encoding(String.new, encoding)\n              templates[$1.to_sym] = [template, file, lines]\n            elsif template\n              template << line\n            end\n          end\n        end\n      end\n\n      # Lookup or register a mime type in Rack's mime registry.\n      def mime_type(type, value = nil)\n        return type      if type.nil?\n        return type.to_s if type.to_s.include?('/')\n        type = \".#{type}\" unless type.to_s[0] == ?.\n        return Rack::Mime.mime_type(type, nil) unless value\n        Rack::Mime::MIME_TYPES[type] = value\n      end\n\n      # provides all mime types matching type, including deprecated types:\n      #   mime_types :html # => ['text/html']\n      #   mime_types :js   # => ['application/javascript', 'text/javascript']\n      def mime_types(type)\n        type = mime_type type\n        type =~ /^application\\/(xml|javascript)$/ ? [type, \"text/#$1\"] : [type]\n      end\n\n      # Define a before filter; runs before all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def before(path = /.*/, **options, &block)\n        add_filter(:before, path, options, &block)\n      end\n\n      # Define an after filter; runs after all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def after(path = /.*/, **options, &block)\n        add_filter(:after, path, options, &block)\n      end\n\n      # add a filter\n      def add_filter(type, path = /.*/, **options, &block)\n        filters[type] << compile!(type, path, block, options)\n      end\n\n      # Add a route condition. The route is considered non-matching when the\n      # block returns false.\n      def condition(name = \"#{caller.first[/`.*'/]} condition\", &block)\n        @conditions << generate_method(name, &block)\n      end\n\n      def public=(value)\n        warn \":public is no longer used to avoid overloading Module#public, use :public_folder or :public_dir instead\"\n        set(:public_folder, value)\n      end\n\n      def public_dir=(value)\n        self.public_folder = value\n      end\n\n      def public_dir\n        public_folder\n      end\n\n      # Defining a `GET` handler also automatically defines\n      # a `HEAD` handler.\n      def get(path, opts = {}, &block)\n        conditions = @conditions.dup\n        route('GET', path, opts, &block)\n\n        @conditions = conditions\n        route('HEAD', path, opts, &block)\n      end\n\n      def put(path, opts = {}, &bk)     route 'PUT',     path, opts, &bk end\n      def post(path, opts = {}, &bk)    route 'POST',    path, opts, &bk end\n      def delete(path, opts = {}, &bk)  route 'DELETE',  path, opts, &bk end\n      def head(path, opts = {}, &bk)    route 'HEAD',    path, opts, &bk end\n      def options(path, opts = {}, &bk) route 'OPTIONS', path, opts, &bk end\n      def patch(path, opts = {}, &bk)   route 'PATCH',   path, opts, &bk end\n      def link(path, opts = {}, &bk)    route 'LINK',    path, opts, &bk end\n      def unlink(path, opts = {}, &bk)  route 'UNLINK',  path, opts, &bk end\n\n      # Makes the methods defined in the block and in the Modules given\n      # in `extensions` available to the handlers and templates\n      def helpers(*extensions, &block)\n        class_eval(&block)   if block_given?\n        include(*extensions) if extensions.any?\n      end\n\n      # Register an extension. Alternatively take a block from which an\n      # extension will be created and registered on the fly.\n      def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end\n\n      def development?; environment == :development end\n      def production?;  environment == :production  end\n      def test?;        environment == :test        end\n\n      # Set configuration options for Sinatra and/or the app.\n      # Allows scoping of settings for certain environments.\n      def configure(*envs)\n        yield self if envs.empty? || envs.include?(environment.to_sym)\n      end\n\n      # Use the specified Rack middleware\n      def use(middleware, *args, &block)\n        @prototype = nil\n        @middleware << [middleware, args, block]\n      end\n\n      # Stop the self-hosted server if running.\n      def quit!\n        return unless running?\n        # Use Thin's hard #stop! if available, otherwise just #stop.\n        running_server.respond_to?(:stop!) ? running_server.stop! : running_server.stop\n        $stderr.puts \"== Sinatra has ended his set (crowd applauds)\" unless suppress_messages?\n        set :running_server, nil\n        set :handler_name, nil\n      end\n\n      alias_method :stop!, :quit!\n\n      # Run the Sinatra app as a self-hosted server using\n      # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call\n      # with the constructed handler once we have taken the stage.\n      def run!(options = {}, &block)\n        return if running?\n        set options\n        handler         = detect_rack_handler\n        handler_name    = handler.name.gsub(/.*::/, '')\n        server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {}\n        server_settings.merge!(:Port => port, :Host => bind)\n\n        begin\n          start_server(handler, server_settings, handler_name, &block)\n        rescue Errno::EADDRINUSE\n          $stderr.puts \"== Someone is already performing on port #{port}!\"\n          raise\n        ensure\n          quit!\n        end\n      end\n\n      alias_method :start!, :run!\n\n      # Check whether the self-hosted server is running or not.\n      def running?\n        running_server?\n      end\n\n      # The prototype instance used to process requests.\n      def prototype\n        @prototype ||= new\n      end\n\n      # Create a new instance without middleware in front of it.\n      alias new! new unless method_defined? :new!\n\n      # Create a new instance of the class fronted by its middleware\n      # pipeline. The object is guaranteed to respond to #call but may not be\n      # an instance of the class new was called on.\n      def new(*args, &bk)\n        instance = new!(*args, &bk)\n        Wrapper.new(build(instance).to_app, instance)\n      end\n\n      # Creates a Rack::Builder instance with all the middleware set up and\n      # the given +app+ as end point.\n      def build(app)\n        builder = Rack::Builder.new\n        setup_default_middleware builder\n        setup_middleware builder\n        builder.run app\n        builder\n      end\n\n      def call(env)\n        synchronize { prototype.call(env) }\n      end\n\n      # Like Kernel#caller but excluding certain magic entries and without\n      # line / method information; the resulting array contains filenames only.\n      def caller_files\n        cleaned_caller(1).flatten\n      end\n\n      # Like caller_files, but containing Arrays rather than strings with the\n      # first element being the file, and the second being the line.\n      def caller_locations\n        cleaned_caller 2\n      end\n\n      private\n\n      # Starts the server by running the Rack Handler.\n      def start_server(handler, server_settings, handler_name)\n        # Ensure we initialize middleware before startup, to match standard Rack\n        # behavior, by ensuring an instance exists:\n        prototype\n        # Run the instance we created:\n        handler.run(self, server_settings) do |server|\n          unless suppress_messages?\n            $stderr.puts \"== Sinatra (v#{Sinatra::VERSION}) has taken the stage on #{port} for #{environment} with backup from #{handler_name}\"\n          end\n\n          setup_traps\n          set :running_server, server\n          set :handler_name,   handler_name\n          server.threaded = settings.threaded if server.respond_to? :threaded=\n\n          yield server if block_given?\n        end\n      end\n\n      def suppress_messages?\n        handler_name =~ /cgi/i || quiet\n      end\n\n      def setup_traps\n        if traps?\n          at_exit { quit! }\n\n          [:INT, :TERM].each do |signal|\n            old_handler = trap(signal) do\n              quit!\n              old_handler.call if old_handler.respond_to?(:call)\n            end\n          end\n\n          set :traps, false\n        end\n      end\n\n      # Dynamically defines a method on settings.\n      def define_singleton(name, content = Proc.new)\n        singleton_class.class_eval do\n          undef_method(name) if method_defined? name\n          String === content ? class_eval(\"def #{name}() #{content}; end\") : define_method(name, &content)\n        end\n      end\n\n      # Condition for matching host name. Parameter might be String or Regexp.\n      def host_name(pattern)\n        condition { pattern === request.host }\n      end\n\n      # Condition for matching user agent. Parameter should be Regexp.\n      # Will set params[:agent].\n      def user_agent(pattern)\n        condition do\n          if request.user_agent.to_s =~ pattern\n            @params[:agent] = $~[1..-1]\n            true\n          else\n            false\n          end\n        end\n      end\n      alias_method :agent, :user_agent\n\n      # Condition for matching mimetypes. Accepts file extensions.\n      def provides(*types)\n        types.map! { |t| mime_types(t) }\n        types.flatten!\n        condition do\n          if type = response['Content-Type']\n            types.include? type or types.include? type[/^[^;]+/]\n          elsif type = request.preferred_type(types)\n            params = (type.respond_to?(:params) ? type.params : {})\n            content_type(type, params)\n            true\n          else\n            false\n          end\n        end\n      end\n\n      def route(verb, path, options = {}, &block)\n        enable :empty_path_info if path == \"\" and empty_path_info.nil?\n        signature = compile!(verb, path, block, options)\n        (@routes[verb] ||= []) << signature\n        invoke_hook(:route_added, verb, path, block)\n        signature\n      end\n\n      def invoke_hook(name, *args)\n        extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end\n\n      def generate_method(method_name, &block)\n        define_method(method_name, &block)\n        method = instance_method method_name\n        remove_method method_name\n        method\n      end\n\n      def compile!(verb, path, block, **options)\n        # Because of self.options.host\n        host_name(options.delete(:host)) if options.key?(:host)\n        # Pass Mustermann opts to compile()\n        route_mustermann_opts = options.key?(:mustermann_opts) ? options.delete(:mustermann_opts) : {}.freeze\n\n        options.each_pair { |option, args| send(option, *args) }\n\n        pattern                 = compile(path, route_mustermann_opts)\n        method_name             = \"#{verb} #{path}\"\n        unbound_method          = generate_method(method_name, &block)\n        conditions, @conditions = @conditions, []\n        wrapper                 = block.arity != 0 ?\n          proc { |a, p| unbound_method.bind(a).call(*p) } :\n          proc { |a, p| unbound_method.bind(a).call }\n\n        [ pattern, conditions, wrapper ]\n      end\n\n      def compile(path, route_mustermann_opts = {})\n        Mustermann.new(path, mustermann_opts.merge(route_mustermann_opts))\n      end\n\n      def setup_default_middleware(builder)\n        builder.use ExtendedRack\n        builder.use ShowExceptions       if show_exceptions?\n        builder.use Rack::MethodOverride if method_override?\n        builder.use Rack::Head\n        setup_logging    builder\n        setup_sessions   builder\n        setup_protection builder\n      end\n\n      def setup_middleware(builder)\n        middleware.each { |c,a,b| builder.use(c, *a, &b) }\n      end\n\n      def setup_logging(builder)\n        if logging?\n          setup_common_logger(builder)\n          setup_custom_logger(builder)\n        elsif logging == false\n          setup_null_logger(builder)\n        end\n      end\n\n      def setup_null_logger(builder)\n        builder.use Rack::NullLogger\n      end\n\n      def setup_common_logger(builder)\n        builder.use Sinatra::CommonLogger\n      end\n\n      def setup_custom_logger(builder)\n        if logging.respond_to? :to_int\n          builder.use Rack::Logger, logging\n        else\n          builder.use Rack::Logger\n        end\n      end\n\n      def setup_protection(builder)\n        return unless protection?\n        options = Hash === protection ? protection.dup : {}\n        options = {\n          img_src:  \"'self' data:\",\n          font_src: \"'self'\"\n        }.merge options\n\n        protect_session = options.fetch(:session) { sessions? }\n        options[:without_session] = !protect_session\n\n        options[:reaction] ||= :drop_session\n\n        builder.use Rack::Protection, options\n      end\n\n      def setup_sessions(builder)\n        return unless sessions?\n        options = {}\n        options[:secret] = session_secret if session_secret?\n        options.merge! sessions.to_hash if sessions.respond_to? :to_hash\n        builder.use session_store, options\n      end\n\n      def detect_rack_handler\n        servers = Array(server)\n        servers.each do |server_name|\n          begin\n            return Rack::Handler.get(server_name.to_s)\n          rescue LoadError, NameError\n          end\n        end\n        fail \"Server handler (#{servers.join(',')}) not found.\"\n      end\n\n      def inherited(subclass)\n        subclass.reset!\n        subclass.set :app_file, caller_files.first unless subclass.app_file?\n        super\n      end\n\n      @@mutex = Mutex.new\n      def synchronize(&block)\n        if lock?\n          @@mutex.synchronize(&block)\n        else\n          yield\n        end\n      end\n\n      # used for deprecation warnings\n      def warn(message)\n        super message + \"\\n\\tfrom #{cleaned_caller.first.join(':')}\"\n      end\n\n      # Like Kernel#caller but excluding certain magic entries\n      def cleaned_caller(keep = 3)\n        caller(1).\n          map!    { |line| line.split(/:(?=\\d|in )/, 3)[0,keep] }.\n          reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } }\n      end\n    end\n\n    # Fixes encoding issues by\n    # * defaulting to UTF-8\n    # * casting params to Encoding.default_external\n    #\n    # The latter might not be necessary if Rack handles it one day.\n    # Keep an eye on Rack's LH #100.\n    def force_encoding(*args) settings.force_encoding(*args) end\n    if defined? Encoding\n      def self.force_encoding(data, encoding = default_encoding)\n        return if data == settings || data.is_a?(Tempfile)\n        if data.respond_to? :force_encoding\n          data.force_encoding(encoding).encode!\n        elsif data.respond_to? :each_value\n          data.each_value { |v| force_encoding(v, encoding) }\n        elsif data.respond_to? :each\n          data.each { |v| force_encoding(v, encoding) }\n        end\n        data\n      end\n    else\n      def self.force_encoding(data, *) data end\n    end\n\n    reset!\n\n    set :environment, (ENV['APP_ENV'] || ENV['RACK_ENV'] || :development).to_sym\n    set :raise_errors, Proc.new { test? }\n    set :dump_errors, Proc.new { !test? }\n    set :show_exceptions, Proc.new { development? }\n    set :sessions, false\n    set :session_store, Rack::Session::Cookie\n    set :logging, false\n    set :protection, true\n    set :method_override, false\n    set :use_code, false\n    set :default_encoding, \"utf-8\"\n    set :x_cascade, true\n    set :add_charset, %w[javascript xml xhtml+xml].map { |t| \"application/#{t}\" }\n    settings.add_charset << /^text\\//\n    set :mustermann_opts, {}\n\n    # explicitly generating a session secret eagerly to play nice with preforking\n    begin\n      require 'securerandom'\n      set :session_secret, SecureRandom.hex(64)\n    rescue LoadError, NotImplementedError\n      # SecureRandom raises a NotImplementedError if no random device is available\n      set :session_secret, \"%064x\" % Kernel.rand(2**256-1)\n    end\n\n    class << self\n      alias_method :methodoverride?, :method_override?\n      alias_method :methodoverride=, :method_override=\n    end\n\n    set :run, false                       # start server via at-exit hook?\n    set :running_server, nil\n    set :handler_name, nil\n    set :traps, true\n    set :server, %w[HTTP webrick]\n    set :bind, Proc.new { development? ? 'localhost' : '0.0.0.0' }\n    set :port, Integer(ENV['PORT'] && !ENV['PORT'].empty? ? ENV['PORT'] : 4567)\n    set :quiet, false\n\n    ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE\n\n    if ruby_engine == 'macruby'\n      server.unshift 'control_tower'\n    else\n      server.unshift 'reel'\n      server.unshift 'mongrel'  if ruby_engine.nil?\n      server.unshift 'puma'     if ruby_engine != 'rbx'\n      server.unshift 'thin'     if ruby_engine != 'jruby'\n      server.unshift 'puma'     if ruby_engine == 'rbx'\n      server.unshift 'trinidad' if ruby_engine == 'jruby'\n    end\n\n    set :absolute_redirects, true\n    set :prefixed_redirects, false\n    set :empty_path_info, nil\n    set :strict_paths, true\n\n    set :app_file, nil\n    set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) }\n    set :views, Proc.new { root && File.join(root, 'views') }\n    set :reload_templates, Proc.new { development? }\n    set :lock, false\n    set :threaded, true\n\n    set :public_folder, Proc.new { root && File.join(root, 'public') }\n    set :static, Proc.new { public_folder && File.exist?(public_folder) }\n    set :static_cache_control, false\n\n    error ::Exception do\n      response.status = 500\n      content_type 'text/html'\n      '<h1>Internal Server Error</h1>'\n    end\n\n    configure :development do\n      get '/__sinatra__/:image.png' do\n        filename = File.dirname(__FILE__) + \"/images/#{params[:image].to_i}.png\"\n        content_type :png\n        send_file filename\n      end\n\n      error NotFound do\n        content_type 'text/html'\n\n        if self.class == Sinatra::Application\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            #{request.request_method.downcase} '#{request.path_info}' do\n              \"Hello World\"\n            end\n          RUBY\n        else\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            class #{self.class}\n              #{request.request_method.downcase} '#{request.path_info}' do\n                \"Hello World\"\n              end\n            end\n          RUBY\n\n          file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\\//, '')\n          code = \"# in #{file}\\n#{code}\" unless file.empty?\n        end\n\n        (<<-HTML).gsub(/^ {10}/, '')\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <style type=\"text/css\">\n            body { text-align:center;font-family:helvetica,arial;font-size:22px;\n              color:#888;margin:20px}\n            #c {margin:0 auto;width:500px;text-align:left}\n            </style>\n          </head>\n          <body>\n            <h2>Sinatra doesn\u2019t know this ditty.</h2>\n            <img src='#{uri \"/__sinatra__/404.png\"}'>\n            <div id=\"c\">\n              Try this:\n              <pre>#{Rack::Utils.escape_html(code)}</pre>\n            </div>\n          </body>\n          </html>\n        HTML\n      end\n    end\n  end\n\n  # Execution context for classic style (top-level) applications. All\n  # DSL methods executed on main are delegated to this class.\n  #\n  # The Application class should not be subclassed, unless you want to\n  # inherit all settings, routes, handlers, and error pages from the\n  # top-level. Subclassing Sinatra::Base is highly recommended for\n  # modular applications.\n  class Application < Base\n    set :logging, Proc.new { !test? }\n    set :method_override, true\n    set :run, Proc.new { !test? }\n    set :app_file, nil\n\n    def self.register(*extensions, &block) #:nodoc:\n      added_methods = extensions.flat_map(&:public_instance_methods)\n      Delegator.delegate(*added_methods)\n      super(*extensions, &block)\n    end\n  end\n\n  # Sinatra delegation mixin. Mixing this module into an object causes all\n  # methods to be delegated to the Sinatra::Application class. Used primarily\n  # at the top-level.\n  module Delegator #:nodoc:\n    def self.delegate(*methods)\n      methods.each do |method_name|\n        define_method(method_name) do |*args, &block|\n          return super(*args, &block) if respond_to? method_name\n          Delegator.target.send(method_name, *args, &block)\n        end\n        private method_name\n      end\n    end\n\n    delegate :get, :patch, :put, :post, :delete, :head, :options, :link, :unlink,\n             :template, :layout, :before, :after, :error, :not_found, :configure,\n             :set, :mime_type, :enable, :disable, :use, :development?, :test?,\n             :production?, :helpers, :settings, :register\n\n    class << self\n      attr_accessor :target\n    end\n\n    self.target = Application\n  end\n\n  class Wrapper\n    def initialize(stack, instance)\n      @stack, @instance = stack, instance\n    end\n\n    def settings\n      @instance.settings\n    end\n\n    def helpers\n      @instance\n    end\n\n    def call(env)\n      @stack.call(env)\n    end\n\n    def inspect\n      \"#<#{@instance.class} app_file=#{settings.app_file.inspect}>\"\n    end\n  end\n\n  # Create a new Sinatra application; the block is evaluated in the class scope.\n  def self.new(base = Base, &block)\n    base = Class.new(base)\n    base.class_eval(&block) if block_given?\n    base\n  end\n\n  # Extend the top-level DSL with the modules provided.\n  def self.register(*extensions, &block)\n    Delegator.target.register(*extensions, &block)\n  end\n\n  # Include the helper modules provided in Sinatra's request context.\n  def self.helpers(*extensions, &block)\n    Delegator.target.helpers(*extensions, &block)\n  end\n\n  # Use the middleware for classic applications.\n  def self.use(*args, &block)\n    Delegator.target.use(*args, &block)\n  end\nend\n"], "fixing_code": ["# coding: utf-8\n# frozen_string_literal: true\n\n# external dependencies\nrequire 'rack'\nrequire 'tilt'\nrequire 'rack/protection'\nrequire 'mustermann'\nrequire 'mustermann/sinatra'\nrequire 'mustermann/regular'\n\n# stdlib dependencies\nrequire 'thread'\nrequire 'time'\nrequire 'uri'\n\n# other files we need\nrequire 'sinatra/indifferent_hash'\nrequire 'sinatra/show_exceptions'\nrequire 'sinatra/version'\n\nmodule Sinatra\n  # The request object. See Rack::Request for more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Request\n  class Request < Rack::Request\n    HEADER_PARAM = /\\s*[\\w.]+=(?:[\\w.]+|\"(?:[^\"\\\\]|\\\\.)*\")?\\s*/\n    HEADER_VALUE_WITH_PARAMS = /(?:(?:\\w+|\\*)\\/(?:\\w+(?:\\.|\\-|\\+)?|\\*)*)\\s*(?:;#{HEADER_PARAM})*/\n\n    # Returns an array of acceptable media types for the response\n    def accept\n      @env['sinatra.accept'] ||= begin\n        if @env.include? 'HTTP_ACCEPT' and @env['HTTP_ACCEPT'].to_s != ''\n          @env['HTTP_ACCEPT'].to_s.scan(HEADER_VALUE_WITH_PARAMS).\n            map! { |e| AcceptEntry.new(e) }.sort\n        else\n          [AcceptEntry.new('*/*')]\n        end\n      end\n    end\n\n    def accept?(type)\n      preferred_type(type).to_s.include?(type)\n    end\n\n    def preferred_type(*types)\n      accepts = accept # just evaluate once\n      return accepts.first if types.empty?\n      types.flatten!\n      return types.first if accepts.empty?\n      accepts.detect do |pattern|\n        type = types.detect { |t| File.fnmatch(pattern, t) }\n        return type if type\n      end\n    end\n\n    alias secure? ssl?\n\n    def forwarded?\n      @env.include? \"HTTP_X_FORWARDED_HOST\"\n    end\n\n    def safe?\n      get? or head? or options? or trace?\n    end\n\n    def idempotent?\n      safe? or put? or delete? or link? or unlink?\n    end\n\n    def link?\n      request_method == \"LINK\"\n    end\n\n    def unlink?\n      request_method == \"UNLINK\"\n    end\n\n    def params\n      super\n    rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e\n      raise BadRequest, \"Invalid query parameters: #{Rack::Utils.escape_html(e.message)}\"\n    end\n\n    private\n\n    class AcceptEntry\n      attr_accessor :params\n      attr_reader :entry\n\n      def initialize(entry)\n        params = entry.scan(HEADER_PARAM).map! do |s|\n          key, value = s.strip.split('=', 2)\n          value = value[1..-2].gsub(/\\\\(.)/, '\\1') if value.start_with?('\"')\n          [key, value]\n        end\n\n        @entry  = entry\n        @type   = entry[/[^;]+/].delete(' ')\n        @params = Hash[params]\n        @q      = @params.delete('q') { 1.0 }.to_f\n      end\n\n      def <=>(other)\n        other.priority <=> self.priority\n      end\n\n      def priority\n        # We sort in descending order; better matches should be higher.\n        [ @q, -@type.count('*'), @params.size ]\n      end\n\n      def to_str\n        @type\n      end\n\n      def to_s(full = false)\n        full ? entry : to_str\n      end\n\n      def respond_to?(*args)\n        super or to_str.respond_to?(*args)\n      end\n\n      def method_missing(*args, &block)\n        to_str.send(*args, &block)\n      end\n    end\n  end\n\n  # The response object. See Rack::Response and Rack::Response::Helpers for\n  # more info:\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response\n  # http://rubydoc.info/github/rack/rack/master/Rack/Response/Helpers\n  class Response < Rack::Response\n    DROP_BODY_RESPONSES = [204, 304]\n    def initialize(*)\n      super\n      headers['Content-Type'] ||= 'text/html'\n    end\n\n    def body=(value)\n      value = value.body while Rack::Response === value\n      @body = String === value ? [value.to_str] : value\n    end\n\n    def each\n      block_given? ? super : enum_for(:each)\n    end\n\n    def finish\n      result = body\n\n      if drop_content_info?\n        headers.delete \"Content-Length\"\n        headers.delete \"Content-Type\"\n      end\n\n      if drop_body?\n        close\n        result = []\n      end\n\n      if calculate_content_length?\n        # if some other code has already set Content-Length, don't muck with it\n        # currently, this would be the static file-handler\n        headers[\"Content-Length\"] = body.inject(0) { |l, p| l + p.bytesize }.to_s\n      end\n\n      [status.to_i, headers, result]\n    end\n\n    private\n\n    def calculate_content_length?\n      headers[\"Content-Type\"] and not headers[\"Content-Length\"] and Array === body\n    end\n\n    def drop_content_info?\n      status.to_i / 100 == 1 or drop_body?\n    end\n\n    def drop_body?\n      DROP_BODY_RESPONSES.include?(status.to_i)\n    end\n  end\n\n  # Some Rack handlers (Thin, Rainbows!) implement an extended body object protocol, however,\n  # some middleware (namely Rack::Lint) will break it by not mirroring the methods in question.\n  # This middleware will detect an extended body object and will make sure it reaches the\n  # handler directly. We do this here, so our middleware and middleware set up by the app will\n  # still be able to run.\n  class ExtendedRack < Struct.new(:app)\n    def call(env)\n      result, callback = app.call(env), env['async.callback']\n      return result unless callback and async?(*result)\n      after_response { callback.call result }\n      setup_close(env, *result)\n      throw :async\n    end\n\n    private\n\n    def setup_close(env, status, headers, body)\n      return unless body.respond_to? :close and env.include? 'async.close'\n      env['async.close'].callback { body.close }\n      env['async.close'].errback { body.close }\n    end\n\n    def after_response(&block)\n      raise NotImplementedError, \"only supports EventMachine at the moment\" unless defined? EventMachine\n      EventMachine.next_tick(&block)\n    end\n\n    def async?(status, headers, body)\n      return true if status == -1\n      body.respond_to? :callback and body.respond_to? :errback\n    end\n  end\n\n  # Behaves exactly like Rack::CommonLogger with the notable exception that it does nothing,\n  # if another CommonLogger is already in the middleware chain.\n  class CommonLogger < Rack::CommonLogger\n    def call(env)\n      env['sinatra.commonlogger'] ? @app.call(env) : super\n    end\n\n    superclass.class_eval do\n      alias call_without_check call unless method_defined? :call_without_check\n      def call(env)\n        env['sinatra.commonlogger'] = true\n        call_without_check(env)\n      end\n    end\n  end\n\n  class BadRequest < TypeError #:nodoc:\n    def http_status; 400 end\n  end\n\n  class NotFound < NameError #:nodoc:\n    def http_status; 404 end\n  end\n\n  # Methods available to routes, before/after filters, and views.\n  module Helpers\n    # Set or retrieve the response status code.\n    def status(value = nil)\n      response.status = Rack::Utils.status_code(value) if value\n      response.status\n    end\n\n    # Set or retrieve the response body. When a block is given,\n    # evaluation is deferred until the body is read with #each.\n    def body(value = nil, &block)\n      if block_given?\n        def block.each; yield(call) end\n        response.body = block\n      elsif value\n        # Rack 2.0 returns a Rack::File::Iterator here instead of\n        # Rack::File as it was in the previous API.\n        unless request.head? || value.is_a?(Rack::File::Iterator) || value.is_a?(Stream)\n          headers.delete 'Content-Length'\n        end\n        response.body = value\n      else\n        response.body\n      end\n    end\n\n    # Halt processing and redirect to the URI provided.\n    def redirect(uri, *args)\n      if env['HTTP_VERSION'] == 'HTTP/1.1' and env[\"REQUEST_METHOD\"] != 'GET'\n        status 303\n      else\n        status 302\n      end\n\n      # According to RFC 2616 section 14.30, \"the field value consists of a\n      # single absolute URI\"\n      response['Location'] = uri(uri.to_s, settings.absolute_redirects?, settings.prefixed_redirects?)\n      halt(*args)\n    end\n\n    # Generates the absolute URI for a given path in the app.\n    # Takes Rack routers and reverse proxies into account.\n    def uri(addr = nil, absolute = true, add_script_name = true)\n      return addr if addr =~ /\\A[a-z][a-z0-9\\+\\.\\-]*:/i\n      uri = [host = String.new]\n      if absolute\n        host << \"http#{'s' if request.secure?}://\"\n        if request.forwarded? or request.port != (request.secure? ? 443 : 80)\n          host << request.host_with_port\n        else\n          host << request.host\n        end\n      end\n      uri << request.script_name.to_s if add_script_name\n      uri << (addr ? addr : request.path_info).to_s\n      File.join uri\n    end\n\n    alias url uri\n    alias to uri\n\n    # Halt processing and return the error status provided.\n    def error(code, body = nil)\n      code, body    = 500, code.to_str if code.respond_to? :to_str\n      response.body = body unless body.nil?\n      halt code\n    end\n\n    # Halt processing and return a 404 Not Found.\n    def not_found(body = nil)\n      error 404, body\n    end\n\n    # Set multiple response headers with Hash.\n    def headers(hash = nil)\n      response.headers.merge! hash if hash\n      response.headers\n    end\n\n    # Access the underlying Rack session.\n    def session\n      request.session\n    end\n\n    # Access shared logger object.\n    def logger\n      request.logger\n    end\n\n    # Look up a media type by file extension in Rack's mime registry.\n    def mime_type(type)\n      Base.mime_type(type)\n    end\n\n    # Set the Content-Type of the response body given a media type or file\n    # extension.\n    def content_type(type = nil, params = {})\n      return response['Content-Type'] unless type\n      default = params.delete :default\n      mime_type = mime_type(type) || default\n      fail \"Unknown media type: %p\" % type if mime_type.nil?\n      mime_type = mime_type.dup\n      unless params.include? :charset or settings.add_charset.all? { |p| not p === mime_type }\n        params[:charset] = params.delete('charset') || settings.default_encoding\n      end\n      params.delete :charset if mime_type.include? 'charset'\n      unless params.empty?\n        mime_type << (mime_type.include?(';') ? ', ' : ';')\n        mime_type << params.map do |key, val|\n          val = val.inspect if val =~ /[\";,]/\n          \"#{key}=#{val}\"\n        end.join(', ')\n      end\n      response['Content-Type'] = mime_type\n    end\n\n    # Set the Content-Disposition to \"attachment\" with the specified filename,\n    # instructing the user agents to prompt to save.\n    def attachment(filename = nil, disposition = :attachment)\n      response['Content-Disposition'] = disposition.to_s\n      if filename\n        params = '; filename=\"%s\"' % File.basename(filename)\n        response['Content-Disposition'] << params\n        ext = File.extname(filename)\n        content_type(ext) unless response['Content-Type'] or ext.empty?\n      end\n    end\n\n    # Use the contents of the file at +path+ as the response body.\n    def send_file(path, opts = {})\n      if opts[:type] or not response['Content-Type']\n        content_type opts[:type] || File.extname(path), :default => 'application/octet-stream'\n      end\n\n      disposition = opts[:disposition]\n      filename    = opts[:filename]\n      disposition = :attachment if disposition.nil? and filename\n      filename    = path        if filename.nil?\n      attachment(filename, disposition) if disposition\n\n      last_modified opts[:last_modified] if opts[:last_modified]\n\n      file   = Rack::File.new(File.dirname(settings.app_file))\n      result = file.serving(request, path)\n\n      result[1].each { |k,v| headers[k] ||= v }\n      headers['Content-Length'] = result[1]['Content-Length']\n      opts[:status] &&= Integer(opts[:status])\n      halt (opts[:status] || result[0]), result[2]\n    rescue Errno::ENOENT\n      not_found\n    end\n\n    # Class of the response body in case you use #stream.\n    #\n    # Three things really matter: The front and back block (back being the\n    # block generating content, front the one sending it to the client) and\n    # the scheduler, integrating with whatever concurrency feature the Rack\n    # handler is using.\n    #\n    # Scheduler has to respond to defer and schedule.\n    class Stream\n      def self.schedule(*) yield end\n      def self.defer(*)    yield end\n\n      def initialize(scheduler = self.class, keep_open = false, &back)\n        @back, @scheduler, @keep_open = back.to_proc, scheduler, keep_open\n        @callbacks, @closed = [], false\n      end\n\n      def close\n        return if closed?\n        @closed = true\n        @scheduler.schedule { @callbacks.each { |c| c.call } }\n      end\n\n      def each(&front)\n        @front = front\n        @scheduler.defer do\n          begin\n            @back.call(self)\n          rescue Exception => e\n            @scheduler.schedule { raise e }\n          end\n          close unless @keep_open\n        end\n      end\n\n      def <<(data)\n        @scheduler.schedule { @front.call(data.to_s) }\n        self\n      end\n\n      def callback(&block)\n        return yield if closed?\n        @callbacks << block\n      end\n\n      alias errback callback\n\n      def closed?\n        @closed\n      end\n    end\n\n    # Allows to start sending data to the client even though later parts of\n    # the response body have not yet been generated.\n    #\n    # The close parameter specifies whether Stream#close should be called\n    # after the block has been executed. This is only relevant for evented\n    # servers like Thin or Rainbows.\n    def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      body Stream.new(scheduler, keep_open) { |out| with_params(current) { yield(out) } }\n    end\n\n    # Specify response freshness policy for HTTP caches (Cache-Control header).\n    # Any number of non-value directives (:public, :private, :no_cache,\n    # :no_store, :must_revalidate, :proxy_revalidate) may be passed along with\n    # a Hash of value directives (:max_age, :s_maxage).\n    #\n    #   cache_control :public, :must_revalidate, :max_age => 60\n    #   => Cache-Control: public, must-revalidate, max-age=60\n    #\n    # See RFC 2616 / 14.9 for more on standard cache control directives:\n    # http://tools.ietf.org/html/rfc2616#section-14.9.1\n    def cache_control(*values)\n      if values.last.kind_of?(Hash)\n        hash = values.pop\n        hash.reject! { |k, v| v == false }\n        hash.reject! { |k, v| values << k if v == true }\n      else\n        hash = {}\n      end\n\n      values.map! { |value| value.to_s.tr('_','-') }\n      hash.each do |key, value|\n        key = key.to_s.tr('_', '-')\n        value = value.to_i if ['max-age', 's-maxage'].include? key\n        values << \"#{key}=#{value}\"\n      end\n\n      response['Cache-Control'] = values.join(', ') if values.any?\n    end\n\n    # Set the Expires header and Cache-Control/max-age directive. Amount\n    # can be an integer number of seconds in the future or a Time object\n    # indicating when the response should be considered \"stale\". The remaining\n    # \"values\" arguments are passed to the #cache_control helper:\n    #\n    #   expires 500, :public, :must_revalidate\n    #   => Cache-Control: public, must-revalidate, max-age=500\n    #   => Expires: Mon, 08 Jun 2009 08:50:17 GMT\n    #\n    def expires(amount, *values)\n      values << {} unless values.last.kind_of?(Hash)\n\n      if amount.is_a? Integer\n        time    = Time.now + amount.to_i\n        max_age = amount\n      else\n        time    = time_for amount\n        max_age = time - Time.now\n      end\n\n      values.last.merge!(:max_age => max_age)\n      cache_control(*values)\n\n      response['Expires'] = time.httpdate\n    end\n\n    # Set the last modified time of the resource (HTTP 'Last-Modified' header)\n    # and halt if conditional GET matches. The +time+ argument is a Time,\n    # DateTime, or other object that responds to +to_time+.\n    #\n    # When the current request includes an 'If-Modified-Since' header that is\n    # equal or later than the time specified, execution is immediately halted\n    # with a '304 Not Modified' response.\n    def last_modified(time)\n      return unless time\n      time = time_for time\n      response['Last-Modified'] = time.httpdate\n      return if env['HTTP_IF_NONE_MATCH']\n\n      if status == 200 and env['HTTP_IF_MODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_MODIFIED_SINCE']).to_i\n        halt 304 if since >= time.to_i\n      end\n\n      if (success? or status == 412) and env['HTTP_IF_UNMODIFIED_SINCE']\n        # compare based on seconds since epoch\n        since = Time.httpdate(env['HTTP_IF_UNMODIFIED_SINCE']).to_i\n        halt 412 if since < time.to_i\n      end\n    rescue ArgumentError\n    end\n\n    ETAG_KINDS = [:strong, :weak]\n    # Set the response entity tag (HTTP 'ETag' header) and halt if conditional\n    # GET matches. The +value+ argument is an identifier that uniquely\n    # identifies the current version of the resource. The +kind+ argument\n    # indicates whether the etag should be used as a :strong (default) or :weak\n    # cache validator.\n    #\n    # When the current request includes an 'If-None-Match' header with a\n    # matching etag, execution is immediately halted. If the request method is\n    # GET or HEAD, a '304 Not Modified' response is sent.\n    def etag(value, options = {})\n      # Before touching this code, please double check RFC 2616 14.24 and 14.26.\n      options      = {:kind => options} unless Hash === options\n      kind         = options[:kind] || :strong\n      new_resource = options.fetch(:new_resource) { request.post? }\n\n      unless ETAG_KINDS.include?(kind)\n        raise ArgumentError, \":strong or :weak expected\"\n      end\n\n      value = '\"%s\"' % value\n      value = \"W/#{value}\" if kind == :weak\n      response['ETag'] = value\n\n      if success? or status == 304\n        if etag_matches? env['HTTP_IF_NONE_MATCH'], new_resource\n          halt(request.safe? ? 304 : 412)\n        end\n\n        if env['HTTP_IF_MATCH']\n          halt 412 unless etag_matches? env['HTTP_IF_MATCH'], new_resource\n        end\n      end\n    end\n\n    # Sugar for redirect (example:  redirect back)\n    def back\n      request.referer\n    end\n\n    # whether or not the status is set to 1xx\n    def informational?\n      status.between? 100, 199\n    end\n\n    # whether or not the status is set to 2xx\n    def success?\n      status.between? 200, 299\n    end\n\n    # whether or not the status is set to 3xx\n    def redirect?\n      status.between? 300, 399\n    end\n\n    # whether or not the status is set to 4xx\n    def client_error?\n      status.between? 400, 499\n    end\n\n    # whether or not the status is set to 5xx\n    def server_error?\n      status.between? 500, 599\n    end\n\n    # whether or not the status is set to 404\n    def not_found?\n      status == 404\n    end\n\n    # whether or not the status is set to 400\n    def bad_request?\n      status == 400\n    end\n\n    # Generates a Time object from the given value.\n    # Used by #expires and #last_modified.\n    def time_for(value)\n      if value.is_a? Numeric\n        Time.at value\n      elsif value.respond_to? :to_s\n        Time.parse value.to_s\n      else\n        value.to_time\n      end\n    rescue ArgumentError => boom\n      raise boom\n    rescue Exception\n      raise ArgumentError, \"unable to convert #{value.inspect} to a Time object\"\n    end\n\n    private\n\n    # Helper method checking if a ETag value list includes the current ETag.\n    def etag_matches?(list, new_resource = request.post?)\n      return !new_resource if list == '*'\n      list.to_s.split(/\\s*,\\s*/).include? response['ETag']\n    end\n\n    def with_params(temp_params)\n      original, @params = @params, temp_params\n      yield\n    ensure\n      @params = original if original\n    end\n  end\n\n  private\n\n  # Template rendering methods. Each method takes the name of a template\n  # to render as a Symbol and returns a String with the rendered output,\n  # as well as an optional hash with additional options.\n  #\n  # `template` is either the name or path of the template as symbol\n  # (Use `:'subdir/myview'` for views in subdirectories), or a string\n  # that will be rendered.\n  #\n  # Possible options are:\n  #   :content_type   The content type to use, same arguments as content_type.\n  #   :layout         If set to something falsy, no layout is rendered, otherwise\n  #                   the specified layout is used (Ignored for `sass` and `less`)\n  #   :layout_engine  Engine to use for rendering the layout.\n  #   :locals         A hash with local variables that should be available\n  #                   in the template\n  #   :scope          If set, template is evaluate with the binding of the given\n  #                   object rather than the application instance.\n  #   :views          Views directory to use.\n  module Templates\n    module ContentTyped\n      attr_accessor :content_type\n    end\n\n    def initialize\n      super\n      @default_layout = :layout\n      @preferred_extension = nil\n    end\n\n    def erb(template, options = {}, locals = {}, &block)\n      render(:erb, template, options, locals, &block)\n    end\n\n    def erubis(template, options = {}, locals = {})\n      warn \"Sinatra::Templates#erubis is deprecated and will be removed, use #erb instead.\\n\" \\\n        \"If you have Erubis installed, it will be used automatically.\"\n      render :erubis, template, options, locals\n    end\n\n    def haml(template, options = {}, locals = {}, &block)\n      render(:haml, template, options, locals, &block)\n    end\n\n    def sass(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :sass, template, options, locals\n    end\n\n    def scss(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :scss, template, options, locals\n    end\n\n    def less(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :less, template, options, locals\n    end\n\n    def stylus(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :css\n      render :styl, template, options, locals\n    end\n\n    def builder(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:builder, template, options, locals, &block)\n    end\n\n    def liquid(template, options = {}, locals = {}, &block)\n      render(:liquid, template, options, locals, &block)\n    end\n\n    def markdown(template, options = {}, locals = {})\n      render :markdown, template, options, locals\n    end\n\n    def textile(template, options = {}, locals = {})\n      render :textile, template, options, locals\n    end\n\n    def rdoc(template, options = {}, locals = {})\n      render :rdoc, template, options, locals\n    end\n\n    def asciidoc(template, options = {}, locals = {})\n      render :asciidoc, template, options, locals\n    end\n\n    def radius(template, options = {}, locals = {})\n      render :radius, template, options, locals\n    end\n\n    def markaby(template = nil, options = {}, locals = {}, &block)\n      render_ruby(:mab, template, options, locals, &block)\n    end\n\n    def coffee(template, options = {}, locals = {})\n      options.merge! :layout => false, :default_content_type => :js\n      render :coffee, template, options, locals\n    end\n\n    def nokogiri(template = nil, options = {}, locals = {}, &block)\n      options[:default_content_type] = :xml\n      render_ruby(:nokogiri, template, options, locals, &block)\n    end\n\n    def slim(template, options = {}, locals = {}, &block)\n      render(:slim, template, options, locals, &block)\n    end\n\n    def creole(template, options = {}, locals = {})\n      render :creole, template, options, locals\n    end\n\n    def mediawiki(template, options = {}, locals = {})\n      render :mediawiki, template, options, locals\n    end\n\n    def wlang(template, options = {}, locals = {}, &block)\n      render(:wlang, template, options, locals, &block)\n    end\n\n    def yajl(template, options = {}, locals = {})\n      options[:default_content_type] = :json\n      render :yajl, template, options, locals\n    end\n\n    def rabl(template, options = {}, locals = {})\n      Rabl.register!\n      render :rabl, template, options, locals\n    end\n\n    # Calls the given block for every possible template file in views,\n    # named name.ext, where ext is registered on engine.\n    def find_template(views, name, engine)\n      yield ::File.join(views, \"#{name}.#{@preferred_extension}\")\n\n      if Tilt.respond_to?(:mappings)\n        Tilt.mappings.each do |ext, engines|\n          next unless ext != @preferred_extension and engines.include? engine\n          yield ::File.join(views, \"#{name}.#{ext}\")\n        end\n      else\n        Tilt.default_mapping.extensions_for(engine).each do |ext|\n          yield ::File.join(views, \"#{name}.#{ext}\") unless ext == @preferred_extension\n        end\n      end\n    end\n\n    private\n\n    # logic shared between builder and nokogiri\n    def render_ruby(engine, template, options = {}, locals = {}, &block)\n      options, template = template, nil if template.is_a?(Hash)\n      template = Proc.new { block } if template.nil?\n      render engine, template, options, locals\n    end\n\n    def render(engine, data, options = {}, locals = {}, &block)\n      # merge app-level options\n      engine_options = settings.respond_to?(engine) ? settings.send(engine) : {}\n      options.merge!(engine_options) { |key, v1, v2| v1 }\n\n      # extract generic options\n      locals          = options.delete(:locals) || locals         || {}\n      views           = options.delete(:views)  || settings.views || \"./views\"\n      layout          = options[:layout]\n      layout          = false if layout.nil? && options.include?(:layout)\n      eat_errors      = layout.nil?\n      layout          = engine_options[:layout] if layout.nil? or (layout == true && engine_options[:layout] != false)\n      layout          = @default_layout         if layout.nil? or layout == true\n      layout_options  = options.delete(:layout_options) || {}\n      content_type    = options.delete(:default_content_type)\n      content_type    = options.delete(:content_type)   || content_type\n      layout_engine   = options.delete(:layout_engine)  || engine\n      scope           = options.delete(:scope)          || self\n      options.delete(:layout)\n\n      # set some defaults\n      options[:outvar]           ||= '@_out_buf'\n      options[:default_encoding] ||= settings.default_encoding\n\n      # compile and render template\n      begin\n        layout_was      = @default_layout\n        @default_layout = false\n        template        = compile_template(engine, data, options, views)\n        output          = template.render(scope, locals, &block)\n      ensure\n        @default_layout = layout_was\n      end\n\n      # render layout\n      if layout\n        options = options.merge(:views => views, :layout => false, :eat_errors => eat_errors, :scope => scope).\n                merge!(layout_options)\n        catch(:layout_missing) { return render(layout_engine, layout, options, locals) { output } }\n      end\n\n      output.extend(ContentTyped).content_type = content_type if content_type\n      output\n    end\n\n    def compile_template(engine, data, options, views)\n      eat_errors = options.delete :eat_errors\n      template_cache.fetch engine, data, options, views do\n        template = Tilt[engine]\n        raise \"Template engine not found: #{engine}\" if template.nil?\n\n        case data\n        when Symbol\n          body, path, line = settings.templates[data]\n          if body\n            body = body.call if body.respond_to?(:call)\n            template.new(path, line.to_i, options) { body }\n          else\n            found = false\n            @preferred_extension = engine.to_s\n            find_template(views, data, template) do |file|\n              path ||= file # keep the initial path rather than the last one\n              if found = File.exist?(file)\n                path = file\n                break\n              end\n            end\n            throw :layout_missing if eat_errors and not found\n            template.new(path, 1, options)\n          end\n        when Proc, String\n          body = data.is_a?(String) ? Proc.new { data } : data\n          caller = settings.caller_locations.first\n          path = options[:path] || caller[0]\n          line = options[:line] || caller[1]\n          template.new(path, line.to_i, options, &body)\n        else\n          raise ArgumentError, \"Sorry, don't know how to render #{data.inspect}.\"\n        end\n      end\n    end\n  end\n\n  # Base class for all Sinatra applications and middleware.\n  class Base\n    include Rack::Utils\n    include Helpers\n    include Templates\n\n    URI_INSTANCE = URI::Parser.new\n\n    attr_accessor :app, :env, :request, :response, :params\n    attr_reader   :template_cache\n\n    def initialize(app = nil)\n      super()\n      @app = app\n      @template_cache = Tilt::Cache.new\n      yield self if block_given?\n    end\n\n    # Rack call interface.\n    def call(env)\n      dup.call!(env)\n    end\n\n    def call!(env) # :nodoc:\n      @env      = env\n      @params   = IndifferentHash.new\n      @request  = Request.new(env)\n      @response = Response.new\n      template_cache.clear if settings.reload_templates\n\n      @response['Content-Type'] = nil\n      invoke { dispatch! }\n      invoke { error_block!(response.status) } unless @env['sinatra.error']\n\n      unless @response['Content-Type']\n        if Array === body and body[0].respond_to? :content_type\n          content_type body[0].content_type\n        else\n          content_type :html\n        end\n      end\n\n      @response.finish\n    end\n\n    # Access settings defined with Base.set.\n    def self.settings\n      self\n    end\n\n    # Access settings defined with Base.set.\n    def settings\n      self.class.settings\n    end\n\n    def options\n      warn \"Sinatra::Base#options is deprecated and will be removed, \" \\\n        \"use #settings instead.\"\n      settings\n    end\n\n    # Exit the current block, halts any further processing\n    # of the request, and returns the specified response.\n    def halt(*response)\n      response = response.first if response.length == 1\n      throw :halt, response\n    end\n\n    # Pass control to the next matching route.\n    # If there are no more matching routes, Sinatra will\n    # return a 404 response.\n    def pass(&block)\n      throw :pass, block\n    end\n\n    # Forward the request to the downstream app -- middleware only.\n    def forward\n      fail \"downstream app not set\" unless @app.respond_to? :call\n      status, headers, body = @app.call env\n      @response.status = status\n      @response.body = body\n      @response.headers.merge! headers\n      nil\n    end\n\n    private\n\n    # Run filters defined on the class and all superclasses.\n    def filter!(type, base = settings)\n      filter! type, base.superclass if base.superclass.respond_to?(:filters)\n      base.filters[type].each { |args| process_route(*args) }\n    end\n\n    # Run routes defined on the class and all superclasses.\n    def route!(base = settings, pass_block = nil)\n      if routes = base.routes[@request.request_method]\n        routes.each do |pattern, conditions, block|\n          returned_pass_block = process_route(pattern, conditions) do |*args|\n            env['sinatra.route'] = \"#{@request.request_method} #{pattern}\"\n            route_eval { block[*args] }\n          end\n\n          # don't wipe out pass_block in superclass\n          pass_block = returned_pass_block if returned_pass_block\n        end\n      end\n\n      # Run routes defined in superclass.\n      if base.superclass.respond_to?(:routes)\n        return route!(base.superclass, pass_block)\n      end\n\n      route_eval(&pass_block) if pass_block\n      route_missing\n    end\n\n    # Run a route block and throw :halt with the result.\n    def route_eval\n      throw :halt, yield\n    end\n\n    # If the current request matches pattern and conditions, fill params\n    # with keys and call the given block.\n    # Revert params afterwards.\n    #\n    # Returns pass block.\n    def process_route(pattern, conditions, block = nil, values = [])\n      route = @request.path_info\n      route = '/' if route.empty? and not settings.empty_path_info?\n      route = route[0..-2] if !settings.strict_paths? && route != '/' && route.end_with?('/')\n      return unless params = pattern.params(route)\n\n      params.delete(\"ignore\") # TODO: better params handling, maybe turn it into \"smart\" object or detect changes\n      force_encoding(params)\n      original, @params = @params, @params.merge(params) if params.any?\n\n      regexp_exists = pattern.is_a?(Mustermann::Regular) || (pattern.respond_to?(:patterns) && pattern.patterns.any? {|subpattern| subpattern.is_a?(Mustermann::Regular)} )\n      if regexp_exists\n        captures           = pattern.match(route).captures\n        values            += captures\n        @params[:captures] = force_encoding(captures) unless captures.nil? || captures.empty?\n      else\n        values += params.values.flatten\n      end\n\n      catch(:pass) do\n        conditions.each { |c| throw :pass if c.bind(self).call == false }\n        block ? block[self, values] : yield(self, values)\n      end\n    rescue\n      @env['sinatra.error.params'] = @params\n      raise\n    ensure\n      @params = original if original\n    end\n\n    # No matching route was found or all routes passed. The default\n    # implementation is to forward the request downstream when running\n    # as middleware (@app is non-nil); when no downstream app is set, raise\n    # a NotFound exception. Subclasses can override this method to perform\n    # custom route miss logic.\n    def route_missing\n      if @app\n        forward\n      else\n        raise NotFound\n      end\n    end\n\n    # Attempt to serve static files from public directory. Throws :halt when\n    # a matching file is found, returns nil otherwise.\n    def static!(options = {})\n      return if (public_dir = settings.public_folder).nil?\n      path = File.expand_path(\"#{public_dir}#{URI_INSTANCE.unescape(request.path_info)}\" )\n      return unless File.file?(path)\n\n      env['sinatra.static_file'] = path\n      cache_control(*settings.static_cache_control) if settings.static_cache_control?\n      send_file path, options.merge(:disposition => nil)\n    end\n\n    # Run the block with 'throw :halt' support and apply result to the response.\n    def invoke\n      res = catch(:halt) { yield }\n\n      res = [res] if Integer === res or String === res\n      if Array === res and Integer === res.first\n        res = res.dup\n        status(res.shift)\n        body(res.pop)\n        headers(*res)\n      elsif res.respond_to? :each\n        body res\n      end\n      nil # avoid double setting the same response tuple twice\n    end\n\n    # Dispatch a request with error handling.\n    def dispatch!\n      force_encoding(@params.merge!(@request.params))\n\n      invoke do\n        static! if settings.static? && (request.get? || request.head?)\n        filter! :before\n        route!\n      end\n    rescue ::Exception => boom\n      invoke { handle_exception!(boom) }\n    ensure\n      begin\n        filter! :after unless env['sinatra.static_file']\n      rescue ::Exception => boom\n        invoke { handle_exception!(boom) } unless @env['sinatra.error']\n      end\n    end\n\n    # Error handling during requests.\n    def handle_exception!(boom)\n      if error_params = @env['sinatra.error.params']\n        @params = @params.merge(error_params)\n      end\n      @env['sinatra.error'] = boom\n\n      if boom.respond_to? :http_status\n        status(boom.http_status)\n      elsif settings.use_code? and boom.respond_to? :code and boom.code.between? 400, 599\n        status(boom.code)\n      else\n        status(500)\n      end\n\n      status(500) unless status.between? 400, 599\n\n      boom_message = boom.message if boom.message && boom.message != boom.class.name\n      if server_error?\n        dump_errors! boom if settings.dump_errors?\n        raise boom if settings.show_exceptions? and settings.show_exceptions != :after_handler\n      elsif not_found?\n        headers['X-Cascade'] = 'pass' if settings.x_cascade?\n        body boom_message || '<h1>Not Found</h1>'\n      elsif bad_request?\n        body boom_message || '<h1>Bad Request</h1>'\n      end\n\n      res = error_block!(boom.class, boom) || error_block!(status, boom)\n      return res if res or not server_error?\n      raise boom if settings.raise_errors? or settings.show_exceptions?\n      error_block! Exception, boom\n    end\n\n    # Find an custom error block for the key(s) specified.\n    def error_block!(key, *block_params)\n      base = settings\n      while base.respond_to?(:errors)\n        next base = base.superclass unless args_array = base.errors[key]\n        args_array.reverse_each do |args|\n          first = args == args_array.first\n          args += [block_params]\n          resp = process_route(*args)\n          return resp unless resp.nil? && !first\n        end\n      end\n      return false unless key.respond_to? :superclass and key.superclass < Exception\n      error_block!(key.superclass, *block_params)\n    end\n\n    def dump_errors!(boom)\n      msg = [\"#{Time.now.strftime(\"%Y-%m-%d %H:%M:%S\")} - #{boom.class} - #{boom.message}:\", *boom.backtrace].join(\"\\n\\t\")\n      @env['rack.errors'].puts(msg)\n    end\n\n    class << self\n      CALLERS_TO_IGNORE = [ # :nodoc:\n        /\\/sinatra(\\/(base|main|show_exceptions))?\\.rb$/,   # all sinatra code\n        /lib\\/tilt.*\\.rb$/,                                 # all tilt code\n        /^\\(.*\\)$/,                                         # generated code\n        /rubygems\\/(custom|core_ext\\/kernel)_require\\.rb$/, # rubygems require hacks\n        /active_support/,                                   # active_support require hacks\n        /bundler(\\/runtime)?\\.rb/,                          # bundler require hacks\n        /<internal:/,                                       # internal in ruby >= 1.9.2\n        /src\\/kernel\\/bootstrap\\/[A-Z]/                     # maglev kernel files\n      ]\n\n      # contrary to what the comment said previously, rubinius never supported this\n      if defined?(RUBY_IGNORE_CALLERS)\n        warn \"RUBY_IGNORE_CALLERS is deprecated and will no longer be supported by Sinatra 2.0\"\n        CALLERS_TO_IGNORE.concat(RUBY_IGNORE_CALLERS)\n      end\n\n      attr_reader :routes, :filters, :templates, :errors\n\n      # Removes all routes, filters, middleware and extension hooks from the\n      # current class (not routes/filters/... defined by its superclass).\n      def reset!\n        @conditions     = []\n        @routes         = {}\n        @filters        = {:before => [], :after => []}\n        @errors         = {}\n        @middleware     = []\n        @prototype      = nil\n        @extensions     = []\n\n        if superclass.respond_to?(:templates)\n          @templates = Hash.new { |hash, key| superclass.templates[key] }\n        else\n          @templates = {}\n        end\n      end\n\n      # Extension modules registered on this class and all superclasses.\n      def extensions\n        if superclass.respond_to?(:extensions)\n          (@extensions + superclass.extensions).uniq\n        else\n          @extensions\n        end\n      end\n\n      # Middleware used in this class and all superclasses.\n      def middleware\n        if superclass.respond_to?(:middleware)\n          superclass.middleware + @middleware\n        else\n          @middleware\n        end\n      end\n\n      # Sets an option to the given value.  If the value is a proc,\n      # the proc will be called every time the option is accessed.\n      def set(option, value = (not_set = true), ignore_setter = false, &block)\n        raise ArgumentError if block and !not_set\n        value, not_set = block, false if block\n\n        if not_set\n          raise ArgumentError unless option.respond_to?(:each)\n          option.each { |k,v| set(k, v) }\n          return self\n        end\n\n        if respond_to?(\"#{option}=\") and not ignore_setter\n          return __send__(\"#{option}=\", value)\n        end\n\n        setter = proc { |val| set option, val, true }\n        getter = proc { value }\n\n        case value\n        when Proc\n          getter = value\n        when Symbol, Integer, FalseClass, TrueClass, NilClass\n          getter = value.inspect\n        when Hash\n          setter = proc do |val|\n            val = value.merge val if Hash === val\n            set option, val, true\n          end\n        end\n\n        define_singleton(\"#{option}=\", setter)\n        define_singleton(option, getter)\n        define_singleton(\"#{option}?\", \"!!#{option}\") unless method_defined? \"#{option}?\"\n        self\n      end\n\n      # Same as calling `set :option, true` for each of the given options.\n      def enable(*opts)\n        opts.each { |key| set(key, true) }\n      end\n\n      # Same as calling `set :option, false` for each of the given options.\n      def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end\n\n      # Define a custom error handler. Optionally takes either an Exception\n      # class, or an HTTP status code to specify which errors should be\n      # handled.\n      def error(*codes, &block)\n        args  = compile! \"ERROR\", /.*/, block\n        codes = codes.flat_map(&method(:Array))\n        codes << Exception if codes.empty?\n        codes << Sinatra::NotFound if codes.include?(404)\n        codes.each { |c| (@errors[c] ||= []) << args }\n      end\n\n      # Sugar for `error(404) { ... }`\n      def not_found(&block)\n        error(404, &block)\n      end\n\n      # Define a named template. The block must return the template source.\n      def template(name, &block)\n        filename, line = caller_locations.first\n        templates[name] = [block, filename, line.to_i]\n      end\n\n      # Define the layout template. The block must return the template source.\n      def layout(name = :layout, &block)\n        template name, &block\n      end\n\n      # Load embedded templates from the file; uses the caller's __FILE__\n      # when no file is specified.\n      def inline_templates=(file = nil)\n        file = (file.nil? || file == true) ? (caller_files.first || File.expand_path($0)) : file\n\n        begin\n          io = ::IO.respond_to?(:binread) ? ::IO.binread(file) : ::IO.read(file)\n          app, data = io.gsub(\"\\r\\n\", \"\\n\").split(/^__END__$/, 2)\n        rescue Errno::ENOENT\n          app, data = nil\n        end\n\n        if data\n          if app and app =~ /([^\\n]*\\n)?#[^\\n]*coding: *(\\S+)/m\n            encoding = $2\n          else\n            encoding = settings.default_encoding\n          end\n          lines = app.count(\"\\n\") + 1\n          template = nil\n          force_encoding data, encoding\n          data.each_line do |line|\n            lines += 1\n            if line =~ /^@@\\s*(.*\\S)\\s*$/\n              template = force_encoding(String.new, encoding)\n              templates[$1.to_sym] = [template, file, lines]\n            elsif template\n              template << line\n            end\n          end\n        end\n      end\n\n      # Lookup or register a mime type in Rack's mime registry.\n      def mime_type(type, value = nil)\n        return type      if type.nil?\n        return type.to_s if type.to_s.include?('/')\n        type = \".#{type}\" unless type.to_s[0] == ?.\n        return Rack::Mime.mime_type(type, nil) unless value\n        Rack::Mime::MIME_TYPES[type] = value\n      end\n\n      # provides all mime types matching type, including deprecated types:\n      #   mime_types :html # => ['text/html']\n      #   mime_types :js   # => ['application/javascript', 'text/javascript']\n      def mime_types(type)\n        type = mime_type type\n        type =~ /^application\\/(xml|javascript)$/ ? [type, \"text/#$1\"] : [type]\n      end\n\n      # Define a before filter; runs before all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def before(path = /.*/, **options, &block)\n        add_filter(:before, path, options, &block)\n      end\n\n      # Define an after filter; runs after all requests within the same\n      # context as route handlers and may access/modify the request and\n      # response.\n      def after(path = /.*/, **options, &block)\n        add_filter(:after, path, options, &block)\n      end\n\n      # add a filter\n      def add_filter(type, path = /.*/, **options, &block)\n        filters[type] << compile!(type, path, block, options)\n      end\n\n      # Add a route condition. The route is considered non-matching when the\n      # block returns false.\n      def condition(name = \"#{caller.first[/`.*'/]} condition\", &block)\n        @conditions << generate_method(name, &block)\n      end\n\n      def public=(value)\n        warn \":public is no longer used to avoid overloading Module#public, use :public_folder or :public_dir instead\"\n        set(:public_folder, value)\n      end\n\n      def public_dir=(value)\n        self.public_folder = value\n      end\n\n      def public_dir\n        public_folder\n      end\n\n      # Defining a `GET` handler also automatically defines\n      # a `HEAD` handler.\n      def get(path, opts = {}, &block)\n        conditions = @conditions.dup\n        route('GET', path, opts, &block)\n\n        @conditions = conditions\n        route('HEAD', path, opts, &block)\n      end\n\n      def put(path, opts = {}, &bk)     route 'PUT',     path, opts, &bk end\n      def post(path, opts = {}, &bk)    route 'POST',    path, opts, &bk end\n      def delete(path, opts = {}, &bk)  route 'DELETE',  path, opts, &bk end\n      def head(path, opts = {}, &bk)    route 'HEAD',    path, opts, &bk end\n      def options(path, opts = {}, &bk) route 'OPTIONS', path, opts, &bk end\n      def patch(path, opts = {}, &bk)   route 'PATCH',   path, opts, &bk end\n      def link(path, opts = {}, &bk)    route 'LINK',    path, opts, &bk end\n      def unlink(path, opts = {}, &bk)  route 'UNLINK',  path, opts, &bk end\n\n      # Makes the methods defined in the block and in the Modules given\n      # in `extensions` available to the handlers and templates\n      def helpers(*extensions, &block)\n        class_eval(&block)   if block_given?\n        include(*extensions) if extensions.any?\n      end\n\n      # Register an extension. Alternatively take a block from which an\n      # extension will be created and registered on the fly.\n      def register(*extensions, &block)\n        extensions << Module.new(&block) if block_given?\n        @extensions += extensions\n        extensions.each do |extension|\n          extend extension\n          extension.registered(self) if extension.respond_to?(:registered)\n        end\n      end\n\n      def development?; environment == :development end\n      def production?;  environment == :production  end\n      def test?;        environment == :test        end\n\n      # Set configuration options for Sinatra and/or the app.\n      # Allows scoping of settings for certain environments.\n      def configure(*envs)\n        yield self if envs.empty? || envs.include?(environment.to_sym)\n      end\n\n      # Use the specified Rack middleware\n      def use(middleware, *args, &block)\n        @prototype = nil\n        @middleware << [middleware, args, block]\n      end\n\n      # Stop the self-hosted server if running.\n      def quit!\n        return unless running?\n        # Use Thin's hard #stop! if available, otherwise just #stop.\n        running_server.respond_to?(:stop!) ? running_server.stop! : running_server.stop\n        $stderr.puts \"== Sinatra has ended his set (crowd applauds)\" unless suppress_messages?\n        set :running_server, nil\n        set :handler_name, nil\n      end\n\n      alias_method :stop!, :quit!\n\n      # Run the Sinatra app as a self-hosted server using\n      # Thin, Puma, Mongrel, or WEBrick (in that order). If given a block, will call\n      # with the constructed handler once we have taken the stage.\n      def run!(options = {}, &block)\n        return if running?\n        set options\n        handler         = detect_rack_handler\n        handler_name    = handler.name.gsub(/.*::/, '')\n        server_settings = settings.respond_to?(:server_settings) ? settings.server_settings : {}\n        server_settings.merge!(:Port => port, :Host => bind)\n\n        begin\n          start_server(handler, server_settings, handler_name, &block)\n        rescue Errno::EADDRINUSE\n          $stderr.puts \"== Someone is already performing on port #{port}!\"\n          raise\n        ensure\n          quit!\n        end\n      end\n\n      alias_method :start!, :run!\n\n      # Check whether the self-hosted server is running or not.\n      def running?\n        running_server?\n      end\n\n      # The prototype instance used to process requests.\n      def prototype\n        @prototype ||= new\n      end\n\n      # Create a new instance without middleware in front of it.\n      alias new! new unless method_defined? :new!\n\n      # Create a new instance of the class fronted by its middleware\n      # pipeline. The object is guaranteed to respond to #call but may not be\n      # an instance of the class new was called on.\n      def new(*args, &bk)\n        instance = new!(*args, &bk)\n        Wrapper.new(build(instance).to_app, instance)\n      end\n\n      # Creates a Rack::Builder instance with all the middleware set up and\n      # the given +app+ as end point.\n      def build(app)\n        builder = Rack::Builder.new\n        setup_default_middleware builder\n        setup_middleware builder\n        builder.run app\n        builder\n      end\n\n      def call(env)\n        synchronize { prototype.call(env) }\n      end\n\n      # Like Kernel#caller but excluding certain magic entries and without\n      # line / method information; the resulting array contains filenames only.\n      def caller_files\n        cleaned_caller(1).flatten\n      end\n\n      # Like caller_files, but containing Arrays rather than strings with the\n      # first element being the file, and the second being the line.\n      def caller_locations\n        cleaned_caller 2\n      end\n\n      private\n\n      # Starts the server by running the Rack Handler.\n      def start_server(handler, server_settings, handler_name)\n        # Ensure we initialize middleware before startup, to match standard Rack\n        # behavior, by ensuring an instance exists:\n        prototype\n        # Run the instance we created:\n        handler.run(self, server_settings) do |server|\n          unless suppress_messages?\n            $stderr.puts \"== Sinatra (v#{Sinatra::VERSION}) has taken the stage on #{port} for #{environment} with backup from #{handler_name}\"\n          end\n\n          setup_traps\n          set :running_server, server\n          set :handler_name,   handler_name\n          server.threaded = settings.threaded if server.respond_to? :threaded=\n\n          yield server if block_given?\n        end\n      end\n\n      def suppress_messages?\n        handler_name =~ /cgi/i || quiet\n      end\n\n      def setup_traps\n        if traps?\n          at_exit { quit! }\n\n          [:INT, :TERM].each do |signal|\n            old_handler = trap(signal) do\n              quit!\n              old_handler.call if old_handler.respond_to?(:call)\n            end\n          end\n\n          set :traps, false\n        end\n      end\n\n      # Dynamically defines a method on settings.\n      def define_singleton(name, content = Proc.new)\n        singleton_class.class_eval do\n          undef_method(name) if method_defined? name\n          String === content ? class_eval(\"def #{name}() #{content}; end\") : define_method(name, &content)\n        end\n      end\n\n      # Condition for matching host name. Parameter might be String or Regexp.\n      def host_name(pattern)\n        condition { pattern === request.host }\n      end\n\n      # Condition for matching user agent. Parameter should be Regexp.\n      # Will set params[:agent].\n      def user_agent(pattern)\n        condition do\n          if request.user_agent.to_s =~ pattern\n            @params[:agent] = $~[1..-1]\n            true\n          else\n            false\n          end\n        end\n      end\n      alias_method :agent, :user_agent\n\n      # Condition for matching mimetypes. Accepts file extensions.\n      def provides(*types)\n        types.map! { |t| mime_types(t) }\n        types.flatten!\n        condition do\n          if type = response['Content-Type']\n            types.include? type or types.include? type[/^[^;]+/]\n          elsif type = request.preferred_type(types)\n            params = (type.respond_to?(:params) ? type.params : {})\n            content_type(type, params)\n            true\n          else\n            false\n          end\n        end\n      end\n\n      def route(verb, path, options = {}, &block)\n        enable :empty_path_info if path == \"\" and empty_path_info.nil?\n        signature = compile!(verb, path, block, options)\n        (@routes[verb] ||= []) << signature\n        invoke_hook(:route_added, verb, path, block)\n        signature\n      end\n\n      def invoke_hook(name, *args)\n        extensions.each { |e| e.send(name, *args) if e.respond_to?(name) }\n      end\n\n      def generate_method(method_name, &block)\n        define_method(method_name, &block)\n        method = instance_method method_name\n        remove_method method_name\n        method\n      end\n\n      def compile!(verb, path, block, **options)\n        # Because of self.options.host\n        host_name(options.delete(:host)) if options.key?(:host)\n        # Pass Mustermann opts to compile()\n        route_mustermann_opts = options.key?(:mustermann_opts) ? options.delete(:mustermann_opts) : {}.freeze\n\n        options.each_pair { |option, args| send(option, *args) }\n\n        pattern                 = compile(path, route_mustermann_opts)\n        method_name             = \"#{verb} #{path}\"\n        unbound_method          = generate_method(method_name, &block)\n        conditions, @conditions = @conditions, []\n        wrapper                 = block.arity != 0 ?\n          proc { |a, p| unbound_method.bind(a).call(*p) } :\n          proc { |a, p| unbound_method.bind(a).call }\n\n        [ pattern, conditions, wrapper ]\n      end\n\n      def compile(path, route_mustermann_opts = {})\n        Mustermann.new(path, mustermann_opts.merge(route_mustermann_opts))\n      end\n\n      def setup_default_middleware(builder)\n        builder.use ExtendedRack\n        builder.use ShowExceptions       if show_exceptions?\n        builder.use Rack::MethodOverride if method_override?\n        builder.use Rack::Head\n        setup_logging    builder\n        setup_sessions   builder\n        setup_protection builder\n      end\n\n      def setup_middleware(builder)\n        middleware.each { |c,a,b| builder.use(c, *a, &b) }\n      end\n\n      def setup_logging(builder)\n        if logging?\n          setup_common_logger(builder)\n          setup_custom_logger(builder)\n        elsif logging == false\n          setup_null_logger(builder)\n        end\n      end\n\n      def setup_null_logger(builder)\n        builder.use Rack::NullLogger\n      end\n\n      def setup_common_logger(builder)\n        builder.use Sinatra::CommonLogger\n      end\n\n      def setup_custom_logger(builder)\n        if logging.respond_to? :to_int\n          builder.use Rack::Logger, logging\n        else\n          builder.use Rack::Logger\n        end\n      end\n\n      def setup_protection(builder)\n        return unless protection?\n        options = Hash === protection ? protection.dup : {}\n        options = {\n          img_src:  \"'self' data:\",\n          font_src: \"'self'\"\n        }.merge options\n\n        protect_session = options.fetch(:session) { sessions? }\n        options[:without_session] = !protect_session\n\n        options[:reaction] ||= :drop_session\n\n        builder.use Rack::Protection, options\n      end\n\n      def setup_sessions(builder)\n        return unless sessions?\n        options = {}\n        options[:secret] = session_secret if session_secret?\n        options.merge! sessions.to_hash if sessions.respond_to? :to_hash\n        builder.use session_store, options\n      end\n\n      def detect_rack_handler\n        servers = Array(server)\n        servers.each do |server_name|\n          begin\n            return Rack::Handler.get(server_name.to_s)\n          rescue LoadError, NameError\n          end\n        end\n        fail \"Server handler (#{servers.join(',')}) not found.\"\n      end\n\n      def inherited(subclass)\n        subclass.reset!\n        subclass.set :app_file, caller_files.first unless subclass.app_file?\n        super\n      end\n\n      @@mutex = Mutex.new\n      def synchronize(&block)\n        if lock?\n          @@mutex.synchronize(&block)\n        else\n          yield\n        end\n      end\n\n      # used for deprecation warnings\n      def warn(message)\n        super message + \"\\n\\tfrom #{cleaned_caller.first.join(':')}\"\n      end\n\n      # Like Kernel#caller but excluding certain magic entries\n      def cleaned_caller(keep = 3)\n        caller(1).\n          map!    { |line| line.split(/:(?=\\d|in )/, 3)[0,keep] }.\n          reject { |file, *_| CALLERS_TO_IGNORE.any? { |pattern| file =~ pattern } }\n      end\n    end\n\n    # Fixes encoding issues by\n    # * defaulting to UTF-8\n    # * casting params to Encoding.default_external\n    #\n    # The latter might not be necessary if Rack handles it one day.\n    # Keep an eye on Rack's LH #100.\n    def force_encoding(*args) settings.force_encoding(*args) end\n    if defined? Encoding\n      def self.force_encoding(data, encoding = default_encoding)\n        return if data == settings || data.is_a?(Tempfile)\n        if data.respond_to? :force_encoding\n          data.force_encoding(encoding).encode!\n        elsif data.respond_to? :each_value\n          data.each_value { |v| force_encoding(v, encoding) }\n        elsif data.respond_to? :each\n          data.each { |v| force_encoding(v, encoding) }\n        end\n        data\n      end\n    else\n      def self.force_encoding(data, *) data end\n    end\n\n    reset!\n\n    set :environment, (ENV['APP_ENV'] || ENV['RACK_ENV'] || :development).to_sym\n    set :raise_errors, Proc.new { test? }\n    set :dump_errors, Proc.new { !test? }\n    set :show_exceptions, Proc.new { development? }\n    set :sessions, false\n    set :session_store, Rack::Session::Cookie\n    set :logging, false\n    set :protection, true\n    set :method_override, false\n    set :use_code, false\n    set :default_encoding, \"utf-8\"\n    set :x_cascade, true\n    set :add_charset, %w[javascript xml xhtml+xml].map { |t| \"application/#{t}\" }\n    settings.add_charset << /^text\\//\n    set :mustermann_opts, {}\n\n    # explicitly generating a session secret eagerly to play nice with preforking\n    begin\n      require 'securerandom'\n      set :session_secret, SecureRandom.hex(64)\n    rescue LoadError, NotImplementedError\n      # SecureRandom raises a NotImplementedError if no random device is available\n      set :session_secret, \"%064x\" % Kernel.rand(2**256-1)\n    end\n\n    class << self\n      alias_method :methodoverride?, :method_override?\n      alias_method :methodoverride=, :method_override=\n    end\n\n    set :run, false                       # start server via at-exit hook?\n    set :running_server, nil\n    set :handler_name, nil\n    set :traps, true\n    set :server, %w[HTTP webrick]\n    set :bind, Proc.new { development? ? 'localhost' : '0.0.0.0' }\n    set :port, Integer(ENV['PORT'] && !ENV['PORT'].empty? ? ENV['PORT'] : 4567)\n    set :quiet, false\n\n    ruby_engine = defined?(RUBY_ENGINE) && RUBY_ENGINE\n\n    if ruby_engine == 'macruby'\n      server.unshift 'control_tower'\n    else\n      server.unshift 'reel'\n      server.unshift 'mongrel'  if ruby_engine.nil?\n      server.unshift 'puma'     if ruby_engine != 'rbx'\n      server.unshift 'thin'     if ruby_engine != 'jruby'\n      server.unshift 'puma'     if ruby_engine == 'rbx'\n      server.unshift 'trinidad' if ruby_engine == 'jruby'\n    end\n\n    set :absolute_redirects, true\n    set :prefixed_redirects, false\n    set :empty_path_info, nil\n    set :strict_paths, true\n\n    set :app_file, nil\n    set :root, Proc.new { app_file && File.expand_path(File.dirname(app_file)) }\n    set :views, Proc.new { root && File.join(root, 'views') }\n    set :reload_templates, Proc.new { development? }\n    set :lock, false\n    set :threaded, true\n\n    set :public_folder, Proc.new { root && File.join(root, 'public') }\n    set :static, Proc.new { public_folder && File.exist?(public_folder) }\n    set :static_cache_control, false\n\n    error ::Exception do\n      response.status = 500\n      content_type 'text/html'\n      '<h1>Internal Server Error</h1>'\n    end\n\n    configure :development do\n      get '/__sinatra__/:image.png' do\n        filename = File.dirname(__FILE__) + \"/images/#{params[:image].to_i}.png\"\n        content_type :png\n        send_file filename\n      end\n\n      error NotFound do\n        content_type 'text/html'\n\n        if self.class == Sinatra::Application\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            #{request.request_method.downcase} '#{request.path_info}' do\n              \"Hello World\"\n            end\n          RUBY\n        else\n          code = <<-RUBY.gsub(/^ {12}/, '')\n            class #{self.class}\n              #{request.request_method.downcase} '#{request.path_info}' do\n                \"Hello World\"\n              end\n            end\n          RUBY\n\n          file = settings.app_file.to_s.sub(settings.root.to_s, '').sub(/^\\//, '')\n          code = \"# in #{file}\\n#{code}\" unless file.empty?\n        end\n\n        (<<-HTML).gsub(/^ {10}/, '')\n          <!DOCTYPE html>\n          <html>\n          <head>\n            <style type=\"text/css\">\n            body { text-align:center;font-family:helvetica,arial;font-size:22px;\n              color:#888;margin:20px}\n            #c {margin:0 auto;width:500px;text-align:left}\n            </style>\n          </head>\n          <body>\n            <h2>Sinatra doesn\u2019t know this ditty.</h2>\n            <img src='#{uri \"/__sinatra__/404.png\"}'>\n            <div id=\"c\">\n              Try this:\n              <pre>#{Rack::Utils.escape_html(code)}</pre>\n            </div>\n          </body>\n          </html>\n        HTML\n      end\n    end\n  end\n\n  # Execution context for classic style (top-level) applications. All\n  # DSL methods executed on main are delegated to this class.\n  #\n  # The Application class should not be subclassed, unless you want to\n  # inherit all settings, routes, handlers, and error pages from the\n  # top-level. Subclassing Sinatra::Base is highly recommended for\n  # modular applications.\n  class Application < Base\n    set :logging, Proc.new { !test? }\n    set :method_override, true\n    set :run, Proc.new { !test? }\n    set :app_file, nil\n\n    def self.register(*extensions, &block) #:nodoc:\n      added_methods = extensions.flat_map(&:public_instance_methods)\n      Delegator.delegate(*added_methods)\n      super(*extensions, &block)\n    end\n  end\n\n  # Sinatra delegation mixin. Mixing this module into an object causes all\n  # methods to be delegated to the Sinatra::Application class. Used primarily\n  # at the top-level.\n  module Delegator #:nodoc:\n    def self.delegate(*methods)\n      methods.each do |method_name|\n        define_method(method_name) do |*args, &block|\n          return super(*args, &block) if respond_to? method_name\n          Delegator.target.send(method_name, *args, &block)\n        end\n        private method_name\n      end\n    end\n\n    delegate :get, :patch, :put, :post, :delete, :head, :options, :link, :unlink,\n             :template, :layout, :before, :after, :error, :not_found, :configure,\n             :set, :mime_type, :enable, :disable, :use, :development?, :test?,\n             :production?, :helpers, :settings, :register\n\n    class << self\n      attr_accessor :target\n    end\n\n    self.target = Application\n  end\n\n  class Wrapper\n    def initialize(stack, instance)\n      @stack, @instance = stack, instance\n    end\n\n    def settings\n      @instance.settings\n    end\n\n    def helpers\n      @instance\n    end\n\n    def call(env)\n      @stack.call(env)\n    end\n\n    def inspect\n      \"#<#{@instance.class} app_file=#{settings.app_file.inspect}>\"\n    end\n  end\n\n  # Create a new Sinatra application; the block is evaluated in the class scope.\n  def self.new(base = Base, &block)\n    base = Class.new(base)\n    base.class_eval(&block) if block_given?\n    base\n  end\n\n  # Extend the top-level DSL with the modules provided.\n  def self.register(*extensions, &block)\n    Delegator.target.register(*extensions, &block)\n  end\n\n  # Include the helper modules provided in Sinatra's request context.\n  def self.helpers(*extensions, &block)\n    Delegator.target.helpers(*extensions, &block)\n  end\n\n  # Use the middleware for classic applications.\n  def self.use(*args, &block)\n    Delegator.target.use(*args, &block)\n  end\nend\n"], "filenames": ["lib/sinatra/base.rb"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [82], "fixing_code_start_loc": [81], "fixing_code_end_loc": [82], "type": "CWE-79", "message": "Sinatra before 2.0.2 has XSS via the 400 Bad Request page that occurs upon a params parser exception.", "other": {"cve": {"id": "CVE-2018-11627", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-31T19:29:00.203", "lastModified": "2019-02-26T15:03:26.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sinatra before 2.0.2 has XSS via the 400 Bad Request page that occurs upon a params parser exception."}, {"lang": "es", "value": "Sinatra en versiones anteriores a la 2.0.2 tiene Cross-Site Scripting (XSS) a trav\u00e9s de la p\u00e1gina 400 Bad Request que se produce en una excepci\u00f3n del analizador de par\u00e1metros."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sinatrarb:sinatra:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.2", "matchCriteriaId": "C5DBA9CC-667A-4F49-96DD-4D16465D8FA3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:cloudforms:4.6:*:*:*:*:*:*:*", "matchCriteriaId": "67F7263F-113D-4BAE-B8CB-86A61531A2AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:cloudforms:4.7:*:*:*:*:*:*:*", "matchCriteriaId": "04AC556D-D511-4C4C-B9FB-A089BB2FEFD5"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:0212", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0315", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/sinatra/sinatra/commit/12786867d6faaceaec62c7c2cb5b0e2dc074d71a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sinatra/sinatra/issues/1428", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sinatra/sinatra/commit/12786867d6faaceaec62c7c2cb5b0e2dc074d71a"}}