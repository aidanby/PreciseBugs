{"buggy_code": ["<p align=\"center\">\n  <img src=\"https://cdn.aahframework.org/assets/img/aah-logo-64x64.png\" />\n  <p align=\"center\">A secure, flexible, rapid Go web framework</p>\n  <p align=\"center\">Visit aah's official website https://aahframework.org to learn more</p>\n</p>\n<p align=\"center\">\n  <p align=\"center\"><a href=\"https://travis-ci.org/go-aah/aah\"><img src=\"https://travis-ci.org/go-aah/aah.svg?branch=master\" alt=\"Build Status\"></a> <a href=\"https://codecov.io/gh/go-aah/aah/branch/master\"><img src=\"https://codecov.io/gh/go-aah/aah/branch/master/graph/badge.svg\" alt=\"Code Coverage\"></a> <a href=\"https://goreportcard.com/report/aahframe.work\"><img src=\"https://goreportcard.com/badge/aahframe.work\" alt=\"Go Report Card\"></a> <a href=\"https://github.com/go-aah/aah/releases/latest\"><img src=\"https://img.shields.io/badge/version-0.12.3-blue.svg\" alt=\"Release Version\"></a> <a href=\"https://godoc.org/aahframe.work\"><img src=\"https://godoc.org/aahframe.work?status.svg\" alt=\"Godoc\"></a> <a href=\"https://twitter.com/aahframework\"><img src=\"https://img.shields.io/badge/twitter-@aahframework-55acee.svg\" alt=\"Twitter @aahframework\"></a></p>\n</p>\n\n### News\n\n  * `v0.12.3` [released](https://docs.aahframework.org/release-notes.html) and tagged on Feb 06, 2019.\n  * `v0.12.2` [released](https://docs.aahframework.org/release-notes.html) and tagged on Dec 13, 2018.\n  * `v0.12.0` [released](https://docs.aahframework.org/release-notes.html) and tagged on Dec 02, 2018.\n  * `v0.11.4` [released](https://docs.aahframework.org/v0.11/release-notes.html) and tagged on Aug 27, 2018.\n\n### Stargazers over time\n\n[![Stargazers over time](https://starcharts.herokuapp.com/go-aah/aah.svg)](https://starcharts.herokuapp.com/go-aah/aah)\n\n\n### Introduction\n\naah aims to provide necessary components to build modern Web, API and WebSocket applications. aah framework is secure, rapid and extensible. It takes full care of infrastructure, boilerplate code, repetitive activities, reusable components, etc.\n\n<p align=\"center\">aah is feature packed framework with <i>nature of micro framework</i>.</p>\n\nHave a look at the [aah features](https://aahframework.org/features.html) to know the benefits of using aah and it is very well [documented](https://docs.aahframework.org/).\n\n* Truly easy to use and configuration driven.\n* Security aware framework, secure session, CSRF prevention, XSS prevention, authentication, authorization, etc.\n* Build powerful end-user product and ship it.\n* Extensible at module level. If not, then immediately raise an [issue](https://aahframework.org/issues).\n* Highly maintainable, reduced delivery time, shines with application growth.\n* Steadily maturing framework and the feature-sets are getting enhanced release by release.\n\n<br>\n<p align=\"center\">aah's initial stable version <code>0.5.0</code> was released on May 19, 2017.</p>", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"aahframe.work/ahttp\"\n\t\"aahframe.work/ainsp\"\n\t\"aahframe.work/aruntime\"\n\t\"aahframe.work/essentials\"\n\t\"aahframe.work/internal/settings\"\n\t\"aahframe.work/log\"\n\t\"aahframe.work/security\"\n\t\"aahframe.work/security/authc\"\n)\n\nconst (\n\tflowCont flowResult = iota\n\tflowAbort\n)\n\nconst (\n\tgzipContentEncoding = \"gzip\"\n\n\t// Standard frame type MTU size is 1500 bytes so 1400 bytes would make sense\n\t// to Gzip by default. Read: https://en.wikipedia.org/wiki/Maximum_transmission_unit\n\tdefaultGzipMinSize = 1400\n)\n\nvar (\n\terrFileNotFound = errors.New(\"file not found\")\n)\n\ntype (\n\t// MinifierFunc is to minify the HTML buffer and write the response into writer.\n\tMinifierFunc func(contentType string, w io.Writer, r io.Reader) error\n\n\t// flowResult is result of engine activities flow.\n\t// For e.g.: route, authentication, authorization, etc.\n\tflowResult uint8\n)\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// HTTP Engine\n//______________________________________________________________________________\n\n// HTTPEngine holds the implementation handling HTTP request, response,\n// middlewares, interceptors, etc.\ntype HTTPEngine struct {\n\ta        *Application\n\tctxPool  *sync.Pool\n\tmwStack  []MiddlewareFunc\n\tmwChain  []*Middleware\n\tregistry *ainsp.TargetRegistry\n\n\t// http engine events/extensions\n\tonRequestFunc     EventCallbackFunc\n\tonPreReplyFunc    EventCallbackFunc\n\tonHeaderReplyFunc EventCallbackFunc\n\tonPostReplyFunc   EventCallbackFunc\n\tonPreAuthFunc     EventCallbackFunc\n\tonPostAuthFunc    EventCallbackFunc\n}\n\n// Handle method is HTTP handler for aah application.\nfunc (e *HTTPEngine) Handle(w http.ResponseWriter, r *http.Request) {\n\tctx := e.ctxPool.Get().(*Context)\n\tdefer e.releaseContext(ctx)\n\n\t// Record access log\n\tif e.a.settings.AccessLogEnabled {\n\t\tctx.Set(reqStartTimeKey, time.Now())\n\t\tdefer e.a.accessLog.Log(ctx)\n\t}\n\n\tctx.Req, ctx.Res = ahttp.AcquireRequest(r), ahttp.AcquireResponseWriter(w)\n\n\t// Recovery handling\n\tdefer e.handleRecovery(ctx)\n\n\tif e.a.settings.RequestIDEnabled {\n\t\tctx.setRequestID()\n\t}\n\n\t// Load session from request if its `stateful` and subject authentication info.\n\tif ctx.a.SessionManager().IsStateful() {\n\t\tctx.Subject().Session = ctx.a.SessionManager().GetSession(ctx.Req.Unwrap())\n\t\tif ctx.Session().IsKeyExists(KeyViewArgAuthcInfo) {\n\t\t\tpopulateAuthenticationInfo(ctx.Session().Get(KeyViewArgAuthcInfo).(*authc.AuthenticationInfo), ctx)\n\t\t}\n\t}\n\n\t// 'OnRequest' HTTP engine event\n\te.publishOnRequestEvent(ctx)\n\n\t// Middlewares, interceptors, targeted controller\n\tif len(e.mwChain) == 0 {\n\t\tif e.a.Type() == \"websocket\" {\n\t\t\tctx.Log().Error(\"HTTP engine is not configured. It seems like WebSocket application.\")\n\t\t} else {\n\t\t\tctx.Log().Error(\"'init.go' file introduced in release v0.10; please check your 'app-base-dir/app' \" +\n\t\t\t\t\"and then add to your version control\")\n\t\t}\n\t\tctx.Reply().InternalServerError().Error(newError(ErrGeneric, http.StatusInternalServerError))\n\t} else {\n\t\te.mwChain[0].Next(ctx)\n\t}\n\n\te.writeReply(ctx)\n}\n\n// Log method returns HTTP engine logger.\nfunc (e *HTTPEngine) Log() log.Loggerer {\n\treturn e.a.logger\n}\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// HTTP Engine - Server Extensions\n//______________________________________________________________________________\n\n// OnRequest method is to subscribe to aah HTTP engine `OnRequest` extension point.\n// `OnRequest` called for every incoming HTTP request.\n//\n// The `aah.Context` object passed to the extension functions is decorated with\n// the `ctx.SetURL()` and `ctx.SetMethod()` methods. Calls to these methods will\n// impact how the request is routed and can be used for rewrite rules.\n//\n// Note: Route is not yet populated/evaluated at this point.\nfunc (e *HTTPEngine) OnRequest(sef EventCallbackFunc) {\n\tif e.onRequestFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnRequest' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onRequestFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onRequestFunc = sef\n}\n\n// OnPreReply method is to subscribe to aah HTTP engine `OnPreReply` extension point.\n// `OnPreReply` called for every reply from aah server.\n//\n// \tExcept when\n//\n//  \t\t1) `Reply().Done()`,\n//\n//  \t\t2) `Reply().Redirect(...)` is called.\n//\n// Refer `aah.Reply().Done()` godoc for more info.\nfunc (e *HTTPEngine) OnPreReply(sef EventCallbackFunc) {\n\tif e.onPreReplyFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPreReply' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPreReplyFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPreReplyFunc = sef\n}\n\n// OnHeaderReply method is to subscribe to aah HTTP engine `OnHeaderReply` extension point.\n// `OnHeaderReply` called for every reply from aah server.\n//\n// \tExcept when\n//\n//  \t\t1) `Reply().Done()`,\n//\n//  \t\t2) `Reply().Redirect(...)` is called.\n//\n// Refer `aah.Reply().Done()` godoc for more info.\nfunc (e *HTTPEngine) OnHeaderReply(sef EventCallbackFunc) {\n\tif e.onHeaderReplyFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnHeaderReply' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onHeaderReplyFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onHeaderReplyFunc = sef\n}\n\n// OnPostReply method is to subscribe to aah HTTP engine `OnPostReply` extension\n// point. `OnPostReply` called for every reply from aah server.\n//\n// \tExcept when\n//\n//  \t\t1) `Reply().Done()`,\n//\n//  \t\t2) `Reply().Redirect(...)` is called.\n//\n// Refer `aah.Reply().Done()` godoc for more info.\nfunc (e *HTTPEngine) OnPostReply(sef EventCallbackFunc) {\n\tif e.onPostReplyFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPostReply' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPostReplyFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPostReplyFunc = sef\n}\n\n// OnPreAuth method is to subscribe to aah application `OnPreAuth` event.\n// `OnPreAuth` event pubished right before the aah server authenticates &\n// authorizes an incoming request.\nfunc (e *HTTPEngine) OnPreAuth(sef EventCallbackFunc) {\n\tif e.onPreAuthFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPreAuth' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPreAuthFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPreAuthFunc = sef\n}\n\n// OnPostAuth method is to subscribe to aah application `OnPreAuth` event.\n// `OnPostAuth` event pubished right after the aah server authenticates &\n// authorizes an incoming request.\nfunc (e *HTTPEngine) OnPostAuth(sef EventCallbackFunc) {\n\tif e.onPostAuthFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPostAuth' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPostAuthFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPostAuthFunc = sef\n}\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// HTTP Engine - Server Extension Publish\n//______________________________________________________________________________\n\nfunc (e *HTTPEngine) publishOnRequestEvent(ctx *Context) {\n\tif e.onRequestFunc != nil {\n\t\tctx.decorated = true\n\t\te.onRequestFunc(&Event{Name: EventOnRequest, Data: ctx})\n\t\tctx.decorated = false\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPreReplyEvent(ctx *Context) {\n\tif e.onPreReplyFunc != nil {\n\t\te.onPreReplyFunc(&Event{Name: EventOnPreReply, Data: ctx})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnHeaderReplyEvent(hdr http.Header) {\n\tif e.onHeaderReplyFunc != nil {\n\t\te.onHeaderReplyFunc(&Event{Name: EventOnHeaderReply, Data: hdr})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPostReplyEvent(ctx *Context) {\n\tif e.onPostReplyFunc != nil {\n\t\te.onPostReplyFunc(&Event{Name: EventOnPostReply, Data: ctx})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPreAuthEvent(ctx *Context) {\n\tif e.onPreAuthFunc != nil {\n\t\te.onPreAuthFunc(&Event{Name: EventOnPreAuth, Data: ctx})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPostAuthEvent(ctx *Context) {\n\tif e.onPostAuthFunc != nil {\n\t\te.onPostAuthFunc(&Event{Name: EventOnPostAuth, Data: ctx})\n\t}\n}\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// Engine Unexported methods\n//______________________________________________________________________________\n\nfunc (e *HTTPEngine) newContext() *Context {\n\treturn &Context{a: e.a, e: e}\n}\n\n// handleRecovery method handles application panics and recovers from it.\n// Panic gets translated into HTTP Internal Server Error (Status 500).\nfunc (e *HTTPEngine) handleRecovery(ctx *Context) {\n\tif r := recover(); r != nil {\n\t\tctx.Log().Errorf(\"Internal Server Error on %s\", ctx.Req.URL().RequestURI())\n\n\t\tst := aruntime.NewStacktrace(r, e.a.Config())\n\t\tbuf := acquireBuffer()\n\t\tdefer releaseBuffer(buf)\n\n\t\tst.Print(buf)\n\t\tctx.Log().Error(buf.String())\n\n\t\terr := ErrPanicRecovery\n\t\tif er, ok := r.(error); ok && er == ErrRenderResponse {\n\t\t\terr = er\n\t\t}\n\n\t\tctx.Reply().InternalServerError().Error(newErrorWithData(err, http.StatusInternalServerError, r))\n\t\te.writeReply(ctx)\n\t}\n}\n\n// writeReply method writes the response on the wire based on `Reply` instance.\nfunc (e *HTTPEngine) writeReply(ctx *Context) {\n\tre := ctx.Reply()\n\tif re.err != nil {\n\t\te.a.errorMgr.Handle(ctx)\n\t}\n\n\t// don't go forward, if:\n\t// \t- Response already written on the wire, refer to method `Reply().Done()`\n\t// \t- Static file route\n\tif re.done || ctx.IsStaticRoute() {\n\t\treturn\n\t}\n\n\t// 'OnPreReply' HTTP event\n\te.publishOnPreReplyEvent(ctx)\n\n\t// HTTP headers\n\tctx.writeHeaders()\n\n\t// Set Cookies\n\tctx.writeCookies()\n\n\tif re.redirect { // handle redirects\n\t\tctx.Log().Debugf(\"Redirecting to '%s' with status '%d'\", re.path, re.Code)\n\t\thttp.Redirect(ctx.Res, ctx.Req.Unwrap(), re.path, re.Code)\n\t\treturn\n\t}\n\n\t// Check ContentType and detect it if need be\n\tif len(re.ContType) == 0 {\n\t\tif _, ok := re.Rdr.(*binaryRender); !ok {\n\t\t\tre.ContentType(ctx.detectContentType())\n\t\t}\n\t}\n\tif len(re.ContType) > 0 {\n\t\tctx.Res.Header().Set(ahttp.HeaderContentType, re.ContType)\n\t}\n\n\t// 'OnHeaderReply' HTTP event\n\te.publishOnHeaderReplyEvent(ctx.Res.Header())\n\n\tif bodyAllowedForStatus(re.Code) {\n\t\tif e.a.viewMgr != nil && re.isHTML() {\n\t\t\te.a.viewMgr.resolve(ctx)\n\t\t}\n\n\t\te.writeOnWire(ctx)\n\t} else {\n\t\tctx.Res.Header().Del(ahttp.HeaderContentType)\n\t\tctx.Res.WriteHeader(re.Code)\n\t}\n\n\t// 'OnPostReply' HTTP event\n\te.publishOnPostReplyEvent(ctx)\n\n\t// Dump request and response\n\tif e.a.settings.DumpLogEnabled {\n\t\te.a.dumpLog.Dump(ctx)\n\t}\n}\n\nfunc (e *HTTPEngine) writeOnWire(ctx *Context) {\n\tre := ctx.Reply()\n\tif _, ok := re.Rdr.(*binaryRender); ok {\n\t\te.writeBinary(ctx)\n\t\treturn\n\t}\n\n\t// Render it\n\tif re.Rdr == nil {\n\t\tctx.Res.WriteHeader(re.Code)\n\t\treturn\n\t}\n\tre.body = acquireBuffer()\n\tif err := re.Rdr.Render(re.body); err != nil {\n\t\tctx.Log().Error(\"Response render error: \", err)\n\t\tpanic(ErrRenderResponse)\n\t}\n\n\t// Check response qualify for Gzip\n\tif e.qualifyGzip(ctx) && re.body.Len() > defaultGzipMinSize {\n\t\tctx.Res = wrapGzipWriter(ctx.Res)\n\t}\n\n\tctx.Res.WriteHeader(re.Code)\n\tvar w io.Writer = ctx.Res\n\n\t// If response dump log enabled with response body\n\tif e.a.settings.DumpLogEnabled && e.a.dumpLog.logResponseBody {\n\t\tresBuf := acquireBuffer()\n\t\tw = io.MultiWriter([]io.Writer{w, resBuf}...)\n\t\tctx.Set(keyAahResponseBodyBuf, resBuf)\n\t}\n\n\t// currently write error on wire is not propagated to error\n\t// since we can't do anything after that.\n\t// It could be network error, client is gone, etc.\n\tif re.isHTML() {\n\t\tif e.a.IsEnvProfile(settings.DefaultEnvProfile) || !e.minifierExists() {\n\t\t\tif _, err := re.body.WriteTo(w); err != nil {\n\t\t\t\tctx.Log().Error(err)\n\t\t\t}\n\t\t} else if err := e.a.viewMgr.minifier(re.ContType, w, re.body); err != nil {\n\t\t\tctx.Log().Error(err)\n\t\t}\n\t} else if _, err := re.body.WriteTo(w); err != nil {\n\t\tctx.Log().Error(err)\n\t}\n}\n\nfunc (e *HTTPEngine) writeBinary(ctx *Context) {\n\tre := ctx.Reply()\n\n\t// Check response qualify for Gzip\n\tif e.qualifyGzip(ctx) {\n\t\tctx.Res = wrapGzipWriter(ctx.Res)\n\t}\n\n\tctx.Res.WriteHeader(re.Code)\n\n\t// currently write error on wire is not propagated to error\n\t// since we can't do anything after that.\n\t// It could be network error, client is gone, etc.\n\tif err := re.Rdr.Render(ctx.Res); err != nil {\n\t\tctx.Log().Error(\"Response write error: \", err)\n\t}\n}\n\nfunc (e *HTTPEngine) minifierExists() bool {\n\treturn e.a.viewMgr != nil && e.a.viewMgr.minifier != nil\n}\n\nfunc (e *HTTPEngine) qualifyGzip(ctx *Context) bool {\n\treturn e.a.settings.GzipEnabled && ctx.Req.IsGzipAccepted && ctx.Reply().gzip\n}\n\nfunc (e *HTTPEngine) releaseContext(ctx *Context) {\n\tahttp.ReleaseResponseWriter(ctx.Res)\n\tahttp.ReleaseRequest(ctx.Req)\n\tsecurity.ReleaseSubject(ctx.subject)\n\treleaseBuffer(ctx.Reply().Body())\n\n\tctx.reset()\n\te.ctxPool.Put(ctx)\n}\n\nconst (\n\twww    = \"www\"\n\tnonwww = \"non-www\"\n)\n\nfunc (e *HTTPEngine) doRedirect(w http.ResponseWriter, r *http.Request) bool {\n\tcfg := e.a.Config()\n\tredirectTo := cfg.StringDefault(\"server.redirect.to\", nonwww)\n\tredirectCode := cfg.IntDefault(\"server.redirect.code\", http.StatusMovedPermanently)\n\thost := ahttp.Host(r)\n\n\tswitch redirectTo {\n\tcase www:\n\t\tif host[:3] != www {\n\t\t\thttp.Redirect(w, r, ahttp.Scheme(r)+\"://www.\"+host+r.URL.RequestURI(), redirectCode)\n\t\t\treturn true\n\t\t}\n\n\tcase nonwww:\n\t\tif host[:3] == www {\n\t\t\thttp.Redirect(w, r, ahttp.Scheme(r)+\"://\"+host[4:]+r.URL.RequestURI(), redirectCode)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// bodyAllowedForStatus reports whether a given response status code\n// permits a body. See RFC 2616, section 4.4.\n//\n// This method taken from https://golang.org/src/net/http/transfer.go#bodyAllowedForStatus\nfunc bodyAllowedForStatus(status int) bool {\n\tswitch {\n\tcase status >= 100 && status <= 199:\n\t\treturn false\n\tcase status == 204: // Status NoContent\n\t\treturn false\n\tcase status == 304: // Status NotModified\n\t\treturn false\n\t}\n\treturn true\n}\n", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"aahframe.work/ahttp\"\n\t\"aahframe.work/essentials\"\n\t\"aahframe.work/internal/util\"\n\t\"aahframe.work/vfs\"\n)\n\nvar (\n\terrSeeker = errors.New(\"static: seeker can't seek\")\n)\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// app Unexported methods\n//______________________________________________________________________________\n\nfunc (a *Application) initStatic() error {\n\ta.staticMgr = &staticManager{\n\t\ta:                     a,\n\t\tmimeCacheHdrMap:       make(map[string]string),\n\t\tnoCacheHdrValue:       \"no-cache, no-store, must-revalidate\",\n\t\tdirListDateTimeFormat: \"2006-01-02 15:04:05\",\n\t}\n\n\t// default cache header\n\ta.staticMgr.defaultCacheHdr = a.Config().StringDefault(\"cache.static.default_cache_control\", \"max-age=31536000, public\")\n\n\t// MIME cache headers\n\t// static file cache configuration is from `cache.static.*`\n\tkeyPrefix := \"cache.static.mime_types\"\n\tfor _, k := range a.Config().KeysByPath(keyPrefix) {\n\t\tmimes := strings.Split(a.Config().StringDefault(keyPrefix+\".\"+k+\".mime\", \"\"), \",\")\n\t\tfor _, m := range mimes {\n\t\t\tif !ess.IsStrEmpty(m) {\n\t\t\t\thdr := a.Config().StringDefault(keyPrefix+\".\"+k+\".cache_control\", a.staticMgr.defaultCacheHdr)\n\t\t\t\ta.staticMgr.mimeCacheHdrMap[strings.TrimSpace(strings.ToLower(m))] = hdr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype staticManager struct {\n\ta                     *Application\n\tdefaultCacheHdr       string\n\tnoCacheHdrValue       string\n\tdirListDateTimeFormat string\n\tmimeCacheHdrMap       map[string]string\n}\n\nfunc (s *staticManager) Serve(ctx *Context) error {\n\t// TODO static assets Dynamic minify for JS and CSS for non-dev profile\n\n\t// Determine route is file or directory as per user defined\n\t// static route config (refer to https://docs.aahframework.org/static-files.html#section-static).\n\tf, err := s.open(ctx)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn errFileNotFound\n\t\t}\n\t\ts.writeError(ctx.Res, ctx.Req, err)\n\t\treturn nil\n\t}\n\tdefer ess.CloseQuietly(f)\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\ts.writeError(ctx.Res, ctx.Req, err)\n\t\treturn nil\n\t}\n\n\tgf, ok := f.(vfs.Gziper)\n\tvar fr io.ReadSeeker = f\n\tif s.a.settings.GzipEnabled && ctx.Req.IsGzipAccepted {\n\t\tif ok && gf.IsGzip() {\n\t\t\tctx.Res.Header().Add(ahttp.HeaderVary, ahttp.HeaderAcceptEncoding)\n\t\t\tctx.Res.Header().Add(ahttp.HeaderContentEncoding, gzipContentEncoding)\n\t\t\tfr = bytes.NewReader(gf.RawBytes())\n\t\t} else if fi.Size() > defaultGzipMinSize && util.IsGzipWorthForFile(fi.Name()) {\n\t\t\tctx.Res = wrapGzipWriter(ctx.Res)\n\t\t}\n\t}\n\n\t// write headers\n\tctx.writeHeaders()\n\n\t// Serve file\n\tif fi.Mode().IsRegular() {\n\t\t// `Cache-Control` header based on `cache.static.*`\n\t\tif contentType, err := util.DetectFileContentType(fi.Name(), f); err == nil {\n\t\t\tctx.Res.Header().Set(ahttp.HeaderContentType, contentType)\n\n\t\t\t// apply cache header if environment profile is `prod`\n\t\t\tif s.a.IsEnvProfile(\"prod\") {\n\t\t\t\tctx.Res.Header().Set(ahttp.HeaderCacheControl, s.cacheHeader(contentType))\n\t\t\t} else { // for static files hot-reload\n\t\t\t\tctx.Res.Header().Set(ahttp.HeaderExpires, \"0\")\n\t\t\t\tctx.Res.Header().Set(ahttp.HeaderCacheControl, s.noCacheHdrValue)\n\t\t\t}\n\t\t}\n\n\t\t// 'OnPreReply' server extension point\n\t\ts.a.he.publishOnPreReplyEvent(ctx)\n\n\t\t// 'OnHeaderReply' HTTP event\n\t\ts.a.he.publishOnHeaderReplyEvent(ctx.Res.Header())\n\n\t\thttp.ServeContent(ctx.Res, ctx.Req.Unwrap(), path.Base(fi.Name()), fi.ModTime(), fr)\n\n\t\t// 'OnAfterReply' server extension point\n\t\ts.a.he.publishOnPostReplyEvent(ctx)\n\t\treturn nil\n\t}\n\n\t// Serve directory\n\tif fi.Mode().IsDir() && ctx.route.ListDir {\n\t\t// redirect if the directory name doesn't end in a slash\n\t\tif ctx.Req.Path[len(ctx.Req.Path)-1] != '/' {\n\t\t\tctx.Log().Debugf(\"redirecting to dir: %s\", ctx.Req.Path+\"/\")\n\t\t\thttp.Redirect(ctx.Res, ctx.Req.Unwrap(), path.Base(ctx.Req.Path)+\"/\", http.StatusMovedPermanently)\n\t\t\treturn nil\n\t\t}\n\n\t\t// 'OnPreReply' server extension point\n\t\ts.a.he.publishOnPreReplyEvent(ctx)\n\n\t\ts.listDirectory(ctx.Res, ctx.Req.Unwrap(), f)\n\n\t\t// 'OnAfterReply' server extension point\n\t\ts.a.he.publishOnPostReplyEvent(ctx)\n\t\treturn nil\n\t}\n\n\t// Flow reached here it means directory listing is not allowed\n\tctx.Log().Warnf(\"Directory listing not allowed: %s\", ctx.Req.Path)\n\tctx.Res.WriteHeader(http.StatusForbidden)\n\tfmt.Fprintf(ctx.Res, \"403 Directory listing not allowed\")\n\n\treturn nil\n}\n\nfunc (s *staticManager) open(ctx *Context) (vfs.File, error) {\n\tvar filePath string\n\tif ctx.route.IsFile() { // this is configured value from routes.conf\n\t\tfilePath = parseCacheBustPart(ctx.route.File, s.a.BuildInfo().Version)\n\t} else {\n\t\tfilePath = parseCacheBustPart(ctx.Req.PathValue(\"filepath\"), s.a.BuildInfo().Version)\n\t}\n\n\tresource := filepath.ToSlash(path.Join(s.a.VirtualBaseDir(), ctx.route.Dir, filePath))\n\tctx.Log().Tracef(\"Static resource: %s\", resource)\n\n\treturn s.a.VFS().Open(resource)\n}\n\nfunc (s *staticManager) cacheHeader(contentType string) string {\n\tif hdrValue, found := s.mimeCacheHdrMap[util.OnlyMIME(contentType)]; found {\n\t\treturn hdrValue\n\t}\n\treturn s.defaultCacheHdr\n}\n\n// listDirectory method compose directory listing response\nfunc (s *staticManager) listDirectory(res http.ResponseWriter, req *http.Request, f http.File) {\n\tdirs, err := f.Readdir(-1)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error reading directory\")\n\t\treturn\n\t}\n\tsort.Slice(dirs, func(i, j int) bool { return dirs[i].Name() < dirs[j].Name() })\n\n\tres.Header().Set(ahttp.HeaderContentType, ahttp.ContentTypeHTML.String())\n\tfmt.Fprintf(res, \"<html>\\n\")\n\tfmt.Fprintf(res, \"<head><title>Listing of %s</title></head>\\n\", req.URL.Path)\n\tfmt.Fprintf(res, \"<body bgcolor=\\\"white\\\">\\n\")\n\tfmt.Fprintf(res, \"<h1>Listing of %s</h1><hr>\\n\", req.URL.Path)\n\tfmt.Fprintf(res, \"<pre><table border=\\\"0\\\">\\n\")\n\tfmt.Fprintf(res, \"<tr><td collapse=\\\"2\\\"><a href=\\\"../\\\">../</a></td></tr>\\n\")\n\tfor _, d := range dirs {\n\t\tname := d.Name()\n\t\tif d.IsDir() {\n\t\t\tname += \"/\"\n\t\t}\n\t\t// name may contain '?' or '#', which must be escaped to remain\n\t\t// part of the URL path, and not indicate the start of a query\n\t\t// string or fragment.\n\t\turl := url.URL{Path: name}\n\t\tfmt.Fprintf(res, \"<tr><td><a href=\\\"%s\\\">%s</a></td><td width=\\\"200px\\\" align=\\\"right\\\">%s</td></tr>\\n\",\n\t\t\turl.String(),\n\t\t\ttemplate.HTMLEscapeString(name),\n\t\t\td.ModTime().Format(s.dirListDateTimeFormat),\n\t\t)\n\t}\n\tfmt.Fprintf(res, \"</table></pre>\\n\")\n\tfmt.Fprintf(res, \"<hr></body>\\n\")\n\tfmt.Fprintf(res, \"</html>\\n\")\n}\n\nfunc (s *staticManager) writeError(res ahttp.ResponseWriter, req *ahttp.Request, err error) {\n\tif os.IsPermission(err) {\n\t\ts.a.Log().Warnf(\"Static file permission issue: %s\", req.Path)\n\t\tres.WriteHeader(http.StatusForbidden)\n\t\tfmt.Fprintf(res, \"403 Forbidden\")\n\t} else {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"500 Internal Server Error\")\n\t}\n}\n\nfunc parseCacheBustPart(name, part string) string {\n\tif strings.Contains(name, part) {\n\t\tname = strings.Replace(name, \"-\"+part, \"\", 1)\n\t\tname = strings.Replace(name, part+\"-\", \"\", 1)\n\t}\n\treturn name\n}\n\n// wrapGzipWriter method writes respective header for gzip and wraps write into\n// gzip writer.\nfunc wrapGzipWriter(res ahttp.ResponseWriter) ahttp.ResponseWriter {\n\tres.Header().Add(ahttp.HeaderVary, ahttp.HeaderAcceptEncoding)\n\tres.Header().Add(ahttp.HeaderContentEncoding, gzipContentEncoding)\n\tres.Header().Del(ahttp.HeaderContentLength)\n\treturn ahttp.WrapGzipWriter(res)\n}\n", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"aahframe.work/ahttp\"\n\t\"aahframe.work/internal/util\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStaticFilesDelivery(t *testing.T) {\n\timportPath := filepath.Join(testdataBaseDir(), \"webapp1\")\n\tts := newTestServer(t, importPath)\n\tdefer ts.Close()\n\n\tt.Logf(\"Test Server URL [Static Files Delivery]: %s\", ts.URL)\n\n\thttpClient := new(http.Client)\n\n\t// Static File - /robots.txt\n\tt.Log(\"Static File - /robots.txt\")\n\tresp, err := httpClient.Get(ts.URL + \"/robots.txt\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.True(t, strings.Contains(responseBody(resp), \"User-agent: *\"))\n\tassert.Equal(t, \"no-cache, no-store, must-revalidate\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Static File - /assets/css/aah.css\n\tt.Log(\"Static File - /assets/css/aah.css\")\n\tresp, err = httpClient.Get(ts.URL + \"/assets/css/aah.css\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.True(t, strings.Contains(responseBody(resp), \"Minimal aah framework application template CSS.\"))\n\tassert.Equal(t, \"no-cache, no-store, must-revalidate\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Directory Listing - /assets\n\tt.Log(\"Directory Listing - /assets\")\n\tresp, err = httpClient.Get(ts.URL + \"/assets\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tbody := responseBody(resp)\n\tassert.True(t, strings.Contains(body, \"<title>Listing of /assets/</title>\"))\n\tassert.True(t, strings.Contains(body, \"<h1>Listing of /assets/</h1><hr>\"))\n\tassert.True(t, strings.Contains(body, `<a href=\"robots.txt\">robots.txt</a>`))\n\tassert.Equal(t, \"\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Static File - /assets/img/aah-framework-logo.png\n\tt.Log(\"Static File - /assets/img/aah-framework-logo.png\")\n\tresp, err = httpClient.Get(ts.URL + \"/assets/img/aah-framework-logo.png\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.Equal(t, \"image/png\", resp.Header.Get(ahttp.HeaderContentType))\n\tassert.Equal(t, \"6990\", resp.Header.Get(ahttp.HeaderContentLength))\n\tassert.Equal(t, \"no-cache, no-store, must-revalidate\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Static File - /assets/img/notfound/file.txt\n\tt.Log(\"Static File - /assets/img/notfound/file.txt\")\n\tresp, err = httpClient.Get(ts.URL + \"/assets/img/notfound/file.txt\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.Equal(t, \"0\", resp.Header.Get(ahttp.HeaderContentLength))\n}\n\nfunc TestStaticDetectContentType(t *testing.T) {\n\ttestcases := []struct {\n\t\tlabel    string\n\t\tfilename string\n\t\tresult   string\n\t}{\n\t\t{\n\t\t\tlabel:    \"svg\",\n\t\t\tfilename: \"image1.svg\",\n\t\t\tresult:   \"image/svg+xml\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"png\",\n\t\t\tfilename: \"image2.png\",\n\t\t\tresult:   \"image/png\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"jpg\",\n\t\t\tfilename: \"image3.jpg\",\n\t\t\tresult:   \"image/jpeg\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"jpeg\",\n\t\t\tfilename: \"image4.jpeg\",\n\t\t\tresult:   \"image/jpeg\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"pdf\",\n\t\t\tfilename: \"file.pdf\",\n\t\t\tresult:   \"application/pdf\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"javascript\",\n\t\t\tfilename: \"file.js\",\n\t\t\tresult:   \"application/javascript; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"txt\",\n\t\t\tfilename: \"file.txt\",\n\t\t\tresult:   \"text/plain; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"xml\",\n\t\t\tfilename: \"file.xml\",\n\t\t\tresult:   \"application/xml; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"css\",\n\t\t\tfilename: \"file.css\",\n\t\t\tresult:   \"text/css; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"html\",\n\t\t\tfilename: \"file.html\",\n\t\t\tresult:   \"text/html; charset=utf-8\",\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tt.Run(tc.label, func(t *testing.T) {\n\t\t\tv, _ := util.DetectFileContentType(tc.filename, nil)\n\t\t\tassert.Equal(t, tc.result, v)\n\t\t})\n\t}\n\n\tcontent, _ := ioutil.ReadFile(filepath.Join(testdataBaseDir(), \"test-image.noext\"))\n\tv, _ := util.DetectFileContentType(\"test-image.noext\", bytes.NewReader(content))\n\tassert.Equal(t, \"image/png\", v)\n}\n\nfunc TestStaticCacheHeader(t *testing.T) {\n\tsm := staticManager{\n\t\tmimeCacheHdrMap: map[string]string{\n\t\t\t\"text/css\":               \"public, max-age=604800, proxy-revalidate\",\n\t\t\t\"application/javascript\": \"public, max-age=604800, proxy-revalidate\",\n\t\t\t\"image/png\":              \"public, max-age=604800, proxy-revalidate\",\n\t\t},\n\t\tdefaultCacheHdr: \"public, max-age=31536000\",\n\t}\n\n\tstr := sm.cacheHeader(\"application/json\")\n\tassert.Equal(t, \"public, max-age=31536000\", str)\n\n\tstr = sm.cacheHeader(\"image/png\")\n\tassert.Equal(t, \"public, max-age=604800, proxy-revalidate\", str)\n\n\tstr = sm.cacheHeader(\"application/json; charset=utf-8\")\n\tassert.Equal(t, \"public, max-age=31536000\", str)\n\n\tstr = sm.cacheHeader(\"text/css\")\n\tassert.Equal(t, \"public, max-age=604800, proxy-revalidate\", str)\n}\n\nfunc TestStaticWriteFileError(t *testing.T) {\n\timportPath := filepath.Join(testdataBaseDir(), \"webapp1\")\n\tts := newTestServer(t, importPath)\n\tdefer ts.Close()\n\n\tt.Logf(\"Test Server URL [Static Write File Error]: %s\", ts.URL)\n\n\tsm := ts.app.staticMgr\n\treq := httptest.NewRequest(ahttp.MethodGet, \"http://localhost:8080/assets/js/myfile.js\", nil)\n\n\tw1 := httptest.NewRecorder()\n\tsm.writeError(ahttp.AcquireResponseWriter(w1), ahttp.AcquireRequest(req), os.ErrPermission)\n\tassert.Equal(t, \"403 Forbidden\", responseBody(w1.Result()))\n\n\tw2 := httptest.NewRecorder()\n\tsm.writeError(ahttp.AcquireResponseWriter(w2), ahttp.AcquireRequest(req), nil)\n\tassert.Equal(t, \"500 Internal Server Error\", responseBody(w2.Result()))\n}\n", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\n// Version no. of aah framework\nconst Version = \"0.12.3\"\n"], "fixing_code": ["<p align=\"center\">\n  <img src=\"https://cdn.aahframework.org/assets/img/aah-logo-64x64.png\" />\n  <p align=\"center\">A secure, flexible, rapid Go web framework</p>\n  <p align=\"center\">Visit aah's official website https://aahframework.org to learn more</p>\n</p>\n<p align=\"center\">\n  <p align=\"center\"><a href=\"https://travis-ci.org/go-aah/aah\"><img src=\"https://travis-ci.org/go-aah/aah.svg?branch=master\" alt=\"Build Status\"></a> <a href=\"https://codecov.io/gh/go-aah/aah/branch/master\"><img src=\"https://codecov.io/gh/go-aah/aah/branch/master/graph/badge.svg\" alt=\"Code Coverage\"></a> <a href=\"https://goreportcard.com/report/aahframe.work\"><img src=\"https://goreportcard.com/badge/aahframe.work\" alt=\"Go Report Card\"></a> <a href=\"https://github.com/go-aah/aah/releases/latest\"><img src=\"https://img.shields.io/badge/version-0.12.3-blue.svg\" alt=\"Release Version\"></a> <a href=\"https://godoc.org/aahframe.work\"><img src=\"https://godoc.org/aahframe.work?status.svg\" alt=\"Godoc\"></a> <a href=\"https://twitter.com/aahframework\"><img src=\"https://img.shields.io/badge/twitter-@aahframework-55acee.svg\" alt=\"Twitter @aahframework\"></a></p>\n</p>\n\n### News\n\n  * `v0.12.4` [released](https://docs.aahframework.org/release-notes.html) and tagged on Mar 03, 2020.\n  * `v0.12.3` [released](https://docs.aahframework.org/release-notes.html) and tagged on Feb 06, 2019.\n  * `v0.12.2` [released](https://docs.aahframework.org/release-notes.html) and tagged on Dec 13, 2018.\n  * `v0.12.0` [released](https://docs.aahframework.org/release-notes.html) and tagged on Dec 02, 2018.\n  * `v0.11.4` [released](https://docs.aahframework.org/v0.11/release-notes.html) and tagged on Aug 27, 2018.\n\n### Stargazers over time\n\n[![Stargazers over time](https://starcharts.herokuapp.com/go-aah/aah.svg)](https://starcharts.herokuapp.com/go-aah/aah)\n\n\n### Introduction\n\naah aims to provide necessary components to build modern Web, API and WebSocket applications. aah framework is secure, rapid and extensible. It takes full care of infrastructure, boilerplate code, repetitive activities, reusable components, etc.\n\n<p align=\"center\">aah is feature packed framework with <i>nature of micro framework</i>.</p>\n\nHave a look at the [aah features](https://aahframework.org/features.html) to know the benefits of using aah and it is very well [documented](https://docs.aahframework.org/).\n\n* Truly easy to use and configuration driven.\n* Security aware framework, secure session, CSRF prevention, XSS prevention, authentication, authorization, etc.\n* Build powerful end-user product and ship it.\n* Extensible at module level. If not, then immediately raise an [issue](https://aahframework.org/issues).\n* Highly maintainable, reduced delivery time, shines with application growth.\n* Steadily maturing framework and the feature-sets are getting enhanced release by release.\n\n<br>\n<p align=\"center\">aah's initial stable version <code>0.5.0</code> was released on May 19, 2017.</p>", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"path\"\n\t\"sync\"\n\t\"time\"\n\n\t\"aahframe.work/ahttp\"\n\t\"aahframe.work/ainsp\"\n\t\"aahframe.work/aruntime\"\n\tess \"aahframe.work/essentials\"\n\t\"aahframe.work/internal/settings\"\n\t\"aahframe.work/log\"\n\t\"aahframe.work/security\"\n\t\"aahframe.work/security/authc\"\n)\n\nconst (\n\tflowCont flowResult = iota\n\tflowAbort\n)\n\nconst (\n\tgzipContentEncoding = \"gzip\"\n\n\t// Standard frame type MTU size is 1500 bytes so 1400 bytes would make sense\n\t// to Gzip by default. Read: https://en.wikipedia.org/wiki/Maximum_transmission_unit\n\tdefaultGzipMinSize = 1400\n)\n\nvar (\n\terrFileNotFound = errors.New(\"file not found\")\n)\n\ntype (\n\t// MinifierFunc is to minify the HTML buffer and write the response into writer.\n\tMinifierFunc func(contentType string, w io.Writer, r io.Reader) error\n\n\t// flowResult is result of engine activities flow.\n\t// For e.g.: route, authentication, authorization, etc.\n\tflowResult uint8\n)\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// HTTP Engine\n//______________________________________________________________________________\n\n// HTTPEngine holds the implementation handling HTTP request, response,\n// middlewares, interceptors, etc.\ntype HTTPEngine struct {\n\ta        *Application\n\tctxPool  *sync.Pool\n\tmwStack  []MiddlewareFunc\n\tmwChain  []*Middleware\n\tregistry *ainsp.TargetRegistry\n\n\t// http engine events/extensions\n\tonRequestFunc     EventCallbackFunc\n\tonPreReplyFunc    EventCallbackFunc\n\tonHeaderReplyFunc EventCallbackFunc\n\tonPostReplyFunc   EventCallbackFunc\n\tonPreAuthFunc     EventCallbackFunc\n\tonPostAuthFunc    EventCallbackFunc\n}\n\n// Handle method is HTTP handler for aah application.\nfunc (e *HTTPEngine) Handle(w http.ResponseWriter, r *http.Request) {\n\tctx := e.ctxPool.Get().(*Context)\n\tdefer e.releaseContext(ctx)\n\n\t// Record access log\n\tif e.a.settings.AccessLogEnabled {\n\t\tctx.Set(reqStartTimeKey, time.Now())\n\t\tdefer e.a.accessLog.Log(ctx)\n\t}\n\n\t// Path Clean\n\tr.URL.Path = path.Clean(r.URL.Path)\n\n\tctx.Req, ctx.Res = ahttp.AcquireRequest(r), ahttp.AcquireResponseWriter(w)\n\n\t// Recovery handling\n\tdefer e.handleRecovery(ctx)\n\n\tif e.a.settings.RequestIDEnabled {\n\t\tctx.setRequestID()\n\t}\n\n\t// Load session from request if its `stateful` and subject authentication info.\n\tif ctx.a.SessionManager().IsStateful() {\n\t\tctx.Subject().Session = ctx.a.SessionManager().GetSession(ctx.Req.Unwrap())\n\t\tif ctx.Session().IsKeyExists(KeyViewArgAuthcInfo) {\n\t\t\tpopulateAuthenticationInfo(ctx.Session().Get(KeyViewArgAuthcInfo).(*authc.AuthenticationInfo), ctx)\n\t\t}\n\t}\n\n\t// 'OnRequest' HTTP engine event\n\te.publishOnRequestEvent(ctx)\n\n\t// Middlewares, interceptors, targeted controller\n\tif len(e.mwChain) == 0 {\n\t\tif e.a.Type() == \"websocket\" {\n\t\t\tctx.Log().Error(\"HTTP engine is not configured. It seems like WebSocket application.\")\n\t\t} else {\n\t\t\tctx.Log().Error(\"'init.go' file introduced in release v0.10; please check your 'app-base-dir/app' \" +\n\t\t\t\t\"and then add to your version control\")\n\t\t}\n\t\tctx.Reply().InternalServerError().Error(newError(ErrGeneric, http.StatusInternalServerError))\n\t} else {\n\t\te.mwChain[0].Next(ctx)\n\t}\n\n\te.writeReply(ctx)\n}\n\n// Log method returns HTTP engine logger.\nfunc (e *HTTPEngine) Log() log.Loggerer {\n\treturn e.a.logger\n}\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// HTTP Engine - Server Extensions\n//______________________________________________________________________________\n\n// OnRequest method is to subscribe to aah HTTP engine `OnRequest` extension point.\n// `OnRequest` called for every incoming HTTP request.\n//\n// The `aah.Context` object passed to the extension functions is decorated with\n// the `ctx.SetURL()` and `ctx.SetMethod()` methods. Calls to these methods will\n// impact how the request is routed and can be used for rewrite rules.\n//\n// Note: Route is not yet populated/evaluated at this point.\nfunc (e *HTTPEngine) OnRequest(sef EventCallbackFunc) {\n\tif e.onRequestFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnRequest' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onRequestFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onRequestFunc = sef\n}\n\n// OnPreReply method is to subscribe to aah HTTP engine `OnPreReply` extension point.\n// `OnPreReply` called for every reply from aah server.\n//\n// \tExcept when\n//\n//  \t\t1) `Reply().Done()`,\n//\n//  \t\t2) `Reply().Redirect(...)` is called.\n//\n// Refer `aah.Reply().Done()` godoc for more info.\nfunc (e *HTTPEngine) OnPreReply(sef EventCallbackFunc) {\n\tif e.onPreReplyFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPreReply' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPreReplyFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPreReplyFunc = sef\n}\n\n// OnHeaderReply method is to subscribe to aah HTTP engine `OnHeaderReply` extension point.\n// `OnHeaderReply` called for every reply from aah server.\n//\n// \tExcept when\n//\n//  \t\t1) `Reply().Done()`,\n//\n//  \t\t2) `Reply().Redirect(...)` is called.\n//\n// Refer `aah.Reply().Done()` godoc for more info.\nfunc (e *HTTPEngine) OnHeaderReply(sef EventCallbackFunc) {\n\tif e.onHeaderReplyFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnHeaderReply' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onHeaderReplyFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onHeaderReplyFunc = sef\n}\n\n// OnPostReply method is to subscribe to aah HTTP engine `OnPostReply` extension\n// point. `OnPostReply` called for every reply from aah server.\n//\n// \tExcept when\n//\n//  \t\t1) `Reply().Done()`,\n//\n//  \t\t2) `Reply().Redirect(...)` is called.\n//\n// Refer `aah.Reply().Done()` godoc for more info.\nfunc (e *HTTPEngine) OnPostReply(sef EventCallbackFunc) {\n\tif e.onPostReplyFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPostReply' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPostReplyFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPostReplyFunc = sef\n}\n\n// OnPreAuth method is to subscribe to aah application `OnPreAuth` event.\n// `OnPreAuth` event pubished right before the aah server authenticates &\n// authorizes an incoming request.\nfunc (e *HTTPEngine) OnPreAuth(sef EventCallbackFunc) {\n\tif e.onPreAuthFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPreAuth' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPreAuthFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPreAuthFunc = sef\n}\n\n// OnPostAuth method is to subscribe to aah application `OnPreAuth` event.\n// `OnPostAuth` event pubished right after the aah server authenticates &\n// authorizes an incoming request.\nfunc (e *HTTPEngine) OnPostAuth(sef EventCallbackFunc) {\n\tif e.onPostAuthFunc != nil {\n\t\te.Log().Warnf(\"Changing 'OnPostAuth' server extension from '%s' to '%s'\",\n\t\t\tess.GetFunctionInfo(e.onPostAuthFunc).QualifiedName, ess.GetFunctionInfo(sef).QualifiedName)\n\t}\n\te.onPostAuthFunc = sef\n}\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// HTTP Engine - Server Extension Publish\n//______________________________________________________________________________\n\nfunc (e *HTTPEngine) publishOnRequestEvent(ctx *Context) {\n\tif e.onRequestFunc != nil {\n\t\tctx.decorated = true\n\t\te.onRequestFunc(&Event{Name: EventOnRequest, Data: ctx})\n\t\tctx.decorated = false\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPreReplyEvent(ctx *Context) {\n\tif e.onPreReplyFunc != nil {\n\t\te.onPreReplyFunc(&Event{Name: EventOnPreReply, Data: ctx})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnHeaderReplyEvent(hdr http.Header) {\n\tif e.onHeaderReplyFunc != nil {\n\t\te.onHeaderReplyFunc(&Event{Name: EventOnHeaderReply, Data: hdr})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPostReplyEvent(ctx *Context) {\n\tif e.onPostReplyFunc != nil {\n\t\te.onPostReplyFunc(&Event{Name: EventOnPostReply, Data: ctx})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPreAuthEvent(ctx *Context) {\n\tif e.onPreAuthFunc != nil {\n\t\te.onPreAuthFunc(&Event{Name: EventOnPreAuth, Data: ctx})\n\t}\n}\n\nfunc (e *HTTPEngine) publishOnPostAuthEvent(ctx *Context) {\n\tif e.onPostAuthFunc != nil {\n\t\te.onPostAuthFunc(&Event{Name: EventOnPostAuth, Data: ctx})\n\t}\n}\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// Engine Unexported methods\n//______________________________________________________________________________\n\nfunc (e *HTTPEngine) newContext() *Context {\n\treturn &Context{a: e.a, e: e}\n}\n\n// handleRecovery method handles application panics and recovers from it.\n// Panic gets translated into HTTP Internal Server Error (Status 500).\nfunc (e *HTTPEngine) handleRecovery(ctx *Context) {\n\tif r := recover(); r != nil {\n\t\tctx.Log().Errorf(\"Internal Server Error on %s\", ctx.Req.URL().RequestURI())\n\n\t\tst := aruntime.NewStacktrace(r, e.a.Config())\n\t\tbuf := acquireBuffer()\n\t\tdefer releaseBuffer(buf)\n\n\t\tst.Print(buf)\n\t\tctx.Log().Error(buf.String())\n\n\t\terr := ErrPanicRecovery\n\t\tif er, ok := r.(error); ok && er == ErrRenderResponse {\n\t\t\terr = er\n\t\t}\n\n\t\tctx.Reply().InternalServerError().Error(newErrorWithData(err, http.StatusInternalServerError, r))\n\t\te.writeReply(ctx)\n\t}\n}\n\n// writeReply method writes the response on the wire based on `Reply` instance.\nfunc (e *HTTPEngine) writeReply(ctx *Context) {\n\tre := ctx.Reply()\n\tif re.err != nil {\n\t\te.a.errorMgr.Handle(ctx)\n\t}\n\n\t// don't go forward, if:\n\t// \t- Response already written on the wire, refer to method `Reply().Done()`\n\t// \t- Static file route\n\tif re.done || ctx.IsStaticRoute() {\n\t\treturn\n\t}\n\n\t// 'OnPreReply' HTTP event\n\te.publishOnPreReplyEvent(ctx)\n\n\t// HTTP headers\n\tctx.writeHeaders()\n\n\t// Set Cookies\n\tctx.writeCookies()\n\n\tif re.redirect { // handle redirects\n\t\tctx.Log().Debugf(\"Redirecting to '%s' with status '%d'\", re.path, re.Code)\n\t\thttp.Redirect(ctx.Res, ctx.Req.Unwrap(), re.path, re.Code)\n\t\treturn\n\t}\n\n\t// Check ContentType and detect it if need be\n\tif len(re.ContType) == 0 {\n\t\tif _, ok := re.Rdr.(*binaryRender); !ok {\n\t\t\tre.ContentType(ctx.detectContentType())\n\t\t}\n\t}\n\tif len(re.ContType) > 0 {\n\t\tctx.Res.Header().Set(ahttp.HeaderContentType, re.ContType)\n\t}\n\n\t// 'OnHeaderReply' HTTP event\n\te.publishOnHeaderReplyEvent(ctx.Res.Header())\n\n\tif bodyAllowedForStatus(re.Code) {\n\t\tif e.a.viewMgr != nil && re.isHTML() {\n\t\t\te.a.viewMgr.resolve(ctx)\n\t\t}\n\n\t\te.writeOnWire(ctx)\n\t} else {\n\t\tctx.Res.Header().Del(ahttp.HeaderContentType)\n\t\tctx.Res.WriteHeader(re.Code)\n\t}\n\n\t// 'OnPostReply' HTTP event\n\te.publishOnPostReplyEvent(ctx)\n\n\t// Dump request and response\n\tif e.a.settings.DumpLogEnabled {\n\t\te.a.dumpLog.Dump(ctx)\n\t}\n}\n\nfunc (e *HTTPEngine) writeOnWire(ctx *Context) {\n\tre := ctx.Reply()\n\tif _, ok := re.Rdr.(*binaryRender); ok {\n\t\te.writeBinary(ctx)\n\t\treturn\n\t}\n\n\t// Render it\n\tif re.Rdr == nil {\n\t\tctx.Res.WriteHeader(re.Code)\n\t\treturn\n\t}\n\tre.body = acquireBuffer()\n\tif err := re.Rdr.Render(re.body); err != nil {\n\t\tctx.Log().Error(\"Response render error: \", err)\n\t\tpanic(ErrRenderResponse)\n\t}\n\n\t// Check response qualify for Gzip\n\tif e.qualifyGzip(ctx) && re.body.Len() > defaultGzipMinSize {\n\t\tctx.Res = wrapGzipWriter(ctx.Res)\n\t}\n\n\tctx.Res.WriteHeader(re.Code)\n\tvar w io.Writer = ctx.Res\n\n\t// If response dump log enabled with response body\n\tif e.a.settings.DumpLogEnabled && e.a.dumpLog.logResponseBody {\n\t\tresBuf := acquireBuffer()\n\t\tw = io.MultiWriter([]io.Writer{w, resBuf}...)\n\t\tctx.Set(keyAahResponseBodyBuf, resBuf)\n\t}\n\n\t// currently write error on wire is not propagated to error\n\t// since we can't do anything after that.\n\t// It could be network error, client is gone, etc.\n\tif re.isHTML() {\n\t\tif e.a.IsEnvProfile(settings.DefaultEnvProfile) || !e.minifierExists() {\n\t\t\tif _, err := re.body.WriteTo(w); err != nil {\n\t\t\t\tctx.Log().Error(err)\n\t\t\t}\n\t\t} else if err := e.a.viewMgr.minifier(re.ContType, w, re.body); err != nil {\n\t\t\tctx.Log().Error(err)\n\t\t}\n\t} else if _, err := re.body.WriteTo(w); err != nil {\n\t\tctx.Log().Error(err)\n\t}\n}\n\nfunc (e *HTTPEngine) writeBinary(ctx *Context) {\n\tre := ctx.Reply()\n\n\t// Check response qualify for Gzip\n\tif e.qualifyGzip(ctx) {\n\t\tctx.Res = wrapGzipWriter(ctx.Res)\n\t}\n\n\tctx.Res.WriteHeader(re.Code)\n\n\t// currently write error on wire is not propagated to error\n\t// since we can't do anything after that.\n\t// It could be network error, client is gone, etc.\n\tif err := re.Rdr.Render(ctx.Res); err != nil {\n\t\tctx.Log().Error(\"Response write error: \", err)\n\t}\n}\n\nfunc (e *HTTPEngine) minifierExists() bool {\n\treturn e.a.viewMgr != nil && e.a.viewMgr.minifier != nil\n}\n\nfunc (e *HTTPEngine) qualifyGzip(ctx *Context) bool {\n\treturn e.a.settings.GzipEnabled && ctx.Req.IsGzipAccepted && ctx.Reply().gzip\n}\n\nfunc (e *HTTPEngine) releaseContext(ctx *Context) {\n\tahttp.ReleaseResponseWriter(ctx.Res)\n\tahttp.ReleaseRequest(ctx.Req)\n\tsecurity.ReleaseSubject(ctx.subject)\n\treleaseBuffer(ctx.Reply().Body())\n\n\tctx.reset()\n\te.ctxPool.Put(ctx)\n}\n\nconst (\n\twww    = \"www\"\n\tnonwww = \"non-www\"\n)\n\nfunc (e *HTTPEngine) doRedirect(w http.ResponseWriter, r *http.Request) bool {\n\tcfg := e.a.Config()\n\tredirectTo := cfg.StringDefault(\"server.redirect.to\", nonwww)\n\tredirectCode := cfg.IntDefault(\"server.redirect.code\", http.StatusMovedPermanently)\n\thost := ahttp.Host(r)\n\n\tswitch redirectTo {\n\tcase www:\n\t\tif host[:3] != www {\n\t\t\thttp.Redirect(w, r, ahttp.Scheme(r)+\"://www.\"+host+r.URL.RequestURI(), redirectCode)\n\t\t\treturn true\n\t\t}\n\n\tcase nonwww:\n\t\tif host[:3] == www {\n\t\t\thttp.Redirect(w, r, ahttp.Scheme(r)+\"://\"+host[4:]+r.URL.RequestURI(), redirectCode)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// bodyAllowedForStatus reports whether a given response status code\n// permits a body. See RFC 2616, section 4.4.\n//\n// This method taken from https://golang.org/src/net/http/transfer.go#bodyAllowedForStatus\nfunc bodyAllowedForStatus(status int) bool {\n\tswitch {\n\tcase status >= 100 && status <= 199:\n\t\treturn false\n\tcase status == 204: // Status NoContent\n\t\treturn false\n\tcase status == 304: // Status NotModified\n\t\treturn false\n\t}\n\treturn true\n}\n", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"aahframe.work/ahttp\"\n\tess \"aahframe.work/essentials\"\n\t\"aahframe.work/internal/util\"\n\t\"aahframe.work/vfs\"\n)\n\nvar (\n\terrSeeker = errors.New(\"static: seeker can't seek\")\n)\n\n//\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\n// app Unexported methods\n//______________________________________________________________________________\n\nfunc (a *Application) initStatic() error {\n\ta.staticMgr = &staticManager{\n\t\ta:                     a,\n\t\tmimeCacheHdrMap:       make(map[string]string),\n\t\tnoCacheHdrValue:       \"no-cache, no-store, must-revalidate\",\n\t\tdirListDateTimeFormat: \"2006-01-02 15:04:05\",\n\t}\n\n\t// default cache header\n\ta.staticMgr.defaultCacheHdr = a.Config().StringDefault(\"cache.static.default_cache_control\", \"max-age=31536000, public\")\n\n\t// MIME cache headers\n\t// static file cache configuration is from `cache.static.*`\n\tkeyPrefix := \"cache.static.mime_types\"\n\tfor _, k := range a.Config().KeysByPath(keyPrefix) {\n\t\tmimes := strings.Split(a.Config().StringDefault(keyPrefix+\".\"+k+\".mime\", \"\"), \",\")\n\t\tfor _, m := range mimes {\n\t\t\tif !ess.IsStrEmpty(m) {\n\t\t\t\thdr := a.Config().StringDefault(keyPrefix+\".\"+k+\".cache_control\", a.staticMgr.defaultCacheHdr)\n\t\t\t\ta.staticMgr.mimeCacheHdrMap[strings.TrimSpace(strings.ToLower(m))] = hdr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype staticManager struct {\n\ta                     *Application\n\tdefaultCacheHdr       string\n\tnoCacheHdrValue       string\n\tdirListDateTimeFormat string\n\tmimeCacheHdrMap       map[string]string\n}\n\nfunc (s *staticManager) Serve(ctx *Context) error {\n\t// TODO static assets Dynamic minify for JS and CSS for non-dev profile\n\n\t// Determine route is file or directory as per user defined\n\t// static route config (refer to https://docs.aahframework.org/static-files.html#section-static).\n\tf, err := s.open(ctx)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn errFileNotFound\n\t\t}\n\t\ts.writeError(ctx.Res, ctx.Req, err)\n\t\treturn nil\n\t}\n\tdefer ess.CloseQuietly(f)\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\ts.writeError(ctx.Res, ctx.Req, err)\n\t\treturn nil\n\t}\n\n\tgf, ok := f.(vfs.Gziper)\n\tvar fr io.ReadSeeker = f\n\tif s.a.settings.GzipEnabled && ctx.Req.IsGzipAccepted {\n\t\tif ok && gf.IsGzip() {\n\t\t\tctx.Res.Header().Add(ahttp.HeaderVary, ahttp.HeaderAcceptEncoding)\n\t\t\tctx.Res.Header().Add(ahttp.HeaderContentEncoding, gzipContentEncoding)\n\t\t\tfr = bytes.NewReader(gf.RawBytes())\n\t\t} else if fi.Size() > defaultGzipMinSize && util.IsGzipWorthForFile(fi.Name()) {\n\t\t\tctx.Res = wrapGzipWriter(ctx.Res)\n\t\t}\n\t}\n\n\t// write headers\n\tctx.writeHeaders()\n\n\t// Serve file\n\tif fi.Mode().IsRegular() {\n\t\t// `Cache-Control` header based on `cache.static.*`\n\t\tif contentType, err := util.DetectFileContentType(fi.Name(), f); err == nil {\n\t\t\tctx.Res.Header().Set(ahttp.HeaderContentType, contentType)\n\n\t\t\t// apply cache header if environment profile is `prod`\n\t\t\tif s.a.IsEnvProfile(\"prod\") {\n\t\t\t\tctx.Res.Header().Set(ahttp.HeaderCacheControl, s.cacheHeader(contentType))\n\t\t\t} else { // for static files hot-reload\n\t\t\t\tctx.Res.Header().Set(ahttp.HeaderExpires, \"0\")\n\t\t\t\tctx.Res.Header().Set(ahttp.HeaderCacheControl, s.noCacheHdrValue)\n\t\t\t}\n\t\t}\n\n\t\t// 'OnPreReply' server extension point\n\t\ts.a.he.publishOnPreReplyEvent(ctx)\n\n\t\t// 'OnHeaderReply' HTTP event\n\t\ts.a.he.publishOnHeaderReplyEvent(ctx.Res.Header())\n\n\t\thttp.ServeContent(ctx.Res, ctx.Req.Unwrap(), path.Base(fi.Name()), fi.ModTime(), fr)\n\n\t\t// 'OnAfterReply' server extension point\n\t\ts.a.he.publishOnPostReplyEvent(ctx)\n\t\treturn nil\n\t}\n\n\t// Serve directory\n\tif fi.Mode().IsDir() && ctx.route.ListDir {\n\t\tfmt.Println(\"here 1\")\n\t\t// redirect if the directory name doesn't end in a slash\n\t\tif ctx.Req.Path[len(ctx.Req.Path)-1] != '/' {\n\t\t\tctx.Log().Debugf(\"redirecting to dir: %s\", ctx.Req.Path+\"/\")\n\t\t\thttp.Redirect(ctx.Res, ctx.Req.Unwrap(), path.Base(ctx.Req.Path)+\"/\", http.StatusMovedPermanently)\n\t\t\treturn nil\n\t\t}\n\n\t\t// 'OnPreReply' server extension point\n\t\ts.a.he.publishOnPreReplyEvent(ctx)\n\n\t\ts.listDirectory(ctx.Res, ctx.Req.Unwrap(), f)\n\n\t\t// 'OnAfterReply' server extension point\n\t\ts.a.he.publishOnPostReplyEvent(ctx)\n\t\treturn nil\n\t}\n\n\t// Flow reached here it means directory listing is not allowed\n\tctx.Log().Warnf(\"Directory listing not allowed: %s\", ctx.Req.Path)\n\tctx.Res.WriteHeader(http.StatusForbidden)\n\tfmt.Fprintf(ctx.Res, \"403 Directory listing not allowed\")\n\n\treturn nil\n}\n\nfunc (s *staticManager) open(ctx *Context) (vfs.File, error) {\n\tvar filePath string\n\tif ctx.route.IsFile() { // this is configured value from routes.conf\n\t\tfilePath = parseCacheBustPart(ctx.route.File, s.a.BuildInfo().Version)\n\t} else {\n\t\tfilePath = parseCacheBustPart(ctx.Req.PathValue(\"filepath\"), s.a.BuildInfo().Version)\n\t}\n\n\tresource := filepath.ToSlash(path.Join(s.a.VirtualBaseDir(), ctx.route.Dir, filePath))\n\tctx.Log().Tracef(\"Static resource: %s\", resource)\n\n\treturn s.a.VFS().Open(resource)\n}\n\nfunc (s *staticManager) cacheHeader(contentType string) string {\n\tif hdrValue, found := s.mimeCacheHdrMap[util.OnlyMIME(contentType)]; found {\n\t\treturn hdrValue\n\t}\n\treturn s.defaultCacheHdr\n}\n\n// listDirectory method compose directory listing response\nfunc (s *staticManager) listDirectory(res http.ResponseWriter, req *http.Request, f http.File) {\n\tdirs, err := f.Readdir(-1)\n\tif err != nil {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"Error reading directory\")\n\t\treturn\n\t}\n\tsort.Slice(dirs, func(i, j int) bool { return dirs[i].Name() < dirs[j].Name() })\n\n\tres.Header().Set(ahttp.HeaderContentType, ahttp.ContentTypeHTML.String())\n\tfmt.Fprintf(res, \"<html>\\n\")\n\tfmt.Fprintf(res, \"<head><title>Listing of %s</title></head>\\n\", req.URL.Path)\n\tfmt.Fprintf(res, \"<body bgcolor=\\\"white\\\">\\n\")\n\tfmt.Fprintf(res, \"<h1>Listing of %s</h1><hr>\\n\", req.URL.Path)\n\tfmt.Fprintf(res, \"<pre><table border=\\\"0\\\">\\n\")\n\tfmt.Fprintf(res, \"<tr><td collapse=\\\"2\\\"><a href=\\\"../\\\">../</a></td></tr>\\n\")\n\tfor _, d := range dirs {\n\t\tname := d.Name()\n\t\tif d.IsDir() {\n\t\t\tname += \"/\"\n\t\t}\n\t\t// name may contain '?' or '#', which must be escaped to remain\n\t\t// part of the URL path, and not indicate the start of a query\n\t\t// string or fragment.\n\t\turl := url.URL{Path: name}\n\t\tfmt.Fprintf(res, \"<tr><td><a href=\\\"%s\\\">%s</a></td><td width=\\\"200px\\\" align=\\\"right\\\">%s</td></tr>\\n\",\n\t\t\turl.String(),\n\t\t\ttemplate.HTMLEscapeString(name),\n\t\t\td.ModTime().Format(s.dirListDateTimeFormat),\n\t\t)\n\t}\n\tfmt.Fprintf(res, \"</table></pre>\\n\")\n\tfmt.Fprintf(res, \"<hr></body>\\n\")\n\tfmt.Fprintf(res, \"</html>\\n\")\n}\n\nfunc (s *staticManager) writeError(res ahttp.ResponseWriter, req *ahttp.Request, err error) {\n\tif os.IsPermission(err) {\n\t\ts.a.Log().Warnf(\"Static file permission issue: %s\", req.Path)\n\t\tres.WriteHeader(http.StatusForbidden)\n\t\tfmt.Fprintf(res, \"403 Forbidden\")\n\t} else {\n\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprintf(res, \"500 Internal Server Error\")\n\t}\n}\n\nfunc parseCacheBustPart(name, part string) string {\n\tif strings.Contains(name, part) {\n\t\tname = strings.Replace(name, \"-\"+part, \"\", 1)\n\t\tname = strings.Replace(name, part+\"-\", \"\", 1)\n\t}\n\treturn name\n}\n\n// wrapGzipWriter method writes respective header for gzip and wraps write into\n// gzip writer.\nfunc wrapGzipWriter(res ahttp.ResponseWriter) ahttp.ResponseWriter {\n\tres.Header().Add(ahttp.HeaderVary, ahttp.HeaderAcceptEncoding)\n\tres.Header().Add(ahttp.HeaderContentEncoding, gzipContentEncoding)\n\tres.Header().Del(ahttp.HeaderContentLength)\n\treturn ahttp.WrapGzipWriter(res)\n}\n", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"aahframe.work/ahttp\"\n\t\"aahframe.work/internal/util\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStaticFilesDelivery(t *testing.T) {\n\timportPath := filepath.Join(testdataBaseDir(), \"webapp1\")\n\tts := newTestServer(t, importPath)\n\tdefer ts.Close()\n\n\tt.Logf(\"Test Server URL [Static Files Delivery]: %s\", ts.URL)\n\n\thttpClient := new(http.Client)\n\n\t// Static File - /robots.txt\n\tt.Log(\"Static File - /robots.txt\")\n\tresp, err := httpClient.Get(ts.URL + \"/robots.txt\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.True(t, strings.Contains(responseBody(resp), \"User-agent: *\"))\n\tassert.Equal(t, \"no-cache, no-store, must-revalidate\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Static File - /assets/css/aah.css\n\tt.Log(\"Static File - /assets/css/aah.css\")\n\tresp, err = httpClient.Get(ts.URL + \"/assets/css/aah.css\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.True(t, strings.Contains(responseBody(resp), \"Minimal aah framework application template CSS.\"))\n\tassert.Equal(t, \"no-cache, no-store, must-revalidate\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Directory Listing - /assets\n\t// t.Log(\"Directory Listing - /assets\")\n\t// resp, err = httpClient.Get(ts.URL + \"/assets\")\n\t// fmt.Println(\"err\", err.Error())\n\t// assert.Nil(t, err)\n\t// assert.Equal(t, 200, resp.StatusCode)\n\t// body := responseBody(resp)\n\t// fmt.Println(\"body\", body)\n\t// assert.True(t, strings.Contains(body, \"<title>Listing of /assets/</title>\"))\n\t// assert.True(t, strings.Contains(body, \"<h1>Listing of /assets/</h1><hr>\"))\n\t// assert.True(t, strings.Contains(body, `<a href=\"robots.txt\">robots.txt</a>`))\n\t// assert.Equal(t, \"\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Static File - /assets/img/aah-framework-logo.png\n\tt.Log(\"Static File - /assets/img/aah-framework-logo.png\")\n\tresp, err = httpClient.Get(ts.URL + \"/assets/img/aah-framework-logo.png\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.Equal(t, \"image/png\", resp.Header.Get(ahttp.HeaderContentType))\n\tassert.Equal(t, \"6990\", resp.Header.Get(ahttp.HeaderContentLength))\n\tassert.Equal(t, \"no-cache, no-store, must-revalidate\", resp.Header.Get(ahttp.HeaderCacheControl))\n\n\t// Static File - /assets/img/notfound/file.txt\n\tt.Log(\"Static File - /assets/img/notfound/file.txt\")\n\tresp, err = httpClient.Get(ts.URL + \"/assets/img/notfound/file.txt\")\n\tassert.Nil(t, err)\n\tassert.Equal(t, 200, resp.StatusCode)\n\tassert.Equal(t, \"0\", resp.Header.Get(ahttp.HeaderContentLength))\n}\n\nfunc TestStaticDetectContentType(t *testing.T) {\n\ttestcases := []struct {\n\t\tlabel    string\n\t\tfilename string\n\t\tresult   string\n\t}{\n\t\t{\n\t\t\tlabel:    \"svg\",\n\t\t\tfilename: \"image1.svg\",\n\t\t\tresult:   \"image/svg+xml\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"png\",\n\t\t\tfilename: \"image2.png\",\n\t\t\tresult:   \"image/png\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"jpg\",\n\t\t\tfilename: \"image3.jpg\",\n\t\t\tresult:   \"image/jpeg\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"jpeg\",\n\t\t\tfilename: \"image4.jpeg\",\n\t\t\tresult:   \"image/jpeg\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"pdf\",\n\t\t\tfilename: \"file.pdf\",\n\t\t\tresult:   \"application/pdf\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"javascript\",\n\t\t\tfilename: \"file.js\",\n\t\t\tresult:   \"application/javascript; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"txt\",\n\t\t\tfilename: \"file.txt\",\n\t\t\tresult:   \"text/plain; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"xml\",\n\t\t\tfilename: \"file.xml\",\n\t\t\tresult:   \"application/xml; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"css\",\n\t\t\tfilename: \"file.css\",\n\t\t\tresult:   \"text/css; charset=utf-8\",\n\t\t},\n\t\t{\n\t\t\tlabel:    \"html\",\n\t\t\tfilename: \"file.html\",\n\t\t\tresult:   \"text/html; charset=utf-8\",\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tt.Run(tc.label, func(t *testing.T) {\n\t\t\tv, _ := util.DetectFileContentType(tc.filename, nil)\n\t\t\tassert.Equal(t, tc.result, v)\n\t\t})\n\t}\n\n\tcontent, _ := ioutil.ReadFile(filepath.Join(testdataBaseDir(), \"test-image.noext\"))\n\tv, _ := util.DetectFileContentType(\"test-image.noext\", bytes.NewReader(content))\n\tassert.Equal(t, \"image/png\", v)\n}\n\nfunc TestStaticCacheHeader(t *testing.T) {\n\tsm := staticManager{\n\t\tmimeCacheHdrMap: map[string]string{\n\t\t\t\"text/css\":               \"public, max-age=604800, proxy-revalidate\",\n\t\t\t\"application/javascript\": \"public, max-age=604800, proxy-revalidate\",\n\t\t\t\"image/png\":              \"public, max-age=604800, proxy-revalidate\",\n\t\t},\n\t\tdefaultCacheHdr: \"public, max-age=31536000\",\n\t}\n\n\tstr := sm.cacheHeader(\"application/json\")\n\tassert.Equal(t, \"public, max-age=31536000\", str)\n\n\tstr = sm.cacheHeader(\"image/png\")\n\tassert.Equal(t, \"public, max-age=604800, proxy-revalidate\", str)\n\n\tstr = sm.cacheHeader(\"application/json; charset=utf-8\")\n\tassert.Equal(t, \"public, max-age=31536000\", str)\n\n\tstr = sm.cacheHeader(\"text/css\")\n\tassert.Equal(t, \"public, max-age=604800, proxy-revalidate\", str)\n}\n\nfunc TestStaticWriteFileError(t *testing.T) {\n\timportPath := filepath.Join(testdataBaseDir(), \"webapp1\")\n\tts := newTestServer(t, importPath)\n\tdefer ts.Close()\n\n\tt.Logf(\"Test Server URL [Static Write File Error]: %s\", ts.URL)\n\n\tsm := ts.app.staticMgr\n\treq := httptest.NewRequest(ahttp.MethodGet, \"http://localhost:8080/assets/js/myfile.js\", nil)\n\n\tw1 := httptest.NewRecorder()\n\tsm.writeError(ahttp.AcquireResponseWriter(w1), ahttp.AcquireRequest(req), os.ErrPermission)\n\tassert.Equal(t, \"403 Forbidden\", responseBody(w1.Result()))\n\n\tw2 := httptest.NewRecorder()\n\tsm.writeError(ahttp.AcquireResponseWriter(w2), ahttp.AcquireRequest(req), nil)\n\tassert.Equal(t, \"500 Internal Server Error\", responseBody(w2.Result()))\n}\n", "// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)\n// Source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage aah\n\n// Version no. of aah framework\nconst Version = \"0.12.4\"\n"], "filenames": ["README.md", "http_engine.go", "static.go", "static_test.go", "version.go"], "buggy_code_start_loc": [11, 10, 22, 48, 8], "buggy_code_end_loc": [11, 81, 135, 57, 9], "fixing_code_start_loc": [12, 11, 22, 48, 8], "fixing_code_end_loc": [13, 86, 137, 59, 9], "type": "CWE-22", "message": "Due to improper sanitization of user input, HTTPEngine.Handle allows for directory traversal, allowing an attacker to read files outside of the target directory that the server has permission to read.", "other": {"cve": {"id": "CVE-2020-36559", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.500", "lastModified": "2023-06-08T21:15:15.410", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Due to improper sanitization of user input, HTTPEngine.Handle allows for directory traversal, allowing an attacker to read files outside of the target directory that the server has permission to read."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aahframework:aah:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.12.4", "matchCriteriaId": "D7F9E1A9-0E79-4115-B596-DAFFB5854FF0"}]}]}], "references": [{"url": "https://github.com/go-aah/aah/commit/881dc9f71d1f7a4e8a9a39df9c5c081d3a2da1ec", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/go-aah/aah/issues/266", "source": "security@golang.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/go-aah/aah/pull/267", "source": "security@golang.org", "tags": ["Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0033", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/go-aah/aah/commit/881dc9f71d1f7a4e8a9a39df9c5c081d3a2da1ec"}}