{"buggy_code": ["import datetime\nimport difflib\nimport json\n\nfrom django.apps import apps\nfrom django.http import (\n    Http404,\n    HttpResponse,\n    HttpResponseBadRequest,\n    HttpResponseForbidden,\n    HttpResponseRedirect,\n)\nfrom django.shortcuts import get_object_or_404, render\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.cache import add_never_cache_headers, patch_cache_control\nfrom django.utils.translation import gettext\nfrom django.views.generic import FormView\nfrom django.views.generic.base import TemplateView, View\nfrom django.views.generic.detail import DetailView\nfrom pygments.lexers import get_lexer_for_filename\nfrom pygments.util import ClassNotFound\n\nfrom dpaste import highlight\nfrom dpaste.forms import SnippetForm, get_expire_values\nfrom dpaste.highlight import PygmentsHighlighter\nfrom dpaste.models import Snippet\n\nconfig = apps.get_app_config(\"dpaste\")\n\n\n# -----------------------------------------------------------------------------\n# Snippet Handling\n# -----------------------------------------------------------------------------\n\n\nclass SnippetView(FormView):\n    \"\"\"\n    Create a new snippet.\n    \"\"\"\n\n    form_class = SnippetForm\n    template_name = \"dpaste/new.html\"\n\n    def get(self, request, *args, **kwargs):\n        response = super().get(request, *args, **kwargs)\n        return response\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"request\": self.request})\n        return kwargs\n\n    def form_valid(self, form):\n        snippet = form.save()\n        return HttpResponseRedirect(snippet.get_absolute_url())\n\n    def get_context_data(self, **kwargs):\n        ctx = super().get_context_data(**kwargs)\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\nclass SnippetDetailView(DetailView, FormView):\n    \"\"\"\n    Details list view of a snippet. Handles the actual view, reply and\n    tree/diff view.\n    \"\"\"\n\n    form_class = SnippetForm\n    queryset = Snippet.objects.all()\n    template_name = \"dpaste/details.html\"\n    slug_url_kwarg = \"snippet_id\"\n    slug_field = \"secret_id\"\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Delete a snippet. This is allowed by anybody as long as he knows the\n        snippet id. I got too many manual requests to do this, mostly for legal\n        reasons and the chance to abuse this is not given anyway, since snippets\n        always expire.\n        \"\"\"\n        if \"delete\" in self.request.POST:\n            snippet = get_object_or_404(Snippet, secret_id=self.kwargs[\"snippet_id\"])\n            snippet.delete()\n\n            # Append `#` so #delete goes away in Firefox\n            url = \"{0}#\".format(reverse(\"snippet_new\"))\n            return HttpResponseRedirect(url)\n\n        return super().post(request, *args, **kwargs)\n\n    def get(self, request, *args, **kwargs):\n        snippet = self.get_object()\n\n        # One-Time snippet get deleted if the view count matches our limit\n        if (\n            snippet.expire_type == Snippet.EXPIRE_TIME\n            and snippet.expires < timezone.now()\n        ) or (\n            snippet.expire_type == Snippet.EXPIRE_ONETIME\n            and snippet.view_count >= config.ONETIME_LIMIT\n        ):\n            snippet.delete()\n            raise Http404()\n\n        # Increase the view count of the snippet\n        snippet.view_count += 1\n        snippet.save(update_fields=[\"view_count\"])\n\n        return super().get(request, *args, **kwargs)\n\n    def get_initial(self):\n        snippet = self.get_object()\n        return {\n            \"content\": snippet.content,\n            \"lexer\": snippet.lexer,\n            \"rtl\": snippet.rtl,\n        }\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"request\": self.request})\n        return kwargs\n\n    def form_valid(self, form):\n        snippet = form.save(parent=self.get_object())\n        return HttpResponseRedirect(snippet.get_absolute_url())\n\n    def get_snippet_diff(self):\n        snippet = self.get_object()\n\n        if not snippet.parent_id:\n            return None\n\n        if snippet.content == snippet.parent.content:\n            return None\n\n        d = difflib.unified_diff(\n            snippet.parent.content.splitlines(),\n            snippet.content.splitlines(),\n            gettext(\"Previous Snippet\"),\n            gettext(\"Current Snippet\"),\n            n=1,\n        )\n        diff_code = \"\\n\".join(d).strip()\n        highlighted = PygmentsHighlighter().render(diff_code, \"diff\")\n\n        # Remove blank lines\n        return highlighted\n\n    def get_context_data(self, **kwargs):\n        self.object = self.get_object()\n\n        ctx = super().get_context_data(**kwargs)\n        ctx.update(\n            {\n                \"wordwrap\": self.object.lexer in highlight.LEXER_WORDWRAP,\n                \"diff\": self.get_snippet_diff(),\n                \"raw_mode\": config.RAW_MODE_ENABLED,\n            }\n        )\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\nclass SnippetRawView(SnippetDetailView):\n    \"\"\"\n    Display the raw content of a snippet\n    \"\"\"\n\n    template_name = \"dpaste/raw.html\"\n\n    def dispatch(self, request, *args, **kwargs):\n        if not config.RAW_MODE_ENABLED:\n            return HttpResponseForbidden(\n                gettext(\"This dpaste installation has Raw view mode disabled.\")\n            )\n        return super().dispatch(request, *args, **kwargs)\n\n    def render_plain_text(self, context, **response_kwargs):\n        snippet = self.get_object()\n        response = HttpResponse(snippet.content)\n        response[\"Content-Type\"] = \"text/plain;charset=UTF-8\"\n        response[\"X-Content-Type-Options\"] = \"nosniff\"\n        return response\n\n    def render_to_response(self, context, **response_kwargs):\n        if config.RAW_MODE_PLAIN_TEXT:\n            return self.render_plain_text(config, **response_kwargs)\n        return super().render_to_response(context, **response_kwargs)\n\n    def get_context_data(self, **kwargs):\n        ctx = super().get_context_data(**kwargs)\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\nclass SnippetHistory(TemplateView):\n    \"\"\"\n    Display the last `n` snippets created by this user (and saved in his\n    session).\n    \"\"\"\n\n    template_name = \"dpaste/history.html\"\n\n    def get_user_snippets(self):\n        snippet_id_list = self.request.session.get(\"snippet_list\", [])\n        return Snippet.objects.filter(pk__in=snippet_id_list)\n\n    def get(self, request, *args, **kwargs):\n        response = super().get(request, *args, **kwargs)\n        add_never_cache_headers(response)\n        return response\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Delete all user snippets at once.\n        \"\"\"\n        if \"delete\" in self.request.POST:\n            self.get_user_snippets().delete()\n\n        # Append `#` so #delete goes away in Firefox\n        url = \"{0}#\".format(reverse(\"snippet_history\"))\n        return HttpResponseRedirect(url)\n\n    def get_context_data(self, **kwargs):\n        ctx = super().get_context_data(**kwargs)\n        ctx.update({\"snippet_list\": self.get_user_snippets()})\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\n# -----------------------------------------------------------------------------\n# API Handling\n# -----------------------------------------------------------------------------\n\n\nclass APIView(View):\n    \"\"\"\n    API View\n    \"\"\"\n\n    def _format_default(self, s):\n        \"\"\"\n        The default response is the snippet URL wrapped in quotes.\n        \"\"\"\n        base_url = config.get_base_url(request=self.request)\n        return f'\"{base_url}{s.get_absolute_url()}\"'\n\n    def _format_url(self, s):\n        \"\"\"\n        The `url` format returns the snippet URL,\n        no quotes, but a linebreak at the end.\n        \"\"\"\n        base_url = config.get_base_url(request=self.request)\n        return f\"{base_url}{s.get_absolute_url()}\\n\"\n\n    def _format_json(self, s):\n        \"\"\"\n        The `json` format export.\n        \"\"\"\n        base_url = config.get_base_url(request=self.request)\n        return json.dumps(\n            {\n                \"url\": f\"{base_url}{s.get_absolute_url()}\",\n                \"content\": s.content,\n                \"lexer\": s.lexer,\n            }\n        )\n\n    def post(self, request, *args, **kwargs):\n        content = request.POST.get(\"content\", \"\")\n        lexer = request.POST.get(\"lexer\", highlight.LEXER_DEFAULT).strip()\n        filename = request.POST.get(\"filename\", \"\").strip()\n        expires = request.POST.get(\"expires\", \"\").strip()\n        response_format = request.POST.get(\"format\", \"default\").strip()\n\n        if not content.strip():\n            return HttpResponseBadRequest(\"No content given\")\n\n        # We need at least a lexer or a filename\n        if not lexer and not filename:\n            return HttpResponseBadRequest(\n                \"No lexer or filename given. Unable to \"\n                \"determine a highlight. Valid lexers are: %s\"\n                % \", \".join(highlight.LEXER_KEYS)\n            )\n\n        # A lexer is given, check if its valid at all\n        if lexer and lexer not in highlight.LEXER_KEYS:\n            return HttpResponseBadRequest(\n                'Invalid lexer \"%s\" given. Valid lexers are: %s'\n                % (lexer, \", \".join(highlight.LEXER_KEYS))\n            )\n\n        # No lexer is given, but we have a filename, try to get the lexer\n        #  out of it. In case Pygments cannot determine the lexer of the\n        # filename, we fallback to 'plain' code.\n        if not lexer and filename:\n            try:\n                lexer_cls = get_lexer_for_filename(filename)\n                lexer = lexer_cls.aliases[0]\n            except (ClassNotFound, IndexError):\n                lexer = config.PLAIN_CODE_SYMBOL\n\n        if expires:\n            expire_options = [str(i) for i in dict(config.EXPIRE_CHOICES)]\n            if expires not in expire_options:\n                return HttpResponseBadRequest(\n                    'Invalid expire choice \"{}\" given. Valid values are: {}'.format(\n                        expires, \", \".join(expire_options)\n                    )\n                )\n            expires, expire_type = get_expire_values(expires)\n        else:\n            expires = datetime.datetime.now() + datetime.timedelta(seconds=60 * 60 * 24)\n            expire_type = Snippet.EXPIRE_TIME\n\n        snippet = Snippet.objects.create(\n            content=content,\n            lexer=lexer,\n            expires=expires,\n            expire_type=expire_type,\n        )\n\n        # Custom formatter for the API response\n        formatter = getattr(self, f\"_format_{response_format}\", None)\n        if callable(formatter):\n            return HttpResponse(formatter(snippet))\n\n        # Otherwise use the default one.\n        return HttpResponse(self._format_default(snippet))\n\n\n# -----------------------------------------------------------------------------\n# Custom 404 and 500 views. Its easier to integrate this as a app if we\n# handle them here.\n# -----------------------------------------------------------------------------\n\n\ndef handler404(request, exception=None, template_name=\"dpaste/404.html\"):\n    context = {}\n    context.update(config.extra_template_context)\n    response = render(request, template_name, context, status=404)\n    patch_cache_control(response, max_age=config.CACHE_TIMEOUT)\n    return response\n\n\ndef handler500(request, template_name=\"dpaste/500.html\"):\n    context = {}\n    context.update(config.extra_template_context)\n    response = render(request, template_name, context, status=500)\n    add_never_cache_headers(response)\n    return response\n"], "fixing_code": ["import datetime\nimport difflib\nimport json\n\nfrom django.apps import apps\nfrom django.http import (\n    Http404,\n    HttpResponse,\n    HttpResponseBadRequest,\n    HttpResponseForbidden,\n    HttpResponseRedirect,\n)\nfrom django.shortcuts import get_object_or_404, render\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.html import escape\nfrom django.utils.cache import add_never_cache_headers, patch_cache_control\nfrom django.utils.translation import gettext\nfrom django.views.generic import FormView\nfrom django.views.generic.base import TemplateView, View\nfrom django.views.generic.detail import DetailView\nfrom pygments.lexers import get_lexer_for_filename\nfrom pygments.util import ClassNotFound\n\nfrom dpaste import highlight\nfrom dpaste.forms import SnippetForm, get_expire_values\nfrom dpaste.highlight import PygmentsHighlighter\nfrom dpaste.models import Snippet\n\nconfig = apps.get_app_config(\"dpaste\")\n\n\n# -----------------------------------------------------------------------------\n# Snippet Handling\n# -----------------------------------------------------------------------------\n\n\nclass SnippetView(FormView):\n    \"\"\"\n    Create a new snippet.\n    \"\"\"\n\n    form_class = SnippetForm\n    template_name = \"dpaste/new.html\"\n\n    def get(self, request, *args, **kwargs):\n        response = super().get(request, *args, **kwargs)\n        return response\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"request\": self.request})\n        return kwargs\n\n    def form_valid(self, form):\n        snippet = form.save()\n        return HttpResponseRedirect(snippet.get_absolute_url())\n\n    def get_context_data(self, **kwargs):\n        ctx = super().get_context_data(**kwargs)\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\nclass SnippetDetailView(DetailView, FormView):\n    \"\"\"\n    Details list view of a snippet. Handles the actual view, reply and\n    tree/diff view.\n    \"\"\"\n\n    form_class = SnippetForm\n    queryset = Snippet.objects.all()\n    template_name = \"dpaste/details.html\"\n    slug_url_kwarg = \"snippet_id\"\n    slug_field = \"secret_id\"\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Delete a snippet. This is allowed by anybody as long as he knows the\n        snippet id. I got too many manual requests to do this, mostly for legal\n        reasons and the chance to abuse this is not given anyway, since snippets\n        always expire.\n        \"\"\"\n        if \"delete\" in self.request.POST:\n            snippet = get_object_or_404(Snippet, secret_id=self.kwargs[\"snippet_id\"])\n            snippet.delete()\n\n            # Append `#` so #delete goes away in Firefox\n            url = \"{0}#\".format(reverse(\"snippet_new\"))\n            return HttpResponseRedirect(url)\n\n        return super().post(request, *args, **kwargs)\n\n    def get(self, request, *args, **kwargs):\n        snippet = self.get_object()\n\n        # One-Time snippet get deleted if the view count matches our limit\n        if (\n            snippet.expire_type == Snippet.EXPIRE_TIME\n            and snippet.expires < timezone.now()\n        ) or (\n            snippet.expire_type == Snippet.EXPIRE_ONETIME\n            and snippet.view_count >= config.ONETIME_LIMIT\n        ):\n            snippet.delete()\n            raise Http404()\n\n        # Increase the view count of the snippet\n        snippet.view_count += 1\n        snippet.save(update_fields=[\"view_count\"])\n\n        return super().get(request, *args, **kwargs)\n\n    def get_initial(self):\n        snippet = self.get_object()\n        return {\n            \"content\": snippet.content,\n            \"lexer\": snippet.lexer,\n            \"rtl\": snippet.rtl,\n        }\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        kwargs.update({\"request\": self.request})\n        return kwargs\n\n    def form_valid(self, form):\n        snippet = form.save(parent=self.get_object())\n        return HttpResponseRedirect(snippet.get_absolute_url())\n\n    def get_snippet_diff(self):\n        snippet = self.get_object()\n\n        if not snippet.parent_id:\n            return None\n\n        if snippet.content == snippet.parent.content:\n            return None\n\n        d = difflib.unified_diff(\n            snippet.parent.content.splitlines(),\n            snippet.content.splitlines(),\n            gettext(\"Previous Snippet\"),\n            gettext(\"Current Snippet\"),\n            n=1,\n        )\n        diff_code = \"\\n\".join(d).strip()\n        highlighted = PygmentsHighlighter().render(diff_code, \"diff\")\n\n        # Remove blank lines\n        return highlighted\n\n    def get_context_data(self, **kwargs):\n        self.object = self.get_object()\n\n        ctx = super().get_context_data(**kwargs)\n        ctx.update(\n            {\n                \"wordwrap\": self.object.lexer in highlight.LEXER_WORDWRAP,\n                \"diff\": self.get_snippet_diff(),\n                \"raw_mode\": config.RAW_MODE_ENABLED,\n            }\n        )\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\nclass SnippetRawView(SnippetDetailView):\n    \"\"\"\n    Display the raw content of a snippet\n    \"\"\"\n\n    template_name = \"dpaste/raw.html\"\n\n    def dispatch(self, request, *args, **kwargs):\n        if not config.RAW_MODE_ENABLED:\n            return HttpResponseForbidden(\n                gettext(\"This dpaste installation has Raw view mode disabled.\")\n            )\n        return super().dispatch(request, *args, **kwargs)\n\n    def render_plain_text(self, context, **response_kwargs):\n        snippet = self.get_object()\n        response = HttpResponse(snippet.content)\n        response[\"Content-Type\"] = \"text/plain;charset=UTF-8\"\n        response[\"X-Content-Type-Options\"] = \"nosniff\"\n        return response\n\n    def render_to_response(self, context, **response_kwargs):\n        if config.RAW_MODE_PLAIN_TEXT:\n            return self.render_plain_text(config, **response_kwargs)\n        return super().render_to_response(context, **response_kwargs)\n\n    def get_context_data(self, **kwargs):\n        ctx = super().get_context_data(**kwargs)\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\nclass SnippetHistory(TemplateView):\n    \"\"\"\n    Display the last `n` snippets created by this user (and saved in his\n    session).\n    \"\"\"\n\n    template_name = \"dpaste/history.html\"\n\n    def get_user_snippets(self):\n        snippet_id_list = self.request.session.get(\"snippet_list\", [])\n        return Snippet.objects.filter(pk__in=snippet_id_list)\n\n    def get(self, request, *args, **kwargs):\n        response = super().get(request, *args, **kwargs)\n        add_never_cache_headers(response)\n        return response\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Delete all user snippets at once.\n        \"\"\"\n        if \"delete\" in self.request.POST:\n            self.get_user_snippets().delete()\n\n        # Append `#` so #delete goes away in Firefox\n        url = \"{0}#\".format(reverse(\"snippet_history\"))\n        return HttpResponseRedirect(url)\n\n    def get_context_data(self, **kwargs):\n        ctx = super().get_context_data(**kwargs)\n        ctx.update({\"snippet_list\": self.get_user_snippets()})\n        ctx.update(config.extra_template_context)\n        return ctx\n\n\n# -----------------------------------------------------------------------------\n# API Handling\n# -----------------------------------------------------------------------------\n\n\nclass APIView(View):\n    \"\"\"\n    API View\n    \"\"\"\n\n    def _format_default(self, s):\n        \"\"\"\n        The default response is the snippet URL wrapped in quotes.\n        \"\"\"\n        base_url = config.get_base_url(request=self.request)\n        return f'\"{base_url}{s.get_absolute_url()}\"'\n\n    def _format_url(self, s):\n        \"\"\"\n        The `url` format returns the snippet URL,\n        no quotes, but a linebreak at the end.\n        \"\"\"\n        base_url = config.get_base_url(request=self.request)\n        return f\"{base_url}{s.get_absolute_url()}\\n\"\n\n    def _format_json(self, s):\n        \"\"\"\n        The `json` format export.\n        \"\"\"\n        base_url = config.get_base_url(request=self.request)\n        return json.dumps(\n            {\n                \"url\": f\"{base_url}{s.get_absolute_url()}\",\n                \"content\": s.content,\n                \"lexer\": s.lexer,\n            }\n        )\n\n    def post(self, request, *args, **kwargs):\n        content = request.POST.get(\"content\", \"\")\n        lexer = request.POST.get(\"lexer\", highlight.LEXER_DEFAULT).strip()\n        filename = request.POST.get(\"filename\", \"\").strip()\n        expires = request.POST.get(\"expires\", \"\").strip()\n        response_format = request.POST.get(\"format\", \"default\").strip()\n\n        if not content.strip():\n            return HttpResponseBadRequest(\"No content given\")\n\n        # We need at least a lexer or a filename\n        if not lexer and not filename:\n            return HttpResponseBadRequest(\n                \"No lexer or filename given. Unable to \"\n                \"determine a highlight. Valid lexers are: %s\"\n                % \", \".join(highlight.LEXER_KEYS)\n            )\n\n        # A lexer is given, check if its valid at all\n        if lexer and lexer not in highlight.LEXER_KEYS:\n            return HttpResponseBadRequest(\n                f'Invalid lexer choice \"{escape(lexer)}\" given. Valid lexer values are: {\", \".join(highlight.LEXER_KEYS)}'\n            )\n\n        # No lexer is given, but we have a filename, try to get the lexer\n        #  out of it. In case Pygments cannot determine the lexer of the\n        # filename, we fallback to 'plain' code.\n        if not lexer and filename:\n            try:\n                lexer_cls = get_lexer_for_filename(filename)\n                lexer = lexer_cls.aliases[0]\n            except (ClassNotFound, IndexError):\n                lexer = config.PLAIN_CODE_SYMBOL\n\n        if expires:\n            expire_options = [str(i) for i in dict(config.EXPIRE_CHOICES)]\n            if expires not in expire_options:\n                return HttpResponseBadRequest(\n                    f'Invalid expire choice \"{escape(expires)}\" given. Valid expire values are: {\", \".join(expire_options)}'\n                )\n            expires, expire_type = get_expire_values(expires)\n        else:\n            expires = datetime.datetime.now() + datetime.timedelta(seconds=60 * 60 * 24)\n            expire_type = Snippet.EXPIRE_TIME\n\n        snippet = Snippet.objects.create(\n            content=content,\n            lexer=lexer,\n            expires=expires,\n            expire_type=expire_type,\n        )\n\n        # Custom formatter for the API response\n        formatter = getattr(self, f\"_format_{response_format}\", None)\n        if callable(formatter):\n            return HttpResponse(formatter(snippet))\n\n        # Otherwise use the default one.\n        return HttpResponse(self._format_default(snippet))\n\n\n# -----------------------------------------------------------------------------\n# Custom 404 and 500 views. Its easier to integrate this as a app if we\n# handle them here.\n# -----------------------------------------------------------------------------\n\n\ndef handler404(request, exception=None, template_name=\"dpaste/404.html\"):\n    context = {}\n    context.update(config.extra_template_context)\n    response = render(request, template_name, context, status=404)\n    patch_cache_control(response, max_age=config.CACHE_TIMEOUT)\n    return response\n\n\ndef handler500(request, template_name=\"dpaste/500.html\"):\n    context = {}\n    context.update(config.extra_template_context)\n    response = render(request, template_name, context, status=500)\n    add_never_cache_headers(response)\n    return response"], "filenames": ["dpaste/views.py"], "buggy_code_start_loc": [15], "buggy_code_end_loc": [356], "fixing_code_start_loc": [16], "fixing_code_end_loc": [354], "type": "CWE-79", "message": "dpaste is an open source pastebin application written in Python using the Django framework. A security vulnerability has been identified in the expires parameter of the dpaste API, allowing for a POST Reflected XSS attack. This vulnerability can be exploited by an attacker to execute arbitrary JavaScript code in the context of a user's browser, potentially leading to unauthorized access, data theft, or other malicious activities. Users are strongly advised to upgrade to dpaste release v3.8 or later versions, as dpaste versions older than v3.8 are susceptible to the identified security vulnerability. No known workarounds have been identified, and applying the patch is the most effective way to remediate the vulnerability.", "other": {"cve": {"id": "CVE-2023-49277", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-01T21:15:08.857", "lastModified": "2023-12-06T20:55:31.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "dpaste is an open source pastebin application written in Python using the Django framework. A security vulnerability has been identified in the expires parameter of the dpaste API, allowing for a POST Reflected XSS attack. This vulnerability can be exploited by an attacker to execute arbitrary JavaScript code in the context of a user's browser, potentially leading to unauthorized access, data theft, or other malicious activities. Users are strongly advised to upgrade to dpaste release v3.8 or later versions, as dpaste versions older than v3.8 are susceptible to the identified security vulnerability. No known workarounds have been identified, and applying the patch is the most effective way to remediate the vulnerability."}, {"lang": "es", "value": "dpaste es una aplicaci\u00f3n de Pastebin de c\u00f3digo abierto escrita en Python utilizando el framework Django. Se ha identificado una vulnerabilidad de seguridad en el par\u00e1metro de caducidad de la API dpaste, lo que permite un ataque POST Reflected XSS. Un atacante puede aprovechar esta vulnerabilidad para ejecutar c\u00f3digo JavaScript arbitrario en el contexto del navegador de un usuario, lo que podr\u00eda provocar acceso no autorizado, robo de datos u otras actividades maliciosas. Se recomienda encarecidamente a los usuarios que actualicen a la versi\u00f3n v3.8 de dpaste o versiones posteriores, ya que las versiones de dpaste anteriores a la v3.8 son susceptibles a vulnerabilidad de seguridad identificada. No se han identificado workarounds conocidos y aplicar el parche es la forma m\u00e1s eficaz de remediar la vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:darrennathanael:dpaste:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.8", "matchCriteriaId": "52C6FF15-547C-4FAF-B1EC-4E0C090D9A69"}]}]}], "references": [{"url": "https://github.com/DarrenOfficial/dpaste/commit/44a666a79b3b29ed4f340600bfcf55113bfb7086", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/DarrenOfficial/dpaste/security/advisories/GHSA-r8j9-5cj7-cv39", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/DarrenOfficial/dpaste/commit/44a666a79b3b29ed4f340600bfcf55113bfb7086"}}