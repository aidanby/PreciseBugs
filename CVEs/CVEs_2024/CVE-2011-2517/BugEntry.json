{"buggy_code": ["/*\n * This is the new netlink-based wireless configuration interface.\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n */\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include <net/sock.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"reg.h\"\n\nstatic int nl80211_pre_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info);\nstatic void nl80211_post_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info);\n\n/* the netlink family */\nstatic struct genl_family nl80211_fam = {\n\t.id = GENL_ID_GENERATE,\t/* don't bother with a hardcoded ID */\n\t.name = \"nl80211\",\t/* have users key off the name instead */\n\t.hdrsize = 0,\t\t/* no private header */\n\t.version = 1,\t\t/* no particular meaning now */\n\t.maxattr = NL80211_ATTR_MAX,\n\t.netnsok = true,\n\t.pre_doit = nl80211_pre_doit,\n\t.post_doit = nl80211_post_doit,\n};\n\n/* internal helper: get rdev and dev */\nstatic int get_rdev_dev_by_info_ifindex(struct genl_info *info,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct net_device **dev)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tint ifindex;\n\n\tif (!attrs[NL80211_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\t*dev = dev_get_by_index(genl_info_net(info), ifindex);\n\tif (!*dev)\n\t\treturn -ENODEV;\n\n\t*rdev = cfg80211_get_dev_from_ifindex(genl_info_net(info), ifindex);\n\tif (IS_ERR(*rdev)) {\n\t\tdev_put(*dev);\n\t\treturn PTR_ERR(*rdev);\n\t}\n\n\treturn 0;\n}\n\n/* policy for the attributes */\nstatic const struct nla_policy nl80211_policy[NL80211_ATTR_MAX+1] = {\n\t[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t      .len = 20-1 },\n\t[NL80211_ATTR_WIPHY_TXQ_PARAMS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WIPHY_FREQ] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_CHANNEL_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RETRY_SHORT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_RETRY_LONG] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_FRAG_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RTS_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_COVERAGE_CLASS] = { .type = NLA_U8 },\n\n\t[NL80211_ATTR_IFTYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL80211_ATTR_MAC] = { .type = NLA_BINARY, .len = ETH_ALEN },\n\t[NL80211_ATTR_PREV_BSSID] = { .type = NLA_BINARY, .len = ETH_ALEN },\n\n\t[NL80211_ATTR_KEY] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_KEY_DATA] = { .type = NLA_BINARY,\n\t\t\t\t    .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_ATTR_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_ATTR_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_ATTR_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_SEQ] = { .type = NLA_BINARY, .len = 8 },\n\t[NL80211_ATTR_KEY_TYPE] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_BEACON_HEAD] = { .type = NLA_BINARY,\n\t\t\t\t       .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_BEACON_TAIL] = { .type = NLA_BINARY,\n\t\t\t\t       .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_STA_AID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t       .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_STA_PLINK_ACTION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MNTR_FLAGS] = { /* NLA_NESTED can't be empty */ },\n\t[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_MESH_ID_LEN },\n\t[NL80211_ATTR_MPATH_NEXT_HOP] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_REG_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_PREAMBLE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_SLOT_TIME] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_BASIC_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t   .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_BSS_HT_OPMODE] = { .type = NLA_U16 },\n\n\t[NL80211_ATTR_MESH_CONFIG] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SUPPORT_MESH_AUTH] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_HT_CAPABILITY] = { .type = NLA_BINARY,\n\t\t\t\t\t .len = NL80211_HT_CAPABILITY_LEN },\n\n\t[NL80211_ATTR_MGMT_SUBTYPE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_IE] = { .type = NLA_BINARY,\n\t\t\t      .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_SCAN_FREQUENCIES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SSIDS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_ATTR_AUTH_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REASON_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FREQ_FIXED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TIMED_OUT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_USE_MFP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_STA_FLAGS2] = {\n\t\t.len = sizeof(struct nl80211_sta_flag_update),\n\t},\n\t[NL80211_ATTR_CONTROL_PORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_ETHERTYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PRIVACY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CIPHER_SUITE_GROUP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_PID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_PMKID] = { .type = NLA_BINARY,\n\t\t\t\t .len = WLAN_PMKID_LEN },\n\t[NL80211_ATTR_DURATION] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_FRAME_MATCH] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_PS_STATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_LOCAL_STATE_CHANGE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_ISOLATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_SETTING] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FRAME_TYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_TX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_RX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MCAST_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_OFFCHANNEL_TX_OK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_PLINK_STATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },\n};\n\n/* policy for the key attributes */\nstatic const struct nla_policy nl80211_key_policy[NL80211_KEY_MAX + 1] = {\n\t[NL80211_KEY_DATA] = { .type = NLA_BINARY, .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_KEY_SEQ] = { .type = NLA_BINARY, .len = 8 },\n\t[NL80211_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_MGMT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_TYPE] = { .type = NLA_U32 },\n\t[NL80211_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n};\n\n/* policy for the key default flags */\nstatic const struct nla_policy\nnl80211_key_default_policy[NUM_NL80211_KEY_DEFAULT_TYPES] = {\n\t[NL80211_KEY_DEFAULT_TYPE_UNICAST] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_TYPE_MULTICAST] = { .type = NLA_FLAG },\n};\n\n/* policy for WoWLAN attributes */\nstatic const struct nla_policy\nnl80211_wowlan_policy[NUM_NL80211_WOWLAN_TRIG] = {\n\t[NL80211_WOWLAN_TRIG_ANY] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_DISCONNECT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_MAGIC_PKT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_PKT_PATTERN] = { .type = NLA_NESTED },\n};\n\n/* ifidx get helper */\nstatic int nl80211_get_ifidx(struct netlink_callback *cb)\n{\n\tint res;\n\n\tres = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t  nl80211_fam.attrbuf, nl80211_fam.maxattr,\n\t\t\t  nl80211_policy);\n\tif (res)\n\t\treturn res;\n\n\tif (!nl80211_fam.attrbuf[NL80211_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tres = nla_get_u32(nl80211_fam.attrbuf[NL80211_ATTR_IFINDEX]);\n\tif (!res)\n\t\treturn -EINVAL;\n\treturn res;\n}\n\nstatic int nl80211_prepare_netdev_dump(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct net_device **dev)\n{\n\tint ifidx = cb->args[0];\n\tint err;\n\n\tif (!ifidx)\n\t\tifidx = nl80211_get_ifidx(cb);\n\tif (ifidx < 0)\n\t\treturn ifidx;\n\n\tcb->args[0] = ifidx;\n\n\trtnl_lock();\n\n\t*dev = __dev_get_by_index(sock_net(skb->sk), ifidx);\n\tif (!*dev) {\n\t\terr = -ENODEV;\n\t\tgoto out_rtnl;\n\t}\n\n\t*rdev = cfg80211_get_dev_from_ifindex(sock_net(skb->sk), ifidx);\n\tif (IS_ERR(*rdev)) {\n\t\terr = PTR_ERR(*rdev);\n\t\tgoto out_rtnl;\n\t}\n\n\treturn 0;\n out_rtnl:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic void nl80211_finish_netdev_dump(struct cfg80211_registered_device *rdev)\n{\n\tcfg80211_unlock_rdev(rdev);\n\trtnl_unlock();\n}\n\n/* IE validation */\nstatic bool is_valid_ie_attr(const struct nlattr *attr)\n{\n\tconst u8 *pos;\n\tint len;\n\n\tif (!attr)\n\t\treturn true;\n\n\tpos = nla_data(attr);\n\tlen = nla_len(attr);\n\n\twhile (len) {\n\t\tu8 elemlen;\n\n\t\tif (len < 2)\n\t\t\treturn false;\n\t\tlen -= 2;\n\n\t\telemlen = pos[1];\n\t\tif (elemlen > len)\n\t\t\treturn false;\n\n\t\tlen -= elemlen;\n\t\tpos += 2 + elemlen;\n\t}\n\n\treturn true;\n}\n\n/* message building helper */\nstatic inline void *nl80211hdr_put(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t   int flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, pid, seq, &nl80211_fam, flags, cmd);\n}\n\nstatic int nl80211_msg_put_channel(struct sk_buff *msg,\n\t\t\t\t   struct ieee80211_channel *chan)\n{\n\tNLA_PUT_U32(msg, NL80211_FREQUENCY_ATTR_FREQ,\n\t\t    chan->center_freq);\n\n\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_DISABLED);\n\tif (chan->flags & IEEE80211_CHAN_PASSIVE_SCAN)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_PASSIVE_SCAN);\n\tif (chan->flags & IEEE80211_CHAN_NO_IBSS)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_NO_IBSS);\n\tif (chan->flags & IEEE80211_CHAN_RADAR)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_RADAR);\n\n\tNLA_PUT_U32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,\n\t\t    DBM_TO_MBM(chan->max_power));\n\n\treturn 0;\n\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\n/* netlink command implementations */\n\nstruct key_parse {\n\tstruct key_params p;\n\tint idx;\n\tint type;\n\tbool def, defmgmt;\n\tbool def_uni, def_multi;\n};\n\nstatic int nl80211_parse_key_new(struct nlattr *key, struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested(tb, NL80211_KEY_MAX, key,\n\t\t\t\t   nl80211_key_policy);\n\tif (err)\n\t\treturn err;\n\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\n\tif (tb[NL80211_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested(kdt,\n\t\t\t\t\t   NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t   tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t\t   nl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key_old(struct genl_info *info, struct key_parse *k)\n{\n\tif (info->attrs[NL80211_ATTR_KEY_DATA]) {\n\t\tk->p.key = nla_data(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t\tk->p.key_len = nla_len(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tk->idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(info->attrs[NL80211_ATTR_KEY_CIPHER]);\n\n\tk->def = !!info->attrs[NL80211_ATTR_KEY_DEFAULT];\n\tk->defmgmt = !!info->attrs[NL80211_ATTR_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested(\n\t\t\t\tkdt, NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\tinfo->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES],\n\t\t\t\tnl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\n\tif (err)\n\t\treturn err;\n\n\tif (k->def && k->defmgmt)\n\t\treturn -EINVAL;\n\n\tif (k->defmgmt) {\n\t\tif (k->def_uni || !k->def_multi)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 5)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_cached_keys *\nnl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct nlattr *keys)\n{\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\tresult->defmgmt = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 4)\n\t\t\tgoto error;\n\t\tif (parse.def) {\n\t\t\tif (def)\n\t\t\t\tgoto error;\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_key_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!wdev->current_bss)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->sme_state != CFG80211_SME_CONNECTED)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start(msg, attr);\n\tint i;\n\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif (ifmodes & 1)\n\t\t\tNLA_PUT_FLAG(msg, i);\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t\t  struct sk_buff *msg)\n{\n\tstruct nlattr *nl_combis;\n\tint i, j;\n\n\tnl_combis = nla_nest_start(msg,\n\t\t\t\tNL80211_ATTR_INTERFACE_COMBINATIONS);\n\tif (!nl_combis)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct nlattr *nl_combi, *nl_limits;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tnl_combi = nla_nest_start(msg, i + 1);\n\t\tif (!nl_combi)\n\t\t\tgoto nla_put_failure;\n\n\t\tnl_limits = nla_nest_start(msg, NL80211_IFACE_COMB_LIMITS);\n\t\tif (!nl_limits)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tstruct nlattr *nl_limit;\n\n\t\t\tnl_limit = nla_nest_start(msg, j + 1);\n\t\t\tif (!nl_limit)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tNLA_PUT_U32(msg, NL80211_IFACE_LIMIT_MAX,\n\t\t\t\t    c->limits[j].max);\n\t\t\tif (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,\n\t\t\t\t\t\tc->limits[j].types))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(msg, nl_limit);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_limits);\n\n\t\tif (c->beacon_int_infra_match)\n\t\t\tNLA_PUT_FLAG(msg,\n\t\t\t\tNL80211_IFACE_COMB_STA_AP_BI_MATCH);\n\t\tNLA_PUT_U32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,\n\t\t\t    c->num_different_channels);\n\t\tNLA_PUT_U32(msg, NL80211_IFACE_COMB_MAXNUM,\n\t\t\t    c->max_interfaces);\n\n\t\tnla_nest_end(msg, nl_combi);\n\t}\n\n\tnla_nest_end(msg, nl_combis);\n\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_send_wiphy(struct sk_buff *msg, u32 pid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *dev)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_bands, *nl_band;\n\tstruct nlattr *nl_freqs, *nl_freq;\n\tstruct nlattr *nl_rates, *nl_rate;\n\tstruct nlattr *nl_cmds;\n\tenum ieee80211_band band;\n\tstruct ieee80211_channel *chan;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes =\n\t\t\t\tdev->wiphy.mgmt_stypes;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_WIPHY);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, dev->wiphy_idx);\n\tNLA_PUT_STRING(msg, NL80211_ATTR_WIPHY_NAME, wiphy_name(&dev->wiphy));\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION,\n\t\t    cfg80211_rdev_list_generation);\n\n\tNLA_PUT_U8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,\n\t\t   dev->wiphy.retry_short);\n\tNLA_PUT_U8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,\n\t\t   dev->wiphy.retry_long);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,\n\t\t    dev->wiphy.frag_threshold);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,\n\t\t    dev->wiphy.rts_threshold);\n\tNLA_PUT_U8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,\n\t\t    dev->wiphy.coverage_class);\n\tNLA_PUT_U8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,\n\t\t   dev->wiphy.max_scan_ssids);\n\tNLA_PUT_U16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,\n\t\t    dev->wiphy.max_scan_ie_len);\n\n\tif (dev->wiphy.flags & WIPHY_FLAG_IBSS_RSN)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_SUPPORT_IBSS_RSN);\n\tif (dev->wiphy.flags & WIPHY_FLAG_MESH_AUTH)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_SUPPORT_MESH_AUTH);\n\n\tNLA_PUT(msg, NL80211_ATTR_CIPHER_SUITES,\n\t\tsizeof(u32) * dev->wiphy.n_cipher_suites,\n\t\tdev->wiphy.cipher_suites);\n\n\tNLA_PUT_U8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,\n\t\t   dev->wiphy.max_num_pmkids);\n\n\tif (dev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,\n\t\t    dev->wiphy.available_antennas_tx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,\n\t\t    dev->wiphy.available_antennas_rx);\n\n\tif ((dev->wiphy.available_antennas_tx ||\n\t     dev->wiphy.available_antennas_rx) && dev->ops->get_antenna) {\n\t\tu32 tx_ant = 0, rx_ant = 0;\n\t\tint res;\n\t\tres = dev->ops->get_antenna(&dev->wiphy, &tx_ant, &rx_ant);\n\t\tif (!res) {\n\t\t\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_TX, tx_ant);\n\t\t\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_RX, rx_ant);\n\t\t}\n\t}\n\n\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,\n\t\t\t\tdev->wiphy.interface_modes))\n\t\tgoto nla_put_failure;\n\n\tnl_bands = nla_nest_start(msg, NL80211_ATTR_WIPHY_BANDS);\n\tif (!nl_bands)\n\t\tgoto nla_put_failure;\n\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tif (!dev->wiphy.bands[band])\n\t\t\tcontinue;\n\n\t\tnl_band = nla_nest_start(msg, band);\n\t\tif (!nl_band)\n\t\t\tgoto nla_put_failure;\n\n\t\t/* add HT info */\n\t\tif (dev->wiphy.bands[band]->ht_cap.ht_supported) {\n\t\t\tNLA_PUT(msg, NL80211_BAND_ATTR_HT_MCS_SET,\n\t\t\t\tsizeof(dev->wiphy.bands[band]->ht_cap.mcs),\n\t\t\t\t&dev->wiphy.bands[band]->ht_cap.mcs);\n\t\t\tNLA_PUT_U16(msg, NL80211_BAND_ATTR_HT_CAPA,\n\t\t\t\tdev->wiphy.bands[band]->ht_cap.cap);\n\t\t\tNLA_PUT_U8(msg, NL80211_BAND_ATTR_HT_AMPDU_FACTOR,\n\t\t\t\tdev->wiphy.bands[band]->ht_cap.ampdu_factor);\n\t\t\tNLA_PUT_U8(msg, NL80211_BAND_ATTR_HT_AMPDU_DENSITY,\n\t\t\t\tdev->wiphy.bands[band]->ht_cap.ampdu_density);\n\t\t}\n\n\t\t/* add frequencies */\n\t\tnl_freqs = nla_nest_start(msg, NL80211_BAND_ATTR_FREQS);\n\t\tif (!nl_freqs)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < dev->wiphy.bands[band]->n_channels; i++) {\n\t\t\tnl_freq = nla_nest_start(msg, i);\n\t\t\tif (!nl_freq)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tchan = &dev->wiphy.bands[band]->channels[i];\n\n\t\t\tif (nl80211_msg_put_channel(msg, chan))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, nl_freq);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_freqs);\n\n\t\t/* add bitrates */\n\t\tnl_rates = nla_nest_start(msg, NL80211_BAND_ATTR_RATES);\n\t\tif (!nl_rates)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < dev->wiphy.bands[band]->n_bitrates; i++) {\n\t\t\tnl_rate = nla_nest_start(msg, i);\n\t\t\tif (!nl_rate)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\trate = &dev->wiphy.bands[band]->bitrates[i];\n\t\t\tNLA_PUT_U32(msg, NL80211_BITRATE_ATTR_RATE,\n\t\t\t\t    rate->bitrate);\n\t\t\tif (rate->flags & IEEE80211_RATE_SHORT_PREAMBLE)\n\t\t\t\tNLA_PUT_FLAG(msg,\n\t\t\t\t\tNL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE);\n\n\t\t\tnla_nest_end(msg, nl_rate);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_rates);\n\n\t\tnla_nest_end(msg, nl_band);\n\t}\n\tnla_nest_end(msg, nl_bands);\n\n\tnl_cmds = nla_nest_start(msg, NL80211_ATTR_SUPPORTED_COMMANDS);\n\tif (!nl_cmds)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n#define CMD(op, n)\t\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\\\n\t\tif (dev->ops->op) {\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\\\n\t\t\tNLA_PUT_U32(msg, i, NL80211_CMD_ ## n);\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(change_virtual_intf, SET_INTERFACE);\n\tCMD(add_key, NEW_KEY);\n\tCMD(add_beacon, NEW_BEACON);\n\tCMD(add_station, NEW_STATION);\n\tCMD(add_mpath, NEW_MPATH);\n\tCMD(update_mesh_config, SET_MESH_CONFIG);\n\tCMD(change_bss, SET_BSS);\n\tCMD(auth, AUTHENTICATE);\n\tCMD(assoc, ASSOCIATE);\n\tCMD(deauth, DEAUTHENTICATE);\n\tCMD(disassoc, DISASSOCIATE);\n\tCMD(join_ibss, JOIN_IBSS);\n\tCMD(join_mesh, JOIN_MESH);\n\tCMD(set_pmksa, SET_PMKSA);\n\tCMD(del_pmksa, DEL_PMKSA);\n\tCMD(flush_pmksa, FLUSH_PMKSA);\n\tCMD(remain_on_channel, REMAIN_ON_CHANNEL);\n\tCMD(set_bitrate_mask, SET_TX_BITRATE_MASK);\n\tCMD(mgmt_tx, FRAME);\n\tCMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);\n\tif (dev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {\n\t\ti++;\n\t\tNLA_PUT_U32(msg, i, NL80211_CMD_SET_WIPHY_NETNS);\n\t}\n\tCMD(set_channel, SET_CHANNEL);\n\tCMD(set_wds_peer, SET_WDS_PEER);\n\tif (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN)\n\t\tCMD(sched_scan_start, START_SCHED_SCAN);\n\n#undef CMD\n\n\tif (dev->ops->connect || dev->ops->auth) {\n\t\ti++;\n\t\tNLA_PUT_U32(msg, i, NL80211_CMD_CONNECT);\n\t}\n\n\tif (dev->ops->disconnect || dev->ops->deauth) {\n\t\ti++;\n\t\tNLA_PUT_U32(msg, i, NL80211_CMD_DISCONNECT);\n\t}\n\n\tnla_nest_end(msg, nl_cmds);\n\n\tif (dev->ops->remain_on_channel)\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,\n\t\t\t    dev->wiphy.max_remain_on_channel_duration);\n\n\t/* for now at least assume all drivers have it */\n\tif (dev->ops->mgmt_tx)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_OFFCHANNEL_TX_OK);\n\n\tif (mgmt_stypes) {\n\t\tu16 stypes;\n\t\tstruct nlattr *nl_ftypes, *nl_ifs;\n\t\tenum nl80211_iftype ift;\n\n\t\tnl_ifs = nla_nest_start(msg, NL80211_ATTR_TX_FRAME_TYPES);\n\t\tif (!nl_ifs)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\t\tnl_ftypes = nla_nest_start(msg, ift);\n\t\t\tif (!nl_ftypes)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ti = 0;\n\t\t\tstypes = mgmt_stypes[ift].tx;\n\t\t\twhile (stypes) {\n\t\t\t\tif (stypes & 1)\n\t\t\t\t\tNLA_PUT_U16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t\t    (i << 4) | IEEE80211_FTYPE_MGMT);\n\t\t\t\tstypes >>= 1;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nl_ftypes);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_ifs);\n\n\t\tnl_ifs = nla_nest_start(msg, NL80211_ATTR_RX_FRAME_TYPES);\n\t\tif (!nl_ifs)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\t\tnl_ftypes = nla_nest_start(msg, ift);\n\t\t\tif (!nl_ftypes)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ti = 0;\n\t\t\tstypes = mgmt_stypes[ift].rx;\n\t\t\twhile (stypes) {\n\t\t\t\tif (stypes & 1)\n\t\t\t\t\tNLA_PUT_U16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t\t    (i << 4) | IEEE80211_FTYPE_MGMT);\n\t\t\t\tstypes >>= 1;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nl_ftypes);\n\t\t}\n\t\tnla_nest_end(msg, nl_ifs);\n\t}\n\n\tif (dev->wiphy.wowlan.flags || dev->wiphy.wowlan.n_patterns) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start(msg,\n\t\t\t\tNL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_ANY)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_ANY);\n\t\tif (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_DISCONNECT)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_DISCONNECT);\n\t\tif (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_MAGIC_PKT)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT);\n\t\tif (dev->wiphy.wowlan.n_patterns) {\n\t\t\tstruct nl80211_wowlan_pattern_support pat = {\n\t\t\t\t.max_patterns = dev->wiphy.wowlan.n_patterns,\n\t\t\t\t.min_pattern_len =\n\t\t\t\t\tdev->wiphy.wowlan.pattern_min_len,\n\t\t\t\t.max_pattern_len =\n\t\t\t\t\tdev->wiphy.wowlan.pattern_max_len,\n\t\t\t};\n\t\t\tNLA_PUT(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t\tsizeof(pat), &pat);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,\n\t\t\t\tdev->wiphy.software_iftypes))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_put_iface_combinations(&dev->wiphy, msg))\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tint start = cb->args[0];\n\tstruct cfg80211_registered_device *dev;\n\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(dev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&dev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_wiphy(skb, NETLINK_CB(cb->skb).pid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       dev) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&cfg80211_mutex);\n\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *dev = info->user_ptr[0];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_wiphy(msg, info->snd_pid, info->snd_seq, 0, dev) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy txq_params_policy[NL80211_TXQ_ATTR_MAX + 1] = {\n\t[NL80211_TXQ_ATTR_QUEUE]\t\t= { .type = NLA_U8 },\n\t[NL80211_TXQ_ATTR_TXOP]\t\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMIN]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMAX]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_AIFS]\t\t\t= { .type = NLA_U8 },\n};\n\nstatic int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tif (!tb[NL80211_TXQ_ATTR_QUEUE] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\n\ttxq_params->queue = nla_get_u8(tb[NL80211_TXQ_ATTR_QUEUE]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\n\treturn 0;\n}\n\nstatic bool nl80211_can_set_dev_channel(struct wireless_dev *wdev)\n{\n\t/*\n\t * You can only set the channel explicitly for AP, mesh\n\t * and WDS type interfaces; all others have their channel\n\t * managed via their respective \"establish a connection\"\n\t * command (connect, join, ...)\n\t *\n\t * Monitors are special as they are normally slaved to\n\t * whatever else is going on, so they behave as though\n\t * you tried setting the wiphy channel itself.\n\t */\n\treturn !wdev ||\n\t\twdev->iftype == NL80211_IFTYPE_AP ||\n\t\twdev->iftype == NL80211_IFTYPE_WDS ||\n\t\twdev->iftype == NL80211_IFTYPE_MESH_POINT ||\n\t\twdev->iftype == NL80211_IFTYPE_MONITOR ||\n\t\twdev->iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nstatic int __nl80211_set_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t struct genl_info *info)\n{\n\tenum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;\n\tu32 freq;\n\tint result;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!nl80211_can_set_dev_channel(wdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tchannel_type = nla_get_u32(info->attrs[\n\t\t\t\t   NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\t\tif (channel_type != NL80211_CHAN_NO_HT &&\n\t\t    channel_type != NL80211_CHAN_HT20 &&\n\t\t    channel_type != NL80211_CHAN_HT40PLUS &&\n\t\t    channel_type != NL80211_CHAN_HT40MINUS)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\n\tmutex_lock(&rdev->devlist_mtx);\n\tif (wdev) {\n\t\twdev_lock(wdev);\n\t\tresult = cfg80211_set_freq(rdev, wdev, freq, channel_type);\n\t\twdev_unlock(wdev);\n\t} else {\n\t\tresult = cfg80211_set_freq(rdev, NULL, freq, channel_type);\n\t}\n\tmutex_unlock(&rdev->devlist_mtx);\n\n\treturn result;\n}\n\nstatic int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\treturn __nl80211_set_channel(rdev, netdev->ieee80211_ptr, info);\n}\n\nstatic int nl80211_set_wds_peer(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *bssid;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!rdev->ops->set_wds_peer)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_WDS)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\treturn rdev->ops->set_wds_peer(wdev->wiphy, dev, bssid);\n}\n\n\nstatic int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *netdev = NULL;\n\tstruct wireless_dev *wdev;\n\tint result = 0, rem_txq_params = 0;\n\tstruct nlattr *nl_txq_params;\n\tu32 changed;\n\tu8 retry_short = 0, retry_long = 0;\n\tu32 frag_threshold = 0, rts_threshold = 0;\n\tu8 coverage_class = 0;\n\n\t/*\n\t * Try to find the wiphy and netdev. Normally this\n\t * function shouldn't need the netdev, but this is\n\t * done for backward compatibility -- previously\n\t * setting the channel was done per wiphy, but now\n\t * it is per netdev. Previous userland like hostapd\n\t * also passed a netdev to set_wiphy, so that it is\n\t * possible to let that go to the right netdev!\n\t */\n\tmutex_lock(&cfg80211_mutex);\n\n\tif (info->attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = dev_get_by_index(genl_info_net(info), ifindex);\n\t\tif (netdev && netdev->ieee80211_ptr) {\n\t\t\trdev = wiphy_to_dev(netdev->ieee80211_ptr->wiphy);\n\t\t\tmutex_lock(&rdev->mtx);\n\t\t} else\n\t\t\tnetdev = NULL;\n\t}\n\n\tif (!netdev) {\n\t\trdev = __cfg80211_rdev_from_info(info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tmutex_unlock(&cfg80211_mutex);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\twdev = NULL;\n\t\tnetdev = NULL;\n\t\tresult = 0;\n\n\t\tmutex_lock(&rdev->mtx);\n\t} else if (netif_running(netdev) &&\n\t\t   nl80211_can_set_dev_channel(netdev->ieee80211_ptr))\n\t\twdev = netdev->ieee80211_ptr;\n\telse\n\t\twdev = NULL;\n\n\t/*\n\t * end workaround code, by now the rdev is available\n\t * and locked, and wdev may or may not be NULL.\n\t */\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_NAME])\n\t\tresult = cfg80211_dev_rename(\n\t\t\trdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));\n\n\tmutex_unlock(&cfg80211_mutex);\n\n\tif (result)\n\t\tgoto bad_res;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {\n\t\tstruct ieee80211_txq_params txq_params;\n\t\tstruct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];\n\n\t\tif (!rdev->ops->set_txq_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\tnla_for_each_nested(nl_txq_params,\n\t\t\t\t    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],\n\t\t\t\t    rem_txq_params) {\n\t\t\tnla_parse(tb, NL80211_TXQ_ATTR_MAX,\n\t\t\t\t  nla_data(nl_txq_params),\n\t\t\t\t  nla_len(nl_txq_params),\n\t\t\t\t  txq_params_policy);\n\t\t\tresult = parse_txq_params(tb, &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto bad_res;\n\n\t\t\tresult = rdev->ops->set_txq_params(&rdev->wiphy,\n\t\t\t\t\t\t\t   &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto bad_res;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tresult = __nl80211_set_channel(rdev, wdev, info);\n\t\tif (result)\n\t\t\tgoto bad_res;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {\n\t\tenum nl80211_tx_power_setting type;\n\t\tint idx, mbm = 0;\n\n\t\tif (!rdev->ops->set_tx_power) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;\n\t\ttype = nla_get_u32(info->attrs[idx]);\n\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&\n\t\t    (type != NL80211_TX_POWER_AUTOMATIC)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\tif (type != NL80211_TX_POWER_AUTOMATIC) {\n\t\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;\n\t\t\tmbm = nla_get_u32(info->attrs[idx]);\n\t\t}\n\n\t\tresult = rdev->ops->set_tx_power(&rdev->wiphy, type, mbm);\n\t\tif (result)\n\t\t\tgoto bad_res;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&\n\t    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {\n\t\tu32 tx_ant, rx_ant;\n\t\tif ((!rdev->wiphy.available_antennas_tx &&\n\t\t     !rdev->wiphy.available_antennas_rx) ||\n\t\t    !rdev->ops->set_antenna) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\ttx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);\n\t\trx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);\n\n\t\t/* reject antenna configurations which don't match the\n\t\t * available antenna masks, except for the \"all\" mask */\n\t\tif ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||\n\t\t    (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx))) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\ttx_ant = tx_ant & rdev->wiphy.available_antennas_tx;\n\t\trx_ant = rx_ant & rdev->wiphy.available_antennas_rx;\n\n\t\tresult = rdev->ops->set_antenna(&rdev->wiphy, tx_ant, rx_ant);\n\t\tif (result)\n\t\t\tgoto bad_res;\n\t}\n\n\tchanged = 0;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {\n\t\tretry_short = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);\n\t\tif (retry_short == 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {\n\t\tretry_long = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);\n\t\tif (retry_long == 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {\n\t\tfrag_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);\n\t\tif (frag_threshold < 256) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\t\tif (frag_threshold != (u32) -1) {\n\t\t\t/*\n\t\t\t * Fragments (apart from the last one) are required to\n\t\t\t * have even length. Make the fragmentation code\n\t\t\t * simpler by stripping LSB should someone try to use\n\t\t\t * odd threshold value.\n\t\t\t */\n\t\t\tfrag_threshold &= ~0x1;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_FRAG_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {\n\t\trts_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);\n\t\tchanged |= WIPHY_PARAM_RTS_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {\n\t\tcoverage_class = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);\n\t\tchanged |= WIPHY_PARAM_COVERAGE_CLASS;\n\t}\n\n\tif (changed) {\n\t\tu8 old_retry_short, old_retry_long;\n\t\tu32 old_frag_threshold, old_rts_threshold;\n\t\tu8 old_coverage_class;\n\n\t\tif (!rdev->ops->set_wiphy_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\told_retry_short = rdev->wiphy.retry_short;\n\t\told_retry_long = rdev->wiphy.retry_long;\n\t\told_frag_threshold = rdev->wiphy.frag_threshold;\n\t\told_rts_threshold = rdev->wiphy.rts_threshold;\n\t\told_coverage_class = rdev->wiphy.coverage_class;\n\n\t\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\t\trdev->wiphy.retry_short = retry_short;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\trdev->wiphy.retry_long = retry_long;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\trdev->wiphy.frag_threshold = frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\trdev->wiphy.rts_threshold = rts_threshold;\n\t\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\t\trdev->wiphy.coverage_class = coverage_class;\n\n\t\tresult = rdev->ops->set_wiphy_params(&rdev->wiphy, changed);\n\t\tif (result) {\n\t\t\trdev->wiphy.retry_short = old_retry_short;\n\t\t\trdev->wiphy.retry_long = old_retry_long;\n\t\t\trdev->wiphy.frag_threshold = old_frag_threshold;\n\t\t\trdev->wiphy.rts_threshold = old_rts_threshold;\n\t\t\trdev->wiphy.coverage_class = old_coverage_class;\n\t\t}\n\t}\n\n bad_res:\n\tmutex_unlock(&rdev->mtx);\n\tif (netdev)\n\t\tdev_put(netdev);\n\treturn result;\n}\n\n\nstatic int nl80211_send_iface(struct sk_buff *msg, u32 pid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *rdev,\n\t\t\t      struct net_device *dev)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_INTERFACE);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, dev->name);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, dev->ieee80211_ptr->iftype);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION,\n\t\t    rdev->devlist_generation ^\n\t\t\t(cfg80211_rdev_list_generation << 2));\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif_idx = 0;\n\n\t\tmutex_lock(&rdev->devlist_mtx);\n\t\tlist_for_each_entry(wdev, &rdev->netdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).pid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev->netdev) < 0) {\n\t\t\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\t\tmutex_unlock(&rdev->devlist_mtx);\n\n\t\twp_idx++;\n\t}\n out:\n\tmutex_unlock(&cfg80211_mutex);\n\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *dev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_iface(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t       dev, netdev) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {\n\t[NL80211_MNTR_FLAG_FCSFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_PLCPFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },\n};\n\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\n\tstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\n\tint flag;\n\n\t*mntrflags = 0;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested(flags, NL80211_MNTR_FLAG_MAX,\n\t\t\t     nla, mntr_flags_policy))\n\t\treturn -EINVAL;\n\n\tfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\t*mntrflags |= (1<<flag);\n\n\treturn 0;\n}\n\nstatic int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu32 _flags, *flags = NULL;\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t\tif (ntype > NL80211_IFTYPE_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MNTR_FLAGS]) {\n\t\tif (ntype != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\t\terr = parse_monitor_flags(info->attrs[NL80211_ATTR_MNTR_FLAGS],\n\t\t\t\t\t  &_flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = &_flags;\n\t\tchange = true;\n\t}\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, flags, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\treturn err;\n}\n\nstatic int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tstruct net_device *dev;\n\tint err;\n\tenum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;\n\tu32 flags;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\ttype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (type > NL80211_IFTYPE_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->add_virtual_intf ||\n\t    !(rdev->wiphy.interface_modes & (1 << type)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\terr = nl80211_valid_4addr(rdev, NULL, params.use_4addr, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = parse_monitor_flags(type == NL80211_IFTYPE_MONITOR ?\n\t\t\t\t  info->attrs[NL80211_ATTR_MNTR_FLAGS] : NULL,\n\t\t\t\t  &flags);\n\tdev = rdev->ops->add_virtual_intf(&rdev->wiphy,\n\t\tnla_data(info->attrs[NL80211_ATTR_IFNAME]),\n\t\ttype, err ? NULL : &flags, &params);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tif (type == NL80211_IFTYPE_MESH_POINT &&\n\t    info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->del_virtual_intf(&rdev->wiphy, dev);\n}\n\nstruct get_key_cookie {\n\tstruct sk_buff *msg;\n\tint error;\n\tint idx;\n};\n\nstatic void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\n\tif (params->key)\n\t\tNLA_PUT(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t\tparams->key_len, params->key);\n\n\tif (params->seq)\n\t\tNLA_PUT(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t\tparams->seq_len, params->seq);\n\n\tif (params->cipher)\n\t\tNLA_PUT_U32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t    params->cipher);\n\n\tkey = nla_nest_start(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\n\tif (params->key)\n\t\tNLA_PUT(cookie->msg, NL80211_KEY_DATA,\n\t\t\tparams->key_len, params->key);\n\n\tif (params->seq)\n\t\tNLA_PUT(cookie->msg, NL80211_KEY_SEQ,\n\t\t\tparams->seq_len, params->seq);\n\n\tif (params->cipher)\n\t\tNLA_PUT_U32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t    params->cipher);\n\n\tNLA_PUT_U8(cookie->msg, NL80211_ATTR_KEY_IDX, cookie->idx);\n\n\tnla_nest_end(cookie->msg, key);\n\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}\n\nstatic int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 key_idx = 0;\n\tconst u8 *mac_addr = NULL;\n\tbool pairwise;\n\tstruct get_key_cookie cookie = {\n\t\t.error = 0,\n\t};\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tkey_idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (key_idx > 5)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tpairwise = !!mac_addr;\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tu32 kt = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\t\tif (kt >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t\tif (kt != NL80211_KEYTYPE_GROUP &&\n\t\t    kt != NL80211_KEYTYPE_PAIRWISE)\n\t\t\treturn -EINVAL;\n\t\tpairwise = kt == NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tif (!rdev->ops->get_key)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_NEW_KEY);\n\tif (IS_ERR(hdr))\n\t\treturn PTR_ERR(hdr);\n\n\tcookie.msg = msg;\n\tcookie.idx = key_idx;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT_U8(msg, NL80211_ATTR_KEY_IDX, key_idx);\n\tif (mac_addr)\n\t\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);\n\n\tif (pairwise && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -ENOENT;\n\n\terr = rdev->ops->get_key(&rdev->wiphy, dev, key_idx, pairwise,\n\t\t\t\t mac_addr, &cookie, get_key_callback);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (cookie.error)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct key_parse key;\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx < 0)\n\t\treturn -EINVAL;\n\n\t/* only support setting default key */\n\tif (!key.def && !key.defmgmt)\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\tif (key.def) {\n\t\tif (!rdev->ops->set_default_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev->ops->set_default_key(&rdev->wiphy, dev, key.idx,\n\t\t\t\t\t\t key.def_uni, key.def_multi);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_key = key.idx;\n#endif\n\t} else {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_mgmt_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev->ops->set_default_mgmt_key(&rdev->wiphy,\n\t\t\t\t\t\t      dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_mgmt_key = key.idx;\n#endif\n\t}\n\n out:\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_new_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct key_parse key;\n\tconst u8 *mac_addr = NULL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (!key.p.key)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->add_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cfg80211_validate_key_settings(rdev, &key.p, key.idx,\n\t\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t   mac_addr))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!err)\n\t\terr = rdev->ops->add_key(&rdev->wiphy, dev, key.idx,\n\t\t\t\t\t key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t mac_addr, &key.p);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\tstruct key_parse key;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\n\tif (key.type == NL80211_KEYTYPE_PAIRWISE && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\terr = -ENOENT;\n\n\tif (!err)\n\t\terr = rdev->ops->del_key(&rdev->wiphy, dev, key.idx,\n\t\t\t\t\t key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t mac_addr);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!err) {\n\t\tif (key.idx == dev->ieee80211_ptr->wext.default_key)\n\t\t\tdev->ieee80211_ptr->wext.default_key = -1;\n\t\telse if (key.idx == dev->ieee80211_ptr->wext.default_mgmt_key)\n\t\t\tdev->ieee80211_ptr->wext.default_mgmt_key = -1;\n\t}\n#endif\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_addset_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n        int (*call)(struct wiphy *wiphy, struct net_device *dev,\n\t\t    struct beacon_parameters *info);\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct beacon_parameters params;\n\tint haveinfo = 0, err;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_BEACON_TAIL]))\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_NEW_BEACON:\n\t\t/* these are required for NEW_BEACON */\n\t\tif (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||\n\t\t    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||\n\t\t    !info->attrs[NL80211_ATTR_BEACON_HEAD])\n\t\t\treturn -EINVAL;\n\n\t\tparams.interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\t\tparams.dtim_period =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\n\t\terr = cfg80211_validate_beacon_int(rdev, params.interval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcall = rdev->ops->add_beacon;\n\t\tbreak;\n\tcase NL80211_CMD_SET_BEACON:\n\t\tcall = rdev->ops->set_beacon;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!call)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_HEAD]) {\n\t\tparams.head = nla_data(info->attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tparams.head_len =\n\t\t    nla_len(info->attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\thaveinfo = 1;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BEACON_TAIL]) {\n\t\tparams.tail = nla_data(info->attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\tparams.tail_len =\n\t\t    nla_len(info->attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\thaveinfo = 1;\n\t}\n\n\tif (!haveinfo)\n\t\treturn -EINVAL;\n\n\terr = call(&rdev->wiphy, dev, &params);\n\tif (!err && params.interval)\n\t\twdev->beacon_interval = params.interval;\n\treturn err;\n}\n\nstatic int nl80211_del_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tif (!rdev->ops->del_beacon)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev->ops->del_beacon(&rdev->wiphy, dev);\n\tif (!err)\n\t\twdev->beacon_interval = 0;\n\treturn err;\n}\n\nstatic const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {\n\t[NL80211_STA_FLAG_AUTHORIZED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_SHORT_PREAMBLE] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_WME] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_MFP] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_AUTHENTICATED] = { .type = NLA_FLAG },\n};\n\nstatic int parse_station_flags(struct genl_info *info,\n\t\t\t       struct station_parameters *params)\n{\n\tstruct nlattr *flags[NL80211_STA_FLAG_MAX + 1];\n\tstruct nlattr *nla;\n\tint flag;\n\n\t/*\n\t * Try parsing the new attribute first so userspace\n\t * can specify both for older kernels.\n\t */\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS2];\n\tif (nla) {\n\t\tstruct nl80211_sta_flag_update *sta_flags;\n\n\t\tsta_flags = nla_data(nla);\n\t\tparams->sta_flags_mask = sta_flags->mask;\n\t\tparams->sta_flags_set = sta_flags->set;\n\t\tif ((params->sta_flags_mask |\n\t\t     params->sta_flags_set) & BIT(__NL80211_STA_FLAG_INVALID))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* if present, parse the old attribute */\n\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS];\n\tif (!nla)\n\t\treturn 0;\n\n\tif (nla_parse_nested(flags, NL80211_STA_FLAG_MAX,\n\t\t\t     nla, sta_flags_policy))\n\t\treturn -EINVAL;\n\n\tparams->sta_flags_mask = (1 << __NL80211_STA_FLAG_AFTER_LAST) - 1;\n\tparams->sta_flags_mask &= ~1;\n\n\tfor (flag = 1; flag <= NL80211_STA_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\tparams->sta_flags_set |= (1<<flag);\n\n\treturn 0;\n}\n\nstatic bool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info,\n\t\t\t\t int attr)\n{\n\tstruct nlattr *rate;\n\tu16 bitrate;\n\n\trate = nla_nest_start(msg, attr);\n\tif (!rate)\n\t\tgoto nla_put_failure;\n\n\t/* cfg80211_calculate_bitrate will return 0 for mcs >= 32 */\n\tbitrate = cfg80211_calculate_bitrate(info);\n\tif (bitrate > 0)\n\t\tNLA_PUT_U16(msg, NL80211_RATE_INFO_BITRATE, bitrate);\n\n\tif (info->flags & RATE_INFO_FLAGS_MCS)\n\t\tNLA_PUT_U8(msg, NL80211_RATE_INFO_MCS, info->mcs);\n\tif (info->flags & RATE_INFO_FLAGS_40_MHZ_WIDTH)\n\t\tNLA_PUT_FLAG(msg, NL80211_RATE_INFO_40_MHZ_WIDTH);\n\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\tNLA_PUT_FLAG(msg, NL80211_RATE_INFO_SHORT_GI);\n\n\tnla_nest_end(msg, rate);\n\treturn true;\n\nnla_put_failure:\n\treturn false;\n}\n\nstatic int nl80211_send_station(struct sk_buff *msg, u32 pid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tconst u8 *mac_addr, struct station_info *sinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *sinfoattr, *bss_param;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_STATION);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION, sinfo->generation);\n\n\tsinfoattr = nla_nest_start(msg, NL80211_ATTR_STA_INFO);\n\tif (!sinfoattr)\n\t\tgoto nla_put_failure;\n\tif (sinfo->filled & STATION_INFO_CONNECTED_TIME)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_CONNECTED_TIME,\n\t\t\t    sinfo->connected_time);\n\tif (sinfo->filled & STATION_INFO_INACTIVE_TIME)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_INACTIVE_TIME,\n\t\t\t    sinfo->inactive_time);\n\tif (sinfo->filled & STATION_INFO_RX_BYTES)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_RX_BYTES,\n\t\t\t    sinfo->rx_bytes);\n\tif (sinfo->filled & STATION_INFO_TX_BYTES)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_BYTES,\n\t\t\t    sinfo->tx_bytes);\n\tif (sinfo->filled & STATION_INFO_LLID)\n\t\tNLA_PUT_U16(msg, NL80211_STA_INFO_LLID,\n\t\t\t    sinfo->llid);\n\tif (sinfo->filled & STATION_INFO_PLID)\n\t\tNLA_PUT_U16(msg, NL80211_STA_INFO_PLID,\n\t\t\t    sinfo->plid);\n\tif (sinfo->filled & STATION_INFO_PLINK_STATE)\n\t\tNLA_PUT_U8(msg, NL80211_STA_INFO_PLINK_STATE,\n\t\t\t    sinfo->plink_state);\n\tif (sinfo->filled & STATION_INFO_SIGNAL)\n\t\tNLA_PUT_U8(msg, NL80211_STA_INFO_SIGNAL,\n\t\t\t   sinfo->signal);\n\tif (sinfo->filled & STATION_INFO_SIGNAL_AVG)\n\t\tNLA_PUT_U8(msg, NL80211_STA_INFO_SIGNAL_AVG,\n\t\t\t   sinfo->signal_avg);\n\tif (sinfo->filled & STATION_INFO_TX_BITRATE) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->txrate,\n\t\t\t\t\t  NL80211_STA_INFO_TX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & STATION_INFO_RX_BITRATE) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->rxrate,\n\t\t\t\t\t  NL80211_STA_INFO_RX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & STATION_INFO_RX_PACKETS)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_RX_PACKETS,\n\t\t\t    sinfo->rx_packets);\n\tif (sinfo->filled & STATION_INFO_TX_PACKETS)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_PACKETS,\n\t\t\t    sinfo->tx_packets);\n\tif (sinfo->filled & STATION_INFO_TX_RETRIES)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_RETRIES,\n\t\t\t    sinfo->tx_retries);\n\tif (sinfo->filled & STATION_INFO_TX_FAILED)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_FAILED,\n\t\t\t    sinfo->tx_failed);\n\tif (sinfo->filled & STATION_INFO_BSS_PARAM) {\n\t\tbss_param = nla_nest_start(msg, NL80211_STA_INFO_BSS_PARAM);\n\t\tif (!bss_param)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (sinfo->bss_param.flags & BSS_PARAM_FLAGS_CTS_PROT)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_STA_BSS_PARAM_CTS_PROT);\n\t\tif (sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_PREAMBLE)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_STA_BSS_PARAM_SHORT_PREAMBLE);\n\t\tif (sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_SLOT_TIME)\n\t\t\tNLA_PUT_FLAG(msg,\n\t\t\t\t     NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME);\n\t\tNLA_PUT_U8(msg, NL80211_STA_BSS_PARAM_DTIM_PERIOD,\n\t\t\t   sinfo->bss_param.dtim_period);\n\t\tNLA_PUT_U16(msg, NL80211_STA_BSS_PARAM_BEACON_INTERVAL,\n\t\t\t    sinfo->bss_param.beacon_interval);\n\n\t\tnla_nest_end(msg, bss_param);\n\t}\n\tnla_nest_end(msg, sinfoattr);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_station(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct station_info sinfo;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint sta_idx = cb->args[1];\n\tint err;\n\n\terr = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!dev->ops->dump_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = dev->ops->dump_station(&dev->wiphy, netdev, sta_idx,\n\t\t\t\t\t     mac_addr, &sinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_station(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev, mac_addr,\n\t\t\t\t&sinfo) < 0)\n\t\t\tgoto out;\n\n\t\tsta_idx++;\n\t}\n\n\n out:\n\tcb->args[1] = sta_idx;\n\terr = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\n\treturn err;\n}\n\nstatic int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_info sinfo;\n\tstruct sk_buff *msg;\n\tu8 *mac_addr = NULL;\n\tint err;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev->ops->get_station(&rdev->wiphy, dev, mac_addr, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_station(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t\t dev, mac_addr, &sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\n/*\n * Get vlan interface making sure it is running and on the right wiphy.\n */\nstatic int get_vlan(struct genl_info *info,\n\t\t    struct cfg80211_registered_device *rdev,\n\t\t    struct net_device **vlan)\n{\n\tstruct nlattr *vlanattr = info->attrs[NL80211_ATTR_STA_VLAN];\n\t*vlan = NULL;\n\n\tif (vlanattr) {\n\t\t*vlan = dev_get_by_index(genl_info_net(info),\n\t\t\t\t\t nla_get_u32(vlanattr));\n\t\tif (!*vlan)\n\t\t\treturn -ENODEV;\n\t\tif (!(*vlan)->ieee80211_ptr)\n\t\t\treturn -EINVAL;\n\t\tif ((*vlan)->ieee80211_ptr->wiphy != &rdev->wiphy)\n\t\t\treturn -EINVAL;\n\t\tif (!netif_running(*vlan))\n\t\t\treturn -ENETDOWN;\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tparams.listen_interval = -1;\n\tparams.plink_state = -1;\n\n\tif (info->attrs[NL80211_ATTR_STA_AID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\tparams.listen_interval =\n\t\t    nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (parse_station_flags(info, &params))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_STATE])\n\t\tparams.plink_state =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_STATE]);\n\n\terr = get_vlan(info, rdev, &params.vlan);\n\tif (err)\n\t\tgoto out;\n\n\t/* validate settings */\n\terr = 0;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* disallow mesh-specific things */\n\t\tif (params.plink_action)\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\t/* disallow everything but AUTHORIZED flag */\n\t\tif (params.plink_action)\n\t\t\terr = -EINVAL;\n\t\tif (params.vlan)\n\t\t\terr = -EINVAL;\n\t\tif (params.supported_rates)\n\t\t\terr = -EINVAL;\n\t\tif (params.ht_capa)\n\t\t\terr = -EINVAL;\n\t\tif (params.listen_interval >= 0)\n\t\t\terr = -EINVAL;\n\t\tif (params.sta_flags_mask & ~BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* disallow things mesh doesn't support */\n\t\tif (params.vlan)\n\t\t\terr = -EINVAL;\n\t\tif (params.ht_capa)\n\t\t\terr = -EINVAL;\n\t\tif (params.listen_interval >= 0)\n\t\t\terr = -EINVAL;\n\t\tif (params.sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\tif (!rdev->ops->change_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev->ops->change_station(&rdev->wiphy, dev, mac_addr, &params);\n\n out:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\n\treturn err;\n}\n\nstatic int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_AID])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tparams.supported_rates =\n\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.supported_rates_len =\n\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.listen_interval =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\tif (!params.aid || params.aid > IEEE80211_MAX_AID)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (parse_station_flags(info, &params))\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\terr = get_vlan(info, rdev, &params.vlan);\n\tif (err)\n\t\tgoto out;\n\n\t/* validate settings */\n\terr = 0;\n\n\tif (!rdev->ops->add_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev->ops->add_station(&rdev->wiphy, dev, mac_addr, &params);\n\n out:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\treturn err;\n}\n\nstatic int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_station)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->del_station(&rdev->wiphy, dev, mac_addr);\n}\n\nstatic int nl80211_send_mpath(struct sk_buff *msg, u32 pid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_STATION);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, dst);\n\tNLA_PUT(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION, pinfo->generation);\n\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (pinfo->filled & MPATH_INFO_FRAME_QLEN)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\t    pinfo->frame_qlen);\n\tif (pinfo->filled & MPATH_INFO_SN)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_SN,\n\t\t\t    pinfo->sn);\n\tif (pinfo->filled & MPATH_INFO_METRIC)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t    pinfo->metric);\n\tif (pinfo->filled & MPATH_INFO_EXPTIME)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t    pinfo->exptime);\n\tif (pinfo->filled & MPATH_INFO_FLAGS)\n\t\tNLA_PUT_U8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\t    pinfo->flags);\n\tif (pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t    pinfo->discovery_timeout);\n\tif (pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES)\n\t\tNLA_PUT_U8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\t    pinfo->discovery_retries);\n\n\tnla_nest_end(msg, pinfoattr);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[1];\n\tint err;\n\n\terr = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!dev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = dev->ops->dump_mpath(&dev->wiphy, netdev, path_idx,\n\t\t\t\t\t   dst, next_hop, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).pid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n\n out:\n\tcb->args[1] = path_idx;\n\terr = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn err;\n}\n\nstatic int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 next_hop[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev->ops->get_mpath(&rdev->wiphy, dev, dst, next_hop, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t\t dev, dst, next_hop, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_set_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->change_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->change_mpath(&rdev->wiphy, dev, dst, next_hop);\n}\n\nstatic int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->add_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->add_mpath(&rdev->wiphy, dev, dst, next_hop);\n}\n\nstatic int nl80211_del_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->del_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->del_mpath(&rdev->wiphy, dev, dst);\n}\n\nstatic int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct bss_parameters params;\n\n\tmemset(&params, 0, sizeof(params));\n\t/* default to not changing parameters */\n\tparams.use_cts_prot = -1;\n\tparams.use_short_preamble = -1;\n\tparams.use_short_slot_time = -1;\n\tparams.ap_isolate = -1;\n\tparams.ht_opmode = -1;\n\n\tif (info->attrs[NL80211_ATTR_BSS_CTS_PROT])\n\t\tparams.use_cts_prot =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_CTS_PROT]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE])\n\t\tparams.use_short_preamble =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME])\n\t\tparams.use_short_slot_time =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME]);\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tparams.basic_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tparams.basic_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t}\n\tif (info->attrs[NL80211_ATTR_AP_ISOLATE])\n\t\tparams.ap_isolate = !!nla_get_u8(info->attrs[NL80211_ATTR_AP_ISOLATE]);\n\tif (info->attrs[NL80211_ATTR_BSS_HT_OPMODE])\n\t\tparams.ht_opmode =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BSS_HT_OPMODE]);\n\n\tif (!rdev->ops->change_bss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->change_bss(&rdev->wiphy, dev, &params);\n}\n\nstatic const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {\n\t[NL80211_ATTR_REG_RULE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_START]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_END]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_MAX_BW]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_EIRP]\t= { .type = NLA_U32 },\n};\n\nstatic int parse_reg_rule(struct nlattr *tb[],\n\tstruct ieee80211_reg_rule *reg_rule)\n{\n\tstruct ieee80211_freq_range *freq_range = &reg_rule->freq_range;\n\tstruct ieee80211_power_rule *power_rule = &reg_rule->power_rule;\n\n\tif (!tb[NL80211_ATTR_REG_RULE_FLAGS])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_START])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_END])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_MAX_BW])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_POWER_RULE_MAX_EIRP])\n\t\treturn -EINVAL;\n\n\treg_rule->flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);\n\n\tfreq_range->start_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]);\n\tfreq_range->end_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]);\n\tfreq_range->max_bandwidth_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]);\n\n\tpower_rule->max_eirp =\n\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_EIRP]);\n\n\tif (tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN])\n\t\tpower_rule->max_antenna_gain =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);\n\n\treturn 0;\n}\n\nstatic int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tint r;\n\tchar *data = NULL;\n\n\t/*\n\t * You should only get this when cfg80211 hasn't yet initialized\n\t * completely when built-in to the kernel right between the time\n\t * window between nl80211_init() and regulatory_init(), if that is\n\t * even possible.\n\t */\n\tmutex_lock(&cfg80211_mutex);\n\tif (unlikely(!cfg80211_regdomain)) {\n\t\tmutex_unlock(&cfg80211_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tmutex_unlock(&cfg80211_mutex);\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tdata = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tr = regulatory_hint_user(data);\n\n\treturn r;\n}\n\nstatic int nl80211_get_mesh_config(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cur_params;\n\tint err = 0;\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\tstruct sk_buff *msg;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\t/* If not connected, get default parameters */\n\tif (!wdev->mesh_id_len)\n\t\tmemcpy(&cur_params, &default_mesh_config, sizeof(cur_params));\n\telse\n\t\terr = rdev->ops->get_mesh_config(&rdev->wiphy, dev,\n\t\t\t\t\t\t &cur_params);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t/* Draw up a netlink message to send back */\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_MESH_CONFIG);\n\tif (!hdr)\n\t\tgoto out;\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_MESH_CONFIG);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_RETRY_TIMEOUT,\n\t\t\tcur_params.dot11MeshRetryTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\tcur_params.dot11MeshConfirmTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\tcur_params.dot11MeshHoldingTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\tcur_params.dot11MeshMaxPeerLinks);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_MAX_RETRIES,\n\t\t\tcur_params.dot11MeshMaxRetries);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_TTL,\n\t\t\tcur_params.dot11MeshTTL);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_ELEMENT_TTL,\n\t\t\tcur_params.element_ttl);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t\tcur_params.auto_open_plinks);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\tcur_params.dot11MeshHWMPmaxPREQretries);\n\tNLA_PUT_U32(msg, NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\tcur_params.path_refresh_time);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tcur_params.min_discovery_timeout);\n\tNLA_PUT_U32(msg, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPpreqMinInterval);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tcur_params.dot11MeshHWMPnetDiameterTraversalTime);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t\tcur_params.dot11MeshHWMPRootMode);\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n out:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic const struct nla_policy nl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {\n\t[NL80211_MESHCONF_RETRY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_CONFIRM_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HOLDING_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_MAX_PEER_LINKS] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_MAX_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_TTL] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_ELEMENT_TTL] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = { .type = NLA_U8 },\n\n\t[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] = { .type = NLA_U16 },\n};\n\nstatic const struct nla_policy\n\tnl80211_mesh_setup_params_policy[NL80211_MESH_SETUP_ATTR_MAX+1] = {\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_IE] = { .type = NLA_BINARY,\n\t\t.len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_MESH_SETUP_USERSPACE_AMPE] = { .type = NLA_FLAG },\n};\n\nstatic int nl80211_parse_mesh_config(struct genl_info *info,\n\t\t\t\t     struct mesh_config *cfg,\n\t\t\t\t     u32 *mask_out)\n{\n\tstruct nlattr *tb[NL80211_MESHCONF_ATTR_MAX + 1];\n\tu32 mask = 0;\n\n#define FILL_IN_MESH_PARAM_IF_SET(table, cfg, param, mask, attr_num, nla_fn) \\\ndo {\\\n\tif (table[attr_num]) {\\\n\t\tcfg->param = nla_fn(table[attr_num]); \\\n\t\tmask |= (1 << (attr_num - 1)); \\\n\t} \\\n} while (0);\\\n\n\n\tif (!info->attrs[NL80211_ATTR_MESH_CONFIG])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested(tb, NL80211_MESHCONF_ATTR_MAX,\n\t\t\t     info->attrs[NL80211_ATTR_MESH_CONFIG],\n\t\t\t     nl80211_meshconf_params_policy))\n\t\treturn -EINVAL;\n\n\t/* This makes sure that there aren't more than 32 mesh config\n\t * parameters (otherwise our bitfield scheme would not work.) */\n\tBUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);\n\n\t/* Fill in the params struct */\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout,\n\t\t\tmask, NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout,\n\t\t\tmask, NL80211_MESHCONF_CONFIRM_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout,\n\t\t\tmask, NL80211_MESHCONF_HOLDING_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks,\n\t\t\tmask, NL80211_MESHCONF_MAX_PEER_LINKS, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries,\n\t\t\tmask, NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL,\n\t\t\tmask, NL80211_MESHCONF_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl,\n\t\t\tmask, NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks,\n\t\t\tmask, NL80211_MESHCONF_AUTO_OPEN_PLINKS, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries,\n\t\t\tmask, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\tnla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time,\n\t\t\tmask, NL80211_MESHCONF_PATH_REFRESH_TIME, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout,\n\t\t\tmask, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tnla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,\n\t\t\tmask, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tnla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval,\n\t\t\tmask, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tnla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\tdot11MeshHWMPnetDiameterTraversalTime,\n\t\t\tmask, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tnla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\tdot11MeshHWMPRootMode, mask,\n\t\t\tNL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t\tnla_get_u8);\n\tif (mask_out)\n\t\t*mask_out = mask;\n\n\treturn 0;\n\n#undef FILL_IN_MESH_PARAM_IF_SET\n}\n\nstatic int nl80211_parse_mesh_setup(struct genl_info *info,\n\t\t\t\t     struct mesh_setup *setup)\n{\n\tstruct nlattr *tb[NL80211_MESH_SETUP_ATTR_MAX + 1];\n\n\tif (!info->attrs[NL80211_ATTR_MESH_SETUP])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested(tb, NL80211_MESH_SETUP_ATTR_MAX,\n\t\t\t     info->attrs[NL80211_ATTR_MESH_SETUP],\n\t\t\t     nl80211_mesh_setup_params_policy))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])\n\t\tsetup->path_sel_proto =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])) ?\n\t\t IEEE80211_PATH_PROTOCOL_VENDOR :\n\t\t IEEE80211_PATH_PROTOCOL_HWMP;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])\n\t\tsetup->path_metric =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])) ?\n\t\t IEEE80211_PATH_METRIC_VENDOR :\n\t\t IEEE80211_PATH_METRIC_AIRTIME;\n\n\n\tif (tb[NL80211_MESH_SETUP_IE]) {\n\t\tstruct nlattr *ieattr =\n\t\t\ttb[NL80211_MESH_SETUP_IE];\n\t\tif (!is_valid_ie_attr(ieattr))\n\t\t\treturn -EINVAL;\n\t\tsetup->ie = nla_data(ieattr);\n\t\tsetup->ie_len = nla_len(ieattr);\n\t}\n\tsetup->is_authenticated = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AUTH]);\n\tsetup->is_secure = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AMPE]);\n\n\treturn 0;\n}\n\nstatic int nl80211_update_mesh_config(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cfg;\n\tu32 mask;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->update_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mesh_config(info, &cfg, &mask);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!wdev->mesh_id_len)\n\t\terr = -ENOLINK;\n\n\tif (!err)\n\t\terr = rdev->ops->update_mesh_config(&rdev->wiphy, dev,\n\t\t\t\t\t\t    mask, &cfg);\n\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr = NULL;\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\tint err = -EINVAL;\n\n\tmutex_lock(&cfg80211_mutex);\n\n\tif (!cfg80211_regdomain)\n\t\tgoto out;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\tNLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2,\n\t\tcfg80211_regdomain->alpha2);\n\n\tnl_reg_rules = nla_nest_start(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < cfg80211_regdomain->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\n\t\treg_rule = &cfg80211_regdomain->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\treg_rule->flags);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\tfreq_range->start_freq_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\tfreq_range->end_freq_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\tfreq_range->max_bandwidth_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\tpower_rule->max_antenna_gain);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\tpower_rule->max_eirp);\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\n\tgenlmsg_end(msg, hdr);\n\terr = genlmsg_reply(msg, info);\n\tgoto out;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\nput_failure:\n\tnlmsg_free(msg);\n\terr = -EMSGSIZE;\nout:\n\tmutex_unlock(&cfg80211_mutex);\n\treturn err;\n}\n\nstatic int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];\n\tstruct nlattr *nl_reg_rule;\n\tchar *alpha2 = NULL;\n\tint rem_reg_rules = 0, r = 0;\n\tu32 num_rules = 0, rule_idx = 0, size_of_regd;\n\tstruct ieee80211_regdomain *rd = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_RULES])\n\t\treturn -EINVAL;\n\n\talpha2 = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\trem_reg_rules) {\n\t\tnum_rules++;\n\t\tif (num_rules > NL80211_MAX_SUPP_REG_RULES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&cfg80211_mutex);\n\n\tif (!reg_is_valid_request(alpha2)) {\n\t\tr = -EINVAL;\n\t\tgoto bad_reg;\n\t}\n\n\tsize_of_regd = sizeof(struct ieee80211_regdomain) +\n\t\t(num_rules * sizeof(struct ieee80211_reg_rule));\n\n\trd = kzalloc(size_of_regd, GFP_KERNEL);\n\tif (!rd) {\n\t\tr = -ENOMEM;\n\t\tgoto bad_reg;\n\t}\n\n\trd->n_reg_rules = num_rules;\n\trd->alpha2[0] = alpha2[0];\n\trd->alpha2[1] = alpha2[1];\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\trem_reg_rules) {\n\t\tnla_parse(tb, NL80211_REG_RULE_ATTR_MAX,\n\t\t\tnla_data(nl_reg_rule), nla_len(nl_reg_rule),\n\t\t\treg_rule_policy);\n\t\tr = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\n\t\trule_idx++;\n\n\t\tif (rule_idx > NL80211_MAX_SUPP_REG_RULES) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad_reg;\n\t\t}\n\t}\n\n\tBUG_ON(rule_idx != num_rules);\n\n\tr = set_regdom(rd);\n\n\tmutex_unlock(&cfg80211_mutex);\n\n\treturn r;\n\n bad_reg:\n\tmutex_unlock(&cfg80211_mutex);\n\tkfree(rd);\n\treturn r;\n}\n\nstatic int validate_scan_freqs(struct nlattr *freqs)\n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t/*\n\t\t * Some hardware has a limited channel list for\n\t\t * scanning, and it is pretty much nonsensical\n\t\t * to scan for a channel twice, so disallow that\n\t\t * and don't require drivers to check that the\n\t\t * channel list they get isn't longer than what\n\t\t * they can scan, as long as they can scan all\n\t\t * the channels they registered at once.\n\t\t */\n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;\n}\n\nstatic int nl80211_stop_sched_scan(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\treturn __cfg80211_stop_sched_scan(rdev, false);\n}\n\nstatic int nl80211_send_bss(struct sk_buff *msg, u32 pid, u32 seq, int flags,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_internal_bss *intbss)\n{\n\tstruct cfg80211_bss *res = &intbss->pub;\n\tvoid *hdr;\n\tstruct nlattr *bss;\n\tint i;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SCAN_RESULTS);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION, rdev->bss_generation);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex);\n\n\tbss = nla_nest_start(msg, NL80211_ATTR_BSS);\n\tif (!bss)\n\t\tgoto nla_put_failure;\n\tif (!is_zero_ether_addr(res->bssid))\n\t\tNLA_PUT(msg, NL80211_BSS_BSSID, ETH_ALEN, res->bssid);\n\tif (res->information_elements && res->len_information_elements)\n\t\tNLA_PUT(msg, NL80211_BSS_INFORMATION_ELEMENTS,\n\t\t\tres->len_information_elements,\n\t\t\tres->information_elements);\n\tif (res->beacon_ies && res->len_beacon_ies &&\n\t    res->beacon_ies != res->information_elements)\n\t\tNLA_PUT(msg, NL80211_BSS_BEACON_IES,\n\t\t\tres->len_beacon_ies, res->beacon_ies);\n\tif (res->tsf)\n\t\tNLA_PUT_U64(msg, NL80211_BSS_TSF, res->tsf);\n\tif (res->beacon_interval)\n\t\tNLA_PUT_U16(msg, NL80211_BSS_BEACON_INTERVAL, res->beacon_interval);\n\tNLA_PUT_U16(msg, NL80211_BSS_CAPABILITY, res->capability);\n\tNLA_PUT_U32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq);\n\tNLA_PUT_U32(msg, NL80211_BSS_SEEN_MS_AGO,\n\t\tjiffies_to_msecs(jiffies - intbss->ts));\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tNLA_PUT_U32(msg, NL80211_BSS_SIGNAL_MBM, res->signal);\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tNLA_PUT_U8(msg, NL80211_BSS_SIGNAL_UNSPEC, res->signal);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (intbss == wdev->current_bss)\n\t\t\tNLA_PUT_U32(msg, NL80211_BSS_STATUS,\n\t\t\t\t    NL80211_BSS_STATUS_ASSOCIATED);\n\t\telse for (i = 0; i < MAX_AUTH_BSSES; i++) {\n\t\t\tif (intbss != wdev->auth_bsses[i])\n\t\t\t\tcontinue;\n\t\t\tNLA_PUT_U32(msg, NL80211_BSS_STATUS,\n\t\t\t\t    NL80211_BSS_STATUS_AUTHENTICATED);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (intbss == wdev->current_bss)\n\t\t\tNLA_PUT_U32(msg, NL80211_BSS_STATUS,\n\t\t\t\t    NL80211_BSS_STATUS_IBSS_JOINED);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, bss);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_scan(struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *dev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[1], idx = 0;\n\tint err;\n\n\terr = nl80211_prepare_netdev_dump(skb, cb, &rdev, &dev);\n\tif (err)\n\t\treturn err;\n\n\twdev = dev->ieee80211_ptr;\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\tcfg80211_bss_expire(rdev);\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[1] = idx;\n\tnl80211_finish_netdev_dump(rdev);\n\n\treturn skb->len;\n}\n\nstatic int nl80211_send_survey(struct sk_buff *msg, u32 pid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tstruct survey_info *survey)\n{\n\tvoid *hdr;\n\tstruct nlattr *infoattr;\n\n\t/* Survey without a channel doesn't make sense */\n\tif (!survey->channel)\n\t\treturn -EINVAL;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SURVEY_RESULTS);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\n\tinfoattr = nla_nest_start(msg, NL80211_ATTR_SURVEY_INFO);\n\tif (!infoattr)\n\t\tgoto nla_put_failure;\n\n\tNLA_PUT_U32(msg, NL80211_SURVEY_INFO_FREQUENCY,\n\t\t    survey->channel->center_freq);\n\tif (survey->filled & SURVEY_INFO_NOISE_DBM)\n\t\tNLA_PUT_U8(msg, NL80211_SURVEY_INFO_NOISE,\n\t\t\t    survey->noise);\n\tif (survey->filled & SURVEY_INFO_IN_USE)\n\t\tNLA_PUT_FLAG(msg, NL80211_SURVEY_INFO_IN_USE);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME,\n\t\t\t    survey->channel_time);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_BUSY)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_BUSY,\n\t\t\t    survey->channel_time_busy);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_EXT_BUSY)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_EXT_BUSY,\n\t\t\t    survey->channel_time_ext_busy);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_RX)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_RX,\n\t\t\t    survey->channel_time_rx);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_TX)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_TX,\n\t\t\t    survey->channel_time_tx);\n\n\tnla_nest_end(msg, infoattr);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_survey(struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb)\n{\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tint survey_idx = cb->args[1];\n\tint res;\n\n\tres = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (res)\n\t\treturn res;\n\n\tif (!dev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tres = dev->ops->dump_survey(&dev->wiphy, netdev, survey_idx,\n\t\t\t\t\t    &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev,\n\t\t\t\t&survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[1] = survey_idx;\n\tres = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn res;\n}\n\nstatic bool nl80211_valid_auth_type(enum nl80211_auth_type auth_type)\n{\n\treturn auth_type <= NL80211_AUTHTYPE_MAX;\n}\n\nstatic bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2));\n}\n\nstatic bool nl80211_valid_akm_suite(u32 akm)\n{\n\treturn akm == WLAN_AKM_SUITE_8021X ||\n\t\takm == WLAN_AKM_SUITE_PSK;\n}\n\nstatic bool nl80211_valid_cipher_suite(u32 cipher)\n{\n\treturn cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\tcipher == WLAN_CIPHER_SUITE_WEP104 ||\n\t\tcipher == WLAN_CIPHER_SUITE_TKIP ||\n\t\tcipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\tcipher == WLAN_CIPHER_SUITE_AES_CMAC;\n}\n\n\nstatic int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL;\n\tint err, ssid_len, ie_len = 0;\n\tenum nl80211_auth_type auth_type;\n\tstruct key_parse key;\n\tbool local_state_change;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_AUTH_TYPE])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx >= 0) {\n\t\tif (key.type != -1 && key.type != NL80211_KEYTYPE_GROUP)\n\t\t\treturn -EINVAL;\n\t\tif (!key.p.key || !key.p.key_len)\n\t\t\treturn -EINVAL;\n\t\tif ((key.p.cipher != WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP40) &&\n\t\t    (key.p.cipher != WLAN_CIPHER_SUITE_WEP104 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP104))\n\t\t\treturn -EINVAL;\n\t\tif (key.idx > 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey.p.key_len = 0;\n\t\tkey.p.key = NULL;\n\t}\n\n\tif (key.idx >= 0) {\n\t\tint i;\n\t\tbool ok = false;\n\t\tfor (i = 0; i < rdev->wiphy.n_cipher_suites; i++) {\n\t\t\tif (key.p.cipher == rdev->wiphy.cipher_suites[i]) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tchan = ieee80211_get_channel(&rdev->wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!chan || (chan->flags & IEEE80211_CHAN_DISABLED))\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\tif (!nl80211_valid_auth_type(auth_type))\n\t\treturn -EINVAL;\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\treturn cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,\n\t\t\t\t  ssid, ssid_len, ie, ie_len,\n\t\t\t\t  key.p.key, key.p.key_len, key.idx,\n\t\t\t\t  local_state_change);\n}\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit)\n{\n\tmemset(settings, 0, sizeof(*settings));\n\n\tsettings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tu16 proto;\n\t\tproto = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\t\tsettings->control_port_ethertype = cpu_to_be16(proto);\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    proto != ETH_P_PAE)\n\t\t\treturn -EINVAL;\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])\n\t\t\tsettings->control_port_no_encrypt = true;\n\t} else\n\t\tsettings->control_port_ethertype = cpu_to_be16(ETH_P_PAE);\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tsettings->n_ciphers_pairwise = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_ciphers_pairwise > cipher_limit)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->ciphers_pairwise, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!nl80211_valid_cipher_suite(\n\t\t\t\t\tsettings->ciphers_pairwise[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {\n\t\tsettings->cipher_group =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);\n\t\tif (!nl80211_valid_cipher_suite(settings->cipher_group))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {\n\t\tsettings->wpa_versions =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);\n\t\tif (!nl80211_valid_wpa_versions(settings->wpa_versions))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AKM_SUITES]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tsettings->n_akm_suites = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->akm_suites, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!nl80211_valid_akm_suite(settings->akm_suites[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_associate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_crypto_settings crypto;\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL, *prev_bssid = NULL;\n\tint err, ssid_len, ie_len = 0;\n\tbool use_mfp = false;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tchan = ieee80211_get_channel(&rdev->wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!chan || (chan->flags & IEEE80211_CHAN_DISABLED))\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tenum nl80211_mfp mfp =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (mfp == NL80211_MFP_REQUIRED)\n\t\t\tuse_mfp = true;\n\t\telse if (mfp != NL80211_MFP_NO)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\tprev_bssid = nla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\terr = nl80211_crypto_settings(rdev, info, &crypto, 1);\n\tif (!err)\n\t\terr = cfg80211_mlme_assoc(rdev, dev, chan, bssid, prev_bssid,\n\t\t\t\t\t  ssid, ssid_len, ie, ie_len, use_mfp,\n\t\t\t\t\t  &crypto);\n\n\treturn err;\n}\n\nstatic int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\treturn cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t    local_state_change);\n}\n\nstatic int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->disassoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\treturn cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t      local_state_change);\n}\n\nstatic bool\nnl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[IEEE80211_NUM_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\t\tif (ibss.beacon_interval < 1 || ibss.beacon_interval > 10000)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tibss.channel = ieee80211_get_channel(wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!ibss.channel ||\n\t    ibss.channel->flags & IEEE80211_CHAN_NO_IBSS ||\n\t    ibss.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn -EINVAL;\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.channel->band];\n\t\tint i, j;\n\n\t\tif (n_rates == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < n_rates; i++) {\n\t\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\t\tbool found = false;\n\n\t\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\t\tif (sband->bitrates[j].bitrate == rate) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tibss.basic_rates |= BIT(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n\nstatic int nl80211_leave_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->leave_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_leave_ibss(rdev, dev, false);\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic struct genl_multicast_group nl80211_testmode_mcgrp = {\n\t.name = \"testmode\",\n};\n\nstatic int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_TESTDATA])\n\t\treturn -EINVAL;\n\n\terr = -EOPNOTSUPP;\n\tif (rdev->ops->testmode_cmd) {\n\t\trdev->testmode_info = info;\n\t\terr = rdev->ops->testmode_cmd(&rdev->wiphy,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_TESTDATA]),\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_TESTDATA]));\n\t\trdev->testmode_info = NULL;\n\t}\n\n\treturn err;\n}\n\nstatic struct sk_buff *\n__cfg80211_testmode_alloc_skb(struct cfg80211_registered_device *rdev,\n\t\t\t      int approxlen, u32 pid, u32 seq, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\tstruct nlattr *data;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nl80211hdr_put(skb, pid, seq, 0, NL80211_CMD_TESTMODE);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tNLA_PUT_U32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tdata = nla_nest_start(skb, NL80211_ATTR_TESTDATA);\n\n\t((void **)skb->cb)[0] = rdev;\n\t((void **)skb->cb)[1] = hdr;\n\t((void **)skb->cb)[2] = data;\n\n\treturn skb;\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\n\tif (WARN_ON(!rdev->testmode_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen,\n\t\t\t\trdev->testmode_info->snd_pid,\n\t\t\t\trdev->testmode_info->snd_seq,\n\t\t\t\tGFP_KERNEL);\n}\nEXPORT_SYMBOL(cfg80211_testmode_alloc_reply_skb);\n\nint cfg80211_testmode_reply(struct sk_buff *skb)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\tif (WARN_ON(!rdev->testmode_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, rdev->testmode_info);\n}\nEXPORT_SYMBOL(cfg80211_testmode_reply);\n\nstruct sk_buff *cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen, 0, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_testmode_alloc_event_skb);\n\nvoid cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)\n{\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\tgenlmsg_multicast(skb, 0, nl80211_testmode_mcgrp.id, gfp);\n}\nEXPORT_SYMBOL(cfg80211_testmode_event);\n#endif\n\nstatic int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(connect.auth_type))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tconnect.channel =\n\t\t\tieee80211_get_channel(wiphy,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\t\tif (!connect.channel ||\n\t\t    connect.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n\nstatic int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_disconnect(rdev, dev, reason, true);\n}\n\nstatic int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\tu32 pid;\n\n\tif (!info->attrs[NL80211_ATTR_PID])\n\t\treturn -EINVAL;\n\n\tpid = nla_get_u32(info->attrs[NL80211_ATTR_PID]);\n\n\tnet = get_net_ns_by_pid(pid);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t/* check if anything to do */\n\tif (!net_eq(wiphy_net(&rdev->wiphy), net))\n\t\terr = cfg80211_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint (*rdev_ops)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_pmksa *pmksa) = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_pmksa pmksa;\n\n\tmemset(&pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_PMKID])\n\t\treturn -EINVAL;\n\n\tpmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\tpmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_SET_PMKSA:\n\t\trdev_ops = rdev->ops->set_pmksa;\n\t\tbreak;\n\tcase NL80211_CMD_DEL_PMKSA:\n\t\trdev_ops = rdev->ops->del_pmksa;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (!rdev_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_ops(&rdev->wiphy, dev, &pmksa);\n}\n\nstatic int nl80211_flush_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->flush_pmksa)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->flush_pmksa(&rdev->wiphy, dev);\n}\n\nstatic int nl80211_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tenum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;\n\tu32 freq, duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t/*\n\t * We should be on that channel for at least one jiffie,\n\t * and more than 5 seconds seems excessive.\n\t */\n\tif (!duration || !msecs_to_jiffies(duration) ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tchannel_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\t\tif (channel_type != NL80211_CHAN_NO_HT &&\n\t\t    channel_type != NL80211_CHAN_HT20 &&\n\t\t    channel_type != NL80211_CHAN_HT40PLUS &&\n\t\t    channel_type != NL80211_CHAN_HT40MINUS)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tchan = rdev_freq_to_chan(rdev, freq, channel_type);\n\tif (chan == NULL)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_REMAIN_ON_CHANNEL);\n\n\tif (IS_ERR(hdr)) {\n\t\terr = PTR_ERR(hdr);\n\t\tgoto free_msg;\n\t}\n\n\terr = rdev->ops->remain_on_channel(&rdev->wiphy, dev, chan,\n\t\t\t\t\t   channel_type, duration, &cookie);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_cancel_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->cancel_remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev->ops->cancel_remain_on_channel(&rdev->wiphy, dev, cookie);\n}\n\nstatic u32 rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t   u8 *rates, u8 rates_len)\n{\n\tu8 i;\n\tu32 mask = 0;\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tint ridx;\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate =\n\t\t\t\t&sband->bitrates[ridx];\n\t\t\tif (rate == srate->bitrate) {\n\t\t\t\tmask |= 1 << ridx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ridx == sband->n_bitrates)\n\t\t\treturn 0; /* rate not found */\n\t}\n\n\treturn mask;\n}\n\nstatic const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {\n\t[NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,\n\t\t\t\t    .len = NL80211_MAX_SUPP_RATES },\n};\n\nstatic int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_TXRATE_MAX + 1];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_bitrate_mask mask;\n\tint rem, i;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *tx_rates;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES] == NULL)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&mask, 0, sizeof(mask));\n\t/* Default to all rates enabled */\n\tfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\n\t\tsband = rdev->wiphy.bands[i];\n\t\tmask.control[i].legacy =\n\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;\n\t}\n\n\t/*\n\t * The nested attribute uses enum nl80211_band as the index. This maps\n\t * directly to the enum ieee80211_band values used in cfg80211.\n\t */\n\tnla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem)\n\t{\n\t\tenum ieee80211_band band = nla_type(tx_rates);\n\t\tif (band < 0 || band >= IEEE80211_NUM_BANDS)\n\t\t\treturn -EINVAL;\n\t\tsband = rdev->wiphy.bands[band];\n\t\tif (sband == NULL)\n\t\t\treturn -EINVAL;\n\t\tnla_parse(tb, NL80211_TXRATE_MAX, nla_data(tx_rates),\n\t\t\t  nla_len(tx_rates), nl80211_txattr_policy);\n\t\tif (tb[NL80211_TXRATE_LEGACY]) {\n\t\t\tmask.control[band].legacy = rateset_to_mask(\n\t\t\t\tsband,\n\t\t\t\tnla_data(tb[NL80211_TXRATE_LEGACY]),\n\t\t\t\tnla_len(tb[NL80211_TXRATE_LEGACY]));\n\t\t\tif (mask.control[band].legacy == 0)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn rdev->ops->set_bitrate_mask(&rdev->wiphy, dev, NULL, &mask);\n}\n\nstatic int nl80211_register_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 frame_type = IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME_MATCH])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_FRAME_TYPE])\n\t\tframe_type = nla_get_u16(info->attrs[NL80211_ATTR_FRAME_TYPE]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\t/* not much point in registering if we can't reply */\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_mlme_register_mgmt(dev->ieee80211_ptr, info->snd_pid,\n\t\t\tframe_type,\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FRAME_MATCH]));\n}\n\nstatic int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;\n\tbool channel_type_valid = false;\n\tu32 freq;\n\tint err;\n\tvoid *hdr;\n\tu64 cookie;\n\tstruct sk_buff *msg;\n\tunsigned int wait = 0;\n\tbool offchan;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\t\treturn -EINVAL;\n\t\twait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tchannel_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\t\tif (channel_type != NL80211_CHAN_NO_HT &&\n\t\t    channel_type != NL80211_CHAN_HT20 &&\n\t\t    channel_type != NL80211_CHAN_HT40PLUS &&\n\t\t    channel_type != NL80211_CHAN_HT40MINUS)\n\t\t\treturn -EINVAL;\n\t\tchannel_type_valid = true;\n\t}\n\n\toffchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tchan = rdev_freq_to_chan(rdev, freq, channel_type);\n\tif (chan == NULL)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_FRAME);\n\n\tif (IS_ERR(hdr)) {\n\t\terr = PTR_ERR(hdr);\n\t\tgoto free_msg;\n\t}\n\terr = cfg80211_mlme_mgmt_tx(rdev, dev, chan, offchan, channel_type,\n\t\t\t\t    channel_type_valid, wait,\n\t\t\t\t    nla_data(info->attrs[NL80211_ATTR_FRAME]),\n\t\t\t\t    nla_len(info->attrs[NL80211_ATTR_FRAME]),\n\t\t\t\t    &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_tx_mgmt_cancel_wait(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev->ops->mgmt_tx_cancel_wait(&rdev->wiphy, dev, cookie);\n}\n\nstatic int nl80211_set_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 ps_state;\n\tbool state;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_PS_STATE])\n\t\treturn -EINVAL;\n\n\tps_state = nla_get_u32(info->attrs[NL80211_ATTR_PS_STATE]);\n\n\tif (ps_state != NL80211_PS_DISABLED && ps_state != NL80211_PS_ENABLED)\n\t\treturn -EINVAL;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tstate = (ps_state == NL80211_PS_ENABLED) ? true : false;\n\n\tif (state == wdev->ps)\n\t\treturn 0;\n\n\terr = rdev->ops->set_power_mgmt(wdev->wiphy, dev, state,\n\t\t\t\t\twdev->ps_timeout);\n\tif (!err)\n\t\twdev->ps = state;\n\treturn err;\n}\n\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_PS_STATE, ps_state);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic struct nla_policy\nnl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] __read_mostly = {\n\t[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },\n};\n\nstatic int nl80211_set_cqm_rssi(struct genl_info *info,\n\t\t\t\ts32 threshold, u32 hysteresis)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (threshold > 0)\n\t\treturn -EINVAL;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_cqm_rssi_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->set_cqm_rssi_config(wdev->wiphy, dev,\n\t\t\t\t\t      threshold, hysteresis);\n}\n\nstatic int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[NL80211_ATTR_CQM_MAX + 1];\n\tstruct nlattr *cqm;\n\tint err;\n\n\tcqm = info->attrs[NL80211_ATTR_CQM];\n\tif (!cqm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = nla_parse_nested(attrs, NL80211_ATTR_CQM_MAX, cqm,\n\t\t\t       nl80211_attr_cqm_policy);\n\tif (err)\n\t\tgoto out;\n\n\tif (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&\n\t    attrs[NL80211_ATTR_CQM_RSSI_HYST]) {\n\t\ts32 threshold;\n\t\tu32 hysteresis;\n\t\tthreshold = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\thysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);\n\t\terr = nl80211_set_cqm_rssi(info, threshold, hysteresis);\n\t} else\n\t\terr = -EINVAL;\n\nout:\n\treturn err;\n}\n\nstatic int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mesh_config cfg;\n\tstruct mesh_setup setup;\n\tint err;\n\n\t/* start with default */\n\tmemcpy(&cfg, &default_mesh_config, sizeof(cfg));\n\tmemcpy(&setup, &default_mesh_setup, sizeof(setup));\n\n\tif (info->attrs[NL80211_ATTR_MESH_CONFIG]) {\n\t\t/* and parse parameters if given */\n\t\terr = nl80211_parse_mesh_config(info, &cfg, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MESH_ID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_MESH_ID]))\n\t\treturn -EINVAL;\n\n\tsetup.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);\n\tsetup.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\n\tif (info->attrs[NL80211_ATTR_MESH_SETUP]) {\n\t\t/* parse additional setup parameters if given */\n\t\terr = nl80211_parse_mesh_setup(info, &setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn cfg80211_join_mesh(rdev, dev, &setup, &cfg);\n}\n\nstatic int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_mesh(rdev, dev);\n}\n\nstatic int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!rdev->wiphy.wowlan.flags && !rdev->wiphy.wowlan.n_patterns)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_WOWLAN);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->wowlan) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start(msg, NL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wowlan->any)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_ANY);\n\t\tif (rdev->wowlan->disconnect)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_DISCONNECT);\n\t\tif (rdev->wowlan->magic_pkt)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT);\n\t\tif (rdev->wowlan->n_patterns) {\n\t\t\tstruct nlattr *nl_pats, *nl_pat;\n\t\t\tint i, pat_len;\n\n\t\t\tnl_pats = nla_nest_start(msg,\n\t\t\t\t\tNL80211_WOWLAN_TRIG_PKT_PATTERN);\n\t\t\tif (!nl_pats)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wowlan->n_patterns; i++) {\n\t\t\t\tnl_pat = nla_nest_start(msg, i + 1);\n\t\t\t\tif (!nl_pat)\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tpat_len = rdev->wowlan->patterns[i].pattern_len;\n\t\t\t\tNLA_PUT(msg, NL80211_WOWLAN_PKTPAT_MASK,\n\t\t\t\t\tDIV_ROUND_UP(pat_len, 8),\n\t\t\t\t\trdev->wowlan->patterns[i].mask);\n\t\t\t\tNLA_PUT(msg, NL80211_WOWLAN_PKTPAT_PATTERN,\n\t\t\t\t\tpat_len,\n\t\t\t\t\trdev->wowlan->patterns[i].pattern);\n\t\t\t\tnla_nest_end(msg, nl_pat);\n\t\t\t}\n\t\t\tnla_nest_end(msg, nl_pats);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];\n\tstruct cfg80211_wowlan no_triggers = {};\n\tstruct cfg80211_wowlan new_triggers = {};\n\tstruct wiphy_wowlan_support *wowlan = &rdev->wiphy.wowlan;\n\tint err, i;\n\n\tif (!rdev->wiphy.wowlan.flags && !rdev->wiphy.wowlan.n_patterns)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS])\n\t\tgoto no_triggers;\n\n\terr = nla_parse(tb, MAX_NL80211_WOWLAN_TRIG,\n\t\t\tnla_data(info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]),\n\t\t\tnla_len(info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]),\n\t\t\tnl80211_wowlan_policy);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_WOWLAN_TRIG_ANY]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_ANY))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.any = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_DISCONNECT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.disconnect = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.magic_pkt = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {\n\t\tstruct nlattr *pat;\n\t\tint n_patterns = 0;\n\t\tint rem, pat_len, mask_len;\n\t\tstruct nlattr *pat_tb[NUM_NL80211_WOWLAN_PKTPAT];\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem)\n\t\t\tn_patterns++;\n\t\tif (n_patterns > wowlan->n_patterns)\n\t\t\treturn -EINVAL;\n\n\t\tnew_triggers.patterns = kcalloc(n_patterns,\n\t\t\t\t\t\tsizeof(new_triggers.patterns[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_triggers.patterns)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_triggers.n_patterns = n_patterns;\n\t\ti = 0;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem) {\n\t\t\tnla_parse(pat_tb, MAX_NL80211_WOWLAN_PKTPAT,\n\t\t\t\t  nla_data(pat), nla_len(pat), NULL);\n\t\t\terr = -EINVAL;\n\t\t\tif (!pat_tb[NL80211_WOWLAN_PKTPAT_MASK] ||\n\t\t\t    !pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN])\n\t\t\t\tgoto error;\n\t\t\tpat_len = nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]);\n\t\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\t\tif (nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]) !=\n\t\t\t    mask_len)\n\t\t\t\tgoto error;\n\t\t\tif (pat_len > wowlan->pattern_max_len ||\n\t\t\t    pat_len < wowlan->pattern_min_len)\n\t\t\t\tgoto error;\n\n\t\t\tnew_triggers.patterns[i].mask =\n\t\t\t\tkmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\t\tif (!new_triggers.patterns[i].mask) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tnew_triggers.patterns[i].pattern =\n\t\t\t\tnew_triggers.patterns[i].mask + mask_len;\n\t\t\tmemcpy(new_triggers.patterns[i].mask,\n\t\t\t       nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]),\n\t\t\t       mask_len);\n\t\t\tnew_triggers.patterns[i].pattern_len = pat_len;\n\t\t\tmemcpy(new_triggers.patterns[i].pattern,\n\t\t\t       nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]),\n\t\t\t       pat_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (memcmp(&new_triggers, &no_triggers, sizeof(new_triggers))) {\n\t\tstruct cfg80211_wowlan *ntrig;\n\t\tntrig = kmemdup(&new_triggers, sizeof(new_triggers),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ntrig) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wowlan = ntrig;\n\t} else {\n no_triggers:\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wowlan = NULL;\n\t}\n\n\treturn 0;\n error:\n\tfor (i = 0; i < new_triggers.n_patterns; i++)\n\t\tkfree(new_triggers.patterns[i].mask);\n\tkfree(new_triggers.patterns);\n\treturn err;\n}\n\n#define NL80211_FLAG_NEED_WIPHY\t\t0x01\n#define NL80211_FLAG_NEED_NETDEV\t0x02\n#define NL80211_FLAG_NEED_RTNL\t\t0x04\n#define NL80211_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL80211_FLAG_NEED_NETDEV_UP\t(NL80211_FLAG_NEED_NETDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n\nstatic int nl80211_pre_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *dev;\n\tint err;\n\tbool rtnl = ops->internal_flags & NL80211_FLAG_NEED_RTNL;\n\n\tif (rtnl)\n\t\trtnl_lock();\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_WIPHY) {\n\t\trdev = cfg80211_get_dev_from_info(info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {\n\t\terr = get_rdev_dev_by_info_ifindex(info, &rdev, &dev);\n\t\tif (err) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn err;\n\t\t}\n\t\tif (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&\n\t\t    !netif_running(dev)) {\n\t\t\tcfg80211_unlock_rdev(rdev);\n\t\t\tdev_put(dev);\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn -ENETDOWN;\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t\tinfo->user_ptr[1] = dev;\n\t}\n\n\treturn 0;\n}\n\nstatic void nl80211_post_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tif (info->user_ptr[0])\n\t\tcfg80211_unlock_rdev(info->user_ptr[0]);\n\tif (info->user_ptr[1])\n\t\tdev_put(info->user_ptr[1]);\n\tif (ops->internal_flags & NL80211_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n}\n\nstatic struct genl_ops nl80211_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_GET_WIPHY,\n\t\t.doit = nl80211_get_wiphy,\n\t\t.dumpit = nl80211_dump_wiphy,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY,\n\t\t.doit = nl80211_set_wiphy,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_INTERFACE,\n\t\t.doit = nl80211_get_interface,\n\t\t.dumpit = nl80211_dump_interface,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_INTERFACE,\n\t\t.doit = nl80211_set_interface,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_INTERFACE,\n\t\t.doit = nl80211_new_interface,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_INTERFACE,\n\t\t.doit = nl80211_del_interface,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_KEY,\n\t\t.doit = nl80211_get_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_KEY,\n\t\t.doit = nl80211_set_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_KEY,\n\t\t.doit = nl80211_new_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_KEY,\n\t\t.doit = nl80211_del_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BEACON,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = nl80211_addset_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_BEACON,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = nl80211_addset_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_BEACON,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = nl80211_del_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_STATION,\n\t\t.doit = nl80211_get_station,\n\t\t.dumpit = nl80211_dump_station,\n\t\t.policy = nl80211_policy,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_STATION,\n\t\t.doit = nl80211_set_station,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_STATION,\n\t\t.doit = nl80211_new_station,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_STATION,\n\t\t.doit = nl80211_del_station,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPATH,\n\t\t.doit = nl80211_get_mpath,\n\t\t.dumpit = nl80211_dump_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MPATH,\n\t\t.doit = nl80211_set_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_MPATH,\n\t\t.doit = nl80211_new_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_MPATH,\n\t\t.doit = nl80211_del_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BSS,\n\t\t.doit = nl80211_set_bss,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_REG,\n\t\t.doit = nl80211_get_reg,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_REG,\n\t\t.doit = nl80211_set_reg,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REQ_SET_REG,\n\t\t.doit = nl80211_req_set_reg,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MESH_CONFIG,\n\t\t.doit = nl80211_get_mesh_config,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MESH_CONFIG,\n\t\t.doit = nl80211_update_mesh_config,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TRIGGER_SCAN,\n\t\t.doit = nl80211_trigger_scan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SCAN,\n\t\t.policy = nl80211_policy,\n\t\t.dumpit = nl80211_dump_scan,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_SCHED_SCAN,\n\t\t.doit = nl80211_start_sched_scan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_SCHED_SCAN,\n\t\t.doit = nl80211_stop_sched_scan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_AUTHENTICATE,\n\t\t.doit = nl80211_authenticate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ASSOCIATE,\n\t\t.doit = nl80211_associate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEAUTHENTICATE,\n\t\t.doit = nl80211_deauthenticate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISASSOCIATE,\n\t\t.doit = nl80211_disassociate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_IBSS,\n\t\t.doit = nl80211_join_ibss,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_IBSS,\n\t\t.doit = nl80211_leave_ibss,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#ifdef CONFIG_NL80211_TESTMODE\n\t{\n\t\t.cmd = NL80211_CMD_TESTMODE,\n\t\t.doit = nl80211_testmode_do,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_CONNECT,\n\t\t.doit = nl80211_connect,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISCONNECT,\n\t\t.doit = nl80211_disconnect,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY_NETNS,\n\t\t.doit = nl80211_wiphy_netns,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SURVEY,\n\t\t.policy = nl80211_policy,\n\t\t.dumpit = nl80211_dump_survey,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMKSA,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMKSA,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FLUSH_PMKSA,\n\t\t.doit = nl80211_flush_pmksa,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t.doit = nl80211_remain_on_channel,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t.doit = nl80211_cancel_remain_on_channel,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TX_BITRATE_MASK,\n\t\t.doit = nl80211_set_tx_bitrate_mask,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_FRAME,\n\t\t.doit = nl80211_register_mgmt,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME,\n\t\t.doit = nl80211_tx_mgmt,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t.doit = nl80211_tx_mgmt_cancel_wait,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_POWER_SAVE,\n\t\t.doit = nl80211_set_power_save,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_POWER_SAVE,\n\t\t.doit = nl80211_get_power_save,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CQM,\n\t\t.doit = nl80211_set_cqm,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CHANNEL,\n\t\t.doit = nl80211_set_channel,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WDS_PEER,\n\t\t.doit = nl80211_set_wds_peer,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_MESH,\n\t\t.doit = nl80211_join_mesh,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_MESH,\n\t\t.doit = nl80211_leave_mesh,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_WOWLAN,\n\t\t.doit = nl80211_get_wowlan,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WOWLAN,\n\t\t.doit = nl80211_set_wowlan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n};\n\nstatic struct genl_multicast_group nl80211_mlme_mcgrp = {\n\t.name = \"mlme\",\n};\n\n/* multicast groups */\nstatic struct genl_multicast_group nl80211_config_mcgrp = {\n\t.name = \"config\",\n};\nstatic struct genl_multicast_group nl80211_scan_mcgrp = {\n\t.name = \"scan\",\n};\nstatic struct genl_multicast_group nl80211_regulatory_mcgrp = {\n\t.name = \"regulatory\",\n};\n\n/* notification functions */\n\nvoid nl80211_notify_dev_rename(struct cfg80211_registered_device *rdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_wiphy(msg, 0, 0, 0, rdev) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_config_mcgrp.id, GFP_KERNEL);\n}\n\nstatic int nl80211_add_scan_req(struct sk_buff *msg,\n\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *req = rdev->scan_req;\n\tstruct nlattr *nest;\n\tint i;\n\n\tASSERT_RDEV_LOCK(rdev);\n\n\tif (WARN_ON(!req))\n\t\treturn 0;\n\n\tnest = nla_nest_start(msg, NL80211_ATTR_SCAN_SSIDS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_ssids; i++)\n\t\tNLA_PUT(msg, i, req->ssids[i].ssid_len, req->ssids[i].ssid);\n\tnla_nest_end(msg, nest);\n\n\tnest = nla_nest_start(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_channels; i++)\n\t\tNLA_PUT_U32(msg, i, req->channels[i]->center_freq);\n\tnla_nest_end(msg, nest);\n\n\tif (req->ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_IE, req->ie_len, req->ie);\n\n\treturn 0;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_send_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t u32 pid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl80211_send_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *netdev,\n\t\t\t    u32 pid, u32 seq, int flags, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nvoid nl80211_send_scan_start(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_scan_done(struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_NEW_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_SCAN_ABORTED) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t\tNL80211_CMD_SCHED_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\n/*\n * This can happen on global regulatory changes or device specific settings\n * based on custom world regulatory domains.\n */\nvoid nl80211_send_reg_change_event(struct regulatory_request *request)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_CHANGE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/* Userspace can always count this one always being set */\n\tNLA_PUT_U8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator);\n\n\tif (request->alpha2[0] == '0' && request->alpha2[1] == '0')\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_WORLD);\n\telse if (request->alpha2[0] == '9' && request->alpha2[1] == '9')\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_CUSTOM_WORLD);\n\telse if ((request->alpha2[0] == '9' && request->alpha2[1] == '8') ||\n\t\t request->intersect)\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_INTERSECTION);\n\telse {\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_COUNTRY);\n\t\tNLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2, request->alpha2);\n\t}\n\n\tif (wiphy_idx_valid(request->wiphy_idx))\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(msg, 0, nl80211_regulatory_mcgrp.id,\n\t\t\t\tGFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    enum nl80211_commands cmd, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_FRAME, len, buf);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_AUTHENTICATE, gfp);\n}\n\nvoid nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_ASSOCIATE, gfp);\n}\n\nvoid nl80211_send_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *buf,\n\t\t\t size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DEAUTHENTICATE, gfp);\n}\n\nvoid nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp);\n}\n\nvoid nl80211_send_unprot_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *buf,\n\t\t\t\tsize_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_UNPROT_DEAUTHENTICATE, gfp);\n}\n\nvoid nl80211_send_unprot_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_UNPROT_DISASSOCIATE, gfp);\n}\n\nstatic void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct net_device *netdev, int cmd,\n\t\t\t\t      const u8 *addr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT_FLAG(msg, NL80211_ATTR_TIMED_OUT);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, const u8 *addr,\n\t\t\t       gfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_AUTHENTICATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_assoc_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *addr,\n\t\t\t\tgfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_ASSOCIATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_connect_result(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *bssid,\n\t\t\t\t const u8 *req_ie, size_t req_ie_len,\n\t\t\t\t const u8 *resp_ie, size_t resp_ie_len,\n\t\t\t\t u16 status, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tif (bssid)\n\t\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);\n\tNLA_PUT_U16(msg, NL80211_ATTR_STATUS_CODE, status);\n\tif (req_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_REQ_IE, req_ie_len, req_ie);\n\tif (resp_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_RESP_IE, resp_ie_len, resp_ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\n}\n\nvoid nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *bssid,\n\t\t\t const u8 *req_ie, size_t req_ie_len,\n\t\t\t const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);\n\tif (req_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_REQ_IE, req_ie_len, req_ie);\n\tif (resp_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_RESP_IE, resp_ie_len, resp_ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\n}\n\nvoid nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tif (from_ap && reason)\n\t\tNLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);\n\tif (from_ap)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);\n\tif (ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\n}\n\nvoid nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_JOIN_IBSS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_new_peer_candidate(struct cfg80211_registered_device *rdev,\n\t\tstruct net_device *netdev,\n\t\tconst u8 *macaddr, const u8* ie, u8 ie_len,\n\t\tgfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NEW_PEER_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, macaddr);\n\tif (ie_len && ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_IE, ie_len , ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *addr,\n\t\t\t\t enum nl80211_key_type key_type, int key_id,\n\t\t\t\t const u8 *tsc, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MICHAEL_MIC_FAILURE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tif (addr)\n\t\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);\n\tNLA_PUT_U32(msg, NL80211_ATTR_KEY_TYPE, key_type);\n\tNLA_PUT_U8(msg, NL80211_ATTR_KEY_IDX, key_id);\n\tif (tsc)\n\t\tNLA_PUT(msg, NL80211_ATTR_KEY_SEQ, 6, tsc);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/*\n\t * Since we are applying the beacon hint to a wiphy we know its\n\t * wiphy_idx is valid\n\t */\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy));\n\n\t/* Before */\n\tnl_freq = nla_nest_start(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\tif (nl80211_msg_put_channel(msg, channel_before))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t/* After */\n\tnl_freq = nla_nest_start(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\tif (nl80211_msg_put_channel(msg, channel_after))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(msg, 0, nl80211_regulatory_mcgrp.id,\n\t\t\t\tGFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_remain_on_chan_event(\n\tint cmd, struct cfg80211_registered_device *rdev,\n\tstruct net_device *netdev, u64 cookie,\n\tstruct ieee80211_channel *chan,\n\tenum nl80211_channel_type channel_type,\n\tunsigned int duration, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, channel_type);\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\n\tif (cmd == NL80211_CMD_REMAIN_ON_CHANNEL)\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_DURATION, duration);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_remain_on_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev, u64 cookie,\n\t\t\t\t    struct ieee80211_channel *chan,\n\t\t\t\t    enum nl80211_channel_type channel_type,\n\t\t\t\t    unsigned int duration, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, netdev, cookie, chan,\n\t\t\t\t\t  channel_type, duration, gfp);\n}\n\nvoid nl80211_send_remain_on_channel_cancel(\n\tstruct cfg80211_registered_device *rdev, struct net_device *netdev,\n\tu64 cookie, struct ieee80211_channel *chan,\n\tenum nl80211_channel_type channel_type, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, netdev, cookie, chan,\n\t\t\t\t\t  channel_type, 0, gfp);\n}\n\nvoid nl80211_send_sta_event(struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_station(msg, 0, 0, 0, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n}\n\nvoid nl80211_send_sta_del_event(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *dev, const u8 *mac_addr,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_STATION);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nint nl80211_send_mgmt(struct cfg80211_registered_device *rdev,\n\t\t      struct net_device *netdev, u32 nlpid,\n\t\t      int freq, const u8 *buf, size_t len, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);\n\tNLA_PUT(msg, NL80211_ATTR_FRAME, len, buf);\n\n\terr = genlmsg_end(msg, hdr);\n\tif (err < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\terr = genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlpid);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid nl80211_send_mgmt_tx_status(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, u64 cookie,\n\t\t\t\t const u8 *buf, size_t len, bool ack,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME_TX_STATUS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_FRAME, len, buf);\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\tif (ack)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_ACK);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast(msg, 0, nl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid\nnl80211_send_cqm_rssi_notify(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev,\n\t\t\t     enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *pinfoattr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t    rssi_event);\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid\nnl80211_send_cqm_pktloss_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *peer,\n\t\t\t\tu32 num_packets, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *pinfoattr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, peer);\n\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets);\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nstatic int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\n\tif (state != NETLINK_URELEASE)\n\t\treturn NOTIFY_DONE;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list)\n\t\tlist_for_each_entry_rcu(wdev, &rdev->netdev_list, list)\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->pid);\n\n\trcu_read_unlock();\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nl80211_netlink_notifier = {\n\t.notifier_call = nl80211_netlink_notify,\n};\n\n/* initialisation/exit functions */\n\nint nl80211_init(void)\n{\n\tint err;\n\n\terr = genl_register_family_with_ops(&nl80211_fam,\n\t\tnl80211_ops, ARRAY_SIZE(nl80211_ops));\n\tif (err)\n\t\treturn err;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_config_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_scan_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_regulatory_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_mlme_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n#ifdef CONFIG_NL80211_TESTMODE\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_testmode_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n#endif\n\n\terr = netlink_register_notifier(&nl80211_netlink_notifier);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n err_out:\n\tgenl_unregister_family(&nl80211_fam);\n\treturn err;\n}\n\nvoid nl80211_exit(void)\n{\n\tnetlink_unregister_notifier(&nl80211_netlink_notifier);\n\tgenl_unregister_family(&nl80211_fam);\n}\n"], "fixing_code": ["/*\n * This is the new netlink-based wireless configuration interface.\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n */\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include <net/sock.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"reg.h\"\n\nstatic int nl80211_pre_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info);\nstatic void nl80211_post_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info);\n\n/* the netlink family */\nstatic struct genl_family nl80211_fam = {\n\t.id = GENL_ID_GENERATE,\t/* don't bother with a hardcoded ID */\n\t.name = \"nl80211\",\t/* have users key off the name instead */\n\t.hdrsize = 0,\t\t/* no private header */\n\t.version = 1,\t\t/* no particular meaning now */\n\t.maxattr = NL80211_ATTR_MAX,\n\t.netnsok = true,\n\t.pre_doit = nl80211_pre_doit,\n\t.post_doit = nl80211_post_doit,\n};\n\n/* internal helper: get rdev and dev */\nstatic int get_rdev_dev_by_info_ifindex(struct genl_info *info,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct net_device **dev)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tint ifindex;\n\n\tif (!attrs[NL80211_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\t*dev = dev_get_by_index(genl_info_net(info), ifindex);\n\tif (!*dev)\n\t\treturn -ENODEV;\n\n\t*rdev = cfg80211_get_dev_from_ifindex(genl_info_net(info), ifindex);\n\tif (IS_ERR(*rdev)) {\n\t\tdev_put(*dev);\n\t\treturn PTR_ERR(*rdev);\n\t}\n\n\treturn 0;\n}\n\n/* policy for the attributes */\nstatic const struct nla_policy nl80211_policy[NL80211_ATTR_MAX+1] = {\n\t[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t      .len = 20-1 },\n\t[NL80211_ATTR_WIPHY_TXQ_PARAMS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WIPHY_FREQ] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_CHANNEL_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RETRY_SHORT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_RETRY_LONG] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_FRAG_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RTS_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_COVERAGE_CLASS] = { .type = NLA_U8 },\n\n\t[NL80211_ATTR_IFTYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL80211_ATTR_MAC] = { .type = NLA_BINARY, .len = ETH_ALEN },\n\t[NL80211_ATTR_PREV_BSSID] = { .type = NLA_BINARY, .len = ETH_ALEN },\n\n\t[NL80211_ATTR_KEY] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_KEY_DATA] = { .type = NLA_BINARY,\n\t\t\t\t    .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_ATTR_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_ATTR_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_ATTR_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_SEQ] = { .type = NLA_BINARY, .len = 8 },\n\t[NL80211_ATTR_KEY_TYPE] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_BEACON_HEAD] = { .type = NLA_BINARY,\n\t\t\t\t       .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_BEACON_TAIL] = { .type = NLA_BINARY,\n\t\t\t\t       .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_STA_AID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t       .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_STA_PLINK_ACTION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MNTR_FLAGS] = { /* NLA_NESTED can't be empty */ },\n\t[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_MESH_ID_LEN },\n\t[NL80211_ATTR_MPATH_NEXT_HOP] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_REG_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_PREAMBLE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_SLOT_TIME] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_BASIC_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t   .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_BSS_HT_OPMODE] = { .type = NLA_U16 },\n\n\t[NL80211_ATTR_MESH_CONFIG] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SUPPORT_MESH_AUTH] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_HT_CAPABILITY] = { .type = NLA_BINARY,\n\t\t\t\t\t .len = NL80211_HT_CAPABILITY_LEN },\n\n\t[NL80211_ATTR_MGMT_SUBTYPE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_IE] = { .type = NLA_BINARY,\n\t\t\t      .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_SCAN_FREQUENCIES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SSIDS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_ATTR_AUTH_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REASON_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FREQ_FIXED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TIMED_OUT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_USE_MFP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_STA_FLAGS2] = {\n\t\t.len = sizeof(struct nl80211_sta_flag_update),\n\t},\n\t[NL80211_ATTR_CONTROL_PORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_ETHERTYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PRIVACY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CIPHER_SUITE_GROUP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_PID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_PMKID] = { .type = NLA_BINARY,\n\t\t\t\t .len = WLAN_PMKID_LEN },\n\t[NL80211_ATTR_DURATION] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_FRAME_MATCH] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_PS_STATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_LOCAL_STATE_CHANGE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_ISOLATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_SETTING] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FRAME_TYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_TX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_RX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MCAST_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_OFFCHANNEL_TX_OK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_PLINK_STATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },\n};\n\n/* policy for the key attributes */\nstatic const struct nla_policy nl80211_key_policy[NL80211_KEY_MAX + 1] = {\n\t[NL80211_KEY_DATA] = { .type = NLA_BINARY, .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_KEY_SEQ] = { .type = NLA_BINARY, .len = 8 },\n\t[NL80211_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_MGMT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_TYPE] = { .type = NLA_U32 },\n\t[NL80211_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n};\n\n/* policy for the key default flags */\nstatic const struct nla_policy\nnl80211_key_default_policy[NUM_NL80211_KEY_DEFAULT_TYPES] = {\n\t[NL80211_KEY_DEFAULT_TYPE_UNICAST] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_TYPE_MULTICAST] = { .type = NLA_FLAG },\n};\n\n/* policy for WoWLAN attributes */\nstatic const struct nla_policy\nnl80211_wowlan_policy[NUM_NL80211_WOWLAN_TRIG] = {\n\t[NL80211_WOWLAN_TRIG_ANY] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_DISCONNECT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_MAGIC_PKT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_PKT_PATTERN] = { .type = NLA_NESTED },\n};\n\n/* ifidx get helper */\nstatic int nl80211_get_ifidx(struct netlink_callback *cb)\n{\n\tint res;\n\n\tres = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t  nl80211_fam.attrbuf, nl80211_fam.maxattr,\n\t\t\t  nl80211_policy);\n\tif (res)\n\t\treturn res;\n\n\tif (!nl80211_fam.attrbuf[NL80211_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tres = nla_get_u32(nl80211_fam.attrbuf[NL80211_ATTR_IFINDEX]);\n\tif (!res)\n\t\treturn -EINVAL;\n\treturn res;\n}\n\nstatic int nl80211_prepare_netdev_dump(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct net_device **dev)\n{\n\tint ifidx = cb->args[0];\n\tint err;\n\n\tif (!ifidx)\n\t\tifidx = nl80211_get_ifidx(cb);\n\tif (ifidx < 0)\n\t\treturn ifidx;\n\n\tcb->args[0] = ifidx;\n\n\trtnl_lock();\n\n\t*dev = __dev_get_by_index(sock_net(skb->sk), ifidx);\n\tif (!*dev) {\n\t\terr = -ENODEV;\n\t\tgoto out_rtnl;\n\t}\n\n\t*rdev = cfg80211_get_dev_from_ifindex(sock_net(skb->sk), ifidx);\n\tif (IS_ERR(*rdev)) {\n\t\terr = PTR_ERR(*rdev);\n\t\tgoto out_rtnl;\n\t}\n\n\treturn 0;\n out_rtnl:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic void nl80211_finish_netdev_dump(struct cfg80211_registered_device *rdev)\n{\n\tcfg80211_unlock_rdev(rdev);\n\trtnl_unlock();\n}\n\n/* IE validation */\nstatic bool is_valid_ie_attr(const struct nlattr *attr)\n{\n\tconst u8 *pos;\n\tint len;\n\n\tif (!attr)\n\t\treturn true;\n\n\tpos = nla_data(attr);\n\tlen = nla_len(attr);\n\n\twhile (len) {\n\t\tu8 elemlen;\n\n\t\tif (len < 2)\n\t\t\treturn false;\n\t\tlen -= 2;\n\n\t\telemlen = pos[1];\n\t\tif (elemlen > len)\n\t\t\treturn false;\n\n\t\tlen -= elemlen;\n\t\tpos += 2 + elemlen;\n\t}\n\n\treturn true;\n}\n\n/* message building helper */\nstatic inline void *nl80211hdr_put(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t   int flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, pid, seq, &nl80211_fam, flags, cmd);\n}\n\nstatic int nl80211_msg_put_channel(struct sk_buff *msg,\n\t\t\t\t   struct ieee80211_channel *chan)\n{\n\tNLA_PUT_U32(msg, NL80211_FREQUENCY_ATTR_FREQ,\n\t\t    chan->center_freq);\n\n\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_DISABLED);\n\tif (chan->flags & IEEE80211_CHAN_PASSIVE_SCAN)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_PASSIVE_SCAN);\n\tif (chan->flags & IEEE80211_CHAN_NO_IBSS)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_NO_IBSS);\n\tif (chan->flags & IEEE80211_CHAN_RADAR)\n\t\tNLA_PUT_FLAG(msg, NL80211_FREQUENCY_ATTR_RADAR);\n\n\tNLA_PUT_U32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,\n\t\t    DBM_TO_MBM(chan->max_power));\n\n\treturn 0;\n\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\n/* netlink command implementations */\n\nstruct key_parse {\n\tstruct key_params p;\n\tint idx;\n\tint type;\n\tbool def, defmgmt;\n\tbool def_uni, def_multi;\n};\n\nstatic int nl80211_parse_key_new(struct nlattr *key, struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested(tb, NL80211_KEY_MAX, key,\n\t\t\t\t   nl80211_key_policy);\n\tif (err)\n\t\treturn err;\n\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\n\tif (tb[NL80211_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested(kdt,\n\t\t\t\t\t   NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t   tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t\t   nl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key_old(struct genl_info *info, struct key_parse *k)\n{\n\tif (info->attrs[NL80211_ATTR_KEY_DATA]) {\n\t\tk->p.key = nla_data(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t\tk->p.key_len = nla_len(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tk->idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(info->attrs[NL80211_ATTR_KEY_CIPHER]);\n\n\tk->def = !!info->attrs[NL80211_ATTR_KEY_DEFAULT];\n\tk->defmgmt = !!info->attrs[NL80211_ATTR_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested(\n\t\t\t\tkdt, NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\tinfo->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES],\n\t\t\t\tnl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\n\tif (err)\n\t\treturn err;\n\n\tif (k->def && k->defmgmt)\n\t\treturn -EINVAL;\n\n\tif (k->defmgmt) {\n\t\tif (k->def_uni || !k->def_multi)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 5)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_cached_keys *\nnl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct nlattr *keys)\n{\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\tresult->defmgmt = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 4)\n\t\t\tgoto error;\n\t\tif (parse.def) {\n\t\t\tif (def)\n\t\t\t\tgoto error;\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_key_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!wdev->current_bss)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->sme_state != CFG80211_SME_CONNECTED)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start(msg, attr);\n\tint i;\n\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif (ifmodes & 1)\n\t\t\tNLA_PUT_FLAG(msg, i);\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t\t  struct sk_buff *msg)\n{\n\tstruct nlattr *nl_combis;\n\tint i, j;\n\n\tnl_combis = nla_nest_start(msg,\n\t\t\t\tNL80211_ATTR_INTERFACE_COMBINATIONS);\n\tif (!nl_combis)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct nlattr *nl_combi, *nl_limits;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tnl_combi = nla_nest_start(msg, i + 1);\n\t\tif (!nl_combi)\n\t\t\tgoto nla_put_failure;\n\n\t\tnl_limits = nla_nest_start(msg, NL80211_IFACE_COMB_LIMITS);\n\t\tif (!nl_limits)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tstruct nlattr *nl_limit;\n\n\t\t\tnl_limit = nla_nest_start(msg, j + 1);\n\t\t\tif (!nl_limit)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tNLA_PUT_U32(msg, NL80211_IFACE_LIMIT_MAX,\n\t\t\t\t    c->limits[j].max);\n\t\t\tif (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,\n\t\t\t\t\t\tc->limits[j].types))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(msg, nl_limit);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_limits);\n\n\t\tif (c->beacon_int_infra_match)\n\t\t\tNLA_PUT_FLAG(msg,\n\t\t\t\tNL80211_IFACE_COMB_STA_AP_BI_MATCH);\n\t\tNLA_PUT_U32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,\n\t\t\t    c->num_different_channels);\n\t\tNLA_PUT_U32(msg, NL80211_IFACE_COMB_MAXNUM,\n\t\t\t    c->max_interfaces);\n\n\t\tnla_nest_end(msg, nl_combi);\n\t}\n\n\tnla_nest_end(msg, nl_combis);\n\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_send_wiphy(struct sk_buff *msg, u32 pid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *dev)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_bands, *nl_band;\n\tstruct nlattr *nl_freqs, *nl_freq;\n\tstruct nlattr *nl_rates, *nl_rate;\n\tstruct nlattr *nl_cmds;\n\tenum ieee80211_band band;\n\tstruct ieee80211_channel *chan;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes =\n\t\t\t\tdev->wiphy.mgmt_stypes;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_WIPHY);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, dev->wiphy_idx);\n\tNLA_PUT_STRING(msg, NL80211_ATTR_WIPHY_NAME, wiphy_name(&dev->wiphy));\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION,\n\t\t    cfg80211_rdev_list_generation);\n\n\tNLA_PUT_U8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,\n\t\t   dev->wiphy.retry_short);\n\tNLA_PUT_U8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,\n\t\t   dev->wiphy.retry_long);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,\n\t\t    dev->wiphy.frag_threshold);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,\n\t\t    dev->wiphy.rts_threshold);\n\tNLA_PUT_U8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,\n\t\t    dev->wiphy.coverage_class);\n\tNLA_PUT_U8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,\n\t\t   dev->wiphy.max_scan_ssids);\n\tNLA_PUT_U16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,\n\t\t    dev->wiphy.max_scan_ie_len);\n\n\tif (dev->wiphy.flags & WIPHY_FLAG_IBSS_RSN)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_SUPPORT_IBSS_RSN);\n\tif (dev->wiphy.flags & WIPHY_FLAG_MESH_AUTH)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_SUPPORT_MESH_AUTH);\n\n\tNLA_PUT(msg, NL80211_ATTR_CIPHER_SUITES,\n\t\tsizeof(u32) * dev->wiphy.n_cipher_suites,\n\t\tdev->wiphy.cipher_suites);\n\n\tNLA_PUT_U8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,\n\t\t   dev->wiphy.max_num_pmkids);\n\n\tif (dev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,\n\t\t    dev->wiphy.available_antennas_tx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,\n\t\t    dev->wiphy.available_antennas_rx);\n\n\tif ((dev->wiphy.available_antennas_tx ||\n\t     dev->wiphy.available_antennas_rx) && dev->ops->get_antenna) {\n\t\tu32 tx_ant = 0, rx_ant = 0;\n\t\tint res;\n\t\tres = dev->ops->get_antenna(&dev->wiphy, &tx_ant, &rx_ant);\n\t\tif (!res) {\n\t\t\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_TX, tx_ant);\n\t\t\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_ANTENNA_RX, rx_ant);\n\t\t}\n\t}\n\n\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,\n\t\t\t\tdev->wiphy.interface_modes))\n\t\tgoto nla_put_failure;\n\n\tnl_bands = nla_nest_start(msg, NL80211_ATTR_WIPHY_BANDS);\n\tif (!nl_bands)\n\t\tgoto nla_put_failure;\n\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tif (!dev->wiphy.bands[band])\n\t\t\tcontinue;\n\n\t\tnl_band = nla_nest_start(msg, band);\n\t\tif (!nl_band)\n\t\t\tgoto nla_put_failure;\n\n\t\t/* add HT info */\n\t\tif (dev->wiphy.bands[band]->ht_cap.ht_supported) {\n\t\t\tNLA_PUT(msg, NL80211_BAND_ATTR_HT_MCS_SET,\n\t\t\t\tsizeof(dev->wiphy.bands[band]->ht_cap.mcs),\n\t\t\t\t&dev->wiphy.bands[band]->ht_cap.mcs);\n\t\t\tNLA_PUT_U16(msg, NL80211_BAND_ATTR_HT_CAPA,\n\t\t\t\tdev->wiphy.bands[band]->ht_cap.cap);\n\t\t\tNLA_PUT_U8(msg, NL80211_BAND_ATTR_HT_AMPDU_FACTOR,\n\t\t\t\tdev->wiphy.bands[band]->ht_cap.ampdu_factor);\n\t\t\tNLA_PUT_U8(msg, NL80211_BAND_ATTR_HT_AMPDU_DENSITY,\n\t\t\t\tdev->wiphy.bands[band]->ht_cap.ampdu_density);\n\t\t}\n\n\t\t/* add frequencies */\n\t\tnl_freqs = nla_nest_start(msg, NL80211_BAND_ATTR_FREQS);\n\t\tif (!nl_freqs)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < dev->wiphy.bands[band]->n_channels; i++) {\n\t\t\tnl_freq = nla_nest_start(msg, i);\n\t\t\tif (!nl_freq)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tchan = &dev->wiphy.bands[band]->channels[i];\n\n\t\t\tif (nl80211_msg_put_channel(msg, chan))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, nl_freq);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_freqs);\n\n\t\t/* add bitrates */\n\t\tnl_rates = nla_nest_start(msg, NL80211_BAND_ATTR_RATES);\n\t\tif (!nl_rates)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < dev->wiphy.bands[band]->n_bitrates; i++) {\n\t\t\tnl_rate = nla_nest_start(msg, i);\n\t\t\tif (!nl_rate)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\trate = &dev->wiphy.bands[band]->bitrates[i];\n\t\t\tNLA_PUT_U32(msg, NL80211_BITRATE_ATTR_RATE,\n\t\t\t\t    rate->bitrate);\n\t\t\tif (rate->flags & IEEE80211_RATE_SHORT_PREAMBLE)\n\t\t\t\tNLA_PUT_FLAG(msg,\n\t\t\t\t\tNL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE);\n\n\t\t\tnla_nest_end(msg, nl_rate);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_rates);\n\n\t\tnla_nest_end(msg, nl_band);\n\t}\n\tnla_nest_end(msg, nl_bands);\n\n\tnl_cmds = nla_nest_start(msg, NL80211_ATTR_SUPPORTED_COMMANDS);\n\tif (!nl_cmds)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n#define CMD(op, n)\t\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\\\n\t\tif (dev->ops->op) {\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\\\n\t\t\tNLA_PUT_U32(msg, i, NL80211_CMD_ ## n);\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(change_virtual_intf, SET_INTERFACE);\n\tCMD(add_key, NEW_KEY);\n\tCMD(add_beacon, NEW_BEACON);\n\tCMD(add_station, NEW_STATION);\n\tCMD(add_mpath, NEW_MPATH);\n\tCMD(update_mesh_config, SET_MESH_CONFIG);\n\tCMD(change_bss, SET_BSS);\n\tCMD(auth, AUTHENTICATE);\n\tCMD(assoc, ASSOCIATE);\n\tCMD(deauth, DEAUTHENTICATE);\n\tCMD(disassoc, DISASSOCIATE);\n\tCMD(join_ibss, JOIN_IBSS);\n\tCMD(join_mesh, JOIN_MESH);\n\tCMD(set_pmksa, SET_PMKSA);\n\tCMD(del_pmksa, DEL_PMKSA);\n\tCMD(flush_pmksa, FLUSH_PMKSA);\n\tCMD(remain_on_channel, REMAIN_ON_CHANNEL);\n\tCMD(set_bitrate_mask, SET_TX_BITRATE_MASK);\n\tCMD(mgmt_tx, FRAME);\n\tCMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);\n\tif (dev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {\n\t\ti++;\n\t\tNLA_PUT_U32(msg, i, NL80211_CMD_SET_WIPHY_NETNS);\n\t}\n\tCMD(set_channel, SET_CHANNEL);\n\tCMD(set_wds_peer, SET_WDS_PEER);\n\tif (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN)\n\t\tCMD(sched_scan_start, START_SCHED_SCAN);\n\n#undef CMD\n\n\tif (dev->ops->connect || dev->ops->auth) {\n\t\ti++;\n\t\tNLA_PUT_U32(msg, i, NL80211_CMD_CONNECT);\n\t}\n\n\tif (dev->ops->disconnect || dev->ops->deauth) {\n\t\ti++;\n\t\tNLA_PUT_U32(msg, i, NL80211_CMD_DISCONNECT);\n\t}\n\n\tnla_nest_end(msg, nl_cmds);\n\n\tif (dev->ops->remain_on_channel)\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,\n\t\t\t    dev->wiphy.max_remain_on_channel_duration);\n\n\t/* for now at least assume all drivers have it */\n\tif (dev->ops->mgmt_tx)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_OFFCHANNEL_TX_OK);\n\n\tif (mgmt_stypes) {\n\t\tu16 stypes;\n\t\tstruct nlattr *nl_ftypes, *nl_ifs;\n\t\tenum nl80211_iftype ift;\n\n\t\tnl_ifs = nla_nest_start(msg, NL80211_ATTR_TX_FRAME_TYPES);\n\t\tif (!nl_ifs)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\t\tnl_ftypes = nla_nest_start(msg, ift);\n\t\t\tif (!nl_ftypes)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ti = 0;\n\t\t\tstypes = mgmt_stypes[ift].tx;\n\t\t\twhile (stypes) {\n\t\t\t\tif (stypes & 1)\n\t\t\t\t\tNLA_PUT_U16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t\t    (i << 4) | IEEE80211_FTYPE_MGMT);\n\t\t\t\tstypes >>= 1;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nl_ftypes);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_ifs);\n\n\t\tnl_ifs = nla_nest_start(msg, NL80211_ATTR_RX_FRAME_TYPES);\n\t\tif (!nl_ifs)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\t\tnl_ftypes = nla_nest_start(msg, ift);\n\t\t\tif (!nl_ftypes)\n\t\t\t\tgoto nla_put_failure;\n\t\t\ti = 0;\n\t\t\tstypes = mgmt_stypes[ift].rx;\n\t\t\twhile (stypes) {\n\t\t\t\tif (stypes & 1)\n\t\t\t\t\tNLA_PUT_U16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t\t    (i << 4) | IEEE80211_FTYPE_MGMT);\n\t\t\t\tstypes >>= 1;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nl_ftypes);\n\t\t}\n\t\tnla_nest_end(msg, nl_ifs);\n\t}\n\n\tif (dev->wiphy.wowlan.flags || dev->wiphy.wowlan.n_patterns) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start(msg,\n\t\t\t\tNL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_ANY)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_ANY);\n\t\tif (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_DISCONNECT)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_DISCONNECT);\n\t\tif (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_MAGIC_PKT)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT);\n\t\tif (dev->wiphy.wowlan.n_patterns) {\n\t\t\tstruct nl80211_wowlan_pattern_support pat = {\n\t\t\t\t.max_patterns = dev->wiphy.wowlan.n_patterns,\n\t\t\t\t.min_pattern_len =\n\t\t\t\t\tdev->wiphy.wowlan.pattern_min_len,\n\t\t\t\t.max_pattern_len =\n\t\t\t\t\tdev->wiphy.wowlan.pattern_max_len,\n\t\t\t};\n\t\t\tNLA_PUT(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t\tsizeof(pat), &pat);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,\n\t\t\t\tdev->wiphy.software_iftypes))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_put_iface_combinations(&dev->wiphy, msg))\n\t\tgoto nla_put_failure;\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tint start = cb->args[0];\n\tstruct cfg80211_registered_device *dev;\n\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(dev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&dev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_wiphy(skb, NETLINK_CB(cb->skb).pid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       dev) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&cfg80211_mutex);\n\n\tcb->args[0] = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *dev = info->user_ptr[0];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_wiphy(msg, info->snd_pid, info->snd_seq, 0, dev) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy txq_params_policy[NL80211_TXQ_ATTR_MAX + 1] = {\n\t[NL80211_TXQ_ATTR_QUEUE]\t\t= { .type = NLA_U8 },\n\t[NL80211_TXQ_ATTR_TXOP]\t\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMIN]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMAX]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_AIFS]\t\t\t= { .type = NLA_U8 },\n};\n\nstatic int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tif (!tb[NL80211_TXQ_ATTR_QUEUE] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\n\ttxq_params->queue = nla_get_u8(tb[NL80211_TXQ_ATTR_QUEUE]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\n\treturn 0;\n}\n\nstatic bool nl80211_can_set_dev_channel(struct wireless_dev *wdev)\n{\n\t/*\n\t * You can only set the channel explicitly for AP, mesh\n\t * and WDS type interfaces; all others have their channel\n\t * managed via their respective \"establish a connection\"\n\t * command (connect, join, ...)\n\t *\n\t * Monitors are special as they are normally slaved to\n\t * whatever else is going on, so they behave as though\n\t * you tried setting the wiphy channel itself.\n\t */\n\treturn !wdev ||\n\t\twdev->iftype == NL80211_IFTYPE_AP ||\n\t\twdev->iftype == NL80211_IFTYPE_WDS ||\n\t\twdev->iftype == NL80211_IFTYPE_MESH_POINT ||\n\t\twdev->iftype == NL80211_IFTYPE_MONITOR ||\n\t\twdev->iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nstatic int __nl80211_set_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t struct genl_info *info)\n{\n\tenum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;\n\tu32 freq;\n\tint result;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!nl80211_can_set_dev_channel(wdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tchannel_type = nla_get_u32(info->attrs[\n\t\t\t\t   NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\t\tif (channel_type != NL80211_CHAN_NO_HT &&\n\t\t    channel_type != NL80211_CHAN_HT20 &&\n\t\t    channel_type != NL80211_CHAN_HT40PLUS &&\n\t\t    channel_type != NL80211_CHAN_HT40MINUS)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\n\tmutex_lock(&rdev->devlist_mtx);\n\tif (wdev) {\n\t\twdev_lock(wdev);\n\t\tresult = cfg80211_set_freq(rdev, wdev, freq, channel_type);\n\t\twdev_unlock(wdev);\n\t} else {\n\t\tresult = cfg80211_set_freq(rdev, NULL, freq, channel_type);\n\t}\n\tmutex_unlock(&rdev->devlist_mtx);\n\n\treturn result;\n}\n\nstatic int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\treturn __nl80211_set_channel(rdev, netdev->ieee80211_ptr, info);\n}\n\nstatic int nl80211_set_wds_peer(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *bssid;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\tif (!rdev->ops->set_wds_peer)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_WDS)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\treturn rdev->ops->set_wds_peer(wdev->wiphy, dev, bssid);\n}\n\n\nstatic int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *netdev = NULL;\n\tstruct wireless_dev *wdev;\n\tint result = 0, rem_txq_params = 0;\n\tstruct nlattr *nl_txq_params;\n\tu32 changed;\n\tu8 retry_short = 0, retry_long = 0;\n\tu32 frag_threshold = 0, rts_threshold = 0;\n\tu8 coverage_class = 0;\n\n\t/*\n\t * Try to find the wiphy and netdev. Normally this\n\t * function shouldn't need the netdev, but this is\n\t * done for backward compatibility -- previously\n\t * setting the channel was done per wiphy, but now\n\t * it is per netdev. Previous userland like hostapd\n\t * also passed a netdev to set_wiphy, so that it is\n\t * possible to let that go to the right netdev!\n\t */\n\tmutex_lock(&cfg80211_mutex);\n\n\tif (info->attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = dev_get_by_index(genl_info_net(info), ifindex);\n\t\tif (netdev && netdev->ieee80211_ptr) {\n\t\t\trdev = wiphy_to_dev(netdev->ieee80211_ptr->wiphy);\n\t\t\tmutex_lock(&rdev->mtx);\n\t\t} else\n\t\t\tnetdev = NULL;\n\t}\n\n\tif (!netdev) {\n\t\trdev = __cfg80211_rdev_from_info(info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tmutex_unlock(&cfg80211_mutex);\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\twdev = NULL;\n\t\tnetdev = NULL;\n\t\tresult = 0;\n\n\t\tmutex_lock(&rdev->mtx);\n\t} else if (netif_running(netdev) &&\n\t\t   nl80211_can_set_dev_channel(netdev->ieee80211_ptr))\n\t\twdev = netdev->ieee80211_ptr;\n\telse\n\t\twdev = NULL;\n\n\t/*\n\t * end workaround code, by now the rdev is available\n\t * and locked, and wdev may or may not be NULL.\n\t */\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_NAME])\n\t\tresult = cfg80211_dev_rename(\n\t\t\trdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));\n\n\tmutex_unlock(&cfg80211_mutex);\n\n\tif (result)\n\t\tgoto bad_res;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {\n\t\tstruct ieee80211_txq_params txq_params;\n\t\tstruct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];\n\n\t\tif (!rdev->ops->set_txq_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\tnla_for_each_nested(nl_txq_params,\n\t\t\t\t    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],\n\t\t\t\t    rem_txq_params) {\n\t\t\tnla_parse(tb, NL80211_TXQ_ATTR_MAX,\n\t\t\t\t  nla_data(nl_txq_params),\n\t\t\t\t  nla_len(nl_txq_params),\n\t\t\t\t  txq_params_policy);\n\t\t\tresult = parse_txq_params(tb, &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto bad_res;\n\n\t\t\tresult = rdev->ops->set_txq_params(&rdev->wiphy,\n\t\t\t\t\t\t\t   &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto bad_res;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tresult = __nl80211_set_channel(rdev, wdev, info);\n\t\tif (result)\n\t\t\tgoto bad_res;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {\n\t\tenum nl80211_tx_power_setting type;\n\t\tint idx, mbm = 0;\n\n\t\tif (!rdev->ops->set_tx_power) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;\n\t\ttype = nla_get_u32(info->attrs[idx]);\n\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&\n\t\t    (type != NL80211_TX_POWER_AUTOMATIC)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\tif (type != NL80211_TX_POWER_AUTOMATIC) {\n\t\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;\n\t\t\tmbm = nla_get_u32(info->attrs[idx]);\n\t\t}\n\n\t\tresult = rdev->ops->set_tx_power(&rdev->wiphy, type, mbm);\n\t\tif (result)\n\t\t\tgoto bad_res;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&\n\t    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {\n\t\tu32 tx_ant, rx_ant;\n\t\tif ((!rdev->wiphy.available_antennas_tx &&\n\t\t     !rdev->wiphy.available_antennas_rx) ||\n\t\t    !rdev->ops->set_antenna) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\ttx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);\n\t\trx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);\n\n\t\t/* reject antenna configurations which don't match the\n\t\t * available antenna masks, except for the \"all\" mask */\n\t\tif ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||\n\t\t    (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx))) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\ttx_ant = tx_ant & rdev->wiphy.available_antennas_tx;\n\t\trx_ant = rx_ant & rdev->wiphy.available_antennas_rx;\n\n\t\tresult = rdev->ops->set_antenna(&rdev->wiphy, tx_ant, rx_ant);\n\t\tif (result)\n\t\t\tgoto bad_res;\n\t}\n\n\tchanged = 0;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {\n\t\tretry_short = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);\n\t\tif (retry_short == 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {\n\t\tretry_long = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);\n\t\tif (retry_long == 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {\n\t\tfrag_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);\n\t\tif (frag_threshold < 256) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto bad_res;\n\t\t}\n\t\tif (frag_threshold != (u32) -1) {\n\t\t\t/*\n\t\t\t * Fragments (apart from the last one) are required to\n\t\t\t * have even length. Make the fragmentation code\n\t\t\t * simpler by stripping LSB should someone try to use\n\t\t\t * odd threshold value.\n\t\t\t */\n\t\t\tfrag_threshold &= ~0x1;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_FRAG_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {\n\t\trts_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);\n\t\tchanged |= WIPHY_PARAM_RTS_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {\n\t\tcoverage_class = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);\n\t\tchanged |= WIPHY_PARAM_COVERAGE_CLASS;\n\t}\n\n\tif (changed) {\n\t\tu8 old_retry_short, old_retry_long;\n\t\tu32 old_frag_threshold, old_rts_threshold;\n\t\tu8 old_coverage_class;\n\n\t\tif (!rdev->ops->set_wiphy_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto bad_res;\n\t\t}\n\n\t\told_retry_short = rdev->wiphy.retry_short;\n\t\told_retry_long = rdev->wiphy.retry_long;\n\t\told_frag_threshold = rdev->wiphy.frag_threshold;\n\t\told_rts_threshold = rdev->wiphy.rts_threshold;\n\t\told_coverage_class = rdev->wiphy.coverage_class;\n\n\t\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\t\trdev->wiphy.retry_short = retry_short;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\trdev->wiphy.retry_long = retry_long;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\trdev->wiphy.frag_threshold = frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\trdev->wiphy.rts_threshold = rts_threshold;\n\t\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\t\trdev->wiphy.coverage_class = coverage_class;\n\n\t\tresult = rdev->ops->set_wiphy_params(&rdev->wiphy, changed);\n\t\tif (result) {\n\t\t\trdev->wiphy.retry_short = old_retry_short;\n\t\t\trdev->wiphy.retry_long = old_retry_long;\n\t\t\trdev->wiphy.frag_threshold = old_frag_threshold;\n\t\t\trdev->wiphy.rts_threshold = old_rts_threshold;\n\t\t\trdev->wiphy.coverage_class = old_coverage_class;\n\t\t}\n\t}\n\n bad_res:\n\tmutex_unlock(&rdev->mtx);\n\tif (netdev)\n\t\tdev_put(netdev);\n\treturn result;\n}\n\n\nstatic int nl80211_send_iface(struct sk_buff *msg, u32 pid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *rdev,\n\t\t\t      struct net_device *dev)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_INTERFACE);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, dev->name);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, dev->ieee80211_ptr->iftype);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION,\n\t\t    rdev->devlist_generation ^\n\t\t\t(cfg80211_rdev_list_generation << 2));\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif_idx = 0;\n\n\t\tmutex_lock(&rdev->devlist_mtx);\n\t\tlist_for_each_entry(wdev, &rdev->netdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).pid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev->netdev) < 0) {\n\t\t\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\t\tmutex_unlock(&rdev->devlist_mtx);\n\n\t\twp_idx++;\n\t}\n out:\n\tmutex_unlock(&cfg80211_mutex);\n\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *dev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_iface(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t       dev, netdev) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {\n\t[NL80211_MNTR_FLAG_FCSFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_PLCPFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },\n};\n\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\n\tstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\n\tint flag;\n\n\t*mntrflags = 0;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested(flags, NL80211_MNTR_FLAG_MAX,\n\t\t\t     nla, mntr_flags_policy))\n\t\treturn -EINVAL;\n\n\tfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\t*mntrflags |= (1<<flag);\n\n\treturn 0;\n}\n\nstatic int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu32 _flags, *flags = NULL;\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t\tif (ntype > NL80211_IFTYPE_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MNTR_FLAGS]) {\n\t\tif (ntype != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\t\terr = parse_monitor_flags(info->attrs[NL80211_ATTR_MNTR_FLAGS],\n\t\t\t\t\t  &_flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = &_flags;\n\t\tchange = true;\n\t}\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, flags, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\treturn err;\n}\n\nstatic int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tstruct net_device *dev;\n\tint err;\n\tenum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;\n\tu32 flags;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\ttype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (type > NL80211_IFTYPE_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->add_virtual_intf ||\n\t    !(rdev->wiphy.interface_modes & (1 << type)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\terr = nl80211_valid_4addr(rdev, NULL, params.use_4addr, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = parse_monitor_flags(type == NL80211_IFTYPE_MONITOR ?\n\t\t\t\t  info->attrs[NL80211_ATTR_MNTR_FLAGS] : NULL,\n\t\t\t\t  &flags);\n\tdev = rdev->ops->add_virtual_intf(&rdev->wiphy,\n\t\tnla_data(info->attrs[NL80211_ATTR_IFNAME]),\n\t\ttype, err ? NULL : &flags, &params);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tif (type == NL80211_IFTYPE_MESH_POINT &&\n\t    info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->del_virtual_intf(&rdev->wiphy, dev);\n}\n\nstruct get_key_cookie {\n\tstruct sk_buff *msg;\n\tint error;\n\tint idx;\n};\n\nstatic void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\n\tif (params->key)\n\t\tNLA_PUT(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t\tparams->key_len, params->key);\n\n\tif (params->seq)\n\t\tNLA_PUT(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t\tparams->seq_len, params->seq);\n\n\tif (params->cipher)\n\t\tNLA_PUT_U32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t    params->cipher);\n\n\tkey = nla_nest_start(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\n\tif (params->key)\n\t\tNLA_PUT(cookie->msg, NL80211_KEY_DATA,\n\t\t\tparams->key_len, params->key);\n\n\tif (params->seq)\n\t\tNLA_PUT(cookie->msg, NL80211_KEY_SEQ,\n\t\t\tparams->seq_len, params->seq);\n\n\tif (params->cipher)\n\t\tNLA_PUT_U32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t    params->cipher);\n\n\tNLA_PUT_U8(cookie->msg, NL80211_ATTR_KEY_IDX, cookie->idx);\n\n\tnla_nest_end(cookie->msg, key);\n\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}\n\nstatic int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 key_idx = 0;\n\tconst u8 *mac_addr = NULL;\n\tbool pairwise;\n\tstruct get_key_cookie cookie = {\n\t\t.error = 0,\n\t};\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tkey_idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (key_idx > 5)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tpairwise = !!mac_addr;\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tu32 kt = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\t\tif (kt >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t\tif (kt != NL80211_KEYTYPE_GROUP &&\n\t\t    kt != NL80211_KEYTYPE_PAIRWISE)\n\t\t\treturn -EINVAL;\n\t\tpairwise = kt == NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tif (!rdev->ops->get_key)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_NEW_KEY);\n\tif (IS_ERR(hdr))\n\t\treturn PTR_ERR(hdr);\n\n\tcookie.msg = msg;\n\tcookie.idx = key_idx;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT_U8(msg, NL80211_ATTR_KEY_IDX, key_idx);\n\tif (mac_addr)\n\t\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);\n\n\tif (pairwise && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -ENOENT;\n\n\terr = rdev->ops->get_key(&rdev->wiphy, dev, key_idx, pairwise,\n\t\t\t\t mac_addr, &cookie, get_key_callback);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (cookie.error)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct key_parse key;\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx < 0)\n\t\treturn -EINVAL;\n\n\t/* only support setting default key */\n\tif (!key.def && !key.defmgmt)\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\tif (key.def) {\n\t\tif (!rdev->ops->set_default_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev->ops->set_default_key(&rdev->wiphy, dev, key.idx,\n\t\t\t\t\t\t key.def_uni, key.def_multi);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_key = key.idx;\n#endif\n\t} else {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_mgmt_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev->ops->set_default_mgmt_key(&rdev->wiphy,\n\t\t\t\t\t\t      dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_mgmt_key = key.idx;\n#endif\n\t}\n\n out:\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_new_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct key_parse key;\n\tconst u8 *mac_addr = NULL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (!key.p.key)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->add_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cfg80211_validate_key_settings(rdev, &key.p, key.idx,\n\t\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t   mac_addr))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!err)\n\t\terr = rdev->ops->add_key(&rdev->wiphy, dev, key.idx,\n\t\t\t\t\t key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t mac_addr, &key.p);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\tstruct key_parse key;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\n\tif (key.type == NL80211_KEYTYPE_PAIRWISE && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\terr = -ENOENT;\n\n\tif (!err)\n\t\terr = rdev->ops->del_key(&rdev->wiphy, dev, key.idx,\n\t\t\t\t\t key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t mac_addr);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!err) {\n\t\tif (key.idx == dev->ieee80211_ptr->wext.default_key)\n\t\t\tdev->ieee80211_ptr->wext.default_key = -1;\n\t\telse if (key.idx == dev->ieee80211_ptr->wext.default_mgmt_key)\n\t\t\tdev->ieee80211_ptr->wext.default_mgmt_key = -1;\n\t}\n#endif\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_addset_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n        int (*call)(struct wiphy *wiphy, struct net_device *dev,\n\t\t    struct beacon_parameters *info);\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct beacon_parameters params;\n\tint haveinfo = 0, err;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_BEACON_TAIL]))\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_NEW_BEACON:\n\t\t/* these are required for NEW_BEACON */\n\t\tif (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||\n\t\t    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||\n\t\t    !info->attrs[NL80211_ATTR_BEACON_HEAD])\n\t\t\treturn -EINVAL;\n\n\t\tparams.interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\t\tparams.dtim_period =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\n\t\terr = cfg80211_validate_beacon_int(rdev, params.interval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcall = rdev->ops->add_beacon;\n\t\tbreak;\n\tcase NL80211_CMD_SET_BEACON:\n\t\tcall = rdev->ops->set_beacon;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!call)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_HEAD]) {\n\t\tparams.head = nla_data(info->attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tparams.head_len =\n\t\t    nla_len(info->attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\thaveinfo = 1;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BEACON_TAIL]) {\n\t\tparams.tail = nla_data(info->attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\tparams.tail_len =\n\t\t    nla_len(info->attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\thaveinfo = 1;\n\t}\n\n\tif (!haveinfo)\n\t\treturn -EINVAL;\n\n\terr = call(&rdev->wiphy, dev, &params);\n\tif (!err && params.interval)\n\t\twdev->beacon_interval = params.interval;\n\treturn err;\n}\n\nstatic int nl80211_del_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tif (!rdev->ops->del_beacon)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev->ops->del_beacon(&rdev->wiphy, dev);\n\tif (!err)\n\t\twdev->beacon_interval = 0;\n\treturn err;\n}\n\nstatic const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {\n\t[NL80211_STA_FLAG_AUTHORIZED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_SHORT_PREAMBLE] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_WME] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_MFP] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_AUTHENTICATED] = { .type = NLA_FLAG },\n};\n\nstatic int parse_station_flags(struct genl_info *info,\n\t\t\t       struct station_parameters *params)\n{\n\tstruct nlattr *flags[NL80211_STA_FLAG_MAX + 1];\n\tstruct nlattr *nla;\n\tint flag;\n\n\t/*\n\t * Try parsing the new attribute first so userspace\n\t * can specify both for older kernels.\n\t */\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS2];\n\tif (nla) {\n\t\tstruct nl80211_sta_flag_update *sta_flags;\n\n\t\tsta_flags = nla_data(nla);\n\t\tparams->sta_flags_mask = sta_flags->mask;\n\t\tparams->sta_flags_set = sta_flags->set;\n\t\tif ((params->sta_flags_mask |\n\t\t     params->sta_flags_set) & BIT(__NL80211_STA_FLAG_INVALID))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* if present, parse the old attribute */\n\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS];\n\tif (!nla)\n\t\treturn 0;\n\n\tif (nla_parse_nested(flags, NL80211_STA_FLAG_MAX,\n\t\t\t     nla, sta_flags_policy))\n\t\treturn -EINVAL;\n\n\tparams->sta_flags_mask = (1 << __NL80211_STA_FLAG_AFTER_LAST) - 1;\n\tparams->sta_flags_mask &= ~1;\n\n\tfor (flag = 1; flag <= NL80211_STA_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\tparams->sta_flags_set |= (1<<flag);\n\n\treturn 0;\n}\n\nstatic bool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info,\n\t\t\t\t int attr)\n{\n\tstruct nlattr *rate;\n\tu16 bitrate;\n\n\trate = nla_nest_start(msg, attr);\n\tif (!rate)\n\t\tgoto nla_put_failure;\n\n\t/* cfg80211_calculate_bitrate will return 0 for mcs >= 32 */\n\tbitrate = cfg80211_calculate_bitrate(info);\n\tif (bitrate > 0)\n\t\tNLA_PUT_U16(msg, NL80211_RATE_INFO_BITRATE, bitrate);\n\n\tif (info->flags & RATE_INFO_FLAGS_MCS)\n\t\tNLA_PUT_U8(msg, NL80211_RATE_INFO_MCS, info->mcs);\n\tif (info->flags & RATE_INFO_FLAGS_40_MHZ_WIDTH)\n\t\tNLA_PUT_FLAG(msg, NL80211_RATE_INFO_40_MHZ_WIDTH);\n\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\tNLA_PUT_FLAG(msg, NL80211_RATE_INFO_SHORT_GI);\n\n\tnla_nest_end(msg, rate);\n\treturn true;\n\nnla_put_failure:\n\treturn false;\n}\n\nstatic int nl80211_send_station(struct sk_buff *msg, u32 pid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tconst u8 *mac_addr, struct station_info *sinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *sinfoattr, *bss_param;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_STATION);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION, sinfo->generation);\n\n\tsinfoattr = nla_nest_start(msg, NL80211_ATTR_STA_INFO);\n\tif (!sinfoattr)\n\t\tgoto nla_put_failure;\n\tif (sinfo->filled & STATION_INFO_CONNECTED_TIME)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_CONNECTED_TIME,\n\t\t\t    sinfo->connected_time);\n\tif (sinfo->filled & STATION_INFO_INACTIVE_TIME)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_INACTIVE_TIME,\n\t\t\t    sinfo->inactive_time);\n\tif (sinfo->filled & STATION_INFO_RX_BYTES)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_RX_BYTES,\n\t\t\t    sinfo->rx_bytes);\n\tif (sinfo->filled & STATION_INFO_TX_BYTES)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_BYTES,\n\t\t\t    sinfo->tx_bytes);\n\tif (sinfo->filled & STATION_INFO_LLID)\n\t\tNLA_PUT_U16(msg, NL80211_STA_INFO_LLID,\n\t\t\t    sinfo->llid);\n\tif (sinfo->filled & STATION_INFO_PLID)\n\t\tNLA_PUT_U16(msg, NL80211_STA_INFO_PLID,\n\t\t\t    sinfo->plid);\n\tif (sinfo->filled & STATION_INFO_PLINK_STATE)\n\t\tNLA_PUT_U8(msg, NL80211_STA_INFO_PLINK_STATE,\n\t\t\t    sinfo->plink_state);\n\tif (sinfo->filled & STATION_INFO_SIGNAL)\n\t\tNLA_PUT_U8(msg, NL80211_STA_INFO_SIGNAL,\n\t\t\t   sinfo->signal);\n\tif (sinfo->filled & STATION_INFO_SIGNAL_AVG)\n\t\tNLA_PUT_U8(msg, NL80211_STA_INFO_SIGNAL_AVG,\n\t\t\t   sinfo->signal_avg);\n\tif (sinfo->filled & STATION_INFO_TX_BITRATE) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->txrate,\n\t\t\t\t\t  NL80211_STA_INFO_TX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & STATION_INFO_RX_BITRATE) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->rxrate,\n\t\t\t\t\t  NL80211_STA_INFO_RX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & STATION_INFO_RX_PACKETS)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_RX_PACKETS,\n\t\t\t    sinfo->rx_packets);\n\tif (sinfo->filled & STATION_INFO_TX_PACKETS)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_PACKETS,\n\t\t\t    sinfo->tx_packets);\n\tif (sinfo->filled & STATION_INFO_TX_RETRIES)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_RETRIES,\n\t\t\t    sinfo->tx_retries);\n\tif (sinfo->filled & STATION_INFO_TX_FAILED)\n\t\tNLA_PUT_U32(msg, NL80211_STA_INFO_TX_FAILED,\n\t\t\t    sinfo->tx_failed);\n\tif (sinfo->filled & STATION_INFO_BSS_PARAM) {\n\t\tbss_param = nla_nest_start(msg, NL80211_STA_INFO_BSS_PARAM);\n\t\tif (!bss_param)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (sinfo->bss_param.flags & BSS_PARAM_FLAGS_CTS_PROT)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_STA_BSS_PARAM_CTS_PROT);\n\t\tif (sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_PREAMBLE)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_STA_BSS_PARAM_SHORT_PREAMBLE);\n\t\tif (sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_SLOT_TIME)\n\t\t\tNLA_PUT_FLAG(msg,\n\t\t\t\t     NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME);\n\t\tNLA_PUT_U8(msg, NL80211_STA_BSS_PARAM_DTIM_PERIOD,\n\t\t\t   sinfo->bss_param.dtim_period);\n\t\tNLA_PUT_U16(msg, NL80211_STA_BSS_PARAM_BEACON_INTERVAL,\n\t\t\t    sinfo->bss_param.beacon_interval);\n\n\t\tnla_nest_end(msg, bss_param);\n\t}\n\tnla_nest_end(msg, sinfoattr);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_station(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct station_info sinfo;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint sta_idx = cb->args[1];\n\tint err;\n\n\terr = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!dev->ops->dump_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = dev->ops->dump_station(&dev->wiphy, netdev, sta_idx,\n\t\t\t\t\t     mac_addr, &sinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_station(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev, mac_addr,\n\t\t\t\t&sinfo) < 0)\n\t\t\tgoto out;\n\n\t\tsta_idx++;\n\t}\n\n\n out:\n\tcb->args[1] = sta_idx;\n\terr = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\n\treturn err;\n}\n\nstatic int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_info sinfo;\n\tstruct sk_buff *msg;\n\tu8 *mac_addr = NULL;\n\tint err;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev->ops->get_station(&rdev->wiphy, dev, mac_addr, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_station(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t\t dev, mac_addr, &sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\n/*\n * Get vlan interface making sure it is running and on the right wiphy.\n */\nstatic int get_vlan(struct genl_info *info,\n\t\t    struct cfg80211_registered_device *rdev,\n\t\t    struct net_device **vlan)\n{\n\tstruct nlattr *vlanattr = info->attrs[NL80211_ATTR_STA_VLAN];\n\t*vlan = NULL;\n\n\tif (vlanattr) {\n\t\t*vlan = dev_get_by_index(genl_info_net(info),\n\t\t\t\t\t nla_get_u32(vlanattr));\n\t\tif (!*vlan)\n\t\t\treturn -ENODEV;\n\t\tif (!(*vlan)->ieee80211_ptr)\n\t\t\treturn -EINVAL;\n\t\tif ((*vlan)->ieee80211_ptr->wiphy != &rdev->wiphy)\n\t\t\treturn -EINVAL;\n\t\tif (!netif_running(*vlan))\n\t\t\treturn -ENETDOWN;\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tparams.listen_interval = -1;\n\tparams.plink_state = -1;\n\n\tif (info->attrs[NL80211_ATTR_STA_AID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\tparams.listen_interval =\n\t\t    nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (parse_station_flags(info, &params))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_STATE])\n\t\tparams.plink_state =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_STATE]);\n\n\terr = get_vlan(info, rdev, &params.vlan);\n\tif (err)\n\t\tgoto out;\n\n\t/* validate settings */\n\terr = 0;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* disallow mesh-specific things */\n\t\tif (params.plink_action)\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\t/* disallow everything but AUTHORIZED flag */\n\t\tif (params.plink_action)\n\t\t\terr = -EINVAL;\n\t\tif (params.vlan)\n\t\t\terr = -EINVAL;\n\t\tif (params.supported_rates)\n\t\t\terr = -EINVAL;\n\t\tif (params.ht_capa)\n\t\t\terr = -EINVAL;\n\t\tif (params.listen_interval >= 0)\n\t\t\terr = -EINVAL;\n\t\tif (params.sta_flags_mask & ~BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* disallow things mesh doesn't support */\n\t\tif (params.vlan)\n\t\t\terr = -EINVAL;\n\t\tif (params.ht_capa)\n\t\t\terr = -EINVAL;\n\t\tif (params.listen_interval >= 0)\n\t\t\terr = -EINVAL;\n\t\tif (params.sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\terr = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\tif (!rdev->ops->change_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev->ops->change_station(&rdev->wiphy, dev, mac_addr, &params);\n\n out:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\n\treturn err;\n}\n\nstatic int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_AID])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tparams.supported_rates =\n\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.supported_rates_len =\n\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.listen_interval =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\tif (!params.aid || params.aid > IEEE80211_MAX_AID)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (parse_station_flags(info, &params))\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\terr = get_vlan(info, rdev, &params.vlan);\n\tif (err)\n\t\tgoto out;\n\n\t/* validate settings */\n\terr = 0;\n\n\tif (!rdev->ops->add_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev->ops->add_station(&rdev->wiphy, dev, mac_addr, &params);\n\n out:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\treturn err;\n}\n\nstatic int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_station)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->del_station(&rdev->wiphy, dev, mac_addr);\n}\n\nstatic int nl80211_send_mpath(struct sk_buff *msg, u32 pid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, NL80211_CMD_NEW_STATION);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, dst);\n\tNLA_PUT(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop);\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION, pinfo->generation);\n\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (pinfo->filled & MPATH_INFO_FRAME_QLEN)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\t    pinfo->frame_qlen);\n\tif (pinfo->filled & MPATH_INFO_SN)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_SN,\n\t\t\t    pinfo->sn);\n\tif (pinfo->filled & MPATH_INFO_METRIC)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t    pinfo->metric);\n\tif (pinfo->filled & MPATH_INFO_EXPTIME)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t    pinfo->exptime);\n\tif (pinfo->filled & MPATH_INFO_FLAGS)\n\t\tNLA_PUT_U8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\t    pinfo->flags);\n\tif (pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT)\n\t\tNLA_PUT_U32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t    pinfo->discovery_timeout);\n\tif (pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES)\n\t\tNLA_PUT_U8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\t    pinfo->discovery_retries);\n\n\tnla_nest_end(msg, pinfoattr);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[1];\n\tint err;\n\n\terr = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!dev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = dev->ops->dump_mpath(&dev->wiphy, netdev, path_idx,\n\t\t\t\t\t   dst, next_hop, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).pid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n\n out:\n\tcb->args[1] = path_idx;\n\terr = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn err;\n}\n\nstatic int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 next_hop[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev->ops->get_mpath(&rdev->wiphy, dev, dst, next_hop, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t\t dev, dst, next_hop, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_set_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->change_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->change_mpath(&rdev->wiphy, dev, dst, next_hop);\n}\n\nstatic int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->add_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->add_mpath(&rdev->wiphy, dev, dst, next_hop);\n}\n\nstatic int nl80211_del_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->del_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->del_mpath(&rdev->wiphy, dev, dst);\n}\n\nstatic int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct bss_parameters params;\n\n\tmemset(&params, 0, sizeof(params));\n\t/* default to not changing parameters */\n\tparams.use_cts_prot = -1;\n\tparams.use_short_preamble = -1;\n\tparams.use_short_slot_time = -1;\n\tparams.ap_isolate = -1;\n\tparams.ht_opmode = -1;\n\n\tif (info->attrs[NL80211_ATTR_BSS_CTS_PROT])\n\t\tparams.use_cts_prot =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_CTS_PROT]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE])\n\t\tparams.use_short_preamble =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME])\n\t\tparams.use_short_slot_time =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME]);\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tparams.basic_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tparams.basic_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t}\n\tif (info->attrs[NL80211_ATTR_AP_ISOLATE])\n\t\tparams.ap_isolate = !!nla_get_u8(info->attrs[NL80211_ATTR_AP_ISOLATE]);\n\tif (info->attrs[NL80211_ATTR_BSS_HT_OPMODE])\n\t\tparams.ht_opmode =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BSS_HT_OPMODE]);\n\n\tif (!rdev->ops->change_bss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->change_bss(&rdev->wiphy, dev, &params);\n}\n\nstatic const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {\n\t[NL80211_ATTR_REG_RULE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_START]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_END]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_MAX_BW]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_EIRP]\t= { .type = NLA_U32 },\n};\n\nstatic int parse_reg_rule(struct nlattr *tb[],\n\tstruct ieee80211_reg_rule *reg_rule)\n{\n\tstruct ieee80211_freq_range *freq_range = &reg_rule->freq_range;\n\tstruct ieee80211_power_rule *power_rule = &reg_rule->power_rule;\n\n\tif (!tb[NL80211_ATTR_REG_RULE_FLAGS])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_START])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_END])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_MAX_BW])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_POWER_RULE_MAX_EIRP])\n\t\treturn -EINVAL;\n\n\treg_rule->flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);\n\n\tfreq_range->start_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]);\n\tfreq_range->end_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]);\n\tfreq_range->max_bandwidth_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]);\n\n\tpower_rule->max_eirp =\n\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_EIRP]);\n\n\tif (tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN])\n\t\tpower_rule->max_antenna_gain =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);\n\n\treturn 0;\n}\n\nstatic int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tint r;\n\tchar *data = NULL;\n\n\t/*\n\t * You should only get this when cfg80211 hasn't yet initialized\n\t * completely when built-in to the kernel right between the time\n\t * window between nl80211_init() and regulatory_init(), if that is\n\t * even possible.\n\t */\n\tmutex_lock(&cfg80211_mutex);\n\tif (unlikely(!cfg80211_regdomain)) {\n\t\tmutex_unlock(&cfg80211_mutex);\n\t\treturn -EINPROGRESS;\n\t}\n\tmutex_unlock(&cfg80211_mutex);\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tdata = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tr = regulatory_hint_user(data);\n\n\treturn r;\n}\n\nstatic int nl80211_get_mesh_config(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cur_params;\n\tint err = 0;\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\tstruct sk_buff *msg;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\t/* If not connected, get default parameters */\n\tif (!wdev->mesh_id_len)\n\t\tmemcpy(&cur_params, &default_mesh_config, sizeof(cur_params));\n\telse\n\t\terr = rdev->ops->get_mesh_config(&rdev->wiphy, dev,\n\t\t\t\t\t\t &cur_params);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t/* Draw up a netlink message to send back */\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_MESH_CONFIG);\n\tif (!hdr)\n\t\tgoto out;\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_MESH_CONFIG);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_RETRY_TIMEOUT,\n\t\t\tcur_params.dot11MeshRetryTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\tcur_params.dot11MeshConfirmTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\tcur_params.dot11MeshHoldingTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\tcur_params.dot11MeshMaxPeerLinks);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_MAX_RETRIES,\n\t\t\tcur_params.dot11MeshMaxRetries);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_TTL,\n\t\t\tcur_params.dot11MeshTTL);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_ELEMENT_TTL,\n\t\t\tcur_params.element_ttl);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t\tcur_params.auto_open_plinks);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\tcur_params.dot11MeshHWMPmaxPREQretries);\n\tNLA_PUT_U32(msg, NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\tcur_params.path_refresh_time);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tcur_params.min_discovery_timeout);\n\tNLA_PUT_U32(msg, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathTimeout);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPpreqMinInterval);\n\tNLA_PUT_U16(msg, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tcur_params.dot11MeshHWMPnetDiameterTraversalTime);\n\tNLA_PUT_U8(msg, NL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t\tcur_params.dot11MeshHWMPRootMode);\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n out:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic const struct nla_policy nl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {\n\t[NL80211_MESHCONF_RETRY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_CONFIRM_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HOLDING_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_MAX_PEER_LINKS] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_MAX_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_TTL] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_ELEMENT_TTL] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = { .type = NLA_U8 },\n\n\t[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] = { .type = NLA_U16 },\n};\n\nstatic const struct nla_policy\n\tnl80211_mesh_setup_params_policy[NL80211_MESH_SETUP_ATTR_MAX+1] = {\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_IE] = { .type = NLA_BINARY,\n\t\t.len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_MESH_SETUP_USERSPACE_AMPE] = { .type = NLA_FLAG },\n};\n\nstatic int nl80211_parse_mesh_config(struct genl_info *info,\n\t\t\t\t     struct mesh_config *cfg,\n\t\t\t\t     u32 *mask_out)\n{\n\tstruct nlattr *tb[NL80211_MESHCONF_ATTR_MAX + 1];\n\tu32 mask = 0;\n\n#define FILL_IN_MESH_PARAM_IF_SET(table, cfg, param, mask, attr_num, nla_fn) \\\ndo {\\\n\tif (table[attr_num]) {\\\n\t\tcfg->param = nla_fn(table[attr_num]); \\\n\t\tmask |= (1 << (attr_num - 1)); \\\n\t} \\\n} while (0);\\\n\n\n\tif (!info->attrs[NL80211_ATTR_MESH_CONFIG])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested(tb, NL80211_MESHCONF_ATTR_MAX,\n\t\t\t     info->attrs[NL80211_ATTR_MESH_CONFIG],\n\t\t\t     nl80211_meshconf_params_policy))\n\t\treturn -EINVAL;\n\n\t/* This makes sure that there aren't more than 32 mesh config\n\t * parameters (otherwise our bitfield scheme would not work.) */\n\tBUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);\n\n\t/* Fill in the params struct */\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout,\n\t\t\tmask, NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout,\n\t\t\tmask, NL80211_MESHCONF_CONFIRM_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout,\n\t\t\tmask, NL80211_MESHCONF_HOLDING_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks,\n\t\t\tmask, NL80211_MESHCONF_MAX_PEER_LINKS, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries,\n\t\t\tmask, NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL,\n\t\t\tmask, NL80211_MESHCONF_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl,\n\t\t\tmask, NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks,\n\t\t\tmask, NL80211_MESHCONF_AUTO_OPEN_PLINKS, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries,\n\t\t\tmask, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\tnla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time,\n\t\t\tmask, NL80211_MESHCONF_PATH_REFRESH_TIME, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout,\n\t\t\tmask, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tnla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,\n\t\t\tmask, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tnla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval,\n\t\t\tmask, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tnla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\tdot11MeshHWMPnetDiameterTraversalTime,\n\t\t\tmask, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tnla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\tdot11MeshHWMPRootMode, mask,\n\t\t\tNL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t\tnla_get_u8);\n\tif (mask_out)\n\t\t*mask_out = mask;\n\n\treturn 0;\n\n#undef FILL_IN_MESH_PARAM_IF_SET\n}\n\nstatic int nl80211_parse_mesh_setup(struct genl_info *info,\n\t\t\t\t     struct mesh_setup *setup)\n{\n\tstruct nlattr *tb[NL80211_MESH_SETUP_ATTR_MAX + 1];\n\n\tif (!info->attrs[NL80211_ATTR_MESH_SETUP])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested(tb, NL80211_MESH_SETUP_ATTR_MAX,\n\t\t\t     info->attrs[NL80211_ATTR_MESH_SETUP],\n\t\t\t     nl80211_mesh_setup_params_policy))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])\n\t\tsetup->path_sel_proto =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])) ?\n\t\t IEEE80211_PATH_PROTOCOL_VENDOR :\n\t\t IEEE80211_PATH_PROTOCOL_HWMP;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])\n\t\tsetup->path_metric =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])) ?\n\t\t IEEE80211_PATH_METRIC_VENDOR :\n\t\t IEEE80211_PATH_METRIC_AIRTIME;\n\n\n\tif (tb[NL80211_MESH_SETUP_IE]) {\n\t\tstruct nlattr *ieattr =\n\t\t\ttb[NL80211_MESH_SETUP_IE];\n\t\tif (!is_valid_ie_attr(ieattr))\n\t\t\treturn -EINVAL;\n\t\tsetup->ie = nla_data(ieattr);\n\t\tsetup->ie_len = nla_len(ieattr);\n\t}\n\tsetup->is_authenticated = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AUTH]);\n\tsetup->is_secure = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AMPE]);\n\n\treturn 0;\n}\n\nstatic int nl80211_update_mesh_config(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cfg;\n\tu32 mask;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->update_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mesh_config(info, &cfg, &mask);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!wdev->mesh_id_len)\n\t\terr = -ENOLINK;\n\n\tif (!err)\n\t\terr = rdev->ops->update_mesh_config(&rdev->wiphy, dev,\n\t\t\t\t\t\t    mask, &cfg);\n\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_get_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr = NULL;\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\tint err = -EINVAL;\n\n\tmutex_lock(&cfg80211_mutex);\n\n\tif (!cfg80211_regdomain)\n\t\tgoto out;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\tNLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2,\n\t\tcfg80211_regdomain->alpha2);\n\n\tnl_reg_rules = nla_nest_start(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < cfg80211_regdomain->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\n\t\treg_rule = &cfg80211_regdomain->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\treg_rule->flags);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\tfreq_range->start_freq_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\tfreq_range->end_freq_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\tfreq_range->max_bandwidth_khz);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\tpower_rule->max_antenna_gain);\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\tpower_rule->max_eirp);\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\n\tgenlmsg_end(msg, hdr);\n\terr = genlmsg_reply(msg, info);\n\tgoto out;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\nput_failure:\n\tnlmsg_free(msg);\n\terr = -EMSGSIZE;\nout:\n\tmutex_unlock(&cfg80211_mutex);\n\treturn err;\n}\n\nstatic int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];\n\tstruct nlattr *nl_reg_rule;\n\tchar *alpha2 = NULL;\n\tint rem_reg_rules = 0, r = 0;\n\tu32 num_rules = 0, rule_idx = 0, size_of_regd;\n\tstruct ieee80211_regdomain *rd = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_RULES])\n\t\treturn -EINVAL;\n\n\talpha2 = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\trem_reg_rules) {\n\t\tnum_rules++;\n\t\tif (num_rules > NL80211_MAX_SUPP_REG_RULES)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&cfg80211_mutex);\n\n\tif (!reg_is_valid_request(alpha2)) {\n\t\tr = -EINVAL;\n\t\tgoto bad_reg;\n\t}\n\n\tsize_of_regd = sizeof(struct ieee80211_regdomain) +\n\t\t(num_rules * sizeof(struct ieee80211_reg_rule));\n\n\trd = kzalloc(size_of_regd, GFP_KERNEL);\n\tif (!rd) {\n\t\tr = -ENOMEM;\n\t\tgoto bad_reg;\n\t}\n\n\trd->n_reg_rules = num_rules;\n\trd->alpha2[0] = alpha2[0];\n\trd->alpha2[1] = alpha2[1];\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\trem_reg_rules) {\n\t\tnla_parse(tb, NL80211_REG_RULE_ATTR_MAX,\n\t\t\tnla_data(nl_reg_rule), nla_len(nl_reg_rule),\n\t\t\treg_rule_policy);\n\t\tr = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\n\t\trule_idx++;\n\n\t\tif (rule_idx > NL80211_MAX_SUPP_REG_RULES) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad_reg;\n\t\t}\n\t}\n\n\tBUG_ON(rule_idx != num_rules);\n\n\tr = set_regdom(rd);\n\n\tmutex_unlock(&cfg80211_mutex);\n\n\treturn r;\n\n bad_reg:\n\tmutex_unlock(&cfg80211_mutex);\n\tkfree(rd);\n\treturn r;\n}\n\nstatic int validate_scan_freqs(struct nlattr *freqs)\n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t/*\n\t\t * Some hardware has a limited channel list for\n\t\t * scanning, and it is pretty much nonsensical\n\t\t * to scan for a channel twice, so disallow that\n\t\t * and don't require drivers to check that the\n\t\t * channel list they get isn't longer than what\n\t\t * they can scan, as long as they can scan all\n\t\t * the channels they registered at once.\n\t\t */\n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;\n}\n\nstatic int nl80211_stop_sched_scan(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\treturn __cfg80211_stop_sched_scan(rdev, false);\n}\n\nstatic int nl80211_send_bss(struct sk_buff *msg, u32 pid, u32 seq, int flags,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_internal_bss *intbss)\n{\n\tstruct cfg80211_bss *res = &intbss->pub;\n\tvoid *hdr;\n\tstruct nlattr *bss;\n\tint i;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SCAN_RESULTS);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_GENERATION, rdev->bss_generation);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex);\n\n\tbss = nla_nest_start(msg, NL80211_ATTR_BSS);\n\tif (!bss)\n\t\tgoto nla_put_failure;\n\tif (!is_zero_ether_addr(res->bssid))\n\t\tNLA_PUT(msg, NL80211_BSS_BSSID, ETH_ALEN, res->bssid);\n\tif (res->information_elements && res->len_information_elements)\n\t\tNLA_PUT(msg, NL80211_BSS_INFORMATION_ELEMENTS,\n\t\t\tres->len_information_elements,\n\t\t\tres->information_elements);\n\tif (res->beacon_ies && res->len_beacon_ies &&\n\t    res->beacon_ies != res->information_elements)\n\t\tNLA_PUT(msg, NL80211_BSS_BEACON_IES,\n\t\t\tres->len_beacon_ies, res->beacon_ies);\n\tif (res->tsf)\n\t\tNLA_PUT_U64(msg, NL80211_BSS_TSF, res->tsf);\n\tif (res->beacon_interval)\n\t\tNLA_PUT_U16(msg, NL80211_BSS_BEACON_INTERVAL, res->beacon_interval);\n\tNLA_PUT_U16(msg, NL80211_BSS_CAPABILITY, res->capability);\n\tNLA_PUT_U32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq);\n\tNLA_PUT_U32(msg, NL80211_BSS_SEEN_MS_AGO,\n\t\tjiffies_to_msecs(jiffies - intbss->ts));\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tNLA_PUT_U32(msg, NL80211_BSS_SIGNAL_MBM, res->signal);\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tNLA_PUT_U8(msg, NL80211_BSS_SIGNAL_UNSPEC, res->signal);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (intbss == wdev->current_bss)\n\t\t\tNLA_PUT_U32(msg, NL80211_BSS_STATUS,\n\t\t\t\t    NL80211_BSS_STATUS_ASSOCIATED);\n\t\telse for (i = 0; i < MAX_AUTH_BSSES; i++) {\n\t\t\tif (intbss != wdev->auth_bsses[i])\n\t\t\t\tcontinue;\n\t\t\tNLA_PUT_U32(msg, NL80211_BSS_STATUS,\n\t\t\t\t    NL80211_BSS_STATUS_AUTHENTICATED);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (intbss == wdev->current_bss)\n\t\t\tNLA_PUT_U32(msg, NL80211_BSS_STATUS,\n\t\t\t\t    NL80211_BSS_STATUS_IBSS_JOINED);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, bss);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_scan(struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *dev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[1], idx = 0;\n\tint err;\n\n\terr = nl80211_prepare_netdev_dump(skb, cb, &rdev, &dev);\n\tif (err)\n\t\treturn err;\n\n\twdev = dev->ieee80211_ptr;\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\tcfg80211_bss_expire(rdev);\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[1] = idx;\n\tnl80211_finish_netdev_dump(rdev);\n\n\treturn skb->len;\n}\n\nstatic int nl80211_send_survey(struct sk_buff *msg, u32 pid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tstruct survey_info *survey)\n{\n\tvoid *hdr;\n\tstruct nlattr *infoattr;\n\n\t/* Survey without a channel doesn't make sense */\n\tif (!survey->channel)\n\t\treturn -EINVAL;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SURVEY_RESULTS);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\n\tinfoattr = nla_nest_start(msg, NL80211_ATTR_SURVEY_INFO);\n\tif (!infoattr)\n\t\tgoto nla_put_failure;\n\n\tNLA_PUT_U32(msg, NL80211_SURVEY_INFO_FREQUENCY,\n\t\t    survey->channel->center_freq);\n\tif (survey->filled & SURVEY_INFO_NOISE_DBM)\n\t\tNLA_PUT_U8(msg, NL80211_SURVEY_INFO_NOISE,\n\t\t\t    survey->noise);\n\tif (survey->filled & SURVEY_INFO_IN_USE)\n\t\tNLA_PUT_FLAG(msg, NL80211_SURVEY_INFO_IN_USE);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME,\n\t\t\t    survey->channel_time);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_BUSY)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_BUSY,\n\t\t\t    survey->channel_time_busy);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_EXT_BUSY)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_EXT_BUSY,\n\t\t\t    survey->channel_time_ext_busy);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_RX)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_RX,\n\t\t\t    survey->channel_time_rx);\n\tif (survey->filled & SURVEY_INFO_CHANNEL_TIME_TX)\n\t\tNLA_PUT_U64(msg, NL80211_SURVEY_INFO_CHANNEL_TIME_TX,\n\t\t\t    survey->channel_time_tx);\n\n\tnla_nest_end(msg, infoattr);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_survey(struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb)\n{\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tint survey_idx = cb->args[1];\n\tint res;\n\n\tres = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (res)\n\t\treturn res;\n\n\tif (!dev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tres = dev->ops->dump_survey(&dev->wiphy, netdev, survey_idx,\n\t\t\t\t\t    &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).pid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev,\n\t\t\t\t&survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[1] = survey_idx;\n\tres = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn res;\n}\n\nstatic bool nl80211_valid_auth_type(enum nl80211_auth_type auth_type)\n{\n\treturn auth_type <= NL80211_AUTHTYPE_MAX;\n}\n\nstatic bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2));\n}\n\nstatic bool nl80211_valid_akm_suite(u32 akm)\n{\n\treturn akm == WLAN_AKM_SUITE_8021X ||\n\t\takm == WLAN_AKM_SUITE_PSK;\n}\n\nstatic bool nl80211_valid_cipher_suite(u32 cipher)\n{\n\treturn cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\tcipher == WLAN_CIPHER_SUITE_WEP104 ||\n\t\tcipher == WLAN_CIPHER_SUITE_TKIP ||\n\t\tcipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\tcipher == WLAN_CIPHER_SUITE_AES_CMAC;\n}\n\n\nstatic int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL;\n\tint err, ssid_len, ie_len = 0;\n\tenum nl80211_auth_type auth_type;\n\tstruct key_parse key;\n\tbool local_state_change;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_AUTH_TYPE])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx >= 0) {\n\t\tif (key.type != -1 && key.type != NL80211_KEYTYPE_GROUP)\n\t\t\treturn -EINVAL;\n\t\tif (!key.p.key || !key.p.key_len)\n\t\t\treturn -EINVAL;\n\t\tif ((key.p.cipher != WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP40) &&\n\t\t    (key.p.cipher != WLAN_CIPHER_SUITE_WEP104 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP104))\n\t\t\treturn -EINVAL;\n\t\tif (key.idx > 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey.p.key_len = 0;\n\t\tkey.p.key = NULL;\n\t}\n\n\tif (key.idx >= 0) {\n\t\tint i;\n\t\tbool ok = false;\n\t\tfor (i = 0; i < rdev->wiphy.n_cipher_suites; i++) {\n\t\t\tif (key.p.cipher == rdev->wiphy.cipher_suites[i]) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tchan = ieee80211_get_channel(&rdev->wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!chan || (chan->flags & IEEE80211_CHAN_DISABLED))\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\tif (!nl80211_valid_auth_type(auth_type))\n\t\treturn -EINVAL;\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\treturn cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,\n\t\t\t\t  ssid, ssid_len, ie, ie_len,\n\t\t\t\t  key.p.key, key.p.key_len, key.idx,\n\t\t\t\t  local_state_change);\n}\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit)\n{\n\tmemset(settings, 0, sizeof(*settings));\n\n\tsettings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tu16 proto;\n\t\tproto = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\t\tsettings->control_port_ethertype = cpu_to_be16(proto);\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    proto != ETH_P_PAE)\n\t\t\treturn -EINVAL;\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])\n\t\t\tsettings->control_port_no_encrypt = true;\n\t} else\n\t\tsettings->control_port_ethertype = cpu_to_be16(ETH_P_PAE);\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tsettings->n_ciphers_pairwise = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_ciphers_pairwise > cipher_limit)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->ciphers_pairwise, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!nl80211_valid_cipher_suite(\n\t\t\t\t\tsettings->ciphers_pairwise[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {\n\t\tsettings->cipher_group =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);\n\t\tif (!nl80211_valid_cipher_suite(settings->cipher_group))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {\n\t\tsettings->wpa_versions =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);\n\t\tif (!nl80211_valid_wpa_versions(settings->wpa_versions))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AKM_SUITES]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tsettings->n_akm_suites = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->akm_suites, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!nl80211_valid_akm_suite(settings->akm_suites[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_associate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_crypto_settings crypto;\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL, *prev_bssid = NULL;\n\tint err, ssid_len, ie_len = 0;\n\tbool use_mfp = false;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tchan = ieee80211_get_channel(&rdev->wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!chan || (chan->flags & IEEE80211_CHAN_DISABLED))\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tenum nl80211_mfp mfp =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (mfp == NL80211_MFP_REQUIRED)\n\t\t\tuse_mfp = true;\n\t\telse if (mfp != NL80211_MFP_NO)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\tprev_bssid = nla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\terr = nl80211_crypto_settings(rdev, info, &crypto, 1);\n\tif (!err)\n\t\terr = cfg80211_mlme_assoc(rdev, dev, chan, bssid, prev_bssid,\n\t\t\t\t\t  ssid, ssid_len, ie, ie_len, use_mfp,\n\t\t\t\t\t  &crypto);\n\n\treturn err;\n}\n\nstatic int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\treturn cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t    local_state_change);\n}\n\nstatic int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->disassoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\treturn cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t      local_state_change);\n}\n\nstatic bool\nnl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[IEEE80211_NUM_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\t\tif (ibss.beacon_interval < 1 || ibss.beacon_interval > 10000)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tibss.channel = ieee80211_get_channel(wiphy,\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (!ibss.channel ||\n\t    ibss.channel->flags & IEEE80211_CHAN_NO_IBSS ||\n\t    ibss.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn -EINVAL;\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.channel->band];\n\t\tint i, j;\n\n\t\tif (n_rates == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < n_rates; i++) {\n\t\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\t\tbool found = false;\n\n\t\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\t\tif (sband->bitrates[j].bitrate == rate) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tibss.basic_rates |= BIT(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n\nstatic int nl80211_leave_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->leave_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_leave_ibss(rdev, dev, false);\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic struct genl_multicast_group nl80211_testmode_mcgrp = {\n\t.name = \"testmode\",\n};\n\nstatic int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_TESTDATA])\n\t\treturn -EINVAL;\n\n\terr = -EOPNOTSUPP;\n\tif (rdev->ops->testmode_cmd) {\n\t\trdev->testmode_info = info;\n\t\terr = rdev->ops->testmode_cmd(&rdev->wiphy,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_TESTDATA]),\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_TESTDATA]));\n\t\trdev->testmode_info = NULL;\n\t}\n\n\treturn err;\n}\n\nstatic struct sk_buff *\n__cfg80211_testmode_alloc_skb(struct cfg80211_registered_device *rdev,\n\t\t\t      int approxlen, u32 pid, u32 seq, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\tstruct nlattr *data;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nl80211hdr_put(skb, pid, seq, 0, NL80211_CMD_TESTMODE);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tNLA_PUT_U32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tdata = nla_nest_start(skb, NL80211_ATTR_TESTDATA);\n\n\t((void **)skb->cb)[0] = rdev;\n\t((void **)skb->cb)[1] = hdr;\n\t((void **)skb->cb)[2] = data;\n\n\treturn skb;\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\n\tif (WARN_ON(!rdev->testmode_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen,\n\t\t\t\trdev->testmode_info->snd_pid,\n\t\t\t\trdev->testmode_info->snd_seq,\n\t\t\t\tGFP_KERNEL);\n}\nEXPORT_SYMBOL(cfg80211_testmode_alloc_reply_skb);\n\nint cfg80211_testmode_reply(struct sk_buff *skb)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\tif (WARN_ON(!rdev->testmode_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, rdev->testmode_info);\n}\nEXPORT_SYMBOL(cfg80211_testmode_reply);\n\nstruct sk_buff *cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen, 0, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_testmode_alloc_event_skb);\n\nvoid cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)\n{\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\tgenlmsg_multicast(skb, 0, nl80211_testmode_mcgrp.id, gfp);\n}\nEXPORT_SYMBOL(cfg80211_testmode_event);\n#endif\n\nstatic int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(connect.auth_type))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tconnect.channel =\n\t\t\tieee80211_get_channel(wiphy,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\t\tif (!connect.channel ||\n\t\t    connect.channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_KEYS]);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys);\n\tif (err)\n\t\tkfree(connkeys);\n\treturn err;\n}\n\nstatic int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_disconnect(rdev, dev, reason, true);\n}\n\nstatic int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\tu32 pid;\n\n\tif (!info->attrs[NL80211_ATTR_PID])\n\t\treturn -EINVAL;\n\n\tpid = nla_get_u32(info->attrs[NL80211_ATTR_PID]);\n\n\tnet = get_net_ns_by_pid(pid);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t/* check if anything to do */\n\tif (!net_eq(wiphy_net(&rdev->wiphy), net))\n\t\terr = cfg80211_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint (*rdev_ops)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_pmksa *pmksa) = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_pmksa pmksa;\n\n\tmemset(&pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_PMKID])\n\t\treturn -EINVAL;\n\n\tpmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\tpmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_SET_PMKSA:\n\t\trdev_ops = rdev->ops->set_pmksa;\n\t\tbreak;\n\tcase NL80211_CMD_DEL_PMKSA:\n\t\trdev_ops = rdev->ops->del_pmksa;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (!rdev_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_ops(&rdev->wiphy, dev, &pmksa);\n}\n\nstatic int nl80211_flush_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->flush_pmksa)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->flush_pmksa(&rdev->wiphy, dev);\n}\n\nstatic int nl80211_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tenum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;\n\tu32 freq, duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t/*\n\t * We should be on that channel for at least one jiffie,\n\t * and more than 5 seconds seems excessive.\n\t */\n\tif (!duration || !msecs_to_jiffies(duration) ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tchannel_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\t\tif (channel_type != NL80211_CHAN_NO_HT &&\n\t\t    channel_type != NL80211_CHAN_HT20 &&\n\t\t    channel_type != NL80211_CHAN_HT40PLUS &&\n\t\t    channel_type != NL80211_CHAN_HT40MINUS)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tchan = rdev_freq_to_chan(rdev, freq, channel_type);\n\tif (chan == NULL)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_REMAIN_ON_CHANNEL);\n\n\tif (IS_ERR(hdr)) {\n\t\terr = PTR_ERR(hdr);\n\t\tgoto free_msg;\n\t}\n\n\terr = rdev->ops->remain_on_channel(&rdev->wiphy, dev, chan,\n\t\t\t\t\t   channel_type, duration, &cookie);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_cancel_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->cancel_remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev->ops->cancel_remain_on_channel(&rdev->wiphy, dev, cookie);\n}\n\nstatic u32 rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t   u8 *rates, u8 rates_len)\n{\n\tu8 i;\n\tu32 mask = 0;\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tint ridx;\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate =\n\t\t\t\t&sband->bitrates[ridx];\n\t\t\tif (rate == srate->bitrate) {\n\t\t\t\tmask |= 1 << ridx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ridx == sband->n_bitrates)\n\t\t\treturn 0; /* rate not found */\n\t}\n\n\treturn mask;\n}\n\nstatic const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {\n\t[NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,\n\t\t\t\t    .len = NL80211_MAX_SUPP_RATES },\n};\n\nstatic int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_TXRATE_MAX + 1];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_bitrate_mask mask;\n\tint rem, i;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *tx_rates;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES] == NULL)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&mask, 0, sizeof(mask));\n\t/* Default to all rates enabled */\n\tfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\n\t\tsband = rdev->wiphy.bands[i];\n\t\tmask.control[i].legacy =\n\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;\n\t}\n\n\t/*\n\t * The nested attribute uses enum nl80211_band as the index. This maps\n\t * directly to the enum ieee80211_band values used in cfg80211.\n\t */\n\tnla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem)\n\t{\n\t\tenum ieee80211_band band = nla_type(tx_rates);\n\t\tif (band < 0 || band >= IEEE80211_NUM_BANDS)\n\t\t\treturn -EINVAL;\n\t\tsband = rdev->wiphy.bands[band];\n\t\tif (sband == NULL)\n\t\t\treturn -EINVAL;\n\t\tnla_parse(tb, NL80211_TXRATE_MAX, nla_data(tx_rates),\n\t\t\t  nla_len(tx_rates), nl80211_txattr_policy);\n\t\tif (tb[NL80211_TXRATE_LEGACY]) {\n\t\t\tmask.control[band].legacy = rateset_to_mask(\n\t\t\t\tsband,\n\t\t\t\tnla_data(tb[NL80211_TXRATE_LEGACY]),\n\t\t\t\tnla_len(tb[NL80211_TXRATE_LEGACY]));\n\t\t\tif (mask.control[band].legacy == 0)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn rdev->ops->set_bitrate_mask(&rdev->wiphy, dev, NULL, &mask);\n}\n\nstatic int nl80211_register_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 frame_type = IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME_MATCH])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_FRAME_TYPE])\n\t\tframe_type = nla_get_u16(info->attrs[NL80211_ATTR_FRAME_TYPE]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\t/* not much point in registering if we can't reply */\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_mlme_register_mgmt(dev->ieee80211_ptr, info->snd_pid,\n\t\t\tframe_type,\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FRAME_MATCH]));\n}\n\nstatic int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;\n\tbool channel_type_valid = false;\n\tu32 freq;\n\tint err;\n\tvoid *hdr;\n\tu64 cookie;\n\tstruct sk_buff *msg;\n\tunsigned int wait = 0;\n\tbool offchan;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\t\treturn -EINVAL;\n\t\twait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tchannel_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\t\tif (channel_type != NL80211_CHAN_NO_HT &&\n\t\t    channel_type != NL80211_CHAN_HT20 &&\n\t\t    channel_type != NL80211_CHAN_HT40PLUS &&\n\t\t    channel_type != NL80211_CHAN_HT40MINUS)\n\t\t\treturn -EINVAL;\n\t\tchannel_type_valid = true;\n\t}\n\n\toffchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]);\n\tchan = rdev_freq_to_chan(rdev, freq, channel_type);\n\tif (chan == NULL)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_FRAME);\n\n\tif (IS_ERR(hdr)) {\n\t\terr = PTR_ERR(hdr);\n\t\tgoto free_msg;\n\t}\n\terr = cfg80211_mlme_mgmt_tx(rdev, dev, chan, offchan, channel_type,\n\t\t\t\t    channel_type_valid, wait,\n\t\t\t\t    nla_data(info->attrs[NL80211_ATTR_FRAME]),\n\t\t\t\t    nla_len(info->attrs[NL80211_ATTR_FRAME]),\n\t\t\t\t    &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_tx_mgmt_cancel_wait(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev->ops->mgmt_tx_cancel_wait(&rdev->wiphy, dev, cookie);\n}\n\nstatic int nl80211_set_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 ps_state;\n\tbool state;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_PS_STATE])\n\t\treturn -EINVAL;\n\n\tps_state = nla_get_u32(info->attrs[NL80211_ATTR_PS_STATE]);\n\n\tif (ps_state != NL80211_PS_DISABLED && ps_state != NL80211_PS_ENABLED)\n\t\treturn -EINVAL;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tstate = (ps_state == NL80211_PS_ENABLED) ? true : false;\n\n\tif (state == wdev->ps)\n\t\treturn 0;\n\n\terr = rdev->ops->set_power_mgmt(wdev->wiphy, dev, state,\n\t\t\t\t\twdev->ps_timeout);\n\tif (!err)\n\t\twdev->ps = state;\n\treturn err;\n}\n\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_PS_STATE, ps_state);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic struct nla_policy\nnl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] __read_mostly = {\n\t[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },\n};\n\nstatic int nl80211_set_cqm_rssi(struct genl_info *info,\n\t\t\t\ts32 threshold, u32 hysteresis)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (threshold > 0)\n\t\treturn -EINVAL;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_cqm_rssi_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev->ops->set_cqm_rssi_config(wdev->wiphy, dev,\n\t\t\t\t\t      threshold, hysteresis);\n}\n\nstatic int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[NL80211_ATTR_CQM_MAX + 1];\n\tstruct nlattr *cqm;\n\tint err;\n\n\tcqm = info->attrs[NL80211_ATTR_CQM];\n\tif (!cqm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = nla_parse_nested(attrs, NL80211_ATTR_CQM_MAX, cqm,\n\t\t\t       nl80211_attr_cqm_policy);\n\tif (err)\n\t\tgoto out;\n\n\tif (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&\n\t    attrs[NL80211_ATTR_CQM_RSSI_HYST]) {\n\t\ts32 threshold;\n\t\tu32 hysteresis;\n\t\tthreshold = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\thysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);\n\t\terr = nl80211_set_cqm_rssi(info, threshold, hysteresis);\n\t} else\n\t\terr = -EINVAL;\n\nout:\n\treturn err;\n}\n\nstatic int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mesh_config cfg;\n\tstruct mesh_setup setup;\n\tint err;\n\n\t/* start with default */\n\tmemcpy(&cfg, &default_mesh_config, sizeof(cfg));\n\tmemcpy(&setup, &default_mesh_setup, sizeof(setup));\n\n\tif (info->attrs[NL80211_ATTR_MESH_CONFIG]) {\n\t\t/* and parse parameters if given */\n\t\terr = nl80211_parse_mesh_config(info, &cfg, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MESH_ID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_MESH_ID]))\n\t\treturn -EINVAL;\n\n\tsetup.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);\n\tsetup.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\n\tif (info->attrs[NL80211_ATTR_MESH_SETUP]) {\n\t\t/* parse additional setup parameters if given */\n\t\terr = nl80211_parse_mesh_setup(info, &setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn cfg80211_join_mesh(rdev, dev, &setup, &cfg);\n}\n\nstatic int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_mesh(rdev, dev);\n}\n\nstatic int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!rdev->wiphy.wowlan.flags && !rdev->wiphy.wowlan.n_patterns)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_WOWLAN);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->wowlan) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start(msg, NL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wowlan->any)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_ANY);\n\t\tif (rdev->wowlan->disconnect)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_DISCONNECT);\n\t\tif (rdev->wowlan->magic_pkt)\n\t\t\tNLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT);\n\t\tif (rdev->wowlan->n_patterns) {\n\t\t\tstruct nlattr *nl_pats, *nl_pat;\n\t\t\tint i, pat_len;\n\n\t\t\tnl_pats = nla_nest_start(msg,\n\t\t\t\t\tNL80211_WOWLAN_TRIG_PKT_PATTERN);\n\t\t\tif (!nl_pats)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wowlan->n_patterns; i++) {\n\t\t\t\tnl_pat = nla_nest_start(msg, i + 1);\n\t\t\t\tif (!nl_pat)\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tpat_len = rdev->wowlan->patterns[i].pattern_len;\n\t\t\t\tNLA_PUT(msg, NL80211_WOWLAN_PKTPAT_MASK,\n\t\t\t\t\tDIV_ROUND_UP(pat_len, 8),\n\t\t\t\t\trdev->wowlan->patterns[i].mask);\n\t\t\t\tNLA_PUT(msg, NL80211_WOWLAN_PKTPAT_PATTERN,\n\t\t\t\t\tpat_len,\n\t\t\t\t\trdev->wowlan->patterns[i].pattern);\n\t\t\t\tnla_nest_end(msg, nl_pat);\n\t\t\t}\n\t\t\tnla_nest_end(msg, nl_pats);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];\n\tstruct cfg80211_wowlan no_triggers = {};\n\tstruct cfg80211_wowlan new_triggers = {};\n\tstruct wiphy_wowlan_support *wowlan = &rdev->wiphy.wowlan;\n\tint err, i;\n\n\tif (!rdev->wiphy.wowlan.flags && !rdev->wiphy.wowlan.n_patterns)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS])\n\t\tgoto no_triggers;\n\n\terr = nla_parse(tb, MAX_NL80211_WOWLAN_TRIG,\n\t\t\tnla_data(info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]),\n\t\t\tnla_len(info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]),\n\t\t\tnl80211_wowlan_policy);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_WOWLAN_TRIG_ANY]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_ANY))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.any = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_DISCONNECT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.disconnect = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.magic_pkt = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {\n\t\tstruct nlattr *pat;\n\t\tint n_patterns = 0;\n\t\tint rem, pat_len, mask_len;\n\t\tstruct nlattr *pat_tb[NUM_NL80211_WOWLAN_PKTPAT];\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem)\n\t\t\tn_patterns++;\n\t\tif (n_patterns > wowlan->n_patterns)\n\t\t\treturn -EINVAL;\n\n\t\tnew_triggers.patterns = kcalloc(n_patterns,\n\t\t\t\t\t\tsizeof(new_triggers.patterns[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_triggers.patterns)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_triggers.n_patterns = n_patterns;\n\t\ti = 0;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem) {\n\t\t\tnla_parse(pat_tb, MAX_NL80211_WOWLAN_PKTPAT,\n\t\t\t\t  nla_data(pat), nla_len(pat), NULL);\n\t\t\terr = -EINVAL;\n\t\t\tif (!pat_tb[NL80211_WOWLAN_PKTPAT_MASK] ||\n\t\t\t    !pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN])\n\t\t\t\tgoto error;\n\t\t\tpat_len = nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]);\n\t\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\t\tif (nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]) !=\n\t\t\t    mask_len)\n\t\t\t\tgoto error;\n\t\t\tif (pat_len > wowlan->pattern_max_len ||\n\t\t\t    pat_len < wowlan->pattern_min_len)\n\t\t\t\tgoto error;\n\n\t\t\tnew_triggers.patterns[i].mask =\n\t\t\t\tkmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\t\tif (!new_triggers.patterns[i].mask) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tnew_triggers.patterns[i].pattern =\n\t\t\t\tnew_triggers.patterns[i].mask + mask_len;\n\t\t\tmemcpy(new_triggers.patterns[i].mask,\n\t\t\t       nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]),\n\t\t\t       mask_len);\n\t\t\tnew_triggers.patterns[i].pattern_len = pat_len;\n\t\t\tmemcpy(new_triggers.patterns[i].pattern,\n\t\t\t       nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]),\n\t\t\t       pat_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (memcmp(&new_triggers, &no_triggers, sizeof(new_triggers))) {\n\t\tstruct cfg80211_wowlan *ntrig;\n\t\tntrig = kmemdup(&new_triggers, sizeof(new_triggers),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ntrig) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wowlan = ntrig;\n\t} else {\n no_triggers:\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wowlan = NULL;\n\t}\n\n\treturn 0;\n error:\n\tfor (i = 0; i < new_triggers.n_patterns; i++)\n\t\tkfree(new_triggers.patterns[i].mask);\n\tkfree(new_triggers.patterns);\n\treturn err;\n}\n\n#define NL80211_FLAG_NEED_WIPHY\t\t0x01\n#define NL80211_FLAG_NEED_NETDEV\t0x02\n#define NL80211_FLAG_NEED_RTNL\t\t0x04\n#define NL80211_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL80211_FLAG_NEED_NETDEV_UP\t(NL80211_FLAG_NEED_NETDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n\nstatic int nl80211_pre_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *dev;\n\tint err;\n\tbool rtnl = ops->internal_flags & NL80211_FLAG_NEED_RTNL;\n\n\tif (rtnl)\n\t\trtnl_lock();\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_WIPHY) {\n\t\trdev = cfg80211_get_dev_from_info(info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {\n\t\terr = get_rdev_dev_by_info_ifindex(info, &rdev, &dev);\n\t\tif (err) {\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn err;\n\t\t}\n\t\tif (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&\n\t\t    !netif_running(dev)) {\n\t\t\tcfg80211_unlock_rdev(rdev);\n\t\t\tdev_put(dev);\n\t\t\tif (rtnl)\n\t\t\t\trtnl_unlock();\n\t\t\treturn -ENETDOWN;\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t\tinfo->user_ptr[1] = dev;\n\t}\n\n\treturn 0;\n}\n\nstatic void nl80211_post_doit(struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tif (info->user_ptr[0])\n\t\tcfg80211_unlock_rdev(info->user_ptr[0]);\n\tif (info->user_ptr[1])\n\t\tdev_put(info->user_ptr[1]);\n\tif (ops->internal_flags & NL80211_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n}\n\nstatic struct genl_ops nl80211_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_GET_WIPHY,\n\t\t.doit = nl80211_get_wiphy,\n\t\t.dumpit = nl80211_dump_wiphy,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY,\n\t\t.doit = nl80211_set_wiphy,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_INTERFACE,\n\t\t.doit = nl80211_get_interface,\n\t\t.dumpit = nl80211_dump_interface,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_INTERFACE,\n\t\t.doit = nl80211_set_interface,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_INTERFACE,\n\t\t.doit = nl80211_new_interface,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_INTERFACE,\n\t\t.doit = nl80211_del_interface,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_KEY,\n\t\t.doit = nl80211_get_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_KEY,\n\t\t.doit = nl80211_set_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_KEY,\n\t\t.doit = nl80211_new_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_KEY,\n\t\t.doit = nl80211_del_key,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BEACON,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = nl80211_addset_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_BEACON,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = nl80211_addset_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_BEACON,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = nl80211_del_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_STATION,\n\t\t.doit = nl80211_get_station,\n\t\t.dumpit = nl80211_dump_station,\n\t\t.policy = nl80211_policy,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_STATION,\n\t\t.doit = nl80211_set_station,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_STATION,\n\t\t.doit = nl80211_new_station,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_STATION,\n\t\t.doit = nl80211_del_station,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPATH,\n\t\t.doit = nl80211_get_mpath,\n\t\t.dumpit = nl80211_dump_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MPATH,\n\t\t.doit = nl80211_set_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_MPATH,\n\t\t.doit = nl80211_new_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_MPATH,\n\t\t.doit = nl80211_del_mpath,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BSS,\n\t\t.doit = nl80211_set_bss,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_REG,\n\t\t.doit = nl80211_get_reg,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_REG,\n\t\t.doit = nl80211_set_reg,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REQ_SET_REG,\n\t\t.doit = nl80211_req_set_reg,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MESH_CONFIG,\n\t\t.doit = nl80211_get_mesh_config,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MESH_CONFIG,\n\t\t.doit = nl80211_update_mesh_config,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TRIGGER_SCAN,\n\t\t.doit = nl80211_trigger_scan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SCAN,\n\t\t.policy = nl80211_policy,\n\t\t.dumpit = nl80211_dump_scan,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_SCHED_SCAN,\n\t\t.doit = nl80211_start_sched_scan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_SCHED_SCAN,\n\t\t.doit = nl80211_stop_sched_scan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_AUTHENTICATE,\n\t\t.doit = nl80211_authenticate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ASSOCIATE,\n\t\t.doit = nl80211_associate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEAUTHENTICATE,\n\t\t.doit = nl80211_deauthenticate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISASSOCIATE,\n\t\t.doit = nl80211_disassociate,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_IBSS,\n\t\t.doit = nl80211_join_ibss,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_IBSS,\n\t\t.doit = nl80211_leave_ibss,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#ifdef CONFIG_NL80211_TESTMODE\n\t{\n\t\t.cmd = NL80211_CMD_TESTMODE,\n\t\t.doit = nl80211_testmode_do,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_CONNECT,\n\t\t.doit = nl80211_connect,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISCONNECT,\n\t\t.doit = nl80211_disconnect,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY_NETNS,\n\t\t.doit = nl80211_wiphy_netns,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SURVEY,\n\t\t.policy = nl80211_policy,\n\t\t.dumpit = nl80211_dump_survey,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMKSA,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMKSA,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FLUSH_PMKSA,\n\t\t.doit = nl80211_flush_pmksa,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t.doit = nl80211_remain_on_channel,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t.doit = nl80211_cancel_remain_on_channel,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TX_BITRATE_MASK,\n\t\t.doit = nl80211_set_tx_bitrate_mask,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_FRAME,\n\t\t.doit = nl80211_register_mgmt,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME,\n\t\t.doit = nl80211_tx_mgmt,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t.doit = nl80211_tx_mgmt_cancel_wait,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_POWER_SAVE,\n\t\t.doit = nl80211_set_power_save,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_POWER_SAVE,\n\t\t.doit = nl80211_get_power_save,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CQM,\n\t\t.doit = nl80211_set_cqm,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CHANNEL,\n\t\t.doit = nl80211_set_channel,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WDS_PEER,\n\t\t.doit = nl80211_set_wds_peer,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_MESH,\n\t\t.doit = nl80211_join_mesh,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_MESH,\n\t\t.doit = nl80211_leave_mesh,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_WOWLAN,\n\t\t.doit = nl80211_get_wowlan,\n\t\t.policy = nl80211_policy,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WOWLAN,\n\t\t.doit = nl80211_set_wowlan,\n\t\t.policy = nl80211_policy,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n};\n\nstatic struct genl_multicast_group nl80211_mlme_mcgrp = {\n\t.name = \"mlme\",\n};\n\n/* multicast groups */\nstatic struct genl_multicast_group nl80211_config_mcgrp = {\n\t.name = \"config\",\n};\nstatic struct genl_multicast_group nl80211_scan_mcgrp = {\n\t.name = \"scan\",\n};\nstatic struct genl_multicast_group nl80211_regulatory_mcgrp = {\n\t.name = \"regulatory\",\n};\n\n/* notification functions */\n\nvoid nl80211_notify_dev_rename(struct cfg80211_registered_device *rdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_wiphy(msg, 0, 0, 0, rdev) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_config_mcgrp.id, GFP_KERNEL);\n}\n\nstatic int nl80211_add_scan_req(struct sk_buff *msg,\n\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *req = rdev->scan_req;\n\tstruct nlattr *nest;\n\tint i;\n\n\tASSERT_RDEV_LOCK(rdev);\n\n\tif (WARN_ON(!req))\n\t\treturn 0;\n\n\tnest = nla_nest_start(msg, NL80211_ATTR_SCAN_SSIDS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_ssids; i++)\n\t\tNLA_PUT(msg, i, req->ssids[i].ssid_len, req->ssids[i].ssid);\n\tnla_nest_end(msg, nest);\n\n\tnest = nla_nest_start(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_channels; i++)\n\t\tNLA_PUT_U32(msg, i, req->channels[i]->center_freq);\n\tnla_nest_end(msg, nest);\n\n\tif (req->ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_IE, req->ie_len, req->ie);\n\n\treturn 0;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_send_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t u32 pid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl80211_send_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *netdev,\n\t\t\t    u32 pid, u32 seq, int flags, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nvoid nl80211_send_scan_start(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_scan_done(struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_NEW_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_SCAN_ABORTED) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t\tNL80211_CMD_SCHED_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\n/*\n * This can happen on global regulatory changes or device specific settings\n * based on custom world regulatory domains.\n */\nvoid nl80211_send_reg_change_event(struct regulatory_request *request)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_CHANGE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/* Userspace can always count this one always being set */\n\tNLA_PUT_U8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator);\n\n\tif (request->alpha2[0] == '0' && request->alpha2[1] == '0')\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_WORLD);\n\telse if (request->alpha2[0] == '9' && request->alpha2[1] == '9')\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_CUSTOM_WORLD);\n\telse if ((request->alpha2[0] == '9' && request->alpha2[1] == '8') ||\n\t\t request->intersect)\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_INTERSECTION);\n\telse {\n\t\tNLA_PUT_U8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t   NL80211_REGDOM_TYPE_COUNTRY);\n\t\tNLA_PUT_STRING(msg, NL80211_ATTR_REG_ALPHA2, request->alpha2);\n\t}\n\n\tif (wiphy_idx_valid(request->wiphy_idx))\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(msg, 0, nl80211_regulatory_mcgrp.id,\n\t\t\t\tGFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    enum nl80211_commands cmd, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_FRAME, len, buf);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_AUTHENTICATE, gfp);\n}\n\nvoid nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_ASSOCIATE, gfp);\n}\n\nvoid nl80211_send_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *buf,\n\t\t\t size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DEAUTHENTICATE, gfp);\n}\n\nvoid nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp);\n}\n\nvoid nl80211_send_unprot_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *buf,\n\t\t\t\tsize_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_UNPROT_DEAUTHENTICATE, gfp);\n}\n\nvoid nl80211_send_unprot_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_UNPROT_DISASSOCIATE, gfp);\n}\n\nstatic void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct net_device *netdev, int cmd,\n\t\t\t\t      const u8 *addr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT_FLAG(msg, NL80211_ATTR_TIMED_OUT);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, const u8 *addr,\n\t\t\t       gfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_AUTHENTICATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_assoc_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *addr,\n\t\t\t\tgfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_ASSOCIATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_connect_result(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *bssid,\n\t\t\t\t const u8 *req_ie, size_t req_ie_len,\n\t\t\t\t const u8 *resp_ie, size_t resp_ie_len,\n\t\t\t\t u16 status, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tif (bssid)\n\t\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);\n\tNLA_PUT_U16(msg, NL80211_ATTR_STATUS_CODE, status);\n\tif (req_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_REQ_IE, req_ie_len, req_ie);\n\tif (resp_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_RESP_IE, resp_ie_len, resp_ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\n}\n\nvoid nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *bssid,\n\t\t\t const u8 *req_ie, size_t req_ie_len,\n\t\t\t const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);\n\tif (req_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_REQ_IE, req_ie_len, req_ie);\n\tif (resp_ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_RESP_IE, resp_ie_len, resp_ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\n}\n\nvoid nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tif (from_ap && reason)\n\t\tNLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);\n\tif (from_ap)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);\n\tif (ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\n}\n\nvoid nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_JOIN_IBSS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_new_peer_candidate(struct cfg80211_registered_device *rdev,\n\t\tstruct net_device *netdev,\n\t\tconst u8 *macaddr, const u8* ie, u8 ie_len,\n\t\tgfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NEW_PEER_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, macaddr);\n\tif (ie_len && ie)\n\t\tNLA_PUT(msg, NL80211_ATTR_IE, ie_len , ie);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *addr,\n\t\t\t\t enum nl80211_key_type key_type, int key_id,\n\t\t\t\t const u8 *tsc, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MICHAEL_MIC_FAILURE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tif (addr)\n\t\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);\n\tNLA_PUT_U32(msg, NL80211_ATTR_KEY_TYPE, key_type);\n\tNLA_PUT_U8(msg, NL80211_ATTR_KEY_IDX, key_id);\n\tif (tsc)\n\t\tNLA_PUT(msg, NL80211_ATTR_KEY_SEQ, 6, tsc);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/*\n\t * Since we are applying the beacon hint to a wiphy we know its\n\t * wiphy_idx is valid\n\t */\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy));\n\n\t/* Before */\n\tnl_freq = nla_nest_start(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\tif (nl80211_msg_put_channel(msg, channel_before))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t/* After */\n\tnl_freq = nla_nest_start(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\tif (nl80211_msg_put_channel(msg, channel_after))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(msg, 0, nl80211_regulatory_mcgrp.id,\n\t\t\t\tGFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_remain_on_chan_event(\n\tint cmd, struct cfg80211_registered_device *rdev,\n\tstruct net_device *netdev, u64 cookie,\n\tstruct ieee80211_channel *chan,\n\tenum nl80211_channel_type channel_type,\n\tunsigned int duration, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, channel_type);\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\n\tif (cmd == NL80211_CMD_REMAIN_ON_CHANNEL)\n\t\tNLA_PUT_U32(msg, NL80211_ATTR_DURATION, duration);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_remain_on_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev, u64 cookie,\n\t\t\t\t    struct ieee80211_channel *chan,\n\t\t\t\t    enum nl80211_channel_type channel_type,\n\t\t\t\t    unsigned int duration, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, netdev, cookie, chan,\n\t\t\t\t\t  channel_type, duration, gfp);\n}\n\nvoid nl80211_send_remain_on_channel_cancel(\n\tstruct cfg80211_registered_device *rdev, struct net_device *netdev,\n\tu64 cookie, struct ieee80211_channel *chan,\n\tenum nl80211_channel_type channel_type, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, netdev, cookie, chan,\n\t\t\t\t\t  channel_type, 0, gfp);\n}\n\nvoid nl80211_send_sta_event(struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_station(msg, 0, 0, 0, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n}\n\nvoid nl80211_send_sta_del_event(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *dev, const u8 *mac_addr,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_STATION);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nint nl80211_send_mgmt(struct cfg80211_registered_device *rdev,\n\t\t      struct net_device *netdev, u32 nlpid,\n\t\t      int freq, const u8 *buf, size_t len, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);\n\tNLA_PUT(msg, NL80211_ATTR_FRAME, len, buf);\n\n\terr = genlmsg_end(msg, hdr);\n\tif (err < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\terr = genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlpid);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid nl80211_send_mgmt_tx_status(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, u64 cookie,\n\t\t\t\t const u8 *buf, size_t len, bool ack,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME_TX_STATUS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_FRAME, len, buf);\n\tNLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);\n\tif (ack)\n\t\tNLA_PUT_FLAG(msg, NL80211_ATTR_ACK);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast(msg, 0, nl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid\nnl80211_send_cqm_rssi_notify(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev,\n\t\t\t     enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *pinfoattr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t    rssi_event);\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nvoid\nnl80211_send_cqm_pktloss_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *peer,\n\t\t\t\tu32 num_packets, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *pinfoattr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\tNLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, peer);\n\n\tpinfoattr = nla_nest_start(msg, NL80211_ATTR_CQM);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets);\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tif (genlmsg_end(msg, hdr) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\n\nstatic int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\n\tif (state != NETLINK_URELEASE)\n\t\treturn NOTIFY_DONE;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list)\n\t\tlist_for_each_entry_rcu(wdev, &rdev->netdev_list, list)\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->pid);\n\n\trcu_read_unlock();\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nl80211_netlink_notifier = {\n\t.notifier_call = nl80211_netlink_notify,\n};\n\n/* initialisation/exit functions */\n\nint nl80211_init(void)\n{\n\tint err;\n\n\terr = genl_register_family_with_ops(&nl80211_fam,\n\t\tnl80211_ops, ARRAY_SIZE(nl80211_ops));\n\tif (err)\n\t\treturn err;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_config_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_scan_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_regulatory_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_mlme_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n\n#ifdef CONFIG_NL80211_TESTMODE\n\terr = genl_register_mc_group(&nl80211_fam, &nl80211_testmode_mcgrp);\n\tif (err)\n\t\tgoto err_out;\n#endif\n\n\terr = netlink_register_notifier(&nl80211_netlink_notifier);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n err_out:\n\tgenl_unregister_family(&nl80211_fam);\n\treturn err;\n}\n\nvoid nl80211_exit(void)\n{\n\tnetlink_unregister_notifier(&nl80211_netlink_notifier);\n\tgenl_unregister_family(&nl80211_fam);\n}\n"], "filenames": ["net/wireless/nl80211.c"], "buggy_code_start_loc": [3408], "buggy_code_end_loc": [3583], "fixing_code_start_loc": [3409], "fixing_code_end_loc": [3582], "type": "CWE-119", "message": "Multiple buffer overflows in net/wireless/nl80211.c in the Linux kernel before 2.6.39.2 allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability during scan operations with a long SSID value.", "other": {"cve": {"id": "CVE-2011-2517", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:01.510", "lastModified": "2023-02-13T01:20:00.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple buffer overflows in net/wireless/nl80211.c in the Linux kernel before 2.6.39.2 allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability during scan operations with a long SSID value."}, {"lang": "es", "value": "M\u00faltiples desbordamientos de b\u00fafer en net/wireless/nl80211.c en el kernel de Linux antes de v2.6.39.2 permite a usuarios locales obtener privilegios mediante el aprovechamiento de la capacidad CAP_NET_ADMIN durante las operaciones de exploraci\u00f3n con un valor de SSID de largo."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39.2", "matchCriteriaId": "800B0EA0-5CBB-429B-9B0B-4926F84458DC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1D8B549B-E57B-4DFE-8A13-CAB06B5356B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "133AAFA7-AF42-4D7B-8822-AA2E85611BF5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "54D669D4-6D7E-449D-80C1-28FA44F06FFE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D0AC5CD5-6E58-433C-9EB3-6DFE5656463E"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39.2", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=208c72f4fe44fe09577e7975ba0e7fa0278f3d03", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2011-1212.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/07/01/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=718152", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03"}}