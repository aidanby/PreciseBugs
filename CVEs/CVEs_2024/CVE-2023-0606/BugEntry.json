{"buggy_code": ["<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\n\n?>\n<form style=\"display:inline;\" name=\"f\" method=\"get\" action=\"<?php echo AmpConfig::get('web_path') . \"/$action\"; ?>\" enctype=\"multipart/form-data\">\n    <label for=\"match\" accesskey=\"S\"><?php echo $text; ?></label>\n    <input type=\"text\" id=\"match\" name=\"match\" value=\"<?php echo $match; ?>\" />\n    <input type=\"hidden\" name=\"action\" value=\"<?php echo scrub_out(filter_input(INPUT_GET, 'action', FILTER_SANITIZE_URL)); ?>\">\n</form>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS, FILTER_FLAG_NO_ENCODE_QUOTES);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Browse Ampache...'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'album_disk' || $filter_str == 'album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('label')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'label') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=label\"><?php echo T_('Labels'); ?></a>\n    <?php }\n    if (AmpConfig::get('broadcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'broadcast') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=broadcast\"><?php echo T_('Broadcasts'); ?></a>\n    <?php }\n    if (AmpConfig::get('live_stream')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'live_stream') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=live_stream\"><?php echo T_('Radio Stations'); ?></a>\n    <?php }\n    if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'podcast') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=podcast\"><?php echo T_('Podcasts'); ?></a>\n        <a class=\"category <?php echo ($filter_str == 'podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS, FILTER_FLAG_NO_ENCODE_QUOTES);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Top Rated'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'highest_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'highest_album_disk' || $filter_str == 'highest_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'highest_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'highest_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'highest_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Authorization\\Access;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS, FILTER_FLAG_NO_ENCODE_QUOTES);\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Dashboards'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'album_disk' || $filter_str == 'album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=<?php echo $albumString; ?>\">\n        <?php echo T_('Albums'); ?>\n    </a>\n    <a class=\"category <?php echo ($filter_str == 'artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=artist\">\n        <?php echo T_('Artists'); ?>\n    </a>\n    <?php if (Access::check('interface', 25)) { ?>\n    <a class=\"category <?php echo ($filter_str == 'playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=playlist\">\n        <?php echo T_('Playlists'); ?>\n    </a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n</div>", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS, FILTER_FLAG_NO_ENCODE_QUOTES);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Newest'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'newest_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'newest_album_disk' || $filter_str == 'newest_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'newest_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'newest_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'newest_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS, FILTER_FLAG_NO_ENCODE_QUOTES);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Popular'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'popular_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'popular_album_disk' || $filter_str == 'popular_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'popular_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'popular_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'popular_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS, FILTER_FLAG_NO_ENCODE_QUOTES);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Recent'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'recent_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'recent_album_disk' || $filter_str == 'recent_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'recent_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'recent_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS, FILTER_FLAG_NO_ENCODE_QUOTES);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Favorites'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'userflag_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'userflag_album_disk' || $filter_str == 'userflag_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'userflag_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'userflag_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'userflag_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Util\\Graph;\nuse Ampache\\Module\\Util\\Ui;\n\n$boxtitle = T_('Statistical Graphs');\nif ($blink) {\n    $boxtitle .= ' - ' . $blink;\n} ?>\n<?php Ui::show_box_top($boxtitle, 'box box_graph'); ?>\n<div class=\"stats_graph\">\n    <?php $web_path = AmpConfig::get('web_path');\n    foreach ($gtypes as $gtype) {\n        $graph_link = $web_path . \"/graph.php?type=\" . $gtype . \"&start_date=\" . $start_date . \"&end_date=\" . $end_date . \"&zoom=\" . $zoom . \"&user_id=\" . $user_id . \"&object_type=\" . $object_type . \"&object_id=\" . $object_id; ?>\n    <a href=\"<?php echo $graph_link; ?>&width=1400&height=690\" target=\"_blank\" title=\"<?php echo T_('Show large'); ?>\"><img src=\"<?php echo $graph_link; ?>\" /></a>\n        <br /><br />\n    <?php\n    } ?>\n</div>\n\n<?php\nif (AmpConfig::get('geolocation')) { ?>\n    <div class=\"stats_graph\">\n    <?php\n        $graph = new Graph();\n        $graph->display_map($user_id, $object_type, $object_id, $start_date, $end_date, $zoom); ?>\n    </div>\n<?php } ?>\n\n<form action='<?php echo get_current_path(); ?>' method='post' enctype='multipart/form-data'>\n    <dl class=\"media_details\">\n        <dt><?php echo T_('Start Date'); ?></dt>\n        <dd><input type=\"text\" name=\"start_date\" id=\"start_date\" value=\"<?php echo $f_start_date; ?>\" /></dd>\n        <dt><?php echo T_('End Date'); ?></dt>\n        <dd><input type=\"text\" name=\"end_date\" id=\"end_date\" value=\"<?php echo $f_end_date; ?>\" /></dd>\n        <dt><?php echo T_('Zoom'); ?></dt>\n        <dd>\n            <select name=\"zoom\">\n            <?php\n                $date_formats = array(\n                    'year' => T_('Year'),\n                    'month' => T_('Month'),\n                    'day' => T_('Day'),\n                    'hour' => T_('Hour')\n                );\n                foreach ($date_formats as $dtype => $dname) {\n                    echo \"<option value='\" . $dtype . \"' \";\n                    if ($dtype == $zoom) {\n                        echo \"selected\";\n                    }\n                    echo \">\" . $dname . \"</option>\";\n                } ?>\n            </select>\n        </dd>\n        <dt></dt>\n        <dd>\n            <input type=\"submit\" value=\"<?php echo T_('View'); ?>\" />\n        </dd>\n    </dl>\n    <input type=\"hidden\" name=\"user_id\" value=\"<?php echo $user_id; ?>\" />\n    <input type=\"hidden\" name=\"object_type\" value=\"<?php echo $object_type; ?>\" />\n    <input type=\"hidden\" name=\"object_id\" value=\"<?php echo $object_id; ?>\" />\n    <input type=\"hidden\" name=\"action\" value=\"<?php echo filter_input(INPUT_GET, 'action', FILTER_SANITIZE_URL); ?>\" />\n    <input type=\"hidden\" name=\"type\" value=\"<?php echo $type; ?>\" />\n</form>\n<script>\n    $('#start_date').datetimepicker({\n        format: 'Y-m-d H:i',\n        theme: 'dark'\n    });\n    $('#end_date').datetimepicker({\n        format:'Y-m-d H:i',\n        theme: 'dark'\n    });\n</script>\n<?php Ui::show_box_bottom(); ?>\n", "<?php\n\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=1);\n\nnamespace Ampache\\Module\\Application;\n\nuse Ampache\\Module\\Application\\Exception\\AccessDeniedException;\nuse Ampache\\Module\\Authorization\\GatekeeperFactoryInterface;\nuse Ampache\\Module\\System\\LegacyLogger;\nuse Ampache\\Module\\Util\\UiInterface;\nuse Narrowspark\\HttpEmitter\\SapiEmitter;\nuse Psr\\Container\\ContainerExceptionInterface;\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Throwable;\n\nfinal class ApplicationRunner\n{\n    private ContainerInterface $dic;\n\n    private LoggerInterface $logger;\n\n    private GatekeeperFactoryInterface $gatekeeperFactory;\n\n    private UiInterface $ui;\n\n    public function __construct(\n        ContainerInterface $dic,\n        LoggerInterface $logger,\n        GatekeeperFactoryInterface $gatekeeperFactory,\n        UiInterface $ui\n    ) {\n        $this->dic               = $dic;\n        $this->logger            = $logger;\n        $this->gatekeeperFactory = $gatekeeperFactory;\n        $this->ui                = $ui;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param array<string, string> $action_list A dict containing request keys and handler class names\n     * @param string $default_action The request key for the default action\n     */\n    public function run(\n        ServerRequestInterface $request,\n        array $action_list,\n        string $default_action\n    ): void {\n        $action_name = $request->getParsedBody()['action'] ?? $request->getQueryParams()['action'] ?? '';\n\n        if (array_key_exists($action_name, $action_list) === false) {\n            $action_name = $default_action;\n        }\n\n        $handler_name = $action_list[$action_name] ?? '';\n\n        try {\n            /** @var ApplicationActionInterface $handler */\n            $handler = $this->dic->get($handler_name);\n        } catch (ContainerExceptionInterface $e) {\n            $this->logger->critical(\n                sprintf('No handler found for action \"%s\"', $action_name),\n                [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n            );\n\n            return;\n        }\n\n        $this->logger->debug(\n            sprintf('Found handler \"%s\" for action \"%s\"', $handler_name, $action_name),\n            [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n        );\n\n        try {\n            $response = $handler->run(\n                $request,\n                $this->gatekeeperFactory->createGuiGatekeeper()\n            );\n\n            /**\n             * Emit response if available.\n             * This will become the default once the rendering of all actions got converted\n             */\n            if ($response !== null) {\n                $this->dic->get(SapiEmitter::class)->emit($response);\n            }\n        } catch (AccessDeniedException $e) {\n            $message = $e->getMessage();\n\n            $this->logger->warning(\n                $message,\n                [\n                    LegacyLogger::CONTEXT_TYPE => sprintf(\n                        '\"%s\" for \"%s\"',\n                        __CLASS__,\n                        $e->getFile()\n                    )\n                ]\n            );\n\n            $this->ui->accessDenied($message);\n\n            return;\n        } catch (Throwable $e) {\n            $this->logger->critical(\n                $e->getMessage(),\n                [\n                    LegacyLogger::CONTEXT_TYPE => sprintf(\n                        '%s:%d',\n                        $e->getFile(),\n                        $e->getLine()\n                    )\n                ]\n            );\n            /**\n             * @todo Add a nice error page\n             */\n        }\n    }\n}\n", "<?php\n\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Application\\Playback;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Application\\ApplicationActionInterface;\nuse Ampache\\Module\\Application\\Exception\\AccessDeniedException;\nuse Ampache\\Module\\Authentication\\AuthenticationManagerInterface;\nuse Ampache\\Module\\Authorization\\AccessLevelEnum;\nuse Ampache\\Module\\Authorization\\Check\\NetworkCheckerInterface;\nuse Ampache\\Module\\Authorization\\GuiGatekeeperInterface;\nuse Ampache\\Module\\Playback\\Stream;\nuse Ampache\\Module\\Playback\\Stream_Playlist;\nuse Ampache\\Module\\Statistics\\Stats;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\System\\Session;\nuse Ampache\\Module\\Util\\Horde_Browser;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Repository\\Model\\Catalog;\nuse Ampache\\Repository\\Model\\Democratic;\nuse Ampache\\Repository\\Model\\Podcast_Episode;\nuse Ampache\\Repository\\Model\\Preference;\nuse Ampache\\Repository\\Model\\Random;\nuse Ampache\\Repository\\Model\\Share;\nuse Ampache\\Repository\\Model\\Song;\nuse Ampache\\Repository\\Model\\Song_Preview;\nuse Ampache\\Repository\\Model\\User;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\UserRepositoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfinal class PlayAction implements ApplicationActionInterface\n{\n    public const REQUEST_KEY = 'play';\n\n    private Horde_Browser $browser;\n\n    private AuthenticationManagerInterface $authenticationManager;\n\n    private NetworkCheckerInterface $networkChecker;\n\n    private UserRepositoryInterface $userRepository;\n\n    public function __construct(\n        Horde_Browser $browser,\n        AuthenticationManagerInterface $authenticationManager,\n        NetworkCheckerInterface $networkChecker,\n        UserRepositoryInterface $userRepository\n    ) {\n        $this->browser               = $browser;\n        $this->authenticationManager = $authenticationManager;\n        $this->networkChecker        = $networkChecker;\n        $this->userRepository        = $userRepository;\n    }\n\n    public function run(ServerRequestInterface $request, GuiGatekeeperInterface $gatekeeper): ?ResponseInterface\n    {\n        ob_end_clean();\n\n        //debug_event('play/index', print_r(apache_request_headers(), true), 5);\n\n        /**\n         * The following code takes a \"beautiful\" url, splits it into key/value pairs and\n         * then replaces the PHP $_REQUEST as if the URL had arrived in un-beautified form.\n         * (This is necessary to avoid some DLNA players barfing on the URL, particularly Windows Media Player)\n         *\n         * The reason for not trying to do the whole job in mod_rewrite is that there are typically\n         * more than 10 arguments to this function now, and that's tricky with mod_rewrite's 10 arg limit\n         */\n        $slashcount = substr_count($_SERVER['QUERY_STRING'], '/');\n        if ($slashcount > 2) {\n            // e.g. ssid/3ca112fff23376ef7c74f018497dd39d/type/song/oid/280/uid/player/api/name/Glad.mp3\n            $new_arr     = explode('/', $_SERVER['QUERY_STRING']);\n            $new_request = array();\n            $key         = null;\n            $i           = 0;\n            // alternate key and value through the split array e.g:\n            // array('ssid', '3ca112fff23376ef7c74f018497dd39d', 'type', 'song', 'oid', '280', 'uid', 'player', 'api', 'name', 'Glad.mp3))\n            foreach ($new_arr as $v) {\n                if ($i == 0) {\n                    // key name\n                    $key = $v;\n                    $i   = 1;\n                } else {\n                    // key value\n                    $value = $v;\n                    $i     = 0;\n                    // set it now that you've set both\n                    $new_request[$key] = $value;\n                }\n            }\n            $_REQUEST = $new_request;\n        }\n\n        /* These parameters had better come in on the url. */\n        $action       = (string)filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n        $stream_name  = (string)filter_input(INPUT_GET, 'name', FILTER_SANITIZE_SPECIAL_CHARS);\n        $object_id    = (int)scrub_in(filter_input(INPUT_GET, 'oid', FILTER_SANITIZE_SPECIAL_CHARS));\n        $user_id      = (int)scrub_in(filter_input(INPUT_GET, 'uid', FILTER_SANITIZE_SPECIAL_CHARS));\n        $session_id   = (string)scrub_in(filter_input(INPUT_GET, 'ssid', FILTER_SANITIZE_SPECIAL_CHARS));\n        $type         = (string)scrub_in(filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS));\n        $client       = (string)scrub_in(filter_input(INPUT_GET, 'client', FILTER_SANITIZE_SPECIAL_CHARS));\n        $cache        = (string)scrub_in(filter_input(INPUT_GET, 'cache', FILTER_SANITIZE_SPECIAL_CHARS));\n        $format       = (string)scrub_in(filter_input(INPUT_GET, 'format', FILTER_SANITIZE_SPECIAL_CHARS));\n        $bitrate      = (int)scrub_in(filter_input(INPUT_GET, 'bitrate', FILTER_SANITIZE_SPECIAL_CHARS));\n        $original     = ($format == 'raw');\n        $transcode_to = (!$original && $format != '') ? $format : (string)scrub_in(filter_input(INPUT_GET, 'transcode_to', FILTER_SANITIZE_SPECIAL_CHARS));\n        $player       = (string)scrub_in(filter_input(INPUT_GET, 'player', FILTER_SANITIZE_SPECIAL_CHARS));\n        $record_stats = true;\n        $use_auth     = AmpConfig::get('use_auth');\n\n        // Share id and secret if used\n        $share_id = (int)filter_input(INPUT_GET, 'share_id', FILTER_SANITIZE_NUMBER_INT);\n        $secret   = (string)scrub_in(filter_input(INPUT_GET, 'share_secret', FILTER_SANITIZE_SPECIAL_CHARS));\n\n        // This is specifically for tmp playlist requests\n        $demo_id    = (string)scrub_in(filter_input(INPUT_GET, 'demo_id', FILTER_SANITIZE_SPECIAL_CHARS));\n        $random     = (string)scrub_in(filter_input(INPUT_GET, 'random', FILTER_SANITIZE_SPECIAL_CHARS));\n\n        // democratic play url doesn't include these\n        if ($demo_id !== '') {\n            $type = 'song';\n        }\n        // random play url can be multiple types but default to song if missing\n        if ($random !== '') {\n            $type = 'song';\n        }\n        // if you don't specify, assume stream\n        if (empty($action)) {\n            $action = 'stream';\n        }\n        // allow disabling stat recording from the play url\n        if (($action == 'download' || $cache == '1') && !in_array($type, array('song', 'video', 'podcast_episode'))) {\n            debug_event('play/index', 'record_stats disabled: cache {' . $type . \"}\", 5);\n            $action       = 'download';\n            $record_stats = false;\n        }\n        $is_download   = ($action == 'download' || $cache == '1');\n        $maxbitrate    = 0;\n        $media_bitrate = 0;\n        $resolution    = '';\n        $quality       = 0;\n        $time          = time();\n\n        if (AmpConfig::get('transcode_player_customize') && !$original) {\n            $transcode_to = $transcode_to ?? (string)scrub_in(filter_input(INPUT_GET, 'transcode_to', FILTER_SANITIZE_SPECIAL_CHARS));\n\n            // Trick to avoid LimitInternalRecursion reconfiguration\n            $vsettings = (string)scrub_in(filter_input(INPUT_GET, 'transcode_to', FILTER_SANITIZE_SPECIAL_CHARS));\n            if (!empty($vsettings)) {\n                $vparts  = explode('-', $vsettings);\n                $v_count = count($vparts);\n                for ($i = 0; $i < $v_count; $i += 2) {\n                    switch ($vparts[$i]) {\n                        case 'maxbitrate':\n                            $maxbitrate = (int) ($vparts[$i + 1]);\n                            break;\n                        case 'resolution':\n                            $resolution = $vparts[$i + 1];\n                            break;\n                        case 'quality':\n                            $quality = (int) ($vparts[$i + 1]);\n                            break;\n                    }\n                }\n            }\n        }\n        $subtitle         = '';\n        $send_full_stream = (string)AmpConfig::get('send_full_stream');\n        $send_all_in_once = ($send_full_stream == 'true' || $send_full_stream == $player);\n\n        if (!$type) {\n            $type = 'song';\n        }\n\n        debug_event('play/index', \"Asked for type {{$type}}\", 5);\n\n        if ($type == 'playlist') {\n            $playlist_type = scrub_in($_REQUEST['playlist_type']);\n            $object_id     = $session_id;\n        }\n\n        // First things first, if we don't have a uid/oid stop here\n        if (empty($object_id) && (!$demo_id && !$share_id && !$secret && !$random)) {\n            debug_event('play/index', 'No object OID specified, nothing to play', 2);\n            header('HTTP/1.1 400 Nothing To Play');\n\n            return null;\n        }\n\n        // Authenticate the user if specified\n        $username = $_REQUEST['PHP_AUTH_USER'] ?? '';\n        if (empty($username)) {\n            $username = $_REQUEST['u'] ?? '';\n        }\n        $password = $_REQUEST['PHP_AUTH_PW'] ?? '';\n        if (empty($password)) {\n            $password = $_REQUEST['p'] ?? '';\n        }\n        $apikey    = $_REQUEST['apikey'] ?? '';\n        $user      = null;\n        $user_auth = false;\n        // If explicit user authentication was passed\n        if (!empty($session_id)) {\n            $user = $this->userRepository->findByStreamToken(trim($session_id));\n            if ($user) {\n                $user_auth = true;\n                $agent     = (!empty($client))\n                    ? $client\n                    : substr(Core::get_server('HTTP_USER_AGENT'), 0, 254);\n                // this is a permastream link so create a session\n                if (!Session::exists('stream', $session_id)) {\n                    Session::create(array(\n                            'sid' => $session_id,\n                            'username' => $user->username,\n                            'value' => '',\n                            'type' => 'stream',\n                            'agent' => ''\n                        )\n                    );\n                } else {\n                    Session::update_agent($session_id, $agent);\n                    Session::extend($session_id, 'stream');\n                }\n            }\n        } elseif (!empty($apikey)) {\n            $user = $this->userRepository->findByApiKey(trim($apikey));\n            if ($user) {\n                $user_auth = true;\n            }\n        } elseif (!empty($username) && !empty($password)) {\n            $auth = $this->authenticationManager->login($username, $password);\n            if ($auth['success']) {\n                $user      = User::get_from_username($auth['username']);\n                $user_auth = true;\n            }\n        }\n        // try the session ID as well\n        if ($user == null) {\n            $user = User::get_from_username(Session::username($session_id));\n        }\n\n        $session_name = AmpConfig::get('session_name');\n        // Identify the user according to it's web session\n        // We try to avoid the generic 'Ampache User' as much as possible\n        if (!($user instanceof User) && array_key_exists($session_name, $_COOKIE) && Session::exists('interface', $_COOKIE[$session_name])) {\n            Session::check();\n            $user = (array_key_exists('userdata', $_SESSION) && array_key_exists('username', $_SESSION['userdata']))\n                ? User::get_from_username($_SESSION['userdata']['username'])\n                : new User(-1);\n        }\n\n        // did you pass a specific user id? (uid)\n        $user_id = ($user instanceof User)\n            ? $user->id\n            : $user_id;\n\n        if (!$share_id) {\n            // No explicit authentication, use session\n            if (!$user instanceof User) {\n                $user = new User($user_id);\n            }\n\n            // If the user has been disabled (true value)\n            if (make_bool($user->disabled)) {\n                debug_event('play/index', $user->username . \" is currently disabled, stream access denied\", 3);\n                header('HTTP/1.1 403 User disabled');\n\n                return null;\n            }\n\n            // If require_session is set then we need to make sure we're legit\n            if (!$user_auth && $use_auth && AmpConfig::get('require_session')) {\n                if (!AmpConfig::get('require_localnet_session') && $this->networkChecker->check(AccessLevelEnum::TYPE_NETWORK, Core::get_global('user')->id, AccessLevelEnum::LEVEL_GUEST)) {\n                    debug_event('play/index', 'Streaming access allowed for local network IP ' . filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP), 4);\n                } elseif (!Session::exists('stream', $session_id)) {\n                    // No valid session id given, try with cookie session from web interface\n                    $session_id = $_COOKIE[$session_name] ?? false;\n                    if (!Session::exists('interface', $session_id)) {\n                        debug_event('play/index', \"Streaming access denied: Session $session_id has expired\", 3);\n                        header('HTTP/1.1 403 Session Expired');\n\n                        return null;\n                    }\n                }\n                // Now that we've confirmed the session is valid extend it\n                Session::extend($session_id, 'stream');\n            }\n\n            // Update the users last seen information\n            $this->userRepository->updateLastSeen($user->id);\n        } else {\n            $user_id = 0;\n            $share   = new Share((int) $share_id);\n\n            if (!$share->is_valid($secret, 'stream')) {\n                header('HTTP/1.1 403 Access Unauthorized');\n\n                return null;\n            }\n\n            if (!$share->is_shared_media($object_id)) {\n                header('HTTP/1.1 403 Access Unauthorized');\n\n                return null;\n            }\n\n            $user = new User($share->user);\n        }\n\n        if (!($user instanceof User) && (!$share_id && !$secret)) {\n            debug_event('play/index', 'No user specified {' . print_r($user, true) . '}', 2);\n            header('HTTP/1.1 400 No User Specified');\n\n            return null;\n        }\n        Session::createGlobalUser($user);\n        Preference::init();\n\n        // If we are in demo mode; die here\n        if (AmpConfig::get('demo_mode')) {\n            throw new AccessDeniedException(\n                'Streaming Access Denied: Disable demo_mode in \\'config/ampache.cfg.php\\''\n            );\n        }\n        // Check whether streaming is allowed\n        $prefs = AmpConfig::get('allow_stream_playback') && $_SESSION['userdata']['preferences']['allow_stream_playback'];\n        if (!$prefs) {\n            throw new AccessDeniedException(\n                'Streaming Access Denied: Enable \\'Allow Streaming\\' in Server Config -> Options'\n            );\n        }\n\n        // If they are using access lists let's make sure that they have enough access to play this mojo\n        if (AmpConfig::get('access_control')) {\n            if (\n                !$this->networkChecker->check(AccessLevelEnum::TYPE_STREAM, Core::get_global('user')->id) &&\n                !$this->networkChecker->check(AccessLevelEnum::TYPE_NETWORK, Core::get_global('user')->id)\n            ) {\n                throw new AccessDeniedException(\n                    sprintf('Streaming Access Denied: %s does not have stream level access', Core::get_user_ip())\n                );\n            }\n        } // access_control is enabled\n\n        // Handle playlist downloads\n        if ($type == 'playlist' && isset($playlist_type)) {\n            $playlist = new Stream_Playlist($object_id);\n            // Some rudimentary security\n            if ($user_id != $playlist->user) {\n                throw new AccessDeniedException();\n            }\n\n            $playlist->generate_playlist($playlist_type);\n\n            return null;\n        }\n\n        /**\n         * If we've got a Democratic playlist then get the current song and redirect to that media files URL\n         */\n        if ($demo_id !== '') {\n            $democratic = new Democratic($demo_id);\n            $democratic->set_parent();\n\n            // If there is a cooldown we need to make sure this song isn't a repeat\n            if (!$democratic->cooldown) {\n                // This takes into account votes, etc and removes the\n                $object_id = $democratic->get_next_object();\n            } else {\n                // Pull history\n                $song_cool_check = 0;\n                $object_id       = $democratic->get_next_object($song_cool_check);\n                $object_ids      = $democratic->get_cool_songs();\n                while (in_array($object_id, $object_ids)) {\n                    $song_cool_check++;\n                    $object_id = $democratic->get_next_object($song_cool_check);\n                    if ($song_cool_check >= '5') {\n                        break;\n                    }\n                } // while we've got the 'new' song in old the array\n            } // end if we've got a cooldown\n            $media = new Song($object_id);\n            if ($media->id > 0) {\n                // Always remove the play from the list\n                $democratic->delete_from_oid($object_id, $type);\n\n                // If the media is disabled\n                if ((isset($media->enabled) && !make_bool($media->enabled)) || !Core::is_readable(Core::conv_lc_file($media->file))) {\n                    debug_event('play/index', \"Error: \" . $media->file . \" is currently disabled, song skipped\", 3);\n                    header('HTTP/1.1 404 File disabled');\n\n                    return null;\n                }\n\n                // play the song instead of going through all the crap\n                header('Location: ' . $media->play_url('', $player, false, $user->id, $user->streamtoken));\n\n                return null;\n            }\n            debug_event('play/index', \"Error: DEMOCRATIC song could not be found\", 3);\n            header('HTTP/1.1 404 File not found');\n\n            return null;\n        } // if democratic ID passed\n\n        /**\n         * if we are doing random let's pull the random object and redirect to that media files URL\n         */\n        if ($random !== '') {\n            if (array_key_exists('start', $_REQUEST) && (int)Core::get_request('start') > 0 && array_key_exists('random', $_SESSION) && array_key_exists('last', $_SESSION['random'])) {\n                // continue the current object\n                $object_id = $_SESSION['random']['last'];\n            } else {\n                // get a new random object and redirect to that object\n                if (array_key_exists('random_type', $_REQUEST)) {\n                    $rtype = $_REQUEST['random_type'];\n                } else {\n                    $rtype = $type;\n                }\n                $object_id = Random::get_single_song($rtype, $user, (int)$_REQUEST['random_id']);\n                if ($object_id > 0) {\n                    // Save this one in case we do a seek\n                    $_SESSION['random']['last'] = $object_id;\n                }\n                $media = new Song($object_id);\n                if ($media->id > 0) {\n                    // If the media is disabled\n                    if ((isset($media->enabled) && !make_bool($media->enabled)) || !Core::is_readable(Core::conv_lc_file($media->file))) {\n                        debug_event('play/index', \"Error: \" . $media->file . \" is currently disabled, song skipped\", 3);\n                        header('HTTP/1.1 404 File disabled');\n\n                        return null;\n                    }\n\n                    // play the song instead of going through all the crap\n                    header('Location: ' . $media->play_url('', $player, false, $user->id, $user->streamtoken));\n\n                    return null;\n                }\n                debug_event('play/index', \"Error: RANDOM song could not be found\", 3);\n                header('HTTP/1.1 404 File not found');\n\n                return null;\n            }\n        } // if random\n\n        if ($type == 'video') {\n            $media = new Video($object_id);\n            if (array_key_exists('subtitle', $_REQUEST)) {\n                $subtitle = $media->get_subtitle_file($_REQUEST['subtitle']);\n            }\n        } elseif ($type == 'song_preview') {\n            $media = new Song_Preview($object_id);\n        } elseif ($type == 'podcast_episode') {\n            $media = new Podcast_Episode((int) $object_id);\n        } else {\n            // default to song\n            $media = new Song($object_id);\n        }\n        $media->format();\n\n        if (!User::stream_control(array(array('object_type' => $type, 'object_id' => $media->id)))) {\n            throw new AccessDeniedException(\n                sprintf(\n                    'Stream control failed for user %s on %s',\n                    Core::get_global('user')->username,\n                    $media->get_stream_name()\n                )\n            );\n        }\n\n        $cache_path     = (string)AmpConfig::get('cache_path', '');\n        $cache_target   = AmpConfig::get('cache_target', '');\n        $cache_file     = false;\n        $file_target    = false;\n        $mediaCatalogId = ($media instanceof Song_Preview) ? null : $media->catalog;\n        if ($mediaCatalogId) {\n            /** @var Song|Podcast_Episode|Video $media */\n            // The media catalog is restricted\n            if (!Catalog::has_access($mediaCatalogId, $user->id)) {\n                debug_event('play/index', \"Error: You are not allowed to play $media->file\", 3);\n\n                return null;\n            }\n            // If we are running in Legalize mode, don't play medias already playing\n            if (AmpConfig::get('lock_songs')) {\n                if (!Stream::check_lock_media($media->id, $type)) {\n                    return null;\n                }\n            }\n            $file_target = Catalog::get_cache_path($media->id, $mediaCatalogId);\n            if (!$is_download && !empty($cache_path) && !empty($cache_target) && ($file_target && is_file($file_target))) {\n                debug_event('play/index', 'Found pre-cached file {' . $file_target . '}', 5);\n                $cache_file   = true;\n                $original     = true;\n                $media->file  = $file_target;\n                $media->size  = Core::get_filesize($file_target);\n                $media->type  = $cache_target;\n                $transcode_to = false;\n            } else {\n                // Build up the catalog for our current object\n                $catalog = Catalog::create_from_id($mediaCatalogId);\n                $media   = $catalog->prepare_media($media);\n            }\n        } else {\n            // No catalog, must be song preview or something like that => just redirect to file\n            if ($type == \"song_preview\" && $media instanceof Song_Preview) {\n                $media->stream();\n            } else {\n                header('Location: ' . $media->file);\n\n                return null;\n            }\n        }\n        // load the cache file or the local file\n        $stream_file = ($cache_file && $file_target) ? $file_target : $media->file;\n\n        /* If we don't have a file, or the file is not readable */\n        if (!$stream_file || !Core::is_readable(Core::conv_lc_file($stream_file))) {\n            debug_event('play/index', \"Media \" . $stream_file . \" ($media->title) does not have a valid filename specified\", 2);\n            header('HTTP/1.1 404 Invalid media, file not found or file unreadable');\n\n            return null;\n        }\n\n        // don't abort the script if user skips this media because we need to update now_playing\n        ignore_user_abort(true);\n\n        // Format the media name\n        $media_name   = $stream_name ?? $media->get_stream_name() . \".\" . $media->type;\n        $transcode_to = ($is_download && !$transcode_to)\n            ? false\n            : Stream::get_transcode_format((string)$media->type, $transcode_to, $player, $type);\n\n        header('Access-Control-Allow-Origin: *');\n\n        $sessionkey = $session_id ?? Stream::get_session();\n        $agent      = (!empty($client))\n            ? $client\n            : Session::agent($sessionkey);\n        $location   = Session::get_geolocation($sessionkey);\n\n        // If they are just trying to download make sure they have rights and then present them with the download file\n        if ($is_download && !$transcode_to) {\n            debug_event('play/index', 'Downloading raw file...', 4);\n            // STUPID IE\n            $media_name = str_replace(array('?', '/', '\\\\'), \"_\", $media->f_file);\n            $headers    = $this->browser->getDownloadHeaders($media_name, $media->mime, false, $media->size);\n\n            foreach ($headers as $headerName => $value) {\n                header(sprintf('%s: %s', $headerName, $value));\n            }\n\n            $filepointer   = fopen(Core::conv_lc_file($stream_file), 'rb');\n            $bytesStreamed = 0;\n\n            if (!is_resource($filepointer)) {\n                debug_event('play/index', \"Error: Unable to open \" . $stream_file . \" for downloading\", 2);\n\n                return null;\n            }\n\n            if (!$share_id) {\n                if (Core::get_server('REQUEST_METHOD') != 'HEAD') {\n                    debug_event('play/index', 'Registering download stats for {' . $media->get_stream_name() . '}...', 5);\n                    Stats::insert($type, $media->id, $user_id, $agent, $location, 'download', $time);\n                }\n            } else {\n                Stats::insert($type, $media->id, $user_id, 'share.php', array(), 'download', $time);\n            }\n\n            // Check to see if we should be throttling because we can get away with it\n            if (AmpConfig::get('rate_limit') > 0) {\n                while (!feof($filepointer)) {\n                    echo fread($filepointer, (int) (round(AmpConfig::get('rate_limit') * 1024)));\n                    $bytesStreamed += round(AmpConfig::get('rate_limit') * 1024);\n                    flush();\n                    sleep(1);\n                }\n            } else {\n                fpassthru($filepointer);\n            }\n\n            fclose($filepointer);\n\n            return null;\n        } // if they are trying to download and they can\n\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        // We're about to start. Record this user's IP.\n        if (AmpConfig::get('track_user_ip')) {\n            Core::get_global('user')->insert_ip_history();\n        }\n\n        $force_downsample = false;\n        if (AmpConfig::get('downsample_remote')) {\n            if (!$this->networkChecker->check(AccessLevelEnum::TYPE_NETWORK, Core::get_global('user')->id, AccessLevelEnum::LEVEL_DEFAULT)) {\n                debug_event('play/index', 'Downsampling enabled for non-local address ' . filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP), 5);\n                $force_downsample = true;\n            }\n        }\n\n        debug_event('play/index', $action . ' file (' . $stream_file . '}...', 5);\n        debug_event('play/index', 'Media type {' . $media->type . '}', 5);\n\n        $cpaction = filter_input(INPUT_GET, 'custom_play_action', FILTER_SANITIZE_SPECIAL_CHARS);\n        if ($cpaction) {\n            debug_event('play/index', 'Custom play action {' . $cpaction . '}', 5);\n        }\n        // Determine whether to transcode\n        $transcode    = false;\n        // transcode_to should only have an effect if the media is the wrong format\n        $transcode_to = $transcode_to == $media->type ? null : $transcode_to;\n        if ($transcode_to) {\n            debug_event('play/index', 'Transcode to {' . (string) $transcode_to . '}', 5);\n        }\n\n        // If custom play action or already cached, do not try to transcode\n        if (!$cpaction && !$original && !$cache_file) {\n            $transcode_cfg = AmpConfig::get('transcode');\n            $valid_types   = $media->get_stream_types($player);\n            if (!is_array($valid_types)) {\n                $valid_types = array($valid_types);\n            }\n            if ($transcode_cfg != 'never' && in_array('transcode', $valid_types) && $type !== 'podcast_episode') {\n                if ($transcode_to) {\n                    $transcode = true;\n                    debug_event('play/index', 'Transcoding due to explicit request for ' . (string) $transcode_to, 5);\n                } elseif ($transcode_cfg == 'always') {\n                    $transcode = true;\n                    debug_event('play/index', 'Transcoding due to always', 5);\n                } elseif ($force_downsample) {\n                    $transcode = true;\n                    debug_event('play/index', 'Transcoding due to downsample_remote', 5);\n                } else {\n                    /** @var Song|Video $media */\n                    $media_bitrate = floor($media->bitrate / 1000);\n                    //debug_event('play/index', \"requested bitrate $bitrate <=> $media_bitrate ({$media->bitrate}) media bitrate\", 5);\n                    if (($bitrate > 0 && $bitrate < $media_bitrate) || ($maxbitrate > 0 && $maxbitrate < $media_bitrate)) {\n                        $transcode = true;\n                        debug_event('play/index', 'Transcoding because explicit bitrate request', 5);\n                    } elseif (!in_array('native', $valid_types) && $action != 'download') {\n                        $transcode = true;\n                        debug_event('play/index', 'Transcoding because native streaming is unavailable', 5);\n                    } elseif (!empty($subtitle)) {\n                        $transcode = true;\n                        debug_event('play/index', 'Transcoding because subtitle requested', 5);\n                    }\n                }\n            } else {\n                if ($transcode_cfg != 'never') {\n                    debug_event('play/index', 'Transcoding is not enabled for this media type. Valid types: {' . json_encode($valid_types) . '}', 4);\n                } else {\n                    debug_event('play/index', 'Transcode disabled in user settings.', 5);\n                }\n            }\n        }\n\n        $troptions = array();\n        if ($transcode) {\n            if ($bitrate) {\n                $troptions['bitrate'] = ($maxbitrate > 0 && $maxbitrate < $media_bitrate) ? $maxbitrate : $bitrate;\n            }\n            if ($maxbitrate > 0) {\n                $troptions['maxbitrate'] = $maxbitrate;\n            }\n            if ($subtitle) {\n                $troptions['subtitle'] = $subtitle;\n            }\n            if ($resolution) {\n                $troptions['resolution'] = $resolution;\n            }\n            if ($quality) {\n                $troptions['quality'] = $quality;\n            }\n\n            if (array_key_exists('frame', $_REQUEST)) {\n                $troptions['frame'] = (float) $_REQUEST['frame'];\n                if (array_key_exists('duration', $_REQUEST)) {\n                    $troptions['duration'] = (float) $_REQUEST['duration'];\n                }\n            } elseif (array_key_exists('segment', $_REQUEST)) {\n                // 10 seconds segment. Should it be an option?\n                $ssize            = 10;\n                $send_all_in_once = true; // Should we use temporary folder instead?\n                debug_event('play/index', 'Sending all data in one piece.', 5);\n                $troptions['frame']    = (int) ($_REQUEST['segment']) * $ssize;\n                $troptions['duration'] = ($troptions['frame'] + $ssize <= $media->time) ? $ssize : ($media->time - $troptions['frame']);\n            }\n\n            $transcoder  = Stream::start_transcode($media, $transcode_to, $player, $troptions);\n            $filepointer = $transcoder['handle'] ?? null;\n            $media_name  = $media->f_artist_full . \" - \" . $media->title . \".\" . ($transcoder['format'] ?? '');\n        } else {\n            if ($cpaction && $media instanceof Song) {\n                $transcoder  = $media->run_custom_play_action($cpaction, $transcode_to ?? '');\n                $filepointer = $transcoder['handle'] ?? null;\n                $transcode   = true;\n            } else {\n                $filepointer = fopen(Core::conv_lc_file($stream_file), 'rb');\n            }\n        }\n        //debug_event('play/index', 'troptions ' . print_r($troptions, true), 5);\n\n        if ($transcode && ($media->bitrate > 0 && $media->time > 0)) {\n            // Content-length guessing if required by the player.\n            // Otherwise it shouldn't be used as we are not really sure about final length when transcoding\n            $transcode_to = Song::get_transcode_settings_for_media(\n                (string) $media->type,\n                $transcode_to,\n                $player,\n                (string) $media->type,\n                $troptions\n            )['format'];\n            $maxbitrate   = Stream::get_max_bitrate($media, $transcode_to, $player, $troptions);\n            if (Core::get_request('content_length') == 'required') {\n                if ($media->time > 0 && $maxbitrate > 0) {\n                    $stream_size = ($media->time * $maxbitrate * 1000) / 8;\n                } else {\n                    debug_event('play/index', 'Bad media duration / Max bitrate. Content-length calculation skipped.', 5);\n                    $stream_size = null;\n                }\n            } elseif ($transcode_to == 'mp3') {\n                // mp3 seems to be the only codec that calculates properly\n                $stream_rate = ($maxbitrate < floor($media->bitrate / 1000))\n                    ? $maxbitrate\n                    : floor($media->bitrate / 1000);\n                $stream_size = ($media->time * $stream_rate * 1000) / 8;\n            } else {\n                $stream_size = null;\n                $maxbitrate  = 0;\n            }\n        } else {\n            $stream_size = $media->size;\n        }\n\n        if (!is_resource($filepointer)) {\n            debug_event('play/index', \"Failed to open \" . $stream_file . \" for streaming\", 2);\n\n            return null;\n        }\n\n        if (!$transcode) {\n            header('ETag: ' . $media->id);\n        }\n        // Handle Content-Range\n\n        $start        = 0;\n        $end          = 0;\n        $range_values = sscanf(Core::get_server('HTTP_RANGE'), \"bytes=%d-%d\", $start, $end);\n\n        if ($range_values > 0 && ($start > 0 || $end > 0)) {\n            // Calculate stream size from byte range\n            if ($range_values >= 2) {\n                $end = min($end, $media->size - 1);\n            } else {\n                $end = $media->size - 1;\n            }\n            $stream_size = ($end - $start) + 1;\n\n            if ($stream_size == null) {\n                debug_event('play/index', 'Content-Range header received, which we cannot fulfill due to unknown final length (transcoding?)', 2);\n            } elseif (!$transcode) {\n                debug_event('play/index', 'Content-Range header received, skipping ' . $start . ' bytes out of ' . $media->size, 5);\n                fseek($filepointer, $start);\n\n                $range = $start . '-' . $end . '/' . $media->size;\n                header('HTTP/1.1 206 Partial Content');\n                header('Content-Range: bytes ' . $range);\n            }\n        }\n\n        if (!isset($_REQUEST['segment'])) {\n            if ($media->time) {\n                header('X-Content-Duration: ' . $media->time);\n            }\n\n            // Stats registering must be done before play. Do not move it.\n            // It can be slow because of scrobbler plugins (lastfm, ...)\n            if ($start > 0) {\n                debug_event('play/index', 'Content-Range doesn\\'t start from 0, stats should already be registered previously; not collecting stats', 5);\n            } else {\n                if (($action != 'download') && $record_stats) {\n                    Stream::insert_now_playing((int) $media->id, (int) $user_id, (int) $media->time, $session_id, ObjectTypeToClassNameMapper::reverseMap(get_class($media)));\n                }\n                if (!$share_id && $record_stats) {\n                    if (Core::get_server('REQUEST_METHOD') != 'HEAD') {\n                        debug_event('play/index', 'Registering stream @' . $time . ' for ' . $user_id . ': ' . $media->get_stream_name() . ' {' . $media->id . '}', 4);\n                        // internal scrobbling (user_activity and object_count tables)\n                        if ($media->set_played($user_id, $agent, $location, $time) && $user->id && get_class($media) == Song::class) {\n                            // scrobble plugins\n                            User::save_mediaplay($user, $media);\n                        }\n                    }\n                } elseif (!$share_id && $record_stats) {\n                    if (Core::get_server('REQUEST_METHOD') != 'HEAD') {\n                        debug_event('play/index', 'Registering download for ' . $user_id . ': ' . $media->get_stream_name() . ' {' . $media->id . '}', 5);\n                        Stats::insert($type, $media->id, $user_id, $agent, $location, 'download', $time);\n                    }\n                } elseif ($share_id) {\n                    // shares are people too\n                    $media->set_played(0, 'share.php', array(), $time);\n                }\n            }\n        }\n\n        if ($transcode || $demo_id) {\n            header('Accept-Ranges: none');\n        } else {\n            header('Accept-Ranges: bytes');\n        }\n\n        $mime = $media->mime;\n        if ($transcode && isset($transcoder)) {\n            $mime = ($type == 'video')\n                ? Video::type_to_mime($transcoder['format'])\n                : Song::type_to_mime($transcoder['format']);\n            // Non-blocking stream doesn't work in Windows (php bug since 2005 and still here in 2020...)\n            // We don't want to wait indefinitely for a potential error so we just ignore it.\n            // https://bugs.php.net/bug.php?id=47918\n            if (strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN') {\n                // This to avoid hang, see http://php.net/manual/en/function.proc-open.php#89338\n                $transcode_error = fread($transcoder['stderr'], 4096);\n                if (!empty($transcode_error)) {\n                    debug_event('play/index', 'Transcode stderr: ' . $transcode_error, 1);\n                }\n                fclose($transcoder['stderr']);\n            }\n        }\n\n        // Close sql connection\n        // Warning: do not call functions requiring sql after this point\n        Dba::disconnect();\n        // Free the session write lock\n        // Warning: Do not change any session variable after this call\n        session_write_close();\n\n        $headers = $this->browser->getDownloadHeaders($media_name, $mime, false, $stream_size);\n\n        foreach ($headers as $headerName => $value) {\n            header(sprintf('%s: %s', $headerName, $value));\n        }\n\n        $bytes_streamed = 0;\n\n        // Actually do the streaming\n        $buf_all = '';\n        $r_arr   = array($filepointer);\n        $w_arr   = $e_arr = array();\n        $status  = stream_select($r_arr, $w_arr, $e_arr, 2);\n        if ($status === false) {\n            debug_event('play/index', 'stream_select failed.', 1);\n        } elseif ($status > 0) {\n            do {\n                $read_size = $transcode ? 2048 : min(2048, $stream_size - $bytes_streamed);\n                if ($buf = fread($filepointer, $read_size)) {\n                    if ($send_all_in_once) {\n                        $buf_all .= $buf;\n                    } elseif (!empty($buf)) {\n                        print($buf);\n                        if (ob_get_length()) {\n                            ob_flush();\n                            flush();\n                            ob_end_flush();\n                        }\n                        ob_start();\n                    }\n                    $bytes_streamed += strlen($buf);\n                }\n            } while (!feof($filepointer) && (connection_status() == 0) && ($transcode || $bytes_streamed < $stream_size));\n        }\n\n        if ($send_all_in_once && connection_status() == 0) {\n            header(\"Content-Length: \" . strlen($buf_all));\n            print($buf_all);\n            ob_flush();\n        }\n\n        $real_bytes_streamed = $bytes_streamed;\n        // Need to make sure enough bytes were sent.\n        if ($bytes_streamed < $stream_size && (connection_status() == 0)) {\n            print(str_repeat(' ', $stream_size - $bytes_streamed));\n            $bytes_streamed = $stream_size;\n        }\n\n        fclose($filepointer);\n        if ($transcode && isset($transcoder)) {\n            Stream::kill_process($transcoder);\n        }\n\n        debug_event('play/index', 'Stream ended at ' . $bytes_streamed . ' (' . $real_bytes_streamed . ') bytes out of ' . $stream_size, 5);\n\n        return null;\n    }\n}\n"], "fixing_code": ["<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\n\n?>\n<form style=\"display:inline;\" name=\"f\" method=\"get\" action=\"<?php echo AmpConfig::get('web_path') . \"/$action\"; ?>\" enctype=\"multipart/form-data\">\n    <label for=\"match\" accesskey=\"S\"><?php echo $text; ?></label>\n    <input type=\"text\" id=\"match\" name=\"match\" value=\"<?php echo $match; ?>\" />\n    <input type=\"hidden\" name=\"action\" value=\"<?php echo scrub_out(filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS)); ?>\">\n</form>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Browse Ampache...'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'album_disk' || $filter_str == 'album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('label')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'label') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=label\"><?php echo T_('Labels'); ?></a>\n    <?php }\n    if (AmpConfig::get('broadcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'broadcast') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=broadcast\"><?php echo T_('Broadcasts'); ?></a>\n    <?php }\n    if (AmpConfig::get('live_stream')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'live_stream') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=live_stream\"><?php echo T_('Radio Stations'); ?></a>\n    <?php }\n    if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'podcast') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=podcast\"><?php echo T_('Podcasts'); ?></a>\n        <a class=\"category <?php echo ($filter_str == 'podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/browse.php?action=video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Top Rated'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'highest_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'highest_album_disk' || $filter_str == 'highest_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'highest_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'highest_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'highest_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'highest_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=highest_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Authorization\\Access;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Dashboards'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'album_disk' || $filter_str == 'album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=<?php echo $albumString; ?>\">\n        <?php echo T_('Albums'); ?>\n    </a>\n    <a class=\"category <?php echo ($filter_str == 'artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=artist\">\n        <?php echo T_('Artists'); ?>\n    </a>\n    <?php if (Access::check('interface', 25)) { ?>\n    <a class=\"category <?php echo ($filter_str == 'playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=playlist\">\n        <?php echo T_('Playlists'); ?>\n    </a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/mashup.php?action=video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n</div>", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Newest'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'newest_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'newest_album_disk' || $filter_str == 'newest_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'newest_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'newest_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'newest_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'newest_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=newest_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Popular'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'popular_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'popular_album_disk' || $filter_str == 'popular_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'popular_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'popular_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'popular_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'popular_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=popular_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Recent'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'recent_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'recent_album_disk' || $filter_str == 'recent_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'recent_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'recent_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'recent_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=recent_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\VideoRepositoryInterface;\n\nglobal $dic;\n\n$videoRepository = $dic->get(VideoRepositoryInterface::class);\n$web_path        = AmpConfig::get('web_path');\n$filter_str      = (string) filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n$showAlbumArtist = AmpConfig::get('show_album_artist');\n$showArtist      = AmpConfig::get('show_artist');\n$albumString     = (AmpConfig::get('album_group'))\n    ? 'album'\n    : 'album_disk'; ?>\n\n<h3 class=\"box-title\"><?php echo T_('Favorites'); ?></h3>\n\n<div class=\"category_options\">\n    <a class=\"category <?php echo ($filter_str == 'userflag_song') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_song\"><?php echo T_('Songs'); ?></a>\n    <a class=\"category <?php echo ($filter_str == 'userflag_album_disk' || $filter_str == 'userflag_album') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_<?php echo $albumString; ?>\"><?php echo T_('Albums'); ?></a>\n    <?php if ($showArtist || $filter_str == 'userflag_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_artist\"><?php echo T_('Artists'); ?></a>\n    <?php } ?>\n    <?php if ($showAlbumArtist || !$showArtist || $filter_str == 'userflag_album_artist') { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_album_artist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_album_artist\"><?php echo T_('Album Artists'); ?></a>\n    <?php } ?>\n    <?php if (AmpConfig::get('podcast')) { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_podcast_episode') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_podcast_episode\"><?php echo T_('Podcast Episodes'); ?></a>\n    <?php }\n    if (AmpConfig::get('allow_video') && $videoRepository->getItemCount(Video::class)) { ?>\n        <a class=\"category <?php echo ($filter_str == 'userflag_video') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_video\"><?php echo T_('Videos'); ?></a>\n    <?php } ?>\n    <a class=\"category <?php echo ($filter_str == 'userflag_playlist') ? 'current' : '' ?>\" href=\"<?php echo $web_path; ?>/stats.php?action=userflag_playlist\"><?php echo T_('Playlists'); ?></a>\n</div>\n", "<?php\n/* vim:set softtabstop=4 shiftwidth=4 expandtab: */\n/**\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Util\\Graph;\nuse Ampache\\Module\\Util\\Ui;\n\n$boxtitle = T_('Statistical Graphs');\nif ($blink) {\n    $boxtitle .= ' - ' . $blink;\n} ?>\n<?php Ui::show_box_top($boxtitle, 'box box_graph'); ?>\n<div class=\"stats_graph\">\n    <?php $web_path = AmpConfig::get('web_path');\n    foreach ($gtypes as $gtype) {\n        $graph_link = $web_path . \"/graph.php?type=\" . $gtype . \"&start_date=\" . $start_date . \"&end_date=\" . $end_date . \"&zoom=\" . $zoom . \"&user_id=\" . $user_id . \"&object_type=\" . $object_type . \"&object_id=\" . $object_id; ?>\n    <a href=\"<?php echo $graph_link; ?>&width=1400&height=690\" target=\"_blank\" title=\"<?php echo T_('Show large'); ?>\"><img src=\"<?php echo $graph_link; ?>\" /></a>\n        <br /><br />\n    <?php\n    } ?>\n</div>\n\n<?php\nif (AmpConfig::get('geolocation')) { ?>\n    <div class=\"stats_graph\">\n    <?php\n        $graph = new Graph();\n        $graph->display_map($user_id, $object_type, $object_id, $start_date, $end_date, $zoom); ?>\n    </div>\n<?php } ?>\n\n<form action='<?php echo get_current_path(); ?>' method='post' enctype='multipart/form-data'>\n    <dl class=\"media_details\">\n        <dt><?php echo T_('Start Date'); ?></dt>\n        <dd><input type=\"text\" name=\"start_date\" id=\"start_date\" value=\"<?php echo $f_start_date; ?>\" /></dd>\n        <dt><?php echo T_('End Date'); ?></dt>\n        <dd><input type=\"text\" name=\"end_date\" id=\"end_date\" value=\"<?php echo $f_end_date; ?>\" /></dd>\n        <dt><?php echo T_('Zoom'); ?></dt>\n        <dd>\n            <select name=\"zoom\">\n            <?php\n                $date_formats = array(\n                    'year' => T_('Year'),\n                    'month' => T_('Month'),\n                    'day' => T_('Day'),\n                    'hour' => T_('Hour')\n                );\n                foreach ($date_formats as $dtype => $dname) {\n                    echo \"<option value='\" . $dtype . \"' \";\n                    if ($dtype == $zoom) {\n                        echo \"selected\";\n                    }\n                    echo \">\" . $dname . \"</option>\";\n                } ?>\n            </select>\n        </dd>\n        <dt></dt>\n        <dd>\n            <input type=\"submit\" value=\"<?php echo T_('View'); ?>\" />\n        </dd>\n    </dl>\n    <input type=\"hidden\" name=\"user_id\" value=\"<?php echo $user_id; ?>\" />\n    <input type=\"hidden\" name=\"object_type\" value=\"<?php echo $object_type; ?>\" />\n    <input type=\"hidden\" name=\"object_id\" value=\"<?php echo $object_id; ?>\" />\n    <input type=\"hidden\" name=\"action\" value=\"<?php echo filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS); ?>\" />\n    <input type=\"hidden\" name=\"type\" value=\"<?php echo $type; ?>\" />\n</form>\n<script>\n    $('#start_date').datetimepicker({\n        format: 'Y-m-d H:i',\n        theme: 'dark'\n    });\n    $('#end_date').datetimepicker({\n        format:'Y-m-d H:i',\n        theme: 'dark'\n    });\n</script>\n<?php Ui::show_box_bottom(); ?>\n", "<?php\n\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=1);\n\nnamespace Ampache\\Module\\Application;\n\nuse Ampache\\Module\\Application\\Exception\\AccessDeniedException;\nuse Ampache\\Module\\Authorization\\GatekeeperFactoryInterface;\nuse Ampache\\Module\\System\\LegacyLogger;\nuse Ampache\\Module\\Util\\UiInterface;\nuse Narrowspark\\HttpEmitter\\SapiEmitter;\nuse Psr\\Container\\ContainerExceptionInterface;\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Throwable;\n\nfinal class ApplicationRunner\n{\n    private ContainerInterface $dic;\n\n    private LoggerInterface $logger;\n\n    private GatekeeperFactoryInterface $gatekeeperFactory;\n\n    private UiInterface $ui;\n\n    public function __construct(\n        ContainerInterface $dic,\n        LoggerInterface $logger,\n        GatekeeperFactoryInterface $gatekeeperFactory,\n        UiInterface $ui\n    ) {\n        $this->dic               = $dic;\n        $this->logger            = $logger;\n        $this->gatekeeperFactory = $gatekeeperFactory;\n        $this->ui                = $ui;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param array<string, string> $action_list A dict containing request keys and handler class names\n     * @param string $default_action The request key for the default action\n     */\n    public function run(\n        ServerRequestInterface $request,\n        array $action_list,\n        string $default_action\n    ): void {\n        $action_name = htmlspecialchars($request->getParsedBody()['action'] ?? $request->getQueryParams()['action'] ?? '');\n\n        if (array_key_exists($action_name, $action_list) === false) {\n            $action_name = $default_action;\n        }\n\n        $handler_name = $action_list[$action_name] ?? '';\n\n        try {\n            /** @var ApplicationActionInterface $handler */\n            $handler = $this->dic->get($handler_name);\n        } catch (ContainerExceptionInterface $e) {\n            $this->logger->critical(\n                sprintf('No handler found for action \"%s\"', $action_name),\n                [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n            );\n\n            return;\n        }\n\n        $this->logger->debug(\n            sprintf('Found handler \"%s\" for action \"%s\"', $handler_name, $action_name),\n            [LegacyLogger::CONTEXT_TYPE => __CLASS__]\n        );\n\n        try {\n            $response = $handler->run(\n                $request,\n                $this->gatekeeperFactory->createGuiGatekeeper()\n            );\n\n            /**\n             * Emit response if available.\n             * This will become the default once the rendering of all actions got converted\n             */\n            if ($response !== null) {\n                $this->dic->get(SapiEmitter::class)->emit($response);\n            }\n        } catch (AccessDeniedException $e) {\n            $message = $e->getMessage();\n\n            $this->logger->warning(\n                $message,\n                [\n                    LegacyLogger::CONTEXT_TYPE => sprintf(\n                        '\"%s\" for \"%s\"',\n                        __CLASS__,\n                        $e->getFile()\n                    )\n                ]\n            );\n\n            $this->ui->accessDenied($message);\n\n            return;\n        } catch (Throwable $e) {\n            $this->logger->critical(\n                $e->getMessage(),\n                [\n                    LegacyLogger::CONTEXT_TYPE => sprintf(\n                        '%s:%d',\n                        $e->getFile(),\n                        $e->getLine()\n                    )\n                ]\n            );\n            /**\n             * @todo Add a nice error page\n             */\n        }\n    }\n}\n", "<?php\n\n/*\n * vim:set softtabstop=4 shiftwidth=4 expandtab:\n *\n * LICENSE: GNU Affero General Public License, version 3 (AGPL-3.0-or-later)\n * Copyright 2001 - 2022 Ampache.org\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\ndeclare(strict_types=0);\n\nnamespace Ampache\\Module\\Application\\Playback;\n\nuse Ampache\\Config\\AmpConfig;\nuse Ampache\\Module\\Application\\ApplicationActionInterface;\nuse Ampache\\Module\\Application\\Exception\\AccessDeniedException;\nuse Ampache\\Module\\Authentication\\AuthenticationManagerInterface;\nuse Ampache\\Module\\Authorization\\AccessLevelEnum;\nuse Ampache\\Module\\Authorization\\Check\\NetworkCheckerInterface;\nuse Ampache\\Module\\Authorization\\GuiGatekeeperInterface;\nuse Ampache\\Module\\Playback\\Stream;\nuse Ampache\\Module\\Playback\\Stream_Playlist;\nuse Ampache\\Module\\Statistics\\Stats;\nuse Ampache\\Module\\System\\Core;\nuse Ampache\\Module\\System\\Dba;\nuse Ampache\\Module\\System\\Session;\nuse Ampache\\Module\\Util\\Horde_Browser;\nuse Ampache\\Module\\Util\\ObjectTypeToClassNameMapper;\nuse Ampache\\Repository\\Model\\Catalog;\nuse Ampache\\Repository\\Model\\Democratic;\nuse Ampache\\Repository\\Model\\Podcast_Episode;\nuse Ampache\\Repository\\Model\\Preference;\nuse Ampache\\Repository\\Model\\Random;\nuse Ampache\\Repository\\Model\\Share;\nuse Ampache\\Repository\\Model\\Song;\nuse Ampache\\Repository\\Model\\Song_Preview;\nuse Ampache\\Repository\\Model\\User;\nuse Ampache\\Repository\\Model\\Video;\nuse Ampache\\Repository\\UserRepositoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfinal class PlayAction implements ApplicationActionInterface\n{\n    public const REQUEST_KEY = 'play';\n\n    private Horde_Browser $browser;\n\n    private AuthenticationManagerInterface $authenticationManager;\n\n    private NetworkCheckerInterface $networkChecker;\n\n    private UserRepositoryInterface $userRepository;\n\n    public function __construct(\n        Horde_Browser $browser,\n        AuthenticationManagerInterface $authenticationManager,\n        NetworkCheckerInterface $networkChecker,\n        UserRepositoryInterface $userRepository\n    ) {\n        $this->browser               = $browser;\n        $this->authenticationManager = $authenticationManager;\n        $this->networkChecker        = $networkChecker;\n        $this->userRepository        = $userRepository;\n    }\n\n    public function run(ServerRequestInterface $request, GuiGatekeeperInterface $gatekeeper): ?ResponseInterface\n    {\n        ob_end_clean();\n\n        //debug_event('play/index', print_r(apache_request_headers(), true), 5);\n\n        /**\n         * The following code takes a \"beautiful\" url, splits it into key/value pairs and\n         * then replaces the PHP $_REQUEST as if the URL had arrived in un-beautified form.\n         * (This is necessary to avoid some DLNA players barfing on the URL, particularly Windows Media Player)\n         *\n         * The reason for not trying to do the whole job in mod_rewrite is that there are typically\n         * more than 10 arguments to this function now, and that's tricky with mod_rewrite's 10 arg limit\n         */\n        $slashcount = substr_count($_SERVER['QUERY_STRING'], '/');\n        if ($slashcount > 2) {\n            // e.g. ssid/3ca112fff23376ef7c74f018497dd39d/type/song/oid/280/uid/player/api/name/Glad.mp3\n            $new_arr     = explode('/', $_SERVER['QUERY_STRING']);\n            $new_request = array();\n            $key         = null;\n            $i           = 0;\n            // alternate key and value through the split array e.g:\n            // array('ssid', '3ca112fff23376ef7c74f018497dd39d', 'type', 'song', 'oid', '280', 'uid', 'player', 'api', 'name', 'Glad.mp3))\n            foreach ($new_arr as $v) {\n                if ($i == 0) {\n                    // key name\n                    $key = $v;\n                    $i   = 1;\n                } else {\n                    // key value\n                    $value = $v;\n                    $i     = 0;\n                    // set it now that you've set both\n                    $new_request[$key] = $value;\n                }\n            }\n            $_REQUEST = $new_request;\n        }\n\n        /* These parameters had better come in on the url. */\n        $action       = (string)filter_input(INPUT_GET, 'action', FILTER_SANITIZE_SPECIAL_CHARS);\n        $stream_name  = (string)filter_input(INPUT_GET, 'name', FILTER_SANITIZE_SPECIAL_CHARS);\n        $object_id    = (int)scrub_in(filter_input(INPUT_GET, 'oid', FILTER_SANITIZE_SPECIAL_CHARS));\n        $user_id      = (int)scrub_in(filter_input(INPUT_GET, 'uid', FILTER_SANITIZE_SPECIAL_CHARS));\n        $session_id   = (string)scrub_in(filter_input(INPUT_GET, 'ssid', FILTER_SANITIZE_SPECIAL_CHARS));\n        $type         = (string)scrub_in(filter_input(INPUT_GET, 'type', FILTER_SANITIZE_SPECIAL_CHARS));\n        $client       = (string)scrub_in(filter_input(INPUT_GET, 'client', FILTER_SANITIZE_SPECIAL_CHARS));\n        $cache        = (string)scrub_in(filter_input(INPUT_GET, 'cache', FILTER_SANITIZE_SPECIAL_CHARS));\n        $format       = (string)scrub_in(filter_input(INPUT_GET, 'format', FILTER_SANITIZE_SPECIAL_CHARS));\n        $bitrate      = (int)scrub_in(filter_input(INPUT_GET, 'bitrate', FILTER_SANITIZE_SPECIAL_CHARS));\n        $original     = ($format == 'raw');\n        $transcode_to = (!$original && $format != '') ? $format : (string)scrub_in(filter_input(INPUT_GET, 'transcode_to', FILTER_SANITIZE_SPECIAL_CHARS));\n        $player       = (string)scrub_in(filter_input(INPUT_GET, 'player', FILTER_SANITIZE_SPECIAL_CHARS));\n        $record_stats = true;\n        $use_auth     = AmpConfig::get('use_auth');\n\n        // Share id and secret if used\n        $share_id = (int)filter_input(INPUT_GET, 'share_id', FILTER_SANITIZE_NUMBER_INT);\n        $secret   = (string)scrub_in(filter_input(INPUT_GET, 'share_secret', FILTER_SANITIZE_SPECIAL_CHARS));\n\n        // This is specifically for tmp playlist requests\n        $demo_id    = (string)scrub_in(filter_input(INPUT_GET, 'demo_id', FILTER_SANITIZE_SPECIAL_CHARS));\n        $random     = (string)scrub_in(filter_input(INPUT_GET, 'random', FILTER_SANITIZE_SPECIAL_CHARS));\n\n        // democratic play url doesn't include these\n        if ($demo_id !== '') {\n            $type = 'song';\n        }\n        // random play url can be multiple types but default to song if missing\n        if ($random !== '') {\n            $type = 'song';\n        }\n        // if you don't specify, assume stream\n        if (empty($action)) {\n            $action = 'stream';\n        }\n        // allow disabling stat recording from the play url\n        if (($action == 'download' || $cache == '1') && !in_array($type, array('song', 'video', 'podcast_episode'))) {\n            debug_event('play/index', 'record_stats disabled: cache {' . $type . \"}\", 5);\n            $action       = 'download';\n            $record_stats = false;\n        }\n        $is_download   = ($action == 'download' || $cache == '1');\n        $maxbitrate    = 0;\n        $media_bitrate = 0;\n        $resolution    = '';\n        $quality       = 0;\n        $time          = time();\n\n        if (AmpConfig::get('transcode_player_customize') && !$original) {\n            $transcode_to = $transcode_to ?? (string)scrub_in(filter_input(INPUT_GET, 'transcode_to', FILTER_SANITIZE_SPECIAL_CHARS));\n\n            // Trick to avoid LimitInternalRecursion reconfiguration\n            $vsettings = (string)scrub_in(filter_input(INPUT_GET, 'transcode_to', FILTER_SANITIZE_SPECIAL_CHARS));\n            if (!empty($vsettings)) {\n                $vparts  = explode('-', $vsettings);\n                $v_count = count($vparts);\n                for ($i = 0; $i < $v_count; $i += 2) {\n                    switch ($vparts[$i]) {\n                        case 'maxbitrate':\n                            $maxbitrate = (int) ($vparts[$i + 1]);\n                            break;\n                        case 'resolution':\n                            $resolution = $vparts[$i + 1];\n                            break;\n                        case 'quality':\n                            $quality = (int) ($vparts[$i + 1]);\n                            break;\n                    }\n                }\n            }\n        }\n        $subtitle         = '';\n        $send_full_stream = (string)AmpConfig::get('send_full_stream');\n        $send_all_in_once = ($send_full_stream == 'true' || $send_full_stream == $player);\n\n        if (!$type) {\n            $type = 'song';\n        }\n\n        debug_event('play/index', \"Asked for type {{$type}}\", 5);\n\n        if ($type == 'playlist') {\n            $playlist_type = scrub_in($_REQUEST['playlist_type']);\n            $object_id     = $session_id;\n        }\n\n        // First things first, if we don't have a uid/oid stop here\n        if (empty($object_id) && (!$demo_id && !$share_id && !$secret && !$random)) {\n            debug_event('play/index', 'No object OID specified, nothing to play', 2);\n            header('HTTP/1.1 400 Nothing To Play');\n\n            return null;\n        }\n\n        // Authenticate the user if specified\n        $username = $_REQUEST['PHP_AUTH_USER'] ?? '';\n        if (empty($username)) {\n            $username = $_REQUEST['u'] ?? '';\n        }\n        $password = $_REQUEST['PHP_AUTH_PW'] ?? '';\n        if (empty($password)) {\n            $password = $_REQUEST['p'] ?? '';\n        }\n        $apikey    = $_REQUEST['apikey'] ?? '';\n        $user      = null;\n        $user_auth = false;\n        // If explicit user authentication was passed\n        if (!empty($session_id)) {\n            $user = $this->userRepository->findByStreamToken(trim($session_id));\n            if ($user) {\n                $user_auth = true;\n                $agent     = (!empty($client))\n                    ? $client\n                    : substr(Core::get_server('HTTP_USER_AGENT'), 0, 254);\n                // this is a permastream link so create a session\n                if (!Session::exists('stream', $session_id)) {\n                    Session::create(array(\n                            'sid' => $session_id,\n                            'username' => $user->username,\n                            'value' => '',\n                            'type' => 'stream',\n                            'agent' => ''\n                        )\n                    );\n                } else {\n                    Session::update_agent($session_id, $agent);\n                    Session::extend($session_id, 'stream');\n                }\n            }\n        } elseif (!empty($apikey)) {\n            $user = $this->userRepository->findByApiKey(trim($apikey));\n            if ($user) {\n                $user_auth = true;\n            }\n        } elseif (!empty($username) && !empty($password)) {\n            $auth = $this->authenticationManager->login($username, $password);\n            if ($auth['success']) {\n                $user      = User::get_from_username($auth['username']);\n                $user_auth = true;\n            }\n        }\n        // try the session ID as well\n        if ($user == null) {\n            $user = User::get_from_username(Session::username($session_id));\n        }\n\n        $session_name = AmpConfig::get('session_name');\n        // Identify the user according to it's web session\n        // We try to avoid the generic 'Ampache User' as much as possible\n        if (!($user instanceof User) && array_key_exists($session_name, $_COOKIE) && Session::exists('interface', $_COOKIE[$session_name])) {\n            Session::check();\n            $user = (array_key_exists('userdata', $_SESSION) && array_key_exists('username', $_SESSION['userdata']))\n                ? User::get_from_username($_SESSION['userdata']['username'])\n                : new User(-1);\n        }\n\n        // did you pass a specific user id? (uid)\n        $user_id = ($user instanceof User)\n            ? $user->id\n            : $user_id;\n\n        if (!$share_id) {\n            // No explicit authentication, use session\n            if (!$user instanceof User) {\n                $user = new User($user_id);\n            }\n\n            // If the user has been disabled (true value)\n            if (make_bool($user->disabled)) {\n                debug_event('play/index', $user->username . \" is currently disabled, stream access denied\", 3);\n                header('HTTP/1.1 403 User disabled');\n\n                return null;\n            }\n\n            // If require_session is set then we need to make sure we're legit\n            if (!$user_auth && $use_auth && AmpConfig::get('require_session')) {\n                if (!AmpConfig::get('require_localnet_session') && $this->networkChecker->check(AccessLevelEnum::TYPE_NETWORK, Core::get_global('user')->id, AccessLevelEnum::LEVEL_GUEST)) {\n                    debug_event('play/index', 'Streaming access allowed for local network IP ' . filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP), 4);\n                } elseif (!Session::exists('stream', $session_id)) {\n                    // No valid session id given, try with cookie session from web interface\n                    $session_id = $_COOKIE[$session_name] ?? false;\n                    if (!Session::exists('interface', $session_id)) {\n                        debug_event('play/index', \"Streaming access denied: Session $session_id has expired\", 3);\n                        header('HTTP/1.1 403 Session Expired');\n\n                        return null;\n                    }\n                }\n                // Now that we've confirmed the session is valid extend it\n                Session::extend($session_id, 'stream');\n            }\n\n            // Update the users last seen information\n            $this->userRepository->updateLastSeen($user->id);\n        } else {\n            $user_id = 0;\n            $share   = new Share((int) $share_id);\n\n            if (!$share->is_valid($secret, 'stream')) {\n                header('HTTP/1.1 403 Access Unauthorized');\n\n                return null;\n            }\n\n            if (!$share->is_shared_media($object_id)) {\n                header('HTTP/1.1 403 Access Unauthorized');\n\n                return null;\n            }\n\n            $user = new User($share->user);\n        }\n\n        if (!($user instanceof User) && (!$share_id && !$secret)) {\n            debug_event('play/index', 'No user specified {' . print_r($user, true) . '}', 2);\n            header('HTTP/1.1 400 No User Specified');\n\n            return null;\n        }\n        Session::createGlobalUser($user);\n        Preference::init();\n\n        // If we are in demo mode; die here\n        if (AmpConfig::get('demo_mode')) {\n            throw new AccessDeniedException(\n                'Streaming Access Denied: Disable demo_mode in \\'config/ampache.cfg.php\\''\n            );\n        }\n        // Check whether streaming is allowed\n        $prefs = AmpConfig::get('allow_stream_playback') && $_SESSION['userdata']['preferences']['allow_stream_playback'];\n        if (!$prefs) {\n            throw new AccessDeniedException(\n                'Streaming Access Denied: Enable \\'Allow Streaming\\' in Server Config -> Options'\n            );\n        }\n\n        // If they are using access lists let's make sure that they have enough access to play this mojo\n        if (AmpConfig::get('access_control')) {\n            if (\n                !$this->networkChecker->check(AccessLevelEnum::TYPE_STREAM, Core::get_global('user')->id) &&\n                !$this->networkChecker->check(AccessLevelEnum::TYPE_NETWORK, Core::get_global('user')->id)\n            ) {\n                throw new AccessDeniedException(\n                    sprintf('Streaming Access Denied: %s does not have stream level access', Core::get_user_ip())\n                );\n            }\n        } // access_control is enabled\n\n        // Handle playlist downloads\n        if ($type == 'playlist' && isset($playlist_type)) {\n            $playlist = new Stream_Playlist($object_id);\n            // Some rudimentary security\n            if ($user_id != $playlist->user) {\n                throw new AccessDeniedException();\n            }\n\n            $playlist->generate_playlist($playlist_type);\n\n            return null;\n        }\n\n        /**\n         * If we've got a Democratic playlist then get the current song and redirect to that media files URL\n         */\n        if ($demo_id !== '') {\n            $democratic = new Democratic($demo_id);\n            $democratic->set_parent();\n\n            // If there is a cooldown we need to make sure this song isn't a repeat\n            if (!$democratic->cooldown) {\n                // This takes into account votes, etc and removes the\n                $object_id = $democratic->get_next_object();\n            } else {\n                // Pull history\n                $song_cool_check = 0;\n                $object_id       = $democratic->get_next_object($song_cool_check);\n                $object_ids      = $democratic->get_cool_songs();\n                while (in_array($object_id, $object_ids)) {\n                    $song_cool_check++;\n                    $object_id = $democratic->get_next_object($song_cool_check);\n                    if ($song_cool_check >= '5') {\n                        break;\n                    }\n                } // while we've got the 'new' song in old the array\n            } // end if we've got a cooldown\n            $media = new Song($object_id);\n            if ($media->id > 0) {\n                // Always remove the play from the list\n                $democratic->delete_from_oid($object_id, $type);\n\n                // If the media is disabled\n                if ((isset($media->enabled) && !make_bool($media->enabled)) || !Core::is_readable(Core::conv_lc_file($media->file))) {\n                    debug_event('play/index', \"Error: \" . $media->file . \" is currently disabled, song skipped\", 3);\n                    header('HTTP/1.1 404 File disabled');\n\n                    return null;\n                }\n\n                // play the song instead of going through all the crap\n                header('Location: ' . $media->play_url('', $player, false, $user->id, $user->streamtoken), true, 303);\n\n                return null;\n            }\n            debug_event('play/index', \"Error: DEMOCRATIC song could not be found\", 3);\n            header('HTTP/1.1 404 File not found');\n\n            return null;\n        } // if democratic ID passed\n\n        /**\n         * if we are doing random let's pull the random object and redirect to that media files URL\n         */\n        if ($random !== '') {\n            if (array_key_exists('start', $_REQUEST) && (int)Core::get_request('start') > 0 && array_key_exists('random', $_SESSION) && array_key_exists('last', $_SESSION['random'])) {\n                // continue the current object\n                $object_id = $_SESSION['random']['last'];\n            } else {\n                // get a new random object and redirect to that object\n                if (array_key_exists('random_type', $_REQUEST)) {\n                    $rtype = $_REQUEST['random_type'];\n                } else {\n                    $rtype = $type;\n                }\n                $object_id = Random::get_single_song($rtype, $user, (int)$_REQUEST['random_id']);\n                if ($object_id > 0) {\n                    // Save this one in case we do a seek\n                    $_SESSION['random']['last'] = $object_id;\n                }\n                $media = new Song($object_id);\n                if ($media->id > 0) {\n                    // If the media is disabled\n                    if ((isset($media->enabled) && !make_bool($media->enabled)) || !Core::is_readable(Core::conv_lc_file($media->file))) {\n                        debug_event('play/index', \"Error: \" . $media->file . \" is currently disabled, song skipped\", 3);\n                        header('HTTP/1.1 404 File disabled');\n\n                        return null;\n                    }\n\n                    // play the song instead of going through all the crap\n                    header('Location: ' . $media->play_url('', $player, false, $user->id, $user->streamtoken), true, 303);\n\n                    return null;\n                }\n                debug_event('play/index', \"Error: RANDOM song could not be found\", 3);\n                header('HTTP/1.1 404 File not found');\n\n                return null;\n            }\n        } // if random\n\n        if ($type == 'video') {\n            $media = new Video($object_id);\n            if (array_key_exists('subtitle', $_REQUEST)) {\n                $subtitle = $media->get_subtitle_file($_REQUEST['subtitle']);\n            }\n        } elseif ($type == 'song_preview') {\n            $media = new Song_Preview($object_id);\n        } elseif ($type == 'podcast_episode') {\n            $media = new Podcast_Episode((int) $object_id);\n        } else {\n            // default to song\n            $media = new Song($object_id);\n        }\n        $media->format();\n\n        if (!User::stream_control(array(array('object_type' => $type, 'object_id' => $media->id)))) {\n            throw new AccessDeniedException(\n                sprintf(\n                    'Stream control failed for user %s on %s',\n                    Core::get_global('user')->username,\n                    $media->get_stream_name()\n                )\n            );\n        }\n\n        $cache_path     = (string)AmpConfig::get('cache_path', '');\n        $cache_target   = AmpConfig::get('cache_target', '');\n        $cache_file     = false;\n        $file_target    = false;\n        $mediaCatalogId = ($media instanceof Song_Preview) ? null : $media->catalog;\n        if ($mediaCatalogId) {\n            /** @var Song|Podcast_Episode|Video $media */\n            // The media catalog is restricted\n            if (!Catalog::has_access($mediaCatalogId, $user->id)) {\n                debug_event('play/index', \"Error: You are not allowed to play $media->file\", 3);\n\n                return null;\n            }\n            // If we are running in Legalize mode, don't play medias already playing\n            if (AmpConfig::get('lock_songs')) {\n                if (!Stream::check_lock_media($media->id, $type)) {\n                    return null;\n                }\n            }\n            $file_target = Catalog::get_cache_path($media->id, $mediaCatalogId);\n            if (!$is_download && !empty($cache_path) && !empty($cache_target) && ($file_target && is_file($file_target))) {\n                debug_event('play/index', 'Found pre-cached file {' . $file_target . '}', 5);\n                $cache_file   = true;\n                $original     = true;\n                $media->file  = $file_target;\n                $media->size  = Core::get_filesize($file_target);\n                $media->type  = $cache_target;\n                $transcode_to = false;\n            } else {\n                // Build up the catalog for our current object\n                $catalog = Catalog::create_from_id($mediaCatalogId);\n                $media   = $catalog->prepare_media($media);\n            }\n        } else {\n            // No catalog, must be song preview or something like that => just redirect to file\n            if ($type == \"song_preview\" && $media instanceof Song_Preview) {\n                $media->stream();\n            } else {\n                header('Location: ' . $media->file, true, 303);\n\n                return null;\n            }\n        }\n        // load the cache file or the local file\n        $stream_file = ($cache_file && $file_target) ? $file_target : $media->file;\n\n        /* If we don't have a file, or the file is not readable */\n        if (!$stream_file || !Core::is_readable(Core::conv_lc_file($stream_file))) {\n            debug_event('play/index', \"Media \" . $stream_file . \" ($media->title) does not have a valid filename specified\", 2);\n            header('HTTP/1.1 404 Invalid media, file not found or file unreadable');\n\n            return null;\n        }\n\n        // don't abort the script if user skips this media because we need to update now_playing\n        ignore_user_abort(true);\n\n        // Format the media name\n        $media_name   = $stream_name ?? $media->get_stream_name() . \".\" . $media->type;\n        $transcode_to = ($is_download && !$transcode_to)\n            ? false\n            : Stream::get_transcode_format((string)$media->type, $transcode_to, $player, $type);\n\n        header('Access-Control-Allow-Origin: *');\n\n        $sessionkey = $session_id ?? Stream::get_session();\n        $agent      = (!empty($client))\n            ? $client\n            : Session::agent($sessionkey);\n        $location   = Session::get_geolocation($sessionkey);\n\n        // If they are just trying to download make sure they have rights and then present them with the download file\n        if ($is_download && !$transcode_to) {\n            debug_event('play/index', 'Downloading raw file...', 4);\n            // STUPID IE\n            $media_name = str_replace(array('?', '/', '\\\\'), \"_\", $media->f_file);\n            $headers    = $this->browser->getDownloadHeaders($media_name, $media->mime, false, $media->size);\n\n            foreach ($headers as $headerName => $value) {\n                header(sprintf('%s: %s', $headerName, $value));\n            }\n\n            $filepointer   = fopen(Core::conv_lc_file($stream_file), 'rb');\n            $bytesStreamed = 0;\n\n            if (!is_resource($filepointer)) {\n                debug_event('play/index', \"Error: Unable to open \" . $stream_file . \" for downloading\", 2);\n\n                return null;\n            }\n\n            if (!$share_id) {\n                if (Core::get_server('REQUEST_METHOD') != 'HEAD') {\n                    debug_event('play/index', 'Registering download stats for {' . $media->get_stream_name() . '}...', 5);\n                    Stats::insert($type, $media->id, $user_id, $agent, $location, 'download', $time);\n                }\n            } else {\n                Stats::insert($type, $media->id, $user_id, 'share.php', array(), 'download', $time);\n            }\n\n            // Check to see if we should be throttling because we can get away with it\n            if (AmpConfig::get('rate_limit') > 0) {\n                while (!feof($filepointer)) {\n                    echo fread($filepointer, (int) (round(AmpConfig::get('rate_limit') * 1024)));\n                    $bytesStreamed += round(AmpConfig::get('rate_limit') * 1024);\n                    flush();\n                    sleep(1);\n                }\n            } else {\n                fpassthru($filepointer);\n            }\n\n            fclose($filepointer);\n\n            return null;\n        } // if they are trying to download and they can\n\n        // Prevent the script from timing out\n        set_time_limit(0);\n\n        // We're about to start. Record this user's IP.\n        if (AmpConfig::get('track_user_ip')) {\n            Core::get_global('user')->insert_ip_history();\n        }\n\n        $force_downsample = false;\n        if (AmpConfig::get('downsample_remote')) {\n            if (!$this->networkChecker->check(AccessLevelEnum::TYPE_NETWORK, Core::get_global('user')->id, AccessLevelEnum::LEVEL_DEFAULT)) {\n                debug_event('play/index', 'Downsampling enabled for non-local address ' . filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP), 5);\n                $force_downsample = true;\n            }\n        }\n\n        debug_event('play/index', $action . ' file (' . $stream_file . '}...', 5);\n        debug_event('play/index', 'Media type {' . $media->type . '}', 5);\n\n        $cpaction = filter_input(INPUT_GET, 'custom_play_action', FILTER_SANITIZE_SPECIAL_CHARS);\n        if ($cpaction) {\n            debug_event('play/index', 'Custom play action {' . $cpaction . '}', 5);\n        }\n        // Determine whether to transcode\n        $transcode    = false;\n        // transcode_to should only have an effect if the media is the wrong format\n        $transcode_to = $transcode_to == $media->type ? null : $transcode_to;\n        if ($transcode_to) {\n            debug_event('play/index', 'Transcode to {' . (string) $transcode_to . '}', 5);\n        }\n\n        // If custom play action or already cached, do not try to transcode\n        if (!$cpaction && !$original && !$cache_file) {\n            $transcode_cfg = AmpConfig::get('transcode');\n            $valid_types   = $media->get_stream_types($player);\n            if (!is_array($valid_types)) {\n                $valid_types = array($valid_types);\n            }\n            if ($transcode_cfg != 'never' && in_array('transcode', $valid_types) && $type !== 'podcast_episode') {\n                if ($transcode_to) {\n                    $transcode = true;\n                    debug_event('play/index', 'Transcoding due to explicit request for ' . (string) $transcode_to, 5);\n                } elseif ($transcode_cfg == 'always') {\n                    $transcode = true;\n                    debug_event('play/index', 'Transcoding due to always', 5);\n                } elseif ($force_downsample) {\n                    $transcode = true;\n                    debug_event('play/index', 'Transcoding due to downsample_remote', 5);\n                } else {\n                    /** @var Song|Video $media */\n                    $media_bitrate = floor($media->bitrate / 1000);\n                    //debug_event('play/index', \"requested bitrate $bitrate <=> $media_bitrate ({$media->bitrate}) media bitrate\", 5);\n                    if (($bitrate > 0 && $bitrate < $media_bitrate) || ($maxbitrate > 0 && $maxbitrate < $media_bitrate)) {\n                        $transcode = true;\n                        debug_event('play/index', 'Transcoding because explicit bitrate request', 5);\n                    } elseif (!in_array('native', $valid_types) && $action != 'download') {\n                        $transcode = true;\n                        debug_event('play/index', 'Transcoding because native streaming is unavailable', 5);\n                    } elseif (!empty($subtitle)) {\n                        $transcode = true;\n                        debug_event('play/index', 'Transcoding because subtitle requested', 5);\n                    }\n                }\n            } else {\n                if ($transcode_cfg != 'never') {\n                    debug_event('play/index', 'Transcoding is not enabled for this media type. Valid types: {' . json_encode($valid_types) . '}', 4);\n                } else {\n                    debug_event('play/index', 'Transcode disabled in user settings.', 5);\n                }\n            }\n        }\n\n        $troptions = array();\n        if ($transcode) {\n            if ($bitrate) {\n                $troptions['bitrate'] = ($maxbitrate > 0 && $maxbitrate < $media_bitrate) ? $maxbitrate : $bitrate;\n            }\n            if ($maxbitrate > 0) {\n                $troptions['maxbitrate'] = $maxbitrate;\n            }\n            if ($subtitle) {\n                $troptions['subtitle'] = $subtitle;\n            }\n            if ($resolution) {\n                $troptions['resolution'] = $resolution;\n            }\n            if ($quality) {\n                $troptions['quality'] = $quality;\n            }\n\n            if (array_key_exists('frame', $_REQUEST)) {\n                $troptions['frame'] = (float) $_REQUEST['frame'];\n                if (array_key_exists('duration', $_REQUEST)) {\n                    $troptions['duration'] = (float) $_REQUEST['duration'];\n                }\n            } elseif (array_key_exists('segment', $_REQUEST)) {\n                // 10 seconds segment. Should it be an option?\n                $ssize            = 10;\n                $send_all_in_once = true; // Should we use temporary folder instead?\n                debug_event('play/index', 'Sending all data in one piece.', 5);\n                $troptions['frame']    = (int) ($_REQUEST['segment']) * $ssize;\n                $troptions['duration'] = ($troptions['frame'] + $ssize <= $media->time) ? $ssize : ($media->time - $troptions['frame']);\n            }\n\n            $transcoder  = Stream::start_transcode($media, $transcode_to, $player, $troptions);\n            $filepointer = $transcoder['handle'] ?? null;\n            $media_name  = $media->f_artist_full . \" - \" . $media->title . \".\" . ($transcoder['format'] ?? '');\n        } else {\n            if ($cpaction && $media instanceof Song) {\n                $transcoder  = $media->run_custom_play_action($cpaction, $transcode_to ?? '');\n                $filepointer = $transcoder['handle'] ?? null;\n                $transcode   = true;\n            } else {\n                $filepointer = fopen(Core::conv_lc_file($stream_file), 'rb');\n            }\n        }\n        //debug_event('play/index', 'troptions ' . print_r($troptions, true), 5);\n\n        if ($transcode && ($media->bitrate > 0 && $media->time > 0)) {\n            // Content-length guessing if required by the player.\n            // Otherwise it shouldn't be used as we are not really sure about final length when transcoding\n            $transcode_to = Song::get_transcode_settings_for_media(\n                (string) $media->type,\n                $transcode_to,\n                $player,\n                (string) $media->type,\n                $troptions\n            )['format'];\n            $maxbitrate   = Stream::get_max_bitrate($media, $transcode_to, $player, $troptions);\n            if (Core::get_request('content_length') == 'required') {\n                if ($media->time > 0 && $maxbitrate > 0) {\n                    $stream_size = ($media->time * $maxbitrate * 1000) / 8;\n                } else {\n                    debug_event('play/index', 'Bad media duration / Max bitrate. Content-length calculation skipped.', 5);\n                    $stream_size = null;\n                }\n            } elseif ($transcode_to == 'mp3') {\n                // mp3 seems to be the only codec that calculates properly\n                $stream_rate = ($maxbitrate < floor($media->bitrate / 1000))\n                    ? $maxbitrate\n                    : floor($media->bitrate / 1000);\n                $stream_size = ($media->time * $stream_rate * 1000) / 8;\n            } else {\n                $stream_size = null;\n                $maxbitrate  = 0;\n            }\n        } else {\n            $stream_size = $media->size;\n        }\n\n        if (!is_resource($filepointer)) {\n            debug_event('play/index', \"Failed to open \" . $stream_file . \" for streaming\", 2);\n\n            return null;\n        }\n\n        if (!$transcode) {\n            header('ETag: ' . $media->id);\n        }\n        // Handle Content-Range\n\n        $start        = 0;\n        $end          = 0;\n        $range_values = sscanf(Core::get_server('HTTP_RANGE'), \"bytes=%d-%d\", $start, $end);\n\n        if ($range_values > 0 && ($start > 0 || $end > 0)) {\n            // Calculate stream size from byte range\n            if ($range_values >= 2) {\n                $end = min($end, $media->size - 1);\n            } else {\n                $end = $media->size - 1;\n            }\n            $stream_size = ($end - $start) + 1;\n\n            if ($stream_size == null) {\n                debug_event('play/index', 'Content-Range header received, which we cannot fulfill due to unknown final length (transcoding?)', 2);\n            } elseif (!$transcode) {\n                debug_event('play/index', 'Content-Range header received, skipping ' . $start . ' bytes out of ' . $media->size, 5);\n                fseek($filepointer, $start);\n\n                $range = $start . '-' . $end . '/' . $media->size;\n                header('HTTP/1.1 206 Partial Content');\n                header('Content-Range: bytes ' . $range);\n            }\n        }\n\n        if (!isset($_REQUEST['segment'])) {\n            if ($media->time) {\n                header('X-Content-Duration: ' . $media->time);\n            }\n\n            // Stats registering must be done before play. Do not move it.\n            // It can be slow because of scrobbler plugins (lastfm, ...)\n            if ($start > 0) {\n                debug_event('play/index', 'Content-Range doesn\\'t start from 0, stats should already be registered previously; not collecting stats', 5);\n            } else {\n                if (($action != 'download') && $record_stats) {\n                    Stream::insert_now_playing((int) $media->id, (int) $user_id, (int) $media->time, $session_id, ObjectTypeToClassNameMapper::reverseMap(get_class($media)));\n                }\n                if (!$share_id && $record_stats) {\n                    if (Core::get_server('REQUEST_METHOD') != 'HEAD') {\n                        debug_event('play/index', 'Registering stream @' . $time . ' for ' . $user_id . ': ' . $media->get_stream_name() . ' {' . $media->id . '}', 4);\n                        // internal scrobbling (user_activity and object_count tables)\n                        if ($media->set_played($user_id, $agent, $location, $time) && $user->id && get_class($media) == Song::class) {\n                            // scrobble plugins\n                            User::save_mediaplay($user, $media);\n                        }\n                    }\n                } elseif (!$share_id && $record_stats) {\n                    if (Core::get_server('REQUEST_METHOD') != 'HEAD') {\n                        debug_event('play/index', 'Registering download for ' . $user_id . ': ' . $media->get_stream_name() . ' {' . $media->id . '}', 5);\n                        Stats::insert($type, $media->id, $user_id, $agent, $location, 'download', $time);\n                    }\n                } elseif ($share_id) {\n                    // shares are people too\n                    $media->set_played(0, 'share.php', array(), $time);\n                }\n            }\n        }\n\n        if ($transcode || $demo_id) {\n            header('Accept-Ranges: none');\n        } else {\n            header('Accept-Ranges: bytes');\n        }\n\n        $mime = $media->mime;\n        if ($transcode && isset($transcoder)) {\n            $mime = ($type == 'video')\n                ? Video::type_to_mime($transcoder['format'])\n                : Song::type_to_mime($transcoder['format']);\n            // Non-blocking stream doesn't work in Windows (php bug since 2005 and still here in 2020...)\n            // We don't want to wait indefinitely for a potential error so we just ignore it.\n            // https://bugs.php.net/bug.php?id=47918\n            if (strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN') {\n                // This to avoid hang, see http://php.net/manual/en/function.proc-open.php#89338\n                $transcode_error = fread($transcoder['stderr'], 4096);\n                if (!empty($transcode_error)) {\n                    debug_event('play/index', 'Transcode stderr: ' . $transcode_error, 1);\n                }\n                fclose($transcoder['stderr']);\n            }\n        }\n\n        // Close sql connection\n        // Warning: do not call functions requiring sql after this point\n        Dba::disconnect();\n        // Free the session write lock\n        // Warning: Do not change any session variable after this call\n        session_write_close();\n\n        $headers = $this->browser->getDownloadHeaders($media_name, $mime, false, $stream_size);\n\n        foreach ($headers as $headerName => $value) {\n            header(sprintf('%s: %s', $headerName, $value));\n        }\n\n        $bytes_streamed = 0;\n\n        // Actually do the streaming\n        $buf_all = '';\n        $r_arr   = array($filepointer);\n        $w_arr   = $e_arr = array();\n        $status  = stream_select($r_arr, $w_arr, $e_arr, 2);\n        if ($status === false) {\n            debug_event('play/index', 'stream_select failed.', 1);\n        } elseif ($status > 0) {\n            do {\n                $read_size = $transcode ? 2048 : min(2048, $stream_size - $bytes_streamed);\n                if ($buf = fread($filepointer, $read_size)) {\n                    if ($send_all_in_once) {\n                        $buf_all .= $buf;\n                    } elseif (!empty($buf)) {\n                        print($buf);\n                        if (ob_get_length()) {\n                            ob_flush();\n                            flush();\n                            ob_end_flush();\n                        }\n                        ob_start();\n                    }\n                    $bytes_streamed += strlen($buf);\n                }\n            } while (!feof($filepointer) && (connection_status() == 0) && ($transcode || $bytes_streamed < $stream_size));\n        }\n\n        if ($send_all_in_once && connection_status() == 0) {\n            header(\"Content-Length: \" . strlen($buf_all));\n            print($buf_all);\n            ob_flush();\n        }\n\n        $real_bytes_streamed = $bytes_streamed;\n        // Need to make sure enough bytes were sent.\n        if ($bytes_streamed < $stream_size && (connection_status() == 0)) {\n            print(str_repeat(' ', $stream_size - $bytes_streamed));\n            $bytes_streamed = $stream_size;\n        }\n\n        fclose($filepointer);\n        if ($transcode && isset($transcoder)) {\n            Stream::kill_process($transcoder);\n        }\n\n        debug_event('play/index', 'Stream ended at ' . $bytes_streamed . ' (' . $real_bytes_streamed . ') bytes out of ' . $stream_size, 5);\n\n        return null;\n    }\n}\n"], "filenames": ["public/templates/show_alphabet_form.inc.php", "public/templates/show_form_browse.inc.php", "public/templates/show_form_highest.inc.php", "public/templates/show_form_mashup.inc.php", "public/templates/show_form_newest.inc.php", "public/templates/show_form_popular.inc.php", "public/templates/show_form_recent.inc.php", "public/templates/show_form_userflag.inc.php", "public/templates/show_graphs.inc.php", "src/Module/Application/ApplicationRunner.php", "src/Module/Application/Playback/PlayAction.php"], "buggy_code_start_loc": [29, 31, 31, 12, 31, 31, 31, 31, 84, 71, 422], "buggy_code_end_loc": [30, 32, 32, 13, 32, 32, 32, 32, 85, 72, 537], "fixing_code_start_loc": [29, 31, 31, 12, 31, 31, 31, 31, 84, 71, 422], "fixing_code_end_loc": [30, 32, 32, 13, 32, 32, 32, 32, 85, 72, 537], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository ampache/ampache prior to 5.5.7.", "other": {"cve": {"id": "CVE-2023-0606", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-01T01:15:08.847", "lastModified": "2023-02-07T21:53:01.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository ampache/ampache prior to 5.5.7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ampache:ampache:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.5.7", "matchCriteriaId": "AA237F19-986D-4470-86E7-CEA9F0BBE2C3"}]}]}], "references": [{"url": "https://github.com/ampache/ampache/commit/d3191503ca856dfe0b33d7cb17717ffd480046cb", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/0bfed46d-ac96-43c4-93fb-13f68b4e711b", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ampache/ampache/commit/d3191503ca856dfe0b33d7cb17717ffd480046cb"}}