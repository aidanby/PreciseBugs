{"buggy_code": ["import Foundation\nimport LocalAuthentication\n\nenum PluginError:Int {\n    case BIOMETRIC_UNKNOWN_ERROR = -100\n    case BIOMETRIC_UNAVAILABLE = -101\n    case BIOMETRIC_AUTHENTICATION_FAILED = -102\n    case BIOMETRIC_PERMISSION_NOT_GRANTED = -105\n    case BIOMETRIC_NOT_ENROLLED = -106\n    case BIOMETRIC_DISMISSED = -108\n    case BIOMETRIC_SCREEN_GUARD_UNSECURED = -110\n    case BIOMETRIC_LOCKED_OUT = -111\n    case BIOMETRIC_SECRET_NOT_FOUND = -113\n}\n\n@objc(Fingerprint) class Fingerprint : CDVPlugin {\n\n    struct ErrorCodes {\n        var code: Int\n    }\n\n\n    @objc(isAvailable:)\n    func isAvailable(_ command: CDVInvokedUrlCommand){\n        let authenticationContext = LAContext();\n        var biometryType = \"finger\";\n        var errorResponse: [AnyHashable: Any] = [\n            \"code\": 0,\n            \"message\": \"Not Available\"\n        ];\n        var error:NSError?;\n        let params = command.argument(at: 0) as? [AnyHashable: Any] ?? [:]\n        let allowBackup = params[\"allowBackup\"] as? Bool ?? false\n        let policy:LAPolicy = allowBackup ? .deviceOwnerAuthentication : .deviceOwnerAuthenticationWithBiometrics;\n        var pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: \"Not available\");\n        let available = authenticationContext.canEvaluatePolicy(policy, error: &error);\n\n        var results: [String : Any]\n\n        if(error != nil){\n            biometryType = \"none\";\n            errorResponse[\"code\"] = error?.code;\n            errorResponse[\"message\"] = error?.localizedDescription;\n        }\n\n        if (available == true) {\n            if #available(iOS 11.0, *) {\n                switch(authenticationContext.biometryType) {\n                case .none:\n                    biometryType = \"none\";\n                case .touchID:\n                    biometryType = \"finger\";\n                case .faceID:\n                    biometryType = \"face\"\n                }\n            }\n\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: biometryType);\n        }else{\n            var code: Int;\n            switch(error!._code) {\n                case Int(kLAErrorBiometryNotAvailable):\n                    code = PluginError.BIOMETRIC_UNAVAILABLE.rawValue;\n                    break;\n                case Int(kLAErrorBiometryNotEnrolled):\n                    code = PluginError.BIOMETRIC_NOT_ENROLLED.rawValue;\n                    break;\n\n                default:\n                    code = PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue;\n                    break;\n            }\n            results = [\"code\": code, \"message\": error!.localizedDescription];\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: results);\n        }\n\n        commandDelegate.send(pluginResult, callbackId:command.callbackId);\n    }\n\n    func justAuthenticate(_ command: CDVInvokedUrlCommand) {\n        let authenticationContext = LAContext();\n        let errorResponse: [AnyHashable: Any] = [\n            \"message\": \"Something went wrong\"\n        ];\n        var pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResponse);\n        var reason = \"Authentication\";\n        var policy:LAPolicy = .deviceOwnerAuthentication;\n        let data  = command.arguments[0] as? [String: Any];\n\n        if let disableBackup = data?[\"disableBackup\"] as! Bool? {\n            if disableBackup {\n                authenticationContext.localizedFallbackTitle = \"\";\n                policy = .deviceOwnerAuthenticationWithBiometrics;\n            } else {\n                if let fallbackButtonTitle = data?[\"fallbackButtonTitle\"] as! String? {\n                    authenticationContext.localizedFallbackTitle = fallbackButtonTitle;\n                }else{\n                    authenticationContext.localizedFallbackTitle = \"Use Pin\";\n                }\n            }\n        }\n\n        // Localized reason\n        if let description = data?[\"description\"] as! String? {\n            reason = description;\n        }\n\n        authenticationContext.evaluatePolicy(\n            policy,\n            localizedReason: reason,\n            reply: { [unowned self] (success, error) -> Void in\n                if( success ) {\n                    pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: \"Success\");\n                }else {\n                    if (error != nil) {\n\n                        var errorCodes = [Int: ErrorCodes]()\n                        var errorResult: [String : Any] = [\"code\":  PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue, \"message\": error?.localizedDescription ?? \"\"];\n\n                        errorCodes[1] = ErrorCodes(code: PluginError.BIOMETRIC_AUTHENTICATION_FAILED.rawValue)\n                        errorCodes[2] = ErrorCodes(code: PluginError.BIOMETRIC_DISMISSED.rawValue)\n                        errorCodes[5] = ErrorCodes(code: PluginError.BIOMETRIC_SCREEN_GUARD_UNSECURED.rawValue)\n                        errorCodes[6] = ErrorCodes(code: PluginError.BIOMETRIC_UNAVAILABLE.rawValue)\n                        errorCodes[7] = ErrorCodes(code: PluginError.BIOMETRIC_NOT_ENROLLED.rawValue)\n                        errorCodes[8] = ErrorCodes(code: PluginError.BIOMETRIC_LOCKED_OUT.rawValue)\n\n                        let errorCode = abs(error!._code)\n                        if let e = errorCodes[errorCode] {\n                           errorResult = [\"code\": e.code, \"message\": error!.localizedDescription];\n                        }\n\n                        pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResult);\n                    }\n                }\n                self.commandDelegate.send(pluginResult, callbackId:command.callbackId);\n            }\n        );\n    }\n\n    func saveSecret(_ secretStr: String, command: CDVInvokedUrlCommand) {\n        let data  = command.arguments[0] as AnyObject?;\n        var pluginResult: CDVPluginResult\n        do {\n            let secret = Secret()\n            try? secret.delete()\n            let invalidateOnEnrollment = (data?[\"invalidateOnEnrollment\"] as? Bool) ?? false\n            try secret.save(secretStr, invalidateOnEnrollment: invalidateOnEnrollment)\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: \"Success\");\n        } catch {\n            let errorResult = [\"code\": PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue, \"message\": error.localizedDescription] as [String : Any];\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResult);\n        }\n        self.commandDelegate.send(pluginResult, callbackId:command.callbackId)\n        return\n    }\n\n\n    func loadSecret(_ command: CDVInvokedUrlCommand) {\n        let data  = command.arguments[0] as AnyObject?;\n        var prompt = \"Authentication\"\n        if let description = data?[\"description\"] as! String? {\n            prompt = description;\n        }\n        var pluginResult: CDVPluginResult\n        do {\n            let result = try Secret().load(prompt)\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: result);\n        } catch {\n            var code = PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue\n            var message = error.localizedDescription\n            if let err = error as? KeychainError {\n                code = err.pluginError.rawValue\n                message = err.localizedDescription\n            }\n            let errorResult = [\"code\": code, \"message\": message] as [String : Any]\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResult);\n        }\n        self.commandDelegate.send(pluginResult, callbackId:command.callbackId)\n    }\n\n    @objc(authenticate:)\n    func authenticate(_ command: CDVInvokedUrlCommand){\n        justAuthenticate(command)\n    }\n\n    @objc(registerBiometricSecret:)\n    func registerBiometricSecret(_ command: CDVInvokedUrlCommand){\n        let data  = command.arguments[0] as AnyObject?;\n        if let secret = data?[\"secret\"] as? String {\n            self.saveSecret(secret, command: command)\n            return\n        }\n    }\n\n    @objc(loadBiometricSecret:)\n    func loadBiometricSecret(_ command: CDVInvokedUrlCommand){\n        self.loadSecret(command)\n    }\n\n    override func pluginInitialize() {\n        super.pluginInitialize()\n    }\n\n}\n\n/// Keychain errors we might encounter.\nstruct KeychainError: Error {\n    var status: OSStatus\n\n    var localizedDescription: String {\n        if #available(iOS 11.3, *) {\n            if let result = SecCopyErrorMessageString(status, nil) as String? {\n                return result\n            }\n        }\n        switch status {\n            case errSecItemNotFound:\n                return \"Secret not found\"\n            case errSecUserCanceled:\n                return \"Biometric dissmissed\"\n            case errSecAuthFailed:\n                return \"Authentication failed\"\n            default:\n                return \"Unknown error \\(status)\"\n        }\n    }\n\n    var pluginError: PluginError {\n        switch status {\n        case errSecItemNotFound:\n            return PluginError.BIOMETRIC_SECRET_NOT_FOUND\n        case errSecUserCanceled:\n            return PluginError.BIOMETRIC_DISMISSED\n        case errSecAuthFailed:\n                return PluginError.BIOMETRIC_AUTHENTICATION_FAILED\n        default:\n            return PluginError.BIOMETRIC_UNKNOWN_ERROR\n        }\n    }\n}\n\nclass Secret {\n\n    private static let keyName: String = \"__aio_key\"\n\n    private func getBioSecAccessControl(invalidateOnEnrollment: Bool) -> SecAccessControl {\n        var access: SecAccessControl?\n        var error: Unmanaged<CFError>?\n\n        if #available(iOS 11.3, *) {\n            access = SecAccessControlCreateWithFlags(nil,\n                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                invalidateOnEnrollment ? .biometryCurrentSet : .userPresence,\n                &error)\n        } else {\n            access = SecAccessControlCreateWithFlags(nil,\n                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                invalidateOnEnrollment ? .touchIDCurrentSet : .userPresence,\n                &error)\n        }\n        precondition(access != nil, \"SecAccessControlCreateWithFlags failed\")\n        return access!\n    }\n\n    func save(_ secret: String, invalidateOnEnrollment: Bool) throws {\n        let password = secret.data(using: String.Encoding.utf8)!\n\n        // Allow a device unlock in the last 10 seconds to be used to get at keychain items.\n        // let context = LAContext()\n        // context.touchIDAuthenticationAllowableReuseDuration = 10\n\n        // Build the query for use in the add operation.\n        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,\n                                    kSecAttrAccount as String: Secret.keyName,\n                                    kSecAttrAccessControl as String: getBioSecAccessControl(invalidateOnEnrollment: invalidateOnEnrollment),\n                                    kSecValueData as String: password]\n\n        let status = SecItemAdd(query as CFDictionary, nil)\n        guard status == errSecSuccess else { throw KeychainError(status: status) }\n    }\n\n    func load(_ prompt: String) throws -> String {\n        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,\n                                    kSecAttrAccount as String: Secret.keyName,\n                                    kSecMatchLimit as String: kSecMatchLimitOne,\n                                    kSecReturnData as String : kCFBooleanTrue,\n                                    kSecAttrAccessControl as String: getBioSecAccessControl(invalidateOnEnrollment: true),\n                                    kSecUseOperationPrompt as String: prompt]\n\n        var item: CFTypeRef?\n        let status = SecItemCopyMatching(query as CFDictionary, &item)\n        guard status == errSecSuccess else { throw KeychainError(status: status) }\n\n        guard let passwordData = item as? Data,\n            let password = String(data: passwordData, encoding: String.Encoding.utf8)\n            // let account = existingItem[kSecAttrAccount as String] as? String\n            else {\n                throw KeychainError(status: errSecInternalError)\n        }\n\n        return password\n    }\n\n    func delete() throws {\n        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,\n                                    kSecAttrAccount as String: Secret.keyName]\n\n        let status = SecItemDelete(query as CFDictionary)\n        guard status == errSecSuccess else { throw KeychainError(status: status) }\n    }\n}\n"], "fixing_code": ["import Cordova\nimport Foundation\nimport LocalAuthentication\n\nenum PluginError:Int {\n    case BIOMETRIC_UNKNOWN_ERROR = -100\n    case BIOMETRIC_UNAVAILABLE = -101\n    case BIOMETRIC_AUTHENTICATION_FAILED = -102\n    case BIOMETRIC_PERMISSION_NOT_GRANTED = -105\n    case BIOMETRIC_NOT_ENROLLED = -106\n    case BIOMETRIC_DISMISSED = -108\n    case BIOMETRIC_SCREEN_GUARD_UNSECURED = -110\n    case BIOMETRIC_LOCKED_OUT = -111\n    case BIOMETRIC_SECRET_NOT_FOUND = -113\n}\n\n@objc(Fingerprint) class Fingerprint : CDVPlugin {\n\n    struct ErrorCodes {\n        var code: Int\n    }\n\n\n    @objc(isAvailable:)\n    func isAvailable(_ command: CDVInvokedUrlCommand){\n        let authenticationContext = LAContext();\n        var biometryType = \"finger\";\n        var errorResponse: [AnyHashable: Any] = [\n            \"code\": 0,\n            \"message\": \"Not Available\"\n        ];\n        var error:NSError?;\n        let params = command.argument(at: 0) as? [AnyHashable: Any] ?? [:]\n        let allowBackup = params[\"allowBackup\"] as? Bool ?? false\n        let policy:LAPolicy = allowBackup ? .deviceOwnerAuthentication : .deviceOwnerAuthenticationWithBiometrics;\n        var pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: \"Not available\");\n        let available = authenticationContext.canEvaluatePolicy(policy, error: &error);\n\n        var results: [String : Any]\n\n        if(error != nil){\n            biometryType = \"none\";\n            errorResponse[\"code\"] = error?.code;\n            errorResponse[\"message\"] = error?.localizedDescription;\n        }\n\n        if (available == true) {\n            if #available(iOS 11.0, *) {\n                switch(authenticationContext.biometryType) {\n                case .none:\n                    biometryType = \"none\";\n                case .touchID:\n                    biometryType = \"finger\";\n                case .faceID:\n                    biometryType = \"face\"\n                @unknown default:\n                    fatalError()\n                }\n            }\n\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: biometryType);\n        }else{\n            var code: Int;\n            switch(error!._code) {\n                case Int(kLAErrorBiometryNotAvailable):\n                    code = PluginError.BIOMETRIC_UNAVAILABLE.rawValue;\n                    break;\n                case Int(kLAErrorBiometryNotEnrolled):\n                    code = PluginError.BIOMETRIC_NOT_ENROLLED.rawValue;\n                    break;\n\n                default:\n                    code = PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue;\n                    break;\n            }\n            results = [\"code\": code, \"message\": error!.localizedDescription];\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: results);\n        }\n\n        commandDelegate.send(pluginResult, callbackId:command.callbackId);\n    }\n\n    func justAuthenticate(_ command: CDVInvokedUrlCommand) {\n        let authenticationContext = LAContext();\n        let errorResponse: [AnyHashable: Any] = [\n            \"message\": \"Something went wrong\"\n        ];\n        var pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResponse);\n        var reason = \"Authentication\";\n        var policy:LAPolicy = .deviceOwnerAuthentication;\n        let data  = command.arguments[0] as? [String: Any];\n\n        if let disableBackup = data?[\"disableBackup\"] as! Bool? {\n            if disableBackup {\n                authenticationContext.localizedFallbackTitle = \"\";\n                policy = .deviceOwnerAuthenticationWithBiometrics;\n            } else {\n                if let fallbackButtonTitle = data?[\"fallbackButtonTitle\"] as! String? {\n                    authenticationContext.localizedFallbackTitle = fallbackButtonTitle;\n                }else{\n                    authenticationContext.localizedFallbackTitle = \"Use Pin\";\n                }\n            }\n        }\n\n        // Localized reason\n        if let description = data?[\"description\"] as! String? {\n            reason = description;\n        }\n\n        authenticationContext.evaluatePolicy(\n            policy,\n            localizedReason: reason,\n            reply: { [unowned self] (success, error) -> Void in\n                if( success ) {\n                    pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: \"Success\");\n                }else {\n                    if (error != nil) {\n\n                        var errorCodes = [Int: ErrorCodes]()\n                        var errorResult: [String : Any] = [\"code\":  PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue, \"message\": error?.localizedDescription ?? \"\"];\n\n                        errorCodes[1] = ErrorCodes(code: PluginError.BIOMETRIC_AUTHENTICATION_FAILED.rawValue)\n                        errorCodes[2] = ErrorCodes(code: PluginError.BIOMETRIC_DISMISSED.rawValue)\n                        errorCodes[5] = ErrorCodes(code: PluginError.BIOMETRIC_SCREEN_GUARD_UNSECURED.rawValue)\n                        errorCodes[6] = ErrorCodes(code: PluginError.BIOMETRIC_UNAVAILABLE.rawValue)\n                        errorCodes[7] = ErrorCodes(code: PluginError.BIOMETRIC_NOT_ENROLLED.rawValue)\n                        errorCodes[8] = ErrorCodes(code: PluginError.BIOMETRIC_LOCKED_OUT.rawValue)\n\n                        let errorCode = abs(error!._code)\n                        if let e = errorCodes[errorCode] {\n                           errorResult = [\"code\": e.code, \"message\": error!.localizedDescription];\n                        }\n\n                        pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResult);\n                    }\n                }\n                self.commandDelegate.send(pluginResult, callbackId:command.callbackId);\n            }\n        );\n    }\n\n    func saveSecret(_ secretStr: String, command: CDVInvokedUrlCommand) {\n        let data  = command.arguments[0] as AnyObject?;\n        var pluginResult: CDVPluginResult\n        do {\n            let secret = Secret()\n            try? secret.delete()\n            let invalidateOnEnrollment = (data?.object(forKey: \"invalidateOnEnrollment\") as? Bool) ?? false\n            try secret.save(secretStr, invalidateOnEnrollment: invalidateOnEnrollment)\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: \"Success\");\n        } catch {\n            let errorResult = [\"code\": PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue, \"message\": error.localizedDescription] as [String : Any];\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResult);\n        }\n        self.commandDelegate.send(pluginResult, callbackId:command.callbackId)\n        return\n    }\n\n\n    func loadSecret(_ command: CDVInvokedUrlCommand) {\n        let data  = command.arguments[0] as AnyObject?;\n        var prompt = \"Authentication\"\n        if let description = data?.object(forKey: \"description\") as! String? {\n            prompt = description;\n        }\n        var pluginResult: CDVPluginResult\n        do {\n            let result = try Secret().load(prompt)\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_OK, messageAs: result);\n        } catch {\n            var code = PluginError.BIOMETRIC_UNKNOWN_ERROR.rawValue\n            var message = error.localizedDescription\n            if let err = error as? KeychainError {\n                code = err.pluginError.rawValue\n                message = err.localizedDescription\n            }\n            let errorResult = [\"code\": code, \"message\": message] as [String : Any]\n            pluginResult = CDVPluginResult(status: CDVCommandStatus_ERROR, messageAs: errorResult);\n        }\n        self.commandDelegate.send(pluginResult, callbackId:command.callbackId)\n    }\n\n    @objc(authenticate:)\n    func authenticate(_ command: CDVInvokedUrlCommand){\n        justAuthenticate(command)\n    }\n\n    @objc(registerBiometricSecret:)\n    func registerBiometricSecret(_ command: CDVInvokedUrlCommand){\n        let data  = command.arguments[0] as AnyObject?;\n        if let secret = data?.object(forKey: \"secret\") as? String {\n            self.saveSecret(secret, command: command)\n            return\n        }\n    }\n\n    @objc(loadBiometricSecret:)\n    func loadBiometricSecret(_ command: CDVInvokedUrlCommand){\n        self.loadSecret(command)\n    }\n\n    override func pluginInitialize() {\n        super.pluginInitialize()\n    }\n\n}\n\n/// Keychain errors we might encounter.\nstruct KeychainError: Error {\n    var status: OSStatus\n\n    var localizedDescription: String {\n        if #available(iOS 11.3, *) {\n            if let result = SecCopyErrorMessageString(status, nil) as String? {\n                return result\n            }\n        }\n        switch status {\n            case errSecItemNotFound:\n                return \"Secret not found\"\n            case errSecUserCanceled:\n                return \"Biometric dissmissed\"\n            case errSecAuthFailed:\n                return \"Authentication failed\"\n            default:\n                return \"Unknown error \\(status)\"\n        }\n    }\n\n    var pluginError: PluginError {\n        switch status {\n        case errSecItemNotFound:\n            return PluginError.BIOMETRIC_SECRET_NOT_FOUND\n        case errSecUserCanceled:\n            return PluginError.BIOMETRIC_DISMISSED\n        case errSecAuthFailed:\n                return PluginError.BIOMETRIC_AUTHENTICATION_FAILED\n        default:\n            return PluginError.BIOMETRIC_UNKNOWN_ERROR\n        }\n    }\n}\n\nclass Secret {\n\n    private static let keyName: String = \"__aio_key\"\n\n    private func getBioSecAccessControl(invalidateOnEnrollment: Bool) -> SecAccessControl {\n        var access: SecAccessControl?\n        var error: Unmanaged<CFError>?\n\n        if #available(iOS 11.3, *) {\n            access = SecAccessControlCreateWithFlags(nil,\n                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                invalidateOnEnrollment ? .biometryCurrentSet : .userPresence,\n                &error)\n        } else {\n            access = SecAccessControlCreateWithFlags(nil,\n                kSecAttrAccessibleWhenUnlockedThisDeviceOnly,\n                invalidateOnEnrollment ? .touchIDCurrentSet : .userPresence,\n                &error)\n        }\n        precondition(access != nil, \"SecAccessControlCreateWithFlags failed\")\n        return access!\n    }\n\n    func save(_ secret: String, invalidateOnEnrollment: Bool) throws {\n        let password = secret.data(using: String.Encoding.utf8)!\n\n        // Allow a device unlock in the last 10 seconds to be used to get at keychain items.\n        // let context = LAContext()\n        // context.touchIDAuthenticationAllowableReuseDuration = 10\n\n        // Build the query for use in the add operation.\n        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,\n                                    kSecAttrAccount as String: Secret.keyName,\n                                    kSecAttrAccessControl as String: getBioSecAccessControl(invalidateOnEnrollment: invalidateOnEnrollment),\n                                    kSecValueData as String: password]\n\n        let status = SecItemAdd(query as CFDictionary, nil)\n        guard status == errSecSuccess else { throw KeychainError(status: status) }\n    }\n\n    func load(_ prompt: String) throws -> String {\n        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,\n                                    kSecAttrAccount as String: Secret.keyName,\n                                    kSecMatchLimit as String: kSecMatchLimitOne,\n                                    kSecReturnData as String : kCFBooleanTrue,\n                                    kSecAttrAccessControl as String: getBioSecAccessControl(invalidateOnEnrollment: true),\n                                    kSecUseOperationPrompt as String: prompt]\n\n        var item: CFTypeRef?\n        let status = SecItemCopyMatching(query as CFDictionary, &item)\n        guard status == errSecSuccess else { throw KeychainError(status: status) }\n\n        guard let passwordData = item as? Data,\n            let password = String(data: passwordData, encoding: String.Encoding.utf8)\n            // let account = existingItem[kSecAttrAccount as String] as? String\n            else {\n                throw KeychainError(status: errSecInternalError)\n        }\n\n        return password\n    }\n\n    func delete() throws {\n        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,\n                                    kSecAttrAccount as String: Secret.keyName]\n\n        let status = SecItemDelete(query as CFDictionary)\n        guard status == errSecSuccess else { throw KeychainError(status: status) }\n    }\n}\n"], "filenames": ["src/ios/Fingerprint.swift"], "buggy_code_start_loc": [0], "buggy_code_end_loc": [190], "fixing_code_start_loc": [1], "fixing_code_end_loc": [193], "type": "CWE-617", "message": "cordova-plugin-fingerprint-aio is a plugin provides a single and simple interface for accessing fingerprint APIs on both Android 6+ and iOS. In versions prior to 5.0.1 The exported activity `de.niklasmerz.cordova.biometric.BiometricActivity` can cause the app to crash. This vulnerability occurred because the activity didn't handle the case where it is requested with invalid or empty data which results in a crash. Any third party app can constantly call this activity with no permission. A 3rd party app/attacker using event listener can continually stop the app from working and make the victim unable to open it. Version 5.0.1 of the cordova-plugin-fingerprint-aio doesn't export the activity anymore and is no longer vulnerable. If you want to fix older versions change the attribute android:exported in plugin.xml to false. Please upgrade to version 5.0.1 as soon as possible.", "other": {"cve": {"id": "CVE-2021-43849", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-23T17:15:07.373", "lastModified": "2022-01-11T17:39:40.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cordova-plugin-fingerprint-aio is a plugin provides a single and simple interface for accessing fingerprint APIs on both Android 6+ and iOS. In versions prior to 5.0.1 The exported activity `de.niklasmerz.cordova.biometric.BiometricActivity` can cause the app to crash. This vulnerability occurred because the activity didn't handle the case where it is requested with invalid or empty data which results in a crash. Any third party app can constantly call this activity with no permission. A 3rd party app/attacker using event listener can continually stop the app from working and make the victim unable to open it. Version 5.0.1 of the cordova-plugin-fingerprint-aio doesn't export the activity anymore and is no longer vulnerable. If you want to fix older versions change the attribute android:exported in plugin.xml to false. Please upgrade to version 5.0.1 as soon as possible."}, {"lang": "es", "value": "cordova-plugin-fingerprint-aio es un plugin que proporciona una interfaz \u00fanica y sencilla para acceder a las API de huellas dactilares tanto en Android 6+ como en iOS. En versiones anteriores a 5.0.1 la actividad exportada \"de.niklasmerz.cordova.biometric.BiometricActivity\" puede causar un bloqueo de la aplicaci\u00f3n. Esta vulnerabilidad es producida porque la actividad no maneja el caso de que es solicitado con datos no v\u00e1lidos o vac\u00edos, lo que resulta en un bloqueo. Cualquier aplicaci\u00f3n de terceros puede llamar constantemente a esta actividad sin permiso. Una aplicaci\u00f3n de terceros/atacante usando un escuchador de eventos puede detener continuamente el funcionamiento de la aplicaci\u00f3n y hacer que la v\u00edctima no pueda abrirla. La versi\u00f3n 5.0.1 del cordova-plugin-fingerprint-aio ya no exporta la actividad y ya no es vulnerable. Si quieres arreglar versiones anteriores cambia el atributo android:exported en el plugin.xml a false. Actualiza a versi\u00f3n 5.0.1 lo antes posible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cordova_plugin_fingerprint_all-in-one_project:cordova_plugin_fingerprint_all-in-one:*:*:*:*:node.js:*:*:*", "versionEndExcluding": "5.0.1", "matchCriteriaId": "88B1BC57-970A-4DCC-B57B-5331423D74AD"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:apple:iphone_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "B5415705-33E5-46D5-8E4D-9EBADC8C5705"}, {"vulnerable": false, "criteria": "cpe:2.3:o:google:android:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "matchCriteriaId": "EB2F89FC-1377-4AEA-B725-BC64DDB4A940"}]}]}], "references": [{"url": "https://github.com/NiklasMerz/cordova-plugin-fingerprint-aio/commit/27434a240f97f69fd930088654590c8ba43569df", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NiklasMerz/cordova-plugin-fingerprint-aio/releases/tag/v5.0.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/NiklasMerz/cordova-plugin-fingerprint-aio/security/advisories/GHSA-7vfx-hfvm-rhr8", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NiklasMerz/cordova-plugin-fingerprint-aio/commit/27434a240f97f69fd930088654590c8ba43569df"}}