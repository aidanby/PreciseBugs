{"buggy_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ZNC_MODULES_H\n#define ZNC_MODULES_H\n\n#include <znc/zncconfig.h>\n#include <znc/WebModules.h>\n#include <znc/Utils.h>\n#include <znc/Threads.h>\n#include <znc/Message.h>\n#include <znc/main.h>\n#include <znc/Translation.h>\n#include <functional>\n#include <set>\n#include <queue>\n#include <sys/time.h>\n\n// Forward Declarations\nclass CAuthBase;\nclass CChan;\nclass CQuery;\nclass CIRCNetwork;\nclass CClient;\nclass CWebSock;\nclass CTemplate;\nclass CIRCSock;\nclass CModule;\nclass CModInfo;\n// !Forward Declarations\n\n#ifdef REQUIRESSL\n#ifndef HAVE_LIBSSL\n#error -\n#error -\n#error This module only works when ZNC is compiled with OpenSSL support\n#error -\n#error -\n#endif\n#endif\n\n#ifdef BUILD_WITH_CMAKE\n#include <znc/znc_export_lib_export.h>\n#elif HAVE_VISIBILITY\n#define ZNC_EXPORT_LIB_EXPORT __attribute__((__visibility__(\"default\")))\n#else\n#define ZNC_EXPORT_LIB_EXPORT\n#endif\n\n/** C-style entry point to the module.\n *\n *  First, core compares C strings with version and compilation options of core\n *  and module. If they match, assume that C++ classes have the same layout and\n *  proceed to filling CModInfo.\n *\n *  Most parts of version-extra is explicitly not compared, otherwise all\n *  modules need to be rebuilt for every commit, which is more cumbersome for\n *  ZNC developers. However, the part set by user (e.g. +deb1), is compared.\n *\n *  If this struct ever changes, the first field (pcVersion) must stay the same.\n *  Otherwise, name of ZNCModuleEntry function must also change. Other fields\n *  can change at will.\n *\n *  Modules shouldn't care about this struct, it's all managed by ...MODULEDEFS\n *  macro.\n */\nstruct CModuleEntry {\n    const char* pcVersion;\n    const char* pcVersionExtra;\n    const char* pcCompileOptions;\n    void (*fpFillModInfo)(CModInfo&);\n};\n\n#define MODCOMMONDEFS(CLASS, DESCRIPTION, TYPE)                             \\\n    static void FillModInfo(CModInfo& Info) {                               \\\n        auto t_s = [&](const CString& sEnglish,                             \\\n                       const CString& sContext = \"\") {                      \\\n            return sEnglish.empty() ? \"\" : Info.t_s(sEnglish, sContext);    \\\n        };                                                                  \\\n        t_s(CString()); /* Don't warn about unused t_s */                   \\\n        Info.SetDescription(DESCRIPTION);                                   \\\n        Info.SetDefaultType(TYPE);                                          \\\n        Info.AddType(TYPE);                                                 \\\n        Info.SetLoader(TModLoad<CLASS>);                                    \\\n        TModInfo<CLASS>(Info);                                              \\\n    }                                                                       \\\n    extern \"C\" {                                                            \\\n    /* A global variable leads to ODR violation when several modules are    \\\n     * loaded. But a static variable inside a function works. */            \\\n    ZNC_EXPORT_LIB_EXPORT const CModuleEntry* ZNCModuleEntry();             \\\n    ZNC_EXPORT_LIB_EXPORT const CModuleEntry* ZNCModuleEntry() {            \\\n        static const CModuleEntry ThisModule = {VERSION_STR, VERSION_EXTRA, \\\n                                                ZNC_COMPILE_OPTIONS_STRING, \\\n                                                FillModInfo};               \\\n        return &ThisModule;                                                 \\\n    }                                                                       \\\n    }\n\n/** Instead of writing a constructor, you should call this macro. It accepts all\n *  the necessary arguments and passes them on to CModule's constructor. You\n *  should assume that there are no arguments to the constructor.\n *\n *  Usage:\n *  \\code\n *  class MyModule : public CModule {\n *      MODCONSTRUCTOR(MyModule) {\n *          // Your own constructor's code here\n *      }\n *  }\n *  \\endcode\n *\n *  @param CLASS The name of your module's class.\n */\n#define MODCONSTRUCTOR(CLASS)                                  \\\n    CLASS(ModHandle pDLL, CUser* pUser, CIRCNetwork* pNetwork, \\\n          const CString& sModName, const CString& sModPath,    \\\n          CModInfo::EModuleType eType)                         \\\n        : CModule(pDLL, pUser, pNetwork, sModName, sModPath, eType)\n\n// User Module Macros\n/** This works exactly like MODULEDEFS, but for user modules. */\n#define USERMODULEDEFS(CLASS, DESCRIPTION) \\\n    MODCOMMONDEFS(CLASS, DESCRIPTION, CModInfo::UserModule)\n// !User Module Macros\n\n// Global Module Macros\n/** This works exactly like MODULEDEFS, but for global modules. */\n#define GLOBALMODULEDEFS(CLASS, DESCRIPTION) \\\n    MODCOMMONDEFS(CLASS, DESCRIPTION, CModInfo::GlobalModule)\n// !Global Module Macros\n\n// Network Module Macros\n/** This works exactly like MODULEDEFS, but for network modules. */\n#define NETWORKMODULEDEFS(CLASS, DESCRIPTION) \\\n    MODCOMMONDEFS(CLASS, DESCRIPTION, CModInfo::NetworkModule)\n// !Network Module Macros\n\n/** At the end of your source file, you must call this macro in global context.\n *  It defines some static functions which ZNC needs to load this module.\n *  By default the module will be a network module.\n *  @param CLASS The name of your module's class.\n *  @param DESCRIPTION A short description of your module.\n */\n#define MODULEDEFS(CLASS, DESCRIPTION) NETWORKMODULEDEFS(CLASS, DESCRIPTION)\n\n// Forward Declarations\nclass CZNC;\nclass CUser;\nclass CNick;\nclass CChan;\nclass CModule;\nclass CFPTimer;\nclass CSockManager;\n// !Forward Declarations\n\nclass CTimer : public CCron {\n  public:\n    CTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles,\n           const CString& sLabel, const CString& sDescription);\n\n    virtual ~CTimer();\n\n    CTimer(const CTimer&) = delete;\n    CTimer& operator=(const CTimer&) = delete;\n\n    // Setters\n    void SetModule(CModule* p);\n    void SetDescription(const CString& s);\n    // !Setters\n\n    // Getters\n    CModule* GetModule() const;\n    const CString& GetDescription() const;\n    // !Getters\n  private:\n  protected:\n    CModule* m_pModule;\n    CString m_sDescription;\n};\n\ntypedef void (*FPTimer_t)(CModule*, CFPTimer*);\n\nclass CFPTimer : public CTimer {\n  public:\n    CFPTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles,\n             const CString& sLabel, const CString& sDescription)\n        : CTimer(pModule, uInterval, uCycles, sLabel, sDescription),\n          m_pFBCallback(nullptr) {}\n\n    virtual ~CFPTimer() {}\n\n    void SetFPCallback(FPTimer_t p) { m_pFBCallback = p; }\n\n  protected:\n    void RunJob() override {\n        if (m_pFBCallback) {\n            m_pFBCallback(m_pModule, this);\n        }\n    }\n\n  private:\n    FPTimer_t m_pFBCallback;\n};\n\n#ifdef HAVE_PTHREAD\n/// A CJob version which can be safely used in modules. The job will be\n/// cancelled when the module is unloaded.\nclass CModuleJob : public CJob {\n  public:\n    CModuleJob(CModule* pModule, const CString& sName, const CString& sDesc)\n        : CJob(), m_pModule(pModule), m_sName(sName), m_sDescription(sDesc) {}\n    virtual ~CModuleJob();\n\n    CModuleJob(const CModuleJob&) = delete;\n    CModuleJob& operator=(const CModuleJob&) = delete;\n\n    // Getters\n    CModule* GetModule() const { return m_pModule; }\n    const CString& GetName() const { return m_sName; }\n    const CString& GetDescription() const { return m_sDescription; }\n    // !Getters\n\n  protected:\n    CModule* m_pModule;\n    const CString m_sName;\n    const CString m_sDescription;\n};\n#endif\n\ntypedef void* ModHandle;\n\nclass CModInfo {\n  public:\n    typedef enum { GlobalModule, UserModule, NetworkModule } EModuleType;\n\n    typedef CModule* (*ModLoader)(ModHandle p, CUser* pUser,\n                                  CIRCNetwork* pNetwork,\n                                  const CString& sModName,\n                                  const CString& sModPath, EModuleType eType);\n\n    CModInfo() : CModInfo(\"\", \"\", NetworkModule) {}\n    CModInfo(const CString& sName, const CString& sPath, EModuleType eType)\n        : m_seType(),\n          m_eDefaultType(eType),\n          m_sName(sName),\n          m_sPath(sPath),\n          m_sDescription(\"\"),\n          m_sWikiPage(\"\"),\n          m_sArgsHelpText(\"\"),\n          m_bHasArgs(false),\n          m_fLoader(nullptr) {}\n    ~CModInfo() {}\n\n    bool operator<(const CModInfo& Info) const {\n        return (GetName() < Info.GetName());\n    }\n\n    bool SupportsType(EModuleType eType) const {\n        return m_seType.find(eType) != m_seType.end();\n    }\n\n    void AddType(EModuleType eType) { m_seType.insert(eType); }\n\n    static CString ModuleTypeToString(EModuleType eType) {\n        switch (eType) {\n            case GlobalModule:\n                return \"Global\";\n            case UserModule:\n                return \"User\";\n            case NetworkModule:\n                return \"Network\";\n            default:\n                return \"UNKNOWN\";\n        }\n    }\n\n    // Getters\n    const CString& GetName() const { return m_sName; }\n    const CString& GetPath() const { return m_sPath; }\n    const CString& GetDescription() const { return m_sDescription; }\n    const CString& GetWikiPage() const { return m_sWikiPage; }\n    const CString& GetArgsHelpText() const { return m_sArgsHelpText; }\n    bool GetHasArgs() const { return m_bHasArgs; }\n    ModLoader GetLoader() const { return m_fLoader; }\n    EModuleType GetDefaultType() const { return m_eDefaultType; }\n    // !Getters\n\n    // Setters\n    void SetName(const CString& s) { m_sName = s; }\n    void SetPath(const CString& s) { m_sPath = s; }\n    void SetDescription(const CString& s) { m_sDescription = s; }\n    void SetWikiPage(const CString& s) { m_sWikiPage = s; }\n    void SetArgsHelpText(const CString& s) { m_sArgsHelpText = s; }\n    void SetHasArgs(bool b = false) { m_bHasArgs = b; }\n    void SetLoader(ModLoader fLoader) { m_fLoader = fLoader; }\n    void SetDefaultType(EModuleType eType) { m_eDefaultType = eType; }\n    // !Setters\n\n    CString t_s(const CString& sEnglish, const CString& sContext = \"\") const;\n\n  private:\n  protected:\n    std::set<EModuleType> m_seType;\n    EModuleType m_eDefaultType;\n    CString m_sName;\n    CString m_sPath;\n    CString m_sDescription;\n    CString m_sWikiPage;\n    CString m_sArgsHelpText;\n    bool m_bHasArgs;\n    ModLoader m_fLoader;\n};\n\ntemplate <class M>\nvoid TModInfo(CModInfo& Info) {}\n\ntemplate <class M>\nCModule* TModLoad(ModHandle p, CUser* pUser, CIRCNetwork* pNetwork,\n                  const CString& sModName, const CString& sModPath,\n                  CModInfo::EModuleType eType) {\n    return new M(p, pUser, pNetwork, sModName, sModPath, eType);\n}\n\n/** A helper class for handling commands in modules. */\nclass CModCommand : private CCoreTranslationMixin {\n  public:\n    /// Type for the callback function that handles the actual command.\n    typedef void (CModule::*ModCmdFunc)(const CString& sLine);\n    typedef std::function<void(const CString& sLine)> CmdFunc;\n\n    /// Default constructor, needed so that this can be saved in a std::map.\n    CModCommand();\n\n    /** Construct a new CModCommand.\n     * @param sCmd The name of the command.\n     * @param func The command's callback function.\n     * @param sArgs Help text describing the arguments to this command.\n     * @param sDesc Help text describing what this command does.\n     */\n    CModCommand(const CString& sCmd, CModule* pMod, ModCmdFunc func,\n                const CString& sArgs, const CString& sDesc);\n    CModCommand(const CString& sCmd, CmdFunc func,\n                const COptionalTranslation& Args,\n                const COptionalTranslation& Desc);\n\n    /** Copy constructor, needed so that this can be saved in a std::map.\n     * @param other Object to copy from.\n     */\n    CModCommand(const CModCommand& other) = default;\n\n    /** Assignment operator, needed so that this can be saved in a std::map.\n     * @param other Object to copy from.\n     */\n    CModCommand& operator=(const CModCommand& other) = default;\n\n    /** Initialize a CTable so that it can be used with AddHelp().\n     * @param Table The instance of CTable to initialize.\n     */\n    static void InitHelp(CTable& Table);\n\n    /** Add this command to the CTable instance.\n     * @param Table Instance of CTable to which this should be added.\n     * @warning The Table should be initialized via InitHelp().\n     */\n    void AddHelp(CTable& Table) const;\n\n    const CString& GetCommand() const { return m_sCmd; }\n    CmdFunc GetFunction() const { return m_pFunc; }\n    CString GetArgs() const { return m_Args.Resolve(); }\n    CString GetDescription() const { return m_Desc.Resolve(); }\n\n    void Call(const CString& sLine) const { m_pFunc(sLine); }\n\n  private:\n    CString m_sCmd;\n    CmdFunc m_pFunc;\n    COptionalTranslation m_Args;\n    COptionalTranslation m_Desc;\n};\n\n/** The base class for your own ZNC modules.\n *\n *  If you want to write a module for ZNC, you will have to implement a class\n *  which inherits from this class. You should override some of the \"On*\"\n *  functions in this class. These function will then be called by ZNC when the\n *  associated event happens.\n *\n *  If such a module hook is called with a non-const reference to e.g. a\n *  CString, then it is free to modify that argument to influence ZNC's\n *  behavior.\n *\n *  @see MODCONSTRUCTOR and MODULEDEFS\n */\nclass CModule {\n  public:\n    CModule(\n        ModHandle pDLL, CUser* pUser, CIRCNetwork* pNetwork,\n        const CString& sModName, const CString& sDataDir,\n        CModInfo::EModuleType eType =\n            CModInfo::NetworkModule);  // TODO: remove default value in ZNC 2.x\n    virtual ~CModule();\n\n    CModule(const CModule&) = delete;\n    CModule& operator=(const CModule&) = delete;\n\n    /** This enum is just used for return from module hooks. Based on this\n     *  return, ZNC then decides what to do with the event which caused the\n     *  module hook.\n     */\n    typedef enum {\n        /** ZNC will continue event processing normally. This is what\n         *  you should return normally.\n         */\n        CONTINUE = 1,\n        /** This is the same as both CModule::HALTMODS and\n         * CModule::HALTCORE together.\n         */\n        HALT = 2,\n        /** Stop sending this even to other modules which were not\n         *  called yet. Internally, the event is handled normally.\n         */\n        HALTMODS = 3,\n        /** Continue calling other modules. When done, ignore the event\n         *  in the ZNC core. (For most module hooks this means that a\n         *  given event won't be forwarded to the connected users)\n         */\n        HALTCORE = 4\n    } EModRet;\n\n    typedef enum {\n        /** Your module can throw this enum at any given time. When this\n         * is thrown, the module will be unloaded.\n         */\n        UNLOAD\n    } EModException;\n\n    void SetUser(CUser* pUser);\n    void SetNetwork(CIRCNetwork* pNetwork);\n    void SetClient(CClient* pClient);\n\n    /** This function throws CModule::UNLOAD which causes this module to be unloaded.\n     */\n    void Unload() { throw UNLOAD; }\n\n    /** This module hook is called when a module is loaded\n     *  @param sArgsi The arguments for the modules.\n     *  @param sMessage A message that may be displayed to the user after\n     *                  loading the module. Useful for returning error messages.\n     *  @return true if the module loaded successfully, else false.\n     */\n    virtual bool OnLoad(const CString& sArgsi, CString& sMessage);\n    /** This module hook is called during ZNC startup. Only modules loaded\n     *  from znc.conf get this call.\n     *  @return false to abort ZNC startup.\n     */\n    virtual bool OnBoot();\n\n    /** Modules which can only be used with an active user session have to return true here.\n     *  @return false for modules that can do stuff for non-logged in web users as well.\n     */\n    virtual bool WebRequiresLogin() { return true; }\n    /** Return true if this module should only be usable for admins on the web.\n     *  @return false if normal users can use this module's web pages as well.\n     */\n    virtual bool WebRequiresAdmin() { return false; }\n    /** Return the title of the module's section in the web interface's side bar.\n     *  @return The Title.\n     */\n    virtual CString GetWebMenuTitle() { return \"\"; }\n    virtual CString GetWebPath();\n    virtual CString GetWebFilesPath();\n    /** For WebMods: Called before the list of registered SubPages will be checked.\n     *  Important: If you return true, you need to take care of calling WebSock.Close!\n     *  This allows for stuff like returning non-templated data, long-polling and other fun.\n     *  @param WebSock The active request.\n     *  @param sPageName The name of the page that has been requested.\n     *  @return true if you handled the page request or false if the name is to be checked\n     *          against the list of registered SubPages and their permission settings.\n     */\n    virtual bool OnWebPreRequest(CWebSock& WebSock, const CString& sPageName);\n    /** If OnWebPreRequest returned false, and the RequiresAdmin/IsAdmin check has been passed,\n     *  this method will be called with the page name. It will also be called for pages that\n     *  have NOT been specifically registered with AddSubPage.\n     *  @param WebSock The active request.\n     *  @param sPageName The name of the page that has been requested.\n     *  @param Tmpl The active template. You can add variables, loops and stuff to it.\n     *  @return You MUST return true if you want the template to be evaluated and sent to the browser.\n     *          Return false if you called Redirect() or PrintErrorPage(). If you didn't, a 404 page will be sent.\n     */\n    virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName,\n                              CTemplate& Tmpl);\n    /** If ValidateWebRequestCSRFCheck returned false, a CSRF error will be printed.\n     *  @param WebSock The active request.\n     *  @param sPageName The name of the page that has been requested.\n     *  @return You MUST return true if the CSRF token is valid.\n     */\n    virtual bool ValidateWebRequestCSRFCheck(CWebSock& WebSock, const CString& sPageName);\n    /** Registers a sub page for the sidebar.\n     *  @param spSubPage The SubPage instance.\n     */\n    virtual void AddSubPage(TWebSubPage spSubPage) {\n        m_vSubPages.push_back(spSubPage);\n    }\n    /** Removes all registered (AddSubPage'd) SubPages.\n     */\n    virtual void ClearSubPages() { m_vSubPages.clear(); }\n    /** Returns a list of all registered SubPages. Don't mess with it too much.\n     *  @return The List.\n     */\n    virtual VWebSubPages& GetSubPages() { return m_vSubPages; }\n    /** Using this hook, module can embed web stuff directly to different places.\n     *  This method is called whenever embededded modules I/O happens.\n     *  Name of used .tmpl file (if any) is up to caller.\n     *  @param WebSock Socket for web connection, don't do bad things with it.\n     *  @param sPageName Describes the place where web stuff is embedded to.\n     *  @param Tmpl Template. Depending on context, you can do various stuff with it.\n     *  @return If you don't need to embed web stuff to the specified place, just return false.\n     *          Exact meaning of return value is up to caller, and depends on context.\n     */\n    virtual bool OnEmbeddedWebRequest(CWebSock& WebSock,\n                                      const CString& sPageName,\n                                      CTemplate& Tmpl);\n\n    /** Called just before znc.conf is rehashed */\n    virtual void OnPreRehash();\n    /** This module hook is called after a <em>successful</em> rehash. */\n    virtual void OnPostRehash();\n    /** This module hook is called when a user gets disconnected from IRC. */\n    virtual void OnIRCDisconnected();\n    /** This module hook is called after a successful login to IRC. */\n    virtual void OnIRCConnected();\n    /** This module hook is called just before ZNC tries to establish a\n     *  connection to an IRC server.\n     *  @param pIRCSock The socket that will be used for the connection.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnIRCConnecting(CIRCSock* pIRCSock);\n    /** This module hook is called when a CIRCSock fails to connect or\n     *  a module returned HALTCORE from OnIRCConnecting.\n     *  @param pIRCSock The socket that failed to connect.\n     */\n    virtual void OnIRCConnectionError(CIRCSock* pIRCSock);\n    /** This module hook is called before loging in to the IRC server. The\n     *  low-level connection is established at this point, but SSL\n     *  handshakes didn't necessarily finish yet.\n     *  @param sPass The server password that will be used.\n     *  @param sNick The nick that will be used.\n     *  @param sIdent The protocol identity that will be used. This is not\n     *                the ident string that is transferred via e.g. oidentd!\n     *  @param sRealName The real name that will be used.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnIRCRegistration(CString& sPass, CString& sNick,\n                                      CString& sIdent, CString& sRealName);\n    /** This module hook is called when a message is broadcasted to all users.\n     *  @param sMessage The message that is broadcasted.\n     *  @return see CModule::EModRet\n     */\n    virtual EModRet OnBroadcast(CString& sMessage);\n\n    /** This module hook is called when a user mode on a channel changes.\n     *  @param pOpNick The nick who sent the mode change, or nullptr if set by server.\n     *  @param Nick The nick whose channel mode changes.\n     *  @param Channel The channel on which the user mode is changed.\n     *  @param cMode The mode character that is changed, e.g. '@' for op.\n     *  @param bAdded True if the mode is added, else false.\n     *  @param bNoChange true if this mode change doesn't change anything\n     *                   because the nick already had this permission.\n     *  @see CIRCSock::GetModeType() for converting uMode into a mode (e.g.\n     *       'o' for op).\n     */\n    virtual void OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                                   CChan& Channel, char cMode,\n                                   bool bAdded, bool bNoChange);\n    /// @deprecated. Use OnChanPermission3.\n    virtual void OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                                   CChan& Channel, unsigned char uMode,\n                                   bool bAdded, bool bNoChange);\n    /// @deprecated. Use OnChanPermission3.\n    virtual void OnChanPermission(const CNick& OpNick, const CNick& Nick,\n                                  CChan& Channel, unsigned char uMode,\n                                  bool bAdded, bool bNoChange);\n    /** Called when a nick is opped on a channel */\n    virtual void OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange);\n    virtual void OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange);\n    /** Called when a nick is deopped on a channel */\n    virtual void OnDeop2(const CNick* pOpNick, const CNick& Nick,\n                         CChan& Channel, bool bNoChange);\n    virtual void OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                        bool bNoChange);\n    /** Called when a nick is voiced on a channel */\n    virtual void OnVoice2(const CNick* pOpNick, const CNick& Nick,\n                          CChan& Channel, bool bNoChange);\n    virtual void OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                         bool bNoChange);\n    /** Called when a nick is devoiced on a channel */\n    virtual void OnDevoice2(const CNick* pOpNick, const CNick& Nick,\n                            CChan& Channel, bool bNoChange);\n    virtual void OnDevoice(const CNick& OpNick, const CNick& Nick,\n                           CChan& Channel, bool bNoChange);\n    /** Called on an individual channel mode change.\n     *  @param pOpNick The nick who changes the channel mode, or nullptr if set by server.\n     *  @param Channel The channel whose mode is changed.\n     *  @param uMode The mode character that is changed.\n     *  @param sArg The argument to the mode character, if any.\n     *  @param bAdded True if this mode is added (\"+\"), else false.\n     *  @param bNoChange True if this mode was already effective before.\n     */\n    virtual void OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                         const CString& sArg, bool bAdded, bool bNoChange);\n    virtual void OnMode(const CNick& OpNick, CChan& Channel, char uMode,\n                        const CString& sArg, bool bAdded, bool bNoChange);\n    /** Called on any channel mode change. This is called before the more\n     *  detailed mode hooks like e.g. OnOp() and OnMode().\n     *  @param pOpNick The nick who changes the channel mode, or nullptr if set by server.\n     *  @param Channel The channel whose mode is changed.\n     *  @param sModes The raw mode change, e.g. \"+s-io\".\n     *  @param sArgs All arguments to the mode change from sModes.\n     */\n    virtual void OnRawMode2(const CNick* pOpNick, CChan& Channel,\n                            const CString& sModes, const CString& sArgs);\n    virtual void OnRawMode(const CNick& OpNick, CChan& Channel,\n                           const CString& sModes, const CString& sArgs);\n\n    /** Called on any raw IRC line received from the <em>IRC server</em>.\n     *  @param sLine The line read from the server.\n     *  @note The line does not include message tags. Use OnRawMessage() to access them.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnRaw(CString& sLine);\n    /** Called on any raw message received from the <em>IRC server</em>.\n     *  @since 1.7.0\n     *  @param Message The received message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnRawMessage(CMessage& Message);\n\n    /** Called when a numeric message is received from the <em>IRC server</em>.\n     *  @since 1.7.0\n     *  @param Message The received message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnNumericMessage(CNumericMessage& Message);\n\n    /** Called when a command to *status is sent.\n     *  @param sCommand The command sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnStatusCommand(CString& sCommand);\n    /** Called when a command to your module is sent, e.g. query to *modname.\n     *  @param sCommand The command that was sent.\n     */\n    virtual void OnModCommand(const CString& sCommand);\n    /** This is similar to OnModCommand(), but it is only called if\n     * HandleCommand didn't find any that wants to handle this. This is only\n     * called if HandleCommand() is called, which practically means that\n     * this is only called if you don't overload OnModCommand().\n     *  @param sCommand The command that was sent.\n     */\n    virtual void OnUnknownModCommand(const CString& sCommand);\n    /** Called when a your module nick was sent a notice.\n     *  @param sMessage The message which was sent.\n     */\n    virtual void OnModNotice(const CString& sMessage);\n    /** Called when your module nick was sent a CTCP message. OnModCommand()\n     *  won't be called for this message.\n     *  @param sMessage The message which was sent.\n     */\n    virtual void OnModCTCP(const CString& sMessage);\n\n    /** Called when a nick quit from IRC.\n     *  @since 1.7.0\n     *  @param Message The quit message.\n     *  @param vChans List of channels which you and nick share.\n     */\n    virtual void OnQuitMessage(CQuitMessage& Message,\n                               const std::vector<CChan*>& vChans);\n    /// @deprecated Use OnQuitMessage() instead.\n    virtual void OnQuit(const CNick& Nick, const CString& sMessage,\n                        const std::vector<CChan*>& vChans);\n\n    /** Called when a nickname change occurs.\n     *  @since 1.7.0\n     *  @param Message The nick message.\n     *  @param vChans Channels which we and nick share.\n     */\n    virtual void OnNickMessage(CNickMessage& Message,\n                               const std::vector<CChan*>& vChans);\n    /// @deprecated Use OnNickMessage() instead.\n    virtual void OnNick(const CNick& Nick, const CString& sNewNick,\n                        const std::vector<CChan*>& vChans);\n\n    /** Called when a nick is kicked from a channel.\n     *  @since 1.7.0\n     *  @param Message The kick message.\n     */\n    virtual void OnKickMessage(CKickMessage& Message);\n    /// @deprecated Use OnKickMessage() instead.\n    virtual void OnKick(const CNick& OpNick, const CString& sKickedNick,\n                        CChan& Channel, const CString& sMessage);\n\n    /** This module hook is called just before ZNC tries to join an IRC channel.\n     *  @param Chan The channel which is about to get joined.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnJoining(CChan& Channel);\n\n    /** Called when a nick joins a channel.\n     *  @since 1.7.0\n     *  @param Message The join message.\n     */\n    virtual void OnJoinMessage(CJoinMessage& Message);\n    /// @deprecated Use OnJoinMessage() instead.\n    virtual void OnJoin(const CNick& Nick, CChan& Channel);\n\n    /** Called when a nick parts a channel.\n     *  @since 1.7.0\n     *  @param Message The part message.\n     */\n    virtual void OnPartMessage(CPartMessage& Message);\n    /// @deprecated Use OnPartMessage() instead.\n    virtual void OnPart(const CNick& Nick, CChan& Channel,\n                        const CString& sMessage);\n\n    /** Called when user is invited into a channel\n     *  @param Nick The nick who invited you.\n     *  @param sChan The channel the user got invited into\n     *  @return See CModule::EModRet.\n     *  @todo Add OnInviteMessage() hook\n     */\n    virtual EModRet OnInvite(const CNick& Nick, const CString& sChan);\n\n    /** Called before a channel buffer is played back to a client.\n     *  @param Chan The channel which will be played back.\n     *  @param Client The client the buffer will be played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanBufferStarting(CChan& Chan, CClient& Client);\n    /** Called after a channel buffer was played back to a client.\n     *  @param Chan The channel which was played back.\n     *  @param Client The client the buffer was played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanBufferEnding(CChan& Chan, CClient& Client);\n\n    /** Called for each message during a channel's buffer play back.\n     *  @since 1.7.0\n     *  @param Message The playback message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanBufferPlayMessage(CMessage& Message);\n    /// @deprecated Use OnChanBufferPlayMessage() instead.\n    virtual EModRet OnChanBufferPlayLine2(CChan& Chan, CClient& Client,\n                                          CString& sLine, const timeval& tv);\n    /// @deprecated Use OnChanBufferPlayMessage() instead.\n    virtual EModRet OnChanBufferPlayLine(CChan& Chan, CClient& Client,\n                                         CString& sLine);\n\n    /** Called before a query buffer is played back to a client.\n     *  @since 1.7.0\n     *  @param Query The query which will be played back.\n     *  @param Client The client the buffer will be played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivBufferStarting(CQuery& Query, CClient& Client);\n    /** Called after a query buffer was played back to a client.\n     *  @since 1.7.0\n     *  @param Query The query which was played back.\n     *  @param Client The client the buffer was played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivBufferEnding(CQuery& Query, CClient& Client);\n\n    /** Called for each message during a query's buffer play back.\n     *  @since 1.7.0\n     *  @param Message The playback message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivBufferPlayMessage(CMessage& Message);\n    /// @deprecated Use OnPrivBufferPlayMessage() instead.\n    virtual EModRet OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                                          const timeval& tv);\n    /// @deprecated Use OnPrivBufferPlayMessage() instead.\n    virtual EModRet OnPrivBufferPlayLine(CClient& Client, CString& sLine);\n\n    /** Called when a client successfully logged in to ZNC. */\n    virtual void OnClientLogin();\n    /** Called when a client disconnected from ZNC. */\n    virtual void OnClientDisconnect();\n\n    /** This module hook is called when a client sends a raw traffic line to ZNC.\n     *  @param sLine The raw traffic line sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserRaw(CString& sLine);\n    /** This module hook is called when a client sends any message to ZNC.\n     *  @since 1.7.0\n     *  @param Message The message sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserRawMessage(CMessage& Message);\n\n    /** This module hook is called when a client sends a CTCP reply.\n     *  @since 1.7.0\n     *  @param Message The CTCP reply message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserCTCPReplyMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnUserCTCPReplyMessage() instead.\n    virtual EModRet OnUserCTCPReply(CString& sTarget, CString& sMessage);\n\n    /** This module hook is called when a client sends a CTCP request.\n     *  @since 1.7.0\n     *  @param Message The CTCP request message.\n     *  @return See CModule::EModRet.\n     *  @note This is not called for CTCP ACTION messages, use\n     *        CModule::OnUserActionMessage() instead.\n     */\n    virtual EModRet OnUserCTCPMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnUserCTCPMessage() instead.\n    virtual EModRet OnUserCTCP(CString& sTarget, CString& sMessage);\n\n    /** Called when a client sends a CTCP ACTION request (\"/me\").\n     *  @since 1.7.0\n     *  @param Message The action message.\n     *  @return See CModule::EModRet.\n     *  @note CModule::OnUserCTCPMessage() will not be called for this message.\n     */\n    virtual EModRet OnUserActionMessage(CActionMessage& Message);\n    /// @deprecated Use OnUserActionMessage() instead.\n    virtual EModRet OnUserAction(CString& sTarget, CString& sMessage);\n\n    /** This module hook is called when a user sends a PRIVMSG message.\n     *  @since 1.7.0\n     *  @param Message The message which was sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserTextMessage(CTextMessage& Message);\n    /// @deprecated Use OnUserTextMessage() instead.\n    virtual EModRet OnUserMsg(CString& sTarget, CString& sMessage);\n\n    /** This module hook is called when a user sends a NOTICE message.\n     *  @since 1.7.0\n     *  @param Message The message which was sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserNoticeMessage(CNoticeMessage& Message);\n    /// @deprecated Use OnUserNoticeMessage() instead.\n    virtual EModRet OnUserNotice(CString& sTarget, CString& sMessage);\n\n    /** This hooks is called when a user sends a JOIN message.\n     *  @since 1.7.0\n     *  @param Message The join message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserJoinMessage(CJoinMessage& Message);\n    /// @deprecated Use OnUserJoinMessage() instead.\n    virtual EModRet OnUserJoin(CString& sChannel, CString& sKey);\n\n    /** This hooks is called when a user sends a PART message.\n     *  @since 1.7.0\n     *  @param Message The part message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserPartMessage(CPartMessage& Message);\n    /// @deprecated Use OnUserPartMessage() instead.\n    virtual EModRet OnUserPart(CString& sChannel, CString& sMessage);\n\n    /** This module hook is called when a user wants to change a channel topic.\n     *  @since 1.7.0\n     *  @param Message The topic message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserTopicMessage(CTopicMessage& Message);\n    /// @deprecated Use OnUserTopicMessage() instead.\n    virtual EModRet OnUserTopic(CString& sChannel, CString& sTopic);\n\n    /** This hook is called when a user requests a channel's topic.\n     *  @param sChannel The channel for which the request is.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserTopicRequest(CString& sChannel);\n\n    /** This module hook is called when a client quits ZNC.\n     *  @since 1.7.0\n     *  @param Message The quit message the client sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserQuitMessage(CQuitMessage& Message);\n    /// @deprecated Use OnUserQuitMessage() instead.\n    virtual EModRet OnUserQuit(CString& sMessage);\n\n    /** Called when we receive a CTCP reply <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The CTCP reply message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnCTCPReplyMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnCTCPReplyMessage() instead.\n    virtual EModRet OnCTCPReply(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a private CTCP request <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The CTCP request message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivCTCPMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnPrivCTCPMessage() instead.\n    virtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel CTCP request <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The CTCP request message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanCTCPMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnChanCTCPMessage() instead.\n    virtual EModRet OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage);\n\n    /** Called when we receive a private CTCP ACTION (\"/me\" in query) <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The action message\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivActionMessage(CActionMessage& Message);\n    /// @deprecated Use OnPrivActionMessage() instead.\n    virtual EModRet OnPrivAction(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel CTCP ACTION (\"/me\" in a channel) <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The action message\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanActionMessage(CActionMessage& Message);\n    /// @deprecated Use OnChanActionMessage() instead.\n    virtual EModRet OnChanAction(CNick& Nick, CChan& Channel,\n                                 CString& sMessage);\n\n    /** Called when we receive a private PRIVMSG message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The private message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivTextMessage(CTextMessage& Message);\n    /// @deprecated Use OnPrivTextMessage() instead.\n    virtual EModRet OnPrivMsg(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel PRIVMSG message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The channel message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanTextMessage(CTextMessage& Message);\n    /// @deprecated Use OnChanTextMessage() instead.\n    virtual EModRet OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage);\n\n    /** Called when we receive a private NOTICE message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The notice message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivNoticeMessage(CNoticeMessage& Message);\n    /// @deprecated Use OnPrivNoticeMessage() instead.\n    virtual EModRet OnPrivNotice(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel NOTICE message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The notice message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanNoticeMessage(CNoticeMessage& Message);\n    /// @deprecated Use OnChanNoticeMessage() instead.\n    virtual EModRet OnChanNotice(CNick& Nick, CChan& Channel,\n                                 CString& sMessage);\n\n    /** Called when we receive a channel topic change <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The topic message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnTopicMessage(CTopicMessage& Message);\n    /// @deprecated Use OnTopicMessage() instead.\n    virtual EModRet OnTopic(CNick& Nick, CChan& Channel, CString& sTopic);\n\n    /** Called for every CAP received via CAP LS from server.\n     *  @param sCap capability supported by server.\n     *  @return true if your module supports this CAP and\n     *          needs to turn it on with CAP REQ.\n     */\n    virtual bool OnServerCapAvailable(const CString& sCap);\n    /** Called for every CAP accepted or rejected by server\n     *  (with CAP ACK or CAP NAK after our CAP REQ).\n     *  @param sCap capability accepted/rejected by server.\n     *  @param bSuccess true if capability was accepted, false if rejected.\n     */\n    virtual void OnServerCapResult(const CString& sCap, bool bSuccess);\n\n    /** This module hook is called just before ZNC tries to join a channel\n     *  by itself because it's in the config but wasn't joined yet.\n     *  @param Channel The channel which will be joined.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnTimerAutoJoin(CChan& Channel);\n\n    /** This module hook is called when a network is being added.\n     *  @param Network The new IRC network.\n     *  @param sErrorRet A message that may be displayed to the user if\n     *                  the module stops adding the network.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnAddNetwork(CIRCNetwork& Network, CString& sErrorRet);\n    /** This module hook is called when a network is deleted.\n     *  @param Network The IRC network which is going to be deleted.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnDeleteNetwork(CIRCNetwork& Network);\n\n    /** Called immediately before ZNC sends a raw traffic line to a client.\n     *  @since 1.7.0\n     *  @param Message The message being sent to the client.\n     *  @warning Calling PutUser() from within this hook leads to infinite recursion.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnSendToClientMessage(CMessage& Message);\n    /// @deprecated Use OnSendToClientMessage() instead.\n    virtual EModRet OnSendToClient(CString& sLine, CClient& Client);\n\n    /** Called immediately before ZNC sends a raw traffic line to the IRC server.\n     *  @since 1.7.0\n     *  @param Message The message being sent to the IRC server.\n     *  @warning Calling PutIRC() from within this hook leads to infinite recursion.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnSendToIRCMessage(CMessage& Message);\n    /// @deprecated Use OnSendToIRCMessage() instead.\n    virtual EModRet OnSendToIRC(CString& sLine);\n\n    ModHandle GetDLL() { return m_pDLL; }\n\n    /** This function sends a given IRC line to the IRC server, if we\n     *  are connected to one. Else this line is discarded.\n     *  @param sLine The line which should be sent.\n     *  @return true if the line was queued for sending.\n     */\n    virtual bool PutIRC(const CString& sLine);\n    /** This function sends a given IRC message to the IRC server, if we\n     *  are connected to one. Else this message is discarded.\n     *  @param Message The message which should be sent.\n     *  @return true if the message was queued for sending.\n     */\n    virtual bool PutIRC(const CMessage& Message);\n    /** This function sends a given raw IRC line to a client.\n     *  If we are in a module hook which is called for a specific client,\n     *  only that client will get the line, else all connected clients will\n     *  receive this line.\n     *  @param sLine The line which should be sent.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutUser(const CString& sLine);\n    /** This function generates a query from *status. If we are in a module\n     *  hook for a specific client, only that client gets this message, else\n     *  all connected clients will receive it.\n     *  @param sLine The message which should be sent from *status.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutStatus(const CString& sLine);\n    /** This function sends a query from your module nick. If we are in a\n     *  module hook for a specific client, only that client gets this\n     *  message, else all connected clients will receive it.\n     *  @param sLine The message which should be sent.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutModule(const CString& sLine);\n    /** This function calls CModule::PutModule(const CString&, const\n     *  CString&, const CString&) for each line in the table.\n     *  @param table The table which should be send.\n     *  @return The number of lines sent.\n     */\n    virtual unsigned int PutModule(const CTable& table);\n    /** Send a notice from your module nick. If we are in a module hook for\n     *  a specific client, only that client gets this notice, else all\n     *  clients will receive it.\n     *  @param sLine The line which should be sent.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutModNotice(const CString& sLine);\n\n    /** @returns The name of the module. */\n    const CString& GetModName() const { return m_sModName; }\n\n    /** @returns The nick of the module. This is just the module name\n     *           prefixed by the status prefix.\n     */\n    CString GetModNick() const;\n\n    /** Get the module's data dir.\n     *  Modules can be accompanied by static data, e.g. skins for webadmin.\n     *  These function will return the path to that data.\n     */\n    const CString& GetModDataDir() const { return m_sDataDir; }\n\n    // Timer stuff\n    bool AddTimer(CTimer* pTimer);\n    bool AddTimer(FPTimer_t pFBCallback, const CString& sLabel, u_int uInterval,\n                  u_int uCycles = 0, const CString& sDescription = \"\");\n    bool RemTimer(CTimer* pTimer);\n    bool RemTimer(const CString& sLabel);\n    bool UnlinkTimer(CTimer* pTimer);\n    CTimer* FindTimer(const CString& sLabel);\n    std::set<CTimer*>::const_iterator BeginTimers() const {\n        return m_sTimers.begin();\n    }\n    std::set<CTimer*>::const_iterator EndTimers() const {\n        return m_sTimers.end();\n    }\n    virtual void ListTimers();\n    // !Timer stuff\n\n    // Socket stuff\n    bool AddSocket(CSocket* pSocket);\n    bool RemSocket(CSocket* pSocket);\n    bool RemSocket(const CString& sSockName);\n    bool UnlinkSocket(CSocket* pSocket);\n    CSocket* FindSocket(const CString& sSockName);\n    std::set<CSocket*>::const_iterator BeginSockets() const {\n        return m_sSockets.begin();\n    }\n    std::set<CSocket*>::const_iterator EndSockets() const {\n        return m_sSockets.end();\n    }\n    virtual void ListSockets();\n// !Socket stuff\n\n#ifdef HAVE_PTHREAD\n    // Job stuff\n    void AddJob(CModuleJob* pJob);\n    void CancelJob(CModuleJob* pJob);\n    bool CancelJob(const CString& sJobName);\n    void CancelJobs(const std::set<CModuleJob*>& sJobs);\n    bool UnlinkJob(CModuleJob* pJob);\n// !Job stuff\n#endif\n\n    // Command stuff\n    /// Register the \"Help\" command.\n    void AddHelpCommand();\n    /// @return True if the command was successfully added.\n    bool AddCommand(const CModCommand& Command);\n    /// @return True if the command was successfully added.\n    /// @deprecated Use the variant with COptionalTranslation.\n    bool AddCommand(const CString& sCmd, CModCommand::ModCmdFunc func,\n                    const CString& sArgs = \"\", const CString& sDesc = \"\");\n    /// @param dDesc Either a string \"\", or the result of t_d()\n    /// @return True if the command was successfully added.\n    bool AddCommand(const CString& sCmd, const COptionalTranslation& Args,\n                    const COptionalTranslation& Desc,\n                    std::function<void(const CString& sLine)> func);\n    /// @return True if the command was successfully removed.\n    bool RemCommand(const CString& sCmd);\n    /// @return The CModCommand instance or nullptr if none was found.\n    const CModCommand* FindCommand(const CString& sCmd) const;\n    /** This function tries to dispatch the given command via the correct\n     * instance of CModCommand. Before this can be called, commands have to\n     * be added via AddCommand(). If no matching commands are found then\n     * OnUnknownModCommand will be called.\n     * @param sLine The command line to handle.\n     * @return True if something was done, else false.\n     */\n    bool HandleCommand(const CString& sLine);\n    /** Send a description of all registered commands via PutModule().\n     * @param sLine The help command that is being asked for.\n     */\n    void HandleHelpCommand(const CString& sLine = \"\");\n    // !Command stuff\n\n    bool LoadRegistry();\n    bool SaveRegistry() const;\n    bool MoveRegistry(const CString& sPath);\n    bool SetNV(const CString& sName, const CString& sValue,\n               bool bWriteToDisk = true);\n    CString GetNV(const CString& sName) const;\n    bool HasNV(const CString& sName) const {\n        return m_mssRegistry.find(sName) != m_mssRegistry.end();\n    }\n    bool DelNV(const CString& sName, bool bWriteToDisk = true);\n    MCString::iterator FindNV(const CString& sName) {\n        return m_mssRegistry.find(sName);\n    }\n    MCString::iterator EndNV() { return m_mssRegistry.end(); }\n    MCString::iterator BeginNV() { return m_mssRegistry.begin(); }\n    void DelNV(MCString::iterator it) { m_mssRegistry.erase(it); }\n    bool ClearNV(bool bWriteToDisk = true);\n\n    const CString& GetSavePath() const;\n    CString ExpandString(const CString& sStr) const;\n    CString& ExpandString(const CString& sStr, CString& sRet) const;\n\n    // Setters\n    void SetType(CModInfo::EModuleType eType) { m_eType = eType; }\n    void SetDescription(const CString& s) { m_sDescription = s; }\n    void SetModPath(const CString& s) { m_sModPath = s; }\n    void SetArgs(const CString& s) { m_sArgs = s; }\n    // !Setters\n\n    // Getters\n    CModInfo::EModuleType GetType() const { return m_eType; }\n    const CString& GetDescription() const { return m_sDescription; }\n    const CString& GetArgs() const { return m_sArgs; }\n    const CString& GetModPath() const { return m_sModPath; }\n\n    /** @returns For user modules this returns the user for which this\n     *           module was loaded. For global modules this returns nullptr,\n     *           except when we are in a user-specific module hook in which\n     *           case this is the user pointer.\n     */\n    CUser* GetUser() const { return m_pUser; }\n    /** @returns nullptr except when we are in a network-specific module hook in\n     *           which case this is the network for which the hook is called.\n     */\n    CIRCNetwork* GetNetwork() const { return m_pNetwork; }\n    /** @returns nullptr except when we are in a client-specific module hook in\n     *           which case this is the client for which the hook is called.\n     */\n    CClient* GetClient() const { return m_pClient; }\n    CSockManager* GetManager() const { return m_pManager; }\n    // !Getters\n\n    // Global Modules\n    /** This module hook is called when a user is being added.\n     * @param User The user which will be added.\n     * @param sErrorRet A message that may be displayed to the user if\n     *                  the module stops adding the user.\n     * @return See CModule::EModRet.\n     */\n    virtual EModRet OnAddUser(CUser& User, CString& sErrorRet);\n    /** This module hook is called when a user is deleted.\n     *  @param User The user which will be deleted.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnDeleteUser(CUser& User);\n    /** This module hook is called when there is an incoming connection on\n     *  any of ZNC's listening sockets.\n     *  @param pSock The incoming client socket.\n     *  @param sHost The IP the client is connecting from.\n     *  @param uPort The port the client is connecting from.\n     */\n    virtual void OnClientConnect(CZNCSock* pSock, const CString& sHost,\n                                 unsigned short uPort);\n    /** This module hook is called when a client tries to login. If your\n     *  module wants to handle the login attempt, it must return\n     *  CModule::EModRet::HALT;\n     *  @param Auth The necessary authentication info for this login attempt.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnLoginAttempt(std::shared_ptr<CAuthBase> Auth);\n    /** Called after a client login was rejected.\n     *  @param sUsername The username that tried to log in.\n     *  @param sRemoteIP The IP address from which the client tried to login.\n     */\n    virtual void OnFailedLogin(const CString& sUsername,\n                               const CString& sRemoteIP);\n    /** This function behaves like CModule::OnUserRaw(), but is also called\n     *  before the client successfully logged in to ZNC. You should always\n     *  prefer to use CModule::OnUserRaw() if possible.\n     *  @param pClient The client which send this line.\n     *  @param sLine The raw traffic line which the client sent.\n     */\n    virtual EModRet OnUnknownUserRaw(CClient* pClient, CString& sLine);\n    virtual EModRet OnUnknownUserRawMessage(CMessage& Message);\n\n    /** Called when a client told us CAP LS. Use ssCaps.insert(\"cap-name\")\n     *  for announcing capabilities which your module supports.\n     *  @param pClient The client which requested the list.\n     *  @param ssCaps set of caps which will be sent to client.\n     */\n    virtual void OnClientCapLs(CClient* pClient, SCString& ssCaps);\n    /** Called only to check if your module supports turning on/off named capability.\n     *  @param pClient The client which wants to enable/disable a capability.\n     *  @param sCap name of capability.\n     *  @param bState On or off, depending on which case is interesting for client.\n     *  @return true if your module supports this capability in the specified state.\n     */\n    virtual bool IsClientCapSupported(CClient* pClient, const CString& sCap,\n                                      bool bState);\n    /** Called when we actually need to turn a capability on or off for a client.\n     *  If implementing a custom capability, make sure to call\n     *  pClient->SetTagSupport(\"tag-name\", bState) for each tag that the\n     *  capability provides.\n     *  @param pClient The client which requested the capability.\n     *  @param sCap name of wanted capability.\n     *  @param bState On or off, depending on which case client needs.\n     *  @see CClient::SetTagSupport()\n     */\n    virtual void OnClientCapRequest(CClient* pClient, const CString& sCap,\n                                    bool bState);\n\n    /** Called when a module is going to be loaded.\n     *  @param sModName name of the module.\n     *  @param eType wanted type of the module (user/global).\n     *  @param sArgs arguments of the module.\n     *  @param[out] bSuccess the module was loaded successfully\n     *                       as result of this module hook?\n     *  @param[out] sRetMsg text about loading of the module.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnModuleLoading(const CString& sModName,\n                                    const CString& sArgs,\n                                    CModInfo::EModuleType eType, bool& bSuccess,\n                                    CString& sRetMsg);\n    /** Called when a module is going to be unloaded.\n     *  @param pModule the module.\n     *  @param[out] bSuccess the module was unloaded successfully\n     *                       as result of this module hook?\n     *  @param[out] sRetMsg text about unloading of the module.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnModuleUnloading(CModule* pModule, bool& bSuccess,\n                                      CString& sRetMsg);\n    /** Called when info about a module is needed.\n     *  @param[out] ModInfo put result here, if your module knows it.\n     *  @param sModule name of the module.\n     *  @param bSuccess this module provided info about the module.\n     *  @param sRetMsg text describing possible issues.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnGetModInfo(CModInfo& ModInfo, const CString& sModule,\n                                 bool& bSuccess, CString& sRetMsg);\n    /** Called when list of available mods is requested.\n     *  @param ssMods put new modules here.\n     *  @param bGlobal true if global modules are needed.\n     */\n    virtual void OnGetAvailableMods(std::set<CModInfo>& ssMods,\n                                    CModInfo::EModuleType eType);\n    // !Global Modules\n\n#ifndef SWIG\n    // Translation\n    CString t_s(const CString& sEnglish, const CString& sContext = \"\") const;\n    CInlineFormatMessage t_f(const CString& sEnglish,\n                             const CString& sContext = \"\") const;\n    CInlineFormatMessage t_p(const CString& sEnglish, const CString& sEnglishes,\n                             int iNum, const CString& sContext = \"\") const;\n    CDelayedTranslation t_d(const CString& sEnglish,\n                            const CString& sContext = \"\") const;\n#endif\n\n  protected:\n    CModInfo::EModuleType m_eType;\n    CString m_sDescription;\n    std::set<CTimer*> m_sTimers;\n    std::set<CSocket*> m_sSockets;\n#ifdef HAVE_PTHREAD\n    std::set<CModuleJob*> m_sJobs;\n#endif\n    ModHandle m_pDLL;\n    CSockManager* m_pManager;\n    CUser* m_pUser;\n    CIRCNetwork* m_pNetwork;\n    CClient* m_pClient;\n    CString m_sModName;\n    CString m_sDataDir;\n    CString m_sSavePath;\n    CString m_sArgs;\n    CString m_sModPath;\n    CTranslationDomainRefHolder m_Translation;\n\n  private:\n    MCString\n        m_mssRegistry;  //!< way to save name/value pairs. Note there is no encryption involved in this\n    VWebSubPages m_vSubPages;\n    std::map<CString, CModCommand> m_mCommands;\n};\n\nclass CModules : public std::vector<CModule*>, private CCoreTranslationMixin {\n  public:\n    CModules();\n    ~CModules();\n\n    CModules(const CModules&) = default;\n    CModules& operator=(const CModules&) = default;\n\n    void SetUser(CUser* pUser) { m_pUser = pUser; }\n    void SetNetwork(CIRCNetwork* pNetwork) { m_pNetwork = pNetwork; }\n    void SetClient(CClient* pClient) { m_pClient = pClient; }\n    CUser* GetUser() const { return m_pUser; }\n    CIRCNetwork* GetNetwork() const { return m_pNetwork; }\n    CClient* GetClient() const { return m_pClient; }\n\n    void UnloadAll();\n\n    bool OnBoot();\n    bool OnPreRehash();\n    bool OnPostRehash();\n    bool OnIRCDisconnected();\n    bool OnIRCConnected();\n    bool OnIRCConnecting(CIRCSock* pIRCSock);\n    bool OnIRCConnectionError(CIRCSock* pIRCSock);\n    bool OnIRCRegistration(CString& sPass, CString& sNick, CString& sIdent,\n                           CString& sRealName);\n    bool OnBroadcast(CString& sMessage);\n\n    bool OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                           CChan& Channel, char cMode, bool bAdded,\n                           bool bNoChange);\n    bool OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                           CChan& Channel, unsigned char uMode, bool bAdded,\n                           bool bNoChange);\n    bool OnChanPermission(const CNick& OpNick, const CNick& Nick,\n                          CChan& Channel, unsigned char uMode, bool bAdded,\n                          bool bNoChange);\n    bool OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n               bool bNoChange);\n    bool OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n              bool bNoChange);\n    bool OnDeop2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                 bool bNoChange);\n    bool OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                bool bNoChange);\n    bool OnVoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                  bool bNoChange);\n    bool OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                 bool bNoChange);\n    bool OnDevoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                    bool bNoChange);\n    bool OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                   bool bNoChange);\n    bool OnRawMode2(const CNick* pOpNick, CChan& Channel, const CString& sModes,\n                    const CString& sArgs);\n    bool OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes,\n                   const CString& sArgs);\n    bool OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                 const CString& sArg, bool bAdded, bool bNoChange);\n    bool OnMode(const CNick& OpNick, CChan& Channel, char uMode,\n                const CString& sArg, bool bAdded, bool bNoChange);\n\n    bool OnRaw(CString& sLine);\n    bool OnRawMessage(CMessage& Message);\n    bool OnNumericMessage(CNumericMessage& Message);\n\n    bool OnStatusCommand(CString& sCommand);\n    bool OnModCommand(const CString& sCommand);\n    bool OnModNotice(const CString& sMessage);\n    bool OnModCTCP(const CString& sMessage);\n\n    bool OnQuit(const CNick& Nick, const CString& sMessage,\n                const std::vector<CChan*>& vChans);\n    bool OnQuitMessage(CQuitMessage& Message,\n                       const std::vector<CChan*>& vChans);\n    bool OnNick(const CNick& Nick, const CString& sNewNick,\n                const std::vector<CChan*>& vChans);\n    bool OnNickMessage(CNickMessage& Message,\n                       const std::vector<CChan*>& vChans);\n    bool OnKick(const CNick& Nick, const CString& sOpNick, CChan& Channel,\n                const CString& sMessage);\n    bool OnKickMessage(CKickMessage& Message);\n    bool OnJoining(CChan& Channel);\n    bool OnJoin(const CNick& Nick, CChan& Channel);\n    bool OnJoinMessage(CJoinMessage& Message);\n    bool OnPart(const CNick& Nick, CChan& Channel, const CString& sMessage);\n    bool OnPartMessage(CPartMessage& Message);\n    bool OnInvite(const CNick& Nick, const CString& sChan);\n\n    bool OnChanBufferStarting(CChan& Chan, CClient& Client);\n    bool OnChanBufferEnding(CChan& Chan, CClient& Client);\n    bool OnChanBufferPlayLine2(CChan& Chan, CClient& Client, CString& sLine,\n                               const timeval& tv);\n    bool OnChanBufferPlayLine(CChan& Chan, CClient& Client, CString& sLine);\n    bool OnPrivBufferStarting(CQuery& Query, CClient& Client);\n    bool OnPrivBufferEnding(CQuery& Query, CClient& Client);\n    bool OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                               const timeval& tv);\n    bool OnPrivBufferPlayLine(CClient& Client, CString& sLine);\n    bool OnChanBufferPlayMessage(CMessage& Message);\n    bool OnPrivBufferPlayMessage(CMessage& Message);\n\n    bool OnClientLogin();\n    bool OnClientDisconnect();\n    bool OnUserRaw(CString& sLine);\n    bool OnUserRawMessage(CMessage& Message);\n    bool OnUserCTCPReply(CString& sTarget, CString& sMessage);\n    bool OnUserCTCPReplyMessage(CCTCPMessage& Message);\n    bool OnUserCTCP(CString& sTarget, CString& sMessage);\n    bool OnUserCTCPMessage(CCTCPMessage& Message);\n    bool OnUserAction(CString& sTarget, CString& sMessage);\n    bool OnUserActionMessage(CActionMessage& Message);\n    bool OnUserMsg(CString& sTarget, CString& sMessage);\n    bool OnUserTextMessage(CTextMessage& Message);\n    bool OnUserNotice(CString& sTarget, CString& sMessage);\n    bool OnUserNoticeMessage(CNoticeMessage& Message);\n    bool OnUserJoin(CString& sChannel, CString& sKey);\n    bool OnUserJoinMessage(CJoinMessage& Message);\n    bool OnUserPart(CString& sChannel, CString& sMessage);\n    bool OnUserPartMessage(CPartMessage& Message);\n    bool OnUserTopic(CString& sChannel, CString& sTopic);\n    bool OnUserTopicMessage(CTopicMessage& Message);\n    bool OnUserTopicRequest(CString& sChannel);\n    bool OnUserQuit(CString& sMessage);\n    bool OnUserQuitMessage(CQuitMessage& Message);\n\n    bool OnCTCPReply(CNick& Nick, CString& sMessage);\n    bool OnCTCPReplyMessage(CCTCPMessage& Message);\n    bool OnPrivCTCP(CNick& Nick, CString& sMessage);\n    bool OnPrivCTCPMessage(CCTCPMessage& Message);\n    bool OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanCTCPMessage(CCTCPMessage& Message);\n    bool OnPrivAction(CNick& Nick, CString& sMessage);\n    bool OnPrivActionMessage(CActionMessage& Message);\n    bool OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanActionMessage(CActionMessage& Message);\n    bool OnPrivMsg(CNick& Nick, CString& sMessage);\n    bool OnPrivTextMessage(CTextMessage& Message);\n    bool OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanTextMessage(CTextMessage& Message);\n    bool OnPrivNotice(CNick& Nick, CString& sMessage);\n    bool OnPrivNoticeMessage(CNoticeMessage& Message);\n    bool OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanNoticeMessage(CNoticeMessage& Message);\n    bool OnTopic(CNick& Nick, CChan& Channel, CString& sTopic);\n    bool OnTopicMessage(CTopicMessage& Message);\n    bool OnTimerAutoJoin(CChan& Channel);\n\n    bool OnAddNetwork(CIRCNetwork& Network, CString& sErrorRet);\n    bool OnDeleteNetwork(CIRCNetwork& Network);\n\n    bool OnSendToClient(CString& sLine, CClient& Client);\n    bool OnSendToClientMessage(CMessage& Message);\n    bool OnSendToIRC(CString& sLine);\n    bool OnSendToIRCMessage(CMessage& Message);\n\n    bool OnServerCapAvailable(const CString& sCap);\n    bool OnServerCapResult(const CString& sCap, bool bSuccess);\n\n    CModule* FindModule(const CString& sModule) const;\n    bool LoadModule(const CString& sModule, const CString& sArgs,\n                    CModInfo::EModuleType eType, CUser* pUser,\n                    CIRCNetwork* pNetwork, CString& sRetMsg);\n    bool UnloadModule(const CString& sModule);\n    bool UnloadModule(const CString& sModule, CString& sRetMsg);\n    bool ReloadModule(const CString& sModule, const CString& sArgs,\n                      CUser* pUser, CIRCNetwork* pNetwork, CString& sRetMsg);\n\n    static bool GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                           CString& sRetMsg);\n    static bool GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                               const CString& sModPath, CString& sRetMsg);\n    static void GetAvailableMods(\n        std::set<CModInfo>& ssMods,\n        CModInfo::EModuleType eType = CModInfo::UserModule);\n    static void GetDefaultMods(\n        std::set<CModInfo>& ssMods,\n        CModInfo::EModuleType eType = CModInfo::UserModule);\n\n    // This returns the path to the .so and to the data dir\n    // which is where static data (webadmin skins) are saved\n    static bool FindModPath(const CString& sModule, CString& sModPath,\n                            CString& sDataPath);\n    // Return a list of <module dir, data dir> pairs for directories in\n    // which modules can be found.\n    typedef std::queue<std::pair<CString, CString>> ModDirList;\n    static ModDirList GetModDirs();\n\n    // Global Modules\n    bool OnAddUser(CUser& User, CString& sErrorRet);\n    bool OnDeleteUser(CUser& User);\n    bool OnClientConnect(CZNCSock* pSock, const CString& sHost,\n                         unsigned short uPort);\n    bool OnLoginAttempt(std::shared_ptr<CAuthBase> Auth);\n    bool OnFailedLogin(const CString& sUsername, const CString& sRemoteIP);\n    bool OnUnknownUserRaw(CClient* pClient, CString& sLine);\n    bool OnUnknownUserRawMessage(CMessage& Message);\n    bool OnClientCapLs(CClient* pClient, SCString& ssCaps);\n    bool IsClientCapSupported(CClient* pClient, const CString& sCap,\n                              bool bState);\n    bool OnClientCapRequest(CClient* pClient, const CString& sCap, bool bState);\n    bool OnModuleLoading(const CString& sModName, const CString& sArgs,\n                         CModInfo::EModuleType eType, bool& bSuccess,\n                         CString& sRetMsg);\n    bool OnModuleUnloading(CModule* pModule, bool& bSuccess, CString& sRetMsg);\n    bool OnGetModInfo(CModInfo& ModInfo, const CString& sModule, bool& bSuccess,\n                      CString& sRetMsg);\n    bool OnGetAvailableMods(std::set<CModInfo>& ssMods,\n                            CModInfo::EModuleType eType);\n    // !Global Modules\n\n  private:\n    static ModHandle OpenModule(const CString& sModule, const CString& sModPath,\n                                CModInfo& Info, CString& sRetMsg);\n\n  protected:\n    CUser* m_pUser;\n    CIRCNetwork* m_pNetwork;\n    CClient* m_pClient;\n};\n\n#endif  // !ZNC_MODULES_H\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/Modules.h>\n#include <znc/FileUtils.h>\n#include <znc/Template.h>\n#include <znc/User.h>\n#include <znc/Query.h>\n#include <znc/IRCNetwork.h>\n#include <znc/WebModules.h>\n#include <znc/znc.h>\n#include <dlfcn.h>\n\nusing std::map;\nusing std::set;\nusing std::vector;\n\nbool ZNC_NO_NEED_TO_DO_ANYTHING_ON_MODULE_CALL_EXITER;\n\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#warning \"your crap box doesn't define RTLD_LOCAL !?\"\n#endif\n\n#define MODUNLOADCHK(func)                              \\\n    for (CModule * pMod : *this) {                      \\\n        try {                                           \\\n            CClient* pOldClient = pMod->GetClient();    \\\n            pMod->SetClient(m_pClient);                 \\\n            CUser* pOldUser = nullptr;                  \\\n            if (m_pUser) {                              \\\n                pOldUser = pMod->GetUser();             \\\n                pMod->SetUser(m_pUser);                 \\\n            }                                           \\\n            CIRCNetwork* pNetwork = nullptr;            \\\n            if (m_pNetwork) {                           \\\n                pNetwork = pMod->GetNetwork();          \\\n                pMod->SetNetwork(m_pNetwork);           \\\n            }                                           \\\n            pMod->func;                                 \\\n            if (m_pUser) pMod->SetUser(pOldUser);       \\\n            if (m_pNetwork) pMod->SetNetwork(pNetwork); \\\n            pMod->SetClient(pOldClient);                \\\n        } catch (const CModule::EModException& e) {     \\\n            if (e == CModule::UNLOAD) {                 \\\n                UnloadModule(pMod->GetModName());       \\\n            }                                           \\\n        }                                               \\\n    }\n\n#define MODHALTCHK(func)                                \\\n    bool bHaltCore = false;                             \\\n    for (CModule * pMod : *this) {                      \\\n        try {                                           \\\n            CModule::EModRet e = CModule::CONTINUE;     \\\n            CClient* pOldClient = pMod->GetClient();    \\\n            pMod->SetClient(m_pClient);                 \\\n            CUser* pOldUser = nullptr;                  \\\n            if (m_pUser) {                              \\\n                pOldUser = pMod->GetUser();             \\\n                pMod->SetUser(m_pUser);                 \\\n            }                                           \\\n            CIRCNetwork* pNetwork = nullptr;            \\\n            if (m_pNetwork) {                           \\\n                pNetwork = pMod->GetNetwork();          \\\n                pMod->SetNetwork(m_pNetwork);           \\\n            }                                           \\\n            e = pMod->func;                             \\\n            if (m_pUser) pMod->SetUser(pOldUser);       \\\n            if (m_pNetwork) pMod->SetNetwork(pNetwork); \\\n            pMod->SetClient(pOldClient);                \\\n            if (e == CModule::HALTMODS) {               \\\n                break;                                  \\\n            } else if (e == CModule::HALTCORE) {        \\\n                bHaltCore = true;                       \\\n            } else if (e == CModule::HALT) {            \\\n                bHaltCore = true;                       \\\n                break;                                  \\\n            }                                           \\\n        } catch (const CModule::EModException& e) {     \\\n            if (e == CModule::UNLOAD) {                 \\\n                UnloadModule(pMod->GetModName());       \\\n            }                                           \\\n        }                                               \\\n    }                                                   \\\n    return bHaltCore;\n\n/////////////////// Timer ///////////////////\nCTimer::CTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles,\n               const CString& sLabel, const CString& sDescription)\n    : CCron(), m_pModule(pModule), m_sDescription(sDescription) {\n    SetName(sLabel);\n\n    // Make integration test faster\n    char* szDebugTimer = getenv(\"ZNC_DEBUG_TIMER\");\n    if (szDebugTimer && *szDebugTimer == '1') {\n        uInterval = std::max(1u, uInterval / 4u);\n    }\n\n    if (uCycles) {\n        StartMaxCycles(uInterval, uCycles);\n    } else {\n        Start(uInterval);\n    }\n}\n\nCTimer::~CTimer() { m_pModule->UnlinkTimer(this); }\n\nvoid CTimer::SetModule(CModule* p) { m_pModule = p; }\nvoid CTimer::SetDescription(const CString& s) { m_sDescription = s; }\nCModule* CTimer::GetModule() const { return m_pModule; }\nconst CString& CTimer::GetDescription() const { return m_sDescription; }\n/////////////////// !Timer ///////////////////\n\nCModule::CModule(ModHandle pDLL, CUser* pUser, CIRCNetwork* pNetwork,\n                 const CString& sModName, const CString& sDataDir,\n                 CModInfo::EModuleType eType)\n    : m_eType(eType),\n      m_sDescription(\"\"),\n      m_sTimers(),\n      m_sSockets(),\n#ifdef HAVE_PTHREAD\n      m_sJobs(),\n#endif\n      m_pDLL(pDLL),\n      m_pManager(&(CZNC::Get().GetManager())),\n      m_pUser(pUser),\n      m_pNetwork(pNetwork),\n      m_pClient(nullptr),\n      m_sModName(sModName),\n      m_sDataDir(sDataDir),\n      m_sSavePath(\"\"),\n      m_sArgs(\"\"),\n      m_sModPath(\"\"),\n      m_Translation(\"znc-\" + sModName),\n      m_mssRegistry(),\n      m_vSubPages(),\n      m_mCommands() {\n    if (m_pNetwork) {\n        m_sSavePath = m_pNetwork->GetNetworkPath() + \"/moddata/\" + m_sModName;\n    } else if (m_pUser) {\n        m_sSavePath = m_pUser->GetUserPath() + \"/moddata/\" + m_sModName;\n    } else {\n        m_sSavePath = CZNC::Get().GetZNCPath() + \"/moddata/\" + m_sModName;\n    }\n    LoadRegistry();\n}\n\nCModule::~CModule() {\n    while (!m_sTimers.empty()) {\n        RemTimer(*m_sTimers.begin());\n    }\n\n    while (!m_sSockets.empty()) {\n        RemSocket(*m_sSockets.begin());\n    }\n\n    SaveRegistry();\n\n#ifdef HAVE_PTHREAD\n    CancelJobs(m_sJobs);\n#endif\n}\n\nvoid CModule::SetUser(CUser* pUser) { m_pUser = pUser; }\nvoid CModule::SetNetwork(CIRCNetwork* pNetwork) { m_pNetwork = pNetwork; }\nvoid CModule::SetClient(CClient* pClient) { m_pClient = pClient; }\n\nCString CModule::ExpandString(const CString& sStr) const {\n    CString sRet;\n    return ExpandString(sStr, sRet);\n}\n\nCString& CModule::ExpandString(const CString& sStr, CString& sRet) const {\n    sRet = sStr;\n\n    if (m_pNetwork) {\n        return m_pNetwork->ExpandString(sRet, sRet);\n    }\n\n    if (m_pUser) {\n        return m_pUser->ExpandString(sRet, sRet);\n    }\n\n    return sRet;\n}\n\nconst CString& CModule::GetSavePath() const {\n    if (!CFile::Exists(m_sSavePath)) {\n        CDir::MakeDir(m_sSavePath);\n    }\n    return m_sSavePath;\n}\n\nCString CModule::GetWebPath() {\n    switch (m_eType) {\n        case CModInfo::GlobalModule:\n            return \"/mods/global/\" + GetModName() + \"/\";\n        case CModInfo::UserModule:\n            return \"/mods/user/\" + GetModName() + \"/\";\n        case CModInfo::NetworkModule:\n            return \"/mods/network/\" + m_pNetwork->GetName() + \"/\" +\n                   GetModName() + \"/\";\n        default:\n            return \"/\";\n    }\n}\n\nCString CModule::GetWebFilesPath() {\n    switch (m_eType) {\n        case CModInfo::GlobalModule:\n            return \"/modfiles/global/\" + GetModName() + \"/\";\n        case CModInfo::UserModule:\n            return \"/modfiles/user/\" + GetModName() + \"/\";\n        case CModInfo::NetworkModule:\n            return \"/modfiles/network/\" + m_pNetwork->GetName() + \"/\" +\n                   GetModName() + \"/\";\n        default:\n            return \"/\";\n    }\n}\n\nbool CModule::LoadRegistry() {\n    // CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : \".global\";\n    return (m_mssRegistry.ReadFromDisk(GetSavePath() + \"/.registry\") ==\n            MCString::MCS_SUCCESS);\n}\n\nbool CModule::SaveRegistry() const {\n    // CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : \".global\";\n    return (m_mssRegistry.WriteToDisk(GetSavePath() + \"/.registry\", 0600) ==\n            MCString::MCS_SUCCESS);\n}\n\nbool CModule::MoveRegistry(const CString& sPath) {\n    if (m_sSavePath != sPath) {\n        CFile fOldNVFile = CFile(m_sSavePath + \"/.registry\");\n        if (!fOldNVFile.Exists()) {\n            return false;\n        }\n        if (!CFile::Exists(sPath) && !CDir::MakeDir(sPath)) {\n            return false;\n        }\n        fOldNVFile.Copy(sPath + \"/.registry\");\n        m_sSavePath = sPath;\n        return true;\n    }\n    return false;\n}\n\nbool CModule::SetNV(const CString& sName, const CString& sValue,\n                    bool bWriteToDisk) {\n    m_mssRegistry[sName] = sValue;\n    if (bWriteToDisk) {\n        return SaveRegistry();\n    }\n\n    return true;\n}\n\nCString CModule::GetNV(const CString& sName) const {\n    MCString::const_iterator it = m_mssRegistry.find(sName);\n\n    if (it != m_mssRegistry.end()) {\n        return it->second;\n    }\n\n    return \"\";\n}\n\nbool CModule::DelNV(const CString& sName, bool bWriteToDisk) {\n    MCString::iterator it = m_mssRegistry.find(sName);\n\n    if (it != m_mssRegistry.end()) {\n        m_mssRegistry.erase(it);\n    } else {\n        return false;\n    }\n\n    if (bWriteToDisk) {\n        return SaveRegistry();\n    }\n\n    return true;\n}\n\nbool CModule::ClearNV(bool bWriteToDisk) {\n    m_mssRegistry.clear();\n\n    if (bWriteToDisk) {\n        return SaveRegistry();\n    }\n    return true;\n}\n\nbool CModule::AddTimer(CTimer* pTimer) {\n    if ((!pTimer) ||\n        (!pTimer->GetName().empty() && FindTimer(pTimer->GetName()))) {\n        delete pTimer;\n        return false;\n    }\n\n    if (!m_sTimers.insert(pTimer).second)\n        // Was already added\n        return true;\n\n    m_pManager->AddCron(pTimer);\n    return true;\n}\n\nbool CModule::AddTimer(FPTimer_t pFBCallback, const CString& sLabel,\n                       u_int uInterval, u_int uCycles,\n                       const CString& sDescription) {\n    CFPTimer* pTimer =\n        new CFPTimer(this, uInterval, uCycles, sLabel, sDescription);\n    pTimer->SetFPCallback(pFBCallback);\n\n    return AddTimer(pTimer);\n}\n\nbool CModule::RemTimer(CTimer* pTimer) {\n    if (m_sTimers.erase(pTimer) == 0) return false;\n    m_pManager->DelCronByAddr(pTimer);\n    return true;\n}\n\nbool CModule::RemTimer(const CString& sLabel) {\n    CTimer* pTimer = FindTimer(sLabel);\n    if (!pTimer) return false;\n    return RemTimer(pTimer);\n}\n\nbool CModule::UnlinkTimer(CTimer* pTimer) { return m_sTimers.erase(pTimer); }\n\nCTimer* CModule::FindTimer(const CString& sLabel) {\n    if (sLabel.empty()) {\n        return nullptr;\n    }\n\n    for (CTimer* pTimer : m_sTimers) {\n        if (pTimer->GetName().Equals(sLabel)) {\n            return pTimer;\n        }\n    }\n\n    return nullptr;\n}\n\nvoid CModule::ListTimers() {\n    if (m_sTimers.empty()) {\n        PutModule(\"You have no timers running.\");\n        return;\n    }\n\n    CTable Table;\n    Table.AddColumn(\"Name\");\n    Table.AddColumn(\"Secs\");\n    Table.AddColumn(\"Cycles\");\n    Table.AddColumn(\"Description\");\n\n    for (const CTimer* pTimer : m_sTimers) {\n        unsigned int uCycles = pTimer->GetCyclesLeft();\n        timeval Interval = pTimer->GetInterval();\n\n        Table.AddRow();\n        Table.SetCell(\"Name\", pTimer->GetName());\n        Table.SetCell(\n            \"Secs\", CString(Interval.tv_sec) + \"seconds\" +\n                        (Interval.tv_usec\n                             ? \" \" + CString(Interval.tv_usec) + \" microseconds\"\n                             : \"\"));\n        Table.SetCell(\"Cycles\", ((uCycles) ? CString(uCycles) : \"INF\"));\n        Table.SetCell(\"Description\", pTimer->GetDescription());\n    }\n\n    PutModule(Table);\n}\n\nbool CModule::AddSocket(CSocket* pSocket) {\n    if (!pSocket) {\n        return false;\n    }\n\n    m_sSockets.insert(pSocket);\n    return true;\n}\n\nbool CModule::RemSocket(CSocket* pSocket) {\n    if (m_sSockets.erase(pSocket)) {\n        m_pManager->DelSockByAddr(pSocket);\n        return true;\n    }\n\n    return false;\n}\n\nbool CModule::RemSocket(const CString& sSockName) {\n    for (CSocket* pSocket : m_sSockets) {\n        if (pSocket->GetSockName().Equals(sSockName)) {\n            m_sSockets.erase(pSocket);\n            m_pManager->DelSockByAddr(pSocket);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CModule::UnlinkSocket(CSocket* pSocket) {\n    return m_sSockets.erase(pSocket);\n}\n\nCSocket* CModule::FindSocket(const CString& sSockName) {\n    for (CSocket* pSocket : m_sSockets) {\n        if (pSocket->GetSockName().Equals(sSockName)) {\n            return pSocket;\n        }\n    }\n\n    return nullptr;\n}\n\nvoid CModule::ListSockets() {\n    if (m_sSockets.empty()) {\n        PutModule(\"You have no open sockets.\");\n        return;\n    }\n\n    CTable Table;\n    Table.AddColumn(\"Name\");\n    Table.AddColumn(\"State\");\n    Table.AddColumn(\"LocalPort\");\n    Table.AddColumn(\"SSL\");\n    Table.AddColumn(\"RemoteIP\");\n    Table.AddColumn(\"RemotePort\");\n\n    for (const CSocket* pSocket : m_sSockets) {\n        Table.AddRow();\n        Table.SetCell(\"Name\", pSocket->GetSockName());\n\n        if (pSocket->GetType() == CSocket::LISTENER) {\n            Table.SetCell(\"State\", \"Listening\");\n        } else {\n            Table.SetCell(\"State\", (pSocket->IsConnected() ? \"Connected\" : \"\"));\n        }\n\n        Table.SetCell(\"LocalPort\", CString(pSocket->GetLocalPort()));\n        Table.SetCell(\"SSL\", (pSocket->GetSSL() ? \"yes\" : \"no\"));\n        Table.SetCell(\"RemoteIP\", pSocket->GetRemoteIP());\n        Table.SetCell(\"RemotePort\", (pSocket->GetRemotePort())\n                                        ? CString(pSocket->GetRemotePort())\n                                        : CString(\"\"));\n    }\n\n    PutModule(Table);\n}\n\n#ifdef HAVE_PTHREAD\nCModuleJob::~CModuleJob() { m_pModule->UnlinkJob(this); }\n\nvoid CModule::AddJob(CModuleJob* pJob) {\n    CThreadPool::Get().addJob(pJob);\n    m_sJobs.insert(pJob);\n}\n\nvoid CModule::CancelJob(CModuleJob* pJob) {\n    if (pJob == nullptr) return;\n    // Destructor calls UnlinkJob and removes the job from m_sJobs\n    CThreadPool::Get().cancelJob(pJob);\n}\n\nbool CModule::CancelJob(const CString& sJobName) {\n    for (CModuleJob* pJob : m_sJobs) {\n        if (pJob->GetName().Equals(sJobName)) {\n            CancelJob(pJob);\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid CModule::CancelJobs(const std::set<CModuleJob*>& sJobs) {\n    set<CJob*> sPlainJobs(sJobs.begin(), sJobs.end());\n\n    // Destructor calls UnlinkJob and removes the jobs from m_sJobs\n    CThreadPool::Get().cancelJobs(sPlainJobs);\n}\n\nbool CModule::UnlinkJob(CModuleJob* pJob) { return 0 != m_sJobs.erase(pJob); }\n#endif\n\nbool CModule::AddCommand(const CModCommand& Command) {\n    if (Command.GetFunction() == nullptr) return false;\n    if (Command.GetCommand().Contains(\" \")) return false;\n    if (FindCommand(Command.GetCommand()) != nullptr) return false;\n\n    m_mCommands[Command.GetCommand()] = Command;\n    return true;\n}\n\nbool CModule::AddCommand(const CString& sCmd, CModCommand::ModCmdFunc func,\n                         const CString& sArgs, const CString& sDesc) {\n    CModCommand cmd(sCmd, this, func, sArgs, sDesc);\n    return AddCommand(cmd);\n}\n\nbool CModule::AddCommand(const CString& sCmd, const COptionalTranslation& Args,\n                         const COptionalTranslation& Desc,\n                         std::function<void(const CString& sLine)> func) {\n    CModCommand cmd(sCmd, std::move(func), Args, Desc);\n    return AddCommand(std::move(cmd));\n}\n\nvoid CModule::AddHelpCommand() {\n    AddCommand(\"Help\", t_d(\"<search>\", \"modhelpcmd\"),\n               t_d(\"Generate this output\", \"modhelpcmd\"),\n               [=](const CString& sLine) { HandleHelpCommand(sLine); });\n}\n\nbool CModule::RemCommand(const CString& sCmd) {\n    return m_mCommands.erase(sCmd) > 0;\n}\n\nconst CModCommand* CModule::FindCommand(const CString& sCmd) const {\n    for (const auto& it : m_mCommands) {\n        if (!it.first.Equals(sCmd)) continue;\n        return &it.second;\n    }\n    return nullptr;\n}\n\nbool CModule::HandleCommand(const CString& sLine) {\n    const CString& sCmd = sLine.Token(0);\n    const CModCommand* pCmd = FindCommand(sCmd);\n\n    if (pCmd) {\n        pCmd->Call(sLine);\n        return true;\n    }\n\n    OnUnknownModCommand(sLine);\n\n    return false;\n}\n\nvoid CModule::HandleHelpCommand(const CString& sLine) {\n    CString sFilter = sLine.Token(1).AsLower();\n    CTable Table;\n\n    CModCommand::InitHelp(Table);\n    for (const auto& it : m_mCommands) {\n        CString sCmd = it.second.GetCommand().AsLower();\n        if (sFilter.empty() ||\n            (sCmd.StartsWith(sFilter, CString::CaseSensitive)) ||\n            sCmd.WildCmp(sFilter)) {\n            it.second.AddHelp(Table);\n        }\n    }\n    if (Table.empty()) {\n        PutModule(t_f(\"No matches for '{1}'\")(sFilter));\n    } else {\n        PutModule(Table);\n    }\n}\n\nCString CModule::GetModNick() const {\n    return ((m_pUser) ? m_pUser->GetStatusPrefix() : \"*\") + m_sModName;\n}\n\n// Webmods\nbool CModule::OnWebPreRequest(CWebSock& WebSock, const CString& sPageName) {\n    return false;\n}\nbool CModule::OnWebRequest(CWebSock& WebSock, const CString& sPageName,\n                           CTemplate& Tmpl) {\n    return false;\n}\nbool CModule::ValidateWebRequestCSRFCheck(CWebSock& WebSock,\n    const CString& sPageName) {\n    return WebSock.ValidateCSRFCheck(WebSock.GetURI());\n}\nbool CModule::OnEmbeddedWebRequest(CWebSock& WebSock, const CString& sPageName,\n                                   CTemplate& Tmpl) {\n    return false;\n}\n// !Webmods\n\nbool CModule::OnLoad(const CString& sArgs, CString& sMessage) {\n    sMessage = \"\";\n    return true;\n}\nbool CModule::OnBoot() { return true; }\nvoid CModule::OnPreRehash() {}\nvoid CModule::OnPostRehash() {}\nvoid CModule::OnIRCDisconnected() {}\nvoid CModule::OnIRCConnected() {}\nCModule::EModRet CModule::OnIRCConnecting(CIRCSock* IRCSock) {\n    return CONTINUE;\n}\nvoid CModule::OnIRCConnectionError(CIRCSock* IRCSock) {}\nCModule::EModRet CModule::OnIRCRegistration(CString& sPass, CString& sNick,\n                                            CString& sIdent,\n                                            CString& sRealName) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnBroadcast(CString& sMessage) { return CONTINUE; }\n\nvoid CModule::OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                                CChan& Channel, char cMode,\n                                bool bAdded, bool bNoChange) {\n    OnChanPermission2(pOpNick, Nick, Channel, cMode, bAdded, bNoChange);\n}\nvoid CModule::OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                                CChan& Channel, unsigned char uMode,\n                                bool bAdded, bool bNoChange) {\n    if (pOpNick)\n        OnChanPermission(*pOpNick, Nick, Channel, uMode, bAdded, bNoChange);\n}\nvoid CModule::OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                    bool bNoChange) {\n    if (pOpNick) OnOp(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnDeop2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange) {\n    if (pOpNick) OnDeop(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnVoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange) {\n    if (pOpNick) OnVoice(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnDevoice2(const CNick* pOpNick, const CNick& Nick,\n                         CChan& Channel, bool bNoChange) {\n    if (pOpNick) OnDevoice(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnRawMode2(const CNick* pOpNick, CChan& Channel,\n                         const CString& sModes, const CString& sArgs) {\n    if (pOpNick) OnRawMode(*pOpNick, Channel, sModes, sArgs);\n}\nvoid CModule::OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                      const CString& sArg, bool bAdded, bool bNoChange) {\n    if (pOpNick) OnMode(*pOpNick, Channel, uMode, sArg, bAdded, bNoChange);\n}\n\nvoid CModule::OnChanPermission(const CNick& pOpNick, const CNick& Nick,\n                               CChan& Channel, unsigned char uMode, bool bAdded,\n                               bool bNoChange) {}\nvoid CModule::OnOp(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                   bool bNoChange) {}\nvoid CModule::OnDeop(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                     bool bNoChange) {}\nvoid CModule::OnVoice(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange) {}\nvoid CModule::OnDevoice(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                        bool bNoChange) {}\nvoid CModule::OnRawMode(const CNick& pOpNick, CChan& Channel,\n                        const CString& sModes, const CString& sArgs) {}\nvoid CModule::OnMode(const CNick& pOpNick, CChan& Channel, char uMode,\n                     const CString& sArg, bool bAdded, bool bNoChange) {}\n\nCModule::EModRet CModule::OnRaw(CString& sLine) { return CONTINUE; }\nCModule::EModRet CModule::OnRawMessage(CMessage& Message) { return CONTINUE; }\nCModule::EModRet CModule::OnNumericMessage(CNumericMessage& Message) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnStatusCommand(CString& sCommand) {\n    return CONTINUE;\n}\nvoid CModule::OnModNotice(const CString& sMessage) {}\nvoid CModule::OnModCTCP(const CString& sMessage) {}\n\nvoid CModule::OnModCommand(const CString& sCommand) { HandleCommand(sCommand); }\nvoid CModule::OnUnknownModCommand(const CString& sLine) {\n    if (m_mCommands.empty())\n        // This function is only called if OnModCommand wasn't\n        // overriden, so no false warnings for modules which don't use\n        // CModCommand for command handling.\n        PutModule(t_s(\"This module doesn't implement any commands.\"));\n    else\n        PutModule(t_s(\"Unknown command!\"));\n}\n\nvoid CModule::OnQuit(const CNick& Nick, const CString& sMessage,\n                     const vector<CChan*>& vChans) {}\nvoid CModule::OnQuitMessage(CQuitMessage& Message,\n                            const vector<CChan*>& vChans) {\n    OnQuit(Message.GetNick(), Message.GetReason(), vChans);\n}\nvoid CModule::OnNick(const CNick& Nick, const CString& sNewNick,\n                     const vector<CChan*>& vChans) {}\nvoid CModule::OnNickMessage(CNickMessage& Message,\n                            const vector<CChan*>& vChans) {\n    OnNick(Message.GetNick(), Message.GetNewNick(), vChans);\n}\nvoid CModule::OnKick(const CNick& Nick, const CString& sKickedNick,\n                     CChan& Channel, const CString& sMessage) {}\nvoid CModule::OnKickMessage(CKickMessage& Message) {\n    OnKick(Message.GetNick(), Message.GetKickedNick(), *Message.GetChan(),\n           Message.GetReason());\n}\nCModule::EModRet CModule::OnJoining(CChan& Channel) { return CONTINUE; }\nvoid CModule::OnJoin(const CNick& Nick, CChan& Channel) {}\nvoid CModule::OnJoinMessage(CJoinMessage& Message) {\n    OnJoin(Message.GetNick(), *Message.GetChan());\n}\nvoid CModule::OnPart(const CNick& Nick, CChan& Channel,\n                     const CString& sMessage) {}\nvoid CModule::OnPartMessage(CPartMessage& Message) {\n    OnPart(Message.GetNick(), *Message.GetChan(), Message.GetReason());\n}\nCModule::EModRet CModule::OnInvite(const CNick& Nick, const CString& sChan) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnChanBufferStarting(CChan& Chan, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanBufferEnding(CChan& Chan, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanBufferPlayLine(CChan& Chan, CClient& Client,\n                                               CString& sLine) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivBufferStarting(CQuery& Query, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivBufferEnding(CQuery& Query, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivBufferPlayLine(CClient& Client,\n                                               CString& sLine) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnChanBufferPlayLine2(CChan& Chan, CClient& Client,\n                                                CString& sLine,\n                                                const timeval& tv) {\n    return OnChanBufferPlayLine(Chan, Client, sLine);\n}\nCModule::EModRet CModule::OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                                                const timeval& tv) {\n    return OnPrivBufferPlayLine(Client, sLine);\n}\n\nCModule::EModRet CModule::OnChanBufferPlayMessage(CMessage& Message) {\n    CString sOriginal, sModified;\n    sOriginal = sModified = Message.ToString(CMessage::ExcludeTags);\n    EModRet ret = OnChanBufferPlayLine2(\n        *Message.GetChan(), *Message.GetClient(), sModified, Message.GetTime());\n    if (sOriginal != sModified) {\n        Message.Parse(sModified);\n    }\n    return ret;\n}\nCModule::EModRet CModule::OnPrivBufferPlayMessage(CMessage& Message) {\n    CString sOriginal, sModified;\n    sOriginal = sModified = Message.ToString(CMessage::ExcludeTags);\n    EModRet ret = OnPrivBufferPlayLine2(*Message.GetClient(), sModified,\n                                        Message.GetTime());\n    if (sOriginal != sModified) {\n        Message.Parse(sModified);\n    }\n    return ret;\n}\n\nvoid CModule::OnClientLogin() {}\nvoid CModule::OnClientDisconnect() {}\nCModule::EModRet CModule::OnUserRaw(CString& sLine) { return CONTINUE; }\nCModule::EModRet CModule::OnUserRawMessage(CMessage& Message) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserCTCPReply(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserCTCPReplyMessage(CCTCPMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserCTCPReply(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserCTCP(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserCTCPMessage(CCTCPMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserCTCP(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserAction(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserActionMessage(CActionMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserAction(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserMsg(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserTextMessage(CTextMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserMsg(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserNotice(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserNoticeMessage(CNoticeMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserNotice(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserJoin(CString& sChannel, CString& sKey) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserJoinMessage(CJoinMessage& Message) {\n    CString sChan = Message.GetTarget();\n    CString sKey = Message.GetKey();\n    EModRet ret = OnUserJoin(sChan, sKey);\n    Message.SetTarget(sChan);\n    Message.SetKey(sKey);\n    return ret;\n}\nCModule::EModRet CModule::OnUserPart(CString& sChannel, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserPartMessage(CPartMessage& Message) {\n    CString sChan = Message.GetTarget();\n    CString sReason = Message.GetReason();\n    EModRet ret = OnUserPart(sChan, sReason);\n    Message.SetTarget(sChan);\n    Message.SetReason(sReason);\n    return ret;\n}\nCModule::EModRet CModule::OnUserTopic(CString& sChannel, CString& sTopic) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserTopicMessage(CTopicMessage& Message) {\n    CString sChan = Message.GetTarget();\n    CString sTopic = Message.GetTopic();\n    EModRet ret = OnUserTopic(sChan, sTopic);\n    Message.SetTarget(sChan);\n    Message.SetTopic(sTopic);\n    return ret;\n}\nCModule::EModRet CModule::OnUserTopicRequest(CString& sChannel) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserQuit(CString& sMessage) { return CONTINUE; }\nCModule::EModRet CModule::OnUserQuitMessage(CQuitMessage& Message) {\n    CString sReason = Message.GetReason();\n    EModRet ret = OnUserQuit(sReason);\n    Message.SetReason(sReason);\n    return ret;\n}\n\nCModule::EModRet CModule::OnCTCPReply(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnCTCPReplyMessage(CCTCPMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnCTCPReply(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivCTCP(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivCTCPMessage(CCTCPMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivCTCP(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanCTCP(CNick& Nick, CChan& Channel,\n                                     CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanCTCPMessage(CCTCPMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanCTCP(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivAction(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivActionMessage(CActionMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivAction(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanAction(CNick& Nick, CChan& Channel,\n                                       CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanActionMessage(CActionMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanAction(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivMsg(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivTextMessage(CTextMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivMsg(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanMsg(CNick& Nick, CChan& Channel,\n                                    CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanTextMessage(CTextMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanMsg(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivNotice(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivNoticeMessage(CNoticeMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivNotice(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanNotice(CNick& Nick, CChan& Channel,\n                                       CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanNoticeMessage(CNoticeMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanNotice(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnTopic(CNick& Nick, CChan& Channel,\n                                  CString& sTopic) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnTopicMessage(CTopicMessage& Message) {\n    CString sTopic = Message.GetTopic();\n    EModRet ret = OnTopic(Message.GetNick(), *Message.GetChan(), sTopic);\n    Message.SetTopic(sTopic);\n    return ret;\n}\nCModule::EModRet CModule::OnTimerAutoJoin(CChan& Channel) { return CONTINUE; }\nCModule::EModRet CModule::OnAddNetwork(CIRCNetwork& Network,\n                                       CString& sErrorRet) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnDeleteNetwork(CIRCNetwork& Network) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnSendToClient(CString& sLine, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnSendToClientMessage(CMessage& Message) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnSendToIRC(CString& sLine) { return CONTINUE; }\nCModule::EModRet CModule::OnSendToIRCMessage(CMessage& Message) {\n    return CONTINUE;\n}\n\nbool CModule::OnServerCapAvailable(const CString& sCap) { return false; }\nvoid CModule::OnServerCapResult(const CString& sCap, bool bSuccess) {}\n\nbool CModule::PutIRC(const CString& sLine) {\n    return m_pNetwork ? m_pNetwork->PutIRC(sLine) : false;\n}\nbool CModule::PutIRC(const CMessage& Message) {\n    return m_pNetwork ? m_pNetwork->PutIRC(Message) : false;\n}\nbool CModule::PutUser(const CString& sLine) {\n    return m_pNetwork ? m_pNetwork->PutUser(sLine, m_pClient) : false;\n}\nbool CModule::PutStatus(const CString& sLine) {\n    return m_pNetwork ? m_pNetwork->PutStatus(sLine, m_pClient) : false;\n}\nunsigned int CModule::PutModule(const CTable& table) {\n    if (!m_pUser) return 0;\n\n    unsigned int idx = 0;\n    CString sLine;\n    while (table.GetLine(idx++, sLine)) PutModule(sLine);\n    return idx - 1;\n}\nbool CModule::PutModule(const CString& sLine) {\n    if (m_pClient) {\n        m_pClient->PutModule(GetModName(), sLine);\n        return true;\n    }\n\n    if (m_pNetwork) {\n        return m_pNetwork->PutModule(GetModName(), sLine);\n    }\n\n    if (m_pUser) {\n        return m_pUser->PutModule(GetModName(), sLine);\n    }\n\n    return false;\n}\nbool CModule::PutModNotice(const CString& sLine) {\n    if (!m_pUser) return false;\n\n    if (m_pClient) {\n        m_pClient->PutModNotice(GetModName(), sLine);\n        return true;\n    }\n\n    return m_pUser->PutModNotice(GetModName(), sLine);\n}\n\n///////////////////\n// Global Module //\n///////////////////\nCModule::EModRet CModule::OnAddUser(CUser& User, CString& sErrorRet) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnDeleteUser(CUser& User) { return CONTINUE; }\nvoid CModule::OnClientConnect(CZNCSock* pClient, const CString& sHost,\n                              unsigned short uPort) {}\nCModule::EModRet CModule::OnLoginAttempt(std::shared_ptr<CAuthBase> Auth) {\n    return CONTINUE;\n}\nvoid CModule::OnFailedLogin(const CString& sUsername,\n                            const CString& sRemoteIP) {}\nCModule::EModRet CModule::OnUnknownUserRaw(CClient* pClient, CString& sLine) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUnknownUserRawMessage(CMessage& Message) {\n    return CONTINUE;\n}\nvoid CModule::OnClientCapLs(CClient* pClient, SCString& ssCaps) {}\nbool CModule::IsClientCapSupported(CClient* pClient, const CString& sCap,\n                                   bool bState) {\n    return false;\n}\nvoid CModule::OnClientCapRequest(CClient* pClient, const CString& sCap,\n                                 bool bState) {}\nCModule::EModRet CModule::OnModuleLoading(const CString& sModName,\n                                          const CString& sArgs,\n                                          CModInfo::EModuleType eType,\n                                          bool& bSuccess, CString& sRetMsg) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnModuleUnloading(CModule* pModule, bool& bSuccess,\n                                            CString& sRetMsg) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnGetModInfo(CModInfo& ModInfo,\n                                       const CString& sModule, bool& bSuccess,\n                                       CString& sRetMsg) {\n    return CONTINUE;\n}\nvoid CModule::OnGetAvailableMods(set<CModInfo>& ssMods,\n                                 CModInfo::EModuleType eType) {}\n\nCModules::CModules()\n    : m_pUser(nullptr), m_pNetwork(nullptr), m_pClient(nullptr) {}\n\nCModules::~CModules() { UnloadAll(); }\n\nvoid CModules::UnloadAll() {\n    while (size()) {\n        CString sRetMsg;\n        CString sModName = back()->GetModName();\n        UnloadModule(sModName, sRetMsg);\n    }\n}\n\nbool CModules::OnBoot() {\n    for (CModule* pMod : *this) {\n        try {\n            if (!pMod->OnBoot()) {\n                return true;\n            }\n        } catch (const CModule::EModException& e) {\n            if (e == CModule::UNLOAD) {\n                UnloadModule(pMod->GetModName());\n            }\n        }\n    }\n\n    return false;\n}\n\nbool CModules::OnPreRehash() {\n    MODUNLOADCHK(OnPreRehash());\n    return false;\n}\nbool CModules::OnPostRehash() {\n    MODUNLOADCHK(OnPostRehash());\n    return false;\n}\nbool CModules::OnIRCConnected() {\n    MODUNLOADCHK(OnIRCConnected());\n    return false;\n}\nbool CModules::OnIRCConnecting(CIRCSock* pIRCSock) {\n    MODHALTCHK(OnIRCConnecting(pIRCSock));\n}\nbool CModules::OnIRCConnectionError(CIRCSock* pIRCSock) {\n    MODUNLOADCHK(OnIRCConnectionError(pIRCSock));\n    return false;\n}\nbool CModules::OnIRCRegistration(CString& sPass, CString& sNick,\n                                 CString& sIdent, CString& sRealName) {\n    MODHALTCHK(OnIRCRegistration(sPass, sNick, sIdent, sRealName));\n}\nbool CModules::OnBroadcast(CString& sMessage) {\n    MODHALTCHK(OnBroadcast(sMessage));\n}\nbool CModules::OnIRCDisconnected() {\n    MODUNLOADCHK(OnIRCDisconnected());\n    return false;\n}\n\nbool CModules::OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                                 CChan& Channel, char cMode,\n                                 bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(\n        OnChanPermission3(pOpNick, Nick, Channel, cMode, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                                 CChan& Channel, unsigned char uMode,\n                                 bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(\n        OnChanPermission2(pOpNick, Nick, Channel, uMode, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnChanPermission(const CNick& OpNick, const CNick& Nick,\n                                CChan& Channel, unsigned char uMode,\n                                bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(\n        OnChanPermission(OpNick, Nick, Channel, uMode, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                     bool bNoChange) {\n    MODUNLOADCHK(OnOp2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                    bool bNoChange) {\n    MODUNLOADCHK(OnOp(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDeop2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange) {\n    MODUNLOADCHK(OnDeop2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange) {\n    MODUNLOADCHK(OnDeop(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnVoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                        bool bNoChange) {\n    MODUNLOADCHK(OnVoice2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange) {\n    MODUNLOADCHK(OnVoice(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDevoice2(const CNick* pOpNick, const CNick& Nick,\n                          CChan& Channel, bool bNoChange) {\n    MODUNLOADCHK(OnDevoice2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                         bool bNoChange) {\n    MODUNLOADCHK(OnDevoice(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnRawMode2(const CNick* pOpNick, CChan& Channel,\n                          const CString& sModes, const CString& sArgs) {\n    MODUNLOADCHK(OnRawMode2(pOpNick, Channel, sModes, sArgs));\n    return false;\n}\nbool CModules::OnRawMode(const CNick& OpNick, CChan& Channel,\n                         const CString& sModes, const CString& sArgs) {\n    MODUNLOADCHK(OnRawMode(OpNick, Channel, sModes, sArgs));\n    return false;\n}\nbool CModules::OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                       const CString& sArg, bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(OnMode2(pOpNick, Channel, uMode, sArg, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnMode(const CNick& OpNick, CChan& Channel, char uMode,\n                      const CString& sArg, bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(OnMode(OpNick, Channel, uMode, sArg, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnRaw(CString& sLine) { MODHALTCHK(OnRaw(sLine)); }\nbool CModules::OnRawMessage(CMessage& Message) {\n    MODHALTCHK(OnRawMessage(Message));\n}\nbool CModules::OnNumericMessage(CNumericMessage& Message) {\n    MODHALTCHK(OnNumericMessage(Message));\n}\n\nbool CModules::OnClientLogin() {\n    MODUNLOADCHK(OnClientLogin());\n    return false;\n}\nbool CModules::OnClientDisconnect() {\n    MODUNLOADCHK(OnClientDisconnect());\n    return false;\n}\nbool CModules::OnUserRaw(CString& sLine) { MODHALTCHK(OnUserRaw(sLine)); }\nbool CModules::OnUserRawMessage(CMessage& Message) {\n    MODHALTCHK(OnUserRawMessage(Message));\n}\nbool CModules::OnUserCTCPReply(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserCTCPReply(sTarget, sMessage));\n}\nbool CModules::OnUserCTCPReplyMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnUserCTCPReplyMessage(Message));\n}\nbool CModules::OnUserCTCP(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserCTCP(sTarget, sMessage));\n}\nbool CModules::OnUserCTCPMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnUserCTCPMessage(Message));\n}\nbool CModules::OnUserAction(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserAction(sTarget, sMessage));\n}\nbool CModules::OnUserActionMessage(CActionMessage& Message) {\n    MODHALTCHK(OnUserActionMessage(Message));\n}\nbool CModules::OnUserMsg(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserMsg(sTarget, sMessage));\n}\nbool CModules::OnUserTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnUserTextMessage(Message));\n}\nbool CModules::OnUserNotice(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserNotice(sTarget, sMessage));\n}\nbool CModules::OnUserNoticeMessage(CNoticeMessage& Message) {\n    MODHALTCHK(OnUserNoticeMessage(Message));\n}\nbool CModules::OnUserJoin(CString& sChannel, CString& sKey) {\n    MODHALTCHK(OnUserJoin(sChannel, sKey));\n}\nbool CModules::OnUserJoinMessage(CJoinMessage& Message) {\n    MODHALTCHK(OnUserJoinMessage(Message));\n}\nbool CModules::OnUserPart(CString& sChannel, CString& sMessage) {\n    MODHALTCHK(OnUserPart(sChannel, sMessage));\n}\nbool CModules::OnUserPartMessage(CPartMessage& Message) {\n    MODHALTCHK(OnUserPartMessage(Message));\n}\nbool CModules::OnUserTopic(CString& sChannel, CString& sTopic) {\n    MODHALTCHK(OnUserTopic(sChannel, sTopic));\n}\nbool CModules::OnUserTopicMessage(CTopicMessage& Message) {\n    MODHALTCHK(OnUserTopicMessage(Message));\n}\nbool CModules::OnUserTopicRequest(CString& sChannel) {\n    MODHALTCHK(OnUserTopicRequest(sChannel));\n}\nbool CModules::OnUserQuit(CString& sMessage) {\n    MODHALTCHK(OnUserQuit(sMessage));\n}\nbool CModules::OnUserQuitMessage(CQuitMessage& Message) {\n    MODHALTCHK(OnUserQuitMessage(Message));\n}\n\nbool CModules::OnQuit(const CNick& Nick, const CString& sMessage,\n                      const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnQuit(Nick, sMessage, vChans));\n    return false;\n}\nbool CModules::OnQuitMessage(CQuitMessage& Message,\n                             const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnQuitMessage(Message, vChans));\n    return false;\n}\nbool CModules::OnNick(const CNick& Nick, const CString& sNewNick,\n                      const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnNick(Nick, sNewNick, vChans));\n    return false;\n}\nbool CModules::OnNickMessage(CNickMessage& Message,\n                             const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnNickMessage(Message, vChans));\n    return false;\n}\nbool CModules::OnKick(const CNick& Nick, const CString& sKickedNick,\n                      CChan& Channel, const CString& sMessage) {\n    MODUNLOADCHK(OnKick(Nick, sKickedNick, Channel, sMessage));\n    return false;\n}\nbool CModules::OnKickMessage(CKickMessage& Message) {\n    MODUNLOADCHK(OnKickMessage(Message));\n    return false;\n}\nbool CModules::OnJoining(CChan& Channel) { MODHALTCHK(OnJoining(Channel)); }\nbool CModules::OnJoin(const CNick& Nick, CChan& Channel) {\n    MODUNLOADCHK(OnJoin(Nick, Channel));\n    return false;\n}\nbool CModules::OnJoinMessage(CJoinMessage& Message) {\n    MODUNLOADCHK(OnJoinMessage(Message));\n    return false;\n}\nbool CModules::OnPart(const CNick& Nick, CChan& Channel,\n                      const CString& sMessage) {\n    MODUNLOADCHK(OnPart(Nick, Channel, sMessage));\n    return false;\n}\nbool CModules::OnPartMessage(CPartMessage& Message) {\n    MODUNLOADCHK(OnPartMessage(Message));\n    return false;\n}\nbool CModules::OnInvite(const CNick& Nick, const CString& sChan) {\n    MODHALTCHK(OnInvite(Nick, sChan));\n}\nbool CModules::OnChanBufferStarting(CChan& Chan, CClient& Client) {\n    MODHALTCHK(OnChanBufferStarting(Chan, Client));\n}\nbool CModules::OnChanBufferEnding(CChan& Chan, CClient& Client) {\n    MODHALTCHK(OnChanBufferEnding(Chan, Client));\n}\nbool CModules::OnChanBufferPlayLine2(CChan& Chan, CClient& Client,\n                                     CString& sLine, const timeval& tv) {\n    MODHALTCHK(OnChanBufferPlayLine2(Chan, Client, sLine, tv));\n}\nbool CModules::OnChanBufferPlayLine(CChan& Chan, CClient& Client,\n                                    CString& sLine) {\n    MODHALTCHK(OnChanBufferPlayLine(Chan, Client, sLine));\n}\nbool CModules::OnPrivBufferStarting(CQuery& Query, CClient& Client) {\n    MODHALTCHK(OnPrivBufferStarting(Query, Client));\n}\nbool CModules::OnPrivBufferEnding(CQuery& Query, CClient& Client) {\n    MODHALTCHK(OnPrivBufferEnding(Query, Client));\n}\nbool CModules::OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                                     const timeval& tv) {\n    MODHALTCHK(OnPrivBufferPlayLine2(Client, sLine, tv));\n}\nbool CModules::OnPrivBufferPlayLine(CClient& Client, CString& sLine) {\n    MODHALTCHK(OnPrivBufferPlayLine(Client, sLine));\n}\nbool CModules::OnChanBufferPlayMessage(CMessage& Message) {\n    MODHALTCHK(OnChanBufferPlayMessage(Message));\n}\nbool CModules::OnPrivBufferPlayMessage(CMessage& Message) {\n    MODHALTCHK(OnPrivBufferPlayMessage(Message));\n}\nbool CModules::OnCTCPReply(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnCTCPReply(Nick, sMessage));\n}\nbool CModules::OnCTCPReplyMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnCTCPReplyMessage(Message));\n}\nbool CModules::OnPrivCTCP(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivCTCP(Nick, sMessage));\n}\nbool CModules::OnPrivCTCPMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnPrivCTCPMessage(Message));\n}\nbool CModules::OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanCTCP(Nick, Channel, sMessage));\n}\nbool CModules::OnChanCTCPMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnChanCTCPMessage(Message));\n}\nbool CModules::OnPrivAction(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivAction(Nick, sMessage));\n}\nbool CModules::OnPrivActionMessage(CActionMessage& Message) {\n    MODHALTCHK(OnPrivActionMessage(Message));\n}\nbool CModules::OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanAction(Nick, Channel, sMessage));\n}\nbool CModules::OnChanActionMessage(CActionMessage& Message) {\n    MODHALTCHK(OnChanActionMessage(Message));\n}\nbool CModules::OnPrivMsg(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivMsg(Nick, sMessage));\n}\nbool CModules::OnPrivTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnPrivTextMessage(Message));\n}\nbool CModules::OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanMsg(Nick, Channel, sMessage));\n}\nbool CModules::OnChanTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnChanTextMessage(Message));\n}\nbool CModules::OnPrivNotice(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivNotice(Nick, sMessage));\n}\nbool CModules::OnPrivNoticeMessage(CNoticeMessage& Message) {\n    MODHALTCHK(OnPrivNoticeMessage(Message));\n}\nbool CModules::OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanNotice(Nick, Channel, sMessage));\n}\nbool CModules::OnChanNoticeMessage(CNoticeMessage& Message) {\n    MODHALTCHK(OnChanNoticeMessage(Message));\n}\nbool CModules::OnTopic(CNick& Nick, CChan& Channel, CString& sTopic) {\n    MODHALTCHK(OnTopic(Nick, Channel, sTopic));\n}\nbool CModules::OnTopicMessage(CTopicMessage& Message) {\n    MODHALTCHK(OnTopicMessage(Message));\n}\nbool CModules::OnTimerAutoJoin(CChan& Channel) {\n    MODHALTCHK(OnTimerAutoJoin(Channel));\n}\nbool CModules::OnAddNetwork(CIRCNetwork& Network, CString& sErrorRet) {\n    MODHALTCHK(OnAddNetwork(Network, sErrorRet));\n}\nbool CModules::OnDeleteNetwork(CIRCNetwork& Network) {\n    MODHALTCHK(OnDeleteNetwork(Network));\n}\nbool CModules::OnSendToClient(CString& sLine, CClient& Client) {\n    MODHALTCHK(OnSendToClient(sLine, Client));\n}\nbool CModules::OnSendToClientMessage(CMessage& Message) {\n    MODHALTCHK(OnSendToClientMessage(Message));\n}\nbool CModules::OnSendToIRC(CString& sLine) { MODHALTCHK(OnSendToIRC(sLine)); }\nbool CModules::OnSendToIRCMessage(CMessage& Message) {\n    MODHALTCHK(OnSendToIRCMessage(Message));\n}\nbool CModules::OnStatusCommand(CString& sCommand) {\n    MODHALTCHK(OnStatusCommand(sCommand));\n}\nbool CModules::OnModCommand(const CString& sCommand) {\n    MODUNLOADCHK(OnModCommand(sCommand));\n    return false;\n}\nbool CModules::OnModNotice(const CString& sMessage) {\n    MODUNLOADCHK(OnModNotice(sMessage));\n    return false;\n}\nbool CModules::OnModCTCP(const CString& sMessage) {\n    MODUNLOADCHK(OnModCTCP(sMessage));\n    return false;\n}\n\n// Why MODHALTCHK works only with functions returning EModRet ? :(\nbool CModules::OnServerCapAvailable(const CString& sCap) {\n    bool bResult = false;\n    for (CModule* pMod : *this) {\n        try {\n            CClient* pOldClient = pMod->GetClient();\n            pMod->SetClient(m_pClient);\n            if (m_pUser) {\n                CUser* pOldUser = pMod->GetUser();\n                pMod->SetUser(m_pUser);\n                bResult |= pMod->OnServerCapAvailable(sCap);\n                pMod->SetUser(pOldUser);\n            } else {\n                // WTF? Is that possible?\n                bResult |= pMod->OnServerCapAvailable(sCap);\n            }\n            pMod->SetClient(pOldClient);\n        } catch (const CModule::EModException& e) {\n            if (CModule::UNLOAD == e) {\n                UnloadModule(pMod->GetModName());\n            }\n        }\n    }\n    return bResult;\n}\n\nbool CModules::OnServerCapResult(const CString& sCap, bool bSuccess) {\n    MODUNLOADCHK(OnServerCapResult(sCap, bSuccess));\n    return false;\n}\n\n////////////////////\n// Global Modules //\n////////////////////\nbool CModules::OnAddUser(CUser& User, CString& sErrorRet) {\n    MODHALTCHK(OnAddUser(User, sErrorRet));\n}\n\nbool CModules::OnDeleteUser(CUser& User) { MODHALTCHK(OnDeleteUser(User)); }\n\nbool CModules::OnClientConnect(CZNCSock* pClient, const CString& sHost,\n                               unsigned short uPort) {\n    MODUNLOADCHK(OnClientConnect(pClient, sHost, uPort));\n    return false;\n}\n\nbool CModules::OnLoginAttempt(std::shared_ptr<CAuthBase> Auth) {\n    MODHALTCHK(OnLoginAttempt(Auth));\n}\n\nbool CModules::OnFailedLogin(const CString& sUsername,\n                             const CString& sRemoteIP) {\n    MODUNLOADCHK(OnFailedLogin(sUsername, sRemoteIP));\n    return false;\n}\n\nbool CModules::OnUnknownUserRaw(CClient* pClient, CString& sLine) {\n    MODHALTCHK(OnUnknownUserRaw(pClient, sLine));\n}\n\nbool CModules::OnUnknownUserRawMessage(CMessage& Message) {\n    MODHALTCHK(OnUnknownUserRawMessage(Message));\n}\n\nbool CModules::OnClientCapLs(CClient* pClient, SCString& ssCaps) {\n    MODUNLOADCHK(OnClientCapLs(pClient, ssCaps));\n    return false;\n}\n\n// Maybe create new macro for this?\nbool CModules::IsClientCapSupported(CClient* pClient, const CString& sCap,\n                                    bool bState) {\n    bool bResult = false;\n    for (CModule* pMod : *this) {\n        try {\n            CClient* pOldClient = pMod->GetClient();\n            pMod->SetClient(m_pClient);\n            if (m_pUser) {\n                CUser* pOldUser = pMod->GetUser();\n                pMod->SetUser(m_pUser);\n                bResult |= pMod->IsClientCapSupported(pClient, sCap, bState);\n                pMod->SetUser(pOldUser);\n            } else {\n                // WTF? Is that possible?\n                bResult |= pMod->IsClientCapSupported(pClient, sCap, bState);\n            }\n            pMod->SetClient(pOldClient);\n        } catch (const CModule::EModException& e) {\n            if (CModule::UNLOAD == e) {\n                UnloadModule(pMod->GetModName());\n            }\n        }\n    }\n    return bResult;\n}\n\nbool CModules::OnClientCapRequest(CClient* pClient, const CString& sCap,\n                                  bool bState) {\n    MODUNLOADCHK(OnClientCapRequest(pClient, sCap, bState));\n    return false;\n}\n\nbool CModules::OnModuleLoading(const CString& sModName, const CString& sArgs,\n                               CModInfo::EModuleType eType, bool& bSuccess,\n                               CString& sRetMsg) {\n    MODHALTCHK(OnModuleLoading(sModName, sArgs, eType, bSuccess, sRetMsg));\n}\n\nbool CModules::OnModuleUnloading(CModule* pModule, bool& bSuccess,\n                                 CString& sRetMsg) {\n    MODHALTCHK(OnModuleUnloading(pModule, bSuccess, sRetMsg));\n}\n\nbool CModules::OnGetModInfo(CModInfo& ModInfo, const CString& sModule,\n                            bool& bSuccess, CString& sRetMsg) {\n    MODHALTCHK(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg));\n}\n\nbool CModules::OnGetAvailableMods(set<CModInfo>& ssMods,\n                                  CModInfo::EModuleType eType) {\n    MODUNLOADCHK(OnGetAvailableMods(ssMods, eType));\n    return false;\n}\n\nCModule* CModules::FindModule(const CString& sModule) const {\n    for (CModule* pMod : *this) {\n        if (sModule.Equals(pMod->GetModName())) {\n            return pMod;\n        }\n    }\n\n    return nullptr;\n}\n\nbool CModules::LoadModule(const CString& sModule, const CString& sArgs,\n                          CModInfo::EModuleType eType, CUser* pUser,\n                          CIRCNetwork* pNetwork, CString& sRetMsg) {\n    sRetMsg = \"\";\n\n    if (FindModule(sModule) != nullptr) {\n        sRetMsg = t_f(\"Module {1} already loaded.\")(sModule);\n        return false;\n    }\n\n    bool bSuccess;\n    bool bHandled = false;\n    _GLOBALMODULECALL(OnModuleLoading(sModule, sArgs, eType, bSuccess, sRetMsg),\n                      pUser, pNetwork, nullptr, &bHandled);\n    if (bHandled) return bSuccess;\n\n    CString sModPath, sDataPath;\n    CModInfo Info;\n\n    if (!FindModPath(sModule, sModPath, sDataPath)) {\n        sRetMsg = t_f(\"Unable to find module {1}\")(sModule);\n        return false;\n    }\n    Info.SetName(sModule);\n    Info.SetPath(sModPath);\n\n    ModHandle p = OpenModule(sModule, sModPath, Info, sRetMsg);\n\n    if (!p) return false;\n\n    if (!Info.SupportsType(eType)) {\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} does not support module type {2}.\")(\n            sModule, CModInfo::ModuleTypeToString(eType));\n        return false;\n    }\n\n    if (!pUser && eType == CModInfo::UserModule) {\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} requires a user.\")(sModule);\n        return false;\n    }\n\n    if (!pNetwork && eType == CModInfo::NetworkModule) {\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} requires a network.\")(sModule);\n        return false;\n    }\n\n    CModule* pModule =\n        Info.GetLoader()(p, pUser, pNetwork, sModule, sDataPath, eType);\n    pModule->SetDescription(Info.GetDescription());\n    pModule->SetArgs(sArgs);\n    pModule->SetModPath(CDir::ChangeDir(CZNC::Get().GetCurPath(), sModPath));\n    push_back(pModule);\n\n    bool bLoaded;\n    try {\n        bLoaded = pModule->OnLoad(sArgs, sRetMsg);\n    } catch (const CModule::EModException&) {\n        bLoaded = false;\n        sRetMsg = t_s(\"Caught an exception\");\n    }\n\n    if (!bLoaded) {\n        UnloadModule(sModule, sModPath);\n        if (!sRetMsg.empty())\n            sRetMsg = t_f(\"Module {1} aborted: {2}\")(sModule, sRetMsg);\n        else\n            sRetMsg = t_f(\"Module {1} aborted.\")(sModule);\n        return false;\n    }\n\n    if (!sRetMsg.empty()) {\n        sRetMsg += \" \";\n    }\n    sRetMsg += \"[\" + sModPath + \"]\";\n    return true;\n}\n\nbool CModules::UnloadModule(const CString& sModule) {\n    CString s;\n    return UnloadModule(sModule, s);\n}\n\nbool CModules::UnloadModule(const CString& sModule, CString& sRetMsg) {\n    // Make a copy incase the reference passed in is from CModule::GetModName()\n    CString sMod = sModule;\n\n    CModule* pModule = FindModule(sMod);\n    sRetMsg = \"\";\n\n    if (!pModule) {\n        sRetMsg = t_f(\"Module [{1}] not loaded.\")(sMod);\n        return false;\n    }\n\n    bool bSuccess;\n    bool bHandled = false;\n    _GLOBALMODULECALL(OnModuleUnloading(pModule, bSuccess, sRetMsg),\n                      pModule->GetUser(), pModule->GetNetwork(), nullptr,\n                      &bHandled);\n    if (bHandled) return bSuccess;\n\n    ModHandle p = pModule->GetDLL();\n\n    if (p) {\n        delete pModule;\n\n        for (iterator it = begin(); it != end(); ++it) {\n            if (*it == pModule) {\n                erase(it);\n                break;\n            }\n        }\n\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} unloaded.\")(sMod);\n\n        return true;\n    }\n\n    sRetMsg = t_f(\"Unable to unload module {1}.\")(sMod);\n    return false;\n}\n\nbool CModules::ReloadModule(const CString& sModule, const CString& sArgs,\n                            CUser* pUser, CIRCNetwork* pNetwork,\n                            CString& sRetMsg) {\n    // Make a copy incase the reference passed in is from CModule::GetModName()\n    CString sMod = sModule;\n\n    CModule* pModule = FindModule(sMod);\n\n    if (!pModule) {\n        sRetMsg = t_f(\"Module [{1}] not loaded.\")(sMod);\n        return false;\n    }\n\n    CModInfo::EModuleType eType = pModule->GetType();\n    pModule = nullptr;\n\n    sRetMsg = \"\";\n    if (!UnloadModule(sMod, sRetMsg)) {\n        return false;\n    }\n\n    if (!LoadModule(sMod, sArgs, eType, pUser, pNetwork, sRetMsg)) {\n        return false;\n    }\n\n    sRetMsg = t_f(\"Reloaded module {1}.\")(sMod);\n    return true;\n}\n\nbool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    CString sModPath, sTmp;\n\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}\n\nbool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                              const CString& sModPath, CString& sRetMsg) {\n    ModInfo.SetName(sModule);\n    ModInfo.SetPath(sModPath);\n\n    ModHandle p = OpenModule(sModule, sModPath, ModInfo, sRetMsg);\n    if (!p) return false;\n\n    dlclose(p);\n\n    return true;\n}\n\nvoid CModules::GetAvailableMods(set<CModInfo>& ssMods,\n                                CModInfo::EModuleType eType) {\n    ssMods.clear();\n\n    unsigned int a = 0;\n    CDir Dir;\n\n    ModDirList dirs = GetModDirs();\n\n    while (!dirs.empty()) {\n        Dir.FillByWildcard(dirs.front().first, \"*.so\");\n        dirs.pop();\n\n        for (a = 0; a < Dir.size(); a++) {\n            CFile& File = *Dir[a];\n            CString sName = File.GetShortName();\n            CString sPath = File.GetLongName();\n            CModInfo ModInfo;\n            sName.RightChomp(3);\n\n            CString sIgnoreRetMsg;\n            if (GetModPathInfo(ModInfo, sName, sPath, sIgnoreRetMsg)) {\n                if (ModInfo.SupportsType(eType)) {\n                    ssMods.insert(ModInfo);\n                }\n            }\n        }\n    }\n\n    GLOBALMODULECALL(OnGetAvailableMods(ssMods, eType), NOTHING);\n}\n\nvoid CModules::GetDefaultMods(set<CModInfo>& ssMods,\n                              CModInfo::EModuleType eType) {\n    GetAvailableMods(ssMods, eType);\n\n    const map<CString, CModInfo::EModuleType> ns = {\n        {\"chansaver\", CModInfo::UserModule},\n        {\"controlpanel\", CModInfo::UserModule},\n        {\"simple_away\", CModInfo::NetworkModule},\n        {\"webadmin\", CModInfo::GlobalModule}};\n\n    auto it = ssMods.begin();\n    while (it != ssMods.end()) {\n        auto it2 = ns.find(it->GetName());\n        if (it2 != ns.end() && it2->second == eType) {\n            ++it;\n        } else {\n            it = ssMods.erase(it);\n        }\n    }\n}\n\nbool CModules::FindModPath(const CString& sModule, CString& sModPath,\n                           CString& sDataPath) {\n    CString sMod = sModule;\n    CString sDir = sMod;\n    if (!sModule.Contains(\".\")) sMod += \".so\";\n\n    ModDirList dirs = GetModDirs();\n\n    while (!dirs.empty()) {\n        sModPath = dirs.front().first + sMod;\n        sDataPath = dirs.front().second;\n        dirs.pop();\n\n        if (CFile::Exists(sModPath)) {\n            sDataPath += sDir;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nCModules::ModDirList CModules::GetModDirs() {\n    ModDirList ret;\n    CString sDir;\n\n#ifdef RUN_FROM_SOURCE\n    // ./modules\n    sDir = CZNC::Get().GetCurPath() + \"/modules/\";\n    ret.push(std::make_pair(sDir, sDir + \"data/\"));\n#endif\n\n    // ~/.znc/modules\n    sDir = CZNC::Get().GetModPath() + \"/\";\n    ret.push(std::make_pair(sDir, sDir));\n\n    // <moduledir> and <datadir> (<prefix>/lib/znc)\n    ret.push(std::make_pair(_MODDIR_ + CString(\"/\"),\n                            _DATADIR_ + CString(\"/modules/\")));\n\n    return ret;\n}\n\nModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n                               CModInfo& Info, CString& sRetMsg) {\n    // Some sane defaults in case anything errors out below\n    sRetMsg.clear();\n\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return nullptr;\n        }\n    }\n\n    // The second argument to dlopen() has a long history. It seems clear\n    // that (despite what the man page says) we must include either of\n    // RTLD_NOW and RTLD_LAZY and either of RTLD_GLOBAL and RTLD_LOCAL.\n    //\n    // RTLD_NOW vs. RTLD_LAZY: We use RTLD_NOW to avoid ZNC dying due to\n    // failed symbol lookups later on. Doesn't really seem to have much of a\n    // performance impact.\n    //\n    // RTLD_GLOBAL vs. RTLD_LOCAL: If perl is loaded with RTLD_LOCAL and later\n    // on loads own modules (which it apparently does with RTLD_LAZY), we will\n    // die in a name lookup since one of perl's symbols isn't found. That's\n    // worse than any theoretical issue with RTLD_GLOBAL.\n    ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (!p) {\n        // dlerror() returns pointer to static buffer, which may be overwritten\n        // very soon with another dl call also it may just return null.\n        const char* cDlError = dlerror();\n        CString sDlError = cDlError ? cDlError : t_s(\"Unknown error\");\n        sRetMsg = t_f(\"Unable to open module {1}: {2}\")(sModule, sDlError);\n        return nullptr;\n    }\n\n    const CModuleEntry* (*fpZNCModuleEntry)() = nullptr;\n    // man dlsym(3) explains this\n    *reinterpret_cast<void**>(&fpZNCModuleEntry) = dlsym(p, \"ZNCModuleEntry\");\n    if (!fpZNCModuleEntry) {\n        dlclose(p);\n        sRetMsg = t_f(\"Could not find ZNCModuleEntry in module {1}\")(sModule);\n        return nullptr;\n    }\n    const CModuleEntry* pModuleEntry = fpZNCModuleEntry();\n\n    if (std::strcmp(pModuleEntry->pcVersion, VERSION_STR) ||\n        std::strcmp(pModuleEntry->pcVersionExtra, VERSION_EXTRA)) {\n        sRetMsg = t_f(\n            \"Version mismatch for module {1}: core is {2}, module is built for \"\n            \"{3}. Recompile this module.\")(\n            sModule, VERSION_STR VERSION_EXTRA,\n            CString(pModuleEntry->pcVersion) + pModuleEntry->pcVersionExtra);\n        dlclose(p);\n        return nullptr;\n    }\n\n    if (std::strcmp(pModuleEntry->pcCompileOptions,\n                    ZNC_COMPILE_OPTIONS_STRING)) {\n        sRetMsg = t_f(\n            \"Module {1} is built incompatibly: core is '{2}', module is '{3}'. \"\n            \"Recompile this module.\")(sModule, ZNC_COMPILE_OPTIONS_STRING,\n                                      pModuleEntry->pcCompileOptions);\n        dlclose(p);\n        return nullptr;\n    }\n\n    CTranslationDomainRefHolder translation(\"znc-\" + sModule);\n    pModuleEntry->fpFillModInfo(Info);\n\n    sRetMsg = \"\";\n    return p;\n}\n\nCModCommand::CModCommand()\n    : m_sCmd(), m_pFunc(nullptr), m_Args(\"\"), m_Desc(\"\") {}\n\nCModCommand::CModCommand(const CString& sCmd, CModule* pMod, ModCmdFunc func,\n                         const CString& sArgs, const CString& sDesc)\n    : m_sCmd(sCmd),\n      m_pFunc([pMod, func](const CString& sLine) { (pMod->*func)(sLine); }),\n      m_Args(sArgs),\n      m_Desc(sDesc) {}\n\nCModCommand::CModCommand(const CString& sCmd, CmdFunc func,\n                         const COptionalTranslation& Args,\n                         const COptionalTranslation& Desc)\n    : m_sCmd(sCmd), m_pFunc(std::move(func)), m_Args(Args), m_Desc(Desc) {}\n\nvoid CModCommand::InitHelp(CTable& Table) {\n    Table.AddColumn(t_s(\"Command\", \"modhelpcmd\"));\n    Table.AddColumn(t_s(\"Description\", \"modhelpcmd\"));\n}\n\nvoid CModCommand::AddHelp(CTable& Table) const {\n    Table.AddRow();\n    Table.SetCell(t_s(\"Command\", \"modhelpcmd\"), GetCommand() + \" \" + GetArgs());\n    Table.SetCell(t_s(\"Description\", \"modhelpcmd\"), GetDescription());\n}\n\nCString CModule::t_s(const CString& sEnglish, const CString& sContext) const {\n    return CTranslation::Get().Singular(\"znc-\" + GetModName(), sContext,\n                                        sEnglish);\n}\n\nCInlineFormatMessage CModule::t_f(const CString& sEnglish,\n                                  const CString& sContext) const {\n    return CInlineFormatMessage(t_s(sEnglish, sContext));\n}\n\nCInlineFormatMessage CModule::t_p(const CString& sEnglish,\n                                  const CString& sEnglishes, int iNum,\n                                  const CString& sContext) const {\n    return CInlineFormatMessage(CTranslation::Get().Plural(\n        \"znc-\" + GetModName(), sContext, sEnglish, sEnglishes, iNum));\n}\n\nCDelayedTranslation CModule::t_d(const CString& sEnglish,\n                                 const CString& sContext) const {\n    return CDelayedTranslation(\"znc-\" + GetModName(), sContext, sEnglish);\n}\n\nCString CModInfo::t_s(const CString& sEnglish, const CString& sContext) const {\n    return CTranslation::Get().Singular(\"znc-\" + GetName(), sContext, sEnglish);\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef ZNC_MODULES_H\n#define ZNC_MODULES_H\n\n#include <znc/zncconfig.h>\n#include <znc/WebModules.h>\n#include <znc/Utils.h>\n#include <znc/Threads.h>\n#include <znc/Message.h>\n#include <znc/main.h>\n#include <znc/Translation.h>\n#include <functional>\n#include <set>\n#include <queue>\n#include <sys/time.h>\n\n// Forward Declarations\nclass CAuthBase;\nclass CChan;\nclass CQuery;\nclass CIRCNetwork;\nclass CClient;\nclass CWebSock;\nclass CTemplate;\nclass CIRCSock;\nclass CModule;\nclass CModInfo;\n// !Forward Declarations\n\n#ifdef REQUIRESSL\n#ifndef HAVE_LIBSSL\n#error -\n#error -\n#error This module only works when ZNC is compiled with OpenSSL support\n#error -\n#error -\n#endif\n#endif\n\n#ifdef BUILD_WITH_CMAKE\n#include <znc/znc_export_lib_export.h>\n#elif HAVE_VISIBILITY\n#define ZNC_EXPORT_LIB_EXPORT __attribute__((__visibility__(\"default\")))\n#else\n#define ZNC_EXPORT_LIB_EXPORT\n#endif\n\n/** C-style entry point to the module.\n *\n *  First, core compares C strings with version and compilation options of core\n *  and module. If they match, assume that C++ classes have the same layout and\n *  proceed to filling CModInfo.\n *\n *  Most parts of version-extra is explicitly not compared, otherwise all\n *  modules need to be rebuilt for every commit, which is more cumbersome for\n *  ZNC developers. However, the part set by user (e.g. +deb1), is compared.\n *\n *  If this struct ever changes, the first field (pcVersion) must stay the same.\n *  Otherwise, name of ZNCModuleEntry function must also change. Other fields\n *  can change at will.\n *\n *  Modules shouldn't care about this struct, it's all managed by ...MODULEDEFS\n *  macro.\n */\nstruct CModuleEntry {\n    const char* pcVersion;\n    const char* pcVersionExtra;\n    const char* pcCompileOptions;\n    void (*fpFillModInfo)(CModInfo&);\n};\n\n#define MODCOMMONDEFS(CLASS, DESCRIPTION, TYPE)                             \\\n    static void FillModInfo(CModInfo& Info) {                               \\\n        auto t_s = [&](const CString& sEnglish,                             \\\n                       const CString& sContext = \"\") {                      \\\n            return sEnglish.empty() ? \"\" : Info.t_s(sEnglish, sContext);    \\\n        };                                                                  \\\n        t_s(CString()); /* Don't warn about unused t_s */                   \\\n        Info.SetDescription(DESCRIPTION);                                   \\\n        Info.SetDefaultType(TYPE);                                          \\\n        Info.AddType(TYPE);                                                 \\\n        Info.SetLoader(TModLoad<CLASS>);                                    \\\n        TModInfo<CLASS>(Info);                                              \\\n    }                                                                       \\\n    extern \"C\" {                                                            \\\n    /* A global variable leads to ODR violation when several modules are    \\\n     * loaded. But a static variable inside a function works. */            \\\n    ZNC_EXPORT_LIB_EXPORT const CModuleEntry* ZNCModuleEntry();             \\\n    ZNC_EXPORT_LIB_EXPORT const CModuleEntry* ZNCModuleEntry() {            \\\n        static const CModuleEntry ThisModule = {VERSION_STR, VERSION_EXTRA, \\\n                                                ZNC_COMPILE_OPTIONS_STRING, \\\n                                                FillModInfo};               \\\n        return &ThisModule;                                                 \\\n    }                                                                       \\\n    }\n\n/** Instead of writing a constructor, you should call this macro. It accepts all\n *  the necessary arguments and passes them on to CModule's constructor. You\n *  should assume that there are no arguments to the constructor.\n *\n *  Usage:\n *  \\code\n *  class MyModule : public CModule {\n *      MODCONSTRUCTOR(MyModule) {\n *          // Your own constructor's code here\n *      }\n *  }\n *  \\endcode\n *\n *  @param CLASS The name of your module's class.\n */\n#define MODCONSTRUCTOR(CLASS)                                  \\\n    CLASS(ModHandle pDLL, CUser* pUser, CIRCNetwork* pNetwork, \\\n          const CString& sModName, const CString& sModPath,    \\\n          CModInfo::EModuleType eType)                         \\\n        : CModule(pDLL, pUser, pNetwork, sModName, sModPath, eType)\n\n// User Module Macros\n/** This works exactly like MODULEDEFS, but for user modules. */\n#define USERMODULEDEFS(CLASS, DESCRIPTION) \\\n    MODCOMMONDEFS(CLASS, DESCRIPTION, CModInfo::UserModule)\n// !User Module Macros\n\n// Global Module Macros\n/** This works exactly like MODULEDEFS, but for global modules. */\n#define GLOBALMODULEDEFS(CLASS, DESCRIPTION) \\\n    MODCOMMONDEFS(CLASS, DESCRIPTION, CModInfo::GlobalModule)\n// !Global Module Macros\n\n// Network Module Macros\n/** This works exactly like MODULEDEFS, but for network modules. */\n#define NETWORKMODULEDEFS(CLASS, DESCRIPTION) \\\n    MODCOMMONDEFS(CLASS, DESCRIPTION, CModInfo::NetworkModule)\n// !Network Module Macros\n\n/** At the end of your source file, you must call this macro in global context.\n *  It defines some static functions which ZNC needs to load this module.\n *  By default the module will be a network module.\n *  @param CLASS The name of your module's class.\n *  @param DESCRIPTION A short description of your module.\n */\n#define MODULEDEFS(CLASS, DESCRIPTION) NETWORKMODULEDEFS(CLASS, DESCRIPTION)\n\n// Forward Declarations\nclass CZNC;\nclass CUser;\nclass CNick;\nclass CChan;\nclass CModule;\nclass CFPTimer;\nclass CSockManager;\n// !Forward Declarations\n\nclass CTimer : public CCron {\n  public:\n    CTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles,\n           const CString& sLabel, const CString& sDescription);\n\n    virtual ~CTimer();\n\n    CTimer(const CTimer&) = delete;\n    CTimer& operator=(const CTimer&) = delete;\n\n    // Setters\n    void SetModule(CModule* p);\n    void SetDescription(const CString& s);\n    // !Setters\n\n    // Getters\n    CModule* GetModule() const;\n    const CString& GetDescription() const;\n    // !Getters\n  private:\n  protected:\n    CModule* m_pModule;\n    CString m_sDescription;\n};\n\ntypedef void (*FPTimer_t)(CModule*, CFPTimer*);\n\nclass CFPTimer : public CTimer {\n  public:\n    CFPTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles,\n             const CString& sLabel, const CString& sDescription)\n        : CTimer(pModule, uInterval, uCycles, sLabel, sDescription),\n          m_pFBCallback(nullptr) {}\n\n    virtual ~CFPTimer() {}\n\n    void SetFPCallback(FPTimer_t p) { m_pFBCallback = p; }\n\n  protected:\n    void RunJob() override {\n        if (m_pFBCallback) {\n            m_pFBCallback(m_pModule, this);\n        }\n    }\n\n  private:\n    FPTimer_t m_pFBCallback;\n};\n\n#ifdef HAVE_PTHREAD\n/// A CJob version which can be safely used in modules. The job will be\n/// cancelled when the module is unloaded.\nclass CModuleJob : public CJob {\n  public:\n    CModuleJob(CModule* pModule, const CString& sName, const CString& sDesc)\n        : CJob(), m_pModule(pModule), m_sName(sName), m_sDescription(sDesc) {}\n    virtual ~CModuleJob();\n\n    CModuleJob(const CModuleJob&) = delete;\n    CModuleJob& operator=(const CModuleJob&) = delete;\n\n    // Getters\n    CModule* GetModule() const { return m_pModule; }\n    const CString& GetName() const { return m_sName; }\n    const CString& GetDescription() const { return m_sDescription; }\n    // !Getters\n\n  protected:\n    CModule* m_pModule;\n    const CString m_sName;\n    const CString m_sDescription;\n};\n#endif\n\ntypedef void* ModHandle;\n\nclass CModInfo {\n  public:\n    typedef enum { GlobalModule, UserModule, NetworkModule } EModuleType;\n\n    typedef CModule* (*ModLoader)(ModHandle p, CUser* pUser,\n                                  CIRCNetwork* pNetwork,\n                                  const CString& sModName,\n                                  const CString& sModPath, EModuleType eType);\n\n    CModInfo() : CModInfo(\"\", \"\", NetworkModule) {}\n    CModInfo(const CString& sName, const CString& sPath, EModuleType eType)\n        : m_seType(),\n          m_eDefaultType(eType),\n          m_sName(sName),\n          m_sPath(sPath),\n          m_sDescription(\"\"),\n          m_sWikiPage(\"\"),\n          m_sArgsHelpText(\"\"),\n          m_bHasArgs(false),\n          m_fLoader(nullptr) {}\n    ~CModInfo() {}\n\n    bool operator<(const CModInfo& Info) const {\n        return (GetName() < Info.GetName());\n    }\n\n    bool SupportsType(EModuleType eType) const {\n        return m_seType.find(eType) != m_seType.end();\n    }\n\n    void AddType(EModuleType eType) { m_seType.insert(eType); }\n\n    static CString ModuleTypeToString(EModuleType eType) {\n        switch (eType) {\n            case GlobalModule:\n                return \"Global\";\n            case UserModule:\n                return \"User\";\n            case NetworkModule:\n                return \"Network\";\n            default:\n                return \"UNKNOWN\";\n        }\n    }\n\n    // Getters\n    const CString& GetName() const { return m_sName; }\n    const CString& GetPath() const { return m_sPath; }\n    const CString& GetDescription() const { return m_sDescription; }\n    const CString& GetWikiPage() const { return m_sWikiPage; }\n    const CString& GetArgsHelpText() const { return m_sArgsHelpText; }\n    bool GetHasArgs() const { return m_bHasArgs; }\n    ModLoader GetLoader() const { return m_fLoader; }\n    EModuleType GetDefaultType() const { return m_eDefaultType; }\n    // !Getters\n\n    // Setters\n    void SetName(const CString& s) { m_sName = s; }\n    void SetPath(const CString& s) { m_sPath = s; }\n    void SetDescription(const CString& s) { m_sDescription = s; }\n    void SetWikiPage(const CString& s) { m_sWikiPage = s; }\n    void SetArgsHelpText(const CString& s) { m_sArgsHelpText = s; }\n    void SetHasArgs(bool b = false) { m_bHasArgs = b; }\n    void SetLoader(ModLoader fLoader) { m_fLoader = fLoader; }\n    void SetDefaultType(EModuleType eType) { m_eDefaultType = eType; }\n    // !Setters\n\n    CString t_s(const CString& sEnglish, const CString& sContext = \"\") const;\n\n  private:\n  protected:\n    std::set<EModuleType> m_seType;\n    EModuleType m_eDefaultType;\n    CString m_sName;\n    CString m_sPath;\n    CString m_sDescription;\n    CString m_sWikiPage;\n    CString m_sArgsHelpText;\n    bool m_bHasArgs;\n    ModLoader m_fLoader;\n};\n\ntemplate <class M>\nvoid TModInfo(CModInfo& Info) {}\n\ntemplate <class M>\nCModule* TModLoad(ModHandle p, CUser* pUser, CIRCNetwork* pNetwork,\n                  const CString& sModName, const CString& sModPath,\n                  CModInfo::EModuleType eType) {\n    return new M(p, pUser, pNetwork, sModName, sModPath, eType);\n}\n\n/** A helper class for handling commands in modules. */\nclass CModCommand : private CCoreTranslationMixin {\n  public:\n    /// Type for the callback function that handles the actual command.\n    typedef void (CModule::*ModCmdFunc)(const CString& sLine);\n    typedef std::function<void(const CString& sLine)> CmdFunc;\n\n    /// Default constructor, needed so that this can be saved in a std::map.\n    CModCommand();\n\n    /** Construct a new CModCommand.\n     * @param sCmd The name of the command.\n     * @param func The command's callback function.\n     * @param sArgs Help text describing the arguments to this command.\n     * @param sDesc Help text describing what this command does.\n     */\n    CModCommand(const CString& sCmd, CModule* pMod, ModCmdFunc func,\n                const CString& sArgs, const CString& sDesc);\n    CModCommand(const CString& sCmd, CmdFunc func,\n                const COptionalTranslation& Args,\n                const COptionalTranslation& Desc);\n\n    /** Copy constructor, needed so that this can be saved in a std::map.\n     * @param other Object to copy from.\n     */\n    CModCommand(const CModCommand& other) = default;\n\n    /** Assignment operator, needed so that this can be saved in a std::map.\n     * @param other Object to copy from.\n     */\n    CModCommand& operator=(const CModCommand& other) = default;\n\n    /** Initialize a CTable so that it can be used with AddHelp().\n     * @param Table The instance of CTable to initialize.\n     */\n    static void InitHelp(CTable& Table);\n\n    /** Add this command to the CTable instance.\n     * @param Table Instance of CTable to which this should be added.\n     * @warning The Table should be initialized via InitHelp().\n     */\n    void AddHelp(CTable& Table) const;\n\n    const CString& GetCommand() const { return m_sCmd; }\n    CmdFunc GetFunction() const { return m_pFunc; }\n    CString GetArgs() const { return m_Args.Resolve(); }\n    CString GetDescription() const { return m_Desc.Resolve(); }\n\n    void Call(const CString& sLine) const { m_pFunc(sLine); }\n\n  private:\n    CString m_sCmd;\n    CmdFunc m_pFunc;\n    COptionalTranslation m_Args;\n    COptionalTranslation m_Desc;\n};\n\n/** The base class for your own ZNC modules.\n *\n *  If you want to write a module for ZNC, you will have to implement a class\n *  which inherits from this class. You should override some of the \"On*\"\n *  functions in this class. These function will then be called by ZNC when the\n *  associated event happens.\n *\n *  If such a module hook is called with a non-const reference to e.g. a\n *  CString, then it is free to modify that argument to influence ZNC's\n *  behavior.\n *\n *  @see MODCONSTRUCTOR and MODULEDEFS\n */\nclass CModule {\n  public:\n    CModule(\n        ModHandle pDLL, CUser* pUser, CIRCNetwork* pNetwork,\n        const CString& sModName, const CString& sDataDir,\n        CModInfo::EModuleType eType =\n            CModInfo::NetworkModule);  // TODO: remove default value in ZNC 2.x\n    virtual ~CModule();\n\n    CModule(const CModule&) = delete;\n    CModule& operator=(const CModule&) = delete;\n\n    /** This enum is just used for return from module hooks. Based on this\n     *  return, ZNC then decides what to do with the event which caused the\n     *  module hook.\n     */\n    typedef enum {\n        /** ZNC will continue event processing normally. This is what\n         *  you should return normally.\n         */\n        CONTINUE = 1,\n        /** This is the same as both CModule::HALTMODS and\n         * CModule::HALTCORE together.\n         */\n        HALT = 2,\n        /** Stop sending this even to other modules which were not\n         *  called yet. Internally, the event is handled normally.\n         */\n        HALTMODS = 3,\n        /** Continue calling other modules. When done, ignore the event\n         *  in the ZNC core. (For most module hooks this means that a\n         *  given event won't be forwarded to the connected users)\n         */\n        HALTCORE = 4\n    } EModRet;\n\n    typedef enum {\n        /** Your module can throw this enum at any given time. When this\n         * is thrown, the module will be unloaded.\n         */\n        UNLOAD\n    } EModException;\n\n    void SetUser(CUser* pUser);\n    void SetNetwork(CIRCNetwork* pNetwork);\n    void SetClient(CClient* pClient);\n\n    /** This function throws CModule::UNLOAD which causes this module to be unloaded.\n     */\n    void Unload() { throw UNLOAD; }\n\n    /** This module hook is called when a module is loaded\n     *  @param sArgsi The arguments for the modules.\n     *  @param sMessage A message that may be displayed to the user after\n     *                  loading the module. Useful for returning error messages.\n     *  @return true if the module loaded successfully, else false.\n     */\n    virtual bool OnLoad(const CString& sArgsi, CString& sMessage);\n    /** This module hook is called during ZNC startup. Only modules loaded\n     *  from znc.conf get this call.\n     *  @return false to abort ZNC startup.\n     */\n    virtual bool OnBoot();\n\n    /** Modules which can only be used with an active user session have to return true here.\n     *  @return false for modules that can do stuff for non-logged in web users as well.\n     */\n    virtual bool WebRequiresLogin() { return true; }\n    /** Return true if this module should only be usable for admins on the web.\n     *  @return false if normal users can use this module's web pages as well.\n     */\n    virtual bool WebRequiresAdmin() { return false; }\n    /** Return the title of the module's section in the web interface's side bar.\n     *  @return The Title.\n     */\n    virtual CString GetWebMenuTitle() { return \"\"; }\n    virtual CString GetWebPath();\n    virtual CString GetWebFilesPath();\n    /** For WebMods: Called before the list of registered SubPages will be checked.\n     *  Important: If you return true, you need to take care of calling WebSock.Close!\n     *  This allows for stuff like returning non-templated data, long-polling and other fun.\n     *  @param WebSock The active request.\n     *  @param sPageName The name of the page that has been requested.\n     *  @return true if you handled the page request or false if the name is to be checked\n     *          against the list of registered SubPages and their permission settings.\n     */\n    virtual bool OnWebPreRequest(CWebSock& WebSock, const CString& sPageName);\n    /** If OnWebPreRequest returned false, and the RequiresAdmin/IsAdmin check has been passed,\n     *  this method will be called with the page name. It will also be called for pages that\n     *  have NOT been specifically registered with AddSubPage.\n     *  @param WebSock The active request.\n     *  @param sPageName The name of the page that has been requested.\n     *  @param Tmpl The active template. You can add variables, loops and stuff to it.\n     *  @return You MUST return true if you want the template to be evaluated and sent to the browser.\n     *          Return false if you called Redirect() or PrintErrorPage(). If you didn't, a 404 page will be sent.\n     */\n    virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName,\n                              CTemplate& Tmpl);\n    /** If ValidateWebRequestCSRFCheck returned false, a CSRF error will be printed.\n     *  @param WebSock The active request.\n     *  @param sPageName The name of the page that has been requested.\n     *  @return You MUST return true if the CSRF token is valid.\n     */\n    virtual bool ValidateWebRequestCSRFCheck(CWebSock& WebSock, const CString& sPageName);\n    /** Registers a sub page for the sidebar.\n     *  @param spSubPage The SubPage instance.\n     */\n    virtual void AddSubPage(TWebSubPage spSubPage) {\n        m_vSubPages.push_back(spSubPage);\n    }\n    /** Removes all registered (AddSubPage'd) SubPages.\n     */\n    virtual void ClearSubPages() { m_vSubPages.clear(); }\n    /** Returns a list of all registered SubPages. Don't mess with it too much.\n     *  @return The List.\n     */\n    virtual VWebSubPages& GetSubPages() { return m_vSubPages; }\n    /** Using this hook, module can embed web stuff directly to different places.\n     *  This method is called whenever embededded modules I/O happens.\n     *  Name of used .tmpl file (if any) is up to caller.\n     *  @param WebSock Socket for web connection, don't do bad things with it.\n     *  @param sPageName Describes the place where web stuff is embedded to.\n     *  @param Tmpl Template. Depending on context, you can do various stuff with it.\n     *  @return If you don't need to embed web stuff to the specified place, just return false.\n     *          Exact meaning of return value is up to caller, and depends on context.\n     */\n    virtual bool OnEmbeddedWebRequest(CWebSock& WebSock,\n                                      const CString& sPageName,\n                                      CTemplate& Tmpl);\n\n    /** Called just before znc.conf is rehashed */\n    virtual void OnPreRehash();\n    /** This module hook is called after a <em>successful</em> rehash. */\n    virtual void OnPostRehash();\n    /** This module hook is called when a user gets disconnected from IRC. */\n    virtual void OnIRCDisconnected();\n    /** This module hook is called after a successful login to IRC. */\n    virtual void OnIRCConnected();\n    /** This module hook is called just before ZNC tries to establish a\n     *  connection to an IRC server.\n     *  @param pIRCSock The socket that will be used for the connection.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnIRCConnecting(CIRCSock* pIRCSock);\n    /** This module hook is called when a CIRCSock fails to connect or\n     *  a module returned HALTCORE from OnIRCConnecting.\n     *  @param pIRCSock The socket that failed to connect.\n     */\n    virtual void OnIRCConnectionError(CIRCSock* pIRCSock);\n    /** This module hook is called before loging in to the IRC server. The\n     *  low-level connection is established at this point, but SSL\n     *  handshakes didn't necessarily finish yet.\n     *  @param sPass The server password that will be used.\n     *  @param sNick The nick that will be used.\n     *  @param sIdent The protocol identity that will be used. This is not\n     *                the ident string that is transferred via e.g. oidentd!\n     *  @param sRealName The real name that will be used.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnIRCRegistration(CString& sPass, CString& sNick,\n                                      CString& sIdent, CString& sRealName);\n    /** This module hook is called when a message is broadcasted to all users.\n     *  @param sMessage The message that is broadcasted.\n     *  @return see CModule::EModRet\n     */\n    virtual EModRet OnBroadcast(CString& sMessage);\n\n    /** This module hook is called when a user mode on a channel changes.\n     *  @param pOpNick The nick who sent the mode change, or nullptr if set by server.\n     *  @param Nick The nick whose channel mode changes.\n     *  @param Channel The channel on which the user mode is changed.\n     *  @param cMode The mode character that is changed, e.g. '@' for op.\n     *  @param bAdded True if the mode is added, else false.\n     *  @param bNoChange true if this mode change doesn't change anything\n     *                   because the nick already had this permission.\n     *  @see CIRCSock::GetModeType() for converting uMode into a mode (e.g.\n     *       'o' for op).\n     */\n    virtual void OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                                   CChan& Channel, char cMode,\n                                   bool bAdded, bool bNoChange);\n    /// @deprecated. Use OnChanPermission3.\n    virtual void OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                                   CChan& Channel, unsigned char uMode,\n                                   bool bAdded, bool bNoChange);\n    /// @deprecated. Use OnChanPermission3.\n    virtual void OnChanPermission(const CNick& OpNick, const CNick& Nick,\n                                  CChan& Channel, unsigned char uMode,\n                                  bool bAdded, bool bNoChange);\n    /** Called when a nick is opped on a channel */\n    virtual void OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange);\n    virtual void OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange);\n    /** Called when a nick is deopped on a channel */\n    virtual void OnDeop2(const CNick* pOpNick, const CNick& Nick,\n                         CChan& Channel, bool bNoChange);\n    virtual void OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                        bool bNoChange);\n    /** Called when a nick is voiced on a channel */\n    virtual void OnVoice2(const CNick* pOpNick, const CNick& Nick,\n                          CChan& Channel, bool bNoChange);\n    virtual void OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                         bool bNoChange);\n    /** Called when a nick is devoiced on a channel */\n    virtual void OnDevoice2(const CNick* pOpNick, const CNick& Nick,\n                            CChan& Channel, bool bNoChange);\n    virtual void OnDevoice(const CNick& OpNick, const CNick& Nick,\n                           CChan& Channel, bool bNoChange);\n    /** Called on an individual channel mode change.\n     *  @param pOpNick The nick who changes the channel mode, or nullptr if set by server.\n     *  @param Channel The channel whose mode is changed.\n     *  @param uMode The mode character that is changed.\n     *  @param sArg The argument to the mode character, if any.\n     *  @param bAdded True if this mode is added (\"+\"), else false.\n     *  @param bNoChange True if this mode was already effective before.\n     */\n    virtual void OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                         const CString& sArg, bool bAdded, bool bNoChange);\n    virtual void OnMode(const CNick& OpNick, CChan& Channel, char uMode,\n                        const CString& sArg, bool bAdded, bool bNoChange);\n    /** Called on any channel mode change. This is called before the more\n     *  detailed mode hooks like e.g. OnOp() and OnMode().\n     *  @param pOpNick The nick who changes the channel mode, or nullptr if set by server.\n     *  @param Channel The channel whose mode is changed.\n     *  @param sModes The raw mode change, e.g. \"+s-io\".\n     *  @param sArgs All arguments to the mode change from sModes.\n     */\n    virtual void OnRawMode2(const CNick* pOpNick, CChan& Channel,\n                            const CString& sModes, const CString& sArgs);\n    virtual void OnRawMode(const CNick& OpNick, CChan& Channel,\n                           const CString& sModes, const CString& sArgs);\n\n    /** Called on any raw IRC line received from the <em>IRC server</em>.\n     *  @param sLine The line read from the server.\n     *  @note The line does not include message tags. Use OnRawMessage() to access them.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnRaw(CString& sLine);\n    /** Called on any raw message received from the <em>IRC server</em>.\n     *  @since 1.7.0\n     *  @param Message The received message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnRawMessage(CMessage& Message);\n\n    /** Called when a numeric message is received from the <em>IRC server</em>.\n     *  @since 1.7.0\n     *  @param Message The received message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnNumericMessage(CNumericMessage& Message);\n\n    /** Called when a command to *status is sent.\n     *  @param sCommand The command sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnStatusCommand(CString& sCommand);\n    /** Called when a command to your module is sent, e.g. query to *modname.\n     *  @param sCommand The command that was sent.\n     */\n    virtual void OnModCommand(const CString& sCommand);\n    /** This is similar to OnModCommand(), but it is only called if\n     * HandleCommand didn't find any that wants to handle this. This is only\n     * called if HandleCommand() is called, which practically means that\n     * this is only called if you don't overload OnModCommand().\n     *  @param sCommand The command that was sent.\n     */\n    virtual void OnUnknownModCommand(const CString& sCommand);\n    /** Called when a your module nick was sent a notice.\n     *  @param sMessage The message which was sent.\n     */\n    virtual void OnModNotice(const CString& sMessage);\n    /** Called when your module nick was sent a CTCP message. OnModCommand()\n     *  won't be called for this message.\n     *  @param sMessage The message which was sent.\n     */\n    virtual void OnModCTCP(const CString& sMessage);\n\n    /** Called when a nick quit from IRC.\n     *  @since 1.7.0\n     *  @param Message The quit message.\n     *  @param vChans List of channels which you and nick share.\n     */\n    virtual void OnQuitMessage(CQuitMessage& Message,\n                               const std::vector<CChan*>& vChans);\n    /// @deprecated Use OnQuitMessage() instead.\n    virtual void OnQuit(const CNick& Nick, const CString& sMessage,\n                        const std::vector<CChan*>& vChans);\n\n    /** Called when a nickname change occurs.\n     *  @since 1.7.0\n     *  @param Message The nick message.\n     *  @param vChans Channels which we and nick share.\n     */\n    virtual void OnNickMessage(CNickMessage& Message,\n                               const std::vector<CChan*>& vChans);\n    /// @deprecated Use OnNickMessage() instead.\n    virtual void OnNick(const CNick& Nick, const CString& sNewNick,\n                        const std::vector<CChan*>& vChans);\n\n    /** Called when a nick is kicked from a channel.\n     *  @since 1.7.0\n     *  @param Message The kick message.\n     */\n    virtual void OnKickMessage(CKickMessage& Message);\n    /// @deprecated Use OnKickMessage() instead.\n    virtual void OnKick(const CNick& OpNick, const CString& sKickedNick,\n                        CChan& Channel, const CString& sMessage);\n\n    /** This module hook is called just before ZNC tries to join an IRC channel.\n     *  @param Chan The channel which is about to get joined.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnJoining(CChan& Channel);\n\n    /** Called when a nick joins a channel.\n     *  @since 1.7.0\n     *  @param Message The join message.\n     */\n    virtual void OnJoinMessage(CJoinMessage& Message);\n    /// @deprecated Use OnJoinMessage() instead.\n    virtual void OnJoin(const CNick& Nick, CChan& Channel);\n\n    /** Called when a nick parts a channel.\n     *  @since 1.7.0\n     *  @param Message The part message.\n     */\n    virtual void OnPartMessage(CPartMessage& Message);\n    /// @deprecated Use OnPartMessage() instead.\n    virtual void OnPart(const CNick& Nick, CChan& Channel,\n                        const CString& sMessage);\n\n    /** Called when user is invited into a channel\n     *  @param Nick The nick who invited you.\n     *  @param sChan The channel the user got invited into\n     *  @return See CModule::EModRet.\n     *  @todo Add OnInviteMessage() hook\n     */\n    virtual EModRet OnInvite(const CNick& Nick, const CString& sChan);\n\n    /** Called before a channel buffer is played back to a client.\n     *  @param Chan The channel which will be played back.\n     *  @param Client The client the buffer will be played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanBufferStarting(CChan& Chan, CClient& Client);\n    /** Called after a channel buffer was played back to a client.\n     *  @param Chan The channel which was played back.\n     *  @param Client The client the buffer was played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanBufferEnding(CChan& Chan, CClient& Client);\n\n    /** Called for each message during a channel's buffer play back.\n     *  @since 1.7.0\n     *  @param Message The playback message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanBufferPlayMessage(CMessage& Message);\n    /// @deprecated Use OnChanBufferPlayMessage() instead.\n    virtual EModRet OnChanBufferPlayLine2(CChan& Chan, CClient& Client,\n                                          CString& sLine, const timeval& tv);\n    /// @deprecated Use OnChanBufferPlayMessage() instead.\n    virtual EModRet OnChanBufferPlayLine(CChan& Chan, CClient& Client,\n                                         CString& sLine);\n\n    /** Called before a query buffer is played back to a client.\n     *  @since 1.7.0\n     *  @param Query The query which will be played back.\n     *  @param Client The client the buffer will be played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivBufferStarting(CQuery& Query, CClient& Client);\n    /** Called after a query buffer was played back to a client.\n     *  @since 1.7.0\n     *  @param Query The query which was played back.\n     *  @param Client The client the buffer was played back to.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivBufferEnding(CQuery& Query, CClient& Client);\n\n    /** Called for each message during a query's buffer play back.\n     *  @since 1.7.0\n     *  @param Message The playback message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivBufferPlayMessage(CMessage& Message);\n    /// @deprecated Use OnPrivBufferPlayMessage() instead.\n    virtual EModRet OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                                          const timeval& tv);\n    /// @deprecated Use OnPrivBufferPlayMessage() instead.\n    virtual EModRet OnPrivBufferPlayLine(CClient& Client, CString& sLine);\n\n    /** Called when a client successfully logged in to ZNC. */\n    virtual void OnClientLogin();\n    /** Called when a client disconnected from ZNC. */\n    virtual void OnClientDisconnect();\n\n    /** This module hook is called when a client sends a raw traffic line to ZNC.\n     *  @param sLine The raw traffic line sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserRaw(CString& sLine);\n    /** This module hook is called when a client sends any message to ZNC.\n     *  @since 1.7.0\n     *  @param Message The message sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserRawMessage(CMessage& Message);\n\n    /** This module hook is called when a client sends a CTCP reply.\n     *  @since 1.7.0\n     *  @param Message The CTCP reply message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserCTCPReplyMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnUserCTCPReplyMessage() instead.\n    virtual EModRet OnUserCTCPReply(CString& sTarget, CString& sMessage);\n\n    /** This module hook is called when a client sends a CTCP request.\n     *  @since 1.7.0\n     *  @param Message The CTCP request message.\n     *  @return See CModule::EModRet.\n     *  @note This is not called for CTCP ACTION messages, use\n     *        CModule::OnUserActionMessage() instead.\n     */\n    virtual EModRet OnUserCTCPMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnUserCTCPMessage() instead.\n    virtual EModRet OnUserCTCP(CString& sTarget, CString& sMessage);\n\n    /** Called when a client sends a CTCP ACTION request (\"/me\").\n     *  @since 1.7.0\n     *  @param Message The action message.\n     *  @return See CModule::EModRet.\n     *  @note CModule::OnUserCTCPMessage() will not be called for this message.\n     */\n    virtual EModRet OnUserActionMessage(CActionMessage& Message);\n    /// @deprecated Use OnUserActionMessage() instead.\n    virtual EModRet OnUserAction(CString& sTarget, CString& sMessage);\n\n    /** This module hook is called when a user sends a PRIVMSG message.\n     *  @since 1.7.0\n     *  @param Message The message which was sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserTextMessage(CTextMessage& Message);\n    /// @deprecated Use OnUserTextMessage() instead.\n    virtual EModRet OnUserMsg(CString& sTarget, CString& sMessage);\n\n    /** This module hook is called when a user sends a NOTICE message.\n     *  @since 1.7.0\n     *  @param Message The message which was sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserNoticeMessage(CNoticeMessage& Message);\n    /// @deprecated Use OnUserNoticeMessage() instead.\n    virtual EModRet OnUserNotice(CString& sTarget, CString& sMessage);\n\n    /** This hooks is called when a user sends a JOIN message.\n     *  @since 1.7.0\n     *  @param Message The join message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserJoinMessage(CJoinMessage& Message);\n    /// @deprecated Use OnUserJoinMessage() instead.\n    virtual EModRet OnUserJoin(CString& sChannel, CString& sKey);\n\n    /** This hooks is called when a user sends a PART message.\n     *  @since 1.7.0\n     *  @param Message The part message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserPartMessage(CPartMessage& Message);\n    /// @deprecated Use OnUserPartMessage() instead.\n    virtual EModRet OnUserPart(CString& sChannel, CString& sMessage);\n\n    /** This module hook is called when a user wants to change a channel topic.\n     *  @since 1.7.0\n     *  @param Message The topic message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserTopicMessage(CTopicMessage& Message);\n    /// @deprecated Use OnUserTopicMessage() instead.\n    virtual EModRet OnUserTopic(CString& sChannel, CString& sTopic);\n\n    /** This hook is called when a user requests a channel's topic.\n     *  @param sChannel The channel for which the request is.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserTopicRequest(CString& sChannel);\n\n    /** This module hook is called when a client quits ZNC.\n     *  @since 1.7.0\n     *  @param Message The quit message the client sent.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnUserQuitMessage(CQuitMessage& Message);\n    /// @deprecated Use OnUserQuitMessage() instead.\n    virtual EModRet OnUserQuit(CString& sMessage);\n\n    /** Called when we receive a CTCP reply <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The CTCP reply message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnCTCPReplyMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnCTCPReplyMessage() instead.\n    virtual EModRet OnCTCPReply(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a private CTCP request <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The CTCP request message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivCTCPMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnPrivCTCPMessage() instead.\n    virtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel CTCP request <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The CTCP request message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanCTCPMessage(CCTCPMessage& Message);\n    /// @deprecated Use OnChanCTCPMessage() instead.\n    virtual EModRet OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage);\n\n    /** Called when we receive a private CTCP ACTION (\"/me\" in query) <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The action message\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivActionMessage(CActionMessage& Message);\n    /// @deprecated Use OnPrivActionMessage() instead.\n    virtual EModRet OnPrivAction(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel CTCP ACTION (\"/me\" in a channel) <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The action message\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanActionMessage(CActionMessage& Message);\n    /// @deprecated Use OnChanActionMessage() instead.\n    virtual EModRet OnChanAction(CNick& Nick, CChan& Channel,\n                                 CString& sMessage);\n\n    /** Called when we receive a private PRIVMSG message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The private message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivTextMessage(CTextMessage& Message);\n    /// @deprecated Use OnPrivTextMessage() instead.\n    virtual EModRet OnPrivMsg(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel PRIVMSG message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The channel message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanTextMessage(CTextMessage& Message);\n    /// @deprecated Use OnChanTextMessage() instead.\n    virtual EModRet OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage);\n\n    /** Called when we receive a private NOTICE message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The notice message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnPrivNoticeMessage(CNoticeMessage& Message);\n    /// @deprecated Use OnPrivNoticeMessage() instead.\n    virtual EModRet OnPrivNotice(CNick& Nick, CString& sMessage);\n\n    /** Called when we receive a channel NOTICE message <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The notice message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnChanNoticeMessage(CNoticeMessage& Message);\n    /// @deprecated Use OnChanNoticeMessage() instead.\n    virtual EModRet OnChanNotice(CNick& Nick, CChan& Channel,\n                                 CString& sMessage);\n\n    /** Called when we receive a channel topic change <em>from IRC</em>.\n     *  @since 1.7.0\n     *  @param Message The topic message.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnTopicMessage(CTopicMessage& Message);\n    /// @deprecated Use OnTopicMessage() instead.\n    virtual EModRet OnTopic(CNick& Nick, CChan& Channel, CString& sTopic);\n\n    /** Called for every CAP received via CAP LS from server.\n     *  @param sCap capability supported by server.\n     *  @return true if your module supports this CAP and\n     *          needs to turn it on with CAP REQ.\n     */\n    virtual bool OnServerCapAvailable(const CString& sCap);\n    /** Called for every CAP accepted or rejected by server\n     *  (with CAP ACK or CAP NAK after our CAP REQ).\n     *  @param sCap capability accepted/rejected by server.\n     *  @param bSuccess true if capability was accepted, false if rejected.\n     */\n    virtual void OnServerCapResult(const CString& sCap, bool bSuccess);\n\n    /** This module hook is called just before ZNC tries to join a channel\n     *  by itself because it's in the config but wasn't joined yet.\n     *  @param Channel The channel which will be joined.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnTimerAutoJoin(CChan& Channel);\n\n    /** This module hook is called when a network is being added.\n     *  @param Network The new IRC network.\n     *  @param sErrorRet A message that may be displayed to the user if\n     *                  the module stops adding the network.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnAddNetwork(CIRCNetwork& Network, CString& sErrorRet);\n    /** This module hook is called when a network is deleted.\n     *  @param Network The IRC network which is going to be deleted.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnDeleteNetwork(CIRCNetwork& Network);\n\n    /** Called immediately before ZNC sends a raw traffic line to a client.\n     *  @since 1.7.0\n     *  @param Message The message being sent to the client.\n     *  @warning Calling PutUser() from within this hook leads to infinite recursion.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnSendToClientMessage(CMessage& Message);\n    /// @deprecated Use OnSendToClientMessage() instead.\n    virtual EModRet OnSendToClient(CString& sLine, CClient& Client);\n\n    /** Called immediately before ZNC sends a raw traffic line to the IRC server.\n     *  @since 1.7.0\n     *  @param Message The message being sent to the IRC server.\n     *  @warning Calling PutIRC() from within this hook leads to infinite recursion.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnSendToIRCMessage(CMessage& Message);\n    /// @deprecated Use OnSendToIRCMessage() instead.\n    virtual EModRet OnSendToIRC(CString& sLine);\n\n    ModHandle GetDLL() { return m_pDLL; }\n\n    /** This function sends a given IRC line to the IRC server, if we\n     *  are connected to one. Else this line is discarded.\n     *  @param sLine The line which should be sent.\n     *  @return true if the line was queued for sending.\n     */\n    virtual bool PutIRC(const CString& sLine);\n    /** This function sends a given IRC message to the IRC server, if we\n     *  are connected to one. Else this message is discarded.\n     *  @param Message The message which should be sent.\n     *  @return true if the message was queued for sending.\n     */\n    virtual bool PutIRC(const CMessage& Message);\n    /** This function sends a given raw IRC line to a client.\n     *  If we are in a module hook which is called for a specific client,\n     *  only that client will get the line, else all connected clients will\n     *  receive this line.\n     *  @param sLine The line which should be sent.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutUser(const CString& sLine);\n    /** This function generates a query from *status. If we are in a module\n     *  hook for a specific client, only that client gets this message, else\n     *  all connected clients will receive it.\n     *  @param sLine The message which should be sent from *status.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutStatus(const CString& sLine);\n    /** This function sends a query from your module nick. If we are in a\n     *  module hook for a specific client, only that client gets this\n     *  message, else all connected clients will receive it.\n     *  @param sLine The message which should be sent.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutModule(const CString& sLine);\n    /** This function calls CModule::PutModule(const CString&, const\n     *  CString&, const CString&) for each line in the table.\n     *  @param table The table which should be send.\n     *  @return The number of lines sent.\n     */\n    virtual unsigned int PutModule(const CTable& table);\n    /** Send a notice from your module nick. If we are in a module hook for\n     *  a specific client, only that client gets this notice, else all\n     *  clients will receive it.\n     *  @param sLine The line which should be sent.\n     *  @return true if the line was sent to at least one client.\n     */\n    virtual bool PutModNotice(const CString& sLine);\n\n    /** @returns The name of the module. */\n    const CString& GetModName() const { return m_sModName; }\n\n    /** @returns The nick of the module. This is just the module name\n     *           prefixed by the status prefix.\n     */\n    CString GetModNick() const;\n\n    /** Get the module's data dir.\n     *  Modules can be accompanied by static data, e.g. skins for webadmin.\n     *  These function will return the path to that data.\n     */\n    const CString& GetModDataDir() const { return m_sDataDir; }\n\n    // Timer stuff\n    bool AddTimer(CTimer* pTimer);\n    bool AddTimer(FPTimer_t pFBCallback, const CString& sLabel, u_int uInterval,\n                  u_int uCycles = 0, const CString& sDescription = \"\");\n    bool RemTimer(CTimer* pTimer);\n    bool RemTimer(const CString& sLabel);\n    bool UnlinkTimer(CTimer* pTimer);\n    CTimer* FindTimer(const CString& sLabel);\n    std::set<CTimer*>::const_iterator BeginTimers() const {\n        return m_sTimers.begin();\n    }\n    std::set<CTimer*>::const_iterator EndTimers() const {\n        return m_sTimers.end();\n    }\n    virtual void ListTimers();\n    // !Timer stuff\n\n    // Socket stuff\n    bool AddSocket(CSocket* pSocket);\n    bool RemSocket(CSocket* pSocket);\n    bool RemSocket(const CString& sSockName);\n    bool UnlinkSocket(CSocket* pSocket);\n    CSocket* FindSocket(const CString& sSockName);\n    std::set<CSocket*>::const_iterator BeginSockets() const {\n        return m_sSockets.begin();\n    }\n    std::set<CSocket*>::const_iterator EndSockets() const {\n        return m_sSockets.end();\n    }\n    virtual void ListSockets();\n// !Socket stuff\n\n#ifdef HAVE_PTHREAD\n    // Job stuff\n    void AddJob(CModuleJob* pJob);\n    void CancelJob(CModuleJob* pJob);\n    bool CancelJob(const CString& sJobName);\n    void CancelJobs(const std::set<CModuleJob*>& sJobs);\n    bool UnlinkJob(CModuleJob* pJob);\n// !Job stuff\n#endif\n\n    // Command stuff\n    /// Register the \"Help\" command.\n    void AddHelpCommand();\n    /// @return True if the command was successfully added.\n    bool AddCommand(const CModCommand& Command);\n    /// @return True if the command was successfully added.\n    /// @deprecated Use the variant with COptionalTranslation.\n    bool AddCommand(const CString& sCmd, CModCommand::ModCmdFunc func,\n                    const CString& sArgs = \"\", const CString& sDesc = \"\");\n    /// @param dDesc Either a string \"\", or the result of t_d()\n    /// @return True if the command was successfully added.\n    bool AddCommand(const CString& sCmd, const COptionalTranslation& Args,\n                    const COptionalTranslation& Desc,\n                    std::function<void(const CString& sLine)> func);\n    /// @return True if the command was successfully removed.\n    bool RemCommand(const CString& sCmd);\n    /// @return The CModCommand instance or nullptr if none was found.\n    const CModCommand* FindCommand(const CString& sCmd) const;\n    /** This function tries to dispatch the given command via the correct\n     * instance of CModCommand. Before this can be called, commands have to\n     * be added via AddCommand(). If no matching commands are found then\n     * OnUnknownModCommand will be called.\n     * @param sLine The command line to handle.\n     * @return True if something was done, else false.\n     */\n    bool HandleCommand(const CString& sLine);\n    /** Send a description of all registered commands via PutModule().\n     * @param sLine The help command that is being asked for.\n     */\n    void HandleHelpCommand(const CString& sLine = \"\");\n    // !Command stuff\n\n    bool LoadRegistry();\n    bool SaveRegistry() const;\n    bool MoveRegistry(const CString& sPath);\n    bool SetNV(const CString& sName, const CString& sValue,\n               bool bWriteToDisk = true);\n    CString GetNV(const CString& sName) const;\n    bool HasNV(const CString& sName) const {\n        return m_mssRegistry.find(sName) != m_mssRegistry.end();\n    }\n    bool DelNV(const CString& sName, bool bWriteToDisk = true);\n    MCString::iterator FindNV(const CString& sName) {\n        return m_mssRegistry.find(sName);\n    }\n    MCString::iterator EndNV() { return m_mssRegistry.end(); }\n    MCString::iterator BeginNV() { return m_mssRegistry.begin(); }\n    void DelNV(MCString::iterator it) { m_mssRegistry.erase(it); }\n    bool ClearNV(bool bWriteToDisk = true);\n\n    const CString& GetSavePath() const;\n    CString ExpandString(const CString& sStr) const;\n    CString& ExpandString(const CString& sStr, CString& sRet) const;\n\n    // Setters\n    void SetType(CModInfo::EModuleType eType) { m_eType = eType; }\n    void SetDescription(const CString& s) { m_sDescription = s; }\n    void SetModPath(const CString& s) { m_sModPath = s; }\n    void SetArgs(const CString& s) { m_sArgs = s; }\n    // !Setters\n\n    // Getters\n    CModInfo::EModuleType GetType() const { return m_eType; }\n    const CString& GetDescription() const { return m_sDescription; }\n    const CString& GetArgs() const { return m_sArgs; }\n    const CString& GetModPath() const { return m_sModPath; }\n\n    /** @returns For user modules this returns the user for which this\n     *           module was loaded. For global modules this returns nullptr,\n     *           except when we are in a user-specific module hook in which\n     *           case this is the user pointer.\n     */\n    CUser* GetUser() const { return m_pUser; }\n    /** @returns nullptr except when we are in a network-specific module hook in\n     *           which case this is the network for which the hook is called.\n     */\n    CIRCNetwork* GetNetwork() const { return m_pNetwork; }\n    /** @returns nullptr except when we are in a client-specific module hook in\n     *           which case this is the client for which the hook is called.\n     */\n    CClient* GetClient() const { return m_pClient; }\n    CSockManager* GetManager() const { return m_pManager; }\n    // !Getters\n\n    // Global Modules\n    /** This module hook is called when a user is being added.\n     * @param User The user which will be added.\n     * @param sErrorRet A message that may be displayed to the user if\n     *                  the module stops adding the user.\n     * @return See CModule::EModRet.\n     */\n    virtual EModRet OnAddUser(CUser& User, CString& sErrorRet);\n    /** This module hook is called when a user is deleted.\n     *  @param User The user which will be deleted.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnDeleteUser(CUser& User);\n    /** This module hook is called when there is an incoming connection on\n     *  any of ZNC's listening sockets.\n     *  @param pSock The incoming client socket.\n     *  @param sHost The IP the client is connecting from.\n     *  @param uPort The port the client is connecting from.\n     */\n    virtual void OnClientConnect(CZNCSock* pSock, const CString& sHost,\n                                 unsigned short uPort);\n    /** This module hook is called when a client tries to login. If your\n     *  module wants to handle the login attempt, it must return\n     *  CModule::EModRet::HALT;\n     *  @param Auth The necessary authentication info for this login attempt.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnLoginAttempt(std::shared_ptr<CAuthBase> Auth);\n    /** Called after a client login was rejected.\n     *  @param sUsername The username that tried to log in.\n     *  @param sRemoteIP The IP address from which the client tried to login.\n     */\n    virtual void OnFailedLogin(const CString& sUsername,\n                               const CString& sRemoteIP);\n    /** This function behaves like CModule::OnUserRaw(), but is also called\n     *  before the client successfully logged in to ZNC. You should always\n     *  prefer to use CModule::OnUserRaw() if possible.\n     *  @param pClient The client which send this line.\n     *  @param sLine The raw traffic line which the client sent.\n     */\n    virtual EModRet OnUnknownUserRaw(CClient* pClient, CString& sLine);\n    virtual EModRet OnUnknownUserRawMessage(CMessage& Message);\n\n    /** Called when a client told us CAP LS. Use ssCaps.insert(\"cap-name\")\n     *  for announcing capabilities which your module supports.\n     *  @param pClient The client which requested the list.\n     *  @param ssCaps set of caps which will be sent to client.\n     */\n    virtual void OnClientCapLs(CClient* pClient, SCString& ssCaps);\n    /** Called only to check if your module supports turning on/off named capability.\n     *  @param pClient The client which wants to enable/disable a capability.\n     *  @param sCap name of capability.\n     *  @param bState On or off, depending on which case is interesting for client.\n     *  @return true if your module supports this capability in the specified state.\n     */\n    virtual bool IsClientCapSupported(CClient* pClient, const CString& sCap,\n                                      bool bState);\n    /** Called when we actually need to turn a capability on or off for a client.\n     *  If implementing a custom capability, make sure to call\n     *  pClient->SetTagSupport(\"tag-name\", bState) for each tag that the\n     *  capability provides.\n     *  @param pClient The client which requested the capability.\n     *  @param sCap name of wanted capability.\n     *  @param bState On or off, depending on which case client needs.\n     *  @see CClient::SetTagSupport()\n     */\n    virtual void OnClientCapRequest(CClient* pClient, const CString& sCap,\n                                    bool bState);\n\n    /** Called when a module is going to be loaded.\n     *  @param sModName name of the module.\n     *  @param eType wanted type of the module (user/global).\n     *  @param sArgs arguments of the module.\n     *  @param[out] bSuccess the module was loaded successfully\n     *                       as result of this module hook?\n     *  @param[out] sRetMsg text about loading of the module.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnModuleLoading(const CString& sModName,\n                                    const CString& sArgs,\n                                    CModInfo::EModuleType eType, bool& bSuccess,\n                                    CString& sRetMsg);\n    /** Called when a module is going to be unloaded.\n     *  @param pModule the module.\n     *  @param[out] bSuccess the module was unloaded successfully\n     *                       as result of this module hook?\n     *  @param[out] sRetMsg text about unloading of the module.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnModuleUnloading(CModule* pModule, bool& bSuccess,\n                                      CString& sRetMsg);\n    /** Called when info about a module is needed.\n     *  @param[out] ModInfo put result here, if your module knows it.\n     *  @param sModule name of the module.\n     *  @param bSuccess this module provided info about the module.\n     *  @param sRetMsg text describing possible issues.\n     *  @return See CModule::EModRet.\n     */\n    virtual EModRet OnGetModInfo(CModInfo& ModInfo, const CString& sModule,\n                                 bool& bSuccess, CString& sRetMsg);\n    /** Called when list of available mods is requested.\n     *  @param ssMods put new modules here.\n     *  @param bGlobal true if global modules are needed.\n     */\n    virtual void OnGetAvailableMods(std::set<CModInfo>& ssMods,\n                                    CModInfo::EModuleType eType);\n    // !Global Modules\n\n#ifndef SWIG\n    // Translation\n    CString t_s(const CString& sEnglish, const CString& sContext = \"\") const;\n    CInlineFormatMessage t_f(const CString& sEnglish,\n                             const CString& sContext = \"\") const;\n    CInlineFormatMessage t_p(const CString& sEnglish, const CString& sEnglishes,\n                             int iNum, const CString& sContext = \"\") const;\n    CDelayedTranslation t_d(const CString& sEnglish,\n                            const CString& sContext = \"\") const;\n#endif\n\n  protected:\n    CModInfo::EModuleType m_eType;\n    CString m_sDescription;\n    std::set<CTimer*> m_sTimers;\n    std::set<CSocket*> m_sSockets;\n#ifdef HAVE_PTHREAD\n    std::set<CModuleJob*> m_sJobs;\n#endif\n    ModHandle m_pDLL;\n    CSockManager* m_pManager;\n    CUser* m_pUser;\n    CIRCNetwork* m_pNetwork;\n    CClient* m_pClient;\n    CString m_sModName;\n    CString m_sDataDir;\n    CString m_sSavePath;\n    CString m_sArgs;\n    CString m_sModPath;\n    CTranslationDomainRefHolder m_Translation;\n\n  private:\n    MCString\n        m_mssRegistry;  //!< way to save name/value pairs. Note there is no encryption involved in this\n    VWebSubPages m_vSubPages;\n    std::map<CString, CModCommand> m_mCommands;\n};\n\nclass CModules : public std::vector<CModule*>, private CCoreTranslationMixin {\n  public:\n    CModules();\n    ~CModules();\n\n    CModules(const CModules&) = default;\n    CModules& operator=(const CModules&) = default;\n\n    void SetUser(CUser* pUser) { m_pUser = pUser; }\n    void SetNetwork(CIRCNetwork* pNetwork) { m_pNetwork = pNetwork; }\n    void SetClient(CClient* pClient) { m_pClient = pClient; }\n    CUser* GetUser() const { return m_pUser; }\n    CIRCNetwork* GetNetwork() const { return m_pNetwork; }\n    CClient* GetClient() const { return m_pClient; }\n\n    void UnloadAll();\n\n    bool OnBoot();\n    bool OnPreRehash();\n    bool OnPostRehash();\n    bool OnIRCDisconnected();\n    bool OnIRCConnected();\n    bool OnIRCConnecting(CIRCSock* pIRCSock);\n    bool OnIRCConnectionError(CIRCSock* pIRCSock);\n    bool OnIRCRegistration(CString& sPass, CString& sNick, CString& sIdent,\n                           CString& sRealName);\n    bool OnBroadcast(CString& sMessage);\n\n    bool OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                           CChan& Channel, char cMode, bool bAdded,\n                           bool bNoChange);\n    bool OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                           CChan& Channel, unsigned char uMode, bool bAdded,\n                           bool bNoChange);\n    bool OnChanPermission(const CNick& OpNick, const CNick& Nick,\n                          CChan& Channel, unsigned char uMode, bool bAdded,\n                          bool bNoChange);\n    bool OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n               bool bNoChange);\n    bool OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n              bool bNoChange);\n    bool OnDeop2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                 bool bNoChange);\n    bool OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                bool bNoChange);\n    bool OnVoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                  bool bNoChange);\n    bool OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                 bool bNoChange);\n    bool OnDevoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                    bool bNoChange);\n    bool OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                   bool bNoChange);\n    bool OnRawMode2(const CNick* pOpNick, CChan& Channel, const CString& sModes,\n                    const CString& sArgs);\n    bool OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes,\n                   const CString& sArgs);\n    bool OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                 const CString& sArg, bool bAdded, bool bNoChange);\n    bool OnMode(const CNick& OpNick, CChan& Channel, char uMode,\n                const CString& sArg, bool bAdded, bool bNoChange);\n\n    bool OnRaw(CString& sLine);\n    bool OnRawMessage(CMessage& Message);\n    bool OnNumericMessage(CNumericMessage& Message);\n\n    bool OnStatusCommand(CString& sCommand);\n    bool OnModCommand(const CString& sCommand);\n    bool OnModNotice(const CString& sMessage);\n    bool OnModCTCP(const CString& sMessage);\n\n    bool OnQuit(const CNick& Nick, const CString& sMessage,\n                const std::vector<CChan*>& vChans);\n    bool OnQuitMessage(CQuitMessage& Message,\n                       const std::vector<CChan*>& vChans);\n    bool OnNick(const CNick& Nick, const CString& sNewNick,\n                const std::vector<CChan*>& vChans);\n    bool OnNickMessage(CNickMessage& Message,\n                       const std::vector<CChan*>& vChans);\n    bool OnKick(const CNick& Nick, const CString& sOpNick, CChan& Channel,\n                const CString& sMessage);\n    bool OnKickMessage(CKickMessage& Message);\n    bool OnJoining(CChan& Channel);\n    bool OnJoin(const CNick& Nick, CChan& Channel);\n    bool OnJoinMessage(CJoinMessage& Message);\n    bool OnPart(const CNick& Nick, CChan& Channel, const CString& sMessage);\n    bool OnPartMessage(CPartMessage& Message);\n    bool OnInvite(const CNick& Nick, const CString& sChan);\n\n    bool OnChanBufferStarting(CChan& Chan, CClient& Client);\n    bool OnChanBufferEnding(CChan& Chan, CClient& Client);\n    bool OnChanBufferPlayLine2(CChan& Chan, CClient& Client, CString& sLine,\n                               const timeval& tv);\n    bool OnChanBufferPlayLine(CChan& Chan, CClient& Client, CString& sLine);\n    bool OnPrivBufferStarting(CQuery& Query, CClient& Client);\n    bool OnPrivBufferEnding(CQuery& Query, CClient& Client);\n    bool OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                               const timeval& tv);\n    bool OnPrivBufferPlayLine(CClient& Client, CString& sLine);\n    bool OnChanBufferPlayMessage(CMessage& Message);\n    bool OnPrivBufferPlayMessage(CMessage& Message);\n\n    bool OnClientLogin();\n    bool OnClientDisconnect();\n    bool OnUserRaw(CString& sLine);\n    bool OnUserRawMessage(CMessage& Message);\n    bool OnUserCTCPReply(CString& sTarget, CString& sMessage);\n    bool OnUserCTCPReplyMessage(CCTCPMessage& Message);\n    bool OnUserCTCP(CString& sTarget, CString& sMessage);\n    bool OnUserCTCPMessage(CCTCPMessage& Message);\n    bool OnUserAction(CString& sTarget, CString& sMessage);\n    bool OnUserActionMessage(CActionMessage& Message);\n    bool OnUserMsg(CString& sTarget, CString& sMessage);\n    bool OnUserTextMessage(CTextMessage& Message);\n    bool OnUserNotice(CString& sTarget, CString& sMessage);\n    bool OnUserNoticeMessage(CNoticeMessage& Message);\n    bool OnUserJoin(CString& sChannel, CString& sKey);\n    bool OnUserJoinMessage(CJoinMessage& Message);\n    bool OnUserPart(CString& sChannel, CString& sMessage);\n    bool OnUserPartMessage(CPartMessage& Message);\n    bool OnUserTopic(CString& sChannel, CString& sTopic);\n    bool OnUserTopicMessage(CTopicMessage& Message);\n    bool OnUserTopicRequest(CString& sChannel);\n    bool OnUserQuit(CString& sMessage);\n    bool OnUserQuitMessage(CQuitMessage& Message);\n\n    bool OnCTCPReply(CNick& Nick, CString& sMessage);\n    bool OnCTCPReplyMessage(CCTCPMessage& Message);\n    bool OnPrivCTCP(CNick& Nick, CString& sMessage);\n    bool OnPrivCTCPMessage(CCTCPMessage& Message);\n    bool OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanCTCPMessage(CCTCPMessage& Message);\n    bool OnPrivAction(CNick& Nick, CString& sMessage);\n    bool OnPrivActionMessage(CActionMessage& Message);\n    bool OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanActionMessage(CActionMessage& Message);\n    bool OnPrivMsg(CNick& Nick, CString& sMessage);\n    bool OnPrivTextMessage(CTextMessage& Message);\n    bool OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanTextMessage(CTextMessage& Message);\n    bool OnPrivNotice(CNick& Nick, CString& sMessage);\n    bool OnPrivNoticeMessage(CNoticeMessage& Message);\n    bool OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage);\n    bool OnChanNoticeMessage(CNoticeMessage& Message);\n    bool OnTopic(CNick& Nick, CChan& Channel, CString& sTopic);\n    bool OnTopicMessage(CTopicMessage& Message);\n    bool OnTimerAutoJoin(CChan& Channel);\n\n    bool OnAddNetwork(CIRCNetwork& Network, CString& sErrorRet);\n    bool OnDeleteNetwork(CIRCNetwork& Network);\n\n    bool OnSendToClient(CString& sLine, CClient& Client);\n    bool OnSendToClientMessage(CMessage& Message);\n    bool OnSendToIRC(CString& sLine);\n    bool OnSendToIRCMessage(CMessage& Message);\n\n    bool OnServerCapAvailable(const CString& sCap);\n    bool OnServerCapResult(const CString& sCap, bool bSuccess);\n\n    CModule* FindModule(const CString& sModule) const;\n    bool LoadModule(const CString& sModule, const CString& sArgs,\n                    CModInfo::EModuleType eType, CUser* pUser,\n                    CIRCNetwork* pNetwork, CString& sRetMsg);\n    bool UnloadModule(const CString& sModule);\n    bool UnloadModule(const CString& sModule, CString& sRetMsg);\n    bool ReloadModule(const CString& sModule, const CString& sArgs,\n                      CUser* pUser, CIRCNetwork* pNetwork, CString& sRetMsg);\n\n    static bool GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                           CString& sRetMsg);\n    static bool GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                               const CString& sModPath, CString& sRetMsg);\n    static void GetAvailableMods(\n        std::set<CModInfo>& ssMods,\n        CModInfo::EModuleType eType = CModInfo::UserModule);\n    static void GetDefaultMods(\n        std::set<CModInfo>& ssMods,\n        CModInfo::EModuleType eType = CModInfo::UserModule);\n\n    // This returns the path to the .so and to the data dir\n    // which is where static data (webadmin skins) are saved\n    static bool FindModPath(const CString& sModule, CString& sModPath,\n                            CString& sDataPath);\n    // Return a list of <module dir, data dir> pairs for directories in\n    // which modules can be found.\n    typedef std::queue<std::pair<CString, CString>> ModDirList;\n    static ModDirList GetModDirs();\n\n    // Global Modules\n    bool OnAddUser(CUser& User, CString& sErrorRet);\n    bool OnDeleteUser(CUser& User);\n    bool OnClientConnect(CZNCSock* pSock, const CString& sHost,\n                         unsigned short uPort);\n    bool OnLoginAttempt(std::shared_ptr<CAuthBase> Auth);\n    bool OnFailedLogin(const CString& sUsername, const CString& sRemoteIP);\n    bool OnUnknownUserRaw(CClient* pClient, CString& sLine);\n    bool OnUnknownUserRawMessage(CMessage& Message);\n    bool OnClientCapLs(CClient* pClient, SCString& ssCaps);\n    bool IsClientCapSupported(CClient* pClient, const CString& sCap,\n                              bool bState);\n    bool OnClientCapRequest(CClient* pClient, const CString& sCap, bool bState);\n    bool OnModuleLoading(const CString& sModName, const CString& sArgs,\n                         CModInfo::EModuleType eType, bool& bSuccess,\n                         CString& sRetMsg);\n    bool OnModuleUnloading(CModule* pModule, bool& bSuccess, CString& sRetMsg);\n    bool OnGetModInfo(CModInfo& ModInfo, const CString& sModule, bool& bSuccess,\n                      CString& sRetMsg);\n    bool OnGetAvailableMods(std::set<CModInfo>& ssMods,\n                            CModInfo::EModuleType eType);\n    // !Global Modules\n\n  private:\n    static ModHandle OpenModule(const CString& sModule, const CString& sModPath,\n                                CModInfo& Info, CString& sRetMsg);\n    static bool ValidateModuleName(const CString& sModule, CString& sRetMsg);\n\n  protected:\n    CUser* m_pUser;\n    CIRCNetwork* m_pNetwork;\n    CClient* m_pClient;\n};\n\n#endif  // !ZNC_MODULES_H\n", "/*\n * Copyright (C) 2004-2018 ZNC, see the NOTICE file for details.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <znc/Modules.h>\n#include <znc/FileUtils.h>\n#include <znc/Template.h>\n#include <znc/User.h>\n#include <znc/Query.h>\n#include <znc/IRCNetwork.h>\n#include <znc/WebModules.h>\n#include <znc/znc.h>\n#include <dlfcn.h>\n\nusing std::map;\nusing std::set;\nusing std::vector;\n\nbool ZNC_NO_NEED_TO_DO_ANYTHING_ON_MODULE_CALL_EXITER;\n\n#ifndef RTLD_LOCAL\n#define RTLD_LOCAL 0\n#warning \"your crap box doesn't define RTLD_LOCAL !?\"\n#endif\n\n#define MODUNLOADCHK(func)                              \\\n    for (CModule * pMod : *this) {                      \\\n        try {                                           \\\n            CClient* pOldClient = pMod->GetClient();    \\\n            pMod->SetClient(m_pClient);                 \\\n            CUser* pOldUser = nullptr;                  \\\n            if (m_pUser) {                              \\\n                pOldUser = pMod->GetUser();             \\\n                pMod->SetUser(m_pUser);                 \\\n            }                                           \\\n            CIRCNetwork* pNetwork = nullptr;            \\\n            if (m_pNetwork) {                           \\\n                pNetwork = pMod->GetNetwork();          \\\n                pMod->SetNetwork(m_pNetwork);           \\\n            }                                           \\\n            pMod->func;                                 \\\n            if (m_pUser) pMod->SetUser(pOldUser);       \\\n            if (m_pNetwork) pMod->SetNetwork(pNetwork); \\\n            pMod->SetClient(pOldClient);                \\\n        } catch (const CModule::EModException& e) {     \\\n            if (e == CModule::UNLOAD) {                 \\\n                UnloadModule(pMod->GetModName());       \\\n            }                                           \\\n        }                                               \\\n    }\n\n#define MODHALTCHK(func)                                \\\n    bool bHaltCore = false;                             \\\n    for (CModule * pMod : *this) {                      \\\n        try {                                           \\\n            CModule::EModRet e = CModule::CONTINUE;     \\\n            CClient* pOldClient = pMod->GetClient();    \\\n            pMod->SetClient(m_pClient);                 \\\n            CUser* pOldUser = nullptr;                  \\\n            if (m_pUser) {                              \\\n                pOldUser = pMod->GetUser();             \\\n                pMod->SetUser(m_pUser);                 \\\n            }                                           \\\n            CIRCNetwork* pNetwork = nullptr;            \\\n            if (m_pNetwork) {                           \\\n                pNetwork = pMod->GetNetwork();          \\\n                pMod->SetNetwork(m_pNetwork);           \\\n            }                                           \\\n            e = pMod->func;                             \\\n            if (m_pUser) pMod->SetUser(pOldUser);       \\\n            if (m_pNetwork) pMod->SetNetwork(pNetwork); \\\n            pMod->SetClient(pOldClient);                \\\n            if (e == CModule::HALTMODS) {               \\\n                break;                                  \\\n            } else if (e == CModule::HALTCORE) {        \\\n                bHaltCore = true;                       \\\n            } else if (e == CModule::HALT) {            \\\n                bHaltCore = true;                       \\\n                break;                                  \\\n            }                                           \\\n        } catch (const CModule::EModException& e) {     \\\n            if (e == CModule::UNLOAD) {                 \\\n                UnloadModule(pMod->GetModName());       \\\n            }                                           \\\n        }                                               \\\n    }                                                   \\\n    return bHaltCore;\n\n/////////////////// Timer ///////////////////\nCTimer::CTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles,\n               const CString& sLabel, const CString& sDescription)\n    : CCron(), m_pModule(pModule), m_sDescription(sDescription) {\n    SetName(sLabel);\n\n    // Make integration test faster\n    char* szDebugTimer = getenv(\"ZNC_DEBUG_TIMER\");\n    if (szDebugTimer && *szDebugTimer == '1') {\n        uInterval = std::max(1u, uInterval / 4u);\n    }\n\n    if (uCycles) {\n        StartMaxCycles(uInterval, uCycles);\n    } else {\n        Start(uInterval);\n    }\n}\n\nCTimer::~CTimer() { m_pModule->UnlinkTimer(this); }\n\nvoid CTimer::SetModule(CModule* p) { m_pModule = p; }\nvoid CTimer::SetDescription(const CString& s) { m_sDescription = s; }\nCModule* CTimer::GetModule() const { return m_pModule; }\nconst CString& CTimer::GetDescription() const { return m_sDescription; }\n/////////////////// !Timer ///////////////////\n\nCModule::CModule(ModHandle pDLL, CUser* pUser, CIRCNetwork* pNetwork,\n                 const CString& sModName, const CString& sDataDir,\n                 CModInfo::EModuleType eType)\n    : m_eType(eType),\n      m_sDescription(\"\"),\n      m_sTimers(),\n      m_sSockets(),\n#ifdef HAVE_PTHREAD\n      m_sJobs(),\n#endif\n      m_pDLL(pDLL),\n      m_pManager(&(CZNC::Get().GetManager())),\n      m_pUser(pUser),\n      m_pNetwork(pNetwork),\n      m_pClient(nullptr),\n      m_sModName(sModName),\n      m_sDataDir(sDataDir),\n      m_sSavePath(\"\"),\n      m_sArgs(\"\"),\n      m_sModPath(\"\"),\n      m_Translation(\"znc-\" + sModName),\n      m_mssRegistry(),\n      m_vSubPages(),\n      m_mCommands() {\n    if (m_pNetwork) {\n        m_sSavePath = m_pNetwork->GetNetworkPath() + \"/moddata/\" + m_sModName;\n    } else if (m_pUser) {\n        m_sSavePath = m_pUser->GetUserPath() + \"/moddata/\" + m_sModName;\n    } else {\n        m_sSavePath = CZNC::Get().GetZNCPath() + \"/moddata/\" + m_sModName;\n    }\n    LoadRegistry();\n}\n\nCModule::~CModule() {\n    while (!m_sTimers.empty()) {\n        RemTimer(*m_sTimers.begin());\n    }\n\n    while (!m_sSockets.empty()) {\n        RemSocket(*m_sSockets.begin());\n    }\n\n    SaveRegistry();\n\n#ifdef HAVE_PTHREAD\n    CancelJobs(m_sJobs);\n#endif\n}\n\nvoid CModule::SetUser(CUser* pUser) { m_pUser = pUser; }\nvoid CModule::SetNetwork(CIRCNetwork* pNetwork) { m_pNetwork = pNetwork; }\nvoid CModule::SetClient(CClient* pClient) { m_pClient = pClient; }\n\nCString CModule::ExpandString(const CString& sStr) const {\n    CString sRet;\n    return ExpandString(sStr, sRet);\n}\n\nCString& CModule::ExpandString(const CString& sStr, CString& sRet) const {\n    sRet = sStr;\n\n    if (m_pNetwork) {\n        return m_pNetwork->ExpandString(sRet, sRet);\n    }\n\n    if (m_pUser) {\n        return m_pUser->ExpandString(sRet, sRet);\n    }\n\n    return sRet;\n}\n\nconst CString& CModule::GetSavePath() const {\n    if (!CFile::Exists(m_sSavePath)) {\n        CDir::MakeDir(m_sSavePath);\n    }\n    return m_sSavePath;\n}\n\nCString CModule::GetWebPath() {\n    switch (m_eType) {\n        case CModInfo::GlobalModule:\n            return \"/mods/global/\" + GetModName() + \"/\";\n        case CModInfo::UserModule:\n            return \"/mods/user/\" + GetModName() + \"/\";\n        case CModInfo::NetworkModule:\n            return \"/mods/network/\" + m_pNetwork->GetName() + \"/\" +\n                   GetModName() + \"/\";\n        default:\n            return \"/\";\n    }\n}\n\nCString CModule::GetWebFilesPath() {\n    switch (m_eType) {\n        case CModInfo::GlobalModule:\n            return \"/modfiles/global/\" + GetModName() + \"/\";\n        case CModInfo::UserModule:\n            return \"/modfiles/user/\" + GetModName() + \"/\";\n        case CModInfo::NetworkModule:\n            return \"/modfiles/network/\" + m_pNetwork->GetName() + \"/\" +\n                   GetModName() + \"/\";\n        default:\n            return \"/\";\n    }\n}\n\nbool CModule::LoadRegistry() {\n    // CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : \".global\";\n    return (m_mssRegistry.ReadFromDisk(GetSavePath() + \"/.registry\") ==\n            MCString::MCS_SUCCESS);\n}\n\nbool CModule::SaveRegistry() const {\n    // CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : \".global\";\n    return (m_mssRegistry.WriteToDisk(GetSavePath() + \"/.registry\", 0600) ==\n            MCString::MCS_SUCCESS);\n}\n\nbool CModule::MoveRegistry(const CString& sPath) {\n    if (m_sSavePath != sPath) {\n        CFile fOldNVFile = CFile(m_sSavePath + \"/.registry\");\n        if (!fOldNVFile.Exists()) {\n            return false;\n        }\n        if (!CFile::Exists(sPath) && !CDir::MakeDir(sPath)) {\n            return false;\n        }\n        fOldNVFile.Copy(sPath + \"/.registry\");\n        m_sSavePath = sPath;\n        return true;\n    }\n    return false;\n}\n\nbool CModule::SetNV(const CString& sName, const CString& sValue,\n                    bool bWriteToDisk) {\n    m_mssRegistry[sName] = sValue;\n    if (bWriteToDisk) {\n        return SaveRegistry();\n    }\n\n    return true;\n}\n\nCString CModule::GetNV(const CString& sName) const {\n    MCString::const_iterator it = m_mssRegistry.find(sName);\n\n    if (it != m_mssRegistry.end()) {\n        return it->second;\n    }\n\n    return \"\";\n}\n\nbool CModule::DelNV(const CString& sName, bool bWriteToDisk) {\n    MCString::iterator it = m_mssRegistry.find(sName);\n\n    if (it != m_mssRegistry.end()) {\n        m_mssRegistry.erase(it);\n    } else {\n        return false;\n    }\n\n    if (bWriteToDisk) {\n        return SaveRegistry();\n    }\n\n    return true;\n}\n\nbool CModule::ClearNV(bool bWriteToDisk) {\n    m_mssRegistry.clear();\n\n    if (bWriteToDisk) {\n        return SaveRegistry();\n    }\n    return true;\n}\n\nbool CModule::AddTimer(CTimer* pTimer) {\n    if ((!pTimer) ||\n        (!pTimer->GetName().empty() && FindTimer(pTimer->GetName()))) {\n        delete pTimer;\n        return false;\n    }\n\n    if (!m_sTimers.insert(pTimer).second)\n        // Was already added\n        return true;\n\n    m_pManager->AddCron(pTimer);\n    return true;\n}\n\nbool CModule::AddTimer(FPTimer_t pFBCallback, const CString& sLabel,\n                       u_int uInterval, u_int uCycles,\n                       const CString& sDescription) {\n    CFPTimer* pTimer =\n        new CFPTimer(this, uInterval, uCycles, sLabel, sDescription);\n    pTimer->SetFPCallback(pFBCallback);\n\n    return AddTimer(pTimer);\n}\n\nbool CModule::RemTimer(CTimer* pTimer) {\n    if (m_sTimers.erase(pTimer) == 0) return false;\n    m_pManager->DelCronByAddr(pTimer);\n    return true;\n}\n\nbool CModule::RemTimer(const CString& sLabel) {\n    CTimer* pTimer = FindTimer(sLabel);\n    if (!pTimer) return false;\n    return RemTimer(pTimer);\n}\n\nbool CModule::UnlinkTimer(CTimer* pTimer) { return m_sTimers.erase(pTimer); }\n\nCTimer* CModule::FindTimer(const CString& sLabel) {\n    if (sLabel.empty()) {\n        return nullptr;\n    }\n\n    for (CTimer* pTimer : m_sTimers) {\n        if (pTimer->GetName().Equals(sLabel)) {\n            return pTimer;\n        }\n    }\n\n    return nullptr;\n}\n\nvoid CModule::ListTimers() {\n    if (m_sTimers.empty()) {\n        PutModule(\"You have no timers running.\");\n        return;\n    }\n\n    CTable Table;\n    Table.AddColumn(\"Name\");\n    Table.AddColumn(\"Secs\");\n    Table.AddColumn(\"Cycles\");\n    Table.AddColumn(\"Description\");\n\n    for (const CTimer* pTimer : m_sTimers) {\n        unsigned int uCycles = pTimer->GetCyclesLeft();\n        timeval Interval = pTimer->GetInterval();\n\n        Table.AddRow();\n        Table.SetCell(\"Name\", pTimer->GetName());\n        Table.SetCell(\n            \"Secs\", CString(Interval.tv_sec) + \"seconds\" +\n                        (Interval.tv_usec\n                             ? \" \" + CString(Interval.tv_usec) + \" microseconds\"\n                             : \"\"));\n        Table.SetCell(\"Cycles\", ((uCycles) ? CString(uCycles) : \"INF\"));\n        Table.SetCell(\"Description\", pTimer->GetDescription());\n    }\n\n    PutModule(Table);\n}\n\nbool CModule::AddSocket(CSocket* pSocket) {\n    if (!pSocket) {\n        return false;\n    }\n\n    m_sSockets.insert(pSocket);\n    return true;\n}\n\nbool CModule::RemSocket(CSocket* pSocket) {\n    if (m_sSockets.erase(pSocket)) {\n        m_pManager->DelSockByAddr(pSocket);\n        return true;\n    }\n\n    return false;\n}\n\nbool CModule::RemSocket(const CString& sSockName) {\n    for (CSocket* pSocket : m_sSockets) {\n        if (pSocket->GetSockName().Equals(sSockName)) {\n            m_sSockets.erase(pSocket);\n            m_pManager->DelSockByAddr(pSocket);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool CModule::UnlinkSocket(CSocket* pSocket) {\n    return m_sSockets.erase(pSocket);\n}\n\nCSocket* CModule::FindSocket(const CString& sSockName) {\n    for (CSocket* pSocket : m_sSockets) {\n        if (pSocket->GetSockName().Equals(sSockName)) {\n            return pSocket;\n        }\n    }\n\n    return nullptr;\n}\n\nvoid CModule::ListSockets() {\n    if (m_sSockets.empty()) {\n        PutModule(\"You have no open sockets.\");\n        return;\n    }\n\n    CTable Table;\n    Table.AddColumn(\"Name\");\n    Table.AddColumn(\"State\");\n    Table.AddColumn(\"LocalPort\");\n    Table.AddColumn(\"SSL\");\n    Table.AddColumn(\"RemoteIP\");\n    Table.AddColumn(\"RemotePort\");\n\n    for (const CSocket* pSocket : m_sSockets) {\n        Table.AddRow();\n        Table.SetCell(\"Name\", pSocket->GetSockName());\n\n        if (pSocket->GetType() == CSocket::LISTENER) {\n            Table.SetCell(\"State\", \"Listening\");\n        } else {\n            Table.SetCell(\"State\", (pSocket->IsConnected() ? \"Connected\" : \"\"));\n        }\n\n        Table.SetCell(\"LocalPort\", CString(pSocket->GetLocalPort()));\n        Table.SetCell(\"SSL\", (pSocket->GetSSL() ? \"yes\" : \"no\"));\n        Table.SetCell(\"RemoteIP\", pSocket->GetRemoteIP());\n        Table.SetCell(\"RemotePort\", (pSocket->GetRemotePort())\n                                        ? CString(pSocket->GetRemotePort())\n                                        : CString(\"\"));\n    }\n\n    PutModule(Table);\n}\n\n#ifdef HAVE_PTHREAD\nCModuleJob::~CModuleJob() { m_pModule->UnlinkJob(this); }\n\nvoid CModule::AddJob(CModuleJob* pJob) {\n    CThreadPool::Get().addJob(pJob);\n    m_sJobs.insert(pJob);\n}\n\nvoid CModule::CancelJob(CModuleJob* pJob) {\n    if (pJob == nullptr) return;\n    // Destructor calls UnlinkJob and removes the job from m_sJobs\n    CThreadPool::Get().cancelJob(pJob);\n}\n\nbool CModule::CancelJob(const CString& sJobName) {\n    for (CModuleJob* pJob : m_sJobs) {\n        if (pJob->GetName().Equals(sJobName)) {\n            CancelJob(pJob);\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid CModule::CancelJobs(const std::set<CModuleJob*>& sJobs) {\n    set<CJob*> sPlainJobs(sJobs.begin(), sJobs.end());\n\n    // Destructor calls UnlinkJob and removes the jobs from m_sJobs\n    CThreadPool::Get().cancelJobs(sPlainJobs);\n}\n\nbool CModule::UnlinkJob(CModuleJob* pJob) { return 0 != m_sJobs.erase(pJob); }\n#endif\n\nbool CModule::AddCommand(const CModCommand& Command) {\n    if (Command.GetFunction() == nullptr) return false;\n    if (Command.GetCommand().Contains(\" \")) return false;\n    if (FindCommand(Command.GetCommand()) != nullptr) return false;\n\n    m_mCommands[Command.GetCommand()] = Command;\n    return true;\n}\n\nbool CModule::AddCommand(const CString& sCmd, CModCommand::ModCmdFunc func,\n                         const CString& sArgs, const CString& sDesc) {\n    CModCommand cmd(sCmd, this, func, sArgs, sDesc);\n    return AddCommand(cmd);\n}\n\nbool CModule::AddCommand(const CString& sCmd, const COptionalTranslation& Args,\n                         const COptionalTranslation& Desc,\n                         std::function<void(const CString& sLine)> func) {\n    CModCommand cmd(sCmd, std::move(func), Args, Desc);\n    return AddCommand(std::move(cmd));\n}\n\nvoid CModule::AddHelpCommand() {\n    AddCommand(\"Help\", t_d(\"<search>\", \"modhelpcmd\"),\n               t_d(\"Generate this output\", \"modhelpcmd\"),\n               [=](const CString& sLine) { HandleHelpCommand(sLine); });\n}\n\nbool CModule::RemCommand(const CString& sCmd) {\n    return m_mCommands.erase(sCmd) > 0;\n}\n\nconst CModCommand* CModule::FindCommand(const CString& sCmd) const {\n    for (const auto& it : m_mCommands) {\n        if (!it.first.Equals(sCmd)) continue;\n        return &it.second;\n    }\n    return nullptr;\n}\n\nbool CModule::HandleCommand(const CString& sLine) {\n    const CString& sCmd = sLine.Token(0);\n    const CModCommand* pCmd = FindCommand(sCmd);\n\n    if (pCmd) {\n        pCmd->Call(sLine);\n        return true;\n    }\n\n    OnUnknownModCommand(sLine);\n\n    return false;\n}\n\nvoid CModule::HandleHelpCommand(const CString& sLine) {\n    CString sFilter = sLine.Token(1).AsLower();\n    CTable Table;\n\n    CModCommand::InitHelp(Table);\n    for (const auto& it : m_mCommands) {\n        CString sCmd = it.second.GetCommand().AsLower();\n        if (sFilter.empty() ||\n            (sCmd.StartsWith(sFilter, CString::CaseSensitive)) ||\n            sCmd.WildCmp(sFilter)) {\n            it.second.AddHelp(Table);\n        }\n    }\n    if (Table.empty()) {\n        PutModule(t_f(\"No matches for '{1}'\")(sFilter));\n    } else {\n        PutModule(Table);\n    }\n}\n\nCString CModule::GetModNick() const {\n    return ((m_pUser) ? m_pUser->GetStatusPrefix() : \"*\") + m_sModName;\n}\n\n// Webmods\nbool CModule::OnWebPreRequest(CWebSock& WebSock, const CString& sPageName) {\n    return false;\n}\nbool CModule::OnWebRequest(CWebSock& WebSock, const CString& sPageName,\n                           CTemplate& Tmpl) {\n    return false;\n}\nbool CModule::ValidateWebRequestCSRFCheck(CWebSock& WebSock,\n    const CString& sPageName) {\n    return WebSock.ValidateCSRFCheck(WebSock.GetURI());\n}\nbool CModule::OnEmbeddedWebRequest(CWebSock& WebSock, const CString& sPageName,\n                                   CTemplate& Tmpl) {\n    return false;\n}\n// !Webmods\n\nbool CModule::OnLoad(const CString& sArgs, CString& sMessage) {\n    sMessage = \"\";\n    return true;\n}\nbool CModule::OnBoot() { return true; }\nvoid CModule::OnPreRehash() {}\nvoid CModule::OnPostRehash() {}\nvoid CModule::OnIRCDisconnected() {}\nvoid CModule::OnIRCConnected() {}\nCModule::EModRet CModule::OnIRCConnecting(CIRCSock* IRCSock) {\n    return CONTINUE;\n}\nvoid CModule::OnIRCConnectionError(CIRCSock* IRCSock) {}\nCModule::EModRet CModule::OnIRCRegistration(CString& sPass, CString& sNick,\n                                            CString& sIdent,\n                                            CString& sRealName) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnBroadcast(CString& sMessage) { return CONTINUE; }\n\nvoid CModule::OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                                CChan& Channel, char cMode,\n                                bool bAdded, bool bNoChange) {\n    OnChanPermission2(pOpNick, Nick, Channel, cMode, bAdded, bNoChange);\n}\nvoid CModule::OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                                CChan& Channel, unsigned char uMode,\n                                bool bAdded, bool bNoChange) {\n    if (pOpNick)\n        OnChanPermission(*pOpNick, Nick, Channel, uMode, bAdded, bNoChange);\n}\nvoid CModule::OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                    bool bNoChange) {\n    if (pOpNick) OnOp(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnDeop2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange) {\n    if (pOpNick) OnDeop(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnVoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange) {\n    if (pOpNick) OnVoice(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnDevoice2(const CNick* pOpNick, const CNick& Nick,\n                         CChan& Channel, bool bNoChange) {\n    if (pOpNick) OnDevoice(*pOpNick, Nick, Channel, bNoChange);\n}\nvoid CModule::OnRawMode2(const CNick* pOpNick, CChan& Channel,\n                         const CString& sModes, const CString& sArgs) {\n    if (pOpNick) OnRawMode(*pOpNick, Channel, sModes, sArgs);\n}\nvoid CModule::OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                      const CString& sArg, bool bAdded, bool bNoChange) {\n    if (pOpNick) OnMode(*pOpNick, Channel, uMode, sArg, bAdded, bNoChange);\n}\n\nvoid CModule::OnChanPermission(const CNick& pOpNick, const CNick& Nick,\n                               CChan& Channel, unsigned char uMode, bool bAdded,\n                               bool bNoChange) {}\nvoid CModule::OnOp(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                   bool bNoChange) {}\nvoid CModule::OnDeop(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                     bool bNoChange) {}\nvoid CModule::OnVoice(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange) {}\nvoid CModule::OnDevoice(const CNick& pOpNick, const CNick& Nick, CChan& Channel,\n                        bool bNoChange) {}\nvoid CModule::OnRawMode(const CNick& pOpNick, CChan& Channel,\n                        const CString& sModes, const CString& sArgs) {}\nvoid CModule::OnMode(const CNick& pOpNick, CChan& Channel, char uMode,\n                     const CString& sArg, bool bAdded, bool bNoChange) {}\n\nCModule::EModRet CModule::OnRaw(CString& sLine) { return CONTINUE; }\nCModule::EModRet CModule::OnRawMessage(CMessage& Message) { return CONTINUE; }\nCModule::EModRet CModule::OnNumericMessage(CNumericMessage& Message) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnStatusCommand(CString& sCommand) {\n    return CONTINUE;\n}\nvoid CModule::OnModNotice(const CString& sMessage) {}\nvoid CModule::OnModCTCP(const CString& sMessage) {}\n\nvoid CModule::OnModCommand(const CString& sCommand) { HandleCommand(sCommand); }\nvoid CModule::OnUnknownModCommand(const CString& sLine) {\n    if (m_mCommands.empty())\n        // This function is only called if OnModCommand wasn't\n        // overriden, so no false warnings for modules which don't use\n        // CModCommand for command handling.\n        PutModule(t_s(\"This module doesn't implement any commands.\"));\n    else\n        PutModule(t_s(\"Unknown command!\"));\n}\n\nvoid CModule::OnQuit(const CNick& Nick, const CString& sMessage,\n                     const vector<CChan*>& vChans) {}\nvoid CModule::OnQuitMessage(CQuitMessage& Message,\n                            const vector<CChan*>& vChans) {\n    OnQuit(Message.GetNick(), Message.GetReason(), vChans);\n}\nvoid CModule::OnNick(const CNick& Nick, const CString& sNewNick,\n                     const vector<CChan*>& vChans) {}\nvoid CModule::OnNickMessage(CNickMessage& Message,\n                            const vector<CChan*>& vChans) {\n    OnNick(Message.GetNick(), Message.GetNewNick(), vChans);\n}\nvoid CModule::OnKick(const CNick& Nick, const CString& sKickedNick,\n                     CChan& Channel, const CString& sMessage) {}\nvoid CModule::OnKickMessage(CKickMessage& Message) {\n    OnKick(Message.GetNick(), Message.GetKickedNick(), *Message.GetChan(),\n           Message.GetReason());\n}\nCModule::EModRet CModule::OnJoining(CChan& Channel) { return CONTINUE; }\nvoid CModule::OnJoin(const CNick& Nick, CChan& Channel) {}\nvoid CModule::OnJoinMessage(CJoinMessage& Message) {\n    OnJoin(Message.GetNick(), *Message.GetChan());\n}\nvoid CModule::OnPart(const CNick& Nick, CChan& Channel,\n                     const CString& sMessage) {}\nvoid CModule::OnPartMessage(CPartMessage& Message) {\n    OnPart(Message.GetNick(), *Message.GetChan(), Message.GetReason());\n}\nCModule::EModRet CModule::OnInvite(const CNick& Nick, const CString& sChan) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnChanBufferStarting(CChan& Chan, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanBufferEnding(CChan& Chan, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanBufferPlayLine(CChan& Chan, CClient& Client,\n                                               CString& sLine) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivBufferStarting(CQuery& Query, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivBufferEnding(CQuery& Query, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivBufferPlayLine(CClient& Client,\n                                               CString& sLine) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnChanBufferPlayLine2(CChan& Chan, CClient& Client,\n                                                CString& sLine,\n                                                const timeval& tv) {\n    return OnChanBufferPlayLine(Chan, Client, sLine);\n}\nCModule::EModRet CModule::OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                                                const timeval& tv) {\n    return OnPrivBufferPlayLine(Client, sLine);\n}\n\nCModule::EModRet CModule::OnChanBufferPlayMessage(CMessage& Message) {\n    CString sOriginal, sModified;\n    sOriginal = sModified = Message.ToString(CMessage::ExcludeTags);\n    EModRet ret = OnChanBufferPlayLine2(\n        *Message.GetChan(), *Message.GetClient(), sModified, Message.GetTime());\n    if (sOriginal != sModified) {\n        Message.Parse(sModified);\n    }\n    return ret;\n}\nCModule::EModRet CModule::OnPrivBufferPlayMessage(CMessage& Message) {\n    CString sOriginal, sModified;\n    sOriginal = sModified = Message.ToString(CMessage::ExcludeTags);\n    EModRet ret = OnPrivBufferPlayLine2(*Message.GetClient(), sModified,\n                                        Message.GetTime());\n    if (sOriginal != sModified) {\n        Message.Parse(sModified);\n    }\n    return ret;\n}\n\nvoid CModule::OnClientLogin() {}\nvoid CModule::OnClientDisconnect() {}\nCModule::EModRet CModule::OnUserRaw(CString& sLine) { return CONTINUE; }\nCModule::EModRet CModule::OnUserRawMessage(CMessage& Message) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserCTCPReply(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserCTCPReplyMessage(CCTCPMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserCTCPReply(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserCTCP(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserCTCPMessage(CCTCPMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserCTCP(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserAction(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserActionMessage(CActionMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserAction(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserMsg(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserTextMessage(CTextMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserMsg(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserNotice(CString& sTarget, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserNoticeMessage(CNoticeMessage& Message) {\n    CString sTarget = Message.GetTarget();\n    CString sText = Message.GetText();\n    EModRet ret = OnUserNotice(sTarget, sText);\n    Message.SetTarget(sTarget);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnUserJoin(CString& sChannel, CString& sKey) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserJoinMessage(CJoinMessage& Message) {\n    CString sChan = Message.GetTarget();\n    CString sKey = Message.GetKey();\n    EModRet ret = OnUserJoin(sChan, sKey);\n    Message.SetTarget(sChan);\n    Message.SetKey(sKey);\n    return ret;\n}\nCModule::EModRet CModule::OnUserPart(CString& sChannel, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserPartMessage(CPartMessage& Message) {\n    CString sChan = Message.GetTarget();\n    CString sReason = Message.GetReason();\n    EModRet ret = OnUserPart(sChan, sReason);\n    Message.SetTarget(sChan);\n    Message.SetReason(sReason);\n    return ret;\n}\nCModule::EModRet CModule::OnUserTopic(CString& sChannel, CString& sTopic) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserTopicMessage(CTopicMessage& Message) {\n    CString sChan = Message.GetTarget();\n    CString sTopic = Message.GetTopic();\n    EModRet ret = OnUserTopic(sChan, sTopic);\n    Message.SetTarget(sChan);\n    Message.SetTopic(sTopic);\n    return ret;\n}\nCModule::EModRet CModule::OnUserTopicRequest(CString& sChannel) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUserQuit(CString& sMessage) { return CONTINUE; }\nCModule::EModRet CModule::OnUserQuitMessage(CQuitMessage& Message) {\n    CString sReason = Message.GetReason();\n    EModRet ret = OnUserQuit(sReason);\n    Message.SetReason(sReason);\n    return ret;\n}\n\nCModule::EModRet CModule::OnCTCPReply(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnCTCPReplyMessage(CCTCPMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnCTCPReply(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivCTCP(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivCTCPMessage(CCTCPMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivCTCP(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanCTCP(CNick& Nick, CChan& Channel,\n                                     CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanCTCPMessage(CCTCPMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanCTCP(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivAction(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivActionMessage(CActionMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivAction(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanAction(CNick& Nick, CChan& Channel,\n                                       CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanActionMessage(CActionMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanAction(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivMsg(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivTextMessage(CTextMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivMsg(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanMsg(CNick& Nick, CChan& Channel,\n                                    CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanTextMessage(CTextMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanMsg(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnPrivNotice(CNick& Nick, CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnPrivNoticeMessage(CNoticeMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnPrivNotice(Message.GetNick(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnChanNotice(CNick& Nick, CChan& Channel,\n                                       CString& sMessage) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnChanNoticeMessage(CNoticeMessage& Message) {\n    CString sText = Message.GetText();\n    EModRet ret = OnChanNotice(Message.GetNick(), *Message.GetChan(), sText);\n    Message.SetText(sText);\n    return ret;\n}\nCModule::EModRet CModule::OnTopic(CNick& Nick, CChan& Channel,\n                                  CString& sTopic) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnTopicMessage(CTopicMessage& Message) {\n    CString sTopic = Message.GetTopic();\n    EModRet ret = OnTopic(Message.GetNick(), *Message.GetChan(), sTopic);\n    Message.SetTopic(sTopic);\n    return ret;\n}\nCModule::EModRet CModule::OnTimerAutoJoin(CChan& Channel) { return CONTINUE; }\nCModule::EModRet CModule::OnAddNetwork(CIRCNetwork& Network,\n                                       CString& sErrorRet) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnDeleteNetwork(CIRCNetwork& Network) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnSendToClient(CString& sLine, CClient& Client) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnSendToClientMessage(CMessage& Message) {\n    return CONTINUE;\n}\n\nCModule::EModRet CModule::OnSendToIRC(CString& sLine) { return CONTINUE; }\nCModule::EModRet CModule::OnSendToIRCMessage(CMessage& Message) {\n    return CONTINUE;\n}\n\nbool CModule::OnServerCapAvailable(const CString& sCap) { return false; }\nvoid CModule::OnServerCapResult(const CString& sCap, bool bSuccess) {}\n\nbool CModule::PutIRC(const CString& sLine) {\n    return m_pNetwork ? m_pNetwork->PutIRC(sLine) : false;\n}\nbool CModule::PutIRC(const CMessage& Message) {\n    return m_pNetwork ? m_pNetwork->PutIRC(Message) : false;\n}\nbool CModule::PutUser(const CString& sLine) {\n    return m_pNetwork ? m_pNetwork->PutUser(sLine, m_pClient) : false;\n}\nbool CModule::PutStatus(const CString& sLine) {\n    return m_pNetwork ? m_pNetwork->PutStatus(sLine, m_pClient) : false;\n}\nunsigned int CModule::PutModule(const CTable& table) {\n    if (!m_pUser) return 0;\n\n    unsigned int idx = 0;\n    CString sLine;\n    while (table.GetLine(idx++, sLine)) PutModule(sLine);\n    return idx - 1;\n}\nbool CModule::PutModule(const CString& sLine) {\n    if (m_pClient) {\n        m_pClient->PutModule(GetModName(), sLine);\n        return true;\n    }\n\n    if (m_pNetwork) {\n        return m_pNetwork->PutModule(GetModName(), sLine);\n    }\n\n    if (m_pUser) {\n        return m_pUser->PutModule(GetModName(), sLine);\n    }\n\n    return false;\n}\nbool CModule::PutModNotice(const CString& sLine) {\n    if (!m_pUser) return false;\n\n    if (m_pClient) {\n        m_pClient->PutModNotice(GetModName(), sLine);\n        return true;\n    }\n\n    return m_pUser->PutModNotice(GetModName(), sLine);\n}\n\n///////////////////\n// Global Module //\n///////////////////\nCModule::EModRet CModule::OnAddUser(CUser& User, CString& sErrorRet) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnDeleteUser(CUser& User) { return CONTINUE; }\nvoid CModule::OnClientConnect(CZNCSock* pClient, const CString& sHost,\n                              unsigned short uPort) {}\nCModule::EModRet CModule::OnLoginAttempt(std::shared_ptr<CAuthBase> Auth) {\n    return CONTINUE;\n}\nvoid CModule::OnFailedLogin(const CString& sUsername,\n                            const CString& sRemoteIP) {}\nCModule::EModRet CModule::OnUnknownUserRaw(CClient* pClient, CString& sLine) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnUnknownUserRawMessage(CMessage& Message) {\n    return CONTINUE;\n}\nvoid CModule::OnClientCapLs(CClient* pClient, SCString& ssCaps) {}\nbool CModule::IsClientCapSupported(CClient* pClient, const CString& sCap,\n                                   bool bState) {\n    return false;\n}\nvoid CModule::OnClientCapRequest(CClient* pClient, const CString& sCap,\n                                 bool bState) {}\nCModule::EModRet CModule::OnModuleLoading(const CString& sModName,\n                                          const CString& sArgs,\n                                          CModInfo::EModuleType eType,\n                                          bool& bSuccess, CString& sRetMsg) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnModuleUnloading(CModule* pModule, bool& bSuccess,\n                                            CString& sRetMsg) {\n    return CONTINUE;\n}\nCModule::EModRet CModule::OnGetModInfo(CModInfo& ModInfo,\n                                       const CString& sModule, bool& bSuccess,\n                                       CString& sRetMsg) {\n    return CONTINUE;\n}\nvoid CModule::OnGetAvailableMods(set<CModInfo>& ssMods,\n                                 CModInfo::EModuleType eType) {}\n\nCModules::CModules()\n    : m_pUser(nullptr), m_pNetwork(nullptr), m_pClient(nullptr) {}\n\nCModules::~CModules() { UnloadAll(); }\n\nvoid CModules::UnloadAll() {\n    while (size()) {\n        CString sRetMsg;\n        CString sModName = back()->GetModName();\n        UnloadModule(sModName, sRetMsg);\n    }\n}\n\nbool CModules::OnBoot() {\n    for (CModule* pMod : *this) {\n        try {\n            if (!pMod->OnBoot()) {\n                return true;\n            }\n        } catch (const CModule::EModException& e) {\n            if (e == CModule::UNLOAD) {\n                UnloadModule(pMod->GetModName());\n            }\n        }\n    }\n\n    return false;\n}\n\nbool CModules::OnPreRehash() {\n    MODUNLOADCHK(OnPreRehash());\n    return false;\n}\nbool CModules::OnPostRehash() {\n    MODUNLOADCHK(OnPostRehash());\n    return false;\n}\nbool CModules::OnIRCConnected() {\n    MODUNLOADCHK(OnIRCConnected());\n    return false;\n}\nbool CModules::OnIRCConnecting(CIRCSock* pIRCSock) {\n    MODHALTCHK(OnIRCConnecting(pIRCSock));\n}\nbool CModules::OnIRCConnectionError(CIRCSock* pIRCSock) {\n    MODUNLOADCHK(OnIRCConnectionError(pIRCSock));\n    return false;\n}\nbool CModules::OnIRCRegistration(CString& sPass, CString& sNick,\n                                 CString& sIdent, CString& sRealName) {\n    MODHALTCHK(OnIRCRegistration(sPass, sNick, sIdent, sRealName));\n}\nbool CModules::OnBroadcast(CString& sMessage) {\n    MODHALTCHK(OnBroadcast(sMessage));\n}\nbool CModules::OnIRCDisconnected() {\n    MODUNLOADCHK(OnIRCDisconnected());\n    return false;\n}\n\nbool CModules::OnChanPermission3(const CNick* pOpNick, const CNick& Nick,\n                                 CChan& Channel, char cMode,\n                                 bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(\n        OnChanPermission3(pOpNick, Nick, Channel, cMode, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnChanPermission2(const CNick* pOpNick, const CNick& Nick,\n                                 CChan& Channel, unsigned char uMode,\n                                 bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(\n        OnChanPermission2(pOpNick, Nick, Channel, uMode, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnChanPermission(const CNick& OpNick, const CNick& Nick,\n                                CChan& Channel, unsigned char uMode,\n                                bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(\n        OnChanPermission(OpNick, Nick, Channel, uMode, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnOp2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                     bool bNoChange) {\n    MODUNLOADCHK(OnOp2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                    bool bNoChange) {\n    MODUNLOADCHK(OnOp(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDeop2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange) {\n    MODUNLOADCHK(OnDeop2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                      bool bNoChange) {\n    MODUNLOADCHK(OnDeop(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnVoice2(const CNick* pOpNick, const CNick& Nick, CChan& Channel,\n                        bool bNoChange) {\n    MODUNLOADCHK(OnVoice2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                       bool bNoChange) {\n    MODUNLOADCHK(OnVoice(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDevoice2(const CNick* pOpNick, const CNick& Nick,\n                          CChan& Channel, bool bNoChange) {\n    MODUNLOADCHK(OnDevoice2(pOpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel,\n                         bool bNoChange) {\n    MODUNLOADCHK(OnDevoice(OpNick, Nick, Channel, bNoChange));\n    return false;\n}\nbool CModules::OnRawMode2(const CNick* pOpNick, CChan& Channel,\n                          const CString& sModes, const CString& sArgs) {\n    MODUNLOADCHK(OnRawMode2(pOpNick, Channel, sModes, sArgs));\n    return false;\n}\nbool CModules::OnRawMode(const CNick& OpNick, CChan& Channel,\n                         const CString& sModes, const CString& sArgs) {\n    MODUNLOADCHK(OnRawMode(OpNick, Channel, sModes, sArgs));\n    return false;\n}\nbool CModules::OnMode2(const CNick* pOpNick, CChan& Channel, char uMode,\n                       const CString& sArg, bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(OnMode2(pOpNick, Channel, uMode, sArg, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnMode(const CNick& OpNick, CChan& Channel, char uMode,\n                      const CString& sArg, bool bAdded, bool bNoChange) {\n    MODUNLOADCHK(OnMode(OpNick, Channel, uMode, sArg, bAdded, bNoChange));\n    return false;\n}\nbool CModules::OnRaw(CString& sLine) { MODHALTCHK(OnRaw(sLine)); }\nbool CModules::OnRawMessage(CMessage& Message) {\n    MODHALTCHK(OnRawMessage(Message));\n}\nbool CModules::OnNumericMessage(CNumericMessage& Message) {\n    MODHALTCHK(OnNumericMessage(Message));\n}\n\nbool CModules::OnClientLogin() {\n    MODUNLOADCHK(OnClientLogin());\n    return false;\n}\nbool CModules::OnClientDisconnect() {\n    MODUNLOADCHK(OnClientDisconnect());\n    return false;\n}\nbool CModules::OnUserRaw(CString& sLine) { MODHALTCHK(OnUserRaw(sLine)); }\nbool CModules::OnUserRawMessage(CMessage& Message) {\n    MODHALTCHK(OnUserRawMessage(Message));\n}\nbool CModules::OnUserCTCPReply(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserCTCPReply(sTarget, sMessage));\n}\nbool CModules::OnUserCTCPReplyMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnUserCTCPReplyMessage(Message));\n}\nbool CModules::OnUserCTCP(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserCTCP(sTarget, sMessage));\n}\nbool CModules::OnUserCTCPMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnUserCTCPMessage(Message));\n}\nbool CModules::OnUserAction(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserAction(sTarget, sMessage));\n}\nbool CModules::OnUserActionMessage(CActionMessage& Message) {\n    MODHALTCHK(OnUserActionMessage(Message));\n}\nbool CModules::OnUserMsg(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserMsg(sTarget, sMessage));\n}\nbool CModules::OnUserTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnUserTextMessage(Message));\n}\nbool CModules::OnUserNotice(CString& sTarget, CString& sMessage) {\n    MODHALTCHK(OnUserNotice(sTarget, sMessage));\n}\nbool CModules::OnUserNoticeMessage(CNoticeMessage& Message) {\n    MODHALTCHK(OnUserNoticeMessage(Message));\n}\nbool CModules::OnUserJoin(CString& sChannel, CString& sKey) {\n    MODHALTCHK(OnUserJoin(sChannel, sKey));\n}\nbool CModules::OnUserJoinMessage(CJoinMessage& Message) {\n    MODHALTCHK(OnUserJoinMessage(Message));\n}\nbool CModules::OnUserPart(CString& sChannel, CString& sMessage) {\n    MODHALTCHK(OnUserPart(sChannel, sMessage));\n}\nbool CModules::OnUserPartMessage(CPartMessage& Message) {\n    MODHALTCHK(OnUserPartMessage(Message));\n}\nbool CModules::OnUserTopic(CString& sChannel, CString& sTopic) {\n    MODHALTCHK(OnUserTopic(sChannel, sTopic));\n}\nbool CModules::OnUserTopicMessage(CTopicMessage& Message) {\n    MODHALTCHK(OnUserTopicMessage(Message));\n}\nbool CModules::OnUserTopicRequest(CString& sChannel) {\n    MODHALTCHK(OnUserTopicRequest(sChannel));\n}\nbool CModules::OnUserQuit(CString& sMessage) {\n    MODHALTCHK(OnUserQuit(sMessage));\n}\nbool CModules::OnUserQuitMessage(CQuitMessage& Message) {\n    MODHALTCHK(OnUserQuitMessage(Message));\n}\n\nbool CModules::OnQuit(const CNick& Nick, const CString& sMessage,\n                      const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnQuit(Nick, sMessage, vChans));\n    return false;\n}\nbool CModules::OnQuitMessage(CQuitMessage& Message,\n                             const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnQuitMessage(Message, vChans));\n    return false;\n}\nbool CModules::OnNick(const CNick& Nick, const CString& sNewNick,\n                      const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnNick(Nick, sNewNick, vChans));\n    return false;\n}\nbool CModules::OnNickMessage(CNickMessage& Message,\n                             const vector<CChan*>& vChans) {\n    MODUNLOADCHK(OnNickMessage(Message, vChans));\n    return false;\n}\nbool CModules::OnKick(const CNick& Nick, const CString& sKickedNick,\n                      CChan& Channel, const CString& sMessage) {\n    MODUNLOADCHK(OnKick(Nick, sKickedNick, Channel, sMessage));\n    return false;\n}\nbool CModules::OnKickMessage(CKickMessage& Message) {\n    MODUNLOADCHK(OnKickMessage(Message));\n    return false;\n}\nbool CModules::OnJoining(CChan& Channel) { MODHALTCHK(OnJoining(Channel)); }\nbool CModules::OnJoin(const CNick& Nick, CChan& Channel) {\n    MODUNLOADCHK(OnJoin(Nick, Channel));\n    return false;\n}\nbool CModules::OnJoinMessage(CJoinMessage& Message) {\n    MODUNLOADCHK(OnJoinMessage(Message));\n    return false;\n}\nbool CModules::OnPart(const CNick& Nick, CChan& Channel,\n                      const CString& sMessage) {\n    MODUNLOADCHK(OnPart(Nick, Channel, sMessage));\n    return false;\n}\nbool CModules::OnPartMessage(CPartMessage& Message) {\n    MODUNLOADCHK(OnPartMessage(Message));\n    return false;\n}\nbool CModules::OnInvite(const CNick& Nick, const CString& sChan) {\n    MODHALTCHK(OnInvite(Nick, sChan));\n}\nbool CModules::OnChanBufferStarting(CChan& Chan, CClient& Client) {\n    MODHALTCHK(OnChanBufferStarting(Chan, Client));\n}\nbool CModules::OnChanBufferEnding(CChan& Chan, CClient& Client) {\n    MODHALTCHK(OnChanBufferEnding(Chan, Client));\n}\nbool CModules::OnChanBufferPlayLine2(CChan& Chan, CClient& Client,\n                                     CString& sLine, const timeval& tv) {\n    MODHALTCHK(OnChanBufferPlayLine2(Chan, Client, sLine, tv));\n}\nbool CModules::OnChanBufferPlayLine(CChan& Chan, CClient& Client,\n                                    CString& sLine) {\n    MODHALTCHK(OnChanBufferPlayLine(Chan, Client, sLine));\n}\nbool CModules::OnPrivBufferStarting(CQuery& Query, CClient& Client) {\n    MODHALTCHK(OnPrivBufferStarting(Query, Client));\n}\nbool CModules::OnPrivBufferEnding(CQuery& Query, CClient& Client) {\n    MODHALTCHK(OnPrivBufferEnding(Query, Client));\n}\nbool CModules::OnPrivBufferPlayLine2(CClient& Client, CString& sLine,\n                                     const timeval& tv) {\n    MODHALTCHK(OnPrivBufferPlayLine2(Client, sLine, tv));\n}\nbool CModules::OnPrivBufferPlayLine(CClient& Client, CString& sLine) {\n    MODHALTCHK(OnPrivBufferPlayLine(Client, sLine));\n}\nbool CModules::OnChanBufferPlayMessage(CMessage& Message) {\n    MODHALTCHK(OnChanBufferPlayMessage(Message));\n}\nbool CModules::OnPrivBufferPlayMessage(CMessage& Message) {\n    MODHALTCHK(OnPrivBufferPlayMessage(Message));\n}\nbool CModules::OnCTCPReply(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnCTCPReply(Nick, sMessage));\n}\nbool CModules::OnCTCPReplyMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnCTCPReplyMessage(Message));\n}\nbool CModules::OnPrivCTCP(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivCTCP(Nick, sMessage));\n}\nbool CModules::OnPrivCTCPMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnPrivCTCPMessage(Message));\n}\nbool CModules::OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanCTCP(Nick, Channel, sMessage));\n}\nbool CModules::OnChanCTCPMessage(CCTCPMessage& Message) {\n    MODHALTCHK(OnChanCTCPMessage(Message));\n}\nbool CModules::OnPrivAction(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivAction(Nick, sMessage));\n}\nbool CModules::OnPrivActionMessage(CActionMessage& Message) {\n    MODHALTCHK(OnPrivActionMessage(Message));\n}\nbool CModules::OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanAction(Nick, Channel, sMessage));\n}\nbool CModules::OnChanActionMessage(CActionMessage& Message) {\n    MODHALTCHK(OnChanActionMessage(Message));\n}\nbool CModules::OnPrivMsg(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivMsg(Nick, sMessage));\n}\nbool CModules::OnPrivTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnPrivTextMessage(Message));\n}\nbool CModules::OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanMsg(Nick, Channel, sMessage));\n}\nbool CModules::OnChanTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnChanTextMessage(Message));\n}\nbool CModules::OnPrivNotice(CNick& Nick, CString& sMessage) {\n    MODHALTCHK(OnPrivNotice(Nick, sMessage));\n}\nbool CModules::OnPrivNoticeMessage(CNoticeMessage& Message) {\n    MODHALTCHK(OnPrivNoticeMessage(Message));\n}\nbool CModules::OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) {\n    MODHALTCHK(OnChanNotice(Nick, Channel, sMessage));\n}\nbool CModules::OnChanNoticeMessage(CNoticeMessage& Message) {\n    MODHALTCHK(OnChanNoticeMessage(Message));\n}\nbool CModules::OnTopic(CNick& Nick, CChan& Channel, CString& sTopic) {\n    MODHALTCHK(OnTopic(Nick, Channel, sTopic));\n}\nbool CModules::OnTopicMessage(CTopicMessage& Message) {\n    MODHALTCHK(OnTopicMessage(Message));\n}\nbool CModules::OnTimerAutoJoin(CChan& Channel) {\n    MODHALTCHK(OnTimerAutoJoin(Channel));\n}\nbool CModules::OnAddNetwork(CIRCNetwork& Network, CString& sErrorRet) {\n    MODHALTCHK(OnAddNetwork(Network, sErrorRet));\n}\nbool CModules::OnDeleteNetwork(CIRCNetwork& Network) {\n    MODHALTCHK(OnDeleteNetwork(Network));\n}\nbool CModules::OnSendToClient(CString& sLine, CClient& Client) {\n    MODHALTCHK(OnSendToClient(sLine, Client));\n}\nbool CModules::OnSendToClientMessage(CMessage& Message) {\n    MODHALTCHK(OnSendToClientMessage(Message));\n}\nbool CModules::OnSendToIRC(CString& sLine) { MODHALTCHK(OnSendToIRC(sLine)); }\nbool CModules::OnSendToIRCMessage(CMessage& Message) {\n    MODHALTCHK(OnSendToIRCMessage(Message));\n}\nbool CModules::OnStatusCommand(CString& sCommand) {\n    MODHALTCHK(OnStatusCommand(sCommand));\n}\nbool CModules::OnModCommand(const CString& sCommand) {\n    MODUNLOADCHK(OnModCommand(sCommand));\n    return false;\n}\nbool CModules::OnModNotice(const CString& sMessage) {\n    MODUNLOADCHK(OnModNotice(sMessage));\n    return false;\n}\nbool CModules::OnModCTCP(const CString& sMessage) {\n    MODUNLOADCHK(OnModCTCP(sMessage));\n    return false;\n}\n\n// Why MODHALTCHK works only with functions returning EModRet ? :(\nbool CModules::OnServerCapAvailable(const CString& sCap) {\n    bool bResult = false;\n    for (CModule* pMod : *this) {\n        try {\n            CClient* pOldClient = pMod->GetClient();\n            pMod->SetClient(m_pClient);\n            if (m_pUser) {\n                CUser* pOldUser = pMod->GetUser();\n                pMod->SetUser(m_pUser);\n                bResult |= pMod->OnServerCapAvailable(sCap);\n                pMod->SetUser(pOldUser);\n            } else {\n                // WTF? Is that possible?\n                bResult |= pMod->OnServerCapAvailable(sCap);\n            }\n            pMod->SetClient(pOldClient);\n        } catch (const CModule::EModException& e) {\n            if (CModule::UNLOAD == e) {\n                UnloadModule(pMod->GetModName());\n            }\n        }\n    }\n    return bResult;\n}\n\nbool CModules::OnServerCapResult(const CString& sCap, bool bSuccess) {\n    MODUNLOADCHK(OnServerCapResult(sCap, bSuccess));\n    return false;\n}\n\n////////////////////\n// Global Modules //\n////////////////////\nbool CModules::OnAddUser(CUser& User, CString& sErrorRet) {\n    MODHALTCHK(OnAddUser(User, sErrorRet));\n}\n\nbool CModules::OnDeleteUser(CUser& User) { MODHALTCHK(OnDeleteUser(User)); }\n\nbool CModules::OnClientConnect(CZNCSock* pClient, const CString& sHost,\n                               unsigned short uPort) {\n    MODUNLOADCHK(OnClientConnect(pClient, sHost, uPort));\n    return false;\n}\n\nbool CModules::OnLoginAttempt(std::shared_ptr<CAuthBase> Auth) {\n    MODHALTCHK(OnLoginAttempt(Auth));\n}\n\nbool CModules::OnFailedLogin(const CString& sUsername,\n                             const CString& sRemoteIP) {\n    MODUNLOADCHK(OnFailedLogin(sUsername, sRemoteIP));\n    return false;\n}\n\nbool CModules::OnUnknownUserRaw(CClient* pClient, CString& sLine) {\n    MODHALTCHK(OnUnknownUserRaw(pClient, sLine));\n}\n\nbool CModules::OnUnknownUserRawMessage(CMessage& Message) {\n    MODHALTCHK(OnUnknownUserRawMessage(Message));\n}\n\nbool CModules::OnClientCapLs(CClient* pClient, SCString& ssCaps) {\n    MODUNLOADCHK(OnClientCapLs(pClient, ssCaps));\n    return false;\n}\n\n// Maybe create new macro for this?\nbool CModules::IsClientCapSupported(CClient* pClient, const CString& sCap,\n                                    bool bState) {\n    bool bResult = false;\n    for (CModule* pMod : *this) {\n        try {\n            CClient* pOldClient = pMod->GetClient();\n            pMod->SetClient(m_pClient);\n            if (m_pUser) {\n                CUser* pOldUser = pMod->GetUser();\n                pMod->SetUser(m_pUser);\n                bResult |= pMod->IsClientCapSupported(pClient, sCap, bState);\n                pMod->SetUser(pOldUser);\n            } else {\n                // WTF? Is that possible?\n                bResult |= pMod->IsClientCapSupported(pClient, sCap, bState);\n            }\n            pMod->SetClient(pOldClient);\n        } catch (const CModule::EModException& e) {\n            if (CModule::UNLOAD == e) {\n                UnloadModule(pMod->GetModName());\n            }\n        }\n    }\n    return bResult;\n}\n\nbool CModules::OnClientCapRequest(CClient* pClient, const CString& sCap,\n                                  bool bState) {\n    MODUNLOADCHK(OnClientCapRequest(pClient, sCap, bState));\n    return false;\n}\n\nbool CModules::OnModuleLoading(const CString& sModName, const CString& sArgs,\n                               CModInfo::EModuleType eType, bool& bSuccess,\n                               CString& sRetMsg) {\n    MODHALTCHK(OnModuleLoading(sModName, sArgs, eType, bSuccess, sRetMsg));\n}\n\nbool CModules::OnModuleUnloading(CModule* pModule, bool& bSuccess,\n                                 CString& sRetMsg) {\n    MODHALTCHK(OnModuleUnloading(pModule, bSuccess, sRetMsg));\n}\n\nbool CModules::OnGetModInfo(CModInfo& ModInfo, const CString& sModule,\n                            bool& bSuccess, CString& sRetMsg) {\n    MODHALTCHK(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg));\n}\n\nbool CModules::OnGetAvailableMods(set<CModInfo>& ssMods,\n                                  CModInfo::EModuleType eType) {\n    MODUNLOADCHK(OnGetAvailableMods(ssMods, eType));\n    return false;\n}\n\nCModule* CModules::FindModule(const CString& sModule) const {\n    for (CModule* pMod : *this) {\n        if (sModule.Equals(pMod->GetModName())) {\n            return pMod;\n        }\n    }\n\n    return nullptr;\n}\n\nbool CModules::ValidateModuleName(const CString& sModule, CString& sRetMsg) {\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool CModules::LoadModule(const CString& sModule, const CString& sArgs,\n                          CModInfo::EModuleType eType, CUser* pUser,\n                          CIRCNetwork* pNetwork, CString& sRetMsg) {\n    sRetMsg = \"\";\n\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n\n    if (FindModule(sModule) != nullptr) {\n        sRetMsg = t_f(\"Module {1} already loaded.\")(sModule);\n        return false;\n    }\n\n    bool bSuccess;\n    bool bHandled = false;\n    _GLOBALMODULECALL(OnModuleLoading(sModule, sArgs, eType, bSuccess, sRetMsg),\n                      pUser, pNetwork, nullptr, &bHandled);\n    if (bHandled) return bSuccess;\n\n    CString sModPath, sDataPath;\n    CModInfo Info;\n\n    if (!FindModPath(sModule, sModPath, sDataPath)) {\n        sRetMsg = t_f(\"Unable to find module {1}\")(sModule);\n        return false;\n    }\n    Info.SetName(sModule);\n    Info.SetPath(sModPath);\n\n    ModHandle p = OpenModule(sModule, sModPath, Info, sRetMsg);\n\n    if (!p) return false;\n\n    if (!Info.SupportsType(eType)) {\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} does not support module type {2}.\")(\n            sModule, CModInfo::ModuleTypeToString(eType));\n        return false;\n    }\n\n    if (!pUser && eType == CModInfo::UserModule) {\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} requires a user.\")(sModule);\n        return false;\n    }\n\n    if (!pNetwork && eType == CModInfo::NetworkModule) {\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} requires a network.\")(sModule);\n        return false;\n    }\n\n    CModule* pModule =\n        Info.GetLoader()(p, pUser, pNetwork, sModule, sDataPath, eType);\n    pModule->SetDescription(Info.GetDescription());\n    pModule->SetArgs(sArgs);\n    pModule->SetModPath(CDir::ChangeDir(CZNC::Get().GetCurPath(), sModPath));\n    push_back(pModule);\n\n    bool bLoaded;\n    try {\n        bLoaded = pModule->OnLoad(sArgs, sRetMsg);\n    } catch (const CModule::EModException&) {\n        bLoaded = false;\n        sRetMsg = t_s(\"Caught an exception\");\n    }\n\n    if (!bLoaded) {\n        UnloadModule(sModule, sModPath);\n        if (!sRetMsg.empty())\n            sRetMsg = t_f(\"Module {1} aborted: {2}\")(sModule, sRetMsg);\n        else\n            sRetMsg = t_f(\"Module {1} aborted.\")(sModule);\n        return false;\n    }\n\n    if (!sRetMsg.empty()) {\n        sRetMsg += \" \";\n    }\n    sRetMsg += \"[\" + sModPath + \"]\";\n    return true;\n}\n\nbool CModules::UnloadModule(const CString& sModule) {\n    CString s;\n    return UnloadModule(sModule, s);\n}\n\nbool CModules::UnloadModule(const CString& sModule, CString& sRetMsg) {\n    // Make a copy incase the reference passed in is from CModule::GetModName()\n    CString sMod = sModule;\n\n    CModule* pModule = FindModule(sMod);\n    sRetMsg = \"\";\n\n    if (!pModule) {\n        sRetMsg = t_f(\"Module [{1}] not loaded.\")(sMod);\n        return false;\n    }\n\n    bool bSuccess;\n    bool bHandled = false;\n    _GLOBALMODULECALL(OnModuleUnloading(pModule, bSuccess, sRetMsg),\n                      pModule->GetUser(), pModule->GetNetwork(), nullptr,\n                      &bHandled);\n    if (bHandled) return bSuccess;\n\n    ModHandle p = pModule->GetDLL();\n\n    if (p) {\n        delete pModule;\n\n        for (iterator it = begin(); it != end(); ++it) {\n            if (*it == pModule) {\n                erase(it);\n                break;\n            }\n        }\n\n        dlclose(p);\n        sRetMsg = t_f(\"Module {1} unloaded.\")(sMod);\n\n        return true;\n    }\n\n    sRetMsg = t_f(\"Unable to unload module {1}.\")(sMod);\n    return false;\n}\n\nbool CModules::ReloadModule(const CString& sModule, const CString& sArgs,\n                            CUser* pUser, CIRCNetwork* pNetwork,\n                            CString& sRetMsg) {\n    // Make a copy incase the reference passed in is from CModule::GetModName()\n    CString sMod = sModule;\n\n    CModule* pModule = FindModule(sMod);\n\n    if (!pModule) {\n        sRetMsg = t_f(\"Module [{1}] not loaded.\")(sMod);\n        return false;\n    }\n\n    CModInfo::EModuleType eType = pModule->GetType();\n    pModule = nullptr;\n\n    sRetMsg = \"\";\n    if (!UnloadModule(sMod, sRetMsg)) {\n        return false;\n    }\n\n    if (!LoadModule(sMod, sArgs, eType, pUser, pNetwork, sRetMsg)) {\n        return false;\n    }\n\n    sRetMsg = t_f(\"Reloaded module {1}.\")(sMod);\n    return true;\n}\n\nbool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n\n    CString sModPath, sTmp;\n\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}\n\nbool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                              const CString& sModPath, CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n\n    ModInfo.SetName(sModule);\n    ModInfo.SetPath(sModPath);\n\n    ModHandle p = OpenModule(sModule, sModPath, ModInfo, sRetMsg);\n    if (!p) return false;\n\n    dlclose(p);\n\n    return true;\n}\n\nvoid CModules::GetAvailableMods(set<CModInfo>& ssMods,\n                                CModInfo::EModuleType eType) {\n    ssMods.clear();\n\n    unsigned int a = 0;\n    CDir Dir;\n\n    ModDirList dirs = GetModDirs();\n\n    while (!dirs.empty()) {\n        Dir.FillByWildcard(dirs.front().first, \"*.so\");\n        dirs.pop();\n\n        for (a = 0; a < Dir.size(); a++) {\n            CFile& File = *Dir[a];\n            CString sName = File.GetShortName();\n            CString sPath = File.GetLongName();\n            CModInfo ModInfo;\n            sName.RightChomp(3);\n\n            CString sIgnoreRetMsg;\n            if (GetModPathInfo(ModInfo, sName, sPath, sIgnoreRetMsg)) {\n                if (ModInfo.SupportsType(eType)) {\n                    ssMods.insert(ModInfo);\n                }\n            }\n        }\n    }\n\n    GLOBALMODULECALL(OnGetAvailableMods(ssMods, eType), NOTHING);\n}\n\nvoid CModules::GetDefaultMods(set<CModInfo>& ssMods,\n                              CModInfo::EModuleType eType) {\n    GetAvailableMods(ssMods, eType);\n\n    const map<CString, CModInfo::EModuleType> ns = {\n        {\"chansaver\", CModInfo::UserModule},\n        {\"controlpanel\", CModInfo::UserModule},\n        {\"simple_away\", CModInfo::NetworkModule},\n        {\"webadmin\", CModInfo::GlobalModule}};\n\n    auto it = ssMods.begin();\n    while (it != ssMods.end()) {\n        auto it2 = ns.find(it->GetName());\n        if (it2 != ns.end() && it2->second == eType) {\n            ++it;\n        } else {\n            it = ssMods.erase(it);\n        }\n    }\n}\n\nbool CModules::FindModPath(const CString& sModule, CString& sModPath,\n                           CString& sDataPath) {\n    CString sMod = sModule;\n    CString sDir = sMod;\n    if (!sModule.Contains(\".\")) sMod += \".so\";\n\n    ModDirList dirs = GetModDirs();\n\n    while (!dirs.empty()) {\n        sModPath = dirs.front().first + sMod;\n        sDataPath = dirs.front().second;\n        dirs.pop();\n\n        if (CFile::Exists(sModPath)) {\n            sDataPath += sDir;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nCModules::ModDirList CModules::GetModDirs() {\n    ModDirList ret;\n    CString sDir;\n\n#ifdef RUN_FROM_SOURCE\n    // ./modules\n    sDir = CZNC::Get().GetCurPath() + \"/modules/\";\n    ret.push(std::make_pair(sDir, sDir + \"data/\"));\n#endif\n\n    // ~/.znc/modules\n    sDir = CZNC::Get().GetModPath() + \"/\";\n    ret.push(std::make_pair(sDir, sDir));\n\n    // <moduledir> and <datadir> (<prefix>/lib/znc)\n    ret.push(std::make_pair(_MODDIR_ + CString(\"/\"),\n                            _DATADIR_ + CString(\"/modules/\")));\n\n    return ret;\n}\n\nModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n                               CModInfo& Info, CString& sRetMsg) {\n    // Some sane defaults in case anything errors out below\n    sRetMsg.clear();\n\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return nullptr;\n    }\n\n    // The second argument to dlopen() has a long history. It seems clear\n    // that (despite what the man page says) we must include either of\n    // RTLD_NOW and RTLD_LAZY and either of RTLD_GLOBAL and RTLD_LOCAL.\n    //\n    // RTLD_NOW vs. RTLD_LAZY: We use RTLD_NOW to avoid ZNC dying due to\n    // failed symbol lookups later on. Doesn't really seem to have much of a\n    // performance impact.\n    //\n    // RTLD_GLOBAL vs. RTLD_LOCAL: If perl is loaded with RTLD_LOCAL and later\n    // on loads own modules (which it apparently does with RTLD_LAZY), we will\n    // die in a name lookup since one of perl's symbols isn't found. That's\n    // worse than any theoretical issue with RTLD_GLOBAL.\n    ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_GLOBAL);\n\n    if (!p) {\n        // dlerror() returns pointer to static buffer, which may be overwritten\n        // very soon with another dl call also it may just return null.\n        const char* cDlError = dlerror();\n        CString sDlError = cDlError ? cDlError : t_s(\"Unknown error\");\n        sRetMsg = t_f(\"Unable to open module {1}: {2}\")(sModule, sDlError);\n        return nullptr;\n    }\n\n    const CModuleEntry* (*fpZNCModuleEntry)() = nullptr;\n    // man dlsym(3) explains this\n    *reinterpret_cast<void**>(&fpZNCModuleEntry) = dlsym(p, \"ZNCModuleEntry\");\n    if (!fpZNCModuleEntry) {\n        dlclose(p);\n        sRetMsg = t_f(\"Could not find ZNCModuleEntry in module {1}\")(sModule);\n        return nullptr;\n    }\n    const CModuleEntry* pModuleEntry = fpZNCModuleEntry();\n\n    if (std::strcmp(pModuleEntry->pcVersion, VERSION_STR) ||\n        std::strcmp(pModuleEntry->pcVersionExtra, VERSION_EXTRA)) {\n        sRetMsg = t_f(\n            \"Version mismatch for module {1}: core is {2}, module is built for \"\n            \"{3}. Recompile this module.\")(\n            sModule, VERSION_STR VERSION_EXTRA,\n            CString(pModuleEntry->pcVersion) + pModuleEntry->pcVersionExtra);\n        dlclose(p);\n        return nullptr;\n    }\n\n    if (std::strcmp(pModuleEntry->pcCompileOptions,\n                    ZNC_COMPILE_OPTIONS_STRING)) {\n        sRetMsg = t_f(\n            \"Module {1} is built incompatibly: core is '{2}', module is '{3}'. \"\n            \"Recompile this module.\")(sModule, ZNC_COMPILE_OPTIONS_STRING,\n                                      pModuleEntry->pcCompileOptions);\n        dlclose(p);\n        return nullptr;\n    }\n\n    CTranslationDomainRefHolder translation(\"znc-\" + sModule);\n    pModuleEntry->fpFillModInfo(Info);\n\n    sRetMsg = \"\";\n    return p;\n}\n\nCModCommand::CModCommand()\n    : m_sCmd(), m_pFunc(nullptr), m_Args(\"\"), m_Desc(\"\") {}\n\nCModCommand::CModCommand(const CString& sCmd, CModule* pMod, ModCmdFunc func,\n                         const CString& sArgs, const CString& sDesc)\n    : m_sCmd(sCmd),\n      m_pFunc([pMod, func](const CString& sLine) { (pMod->*func)(sLine); }),\n      m_Args(sArgs),\n      m_Desc(sDesc) {}\n\nCModCommand::CModCommand(const CString& sCmd, CmdFunc func,\n                         const COptionalTranslation& Args,\n                         const COptionalTranslation& Desc)\n    : m_sCmd(sCmd), m_pFunc(std::move(func)), m_Args(Args), m_Desc(Desc) {}\n\nvoid CModCommand::InitHelp(CTable& Table) {\n    Table.AddColumn(t_s(\"Command\", \"modhelpcmd\"));\n    Table.AddColumn(t_s(\"Description\", \"modhelpcmd\"));\n}\n\nvoid CModCommand::AddHelp(CTable& Table) const {\n    Table.AddRow();\n    Table.SetCell(t_s(\"Command\", \"modhelpcmd\"), GetCommand() + \" \" + GetArgs());\n    Table.SetCell(t_s(\"Description\", \"modhelpcmd\"), GetDescription());\n}\n\nCString CModule::t_s(const CString& sEnglish, const CString& sContext) const {\n    return CTranslation::Get().Singular(\"znc-\" + GetModName(), sContext,\n                                        sEnglish);\n}\n\nCInlineFormatMessage CModule::t_f(const CString& sEnglish,\n                                  const CString& sContext) const {\n    return CInlineFormatMessage(t_s(sEnglish, sContext));\n}\n\nCInlineFormatMessage CModule::t_p(const CString& sEnglish,\n                                  const CString& sEnglishes, int iNum,\n                                  const CString& sContext) const {\n    return CInlineFormatMessage(CTranslation::Get().Plural(\n        \"znc-\" + GetModName(), sContext, sEnglish, sEnglishes, iNum));\n}\n\nCDelayedTranslation CModule::t_d(const CString& sEnglish,\n                                 const CString& sContext) const {\n    return CDelayedTranslation(\"znc-\" + GetModName(), sContext, sEnglish);\n}\n\nCString CModInfo::t_s(const CString& sEnglish, const CString& sContext) const {\n    return CTranslation::Get().Singular(\"znc-\" + GetName(), sContext, sEnglish);\n}\n"], "filenames": ["include/znc/Modules.h", "src/Modules.cpp"], "buggy_code_start_loc": [1602, 1626], "buggy_code_end_loc": [1602, 1923], "fixing_code_start_loc": [1603, 1627], "fixing_code_end_loc": [1604, 1943], "type": "CWE-20", "message": "Modules.cpp in ZNC before 1.7.4-rc1 allows remote authenticated non-admin users to escalate privileges and execute arbitrary code by loading a module with a crafted name.", "other": {"cve": {"id": "CVE-2019-12816", "sourceIdentifier": "cve@mitre.org", "published": "2019-06-15T16:29:00.210", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Modules.cpp in ZNC before 1.7.4-rc1 allows remote authenticated non-admin users to escalate privileges and execute arbitrary code by loading a module with a crafted name."}, {"lang": "es", "value": "El archivo Modules.cpp en ZNC anterior a versi\u00f3n 1.7.4-rc1 permite a los usuarios remotos no administradores y autenticados, escalar privilegios y ejecutar c\u00f3digo arbitrario mediante la carga de un m\u00f3dulo con un nombre creado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:znc:znc:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.7.3", "matchCriteriaId": "CB7DA41D-1A52-4F99-ACC0-422F16796399"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00037.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00018.html", "source": "cve@mitre.org"}, {"url": "https://github.com/znc/znc/commit/8de9e376ce531fe7f3c8b0aa4876d15b479b7311", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/znc/znc/compare/be1b6bc...d1997d6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/06/msg00017.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4O24TQOB73X57GACLZVMRVUK4UKHLE5G/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NHR6OD52FQAG5ZPZ42NJM2T765C3V2XC/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TEESIGRNFLZUWXZPDGXAZ7JZTHYBDJ7G/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Jun/23", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201908-15", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4044-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/znc/znc/commit/8de9e376ce531fe7f3c8b0aa4876d15b479b7311"}}