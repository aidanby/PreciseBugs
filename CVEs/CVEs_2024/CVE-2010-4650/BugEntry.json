{"buggy_code": ["/*\n  FUSE: Filesystem in Userspace\n  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>\n\n  This program can be distributed under the terms of the GNU GPL.\n  See the file COPYING.\n*/\n\n#include \"fuse_i.h\"\n\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n\nstatic const struct file_operations fuse_direct_io_file_operations;\n\nstatic int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tstruct fuse_req *req;\n\tint err;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(*outargp);\n\treq->out.args[0].value = outargp;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}\n\nstruct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc();\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}\n\nstatic void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tpath_put(&req->misc.release.path);\n}\n\nstatic void fuse_file_put(struct fuse_file *ff)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\treq->end = fuse_release_end;\n\t\tfuse_request_send_background(ff->fc, req);\n\t\tkfree(ff);\n\t}\n}\n\nint fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_open_out outarg;\n\tstruct fuse_file *ff;\n\tint err;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\tif (err) {\n\t\tfuse_file_free(ff);\n\t\treturn err;\n\t}\n\n\tif (isdir)\n\t\toutarg.open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->fh = outarg.fh;\n\tff->nodeid = nodeid;\n\tff->open_flags = outarg.open_flags;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fuse_do_open);\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t}\n}\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\t/* VFS checks this, but only _after_ ->open() */\n\tif (file->f_flags & O_DIRECT)\n\t\treturn -EINVAL;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\tif (err)\n\t\treturn err;\n\n\tfuse_finish_open(inode, file);\n\n\treturn 0;\n}\n\nstatic void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_sync(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}\n\nvoid fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\t/* Hold vfsmount and dentry until release is finished */\n\tpath_get(&file->f_path);\n\treq->misc.release.path = file->f_path;\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t */\n\tfuse_file_put(ff);\n}\n\nstatic int fuse_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, false);\n}\n\nstatic int fuse_release(struct inode *inode, struct file *file)\n{\n\tfuse_release_common(file, FUSE_RELEASE);\n\n\t/* return value is ignored by VFS */\n\treturn 0;\n}\n\nvoid fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}\nEXPORT_SYMBOL_GPL(fuse_sync_release);\n\n/*\n * Scramble the ID space with XTEA, so that the value of the files_struct\n * pointer is not exposed to userspace.\n */\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}\n\n/*\n * Check if page is under writeback\n *\n * This is currently done by walking the list of writepage requests\n * for the inode, which can be pretty inefficient.\n */\nstatic bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index == index) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}\n\n/*\n * Wait for page writeback to be completed.\n *\n * Since fuse doesn't rely on the VM writeback tracking, this has to\n * use some other means.\n */\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}\n\nstatic int fuse_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_flush_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_flush)\n\t\treturn 0;\n\n\treq = fuse_get_req_nofail(fc, file);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fc, id);\n\treq->in.h.opcode = FUSE_FLUSH;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->force = 1;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tfc->no_flush = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\n/*\n * Wait for all pending writepages on the inode to finish.\n *\n * This is currently done by blocking further writes with FUSE_NOWRITE\n * and waiting for all sent writes to complete.\n *\n * This must be called under i_mutex, otherwise the FUSE_NOWRITE usage\n * could conflict with truncation.\n */\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}\n\nint fuse_fsync_common(struct file *file, int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\treturn 0;\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = write_inode_now(inode, 0);\n\tif (err)\n\t\treturn err;\n\n\tfuse_sync_writes(inode);\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\treq->in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int fuse_fsync(struct file *file, int datasync)\n{\n\treturn fuse_fsync_common(file, datasync, 0);\n}\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}\n\nstatic size_t fuse_send_read(struct fuse_req *req, struct file *file,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}\n\nstatic void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nstatic int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\t/*\n\t * Page writeback can extend beyond the liftime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc);\n\terr = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\tnum_read = fuse_send_read(req, file, pos, count, NULL);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_read_update_size(inode, pos + num_read, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_invalidate_attr(inode); /* atime changed */\n out:\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count) {\n\t\t\tloff_t pos;\n\n\t\t\tpos = page_offset(req->pages[0]) + num_read;\n\t\t\tfuse_read_update_size(inode, pos,\n\t\t\t\t\t      req->misc.read.attr_ver);\n\t\t}\n\t\tfuse_invalidate_attr(inode); /* atime changed */\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff);\n}\n\nstatic void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}\n\nstruct fuse_fill_data {\n\tstruct fuse_req *req;\n\tstruct file *file;\n\tstruct inode *inode;\n};\n\nstatic int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_send_readpages(req, data->file);\n\t\tdata->req = req = fuse_get_req(fc);\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->num_pages++;\n\treturn 0;\n}\n\nstatic int fuse_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.file = file;\n\tdata.inode = inode;\n\tdata.req = fuse_get_req(fc);\n\terr = PTR_ERR(data.req);\n\tif (IS_ERR(data.req))\n\t\tgoto out;\n\n\terr = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);\n\tif (!err) {\n\t\tif (data.req->num_pages)\n\t\t\tfuse_send_readpages(data.req, file);\n\t\telse\n\t\t\tfuse_put_request(fc, data.req);\n\t}\nout:\n\treturn err;\n}\n\nstatic ssize_t fuse_file_aio_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t\t  unsigned long nr_segs, loff_t pos)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\n\tif (pos + iov_length(iov, nr_segs) > i_size_read(inode)) {\n\t\tint err;\n\t\t/*\n\t\t * If trying to read past EOF, make sure the i_size\n\t\t * attribute is up-to-date.\n\t\t */\n\t\terr = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_aio_read(iocb, iov, nr_segs, pos);\n}\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}\n\nstatic size_t fuse_send_write(struct fuse_req *req, struct file *file,\n\t\t\t      loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tfuse_write_fill(req, ff, pos, count);\n\tinarg->flags = file->f_flags;\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\tfuse_request_send(fc, req);\n\treturn req->misc.write.out.size;\n}\n\nstatic int fuse_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\n\t*pagep = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!*pagep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size)\n\t\ti_size_write(inode, pos);\n\tspin_unlock(&fc->lock);\n}\n\nstatic int fuse_buffered_write(struct file *file, struct inode *inode,\n\t\t\t       loff_t pos, unsigned count, struct page *page)\n{\n\tint err;\n\tsize_t nres;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct fuse_req *req;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/*\n\t * Make sure writepages on the same page are not mixed up with\n\t * plain writes.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_offset = offset;\n\tnres = fuse_send_write(req, file, pos, count, NULL);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (!err && !nres)\n\t\terr = -EIO;\n\tif (!err) {\n\t\tpos += nres;\n\t\tfuse_write_update_size(inode, pos);\n\t\tif (count == PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\t}\n\tfuse_invalidate_attr(inode);\n\treturn err ? err : nres;\n}\n\nstatic int fuse_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint res = 0;\n\n\tif (copied)\n\t\tres = fuse_buffered_write(file, inode, pos, copied, page);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn res;\n}\n\nstatic size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, file, pos, count, NULL);\n\n\toffset = req->page_offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}\n\nstatic ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tpagefault_disable();\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < FUSE_MAX_PAGES_PER_REQ && offset == 0);\n\n\treturn count > 0 ? count : err;\n}\n\nstatic ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\n\t\treq = fuse_get_req(fc);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}\n\nstatic ssize_t fuse_file_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t\t   unsigned long nr_segs, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tsize_t count = 0;\n\tssize_t written = 0;\n\tstruct inode *inode = mapping->host;\n\tssize_t err;\n\tstruct iov_iter i;\n\n\tWARN_ON(iocb->ki_pos != pos);\n\n\terr = generic_segment_checks(iov, &nr_segs, &count, VERIFY_READ);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tvfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = mapping->backing_dev_info;\n\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\n\tfile_update_time(file);\n\n\tiov_iter_init(&i, iov, nr_segs, count, 0);\n\twritten = fuse_perform_write(file, mapping, &i, pos);\n\tif (written >= 0)\n\t\tiocb->ki_pos = pos + written;\n\nout:\n\tcurrent->backing_dev_info = NULL;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn written ? written : err;\n}\n\nstatic void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}\n\nstatic int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = *nbytesp;\n\tunsigned long user_addr = (unsigned long) buf;\n\tunsigned offset = user_addr & ~PAGE_MASK;\n\tint npages;\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\treturn 0;\n\t}\n\n\tnbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n\tnpages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnpages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);\n\tnpages = get_user_pages_fast(user_addr, npages, !write, req->pages);\n\tif (npages < 0)\n\t\treturn npages;\n\n\treq->num_pages = npages;\n\treq->page_offset = offset;\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\tnbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;\n\t*nbytesp = min(*nbytesp, nbytes);\n\n\treturn 0;\n}\n\nssize_t fuse_direct_io(struct file *file, const char __user *buf,\n\t\t       size_t count, loff_t *ppos, int write)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, buf, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, file, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, file, pos, nbytes, owner);\n\n\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tbuf += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\treq = fuse_get_req(fc);\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(fuse_direct_io);\n\nstatic ssize_t fuse_direct_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tssize_t res;\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(file, buf, count, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}\n\nstatic ssize_t fuse_direct_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tssize_t res;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/* Don't allow parallel writes to the same file */\n\tmutex_lock(&inode->i_mutex);\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tres = fuse_direct_io(file, buf, count, ppos, 1);\n\t\tif (res > 0)\n\t\t\tfuse_write_update_size(inode, *ppos);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\t__free_page(req->pages[0]);\n\tfuse_file_put(req->ff);\n}\n\nstatic void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode->i_mapping->backing_dev_info;\n\n\tlist_del(&req->writepages_entry);\n\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\tdec_zone_page_state(req->pages[0], NR_WRITEBACK_TEMP);\n\tbdi_writeout_inc(bdi);\n\twake_up(&fi->page_waitq);\n}\n\n/* Called under fc->lock, may release and reacquire it */\nstatic void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tloff_t size = i_size_read(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + PAGE_CACHE_SIZE <= size) {\n\t\tinarg->size = PAGE_CACHE_SIZE;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size & (PAGE_CACHE_SIZE - 1);\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}\n\n/*\n * If fi->writectr is positive (no truncate or fsync going on) send\n * all queued writepage requests.\n *\n * Called with fc->lock\n */\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req);\n\t}\n}\n\nstatic void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tmapping_set_error(inode->i_mapping, req->out.h.error);\n\tspin_lock(&fc->lock);\n\tfi->writectr--;\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n}\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_file *ff;\n\tstruct page *tmp_page;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs();\n\tif (!req)\n\t\tgoto err;\n\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(list_empty(&fi->write_files));\n\tff = list_entry(fi->write_files.next, struct fuse_file, write_entry);\n\treq->ff = fuse_file_get(ff);\n\tspin_unlock(&fc->lock);\n\n\tfuse_write_fill(req, ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_offset = 0;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(mapping->backing_dev_info, BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\tend_page_writeback(page);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\treturn 0;\n\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn -ENOMEM;\n}\n\nstatic int fuse_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\n\terr = fuse_writepage_locked(page);\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstatic int fuse_launder_page(struct page *page)\n{\n\tint err = 0;\n\tif (clear_page_dirty_for_io(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\terr = fuse_writepage_locked(page);\n\t\tif (!err)\n\t\t\tfuse_wait_on_page_writeback(inode, page->index);\n\t}\n\treturn err;\n}\n\n/*\n * Write back dirty pages now, because there may not be any suitable\n * open files later\n */\nstatic void fuse_vma_close(struct vm_area_struct *vma)\n{\n\tfilemap_write_and_wait(vma->vm_file->f_mapping);\n}\n\n/*\n * Wait for writeback against this page to complete before allowing it\n * to be marked dirty again, and hence written back again, possibly\n * before the previous writepage completed.\n *\n * Block here, instead of in ->writepage(), so that the userspace fs\n * can only block processes actually operating on the filesystem.\n *\n * Otherwise unprivileged userspace fs would be able to block\n * unrelated:\n *\n * - page migration\n * - sync(2)\n * - try_to_free_pages() with order > PAGE_ALLOC_COSTLY_ORDER\n */\nstatic int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\t/*\n\t * Don't use page->mapping as it may become NULL from a\n\t * concurrent truncate.\n\t */\n\tstruct inode *inode = vma->vm_file->f_mapping->host;\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct fuse_file_vm_ops = {\n\t.close\t\t= fuse_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.page_mkwrite\t= fuse_page_mkwrite,\n};\n\nstatic int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE)) {\n\t\tstruct inode *inode = file->f_dentry->d_inode;\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\t\tstruct fuse_file *ff = file->private_data;\n\t\t/*\n\t\t * file may be written through mmap, so chain it onto the\n\t\t * inodes's write_file list\n\t\t */\n\t\tspin_lock(&fc->lock);\n\t\tif (list_empty(&ff->write_entry))\n\t\t\tlist_add(&ff->write_entry, &fi->write_files);\n\t\tspin_unlock(&fc->lock);\n\t}\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}\n\nstatic int fuse_direct_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\t/* Can't provide the coherency needed for MAP_SHARED */\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn -ENODEV;\n\n\tinvalidate_inode_pages2(file->f_mapping);\n\n\treturn generic_file_mmap(file, vma);\n}\n\nstatic int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}\n\nstatic void fuse_lk_fill(struct fuse_req *req, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_lk_in *arg = &req->misc.lk_in;\n\n\targ->fh = ff->fh;\n\targ->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\targ->lk.start = fl->fl_start;\n\targ->lk.end = fl->fl_end;\n\targ->lk.type = fl->fl_type;\n\targ->lk.pid = pid;\n\tif (flock)\n\t\targ->lk_flags |= FUSE_LK_FLOCK;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(*arg);\n\treq->in.args[0].value = arg;\n}\n\nstatic int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tfuse_lk_fill(req, file, fl, FUSE_GETLK, 0, 0);\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->fl_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tfuse_lk_fill(req, file, fl, opcode, pid, flock);\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\tfuse_put_request(fc, req);\n\treturn err;\n}\n\nstatic int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (cmd == F_CANCELLK) {\n\t\terr = 0;\n\t} else if (cmd == F_GETLK) {\n\t\tif (fc->no_lock) {\n\t\t\tposix_test_lock(file, fl);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = fuse_getlk(file, fl);\n\t} else {\n\t\tif (fc->no_lock)\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\telse\n\t\t\terr = fuse_setlk(file, fl, 0);\n\t}\n\treturn err;\n}\n\nstatic int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fc->no_lock) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t} else {\n\t\t/* emulate flock with POSIX locks */\n\t\tfl->fl_owner = (fl_owner_t) file;\n\t\terr = fuse_setlk(file, fl, 1);\n\t}\n\n\treturn err;\n}\n\nstatic sector_t fuse_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_bmap_in inarg;\n\tstruct fuse_bmap_out outarg;\n\tint err;\n\n\tif (!inode->i_sb->s_bdev || fc->no_bmap)\n\t\treturn 0;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.block = block;\n\tinarg.blocksize = inode->i_sb->s_blocksize;\n\treq->in.h.opcode = FUSE_BMAP;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS)\n\t\tfc->no_bmap = 1;\n\n\treturn err ? 0 : outarg.block;\n}\n\nstatic loff_t fuse_file_llseek(struct file *file, loff_t offset, int origin)\n{\n\tloff_t retval;\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (origin) {\n\tcase SEEK_END:\n\t\tretval = fuse_update_attributes(inode, NULL, file, NULL);\n\t\tif (retval)\n\t\t\tgoto exit;\n\t\toffset += i_size_read(inode);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 && offset <= inode->i_sb->s_maxbytes) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nexit:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}\n\nstatic int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, iov, nr_segs, bytes, 0);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}\n\n/*\n * CUSE servers compiled on 32bit broke on 64bit kernels because the\n * ABI was defined to be 'struct iovec' which is different on 32bit\n * and 64bit.  Fortunately we can determine which structure the server\n * used from the size of the reply.\n */\nstatic int fuse_copy_ioctl_iovec(struct iovec *dst, void *src,\n\t\t\t\t size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}\n\n/*\n * For ioctls, there is no generic way to determine how much memory\n * needs to be read and/or written.  Furthermore, ioctls are allowed\n * to dereference the passed pointer, so the parameter requires deep\n * copying but FUSE has no idea whatsoever about what to copy in or\n * out.\n *\n * This is solved by allowing FUSE server to retry ioctl with\n * necessary in/out iovecs.  Let's assume the ioctl implementation\n * needs to read in the following structure.\n *\n * struct a {\n *\tchar\t*buf;\n *\tsize_t\tbuflen;\n * }\n *\n * On the first callout to FUSE server, inarg->in_size and\n * inarg->out_size will be NULL; then, the server completes the ioctl\n * with FUSE_IOCTL_RETRY set in out->flags, out->in_iovs set to 1 and\n * the actual iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a) } }\n *\n * which tells FUSE to copy in the requested area and retry the ioctl.\n * On the second round, the server has access to the structure and\n * from that it can tell what to look for next, so on the invocation,\n * it sets FUSE_IOCTL_RETRY, out->in_iovs to 2 and iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a)\t},\n *   { .iov_base = a.buf,\t.iov_len = a.buflen\t\t} }\n *\n * FUSE will copy both struct a and the pointed buffer from the\n * process doing the ioctl and retry ioctl with both struct a and the\n * buffer.\n *\n * This time, FUSE server has everything it needs and completes ioctl\n * without FUSE_IOCTL_RETRY which finishes the ioctl call.\n *\n * Copying data out works the same way.\n *\n * Note that if FUSE_IOCTL_UNRESTRICTED is clear, the kernel\n * automatically initializes in and out iovs by decoding @cmd with\n * _IOC_* macros and the server is not allowed to request RETRY.  This\n * limits ioctl data transfers to well-formed ioctls and is the forced\n * behavior for all FUSE servers.\n */\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = page_address(iov_page);\n\t\tout_iov = in_iov + in_iovs;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\nEXPORT_SYMBOL_GPL(fuse_do_ioctl);\n\nstatic long fuse_file_ioctl_common(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file->f_dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_task(fc, current))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic long fuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn fuse_file_ioctl_common(file, cmd, arg, 0);\n}\n\nstatic long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\treturn fuse_file_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);\n}\n\n/*\n * All files which have been polled are linked to RB tree\n * fuse_conn->polled_files which is indexed by kh.  Walk the tree and\n * find the matching one.\n */\nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}\n\n/*\n * The file is about to be polled.  Make sure it's on the polled_files\n * RB tree.  Note that files once added to the polled_files tree are\n * not removed before the file is released.  This is because a file\n * polled once is likely to be polled again.\n */\nstatic void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *parent;\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nunsigned fuse_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };\n\tstruct fuse_poll_out outarg;\n\tstruct fuse_req *req;\n\tint err;\n\n\tif (fc->no_poll)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(file, &ff->poll_wait, wait);\n\n\t/*\n\t * Ask for notification iff there's someone waiting for it.\n\t * The client may ignore the flag and always notify.\n\t */\n\tif (waitqueue_active(&ff->poll_wait)) {\n\t\tinarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;\n\t\tfuse_register_polled_file(fc, ff);\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn POLLERR;\n\n\treq->in.h.opcode = FUSE_POLL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\n\tif (!err)\n\t\treturn outarg.revents;\n\tif (err == -ENOSYS) {\n\t\tfc->no_poll = 1;\n\t\treturn DEFAULT_POLLMASK;\n\t}\n\treturn POLLERR;\n}\nEXPORT_SYMBOL_GPL(fuse_file_poll);\n\n/*\n * This is called from fuse_handle_notify() on FUSE_NOTIFY_POLL and\n * wakes up the poll waiters.\n */\nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= do_sync_read,\n\t.aio_read\t= fuse_file_aio_read,\n\t.write\t\t= do_sync_write,\n\t.aio_write\t= fuse_file_aio_write,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n};\n\nstatic const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t/* no splice_read */\n};\n\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.launder_page\t= fuse_launder_page,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}\n"], "fixing_code": ["/*\n  FUSE: Filesystem in Userspace\n  Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>\n\n  This program can be distributed under the terms of the GNU GPL.\n  See the file COPYING.\n*/\n\n#include \"fuse_i.h\"\n\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n\nstatic const struct file_operations fuse_direct_io_file_operations;\n\nstatic int fuse_send_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t\t  int opcode, struct fuse_open_out *outargp)\n{\n\tstruct fuse_open_in inarg;\n\tstruct fuse_req *req;\n\tint err;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.flags = file->f_flags & ~(O_CREAT | O_EXCL | O_NOCTTY);\n\tif (!fc->atomic_o_trunc)\n\t\tinarg.flags &= ~O_TRUNC;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(*outargp);\n\treq->out.args[0].value = outargp;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\n\treturn err;\n}\n\nstruct fuse_file *fuse_file_alloc(struct fuse_conn *fc)\n{\n\tstruct fuse_file *ff;\n\n\tff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);\n\tif (unlikely(!ff))\n\t\treturn NULL;\n\n\tff->fc = fc;\n\tff->reserved_req = fuse_request_alloc();\n\tif (unlikely(!ff->reserved_req)) {\n\t\tkfree(ff);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&ff->write_entry);\n\tatomic_set(&ff->count, 0);\n\tRB_CLEAR_NODE(&ff->polled_node);\n\tinit_waitqueue_head(&ff->poll_wait);\n\n\tspin_lock(&fc->lock);\n\tff->kh = ++fc->khctr;\n\tspin_unlock(&fc->lock);\n\n\treturn ff;\n}\n\nvoid fuse_file_free(struct fuse_file *ff)\n{\n\tfuse_request_free(ff->reserved_req);\n\tkfree(ff);\n}\n\nstruct fuse_file *fuse_file_get(struct fuse_file *ff)\n{\n\tatomic_inc(&ff->count);\n\treturn ff;\n}\n\nstatic void fuse_release_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tpath_put(&req->misc.release.path);\n}\n\nstatic void fuse_file_put(struct fuse_file *ff)\n{\n\tif (atomic_dec_and_test(&ff->count)) {\n\t\tstruct fuse_req *req = ff->reserved_req;\n\n\t\treq->end = fuse_release_end;\n\t\tfuse_request_send_background(ff->fc, req);\n\t\tkfree(ff);\n\t}\n}\n\nint fuse_do_open(struct fuse_conn *fc, u64 nodeid, struct file *file,\n\t\t bool isdir)\n{\n\tstruct fuse_open_out outarg;\n\tstruct fuse_file *ff;\n\tint err;\n\tint opcode = isdir ? FUSE_OPENDIR : FUSE_OPEN;\n\n\tff = fuse_file_alloc(fc);\n\tif (!ff)\n\t\treturn -ENOMEM;\n\n\terr = fuse_send_open(fc, nodeid, file, opcode, &outarg);\n\tif (err) {\n\t\tfuse_file_free(ff);\n\t\treturn err;\n\t}\n\n\tif (isdir)\n\t\toutarg.open_flags &= ~FOPEN_DIRECT_IO;\n\n\tff->fh = outarg.fh;\n\tff->nodeid = nodeid;\n\tff->open_flags = outarg.open_flags;\n\tfile->private_data = fuse_file_get(ff);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fuse_do_open);\n\nvoid fuse_finish_open(struct inode *inode, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (ff->open_flags & FOPEN_DIRECT_IO)\n\t\tfile->f_op = &fuse_direct_io_file_operations;\n\tif (!(ff->open_flags & FOPEN_KEEP_CACHE))\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\tif (ff->open_flags & FOPEN_NONSEEKABLE)\n\t\tnonseekable_open(inode, file);\n\tif (fc->atomic_o_trunc && (file->f_flags & O_TRUNC)) {\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\t\tspin_lock(&fc->lock);\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, 0);\n\t\tspin_unlock(&fc->lock);\n\t\tfuse_invalidate_attr(inode);\n\t}\n}\n\nint fuse_open_common(struct inode *inode, struct file *file, bool isdir)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\t/* VFS checks this, but only _after_ ->open() */\n\tif (file->f_flags & O_DIRECT)\n\t\treturn -EINVAL;\n\n\terr = generic_file_open(inode, file);\n\tif (err)\n\t\treturn err;\n\n\terr = fuse_do_open(fc, get_node_id(inode), file, isdir);\n\tif (err)\n\t\treturn err;\n\n\tfuse_finish_open(inode, file);\n\n\treturn 0;\n}\n\nstatic void fuse_prepare_release(struct fuse_file *ff, int flags, int opcode)\n{\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_req *req = ff->reserved_req;\n\tstruct fuse_release_in *inarg = &req->misc.release.in;\n\n\tspin_lock(&fc->lock);\n\tlist_del(&ff->write_entry);\n\tif (!RB_EMPTY_NODE(&ff->polled_node))\n\t\trb_erase(&ff->polled_node, &fc->polled_files);\n\tspin_unlock(&fc->lock);\n\n\twake_up_interruptible_sync(&ff->poll_wait);\n\n\tinarg->fh = ff->fh;\n\tinarg->flags = flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_release_in);\n\treq->in.args[0].value = inarg;\n}\n\nvoid fuse_release_common(struct file *file, int opcode)\n{\n\tstruct fuse_file *ff;\n\tstruct fuse_req *req;\n\n\tff = file->private_data;\n\tif (unlikely(!ff))\n\t\treturn;\n\n\treq = ff->reserved_req;\n\tfuse_prepare_release(ff, file->f_flags, opcode);\n\n\t/* Hold vfsmount and dentry until release is finished */\n\tpath_get(&file->f_path);\n\treq->misc.release.path = file->f_path;\n\n\t/*\n\t * Normally this will send the RELEASE request, however if\n\t * some asynchronous READ or WRITE requests are outstanding,\n\t * the sending will be delayed.\n\t */\n\tfuse_file_put(ff);\n}\n\nstatic int fuse_open(struct inode *inode, struct file *file)\n{\n\treturn fuse_open_common(inode, file, false);\n}\n\nstatic int fuse_release(struct inode *inode, struct file *file)\n{\n\tfuse_release_common(file, FUSE_RELEASE);\n\n\t/* return value is ignored by VFS */\n\treturn 0;\n}\n\nvoid fuse_sync_release(struct fuse_file *ff, int flags)\n{\n\tWARN_ON(atomic_read(&ff->count) > 1);\n\tfuse_prepare_release(ff, flags, FUSE_RELEASE);\n\tff->reserved_req->force = 1;\n\tfuse_request_send(ff->fc, ff->reserved_req);\n\tfuse_put_request(ff->fc, ff->reserved_req);\n\tkfree(ff);\n}\nEXPORT_SYMBOL_GPL(fuse_sync_release);\n\n/*\n * Scramble the ID space with XTEA, so that the value of the files_struct\n * pointer is not exposed to userspace.\n */\nu64 fuse_lock_owner_id(struct fuse_conn *fc, fl_owner_t id)\n{\n\tu32 *k = fc->scramble_key;\n\tu64 v = (unsigned long) id;\n\tu32 v0 = v;\n\tu32 v1 = v >> 32;\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tv0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + k[sum & 3]);\n\t\tsum += 0x9E3779B9;\n\t\tv1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + k[sum>>11 & 3]);\n\t}\n\n\treturn (u64) v0 + ((u64) v1 << 32);\n}\n\n/*\n * Check if page is under writeback\n *\n * This is currently done by walking the list of writepage requests\n * for the inode, which can be pretty inefficient.\n */\nstatic bool fuse_page_is_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tbool found = false;\n\n\tspin_lock(&fc->lock);\n\tlist_for_each_entry(req, &fi->writepages, writepages_entry) {\n\t\tpgoff_t curr_index;\n\n\t\tBUG_ON(req->inode != inode);\n\t\tcurr_index = req->misc.write.in.offset >> PAGE_CACHE_SHIFT;\n\t\tif (curr_index == index) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fc->lock);\n\n\treturn found;\n}\n\n/*\n * Wait for page writeback to be completed.\n *\n * Since fuse doesn't rely on the VM writeback tracking, this has to\n * use some other means.\n */\nstatic int fuse_wait_on_page_writeback(struct inode *inode, pgoff_t index)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\twait_event(fi->page_waitq, !fuse_page_is_writeback(inode, index));\n\treturn 0;\n}\n\nstatic int fuse_flush(struct file *file, fl_owner_t id)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_flush_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif (fc->no_flush)\n\t\treturn 0;\n\n\treq = fuse_get_req_nofail(fc, file);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.lock_owner = fuse_lock_owner_id(fc, id);\n\treq->in.h.opcode = FUSE_FLUSH;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->force = 1;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tfc->no_flush = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\n/*\n * Wait for all pending writepages on the inode to finish.\n *\n * This is currently done by blocking further writes with FUSE_NOWRITE\n * and waiting for all sent writes to complete.\n *\n * This must be called under i_mutex, otherwise the FUSE_NOWRITE usage\n * could conflict with truncation.\n */\nstatic void fuse_sync_writes(struct inode *inode)\n{\n\tfuse_set_nowrite(inode);\n\tfuse_release_nowrite(inode);\n}\n\nint fuse_fsync_common(struct file *file, int datasync, int isdir)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_req *req;\n\tstruct fuse_fsync_in inarg;\n\tint err;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tif ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))\n\t\treturn 0;\n\n\t/*\n\t * Start writeback against all dirty pages of the inode, then\n\t * wait for all outstanding writes, before sending the FSYNC\n\t * request.\n\t */\n\terr = write_inode_now(inode, 0);\n\tif (err)\n\t\treturn err;\n\n\tfuse_sync_writes(inode);\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.fh = ff->fh;\n\tinarg.fsync_flags = datasync ? 1 : 0;\n\treq->in.h.opcode = isdir ? FUSE_FSYNCDIR : FUSE_FSYNC;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS) {\n\t\tif (isdir)\n\t\t\tfc->no_fsyncdir = 1;\n\t\telse\n\t\t\tfc->no_fsync = 1;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int fuse_fsync(struct file *file, int datasync)\n{\n\treturn fuse_fsync_common(file, datasync, 0);\n}\n\nvoid fuse_read_fill(struct fuse_req *req, struct file *file, loff_t pos,\n\t\t    size_t count, int opcode)\n{\n\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\tstruct fuse_file *ff = file->private_data;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\tinarg->flags = file->f_flags;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(struct fuse_read_in);\n\treq->in.args[0].value = inarg;\n\treq->out.argvar = 1;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = count;\n}\n\nstatic size_t fuse_send_read(struct fuse_req *req, struct file *file,\n\t\t\t     loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\tif (owner != NULL) {\n\t\tstruct fuse_read_in *inarg = &req->misc.read.in;\n\n\t\tinarg->read_flags |= FUSE_READ_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\tfuse_request_send(fc, req);\n\treturn req->out.args[0].size;\n}\n\nstatic void fuse_read_update_size(struct inode *inode, loff_t size,\n\t\t\t\t  u64 attr_ver)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tif (attr_ver == fi->attr_version && size < inode->i_size) {\n\t\tfi->attr_version = ++fc->attr_version;\n\t\ti_size_write(inode, size);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nstatic int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\t/*\n\t * Page writeback can extend beyond the liftime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc);\n\terr = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\tnum_read = fuse_send_read(req, file, pos, count, NULL);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_read_update_size(inode, pos + num_read, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_invalidate_attr(inode); /* atime changed */\n out:\n\tunlock_page(page);\n\treturn err;\n}\n\nstatic void fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tint i;\n\tsize_t count = req->misc.read.in.size;\n\tsize_t num_read = req->out.args[0].size;\n\tstruct address_space *mapping = NULL;\n\n\tfor (i = 0; mapping == NULL && i < req->num_pages; i++)\n\t\tmapping = req->pages[i]->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\n\t\t/*\n\t\t * Short read means EOF. If file size is larger, truncate it\n\t\t */\n\t\tif (!req->out.h.error && num_read < count) {\n\t\t\tloff_t pos;\n\n\t\t\tpos = page_offset(req->pages[0]) + num_read;\n\t\t\tfuse_read_update_size(inode, pos,\n\t\t\t\t\t      req->misc.read.attr_ver);\n\t\t}\n\t\tfuse_invalidate_attr(inode); /* atime changed */\n\t}\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (!req->out.h.error)\n\t\t\tSetPageUptodate(page);\n\t\telse\n\t\t\tSetPageError(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tif (req->ff)\n\t\tfuse_file_put(req->ff);\n}\n\nstatic void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\treq->out.page_replace = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}\n\nstruct fuse_fill_data {\n\tstruct fuse_req *req;\n\tstruct file *file;\n\tstruct inode *inode;\n};\n\nstatic int fuse_readpages_fill(void *_data, struct page *page)\n{\n\tstruct fuse_fill_data *data = _data;\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\tif (req->num_pages &&\n\t    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||\n\t     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||\n\t     req->pages[req->num_pages - 1]->index + 1 != page->index)) {\n\t\tfuse_send_readpages(req, data->file);\n\t\tdata->req = req = fuse_get_req(fc);\n\t\tif (IS_ERR(req)) {\n\t\t\tunlock_page(page);\n\t\t\treturn PTR_ERR(req);\n\t\t}\n\t}\n\tpage_cache_get(page);\n\treq->pages[req->num_pages] = page;\n\treq->num_pages++;\n\treturn 0;\n}\n\nstatic int fuse_readpages(struct file *file, struct address_space *mapping,\n\t\t\t  struct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_fill_data data;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\tdata.file = file;\n\tdata.inode = inode;\n\tdata.req = fuse_get_req(fc);\n\terr = PTR_ERR(data.req);\n\tif (IS_ERR(data.req))\n\t\tgoto out;\n\n\terr = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);\n\tif (!err) {\n\t\tif (data.req->num_pages)\n\t\t\tfuse_send_readpages(data.req, file);\n\t\telse\n\t\t\tfuse_put_request(fc, data.req);\n\t}\nout:\n\treturn err;\n}\n\nstatic ssize_t fuse_file_aio_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t\t  unsigned long nr_segs, loff_t pos)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\n\tif (pos + iov_length(iov, nr_segs) > i_size_read(inode)) {\n\t\tint err;\n\t\t/*\n\t\t * If trying to read past EOF, make sure the i_size\n\t\t * attribute is up-to-date.\n\t\t */\n\t\terr = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_aio_read(iocb, iov, nr_segs, pos);\n}\n\nstatic void fuse_write_fill(struct fuse_req *req, struct fuse_file *ff,\n\t\t\t    loff_t pos, size_t count)\n{\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tstruct fuse_write_out *outarg = &req->misc.write.out;\n\n\tinarg->fh = ff->fh;\n\tinarg->offset = pos;\n\tinarg->size = count;\n\treq->in.h.opcode = FUSE_WRITE;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 2;\n\tif (ff->fc->minor < 9)\n\t\treq->in.args[0].size = FUSE_COMPAT_WRITE_IN_SIZE;\n\telse\n\t\treq->in.args[0].size = sizeof(struct fuse_write_in);\n\treq->in.args[0].value = inarg;\n\treq->in.args[1].size = count;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(struct fuse_write_out);\n\treq->out.args[0].value = outarg;\n}\n\nstatic size_t fuse_send_write(struct fuse_req *req, struct file *file,\n\t\t\t      loff_t pos, size_t count, fl_owner_t owner)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tfuse_write_fill(req, ff, pos, count);\n\tinarg->flags = file->f_flags;\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fc, owner);\n\t}\n\tfuse_request_send(fc, req);\n\treturn req->misc.write.out.size;\n}\n\nstatic int fuse_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\n\t*pagep = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!*pagep)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid fuse_write_update_size(struct inode *inode, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tspin_lock(&fc->lock);\n\tfi->attr_version = ++fc->attr_version;\n\tif (pos > inode->i_size)\n\t\ti_size_write(inode, pos);\n\tspin_unlock(&fc->lock);\n}\n\nstatic int fuse_buffered_write(struct file *file, struct inode *inode,\n\t\t\t       loff_t pos, unsigned count, struct page *page)\n{\n\tint err;\n\tsize_t nres;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tstruct fuse_req *req;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/*\n\t * Make sure writepages on the same page are not mixed up with\n\t * plain writes.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\treq->page_offset = offset;\n\tnres = fuse_send_write(req, file, pos, count, NULL);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (!err && !nres)\n\t\terr = -EIO;\n\tif (!err) {\n\t\tpos += nres;\n\t\tfuse_write_update_size(inode, pos);\n\t\tif (count == PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\t}\n\tfuse_invalidate_attr(inode);\n\treturn err ? err : nres;\n}\n\nstatic int fuse_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint res = 0;\n\n\tif (copied)\n\t\tres = fuse_buffered_write(file, inode, pos, copied, page);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn res;\n}\n\nstatic size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,\n\t\t\t\t    struct inode *inode, loff_t pos,\n\t\t\t\t    size_t count)\n{\n\tsize_t res;\n\tunsigned offset;\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++)\n\t\tfuse_wait_on_page_writeback(inode, req->pages[i]->index);\n\n\tres = fuse_send_write(req, file, pos, count, NULL);\n\n\toffset = req->page_offset;\n\tcount = res;\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\n\t\tif (!req->out.h.error && !offset && count >= PAGE_CACHE_SIZE)\n\t\t\tSetPageUptodate(page);\n\n\t\tif (count > PAGE_CACHE_SIZE - offset)\n\t\t\tcount -= PAGE_CACHE_SIZE - offset;\n\t\telse\n\t\t\tcount = 0;\n\t\toffset = 0;\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\treturn res;\n}\n\nstatic ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\tpagefault_disable();\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < FUSE_MAX_PAGES_PER_REQ && offset == 0);\n\n\treturn count > 0 ? count : err;\n}\n\nstatic ssize_t fuse_perform_write(struct file *file,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct iov_iter *ii, loff_t pos)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err = 0;\n\tssize_t res = 0;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tdo {\n\t\tstruct fuse_req *req;\n\t\tssize_t count;\n\n\t\treq = fuse_get_req(fc);\n\t\tif (IS_ERR(req)) {\n\t\t\terr = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = fuse_fill_write_pages(req, mapping, ii, pos);\n\t\tif (count <= 0) {\n\t\t\terr = count;\n\t\t} else {\n\t\t\tsize_t num_written;\n\n\t\t\tnum_written = fuse_send_write_pages(req, file, inode,\n\t\t\t\t\t\t\t    pos, count);\n\t\t\terr = req->out.h.error;\n\t\t\tif (!err) {\n\t\t\t\tres += num_written;\n\t\t\t\tpos += num_written;\n\n\t\t\t\t/* break out of the loop on short write */\n\t\t\t\tif (num_written != count)\n\t\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t}\n\t\tfuse_put_request(fc, req);\n\t} while (!err && iov_iter_count(ii));\n\n\tif (res > 0)\n\t\tfuse_write_update_size(inode, pos);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res > 0 ? res : err;\n}\n\nstatic ssize_t fuse_file_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t\t   unsigned long nr_segs, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tsize_t count = 0;\n\tssize_t written = 0;\n\tstruct inode *inode = mapping->host;\n\tssize_t err;\n\tstruct iov_iter i;\n\n\tWARN_ON(iocb->ki_pos != pos);\n\n\terr = generic_segment_checks(iov, &nr_segs, &count, VERIFY_READ);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&inode->i_mutex);\n\tvfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = mapping->backing_dev_info;\n\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\n\tif (count == 0)\n\t\tgoto out;\n\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\n\tfile_update_time(file);\n\n\tiov_iter_init(&i, iov, nr_segs, count, 0);\n\twritten = fuse_perform_write(file, mapping, &i, pos);\n\tif (written >= 0)\n\t\tiocb->ki_pos = pos + written;\n\nout:\n\tcurrent->backing_dev_info = NULL;\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn written ? written : err;\n}\n\nstatic void fuse_release_user_pages(struct fuse_req *req, int write)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < req->num_pages; i++) {\n\t\tstruct page *page = req->pages[i];\n\t\tif (write)\n\t\t\tset_page_dirty_lock(page);\n\t\tput_page(page);\n\t}\n}\n\nstatic int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = *nbytesp;\n\tunsigned long user_addr = (unsigned long) buf;\n\tunsigned offset = user_addr & ~PAGE_MASK;\n\tint npages;\n\n\t/* Special case for kernel I/O: can copy directly into the buffer */\n\tif (segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\n\t\treturn 0;\n\t}\n\n\tnbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n\tnpages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnpages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);\n\tnpages = get_user_pages_fast(user_addr, npages, !write, req->pages);\n\tif (npages < 0)\n\t\treturn npages;\n\n\treq->num_pages = npages;\n\treq->page_offset = offset;\n\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\n\tnbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;\n\t*nbytesp = min(*nbytesp, nbytes);\n\n\treturn 0;\n}\n\nssize_t fuse_direct_io(struct file *file, const char __user *buf,\n\t\t       size_t count, loff_t *ppos, int write)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tsize_t nmax = write ? fc->max_write : fc->max_read;\n\tloff_t pos = *ppos;\n\tssize_t res = 0;\n\tstruct fuse_req *req;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\twhile (count) {\n\t\tsize_t nres;\n\t\tfl_owner_t owner = current->files;\n\t\tsize_t nbytes = min(count, nmax);\n\t\tint err = fuse_get_user_pages(req, buf, &nbytes, write);\n\t\tif (err) {\n\t\t\tres = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write)\n\t\t\tnres = fuse_send_write(req, file, pos, nbytes, owner);\n\t\telse\n\t\t\tnres = fuse_send_read(req, file, pos, nbytes, owner);\n\n\t\tfuse_release_user_pages(req, !write);\n\t\tif (req->out.h.error) {\n\t\t\tif (!res)\n\t\t\t\tres = req->out.h.error;\n\t\t\tbreak;\n\t\t} else if (nres > nbytes) {\n\t\t\tres = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcount -= nres;\n\t\tres += nres;\n\t\tpos += nres;\n\t\tbuf += nres;\n\t\tif (nres != nbytes)\n\t\t\tbreak;\n\t\tif (count) {\n\t\t\tfuse_put_request(fc, req);\n\t\t\treq = fuse_get_req(fc);\n\t\t\tif (IS_ERR(req))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!IS_ERR(req))\n\t\tfuse_put_request(fc, req);\n\tif (res > 0)\n\t\t*ppos = pos;\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(fuse_direct_io);\n\nstatic ssize_t fuse_direct_read(struct file *file, char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tssize_t res;\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\tres = fuse_direct_io(file, buf, count, ppos, 0);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}\n\nstatic ssize_t fuse_direct_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tssize_t res;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/* Don't allow parallel writes to the same file */\n\tmutex_lock(&inode->i_mutex);\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tres = fuse_direct_io(file, buf, count, ppos, 1);\n\t\tif (res > 0)\n\t\t\tfuse_write_update_size(inode, *ppos);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}\n\nstatic void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)\n{\n\t__free_page(req->pages[0]);\n\tfuse_file_put(req->ff);\n}\n\nstatic void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct backing_dev_info *bdi = inode->i_mapping->backing_dev_info;\n\n\tlist_del(&req->writepages_entry);\n\tdec_bdi_stat(bdi, BDI_WRITEBACK);\n\tdec_zone_page_state(req->pages[0], NR_WRITEBACK_TEMP);\n\tbdi_writeout_inc(bdi);\n\twake_up(&fi->page_waitq);\n}\n\n/* Called under fc->lock, may release and reacquire it */\nstatic void fuse_send_writepage(struct fuse_conn *fc, struct fuse_req *req)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tloff_t size = i_size_read(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\n\tif (!fc->connected)\n\t\tgoto out_free;\n\n\tif (inarg->offset + PAGE_CACHE_SIZE <= size) {\n\t\tinarg->size = PAGE_CACHE_SIZE;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size & (PAGE_CACHE_SIZE - 1);\n\t} else {\n\t\t/* Got truncated off completely */\n\t\tgoto out_free;\n\t}\n\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}\n\n/*\n * If fi->writectr is positive (no truncate or fsync going on) send\n * all queued writepage requests.\n *\n * Called with fc->lock\n */\nvoid fuse_flush_writepages(struct inode *inode)\n__releases(fc->lock)\n__acquires(fc->lock)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\n\twhile (fi->writectr >= 0 && !list_empty(&fi->queued_writes)) {\n\t\treq = list_entry(fi->queued_writes.next, struct fuse_req, list);\n\t\tlist_del_init(&req->list);\n\t\tfuse_send_writepage(fc, req);\n\t}\n}\n\nstatic void fuse_writepage_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct inode *inode = req->inode;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\n\tmapping_set_error(inode->i_mapping, req->out.h.error);\n\tspin_lock(&fc->lock);\n\tfi->writectr--;\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n}\n\nstatic int fuse_writepage_locked(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_file *ff;\n\tstruct page *tmp_page;\n\n\tset_page_writeback(page);\n\n\treq = fuse_request_alloc_nofs();\n\tif (!req)\n\t\tgoto err;\n\n\ttmp_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (!tmp_page)\n\t\tgoto err_free;\n\n\tspin_lock(&fc->lock);\n\tBUG_ON(list_empty(&fi->write_files));\n\tff = list_entry(fi->write_files.next, struct fuse_file, write_entry);\n\treq->ff = fuse_file_get(ff);\n\tspin_unlock(&fc->lock);\n\n\tfuse_write_fill(req, ff, page_offset(page), 0);\n\n\tcopy_highpage(tmp_page, page);\n\treq->misc.write.in.write_flags |= FUSE_WRITE_CACHE;\n\treq->in.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = tmp_page;\n\treq->page_offset = 0;\n\treq->end = fuse_writepage_end;\n\treq->inode = inode;\n\n\tinc_bdi_stat(mapping->backing_dev_info, BDI_WRITEBACK);\n\tinc_zone_page_state(tmp_page, NR_WRITEBACK_TEMP);\n\tend_page_writeback(page);\n\n\tspin_lock(&fc->lock);\n\tlist_add(&req->writepages_entry, &fi->writepages);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\treturn 0;\n\nerr_free:\n\tfuse_request_free(req);\nerr:\n\tend_page_writeback(page);\n\treturn -ENOMEM;\n}\n\nstatic int fuse_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint err;\n\n\terr = fuse_writepage_locked(page);\n\tunlock_page(page);\n\n\treturn err;\n}\n\nstatic int fuse_launder_page(struct page *page)\n{\n\tint err = 0;\n\tif (clear_page_dirty_for_io(page)) {\n\t\tstruct inode *inode = page->mapping->host;\n\t\terr = fuse_writepage_locked(page);\n\t\tif (!err)\n\t\t\tfuse_wait_on_page_writeback(inode, page->index);\n\t}\n\treturn err;\n}\n\n/*\n * Write back dirty pages now, because there may not be any suitable\n * open files later\n */\nstatic void fuse_vma_close(struct vm_area_struct *vma)\n{\n\tfilemap_write_and_wait(vma->vm_file->f_mapping);\n}\n\n/*\n * Wait for writeback against this page to complete before allowing it\n * to be marked dirty again, and hence written back again, possibly\n * before the previous writepage completed.\n *\n * Block here, instead of in ->writepage(), so that the userspace fs\n * can only block processes actually operating on the filesystem.\n *\n * Otherwise unprivileged userspace fs would be able to block\n * unrelated:\n *\n * - page migration\n * - sync(2)\n * - try_to_free_pages() with order > PAGE_ALLOC_COSTLY_ORDER\n */\nstatic int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\t/*\n\t * Don't use page->mapping as it may become NULL from a\n\t * concurrent truncate.\n\t */\n\tstruct inode *inode = vma->vm_file->f_mapping->host;\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct fuse_file_vm_ops = {\n\t.close\t\t= fuse_vma_close,\n\t.fault\t\t= filemap_fault,\n\t.page_mkwrite\t= fuse_page_mkwrite,\n};\n\nstatic int fuse_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_MAYWRITE)) {\n\t\tstruct inode *inode = file->f_dentry->d_inode;\n\t\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\t\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\t\tstruct fuse_file *ff = file->private_data;\n\t\t/*\n\t\t * file may be written through mmap, so chain it onto the\n\t\t * inodes's write_file list\n\t\t */\n\t\tspin_lock(&fc->lock);\n\t\tif (list_empty(&ff->write_entry))\n\t\t\tlist_add(&ff->write_entry, &fi->write_files);\n\t\tspin_unlock(&fc->lock);\n\t}\n\tfile_accessed(file);\n\tvma->vm_ops = &fuse_file_vm_ops;\n\treturn 0;\n}\n\nstatic int fuse_direct_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\t/* Can't provide the coherency needed for MAP_SHARED */\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\treturn -ENODEV;\n\n\tinvalidate_inode_pages2(file->f_mapping);\n\n\treturn generic_file_mmap(file, vma);\n}\n\nstatic int convert_fuse_file_lock(const struct fuse_file_lock *ffl,\n\t\t\t\t  struct file_lock *fl)\n{\n\tswitch (ffl->type) {\n\tcase F_UNLCK:\n\t\tbreak;\n\n\tcase F_RDLCK:\n\tcase F_WRLCK:\n\t\tif (ffl->start > OFFSET_MAX || ffl->end > OFFSET_MAX ||\n\t\t    ffl->end < ffl->start)\n\t\t\treturn -EIO;\n\n\t\tfl->fl_start = ffl->start;\n\t\tfl->fl_end = ffl->end;\n\t\tfl->fl_pid = ffl->pid;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tfl->fl_type = ffl->type;\n\treturn 0;\n}\n\nstatic void fuse_lk_fill(struct fuse_req *req, struct file *file,\n\t\t\t const struct file_lock *fl, int opcode, pid_t pid,\n\t\t\t int flock)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_lk_in *arg = &req->misc.lk_in;\n\n\targ->fh = ff->fh;\n\targ->owner = fuse_lock_owner_id(fc, fl->fl_owner);\n\targ->lk.start = fl->fl_start;\n\targ->lk.end = fl->fl_end;\n\targ->lk.type = fl->fl_type;\n\targ->lk.pid = pid;\n\tif (flock)\n\t\targ->lk_flags |= FUSE_LK_FLOCK;\n\treq->in.h.opcode = opcode;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(*arg);\n\treq->in.args[0].value = arg;\n}\n\nstatic int fuse_getlk(struct file *file, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_lk_out outarg;\n\tint err;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tfuse_lk_fill(req, file, fl, FUSE_GETLK, 0, 0);\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (!err)\n\t\terr = convert_fuse_file_lock(&outarg.lk, fl);\n\n\treturn err;\n}\n\nstatic int fuse_setlk(struct file *file, struct file_lock *fl, int flock)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tint opcode = (fl->fl_flags & FL_SLEEP) ? FUSE_SETLKW : FUSE_SETLK;\n\tpid_t pid = fl->fl_type != F_UNLCK ? current->tgid : 0;\n\tint err;\n\n\tif (fl->fl_lmops && fl->fl_lmops->fl_grant) {\n\t\t/* NLM needs asynchronous locks, which we don't support yet */\n\t\treturn -ENOLCK;\n\t}\n\n\t/* Unlock on close is handled by the flush method */\n\tif (fl->fl_flags & FL_CLOSE)\n\t\treturn 0;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tfuse_lk_fill(req, file, fl, opcode, pid, flock);\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\t/* locking is restartable */\n\tif (err == -EINTR)\n\t\terr = -ERESTARTSYS;\n\tfuse_put_request(fc, req);\n\treturn err;\n}\n\nstatic int fuse_file_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (cmd == F_CANCELLK) {\n\t\terr = 0;\n\t} else if (cmd == F_GETLK) {\n\t\tif (fc->no_lock) {\n\t\t\tposix_test_lock(file, fl);\n\t\t\terr = 0;\n\t\t} else\n\t\t\terr = fuse_getlk(file, fl);\n\t} else {\n\t\tif (fc->no_lock)\n\t\t\terr = posix_lock_file(file, fl, NULL);\n\t\telse\n\t\t\terr = fuse_setlk(file, fl, 0);\n\t}\n\treturn err;\n}\n\nstatic int fuse_file_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tint err;\n\n\tif (fc->no_lock) {\n\t\terr = flock_lock_file_wait(file, fl);\n\t} else {\n\t\t/* emulate flock with POSIX locks */\n\t\tfl->fl_owner = (fl_owner_t) file;\n\t\terr = fuse_setlk(file, fl, 1);\n\t}\n\n\treturn err;\n}\n\nstatic sector_t fuse_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tstruct fuse_bmap_in inarg;\n\tstruct fuse_bmap_out outarg;\n\tint err;\n\n\tif (!inode->i_sb->s_bdev || fc->no_bmap)\n\t\treturn 0;\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn 0;\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tinarg.block = block;\n\tinarg.blocksize = inode->i_sb->s_blocksize;\n\treq->in.h.opcode = FUSE_BMAP;\n\treq->in.h.nodeid = get_node_id(inode);\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\tif (err == -ENOSYS)\n\t\tfc->no_bmap = 1;\n\n\treturn err ? 0 : outarg.block;\n}\n\nstatic loff_t fuse_file_llseek(struct file *file, loff_t offset, int origin)\n{\n\tloff_t retval;\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (origin) {\n\tcase SEEK_END:\n\t\tretval = fuse_update_attributes(inode, NULL, file, NULL);\n\t\tif (retval)\n\t\t\tgoto exit;\n\t\toffset += i_size_read(inode);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 && offset <= inode->i_sb->s_maxbytes) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nexit:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}\n\nstatic int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov,\n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, iov, nr_segs, bytes, 0);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}\n\n/*\n * CUSE servers compiled on 32bit broke on 64bit kernels because the\n * ABI was defined to be 'struct iovec' which is different on 32bit\n * and 64bit.  Fortunately we can determine which structure the server\n * used from the size of the reply.\n */\nstatic int fuse_copy_ioctl_iovec(struct iovec *dst, void *src,\n\t\t\t\t size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}\n\n/* Make sure iov_length() won't overflow */\nstatic int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}\n\n/*\n * For ioctls, there is no generic way to determine how much memory\n * needs to be read and/or written.  Furthermore, ioctls are allowed\n * to dereference the passed pointer, so the parameter requires deep\n * copying but FUSE has no idea whatsoever about what to copy in or\n * out.\n *\n * This is solved by allowing FUSE server to retry ioctl with\n * necessary in/out iovecs.  Let's assume the ioctl implementation\n * needs to read in the following structure.\n *\n * struct a {\n *\tchar\t*buf;\n *\tsize_t\tbuflen;\n * }\n *\n * On the first callout to FUSE server, inarg->in_size and\n * inarg->out_size will be NULL; then, the server completes the ioctl\n * with FUSE_IOCTL_RETRY set in out->flags, out->in_iovs set to 1 and\n * the actual iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a) } }\n *\n * which tells FUSE to copy in the requested area and retry the ioctl.\n * On the second round, the server has access to the structure and\n * from that it can tell what to look for next, so on the invocation,\n * it sets FUSE_IOCTL_RETRY, out->in_iovs to 2 and iov array to\n *\n * { { .iov_base = inarg.arg,\t.iov_len = sizeof(struct a)\t},\n *   { .iov_base = a.buf,\t.iov_len = a.buflen\t\t} }\n *\n * FUSE will copy both struct a and the pointed buffer from the\n * process doing the ioctl and retry ioctl with both struct a and the\n * buffer.\n *\n * This time, FUSE server has everything it needs and completes ioctl\n * without FUSE_IOCTL_RETRY which finishes the ioctl call.\n *\n * Copying data out works the same way.\n *\n * Note that if FUSE_IOCTL_UNRESTRICTED is clear, the kernel\n * automatically initializes in and out iovs by decoding @cmd with\n * _IOC_* macros and the server is not allowed to request RETRY.  This\n * limits ioctl data transfers to well-formed ioctls and is the forced\n * behavior for all FUSE servers.\n */\nlong fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,\n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = page_address(iov_page);\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}\nEXPORT_SYMBOL_GPL(fuse_do_ioctl);\n\nstatic long fuse_file_ioctl_common(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg, unsigned int flags)\n{\n\tstruct inode *inode = file->f_dentry->d_inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_task(fc, current))\n\t\treturn -EACCES;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\treturn fuse_do_ioctl(file, cmd, arg, flags);\n}\n\nstatic long fuse_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\treturn fuse_file_ioctl_common(file, cmd, arg, 0);\n}\n\nstatic long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t   unsigned long arg)\n{\n\treturn fuse_file_ioctl_common(file, cmd, arg, FUSE_IOCTL_COMPAT);\n}\n\n/*\n * All files which have been polled are linked to RB tree\n * fuse_conn->polled_files which is indexed by kh.  Walk the tree and\n * find the matching one.\n */\nstatic struct rb_node **fuse_find_polled_node(struct fuse_conn *fc, u64 kh,\n\t\t\t\t\t      struct rb_node **parent_out)\n{\n\tstruct rb_node **link = &fc->polled_files.rb_node;\n\tstruct rb_node *last = NULL;\n\n\twhile (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tlast = *link;\n\t\tff = rb_entry(last, struct fuse_file, polled_node);\n\n\t\tif (kh < ff->kh)\n\t\t\tlink = &last->rb_left;\n\t\telse if (kh > ff->kh)\n\t\t\tlink = &last->rb_right;\n\t\telse\n\t\t\treturn link;\n\t}\n\n\tif (parent_out)\n\t\t*parent_out = last;\n\treturn link;\n}\n\n/*\n * The file is about to be polled.  Make sure it's on the polled_files\n * RB tree.  Note that files once added to the polled_files tree are\n * not removed before the file is released.  This is because a file\n * polled once is likely to be polled again.\n */\nstatic void fuse_register_polled_file(struct fuse_conn *fc,\n\t\t\t\t      struct fuse_file *ff)\n{\n\tspin_lock(&fc->lock);\n\tif (RB_EMPTY_NODE(&ff->polled_node)) {\n\t\tstruct rb_node **link, *parent;\n\n\t\tlink = fuse_find_polled_node(fc, ff->kh, &parent);\n\t\tBUG_ON(*link);\n\t\trb_link_node(&ff->polled_node, parent, link);\n\t\trb_insert_color(&ff->polled_node, &fc->polled_files);\n\t}\n\tspin_unlock(&fc->lock);\n}\n\nunsigned fuse_file_poll(struct file *file, poll_table *wait)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_poll_in inarg = { .fh = ff->fh, .kh = ff->kh };\n\tstruct fuse_poll_out outarg;\n\tstruct fuse_req *req;\n\tint err;\n\n\tif (fc->no_poll)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(file, &ff->poll_wait, wait);\n\n\t/*\n\t * Ask for notification iff there's someone waiting for it.\n\t * The client may ignore the flag and always notify.\n\t */\n\tif (waitqueue_active(&ff->poll_wait)) {\n\t\tinarg.flags |= FUSE_POLL_SCHEDULE_NOTIFY;\n\t\tfuse_register_polled_file(fc, ff);\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req))\n\t\treturn POLLERR;\n\n\treq->in.h.opcode = FUSE_POLL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\treq->out.numargs = 1;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\n\tif (!err)\n\t\treturn outarg.revents;\n\tif (err == -ENOSYS) {\n\t\tfc->no_poll = 1;\n\t\treturn DEFAULT_POLLMASK;\n\t}\n\treturn POLLERR;\n}\nEXPORT_SYMBOL_GPL(fuse_file_poll);\n\n/*\n * This is called from fuse_handle_notify() on FUSE_NOTIFY_POLL and\n * wakes up the poll waiters.\n */\nint fuse_notify_poll_wakeup(struct fuse_conn *fc,\n\t\t\t    struct fuse_notify_poll_wakeup_out *outarg)\n{\n\tu64 kh = outarg->kh;\n\tstruct rb_node **link;\n\n\tspin_lock(&fc->lock);\n\n\tlink = fuse_find_polled_node(fc, kh, NULL);\n\tif (*link) {\n\t\tstruct fuse_file *ff;\n\n\t\tff = rb_entry(*link, struct fuse_file, polled_node);\n\t\twake_up_interruptible_sync(&ff->poll_wait);\n\t}\n\n\tspin_unlock(&fc->lock);\n\treturn 0;\n}\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= do_sync_read,\n\t.aio_read\t= fuse_file_aio_read,\n\t.write\t\t= do_sync_write,\n\t.aio_write\t= fuse_file_aio_write,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n};\n\nstatic const struct file_operations fuse_direct_io_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= fuse_direct_read,\n\t.write\t\t= fuse_direct_write,\n\t.mmap\t\t= fuse_direct_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t/* no splice_read */\n};\n\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.launder_page\t= fuse_launder_page,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}\n"], "filenames": ["fs/fuse/file.c"], "buggy_code_start_loc": [1665], "buggy_code_end_loc": [1860], "fixing_code_start_loc": [1666], "fixing_code_end_loc": [1883], "type": "CWE-119", "message": "Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server.", "other": {"cve": {"id": "CVE-2010-4650", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:01.740", "lastModified": "2023-02-13T03:21:31.763", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer en la funci\u00f3n fuse_do_ioctl en fs/fusible/file.c en versiones del kernel de Linux anteriores a v2.6.37 permite a usuarios locales provocar una denegaci\u00f3n de servicio o posiblemente tener un impacto no especificado mediante el aprovechamiento de la capacidad de operar un servidor CUSE."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.36.4", "matchCriteriaId": "C03086A2-8EEE-40E3-9A7F-A5303FBF0472"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.1:*:*:*:*:*:*:*", "matchCriteriaId": "907A3F7F-B11D-4CF1-A1B2-A28BBEBF03C3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.2:*:*:*:*:*:*:*", "matchCriteriaId": "EE4657B8-B691-4833-8546-220AD2BA8A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.36.3:*:*:*:*:*:*:*", "matchCriteriaId": "A2455F37-66D8-4BE1-8739-1A20A2E5375D"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.37", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=7572777eef78ebdee1ecb7c258c0ef94d35bad16", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/01/06/18", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=667892", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16"}}