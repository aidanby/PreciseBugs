{"buggy_code": ["/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-\n *\n * Copyright (C) 2008-2014 Richard Hughes <richard@hughsie.com>\n *\n * Licensed under the GNU General Public License Version 2\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <signal.h>\n\n#include <string.h>\n#include <sys/types.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif /* HAVE_UNISTD_H */\n\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <syslog.h>\n\n#include <glib/gstdio.h>\n#include <glib/gi18n.h>\n#include <gio/gio.h>\n#include <packagekit-glib2/pk-common.h>\n#include <packagekit-glib2/pk-common-private.h>\n#include <packagekit-glib2/pk-enum.h>\n#include <packagekit-glib2/pk-offline-private.h>\n#include <packagekit-glib2/pk-package-id.h>\n#include <packagekit-glib2/pk-package-ids.h>\n#include <packagekit-glib2/pk-results.h>\n#include <polkit/polkit.h>\n\n#include \"pk-backend.h\"\n#include \"pk-dbus.h\"\n#include \"pk-shared.h\"\n#include \"pk-transaction-db.h\"\n#include \"pk-transaction.h\"\n#include \"pk-transaction-private.h\"\n\n#ifndef HAVE_POLKIT_0_114\nG_DEFINE_AUTOPTR_CLEANUP_FUNC(PolkitAuthorizationResult, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC(PolkitDetails, g_object_unref)\n#endif\n\nstatic void     pk_transaction_finalize\t\t(GObject\t    *object);\nstatic void     pk_transaction_dispose\t\t(GObject\t    *object);\n\nstatic gchar *pk_transaction_get_content_type_for_file (const gchar *filename, GError **error);\nstatic gboolean pk_transaction_is_supported_content_type (PkTransaction *transaction, const gchar *content_type);\n\n#define PK_TRANSACTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PK_TYPE_TRANSACTION, PkTransactionPrivate))\n#define PK_TRANSACTION_UPDATES_CHANGED_TIMEOUT\t100 /* ms */\n\n/* when the UID is invalid or not known */\n#define PK_TRANSACTION_UID_INVALID\t\tG_MAXUINT32\n\n/* when the client PID is invalid or not known */\n#define PK_TRANSACTION_PID_INVALID\t\tG_MAXUINT32\n\n/* maximum number of items that can be resolved in one go */\n#define PK_TRANSACTION_MAX_ITEMS_TO_RESOLVE\t10000\n\nstruct PkTransactionPrivate\n{\n\tPkRoleEnum\t\t role;\n\tPkStatusEnum\t\t status;\n\tPkTransactionState\t state;\n\tguint\t\t\t percentage;\n\tguint\t\t\t elapsed_time;\n\tguint\t\t\t remaining_time;\n\tguint\t\t\t speed;\n\tguint\t\t\t download_size_remaining;\n\tgboolean\t\t finished;\n\tgboolean\t\t allow_cancel;\n\tgboolean\t\t waiting_for_auth;\n\tgboolean\t\t emit_eula_required;\n\tgboolean\t\t emit_signature_required;\n\tgboolean\t\t emit_media_change_required;\n\tgboolean\t\t caller_active;\n\tgboolean\t\t exclusive;\n\tguint32\t\t\t client_uid;\n\tguint32\t\t\t client_pid;\n\tguint\t\t\t watch_id;\n\tPkBackend\t\t*backend;\n\tPkBackendJob\t\t*job;\n\tGKeyFile\t\t*conf;\n\tPkDbus\t\t\t*dbus;\n\tPolkitAuthority\t\t*authority;\n\tPolkitSubject\t\t*subject;\n\tGCancellable\t\t*cancellable;\n\tgboolean\t\t skip_auth_check;\n\tgboolean\t\t client_supports_plural_signals;\n\n\t/* Rate limiting of progress reporting */\n\tgboolean\t\t progress_changed;\n\tGSource\t\t\t*progress_timeout_source;  /* (nullable) (owned) */\n\n\t/* needed for gui coldplugging */\n\tgchar\t\t\t*last_package_id;\n\tgchar\t\t\t*tid;\n\tgchar\t\t\t*sender;\n\tgchar\t\t\t*cmdline;\n\tPkResults\t\t*results;\n\tPkTransactionDb\t\t*transaction_db;\n\n\t/* cached */\n\tgboolean\t\t cached_force;\n\tgboolean\t\t cached_allow_deps;\n\tgboolean\t\t cached_autoremove;\n\tgboolean\t\t cached_enabled;\n\tPkBitfield\t\t cached_transaction_flags;\n\tgchar\t\t\t*cached_package_id;\n\tgchar\t\t\t**cached_package_ids;\n\tgchar\t\t\t*cached_transaction_id;\n\tgchar\t\t\t**cached_full_paths;\n\tPkBitfield\t\t cached_filters;\n\tgchar\t\t\t**cached_values;\n\tgchar\t\t\t*cached_repo_id;\n\tgchar\t\t\t*cached_key_id;\n\tgchar\t\t\t*cached_parameter;\n\tgchar\t\t\t*cached_value;\n\tgchar\t\t\t*cached_directory;\n\tgchar\t\t\t*cached_cat_id;\n\tPkUpgradeKindEnum\t cached_upgrade_kind;\n\tGPtrArray\t\t*supported_content_types;\n\tguint\t\t\t registration_id;\n\tGDBusConnection\t\t*connection;\n\tGDBusNodeInfo\t\t*introspection;\n};\n\ntypedef enum {\n\tPK_TRANSACTION_ERROR_DENIED,\n\tPK_TRANSACTION_ERROR_NOT_RUNNING,\n\tPK_TRANSACTION_ERROR_NO_ROLE,\n\tPK_TRANSACTION_ERROR_CANNOT_CANCEL,\n\tPK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\tPK_TRANSACTION_ERROR_NO_SUCH_TRANSACTION,\n\tPK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\tPK_TRANSACTION_ERROR_NO_SUCH_DIRECTORY,\n\tPK_TRANSACTION_ERROR_TRANSACTION_EXISTS_WITH_ROLE,\n\tPK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\tPK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\tPK_TRANSACTION_ERROR_SEARCH_INVALID,\n\tPK_TRANSACTION_ERROR_SEARCH_PATH_INVALID,\n\tPK_TRANSACTION_ERROR_FILTER_INVALID,\n\tPK_TRANSACTION_ERROR_INPUT_INVALID,\n\tPK_TRANSACTION_ERROR_INVALID_STATE,\n\tPK_TRANSACTION_ERROR_INITIALIZE_FAILED,\n\tPK_TRANSACTION_ERROR_COMMIT_FAILED,\n\tPK_TRANSACTION_ERROR_INVALID_PROVIDE,\n\tPK_TRANSACTION_ERROR_PACK_INVALID,\n\tPK_TRANSACTION_ERROR_MIME_TYPE_NOT_SUPPORTED,\n\tPK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\tPK_TRANSACTION_ERROR_LAST\n} PkTransactionError;\n\nenum {\n\tSIGNAL_FINISHED,\n\tSIGNAL_STATE_CHANGED,\n\tSIGNAL_ALLOW_CANCEL_CHANGED,\n\tSIGNAL_LAST\n};\n\nstatic guint signals[SIGNAL_LAST] = { 0 };\n\nG_DEFINE_TYPE (PkTransaction, pk_transaction, G_TYPE_OBJECT)\n\nGQuark\npk_transaction_error_quark (void)\n{\n\tstatic GQuark quark = 0;\n\tif (!quark) {\n\t\tquark = g_quark_from_static_string (\"pk-transaction-error-quark\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_DENIED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".Denied\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_RUNNING,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NotRunning\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_ROLE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoRole\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_CANNOT_CANCEL,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".CannotCancel\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NotSupported\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_TRANSACTION,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoSuchTransaction\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoSuchFile\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_DIRECTORY,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoSuchDirectory\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_TRANSACTION_EXISTS_WITH_ROLE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".TransactionExistsWithRole\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".RefusedByPolicy\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".PackageIdInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".SearchInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".PathInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_FILTER_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".FilterInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InputInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INVALID_STATE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InvalidState\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INITIALIZE_FAILED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InitializeFailed\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_COMMIT_FAILED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".CommitFailed\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INVALID_PROVIDE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InvalidProvide\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_PACK_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".PackInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_MIME_TYPE_NOT_SUPPORTED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".MimeTypeNotSupported\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NumberOfPackagesInvalid\");\n\t}\n\treturn quark;\n}\n\nstatic guint\npk_transaction_get_runtime (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), 0);\n\tg_return_val_if_fail (transaction->priv->tid != NULL, 0);\n\treturn pk_backend_job_get_runtime (transaction->priv->job);\n}\n\ngboolean\npk_transaction_get_background (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\treturn pk_backend_job_get_background (transaction->priv->job);\n}\n\nstatic gboolean\npk_transaction_finish_invalidate_caches (PkTransaction *transaction)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\n\t/* could the update list have changed? */\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_SIMULATE))\n\t\tgoto out;\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD))\n\t\tgoto out;\n\tif (priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_REPO_ENABLE ||\n\t    priv->role == PK_ROLE_ENUM_REPO_SET_DATA ||\n\t    priv->role == PK_ROLE_ENUM_REPO_REMOVE ||\n\t    priv->role == PK_ROLE_ENUM_REFRESH_CACHE) {\n\n\t\t/* this needs to be done after a small delay */\n\t\tpk_backend_updates_changed_delay (priv->backend,\n\t\t\t\t\t\t  PK_TRANSACTION_UPDATES_CHANGED_TIMEOUT);\n\t}\nout:\n\treturn TRUE;\n}\n\nstatic void pk_transaction_emit_properties_changed (PkTransaction *transaction,\n                                                    const gchar   *first_property_name,\n                                                    GVariant      *first_property_value,\n                                                    ...) G_GNUC_NULL_TERMINATED;\n\nstatic void\npk_transaction_emit_properties_changed (PkTransaction *transaction,\n                                        const gchar   *first_property_name,\n                                        GVariant      *first_property_value,\n                                        ...)\n{\n\tGVariantBuilder builder;\n\tGVariantBuilder invalidated_builder;\n\tva_list args;\n\tconst gchar *property_name;\n\tGVariant *property_value;\n\n\t/* build the dict */\n\tg_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE (\"as\"));\n\tg_variant_builder_init (&builder, G_VARIANT_TYPE_ARRAY);\n\n\tva_start (args, first_property_value);\n\n\tfor (property_name = first_property_name, property_value = first_property_value;\n\t     property_name != NULL;\n\t     property_name = va_arg (args, const gchar *), property_value = (property_name != NULL) ? va_arg (args, GVariant *) : NULL) {\n\t\tg_variant_builder_add (&builder,\n\t\t\t\t       \"{sv}\",\n\t\t\t\t       property_name,\n\t\t\t\t       property_value);\n\t}\n\n\tva_end (args);\n\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       \"org.freedesktop.DBus.Properties\",\n\t\t\t\t       \"PropertiesChanged\",\n\t\t\t\t       g_variant_new (\"(sa{sv}as)\",\n\t\t\t\t\t\t      PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t\t      &builder,\n\t\t\t\t\t\t      &invalidated_builder),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_emit_property_changed (PkTransaction *transaction,\n                                      const gchar   *property_name,\n                                      GVariant      *property_value)\n{\n\tpk_transaction_emit_properties_changed (transaction,\n\t\t\t\t\t\tproperty_name, property_value,\n\t\t\t\t\t\tNULL);\n}\n\n/* If any progress-related properties have changed since the last\n * `PropertiesChanged` emission, immediately emit that D-Bus signal with the\n * latest values and clear the pending changes flag.\n *\n * See schedule_progress_changed().\n */\nstatic void\nflush_progress_changed (PkTransaction *transaction)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\tif (!priv->progress_changed)\n\t\treturn;\n\n\t/* Emit a D-Bus signal to notify of the progress changes. */\n\tpk_transaction_emit_properties_changed (transaction,\n\t\t\t\t\t\t\"Percentage\", g_variant_new_uint32 (priv->percentage),\n\t\t\t\t\t\t\"ElapsedTime\", g_variant_new_uint32 (priv->elapsed_time),\n\t\t\t\t\t\t\"RemainingTime\", g_variant_new_uint32 (priv->remaining_time),\n\t\t\t\t\t\t\"Speed\", g_variant_new_uint32 (priv->speed),\n\t\t\t\t\t\t\"DownloadSizeRemaining\", g_variant_new_uint64 (priv->download_size_remaining),\n\t\t\t\t\t\tNULL);\n\n\tpriv->progress_changed = FALSE;\n}\n\nstatic gboolean\nprogress_timeout_cb (gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\n\tflush_progress_changed (transaction);\n\n\treturn G_SOURCE_CONTINUE;\n}\n\n/* Aggregate progress-related property notifications so that the transaction\n * doesn\u2019t emit multiple D-Bus signals every millisecond for fast-progressing\n * operations (which are quite common).\n *\n * Instead, emit signals on a timer, set to 100ms (which should be fast enough\n * for users to not notice the quantisation).\n *\n * This significantly reduces the context switching overhead between\n * packagekitd, dbus-daemon, and the PackageKit clients.\n *\n * If the transaction reaches a point where property notifications need to be\n * synced up with other externally-visible transaction state (such as if another\n * progress calls `org.freedesktop.DBus.Properties.Get()`), call\n * flush_progress_changed().\n */\nstatic void\nschedule_progress_changed (PkTransaction *transaction)\n{\n\ttransaction->priv->progress_changed = TRUE;\n\n\tif (transaction->priv->progress_timeout_source == NULL) {\n\t\tg_autoptr(GSource) source = NULL;\n\n\t\tsource = g_timeout_source_new (100  /* ms */);\n\t\tg_source_set_callback (source, G_SOURCE_FUNC (progress_timeout_cb), transaction, NULL);\n\n#if GLIB_CHECK_VERSION(2, 70, 0)\n\t\tg_source_set_static_name (source, \"PkTransaction progress timeout\");\n#endif\n\n\t\tg_source_attach (source, g_main_context_get_thread_default ());\n\t\ttransaction->priv->progress_timeout_source = g_steal_pointer (&source);\n\t}\n}\n\n/* Remove the @progress_timeout_source, if set. */\nstatic void\nunschedule_progress_changed (PkTransaction *transaction)\n{\n\tflush_progress_changed (transaction);\n\n\tif (transaction->priv->progress_timeout_source != NULL) {\n\t\tg_source_destroy (transaction->priv->progress_timeout_source);\n\t\tg_clear_pointer (&transaction->priv->progress_timeout_source, g_source_unref);\n\t}\n}\n\nstatic void\npk_transaction_progress_changed_emit (PkTransaction *transaction,\n\t\t\t\t     guint percentage,\n\t\t\t\t     guint elapsed,\n\t\t\t\t     guint remaining)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\tif (transaction->priv->percentage == percentage &&\n\t    transaction->priv->elapsed_time == elapsed &&\n\t    transaction->priv->remaining_time == remaining)\n\t\treturn;\n\n\ttransaction->priv->percentage = percentage;\n\ttransaction->priv->elapsed_time = elapsed;\n\ttransaction->priv->remaining_time = remaining;\n\n\tschedule_progress_changed (transaction);\n}\n\nstatic void\npk_transaction_allow_cancel_emit (PkTransaction *transaction, gboolean allow_cancel)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\t/* already set */\n\tif (transaction->priv->allow_cancel == allow_cancel)\n\t\treturn;\n\n\ttransaction->priv->allow_cancel = allow_cancel;\n\n\t/* proxy this up so we can change the system inhibit */\n\tg_signal_emit (transaction, signals[SIGNAL_ALLOW_CANCEL_CHANGED], 0, allow_cancel);\n\n\t/* emit */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"AllowCancel\",\n\t\t\t\t\t      g_variant_new_boolean (allow_cancel));\n}\n\nstatic void\npk_transaction_status_changed_emit (PkTransaction *transaction, PkStatusEnum status)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* already set */\n\tif (transaction->priv->status == status)\n\t\treturn;\n\n\ttransaction->priv->status = status;\n\n\t/* Emit the status change, and also flush out any pending progress updates,\n\t * since the client will want to know the latest values of those\n\t * alongside the status. */\n\tflush_progress_changed (transaction);\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"Status\",\n\t\t\t\t\t      g_variant_new_uint32 (status));\n}\n\nstatic void\npk_transaction_finished_emit (PkTransaction *transaction,\n\t\t\t      PkExitEnum exit_enum,\n\t\t\t      guint time_ms)\n{\n\tg_debug (\"emitting finished '%s', %i\",\n\t\t pk_exit_enum_to_string (exit_enum),\n\t\t time_ms);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Finished\",\n\t\t\t\t       g_variant_new (\"(uu)\",\n\t\t\t\t\t\t      exit_enum,\n\t\t\t\t\t\t      time_ms),\n\t\t\t\t       NULL);\n\n\t/* For the transaction list */\n\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n}\n\nstatic void\npk_transaction_error_code_emit (PkTransaction *transaction,\n\t\t\t\tPkErrorEnum error_enum,\n\t\t\t\tconst gchar *details)\n{\n\tg_debug (\"emitting error-code %s, '%s'\",\n\t\t pk_error_enum_to_string (error_enum),\n\t\t details);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"ErrorCode\",\n\t\t\t\t       g_variant_new (\"(us)\",\n\t\t\t\t\t\t      error_enum,\n\t\t\t\t\t\t      details),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_allow_cancel_cb (PkBackendJob *job,\n\t\t\t\tgboolean allow_cancel,\n\t\t\t\tPkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"emitting allow-cancel %i\", allow_cancel);\n\tpk_transaction_allow_cancel_emit (transaction, allow_cancel);\n}\n\nstatic void\npk_transaction_locked_changed_cb (PkBackendJob *job,\n\t\t\t\tgboolean locked,\n\t\t\t\tPkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"backend job lock status changed: %i\", locked);\n\n\t/* if backend cache is locked at some time, this transaction is running in exclusive mode */\n\tif (locked)\n\t\tpk_transaction_make_exclusive (transaction);\n}\n\nstatic void\npk_transaction_details_cb (PkBackendJob *job,\n\t\t\t   PkDetails *item,\n\t\t\t   PkTransaction *transaction)\n{\n\tGVariantBuilder builder;\n\tPkGroupEnum group;\n\tconst gchar *tmp;\n\tguint64 size;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_details (transaction->priv->results, item);\n\n\t/* emit */\n\tg_debug (\"emitting details\");\n\tg_variant_builder_init (&builder, G_VARIANT_TYPE(\"a{sv}\"));\n\tg_variant_builder_add (&builder, \"{sv}\", \"package-id\",\n\t\t\t       g_variant_new_string (pk_details_get_package_id (item)));\n\tgroup = pk_details_get_group (item);\n\tif (group != PK_GROUP_ENUM_UNKNOWN)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"group\",\n\t\t\t\t       g_variant_new_uint32 (group));\n\ttmp = pk_details_get_summary (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"summary\",\n\t\t\t\t       g_variant_new_string (tmp));\n\ttmp = pk_details_get_description (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"description\",\n\t\t\t\t       g_variant_new_string (tmp));\n\ttmp = pk_details_get_url (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"url\",\n\t\t\t\t       g_variant_new_string (tmp));\n\ttmp = pk_details_get_license (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"license\",\n\t\t\t\t       g_variant_new_string (tmp));\n\tsize = pk_details_get_size (item);\n\tif (size != 0)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"size\",\n\t\t\t\t       g_variant_new_uint64 (size));\n\tsize = pk_details_get_download_size (item);\n\tif (size != G_MAXUINT64)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"download-size\",\n\t\t\t\t       g_variant_new_uint64 (size));\n\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Details\",\n\t\t\t\t       g_variant_new (\"(a{sv})\", &builder),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_error_code_cb (PkBackendJob *job,\n\t\t\t      PkError *item,\n\t\t\t      PkTransaction *transaction)\n{\n\tPkErrorEnum code;\n\tg_autofree gchar *details = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"code\", &code,\n\t\t      \"details\", &details,\n\t\t      NULL);\n\n\tif (code == PK_ERROR_ENUM_UNKNOWN) {\n\t\tg_warning (\"%s emitted 'unknown error'\",\n\t\t\t   pk_role_enum_to_string (transaction->priv->role));\n\t}\n\n\t/* add to results */\n\tpk_results_set_error_code (transaction->priv->results, item);\n\n\tif (!transaction->priv->exclusive && code == PK_ERROR_ENUM_LOCK_REQUIRED) {\n\t\t/* the backend failed to get lock for this action, this means this transaction has to be run in exclusive mode */\n\t\tg_debug (\"changing transaction to exclusive mode (after failing with lock-required)\");\n\t\ttransaction->priv->exclusive = TRUE;\n\t} else {\n\t\t/* emit, as it is not the internally-handled LOCK_REQUIRED code */\n\t\tpk_transaction_error_code_emit (transaction, code, details);\n\t}\n}\n\nstatic void\npk_transaction_files_cb (PkBackendJob *job,\n\t\t\t PkFiles *item,\n\t\t\t PkTransaction *transaction)\n{\n\tguint i;\n\tg_autofree gchar *package_id = NULL;\n\tg_auto(GStrv) files = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"package-id\", &package_id,\n\t\t      \"files\", &files,\n\t\t      NULL);\n\n\t/* ensure the files have the correct prefix */\n\tif (transaction->priv->role == PK_ROLE_ENUM_DOWNLOAD_PACKAGES &&\n\t    transaction->priv->cached_directory != NULL) {\n\t\tfor (i = 0; files[i] != NULL; i++) {\n\t\t\tif (!g_str_has_prefix (files[i], transaction->priv->cached_directory)) {\n\t\t\t\tg_warning (\"%s does not have the correct prefix (%s)\",\n\t\t\t\t\t   files[i],\n\t\t\t\t\t   transaction->priv->cached_directory);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* add to results */\n\tpk_results_add_files (transaction->priv->results, item);\n\n\t/* emit */\n\tg_debug (\"emitting files %s\", package_id);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Files\",\n\t\t\t\t       g_variant_new (\"(s^as)\",\n\t\t\t\t\t\t      package_id != NULL ? package_id : \"\",\n\t\t\t\t\t\t      files),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_category_cb (PkBackendJob *job,\n\t\t\t    PkCategory *item,\n\t\t\t    PkTransaction *transaction)\n{\n\tg_autofree gchar *parent_id = NULL;\n\tg_autofree gchar *cat_id = NULL;\n\tg_autofree gchar *name = NULL;\n\tg_autofree gchar *summary = NULL;\n\tg_autofree gchar *icon = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_category (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"parent-id\", &parent_id,\n\t\t      \"cat-id\", &cat_id,\n\t\t      \"name\", &name,\n\t\t      \"summary\", &summary,\n\t\t      \"icon\", &icon,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting category %s, %s, %s, %s, %s \", parent_id, cat_id, name, summary, icon);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Category\",\n\t\t\t\t       g_variant_new (\"(sssss)\",\n\t\t\t\t\t\t      parent_id != NULL ? parent_id : \"\",\n\t\t\t\t\t\t      cat_id,\n\t\t\t\t\t\t      name,\n\t\t\t\t\t\t      summary,\n\t\t\t\t\t\t      icon != NULL ? icon : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_item_progress_cb (PkBackendJob *job,\n\t\t\t\t PkItemProgress *item_progress,\n\t\t\t\t PkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* emit */\n\tg_debug (\"emitting item-progress %s, %s: %u\",\n\t\t pk_item_progress_get_package_id (item_progress),\n\t\t pk_status_enum_to_string (pk_item_progress_get_status (item_progress)),\n\t\t pk_item_progress_get_percentage (item_progress));\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"ItemProgress\",\n\t\t\t\t       g_variant_new (\"(suu)\",\n\t\t\t\t\t\t      pk_item_progress_get_package_id (item_progress),\n\t\t\t\t\t\t      pk_item_progress_get_status (item_progress),\n\t\t\t\t\t\t      pk_item_progress_get_percentage (item_progress)),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_distro_upgrade_cb (PkBackendJob *job,\n\t\t\t\t  PkDistroUpgrade *item,\n\t\t\t\t  PkTransaction *transaction)\n{\n\tPkUpdateStateEnum state;\n\tg_autofree gchar *name = NULL;\n\tg_autofree gchar *summary = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_distro_upgrade (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"state\", &state,\n\t\t      \"name\", &name,\n\t\t      \"summary\", &summary,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting distro-upgrade %s, %s, %s\",\n\t\t pk_update_state_enum_to_string (state),\n\t\t name, summary);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"DistroUpgrade\",\n\t\t\t\t       g_variant_new (\"(uss)\",\n\t\t\t\t\t\t      state,\n\t\t\t\t\t\t      name,\n\t\t\t\t\t\t      summary != NULL ? summary : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic gchar *\npk_transaction_package_list_to_string (GPtrArray *array)\n{\n\tGString *string;\n\tPkPackage *pkg;\n\tguint i;\n\n\tstring = g_string_new (\"\");\n\tfor (i = 0; i < array->len; i++) {\n\t\tpkg = g_ptr_array_index (array, i);\n\t\tg_string_append_printf (string, \"%s\\t%s\\t%s\\n\",\n\t\t\t\t\tpk_info_enum_to_string (pk_package_get_info (pkg)),\n\t\t\t\t\tpk_package_get_id (pkg),\n\t\t\t\t\tpk_package_get_summary (pkg));\n\t}\n\n\t/* remove trailing newline */\n\tif (string->len != 0)\n\t\tg_string_set_size (string, string->len-1);\n\treturn g_string_free (string, FALSE);\n}\n\nconst gchar *\npk_transaction_state_to_string (PkTransactionState state)\n{\n\tif (state == PK_TRANSACTION_STATE_NEW)\n\t\treturn \"new\";\n\tif (state == PK_TRANSACTION_STATE_WAITING_FOR_AUTH)\n\t\treturn \"waiting-for-auth\";\n\tif (state == PK_TRANSACTION_STATE_READY)\n\t\treturn \"ready\";\n\tif (state == PK_TRANSACTION_STATE_RUNNING)\n\t\treturn \"running\";\n\tif (state == PK_TRANSACTION_STATE_FINISHED)\n\t\treturn \"finished\";\n\tif (state == PK_TRANSACTION_STATE_ERROR)\n\t\treturn \"error\";\n\treturn NULL;\n}\n\n/**\n * pk_transaction_set_state:\n *\n * A transaction can have only one state at any time as it is processed.\n * Typically, these states will be:\n *\n * 1. 'new'\n * 2. 'waiting for auth'  <--- waiting for PolicyKit (optional)\n * 3. 'ready'\t     <--- when the transaction is ready to be run\n * 4. 'running'\t   <--- where PkBackend gets used\n * 5. 'finished'\n *\n **/\nvoid\npk_transaction_set_state (PkTransaction *transaction, PkTransactionState state)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* check we're not going backwards */\n\tif (priv->state != PK_TRANSACTION_STATE_UNKNOWN &&\n\t    priv->state > state) {\n\t\tg_warning (\"cannot set %s, as already %s\",\n\t\t\t   pk_transaction_state_to_string (state),\n\t\t\t   pk_transaction_state_to_string (priv->state));\n\t\treturn;\n\t}\n\n\t/* check we're not assuming the same state twice */\n\tif (priv->state == state) {\n\t\tg_warning (\"cannot set %s, as already in that state\",\n\t\t\t   pk_transaction_state_to_string (state));\n\t\treturn;\n\t}\n\n\tg_debug (\"transaction now %s\", pk_transaction_state_to_string (state));\n\tpriv->state = state;\n\tg_signal_emit (transaction, signals[SIGNAL_STATE_CHANGED], 0, state);\n\n\t/* only get cmdline when it's going to be saved into the database */\n\tif (priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\t\tif (priv->client_pid != PK_TRANSACTION_PID_INVALID && priv->cmdline == NULL)\n\t\t\tpriv->cmdline = pk_get_cmdline_for_pid (priv->client_pid);\n\t}\n\n\t/* only save into the database for useful stuff */\n\tif (state == PK_TRANSACTION_STATE_READY &&\n\t    (priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t     priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t     priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES)) {\n\n\t\t/* add to database */\n\t\tpk_transaction_db_add (priv->transaction_db, priv->tid);\n\n\t\t/* save role in the database */\n\t\tpk_transaction_db_set_role (priv->transaction_db, priv->tid, priv->role);\n\n\t\t/* save uid */\n\t\tpk_transaction_db_set_uid (priv->transaction_db, priv->tid, priv->client_uid);\n\n\t\t/* save cmdline in db */\n\t\tif (priv->cmdline != NULL)\n\t\t\tpk_transaction_db_set_cmdline (priv->transaction_db, priv->tid, priv->cmdline);\n\n\t\t/* report to syslog */\n\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\"new %s transaction %s scheduled from uid %i\",\n\t\t\tpk_role_enum_to_string (priv->role),\n\t\t\tpriv->tid, priv->client_uid);\n\t}\n\n\t/* update GUI */\n\tif (state == PK_TRANSACTION_STATE_WAITING_FOR_AUTH) {\n\t\tpk_transaction_status_changed_emit (transaction,\n\t\t\t\t\t\t    PK_STATUS_ENUM_WAITING_FOR_AUTH);\n\t\tpk_transaction_progress_changed_emit (transaction,\n\t\t\t\t\t\t      PK_BACKEND_PERCENTAGE_INVALID,\n\t\t\t\t\t\t      0, 0);\n\n\t} else if (state == PK_TRANSACTION_STATE_READY) {\n\t\tpk_transaction_status_changed_emit (transaction,\n\t\t\t\t\t\t    PK_STATUS_ENUM_WAIT);\n\t\tpk_transaction_progress_changed_emit (transaction,\n\t\t\t\t\t\t      PK_BACKEND_PERCENTAGE_INVALID,\n\t\t\t\t\t\t      0, 0);\n\t}\n}\n\nPkTransactionState\npk_transaction_get_state (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), PK_TRANSACTION_STATE_UNKNOWN);\n\n\treturn transaction->priv->state;\n}\n\nguint\npk_transaction_get_uid (PkTransaction *transaction)\n{\n\treturn transaction->priv->client_uid;\n}\n\nstatic void\npk_transaction_setup_mime_types (PkTransaction *transaction)\n{\n\tguint i;\n\tg_auto(GStrv) mime_types = NULL;\n\n\t/* get list of mime types supported by backends */\n\tmime_types = pk_backend_get_mime_types (transaction->priv->backend);\n\tfor (i = 0; mime_types[i] != NULL; i++) {\n\t\tg_ptr_array_add (transaction->priv->supported_content_types,\n\t\t\t\t g_strdup (mime_types[i]));\n\t}\n}\n\nvoid\npk_transaction_set_backend (PkTransaction *transaction,\n\t\t\t    PkBackend *backend)\n{\n\t/* save a reference */\n\tif (transaction->priv->backend != NULL)\n\t\tg_object_unref (transaction->priv->backend);\n\ttransaction->priv->backend = g_object_ref (backend);\n\n\t/* setup supported mime types */\n\tpk_transaction_setup_mime_types (transaction);\n}\n\n/**\n* pk_transaction_get_backend_job:\n*\n* Returns: (transfer none): Current PkBackendJob for this transaction\n**/\nPkBackendJob *\npk_transaction_get_backend_job (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), NULL);\n\treturn transaction->priv->job;\n}\n\n/**\n * pk_transaction_is_finished_with_lock_required:\n **/\ngboolean\npk_transaction_is_finished_with_lock_required (PkTransaction *transaction)\n{\n\tg_autoptr(PkError) error_code = NULL;\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\n\terror_code = pk_results_get_error_code (transaction->priv->results);\n\tif (error_code != NULL &&\n\t    pk_error_get_code (error_code) == PK_ERROR_ENUM_LOCK_REQUIRED) {\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic void\npk_transaction_offline_invalidate_check (PkTransaction *transaction)\n{\n\tPkPackage *pkg;\n\tconst gchar *package_id;\n\tgchar **package_ids;\n\tguint i;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(PkPackageSack) sack = NULL;\n\tg_autoptr(GPtrArray) invalidated = NULL;\n\n\t/* get the existing prepared updates */\n\tsack = pk_offline_get_prepared_sack (NULL);\n\tif (sack == NULL)\n\t\treturn;\n\n\t/* are there any requested packages that match in prepared-updates */\n\tpackage_ids = transaction->priv->cached_package_ids;\n\tfor (i = 0; package_ids[i] != NULL; i++) {\n\t\tpkg = pk_package_sack_find_by_id_name_arch (sack, package_ids[i]);\n\t\tif (pkg != NULL) {\n\t\t\tg_debug (\"%s modified %s, invalidating prepared-updates\",\n\t\t\t\t package_ids[i], pk_package_get_id (pkg));\n\t\t\tif (!pk_offline_auth_invalidate (&error)) {\n\t\t\t\tg_warning (\"failed to invalidate: %s\",\n\t\t\t\t\t   error->message);\n\t\t\t}\n\t\t\tg_object_unref (pkg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* are there any changed deps that match a package in prepared-updates */\n\tinvalidated = pk_results_get_package_array (transaction->priv->results);\n\tfor (i = 0; i < invalidated->len; i++) {\n\t\tpackage_id = pk_package_get_id (g_ptr_array_index (invalidated, i));\n\t\tpkg = pk_package_sack_find_by_id_name_arch (sack, package_id);\n\t\tif (pkg != NULL) {\n\t\t\tg_debug (\"%s modified %s, invalidating prepared-updates\",\n\t\t\t\t package_id, pk_package_get_id (pkg));\n\t\t\tif (!pk_offline_auth_invalidate (&error)) {\n\t\t\t\tg_warning (\"failed to invalidate: %s\",\n\t\t\t\t\t   error->message);\n\t\t\t}\n\t\t\tg_object_unref (pkg);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\npk_transaction_offline_finished (PkTransaction *transaction)\n{\n\tPkBitfield transaction_flags;\n\tgchar **package_ids;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) array = NULL;\n\n\t/* if we're doing UpdatePackages[only-download] then update the\n\t * prepared-updates file */\n\ttransaction_flags = transaction->priv->cached_transaction_flags;\n\tif (transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES &&\n\t    pk_bitfield_contain (transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD)) {\n\t\tpackage_ids = transaction->priv->cached_package_ids;\n\t\tif (!pk_offline_auth_set_prepared_ids (package_ids, &error)) {\n\t\t\tg_warning (\"failed to write offline update: %s\",\n\t\t\t\t   error->message);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* if we're doing UpgradeSystem[only-download] then update the\n\t * prepared-upgrade file */\n\ttransaction_flags = transaction->priv->cached_transaction_flags;\n\tif (transaction->priv->role == PK_ROLE_ENUM_UPGRADE_SYSTEM &&\n\t    pk_bitfield_contain (transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD)) {\n\t\tconst gchar *version = transaction->priv->cached_value;\n\t\tg_autofree gchar *name = NULL;\n\n\t\tname = pk_get_distro_name (&error);\n\t\tif (name == NULL) {\n\t\t\tg_warning (\"failed to get distro name: %s\",\n\t\t\t\t   error->message);\n\t\t\treturn;\n\t\t}\n\t\tif (!pk_offline_auth_set_prepared_upgrade (name, version, &error)) {\n\t\t\tg_warning (\"failed to write offline system upgrade state: %s\",\n\t\t\t\t   error->message);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\tswitch (transaction->priv->role) {\n\tcase PK_ROLE_ENUM_GET_UPDATES:\n\t\t/* if we do get-updates and there's no updates then remove\n\t\t * prepared-updates so the UI doesn't display update & reboot */\n\t\tarray = pk_results_get_package_array (transaction->priv->results);\n\t\tif (array->len == 0) {\n\t\t\tif (!pk_offline_auth_invalidate (&error)) {\n\t\t\t\tg_warning (\"failed to invalidate: %s\",\n\t\t\t\t\t   error->message);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REFRESH_CACHE:\n\tcase PK_ROLE_ENUM_REPO_SET_DATA:\n\tcase PK_ROLE_ENUM_REPO_ENABLE:\n\t\t/* delete the prepared updates file as it's not valid */\n\t\tif (!pk_offline_auth_invalidate (&error))\n\t\t\tg_warning (\"failed to invalidate: %s\", error->message);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_UPDATE_PACKAGES:\n\tcase PK_ROLE_ENUM_INSTALL_PACKAGES:\n\tcase PK_ROLE_ENUM_REMOVE_PACKAGES:\n\t\t/* delete the file if the action affected any package\n\t\t * already listed in the prepared updates file */\n\t\tpk_transaction_offline_invalidate_check (transaction);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\npk_transaction_finished_cb (PkBackendJob *job, PkExitEnum exit_enum, PkTransaction *transaction)\n{\n\tguint time_ms;\n\tguint i;\n\tPkPackage *item;\n\tPkInfoEnum info;\n\tPkBitfield transaction_flags;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished\");\n\t\treturn;\n\t}\n\n\t/* Ensure any pending progress has been emitted and remove the progress\n\t * timer since it\u2019s unlikely to be used again. */\n\tunschedule_progress_changed (transaction);\n\n\t/* save this so we know if the cache is valid */\n\tpk_results_set_exit_code (transaction->priv->results, exit_enum);\n\n\t/* don't really finish the transaction if we only completed to wait for lock */\n\tif (exit_enum != PK_EXIT_ENUM_CANCELLED &&\n\t    pk_transaction_is_finished_with_lock_required (transaction)) {\n\t\t/* finish only for the transaction list */\n\t\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n\t\treturn;\n\t}\n\n\t/* handle offline updates */\n\ttransaction_flags = transaction->priv->cached_transaction_flags;\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS &&\n\t    !pk_bitfield_contain (transaction_flags, PK_TRANSACTION_FLAG_ENUM_SIMULATE)) {\n\t\tpk_transaction_offline_finished (transaction);\n\t}\n\n\t/* we should get no more from the backend with this tid */\n\ttransaction->priv->finished = TRUE;\n\n\t/* if we did ::repo-signature-required or ::eula-required, change the error code */\n\tif (transaction->priv->emit_signature_required)\n\t\texit_enum = PK_EXIT_ENUM_KEY_REQUIRED;\n\telse if (transaction->priv->emit_eula_required)\n\t\texit_enum = PK_EXIT_ENUM_EULA_REQUIRED;\n\telse if (transaction->priv->emit_media_change_required)\n\t\texit_enum = PK_EXIT_ENUM_MEDIA_CHANGE_REQUIRED;\n\n\t/* invalidate some caches if we succeeded */\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS)\n\t\tpk_transaction_finish_invalidate_caches (transaction);\n\n\t/* find the length of time we have been running */\n\ttime_ms = pk_transaction_get_runtime (transaction);\n\tg_debug (\"backend was running for %i ms\", time_ms);\n\n\t/* add to the database if we are going to log it */\n\tif (transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES ||\n\t    transaction->priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    transaction->priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES) {\n\t\tg_autoptr(GPtrArray) array = NULL;\n\t\tg_autofree gchar *packages = NULL;\n\n\t\tarray = pk_results_get_package_array (transaction->priv->results);\n\n\t\t/* save to database */\n\t\tpackages = pk_transaction_package_list_to_string (array);\n\t\tif (!pk_strzero (packages))\n\t\t\tpk_transaction_db_set_data (transaction->priv->transaction_db, transaction->priv->tid, packages);\n\n\t\t/* report to syslog */\n\t\tfor (i = 0; i < array->len; i++) {\n\t\t\titem = g_ptr_array_index (array, i);\n\t\t\tinfo = pk_package_get_info (item);\n\t\t\tif (info == PK_INFO_ENUM_REMOVING ||\n\t\t\t    info == PK_INFO_ENUM_INSTALLING ||\n\t\t\t    info == PK_INFO_ENUM_UPDATING) {\n\t\t\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\t\t\"in %s for %s package %s was %s for uid %i\",\n\t\t\t\t\ttransaction->priv->tid,\n\t\t\t\t\tpk_role_enum_to_string (transaction->priv->role),\n\t\t\t\t\tpk_package_get_id (item),\n\t\t\t\t\tpk_info_enum_to_string (info),\n\t\t\t\t\ttransaction->priv->client_uid);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the repo list will have changed */\n\tif (transaction->priv->role == PK_ROLE_ENUM_REPO_ENABLE ||\n\t    transaction->priv->role == PK_ROLE_ENUM_REPO_REMOVE ||\n\t    transaction->priv->role == PK_ROLE_ENUM_REPO_SET_DATA) {\n\t\tpk_backend_repo_list_changed (transaction->priv->backend);\n\t}\n\n\t/* only reset the time if we succeeded */\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS)\n\t\tpk_transaction_db_action_time_reset (transaction->priv->transaction_db, transaction->priv->role);\n\n\t/* did we finish okay? */\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS)\n\t\tpk_transaction_db_set_finished (transaction->priv->transaction_db, transaction->priv->tid, TRUE, time_ms);\n\telse\n\t\tpk_transaction_db_set_finished (transaction->priv->transaction_db, transaction->priv->tid, FALSE, time_ms);\n\n\t/* remove any inhibit */\n\t//TODO: on main interface\n\n\t/* report to syslog */\n\tif (transaction->priv->client_uid != PK_TRANSACTION_UID_INVALID) {\n\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\"%s transaction %s from uid %i finished with %s after %ims\",\n\t\t\tpk_role_enum_to_string (transaction->priv->role),\n\t\t\ttransaction->priv->tid,\n\t\t\ttransaction->priv->client_uid,\n\t\t\tpk_exit_enum_to_string (exit_enum),\n\t\t\ttime_ms);\n\t} else {\n\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\"%s transaction %s finished with %s after %ims\",\n\t\t\tpk_role_enum_to_string (transaction->priv->role),\n\t\t\ttransaction->priv->tid,\n\t\t\tpk_exit_enum_to_string (exit_enum),\n\t\t\ttime_ms);\n\t}\n\n\t/* this disconnects any pending signals */\n\tpk_backend_job_disconnect_vfuncs (transaction->priv->job);\n\n\t/* destroy the job */\n\tpk_backend_stop_job (transaction->priv->backend, transaction->priv->job);\n\n\t/* we emit last, as other backends will be running very soon after us, and we don't want to be notified */\n\tpk_transaction_finished_emit (transaction, exit_enum, time_ms);\n}\n\nstatic void\npk_transaction_package_cb (PkBackend *backend,\n\t\t\t   PkPackage *item,\n\t\t\t   PkTransaction *transaction)\n{\n\tconst gchar *role_text;\n\tPkInfoEnum info;\n\tPkInfoEnum update_severity;\n\tconst gchar *package_id;\n\tconst gchar *summary = NULL;\n\tguint encoded_value;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished\");\n\t\treturn;\n\t}\n\n\t/* check the backend is doing the right thing */\n\tinfo = pk_package_get_info (item);\n\tif (transaction->priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\tg_warning (\"%s emitted 'installed' rather than 'installing'\",\n\t\t\t\t   role_text);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* check we are respecting the filters */\n\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t PK_FILTER_ENUM_NOT_INSTALLED)) {\n\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\tg_warning (\"%s emitted package that was installed when \"\n\t\t\t\t   \"the ~installed filter is in place\",\n\t\t\t\t   role_text);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t PK_FILTER_ENUM_INSTALLED)) {\n\t\tif (info == PK_INFO_ENUM_AVAILABLE) {\n\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\tg_warning (\"%s emitted package that was ~installed when \"\n\t\t\t\t   \"the installed filter is in place\",\n\t\t\t\t   role_text);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* add to results even if we already got a result */\n\tif (info != PK_INFO_ENUM_FINISHED)\n\t\tpk_results_add_package (transaction->priv->results, item);\n\n\t/* emit */\n\tpackage_id = pk_package_get_id (item);\n\tg_free (transaction->priv->last_package_id);\n\ttransaction->priv->last_package_id = g_strdup (package_id);\n\tsummary = pk_package_get_summary (item);\n\tif (transaction->priv->role != PK_ROLE_ENUM_GET_PACKAGES) {\n\t\tg_debug (\"emit package %s, %s, %s\",\n\t\t\t pk_info_enum_to_string (info),\n\t\t\t package_id,\n\t\t\t summary);\n\t}\n\n\t/* Safety checks, that the two values do not interleave, neither overflow */\n\tg_assert ((PK_INFO_ENUM_LAST & (~0xFFFF)) == 0);\n\n\tupdate_severity = pk_package_get_update_severity (item);\n\tencoded_value = info | (((guint32) update_severity) << 16);\n\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Package\",\n\t\t\t\t       g_variant_new (\"(uss)\",\n\t\t\t\t\t\t      encoded_value,\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      summary ? summary : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_packages_cb (PkBackend *backend,\n\t\t\t    GPtrArray *package_array,\n\t\t\t    PkTransaction *transaction)\n{\n\tg_auto(GVariantBuilder) builder = G_VARIANT_BUILDER_INIT (G_VARIANT_TYPE (\"a(uss)\"));\n\tg_autoptr(GVariant) package_array_variant = NULL;\n\tguint n_added_packages = 0;\n\tgboolean emitted = FALSE;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished\");\n\t\treturn;\n\t}\n\n\t/* Loop through the packages and build a signal emission. */\n\tfor (guint i = 0; i < package_array->len; i++) {\n\t\tPkPackage *item = g_ptr_array_index (package_array, i);\n\t\tconst gchar *role_text;\n\t\tPkInfoEnum info;\n\t\tPkInfoEnum update_severity;\n\t\tconst gchar *package_id;\n\t\tconst gchar *summary = NULL;\n\t\tguint encoded_value;\n\n\t\t/* check the backend is doing the right thing */\n\t\tinfo = pk_package_get_info (item);\n\t\tif (transaction->priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t\t    transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\t\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\t\tg_warning (\"%s emitted 'installed' rather than 'installing'\",\n\t\t\t\t\t   role_text);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* check we are respecting the filters */\n\t\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t\t PK_FILTER_ENUM_NOT_INSTALLED)) {\n\t\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\t\tg_warning (\"%s emitted package that was installed when \"\n\t\t\t\t\t   \"the ~installed filter is in place\",\n\t\t\t\t\t   role_text);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t\t PK_FILTER_ENUM_INSTALLED)) {\n\t\t\tif (info == PK_INFO_ENUM_AVAILABLE) {\n\t\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\t\tg_warning (\"%s emitted package that was ~installed when \"\n\t\t\t\t\t   \"the installed filter is in place\",\n\t\t\t\t\t   role_text);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* add to results even if we already got a result */\n\t\tif (info != PK_INFO_ENUM_FINISHED)\n\t\t\tpk_results_add_package (transaction->priv->results, item);\n\n\t\t/* emit */\n\t\tpackage_id = pk_package_get_id (item);\n\t\tg_free (transaction->priv->last_package_id);\n\t\ttransaction->priv->last_package_id = g_strdup (package_id);\n\t\tsummary = pk_package_get_summary (item);\n\t\tif (transaction->priv->role != PK_ROLE_ENUM_GET_PACKAGES) {\n\t\t\tg_debug (\"emit package %s, %s, %s\",\n\t\t\t\t pk_info_enum_to_string (info),\n\t\t\t\t package_id,\n\t\t\t\t summary);\n\t\t}\n\n\t\t/* Safety checks, that the two values do not interleave, neither overflow */\n\t\tg_assert ((PK_INFO_ENUM_LAST & (~0xFFFF)) == 0);\n\n\t\tupdate_severity = pk_package_get_update_severity (item);\n\t\tencoded_value = info | (((guint32) update_severity) << 16);\n\n\t\tg_variant_builder_add (&builder,\n\t\t\t\t       \"(uss)\",\n\t\t\t\t       encoded_value,\n\t\t\t\t       package_id,\n\t\t\t\t       summary ? summary : \"\");\n\t\tn_added_packages++;\n\t}\n\n\tif (n_added_packages == 0) {\n\t\tg_debug (\"Empty package array\");\n\t\treturn;\n\t}\n\n\tpackage_array_variant = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n\t/* Emit the signal. Grouping multiple package details into a single\n\t * signal reduces the number of signals and hence the amount of context\n\t * switching between packagekitd, dbus-daemon and the client process.\n\t * This results in much improved performance compared to emitting one\n\t * signal per package.\n\t *\n\t * This should not hit the D-Bus limits (maximum array size of 64MB,\n\t * maximum message size of 128MB) until it\u2019s listing on the order of\n\t * 100000 packages. If it does, we fall back below. */\n\tif (transaction->priv->client_supports_plural_signals &&\n\t    g_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   transaction->priv->tid,\n\t\t\t\t\t   PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t   \"Packages\",\n\t\t\t\t\t   g_variant_new (\"(@a(uss))\",\n\t\t\t\t\t                  package_array_variant),\n\t\t\t\t\t   NULL))\n\t\temitted = TRUE;\n\n\tif (!emitted) {\n\t\tGVariantIter iter;\n\t\tg_autoptr(GVariant) child = NULL;\n\n\t\t/* Fall back to one signal per package. */\n\t\tg_variant_iter_init (&iter, package_array_variant);\n\n\t\twhile ((child = g_variant_iter_next_value (&iter))) {\n\t\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t\t       NULL,\n\t\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t\t       \"Package\",\n\t\t\t\t\t\t       child,\n\t\t\t\t\t\t       NULL);\n\t\t\tg_clear_pointer (&child, g_variant_unref);\n\t\t}\n\t}\n}\n\nstatic void\npk_transaction_repo_detail_cb (PkBackend *backend,\n\t\t\t       PkRepoDetail *item,\n\t\t\t       PkTransaction *transaction)\n{\n\tgboolean enabled;\n\tconst gchar *repo_id;\n\tconst gchar *description;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_repo_detail (transaction->priv->results, item);\n\n\t/* emit */\n\trepo_id = pk_repo_detail_get_id (item);\n\tdescription = pk_repo_detail_get_description (item);\n\tenabled = pk_repo_detail_get_enabled (item);\n\tg_debug (\"emitting repo-detail %s, %s, %i\", repo_id, description, enabled);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"RepoDetail\",\n\t\t\t\t       g_variant_new (\"(ssb)\",\n\t\t\t\t\t\t      repo_id,\n\t\t\t\t\t\t      description != NULL ? description : \"\",\n\t\t\t\t\t\t      enabled),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_repo_signature_required_cb (PkBackend *backend,\n\t\t\t\t\t   PkRepoSignatureRequired *item,\n\t\t\t\t\t   PkTransaction *transaction)\n{\n\tPkSigTypeEnum type;\n\tg_autofree gchar *package_id = NULL;\n\tg_autofree gchar *repository_name = NULL;\n\tg_autofree gchar *key_url = NULL;\n\tg_autofree gchar *key_userid = NULL;\n\tg_autofree gchar *key_id = NULL;\n\tg_autofree gchar *key_fingerprint = NULL;\n\tg_autofree gchar *key_timestamp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_repo_signature_required (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"type\", &type,\n\t\t      \"package-id\", &package_id,\n\t\t      \"repository-name\", &repository_name,\n\t\t      \"key-url\", &key_url,\n\t\t      \"key-userid\", &key_userid,\n\t\t      \"key-id\", &key_id,\n\t\t      \"key-fingerprint\", &key_fingerprint,\n\t\t      \"key-timestamp\", &key_timestamp,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting repo_signature_required %s, %s, %s, %s, %s, %s, %s, %s\",\n\t\t package_id, repository_name, key_url, key_userid, key_id,\n\t\t key_fingerprint, key_timestamp,\n\t\t pk_sig_type_enum_to_string (type));\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"RepoSignatureRequired\",\n\t\t\t\t       g_variant_new (\"(sssssssu)\",\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      repository_name,\n\t\t\t\t\t\t      key_url != NULL ? key_url : \"\",\n\t\t\t\t\t\t      key_userid != NULL ? key_userid : \"\",\n\t\t\t\t\t\t      key_id != NULL ? key_id : \"\",\n\t\t\t\t\t\t      key_fingerprint != NULL ? key_fingerprint : \"\",\n\t\t\t\t\t\t      key_timestamp != NULL ? key_timestamp : \"\",\n\t\t\t\t\t\t      type),\n\t\t\t\t       NULL);\n\n\t/* we should mark this transaction so that we finish with a special code */\n\ttransaction->priv->emit_signature_required = TRUE;\n}\n\nstatic void\npk_transaction_eula_required_cb (PkBackend *backend,\n\t\t\t\t PkEulaRequired *item,\n\t\t\t\t PkTransaction *transaction)\n{\n\tconst gchar *eula_id;\n\tconst gchar *package_id;\n\tconst gchar *vendor_name;\n\tconst gchar *license_agreement;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_eula_required (transaction->priv->results, item);\n\n\t/* get data */\n\teula_id = pk_eula_required_get_eula_id (item);\n\tpackage_id = pk_eula_required_get_package_id (item);\n\tvendor_name = pk_eula_required_get_vendor_name (item);\n\tlicense_agreement = pk_eula_required_get_license_agreement (item);\n\n\t/* emit */\n\tg_debug (\"emitting eula-required %s, %s, %s, %s\",\n\t\t   eula_id, package_id, vendor_name, license_agreement);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"EulaRequired\",\n\t\t\t\t       g_variant_new (\"(ssss)\",\n\t\t\t\t\t\t      eula_id,\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      vendor_name != NULL ? vendor_name : \"\",\n\t\t\t\t\t\t      license_agreement != NULL ? license_agreement : \"\"),\n\t\t\t\t       NULL);\n\n\t/* we should mark this transaction so that we finish with a special code */\n\ttransaction->priv->emit_eula_required = TRUE;\n}\n\nstatic void\npk_transaction_media_change_required_cb (PkBackend *backend,\n\t\t\t\t\t PkMediaChangeRequired *item,\n\t\t\t\t\t PkTransaction *transaction)\n{\n\tPkMediaTypeEnum media_type;\n\tg_autofree gchar *media_id = NULL;\n\tg_autofree gchar *media_text = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_media_change_required (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"media-type\", &media_type,\n\t\t      \"media-id\", &media_id,\n\t\t      \"media-text\", &media_text,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting media-change-required %s, %s, %s\",\n\t\t pk_media_type_enum_to_string (media_type),\n\t\t media_id,\n\t\t media_text);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"MediaChangeRequired\",\n\t\t\t\t       g_variant_new (\"(uss)\",\n\t\t\t\t\t\t      media_type,\n\t\t\t\t\t\t      media_id,\n\t\t\t\t\t\t      media_text != NULL ? media_text : \"\"),\n\t\t\t\t       NULL);\n\n\t/* we should mark this transaction so that we finish with a special code */\n\ttransaction->priv->emit_media_change_required = TRUE;\n}\n\nstatic void\npk_transaction_require_restart_cb (PkBackend *backend,\n\t\t\t\t   PkRequireRestart *item,\n\t\t\t\t   PkTransaction *transaction)\n{\n\tPkRequireRestart *item_tmp;\n\tgboolean found = FALSE;\n\tguint i;\n\tPkRestartEnum restart;\n\tg_autofree gchar *package_id = NULL;\n\tg_autoptr(GPtrArray) array = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"package-id\", &package_id,\n\t\t      \"restart\", &restart,\n\t\t      NULL);\n\n\t/* filter out duplicates */\n\tarray = pk_results_get_require_restart_array (transaction->priv->results);\n\tfor (i = 0; i < array->len; i++) {\n\t\tg_autofree gchar *package_id_tmp = NULL;\n\t\titem_tmp = g_ptr_array_index (array, i);\n\t\tg_object_get (item_tmp,\n\t\t\t      \"package-id\", &package_id_tmp,\n\t\t\t      NULL);\n\t\tif (g_strcmp0 (package_id, package_id_tmp) == 0) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* ignore */\n\tif (found) {\n\t\tg_debug (\"ignoring %s (%s) as already sent\",\n\t\t\t pk_restart_enum_to_string (restart),\n\t\t\t package_id);\n\t\treturn;\n\t}\n\n\t/* add to results */\n\tpk_results_add_require_restart (transaction->priv->results, item);\n\n\t/* emit */\n\tg_debug (\"emitting require-restart %s, '%s'\",\n\t\t pk_restart_enum_to_string (restart),\n\t\t package_id);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"RequireRestart\",\n\t\t\t\t       g_variant_new (\"(us)\",\n\t\t\t\t\t\t      restart,\n\t\t\t\t\t\t      package_id),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_status_changed_cb (PkBackendJob *job,\n\t\t\t\t  PkStatusEnum status,\n\t\t\t\t  PkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* don't proxy this on the bus, just for use internal */\n\tif (status == PK_STATUS_ENUM_WAIT)\n\t\treturn;\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished, so can't proxy status %s\",\n\t\t\t   pk_status_enum_to_string (status));\n\t\treturn;\n\t}\n\n\tpk_transaction_status_changed_emit (transaction, status);\n}\n\nstatic void\npk_transaction_update_detail_cb (PkBackend *backend,\n\t\t\t\t PkUpdateDetail *item,\n\t\t\t\t PkTransaction *transaction)\n{\n\tconst gchar *changelog;\n\tconst gchar *issued;\n\tconst gchar *package_id;\n\tconst gchar *updated;\n\tconst gchar *update_text;\n\tgchar **bugzilla_urls;\n\tgchar **cve_urls;\n\tgchar *empty[] = { NULL };\n\tgchar **obsoletes;\n\tgchar **updates;\n\tgchar **vendor_urls;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_update_detail (transaction->priv->results, item);\n\n\t/* emit */\n\tpackage_id = pk_update_detail_get_package_id (item);\n\tupdates = pk_update_detail_get_updates (item);\n\tobsoletes = pk_update_detail_get_obsoletes (item);\n\tvendor_urls = pk_update_detail_get_vendor_urls (item);\n\tbugzilla_urls = pk_update_detail_get_bugzilla_urls (item);\n\tcve_urls = pk_update_detail_get_cve_urls (item);\n\tupdate_text = pk_update_detail_get_update_text (item);\n\tchangelog = pk_update_detail_get_changelog (item);\n\tissued = pk_update_detail_get_issued (item);\n\tupdated = pk_update_detail_get_updated (item);\n\tg_debug (\"emitting update-detail for %s\", package_id);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"UpdateDetail\",\n\t\t\t\t       g_variant_new (\"(s^as^as^as^as^asussuss)\",\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      updates != NULL ? updates : empty,\n\t\t\t\t\t\t      obsoletes != NULL ? obsoletes : empty,\n\t\t\t\t\t\t      vendor_urls != NULL ? vendor_urls : empty,\n\t\t\t\t\t\t      bugzilla_urls != NULL ? bugzilla_urls : empty,\n\t\t\t\t\t\t      cve_urls != NULL ? cve_urls : empty,\n\t\t\t\t\t\t      pk_update_detail_get_restart (item),\n\t\t\t\t\t\t      update_text != NULL ? update_text : \"\",\n\t\t\t\t\t\t      changelog != NULL ? changelog : \"\",\n\t\t\t\t\t\t      pk_update_detail_get_state (item),\n\t\t\t\t\t\t      issued != NULL ? issued : \"\",\n\t\t\t\t\t\t      updated != NULL ? updated : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_update_details_cb (PkBackend *backend,\n\t\t\t\t  GPtrArray *update_details_array,  /* (element-type PkUpdateDetail) */\n\t\t\t\t  PkTransaction *transaction)\n{\n\tg_auto(GVariantBuilder) builder = G_VARIANT_BUILDER_INIT (G_VARIANT_TYPE (\"a(sasasasasasussuss)\"));\n\tg_autoptr(GVariant) update_details_array_variant = NULL;\n\tguint n_update_details = 0;\n\tgboolean emitted = FALSE;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* Loop through the packages and build a signal emission. */\n\tfor (guint i = 0; i < update_details_array->len; i++) {\n\t\tPkUpdateDetail *item = g_ptr_array_index (update_details_array, i);\n\t\tconst gchar *changelog;\n\t\tconst gchar *issued;\n\t\tconst gchar *package_id;\n\t\tconst gchar *updated;\n\t\tconst gchar *update_text;\n\t\tconst gchar * const *bugzilla_urls;\n\t\tconst gchar * const *cve_urls;\n\t\tconst gchar * const empty[] = { NULL };\n\t\tconst gchar * const *obsoletes;\n\t\tconst gchar * const *updates;\n\t\tconst gchar * const *vendor_urls;\n\n\t\t/* add to results */\n\t\tpk_results_add_update_detail (transaction->priv->results, item);\n\n\t\t/* emit */\n\t\tpackage_id = pk_update_detail_get_package_id (item);\n\t\tupdates = (const gchar * const *) pk_update_detail_get_updates (item);\n\t\tobsoletes = (const gchar * const *) pk_update_detail_get_obsoletes (item);\n\t\tvendor_urls = (const gchar * const *) pk_update_detail_get_vendor_urls (item);\n\t\tbugzilla_urls = (const gchar * const *) pk_update_detail_get_bugzilla_urls (item);\n\t\tcve_urls = (const gchar * const *) pk_update_detail_get_cve_urls (item);\n\t\tupdate_text = pk_update_detail_get_update_text (item);\n\t\tchangelog = pk_update_detail_get_changelog (item);\n\t\tissued = pk_update_detail_get_issued (item);\n\t\tupdated = pk_update_detail_get_updated (item);\n\t\tg_debug (\"emitting update-detail for %s\", package_id);\n\n\t\tg_variant_builder_add (&builder,\n\t\t\t\t       \"(s^as^as^as^as^asussuss)\",\n\t\t\t\t       package_id,\n\t\t\t\t       updates != NULL ? updates : empty,\n\t\t\t\t       obsoletes != NULL ? obsoletes : empty,\n\t\t\t\t       vendor_urls != NULL ? vendor_urls : empty,\n\t\t\t\t       bugzilla_urls != NULL ? bugzilla_urls : empty,\n\t\t\t\t       cve_urls != NULL ? cve_urls : empty,\n\t\t\t\t       pk_update_detail_get_restart (item),\n\t\t\t\t       update_text != NULL ? update_text : \"\",\n\t\t\t\t       changelog != NULL ? changelog : \"\",\n\t\t\t\t       pk_update_detail_get_state (item),\n\t\t\t\t       issued != NULL ? issued : \"\",\n\t\t\t\t       updated != NULL ? updated : \"\");\n\t\tn_update_details++;\n\t}\n\n\tif (n_update_details == 0) {\n\t\tg_debug (\"Empty update details array\");\n\t\treturn;\n\t}\n\n\tupdate_details_array_variant = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n\t/* Emit the signal. Grouping multiple update details into a single\n\t * signal reduces the number of signals and hence the amount of context\n\t * switching between packagekitd, dbus-daemon and the client process.\n\t * This results in much improved performance compared to emitting one\n\t * signal per update details.\n\t *\n\t * This should not hit the D-Bus limits (maximum array size of 64MB,\n\t * maximum message size of 128MB) until it\u2019s listing on the order of\n\t * 6400 updates, if we assume 10KB of changelog/details per update.\n\t * If it does hit the limits, we fall back to the old code below. */\n\tif (transaction->priv->client_supports_plural_signals &&\n\t    g_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   transaction->priv->tid,\n\t\t\t\t\t   PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t   \"UpdateDetails\",\n\t\t\t\t\t   g_variant_new (\"(@a(sasasasasasussuss))\",\n\t\t\t\t\t                  update_details_array_variant),\n\t\t\t\t\t   NULL))\n\t\temitted = TRUE;\n\n\tif (!emitted) {\n\t\tGVariantIter iter;\n\t\tg_autoptr(GVariant) child = NULL;\n\n\t\t/* Fall back to one signal per update details. */\n\t\tg_variant_iter_init (&iter, update_details_array_variant);\n\n\t\twhile ((child = g_variant_iter_next_value (&iter))) {\n\t\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t\t       NULL,\n\t\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t\t       \"UpdateDetail\",\n\t\t\t\t\t\t       child,\n\t\t\t\t\t\t       NULL);\n\t\t\tg_clear_pointer (&child, g_variant_unref);\n\t\t}\n\t}\n}\n\nstatic gboolean\npk_transaction_set_session_state (PkTransaction *transaction,\n\t\t\t\t  GError **error)\n{\n\tgboolean ret;\n\tg_autofree gchar *session = NULL;\n\tg_autofree gchar *proxy_http = NULL;\n\tg_autofree gchar *proxy_https = NULL;\n\tg_autofree gchar *proxy_ftp = NULL;\n\tg_autofree gchar *proxy_socks = NULL;\n\tg_autofree gchar *no_proxy = NULL;\n\tg_autofree gchar *pac = NULL;\n\tg_autofree gchar *cmdline = NULL;\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* get session */\n\tif (!pk_dbus_connect (priv->dbus, error))\n\t\treturn FALSE;\n\tsession = pk_dbus_get_session (priv->dbus, priv->sender);\n\tif (session == NULL) {\n\t\tg_set_error_literal (error, 1, 0, \"failed to get the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* get from database */\n\tret = pk_transaction_db_get_proxy (priv->transaction_db,\n\t\t\t\t\t   priv->client_uid,\n\t\t\t\t\t   session,\n\t\t\t\t\t   &proxy_http,\n\t\t\t\t\t   &proxy_https,\n\t\t\t\t\t   &proxy_ftp,\n\t\t\t\t\t   &proxy_socks,\n\t\t\t\t\t   &no_proxy,\n\t\t\t\t\t   &pac);\n\tif (!ret) {\n\t\tg_set_error_literal (error, 1, 0,\n\t\t\t\t     \"failed to get the proxy from the database\");\n\t\treturn FALSE;\n\t}\n\n\t/* try to set the new proxy */\n\tpk_backend_job_set_proxy (priv->job,\n\t\t\t\t  proxy_http,\n\t\t\t\t  proxy_https,\n\t\t\t\t  proxy_ftp,\n\t\t\t\t  proxy_socks,\n\t\t\t\t  no_proxy,\n\t\t\t\t  pac);\n\n\t/* try to set the new uid and cmdline */\n\tcmdline = g_strdup_printf (\"PackageKit: %s\",\n\t\t\t\t   pk_role_enum_to_string (priv->role));\n\tpk_backend_job_set_uid (priv->job, priv->client_uid);\n\tpk_backend_job_set_cmdline (priv->job, cmdline);\n\treturn TRUE;\n}\n\nstatic void\npk_transaction_speed_cb (PkBackendJob *job,\n\t\t\t guint speed,\n\t\t\t PkTransaction *transaction)\n{\n\tif (transaction->priv->speed == speed)\n\t\treturn;\n\n\ttransaction->priv->speed = speed;\n\n\tschedule_progress_changed (transaction);\n}\n\nstatic void\npk_transaction_download_size_remaining_cb (PkBackendJob *job,\n\t\t\t\t\t   guint64 *download_size_remaining,\n\t\t\t\t\t   PkTransaction *transaction)\n{\n\tif (transaction->priv->download_size_remaining == *download_size_remaining)\n\t\treturn;\n\n\ttransaction->priv->download_size_remaining = *download_size_remaining;\n\n\tschedule_progress_changed (transaction);\n}\n\nstatic void\npk_transaction_percentage_cb (PkBackendJob *job,\n\t\t\t      guint percentage,\n\t\t\t      PkTransaction *transaction)\n{\n\tif (transaction->priv->percentage == percentage)\n\t\treturn;\n\n\ttransaction->priv->percentage = percentage;\n\n\tschedule_progress_changed (transaction);\n}\n\ngboolean\npk_transaction_run (PkTransaction *transaction)\n{\n\tGError *error = NULL;\n\tPkExitEnum exit_status;\n\tPkTransactionPrivate *priv = PK_TRANSACTION_GET_PRIVATE (transaction);\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\tg_return_val_if_fail (priv->tid != NULL, FALSE);\n\tg_return_val_if_fail (transaction->priv->backend != NULL, FALSE);\n\n\t/* we are no longer waiting, we are setting up */\n\tpk_transaction_status_changed_emit (transaction, PK_STATUS_ENUM_SETUP);\n\n\t/* set proxy */\n\tif (!pk_transaction_set_session_state (transaction, &error)) {\n\t\tg_debug (\"failed to set the session state (non-fatal): %s\",\n\t\t\t error->message);\n\t\tg_clear_error (&error);\n\t}\n\n\t/* already cancelled? */\n\tif (pk_backend_job_get_exit_code (priv->job) == PK_EXIT_ENUM_CANCELLED) {\n\t\texit_status = pk_backend_job_get_exit_code (priv->job);\n\t\tpk_transaction_finished_emit (transaction, exit_status, 0);\n\t\treturn TRUE;\n\t}\n\n\t/* run the job */\n\tpk_backend_start_job (priv->backend, priv->job);\n\n\t/* is an error code set? */\n\tif (pk_backend_job_get_is_error_set (priv->job)) {\n\t\texit_status = pk_backend_job_get_exit_code (priv->job);\n\t\tpk_transaction_finished_emit (transaction, exit_status, 0);\n\t\t/* do not fail the transaction */\n\t}\n\n\t/* check if we should skip this transaction */\n\tif (pk_backend_job_get_exit_code (priv->job) == PK_EXIT_ENUM_SKIP_TRANSACTION) {\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_SUCCESS, 0);\n\t\t/* do not fail the transaction */\n\t}\n\n\t/* set the role */\n\tpk_backend_job_set_role (priv->job, priv->role);\n\tg_debug (\"setting role for %s to %s\",\n\t\t priv->tid,\n\t\t pk_role_enum_to_string (priv->role));\n\n\t/* reset after the pre-transaction checks */\n\tpk_backend_job_set_percentage (priv->job, PK_BACKEND_PERCENTAGE_INVALID);\n\n\t/* connect signal to receive backend lock changes */\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_LOCKED_CHANGED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_locked_changed_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_ALLOW_CANCEL,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_allow_cancel_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_DETAILS,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_details_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_ERROR_CODE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_error_code_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_FILES,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_files_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_DISTRO_UPGRADE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_distro_upgrade_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_FINISHED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_finished_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_PACKAGE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_package_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_PACKAGES,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_packages_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_ITEM_PROGRESS,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_item_progress_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_PERCENTAGE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_percentage_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_SPEED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_speed_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_DOWNLOAD_SIZE_REMAINING,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_download_size_remaining_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_REPO_DETAIL,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_repo_detail_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_REPO_SIGNATURE_REQUIRED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_repo_signature_required_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_EULA_REQUIRED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_eula_required_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_MEDIA_CHANGE_REQUIRED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_media_change_required_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_REQUIRE_RESTART,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_require_restart_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_STATUS_CHANGED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_status_changed_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_UPDATE_DETAIL,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_update_detail_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_UPDATE_DETAILS,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_update_details_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_CATEGORY,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_category_cb),\n\t\t\t\t  transaction);\n\n\t/* do the correct action with the cached parameters */\n\tswitch (priv->role) {\n\tcase PK_ROLE_ENUM_DEPENDS_ON:\n\t\tpk_backend_depends_on (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_filters,\n\t\t\t\t\tpriv->cached_package_ids,\n\t\t\t\t\tpriv->cached_force);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_UPDATE_DETAIL:\n\t\tpk_backend_get_update_detail (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_RESOLVE:\n\t\tpk_backend_resolve (priv->backend,\n\t\t\t\t    priv->job,\n\t\t\t\t    priv->cached_filters,\n\t\t\t\t    priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_DOWNLOAD_PACKAGES:\n\t\tpk_backend_download_packages (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      priv->cached_package_ids,\n\t\t\t\t\t      priv->cached_directory);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_DETAILS:\n\t\tpk_backend_get_details (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_DETAILS_LOCAL:\n\t\tpk_backend_get_details_local (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      priv->cached_full_paths);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_FILES_LOCAL:\n\t\tpk_backend_get_files_local (priv->backend,\n\t\t\t\t\t    priv->job,\n\t\t\t\t\t    priv->cached_full_paths);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_DISTRO_UPGRADES:\n\t\tpk_backend_get_distro_upgrades (priv->backend,\n\t\t\t\t\t\tpriv->job);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_FILES:\n\t\tpk_backend_get_files (priv->backend,\n\t\t\t\t      priv->job,\n\t\t\t\t      priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REQUIRED_BY:\n\t\tpk_backend_required_by (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters,\n\t\t\t\t\t priv->cached_package_ids,\n\t\t\t\t\t priv->cached_force);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_WHAT_PROVIDES:\n\t\tpk_backend_what_provides (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_filters,\n\t\t\t\t\t  priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_UPDATES:\n\t\tpk_backend_get_updates (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_filters);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_PACKAGES:\n\t\tpk_backend_get_packages (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_DETAILS:\n\t\tpk_backend_search_details (priv->backend,\n\t\t\t\t\t   priv->job,\n\t\t\t\t\t   priv->cached_filters,\n\t\t\t\t\t   priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_FILE:\n\t\tpk_backend_search_files (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters,\n\t\t\t\t\t priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_GROUP:\n\t\tpk_backend_search_groups (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_filters,\n\t\t\t\t\t  priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_NAME:\n\t\tpk_backend_search_names (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters,\n\t\t\t\t\t priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_INSTALL_PACKAGES:\n\t\tpk_backend_install_packages (priv->backend,\n\t\t\t\t\t     priv->job,\n\t\t\t\t\t     priv->cached_transaction_flags,\n\t\t\t\t\t     priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_INSTALL_FILES:\n\t\tpk_backend_install_files (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_transaction_flags,\n\t\t\t\t\t  priv->cached_full_paths);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_INSTALL_SIGNATURE:\n\t\tpk_backend_install_signature (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      PK_SIGTYPE_ENUM_GPG,\n\t\t\t\t\t      priv->cached_key_id,\n\t\t\t\t\t      priv->cached_package_id);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REFRESH_CACHE:\n\t\tpk_backend_refresh_cache (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_force);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REMOVE_PACKAGES:\n\t\tpk_backend_remove_packages (priv->backend,\n\t\t\t\t\t    priv->job,\n\t\t\t\t\t    priv->cached_transaction_flags,\n\t\t\t\t\t    priv->cached_package_ids,\n\t\t\t\t\t    priv->cached_allow_deps,\n\t\t\t\t\t    priv->cached_autoremove);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_UPDATE_PACKAGES:\n\t\tpk_backend_update_packages (priv->backend,\n\t\t\t\t\t    priv->job,\n\t\t\t\t\t    priv->cached_transaction_flags,\n\t\t\t\t\t    priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_CATEGORIES:\n\t\tpk_backend_get_categories (priv->backend,\n\t\t\t\t\t   priv->job);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_REPO_LIST:\n\t\tpk_backend_get_repo_list (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_filters);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPO_ENABLE:\n\t\tpk_backend_repo_enable (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_repo_id,\n\t\t\t\t\tpriv->cached_enabled);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPO_SET_DATA:\n\t\tpk_backend_repo_set_data (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_repo_id,\n\t\t\t\t\t  priv->cached_parameter,\n\t\t\t\t\t  priv->cached_value);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPO_REMOVE:\n\t\tpk_backend_repo_remove (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_transaction_flags,\n\t\t\t\t\tpriv->cached_repo_id,\n\t\t\t\t\tpriv->cached_autoremove);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_UPGRADE_SYSTEM:\n\t\tpk_backend_upgrade_system (priv->backend,\n\t\t\t\t\t   priv->job,\n\t\t\t\t\t   priv->cached_transaction_flags,\n\t\t\t\t\t   priv->cached_value,\n\t\t\t\t\t   priv->cached_upgrade_kind);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPAIR_SYSTEM:\n\t\tpk_backend_repair_system (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_transaction_flags);\n\t\tbreak;\n\t/* handled in the engine without a transaction */\n\tcase PK_ROLE_ENUM_CANCEL:\n\tcase PK_ROLE_ENUM_GET_OLD_TRANSACTIONS:\n\tcase PK_ROLE_ENUM_ACCEPT_EULA:\n\t\tg_warning (\"role %s should be handled by engine\",\n\t\t\t   pk_role_enum_to_string (priv->role));\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"failed to run as role not assigned\");\n\t\treturn FALSE;\n\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\nconst gchar *\npk_transaction_get_tid (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), NULL);\n\tg_return_val_if_fail (transaction->priv->tid != NULL, NULL);\n\n\treturn transaction->priv->tid;\n}\n\ngboolean\npk_transaction_is_exclusive (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\n\treturn transaction->priv->exclusive;\n}\n\nvoid\npk_transaction_make_exclusive (PkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\tg_debug (\"changing transaction to exclusive mode\");\n\n\ttransaction->priv->exclusive = TRUE;\n}\n\nstatic void\npk_transaction_vanished_cb (GDBusConnection *connection,\n\t\t\t    const gchar *name,\n\t\t\t    gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\ttransaction->priv->caller_active = FALSE;\n\n\t/* emit */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"CallerActive\",\n\t\t\t\t\t      g_variant_new_boolean (transaction->priv->caller_active));\n}\n\ngboolean\npk_transaction_set_sender (PkTransaction *transaction, const gchar *sender)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\tg_return_val_if_fail (sender != NULL, FALSE);\n\tg_return_val_if_fail (transaction->priv->sender == NULL, FALSE);\n\n\tg_debug (\"setting sender to %s\", sender);\n\tpriv->sender = g_strdup (sender);\n\n\tpriv->watch_id =\n\t\tg_bus_watch_name (G_BUS_TYPE_SYSTEM,\n\t\t\t\t  sender,\n\t\t\t\t  G_BUS_NAME_WATCHER_FLAGS_NONE,\n\t\t\t\t  NULL,\n\t\t\t\t  pk_transaction_vanished_cb,\n\t\t\t\t  transaction,\n\t\t\t\t  NULL);\n\n\t/* we get the UID for all callers as we need to know when to cancel */\n\tpriv->subject = polkit_system_bus_name_new (sender);\n\tif (!pk_dbus_connect (priv->dbus, &error)) {\n\t\tg_warning (\"cannot get UID: %s\", error->message);\n\t\treturn FALSE;\n\t}\n\n\t/* get uid and pid of the caller */\n\tif (!pk_dbus_get_uid_pid (priv->dbus, sender, &priv->client_uid, &priv->client_pid)) {\n\t\t/* fallback in case our D-Bus does not support GetConnectionCredentials */\n\t\tpriv->client_uid = pk_dbus_get_uid (priv->dbus, sender);\n\t\tpriv->client_pid = pk_dbus_get_pid (priv->dbus, sender);\n\t}\n\n\t/* set in the test suite */\n\tif (g_strcmp0 (sender, \":org.freedesktop.PackageKit\") == 0) {\n\t\tg_debug (\"using self-check shortcut\");\n\t\tpriv->cmdline = g_strdup (\"/usr/sbin/packagekit\");\n\t}\n\n\treturn TRUE;\n}\n\nstatic gboolean\npk_transaction_finished_idle_cb (PkTransaction *transaction)\n{\n\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_SUCCESS, 0);\n\treturn FALSE;\n}\n\n/**\n * pk_transaction_strvalidate:\n * @text: The text to check for validity\n *\n * Tests a string to see if it may be dangerous or invalid.\n *\n * Return value: %TRUE if the string is valid\n **/\ngboolean\npk_transaction_strvalidate (const gchar *text, GError **error)\n{\n\tguint length;\n\n\t/* maximum size is 1024 */\n\tlength = pk_strlen (text, 1024);\n\tif (length == 0) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t\t     \"Invalid input passed to daemon: zero length string\");\n\t\treturn FALSE;\n\t}\n\tif (length > 1024) {\n\t\tg_set_error (error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Invalid input passed to daemon: input too long: %u\", length);\n\t\treturn FALSE;\n\t}\n\n\t/* just check for valid UTF-8 */\n\tif (!g_utf8_validate (text, -1, NULL)) {\n\t\tg_set_error (error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Invalid input passed to daemon: %s\", text);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\npk_transaction_search_check_item (const gchar *values, GError **error)\n{\n\tguint size;\n\n\t/* limit to a 1k chunk */\n\tif (values == NULL) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Search is null. This isn't supposed to happen...\");\n\t\treturn FALSE;\n\t}\n\tsize = pk_strlen (values, 1024);\n\tif (size == 0) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Search string zero length\");\n\t\treturn FALSE;\n\t}\n\tif (strstr (values, \"*\") != NULL) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Invalid search containing '*'\");\n\t\treturn FALSE;\n\t}\n\tif (strstr (values, \"?\") != NULL) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Invalid search containing '?'\");\n\t\treturn FALSE;\n\t}\n\tif (size == 1024) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"The search string length is too large\");\n\t\treturn FALSE;\n\t}\n\treturn pk_transaction_strvalidate (values, error);\n}\n\nstatic gboolean\npk_transaction_search_check (gchar **values, GError **error)\n{\n\tguint i;\n\n\t/* check each parameter */\n\tfor (i = 0; values[i] != NULL; i++) {\n\t\tif (!pk_transaction_search_check_item (values[i], error))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstruct AuthorizeActionsData {\n\tPkTransaction *transaction;\n\tPkRoleEnum role;\n\t/** Array of policy actions to authorize. They will are processed sequentially,\n\t * which can result in several chained callbacks. */\n\tGPtrArray *actions;\n};\n\nstatic gboolean\npk_transaction_authorize_actions (PkTransaction *transaction,\n\t\t\t\t  PkRoleEnum role,\n\t\t\t\t  GPtrArray *actions);\n\n/**\n * pk_transaction_authorize_actions_finished_cb:\n *\n * A callback processing the result of action's authorization done by\n * polkit daemon. If the action was authorized, it pops another\n * from *data->actions* and schedules it for authorization. This continues\n * until an action is denied or all of them are authorized.\n **/\nstatic void\npk_transaction_authorize_actions_finished_cb (GObject *source_object,\n\t\t\t\t\t      GAsyncResult *res,\n\t\t\t\t\t      struct AuthorizeActionsData *data)\n{\n\tconst gchar *action_id = NULL;\n\tPkTransactionPrivate *priv = data->transaction->priv;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(PolkitAuthorizationResult) result = NULL;\n\tg_assert (data->actions && data->actions->len > 0);\n\n\t/* get the first action */\n\taction_id = g_ptr_array_index (data->actions, 0);\n\n\t/* finish the call */\n\tresult = polkit_authority_check_authorization_finish (priv->authority, res, &error);\n\n\t/* failed because the request was cancelled */\n\tif (g_cancellable_is_cancelled (priv->cancellable)) {\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\"The authentication was cancelled due to a timeout.\");\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* failed, maybe polkit is messed up? */\n\tif (result == NULL) {\n\t\tg_autofree gchar *message = NULL;\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tg_warning (\"failed to check for auth: %s\", error->message);\n\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tmessage = g_strdup_printf (\"Failed to check for authentication: %s\", error->message);\n\t\tpk_transaction_error_code_emit (data->transaction,\n\t\t\t\t\t\tPK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\tmessage);\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* did not auth */\n\tif (!polkit_authorization_result_get_is_authorized (result)) {\n\t\tpriv->waiting_for_auth = FALSE;\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\"Failed to obtain authentication.\");\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tsyslog (LOG_AUTH | LOG_NOTICE, \"uid %i failed to obtain auth\", priv->client_uid);\n\t\tgoto out;\n\t}\n\n\tif (data->actions->len <= 1) {\n\t\t/* authentication finished successfully */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_set_state (data->transaction, PK_TRANSACTION_STATE_READY);\n\t\t/* log success too */\n\t\tsyslog (LOG_AUTH | LOG_INFO,\n\t\t\t\"uid %i obtained auth for %s\",\n\t\t\tpriv->client_uid, action_id);\n\t} else {\n\t\t/* process the rest of actions */\n\t\tg_ptr_array_remove_index (data->actions, 0);\n\t\tpk_transaction_authorize_actions (data->transaction, data->role, data->actions);\n\t}\n\nout:\n\tg_object_unref (data->transaction);\n\tg_ptr_array_unref (data->actions);\n\tg_free (data);\n}\n\n/**\n * pk_transaction_authorize_actions:\n *\n * Param actions is an array of policy actions that shall be authorized. They\n * will be processed one-by-one until one action is denied or all of them are\n * authorized. Each action results in one asynchronous function call to polkit\n * daemon.\n *\n * Return value: %TRUE if no authorization is required or the first action\n *\t\tis scheduled for processing.\n */\nstatic gboolean\npk_transaction_authorize_actions (PkTransaction *transaction,\n\t\t\t\t  PkRoleEnum role,\n\t\t\t\t  GPtrArray *actions)\n{\n\tconst gchar *action_id = NULL;\n\tg_autoptr(PolkitDetails) details = NULL;\n\tg_autofree gchar *package_ids = NULL;\n\tGString *string = NULL;\n\tPkTransactionPrivate *priv = transaction->priv;\n\tconst gchar *text = NULL;\n\tstruct AuthorizeActionsData *data = NULL;\n\tPolkitCheckAuthorizationFlags flags;\n\n\tif (actions->len <= 0) {\n\t\tg_debug (\"No authentication required\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\n\t\treturn TRUE;\n\t}\n\taction_id = g_ptr_array_index (actions, 0);\n\n\t/* log */\n\tsyslog (LOG_AUTH | LOG_INFO,\n\t\t\"uid %i is trying to obtain %s auth (only_trusted:%i)\",\n\t\tpriv->client_uid,\n\t\taction_id,\n\t\tpk_bitfield_contain (priv->cached_transaction_flags,\n\t\t\t\t\tPK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED));\n\n\t/* set transaction state */\n\tpk_transaction_set_state (transaction,\n\t\t\t\t  PK_TRANSACTION_STATE_WAITING_FOR_AUTH);\n\n\t/* check subject */\n\tpriv->waiting_for_auth = TRUE;\n\n\t/* insert details about the authorization */\n\tdetails = polkit_details_new ();\n\n\t/* do we have package details? */\n\tif (priv->cached_package_id != NULL)\n\t\tpackage_ids = g_strdup (priv->cached_package_id);\n\telse if (priv->cached_package_ids != NULL)\n\t\tpackage_ids = pk_package_ids_to_string (priv->cached_package_ids);\n\n\t/* save optional stuff */\n\tif (package_ids != NULL)\n\t\tpolkit_details_insert (details, \"package_ids\", package_ids);\n\tif (priv->cmdline != NULL)\n\t\tpolkit_details_insert (details, \"cmdline\", priv->cmdline);\n\n\t/* do not use the default icon and wording for some roles */\n\tif ((role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    role == PK_ROLE_ENUM_UPDATE_PACKAGES) &&\n\t    !pk_bitfield_contain (priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED)) {\n\n\t\t/* don't use the friendly PackageKit icon as this is\n\t\t * might be a ricky authorisation */\n\t\tpolkit_details_insert (details, \"polkit.icon_name\", \"emblem-important\");\n\n\t\tstring = g_string_new (\"\");\n\n\t\t/* TRANSLATORS: is not GPG signed */\n\t\tg_string_append (string, g_dgettext (GETTEXT_PACKAGE, N_(\"The software is not from a trusted source.\")));\n\t\tg_string_append (string, \"\\n\");\n\n\t\t/* UpdatePackages */\n\t\tif (priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\n\t\t\t/* TRANSLATORS: user has to trust provider -- I know, this sucks */\n\t\t\ttext = g_dngettext (GETTEXT_PACKAGE,\n\t\t\t\t\t    N_(\"Do not update this package unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    N_(\"Do not update these packages unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    g_strv_length (priv->cached_package_ids));\n\t\t\tg_string_append (string, text);\n\t\t}\n\n\t\t/* InstallPackages */\n\t\tif (priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES) {\n\n\t\t\t/* TRANSLATORS: user has to trust provider -- I know, this sucks */\n\t\t\ttext = g_dngettext (GETTEXT_PACKAGE,\n\t\t\t\t\t    N_(\"Do not install this package unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    N_(\"Do not install these packages unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    g_strv_length (priv->cached_package_ids));\n\t\t\tg_string_append (string, text);\n\t\t}\n\t\tif (string->len > 0) {\n\t\t\tpolkit_details_insert (details, \"polkit.gettext_domain\", GETTEXT_PACKAGE);\n\t\t\tpolkit_details_insert (details, \"polkit.message\", string->str);\n\t\t}\n\t}\n\n\tdata = g_new (struct AuthorizeActionsData, 1);\n\tdata->transaction = g_object_ref (transaction);\n\tdata->role = role;\n\tdata->actions = g_ptr_array_ref (actions);\n\n\t/* create if required */\n\tif (priv->authority == NULL) {\n\t\tg_autoptr(GError) error = NULL;\n\t\tpriv->authority = polkit_authority_get_sync (NULL, &error);\n\t\tif (priv->authority == NULL) {\n\t\t\tg_warning (\"failed to get polkit authority: %s\", error->message);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tflags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;\n\tif (pk_backend_job_get_interactive (priv->job))\n\t\tflags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;\n\n\tg_debug (\"authorizing action %s\", action_id);\n\t/* do authorization async */\n\tpolkit_authority_check_authorization (priv->authority,\n\t\t\t\t\t      priv->subject,\n\t\t\t\t\t      action_id,\n\t\t\t\t\t      details,\n\t\t\t\t\t      flags,\n\t\t\t\t\t      priv->cancellable,\n\t\t\t\t\t      (GAsyncReadyCallback) pk_transaction_authorize_actions_finished_cb,\n\t\t\t\t\t      data);\n\treturn TRUE;\n}\n\n/**\n * pk_transaction_role_to_actions:\n *\n * Produces a list of policy actions needing authorization for given role\n * and transaction flags.\n *\n * Return value: array of policy action ids\n **/\nstatic GPtrArray *\npk_transaction_role_to_actions (PkRoleEnum role, guint64 transaction_flags)\n{\n\tconst gchar *policy = NULL;\n\tGPtrArray *result = NULL;\n\tgboolean check_install_untrusted = FALSE;\n\n\tresult = g_ptr_array_new_with_free_func (g_free);\n\tif (result == NULL)\n\t\treturn result;\n\n\tif ((role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t     role == PK_ROLE_ENUM_INSTALL_FILES ||\n\t     role == PK_ROLE_ENUM_UPDATE_PACKAGES) &&\n\t    !pk_bitfield_contain (transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED)) {\n\t\tg_ptr_array_add (result, g_strdup (\"org.freedesktop.packagekit.package-install-untrusted\"));\n\t\tcheck_install_untrusted = TRUE;\n\t}\n\n\tif (role == PK_ROLE_ENUM_INSTALL_PACKAGES &&\n\t    pk_bitfield_contain (transaction_flags, PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL)) {\n\t\tg_ptr_array_add (result, g_strdup (\"org.freedesktop.packagekit.package-reinstall\"));\n\t}\n\n\tif ((role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t     role == PK_ROLE_ENUM_UPDATE_PACKAGES) &&\n\t    pk_bitfield_contain (transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ALLOW_DOWNGRADE)) {\n\t\tg_ptr_array_add (result, g_strdup (\"org.freedesktop.packagekit.package-downgrade\"));\n\t} else if (!check_install_untrusted) {\n\t\tswitch (role) {\n\t\tcase PK_ROLE_ENUM_UPDATE_PACKAGES:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-update\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_INSTALL_SIGNATURE:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-trust-signing-key\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REPO_ENABLE:\n\t\tcase PK_ROLE_ENUM_REPO_SET_DATA:\n\t\tcase PK_ROLE_ENUM_REPO_REMOVE:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-sources-configure\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REFRESH_CACHE:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-sources-refresh\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REMOVE_PACKAGES:\n\t\t\tpolicy = \"org.freedesktop.packagekit.package-remove\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_INSTALL_PACKAGES:\n\t\tcase PK_ROLE_ENUM_INSTALL_FILES:\n\t\t\tpolicy = \"org.freedesktop.packagekit.package-install\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_ACCEPT_EULA:\n\t\t\tpolicy = \"org.freedesktop.packagekit.package-eula-accept\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_CANCEL:\n\t\t\tpolicy = \"org.freedesktop.packagekit.cancel-foreign\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_UPGRADE_SYSTEM:\n\t\t\tpolicy = \"org.freedesktop.packagekit.upgrade-system\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REPAIR_SYSTEM:\n\t\t\tpolicy = \"org.freedesktop.packagekit.repair-system\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (policy != NULL)\n\t\t\tg_ptr_array_add (result, g_strdup (policy));\n\t}\n\n\treturn result;\n}\n\n/**\n * pk_transaction_obtain_authorization:\n *\n * Only valid from an async caller, which is fine, as we won't prompt the user\n * when not async.\n *\n * Because checking for authentication might have to respond to user input, this\n * is treated as async. As such, the transaction should only be added to the\n * transaction list when authorised, and not before.\n **/\nstatic gboolean\npk_transaction_obtain_authorization (PkTransaction *transaction,\n\t\t\t\t     PkRoleEnum role,\n\t\t\t\t     GError **error)\n{\n\tg_autoptr(GPtrArray) actions = NULL;\n\tPkTransactionPrivate *priv = transaction->priv;\n\tg_autofree gchar *package_ids = NULL;\n\tg_autoptr(PolkitDetails) details = NULL;\n\tg_autoptr(GString) string = NULL;\n\n\tg_return_val_if_fail (priv->sender != NULL, FALSE);\n\n\t/* we don't need to authenticate at all to just download\n\t * packages or if we're running unit tests */\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD) ||\n\t\t\tpk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_SIMULATE) ||\n\t\t\tpriv->skip_auth_check == TRUE) {\n\t\tg_debug (\"No authentication required\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\n\t\treturn TRUE;\n\t}\n\n\t/* we should always have subject */\n\tif (priv->subject == NULL) {\n\t\tg_set_error (error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\t\t\t     \"subject %s not found\", priv->sender);\n\t\treturn FALSE;\n\t}\n\n\tactions = pk_transaction_role_to_actions (role, priv->cached_transaction_flags);\n\tif (actions == NULL)\n\t\treturn FALSE;\n\n\treturn pk_transaction_authorize_actions (transaction, role, actions);\n}\n\n/**\n * pk_transaction_skip_auth_checks:\n *\n * Skip authorization checks.\n * NOTE: This is *only* for testing, do never\n * use it somewhere else!\n **/\nvoid\npk_transaction_skip_auth_checks (PkTransaction *transaction, gboolean skip_checks)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\ttransaction->priv->skip_auth_check = skip_checks;\n}\n\nPkRoleEnum\npk_transaction_get_role (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\treturn transaction->priv->role;\n}\n\nstatic void\npk_transaction_set_role (PkTransaction *transaction, PkRoleEnum role)\n{\n\ttransaction->priv->role = role;\n\n\t/* always set transaction exclusive for some actions (improves performance) */\n\tif (role == PK_ROLE_ENUM_INSTALL_FILES ||\n\t    role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t    role == PK_ROLE_ENUM_UPDATE_PACKAGES ||\n\t    role == PK_ROLE_ENUM_UPGRADE_SYSTEM ||\n\t    role == PK_ROLE_ENUM_REPAIR_SYSTEM) {\n\t\tpk_transaction_make_exclusive (transaction);\n\t}\n\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"Role\",\n\t\t\t\t\t      g_variant_new_uint32 (role));\n}\n\nstatic void\npk_transaction_dbus_return (GDBusMethodInvocation *context, const GError *error)\n{\n\t/* not set inside the test suite */\n\tif (context == NULL) {\n\t\tif (error != NULL)\n\t\t\tg_warning (\"context null, and error: %s\", error->message);\n\t\treturn;\n\t}\n\tif (error != NULL)\n\t\tg_dbus_method_invocation_return_gerror (context, error);\n\telse\n\t\tg_dbus_method_invocation_return_value (context, NULL);\n}\n\nstatic void\npk_transaction_accept_eula (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint idle_id;\n\tconst gchar *eula_id = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(&s)\",\n\t\t       &eula_id);\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (eula_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_ACCEPT_EULA);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_ACCEPT_EULA,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\tg_debug (\"AcceptEula method called: %s\", eula_id);\n\tpk_backend_accept_eula (transaction->priv->backend, eula_id);\n\n\t/* we are done */\n\tidle_id = g_idle_add ((GSourceFunc) pk_transaction_finished_idle_cb, transaction);\n\tg_source_set_name_by_id (idle_id, \"[PkTransaction] finished from accept\");\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_cancel_bg (PkTransaction *transaction)\n{\n\tg_debug (\"CancelBg method called on %s\", transaction->priv->tid);\n\n\t/* transaction is already finished */\n\tif (transaction->priv->state == PK_TRANSACTION_STATE_FINISHED)\n\t\treturn;\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_CANCEL)) {\n\t\tg_warning (\"Cancel not supported by backend\");\n\t\treturn;\n\t}\n\n\t/* if it's never been run, just remove this transaction from the list */\n\tif (transaction->priv->state <= PK_TRANSACTION_STATE_READY) {\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_CANCELLED, 0);\n\t\treturn;\n\t}\n\n\t/* set the state, as cancelling might take a few seconds */\n\tpk_backend_job_set_status (transaction->priv->job, PK_STATUS_ENUM_CANCEL);\n\n\t/* we don't want to cancel twice */\n\tpk_backend_job_set_allow_cancel (transaction->priv->job, FALSE);\n\n\t/* we need ::finished to not return success or failed */\n\tpk_backend_job_set_exit_code (transaction->priv->job, PK_EXIT_ENUM_CANCELLED_PRIORITY);\n\n\t/* actually run the method */\n\tpk_backend_cancel (transaction->priv->backend, transaction->priv->job);\n}\n\nstatic void\npk_transaction_cancel (PkTransaction *transaction,\n\t\t       GVariant *params,\n\t\t       GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *sender;\n\tguint uid;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"Cancel method called on %s\", transaction->priv->tid);\n\n\t/* transaction is already finished */\n\tif (transaction->priv->state == PK_TRANSACTION_STATE_FINISHED) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_RUNNING,\n\t\t\t     \"Transaction is already finished\");\n\t\tgoto out;\n\t}\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_CANCEL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"Cancel not supported by backend\");\n\t\tgoto out;\n\t}\n\n\t/* if it's finished, cancelling will have no action regardless of uid */\n\tif (transaction->priv->finished) {\n\t\tg_debug (\"No point trying to cancel a finished transaction, ignoring\");\n\n\t\t/* return from async with success */\n\t\tpk_transaction_dbus_return (context, NULL);\n\t\tgoto out;\n\t}\n\n\t/* check to see if we have an action */\n\tif (transaction->priv->role == PK_ROLE_ENUM_UNKNOWN) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NO_ROLE, \"No role\");\n\t\tgoto out;\n\t}\n\n\t/* first, check the sender -- if it's the same we don't need to check the uid */\n\tsender = g_dbus_method_invocation_get_sender (context);\n\tret = (g_strcmp0 (transaction->priv->sender, sender) == 0);\n\tif (ret) {\n\t\tg_debug (\"same sender, no need to check uid\");\n\t\tgoto skip_uid;\n\t}\n\n\t/* check if we saved the uid */\n\tif (transaction->priv->client_uid == PK_TRANSACTION_UID_INVALID) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_CANNOT_CANCEL,\n\t\t\t     \"No context from caller to get UID from\");\n\t\tgoto out;\n\t}\n\n\t/* get the UID of the caller */\n\tif (!pk_dbus_connect (transaction->priv->dbus, &error))\n\t\tgoto out;\n\tuid = pk_dbus_get_uid (transaction->priv->dbus, sender);\n\tif (uid == PK_TRANSACTION_UID_INVALID) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INVALID_STATE,\n\t\t\t     \"unable to get uid of caller\");\n\t\tgoto out;\n\t}\n\n\t/* check the caller uid with the originator uid */\n\tif (transaction->priv->client_uid != uid) {\n\t\tg_debug (\"uid does not match (%i vs. %i)\", transaction->priv->client_uid, uid);\n\t\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t\t   PK_ROLE_ENUM_CANCEL,\n\t\t\t\t\t\t\t   &error);\n\t\tif (!ret)\n\t\t\tgoto out;\n\t}\n\nskip_uid:\n\t/* if it's never been run, just remove this transaction from the list */\n\tif (transaction->priv->state <= PK_TRANSACTION_STATE_READY) {\n\t\tg_autofree gchar *msg = NULL;\n\t\tmsg = g_strdup_printf (\"%s was cancelled and was never run\",\n\t\t\t\t       transaction->priv->tid);\n\t\tpk_transaction_error_code_emit (transaction,\n\t\t\t\t\t\tPK_ERROR_ENUM_TRANSACTION_CANCELLED,\n\t\t\t\t\t\tmsg);\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_CANCELLED, 0);\n\t\tgoto out;\n\t}\n\n\t/* set the state, as cancelling might take a few seconds */\n\tpk_backend_job_set_status (transaction->priv->job, PK_STATUS_ENUM_CANCEL);\n\n\t/* we don't want to cancel twice */\n\tpk_backend_job_set_allow_cancel (transaction->priv->job, FALSE);\n\n\t/* we need ::finished to not return success or failed */\n\tpk_backend_job_set_exit_code (transaction->priv->job, PK_EXIT_ENUM_CANCELLED);\n\n\t/* actually run the method */\n\tpk_backend_cancel (transaction->priv->backend, transaction->priv->job);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_download_packages (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgint retval;\n\tgboolean store_in_cache;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *directory = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(b^a&s)\",\n\t\t       &store_in_cache,\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"DownloadPackages method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_DOWNLOAD_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"DownloadPackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tgoto out;\n\t}\n\n\t/* create cache directory */\n\tif (!store_in_cache) {\n\t\tdirectory = g_build_filename (LOCALSTATEDIR, \"cache\", \"PackageKit\",\n\t\t\t\t\t     \"downloads\", transaction->priv->tid, NULL);\n\t\t/* rwxrwxr-x */\n\t\tretval = g_mkdir_with_parents (directory, 0775);\n\t\tif (retval != 0) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_DENIED,\n\t\t\t\t     \"cannot create %s\", directory);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_directory = g_strdup (directory);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_DOWNLOAD_PACKAGES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_categories (PkTransaction *transaction,\n\t\t\t       GVariant *params,\n\t\t\t       GDBusMethodInvocation *context)\n{\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"GetCategories method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_CATEGORIES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetCategories not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_CATEGORIES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_depends_on (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgchar *package_ids_temp;\n\tPkBitfield filter;\n\tgboolean recursive;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&sb)\",\n\t\t       &filter,\n\t\t       &package_ids,\n\t\t       &recursive);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"DependsOn method called: %s (recursive %i)\", package_ids_temp, recursive);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_DEPENDS_ON)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"DependsOn not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_force = recursive;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_DEPENDS_ON);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_details (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\",\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"GetDetails method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_DETAILS)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetDetails not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\",\n\t\t\t     package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_DETAILS);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_details_local (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error_local = NULL;\n\tGError *error = NULL;\n\tguint i;\n\tguint length;\n\tg_autofree gchar *content_type = NULL;\n\tg_autofree gchar *files_temp = NULL;\n\tg_autofree gchar **full_paths = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\", &full_paths);\n\n\tfiles_temp = pk_package_ids_to_string (full_paths);\n\tg_debug (\"GetDetailsLocal method called: %s\", files_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_DETAILS_LOCAL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetDetailsLocal not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for empty package list */\n\tlength = g_strv_length (full_paths);\n\tif (length == 0) {\n\t\tg_set_error_literal (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\t\t\t\t     \"No filenames listed\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check all files exists and are valid */\n\tlength = g_strv_length (full_paths);\n\tfor (i = 0; i < length; i++) {\n\n\t\t/* exists */\n\t\tret = g_file_test (full_paths[i], G_FILE_TEST_EXISTS);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get content type */\n\t\tcontent_type = pk_transaction_get_content_type_for_file (full_paths[i],\n\t\t\t\t\t\t\t\t         &error_local);\n\t\tif (content_type == NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* supported content type? */\n\t\tret = pk_transaction_is_supported_content_type (transaction, content_type);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_full_paths = g_strdupv (full_paths);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_DETAILS_LOCAL);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_files_local (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error_local = NULL;\n\tguint i;\n\tguint length;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *content_type = NULL;\n\tg_autofree gchar *files_temp = NULL;\n\tg_autofree gchar **full_paths = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\", &full_paths);\n\n\tfiles_temp = pk_package_ids_to_string (full_paths);\n\tg_debug (\"GetFilesLocal method called: %s\", files_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_FILES_LOCAL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetFilesLocal not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for empty package list */\n\tlength = g_strv_length (full_paths);\n\tif (length == 0) {\n\t\tg_set_error_literal (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\t\t\t\t     \"No filenames listed\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check all files exists and are valid */\n\tlength = g_strv_length (full_paths);\n\tfor (i = 0; i < length; i++) {\n\n\t\t/* exists */\n\t\tret = g_file_test (full_paths[i], G_FILE_TEST_EXISTS);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get content type */\n\t\tcontent_type = pk_transaction_get_content_type_for_file (full_paths[i],\n\t\t\t\t\t\t\t\t         &error_local);\n\t\tif (content_type == NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* supported content type? */\n\t\tret = pk_transaction_is_supported_content_type (transaction, content_type);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_full_paths = g_strdupv (full_paths);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_FILES_LOCAL);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_distro_upgrades (PkTransaction *transaction,\n\t\t\t\t    GVariant *params,\n\t\t\t\t    GDBusMethodInvocation *context)\n{\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"GetDistroUpgrades method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_DISTRO_UPGRADES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetDistroUpgrades not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_DISTRO_UPGRADES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_files (PkTransaction *transaction,\n\t\t\t  GVariant *params,\n\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\",\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"GetFiles method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_FILES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetFiles not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_FILES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_packages (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\",\n\t\t       &filter);\n\n\tg_debug (\"GetPackages method called: %\" G_GUINT64_FORMAT, filter);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetPackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_PACKAGES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_old_transactions (PkTransaction *transaction,\n\t\t\t\t     GVariant *params,\n\t\t\t\t     GDBusMethodInvocation *context)\n{\n\tconst gchar *cmdline;\n\tconst gchar *data;\n\tconst gchar *modified;\n\tconst gchar *tid;\n\tgboolean succeeded;\n\tGList *l;\n\tGList *transactions = NULL;\n\tguint duration;\n\tguint idle_id;\n\tguint number;\n\tguint uid;\n\tPkRoleEnum role;\n\tPkTransactionPast *item;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(u)\",\n\t\t       &number);\n\n\tg_debug (\"GetOldTransactions method called\");\n\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_OLD_TRANSACTIONS);\n\ttransactions = pk_transaction_db_get_list (transaction->priv->transaction_db, number);\n\tfor (l = transactions; l != NULL; l = l->next) {\n\t\titem = PK_TRANSACTION_PAST (l->data);\n\n\t\t/* add to results */\n\t\tpk_results_add_transaction (transaction->priv->results, item);\n\n\t\t/* get data */\n\t\trole = pk_transaction_past_get_role (item);\n\t\ttid = pk_transaction_past_get_id (item);\n\t\tmodified = pk_transaction_past_get_timespec (item);\n\t\tsucceeded = pk_transaction_past_get_succeeded (item);\n\t\tduration = pk_transaction_past_get_duration (item);\n\t\tdata = pk_transaction_past_get_data (item);\n\t\tuid = pk_transaction_past_get_uid (item);\n\t\tcmdline = pk_transaction_past_get_cmdline (item);\n\n\t\t/* emit */\n\t\tg_debug (\"adding transaction %s, %s, %i, %s, %i, %s, %i, %s\",\n\t\t\t tid, modified, succeeded,\n\t\t\t pk_role_enum_to_string (role),\n\t\t\t duration, data, uid, cmdline);\n\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t       \"Transaction\",\n\t\t\t\t\t       g_variant_new (\"(osbuusus)\",\n\t\t\t\t\t\t\t      tid,\n\t\t\t\t\t\t\t      modified,\n\t\t\t\t\t\t\t      succeeded,\n\t\t\t\t\t\t\t      role,\n\t\t\t\t\t\t\t      duration,\n\t\t\t\t\t\t\t      data != NULL ? data : \"\",\n\t\t\t\t\t\t\t      uid,\n\t\t\t\t\t\t\t      cmdline != NULL ? cmdline : \"\"),\n\t\t\t\t\t       NULL);\n\t}\n\tg_list_free_full (transactions, (GDestroyNotify) g_object_unref);\n\n\tidle_id = g_idle_add ((GSourceFunc) pk_transaction_finished_idle_cb, transaction);\n\tg_source_set_name_by_id (idle_id, \"[PkTransaction] finished from get-old-transactions\");\n\n\tpk_transaction_dbus_return (context, NULL);\n}\n\nstatic void\npk_transaction_get_repo_list (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\",\n\t\t       &filter);\n\n\tg_debug (\"GetRepoList method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_REPO_LIST)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetRepoList not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_REPO_LIST);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_required_by (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tgboolean recursive;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&sb)\",\n\t\t       &filter,\n\t\t       &package_ids,\n\t\t       &recursive);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"RequiredBy method called: %s (recursive %i)\", package_ids_temp, recursive);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REQUIRED_BY)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RequiredBy not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_force = recursive;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REQUIRED_BY);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_update_detail (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\",\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"GetUpdateDetail method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_UPDATE_DETAIL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetUpdateDetail not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\",\n\t\t\t     package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_UPDATE_DETAIL);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_get_updates (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\",\n\t\t       &filter);\n\n\tg_debug (\"GetUpdates method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_UPDATES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetUpdates not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_UPDATES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic gchar *\npk_transaction_get_content_type_for_file (const gchar *filename, GError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\tg_autoptr(GFile) file = NULL;\n\tg_autoptr(GFileInfo) info = NULL;\n\n\t/* get file info synchronously */\n\tfile = g_file_new_for_path (filename);\n\tinfo = g_file_query_info (file, \"standard::content-type\",\n\t\t\t\t  G_FILE_QUERY_INFO_NONE, NULL, &error_local);\n\tif (info == NULL) {\n\t\tg_set_error (error, 1, 0,\n\t\t\t     \"failed to get file attributes for %s: %s\",\n\t\t\t     filename, error_local->message);\n\t\treturn NULL;\n\t}\n\n\t/* get content type as string */\n\treturn g_file_info_get_attribute_as_string (info, \"standard::content-type\");\n}\n\nstatic gboolean\npk_transaction_is_supported_content_type (PkTransaction *transaction,\n\t\t\t\t\t  const gchar *content_type)\n{\n\tconst gchar *tmp;\n\tGPtrArray *array = transaction->priv->supported_content_types;\n\tguint i;\n\n\t/* can we support this one? */\n\tfor (i = 0; i < array->len; i++) {\n\t\ttmp = g_ptr_array_index (array, i);\n\t\tif (g_strcmp0 (tmp, content_type) == 0)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic void\npk_transaction_install_files (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error_local = NULL;\n\tguint length;\n\tguint i;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *content_type = NULL;\n\tg_autofree gchar **full_paths = NULL;\n\tg_autofree gchar *full_paths_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &transaction_flags,\n\t\t       &full_paths);\n\n\tfull_paths_temp = pk_package_ids_to_string (full_paths);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"InstallFiles method called: %s (transaction_flags: %s)\",\n\t\t full_paths_temp, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_INSTALL_FILES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"InstallFiles not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check all files exists and are valid */\n\tlength = g_strv_length (full_paths);\n\tfor (i = 0; i < length; i++) {\n\t\t/* exists */\n\t\tret = g_file_test (full_paths[i], G_FILE_TEST_EXISTS);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* get content type */\n\t\tcontent_type = pk_transaction_get_content_type_for_file (full_paths[i], &error_local);\n\t\tif (content_type == NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* supported content type? */\n\t\tret = pk_transaction_is_supported_content_type (transaction, content_type);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_full_paths = g_strdupv (full_paths);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_INSTALL_FILES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_INSTALL_FILES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_install_packages (PkTransaction *transaction,\n\t\t\t\t GVariant *params,\n\t\t\t\t GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &transaction_flags,\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"InstallPackages method called: %s (transaction_flags: %s)\",\n\t\t package_ids_temp, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_INSTALL_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"InstallPackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_INSTALL_PACKAGES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_INSTALL_PACKAGES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_install_signature (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *key_id;\n\tconst gchar *package_id;\n\tPkSigTypeEnum sig_type;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(u&s&s)\",\n\t\t       &sig_type,\n\t\t       &key_id,\n\t\t       &package_id);\n\n\tg_debug (\"InstallSignature method called: %s, %s, %s\",\n\t\t pk_sig_type_enum_to_string (sig_type),\n\t\t key_id,\n\t\t package_id);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_INSTALL_SIGNATURE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"InstallSignature not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (key_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_id (';;;repo-id' is used for the repo key) */\n\tret = pk_package_id_check (package_id);\n\tif (!ret && !g_str_has_prefix (package_id, \";;;\")) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id '%s' is not valid\", package_id);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_id = g_strdup (package_id);\n\ttransaction->priv->cached_key_id = g_strdup (key_id);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_INSTALL_SIGNATURE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_INSTALL_SIGNATURE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_refresh_cache (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgboolean force;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(b)\",\n\t\t       &force);\n\n\tg_debug (\"RefreshCache method called: %i\", force);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REFRESH_CACHE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RefreshCache not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_force = force;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REFRESH_CACHE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REFRESH_CACHE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_remove_packages (PkTransaction *transaction,\n\t\t\t\tGVariant *params,\n\t\t\t\tGDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgboolean allow_deps;\n\tgboolean autoremove;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&sbb)\",\n\t\t       &transaction_flags,\n\t\t       &package_ids,\n\t\t       &allow_deps,\n\t\t       &autoremove);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"RemovePackages method called: %s, %i, %i (transaction_flags: %s)\",\n\t\t package_ids_temp, allow_deps, autoremove, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REMOVE_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RemovePackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_allow_deps = allow_deps;\n\ttransaction->priv->cached_autoremove = autoremove;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REMOVE_PACKAGES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REMOVE_PACKAGES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repo_enable (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *repo_id;\n\tgboolean enabled;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(&sb)\",\n\t\t       &repo_id,\n\t\t       &enabled);\n\n\tg_debug (\"RepoEnable method called: %s, %i\", repo_id, enabled);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPO_ENABLE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RepoEnable not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (repo_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_repo_id = g_strdup (repo_id);\n\ttransaction->priv->cached_enabled = enabled;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPO_ENABLE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPO_ENABLE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repo_set_data (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *repo_id;\n\tconst gchar *parameter;\n\tconst gchar *value;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(&s&s&s)\",\n\t\t       &repo_id,\n\t\t       &parameter,\n\t\t       &value);\n\n\tg_debug (\"RepoSetData method called: %s, %s, %s\",\n\t\t repo_id, parameter, value);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPO_SET_DATA)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RepoSetData not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (repo_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_repo_id = g_strdup (repo_id);\n\ttransaction->priv->cached_parameter = g_strdup (parameter);\n\ttransaction->priv->cached_value = g_strdup (value);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPO_SET_DATA);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPO_SET_DATA,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repo_remove (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tPkBitfield transaction_flags;\n\tconst gchar *repo_id;\n\tgboolean autoremove;\n\tgboolean ret;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *tmp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t&sb)\",\n\t\t       &transaction_flags,\n\t\t       &repo_id,\n\t\t       &autoremove);\n\n\ttmp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"RepoRemove method called: %s, %s, %i\",\n\t\t tmp, repo_id, autoremove);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPO_REMOVE)) {\n\t\tg_set_error_literal (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t     \"RepoSetData not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (repo_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_repo_id = g_strdup (repo_id);\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_autoremove = autoremove;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPO_REMOVE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPO_REMOVE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_resolve (PkTransaction *transaction,\n\t\t\tGVariant *params,\n\t\t\tGDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tguint length;\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **packages = NULL;\n\tg_autofree gchar *packages_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &packages);\n\n\tpackages_temp = pk_package_ids_to_string (packages);\n\tg_debug (\"Resolve method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, packages_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_RESOLVE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"Resolve not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for length sanity */\n\tlength = g_strv_length (packages);\n\tif (length == 0) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Too few items to process\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\tif (length > PK_TRANSACTION_MAX_ITEMS_TO_RESOLVE) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Too many items to process (%i/%i)\",\n\t\t\t     length, PK_TRANSACTION_MAX_ITEMS_TO_RESOLVE);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check each package for sanity */\n\tfor (i = 0; i < length; i++) {\n\t\tret = pk_transaction_strvalidate (packages[i], &error);\n\t\tif (!ret) {\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (packages);\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_RESOLVE);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_search_details (PkTransaction *transaction,\n\t\t\t       GVariant *params,\n\t\t\t       GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchDetails method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_DETAILS)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchDetails not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_DETAILS);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_search_files (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchFiles method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_FILE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchFiles not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* when not an absolute path, disallow slashes in search */\n\tfor (i = 0; values[i] != NULL; i++) {\n\t\tif (values[i][0] != '/' && strstr (values[i], \"/\") != NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID,\n\t\t\t\t     \"Invalid search path\");\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_FILE);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_search_groups (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchGroups method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_GROUP)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchGroups not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* do not allow spaces */\n\tfor (i = 0; values[i] != NULL; i++) {\n\t\tif (strstr (values[i], \" \") != NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Invalid search containing spaces\");\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_GROUP);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_search_names (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchNames method called: %\"  G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_NAME)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchNames not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_NAME);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic gboolean\npk_transaction_set_hint (PkTransaction *transaction,\n\t\t\t const gchar *key,\n\t\t\t const gchar *value,\n\t\t\t GError **error)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* locale=en_GB.utf8 */\n\tif (g_strcmp0 (key, \"locale\") == 0) {\n\t\tpk_backend_job_set_locale (priv->job, value);\n\t\treturn TRUE;\n\t}\n\n\t/* frontend_socket=/tmp/socket.3456 */\n\tif (g_strcmp0 (key, \"frontend-socket\") == 0) {\n\n\t\t/* nothing provided */\n\t\tif (value == NULL || value[0] == '\\0') {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"Could not set frontend-socket to nothing\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* nothing provided */\n\t\tif (value[0] != '/') {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"frontend-socket has to be an absolute path\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* socket does not exist */\n\t\tif (!g_file_test (value, G_FILE_TEST_EXISTS)) {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"frontend-socket does not exist\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* success */\n\t\tpk_backend_job_set_frontend_socket (priv->job, value);\n\t\treturn TRUE;\n\t}\n\n\t/* background=true */\n\tif (g_strcmp0 (key, \"background\") == 0) {\n\t\tif (g_strcmp0 (value, \"true\") == 0) {\n\t\t\tpk_backend_job_set_background (priv->job, TRUE);\n\t\t} else if (g_strcmp0 (value, \"false\") == 0) {\n\t\t\tpk_backend_job_set_background (priv->job, FALSE);\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t      \"background hint expects true or false, not %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* interactive=true */\n\tif (g_strcmp0 (key, \"interactive\") == 0) {\n\t\tif (g_strcmp0 (value, \"true\") == 0) {\n\t\t\tpk_backend_job_set_interactive (priv->job, TRUE);\n\t\t} else if (g_strcmp0 (value, \"false\") == 0) {\n\t\t\tpk_backend_job_set_interactive (priv->job, FALSE);\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t      \"interactive hint expects true or false, not %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* cache-age=<time-in-seconds> */\n\tif (g_strcmp0 (key, \"cache-age\") == 0) {\n\t\tguint cache_age;\n\t\tif (!pk_strtouint (value, &cache_age)) {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t     \"cannot parse cache age value %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (cache_age == 0) {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"cannot set a cache age of zero\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tpk_backend_job_set_cache_age (priv->job, cache_age);\n\t\treturn TRUE;\n\t}\n\n\t/* Is the plural Packages signal supported? The key\u2019s value is ignored,\n\t * as clients will only send it if it\u2019s true. */\n\tif (g_strcmp0 (key, \"supports-plural-signals\") == 0) {\n\t\tif (g_strcmp0 (value, \"true\") != 0) {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t      \"supports-plural-signals hint expects true only, not %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tg_debug (\"Client has set supports-plural-signals=true\");\n\t\tpriv->client_supports_plural_signals = TRUE;\n\t\treturn TRUE;\n\t}\n\n\t/* to preserve forwards and backwards compatibility, we ignore\n\t * extra options here */\n\tg_warning (\"unknown option: %s with value %s\", key, value);\n\treturn TRUE;\n}\n\nstatic void\npk_transaction_set_hints (PkTransaction *transaction,\n\t\t\t  GVariant *params,\n\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tg_autofree gchar **hints = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *dbg = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\", &hints);\n\tdbg = g_strjoinv (\", \", (gchar**) hints);\n\tg_debug (\"SetHints method called: %s\", dbg);\n\n\t/* parse */\n\tfor (i = 0; hints[i] != NULL; i++) {\n\t\tg_auto(GStrv) sections = NULL;\n\t\tsections = g_strsplit (hints[i], \"=\", 2);\n\t\tif (g_strv_length (sections) == 2) {\n\t\t\tret = pk_transaction_set_hint (transaction,\n\t\t\t\t\t\t       sections[0],\n\t\t\t\t\t\t       sections[1],\n\t\t\t\t\t\t       &error);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tg_set_error (&error, PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"Could not parse hint '%s'\", hints[i]);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_update_packages (PkTransaction *transaction,\n\t\t\t\tGVariant *params,\n\t\t\t\tGDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &transaction_flags,\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"UpdatePackages method called: %s (transaction_flags: %s)\",\n\t\t package_ids_temp, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_UPDATE_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"UpdatePackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\",\n\t\t\t     package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_UPDATE_PACKAGES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_UPDATE_PACKAGES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_what_provides (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"WhatProvides method called: %s\",\n\t\t values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_WHAT_PROVIDES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"WhatProvides not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_WHAT_PROVIDES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_upgrade_system (PkTransaction *transaction,\n\t\t\t       GVariant *params,\n\t\t\t       GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tPkUpgradeKindEnum upgrade_kind;\n\tconst gchar *distro_id;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t&su)\",\n\t\t       &transaction_flags,\n\t\t       &distro_id,\n\t\t       &upgrade_kind);\n\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"UpgradeSystem method called: %s: %s  (transaction_flags: %s)\",\n\t\t distro_id,\n\t\t pk_upgrade_kind_enum_to_string (upgrade_kind),\n\t\t transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_UPGRADE_SYSTEM)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"UpgradeSystem not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_value = g_strdup (distro_id);\n\ttransaction->priv->cached_upgrade_kind = upgrade_kind;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_UPGRADE_SYSTEM);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_UPGRADE_SYSTEM,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repair_system (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\", &transaction_flags);\n\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"RepairSystem method called  (transaction_flags: %s)\",\n\t\t transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPAIR_SYSTEM)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RepairSystem not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPAIR_SYSTEM);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPAIR_SYSTEM,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic GVariant *\n_g_variant_new_maybe_string (const gchar *value)\n{\n\tif (value == NULL)\n\t\treturn g_variant_new_string (\"\");\n\treturn g_variant_new_string (value);\n}\n\nstatic GVariant *\npk_transaction_get_property (GDBusConnection *connection_, const gchar *sender,\n\t\t\t     const gchar *object_path, const gchar *interface_name,\n\t\t\t     const gchar *property_name, GError **error,\n\t\t\t     gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* Ensure that progress signal emissions are done before we potentially\n\t * return more up-to-date property values. */\n\tflush_progress_changed (transaction);\n\n\tif (g_strcmp0 (property_name, \"Role\") == 0)\n\t\treturn g_variant_new_uint32 (priv->role);\n\tif (g_strcmp0 (property_name, \"Status\") == 0)\n\t\treturn g_variant_new_uint32 (priv->status);\n\tif (g_strcmp0 (property_name, \"LastPackage\") == 0)\n\t\treturn _g_variant_new_maybe_string (priv->last_package_id);\n\tif (g_strcmp0 (property_name, \"Uid\") == 0)\n\t\treturn g_variant_new_uint32 (priv->client_uid);\n\tif (g_strcmp0 (property_name, \"Sender\") == 0)\n\t\treturn _g_variant_new_maybe_string (priv->sender);\n\tif (g_strcmp0 (property_name, \"Percentage\") == 0)\n\t\treturn g_variant_new_uint32 (transaction->priv->percentage);\n\tif (g_strcmp0 (property_name, \"AllowCancel\") == 0)\n\t\treturn g_variant_new_boolean (priv->allow_cancel);\n\tif (g_strcmp0 (property_name, \"CallerActive\") == 0)\n\t\treturn g_variant_new_boolean (priv->caller_active);\n\tif (g_strcmp0 (property_name, \"ElapsedTime\") == 0)\n\t\treturn g_variant_new_uint32 (priv->elapsed_time);\n\tif (g_strcmp0 (property_name, \"Speed\") == 0)\n\t\treturn g_variant_new_uint32 (priv->speed);\n\tif (g_strcmp0 (property_name, \"DownloadSizeRemaining\") == 0)\n\t\treturn g_variant_new_uint64 (priv->download_size_remaining);\n\tif (g_strcmp0 (property_name, \"TransactionFlags\") == 0)\n\t\treturn g_variant_new_uint64 (priv->cached_transaction_flags);\n\tif (g_strcmp0 (property_name, \"RemainingTime\") == 0)\n\t\treturn g_variant_new_uint32 (priv->remaining_time);\n\n\tg_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_PROPERTY,\n\t\t     \"Unknown transaction property \u2018%s\u2019\", property_name);\n\treturn NULL;\n}\n\nstatic void\npk_transaction_method_call (GDBusConnection *connection_, const gchar *sender,\n\t\t\t    const gchar *object_path, const gchar *interface_name,\n\t\t\t    const gchar *method_name, GVariant *parameters,\n\t\t\t    GDBusMethodInvocation *invocation, gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\n\tg_return_if_fail (transaction->priv->sender != NULL);\n\n\t/* check is the same as the sender that did CreateTransaction */\n\tif (g_strcmp0 (transaction->priv->sender, sender) != 0) {\n\t\tg_dbus_method_invocation_return_error (invocation,\n\t\t\t\t\t\t       PK_TRANSACTION_ERROR,\n\t\t\t\t\t\t       PK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\t\t\t\t\t\t       \"sender does not match (%s vs %s)\",\n\t\t\t\t\t\t       sender,\n\t\t\t\t\t\t       transaction->priv->sender);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SetHints\") == 0) {\n\t\tpk_transaction_set_hints (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"AcceptEula\") == 0) {\n\t\tpk_transaction_accept_eula (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"Cancel\") == 0) {\n\t\tpk_transaction_cancel (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"DownloadPackages\") == 0) {\n\t\tpk_transaction_download_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetCategories\") == 0) {\n\t\tpk_transaction_get_categories (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"DependsOn\") == 0) {\n\t\tpk_transaction_depends_on (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetDetails\") == 0) {\n\t\tpk_transaction_get_details (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetDetailsLocal\") == 0) {\n\t\tpk_transaction_get_details_local (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetFilesLocal\") == 0) {\n\t\tpk_transaction_get_files_local (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetFiles\") == 0) {\n\t\tpk_transaction_get_files (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetOldTransactions\") == 0) {\n\t\tpk_transaction_get_old_transactions (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetPackages\") == 0) {\n\t\tpk_transaction_get_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetRepoList\") == 0) {\n\t\tpk_transaction_get_repo_list (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RequiredBy\") == 0) {\n\t\tpk_transaction_required_by (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetUpdateDetail\") == 0) {\n\t\tpk_transaction_get_update_detail (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetUpdates\") == 0) {\n\t\tpk_transaction_get_updates (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetDistroUpgrades\") == 0) {\n\t\tpk_transaction_get_distro_upgrades (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"InstallFiles\") == 0) {\n\t\tpk_transaction_install_files (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"InstallPackages\") == 0) {\n\t\tpk_transaction_install_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"InstallSignature\") == 0) {\n\t\tpk_transaction_install_signature (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RefreshCache\") == 0) {\n\t\tpk_transaction_refresh_cache (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RemovePackages\") == 0) {\n\t\tpk_transaction_remove_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepoEnable\") == 0) {\n\t\tpk_transaction_repo_enable (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepoSetData\") == 0) {\n\t\tpk_transaction_repo_set_data (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepoRemove\") == 0) {\n\t\tpk_transaction_repo_remove (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"Resolve\") == 0) {\n\t\tpk_transaction_resolve (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchDetails\") == 0) {\n\t\tpk_transaction_search_details (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchFiles\") == 0) {\n\t\tpk_transaction_search_files (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchGroups\") == 0) {\n\t\tpk_transaction_search_groups (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchNames\") == 0) {\n\t\tpk_transaction_search_names (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"UpdatePackages\") == 0) {\n\t\tpk_transaction_update_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"WhatProvides\") == 0) {\n\t\tpk_transaction_what_provides (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"UpgradeSystem\") == 0) {\n\t\tpk_transaction_upgrade_system (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepairSystem\") == 0) {\n\t\tpk_transaction_repair_system (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\n\t/* nothing matched */\n\tg_dbus_method_invocation_return_error (invocation,\n\t\t\t\t\t       PK_TRANSACTION_ERROR,\n\t\t\t\t\t       PK_TRANSACTION_ERROR_INVALID_STATE,\n\t\t\t\t\t       \"method from %s not recognised\",\n\t\t\t\t\t       sender);\n}\n\ngboolean\npk_transaction_set_tid (PkTransaction *transaction, const gchar *tid)\n{\n\tstatic const GDBusInterfaceVTable interface_vtable = {\n\t\t.method_call = pk_transaction_method_call,\n\t\t.get_property = pk_transaction_get_property,\n\t\t.set_property = NULL\n\t};\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\tg_return_val_if_fail (tid != NULL, FALSE);\n\tg_return_val_if_fail (transaction->priv->tid == NULL, FALSE);\n\n\ttransaction->priv->tid = g_strdup (tid);\n\n\t/* register org.freedesktop.PackageKit.Transaction */\n\ttransaction->priv->connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n\tg_assert (transaction->priv->connection != NULL);\n\ttransaction->priv->registration_id =\n\t\tg_dbus_connection_register_object (transaction->priv->connection,\n\t\t\t\t\t\t   tid,\n\t\t\t\t\t\t   transaction->priv->introspection->interfaces[0],\n\t\t\t\t\t\t   &interface_vtable,\n\t\t\t\t\t\t   transaction,  /* user_data */\n\t\t\t\t\t\t   NULL,  /* user_data_free_func */\n\t\t\t\t\t\t   NULL); /* GError** */\n\tg_assert (transaction->priv->registration_id > 0);\n\treturn TRUE;\n}\n\nvoid\npk_transaction_reset_after_lock_error (PkTransaction *transaction)\n{\n\tPkTransactionPrivate *priv = PK_TRANSACTION_GET_PRIVATE (transaction);\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\t/* clear results */\n\tg_object_unref (priv->results);\n\tpriv->results = pk_results_new ();\n\n\t/* reset transaction state */\n\t/* first set state manually, otherwise set_state will refuse to switch to an earlier stage */\n\tpriv->state = PK_TRANSACTION_STATE_READY;\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\n\n\tg_debug (\"transaction has been reset after lock-required issue.\");\n}\n\nstatic void\npk_transaction_class_init (PkTransactionClass *klass)\n{\n\tGObjectClass *object_class = G_OBJECT_CLASS (klass);\n\tobject_class->dispose = pk_transaction_dispose;\n\tobject_class->finalize = pk_transaction_finalize;\n\n\tsignals[SIGNAL_FINISHED] =\n\t\tg_signal_new (\"finished\",\n\t\t\t      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,\n\t\t\t      0, NULL, NULL, g_cclosure_marshal_VOID__VOID,\n\t\t\t      G_TYPE_NONE, 0);\n\tsignals[SIGNAL_STATE_CHANGED] =\n\t\tg_signal_new (\"state-changed\",\n\t\t\t      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,\n\t\t\t      0, NULL, NULL, g_cclosure_marshal_VOID__UINT,\n\t\t\t      G_TYPE_NONE, 1, G_TYPE_UINT);\n\tsignals[SIGNAL_ALLOW_CANCEL_CHANGED] =\n\t\tg_signal_new (\"allow-cancel-changed\",\n\t\t\t      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,\n\t\t\t      0, NULL, NULL, g_cclosure_marshal_VOID__UINT,\n\t\t\t      G_TYPE_NONE, 1, G_TYPE_UINT);\n\n\tg_type_class_add_private (klass, sizeof (PkTransactionPrivate));\n}\n\nstatic void\npk_transaction_init (PkTransaction *transaction)\n{\n\tgboolean ret;\n\tg_autoptr(GError) error = NULL;\n\ttransaction->priv = PK_TRANSACTION_GET_PRIVATE (transaction);\n\ttransaction->priv->allow_cancel = TRUE;\n\ttransaction->priv->caller_active = TRUE;\n\ttransaction->priv->cached_transaction_flags = PK_TRANSACTION_FLAG_ENUM_NONE;\n\ttransaction->priv->cached_filters = PK_FILTER_ENUM_NONE;\n\ttransaction->priv->client_uid = PK_TRANSACTION_UID_INVALID;\n\ttransaction->priv->client_pid = PK_TRANSACTION_PID_INVALID;\n\ttransaction->priv->role = PK_ROLE_ENUM_UNKNOWN;\n\ttransaction->priv->status = PK_STATUS_ENUM_WAIT;\n\ttransaction->priv->percentage = PK_BACKEND_PERCENTAGE_INVALID;\n\ttransaction->priv->state = PK_TRANSACTION_STATE_UNKNOWN;\n\ttransaction->priv->dbus = pk_dbus_new ();\n\ttransaction->priv->results = pk_results_new ();\n\ttransaction->priv->supported_content_types = g_ptr_array_new_with_free_func (g_free);\n\ttransaction->priv->cancellable = g_cancellable_new ();\n\n\ttransaction->priv->transaction_db = pk_transaction_db_new ();\n\tret = pk_transaction_db_load (transaction->priv->transaction_db, &error);\n\tif (!ret)\n\t\tg_error (\"PkEngine: failed to load transaction db: %s\", error->message);\n}\n\nstatic void\npk_transaction_dispose (GObject *object)\n{\n\tPkTransaction *transaction;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (object));\n\n\ttransaction = PK_TRANSACTION (object);\n\n\t/* were we waiting for the client to authorise */\n\tif (transaction->priv->waiting_for_auth) {\n\t\tg_cancellable_cancel (transaction->priv->cancellable);\n\t\t/* emit an ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_error_code_emit (transaction, PK_ERROR_ENUM_NOT_AUTHORIZED, \"client did not authorize action\");\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_FAILED, 0);\n\t}\n\n\tif (transaction->priv->registration_id > 0) {\n\t\tg_dbus_connection_unregister_object (transaction->priv->connection,\n\t\t\t\t\t\t     transaction->priv->registration_id);\n\t\ttransaction->priv->registration_id = 0;\n\t}\n\n\tunschedule_progress_changed (transaction);\n\n\t/* send signal to clients that we are about to be destroyed */\n\tif (transaction->priv->connection != NULL) {\n\t\tg_debug (\"emitting destroy %s\", transaction->priv->tid);\n\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t       \"Destroy\",\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       NULL);\n\t}\n\n\tG_OBJECT_CLASS (pk_transaction_parent_class)->dispose (object);\n}\n\nstatic void\npk_transaction_finalize (GObject *object)\n{\n\tPkTransaction *transaction;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (object));\n\n\ttransaction = PK_TRANSACTION (object);\n\n\tif (transaction->priv->subject != NULL)\n\t\tg_object_unref (transaction->priv->subject);\n\tif (transaction->priv->watch_id > 0)\n\t\tg_bus_unwatch_name (transaction->priv->watch_id);\n\tg_free (transaction->priv->last_package_id);\n\tg_free (transaction->priv->cached_package_id);\n\tg_free (transaction->priv->cached_key_id);\n\tg_strfreev (transaction->priv->cached_package_ids);\n\tg_free (transaction->priv->cached_transaction_id);\n\tg_free (transaction->priv->cached_directory);\n\tg_strfreev (transaction->priv->cached_values);\n\tg_free (transaction->priv->cached_repo_id);\n\tg_free (transaction->priv->cached_parameter);\n\tg_free (transaction->priv->cached_value);\n\tg_free (transaction->priv->tid);\n\tg_free (transaction->priv->sender);\n\tg_free (transaction->priv->cmdline);\n\tg_ptr_array_unref (transaction->priv->supported_content_types);\n\n\tif (transaction->priv->connection != NULL)\n\t\tg_object_unref (transaction->priv->connection);\n\tif (transaction->priv->introspection != NULL)\n\t\tg_dbus_node_info_unref (transaction->priv->introspection);\n\n\tg_key_file_unref (transaction->priv->conf);\n\tg_object_unref (transaction->priv->dbus);\n\tif (transaction->priv->backend != NULL)\n\t\tg_object_unref (transaction->priv->backend);\n\tg_object_unref (transaction->priv->job);\n\tg_object_unref (transaction->priv->transaction_db);\n\tg_object_unref (transaction->priv->results);\n\tif (transaction->priv->authority != NULL)\n\t\tg_object_unref (transaction->priv->authority);\n\tg_object_unref (transaction->priv->cancellable);\n\n\tG_OBJECT_CLASS (pk_transaction_parent_class)->finalize (object);\n}\n\nPkTransaction *\npk_transaction_new (GKeyFile *conf, GDBusNodeInfo *introspection)\n{\n\tPkTransaction *transaction;\n\ttransaction = g_object_new (PK_TYPE_TRANSACTION, NULL);\n\ttransaction->priv->conf = g_key_file_ref (conf);\n\ttransaction->priv->job = pk_backend_job_new (conf);\n\ttransaction->priv->introspection = g_dbus_node_info_ref (introspection);\n\treturn PK_TRANSACTION (transaction);\n}\n\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-\n *\n * Copyright (C) 2008-2014 Richard Hughes <richard@hughsie.com>\n *\n * Licensed under the GNU General Public License Version 2\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <signal.h>\n\n#include <string.h>\n#include <sys/types.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif /* HAVE_UNISTD_H */\n\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <syslog.h>\n\n#include <glib/gstdio.h>\n#include <glib/gi18n.h>\n#include <gio/gio.h>\n#include <packagekit-glib2/pk-common.h>\n#include <packagekit-glib2/pk-common-private.h>\n#include <packagekit-glib2/pk-enum.h>\n#include <packagekit-glib2/pk-offline-private.h>\n#include <packagekit-glib2/pk-package-id.h>\n#include <packagekit-glib2/pk-package-ids.h>\n#include <packagekit-glib2/pk-results.h>\n#include <polkit/polkit.h>\n\n#include \"pk-backend.h\"\n#include \"pk-dbus.h\"\n#include \"pk-shared.h\"\n#include \"pk-transaction-db.h\"\n#include \"pk-transaction.h\"\n#include \"pk-transaction-private.h\"\n\n#ifndef HAVE_POLKIT_0_114\nG_DEFINE_AUTOPTR_CLEANUP_FUNC(PolkitAuthorizationResult, g_object_unref)\nG_DEFINE_AUTOPTR_CLEANUP_FUNC(PolkitDetails, g_object_unref)\n#endif\n\nstatic void     pk_transaction_finalize\t\t(GObject\t    *object);\nstatic void     pk_transaction_dispose\t\t(GObject\t    *object);\n\nstatic gchar *pk_transaction_get_content_type_for_file (const gchar *filename, GError **error);\nstatic gboolean pk_transaction_is_supported_content_type (PkTransaction *transaction, const gchar *content_type);\n\n#define PK_TRANSACTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PK_TYPE_TRANSACTION, PkTransactionPrivate))\n#define PK_TRANSACTION_UPDATES_CHANGED_TIMEOUT\t100 /* ms */\n\n/* when the UID is invalid or not known */\n#define PK_TRANSACTION_UID_INVALID\t\tG_MAXUINT32\n\n/* when the client PID is invalid or not known */\n#define PK_TRANSACTION_PID_INVALID\t\tG_MAXUINT32\n\n/* maximum number of items that can be resolved in one go */\n#define PK_TRANSACTION_MAX_ITEMS_TO_RESOLVE\t10000\n\nstruct PkTransactionPrivate\n{\n\tPkRoleEnum\t\t role;\n\tPkStatusEnum\t\t status;\n\tPkTransactionState\t state;\n\tguint\t\t\t percentage;\n\tguint\t\t\t elapsed_time;\n\tguint\t\t\t remaining_time;\n\tguint\t\t\t speed;\n\tguint\t\t\t download_size_remaining;\n\tgboolean\t\t finished;\n\tgboolean\t\t emitted_finished;\n\tgboolean\t\t allow_cancel;\n\tgboolean\t\t waiting_for_auth;\n\tgboolean\t\t emit_eula_required;\n\tgboolean\t\t emit_signature_required;\n\tgboolean\t\t emit_media_change_required;\n\tgboolean\t\t caller_active;\n\tgboolean\t\t exclusive;\n\tguint32\t\t\t client_uid;\n\tguint32\t\t\t client_pid;\n\tguint\t\t\t watch_id;\n\tPkBackend\t\t*backend;\n\tPkBackendJob\t\t*job;\n\tGKeyFile\t\t*conf;\n\tPkDbus\t\t\t*dbus;\n\tPolkitAuthority\t\t*authority;\n\tPolkitSubject\t\t*subject;\n\tGCancellable\t\t*cancellable;\n\tgboolean\t\t skip_auth_check;\n\tgboolean\t\t client_supports_plural_signals;\n\n\t/* Rate limiting of progress reporting */\n\tgboolean\t\t progress_changed;\n\tGSource\t\t\t*progress_timeout_source;  /* (nullable) (owned) */\n\n\t/* needed for gui coldplugging */\n\tgchar\t\t\t*last_package_id;\n\tgchar\t\t\t*tid;\n\tgchar\t\t\t*sender;\n\tgchar\t\t\t*cmdline;\n\tPkResults\t\t*results;\n\tPkTransactionDb\t\t*transaction_db;\n\n\t/* cached */\n\tgboolean\t\t cached_force;\n\tgboolean\t\t cached_allow_deps;\n\tgboolean\t\t cached_autoremove;\n\tgboolean\t\t cached_enabled;\n\tPkBitfield\t\t cached_transaction_flags;\n\tgchar\t\t\t*cached_package_id;\n\tgchar\t\t\t**cached_package_ids;\n\tgchar\t\t\t*cached_transaction_id;\n\tgchar\t\t\t**cached_full_paths;\n\tPkBitfield\t\t cached_filters;\n\tgchar\t\t\t**cached_values;\n\tgchar\t\t\t*cached_repo_id;\n\tgchar\t\t\t*cached_key_id;\n\tgchar\t\t\t*cached_parameter;\n\tgchar\t\t\t*cached_value;\n\tgchar\t\t\t*cached_directory;\n\tgchar\t\t\t*cached_cat_id;\n\tPkUpgradeKindEnum\t cached_upgrade_kind;\n\tGPtrArray\t\t*supported_content_types;\n\tguint\t\t\t registration_id;\n\tGDBusConnection\t\t*connection;\n\tGDBusNodeInfo\t\t*introspection;\n};\n\ntypedef enum {\n\tPK_TRANSACTION_ERROR_DENIED,\n\tPK_TRANSACTION_ERROR_NOT_RUNNING,\n\tPK_TRANSACTION_ERROR_NO_ROLE,\n\tPK_TRANSACTION_ERROR_CANNOT_CANCEL,\n\tPK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\tPK_TRANSACTION_ERROR_NO_SUCH_TRANSACTION,\n\tPK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\tPK_TRANSACTION_ERROR_NO_SUCH_DIRECTORY,\n\tPK_TRANSACTION_ERROR_TRANSACTION_EXISTS_WITH_ROLE,\n\tPK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\tPK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\tPK_TRANSACTION_ERROR_SEARCH_INVALID,\n\tPK_TRANSACTION_ERROR_SEARCH_PATH_INVALID,\n\tPK_TRANSACTION_ERROR_FILTER_INVALID,\n\tPK_TRANSACTION_ERROR_INPUT_INVALID,\n\tPK_TRANSACTION_ERROR_INVALID_STATE,\n\tPK_TRANSACTION_ERROR_INITIALIZE_FAILED,\n\tPK_TRANSACTION_ERROR_COMMIT_FAILED,\n\tPK_TRANSACTION_ERROR_INVALID_PROVIDE,\n\tPK_TRANSACTION_ERROR_PACK_INVALID,\n\tPK_TRANSACTION_ERROR_MIME_TYPE_NOT_SUPPORTED,\n\tPK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\tPK_TRANSACTION_ERROR_LAST\n} PkTransactionError;\n\nenum {\n\tSIGNAL_FINISHED,\n\tSIGNAL_STATE_CHANGED,\n\tSIGNAL_ALLOW_CANCEL_CHANGED,\n\tSIGNAL_LAST\n};\n\nstatic guint signals[SIGNAL_LAST] = { 0 };\n\nG_DEFINE_TYPE (PkTransaction, pk_transaction, G_TYPE_OBJECT)\n\nGQuark\npk_transaction_error_quark (void)\n{\n\tstatic GQuark quark = 0;\n\tif (!quark) {\n\t\tquark = g_quark_from_static_string (\"pk-transaction-error-quark\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_DENIED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".Denied\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_RUNNING,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NotRunning\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_ROLE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoRole\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_CANNOT_CANCEL,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".CannotCancel\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NotSupported\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_TRANSACTION,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoSuchTransaction\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoSuchFile\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_DIRECTORY,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NoSuchDirectory\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_TRANSACTION_EXISTS_WITH_ROLE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".TransactionExistsWithRole\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".RefusedByPolicy\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".PackageIdInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".SearchInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".PathInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_FILTER_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".FilterInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InputInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INVALID_STATE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InvalidState\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INITIALIZE_FAILED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InitializeFailed\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_COMMIT_FAILED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".CommitFailed\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_INVALID_PROVIDE,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".InvalidProvide\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_PACK_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".PackInvalid\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_MIME_TYPE_NOT_SUPPORTED,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".MimeTypeNotSupported\");\n\t\tg_dbus_error_register_error (quark,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\t\t\t\t\t     PK_DBUS_INTERFACE_TRANSACTION \".NumberOfPackagesInvalid\");\n\t}\n\treturn quark;\n}\n\nstatic guint\npk_transaction_get_runtime (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), 0);\n\tg_return_val_if_fail (transaction->priv->tid != NULL, 0);\n\treturn pk_backend_job_get_runtime (transaction->priv->job);\n}\n\ngboolean\npk_transaction_get_background (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\treturn pk_backend_job_get_background (transaction->priv->job);\n}\n\nstatic gboolean\npk_transaction_finish_invalidate_caches (PkTransaction *transaction)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\n\t/* could the update list have changed? */\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_SIMULATE))\n\t\tgoto out;\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD))\n\t\tgoto out;\n\tif (priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_REPO_ENABLE ||\n\t    priv->role == PK_ROLE_ENUM_REPO_SET_DATA ||\n\t    priv->role == PK_ROLE_ENUM_REPO_REMOVE ||\n\t    priv->role == PK_ROLE_ENUM_REFRESH_CACHE) {\n\n\t\t/* this needs to be done after a small delay */\n\t\tpk_backend_updates_changed_delay (priv->backend,\n\t\t\t\t\t\t  PK_TRANSACTION_UPDATES_CHANGED_TIMEOUT);\n\t}\nout:\n\treturn TRUE;\n}\n\nstatic void pk_transaction_emit_properties_changed (PkTransaction *transaction,\n                                                    const gchar   *first_property_name,\n                                                    GVariant      *first_property_value,\n                                                    ...) G_GNUC_NULL_TERMINATED;\n\nstatic void\npk_transaction_emit_properties_changed (PkTransaction *transaction,\n                                        const gchar   *first_property_name,\n                                        GVariant      *first_property_value,\n                                        ...)\n{\n\tGVariantBuilder builder;\n\tGVariantBuilder invalidated_builder;\n\tva_list args;\n\tconst gchar *property_name;\n\tGVariant *property_value;\n\n\t/* build the dict */\n\tg_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE (\"as\"));\n\tg_variant_builder_init (&builder, G_VARIANT_TYPE_ARRAY);\n\n\tva_start (args, first_property_value);\n\n\tfor (property_name = first_property_name, property_value = first_property_value;\n\t     property_name != NULL;\n\t     property_name = va_arg (args, const gchar *), property_value = (property_name != NULL) ? va_arg (args, GVariant *) : NULL) {\n\t\tg_variant_builder_add (&builder,\n\t\t\t\t       \"{sv}\",\n\t\t\t\t       property_name,\n\t\t\t\t       property_value);\n\t}\n\n\tva_end (args);\n\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       \"org.freedesktop.DBus.Properties\",\n\t\t\t\t       \"PropertiesChanged\",\n\t\t\t\t       g_variant_new (\"(sa{sv}as)\",\n\t\t\t\t\t\t      PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t\t      &builder,\n\t\t\t\t\t\t      &invalidated_builder),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_emit_property_changed (PkTransaction *transaction,\n                                      const gchar   *property_name,\n                                      GVariant      *property_value)\n{\n\tpk_transaction_emit_properties_changed (transaction,\n\t\t\t\t\t\tproperty_name, property_value,\n\t\t\t\t\t\tNULL);\n}\n\n/* If any progress-related properties have changed since the last\n * `PropertiesChanged` emission, immediately emit that D-Bus signal with the\n * latest values and clear the pending changes flag.\n *\n * See schedule_progress_changed().\n */\nstatic void\nflush_progress_changed (PkTransaction *transaction)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\tif (!priv->progress_changed)\n\t\treturn;\n\n\t/* Emit a D-Bus signal to notify of the progress changes. */\n\tpk_transaction_emit_properties_changed (transaction,\n\t\t\t\t\t\t\"Percentage\", g_variant_new_uint32 (priv->percentage),\n\t\t\t\t\t\t\"ElapsedTime\", g_variant_new_uint32 (priv->elapsed_time),\n\t\t\t\t\t\t\"RemainingTime\", g_variant_new_uint32 (priv->remaining_time),\n\t\t\t\t\t\t\"Speed\", g_variant_new_uint32 (priv->speed),\n\t\t\t\t\t\t\"DownloadSizeRemaining\", g_variant_new_uint64 (priv->download_size_remaining),\n\t\t\t\t\t\tNULL);\n\n\tpriv->progress_changed = FALSE;\n}\n\nstatic gboolean\nprogress_timeout_cb (gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\n\tflush_progress_changed (transaction);\n\n\treturn G_SOURCE_CONTINUE;\n}\n\n/* Aggregate progress-related property notifications so that the transaction\n * doesn\u2019t emit multiple D-Bus signals every millisecond for fast-progressing\n * operations (which are quite common).\n *\n * Instead, emit signals on a timer, set to 100ms (which should be fast enough\n * for users to not notice the quantisation).\n *\n * This significantly reduces the context switching overhead between\n * packagekitd, dbus-daemon, and the PackageKit clients.\n *\n * If the transaction reaches a point where property notifications need to be\n * synced up with other externally-visible transaction state (such as if another\n * progress calls `org.freedesktop.DBus.Properties.Get()`), call\n * flush_progress_changed().\n */\nstatic void\nschedule_progress_changed (PkTransaction *transaction)\n{\n\ttransaction->priv->progress_changed = TRUE;\n\n\tif (transaction->priv->progress_timeout_source == NULL) {\n\t\tg_autoptr(GSource) source = NULL;\n\n\t\tsource = g_timeout_source_new (100  /* ms */);\n\t\tg_source_set_callback (source, G_SOURCE_FUNC (progress_timeout_cb), transaction, NULL);\n\n#if GLIB_CHECK_VERSION(2, 70, 0)\n\t\tg_source_set_static_name (source, \"PkTransaction progress timeout\");\n#endif\n\n\t\tg_source_attach (source, g_main_context_get_thread_default ());\n\t\ttransaction->priv->progress_timeout_source = g_steal_pointer (&source);\n\t}\n}\n\n/* Remove the @progress_timeout_source, if set. */\nstatic void\nunschedule_progress_changed (PkTransaction *transaction)\n{\n\tflush_progress_changed (transaction);\n\n\tif (transaction->priv->progress_timeout_source != NULL) {\n\t\tg_source_destroy (transaction->priv->progress_timeout_source);\n\t\tg_clear_pointer (&transaction->priv->progress_timeout_source, g_source_unref);\n\t}\n}\n\nstatic void\npk_transaction_progress_changed_emit (PkTransaction *transaction,\n\t\t\t\t     guint percentage,\n\t\t\t\t     guint elapsed,\n\t\t\t\t     guint remaining)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\tif (transaction->priv->percentage == percentage &&\n\t    transaction->priv->elapsed_time == elapsed &&\n\t    transaction->priv->remaining_time == remaining)\n\t\treturn;\n\n\ttransaction->priv->percentage = percentage;\n\ttransaction->priv->elapsed_time = elapsed;\n\ttransaction->priv->remaining_time = remaining;\n\n\tschedule_progress_changed (transaction);\n}\n\nstatic void\npk_transaction_allow_cancel_emit (PkTransaction *transaction, gboolean allow_cancel)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\t/* already set */\n\tif (transaction->priv->allow_cancel == allow_cancel)\n\t\treturn;\n\n\ttransaction->priv->allow_cancel = allow_cancel;\n\n\t/* proxy this up so we can change the system inhibit */\n\tg_signal_emit (transaction, signals[SIGNAL_ALLOW_CANCEL_CHANGED], 0, allow_cancel);\n\n\t/* emit */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"AllowCancel\",\n\t\t\t\t\t      g_variant_new_boolean (allow_cancel));\n}\n\nstatic void\npk_transaction_status_changed_emit (PkTransaction *transaction, PkStatusEnum status)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* already set */\n\tif (transaction->priv->status == status)\n\t\treturn;\n\n\ttransaction->priv->status = status;\n\n\t/* Emit the status change, and also flush out any pending progress updates,\n\t * since the client will want to know the latest values of those\n\t * alongside the status. */\n\tflush_progress_changed (transaction);\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"Status\",\n\t\t\t\t\t      g_variant_new_uint32 (status));\n}\n\nstatic void\npk_transaction_finished_emit (PkTransaction *transaction,\n\t\t\t      PkExitEnum exit_enum,\n\t\t\t      guint time_ms)\n{\n\tg_assert (!transaction->priv->emitted_finished);\n\ttransaction->priv->emitted_finished = TRUE;\n\n\tg_debug (\"emitting finished '%s', %i\",\n\t\t pk_exit_enum_to_string (exit_enum),\n\t\t time_ms);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Finished\",\n\t\t\t\t       g_variant_new (\"(uu)\",\n\t\t\t\t\t\t      exit_enum,\n\t\t\t\t\t\t      time_ms),\n\t\t\t\t       NULL);\n\n\t/* For the transaction list */\n\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n}\n\nstatic void\npk_transaction_error_code_emit (PkTransaction *transaction,\n\t\t\t\tPkErrorEnum error_enum,\n\t\t\t\tconst gchar *details)\n{\n\tg_debug (\"emitting error-code %s, '%s'\",\n\t\t pk_error_enum_to_string (error_enum),\n\t\t details);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"ErrorCode\",\n\t\t\t\t       g_variant_new (\"(us)\",\n\t\t\t\t\t\t      error_enum,\n\t\t\t\t\t\t      details),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_allow_cancel_cb (PkBackendJob *job,\n\t\t\t\tgboolean allow_cancel,\n\t\t\t\tPkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"emitting allow-cancel %i\", allow_cancel);\n\tpk_transaction_allow_cancel_emit (transaction, allow_cancel);\n}\n\nstatic void\npk_transaction_locked_changed_cb (PkBackendJob *job,\n\t\t\t\tgboolean locked,\n\t\t\t\tPkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"backend job lock status changed: %i\", locked);\n\n\t/* if backend cache is locked at some time, this transaction is running in exclusive mode */\n\tif (locked)\n\t\tpk_transaction_make_exclusive (transaction);\n}\n\nstatic void\npk_transaction_details_cb (PkBackendJob *job,\n\t\t\t   PkDetails *item,\n\t\t\t   PkTransaction *transaction)\n{\n\tGVariantBuilder builder;\n\tPkGroupEnum group;\n\tconst gchar *tmp;\n\tguint64 size;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_details (transaction->priv->results, item);\n\n\t/* emit */\n\tg_debug (\"emitting details\");\n\tg_variant_builder_init (&builder, G_VARIANT_TYPE(\"a{sv}\"));\n\tg_variant_builder_add (&builder, \"{sv}\", \"package-id\",\n\t\t\t       g_variant_new_string (pk_details_get_package_id (item)));\n\tgroup = pk_details_get_group (item);\n\tif (group != PK_GROUP_ENUM_UNKNOWN)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"group\",\n\t\t\t\t       g_variant_new_uint32 (group));\n\ttmp = pk_details_get_summary (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"summary\",\n\t\t\t\t       g_variant_new_string (tmp));\n\ttmp = pk_details_get_description (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"description\",\n\t\t\t\t       g_variant_new_string (tmp));\n\ttmp = pk_details_get_url (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"url\",\n\t\t\t\t       g_variant_new_string (tmp));\n\ttmp = pk_details_get_license (item);\n\tif (tmp != NULL)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"license\",\n\t\t\t\t       g_variant_new_string (tmp));\n\tsize = pk_details_get_size (item);\n\tif (size != 0)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"size\",\n\t\t\t\t       g_variant_new_uint64 (size));\n\tsize = pk_details_get_download_size (item);\n\tif (size != G_MAXUINT64)\n\t\tg_variant_builder_add (&builder, \"{sv}\", \"download-size\",\n\t\t\t\t       g_variant_new_uint64 (size));\n\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Details\",\n\t\t\t\t       g_variant_new (\"(a{sv})\", &builder),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_error_code_cb (PkBackendJob *job,\n\t\t\t      PkError *item,\n\t\t\t      PkTransaction *transaction)\n{\n\tPkErrorEnum code;\n\tg_autofree gchar *details = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"code\", &code,\n\t\t      \"details\", &details,\n\t\t      NULL);\n\n\tif (code == PK_ERROR_ENUM_UNKNOWN) {\n\t\tg_warning (\"%s emitted 'unknown error'\",\n\t\t\t   pk_role_enum_to_string (transaction->priv->role));\n\t}\n\n\t/* add to results */\n\tpk_results_set_error_code (transaction->priv->results, item);\n\n\tif (!transaction->priv->exclusive && code == PK_ERROR_ENUM_LOCK_REQUIRED) {\n\t\t/* the backend failed to get lock for this action, this means this transaction has to be run in exclusive mode */\n\t\tg_debug (\"changing transaction to exclusive mode (after failing with lock-required)\");\n\t\ttransaction->priv->exclusive = TRUE;\n\t} else {\n\t\t/* emit, as it is not the internally-handled LOCK_REQUIRED code */\n\t\tpk_transaction_error_code_emit (transaction, code, details);\n\t}\n}\n\nstatic void\npk_transaction_files_cb (PkBackendJob *job,\n\t\t\t PkFiles *item,\n\t\t\t PkTransaction *transaction)\n{\n\tguint i;\n\tg_autofree gchar *package_id = NULL;\n\tg_auto(GStrv) files = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"package-id\", &package_id,\n\t\t      \"files\", &files,\n\t\t      NULL);\n\n\t/* ensure the files have the correct prefix */\n\tif (transaction->priv->role == PK_ROLE_ENUM_DOWNLOAD_PACKAGES &&\n\t    transaction->priv->cached_directory != NULL) {\n\t\tfor (i = 0; files[i] != NULL; i++) {\n\t\t\tif (!g_str_has_prefix (files[i], transaction->priv->cached_directory)) {\n\t\t\t\tg_warning (\"%s does not have the correct prefix (%s)\",\n\t\t\t\t\t   files[i],\n\t\t\t\t\t   transaction->priv->cached_directory);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* add to results */\n\tpk_results_add_files (transaction->priv->results, item);\n\n\t/* emit */\n\tg_debug (\"emitting files %s\", package_id);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Files\",\n\t\t\t\t       g_variant_new (\"(s^as)\",\n\t\t\t\t\t\t      package_id != NULL ? package_id : \"\",\n\t\t\t\t\t\t      files),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_category_cb (PkBackendJob *job,\n\t\t\t    PkCategory *item,\n\t\t\t    PkTransaction *transaction)\n{\n\tg_autofree gchar *parent_id = NULL;\n\tg_autofree gchar *cat_id = NULL;\n\tg_autofree gchar *name = NULL;\n\tg_autofree gchar *summary = NULL;\n\tg_autofree gchar *icon = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_category (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"parent-id\", &parent_id,\n\t\t      \"cat-id\", &cat_id,\n\t\t      \"name\", &name,\n\t\t      \"summary\", &summary,\n\t\t      \"icon\", &icon,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting category %s, %s, %s, %s, %s \", parent_id, cat_id, name, summary, icon);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Category\",\n\t\t\t\t       g_variant_new (\"(sssss)\",\n\t\t\t\t\t\t      parent_id != NULL ? parent_id : \"\",\n\t\t\t\t\t\t      cat_id,\n\t\t\t\t\t\t      name,\n\t\t\t\t\t\t      summary,\n\t\t\t\t\t\t      icon != NULL ? icon : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_item_progress_cb (PkBackendJob *job,\n\t\t\t\t PkItemProgress *item_progress,\n\t\t\t\t PkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* emit */\n\tg_debug (\"emitting item-progress %s, %s: %u\",\n\t\t pk_item_progress_get_package_id (item_progress),\n\t\t pk_status_enum_to_string (pk_item_progress_get_status (item_progress)),\n\t\t pk_item_progress_get_percentage (item_progress));\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"ItemProgress\",\n\t\t\t\t       g_variant_new (\"(suu)\",\n\t\t\t\t\t\t      pk_item_progress_get_package_id (item_progress),\n\t\t\t\t\t\t      pk_item_progress_get_status (item_progress),\n\t\t\t\t\t\t      pk_item_progress_get_percentage (item_progress)),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_distro_upgrade_cb (PkBackendJob *job,\n\t\t\t\t  PkDistroUpgrade *item,\n\t\t\t\t  PkTransaction *transaction)\n{\n\tPkUpdateStateEnum state;\n\tg_autofree gchar *name = NULL;\n\tg_autofree gchar *summary = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_distro_upgrade (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"state\", &state,\n\t\t      \"name\", &name,\n\t\t      \"summary\", &summary,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting distro-upgrade %s, %s, %s\",\n\t\t pk_update_state_enum_to_string (state),\n\t\t name, summary);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"DistroUpgrade\",\n\t\t\t\t       g_variant_new (\"(uss)\",\n\t\t\t\t\t\t      state,\n\t\t\t\t\t\t      name,\n\t\t\t\t\t\t      summary != NULL ? summary : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic gchar *\npk_transaction_package_list_to_string (GPtrArray *array)\n{\n\tGString *string;\n\tPkPackage *pkg;\n\tguint i;\n\n\tstring = g_string_new (\"\");\n\tfor (i = 0; i < array->len; i++) {\n\t\tpkg = g_ptr_array_index (array, i);\n\t\tg_string_append_printf (string, \"%s\\t%s\\t%s\\n\",\n\t\t\t\t\tpk_info_enum_to_string (pk_package_get_info (pkg)),\n\t\t\t\t\tpk_package_get_id (pkg),\n\t\t\t\t\tpk_package_get_summary (pkg));\n\t}\n\n\t/* remove trailing newline */\n\tif (string->len != 0)\n\t\tg_string_set_size (string, string->len-1);\n\treturn g_string_free (string, FALSE);\n}\n\nconst gchar *\npk_transaction_state_to_string (PkTransactionState state)\n{\n\tif (state == PK_TRANSACTION_STATE_NEW)\n\t\treturn \"new\";\n\tif (state == PK_TRANSACTION_STATE_WAITING_FOR_AUTH)\n\t\treturn \"waiting-for-auth\";\n\tif (state == PK_TRANSACTION_STATE_READY)\n\t\treturn \"ready\";\n\tif (state == PK_TRANSACTION_STATE_RUNNING)\n\t\treturn \"running\";\n\tif (state == PK_TRANSACTION_STATE_FINISHED)\n\t\treturn \"finished\";\n\tif (state == PK_TRANSACTION_STATE_ERROR)\n\t\treturn \"error\";\n\treturn NULL;\n}\n\n/**\n * pk_transaction_set_state:\n *\n * A transaction can have only one state at any time as it is processed.\n * Typically, these states will be:\n *\n * 1. 'new'\n * 2. 'waiting for auth'  <--- waiting for PolicyKit (optional)\n * 3. 'ready'\t     <--- when the transaction is ready to be run\n * 4. 'running'\t   <--- where PkBackend gets used\n * 5. 'finished'\n *\n **/\nvoid\npk_transaction_set_state (PkTransaction *transaction, PkTransactionState state)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* check we're not going backwards */\n\tif (priv->state != PK_TRANSACTION_STATE_UNKNOWN &&\n\t    priv->state > state) {\n\t\tg_warning (\"cannot set %s, as already %s\",\n\t\t\t   pk_transaction_state_to_string (state),\n\t\t\t   pk_transaction_state_to_string (priv->state));\n\t\treturn;\n\t}\n\n\t/* check we're not assuming the same state twice */\n\tif (priv->state == state) {\n\t\tg_warning (\"cannot set %s, as already in that state\",\n\t\t\t   pk_transaction_state_to_string (state));\n\t\treturn;\n\t}\n\n\tg_debug (\"transaction now %s\", pk_transaction_state_to_string (state));\n\tpriv->state = state;\n\tg_signal_emit (transaction, signals[SIGNAL_STATE_CHANGED], 0, state);\n\n\t/* only get cmdline when it's going to be saved into the database */\n\tif (priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\t\tif (priv->client_pid != PK_TRANSACTION_PID_INVALID && priv->cmdline == NULL)\n\t\t\tpriv->cmdline = pk_get_cmdline_for_pid (priv->client_pid);\n\t}\n\n\t/* only save into the database for useful stuff */\n\tif (state == PK_TRANSACTION_STATE_READY &&\n\t    (priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t     priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t     priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES)) {\n\n\t\t/* add to database */\n\t\tpk_transaction_db_add (priv->transaction_db, priv->tid);\n\n\t\t/* save role in the database */\n\t\tpk_transaction_db_set_role (priv->transaction_db, priv->tid, priv->role);\n\n\t\t/* save uid */\n\t\tpk_transaction_db_set_uid (priv->transaction_db, priv->tid, priv->client_uid);\n\n\t\t/* save cmdline in db */\n\t\tif (priv->cmdline != NULL)\n\t\t\tpk_transaction_db_set_cmdline (priv->transaction_db, priv->tid, priv->cmdline);\n\n\t\t/* report to syslog */\n\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\"new %s transaction %s scheduled from uid %i\",\n\t\t\tpk_role_enum_to_string (priv->role),\n\t\t\tpriv->tid, priv->client_uid);\n\t}\n\n\t/* update GUI */\n\tif (state == PK_TRANSACTION_STATE_WAITING_FOR_AUTH) {\n\t\tpk_transaction_status_changed_emit (transaction,\n\t\t\t\t\t\t    PK_STATUS_ENUM_WAITING_FOR_AUTH);\n\t\tpk_transaction_progress_changed_emit (transaction,\n\t\t\t\t\t\t      PK_BACKEND_PERCENTAGE_INVALID,\n\t\t\t\t\t\t      0, 0);\n\n\t} else if (state == PK_TRANSACTION_STATE_READY) {\n\t\tpk_transaction_status_changed_emit (transaction,\n\t\t\t\t\t\t    PK_STATUS_ENUM_WAIT);\n\t\tpk_transaction_progress_changed_emit (transaction,\n\t\t\t\t\t\t      PK_BACKEND_PERCENTAGE_INVALID,\n\t\t\t\t\t\t      0, 0);\n\t}\n}\n\nPkTransactionState\npk_transaction_get_state (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), PK_TRANSACTION_STATE_UNKNOWN);\n\n\treturn transaction->priv->state;\n}\n\nguint\npk_transaction_get_uid (PkTransaction *transaction)\n{\n\treturn transaction->priv->client_uid;\n}\n\nstatic void\npk_transaction_setup_mime_types (PkTransaction *transaction)\n{\n\tguint i;\n\tg_auto(GStrv) mime_types = NULL;\n\n\t/* get list of mime types supported by backends */\n\tmime_types = pk_backend_get_mime_types (transaction->priv->backend);\n\tfor (i = 0; mime_types[i] != NULL; i++) {\n\t\tg_ptr_array_add (transaction->priv->supported_content_types,\n\t\t\t\t g_strdup (mime_types[i]));\n\t}\n}\n\nvoid\npk_transaction_set_backend (PkTransaction *transaction,\n\t\t\t    PkBackend *backend)\n{\n\t/* save a reference */\n\tif (transaction->priv->backend != NULL)\n\t\tg_object_unref (transaction->priv->backend);\n\ttransaction->priv->backend = g_object_ref (backend);\n\n\t/* setup supported mime types */\n\tpk_transaction_setup_mime_types (transaction);\n}\n\n/**\n* pk_transaction_get_backend_job:\n*\n* Returns: (transfer none): Current PkBackendJob for this transaction\n**/\nPkBackendJob *\npk_transaction_get_backend_job (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), NULL);\n\treturn transaction->priv->job;\n}\n\n/**\n * pk_transaction_is_finished_with_lock_required:\n **/\ngboolean\npk_transaction_is_finished_with_lock_required (PkTransaction *transaction)\n{\n\tg_autoptr(PkError) error_code = NULL;\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\n\terror_code = pk_results_get_error_code (transaction->priv->results);\n\tif (error_code != NULL &&\n\t    pk_error_get_code (error_code) == PK_ERROR_ENUM_LOCK_REQUIRED) {\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic void\npk_transaction_offline_invalidate_check (PkTransaction *transaction)\n{\n\tPkPackage *pkg;\n\tconst gchar *package_id;\n\tgchar **package_ids;\n\tguint i;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(PkPackageSack) sack = NULL;\n\tg_autoptr(GPtrArray) invalidated = NULL;\n\n\t/* get the existing prepared updates */\n\tsack = pk_offline_get_prepared_sack (NULL);\n\tif (sack == NULL)\n\t\treturn;\n\n\t/* are there any requested packages that match in prepared-updates */\n\tpackage_ids = transaction->priv->cached_package_ids;\n\tfor (i = 0; package_ids[i] != NULL; i++) {\n\t\tpkg = pk_package_sack_find_by_id_name_arch (sack, package_ids[i]);\n\t\tif (pkg != NULL) {\n\t\t\tg_debug (\"%s modified %s, invalidating prepared-updates\",\n\t\t\t\t package_ids[i], pk_package_get_id (pkg));\n\t\t\tif (!pk_offline_auth_invalidate (&error)) {\n\t\t\t\tg_warning (\"failed to invalidate: %s\",\n\t\t\t\t\t   error->message);\n\t\t\t}\n\t\t\tg_object_unref (pkg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* are there any changed deps that match a package in prepared-updates */\n\tinvalidated = pk_results_get_package_array (transaction->priv->results);\n\tfor (i = 0; i < invalidated->len; i++) {\n\t\tpackage_id = pk_package_get_id (g_ptr_array_index (invalidated, i));\n\t\tpkg = pk_package_sack_find_by_id_name_arch (sack, package_id);\n\t\tif (pkg != NULL) {\n\t\t\tg_debug (\"%s modified %s, invalidating prepared-updates\",\n\t\t\t\t package_id, pk_package_get_id (pkg));\n\t\t\tif (!pk_offline_auth_invalidate (&error)) {\n\t\t\t\tg_warning (\"failed to invalidate: %s\",\n\t\t\t\t\t   error->message);\n\t\t\t}\n\t\t\tg_object_unref (pkg);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\npk_transaction_offline_finished (PkTransaction *transaction)\n{\n\tPkBitfield transaction_flags;\n\tgchar **package_ids;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(GPtrArray) array = NULL;\n\n\t/* if we're doing UpdatePackages[only-download] then update the\n\t * prepared-updates file */\n\ttransaction_flags = transaction->priv->cached_transaction_flags;\n\tif (transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES &&\n\t    pk_bitfield_contain (transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD)) {\n\t\tpackage_ids = transaction->priv->cached_package_ids;\n\t\tif (!pk_offline_auth_set_prepared_ids (package_ids, &error)) {\n\t\t\tg_warning (\"failed to write offline update: %s\",\n\t\t\t\t   error->message);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* if we're doing UpgradeSystem[only-download] then update the\n\t * prepared-upgrade file */\n\ttransaction_flags = transaction->priv->cached_transaction_flags;\n\tif (transaction->priv->role == PK_ROLE_ENUM_UPGRADE_SYSTEM &&\n\t    pk_bitfield_contain (transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD)) {\n\t\tconst gchar *version = transaction->priv->cached_value;\n\t\tg_autofree gchar *name = NULL;\n\n\t\tname = pk_get_distro_name (&error);\n\t\tif (name == NULL) {\n\t\t\tg_warning (\"failed to get distro name: %s\",\n\t\t\t\t   error->message);\n\t\t\treturn;\n\t\t}\n\t\tif (!pk_offline_auth_set_prepared_upgrade (name, version, &error)) {\n\t\t\tg_warning (\"failed to write offline system upgrade state: %s\",\n\t\t\t\t   error->message);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\tswitch (transaction->priv->role) {\n\tcase PK_ROLE_ENUM_GET_UPDATES:\n\t\t/* if we do get-updates and there's no updates then remove\n\t\t * prepared-updates so the UI doesn't display update & reboot */\n\t\tarray = pk_results_get_package_array (transaction->priv->results);\n\t\tif (array->len == 0) {\n\t\t\tif (!pk_offline_auth_invalidate (&error)) {\n\t\t\t\tg_warning (\"failed to invalidate: %s\",\n\t\t\t\t\t   error->message);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REFRESH_CACHE:\n\tcase PK_ROLE_ENUM_REPO_SET_DATA:\n\tcase PK_ROLE_ENUM_REPO_ENABLE:\n\t\t/* delete the prepared updates file as it's not valid */\n\t\tif (!pk_offline_auth_invalidate (&error))\n\t\t\tg_warning (\"failed to invalidate: %s\", error->message);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_UPDATE_PACKAGES:\n\tcase PK_ROLE_ENUM_INSTALL_PACKAGES:\n\tcase PK_ROLE_ENUM_REMOVE_PACKAGES:\n\t\t/* delete the file if the action affected any package\n\t\t * already listed in the prepared updates file */\n\t\tpk_transaction_offline_invalidate_check (transaction);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\npk_transaction_finished_cb (PkBackendJob *job, PkExitEnum exit_enum, PkTransaction *transaction)\n{\n\tguint time_ms;\n\tguint i;\n\tPkPackage *item;\n\tPkInfoEnum info;\n\tPkBitfield transaction_flags;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished\");\n\t\treturn;\n\t}\n\n\t/* Ensure any pending progress has been emitted and remove the progress\n\t * timer since it\u2019s unlikely to be used again. */\n\tunschedule_progress_changed (transaction);\n\n\t/* save this so we know if the cache is valid */\n\tpk_results_set_exit_code (transaction->priv->results, exit_enum);\n\n\t/* don't really finish the transaction if we only completed to wait for lock */\n\tif (exit_enum != PK_EXIT_ENUM_CANCELLED &&\n\t    pk_transaction_is_finished_with_lock_required (transaction)) {\n\t\t/* finish only for the transaction list */\n\t\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n\t\treturn;\n\t}\n\n\t/* handle offline updates */\n\ttransaction_flags = transaction->priv->cached_transaction_flags;\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS &&\n\t    !pk_bitfield_contain (transaction_flags, PK_TRANSACTION_FLAG_ENUM_SIMULATE)) {\n\t\tpk_transaction_offline_finished (transaction);\n\t}\n\n\t/* we should get no more from the backend with this tid */\n\ttransaction->priv->finished = TRUE;\n\n\t/* if we did ::repo-signature-required or ::eula-required, change the error code */\n\tif (transaction->priv->emit_signature_required)\n\t\texit_enum = PK_EXIT_ENUM_KEY_REQUIRED;\n\telse if (transaction->priv->emit_eula_required)\n\t\texit_enum = PK_EXIT_ENUM_EULA_REQUIRED;\n\telse if (transaction->priv->emit_media_change_required)\n\t\texit_enum = PK_EXIT_ENUM_MEDIA_CHANGE_REQUIRED;\n\n\t/* invalidate some caches if we succeeded */\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS)\n\t\tpk_transaction_finish_invalidate_caches (transaction);\n\n\t/* find the length of time we have been running */\n\ttime_ms = pk_transaction_get_runtime (transaction);\n\tg_debug (\"backend was running for %i ms\", time_ms);\n\n\t/* add to the database if we are going to log it */\n\tif (transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES ||\n\t    transaction->priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    transaction->priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES) {\n\t\tg_autoptr(GPtrArray) array = NULL;\n\t\tg_autofree gchar *packages = NULL;\n\n\t\tarray = pk_results_get_package_array (transaction->priv->results);\n\n\t\t/* save to database */\n\t\tpackages = pk_transaction_package_list_to_string (array);\n\t\tif (!pk_strzero (packages))\n\t\t\tpk_transaction_db_set_data (transaction->priv->transaction_db, transaction->priv->tid, packages);\n\n\t\t/* report to syslog */\n\t\tfor (i = 0; i < array->len; i++) {\n\t\t\titem = g_ptr_array_index (array, i);\n\t\t\tinfo = pk_package_get_info (item);\n\t\t\tif (info == PK_INFO_ENUM_REMOVING ||\n\t\t\t    info == PK_INFO_ENUM_INSTALLING ||\n\t\t\t    info == PK_INFO_ENUM_UPDATING) {\n\t\t\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\t\t\"in %s for %s package %s was %s for uid %i\",\n\t\t\t\t\ttransaction->priv->tid,\n\t\t\t\t\tpk_role_enum_to_string (transaction->priv->role),\n\t\t\t\t\tpk_package_get_id (item),\n\t\t\t\t\tpk_info_enum_to_string (info),\n\t\t\t\t\ttransaction->priv->client_uid);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the repo list will have changed */\n\tif (transaction->priv->role == PK_ROLE_ENUM_REPO_ENABLE ||\n\t    transaction->priv->role == PK_ROLE_ENUM_REPO_REMOVE ||\n\t    transaction->priv->role == PK_ROLE_ENUM_REPO_SET_DATA) {\n\t\tpk_backend_repo_list_changed (transaction->priv->backend);\n\t}\n\n\t/* only reset the time if we succeeded */\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS)\n\t\tpk_transaction_db_action_time_reset (transaction->priv->transaction_db, transaction->priv->role);\n\n\t/* did we finish okay? */\n\tif (exit_enum == PK_EXIT_ENUM_SUCCESS)\n\t\tpk_transaction_db_set_finished (transaction->priv->transaction_db, transaction->priv->tid, TRUE, time_ms);\n\telse\n\t\tpk_transaction_db_set_finished (transaction->priv->transaction_db, transaction->priv->tid, FALSE, time_ms);\n\n\t/* remove any inhibit */\n\t//TODO: on main interface\n\n\t/* report to syslog */\n\tif (transaction->priv->client_uid != PK_TRANSACTION_UID_INVALID) {\n\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\"%s transaction %s from uid %i finished with %s after %ims\",\n\t\t\tpk_role_enum_to_string (transaction->priv->role),\n\t\t\ttransaction->priv->tid,\n\t\t\ttransaction->priv->client_uid,\n\t\t\tpk_exit_enum_to_string (exit_enum),\n\t\t\ttime_ms);\n\t} else {\n\t\tsyslog (LOG_DAEMON | LOG_DEBUG,\n\t\t\t\"%s transaction %s finished with %s after %ims\",\n\t\t\tpk_role_enum_to_string (transaction->priv->role),\n\t\t\ttransaction->priv->tid,\n\t\t\tpk_exit_enum_to_string (exit_enum),\n\t\t\ttime_ms);\n\t}\n\n\t/* this disconnects any pending signals */\n\tpk_backend_job_disconnect_vfuncs (transaction->priv->job);\n\n\t/* destroy the job */\n\tpk_backend_stop_job (transaction->priv->backend, transaction->priv->job);\n\n\t/* we emit last, as other backends will be running very soon after us, and we don't want to be notified */\n\tpk_transaction_finished_emit (transaction, exit_enum, time_ms);\n}\n\nstatic void\npk_transaction_package_cb (PkBackend *backend,\n\t\t\t   PkPackage *item,\n\t\t\t   PkTransaction *transaction)\n{\n\tconst gchar *role_text;\n\tPkInfoEnum info;\n\tPkInfoEnum update_severity;\n\tconst gchar *package_id;\n\tconst gchar *summary = NULL;\n\tguint encoded_value;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished\");\n\t\treturn;\n\t}\n\n\t/* check the backend is doing the right thing */\n\tinfo = pk_package_get_info (item);\n\tif (transaction->priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\tg_warning (\"%s emitted 'installed' rather than 'installing'\",\n\t\t\t\t   role_text);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* check we are respecting the filters */\n\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t PK_FILTER_ENUM_NOT_INSTALLED)) {\n\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\tg_warning (\"%s emitted package that was installed when \"\n\t\t\t\t   \"the ~installed filter is in place\",\n\t\t\t\t   role_text);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t PK_FILTER_ENUM_INSTALLED)) {\n\t\tif (info == PK_INFO_ENUM_AVAILABLE) {\n\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\tg_warning (\"%s emitted package that was ~installed when \"\n\t\t\t\t   \"the installed filter is in place\",\n\t\t\t\t   role_text);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* add to results even if we already got a result */\n\tif (info != PK_INFO_ENUM_FINISHED)\n\t\tpk_results_add_package (transaction->priv->results, item);\n\n\t/* emit */\n\tpackage_id = pk_package_get_id (item);\n\tg_free (transaction->priv->last_package_id);\n\ttransaction->priv->last_package_id = g_strdup (package_id);\n\tsummary = pk_package_get_summary (item);\n\tif (transaction->priv->role != PK_ROLE_ENUM_GET_PACKAGES) {\n\t\tg_debug (\"emit package %s, %s, %s\",\n\t\t\t pk_info_enum_to_string (info),\n\t\t\t package_id,\n\t\t\t summary);\n\t}\n\n\t/* Safety checks, that the two values do not interleave, neither overflow */\n\tg_assert ((PK_INFO_ENUM_LAST & (~0xFFFF)) == 0);\n\n\tupdate_severity = pk_package_get_update_severity (item);\n\tencoded_value = info | (((guint32) update_severity) << 16);\n\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Package\",\n\t\t\t\t       g_variant_new (\"(uss)\",\n\t\t\t\t\t\t      encoded_value,\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      summary ? summary : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_packages_cb (PkBackend *backend,\n\t\t\t    GPtrArray *package_array,\n\t\t\t    PkTransaction *transaction)\n{\n\tg_auto(GVariantBuilder) builder = G_VARIANT_BUILDER_INIT (G_VARIANT_TYPE (\"a(uss)\"));\n\tg_autoptr(GVariant) package_array_variant = NULL;\n\tguint n_added_packages = 0;\n\tgboolean emitted = FALSE;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished\");\n\t\treturn;\n\t}\n\n\t/* Loop through the packages and build a signal emission. */\n\tfor (guint i = 0; i < package_array->len; i++) {\n\t\tPkPackage *item = g_ptr_array_index (package_array, i);\n\t\tconst gchar *role_text;\n\t\tPkInfoEnum info;\n\t\tPkInfoEnum update_severity;\n\t\tconst gchar *package_id;\n\t\tconst gchar *summary = NULL;\n\t\tguint encoded_value;\n\n\t\t/* check the backend is doing the right thing */\n\t\tinfo = pk_package_get_info (item);\n\t\tif (transaction->priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t\t    transaction->priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\t\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\t\tg_warning (\"%s emitted 'installed' rather than 'installing'\",\n\t\t\t\t\t   role_text);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* check we are respecting the filters */\n\t\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t\t PK_FILTER_ENUM_NOT_INSTALLED)) {\n\t\t\tif (info == PK_INFO_ENUM_INSTALLED) {\n\t\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\t\tg_warning (\"%s emitted package that was installed when \"\n\t\t\t\t\t   \"the ~installed filter is in place\",\n\t\t\t\t\t   role_text);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (pk_bitfield_contain (transaction->priv->cached_filters,\n\t\t\t\t\t PK_FILTER_ENUM_INSTALLED)) {\n\t\t\tif (info == PK_INFO_ENUM_AVAILABLE) {\n\t\t\t\trole_text = pk_role_enum_to_string (transaction->priv->role);\n\t\t\t\tg_warning (\"%s emitted package that was ~installed when \"\n\t\t\t\t\t   \"the installed filter is in place\",\n\t\t\t\t\t   role_text);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* add to results even if we already got a result */\n\t\tif (info != PK_INFO_ENUM_FINISHED)\n\t\t\tpk_results_add_package (transaction->priv->results, item);\n\n\t\t/* emit */\n\t\tpackage_id = pk_package_get_id (item);\n\t\tg_free (transaction->priv->last_package_id);\n\t\ttransaction->priv->last_package_id = g_strdup (package_id);\n\t\tsummary = pk_package_get_summary (item);\n\t\tif (transaction->priv->role != PK_ROLE_ENUM_GET_PACKAGES) {\n\t\t\tg_debug (\"emit package %s, %s, %s\",\n\t\t\t\t pk_info_enum_to_string (info),\n\t\t\t\t package_id,\n\t\t\t\t summary);\n\t\t}\n\n\t\t/* Safety checks, that the two values do not interleave, neither overflow */\n\t\tg_assert ((PK_INFO_ENUM_LAST & (~0xFFFF)) == 0);\n\n\t\tupdate_severity = pk_package_get_update_severity (item);\n\t\tencoded_value = info | (((guint32) update_severity) << 16);\n\n\t\tg_variant_builder_add (&builder,\n\t\t\t\t       \"(uss)\",\n\t\t\t\t       encoded_value,\n\t\t\t\t       package_id,\n\t\t\t\t       summary ? summary : \"\");\n\t\tn_added_packages++;\n\t}\n\n\tif (n_added_packages == 0) {\n\t\tg_debug (\"Empty package array\");\n\t\treturn;\n\t}\n\n\tpackage_array_variant = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n\t/* Emit the signal. Grouping multiple package details into a single\n\t * signal reduces the number of signals and hence the amount of context\n\t * switching between packagekitd, dbus-daemon and the client process.\n\t * This results in much improved performance compared to emitting one\n\t * signal per package.\n\t *\n\t * This should not hit the D-Bus limits (maximum array size of 64MB,\n\t * maximum message size of 128MB) until it\u2019s listing on the order of\n\t * 100000 packages. If it does, we fall back below. */\n\tif (transaction->priv->client_supports_plural_signals &&\n\t    g_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   transaction->priv->tid,\n\t\t\t\t\t   PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t   \"Packages\",\n\t\t\t\t\t   g_variant_new (\"(@a(uss))\",\n\t\t\t\t\t                  package_array_variant),\n\t\t\t\t\t   NULL))\n\t\temitted = TRUE;\n\n\tif (!emitted) {\n\t\tGVariantIter iter;\n\t\tg_autoptr(GVariant) child = NULL;\n\n\t\t/* Fall back to one signal per package. */\n\t\tg_variant_iter_init (&iter, package_array_variant);\n\n\t\twhile ((child = g_variant_iter_next_value (&iter))) {\n\t\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t\t       NULL,\n\t\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t\t       \"Package\",\n\t\t\t\t\t\t       child,\n\t\t\t\t\t\t       NULL);\n\t\t\tg_clear_pointer (&child, g_variant_unref);\n\t\t}\n\t}\n}\n\nstatic void\npk_transaction_repo_detail_cb (PkBackend *backend,\n\t\t\t       PkRepoDetail *item,\n\t\t\t       PkTransaction *transaction)\n{\n\tgboolean enabled;\n\tconst gchar *repo_id;\n\tconst gchar *description;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_repo_detail (transaction->priv->results, item);\n\n\t/* emit */\n\trepo_id = pk_repo_detail_get_id (item);\n\tdescription = pk_repo_detail_get_description (item);\n\tenabled = pk_repo_detail_get_enabled (item);\n\tg_debug (\"emitting repo-detail %s, %s, %i\", repo_id, description, enabled);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"RepoDetail\",\n\t\t\t\t       g_variant_new (\"(ssb)\",\n\t\t\t\t\t\t      repo_id,\n\t\t\t\t\t\t      description != NULL ? description : \"\",\n\t\t\t\t\t\t      enabled),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_repo_signature_required_cb (PkBackend *backend,\n\t\t\t\t\t   PkRepoSignatureRequired *item,\n\t\t\t\t\t   PkTransaction *transaction)\n{\n\tPkSigTypeEnum type;\n\tg_autofree gchar *package_id = NULL;\n\tg_autofree gchar *repository_name = NULL;\n\tg_autofree gchar *key_url = NULL;\n\tg_autofree gchar *key_userid = NULL;\n\tg_autofree gchar *key_id = NULL;\n\tg_autofree gchar *key_fingerprint = NULL;\n\tg_autofree gchar *key_timestamp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_repo_signature_required (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"type\", &type,\n\t\t      \"package-id\", &package_id,\n\t\t      \"repository-name\", &repository_name,\n\t\t      \"key-url\", &key_url,\n\t\t      \"key-userid\", &key_userid,\n\t\t      \"key-id\", &key_id,\n\t\t      \"key-fingerprint\", &key_fingerprint,\n\t\t      \"key-timestamp\", &key_timestamp,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting repo_signature_required %s, %s, %s, %s, %s, %s, %s, %s\",\n\t\t package_id, repository_name, key_url, key_userid, key_id,\n\t\t key_fingerprint, key_timestamp,\n\t\t pk_sig_type_enum_to_string (type));\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"RepoSignatureRequired\",\n\t\t\t\t       g_variant_new (\"(sssssssu)\",\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      repository_name,\n\t\t\t\t\t\t      key_url != NULL ? key_url : \"\",\n\t\t\t\t\t\t      key_userid != NULL ? key_userid : \"\",\n\t\t\t\t\t\t      key_id != NULL ? key_id : \"\",\n\t\t\t\t\t\t      key_fingerprint != NULL ? key_fingerprint : \"\",\n\t\t\t\t\t\t      key_timestamp != NULL ? key_timestamp : \"\",\n\t\t\t\t\t\t      type),\n\t\t\t\t       NULL);\n\n\t/* we should mark this transaction so that we finish with a special code */\n\ttransaction->priv->emit_signature_required = TRUE;\n}\n\nstatic void\npk_transaction_eula_required_cb (PkBackend *backend,\n\t\t\t\t PkEulaRequired *item,\n\t\t\t\t PkTransaction *transaction)\n{\n\tconst gchar *eula_id;\n\tconst gchar *package_id;\n\tconst gchar *vendor_name;\n\tconst gchar *license_agreement;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_eula_required (transaction->priv->results, item);\n\n\t/* get data */\n\teula_id = pk_eula_required_get_eula_id (item);\n\tpackage_id = pk_eula_required_get_package_id (item);\n\tvendor_name = pk_eula_required_get_vendor_name (item);\n\tlicense_agreement = pk_eula_required_get_license_agreement (item);\n\n\t/* emit */\n\tg_debug (\"emitting eula-required %s, %s, %s, %s\",\n\t\t   eula_id, package_id, vendor_name, license_agreement);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"EulaRequired\",\n\t\t\t\t       g_variant_new (\"(ssss)\",\n\t\t\t\t\t\t      eula_id,\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      vendor_name != NULL ? vendor_name : \"\",\n\t\t\t\t\t\t      license_agreement != NULL ? license_agreement : \"\"),\n\t\t\t\t       NULL);\n\n\t/* we should mark this transaction so that we finish with a special code */\n\ttransaction->priv->emit_eula_required = TRUE;\n}\n\nstatic void\npk_transaction_media_change_required_cb (PkBackend *backend,\n\t\t\t\t\t PkMediaChangeRequired *item,\n\t\t\t\t\t PkTransaction *transaction)\n{\n\tPkMediaTypeEnum media_type;\n\tg_autofree gchar *media_id = NULL;\n\tg_autofree gchar *media_text = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_media_change_required (transaction->priv->results, item);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"media-type\", &media_type,\n\t\t      \"media-id\", &media_id,\n\t\t      \"media-text\", &media_text,\n\t\t      NULL);\n\n\t/* emit */\n\tg_debug (\"emitting media-change-required %s, %s, %s\",\n\t\t pk_media_type_enum_to_string (media_type),\n\t\t media_id,\n\t\t media_text);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"MediaChangeRequired\",\n\t\t\t\t       g_variant_new (\"(uss)\",\n\t\t\t\t\t\t      media_type,\n\t\t\t\t\t\t      media_id,\n\t\t\t\t\t\t      media_text != NULL ? media_text : \"\"),\n\t\t\t\t       NULL);\n\n\t/* we should mark this transaction so that we finish with a special code */\n\ttransaction->priv->emit_media_change_required = TRUE;\n}\n\nstatic void\npk_transaction_require_restart_cb (PkBackend *backend,\n\t\t\t\t   PkRequireRestart *item,\n\t\t\t\t   PkTransaction *transaction)\n{\n\tPkRequireRestart *item_tmp;\n\tgboolean found = FALSE;\n\tguint i;\n\tPkRestartEnum restart;\n\tg_autofree gchar *package_id = NULL;\n\tg_autoptr(GPtrArray) array = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* get data */\n\tg_object_get (item,\n\t\t      \"package-id\", &package_id,\n\t\t      \"restart\", &restart,\n\t\t      NULL);\n\n\t/* filter out duplicates */\n\tarray = pk_results_get_require_restart_array (transaction->priv->results);\n\tfor (i = 0; i < array->len; i++) {\n\t\tg_autofree gchar *package_id_tmp = NULL;\n\t\titem_tmp = g_ptr_array_index (array, i);\n\t\tg_object_get (item_tmp,\n\t\t\t      \"package-id\", &package_id_tmp,\n\t\t\t      NULL);\n\t\tif (g_strcmp0 (package_id, package_id_tmp) == 0) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* ignore */\n\tif (found) {\n\t\tg_debug (\"ignoring %s (%s) as already sent\",\n\t\t\t pk_restart_enum_to_string (restart),\n\t\t\t package_id);\n\t\treturn;\n\t}\n\n\t/* add to results */\n\tpk_results_add_require_restart (transaction->priv->results, item);\n\n\t/* emit */\n\tg_debug (\"emitting require-restart %s, '%s'\",\n\t\t pk_restart_enum_to_string (restart),\n\t\t package_id);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"RequireRestart\",\n\t\t\t\t       g_variant_new (\"(us)\",\n\t\t\t\t\t\t      restart,\n\t\t\t\t\t\t      package_id),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_status_changed_cb (PkBackendJob *job,\n\t\t\t\t  PkStatusEnum status,\n\t\t\t\t  PkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* don't proxy this on the bus, just for use internal */\n\tif (status == PK_STATUS_ENUM_WAIT)\n\t\treturn;\n\n\t/* have we already been marked as finished? */\n\tif (transaction->priv->finished) {\n\t\tg_warning (\"Already finished, so can't proxy status %s\",\n\t\t\t   pk_status_enum_to_string (status));\n\t\treturn;\n\t}\n\n\tpk_transaction_status_changed_emit (transaction, status);\n}\n\nstatic void\npk_transaction_update_detail_cb (PkBackend *backend,\n\t\t\t\t PkUpdateDetail *item,\n\t\t\t\t PkTransaction *transaction)\n{\n\tconst gchar *changelog;\n\tconst gchar *issued;\n\tconst gchar *package_id;\n\tconst gchar *updated;\n\tconst gchar *update_text;\n\tgchar **bugzilla_urls;\n\tgchar **cve_urls;\n\tgchar *empty[] = { NULL };\n\tgchar **obsoletes;\n\tgchar **updates;\n\tgchar **vendor_urls;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* add to results */\n\tpk_results_add_update_detail (transaction->priv->results, item);\n\n\t/* emit */\n\tpackage_id = pk_update_detail_get_package_id (item);\n\tupdates = pk_update_detail_get_updates (item);\n\tobsoletes = pk_update_detail_get_obsoletes (item);\n\tvendor_urls = pk_update_detail_get_vendor_urls (item);\n\tbugzilla_urls = pk_update_detail_get_bugzilla_urls (item);\n\tcve_urls = pk_update_detail_get_cve_urls (item);\n\tupdate_text = pk_update_detail_get_update_text (item);\n\tchangelog = pk_update_detail_get_changelog (item);\n\tissued = pk_update_detail_get_issued (item);\n\tupdated = pk_update_detail_get_updated (item);\n\tg_debug (\"emitting update-detail for %s\", package_id);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"UpdateDetail\",\n\t\t\t\t       g_variant_new (\"(s^as^as^as^as^asussuss)\",\n\t\t\t\t\t\t      package_id,\n\t\t\t\t\t\t      updates != NULL ? updates : empty,\n\t\t\t\t\t\t      obsoletes != NULL ? obsoletes : empty,\n\t\t\t\t\t\t      vendor_urls != NULL ? vendor_urls : empty,\n\t\t\t\t\t\t      bugzilla_urls != NULL ? bugzilla_urls : empty,\n\t\t\t\t\t\t      cve_urls != NULL ? cve_urls : empty,\n\t\t\t\t\t\t      pk_update_detail_get_restart (item),\n\t\t\t\t\t\t      update_text != NULL ? update_text : \"\",\n\t\t\t\t\t\t      changelog != NULL ? changelog : \"\",\n\t\t\t\t\t\t      pk_update_detail_get_state (item),\n\t\t\t\t\t\t      issued != NULL ? issued : \"\",\n\t\t\t\t\t\t      updated != NULL ? updated : \"\"),\n\t\t\t\t       NULL);\n}\n\nstatic void\npk_transaction_update_details_cb (PkBackend *backend,\n\t\t\t\t  GPtrArray *update_details_array,  /* (element-type PkUpdateDetail) */\n\t\t\t\t  PkTransaction *transaction)\n{\n\tg_auto(GVariantBuilder) builder = G_VARIANT_BUILDER_INIT (G_VARIANT_TYPE (\"a(sasasasasasussuss)\"));\n\tg_autoptr(GVariant) update_details_array_variant = NULL;\n\tguint n_update_details = 0;\n\tgboolean emitted = FALSE;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\t/* Loop through the packages and build a signal emission. */\n\tfor (guint i = 0; i < update_details_array->len; i++) {\n\t\tPkUpdateDetail *item = g_ptr_array_index (update_details_array, i);\n\t\tconst gchar *changelog;\n\t\tconst gchar *issued;\n\t\tconst gchar *package_id;\n\t\tconst gchar *updated;\n\t\tconst gchar *update_text;\n\t\tconst gchar * const *bugzilla_urls;\n\t\tconst gchar * const *cve_urls;\n\t\tconst gchar * const empty[] = { NULL };\n\t\tconst gchar * const *obsoletes;\n\t\tconst gchar * const *updates;\n\t\tconst gchar * const *vendor_urls;\n\n\t\t/* add to results */\n\t\tpk_results_add_update_detail (transaction->priv->results, item);\n\n\t\t/* emit */\n\t\tpackage_id = pk_update_detail_get_package_id (item);\n\t\tupdates = (const gchar * const *) pk_update_detail_get_updates (item);\n\t\tobsoletes = (const gchar * const *) pk_update_detail_get_obsoletes (item);\n\t\tvendor_urls = (const gchar * const *) pk_update_detail_get_vendor_urls (item);\n\t\tbugzilla_urls = (const gchar * const *) pk_update_detail_get_bugzilla_urls (item);\n\t\tcve_urls = (const gchar * const *) pk_update_detail_get_cve_urls (item);\n\t\tupdate_text = pk_update_detail_get_update_text (item);\n\t\tchangelog = pk_update_detail_get_changelog (item);\n\t\tissued = pk_update_detail_get_issued (item);\n\t\tupdated = pk_update_detail_get_updated (item);\n\t\tg_debug (\"emitting update-detail for %s\", package_id);\n\n\t\tg_variant_builder_add (&builder,\n\t\t\t\t       \"(s^as^as^as^as^asussuss)\",\n\t\t\t\t       package_id,\n\t\t\t\t       updates != NULL ? updates : empty,\n\t\t\t\t       obsoletes != NULL ? obsoletes : empty,\n\t\t\t\t       vendor_urls != NULL ? vendor_urls : empty,\n\t\t\t\t       bugzilla_urls != NULL ? bugzilla_urls : empty,\n\t\t\t\t       cve_urls != NULL ? cve_urls : empty,\n\t\t\t\t       pk_update_detail_get_restart (item),\n\t\t\t\t       update_text != NULL ? update_text : \"\",\n\t\t\t\t       changelog != NULL ? changelog : \"\",\n\t\t\t\t       pk_update_detail_get_state (item),\n\t\t\t\t       issued != NULL ? issued : \"\",\n\t\t\t\t       updated != NULL ? updated : \"\");\n\t\tn_update_details++;\n\t}\n\n\tif (n_update_details == 0) {\n\t\tg_debug (\"Empty update details array\");\n\t\treturn;\n\t}\n\n\tupdate_details_array_variant = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n\t/* Emit the signal. Grouping multiple update details into a single\n\t * signal reduces the number of signals and hence the amount of context\n\t * switching between packagekitd, dbus-daemon and the client process.\n\t * This results in much improved performance compared to emitting one\n\t * signal per update details.\n\t *\n\t * This should not hit the D-Bus limits (maximum array size of 64MB,\n\t * maximum message size of 128MB) until it\u2019s listing on the order of\n\t * 6400 updates, if we assume 10KB of changelog/details per update.\n\t * If it does hit the limits, we fall back to the old code below. */\n\tif (transaction->priv->client_supports_plural_signals &&\n\t    g_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   transaction->priv->tid,\n\t\t\t\t\t   PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t   \"UpdateDetails\",\n\t\t\t\t\t   g_variant_new (\"(@a(sasasasasasussuss))\",\n\t\t\t\t\t                  update_details_array_variant),\n\t\t\t\t\t   NULL))\n\t\temitted = TRUE;\n\n\tif (!emitted) {\n\t\tGVariantIter iter;\n\t\tg_autoptr(GVariant) child = NULL;\n\n\t\t/* Fall back to one signal per update details. */\n\t\tg_variant_iter_init (&iter, update_details_array_variant);\n\n\t\twhile ((child = g_variant_iter_next_value (&iter))) {\n\t\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t\t       NULL,\n\t\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t\t       \"UpdateDetail\",\n\t\t\t\t\t\t       child,\n\t\t\t\t\t\t       NULL);\n\t\t\tg_clear_pointer (&child, g_variant_unref);\n\t\t}\n\t}\n}\n\nstatic gboolean\npk_transaction_set_session_state (PkTransaction *transaction,\n\t\t\t\t  GError **error)\n{\n\tgboolean ret;\n\tg_autofree gchar *session = NULL;\n\tg_autofree gchar *proxy_http = NULL;\n\tg_autofree gchar *proxy_https = NULL;\n\tg_autofree gchar *proxy_ftp = NULL;\n\tg_autofree gchar *proxy_socks = NULL;\n\tg_autofree gchar *no_proxy = NULL;\n\tg_autofree gchar *pac = NULL;\n\tg_autofree gchar *cmdline = NULL;\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* get session */\n\tif (!pk_dbus_connect (priv->dbus, error))\n\t\treturn FALSE;\n\tsession = pk_dbus_get_session (priv->dbus, priv->sender);\n\tif (session == NULL) {\n\t\tg_set_error_literal (error, 1, 0, \"failed to get the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* get from database */\n\tret = pk_transaction_db_get_proxy (priv->transaction_db,\n\t\t\t\t\t   priv->client_uid,\n\t\t\t\t\t   session,\n\t\t\t\t\t   &proxy_http,\n\t\t\t\t\t   &proxy_https,\n\t\t\t\t\t   &proxy_ftp,\n\t\t\t\t\t   &proxy_socks,\n\t\t\t\t\t   &no_proxy,\n\t\t\t\t\t   &pac);\n\tif (!ret) {\n\t\tg_set_error_literal (error, 1, 0,\n\t\t\t\t     \"failed to get the proxy from the database\");\n\t\treturn FALSE;\n\t}\n\n\t/* try to set the new proxy */\n\tpk_backend_job_set_proxy (priv->job,\n\t\t\t\t  proxy_http,\n\t\t\t\t  proxy_https,\n\t\t\t\t  proxy_ftp,\n\t\t\t\t  proxy_socks,\n\t\t\t\t  no_proxy,\n\t\t\t\t  pac);\n\n\t/* try to set the new uid and cmdline */\n\tcmdline = g_strdup_printf (\"PackageKit: %s\",\n\t\t\t\t   pk_role_enum_to_string (priv->role));\n\tpk_backend_job_set_uid (priv->job, priv->client_uid);\n\tpk_backend_job_set_cmdline (priv->job, cmdline);\n\treturn TRUE;\n}\n\nstatic void\npk_transaction_speed_cb (PkBackendJob *job,\n\t\t\t guint speed,\n\t\t\t PkTransaction *transaction)\n{\n\tif (transaction->priv->speed == speed)\n\t\treturn;\n\n\ttransaction->priv->speed = speed;\n\n\tschedule_progress_changed (transaction);\n}\n\nstatic void\npk_transaction_download_size_remaining_cb (PkBackendJob *job,\n\t\t\t\t\t   guint64 *download_size_remaining,\n\t\t\t\t\t   PkTransaction *transaction)\n{\n\tif (transaction->priv->download_size_remaining == *download_size_remaining)\n\t\treturn;\n\n\ttransaction->priv->download_size_remaining = *download_size_remaining;\n\n\tschedule_progress_changed (transaction);\n}\n\nstatic void\npk_transaction_percentage_cb (PkBackendJob *job,\n\t\t\t      guint percentage,\n\t\t\t      PkTransaction *transaction)\n{\n\tif (transaction->priv->percentage == percentage)\n\t\treturn;\n\n\ttransaction->priv->percentage = percentage;\n\n\tschedule_progress_changed (transaction);\n}\n\ngboolean\npk_transaction_run (PkTransaction *transaction)\n{\n\tGError *error = NULL;\n\tPkExitEnum exit_status;\n\tPkTransactionPrivate *priv = PK_TRANSACTION_GET_PRIVATE (transaction);\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\tg_return_val_if_fail (priv->tid != NULL, FALSE);\n\tg_return_val_if_fail (transaction->priv->backend != NULL, FALSE);\n\n\t/* we are no longer waiting, we are setting up */\n\tpk_transaction_status_changed_emit (transaction, PK_STATUS_ENUM_SETUP);\n\n\t/* set proxy */\n\tif (!pk_transaction_set_session_state (transaction, &error)) {\n\t\tg_debug (\"failed to set the session state (non-fatal): %s\",\n\t\t\t error->message);\n\t\tg_clear_error (&error);\n\t}\n\n\t/* already cancelled? */\n\tif (pk_backend_job_get_exit_code (priv->job) == PK_EXIT_ENUM_CANCELLED) {\n\t\texit_status = pk_backend_job_get_exit_code (priv->job);\n\t\tpk_transaction_finished_emit (transaction, exit_status, 0);\n\t\treturn TRUE;\n\t}\n\n\t/* run the job */\n\tpk_backend_start_job (priv->backend, priv->job);\n\n\t/* is an error code set? */\n\tif (pk_backend_job_get_is_error_set (priv->job)) {\n\t\texit_status = pk_backend_job_get_exit_code (priv->job);\n\t\tpk_transaction_finished_emit (transaction, exit_status, 0);\n\t\t/* do not fail the transaction */\n\t}\n\n\t/* check if we should skip this transaction */\n\tif (pk_backend_job_get_exit_code (priv->job) == PK_EXIT_ENUM_SKIP_TRANSACTION) {\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_SUCCESS, 0);\n\t\t/* do not fail the transaction */\n\t}\n\n\t/* set the role */\n\tpk_backend_job_set_role (priv->job, priv->role);\n\tg_debug (\"setting role for %s to %s\",\n\t\t priv->tid,\n\t\t pk_role_enum_to_string (priv->role));\n\n\t/* reset after the pre-transaction checks */\n\tpk_backend_job_set_percentage (priv->job, PK_BACKEND_PERCENTAGE_INVALID);\n\n\t/* connect signal to receive backend lock changes */\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_LOCKED_CHANGED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_locked_changed_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_ALLOW_CANCEL,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_allow_cancel_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_DETAILS,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_details_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_ERROR_CODE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_error_code_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_FILES,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_files_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_DISTRO_UPGRADE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_distro_upgrade_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_FINISHED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_finished_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_PACKAGE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_package_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_PACKAGES,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_packages_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_ITEM_PROGRESS,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_item_progress_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_PERCENTAGE,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_percentage_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_SPEED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_speed_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_DOWNLOAD_SIZE_REMAINING,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_download_size_remaining_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_REPO_DETAIL,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_repo_detail_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_REPO_SIGNATURE_REQUIRED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_repo_signature_required_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_EULA_REQUIRED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_eula_required_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_MEDIA_CHANGE_REQUIRED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_media_change_required_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_REQUIRE_RESTART,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_require_restart_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_STATUS_CHANGED,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_status_changed_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_UPDATE_DETAIL,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_update_detail_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_UPDATE_DETAILS,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_update_details_cb),\n\t\t\t\t  transaction);\n\tpk_backend_job_set_vfunc (priv->job,\n\t\t\t\t  PK_BACKEND_SIGNAL_CATEGORY,\n\t\t\t\t  PK_BACKEND_JOB_VFUNC (pk_transaction_category_cb),\n\t\t\t\t  transaction);\n\n\t/* do the correct action with the cached parameters */\n\tswitch (priv->role) {\n\tcase PK_ROLE_ENUM_DEPENDS_ON:\n\t\tpk_backend_depends_on (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_filters,\n\t\t\t\t\tpriv->cached_package_ids,\n\t\t\t\t\tpriv->cached_force);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_UPDATE_DETAIL:\n\t\tpk_backend_get_update_detail (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_RESOLVE:\n\t\tpk_backend_resolve (priv->backend,\n\t\t\t\t    priv->job,\n\t\t\t\t    priv->cached_filters,\n\t\t\t\t    priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_DOWNLOAD_PACKAGES:\n\t\tpk_backend_download_packages (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      priv->cached_package_ids,\n\t\t\t\t\t      priv->cached_directory);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_DETAILS:\n\t\tpk_backend_get_details (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_DETAILS_LOCAL:\n\t\tpk_backend_get_details_local (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      priv->cached_full_paths);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_FILES_LOCAL:\n\t\tpk_backend_get_files_local (priv->backend,\n\t\t\t\t\t    priv->job,\n\t\t\t\t\t    priv->cached_full_paths);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_DISTRO_UPGRADES:\n\t\tpk_backend_get_distro_upgrades (priv->backend,\n\t\t\t\t\t\tpriv->job);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_FILES:\n\t\tpk_backend_get_files (priv->backend,\n\t\t\t\t      priv->job,\n\t\t\t\t      priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REQUIRED_BY:\n\t\tpk_backend_required_by (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters,\n\t\t\t\t\t priv->cached_package_ids,\n\t\t\t\t\t priv->cached_force);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_WHAT_PROVIDES:\n\t\tpk_backend_what_provides (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_filters,\n\t\t\t\t\t  priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_UPDATES:\n\t\tpk_backend_get_updates (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_filters);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_PACKAGES:\n\t\tpk_backend_get_packages (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_DETAILS:\n\t\tpk_backend_search_details (priv->backend,\n\t\t\t\t\t   priv->job,\n\t\t\t\t\t   priv->cached_filters,\n\t\t\t\t\t   priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_FILE:\n\t\tpk_backend_search_files (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters,\n\t\t\t\t\t priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_GROUP:\n\t\tpk_backend_search_groups (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_filters,\n\t\t\t\t\t  priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_SEARCH_NAME:\n\t\tpk_backend_search_names (priv->backend,\n\t\t\t\t\t priv->job,\n\t\t\t\t\t priv->cached_filters,\n\t\t\t\t\t priv->cached_values);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_INSTALL_PACKAGES:\n\t\tpk_backend_install_packages (priv->backend,\n\t\t\t\t\t     priv->job,\n\t\t\t\t\t     priv->cached_transaction_flags,\n\t\t\t\t\t     priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_INSTALL_FILES:\n\t\tpk_backend_install_files (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_transaction_flags,\n\t\t\t\t\t  priv->cached_full_paths);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_INSTALL_SIGNATURE:\n\t\tpk_backend_install_signature (priv->backend,\n\t\t\t\t\t      priv->job,\n\t\t\t\t\t      PK_SIGTYPE_ENUM_GPG,\n\t\t\t\t\t      priv->cached_key_id,\n\t\t\t\t\t      priv->cached_package_id);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REFRESH_CACHE:\n\t\tpk_backend_refresh_cache (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_force);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REMOVE_PACKAGES:\n\t\tpk_backend_remove_packages (priv->backend,\n\t\t\t\t\t    priv->job,\n\t\t\t\t\t    priv->cached_transaction_flags,\n\t\t\t\t\t    priv->cached_package_ids,\n\t\t\t\t\t    priv->cached_allow_deps,\n\t\t\t\t\t    priv->cached_autoremove);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_UPDATE_PACKAGES:\n\t\tpk_backend_update_packages (priv->backend,\n\t\t\t\t\t    priv->job,\n\t\t\t\t\t    priv->cached_transaction_flags,\n\t\t\t\t\t    priv->cached_package_ids);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_CATEGORIES:\n\t\tpk_backend_get_categories (priv->backend,\n\t\t\t\t\t   priv->job);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_GET_REPO_LIST:\n\t\tpk_backend_get_repo_list (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_filters);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPO_ENABLE:\n\t\tpk_backend_repo_enable (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_repo_id,\n\t\t\t\t\tpriv->cached_enabled);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPO_SET_DATA:\n\t\tpk_backend_repo_set_data (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_repo_id,\n\t\t\t\t\t  priv->cached_parameter,\n\t\t\t\t\t  priv->cached_value);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPO_REMOVE:\n\t\tpk_backend_repo_remove (priv->backend,\n\t\t\t\t\tpriv->job,\n\t\t\t\t\tpriv->cached_transaction_flags,\n\t\t\t\t\tpriv->cached_repo_id,\n\t\t\t\t\tpriv->cached_autoremove);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_UPGRADE_SYSTEM:\n\t\tpk_backend_upgrade_system (priv->backend,\n\t\t\t\t\t   priv->job,\n\t\t\t\t\t   priv->cached_transaction_flags,\n\t\t\t\t\t   priv->cached_value,\n\t\t\t\t\t   priv->cached_upgrade_kind);\n\t\tbreak;\n\tcase PK_ROLE_ENUM_REPAIR_SYSTEM:\n\t\tpk_backend_repair_system (priv->backend,\n\t\t\t\t\t  priv->job,\n\t\t\t\t\t  priv->cached_transaction_flags);\n\t\tbreak;\n\t/* handled in the engine without a transaction */\n\tcase PK_ROLE_ENUM_CANCEL:\n\tcase PK_ROLE_ENUM_GET_OLD_TRANSACTIONS:\n\tcase PK_ROLE_ENUM_ACCEPT_EULA:\n\t\tg_warning (\"role %s should be handled by engine\",\n\t\t\t   pk_role_enum_to_string (priv->role));\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"failed to run as role not assigned\");\n\t\treturn FALSE;\n\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\nconst gchar *\npk_transaction_get_tid (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), NULL);\n\tg_return_val_if_fail (transaction->priv->tid != NULL, NULL);\n\n\treturn transaction->priv->tid;\n}\n\ngboolean\npk_transaction_is_exclusive (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\n\treturn transaction->priv->exclusive;\n}\n\nvoid\npk_transaction_make_exclusive (PkTransaction *transaction)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\tg_debug (\"changing transaction to exclusive mode\");\n\n\ttransaction->priv->exclusive = TRUE;\n}\n\nstatic void\npk_transaction_vanished_cb (GDBusConnection *connection,\n\t\t\t    const gchar *name,\n\t\t\t    gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\ttransaction->priv->caller_active = FALSE;\n\n\t/* emit */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"CallerActive\",\n\t\t\t\t\t      g_variant_new_boolean (transaction->priv->caller_active));\n}\n\ngboolean\npk_transaction_set_sender (PkTransaction *transaction, const gchar *sender)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\tg_return_val_if_fail (sender != NULL, FALSE);\n\tg_return_val_if_fail (transaction->priv->sender == NULL, FALSE);\n\n\tg_debug (\"setting sender to %s\", sender);\n\tpriv->sender = g_strdup (sender);\n\n\tpriv->watch_id =\n\t\tg_bus_watch_name (G_BUS_TYPE_SYSTEM,\n\t\t\t\t  sender,\n\t\t\t\t  G_BUS_NAME_WATCHER_FLAGS_NONE,\n\t\t\t\t  NULL,\n\t\t\t\t  pk_transaction_vanished_cb,\n\t\t\t\t  transaction,\n\t\t\t\t  NULL);\n\n\t/* we get the UID for all callers as we need to know when to cancel */\n\tpriv->subject = polkit_system_bus_name_new (sender);\n\tif (!pk_dbus_connect (priv->dbus, &error)) {\n\t\tg_warning (\"cannot get UID: %s\", error->message);\n\t\treturn FALSE;\n\t}\n\n\t/* get uid and pid of the caller */\n\tif (!pk_dbus_get_uid_pid (priv->dbus, sender, &priv->client_uid, &priv->client_pid)) {\n\t\t/* fallback in case our D-Bus does not support GetConnectionCredentials */\n\t\tpriv->client_uid = pk_dbus_get_uid (priv->dbus, sender);\n\t\tpriv->client_pid = pk_dbus_get_pid (priv->dbus, sender);\n\t}\n\n\t/* set in the test suite */\n\tif (g_strcmp0 (sender, \":org.freedesktop.PackageKit\") == 0) {\n\t\tg_debug (\"using self-check shortcut\");\n\t\tpriv->cmdline = g_strdup (\"/usr/sbin/packagekit\");\n\t}\n\n\treturn TRUE;\n}\n\nstatic gboolean\npk_transaction_finished_idle_cb (PkTransaction *transaction)\n{\n\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_SUCCESS, 0);\n\treturn FALSE;\n}\n\n/**\n * pk_transaction_strvalidate:\n * @text: The text to check for validity\n *\n * Tests a string to see if it may be dangerous or invalid.\n *\n * Return value: %TRUE if the string is valid\n **/\ngboolean\npk_transaction_strvalidate (const gchar *text, GError **error)\n{\n\tguint length;\n\n\t/* maximum size is 1024 */\n\tlength = pk_strlen (text, 1024);\n\tif (length == 0) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t\t     \"Invalid input passed to daemon: zero length string\");\n\t\treturn FALSE;\n\t}\n\tif (length > 1024) {\n\t\tg_set_error (error, PK_TRANSACTION_ERROR, PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Invalid input passed to daemon: input too long: %u\", length);\n\t\treturn FALSE;\n\t}\n\n\t/* just check for valid UTF-8 */\n\tif (!g_utf8_validate (text, -1, NULL)) {\n\t\tg_set_error (error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Invalid input passed to daemon: %s\", text);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\npk_transaction_search_check_item (const gchar *values, GError **error)\n{\n\tguint size;\n\n\t/* limit to a 1k chunk */\n\tif (values == NULL) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Search is null. This isn't supposed to happen...\");\n\t\treturn FALSE;\n\t}\n\tsize = pk_strlen (values, 1024);\n\tif (size == 0) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Search string zero length\");\n\t\treturn FALSE;\n\t}\n\tif (strstr (values, \"*\") != NULL) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Invalid search containing '*'\");\n\t\treturn FALSE;\n\t}\n\tif (strstr (values, \"?\") != NULL) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Invalid search containing '?'\");\n\t\treturn FALSE;\n\t}\n\tif (size == 1024) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"The search string length is too large\");\n\t\treturn FALSE;\n\t}\n\treturn pk_transaction_strvalidate (values, error);\n}\n\nstatic gboolean\npk_transaction_search_check (gchar **values, GError **error)\n{\n\tguint i;\n\n\t/* check each parameter */\n\tfor (i = 0; values[i] != NULL; i++) {\n\t\tif (!pk_transaction_search_check_item (values[i], error))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstruct AuthorizeActionsData {\n\tPkTransaction *transaction;\n\tPkRoleEnum role;\n\t/** Array of policy actions to authorize. They will are processed sequentially,\n\t * which can result in several chained callbacks. */\n\tGPtrArray *actions;\n};\n\nstatic gboolean\npk_transaction_authorize_actions (PkTransaction *transaction,\n\t\t\t\t  PkRoleEnum role,\n\t\t\t\t  GPtrArray *actions);\n\n/**\n * pk_transaction_authorize_actions_finished_cb:\n *\n * A callback processing the result of action's authorization done by\n * polkit daemon. If the action was authorized, it pops another\n * from *data->actions* and schedules it for authorization. This continues\n * until an action is denied or all of them are authorized.\n **/\nstatic void\npk_transaction_authorize_actions_finished_cb (GObject *source_object,\n\t\t\t\t\t      GAsyncResult *res,\n\t\t\t\t\t      struct AuthorizeActionsData *data)\n{\n\tconst gchar *action_id = NULL;\n\tPkTransactionPrivate *priv = data->transaction->priv;\n\tg_autoptr(GError) error = NULL;\n\tg_autoptr(PolkitAuthorizationResult) result = NULL;\n\tg_assert (data->actions && data->actions->len > 0);\n\n\t/* get the first action */\n\taction_id = g_ptr_array_index (data->actions, 0);\n\n\t/* finish the call */\n\tresult = polkit_authority_check_authorization_finish (priv->authority, res, &error);\n\n\t/* failed because the request was cancelled */\n\tif (g_cancellable_is_cancelled (priv->cancellable)) {\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\"The authentication was cancelled due to a timeout.\");\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* failed, maybe polkit is messed up? */\n\tif (result == NULL) {\n\t\tg_autofree gchar *message = NULL;\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tg_warning (\"failed to check for auth: %s\", error->message);\n\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tmessage = g_strdup_printf (\"Failed to check for authentication: %s\", error->message);\n\t\tpk_transaction_error_code_emit (data->transaction,\n\t\t\t\t\t\tPK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\tmessage);\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tgoto out;\n\t}\n\n\t/* did not auth */\n\tif (!polkit_authorization_result_get_is_authorized (result)) {\n\t\tpriv->waiting_for_auth = FALSE;\n\t\t/* emit an ::StatusChanged, ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_status_changed_emit (data->transaction, PK_STATUS_ENUM_FINISHED);\n\t\tpk_transaction_error_code_emit (data->transaction, PK_ERROR_ENUM_NOT_AUTHORIZED,\n\t\t\t\t\t\t\"Failed to obtain authentication.\");\n\t\tpk_transaction_finished_emit (data->transaction, PK_EXIT_ENUM_FAILED, 0);\n\t\tsyslog (LOG_AUTH | LOG_NOTICE, \"uid %i failed to obtain auth\", priv->client_uid);\n\t\tgoto out;\n\t}\n\n\tif (data->actions->len <= 1) {\n\t\t/* authentication finished successfully */\n\t\tpriv->waiting_for_auth = FALSE;\n\t\tpk_transaction_set_state (data->transaction, PK_TRANSACTION_STATE_READY);\n\t\t/* log success too */\n\t\tsyslog (LOG_AUTH | LOG_INFO,\n\t\t\t\"uid %i obtained auth for %s\",\n\t\t\tpriv->client_uid, action_id);\n\t} else {\n\t\t/* process the rest of actions */\n\t\tg_ptr_array_remove_index (data->actions, 0);\n\t\tpk_transaction_authorize_actions (data->transaction, data->role, data->actions);\n\t}\n\nout:\n\tg_object_unref (data->transaction);\n\tg_ptr_array_unref (data->actions);\n\tg_free (data);\n}\n\n/**\n * pk_transaction_authorize_actions:\n *\n * Param actions is an array of policy actions that shall be authorized. They\n * will be processed one-by-one until one action is denied or all of them are\n * authorized. Each action results in one asynchronous function call to polkit\n * daemon.\n *\n * Return value: %TRUE if no authorization is required or the first action\n *\t\tis scheduled for processing.\n */\nstatic gboolean\npk_transaction_authorize_actions (PkTransaction *transaction,\n\t\t\t\t  PkRoleEnum role,\n\t\t\t\t  GPtrArray *actions)\n{\n\tconst gchar *action_id = NULL;\n\tg_autoptr(PolkitDetails) details = NULL;\n\tg_autofree gchar *package_ids = NULL;\n\tGString *string = NULL;\n\tPkTransactionPrivate *priv = transaction->priv;\n\tconst gchar *text = NULL;\n\tstruct AuthorizeActionsData *data = NULL;\n\tPolkitCheckAuthorizationFlags flags;\n\n\tif (actions->len <= 0) {\n\t\tg_debug (\"No authentication required\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\n\t\treturn TRUE;\n\t}\n\taction_id = g_ptr_array_index (actions, 0);\n\n\t/* log */\n\tsyslog (LOG_AUTH | LOG_INFO,\n\t\t\"uid %i is trying to obtain %s auth (only_trusted:%i)\",\n\t\tpriv->client_uid,\n\t\taction_id,\n\t\tpk_bitfield_contain (priv->cached_transaction_flags,\n\t\t\t\t\tPK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED));\n\n\t/* set transaction state */\n\tpk_transaction_set_state (transaction,\n\t\t\t\t  PK_TRANSACTION_STATE_WAITING_FOR_AUTH);\n\n\t/* check subject */\n\tpriv->waiting_for_auth = TRUE;\n\n\t/* insert details about the authorization */\n\tdetails = polkit_details_new ();\n\n\t/* do we have package details? */\n\tif (priv->cached_package_id != NULL)\n\t\tpackage_ids = g_strdup (priv->cached_package_id);\n\telse if (priv->cached_package_ids != NULL)\n\t\tpackage_ids = pk_package_ids_to_string (priv->cached_package_ids);\n\n\t/* save optional stuff */\n\tif (package_ids != NULL)\n\t\tpolkit_details_insert (details, \"package_ids\", package_ids);\n\tif (priv->cmdline != NULL)\n\t\tpolkit_details_insert (details, \"cmdline\", priv->cmdline);\n\n\t/* do not use the default icon and wording for some roles */\n\tif ((role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    role == PK_ROLE_ENUM_UPDATE_PACKAGES) &&\n\t    !pk_bitfield_contain (priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED)) {\n\n\t\t/* don't use the friendly PackageKit icon as this is\n\t\t * might be a ricky authorisation */\n\t\tpolkit_details_insert (details, \"polkit.icon_name\", \"emblem-important\");\n\n\t\tstring = g_string_new (\"\");\n\n\t\t/* TRANSLATORS: is not GPG signed */\n\t\tg_string_append (string, g_dgettext (GETTEXT_PACKAGE, N_(\"The software is not from a trusted source.\")));\n\t\tg_string_append (string, \"\\n\");\n\n\t\t/* UpdatePackages */\n\t\tif (priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES) {\n\n\t\t\t/* TRANSLATORS: user has to trust provider -- I know, this sucks */\n\t\t\ttext = g_dngettext (GETTEXT_PACKAGE,\n\t\t\t\t\t    N_(\"Do not update this package unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    N_(\"Do not update these packages unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    g_strv_length (priv->cached_package_ids));\n\t\t\tg_string_append (string, text);\n\t\t}\n\n\t\t/* InstallPackages */\n\t\tif (priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES) {\n\n\t\t\t/* TRANSLATORS: user has to trust provider -- I know, this sucks */\n\t\t\ttext = g_dngettext (GETTEXT_PACKAGE,\n\t\t\t\t\t    N_(\"Do not install this package unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    N_(\"Do not install these packages unless you are sure it is safe to do so.\"),\n\t\t\t\t\t    g_strv_length (priv->cached_package_ids));\n\t\t\tg_string_append (string, text);\n\t\t}\n\t\tif (string->len > 0) {\n\t\t\tpolkit_details_insert (details, \"polkit.gettext_domain\", GETTEXT_PACKAGE);\n\t\t\tpolkit_details_insert (details, \"polkit.message\", string->str);\n\t\t}\n\t}\n\n\tdata = g_new (struct AuthorizeActionsData, 1);\n\tdata->transaction = g_object_ref (transaction);\n\tdata->role = role;\n\tdata->actions = g_ptr_array_ref (actions);\n\n\t/* create if required */\n\tif (priv->authority == NULL) {\n\t\tg_autoptr(GError) error = NULL;\n\t\tpriv->authority = polkit_authority_get_sync (NULL, &error);\n\t\tif (priv->authority == NULL) {\n\t\t\tg_warning (\"failed to get polkit authority: %s\", error->message);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tflags = POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE;\n\tif (pk_backend_job_get_interactive (priv->job))\n\t\tflags |= POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION;\n\n\tg_debug (\"authorizing action %s\", action_id);\n\t/* do authorization async */\n\tpolkit_authority_check_authorization (priv->authority,\n\t\t\t\t\t      priv->subject,\n\t\t\t\t\t      action_id,\n\t\t\t\t\t      details,\n\t\t\t\t\t      flags,\n\t\t\t\t\t      priv->cancellable,\n\t\t\t\t\t      (GAsyncReadyCallback) pk_transaction_authorize_actions_finished_cb,\n\t\t\t\t\t      data);\n\treturn TRUE;\n}\n\n/**\n * pk_transaction_role_to_actions:\n *\n * Produces a list of policy actions needing authorization for given role\n * and transaction flags.\n *\n * Return value: array of policy action ids\n **/\nstatic GPtrArray *\npk_transaction_role_to_actions (PkRoleEnum role, guint64 transaction_flags)\n{\n\tconst gchar *policy = NULL;\n\tGPtrArray *result = NULL;\n\tgboolean check_install_untrusted = FALSE;\n\n\tresult = g_ptr_array_new_with_free_func (g_free);\n\tif (result == NULL)\n\t\treturn result;\n\n\tif ((role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t     role == PK_ROLE_ENUM_INSTALL_FILES ||\n\t     role == PK_ROLE_ENUM_UPDATE_PACKAGES) &&\n\t    !pk_bitfield_contain (transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED)) {\n\t\tg_ptr_array_add (result, g_strdup (\"org.freedesktop.packagekit.package-install-untrusted\"));\n\t\tcheck_install_untrusted = TRUE;\n\t}\n\n\tif (role == PK_ROLE_ENUM_INSTALL_PACKAGES &&\n\t    pk_bitfield_contain (transaction_flags, PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL)) {\n\t\tg_ptr_array_add (result, g_strdup (\"org.freedesktop.packagekit.package-reinstall\"));\n\t}\n\n\tif ((role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t     role == PK_ROLE_ENUM_UPDATE_PACKAGES) &&\n\t    pk_bitfield_contain (transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ALLOW_DOWNGRADE)) {\n\t\tg_ptr_array_add (result, g_strdup (\"org.freedesktop.packagekit.package-downgrade\"));\n\t} else if (!check_install_untrusted) {\n\t\tswitch (role) {\n\t\tcase PK_ROLE_ENUM_UPDATE_PACKAGES:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-update\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_INSTALL_SIGNATURE:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-trust-signing-key\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REPO_ENABLE:\n\t\tcase PK_ROLE_ENUM_REPO_SET_DATA:\n\t\tcase PK_ROLE_ENUM_REPO_REMOVE:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-sources-configure\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REFRESH_CACHE:\n\t\t\tpolicy = \"org.freedesktop.packagekit.system-sources-refresh\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REMOVE_PACKAGES:\n\t\t\tpolicy = \"org.freedesktop.packagekit.package-remove\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_INSTALL_PACKAGES:\n\t\tcase PK_ROLE_ENUM_INSTALL_FILES:\n\t\t\tpolicy = \"org.freedesktop.packagekit.package-install\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_ACCEPT_EULA:\n\t\t\tpolicy = \"org.freedesktop.packagekit.package-eula-accept\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_CANCEL:\n\t\t\tpolicy = \"org.freedesktop.packagekit.cancel-foreign\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_UPGRADE_SYSTEM:\n\t\t\tpolicy = \"org.freedesktop.packagekit.upgrade-system\";\n\t\t\tbreak;\n\t\tcase PK_ROLE_ENUM_REPAIR_SYSTEM:\n\t\t\tpolicy = \"org.freedesktop.packagekit.repair-system\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (policy != NULL)\n\t\t\tg_ptr_array_add (result, g_strdup (policy));\n\t}\n\n\treturn result;\n}\n\n/**\n * pk_transaction_obtain_authorization:\n *\n * Only valid from an async caller, which is fine, as we won't prompt the user\n * when not async.\n *\n * Because checking for authentication might have to respond to user input, this\n * is treated as async. As such, the transaction should only be added to the\n * transaction list when authorised, and not before.\n **/\nstatic gboolean\npk_transaction_obtain_authorization (PkTransaction *transaction,\n\t\t\t\t     PkRoleEnum role,\n\t\t\t\t     GError **error)\n{\n\tg_autoptr(GPtrArray) actions = NULL;\n\tPkTransactionPrivate *priv = transaction->priv;\n\tg_autofree gchar *package_ids = NULL;\n\tg_autoptr(PolkitDetails) details = NULL;\n\tg_autoptr(GString) string = NULL;\n\n\tg_return_val_if_fail (priv->sender != NULL, FALSE);\n\n\t/* we don't need to authenticate at all to just download\n\t * packages or if we're running unit tests */\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD) ||\n\t\t\tpk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t PK_TRANSACTION_FLAG_ENUM_SIMULATE) ||\n\t\t\tpriv->skip_auth_check == TRUE) {\n\t\tg_debug (\"No authentication required\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\n\t\treturn TRUE;\n\t}\n\n\t/* we should always have subject */\n\tif (priv->subject == NULL) {\n\t\tg_set_error (error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\t\t\t     \"subject %s not found\", priv->sender);\n\t\treturn FALSE;\n\t}\n\n\tactions = pk_transaction_role_to_actions (role, priv->cached_transaction_flags);\n\tif (actions == NULL)\n\t\treturn FALSE;\n\n\treturn pk_transaction_authorize_actions (transaction, role, actions);\n}\n\n/**\n * pk_transaction_skip_auth_checks:\n *\n * Skip authorization checks.\n * NOTE: This is *only* for testing, do never\n * use it somewhere else!\n **/\nvoid\npk_transaction_skip_auth_checks (PkTransaction *transaction, gboolean skip_checks)\n{\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\ttransaction->priv->skip_auth_check = skip_checks;\n}\n\nPkRoleEnum\npk_transaction_get_role (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\treturn transaction->priv->role;\n}\n\nstatic void\npk_transaction_set_role (PkTransaction *transaction, PkRoleEnum role)\n{\n\ttransaction->priv->role = role;\n\n\t/* always set transaction exclusive for some actions (improves performance) */\n\tif (role == PK_ROLE_ENUM_INSTALL_FILES ||\n\t    role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t    role == PK_ROLE_ENUM_UPDATE_PACKAGES ||\n\t    role == PK_ROLE_ENUM_UPGRADE_SYSTEM ||\n\t    role == PK_ROLE_ENUM_REPAIR_SYSTEM) {\n\t\tpk_transaction_make_exclusive (transaction);\n\t}\n\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"Role\",\n\t\t\t\t\t      g_variant_new_uint32 (role));\n}\n\nstatic void\npk_transaction_dbus_return (GDBusMethodInvocation *context, const GError *error)\n{\n\t/* not set inside the test suite */\n\tif (context == NULL) {\n\t\tif (error != NULL)\n\t\t\tg_warning (\"context null, and error: %s\", error->message);\n\t\treturn;\n\t}\n\tif (error != NULL)\n\t\tg_dbus_method_invocation_return_gerror (context, error);\n\telse\n\t\tg_dbus_method_invocation_return_value (context, NULL);\n}\n\nstatic void\npk_transaction_accept_eula (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint idle_id;\n\tconst gchar *eula_id = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(&s)\",\n\t\t       &eula_id);\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (eula_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_ACCEPT_EULA);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_ACCEPT_EULA,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\tg_debug (\"AcceptEula method called: %s\", eula_id);\n\tpk_backend_accept_eula (transaction->priv->backend, eula_id);\n\n\t/* we are done */\n\tidle_id = g_idle_add ((GSourceFunc) pk_transaction_finished_idle_cb, transaction);\n\tg_source_set_name_by_id (idle_id, \"[PkTransaction] finished from accept\");\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_cancel_bg (PkTransaction *transaction)\n{\n\tg_debug (\"CancelBg method called on %s\", transaction->priv->tid);\n\n\t/* transaction is already finished */\n\tif (transaction->priv->state == PK_TRANSACTION_STATE_FINISHED)\n\t\treturn;\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_CANCEL)) {\n\t\tg_warning (\"Cancel not supported by backend\");\n\t\treturn;\n\t}\n\n\t/* if it's never been run, just remove this transaction from the list */\n\tif (transaction->priv->state <= PK_TRANSACTION_STATE_READY) {\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_CANCELLED, 0);\n\t\treturn;\n\t}\n\n\t/* set the state, as cancelling might take a few seconds */\n\tpk_backend_job_set_status (transaction->priv->job, PK_STATUS_ENUM_CANCEL);\n\n\t/* we don't want to cancel twice */\n\tpk_backend_job_set_allow_cancel (transaction->priv->job, FALSE);\n\n\t/* we need ::finished to not return success or failed */\n\tpk_backend_job_set_exit_code (transaction->priv->job, PK_EXIT_ENUM_CANCELLED_PRIORITY);\n\n\t/* actually run the method */\n\tpk_backend_cancel (transaction->priv->backend, transaction->priv->job);\n}\n\nstatic void\npk_transaction_cancel (PkTransaction *transaction,\n\t\t       GVariant *params,\n\t\t       GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *sender;\n\tguint uid;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"Cancel method called on %s\", transaction->priv->tid);\n\n\t/* transaction is already finished */\n\tif (transaction->priv->state == PK_TRANSACTION_STATE_FINISHED) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_RUNNING,\n\t\t\t     \"Transaction is already finished\");\n\t\tgoto out;\n\t}\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_CANCEL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"Cancel not supported by backend\");\n\t\tgoto out;\n\t}\n\n\t/* if it's finished, cancelling will have no action regardless of uid */\n\tif (transaction->priv->finished) {\n\t\tg_debug (\"No point trying to cancel a finished transaction, ignoring\");\n\n\t\t/* return from async with success */\n\t\tpk_transaction_dbus_return (context, NULL);\n\t\tgoto out;\n\t}\n\n\t/* check to see if we have an action */\n\tif (transaction->priv->role == PK_ROLE_ENUM_UNKNOWN) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NO_ROLE, \"No role\");\n\t\tgoto out;\n\t}\n\n\t/* first, check the sender -- if it's the same we don't need to check the uid */\n\tsender = g_dbus_method_invocation_get_sender (context);\n\tret = (g_strcmp0 (transaction->priv->sender, sender) == 0);\n\tif (ret) {\n\t\tg_debug (\"same sender, no need to check uid\");\n\t\tgoto skip_uid;\n\t}\n\n\t/* check if we saved the uid */\n\tif (transaction->priv->client_uid == PK_TRANSACTION_UID_INVALID) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_CANNOT_CANCEL,\n\t\t\t     \"No context from caller to get UID from\");\n\t\tgoto out;\n\t}\n\n\t/* get the UID of the caller */\n\tif (!pk_dbus_connect (transaction->priv->dbus, &error))\n\t\tgoto out;\n\tuid = pk_dbus_get_uid (transaction->priv->dbus, sender);\n\tif (uid == PK_TRANSACTION_UID_INVALID) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INVALID_STATE,\n\t\t\t     \"unable to get uid of caller\");\n\t\tgoto out;\n\t}\n\n\t/* check the caller uid with the originator uid */\n\tif (transaction->priv->client_uid != uid) {\n\t\tg_debug (\"uid does not match (%i vs. %i)\", transaction->priv->client_uid, uid);\n\t\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t\t   PK_ROLE_ENUM_CANCEL,\n\t\t\t\t\t\t\t   &error);\n\t\tif (!ret)\n\t\t\tgoto out;\n\t}\n\nskip_uid:\n\t/* if it's never been run, just remove this transaction from the list */\n\tif (transaction->priv->state <= PK_TRANSACTION_STATE_READY) {\n\t\tg_autofree gchar *msg = NULL;\n\t\tmsg = g_strdup_printf (\"%s was cancelled and was never run\",\n\t\t\t\t       transaction->priv->tid);\n\t\tpk_transaction_error_code_emit (transaction,\n\t\t\t\t\t\tPK_ERROR_ENUM_TRANSACTION_CANCELLED,\n\t\t\t\t\t\tmsg);\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_CANCELLED, 0);\n\t\tgoto out;\n\t}\n\n\t/* set the state, as cancelling might take a few seconds */\n\tpk_backend_job_set_status (transaction->priv->job, PK_STATUS_ENUM_CANCEL);\n\n\t/* we don't want to cancel twice */\n\tpk_backend_job_set_allow_cancel (transaction->priv->job, FALSE);\n\n\t/* we need ::finished to not return success or failed */\n\tpk_backend_job_set_exit_code (transaction->priv->job, PK_EXIT_ENUM_CANCELLED);\n\n\t/* actually run the method */\n\tpk_backend_cancel (transaction->priv->backend, transaction->priv->job);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_download_packages (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgint retval;\n\tgboolean store_in_cache;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *directory = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(b^a&s)\",\n\t\t       &store_in_cache,\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"DownloadPackages method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_DOWNLOAD_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"DownloadPackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tgoto out;\n\t}\n\n\t/* create cache directory */\n\tif (!store_in_cache) {\n\t\tdirectory = g_build_filename (LOCALSTATEDIR, \"cache\", \"PackageKit\",\n\t\t\t\t\t     \"downloads\", transaction->priv->tid, NULL);\n\t\t/* rwxrwxr-x */\n\t\tretval = g_mkdir_with_parents (directory, 0775);\n\t\tif (retval != 0) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_DENIED,\n\t\t\t\t     \"cannot create %s\", directory);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_directory = g_strdup (directory);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_DOWNLOAD_PACKAGES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_categories (PkTransaction *transaction,\n\t\t\t       GVariant *params,\n\t\t\t       GDBusMethodInvocation *context)\n{\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"GetCategories method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_CATEGORIES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetCategories not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_CATEGORIES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_depends_on (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgchar *package_ids_temp;\n\tPkBitfield filter;\n\tgboolean recursive;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&sb)\",\n\t\t       &filter,\n\t\t       &package_ids,\n\t\t       &recursive);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"DependsOn method called: %s (recursive %i)\", package_ids_temp, recursive);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_DEPENDS_ON)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"DependsOn not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_force = recursive;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_DEPENDS_ON);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_details (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\",\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"GetDetails method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_DETAILS)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetDetails not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\",\n\t\t\t     package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_DETAILS);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_details_local (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error_local = NULL;\n\tGError *error = NULL;\n\tguint i;\n\tguint length;\n\tg_autofree gchar *content_type = NULL;\n\tg_autofree gchar *files_temp = NULL;\n\tg_autofree gchar **full_paths = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\", &full_paths);\n\n\tfiles_temp = pk_package_ids_to_string (full_paths);\n\tg_debug (\"GetDetailsLocal method called: %s\", files_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_DETAILS_LOCAL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetDetailsLocal not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for empty package list */\n\tlength = g_strv_length (full_paths);\n\tif (length == 0) {\n\t\tg_set_error_literal (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\t\t\t\t     \"No filenames listed\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check all files exists and are valid */\n\tlength = g_strv_length (full_paths);\n\tfor (i = 0; i < length; i++) {\n\n\t\t/* exists */\n\t\tret = g_file_test (full_paths[i], G_FILE_TEST_EXISTS);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get content type */\n\t\tcontent_type = pk_transaction_get_content_type_for_file (full_paths[i],\n\t\t\t\t\t\t\t\t         &error_local);\n\t\tif (content_type == NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* supported content type? */\n\t\tret = pk_transaction_is_supported_content_type (transaction, content_type);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_full_paths = g_strdupv (full_paths);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_DETAILS_LOCAL);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_files_local (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error_local = NULL;\n\tguint i;\n\tguint length;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *content_type = NULL;\n\tg_autofree gchar *files_temp = NULL;\n\tg_autofree gchar **full_paths = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\", &full_paths);\n\n\tfiles_temp = pk_package_ids_to_string (full_paths);\n\tg_debug (\"GetFilesLocal method called: %s\", files_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_FILES_LOCAL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetFilesLocal not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for empty package list */\n\tlength = g_strv_length (full_paths);\n\tif (length == 0) {\n\t\tg_set_error_literal (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NUMBER_OF_PACKAGES_INVALID,\n\t\t\t\t     \"No filenames listed\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check all files exists and are valid */\n\tlength = g_strv_length (full_paths);\n\tfor (i = 0; i < length; i++) {\n\n\t\t/* exists */\n\t\tret = g_file_test (full_paths[i], G_FILE_TEST_EXISTS);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get content type */\n\t\tcontent_type = pk_transaction_get_content_type_for_file (full_paths[i],\n\t\t\t\t\t\t\t\t         &error_local);\n\t\tif (content_type == NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* supported content type? */\n\t\tret = pk_transaction_is_supported_content_type (transaction, content_type);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_full_paths = g_strdupv (full_paths);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_FILES_LOCAL);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_distro_upgrades (PkTransaction *transaction,\n\t\t\t\t    GVariant *params,\n\t\t\t\t    GDBusMethodInvocation *context)\n{\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_debug (\"GetDistroUpgrades method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_DISTRO_UPGRADES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetDistroUpgrades not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_DISTRO_UPGRADES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_files (PkTransaction *transaction,\n\t\t\t  GVariant *params,\n\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\",\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"GetFiles method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_FILES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetFiles not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_FILES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_packages (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\",\n\t\t       &filter);\n\n\tg_debug (\"GetPackages method called: %\" G_GUINT64_FORMAT, filter);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetPackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_PACKAGES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_old_transactions (PkTransaction *transaction,\n\t\t\t\t     GVariant *params,\n\t\t\t\t     GDBusMethodInvocation *context)\n{\n\tconst gchar *cmdline;\n\tconst gchar *data;\n\tconst gchar *modified;\n\tconst gchar *tid;\n\tgboolean succeeded;\n\tGList *l;\n\tGList *transactions = NULL;\n\tguint duration;\n\tguint idle_id;\n\tguint number;\n\tguint uid;\n\tPkRoleEnum role;\n\tPkTransactionPast *item;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(u)\",\n\t\t       &number);\n\n\tg_debug (\"GetOldTransactions method called\");\n\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_OLD_TRANSACTIONS);\n\ttransactions = pk_transaction_db_get_list (transaction->priv->transaction_db, number);\n\tfor (l = transactions; l != NULL; l = l->next) {\n\t\titem = PK_TRANSACTION_PAST (l->data);\n\n\t\t/* add to results */\n\t\tpk_results_add_transaction (transaction->priv->results, item);\n\n\t\t/* get data */\n\t\trole = pk_transaction_past_get_role (item);\n\t\ttid = pk_transaction_past_get_id (item);\n\t\tmodified = pk_transaction_past_get_timespec (item);\n\t\tsucceeded = pk_transaction_past_get_succeeded (item);\n\t\tduration = pk_transaction_past_get_duration (item);\n\t\tdata = pk_transaction_past_get_data (item);\n\t\tuid = pk_transaction_past_get_uid (item);\n\t\tcmdline = pk_transaction_past_get_cmdline (item);\n\n\t\t/* emit */\n\t\tg_debug (\"adding transaction %s, %s, %i, %s, %i, %s, %i, %s\",\n\t\t\t tid, modified, succeeded,\n\t\t\t pk_role_enum_to_string (role),\n\t\t\t duration, data, uid, cmdline);\n\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t       \"Transaction\",\n\t\t\t\t\t       g_variant_new (\"(osbuusus)\",\n\t\t\t\t\t\t\t      tid,\n\t\t\t\t\t\t\t      modified,\n\t\t\t\t\t\t\t      succeeded,\n\t\t\t\t\t\t\t      role,\n\t\t\t\t\t\t\t      duration,\n\t\t\t\t\t\t\t      data != NULL ? data : \"\",\n\t\t\t\t\t\t\t      uid,\n\t\t\t\t\t\t\t      cmdline != NULL ? cmdline : \"\"),\n\t\t\t\t\t       NULL);\n\t}\n\tg_list_free_full (transactions, (GDestroyNotify) g_object_unref);\n\n\tidle_id = g_idle_add ((GSourceFunc) pk_transaction_finished_idle_cb, transaction);\n\tg_source_set_name_by_id (idle_id, \"[PkTransaction] finished from get-old-transactions\");\n\n\tpk_transaction_dbus_return (context, NULL);\n}\n\nstatic void\npk_transaction_get_repo_list (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\",\n\t\t       &filter);\n\n\tg_debug (\"GetRepoList method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_REPO_LIST)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetRepoList not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_REPO_LIST);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_required_by (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tgboolean recursive;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&sb)\",\n\t\t       &filter,\n\t\t       &package_ids,\n\t\t       &recursive);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"RequiredBy method called: %s (recursive %i)\", package_ids_temp, recursive);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REQUIRED_BY)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RequiredBy not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_force = recursive;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REQUIRED_BY);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_get_update_detail (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\",\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\tg_debug (\"GetUpdateDetail method called: %s\", package_ids_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_UPDATE_DETAIL)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetUpdateDetail not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\",\n\t\t\t     package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_UPDATE_DETAIL);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_get_updates (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\",\n\t\t       &filter);\n\n\tg_debug (\"GetUpdates method called\");\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_GET_UPDATES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"GetUpdates not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_GET_UPDATES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic gchar *\npk_transaction_get_content_type_for_file (const gchar *filename, GError **error)\n{\n\tg_autoptr(GError) error_local = NULL;\n\tg_autoptr(GFile) file = NULL;\n\tg_autoptr(GFileInfo) info = NULL;\n\n\t/* get file info synchronously */\n\tfile = g_file_new_for_path (filename);\n\tinfo = g_file_query_info (file, \"standard::content-type\",\n\t\t\t\t  G_FILE_QUERY_INFO_NONE, NULL, &error_local);\n\tif (info == NULL) {\n\t\tg_set_error (error, 1, 0,\n\t\t\t     \"failed to get file attributes for %s: %s\",\n\t\t\t     filename, error_local->message);\n\t\treturn NULL;\n\t}\n\n\t/* get content type as string */\n\treturn g_file_info_get_attribute_as_string (info, \"standard::content-type\");\n}\n\nstatic gboolean\npk_transaction_is_supported_content_type (PkTransaction *transaction,\n\t\t\t\t\t  const gchar *content_type)\n{\n\tconst gchar *tmp;\n\tGPtrArray *array = transaction->priv->supported_content_types;\n\tguint i;\n\n\t/* can we support this one? */\n\tfor (i = 0; i < array->len; i++) {\n\t\ttmp = g_ptr_array_index (array, i);\n\t\tif (g_strcmp0 (tmp, content_type) == 0)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic void\npk_transaction_install_files (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tGError *error_local = NULL;\n\tguint length;\n\tguint i;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *content_type = NULL;\n\tg_autofree gchar **full_paths = NULL;\n\tg_autofree gchar *full_paths_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &transaction_flags,\n\t\t       &full_paths);\n\n\tfull_paths_temp = pk_package_ids_to_string (full_paths);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"InstallFiles method called: %s (transaction_flags: %s)\",\n\t\t full_paths_temp, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_INSTALL_FILES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"InstallFiles not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check all files exists and are valid */\n\tlength = g_strv_length (full_paths);\n\tfor (i = 0; i < length; i++) {\n\t\t/* exists */\n\t\tret = g_file_test (full_paths[i], G_FILE_TEST_EXISTS);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* get content type */\n\t\tcontent_type = pk_transaction_get_content_type_for_file (full_paths[i], &error_local);\n\t\tif (content_type == NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t/* supported content type? */\n\t\tret = pk_transaction_is_supported_content_type (transaction, content_type);\n\t\tif (!ret) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NO_SUCH_FILE,\n\t\t\t\t     \"File %s is not found or unsupported\", full_paths[i]);\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_full_paths = g_strdupv (full_paths);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_INSTALL_FILES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_INSTALL_FILES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_install_packages (PkTransaction *transaction,\n\t\t\t\t GVariant *params,\n\t\t\t\t GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &transaction_flags,\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"InstallPackages method called: %s (transaction_flags: %s)\",\n\t\t package_ids_temp, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_INSTALL_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"InstallPackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_INSTALL_PACKAGES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_INSTALL_PACKAGES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_install_signature (PkTransaction *transaction,\n\t\t\t\t  GVariant *params,\n\t\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *key_id;\n\tconst gchar *package_id;\n\tPkSigTypeEnum sig_type;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(u&s&s)\",\n\t\t       &sig_type,\n\t\t       &key_id,\n\t\t       &package_id);\n\n\tg_debug (\"InstallSignature method called: %s, %s, %s\",\n\t\t pk_sig_type_enum_to_string (sig_type),\n\t\t key_id,\n\t\t package_id);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_INSTALL_SIGNATURE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"InstallSignature not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (key_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_id (';;;repo-id' is used for the repo key) */\n\tret = pk_package_id_check (package_id);\n\tif (!ret && !g_str_has_prefix (package_id, \";;;\")) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id '%s' is not valid\", package_id);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_id = g_strdup (package_id);\n\ttransaction->priv->cached_key_id = g_strdup (key_id);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_INSTALL_SIGNATURE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_INSTALL_SIGNATURE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_refresh_cache (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgboolean force;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(b)\",\n\t\t       &force);\n\n\tg_debug (\"RefreshCache method called: %i\", force);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REFRESH_CACHE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RefreshCache not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_force = force;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REFRESH_CACHE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REFRESH_CACHE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_remove_packages (PkTransaction *transaction,\n\t\t\t\tGVariant *params,\n\t\t\t\tGDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tgboolean allow_deps;\n\tgboolean autoremove;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&sbb)\",\n\t\t       &transaction_flags,\n\t\t       &package_ids,\n\t\t       &allow_deps,\n\t\t       &autoremove);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"RemovePackages method called: %s, %i, %i (transaction_flags: %s)\",\n\t\t package_ids_temp, allow_deps, autoremove, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REMOVE_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RemovePackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\", package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\ttransaction->priv->cached_allow_deps = allow_deps;\n\ttransaction->priv->cached_autoremove = autoremove;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REMOVE_PACKAGES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REMOVE_PACKAGES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repo_enable (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *repo_id;\n\tgboolean enabled;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(&sb)\",\n\t\t       &repo_id,\n\t\t       &enabled);\n\n\tg_debug (\"RepoEnable method called: %s, %i\", repo_id, enabled);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPO_ENABLE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RepoEnable not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (repo_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_repo_id = g_strdup (repo_id);\n\ttransaction->priv->cached_enabled = enabled;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPO_ENABLE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPO_ENABLE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repo_set_data (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tconst gchar *repo_id;\n\tconst gchar *parameter;\n\tconst gchar *value;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(&s&s&s)\",\n\t\t       &repo_id,\n\t\t       &parameter,\n\t\t       &value);\n\n\tg_debug (\"RepoSetData method called: %s, %s, %s\",\n\t\t repo_id, parameter, value);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPO_SET_DATA)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RepoSetData not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (repo_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_repo_id = g_strdup (repo_id);\n\ttransaction->priv->cached_parameter = g_strdup (parameter);\n\ttransaction->priv->cached_value = g_strdup (value);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPO_SET_DATA);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPO_SET_DATA,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repo_remove (PkTransaction *transaction,\n\t\t\t    GVariant *params,\n\t\t\t    GDBusMethodInvocation *context)\n{\n\tPkBitfield transaction_flags;\n\tconst gchar *repo_id;\n\tgboolean autoremove;\n\tgboolean ret;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *tmp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t&sb)\",\n\t\t       &transaction_flags,\n\t\t       &repo_id,\n\t\t       &autoremove);\n\n\ttmp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"RepoRemove method called: %s, %s, %i\",\n\t\t tmp, repo_id, autoremove);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPO_REMOVE)) {\n\t\tg_set_error_literal (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t     \"RepoSetData not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for sanity */\n\tret = pk_transaction_strvalidate (repo_id, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_repo_id = g_strdup (repo_id);\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_autoremove = autoremove;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPO_REMOVE);\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPO_REMOVE,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_resolve (PkTransaction *transaction,\n\t\t\tGVariant *params,\n\t\t\tGDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tguint length;\n\tPkBitfield filter;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **packages = NULL;\n\tg_autofree gchar *packages_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &packages);\n\n\tpackages_temp = pk_package_ids_to_string (packages);\n\tg_debug (\"Resolve method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, packages_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_RESOLVE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"Resolve not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check for length sanity */\n\tlength = g_strv_length (packages);\n\tif (length == 0) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Too few items to process\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\tif (length > PK_TRANSACTION_MAX_ITEMS_TO_RESOLVE) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_INPUT_INVALID,\n\t\t\t     \"Too many items to process (%i/%i)\",\n\t\t\t     length, PK_TRANSACTION_MAX_ITEMS_TO_RESOLVE);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check each package for sanity */\n\tfor (i = 0; i < length; i++) {\n\t\tret = pk_transaction_strvalidate (packages[i], &error);\n\t\tif (!ret) {\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_package_ids = g_strdupv (packages);\n\ttransaction->priv->cached_filters = filter;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_RESOLVE);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_search_details (PkTransaction *transaction,\n\t\t\t       GVariant *params,\n\t\t\t       GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchDetails method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_DETAILS)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchDetails not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_DETAILS);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_search_files (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchFiles method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_FILE)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchFiles not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* when not an absolute path, disallow slashes in search */\n\tfor (i = 0; values[i] != NULL; i++) {\n\t\tif (values[i][0] != '/' && strstr (values[i], \"/\") != NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID,\n\t\t\t\t     \"Invalid search path\");\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_FILE);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_search_groups (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchGroups method called: %\" G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_GROUP)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchGroups not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* do not allow spaces */\n\tfor (i = 0; values[i] != NULL; i++) {\n\t\tif (strstr (values[i], \" \") != NULL) {\n\t\t\tg_set_error (&error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_SEARCH_INVALID,\n\t\t\t\t     \"Invalid search containing spaces\");\n\t\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_GROUP);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nvoid\npk_transaction_search_names (PkTransaction *transaction,\n\t\t\t     GVariant *params,\n\t\t\t     GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"SearchNames method called: %\"  G_GUINT64_FORMAT \", %s\",\n\t\t filter, values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_SEARCH_NAME)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"SearchNames not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_SEARCH_NAME);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic gboolean\npk_transaction_set_hint (PkTransaction *transaction,\n\t\t\t const gchar *key,\n\t\t\t const gchar *value,\n\t\t\t GError **error)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* locale=en_GB.utf8 */\n\tif (g_strcmp0 (key, \"locale\") == 0) {\n\t\tpk_backend_job_set_locale (priv->job, value);\n\t\treturn TRUE;\n\t}\n\n\t/* frontend_socket=/tmp/socket.3456 */\n\tif (g_strcmp0 (key, \"frontend-socket\") == 0) {\n\n\t\t/* nothing provided */\n\t\tif (value == NULL || value[0] == '\\0') {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"Could not set frontend-socket to nothing\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* nothing provided */\n\t\tif (value[0] != '/') {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"frontend-socket has to be an absolute path\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* socket does not exist */\n\t\tif (!g_file_test (value, G_FILE_TEST_EXISTS)) {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"frontend-socket does not exist\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* success */\n\t\tpk_backend_job_set_frontend_socket (priv->job, value);\n\t\treturn TRUE;\n\t}\n\n\t/* background=true */\n\tif (g_strcmp0 (key, \"background\") == 0) {\n\t\tif (g_strcmp0 (value, \"true\") == 0) {\n\t\t\tpk_backend_job_set_background (priv->job, TRUE);\n\t\t} else if (g_strcmp0 (value, \"false\") == 0) {\n\t\t\tpk_backend_job_set_background (priv->job, FALSE);\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t      \"background hint expects true or false, not %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* interactive=true */\n\tif (g_strcmp0 (key, \"interactive\") == 0) {\n\t\tif (g_strcmp0 (value, \"true\") == 0) {\n\t\t\tpk_backend_job_set_interactive (priv->job, TRUE);\n\t\t} else if (g_strcmp0 (value, \"false\") == 0) {\n\t\t\tpk_backend_job_set_interactive (priv->job, FALSE);\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t      \"interactive hint expects true or false, not %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* cache-age=<time-in-seconds> */\n\tif (g_strcmp0 (key, \"cache-age\") == 0) {\n\t\tguint cache_age;\n\t\tif (!pk_strtouint (value, &cache_age)) {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t     \"cannot parse cache age value %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (cache_age == 0) {\n\t\t\tg_set_error_literal (error,\n\t\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"cannot set a cache age of zero\");\n\t\t\treturn FALSE;\n\t\t}\n\t\tpk_backend_job_set_cache_age (priv->job, cache_age);\n\t\treturn TRUE;\n\t}\n\n\t/* Is the plural Packages signal supported? The key\u2019s value is ignored,\n\t * as clients will only send it if it\u2019s true. */\n\tif (g_strcmp0 (key, \"supports-plural-signals\") == 0) {\n\t\tif (g_strcmp0 (value, \"true\") != 0) {\n\t\t\tg_set_error (error,\n\t\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t      \"supports-plural-signals hint expects true only, not %s\", value);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tg_debug (\"Client has set supports-plural-signals=true\");\n\t\tpriv->client_supports_plural_signals = TRUE;\n\t\treturn TRUE;\n\t}\n\n\t/* to preserve forwards and backwards compatibility, we ignore\n\t * extra options here */\n\tg_warning (\"unknown option: %s with value %s\", key, value);\n\treturn TRUE;\n}\n\nstatic void\npk_transaction_set_hints (PkTransaction *transaction,\n\t\t\t  GVariant *params,\n\t\t\t  GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tguint i;\n\tg_autofree gchar **hints = NULL;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *dbg = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(^a&s)\", &hints);\n\tdbg = g_strjoinv (\", \", (gchar**) hints);\n\tg_debug (\"SetHints method called: %s\", dbg);\n\n\t/* parse */\n\tfor (i = 0; hints[i] != NULL; i++) {\n\t\tg_auto(GStrv) sections = NULL;\n\t\tsections = g_strsplit (hints[i], \"=\", 2);\n\t\tif (g_strv_length (sections) == 2) {\n\t\t\tret = pk_transaction_set_hint (transaction,\n\t\t\t\t\t\t       sections[0],\n\t\t\t\t\t\t       sections[1],\n\t\t\t\t\t\t       &error);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tg_set_error (&error, PK_TRANSACTION_ERROR,\n\t\t\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t\t\t     \"Could not parse hint '%s'\", hints[i]);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_update_packages (PkTransaction *transaction,\n\t\t\t\tGVariant *params,\n\t\t\t\tGDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar **package_ids = NULL;\n\tg_autofree gchar *package_ids_temp = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &transaction_flags,\n\t\t       &package_ids);\n\n\tpackage_ids_temp = pk_package_ids_to_string (package_ids);\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"UpdatePackages method called: %s (transaction_flags: %s)\",\n\t\t package_ids_temp, transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_UPDATE_PACKAGES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"UpdatePackages not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check package_ids */\n\tret = pk_package_ids_check (package_ids);\n\tif (!ret) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_PACKAGE_ID_INVALID,\n\t\t\t     \"The package id's '%s' are not valid\",\n\t\t\t     package_ids_temp);\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_package_ids = g_strdupv (package_ids);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_UPDATE_PACKAGES);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_UPDATE_PACKAGES,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_what_provides (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield filter;\n\tg_autofree gchar **values = NULL;\n\tg_autoptr(GError) error = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t^a&s)\",\n\t\t       &filter,\n\t\t       &values);\n\n\tg_debug (\"WhatProvides method called: %s\",\n\t\t values[0]);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_WHAT_PROVIDES)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"WhatProvides not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* check the search term */\n\tret = pk_transaction_search_check (values, &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_filters = filter;\n\ttransaction->priv->cached_values = g_strdupv (values);\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_WHAT_PROVIDES);\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_upgrade_system (PkTransaction *transaction,\n\t\t\t       GVariant *params,\n\t\t\t       GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tPkUpgradeKindEnum upgrade_kind;\n\tconst gchar *distro_id;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t&su)\",\n\t\t       &transaction_flags,\n\t\t       &distro_id,\n\t\t       &upgrade_kind);\n\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"UpgradeSystem method called: %s: %s  (transaction_flags: %s)\",\n\t\t distro_id,\n\t\t pk_upgrade_kind_enum_to_string (upgrade_kind),\n\t\t transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_UPGRADE_SYSTEM)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"UpgradeSystem not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\ttransaction->priv->cached_value = g_strdup (distro_id);\n\ttransaction->priv->cached_upgrade_kind = upgrade_kind;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_UPGRADE_SYSTEM);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_UPGRADE_SYSTEM,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic void\npk_transaction_repair_system (PkTransaction *transaction,\n\t\t\t      GVariant *params,\n\t\t\t      GDBusMethodInvocation *context)\n{\n\tgboolean ret;\n\tPkBitfield transaction_flags;\n\tg_autoptr(GError) error = NULL;\n\tg_autofree gchar *transaction_flags_temp = NULL;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\tg_return_if_fail (transaction->priv->tid != NULL);\n\n\tg_variant_get (params, \"(t)\", &transaction_flags);\n\n\ttransaction_flags_temp = pk_transaction_flag_bitfield_to_string (transaction_flags);\n\tg_debug (\"RepairSystem method called  (transaction_flags: %s)\",\n\t\t transaction_flags_temp);\n\n\t/* not implemented yet */\n\tif (!pk_backend_is_implemented (transaction->priv->backend,\n\t\t\t\t\tPK_ROLE_ENUM_REPAIR_SYSTEM)) {\n\t\tg_set_error (&error,\n\t\t\t     PK_TRANSACTION_ERROR,\n\t\t\t     PK_TRANSACTION_ERROR_NOT_SUPPORTED,\n\t\t\t     \"RepairSystem not supported by backend\");\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\n\n\t/* save so we can run later */\n\ttransaction->priv->cached_transaction_flags = transaction_flags;\n\tpk_transaction_set_role (transaction, PK_ROLE_ENUM_REPAIR_SYSTEM);\n\n\t/* this changed */\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"TransactionFlags\",\n\t\t\t\t\t      g_variant_new_uint64 (transaction_flags));\n\n\t/* try to get authorization */\n\tret = pk_transaction_obtain_authorization (transaction,\n\t\t\t\t\t\t   PK_ROLE_ENUM_REPAIR_SYSTEM,\n\t\t\t\t\t\t   &error);\n\tif (!ret) {\n\t\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_ERROR);\n\t\tgoto out;\n\t}\nout:\n\tpk_transaction_dbus_return (context, error);\n}\n\nstatic GVariant *\n_g_variant_new_maybe_string (const gchar *value)\n{\n\tif (value == NULL)\n\t\treturn g_variant_new_string (\"\");\n\treturn g_variant_new_string (value);\n}\n\nstatic GVariant *\npk_transaction_get_property (GDBusConnection *connection_, const gchar *sender,\n\t\t\t     const gchar *object_path, const gchar *interface_name,\n\t\t\t     const gchar *property_name, GError **error,\n\t\t\t     gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\t/* Ensure that progress signal emissions are done before we potentially\n\t * return more up-to-date property values. */\n\tflush_progress_changed (transaction);\n\n\tif (g_strcmp0 (property_name, \"Role\") == 0)\n\t\treturn g_variant_new_uint32 (priv->role);\n\tif (g_strcmp0 (property_name, \"Status\") == 0)\n\t\treturn g_variant_new_uint32 (priv->status);\n\tif (g_strcmp0 (property_name, \"LastPackage\") == 0)\n\t\treturn _g_variant_new_maybe_string (priv->last_package_id);\n\tif (g_strcmp0 (property_name, \"Uid\") == 0)\n\t\treturn g_variant_new_uint32 (priv->client_uid);\n\tif (g_strcmp0 (property_name, \"Sender\") == 0)\n\t\treturn _g_variant_new_maybe_string (priv->sender);\n\tif (g_strcmp0 (property_name, \"Percentage\") == 0)\n\t\treturn g_variant_new_uint32 (transaction->priv->percentage);\n\tif (g_strcmp0 (property_name, \"AllowCancel\") == 0)\n\t\treturn g_variant_new_boolean (priv->allow_cancel);\n\tif (g_strcmp0 (property_name, \"CallerActive\") == 0)\n\t\treturn g_variant_new_boolean (priv->caller_active);\n\tif (g_strcmp0 (property_name, \"ElapsedTime\") == 0)\n\t\treturn g_variant_new_uint32 (priv->elapsed_time);\n\tif (g_strcmp0 (property_name, \"Speed\") == 0)\n\t\treturn g_variant_new_uint32 (priv->speed);\n\tif (g_strcmp0 (property_name, \"DownloadSizeRemaining\") == 0)\n\t\treturn g_variant_new_uint64 (priv->download_size_remaining);\n\tif (g_strcmp0 (property_name, \"TransactionFlags\") == 0)\n\t\treturn g_variant_new_uint64 (priv->cached_transaction_flags);\n\tif (g_strcmp0 (property_name, \"RemainingTime\") == 0)\n\t\treturn g_variant_new_uint32 (priv->remaining_time);\n\n\tg_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_PROPERTY,\n\t\t     \"Unknown transaction property \u2018%s\u2019\", property_name);\n\treturn NULL;\n}\n\nstatic void\npk_transaction_method_call (GDBusConnection *connection_, const gchar *sender,\n\t\t\t    const gchar *object_path, const gchar *interface_name,\n\t\t\t    const gchar *method_name, GVariant *parameters,\n\t\t\t    GDBusMethodInvocation *invocation, gpointer user_data)\n{\n\tPkTransaction *transaction = PK_TRANSACTION (user_data);\n\n\tg_return_if_fail (transaction->priv->sender != NULL);\n\n\t/* check is the same as the sender that did CreateTransaction */\n\tif (g_strcmp0 (transaction->priv->sender, sender) != 0) {\n\t\tg_dbus_method_invocation_return_error (invocation,\n\t\t\t\t\t\t       PK_TRANSACTION_ERROR,\n\t\t\t\t\t\t       PK_TRANSACTION_ERROR_REFUSED_BY_POLICY,\n\t\t\t\t\t\t       \"sender does not match (%s vs %s)\",\n\t\t\t\t\t\t       sender,\n\t\t\t\t\t\t       transaction->priv->sender);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SetHints\") == 0) {\n\t\tpk_transaction_set_hints (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"AcceptEula\") == 0) {\n\t\tpk_transaction_accept_eula (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"Cancel\") == 0) {\n\t\tpk_transaction_cancel (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"DownloadPackages\") == 0) {\n\t\tpk_transaction_download_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetCategories\") == 0) {\n\t\tpk_transaction_get_categories (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"DependsOn\") == 0) {\n\t\tpk_transaction_depends_on (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetDetails\") == 0) {\n\t\tpk_transaction_get_details (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetDetailsLocal\") == 0) {\n\t\tpk_transaction_get_details_local (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetFilesLocal\") == 0) {\n\t\tpk_transaction_get_files_local (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetFiles\") == 0) {\n\t\tpk_transaction_get_files (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetOldTransactions\") == 0) {\n\t\tpk_transaction_get_old_transactions (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetPackages\") == 0) {\n\t\tpk_transaction_get_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetRepoList\") == 0) {\n\t\tpk_transaction_get_repo_list (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RequiredBy\") == 0) {\n\t\tpk_transaction_required_by (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetUpdateDetail\") == 0) {\n\t\tpk_transaction_get_update_detail (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetUpdates\") == 0) {\n\t\tpk_transaction_get_updates (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"GetDistroUpgrades\") == 0) {\n\t\tpk_transaction_get_distro_upgrades (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"InstallFiles\") == 0) {\n\t\tpk_transaction_install_files (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"InstallPackages\") == 0) {\n\t\tpk_transaction_install_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"InstallSignature\") == 0) {\n\t\tpk_transaction_install_signature (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RefreshCache\") == 0) {\n\t\tpk_transaction_refresh_cache (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RemovePackages\") == 0) {\n\t\tpk_transaction_remove_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepoEnable\") == 0) {\n\t\tpk_transaction_repo_enable (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepoSetData\") == 0) {\n\t\tpk_transaction_repo_set_data (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepoRemove\") == 0) {\n\t\tpk_transaction_repo_remove (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"Resolve\") == 0) {\n\t\tpk_transaction_resolve (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchDetails\") == 0) {\n\t\tpk_transaction_search_details (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchFiles\") == 0) {\n\t\tpk_transaction_search_files (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchGroups\") == 0) {\n\t\tpk_transaction_search_groups (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"SearchNames\") == 0) {\n\t\tpk_transaction_search_names (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"UpdatePackages\") == 0) {\n\t\tpk_transaction_update_packages (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"WhatProvides\") == 0) {\n\t\tpk_transaction_what_provides (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"UpgradeSystem\") == 0) {\n\t\tpk_transaction_upgrade_system (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\tif (g_strcmp0 (method_name, \"RepairSystem\") == 0) {\n\t\tpk_transaction_repair_system (transaction, parameters, invocation);\n\t\treturn;\n\t}\n\n\t/* nothing matched */\n\tg_dbus_method_invocation_return_error (invocation,\n\t\t\t\t\t       PK_TRANSACTION_ERROR,\n\t\t\t\t\t       PK_TRANSACTION_ERROR_INVALID_STATE,\n\t\t\t\t\t       \"method from %s not recognised\",\n\t\t\t\t\t       sender);\n}\n\ngboolean\npk_transaction_set_tid (PkTransaction *transaction, const gchar *tid)\n{\n\tstatic const GDBusInterfaceVTable interface_vtable = {\n\t\t.method_call = pk_transaction_method_call,\n\t\t.get_property = pk_transaction_get_property,\n\t\t.set_property = NULL\n\t};\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\tg_return_val_if_fail (tid != NULL, FALSE);\n\tg_return_val_if_fail (transaction->priv->tid == NULL, FALSE);\n\n\ttransaction->priv->tid = g_strdup (tid);\n\n\t/* register org.freedesktop.PackageKit.Transaction */\n\ttransaction->priv->connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n\tg_assert (transaction->priv->connection != NULL);\n\ttransaction->priv->registration_id =\n\t\tg_dbus_connection_register_object (transaction->priv->connection,\n\t\t\t\t\t\t   tid,\n\t\t\t\t\t\t   transaction->priv->introspection->interfaces[0],\n\t\t\t\t\t\t   &interface_vtable,\n\t\t\t\t\t\t   transaction,  /* user_data */\n\t\t\t\t\t\t   NULL,  /* user_data_free_func */\n\t\t\t\t\t\t   NULL); /* GError** */\n\tg_assert (transaction->priv->registration_id > 0);\n\treturn TRUE;\n}\n\nvoid\npk_transaction_reset_after_lock_error (PkTransaction *transaction)\n{\n\tPkTransactionPrivate *priv = PK_TRANSACTION_GET_PRIVATE (transaction);\n\tg_return_if_fail (PK_IS_TRANSACTION (transaction));\n\n\t/* clear results */\n\tg_object_unref (priv->results);\n\tpriv->results = pk_results_new ();\n\n\t/* reset transaction state */\n\t/* first set state manually, otherwise set_state will refuse to switch to an earlier stage */\n\tpriv->state = PK_TRANSACTION_STATE_READY;\n\tpk_transaction_set_state (transaction, PK_TRANSACTION_STATE_READY);\n\n\tg_debug (\"transaction has been reset after lock-required issue.\");\n}\n\nstatic void\npk_transaction_class_init (PkTransactionClass *klass)\n{\n\tGObjectClass *object_class = G_OBJECT_CLASS (klass);\n\tobject_class->dispose = pk_transaction_dispose;\n\tobject_class->finalize = pk_transaction_finalize;\n\n\tsignals[SIGNAL_FINISHED] =\n\t\tg_signal_new (\"finished\",\n\t\t\t      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,\n\t\t\t      0, NULL, NULL, g_cclosure_marshal_VOID__VOID,\n\t\t\t      G_TYPE_NONE, 0);\n\tsignals[SIGNAL_STATE_CHANGED] =\n\t\tg_signal_new (\"state-changed\",\n\t\t\t      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,\n\t\t\t      0, NULL, NULL, g_cclosure_marshal_VOID__UINT,\n\t\t\t      G_TYPE_NONE, 1, G_TYPE_UINT);\n\tsignals[SIGNAL_ALLOW_CANCEL_CHANGED] =\n\t\tg_signal_new (\"allow-cancel-changed\",\n\t\t\t      G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST,\n\t\t\t      0, NULL, NULL, g_cclosure_marshal_VOID__UINT,\n\t\t\t      G_TYPE_NONE, 1, G_TYPE_UINT);\n\n\tg_type_class_add_private (klass, sizeof (PkTransactionPrivate));\n}\n\nstatic void\npk_transaction_init (PkTransaction *transaction)\n{\n\tgboolean ret;\n\tg_autoptr(GError) error = NULL;\n\ttransaction->priv = PK_TRANSACTION_GET_PRIVATE (transaction);\n\ttransaction->priv->allow_cancel = TRUE;\n\ttransaction->priv->caller_active = TRUE;\n\ttransaction->priv->cached_transaction_flags = PK_TRANSACTION_FLAG_ENUM_NONE;\n\ttransaction->priv->cached_filters = PK_FILTER_ENUM_NONE;\n\ttransaction->priv->client_uid = PK_TRANSACTION_UID_INVALID;\n\ttransaction->priv->client_pid = PK_TRANSACTION_PID_INVALID;\n\ttransaction->priv->role = PK_ROLE_ENUM_UNKNOWN;\n\ttransaction->priv->status = PK_STATUS_ENUM_WAIT;\n\ttransaction->priv->percentage = PK_BACKEND_PERCENTAGE_INVALID;\n\ttransaction->priv->state = PK_TRANSACTION_STATE_UNKNOWN;\n\ttransaction->priv->dbus = pk_dbus_new ();\n\ttransaction->priv->results = pk_results_new ();\n\ttransaction->priv->supported_content_types = g_ptr_array_new_with_free_func (g_free);\n\ttransaction->priv->cancellable = g_cancellable_new ();\n\n\ttransaction->priv->transaction_db = pk_transaction_db_new ();\n\tret = pk_transaction_db_load (transaction->priv->transaction_db, &error);\n\tif (!ret)\n\t\tg_error (\"PkEngine: failed to load transaction db: %s\", error->message);\n}\n\nstatic void\npk_transaction_dispose (GObject *object)\n{\n\tPkTransaction *transaction;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (object));\n\n\ttransaction = PK_TRANSACTION (object);\n\n\t/* were we waiting for the client to authorise */\n\tif (transaction->priv->waiting_for_auth) {\n\t\tg_cancellable_cancel (transaction->priv->cancellable);\n\t\t/* emit an ::ErrorCode() and then ::Finished() */\n\t\tpk_transaction_error_code_emit (transaction, PK_ERROR_ENUM_NOT_AUTHORIZED, \"client did not authorize action\");\n\t\tpk_transaction_finished_emit (transaction, PK_EXIT_ENUM_FAILED, 0);\n\t}\n\n\tif (transaction->priv->registration_id > 0) {\n\t\tg_dbus_connection_unregister_object (transaction->priv->connection,\n\t\t\t\t\t\t     transaction->priv->registration_id);\n\t\ttransaction->priv->registration_id = 0;\n\t}\n\n\tunschedule_progress_changed (transaction);\n\n\t/* send signal to clients that we are about to be destroyed */\n\tif (transaction->priv->connection != NULL) {\n\t\tg_debug (\"emitting destroy %s\", transaction->priv->tid);\n\t\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       transaction->priv->tid,\n\t\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t\t       \"Destroy\",\n\t\t\t\t\t       NULL,\n\t\t\t\t\t       NULL);\n\t}\n\n\tG_OBJECT_CLASS (pk_transaction_parent_class)->dispose (object);\n}\n\nstatic void\npk_transaction_finalize (GObject *object)\n{\n\tPkTransaction *transaction;\n\n\tg_return_if_fail (PK_IS_TRANSACTION (object));\n\n\ttransaction = PK_TRANSACTION (object);\n\n\tif (transaction->priv->subject != NULL)\n\t\tg_object_unref (transaction->priv->subject);\n\tif (transaction->priv->watch_id > 0)\n\t\tg_bus_unwatch_name (transaction->priv->watch_id);\n\tg_free (transaction->priv->last_package_id);\n\tg_free (transaction->priv->cached_package_id);\n\tg_free (transaction->priv->cached_key_id);\n\tg_strfreev (transaction->priv->cached_package_ids);\n\tg_free (transaction->priv->cached_transaction_id);\n\tg_free (transaction->priv->cached_directory);\n\tg_strfreev (transaction->priv->cached_values);\n\tg_free (transaction->priv->cached_repo_id);\n\tg_free (transaction->priv->cached_parameter);\n\tg_free (transaction->priv->cached_value);\n\tg_free (transaction->priv->tid);\n\tg_free (transaction->priv->sender);\n\tg_free (transaction->priv->cmdline);\n\tg_ptr_array_unref (transaction->priv->supported_content_types);\n\n\tif (transaction->priv->connection != NULL)\n\t\tg_object_unref (transaction->priv->connection);\n\tif (transaction->priv->introspection != NULL)\n\t\tg_dbus_node_info_unref (transaction->priv->introspection);\n\n\tg_key_file_unref (transaction->priv->conf);\n\tg_object_unref (transaction->priv->dbus);\n\tif (transaction->priv->backend != NULL)\n\t\tg_object_unref (transaction->priv->backend);\n\tg_object_unref (transaction->priv->job);\n\tg_object_unref (transaction->priv->transaction_db);\n\tg_object_unref (transaction->priv->results);\n\tif (transaction->priv->authority != NULL)\n\t\tg_object_unref (transaction->priv->authority);\n\tg_object_unref (transaction->priv->cancellable);\n\n\tG_OBJECT_CLASS (pk_transaction_parent_class)->finalize (object);\n}\n\nPkTransaction *\npk_transaction_new (GKeyFile *conf, GDBusNodeInfo *introspection)\n{\n\tPkTransaction *transaction;\n\ttransaction = g_object_new (PK_TYPE_TRANSACTION, NULL);\n\ttransaction->priv->conf = g_key_file_ref (conf);\n\ttransaction->priv->job = pk_backend_job_new (conf);\n\ttransaction->priv->introspection = g_dbus_node_info_ref (introspection);\n\treturn PK_TRANSACTION (transaction);\n}\n\n"], "filenames": ["src/pk-transaction.c"], "buggy_code_start_loc": [92], "buggy_code_end_loc": [512], "fixing_code_start_loc": [93], "fixing_code_end_loc": [517], "type": "CWE-416", "message": "A use-after-free flaw was found in PackageKitd. In some conditions, the order of cleanup mechanics for a transaction could be impacted. As a result, some memory access could occur on memory regions that were previously freed. Once freed, a memory region can be reused for other allocations and any previously stored data in this memory region is considered lost.", "other": {"cve": {"id": "CVE-2024-0217", "sourceIdentifier": "secalert@redhat.com", "published": "2024-01-03T17:15:12.110", "lastModified": "2024-02-02T15:20:25.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use-after-free flaw was found in PackageKitd. In some conditions, the order of cleanup mechanics for a transaction could be impacted. As a result, some memory access could occur on memory regions that were previously freed. Once freed, a memory region can be reused for other allocations and any previously stored data in this memory region is considered lost."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo de use after free en PackageKitd. En algunas condiciones, el orden de los mecanismos de limpieza de una transacci\u00f3n podr\u00eda verse afectado. Como resultado, podr\u00eda producirse cierto acceso a la memoria en regiones de memoria que se liberaron previamente. Una vez liberada, una regi\u00f3n de memoria se puede reutilizar para otras asignaciones y cualquier dato previamente almacenado en esta regi\u00f3n de memoria se considera perdido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:packagekit_project:packagekit:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.7", "matchCriteriaId": "2E42E6D2-CD64-440D-8A80-CA4103E1C4D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2024-0217", "source": "secalert@redhat.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2256624", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/PackageKit/PackageKit/commit/64278c9127e3333342b56ead99556161f7e86f79", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/PackageKit/PackageKit/commit/64278c9127e3333342b56ead99556161f7e86f79"}}