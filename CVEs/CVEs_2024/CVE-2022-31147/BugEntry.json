{"buggy_code": ["// Same as url, but TLD is optional\n$.validator.addMethod( \"url2\", function( value, element ) {\n\treturn this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.?)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test( value );\n}, $.validator.messages.url );\n", "$.extend( $.fn, {\n\n\t// https://jqueryvalidation.org/validate/\n\tvalidate: function( options ) {\n\n\t\t// If nothing is selected, return nothing; can't chain anyway\n\t\tif ( !this.length ) {\n\t\t\tif ( options && options.debug && window.console ) {\n\t\t\t\tconsole.warn( \"Nothing selected, can't validate, returning nothing.\" );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a validator for this form was already created\n\t\tvar validator = $.data( this[ 0 ], \"validator\" );\n\t\tif ( validator ) {\n\t\t\treturn validator;\n\t\t}\n\n\t\t// Add novalidate tag if HTML5.\n\t\tthis.attr( \"novalidate\", \"novalidate\" );\n\n\t\tvalidator = new $.validator( options, this[ 0 ] );\n\t\t$.data( this[ 0 ], \"validator\", validator );\n\n\t\tif ( validator.settings.onsubmit ) {\n\n\t\t\tthis.on( \"click.validate\", \":submit\", function( event ) {\n\n\t\t\t\t// Track the used submit button to properly handle scripted\n\t\t\t\t// submits later.\n\t\t\t\tvalidator.submitButton = event.currentTarget;\n\n\t\t\t\t// Allow suppressing validation by adding a cancel class to the submit button\n\t\t\t\tif ( $( this ).hasClass( \"cancel\" ) ) {\n\t\t\t\t\tvalidator.cancelSubmit = true;\n\t\t\t\t}\n\n\t\t\t\t// Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button\n\t\t\t\tif ( $( this ).attr( \"formnovalidate\" ) !== undefined ) {\n\t\t\t\t\tvalidator.cancelSubmit = true;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Validate the form on submit\n\t\t\tthis.on( \"submit.validate\", function( event ) {\n\t\t\t\tif ( validator.settings.debug ) {\n\n\t\t\t\t\t// Prevent form submit to be able to see console output\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\tfunction handle() {\n\t\t\t\t\tvar hidden, result;\n\n\t\t\t\t\t// Insert a hidden input as a replacement for the missing submit button\n\t\t\t\t\t// The hidden input is inserted in two cases:\n\t\t\t\t\t//   - A user defined a `submitHandler`\n\t\t\t\t\t//   - There was a pending request due to `remote` method and `stopRequest()`\n\t\t\t\t\t//     was called to submit the form in case it's valid\n\t\t\t\t\tif ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {\n\t\t\t\t\t\thidden = $( \"<input type='hidden'/>\" )\n\t\t\t\t\t\t\t.attr( \"name\", validator.submitButton.name )\n\t\t\t\t\t\t\t.val( $( validator.submitButton ).val() )\n\t\t\t\t\t\t\t.appendTo( validator.currentForm );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( validator.settings.submitHandler && !validator.settings.debug ) {\n\t\t\t\t\t\tresult = validator.settings.submitHandler.call( validator, validator.currentForm, event );\n\t\t\t\t\t\tif ( hidden ) {\n\n\t\t\t\t\t\t\t// And clean up afterwards; thanks to no-block-scope, hidden can be referenced\n\t\t\t\t\t\t\thidden.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( result !== undefined ) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Prevent submit for invalid forms or custom submit handlers\n\t\t\t\tif ( validator.cancelSubmit ) {\n\t\t\t\t\tvalidator.cancelSubmit = false;\n\t\t\t\t\treturn handle();\n\t\t\t\t}\n\t\t\t\tif ( validator.form() ) {\n\t\t\t\t\tif ( validator.pendingRequest ) {\n\t\t\t\t\t\tvalidator.formSubmitted = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn handle();\n\t\t\t\t} else {\n\t\t\t\t\tvalidator.focusInvalid();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\treturn validator;\n\t},\n\n\t// https://jqueryvalidation.org/valid/\n\tvalid: function() {\n\t\tvar valid, validator, errorList;\n\n\t\tif ( $( this[ 0 ] ).is( \"form\" ) ) {\n\t\t\tvalid = this.validate().form();\n\t\t} else {\n\t\t\terrorList = [];\n\t\t\tvalid = true;\n\t\t\tvalidator = $( this[ 0 ].form ).validate();\n\t\t\tthis.each( function() {\n\t\t\t\tvalid = validator.element( this ) && valid;\n\t\t\t\tif ( !valid ) {\n\t\t\t\t\terrorList = errorList.concat( validator.errorList );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tvalidator.errorList = errorList;\n\t\t}\n\t\treturn valid;\n\t},\n\n\t// https://jqueryvalidation.org/rules/\n\trules: function( command, argument ) {\n\t\tvar element = this[ 0 ],\n\t\t\tisContentEditable = typeof this.attr( \"contenteditable\" ) !== \"undefined\" && this.attr( \"contenteditable\" ) !== \"false\",\n\t\t\tsettings, staticRules, existingRules, data, param, filtered;\n\n\t\t// If nothing is selected, return empty object; can't chain anyway\n\t\tif ( element == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !element.form && isContentEditable ) {\n\t\t\telement.form = this.closest( \"form\" )[ 0 ];\n\t\t\telement.name = this.attr( \"name\" );\n\t\t}\n\n\t\tif ( element.form == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( command ) {\n\t\t\tsettings = $.data( element.form, \"validator\" ).settings;\n\t\t\tstaticRules = settings.rules;\n\t\t\texistingRules = $.validator.staticRules( element );\n\t\t\tswitch ( command ) {\n\t\t\tcase \"add\":\n\t\t\t\t$.extend( existingRules, $.validator.normalizeRule( argument ) );\n\n\t\t\t\t// Remove messages from rules, but allow them to be set separately\n\t\t\t\tdelete existingRules.messages;\n\t\t\t\tstaticRules[ element.name ] = existingRules;\n\t\t\t\tif ( argument.messages ) {\n\t\t\t\t\tsettings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"remove\":\n\t\t\t\tif ( !argument ) {\n\t\t\t\t\tdelete staticRules[ element.name ];\n\t\t\t\t\treturn existingRules;\n\t\t\t\t}\n\t\t\t\tfiltered = {};\n\t\t\t\t$.each( argument.split( /\\s/ ), function( index, method ) {\n\t\t\t\t\tfiltered[ method ] = existingRules[ method ];\n\t\t\t\t\tdelete existingRules[ method ];\n\t\t\t\t} );\n\t\t\t\treturn filtered;\n\t\t\t}\n\t\t}\n\n\t\tdata = $.validator.normalizeRules(\n\t\t$.extend(\n\t\t\t{},\n\t\t\t$.validator.classRules( element ),\n\t\t\t$.validator.attributeRules( element ),\n\t\t\t$.validator.dataRules( element ),\n\t\t\t$.validator.staticRules( element )\n\t\t), element );\n\n\t\t// Make sure required is at front\n\t\tif ( data.required ) {\n\t\t\tparam = data.required;\n\t\t\tdelete data.required;\n\t\t\tdata = $.extend( { required: param }, data );\n\t\t}\n\n\t\t// Make sure remote is at back\n\t\tif ( data.remote ) {\n\t\t\tparam = data.remote;\n\t\t\tdelete data.remote;\n\t\t\tdata = $.extend( data, { remote: param } );\n\t\t}\n\n\t\treturn data;\n\t}\n} );\n\n// JQuery trim is deprecated, provide a trim method based on String.prototype.trim\nvar trim = function( str ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim#Polyfill\n\treturn str.replace( /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\" );\n};\n\n// Custom selectors\n$.extend( $.expr.pseudos || $.expr[ \":\" ], {\t\t// '|| $.expr[ \":\" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support\n\n\t// https://jqueryvalidation.org/blank-selector/\n\tblank: function( a ) {\n\t\treturn !trim( \"\" + $( a ).val() );\n\t},\n\n\t// https://jqueryvalidation.org/filled-selector/\n\tfilled: function( a ) {\n\t\tvar val = $( a ).val();\n\t\treturn val !== null && !!trim( \"\" + val );\n\t},\n\n\t// https://jqueryvalidation.org/unchecked-selector/\n\tunchecked: function( a ) {\n\t\treturn !$( a ).prop( \"checked\" );\n\t}\n} );\n\n// Constructor for validator\n$.validator = function( options, form ) {\n\tthis.settings = $.extend( true, {}, $.validator.defaults, options );\n\tthis.currentForm = form;\n\tthis.init();\n};\n\n// https://jqueryvalidation.org/jQuery.validator.format/\n$.validator.format = function( source, params ) {\n\tif ( arguments.length === 1 ) {\n\t\treturn function() {\n\t\t\tvar args = $.makeArray( arguments );\n\t\t\targs.unshift( source );\n\t\t\treturn $.validator.format.apply( this, args );\n\t\t};\n\t}\n\tif ( params === undefined ) {\n\t\treturn source;\n\t}\n\tif ( arguments.length > 2 && params.constructor !== Array  ) {\n\t\tparams = $.makeArray( arguments ).slice( 1 );\n\t}\n\tif ( params.constructor !== Array ) {\n\t\tparams = [ params ];\n\t}\n\t$.each( params, function( i, n ) {\n\t\tsource = source.replace( new RegExp( \"\\\\{\" + i + \"\\\\}\", \"g\" ), function() {\n\t\t\treturn n;\n\t\t} );\n\t} );\n\treturn source;\n};\n\n$.extend( $.validator, {\n\n\tdefaults: {\n\t\tmessages: {},\n\t\tgroups: {},\n\t\trules: {},\n\t\terrorClass: \"error\",\n\t\tpendingClass: \"pending\",\n\t\tvalidClass: \"valid\",\n\t\terrorElement: \"label\",\n\t\tfocusCleanup: false,\n\t\tfocusInvalid: true,\n\t\terrorContainer: $( [] ),\n\t\terrorLabelContainer: $( [] ),\n\t\tonsubmit: true,\n\t\tignore: \":hidden\",\n\t\tignoreTitle: false,\n\t\tonfocusin: function( element ) {\n\t\t\tthis.lastActive = element;\n\n\t\t\t// Hide error label and remove error class on focus if enabled\n\t\t\tif ( this.settings.focusCleanup ) {\n\t\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t\tthis.hideThese( this.errorsFor( element ) );\n\t\t\t}\n\t\t},\n\t\tonfocusout: function( element ) {\n\t\t\tif ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {\n\t\t\t\tthis.element( element );\n\t\t\t}\n\t\t},\n\t\tonkeyup: function( element, event ) {\n\n\t\t\t// Avoid revalidate the field when pressing one of the following keys\n\t\t\t// Shift       => 16\n\t\t\t// Ctrl        => 17\n\t\t\t// Alt         => 18\n\t\t\t// Caps lock   => 20\n\t\t\t// End         => 35\n\t\t\t// Home        => 36\n\t\t\t// Left arrow  => 37\n\t\t\t// Up arrow    => 38\n\t\t\t// Right arrow => 39\n\t\t\t// Down arrow  => 40\n\t\t\t// Insert      => 45\n\t\t\t// Num lock    => 144\n\t\t\t// AltGr key   => 225\n\t\t\tvar excludedKeys = [\n\t\t\t\t16, 17, 18, 20, 35, 36, 37,\n\t\t\t\t38, 39, 40, 45, 144, 225\n\t\t\t];\n\n\t\t\tif ( event.which === 9 && this.elementValue( element ) === \"\" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {\n\t\t\t\treturn;\n\t\t\t} else if ( element.name in this.submitted || element.name in this.invalid ) {\n\t\t\t\tthis.element( element );\n\t\t\t}\n\t\t},\n\t\tonclick: function( element ) {\n\n\t\t\t// Click on selects, radiobuttons and checkboxes\n\t\t\tif ( element.name in this.submitted ) {\n\t\t\t\tthis.element( element );\n\n\t\t\t// Or option elements, check parent select in that case\n\t\t\t} else if ( element.parentNode.name in this.submitted ) {\n\t\t\t\tthis.element( element.parentNode );\n\t\t\t}\n\t\t},\n\t\thighlight: function( element, errorClass, validClass ) {\n\t\t\tif ( element.type === \"radio\" ) {\n\t\t\t\tthis.findByName( element.name ).addClass( errorClass ).removeClass( validClass );\n\t\t\t} else {\n\t\t\t\t$( element ).addClass( errorClass ).removeClass( validClass );\n\t\t\t}\n\t\t},\n\t\tunhighlight: function( element, errorClass, validClass ) {\n\t\t\tif ( element.type === \"radio\" ) {\n\t\t\t\tthis.findByName( element.name ).removeClass( errorClass ).addClass( validClass );\n\t\t\t} else {\n\t\t\t\t$( element ).removeClass( errorClass ).addClass( validClass );\n\t\t\t}\n\t\t}\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.setDefaults/\n\tsetDefaults: function( settings ) {\n\t\t$.extend( $.validator.defaults, settings );\n\t},\n\n\tmessages: {\n\t\trequired: \"This field is required.\",\n\t\tremote: \"Please fix this field.\",\n\t\temail: \"Please enter a valid email address.\",\n\t\turl: \"Please enter a valid URL.\",\n\t\tdate: \"Please enter a valid date.\",\n\t\tdateISO: \"Please enter a valid date (ISO).\",\n\t\tnumber: \"Please enter a valid number.\",\n\t\tdigits: \"Please enter only digits.\",\n\t\tequalTo: \"Please enter the same value again.\",\n\t\tmaxlength: $.validator.format( \"Please enter no more than {0} characters.\" ),\n\t\tminlength: $.validator.format( \"Please enter at least {0} characters.\" ),\n\t\trangelength: $.validator.format( \"Please enter a value between {0} and {1} characters long.\" ),\n\t\trange: $.validator.format( \"Please enter a value between {0} and {1}.\" ),\n\t\tmax: $.validator.format( \"Please enter a value less than or equal to {0}.\" ),\n\t\tmin: $.validator.format( \"Please enter a value greater than or equal to {0}.\" ),\n\t\tstep: $.validator.format( \"Please enter a multiple of {0}.\" )\n\t},\n\n\tautoCreateRanges: false,\n\n\tprototype: {\n\n\t\tinit: function() {\n\t\t\tthis.labelContainer = $( this.settings.errorLabelContainer );\n\t\t\tthis.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );\n\t\t\tthis.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );\n\t\t\tthis.submitted = {};\n\t\t\tthis.valueCache = {};\n\t\t\tthis.pendingRequest = 0;\n\t\t\tthis.pending = {};\n\t\t\tthis.invalid = {};\n\t\t\tthis.reset();\n\n\t\t\tvar currentForm = this.currentForm,\n\t\t\t\tgroups = ( this.groups = {} ),\n\t\t\t\trules;\n\t\t\t$.each( this.settings.groups, function( key, value ) {\n\t\t\t\tif ( typeof value === \"string\" ) {\n\t\t\t\t\tvalue = value.split( /\\s/ );\n\t\t\t\t}\n\t\t\t\t$.each( value, function( index, name ) {\n\t\t\t\t\tgroups[ name ] = key;\n\t\t\t\t} );\n\t\t\t} );\n\t\t\trules = this.settings.rules;\n\t\t\t$.each( rules, function( key, value ) {\n\t\t\t\trules[ key ] = $.validator.normalizeRule( value );\n\t\t\t} );\n\n\t\t\tfunction delegate( event ) {\n\t\t\t\tvar isContentEditable = typeof $( this ).attr( \"contenteditable\" ) !== \"undefined\" && $( this ).attr( \"contenteditable\" ) !== \"false\";\n\n\t\t\t\t// Set form expando on contenteditable\n\t\t\t\tif ( !this.form && isContentEditable ) {\n\t\t\t\t\tthis.form = $( this ).closest( \"form\" )[ 0 ];\n\t\t\t\t\tthis.name = $( this ).attr( \"name\" );\n\t\t\t\t}\n\n\t\t\t\t// Ignore the element if it belongs to another form. This will happen mainly\n\t\t\t\t// when setting the `form` attribute of an input to the id of another form.\n\t\t\t\tif ( currentForm !== this.form ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar validator = $.data( this.form, \"validator\" ),\n\t\t\t\t\teventType = \"on\" + event.type.replace( /^validate/, \"\" ),\n\t\t\t\t\tsettings = validator.settings;\n\t\t\t\tif ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {\n\t\t\t\t\tsettings[ eventType ].call( validator, this, event );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$( this.currentForm )\n\t\t\t\t.on( \"focusin.validate focusout.validate keyup.validate\",\n\t\t\t\t\t\":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], \" +\n\t\t\t\t\t\"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], \" +\n\t\t\t\t\t\"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], \" +\n\t\t\t\t\t\"[type='radio'], [type='checkbox'], [contenteditable], [type='button']\", delegate )\n\n\t\t\t\t// Support: Chrome, oldIE\n\t\t\t\t// \"select\" is provided as event.target when clicking a option\n\t\t\t\t.on( \"click.validate\", \"select, option, [type='radio'], [type='checkbox']\", delegate );\n\n\t\t\tif ( this.settings.invalidHandler ) {\n\t\t\t\t$( this.currentForm ).on( \"invalid-form.validate\", this.settings.invalidHandler );\n\t\t\t}\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.form/\n\t\tform: function() {\n\t\t\tthis.checkForm();\n\t\t\t$.extend( this.submitted, this.errorMap );\n\t\t\tthis.invalid = $.extend( {}, this.errorMap );\n\t\t\tif ( !this.valid() ) {\n\t\t\t\t$( this.currentForm ).triggerHandler( \"invalid-form\", [ this ] );\n\t\t\t}\n\t\t\tthis.showErrors();\n\t\t\treturn this.valid();\n\t\t},\n\n\t\tcheckForm: function() {\n\t\t\tthis.prepareForm();\n\t\t\tfor ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {\n\t\t\t\tthis.check( elements[ i ] );\n\t\t\t}\n\t\t\treturn this.valid();\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.element/\n\t\telement: function( element ) {\n\t\t\tvar cleanElement = this.clean( element ),\n\t\t\t\tcheckElement = this.validationTargetFor( cleanElement ),\n\t\t\t\tv = this,\n\t\t\t\tresult = true,\n\t\t\t\trs, group;\n\n\t\t\tif ( checkElement === undefined ) {\n\t\t\t\tdelete this.invalid[ cleanElement.name ];\n\t\t\t} else {\n\t\t\t\tthis.prepareElement( checkElement );\n\t\t\t\tthis.currentElements = $( checkElement );\n\n\t\t\t\t// If this element is grouped, then validate all group elements already\n\t\t\t\t// containing a value\n\t\t\t\tgroup = this.groups[ checkElement.name ];\n\t\t\t\tif ( group ) {\n\t\t\t\t\t$.each( this.groups, function( name, testgroup ) {\n\t\t\t\t\t\tif ( testgroup === group && name !== checkElement.name ) {\n\t\t\t\t\t\t\tcleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );\n\t\t\t\t\t\t\tif ( cleanElement && cleanElement.name in v.invalid ) {\n\t\t\t\t\t\t\t\tv.currentElements.push( cleanElement );\n\t\t\t\t\t\t\t\tresult = v.check( cleanElement ) && result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\trs = this.check( checkElement ) !== false;\n\t\t\t\tresult = result && rs;\n\t\t\t\tif ( rs ) {\n\t\t\t\t\tthis.invalid[ checkElement.name ] = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.invalid[ checkElement.name ] = true;\n\t\t\t\t}\n\n\t\t\t\tif ( !this.numberOfInvalids() ) {\n\n\t\t\t\t\t// Hide error containers on last error\n\t\t\t\t\tthis.toHide = this.toHide.add( this.containers );\n\t\t\t\t}\n\t\t\t\tthis.showErrors();\n\n\t\t\t\t// Add aria-invalid status for screen readers\n\t\t\t\t$( element ).attr( \"aria-invalid\", !rs );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.showErrors/\n\t\tshowErrors: function( errors ) {\n\t\t\tif ( errors ) {\n\t\t\t\tvar validator = this;\n\n\t\t\t\t// Add items to error list and map\n\t\t\t\t$.extend( this.errorMap, errors );\n\t\t\t\tthis.errorList = $.map( this.errorMap, function( message, name ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessage: message,\n\t\t\t\t\t\telement: validator.findByName( name )[ 0 ]\n\t\t\t\t\t};\n\t\t\t\t} );\n\n\t\t\t\t// Remove items from success list\n\t\t\t\tthis.successList = $.grep( this.successList, function( element ) {\n\t\t\t\t\treturn !( element.name in errors );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( this.settings.showErrors ) {\n\t\t\t\tthis.settings.showErrors.call( this, this.errorMap, this.errorList );\n\t\t\t} else {\n\t\t\t\tthis.defaultShowErrors();\n\t\t\t}\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.resetForm/\n\t\tresetForm: function() {\n\t\t\tif ( $.fn.resetForm ) {\n\t\t\t\t$( this.currentForm ).resetForm();\n\t\t\t}\n\t\t\tthis.invalid = {};\n\t\t\tthis.submitted = {};\n\t\t\tthis.prepareForm();\n\t\t\tthis.hideErrors();\n\t\t\tvar elements = this.elements()\n\t\t\t\t.removeData( \"previousValue\" )\n\t\t\t\t.removeAttr( \"aria-invalid\" );\n\n\t\t\tthis.resetElements( elements );\n\t\t},\n\n\t\tresetElements: function( elements ) {\n\t\t\tvar i;\n\n\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\tfor ( i = 0; elements[ i ]; i++ ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, elements[ i ],\n\t\t\t\t\t\tthis.settings.errorClass, \"\" );\n\t\t\t\t\tthis.findByName( elements[ i ].name ).removeClass( this.settings.validClass );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements\n\t\t\t\t\t.removeClass( this.settings.errorClass )\n\t\t\t\t\t.removeClass( this.settings.validClass );\n\t\t\t}\n\t\t},\n\n\t\tnumberOfInvalids: function() {\n\t\t\treturn this.objectLength( this.invalid );\n\t\t},\n\n\t\tobjectLength: function( obj ) {\n\t\t\t/* jshint unused: false */\n\t\t\tvar count = 0,\n\t\t\t\ti;\n\t\t\tfor ( i in obj ) {\n\n\t\t\t\t// This check allows counting elements with empty error\n\t\t\t\t// message as invalid elements\n\t\t\t\tif ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\thideErrors: function() {\n\t\t\tthis.hideThese( this.toHide );\n\t\t},\n\n\t\thideThese: function( errors ) {\n\t\t\terrors.not( this.containers ).text( \"\" );\n\t\t\tthis.addWrapper( errors ).hide();\n\t\t},\n\n\t\tvalid: function() {\n\t\t\treturn this.size() === 0;\n\t\t},\n\n\t\tsize: function() {\n\t\t\treturn this.errorList.length;\n\t\t},\n\n\t\tfocusInvalid: function() {\n\t\t\tif ( this.settings.focusInvalid ) {\n\t\t\t\ttry {\n\t\t\t\t\t$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )\n\t\t\t\t\t.filter( \":visible\" )\n\t\t\t\t\t.trigger( \"focus\" )\n\n\t\t\t\t\t// Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find\n\t\t\t\t\t.trigger( \"focusin\" );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// Ignore IE throwing errors when focusing hidden elements\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tfindLastActive: function() {\n\t\t\tvar lastActive = this.lastActive;\n\t\t\treturn lastActive && $.grep( this.errorList, function( n ) {\n\t\t\t\treturn n.element.name === lastActive.name;\n\t\t\t} ).length === 1 && lastActive;\n\t\t},\n\n\t\telements: function() {\n\t\t\tvar validator = this,\n\t\t\t\trulesCache = {};\n\n\t\t\t// Select all valid inputs inside the form (no submit or reset buttons)\n\t\t\treturn $( this.currentForm )\n\t\t\t.find( \"input, select, textarea, [contenteditable]\" )\n\t\t\t.not( \":submit, :reset, :image, :disabled\" )\n\t\t\t.not( this.settings.ignore )\n\t\t\t.filter( function() {\n\t\t\t\tvar name = this.name || $( this ).attr( \"name\" ); // For contenteditable\n\t\t\t\tvar isContentEditable = typeof $( this ).attr( \"contenteditable\" ) !== \"undefined\" && $( this ).attr( \"contenteditable\" ) !== \"false\";\n\n\t\t\t\tif ( !name && validator.settings.debug && window.console ) {\n\t\t\t\t\tconsole.error( \"%o has no name assigned\", this );\n\t\t\t\t}\n\n\t\t\t\t// Set form expando on contenteditable\n\t\t\t\tif ( isContentEditable ) {\n\t\t\t\t\tthis.form = $( this ).closest( \"form\" )[ 0 ];\n\t\t\t\t\tthis.name = name;\n\t\t\t\t}\n\n\t\t\t\t// Ignore elements that belong to other/nested forms\n\t\t\t\tif ( this.form !== validator.currentForm ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Select only the first element for each name, and only those with rules specified\n\t\t\t\tif ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\trulesCache[ name ] = true;\n\t\t\t\treturn true;\n\t\t\t} );\n\t\t},\n\n\t\tclean: function( selector ) {\n\t\t\treturn $( selector )[ 0 ];\n\t\t},\n\n\t\terrors: function() {\n\t\t\tvar errorClass = this.settings.errorClass.split( \" \" ).join( \".\" );\n\t\t\treturn $( this.settings.errorElement + \".\" + errorClass, this.errorContext );\n\t\t},\n\n\t\tresetInternals: function() {\n\t\t\tthis.successList = [];\n\t\t\tthis.errorList = [];\n\t\t\tthis.errorMap = {};\n\t\t\tthis.toShow = $( [] );\n\t\t\tthis.toHide = $( [] );\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.resetInternals();\n\t\t\tthis.currentElements = $( [] );\n\t\t},\n\n\t\tprepareForm: function() {\n\t\t\tthis.reset();\n\t\t\tthis.toHide = this.errors().add( this.containers );\n\t\t},\n\n\t\tprepareElement: function( element ) {\n\t\t\tthis.reset();\n\t\t\tthis.toHide = this.errorsFor( element );\n\t\t},\n\n\t\telementValue: function( element ) {\n\t\t\tvar $element = $( element ),\n\t\t\t\ttype = element.type,\n\t\t\t\tisContentEditable = typeof $element.attr( \"contenteditable\" ) !== \"undefined\" && $element.attr( \"contenteditable\" ) !== \"false\",\n\t\t\t\tval, idx;\n\n\t\t\tif ( type === \"radio\" || type === \"checkbox\" ) {\n\t\t\t\treturn this.findByName( element.name ).filter( \":checked\" ).val();\n\t\t\t} else if ( type === \"number\" && typeof element.validity !== \"undefined\" ) {\n\t\t\t\treturn element.validity.badInput ? \"NaN\" : $element.val();\n\t\t\t}\n\n\t\t\tif ( isContentEditable ) {\n\t\t\t\tval = $element.text();\n\t\t\t} else {\n\t\t\t\tval = $element.val();\n\t\t\t}\n\n\t\t\tif ( type === \"file\" ) {\n\n\t\t\t\t// Modern browser (chrome & safari)\n\t\t\t\tif ( val.substr( 0, 12 ) === \"C:\\\\fakepath\\\\\" ) {\n\t\t\t\t\treturn val.substr( 12 );\n\t\t\t\t}\n\n\t\t\t\t// Legacy browsers\n\t\t\t\t// Unix-based path\n\t\t\t\tidx = val.lastIndexOf( \"/\" );\n\t\t\t\tif ( idx >= 0 ) {\n\t\t\t\t\treturn val.substr( idx + 1 );\n\t\t\t\t}\n\n\t\t\t\t// Windows-based path\n\t\t\t\tidx = val.lastIndexOf( \"\\\\\" );\n\t\t\t\tif ( idx >= 0 ) {\n\t\t\t\t\treturn val.substr( idx + 1 );\n\t\t\t\t}\n\n\t\t\t\t// Just the file name\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\tif ( typeof val === \"string\" ) {\n\t\t\t\treturn val.replace( /\\r/g, \"\" );\n\t\t\t}\n\t\t\treturn val;\n\t\t},\n\n\t\tcheck: function( element ) {\n\t\t\telement = this.validationTargetFor( this.clean( element ) );\n\n\t\t\tvar rules = $( element ).rules(),\n\t\t\t\trulesCount = $.map( rules, function( n, i ) {\n\t\t\t\t\treturn i;\n\t\t\t\t} ).length,\n\t\t\t\tdependencyMismatch = false,\n\t\t\t\tval = this.elementValue( element ),\n\t\t\t\tresult, method, rule, normalizer;\n\n\t\t\t// Prioritize the local normalizer defined for this element over the global one\n\t\t\t// if the former exists, otherwise user the global one in case it exists.\n\t\t\tif ( typeof rules.normalizer === \"function\" ) {\n\t\t\t\tnormalizer = rules.normalizer;\n\t\t\t} else if (\ttypeof this.settings.normalizer === \"function\" ) {\n\t\t\t\tnormalizer = this.settings.normalizer;\n\t\t\t}\n\n\t\t\t// If normalizer is defined, then call it to retreive the changed value instead\n\t\t\t// of using the real one.\n\t\t\t// Note that `this` in the normalizer is `element`.\n\t\t\tif ( normalizer ) {\n\t\t\t\tval = normalizer.call( element, val );\n\n\t\t\t\t// Delete the normalizer from rules to avoid treating it as a pre-defined method.\n\t\t\t\tdelete rules.normalizer;\n\t\t\t}\n\n\t\t\tfor ( method in rules ) {\n\t\t\t\trule = { method: method, parameters: rules[ method ] };\n\t\t\t\ttry {\n\t\t\t\t\tresult = $.validator.methods[ method ].call( this, val, element, rule.parameters );\n\n\t\t\t\t\t// If a method indicates that the field is optional and therefore valid,\n\t\t\t\t\t// don't mark it as valid when there are no other rules\n\t\t\t\t\tif ( result === \"dependency-mismatch\" && rulesCount === 1 ) {\n\t\t\t\t\t\tdependencyMismatch = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdependencyMismatch = false;\n\n\t\t\t\t\tif ( result === \"pending\" ) {\n\t\t\t\t\t\tthis.toHide = this.toHide.not( this.errorsFor( element ) );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !result ) {\n\t\t\t\t\t\tthis.formatAndAdd( element, rule );\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tif ( this.settings.debug && window.console ) {\n\t\t\t\t\t\tconsole.log( \"Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\", e );\n\t\t\t\t\t}\n\t\t\t\t\tif ( e instanceof TypeError ) {\n\t\t\t\t\t\te.message += \".  Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\";\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( dependencyMismatch ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( this.objectLength( rules ) ) {\n\t\t\t\tthis.successList.push( element );\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t// Return the custom message for the given element and validation method\n\t\t// specified in the element's HTML5 data attribute\n\t\t// return the generic message if present and no method specific message is present\n\t\tcustomDataMessage: function( element, method ) {\n\t\t\treturn $( element ).data( \"msg\" + method.charAt( 0 ).toUpperCase() +\n\t\t\t\tmethod.substring( 1 ).toLowerCase() ) || $( element ).data( \"msg\" );\n\t\t},\n\n\t\t// Return the custom message for the given element name and validation method\n\t\tcustomMessage: function( name, method ) {\n\t\t\tvar m = this.settings.messages[ name ];\n\t\t\treturn m && ( m.constructor === String ? m : m[ method ] );\n\t\t},\n\n\t\t// Return the first defined argument, allowing empty strings\n\t\tfindDefined: function() {\n\t\t\tfor ( var i = 0; i < arguments.length; i++ ) {\n\t\t\t\tif ( arguments[ i ] !== undefined ) {\n\t\t\t\t\treturn arguments[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\n\t\t// The second parameter 'rule' used to be a string, and extended to an object literal\n\t\t// of the following form:\n\t\t// rule = {\n\t\t//     method: \"method name\",\n\t\t//     parameters: \"the given method parameters\"\n\t\t// }\n\t\t//\n\t\t// The old behavior still supported, kept to maintain backward compatibility with\n\t\t// old code, and will be removed in the next major release.\n\t\tdefaultMessage: function( element, rule ) {\n\t\t\tif ( typeof rule === \"string\" ) {\n\t\t\t\trule = { method: rule };\n\t\t\t}\n\n\t\t\tvar message = this.findDefined(\n\t\t\t\t\tthis.customMessage( element.name, rule.method ),\n\t\t\t\t\tthis.customDataMessage( element, rule.method ),\n\n\t\t\t\t\t// 'title' is never undefined, so handle empty string as undefined\n\t\t\t\t\t!this.settings.ignoreTitle && element.title || undefined,\n\t\t\t\t\t$.validator.messages[ rule.method ],\n\t\t\t\t\t\"<strong>Warning: No message defined for \" + element.name + \"</strong>\"\n\t\t\t\t),\n\t\t\t\ttheregex = /\\$?\\{(\\d+)\\}/g;\n\t\t\tif ( typeof message === \"function\" ) {\n\t\t\t\tmessage = message.call( this, rule.parameters, element );\n\t\t\t} else if ( theregex.test( message ) ) {\n\t\t\t\tmessage = $.validator.format( message.replace( theregex, \"{$1}\" ), rule.parameters );\n\t\t\t}\n\n\t\t\treturn message;\n\t\t},\n\n\t\tformatAndAdd: function( element, rule ) {\n\t\t\tvar message = this.defaultMessage( element, rule );\n\n\t\t\tthis.errorList.push( {\n\t\t\t\tmessage: message,\n\t\t\t\telement: element,\n\t\t\t\tmethod: rule.method\n\t\t\t} );\n\n\t\t\tthis.errorMap[ element.name ] = message;\n\t\t\tthis.submitted[ element.name ] = message;\n\t\t},\n\n\t\taddWrapper: function( toToggle ) {\n\t\t\tif ( this.settings.wrapper ) {\n\t\t\t\ttoToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );\n\t\t\t}\n\t\t\treturn toToggle;\n\t\t},\n\n\t\tdefaultShowErrors: function() {\n\t\t\tvar i, elements, error;\n\t\t\tfor ( i = 0; this.errorList[ i ]; i++ ) {\n\t\t\t\terror = this.errorList[ i ];\n\t\t\t\tif ( this.settings.highlight ) {\n\t\t\t\t\tthis.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t\tthis.showLabel( error.element, error.message );\n\t\t\t}\n\t\t\tif ( this.errorList.length ) {\n\t\t\t\tthis.toShow = this.toShow.add( this.containers );\n\t\t\t}\n\t\t\tif ( this.settings.success ) {\n\t\t\t\tfor ( i = 0; this.successList[ i ]; i++ ) {\n\t\t\t\t\tthis.showLabel( this.successList[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\tfor ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.toHide = this.toHide.not( this.toShow );\n\t\t\tthis.hideErrors();\n\t\t\tthis.addWrapper( this.toShow ).show();\n\t\t},\n\n\t\tvalidElements: function() {\n\t\t\treturn this.currentElements.not( this.invalidElements() );\n\t\t},\n\n\t\tinvalidElements: function() {\n\t\t\treturn $( this.errorList ).map( function() {\n\t\t\t\treturn this.element;\n\t\t\t} );\n\t\t},\n\n\t\tshowLabel: function( element, message ) {\n\t\t\tvar place, group, errorID, v,\n\t\t\t\terror = this.errorsFor( element ),\n\t\t\t\telementID = this.idOrName( element ),\n\t\t\t\tdescribedBy = $( element ).attr( \"aria-describedby\" );\n\n\t\t\tif ( error.length ) {\n\n\t\t\t\t// Refresh error/success class\n\t\t\t\terror.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );\n\n\t\t\t\t// Replace message on existing label\n\t\t\t\terror.html( message );\n\t\t\t} else {\n\n\t\t\t\t// Create error element\n\t\t\t\terror = $( \"<\" + this.settings.errorElement + \">\" )\n\t\t\t\t\t.attr( \"id\", elementID + \"-error\" )\n\t\t\t\t\t.addClass( this.settings.errorClass )\n\t\t\t\t\t.html( message || \"\" );\n\n\t\t\t\t// Maintain reference to the element to be placed into the DOM\n\t\t\t\tplace = error;\n\t\t\t\tif ( this.settings.wrapper ) {\n\n\t\t\t\t\t// Make sure the element is visible, even in IE\n\t\t\t\t\t// actually showing the wrapped element is handled elsewhere\n\t\t\t\t\tplace = error.hide().show().wrap( \"<\" + this.settings.wrapper + \"/>\" ).parent();\n\t\t\t\t}\n\t\t\t\tif ( this.labelContainer.length ) {\n\t\t\t\t\tthis.labelContainer.append( place );\n\t\t\t\t} else if ( this.settings.errorPlacement ) {\n\t\t\t\t\tthis.settings.errorPlacement.call( this, place, $( element ) );\n\t\t\t\t} else {\n\t\t\t\t\tplace.insertAfter( element );\n\t\t\t\t}\n\n\t\t\t\t// Link error back to the element\n\t\t\t\tif ( error.is( \"label\" ) ) {\n\n\t\t\t\t\t// If the error is a label, then associate using 'for'\n\t\t\t\t\terror.attr( \"for\", elementID );\n\n\t\t\t\t\t// If the element is not a child of an associated label, then it's necessary\n\t\t\t\t\t// to explicitly apply aria-describedby\n\t\t\t\t} else if ( error.parents( \"label[for='\" + this.escapeCssMeta( elementID ) + \"']\" ).length === 0 ) {\n\t\t\t\t\terrorID = error.attr( \"id\" );\n\n\t\t\t\t\t// Respect existing non-error aria-describedby\n\t\t\t\t\tif ( !describedBy ) {\n\t\t\t\t\t\tdescribedBy = errorID;\n\t\t\t\t\t} else if ( !describedBy.match( new RegExp( \"\\\\b\" + this.escapeCssMeta( errorID ) + \"\\\\b\" ) ) ) {\n\n\t\t\t\t\t\t// Add to end of list if not already present\n\t\t\t\t\t\tdescribedBy += \" \" + errorID;\n\t\t\t\t\t}\n\t\t\t\t\t$( element ).attr( \"aria-describedby\", describedBy );\n\n\t\t\t\t\t// If this element is grouped, then assign to all elements in the same group\n\t\t\t\t\tgroup = this.groups[ element.name ];\n\t\t\t\t\tif ( group ) {\n\t\t\t\t\t\tv = this;\n\t\t\t\t\t\t$.each( v.groups, function( name, testgroup ) {\n\t\t\t\t\t\t\tif ( testgroup === group ) {\n\t\t\t\t\t\t\t\t$( \"[name='\" + v.escapeCssMeta( name ) + \"']\", v.currentForm )\n\t\t\t\t\t\t\t\t\t.attr( \"aria-describedby\", error.attr( \"id\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !message && this.settings.success ) {\n\t\t\t\terror.text( \"\" );\n\t\t\t\tif ( typeof this.settings.success === \"string\" ) {\n\t\t\t\t\terror.addClass( this.settings.success );\n\t\t\t\t} else {\n\t\t\t\t\tthis.settings.success( error, element );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.toShow = this.toShow.add( error );\n\t\t},\n\n\t\terrorsFor: function( element ) {\n\t\t\tvar name = this.escapeCssMeta( this.idOrName( element ) ),\n\t\t\t\tdescriber = $( element ).attr( \"aria-describedby\" ),\n\t\t\t\tselector = \"label[for='\" + name + \"'], label[for='\" + name + \"'] *\";\n\n\t\t\t// 'aria-describedby' should directly reference the error element\n\t\t\tif ( describer ) {\n\t\t\t\tselector = selector + \", #\" + this.escapeCssMeta( describer )\n\t\t\t\t\t.replace( /\\s+/g, \", #\" );\n\t\t\t}\n\n\t\t\treturn this\n\t\t\t\t.errors()\n\t\t\t\t.filter( selector );\n\t\t},\n\n\t\t// See https://api.jquery.com/category/selectors/, for CSS\n\t\t// meta-characters that should be escaped in order to be used with JQuery\n\t\t// as a literal part of a name/id or any selector.\n\t\tescapeCssMeta: function( string ) {\n\t\t\tif ( string === undefined ) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn string.replace( /([\\\\!\"#$%&'()*+,./:;<=>?@\\[\\]^`{|}~])/g, \"\\\\$1\" );\n\t\t},\n\n\t\tidOrName: function( element ) {\n\t\t\treturn this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );\n\t\t},\n\n\t\tvalidationTargetFor: function( element ) {\n\n\t\t\t// If radio/checkbox, validate first element in group instead\n\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\telement = this.findByName( element.name );\n\t\t\t}\n\n\t\t\t// Always apply ignore filter\n\t\t\treturn $( element ).not( this.settings.ignore )[ 0 ];\n\t\t},\n\n\t\tcheckable: function( element ) {\n\t\t\treturn ( /radio|checkbox/i ).test( element.type );\n\t\t},\n\n\t\tfindByName: function( name ) {\n\t\t\treturn $( this.currentForm ).find( \"[name='\" + this.escapeCssMeta( name ) + \"']\" );\n\t\t},\n\n\t\tgetLength: function( value, element ) {\n\t\t\tswitch ( element.nodeName.toLowerCase() ) {\n\t\t\tcase \"select\":\n\t\t\t\treturn $( \"option:selected\", element ).length;\n\t\t\tcase \"input\":\n\t\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\t\treturn this.findByName( element.name ).filter( \":checked\" ).length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value.length;\n\t\t},\n\n\t\tdepend: function( param, element ) {\n\t\t\treturn this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;\n\t\t},\n\n\t\tdependTypes: {\n\t\t\t\"boolean\": function( param ) {\n\t\t\t\treturn param;\n\t\t\t},\n\t\t\t\"string\": function( param, element ) {\n\t\t\t\treturn !!$( param, element.form ).length;\n\t\t\t},\n\t\t\t\"function\": function( param, element ) {\n\t\t\t\treturn param( element );\n\t\t\t}\n\t\t},\n\n\t\toptional: function( element ) {\n\t\t\tvar val = this.elementValue( element );\n\t\t\treturn !$.validator.methods.required.call( this, val, element ) && \"dependency-mismatch\";\n\t\t},\n\n\t\tstartRequest: function( element ) {\n\t\t\tif ( !this.pending[ element.name ] ) {\n\t\t\t\tthis.pendingRequest++;\n\t\t\t\t$( element ).addClass( this.settings.pendingClass );\n\t\t\t\tthis.pending[ element.name ] = true;\n\t\t\t}\n\t\t},\n\n\t\tstopRequest: function( element, valid ) {\n\t\t\tthis.pendingRequest--;\n\n\t\t\t// Sometimes synchronization fails, make sure pendingRequest is never < 0\n\t\t\tif ( this.pendingRequest < 0 ) {\n\t\t\t\tthis.pendingRequest = 0;\n\t\t\t}\n\t\t\tdelete this.pending[ element.name ];\n\t\t\t$( element ).removeClass( this.settings.pendingClass );\n\t\t\tif ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() && this.pendingRequest === 0 ) {\n\t\t\t\t$( this.currentForm ).trigger( \"submit\" );\n\n\t\t\t\t// Remove the hidden input that was used as a replacement for the\n\t\t\t\t// missing submit button. The hidden input is added by `handle()`\n\t\t\t\t// to ensure that the value of the used submit button is passed on\n\t\t\t\t// for scripted submits triggered by this method\n\t\t\t\tif ( this.submitButton ) {\n\t\t\t\t\t$( \"input:hidden[name='\" + this.submitButton.name + \"']\", this.currentForm ).remove();\n\t\t\t\t}\n\n\t\t\t\tthis.formSubmitted = false;\n\t\t\t} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {\n\t\t\t\t$( this.currentForm ).triggerHandler( \"invalid-form\", [ this ] );\n\t\t\t\tthis.formSubmitted = false;\n\t\t\t}\n\t\t},\n\n\t\tpreviousValue: function( element, method ) {\n\t\t\tmethod = typeof method === \"string\" && method || \"remote\";\n\n\t\t\treturn $.data( element, \"previousValue\" ) || $.data( element, \"previousValue\", {\n\t\t\t\told: null,\n\t\t\t\tvalid: true,\n\t\t\t\tmessage: this.defaultMessage( element, { method: method } )\n\t\t\t} );\n\t\t},\n\n\t\t// Cleans up all forms and elements, removes validator-specific events\n\t\tdestroy: function() {\n\t\t\tthis.resetForm();\n\n\t\t\t$( this.currentForm )\n\t\t\t\t.off( \".validate\" )\n\t\t\t\t.removeData( \"validator\" )\n\t\t\t\t.find( \".validate-equalTo-blur\" )\n\t\t\t\t\t.off( \".validate-equalTo\" )\n\t\t\t\t\t.removeClass( \"validate-equalTo-blur\" )\n\t\t\t\t.find( \".validate-lessThan-blur\" )\n\t\t\t\t\t.off( \".validate-lessThan\" )\n\t\t\t\t\t.removeClass( \"validate-lessThan-blur\" )\n\t\t\t\t.find( \".validate-lessThanEqual-blur\" )\n\t\t\t\t\t.off( \".validate-lessThanEqual\" )\n\t\t\t\t\t.removeClass( \"validate-lessThanEqual-blur\" )\n\t\t\t\t.find( \".validate-greaterThanEqual-blur\" )\n\t\t\t\t\t.off( \".validate-greaterThanEqual\" )\n\t\t\t\t\t.removeClass( \"validate-greaterThanEqual-blur\" )\n\t\t\t\t.find( \".validate-greaterThan-blur\" )\n\t\t\t\t\t.off( \".validate-greaterThan\" )\n\t\t\t\t\t.removeClass( \"validate-greaterThan-blur\" );\n\t\t}\n\n\t},\n\n\tclassRuleSettings: {\n\t\trequired: { required: true },\n\t\temail: { email: true },\n\t\turl: { url: true },\n\t\tdate: { date: true },\n\t\tdateISO: { dateISO: true },\n\t\tnumber: { number: true },\n\t\tdigits: { digits: true },\n\t\tcreditcard: { creditcard: true }\n\t},\n\n\taddClassRules: function( className, rules ) {\n\t\tif ( className.constructor === String ) {\n\t\t\tthis.classRuleSettings[ className ] = rules;\n\t\t} else {\n\t\t\t$.extend( this.classRuleSettings, className );\n\t\t}\n\t},\n\n\tclassRules: function( element ) {\n\t\tvar rules = {},\n\t\t\tclasses = $( element ).attr( \"class\" );\n\n\t\tif ( classes ) {\n\t\t\t$.each( classes.split( \" \" ), function() {\n\t\t\t\tif ( this in $.validator.classRuleSettings ) {\n\t\t\t\t\t$.extend( rules, $.validator.classRuleSettings[ this ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\treturn rules;\n\t},\n\n\tnormalizeAttributeRule: function( rules, type, method, value ) {\n\n\t\t// Convert the value to a number for number inputs, and for text for backwards compability\n\t\t// allows type=\"date\" and others to be compared as strings\n\t\tif ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {\n\t\t\tvalue = Number( value );\n\n\t\t\t// Support Opera Mini, which returns NaN for undefined minlength\n\t\t\tif ( isNaN( value ) ) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif ( value || value === 0 ) {\n\t\t\trules[ method ] = value;\n\t\t} else if ( type === method && type !== \"range\" ) {\n\n\t\t\t// Exception: the jquery validate 'range' method\n\t\t\t// does not test for the html5 'range' type\n\t\t\trules[ type === \"date\" ? \"dateISO\" : method ] = true;\n\t\t}\n\t},\n\n\tattributeRules: function( element ) {\n\t\tvar rules = {},\n\t\t\t$element = $( element ),\n\t\t\ttype = element.getAttribute( \"type\" ),\n\t\t\tmethod, value;\n\n\t\tfor ( method in $.validator.methods ) {\n\n\t\t\t// Support for <input required> in both html5 and older browsers\n\t\t\tif ( method === \"required\" ) {\n\t\t\t\tvalue = element.getAttribute( method );\n\n\t\t\t\t// Some browsers return an empty string for the required attribute\n\t\t\t\t// and non-HTML5 browsers might have required=\"\" markup\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\tvalue = true;\n\t\t\t\t}\n\n\t\t\t\t// Force non-HTML5 browsers to return bool\n\t\t\t\tvalue = !!value;\n\t\t\t} else {\n\t\t\t\tvalue = $element.attr( method );\n\t\t\t}\n\n\t\t\tthis.normalizeAttributeRule( rules, type, method, value );\n\t\t}\n\n\t\t// 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs\n\t\tif ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {\n\t\t\tdelete rules.maxlength;\n\t\t}\n\n\t\treturn rules;\n\t},\n\n\tdataRules: function( element ) {\n\t\tvar rules = {},\n\t\t\t$element = $( element ),\n\t\t\ttype = element.getAttribute( \"type\" ),\n\t\t\tmethod, value;\n\n\t\tfor ( method in $.validator.methods ) {\n\t\t\tvalue = $element.data( \"rule\" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );\n\n\t\t\t// Cast empty attributes like `data-rule-required` to `true`\n\t\t\tif ( value === \"\" ) {\n\t\t\t\tvalue = true;\n\t\t\t}\n\n\t\t\tthis.normalizeAttributeRule( rules, type, method, value );\n\t\t}\n\t\treturn rules;\n\t},\n\n\tstaticRules: function( element ) {\n\t\tvar rules = {},\n\t\t\tvalidator = $.data( element.form, \"validator\" );\n\n\t\tif ( validator.settings.rules ) {\n\t\t\trules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};\n\t\t}\n\t\treturn rules;\n\t},\n\n\tnormalizeRules: function( rules, element ) {\n\n\t\t// Handle dependency check\n\t\t$.each( rules, function( prop, val ) {\n\n\t\t\t// Ignore rule when param is explicitly false, eg. required:false\n\t\t\tif ( val === false ) {\n\t\t\t\tdelete rules[ prop ];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( val.param || val.depends ) {\n\t\t\t\tvar keepRule = true;\n\t\t\t\tswitch ( typeof val.depends ) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tkeepRule = !!$( val.depends, element.form ).length;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tkeepRule = val.depends.call( element, element );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( keepRule ) {\n\t\t\t\t\trules[ prop ] = val.param !== undefined ? val.param : true;\n\t\t\t\t} else {\n\t\t\t\t\t$.data( element.form, \"validator\" ).resetElements( $( element ) );\n\t\t\t\t\tdelete rules[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Evaluate parameters\n\t\t$.each( rules, function( rule, parameter ) {\n\t\t\trules[ rule ] = typeof parameter === \"function\" && rule !== \"normalizer\" ? parameter( element ) : parameter;\n\t\t} );\n\n\t\t// Clean number parameters\n\t\t$.each( [ \"minlength\", \"maxlength\" ], function() {\n\t\t\tif ( rules[ this ] ) {\n\t\t\t\trules[ this ] = Number( rules[ this ] );\n\t\t\t}\n\t\t} );\n\t\t$.each( [ \"rangelength\", \"range\" ], function() {\n\t\t\tvar parts;\n\t\t\tif ( rules[ this ] ) {\n\t\t\t\tif ( Array.isArray( rules[ this ] ) ) {\n\t\t\t\t\trules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];\n\t\t\t\t} else if ( typeof rules[ this ] === \"string\" ) {\n\t\t\t\t\tparts = rules[ this ].replace( /[\\[\\]]/g, \"\" ).split( /[\\s,]+/ );\n\t\t\t\t\trules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\tif ( $.validator.autoCreateRanges ) {\n\n\t\t\t// Auto-create ranges\n\t\t\tif ( rules.min != null && rules.max != null ) {\n\t\t\t\trules.range = [ rules.min, rules.max ];\n\t\t\t\tdelete rules.min;\n\t\t\t\tdelete rules.max;\n\t\t\t}\n\t\t\tif ( rules.minlength != null && rules.maxlength != null ) {\n\t\t\t\trules.rangelength = [ rules.minlength, rules.maxlength ];\n\t\t\t\tdelete rules.minlength;\n\t\t\t\tdelete rules.maxlength;\n\t\t\t}\n\t\t}\n\n\t\treturn rules;\n\t},\n\n\t// Converts a simple string to a {string: true} rule, e.g., \"required\" to {required:true}\n\tnormalizeRule: function( data ) {\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tvar transformed = {};\n\t\t\t$.each( data.split( /\\s/ ), function() {\n\t\t\t\ttransformed[ this ] = true;\n\t\t\t} );\n\t\t\tdata = transformed;\n\t\t}\n\t\treturn data;\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.addMethod/\n\taddMethod: function( name, method, message ) {\n\t\t$.validator.methods[ name ] = method;\n\t\t$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];\n\t\tif ( method.length < 3 ) {\n\t\t\t$.validator.addClassRules( name, $.validator.normalizeRule( name ) );\n\t\t}\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.methods/\n\tmethods: {\n\n\t\t// https://jqueryvalidation.org/required-method/\n\t\trequired: function( value, element, param ) {\n\n\t\t\t// Check if dependency is met\n\t\t\tif ( !this.depend( param, element ) ) {\n\t\t\t\treturn \"dependency-mismatch\";\n\t\t\t}\n\t\t\tif ( element.nodeName.toLowerCase() === \"select\" ) {\n\n\t\t\t\t// Could be an array for select-multiple or a string, both are fine this way\n\t\t\t\tvar val = $( element ).val();\n\t\t\t\treturn val && val.length > 0;\n\t\t\t}\n\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\treturn this.getLength( value, element ) > 0;\n\t\t\t}\n\t\t\treturn value !== undefined && value !== null && value.length > 0;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/email-method/\n\t\temail: function( value, element ) {\n\n\t\t\t// From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\n\t\t\t// Retrieved 2014-01-14\n\t\t\t// If you have a problem with this implementation, report a bug against the above spec\n\t\t\t// Or use custom methods to implement your own email validation\n\t\t\treturn this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/url-method/\n\t\turl: function( value, element ) {\n\n\t\t\t// Copyright (c) 2010-2013 Diego Perini, MIT licensed\n\t\t\t// https://gist.github.com/dperini/729294\n\t\t\t// see also https://mathiasbynens.be/demo/url-regex\n\t\t\t// modified to allow protocol-relative URLs\n\t\t\treturn this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/date-method/\n\t\tdate: ( function() {\n\t\t\tvar called = false;\n\n\t\t\treturn function( value, element ) {\n\t\t\t\tif ( !called ) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif ( this.settings.debug && window.console ) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"The `date` method is deprecated and will be removed in version '2.0.0'.\\n\" +\n\t\t\t\t\t\t\t\"Please don't use it, since it relies on the Date constructor, which\\n\" +\n\t\t\t\t\t\t\t\"behaves very differently across browsers and locales. Use `dateISO`\\n\" +\n\t\t\t\t\t\t\t\"instead or one of the locale specific methods in `localizations/`\\n\" +\n\t\t\t\t\t\t\t\"and `additional-methods.js`.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );\n\t\t\t};\n\t\t}() ),\n\n\t\t// https://jqueryvalidation.org/dateISO-method/\n\t\tdateISO: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/number-method/\n\t\tnumber: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^(?:-?\\d+|-?\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/digits-method/\n\t\tdigits: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^\\d+$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/minlength-method/\n\t\tminlength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || length >= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/maxlength-method/\n\t\tmaxlength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || length <= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/rangelength-method/\n\t\trangelength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/min-method/\n\t\tmin: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || value >= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/max-method/\n\t\tmax: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || value <= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/range-method/\n\t\trange: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/step-method/\n\t\tstep: function( value, element, param ) {\n\t\t\tvar type = $( element ).attr( \"type\" ),\n\t\t\t\terrorMessage = \"Step attribute on input type \" + type + \" is not supported.\",\n\t\t\t\tsupportedTypes = [ \"text\", \"number\", \"range\" ],\n\t\t\t\tre = new RegExp( \"\\\\b\" + type + \"\\\\b\" ),\n\t\t\t\tnotSupported = type && !re.test( supportedTypes.join() ),\n\t\t\t\tdecimalPlaces = function( num ) {\n\t\t\t\t\tvar match = ( \"\" + num ).match( /(?:\\.(\\d+))?$/ );\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Number of digits right of decimal point.\n\t\t\t\t\treturn match[ 1 ] ? match[ 1 ].length : 0;\n\t\t\t\t},\n\t\t\t\ttoInt = function( num ) {\n\t\t\t\t\treturn Math.round( num * Math.pow( 10, decimals ) );\n\t\t\t\t},\n\t\t\t\tvalid = true,\n\t\t\t\tdecimals;\n\n\t\t\t// Works only for text, number and range input types\n\t\t\t// TODO find a way to support input types date, datetime, datetime-local, month, time and week\n\t\t\tif ( notSupported ) {\n\t\t\t\tthrow new Error( errorMessage );\n\t\t\t}\n\n\t\t\tdecimals = decimalPlaces( param );\n\n\t\t\t// Value can't have too many decimals\n\t\t\tif ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\treturn this.optional( element ) || valid;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/equalTo-method/\n\t\tequalTo: function( value, element, param ) {\n\n\t\t\t// Bind to the blur event of the target in order to revalidate whenever the target field is updated\n\t\t\tvar target = $( param );\n\t\t\tif ( this.settings.onfocusout && target.not( \".validate-equalTo-blur\" ).length ) {\n\t\t\t\ttarget.addClass( \"validate-equalTo-blur\" ).on( \"blur.validate-equalTo\", function() {\n\t\t\t\t\t$( element ).valid();\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn value === target.val();\n\t\t},\n\n\t\t// https://jqueryvalidation.org/remote-method/\n\t\tremote: function( value, element, param, method ) {\n\t\t\tif ( this.optional( element ) ) {\n\t\t\t\treturn \"dependency-mismatch\";\n\t\t\t}\n\n\t\t\tmethod = typeof method === \"string\" && method || \"remote\";\n\n\t\t\tvar previous = this.previousValue( element, method ),\n\t\t\t\tvalidator, data, optionDataString;\n\n\t\t\tif ( !this.settings.messages[ element.name ] ) {\n\t\t\t\tthis.settings.messages[ element.name ] = {};\n\t\t\t}\n\t\t\tprevious.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];\n\t\t\tthis.settings.messages[ element.name ][ method ] = previous.message;\n\n\t\t\tparam = typeof param === \"string\" && { url: param } || param;\n\t\t\toptionDataString = $.param( $.extend( { data: value }, param.data ) );\n\t\t\tif ( previous.old === optionDataString ) {\n\t\t\t\treturn previous.valid;\n\t\t\t}\n\n\t\t\tprevious.old = optionDataString;\n\t\t\tvalidator = this;\n\t\t\tthis.startRequest( element );\n\t\t\tdata = {};\n\t\t\tdata[ element.name ] = value;\n\t\t\t$.ajax( $.extend( true, {\n\t\t\t\tmode: \"abort\",\n\t\t\t\tport: \"validate\" + element.name,\n\t\t\t\tdataType: \"json\",\n\t\t\t\tdata: data,\n\t\t\t\tcontext: validator.currentForm,\n\t\t\t\tsuccess: function( response ) {\n\t\t\t\t\tvar valid = response === true || response === \"true\",\n\t\t\t\t\t\terrors, message, submitted;\n\n\t\t\t\t\tvalidator.settings.messages[ element.name ][ method ] = previous.originalMessage;\n\t\t\t\t\tif ( valid ) {\n\t\t\t\t\t\tsubmitted = validator.formSubmitted;\n\t\t\t\t\t\tvalidator.resetInternals();\n\t\t\t\t\t\tvalidator.toHide = validator.errorsFor( element );\n\t\t\t\t\t\tvalidator.formSubmitted = submitted;\n\t\t\t\t\t\tvalidator.successList.push( element );\n\t\t\t\t\t\tvalidator.invalid[ element.name ] = false;\n\t\t\t\t\t\tvalidator.showErrors();\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors = {};\n\t\t\t\t\t\tmessage = response || validator.defaultMessage( element, { method: method, parameters: value } );\n\t\t\t\t\t\terrors[ element.name ] = previous.message = message;\n\t\t\t\t\t\tvalidator.invalid[ element.name ] = true;\n\t\t\t\t\t\tvalidator.showErrors( errors );\n\t\t\t\t\t}\n\t\t\t\t\tprevious.valid = valid;\n\t\t\t\t\tvalidator.stopRequest( element, valid );\n\t\t\t\t}\n\t\t\t}, param ) );\n\t\t\treturn \"pending\";\n\t\t}\n\t}\n\n} );\n", "function methodTest( methodName ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods[ methodName ],\n\t\telement = $( \"#firstname\" )[ 0 ];\n\n\treturn function( value, param ) {\n\t\telement.value = value;\n\t\treturn method.call( v, value, element, param );\n\t};\n}\n\n/**\n * Creates a dummy DOM file input with FileList\n * @param filename\n * @param mimeType\n * @returns {{}}\n */\nfunction acceptFileDummyInput( filename, mimeType ) {\n\n\tfunction dummy() {\n\t\treturn file;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/FileList\n\tvar file = {\n\t\t\tname: filename,\n\t\t\tsize: 500001,\n\t\t\ttype: mimeType\n\t\t},\n\t\tfileList = {\n\t\t\t0: file,\n\t\t\tlength: 1,\n\t\t\titem: dummy\n\t\t};\n\n\treturn {\n\t\ttype: \"file\",\n\t\tfiles: fileList,\n\t\tnodeName: \"INPUT\",\n\t\tvalue: \"/tmp/fake_value\",\n\t\thasAttribute: function() { return false; }\n\t};\n}\n\nfunction fileDummyInput( selectedFiles ) {\n\tvar aFiles = [],\n\t\toFiles;\n\n\tfor ( var i = 0; i < selectedFiles.length; i++ ) {\n\t\taFiles.push( {\n\t\t\tname: selectedFiles[ i ].name,\n\t\t\tsize: selectedFiles[ i ].size,\n\t\t\ttype: \"image/jpeg\"\n\t\t} );\n\t}\n\n\t//Convert the array of objects to an object.\n\toFiles = aFiles.reduce( function( acc, cur, i ) {\n\t\tacc[ i ] = cur;\n\t\treturn acc;\n\t}, {} );\n\n\t//Add the \"length\" property to the object.\n\toFiles.length = selectedFiles.length;\n\n\t//Add the \"item()\" method to the object.\n\toFiles.item = function( i ) { return aFiles[ i ]; };\n\n\treturn {\n\t\ttype: \"file\",\n\t\tfiles: oFiles,\n\t\tnodeName: \"INPUT\",\n\t\tvalue: \"/tmp/fake_value\",\n\t\thasAttribute: function() { return false; }\n\t};\n}\n\nQUnit.module( \"methods\" );\n\nQUnit.test( \"default messages\", function( assert ) {\n\tvar m = $.validator.methods;\n\t$.each( m, function( key ) {\n\t\tassert.ok( jQuery.validator.messages[ key ], key + \" has a default message.\" );\n\t} );\n} );\n\nQUnit.test( \"digit\", function( assert ) {\n\tvar method = methodTest( \"digits\" );\n\tassert.ok( method( \"123\" ), \"Valid digits\" );\n\tassert.ok( !method( \"123.000\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"123.000,00\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"123.0.0,0\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"x123\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"100.100,0,0\" ), \"Invalid digits\" );\n} );\n\nQUnit.test( \"url\", function( assert ) {\n\tvar method = methodTest( \"url\" );\n\tassert.ok( method( \"http://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"https://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"ftp://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"http://www.f\u00f8tex.dk/\" ), \"Valid url, danish unicode characters\" );\n\tassert.ok( method( \"http://b\u00f6sendorfer.de/\" ), \"Valid url, german unicode characters\" );\n\tassert.ok( method( \"http://142.42.1.1\" ), \"Valid IP Address\" );\n\tassert.ok( method( \"http://pro.photography\" ), \"Valid long TLD\" );\n\tassert.ok( method( \"//code.jquery.com/jquery-1.11.3.min.js\" ), \"Valid protocol-relative url\" );\n\tassert.ok( method( \"//142.42.1.1\" ), \"Valid protocol-relative IP Address\" );\n\tassert.ok( !method( \"htp://code.jquery.com/jquery-1.11.3.min.js\" ), \"Invalid protocol\" );\n\tassert.ok( !method( \"http://192.168.8.\" ), \"Invalid IP Address\" );\n\tassert.ok( !method( \"http://bassistance\" ), \"Invalid url\" ); // Valid\n\tassert.ok( !method( \"http://bassistance.\" ), \"Invalid url\" ); // Valid\n\tassert.ok( !method( \"http://bassistance,de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://bassistance;de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://.bassistancede\" ), \"Invalid url\" );\n\tassert.ok( !method( \"bassistance.de\" ), \"Invalid url\" );\n} );\n\nQUnit.test( \"url2 (tld optional)\", function( assert ) {\n\tvar method = methodTest( \"url2\" );\n\tassert.ok( method( \"http://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"https://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"ftp://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"http://www.f\u00f8tex.dk/\" ), \"Valid url, danish unicode characters\" );\n\tassert.ok( method( \"http://b\u00f6sendorfer.de/\" ), \"Valid url, german unicode characters\" );\n\tassert.ok( method( \"http://142.42.1.1\" ), \"Valid IP Address\" );\n\tassert.ok( !method( \"http://192.168.8.\" ), \"Invalid IP Address\" );\n\tassert.ok( method( \"http://bassistance\" ), \"Invalid url\" );\n\tassert.ok( method( \"http://bassistance.\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://bassistance,de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://bassistance;de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://.bassistancede\" ), \"Invalid url\" );\n\tassert.ok( !method( \"bassistance.de\" ), \"Invalid url\" );\n} );\n\nQUnit.test( \"email\", function( assert ) {\n\tvar method = methodTest( \"email\" );\n\tassert.ok( method( \"name@domain.tld\" ), \"Valid email\" );\n\tassert.ok( method( \"name@domain.tl\" ), \"Valid email\" );\n\tassert.ok( method( \"bart+bart@tokbox.com\" ), \"Valid email\" );\n\tassert.ok( method( \"bart+bart@tokbox.travel\" ), \"Valid email\" );\n\tassert.ok( method( \"n@d.tld\" ), \"Valid email\" );\n\tassert.ok( method( \"bla.blu@g.mail.com\" ), \"Valid email\" );\n\tassert.ok( method( \"name@domain\" ), \"Valid email\" );\n\tassert.ok( method( \"name.@domain.tld\" ), \"Valid email\" );\n\tassert.ok( method( \"name@website.a\" ), \"Valid email\" );\n\tassert.ok( method( \"name@pro.photography\" ), \"Valid email\" );\n\tassert.ok( !method( \"ole@f\u00f8tex.dk\" ), \"Invalid email\" );\n\tassert.ok( !method( \"j\u00f6rn@bassistance.de\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name\" ), \"Invalid email\" );\n\tassert.ok( !method( \"test@test-.com\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name@\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name,@domain.tld\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name;@domain.tld\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name;@domain.tld.\" ), \"Invalid email\" );\n} );\n\nQUnit.test( \"number\", function( assert ) {\n\tvar method = methodTest( \"number\" );\n\tassert.ok( method( \"123\" ), \"Valid number\" );\n\tassert.ok( method( \"-123\" ), \"Valid number\" );\n\tassert.ok( method( \"123,000\" ), \"Valid number\" );\n\tassert.ok( method( \"-123,000\" ), \"Valid number\" );\n\tassert.ok( method( \"123,000.00\" ), \"Valid number\" );\n\tassert.ok( method( \"-123,000.00\" ), \"Valid number\" );\n\tassert.ok( !method( \"-\" ), \"Invalid number\" );\n\tassert.ok( !method( \"123.000,00\" ), \"Invalid number\" );\n\tassert.ok( !method( \"123.0.0,0\" ), \"Invalid number\" );\n\tassert.ok( !method( \"x123\" ), \"Invalid number\" );\n\tassert.ok( !method( \"100.100,0,0\" ), \"Invalid number\" );\n\n\tassert.ok( method( \"\" ), \"Blank is valid\" );\n\tassert.ok( method( \"123\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123000\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123000.12\" ), \"Valid decimal\" );\n\tassert.ok( method( \"-123000.12\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123.000\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123,000.00\" ), \"Valid decimal\" );\n\tassert.ok( method( \"-123,000.00\" ), \"Valid decimal\" );\n\tassert.ok( method( \".100\" ), \"Valid decimal\" );\n\tassert.ok( !method( \"1230,000.00\" ), \"Invalid decimal\" );\n\tassert.ok( !method( \"123.0.0,0\" ), \"Invalid decimal\" );\n\tassert.ok( !method( \"x123\" ), \"Invalid decimal\" );\n\tassert.ok( !method( \"100.100,0,0\" ), \"Invalid decimal\" );\n} );\n\n/* Disabled for now, need to figure out how to test localized methods\nQUnit.test(\"numberDE\", function( assert ) {\n\tvar method = methodTest(\"numberDE\");\n\tassert.ok( method( \"123\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"-123\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"123.000\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"-123.000\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"123.000,00\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"-123.000,00\" ), \"Valid numberDE\" );\n\tassert.ok(!method( \"123,000.00\" ), \"Invalid numberDE\" );\n\tassert.ok(!method( \"123,0,0.0\" ), \"Invalid numberDE\" );\n\tassert.ok(!method( \"x123\" ), \"Invalid numberDE\" );\n\tassert.ok(!method( \"100,100.0.0\" ), \"Invalid numberDE\" );\n\n\tassert.ok( method( \"\" ), \"Blank is valid\" );\n\tassert.ok( method( \"123\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123000\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123000,12\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"-123000,12\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123.000\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123.000,00\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"-123.000,00\" ), \"Valid decimalDE\" )\n\tassert.ok(!method( \"123.0.0,0\" ), \"Invalid decimalDE\" );\n\tassert.ok(!method( \"x123\" ), \"Invalid decimalDE\" );\n\tassert.ok(!method( \"100,100.0.0\" ), \"Invalid decimalDE\" );\n});\n*/\n\nQUnit.test( \"date\", function( assert ) {\n\tvar method = methodTest( \"date\" );\n\tassert.ok( method( \"06/06/1990\" ), \"Valid date\" );\n\tassert.ok( method( \"6/6/06\" ), \"Valid date\" );\n\tassert.ok( !method( \"1990x-06-06\" ), \"Invalid date\" );\n} );\n\nQUnit.test( \"dateISO\", function( assert ) {\n\tvar method = methodTest( \"dateISO\" );\n\tassert.ok( method( \"1990-06-06\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-01-01\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-01-31\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-12-01\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-12-31\" ), \"Valid date\" );\n\tassert.ok( method( \"1990/06/06\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-6-6\" ), \"Valid date\" );\n\tassert.ok( method( \"1990/6/6\" ), \"Valid date\" );\n\tassert.ok( !method( \"1990-106-06\" ), \"Invalid date\" );\n\tassert.ok( !method( \"190-06-06\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-00-06\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-13-01\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-01-00\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-01-32\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-13-32\" ), \"Invalid date\" );\n} );\n\n/* Disabled for now, need to figure out how to test localized methods\nQUnit.test(\"dateDE\", function( assert ) {\n\tvar method = methodTest(\"dateDE\");\n\tassert.ok( method( \"03.06.1984\" ), \"Valid dateDE\" );\n\tassert.ok( method( \"3.6.84\" ), \"Valid dateDE\" );\n\tassert.ok(!method( \"6-6-06\" ), \"Invalid dateDE\" );\n\tassert.ok(!method( \"1990-06-06\" ), \"Invalid dateDE\" );\n\tassert.ok(!method( \"06/06/1990\" ), \"Invalid dateDE\" );\n\tassert.ok(!method( \"6/6/06\" ), \"Invalid dateDE\" );\n});\n*/\n\nQUnit.test( \"required\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.required,\n\t\te = $( \"#text1, #text1b, #hidden2, #select1, #select2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ] ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ] ), \"Invalid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ] ), \"Invalid text input\" );\n\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ] ), \"Invalid select\" );\n\tassert.ok( method.call( v, e[ 4 ].value, e[ 4 ] ), \"Valid select\" );\n\n\te = $( \"#area1, #area2, #pw1, #pw2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ] ), \"Valid textarea\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ] ), \"Invalid textarea\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ] ), \"Valid password input\" );\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ] ), \"Invalid password input\" );\n\n\te = $( \"#radio1, #radio2, #radio3\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ] ), \"Invalid radio\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ] ), \"Valid radio\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ] ), \"Valid radio\" );\n\n\te = $( \"#check1, #check2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ] ), \"Valid checkbox\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ] ), \"Invalid checkbox\" );\n\n\te = $( \"#select1, #select2, #select3, #select4\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ] ), \"Invalid select\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ] ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ] ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ] ), \"Valid select\" );\n} );\n\nQUnit.test( \"required with dependencies\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.required,\n\t\te = $( \"#hidden2, #select1, #area2, #radio1, #check2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], \"asffsaa\" ), \"Valid text input due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], \"input\" ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], function() { return false; } ), \"Valid text input due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], function() { return true; } ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], \"asfsfa\" ), \"Valid select due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], \"input\" ), \"Invalid select\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], \"asfsafsfa\" ), \"Valid textarea due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], \"input\" ), \"Invalid textarea\" );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ], \"asfsafsfa\" ), \"Valid radio due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ], \"input\" ), \"Invalid radio\" );\n\tassert.ok( method.call( v, e[ 4 ].value, e[ 4 ], \"asfsafsfa\" ), \"Valid checkbox due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 4 ].value, e[ 4 ], \"input\" ), \"Invalid checkbox\" );\n} );\n\nQUnit.test( \"minlength\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.minlength,\n\t\tparam = 2,\n\t\te = $( \"#text1, #text1c, #text2, #text3\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ], param ), \"Valid text input\" );\n\n\te = $( \"#check1, #check2, #check3\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid checkbox\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid checkbox\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid checkbox\" );\n\n\te = $( \"#select1, #select2, #select3, #select4, #select5\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid select \" + e[ 0 ].id );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid select \" + e[ 1 ].id );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid select \" + e[ 2 ].id );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ], param ), \"Valid select \" + e[ 3 ].id );\n\tassert.ok( method.call( v, e[ 4 ].value, e[ 4 ], param ), \"Valid select \" + e[ 4 ].id );\n} );\n\nQUnit.test( \"maxlength\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.maxlength,\n\t\tparam = 4,\n\t\te = $( \"#text1, #text2, #text3\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n\n\te = $( \"#check1, #check2, #check3\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid checkbox\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid checkbox\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid checkbox\" );\n\n\te = $( \"#select1, #select2, #select3, #select4\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid select\" );\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ], param ), \"Invalid select\" );\n} );\n\nQUnit.test( \"rangelength\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.rangelength,\n\t\tparam = [ 2, 4 ],\n\t\te = $( \"#text1, #text2, #text3\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n} );\n\nQUnit.test( \"min\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.min,\n\t\tparam = 8,\n\t\te = $( \"#value1, #value2, #value3\" );\n\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid text input\" );\n} );\n\nQUnit.test( \"max\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.max,\n\t\tparam = 12,\n\t\te = $( \"#value1, #value2, #value3\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n} );\n\nQUnit.test( \"range\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.range,\n\t\tparam = [ 4, 12 ],\n\t\te = $( \"#value1, #value2, #value3\" );\n\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n} );\n\nQUnit.test( \"step\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.step,\n\t\tparam = 1000,\n\t\te = $( \"#value1, #value2, #value3, #value4\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid text input\" );\n} );\n\nQUnit.test( \"#1760 - step modulo/remainder regression tests\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.step,\n\t\tparam = 0.00125,\n\t\te = $( \"#value4\" );\n\n\tfor ( var i = 1; i <= 1000; i++ ) {\n\t\te[ 0 ].value = ( param * 100000 * i ) / 100000;\n\t\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Ensure \" + e[ 0 ].value + \" % \" + param + \" === 0 is valid\" );\n\t}\n} );\n\nQUnit.test( \"lessThan\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.lessThan,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( !method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( !method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n} );\n\nQUnit.test( \"lessThanEqual\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.lessThanEqual,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( !method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n} );\n\nQUnit.test( \"equalTo\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.equalTo,\n\t\te = $( \"#text1, #text2\" );\n\n\tassert.ok( method.call( v, \"Test\", e[ 0 ], \"#text1\" ), \"Text input\" );\n\tassert.ok( method.call( v, \"T\", e[ 1 ], \"#text2\" ), \"Another one\" );\n} );\n\nQUnit.test( \"greaterThanEqual\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.greaterThanEqual,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( !method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n} );\n\nQUnit.test( \"greaterThan\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.greaterThan,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( !method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( !method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n} );\n\nQUnit.test( \"extension\", function( assert ) {\n\tvar method = methodTest( \"extension\" ),\n\t\tv;\n\tassert.ok( method( \"picture.gif\" ), \"Valid default accept type\" );\n\tassert.ok( method( \"picture.jpg\" ), \"Valid default accept type\" );\n\tassert.ok( method( \"picture.jpeg\" ), \"Valid default accept type\" );\n\tassert.ok( method( \"picture.png\" ), \"Valid default accept type\" );\n\tassert.ok( !method( \"picture.pgn\" ), \"Invalid default accept type\" );\n\n\tv = jQuery( \"#form\" ).validate();\n\tmethod = function( value, param ) {\n\t\treturn $.validator.methods.extension.call( v, value, $( \"#text1\" )[ 0 ], param );\n\t};\n\tassert.ok( method( \"picture.doc\", \"doc\" ), \"Valid custom accept type\" );\n\tassert.ok( method( \"picture.pdf\", \"doc|pdf\" ), \"Valid custom accept type\" );\n\tassert.ok( method( \"picture.pdf\", \"pdf|doc\" ), \"Valid custom accept type\" );\n\tassert.ok( !method( \"picture.pdf\", \"doc\" ), \"Invalid custom accept type\" );\n\tassert.ok( !method( \"picture.doc\", \"pdf\" ), \"Invalid custom accept type\" );\n\n\tassert.ok( method( \"picture.pdf\", \"doc,pdf\" ), \"Valid custom accept type, comma separated\" );\n\tassert.ok( method( \"picture.pdf\", \"pdf,doc\" ), \"Valid custom accept type, comma separated\" );\n\tassert.ok( !method( \"picture.pdf\", \"gop,top\" ), \"Invalid custom accept type, comma separated\" );\n} );\n\nQUnit.test( \"remote\", function( assert ) {\n\tassert.expect( 7 );\n\tvar e = $( \"#username\" ),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: true,\n\t\t\t\t\tremote: \"users.php\"\n\t\t\t\t}\n\t\t\t},\n\t\t\tmessages: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: \"Please\",\n\t\t\t\t\tremote: jQuery.validator.format( \"{0} in use\" )\n\t\t\t\t}\n\t\t\t}\n\t\t} ),\n\t\tdone = assert.async();\n\n\t$( document ).ajaxStop( function() {\n\t\t$( document ).unbind( \"ajaxStop\" );\n\t\tassert.equal( v.size(), 1, \"There must be one error\" );\n\t\tassert.equal( v.errorList[ 0 ].message, \"Peter in use\" );\n\n\t\t$( document ).ajaxStop( function() {\n\t\t\t$( document ).unbind( \"ajaxStop\" );\n\t\t\tassert.equal( v.size(), 1, \"There must be one error\" );\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"Peter2 in use\" );\n\t\t\tdone();\n\t\t} );\n\t\te.val( \"Peter2\" );\n\t\tassert.strictEqual( v.element( e ), true, \"new value, new request; dependency-mismatch considered as valid though\" );\n\t} );\n\tassert.strictEqual( v.element( e ), false, \"invalid element, nothing entered yet\" );\n\te.val( \"Peter\" );\n\tassert.strictEqual( v.element( e ), true, \"still invalid, because remote validation must block until it returns; dependency-mismatch considered as valid though\" );\n} );\n\nQUnit.test( \"remote, pending class added to element while call outstanding\", function( assert ) {\n\tassert.expect( 3 );\n\tvar e = $( \"#username\" ),\n\t\tdone = assert.async(),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\tremote: {\n\t\t\t\t\t\turl: \"users.php\",\n\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\tassert.strictEqual( e.hasClass( \"pending\" ), false, \"not pending since ajax call complete\" );\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\tassert.strictEqual( e.hasClass( \"pending\" ), false, \"not pending since no data entered\" );\n\te.val( \"Peter\" );\n\n\t// This fires off the validation:\n\tv.element( e );\n\tassert.strictEqual( e.hasClass( \"pending\" ), true, \"pending while validation outstanding\" );\n} );\n\nQUnit.test( \"remote, customized ajax options\", function( assert ) {\n\tassert.expect( 2 );\n\tvar done = assert.async();\n\t$( \"#userForm\" ).validate( {\n\t\trules: {\n\t\t\tusername: {\n\t\t\t\trequired: true,\n\t\t\t\tremote: {\n\t\t\t\t\turl: \"users.php\",\n\t\t\t\t\ttype: \"POST\",\n\t\t\t\t\tbeforeSend: function( request, settings ) {\n\t\t\t\t\t\tassert.deepEqual( settings.type, \"POST\" );\n\t\t\t\t\t\tassert.deepEqual( settings.data, \"username=asdf&email=email.com\" );\n\t\t\t\t\t},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\temail: function() {\n\t\t\t\t\t\t\treturn \"email.com\";\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\tdone();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t$( \"#username\" ).val( \"asdf\" );\n\t$( \"#userForm\" ).valid();\n} );\n\nQUnit.test( \"remote extensions\", function( assert ) {\n\tassert.expect( 5 );\n\tvar e = $( \"#username\" ),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: true,\n\t\t\t\t\tremote: \"users2.php\"\n\t\t\t\t}\n\t\t\t},\n\t\t\tmessages: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: \"Please\"\n\t\t\t\t}\n\t\t\t}\n\t\t} ),\n\t\tdone = assert.async();\n\n\t$( document ).ajaxStop( function() {\n\t\t$( document ).unbind( \"ajaxStop\" );\n\t\tif ( v.size() !== 0 ) {\n\t\t\tassert.ok( \"There must be one error\" );\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"asdf is already taken, please try something else\" );\n\t\t\tv.element( e );\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"asdf is already taken, please try something else\", \"message doesn't change on revalidation\" );\n\t\t}\n\t\tdone();\n\t} );\n\tassert.strictEqual( v.element( e ), false, \"invalid element, nothing entered yet\" );\n\te.val( \"asdf\" );\n\tassert.strictEqual( v.element( e ), true, \"still invalid, because remote validation must block until it returns; dependency-mismatch considered as valid though\" );\n} );\n\nQUnit.test( \"remote, data previous querystring\", function( assert ) {\n\tassert.expect( 4 );\n\tvar succeeded = 0,\n\t\t$f = $( \"#firstnamec\" ),\n\t\t$l = $( \"#lastnamec\" ),\n\t\tdone1 = assert.async(),\n\t\tdone2 = assert.async(),\n\t\tdone3 = assert.async(),\n\t\tv = $( \"#testForm1clean\" ).validate( {\n\t\t\trules: {\n\t\t\t\tlastname: {\n\t\t\t\t\tremote: {\n\t\t\t\t\t\turl: \"users.php\",\n\t\t\t\t\t\ttype: \"POST\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tfirstname: function() {\n\t\t\t\t\t\t\t\treturn $f.val();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\tsucceeded++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t$f.val( \"first-name\" );\n\t$l.val( \"last-name\" );\n\tassert.strictEqual( succeeded, 0, \"no valid call means no successful validation\" );\n\tv.element( $l );\n\tsetTimeout( function() {\n\t\tassert.strictEqual( succeeded, 1, \"first valid check should submit given first name\" );\n\t\tdone1();\n\t\tv.element( $l );\n\t\tsetTimeout( function() {\n\t\t\tassert.strictEqual( succeeded, 1, \"second valid check should not resubmit given same first name\" );\n\t\t\tdone2();\n\t\t\t$f.val( \"different-first-name\" );\n\t\t\tv.element( $l );\n\t\t\tsetTimeout( function() {\n\t\t\t\tassert.strictEqual( succeeded, 2, \"third valid check should resubmit given different first name\" );\n\t\t\t\tdone3();\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n\nQUnit.test( \"remote, highlight all invalid fields\", function( assert ) {\n\tassert.expect( 3 );\n\n\tvar done = assert.async(),\n\t\t$form = $( \"#testForm1\" ),\n\t\t$firstnameField = $form.find( \"input[name='firstname']\" ),\n\t\t$lastnameField = $form.find( \"input[name='lastname']\" ),\n\t\t$somethingField = $form.find( \"input[name='something']\" ),\n\t\tvalidateOptions = {\n\t        rules: {\n\t\t\t\tfirstname: {\n\t                required: true\n\t            },\n\t            lastname: {\n\t                required: true\n\t            },\n\t\t\t\tsomething: {\n\t                required: true,\n\t                remote: {\n\t                    url: \"response.php\",\n\t                    type: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tresponseText: \"false\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t$firstnameField.val( \"\" );\n\t$lastnameField.val( \"\" );\n\t$somethingField.val( \"something value\" );\n\n\t$form.validate( validateOptions );\n\t$form.valid();\n\n\tsetTimeout( function() {\n\t\tassert.equal( $firstnameField.hasClass( \"error\" ), true, \"Field 'firstname' should have a '.error' class\" );\n\t\tassert.equal( $lastnameField.hasClass( \"error\" ), true, \"Field 'lastname' should have a '.error' class\" );\n\t\tassert.equal( $somethingField.hasClass( \"error\" ), true, \"Field 'something' should have a '.error' class\" );\n\t\tdone();\n\t}, 500 );\n} );\nQUnit.test( \"remote, unhighlighted should be invoked after being highlighted/invalid\", function( assert ) {\n\tassert.expect( 6 );\n\n\tvar done1 = assert.async(),\n\t\tdone2 = assert.async(),\n\t\t$form = $( \"#testForm25\" ),\n\t\t$somethingField = $form.find( \"input[name='something25']\" ),\n\t\tresponseText = \"false\",\n\t\tresponse = function() { return responseText; },\n\t\tvalidateOptions = {\n\t\t\thighlight: function( e ) {\n\t\t\t\t$( e ).addClass( \"error\" );\n\t\t\t\tassert.ok( true, \"highlight should be called\" );\n\t\t\t},\n\t\t\tunhighlight: function( e ) {\n\t\t\t\t$( e ).removeClass( \"error\" );\n\t\t\t\tassert.ok( true, \"unhighlight should be called\" );\n\t\t\t},\n\t        rules: {\n\t\t\t\tsomething25: {\n\t                required: true,\n\t                remote: {\n\t                    url: \"response.php\",\n\t                    type: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tresponseText: response\n\t\t\t\t\t\t},\n\t\t\t\t\t\tasync: false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t$somethingField.val( \"something value\" );\n\tvar v = $form.validate( validateOptions );\n\tv.element( $somethingField );\n\n\tsetTimeout( function() {\n\t\tassert.equal( $somethingField.hasClass( \"error\" ), true, \"Field 'something' should have the error class\" );\n\t\tdone1();\n\t\t$somethingField.val( \"something value 2\" );\n\t\tresponseText = \"true\";\n\n\t\tv.element( $somethingField );\n\n\t\tsetTimeout( function() {\n\t\t\tassert.equal( $somethingField.hasClass( \"error\" ), false, \"Field 'something' should not have the error class\" );\n\t\t\tdone2();\n\t\t}, 500 );\n\t}, 500 );\n} );\n\nQUnit.test( \"Fix #697: remote validation uses wrong error messages\", function( assert ) {\n\tvar e = $( \"#username\" ),\n\t\tdone1 = assert.async(),\n\t\tdone2 = assert.async(),\n\t\tdone3 = assert.async(),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: true,\n\t\t\t\t\tremote: {\n\t\t\t\t\t\turl: \"users.php\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tmessages: {\n\t\t\t\tusername: {\n\t\t\t\t\tremote: $.validator.format( \"{0} in use\" )\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t$( \"#userForm\" ).valid();\n\n\te.val( \"Peter\" );\n\tv.element( e );\n\tsetTimeout( function() {\n\t\tassert.equal( v.errorList[ 0 ].message, \"Peter in use\" );\n\t\tdone1();\n\n\t\te.val( \"something\" );\n\t\tv.element( e );\n\n\t\te.val( \"Peter\" );\n\t\tv.element( e );\n\t\tsetTimeout( function() {\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"Peter in use\" );\n\t\t\tdone2();\n\n\t\t\te.val( \"asdf\" );\n\t\t\tv.element( e );\n\t\t\tsetTimeout( function() {\n\t\t\t\tassert.equal( v.errorList[ 0 ].message, \"asdf in use\", \"error message should be updated\" );\n\t\t\t\tdone3();\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n\nQUnit.module( \"additional methods\" );\n\nQUnit.test( \"phone (us)\", function( assert ) {\n\tvar method = methodTest( \"phoneUS\" );\n\tassert.ok( method( \"1(212)-999-2345\" ), \"Valid US phone number\" );\n\tassert.ok( method( \"212 999 2344\" ), \"Valid US phone number\" );\n\tassert.ok( method( \"212-999-0983\" ), \"Valid US phone number\" );\n\tassert.ok( method( \"234-911-5678\" ), \"Valid US phone number\" );\n\tassert.ok( !method( \"111-123-5434\" ), \"Invalid US phone number. Area Code cannot start with 1\" );\n\tassert.ok( !method( \"212 123 4567\" ), \"Invalid US phone number. NXX cannot start with 1\" );\n\tassert.ok( !method( \"911-333-5678\" ), \"Invalid US phone number, because the area code cannot be in the form N11\" );\n\tassert.ok( method( \"234-912-5678\" ), \"Valid US phone number\" );\n} );\n\nQUnit.test( \"phoneUK\", function( assert ) {\n\tvar method = methodTest( \"phoneUK\" );\n\tassert.ok( method( \"0117 333 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0121 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"01633 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"01298 28555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"015395 55555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"016977 3999\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"020 3000 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"024 7500 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0333 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0500 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"055 3555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"07122 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"07222 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"07322 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0800 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0800 355555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0843 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0872 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0903 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0983 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"(07122) 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"(07222) 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"(07322) 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"+44 7122 555 555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"+44 7222 555 555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"+44 7322 555 555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( !method( \"7222 555555\" ), \"Invalid UK Phone Number\" );\n\tassert.ok( !method( \"+44 07222 555555\" ), \"Invalid UK Phone Number\" );\n} );\n\nQUnit.test( \"mobileUK\", function( assert ) {\n\tvar method = methodTest( \"mobileUK\" );\n\tassert.ok( method( \"07134234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"07334234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"07624234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"07734234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447134234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447334234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447624234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447734234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( !method( \"07034234323\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"0753423432\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"07604234323\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"077342343234\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"044342343234\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+44753423432\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+447604234323\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+4477342343234\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+4444342343234\" ), \"Invalid UK Mobile Number\" );\n} );\n\nQUnit.test( \"mobileRU\", function( assert ) {\n\tvar method = methodTest( \"mobileRU\" );\n\tassert.ok( method( \"+74957207089\" ), \"Valid RU Mobile Number\" );\n\tassert.ok( method( \"84957207089\" ), \"Valid RU Mobile Number\" );\n\tassert.ok( !method( \"+447604234323\" ), \"Invalid RU Mobile Number\" );\n\tassert.ok( !method( \"9477342343234\" ), \"Invalid RU Mobile Number\" );\n\tassert.ok( !method( \"344342343234\" ), \"Invalid RU Mobile Number\" );\n} );\n\nQUnit.test( \"dateITA\", function( assert ) {\n\tvar method = methodTest( \"dateITA\" );\n\tassert.ok( method( \"01/01/1900\" ), \"Valid date ITA\" );\n\tassert.ok( method( \"17/10/2010\" ), \"Valid date ITA\" );\n\tassert.ok( !method( \"01/13/1990\" ), \"Invalid date ITA\" );\n\tassert.ok( !method( \"01.01.1900\" ), \"Invalid date ITA\" );\n\tassert.ok( !method( \"01/01/199\" ), \"Invalid date ITA\" );\n} );\n\nQUnit.test( \"dateFA\", function( assert ) {\n\tvar method = methodTest( \"dateFA\" );\n\n\tassert.ok( method( \"1342/12/29\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1342/12/30\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1361/6/31\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1321/11/30\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1361/1/1\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/3/3\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/03/3\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/3/03\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/03/03\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1001/7/30\" ), \"Valid date FA\" );\n\n\tassert.ok( !method( \"1000/1/32\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"1323/12/31\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"1361/0/11\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"63/4/4\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"15/6/1361\" ), \"Invalid date FA\" );\n} );\n\nQUnit.test( \"iban\", function( assert ) {\n\tvar method = methodTest( \"iban\" );\n\tassert.ok( method( \"NL20INGB0001234567\" ), \"Valid IBAN\" );\n\tassert.ok( method( \"DE68 2105 0170 0012 3456 78\" ), \"Valid IBAN\" );\n\tassert.ok( method( \"NL20 INGB0001234567\" ), \"Valid IBAN: invalid spacing\" );\n\tassert.ok( method( \"NL20 INGB 00 0123 4567\" ), \"Valid IBAN: invalid spacing\" );\n\tassert.ok( method( \"XX40INGB000123456712341234\" ), \"Valid (more or less) IBAN: unknown country, but checksum OK\" );\n\n\tassert.ok( !method( \"1\" ), \"Invalid IBAN: too short\" );\n\tassert.ok( !method( \"NL20INGB000123456\" ), \"Invalid IBAN: too short\" );\n\tassert.ok( !method( \"NL20INGB00012345678\" ), \"Invalid IBAN: too long\" );\n\tassert.ok( !method( \"NL20INGB0001234566\" ), \"Invalid IBAN: checksum incorrect\" );\n\tassert.ok( !method( \"DE68 2105 0170 0012 3456 7\" ), \"Invalid IBAN: too short\" );\n\tassert.ok( !method( \"DE68 2105 0170 0012 3456 789\" ), \"Invalid IBAN: too long\" );\n\tassert.ok( !method( \"DE68 2105 0170 0012 3456 79\" ), \"Invalid IBAN: checksum incorrect\" );\n\n\tassert.ok( !method( \"NL54INGB00012345671234\" ), \"Invalid IBAN too long, BUT CORRECT CHECKSUM\" );\n\tassert.ok( !method( \"XX00INGB000123456712341234\" ), \"Invalid IBAN: unknown country and checksum incorrect\" );\n\n\t// Sample IBANs for different countries\n\tassert.ok( method( \"AL47 2121 1009 0000 0002 3569 8741\" ), \"Valid IBAN - AL\" );\n\tassert.ok( method( \"AD12 0001 2030 2003 5910 0100\" ), \"Valid IBAN - AD\" );\n\tassert.ok( method( \"AT61 1904 3002 3457 3201\" ), \"Valid IBAN - AT\" );\n\tassert.ok( method( \"AZ21 NABZ 0000 0000 1370 1000 1944\" ), \"Valid IBAN - AZ\" );\n\tassert.ok( method( \"BH67 BMAG 0000 1299 1234 56\" ), \"Valid IBAN - BH\" );\n\tassert.ok( method( \"BE62 5100 0754 7061\" ), \"Valid IBAN - BE\" );\n\tassert.ok( method( \"BA39 1290 0794 0102 8494\" ), \"Valid IBAN - BA\" );\n\tassert.ok( method( \"BG80 BNBG 9661 1020 3456 78\" ), \"Valid IBAN - BG\" );\n\tassert.ok( method( \"HR12 1001 0051 8630 0016 0\" ), \"Valid IBAN - HR\" );\n\tassert.ok( method( \"CH93 0076 2011 6238 5295 7\" ), \"Valid IBAN - CH\" );\n\tassert.ok( method( \"CY17 0020 0128 0000 0012 0052 7600\" ), \"Valid IBAN - CY\" );\n\tassert.ok( method( \"CZ65 0800 0000 1920 0014 5399\" ), \"Valid IBAN - CZ\" );\n\tassert.ok( method( \"DK50 0040 0440 1162 43\" ), \"Valid IBAN - DK\" );\n\tassert.ok( method( \"EE38 2200 2210 2014 5685\" ), \"Valid IBAN - EE\" );\n\tassert.ok( method( \"FO97 5432 0388 8999 44\" ), \"Valid IBAN - FO\" );\n\tassert.ok( method( \"FI21 1234 5600 0007 85\" ), \"Valid IBAN - FI\" );\n\tassert.ok( method( \"FR14 2004 1010 0505 0001 3M02 606\" ), \"Valid IBAN - FR\" );\n\tassert.ok( method( \"GE29 NB00 0000 0101 9049 17\" ), \"Valid IBAN - GE\" );\n\tassert.ok( method( \"DE89 3704 0044 0532 0130 00\" ), \"Valid IBAN - DE\" );\n\tassert.ok( method( \"GI75 NWBK 0000 0000 7099 453\" ), \"Valid IBAN - GI\" );\n\tassert.ok( method( \"GR16 0110 1250 0000 0001 2300 695\" ), \"Valid IBAN - GR\" );\n\tassert.ok( method( \"GL56 0444 9876 5432 10\" ), \"Valid IBAN - GL\" );\n\tassert.ok( method( \"HU42 1177 3016 1111 1018 0000 0000\" ), \"Valid IBAN - HU\" );\n\tassert.ok( method( \"IS14 0159 2600 7654 5510 7303 39\" ), \"Valid IBAN - IS\" );\n\tassert.ok( method( \"IE29 AIBK 9311 5212 3456 78\" ), \"Valid IBAN - IE\" );\n\tassert.ok( method( \"IL62 0108 0000 0009 9999 999\" ), \"Valid IBAN - IL\" );\n\tassert.ok( method( \"IT40 S054 2811 1010 0000 0123 456\" ), \"Valid IBAN - IT\" );\n\tassert.ok( method( \"LV80 BANK 0000 4351 9500 1\" ), \"Valid IBAN - LV\" );\n\tassert.ok( method( \"LB62 0999 0000 0001 0019 0122 9114\" ), \"Valid IBAN - LB\" );\n\tassert.ok( method( \"LI21 0881 0000 2324 013A A\" ), \"Valid IBAN - LI\" );\n\tassert.ok( method( \"LT12 1000 0111 0100 1000\" ), \"Valid IBAN - LT\" );\n\tassert.ok( method( \"LU28 0019 4006 4475 0000\" ), \"Valid IBAN - LU\" );\n\tassert.ok( method( \"MK07 2501 2000 0058 984\" ), \"Valid IBAN - MK\" );\n\tassert.ok( method( \"MT84 MALT 0110 0001 2345 MTLC AST0 01S\" ), \"Valid IBAN - MT\" );\n\tassert.ok( method( \"MU17 BOMM 0101 1010 3030 0200 000M UR\" ), \"Valid IBAN - MU\" );\n\tassert.ok( method( \"MD24 AG00 0225 1000 1310 4168\" ), \"Valid IBAN - MD\" );\n\tassert.ok( method( \"MC93 2005 2222 1001 1223 3M44 555\" ), \"Valid IBAN - MC\" );\n\tassert.ok( method( \"ME25 5050 0001 2345 6789 51\" ), \"Valid IBAN - ME\" );\n\tassert.ok( method( \"NL39 RABO 0300 0652 64\" ), \"Valid IBAN - NL\" );\n\tassert.ok( method( \"NO93 8601 1117 947\" ), \"Valid IBAN - NO\" );\n\tassert.ok( method( \"PK36 SCBL 0000 0011 2345 6702\" ), \"Valid IBAN - PK\" );\n\tassert.ok( method( \"PL60 1020 1026 0000 0422 7020 1111\" ), \"Valid IBAN - PL\" );\n\tassert.ok( method( \"PT50 0002 0123 1234 5678 9015 4\" ), \"Valid IBAN - PT\" );\n\tassert.ok( method( \"RO49 AAAA 1B31 0075 9384 0000\" ), \"Valid IBAN - RO\" );\n\tassert.ok( method( \"SM86 U032 2509 8000 0000 0270 100\" ), \"Valid IBAN - SM\" );\n\tassert.ok( method( \"SA03 8000 0000 6080 1016 7519\" ), \"Valid IBAN - SA\" );\n\tassert.ok( method( \"RS35 2600 0560 1001 6113 79\" ), \"Valid IBAN - RS\" );\n\tassert.ok( method( \"SK31 1200 0000 1987 4263 7541\" ), \"Valid IBAN - SK\" );\n\tassert.ok( method( \"SI56 1910 0000 0123 438\" ), \"Valid IBAN - SI\" );\n\tassert.ok( method( \"ES80 2310 0001 1800 0001 2345\" ), \"Valid IBAN - ES\" );\n\tassert.ok( method( \"SE35 5000 0000 0549 1000 0003\" ), \"Valid IBAN - SE\" );\n\tassert.ok( method( \"CH93 0076 2011 6238 5295 7\" ), \"Valid IBAN - CH\" );\n\tassert.ok( method( \"TN59 1000 6035 1835 9847 8831\" ), \"Valid IBAN - TN\" );\n\tassert.ok( method( \"TR33 0006 1005 1978 6457 8413 26\" ), \"Valid IBAN - TR\" );\n\tassert.ok( method( \"AE07 0331 2345 6789 0123 456\" ), \"Valid IBAN - AE\" );\n\tassert.ok( method( \"GB29 NWBK 6016 1331 9268 19\" ), \"Valid IBAN - GB\" );\n} );\n\n/**\n * BIC tests (For BIC definition take a look on the implementation itself)\n */\nQUnit.test( \"bic\", function( assert ) {\n\tvar method = methodTest( \"bic\" );\n\n\tassert.ok( !method( \"PBNKDEF\" ), \"Invalid BIC: too short\" );\n\tassert.ok( !method( \"DEUTDEFFA1\" ), \"Invalid BIC: disallowed length\" );\n\tassert.ok( !method( \"PBNKDEFFXXX1\" ), \"Invalid BIC: too long\" );\n\tassert.ok( !method( \"1BNKDEFF\" ), \"Invalid BIC: invalid digit\" );\n\tassert.ok( !method( \"PBNKDE1F\" ), \"Invalid BIC: invalid digit\" );\n\tassert.ok( !method( \"PBNKDEFO\" ), \"Invalid BIC: invalid char\" );\n\tassert.ok( !method( \"INGDDEFFXAA\" ), \"Invalid BIC: invalid char\" );\n\tassert.ok( !method( \"DEUTDEF0\" ), \"Invalid BIC: invalid digit\" );\n\n\tassert.ok( method( \"DEUTDEFF\" ), \"Valid BIC\" );\n\tassert.ok( method( \"DEUTDEFFXXX\" ), \"Valid BIC\" );\n\tassert.ok( method( \"PBNKDE2F\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDEFF101\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDEF2134\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDE91XXX\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDEF2\" ), \"Valid BIC\" );\n\tassert.ok( method( \"AAFFFRP1\" ), \"Valid BIC\" );\n\tassert.ok( method( \"DEUTDEFFAB1\" ), \"Valid BIC\" );\n\tassert.ok( method( \"DEUTDEFFAXX\" ), \"Valid BIC\" );\n\tassert.ok( method( \"SSKNDE77XXX\" ), \"Valid BIC\" );\n\n\t// BIC accept also lowercased values\n\tassert.ok( !method( \"pbnkdef\" ), \"Invalid BIC: too short\" );\n\tassert.ok( !method( \"deutdeffa1\" ), \"Invalid BIC: disallowed length\" );\n\tassert.ok( !method( \"pbnkdeffxxx1\" ), \"Invalid BIC: too long\" );\n\tassert.ok( !method( \"1bnkdeff\" ), \"Invalid BIC: invalid digit\" );\n\tassert.ok( !method( \"ingddeffxaa\" ), \"Invalid BIC: invalid char\" );\n\n\tassert.ok( method( \"deutdeff\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"deutdeffxxx\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"pbnkde2f\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"ingdde91xxx\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"ingddef2\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"deutdeffab1\" ), \"Valid BIC (lowercase value)\" );\n} );\n\nQUnit.test( \"postcodeUK\", function( assert ) {\n\tvar method = methodTest( \"postcodeUK\" );\n\tassert.ok( method( \"AA9A 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"A9A 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"A9 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"A99 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"AA9 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"AA99 9AA\" ), \"Valid postcode\" );\n\n\t// Channel Island\n\tassert.ok( !method( \"AAAA 9AA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"AA-2640\" ), \"Invalid postcode\" );\n\n\tassert.ok( !method( \"AAA AAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"AA AAAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"A AAAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"AAAAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"999 999\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"99 9999\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"9 9999\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"99999\" ), \"Invalid postcode\" );\n} );\n\nQUnit.test( \"dateNL\", function( assert ) {\n\tvar method = methodTest( \"dateNL\" );\n\tassert.ok( method( \"01-01-1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"01.01.1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"01/01/1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"01-01-00\" ), \"Valid date NL\" );\n\tassert.ok( method( \"1-01-1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"10-10-1900\" ), \"Valid date NL\" );\n\tassert.ok( !method( \"0-01-1900\" ), \"Invalid date NL\" );\n\tassert.ok( !method( \"00-01-1900\" ), \"Invalid date NL\" );\n\tassert.ok( !method( \"35-01-1990\" ), \"Invalid date NL\" );\n\tassert.ok( !method( \"01.01.190\" ), \"Invalid date NL\" );\n} );\n\nQUnit.test( \"phoneNL\", function( assert ) {\n\tvar method = methodTest( \"phoneNL\" );\n\tassert.ok( method( \"0701234567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"0687654321\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"020-1234567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"020 - 12 34 567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"010-2345678\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"+3120-1234567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"+31(0)10-2345678\" ), \"Valid phone NL\" );\n\tassert.ok( !method( \"020-123456\" ), \"Invalid phone NL: too short\" );\n\tassert.ok( !method( \"020-12345678\" ), \"Invalid phone NL: too long\" );\n\tassert.ok( !method( \"-0201234567\" ), \"Invalid phone NL\" );\n\tassert.ok( !method( \"+310201234567\" ), \"Invalid phone NL: no 0 after +31 allowed\" );\n} );\n\nQUnit.test( \"mobileNL\", function( assert ) {\n\tvar method = methodTest( \"mobileNL\" );\n\tassert.ok( method( \"0612345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"06-12345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"06-12 345 678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"+316-12345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"+31(0)6-12345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( !method( \"abcdefghij\" ), \"Invalid NL Mobile Number: text\" );\n\tassert.ok( !method( \"0123456789\" ), \"Invalid NL Mobile Number: should start with 06\" );\n\tassert.ok( !method( \"0823456789\" ), \"Invalid NL Mobile Number: should start with 06\" );\n\tassert.ok( !method( \"06-1234567\" ), \"Invalid NL Mobile Number: too short\" );\n\tassert.ok( !method( \"06-123456789\" ), \"Invalid NL Mobile Number: too long\" );\n\tassert.ok( !method( \"-0612345678\" ), \"Invalid NL Mobile Number\" );\n\tassert.ok( !method( \"+310612345678\" ), \"Invalid NL Mobile Number: no 0 after +31 allowed\" );\n} );\n\nQUnit.test( \"postalcodeNL\", function( assert ) {\n\tvar method = methodTest( \"postalcodeNL\" );\n\tassert.ok( method( \"1234AB\" ), \"Valid NL Postal Code\" );\n\tassert.ok( method( \"1234ab\" ), \"Valid NL Postal Code\" );\n\tassert.ok( method( \"1234 AB\" ), \"Valid NL Postal Code\" );\n\tassert.ok( method( \"6789YZ\" ), \"Valid NL Postal Code\" );\n\tassert.ok( !method( \"123AA\" ), \"Invalid NL Postal Code: not enough digits\" );\n\tassert.ok( !method( \"12345ZZ\" ), \"Invalid NL Postal Code: too many digits\" );\n\tassert.ok( !method( \"1234  AA\" ), \"Invalid NL Postal Code: too many spaces\" );\n\tassert.ok( !method( \"AA1234\" ), \"Invalid NL Postal Code\" );\n\tassert.ok( !method( \"1234-AA\" ), \"Invalid NL Postal Code\" );\n} );\n\nQUnit.test( \"bankaccountNL\", function( assert ) {\n\tvar method = methodTest( \"bankaccountNL\" );\n\tassert.ok( method( \"755490975\" ), \"Valid NL bank account\" );\n\tassert.ok( method( \"75 54 90 975\" ), \"Valid NL bank account\" );\n\tassert.ok( method( \"123456789\" ), \"Valid NL bank account\" );\n\tassert.ok( method( \"12 34 56 789\" ), \"Valid NL bank account\" );\n\tassert.ok( !method( \"12 3456789\" ), \"Valid NL bank account: inconsistent spaces\" );\n\tassert.ok( !method( \"123 45 67 89\" ), \"Valid NL bank account: incorrect spaces\" );\n\tassert.ok( !method( \"755490971\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"755490973\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"755490979\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"123456781\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"123456784\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"123456788\" ), \"Invalid NL bank account\" );\n} );\n\nQUnit.test( \"giroaccountNL\", function( assert ) {\n\tvar method = methodTest( \"giroaccountNL\" );\n\tassert.ok( method( \"123\" ), \"Valid NL giro  account\" );\n\tassert.ok( method( \"1234567\" ), \"Valid NL giro account\" );\n\tassert.ok( !method( \"123456788\" ), \"Invalid NL giro account\" );\n} );\n\nQUnit.test( \"bankorgiroaccountNL\", function( assert ) {\n\tvar method = methodTest( \"bankorgiroaccountNL\" );\n\tassert.ok( method( \"123\" ), \"Valid NL giro account\" );\n\tassert.ok( method( \"1234567\" ), \"Valid NL giro account\" );\n\tassert.ok( method( \"123456789\" ), \"Valid NL bank account\" );\n\tassert.ok( !method( \"12345678\" ), \"Invalid NL bank or giro account\" );\n\tassert.ok( !method( \"123456788\" ), \"Invalid NL bank or giro account\" );\n} );\n\nQUnit.test( \"time\", function( assert ) {\n\tvar method = methodTest( \"time\" );\n\tassert.ok( method( \"00:00\" ), \"Valid time, lower bound\" );\n\tassert.ok( method( \"23:59\" ), \"Valid time, upper bound\" );\n\tassert.ok( method( \"3:59\" ), \"Valid time, single digit hour\" );\n\tassert.ok( !method( \"12\" ), \"Invalid time\" );\n\tassert.ok( !method( \"29:59\" ), \"Invalid time\" );\n\tassert.ok( !method( \"00:60\" ), \"Invalid time\" );\n\tassert.ok( !method( \"24:60\" ), \"Invalid time\" );\n\tassert.ok( !method( \"24:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"30:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"29:59\" ), \"Invalid time\" );\n\tassert.ok( !method( \"120:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"12:001\" ), \"Invalid time\" );\n\tassert.ok( !method( \"12:00a\" ), \"Invalid time\" );\n} );\n\nQUnit.test( \"time12h\", function( assert ) {\n\tvar method = methodTest( \"time12h\" );\n\tassert.ok( method( \"12:00 AM\" ), \"Valid time, lower bound, am\" );\n\tassert.ok( method( \"11:59 AM\" ), \"Valid time, upper bound, am\" );\n\tassert.ok( method( \"12:00AM\" ), \"Valid time, no space, am\" );\n\tassert.ok( method( \"12:00PM\" ), \"Valid time, no space, pm\" );\n\tassert.ok( method( \"12:00 PM\" ), \"Valid time, lower bound, pm\" );\n\tassert.ok( method( \"11:59 PM\" ), \"Valid time, upper bound, pm\" );\n\tassert.ok( method( \"11:59 am\" ), \"Valid time, also accept lowercase\" );\n\tassert.ok( method( \"11:59 pm\" ), \"Valid time, also accept lowercase\" );\n\tassert.ok( method( \"1:59 pm\" ), \"Valid time, single hour, no leading 0\" );\n\tassert.ok( method( \"01:59 pm\" ), \"Valid time, single hour, leading 0\" );\n\tassert.ok( !method( \"12:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"9\" ), \"Invalid time\" );\n\tassert.ok( !method( \"9 am\" ), \"Invalid time\" );\n\tassert.ok( !method( \"12:61 am\" ), \"Invalid time\" );\n\tassert.ok( !method( \"13:00 am\" ), \"Invalid time\" );\n\tassert.ok( !method( \"00:00 am\" ), \"Invalid time\" );\n} );\n\nQUnit.test( \"minWords\", function( assert ) {\n\tvar method = methodTest( \"minWords\" );\n\tassert.ok( method( \"hello worlds\", 2 ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>hello</b> world\", 2 ), \"html, valid\" );\n\tassert.ok( !method( \"hello\", 2 ), \"plain text, invalid\" );\n\tassert.ok( !method( \"<b>world</b>\", 2 ), \"html, invalid\" );\n\tassert.ok( !method( \"world <br/>\", 2 ), \"html, invalid\" );\n} );\n\nQUnit.test( \"maxWords\", function( assert ) {\n\tvar method = methodTest( \"maxWords\" );\n\tassert.ok( method( \"hello\", 2 ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>world</b>\", 2 ), \"html, valid\" );\n\tassert.ok( method( \"world <br/>\", 2 ), \"html, valid\" );\n\tassert.ok( method( \"hello worlds\", 2 ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>hello</b> world\", 2 ), \"html, valid\" );\n\tassert.ok( !method( \"hello 123 world\", 2 ), \"plain text, invalid\" );\n\tassert.ok( !method( \"<b>hello</b> 123 world\", 2 ), \"html, invalid\" );\n} );\n\nQUnit.test( \"rangeWords\", function( assert ) {\n\tvar method = methodTest( \"rangeWords\" );\n\tassert.ok( method( \"hello\", [ 0, 2 ] ), \"plain text, valid\" );\n\tassert.ok( method( \"hello worlds\", [ 0, 2 ] ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>hello</b> world\", [ 0, 2 ] ), \"html, valid\" );\n\tassert.ok( !method( \"hello worlds what is up\", [ 0, 2 ] ), \"plain text, invalid\" );\n\tassert.ok( !method( \"<b>Hello</b> <b>world</b> <b>hello</b>\", [ 0, 2 ] ), \"html, invalid\" );\n} );\n\nQUnit.test( \"pattern\", function( assert ) {\n\tvar method = methodTest( \"pattern\" );\n\tassert.ok( method( \"AR1004\", \"AR\\\\d{4}\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( method( \"AR1004\", /^AR\\d{4}$/ ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"BR1004\", /^AR\\d{4}$/ ), \"Invalid format for the given RegExp\" );\n\tassert.ok( method( \"1ABC\", \"[0-9][A-Z]{3}\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"ABC\", \"[0-9][A-Z]{3}\" ), \"Invalid format for the given RegExp\" );\n\tassert.ok( !method( \"1ABC DEF\", \"[0-9][A-Z]{3}\" ), \"Invalid format for the given RegExp\" );\n\tassert.ok( method( \"1ABCdef\", \"[a-zA-Z0-9]+\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"1ABC def\", \"[a-zA-Z0-9]+\" ), \"Invalid format for the given RegExp\" );\n\tassert.ok( method( \"2014-10-02\", \"[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"02-10-2014\", \"[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])\" ), \"Invalid format for the given RegExp\" );\n} );\n\nfunction testCardTypeByNumber( assert, number, cardname, expected ) {\n\t$( \"#cardnumber\" ).val( number );\n\tvar actual = $( \"#ccform\" ).valid();\n\tassert.equal( actual, expected, $.validator.format( \"Expect card number {0} to validate to {1}, actually validated to \", number, expected ) );\n}\n\nQUnit.test( \"creditcardtypes, all\", function( assert ) {\n\t$( \"#ccform\" ).validate( {\n\t\trules: {\n\t\t\tcardnumber: {\n\t\t\t\tcreditcard: true,\n\t\t\t\tcreditcardtypes: {\n\t\t\t\t\tall: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1111\", \"VISA\", true );\n\ttestCardTypeByNumber( assert, \"2211-1111-1111-1114\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"5111-1111-1111-1118\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"6111-1111-1111-1116\", \"Discover\", true );\n\ttestCardTypeByNumber( assert, \"3400-0000-0000-009\", \"AMEX\", true );\n\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1110\", \"VISA\", false );\n\ttestCardTypeByNumber( assert, \"5432-1111-1111-1111\", \"MasterCard\", false );\n\ttestCardTypeByNumber( assert, \"6611-6611-6611-6611\", \"Discover\", false );\n\ttestCardTypeByNumber( assert, \"3777-7777-7777-7777\", \"AMEX\", false );\n} );\n\nQUnit.test( \"creditcardtypes, visa\", function( assert ) {\n\t$( \"#ccform\" ).validate( {\n\t\trules: {\n\t\t\tcardnumber: {\n\t\t\t\tcreditcard: true,\n\t\t\t\tcreditcardtypes: {\n\t\t\t\t\tvisa: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1111\", \"VISA\", true );\n\ttestCardTypeByNumber( assert, \"5111-1111-1111-1118\", \"MasterCard\", false );\n\ttestCardTypeByNumber( assert, \"6111-1111-1111-1116\", \"Discover\", false );\n\ttestCardTypeByNumber( assert, \"3400-0000-0000-009\", \"AMEX\", false );\n} );\n\nQUnit.test( \"creditcardtypes, mastercard\", function( assert ) {\n\t$( \"#ccform\" ).validate( {\n\t\trules: {\n\t\t\tcardnumber: {\n\t\t\t\tcreditcard: true,\n\t\t\t\tcreditcardtypes: {\n\t\t\t\t\tmastercard: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\ttestCardTypeByNumber( assert, \"2211-1111-1111-1114\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"5111-1111-1111-1118\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"6111-1111-1111-1116\", \"Discover\", false );\n\ttestCardTypeByNumber( assert, \"3400-0000-0000-009\", \"AMEX\", false );\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1111\", \"VISA\", false );\n} );\n\nfunction fillFormWithValuesAndExpect( assert, formSelector, inputValues, expected ) {\n\tvar i, actual;\n\n\tfor ( i = 0; i < inputValues.length; i++ ) {\n\t\t$( formSelector + \" input:eq(\" + i + \")\" ).val( inputValues[ i ] );\n\t}\n\tactual = $( formSelector ).valid();\n\tassert.equal( actual, expected, $.validator.format( \"Filled inputs of form '{0}' with {1} values ({2})\", formSelector, inputValues.length, inputValues.toString() ) );\n\n}\n\nQUnit.test( \"require_from_group\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tdiscount: { require_from_group: [ 2, \".productInfo\" ] }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], false );\n\t$( \"#productInfo input[type='checkbox']\" ).attr( \"checked\", \"checked\" );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], true );\n\t$( \"#productInfo input[type='checkbox']\" ).removeAttr( \"checked\" );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\" ], true );\n} );\n\nQUnit.test( \"require_from_group preserve other rules\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tcolor: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tsupplier: { required: true }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ \"\", \"\", \"\", \"Acme\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"\", \"\", \"Acme\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"\", \"Acme\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\", \"Acme\" ], true );\n} );\n\nQUnit.test( \"skip_or_fill_minimum\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber:  { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tcolor:       { skip_or_fill_minimum: [ 2, \".productInfo\" ] }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\" ], true );\n} );\n\nQUnit.test( \"skip_or_fill_minimum preserve other rules\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber:  { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tcolor:       { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tsupplier: { required: true }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ \"\", \"\", \"\", \"Acme\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"\", \"\", \"Acme\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"\", \"Acme\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\", \"Acme\" ], true );\n} );\n\nQUnit.test( \"zipcodeUS\", function( assert ) {\n\tvar method = methodTest( \"zipcodeUS\" );\n\tassert.ok( method( \"12345\" ), \"Valid zip\" );\n\tassert.ok( method( \"12345-2345\" ), \"Valid zip\" );\n\tassert.ok( method( \"90210-4567\" ), \"Valid zip\" );\n\tassert.ok( !method( \"1\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"1234\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"123-23\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"12345-43\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"123456-7890\" ), \"Invalid zip\" );\n} );\n\nQUnit.test( \"nifES\", function( assert ) {\n\tvar method = methodTest( \"nifES\" );\n\tassert.ok( method( \"11441059P\" ), \"NIF valid\" );\n\tassert.ok( method( \"80054306T\" ), \"NIF valid\" );\n\tassert.ok( method( \"76048581R\" ), \"NIF valid\" );\n\tassert.ok( method( \"28950849J\" ), \"NIF valid\" );\n\tassert.ok( method( \"34048598L\" ), \"NIF valid\" );\n\tassert.ok( method( \"28311529R\" ), \"NIF valid\" );\n\tassert.ok( method( \"34673804Q\" ), \"NIF valid\" );\n\tassert.ok( method( \"92133247P\" ), \"NIF valid\" );\n\tassert.ok( method( \"77149717N\" ), \"NIF valid\" );\n\tassert.ok( method( \"15762034L\" ), \"NIF valid\" );\n\tassert.ok( method( \"05122654W\" ), \"NIF valid\" );\n\tassert.ok( method( \"05122654w\" ), \"NIF valid: lower case\" );\n\tassert.ok( method( \"M1503708Z\" ), \"NIF valid. Temporary foreign nif\" );\n\tassert.ok( !method( \"1144105R\" ), \"NIF invalid: less than 8 digits without zero\" );\n\tassert.ok( !method( \"11441059 R\" ), \"NIF invalid: white space\" );\n\tassert.ok( !method( \"11441059\" ), \"NIF invalid: no letter\" );\n\tassert.ok( !method( \"11441059PR\" ), \"NIF invalid: two letters\" );\n\tassert.ok( !method( \"11440059R\" ), \"NIF invalid: wrong number\" );\n\tassert.ok( !method( \"11441059S\" ), \"NIF invalid: wrong letter\" );\n\tassert.ok( !method( \"114410598R\" ), \"NIF invalid: > 8 digits\" );\n\tassert.ok( !method( \"11441059-R\" ), \"NIF invalid: dash\" );\n\tassert.ok( !method( \"asdasdasd\" ), \"NIF invalid: all letters\" );\n\tassert.ok( !method( \"11.144.059R\" ), \"NIF invalid: two dots\" );\n\tassert.ok( !method( \"05.122.654R\" ), \"NIF invalid: starts with 0 and dots\" );\n\tassert.ok( !method( \"5.122.654-R\" ), \"NIF invalid:  dots and dash\" );\n\tassert.ok( !method( \"05.122.654-R\" ), \"NIF invalid: starts with zero and dot and dash\" );\n} );\n\nQUnit.test( \"nieES\", function( assert ) {\n\tvar method = methodTest( \"nieES\" );\n\tassert.ok( method( \"X0093999K\" ), \"NIE valid\" );\n\tassert.ok( method( \"X1923000Q\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z9669587R\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z8945005B\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z6663465W\" ), \"NIE valid\" );\n\tassert.ok( method( \"Y7875935J\" ), \"NIE valid\" );\n\tassert.ok( method( \"X3390130E\" ), \"NIE valid\" );\n\tassert.ok( method( \"Y7699182S\" ), \"NIE valid\" );\n\tassert.ok( method( \"Y1524243R\" ), \"NIE valid\" );\n\tassert.ok( method( \"X3744072V\" ), \"NIE valid\" );\n\tassert.ok( method( \"X7436800A\" ), \"NIE valid\" );\n\tassert.ok( method( \"X00002153Z\" ), \"NIE valid\" );\n\tassert.ok( method( \"X02323232W\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z0569549M\" ), \"NIE valid\" );\n\tassert.ok( method( \"X0479906B\" ), \"NIE valid\" );\n\tassert.ok( method( \"y7875935j\" ), \"NIE valid: lower case\" );\n\n\tassert.ok( !method( \"X0093999 K\" ), \"NIE invalid: white space\" );\n\tassert.ok( !method( \"X 0093999 K\" ), \"NIE invalid:  white space\" );\n\tassert.ok( !method( \"11441059\" ), \"NIE invalid: no letter\" );\n\tassert.ok( !method( \"11441059PR\" ), \"NIE invalid: two letters\" );\n\tassert.ok( !method( \"11440059R\" ), \"NIE invalid: wrong number\" );\n\tassert.ok( !method( \"11441059S\" ), \"NIE invalid: wrong letter\" );\n\tassert.ok( !method( \"114410598R\" ), \"NIE invalid: > 8 digits\" );\n\tassert.ok( !method( \"11441059-R\" ), \"NIE invalid: dash\" );\n\tassert.ok( !method( \"asdasdasd\" ), \"NIE invalid: all letters\" );\n\tassert.ok( !method( \"11.144.059R\" ), \"NIE invalid: two dots\" );\n\tassert.ok( !method( \"05.122.654R\" ), \"NIE invalid: starts with 0 and dots\" );\n\tassert.ok( !method( \"5.122.654-R\" ), \"NIE invalid: dots and dash\" );\n\tassert.ok( !method( \"05.122.654-R\" ), \"NIE invalid: starts with zero and dot and dash\" );\n} );\n\nQUnit.test( \"cifES\", function( assert ) {\n\tvar method = methodTest( \"cifES\" );\n\tassert.ok( method( \"A58818501\" ), \"CIF valid\" );\n\tassert.ok( method( \"A79082244\" ), \"CIF valid\" );\n\tassert.ok( method( \"A60917978\" ), \"CIF valid\" );\n\tassert.ok( method( \"A39000013\" ), \"CIF valid\" );\n\tassert.ok( method( \"A28315182\" ), \"CIF valid\" );\n\tassert.ok( method( \"A75409573\" ), \"CIF valid\" );\n\tassert.ok( method( \"A34396994\" ), \"CIF valid\" );\n\tassert.ok( method( \"A08153538\" ), \"CIF valid\" );\n\tassert.ok( method( \"A09681396\" ), \"CIF valid\" );\n\tassert.ok( method( \"A06706303\" ), \"CIF valid\" );\n\tassert.ok( method( \"A66242173\" ), \"CIF valid\" );\n\tassert.ok( method( \"A61416699\" ), \"CIF valid\" );\n\tassert.ok( method( \"A99545444\" ), \"CIF valid\" );\n\tassert.ok( method( \"A10407252\" ), \"CIF valid\" );\n\tassert.ok( method( \"A76170885\" ), \"CIF valid\" );\n\tassert.ok( method( \"A83535047\" ), \"CIF valid\" );\n\tassert.ok( method( \"A46031969\" ), \"CIF valid\" );\n\tassert.ok( method( \"A97252910\" ), \"CIF valid\" );\n\tassert.ok( method( \"A79082244\" ), \"CIF valid\" );\n\tassert.ok( !method( \"A7908224D\" ), \"CIF invalid: digit control must be a number (4)\" );\n\n\tassert.ok( method( \"B71413892\" ), \"CIF valid\" );\n\tassert.ok( method( \"B37484755\" ), \"CIF valid\" );\n\tassert.ok( method( \"B15940893\" ), \"CIF valid\" );\n\tassert.ok( method( \"B55429161\" ), \"CIF valid\" );\n\tassert.ok( method( \"B93337087\" ), \"CIF valid\" );\n\tassert.ok( method( \"B43522192\" ), \"CIF valid\" );\n\tassert.ok( method( \"B38624334\" ), \"CIF valid\" );\n\tassert.ok( method( \"B21920426\" ), \"CIF valid\" );\n\tassert.ok( method( \"B74940156\" ), \"CIF valid\" );\n\tassert.ok( method( \"B46125746\" ), \"CIF valid\" );\n\tassert.ok( method( \"B67077537\" ), \"CIF valid\" );\n\tassert.ok( method( \"B21283155\" ), \"CIF valid\" );\n\tassert.ok( method( \"B57104176\" ), \"CIF valid\" );\n\tassert.ok( method( \"B25060179\" ), \"CIF valid\" );\n\tassert.ok( method( \"B06536338\" ), \"CIF valid\" );\n\tassert.ok( method( \"B50964592\" ), \"CIF valid\" );\n\tassert.ok( method( \"B15653330\" ), \"CIF valid\" );\n\tassert.ok( method( \"B83524710\" ), \"CIF valid\" );\n\tassert.ok( !method( \"B8352471J\" ), \"CIF invalid: digit control must be a number (0)\" );\n\n\tassert.ok( !method( \"C27827551\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827552\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827553\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827554\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827555\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827556\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827557\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827558\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827550\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755A\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755B\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755C\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755D\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755E\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755F\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755G\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755H\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755J\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( method( \"C2782755I\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\tassert.ok( method( \"C27827559\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"E48911572\" ), \"CIF valid\" );\n\tassert.ok( method( \"E93928703\" ), \"CIF valid\" );\n\tassert.ok( method( \"E17472952\" ), \"CIF valid\" );\n\tassert.ok( !method( \"E1747295B\" ), \"CIF invalid: digit control must be a number (2)\" );\n\n\tassert.ok( method( \"F41190612\" ), \"CIF valid\" );\n\tassert.ok( method( \"F4119061B\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"G72102064\" ), \"CIF valid\" );\n\tassert.ok( method( \"G32937757\" ), \"CIF valid\" );\n\tassert.ok( method( \"G8984953C\" ), \"CIF valid\" );\n\tassert.ok( method( \"G3370454E\" ), \"CIF valid\" );\n\tassert.ok( method( \"G33704545\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"H48911572\" ), \"CIF valid\" );\n\tassert.ok( method( \"H93928703\" ), \"CIF valid\" );\n\tassert.ok( method( \"H17472952\" ), \"CIF valid\" );\n\tassert.ok( !method( \"H1747295B\" ), \"CIF invalid: digit control must be a number (2)\" );\n\n\tassert.ok( !method( \"I48911572\" ), \"CIF invalid: starts with I\" );\n\n\tassert.ok( method( \"J85081081\" ), \"CIF valid\" );\n\tassert.ok( method( \"J8508108A\" ), \"CIF valid\" );\n\n\tassert.ok( method( \"K3902238I\" ), \"CIF valid\" );\n\tassert.ok( !method( \"K39022389\" ), \"CIF invalid. Digit control must be a letter (I)\" );\n\n\tassert.ok( method( \"M9916080F\" ), \"CIF valid\" );\n\tassert.ok( method( \"M1566151E\" ), \"CIF valid\" );\n\tassert.ok( method( \"M15661515\" ), \"CIF valid\" );\n\tassert.ok( method( \"M4778730D\" ), \"CIF valid\" );\n\n\tassert.ok( method( \"N1172218H\" ), \"CIF valid\" );\n\tassert.ok( method( \"N4094938J\" ), \"CIF valid\" );\n\tassert.ok( method( \"N40949380\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"P5141387J\" ), \"CIF valid\" );\n\tassert.ok( method( \"P9803881C\" ), \"CIF valid\" );\n\tassert.ok( !method( \"P98038813\" ), \"CIF invalid: digit control must be a letter (C)\" );\n\n\tassert.ok( method( \"Q5141387J\" ), \"CIF valid\" );\n\tassert.ok( method( \"Q9803881C\" ), \"CIF valid\" );\n\tassert.ok( !method( \"Q98038813\" ), \"CIF invalid: digit control must be a letter (C)\" );\n\n\tassert.ok( method( \"S5141387J\" ), \"CIF valid\" );\n\tassert.ok( method( \"S9803881C\" ), \"CIF valid\" );\n\tassert.ok( !method( \"S98038813\" ), \"CIF invalid: digit control must be a letter (C)\" );\n\tassert.ok( method( \"s98038813\" ), \"CIF valid: lower case\" );\n\n\tassert.ok( !method( \"X48911572\" ), \"CIF invalid: starts with X\" );\n\tassert.ok( !method( \"Y48911572\" ), \"CIF invalid: starts with Y\" );\n\tassert.ok( !method( \"Z48911572\" ), \"CIF invalid: starts with Z\" );\n\tassert.ok( !method( \"Z98038813\" ), \"CIF invalid: wrong letter\" );\n\tassert.ok( !method( \"B 43522192\" ), \"CIF invalid: white spaces\" );\n\tassert.ok( !method( \"43522192\" ), \"CIF invalid: missing letter\" );\n\tassert.ok( !method( \"BB43522192\" ), \"CIF invalid: two letters\" );\n\tassert.ok( !method( \"B53522192\" ), \"CIF invalid: wrong number\" );\n\tassert.ok( !method( \"B433522192\" ), \"CIF invalid: > 8 digits\" );\n\tassert.ok( !method( \"B3522192\" ), \"CIF invalid: < 8 digits\" );\n\tassert.ok( !method( \"B-43522192\" ), \"CIF invalid: dash\" );\n\tassert.ok( !method( \"Basdasdas\" ), \"CIF invalid: all letters\" );\n\tassert.ok( !method( \"B43.522.192\" ), \"CIF invalid: dots\" );\n\tassert.ok( !method( \"B-43.522.192\" ), \"CIF invalid: dots and dash\" );\n} );\n\nQUnit.test( \"nipPL\", function( assert ) {\n\tvar method = methodTest( \"nipPL\" );\n\tassert.ok( method( \"3514242002\" ), \"NIP valid\" );\n\tassert.ok( method( \"8117892840\" ), \"NIP valid\" );\n\tassert.ok( method( \"7249598309\" ), \"NIP valid\" );\n\tassert.ok( method( \"6853539166\" ), \"NIP valid\" );\n\tassert.ok( method( \"5715750580\" ), \"NIP valid\" );\n\tassert.ok( method( \"3496120813\" ), \"NIP valid\" );\n\tassert.ok( method( \"1565710251\" ), \"NIP valid\" );\n\tassert.ok( method( \"8190761165\" ), \"NIP valid\" );\n\tassert.ok( method( \"9487499667\" ), \"NIP valid\" );\n\tassert.ok( method( \"9283384684\" ), \"NIP valid\" );\n\tassert.ok( method( \"3887569138\" ), \"NIP valid\" );\n\tassert.ok( method( \"3962898856\" ), \"NIP valid\" );\n\tassert.ok( !method( \"76355753\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"454\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"234565545\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"543455\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"6345634563456\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"53453453455335\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"543453760902\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"43090012454\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"3958250194\" ), \"NIP invalid: wrong checksum\" );\n\tassert.ok( !method( \"3928541049\" ), \"NIP invalid: wrong checksum\" );\n\tassert.ok( !method( \"5920397295\" ), \"NIP invalid: wrong checksum\" );\n\tassert.ok( !method( \"9502947712\" ), \"NIP invalid: wrong checksum\" );\n} );\n\nQUnit.test( \"phonePL\", function( assert ) {\n    var method = methodTest( \"phonePL\" );\n\tassert.ok( method( \"+48 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \"00 48 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \"(+48) 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \"(48) 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \" 13 34 56 78  9 \" ), \"Valid phone PL\" );\n\tassert.ok( method( \"13 345 67 89\" ), \"Valid phone PL\" );\n\tassert.ok( !method( \"100 000 000\" ), \"Invalid phone PL: cannot start with 10x xxx xxx\" );\n\tassert.ok( !method( \"111 111 111\" ), \"Invalid phone PL: cannot start with 11x xxx xxx\" );\n\tassert.ok( !method( \"123 456 78\" ), \"Invalid phone PL: too short\" );\n\tassert.ok( !method( \"123 4567890\" ), \"Invalid phone PL: too long\" );\n\tassert.ok( !method( \"700 123 456\" ), \"Invalid phone PL: intelligent network, premium rate\" );\n\tassert.ok( !method( \"800 123 456\" ), \"Invalid phone PL: intelligent network, freephone\" );\n\tassert.ok( !method( \"980 000 000\" ), \"Invalid phone PL: cannot start with 98x xxx xxx\" );\n\tassert.ok( !method( \"990 000 000\" ), \"Invalid phone PL: cannot start with 99x xxx xxx\" );\n} );\n\nQUnit.test( \"maxWords\", function( assert ) {\n\tvar method = methodTest( \"maxWords\" ),\n\t\tmaxWords = 6;\n\n\tassert.ok( method( \"I am a sentence\", maxWords ), \"Max Words\" );\n\tassert.ok( !method( \"I'm way too long for this sentence!\", maxWords ), \"Too many words\" );\n\tassert.ok( method( \"Don\u2019t \u201ccount\u201d me as too long\", maxWords ), \"Right amount of words with smartquotes\" );\n\tassert.ok( !method( \"But you can \u201ccount\u201d me as too long\", maxWords ), \"Too many words with smartquotes\" );\n\tassert.ok( method( \"<div>Don\u2019t \u201ccount\u201d me as too long</div>\", maxWords ), \"Right amount of words with smartquotes w/ HTML\" );\n\tassert.ok( !method( \"<div>But you can \u201ccount\u201d me as too long</div>\", maxWords ), \"Too many words with smartquotes w/ HTML\" );\n} );\n\nQUnit.test( \"minWords\", function( assert ) {\n\tvar method = methodTest( \"minWords\" ),\n\t\tminWords = 6;\n\n\tassert.ok( !method( \"I am a short sentence\", minWords ), \"Max Words\" );\n\tassert.ok( method( \"I'm way too long for this sentence!\", minWords ), \"Too many words\" );\n\tassert.ok( !method( \"Don\u2019t \u201ccount\u201d me as short.\", minWords ), \"Right amount of words with smartquotes\" );\n\tassert.ok( method( \"But you can \u201ccount\u201d me as too short\", minWords ), \"Too many words with smartquotes\" );\n\tassert.ok( !method( \"<div>\u201cCount\u201d me as too short.</div>\", minWords ), \"Right amount of words with smartquotes w/ HTML\" );\n\tassert.ok( method( \"<div>But you can \u201ccount\u201d me as too long</div>\", minWords ), \"Too many words with smartquotes w/ HTML\" );\n} );\n\nQUnit.test( \"rangeWords\", function( assert ) {\n\tvar method = methodTest( \"rangeWords\" ),\n\t\trangeWords = [ 3, 6 ];\n\n\tassert.ok( !method( \"I'm going to be longer than \u201csix words!\u201d\", rangeWords ), \"Longer than 6 with smartquotes\" );\n\tassert.ok( method( \"I'm just the right amount!\", rangeWords ), \"In between\" );\n\tassert.ok( method( \"Super short sentence\u2019s.\", rangeWords ), \"Low end\" );\n\tassert.ok( !method( \"I\", rangeWords ), \"Too short\" );\n\tassert.ok( method( \"<div>\u201cCount\u201d me as perfect.</div>\", rangeWords ), \"Right amount of words with smartquotes w/ HTML\" );\n\tassert.ok( !method( \"<div>But you can \u201ccount\u201d me as too long</div>\", rangeWords ), \"Too many words with smartquotes w/ HTML\" );\n} );\n\nQUnit.test( \"currency\", function( assert ) { // Works with any symbol\n\tvar method = methodTest( \"currency\" );\n\tassert.ok( method( \"\u00a39\", \"\u00a3\" ), \"Symbol no decimal\" );\n\tassert.ok( method( \"\u00a39.9\", \"\u00a3\" ), \"\u00a3, one decimal\" );\n\tassert.ok( method( \"\u00a39.99\", \"\u00a3\" ), \"\u00a3, two decimal\" );\n\tassert.ok( method( \"\u00a39.90\", \"\u00a3\" ), \"Valid currency\" );\n\tassert.ok( method( \"\u00a39,999.9\", \"\u00a3\" ), \"\u00a3, thousand, comma separator, one decimal\" );\n\tassert.ok( method( \"\u00a39,999.99\", \"\u00a3\" ), \"\u00a3, thousand, comma separator, two decimal\" );\n\tassert.ok( method( \"\u00a39,999,999.9\", \"\u00a3\" ), \"\u00a3, million, comma separators, one decimal\" );\n\tassert.ok( method( \"9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9.9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9.99\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9.90\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9,999.9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9,999.99\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9,999,999.9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( !method( \"9,\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9,99.99\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9,\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9.999\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9.999\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9.99,9\", \"\u00a3\" ), \"Invalid currency\" );\n} );\n\nQUnit.test( \"postalCodeCA\", function( assert ) {\n\tvar method = methodTest( \"postalCodeCA\" );\n\tassert.ok( method( \"H0H0H0\" ), \"Valid Canadian postal code: all upper case with no space\" );\n\tassert.ok( method( \"H0H 0H0\" ), \"Valid Canadian postal code: all upper case with one space\" );\n\tassert.ok( method( \"H0H  0H0\" ), \"Valid Canadian postal code: all upper case with multiple spaces\" );\n\tassert.ok( method( \"h0h 0h0\" ), \"Valid Canadian postal code: all lower case with space\" );\n\tassert.ok( method( \"h0h0h0\" ), \"Valid Canadian postal code: all lower case with no space\" );\n\tassert.ok( !method( \"H0H-0H0\" ), \"Invalid Canadian postal code: dash used as separator\" );\n\tassert.ok( !method( \"H0H 0H\" ), \"Invalid Canadian postal code: too short\" );\n\tassert.ok( !method( \"Z0H 0H0\" ), \"Invalid Canadian postal code: only 'ABCEGHJKLMNPRSTVXY' are valid first characters for the Forward Sorting Area\" );\n\tassert.ok( !method( \"H0D 0H0\" ), \"Invalid Canadian postal code: only 'ABCEGHJKLMNPRSTVWXYZ' are valid third characters for the Forward Sorting Area\" );\n\tassert.ok( !method( \"H0H 0D0\" ), \"Invalid Canadian postal code: only 'ABCEGHJKLMNPRSTVWXYZ' are valid second characters for the Local Delivery Unit\" );\n} );\n\nQUnit.test( \"stateUS\", function( assert ) {\n\tvar method = methodTest( \"stateUS\" );\n\tassert.ok( method( \"AZ\" ), \"Valid US state\" );\n\tassert.ok( method( \"OH\" ), \"Valid US state\" );\n\tassert.ok( method( \"DC\" ), \"Valid US state\" );\n\tassert.ok( method( \"PR\", { includeTerritories: true } ), \"Valid US territory\" );\n\tassert.ok( method( \"AA\", { includeMilitary: true } ), \"Valid US military zone\" );\n\tassert.ok( method( \"me\", { caseSensitive: false } ), \"Valid US state\" );\n\tassert.ok( !method( \"az\", { caseSensitive: true } ), \"Must be capital letters\" );\n\tassert.ok( !method( \"mp\", { caseSensitive: false, includeTerritories: false } ), \"US territories not allowed\" );\n} );\n\nQUnit.test( \"postalcodeBR\", function( assert ) {\n\tvar method = methodTest( \"postalcodeBR\" );\n\tassert.ok( method( \"99999-999\" ), \"Valid BR Postal Code\" );\n\tassert.ok( method( \"99999999\" ), \"Valid BR Postal Code\" );\n\tassert.ok( method( \"99.999-999\" ), \"Valid BR Postal Code\" );\n\tassert.ok( !method( \"99.999999\" ), \"Invalid BR Postal Code\" );\n} );\n\nQUnit.test( \"cpfBR\", function( assert ) {\n\tvar method = methodTest( \"cpfBR\" );\n\tassert.ok( method( \"11144477735\" ), \"Valid CPF Number\" );\n\tassert.ok( method( \"263.946.533-30\" ), \"Valid CPF Number\" );\n\tassert.ok( method( \"325 861 044 47\" ), \"Valid CPF Number\" );\n\tassert.ok( method( \"859-684-732-40\" ), \"Valid CPF Number\" );\n\tassert.ok( !method( \"99999999999\" ), \"Invalid CPF Number: dump data\" );\n\tassert.ok( !method( \"1114447773\" ), \"Invalid CPF Number: < 11 digits\" );\n\tassert.ok( !method( \"111444777355\" ), \"Invalid CPF Number: > 11 digits\" );\n\tassert.ok( !method( \"11144477715\" ), \"Invalid CPF Number: 1st check number failed\" );\n\tassert.ok( !method( \"11144477737\" ), \"Invalid CPF Number: 2nd check number failed\" );\n} );\n\nQUnit.test( \"cnpjBR\", function( assert ) {\n\tvar method = methodTest( \"cnpjBR\" );\n\tassert.ok( method( \"18517604000175\" ), \"Valid CNPJ Number\" );\n\tassert.ok( method( \"18.517.604/0001-75\" ), \"Valid CNPJ Number\" );\n\tassert.ok( method( \"06994660000111\" ), \"Valid CNPJ Number\" );\n\tassert.ok( method( \"06.994.660/0001-11\" ), \"Valid CNPJ Number\" );\n\tassert.ok( !method( \"00000000000000\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"11111111111111\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"22222222222222\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"99999999999999\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"8517604000175\" ), \"Invalid CNPJ Number: < 14 digits\" );\n\tassert.ok( !method( \"8.517.604/0001-75\" ), \"Invalid CNPJ Number: < 14 digits\" );\n\tassert.ok( !method( \"1185176040001750\" ), \"Invalid CNPJ Number: > 14 digits\" );\n\tassert.ok( !method( \"18.517.604/0001-750\" ), \"Invalid CNPJ Number: > 14 digits\" );\n\tassert.ok( !method( \"18517604000174\" ), \"Invalid CNPJ Number\" );\n\tassert.ok( !method( \"18.517.604/0001-74\" ), \"Invalid CNPJ Number\" );\n\tassert.ok( !method( \"06994660000211\" ), \"Invalid CNPJ Number\" );\n\tassert.ok( !method( \"06.994.660/0002-11\" ), \"Invalid CNPJ Number\" );\n} );\n\nQUnit.test( \"nisBR\", function( assert ) {\n\tvar method = methodTest( \"nisBR\" );\n\tassert.ok( method( \"10757995753\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107.57995.75-3\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107.579.957-53\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107-579-957-53\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107.579.957.5-3\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( !method( \"99999999999\" ), \"Invalid NIS/PIS Number: dump data\" );\n\tassert.ok( !method( \"1075799575\" ), \"Invalid  NIS/PIS Number: < 11 digits\" );\n\tassert.ok( !method( \"111444777355\" ), \"Invalid NIS/PIS Number: > 11 digits\" );\n\tassert.ok( !method( \"10757995752\" ), \"Invalid NIS/PIS Number: check number failed\" );\n} );\n\nQUnit.test( \"file accept - image wildcard\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"image/*\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - specified mime type\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.kml\", \"application/vnd.google-earth.kml+xml\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"application/vnd.google-earth.kml+xml\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - multiple mimetypes\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"image/png,video/jpeg\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - multiple mimetypes with wildcard\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.mp3\", \"audio/mpeg\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"image/*,audio/*\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - invalid mime type\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.kml\", \"foobar/vnd.google-earth.kml+xml\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"application/vnd.google-earth.kml+xml\" );\n\tassert.equal( proxy(), false, \"the selected file for upload has invalid mime type\" );\n} );\n\nQUnit.test( \"file size - below max\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, \"500001\" );\n\tassert.ok( proxy(), \"the selected file for upload is smaller than max\" );\n} );\n\nQUnit.test( \"file size - over max\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, \"500000\" );\n\tassert.equal( proxy(), false, \"the selected file for upload is greater than max\" );\n} );\n\nQUnit.test( \"file maxsize - valid size\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.ok( proxy(), \"the size of the file does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxsize - valid size for each file\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.ok( proxy(), \"the size of the each file does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxsize - too big\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test.jpg\", size: 500001 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.equal( proxy(), false, \"the size of the file exceeds the maximum\" );\n} );\n\nQUnit.test( \"file maxsize - second file too big\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500001 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.equal( proxy(), false, \"the size of the second file exceeds the maximum\" );\n} );\n\nQUnit.test( \"file maxsizetotal - valid size\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 250000 }, { name: \"test2.jpg\", size: 250000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsizetotal, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.ok( proxy(), \"the size of the files together does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxsizetotal - too big\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 250000 }, { name: \"test2.jpg\", size: 250001 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsizetotal, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.equal( proxy(), false, \"the size of the files together exceeds the maximum\" );\n} );\n\nQUnit.test( \"file maxfiles - valid number\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxfiles, new $.validator( {}, $form[ 0 ] ), null, input, 2 );\n\tassert.ok( proxy(), \"the number of files does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxfiles - too many\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500000 }, { name: \"test3.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxfiles, new $.validator( {}, $form[ 0 ] ), null, input, 2 );\n\tassert.equal( proxy(), false, \"the number of files exceeds the maximum\" );\n} );\n"], "fixing_code": ["// Same as url, but TLD is optional\n$.validator.addMethod( \"url2\", function( value, element ) {\n\treturn this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:(?:[^\\]\\[?\\/<~#`!@$^&*()+=}|:\";',>{ ]|%[0-9A-Fa-f]{2})+(?::(?:[^\\]\\[?\\/<~#`!@$^&*()+=}|:\";',>{ ]|%[0-9A-Fa-f]{2})*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?)|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff])|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62}\\.)))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test( value );\n}, $.validator.messages.url );\n", "$.extend( $.fn, {\n\n\t// https://jqueryvalidation.org/validate/\n\tvalidate: function( options ) {\n\n\t\t// If nothing is selected, return nothing; can't chain anyway\n\t\tif ( !this.length ) {\n\t\t\tif ( options && options.debug && window.console ) {\n\t\t\t\tconsole.warn( \"Nothing selected, can't validate, returning nothing.\" );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if a validator for this form was already created\n\t\tvar validator = $.data( this[ 0 ], \"validator\" );\n\t\tif ( validator ) {\n\t\t\treturn validator;\n\t\t}\n\n\t\t// Add novalidate tag if HTML5.\n\t\tthis.attr( \"novalidate\", \"novalidate\" );\n\n\t\tvalidator = new $.validator( options, this[ 0 ] );\n\t\t$.data( this[ 0 ], \"validator\", validator );\n\n\t\tif ( validator.settings.onsubmit ) {\n\n\t\t\tthis.on( \"click.validate\", \":submit\", function( event ) {\n\n\t\t\t\t// Track the used submit button to properly handle scripted\n\t\t\t\t// submits later.\n\t\t\t\tvalidator.submitButton = event.currentTarget;\n\n\t\t\t\t// Allow suppressing validation by adding a cancel class to the submit button\n\t\t\t\tif ( $( this ).hasClass( \"cancel\" ) ) {\n\t\t\t\t\tvalidator.cancelSubmit = true;\n\t\t\t\t}\n\n\t\t\t\t// Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button\n\t\t\t\tif ( $( this ).attr( \"formnovalidate\" ) !== undefined ) {\n\t\t\t\t\tvalidator.cancelSubmit = true;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Validate the form on submit\n\t\t\tthis.on( \"submit.validate\", function( event ) {\n\t\t\t\tif ( validator.settings.debug ) {\n\n\t\t\t\t\t// Prevent form submit to be able to see console output\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\tfunction handle() {\n\t\t\t\t\tvar hidden, result;\n\n\t\t\t\t\t// Insert a hidden input as a replacement for the missing submit button\n\t\t\t\t\t// The hidden input is inserted in two cases:\n\t\t\t\t\t//   - A user defined a `submitHandler`\n\t\t\t\t\t//   - There was a pending request due to `remote` method and `stopRequest()`\n\t\t\t\t\t//     was called to submit the form in case it's valid\n\t\t\t\t\tif ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {\n\t\t\t\t\t\thidden = $( \"<input type='hidden'/>\" )\n\t\t\t\t\t\t\t.attr( \"name\", validator.submitButton.name )\n\t\t\t\t\t\t\t.val( $( validator.submitButton ).val() )\n\t\t\t\t\t\t\t.appendTo( validator.currentForm );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( validator.settings.submitHandler && !validator.settings.debug ) {\n\t\t\t\t\t\tresult = validator.settings.submitHandler.call( validator, validator.currentForm, event );\n\t\t\t\t\t\tif ( hidden ) {\n\n\t\t\t\t\t\t\t// And clean up afterwards; thanks to no-block-scope, hidden can be referenced\n\t\t\t\t\t\t\thidden.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( result !== undefined ) {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// Prevent submit for invalid forms or custom submit handlers\n\t\t\t\tif ( validator.cancelSubmit ) {\n\t\t\t\t\tvalidator.cancelSubmit = false;\n\t\t\t\t\treturn handle();\n\t\t\t\t}\n\t\t\t\tif ( validator.form() ) {\n\t\t\t\t\tif ( validator.pendingRequest ) {\n\t\t\t\t\t\tvalidator.formSubmitted = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn handle();\n\t\t\t\t} else {\n\t\t\t\t\tvalidator.focusInvalid();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\treturn validator;\n\t},\n\n\t// https://jqueryvalidation.org/valid/\n\tvalid: function() {\n\t\tvar valid, validator, errorList;\n\n\t\tif ( $( this[ 0 ] ).is( \"form\" ) ) {\n\t\t\tvalid = this.validate().form();\n\t\t} else {\n\t\t\terrorList = [];\n\t\t\tvalid = true;\n\t\t\tvalidator = $( this[ 0 ].form ).validate();\n\t\t\tthis.each( function() {\n\t\t\t\tvalid = validator.element( this ) && valid;\n\t\t\t\tif ( !valid ) {\n\t\t\t\t\terrorList = errorList.concat( validator.errorList );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tvalidator.errorList = errorList;\n\t\t}\n\t\treturn valid;\n\t},\n\n\t// https://jqueryvalidation.org/rules/\n\trules: function( command, argument ) {\n\t\tvar element = this[ 0 ],\n\t\t\tisContentEditable = typeof this.attr( \"contenteditable\" ) !== \"undefined\" && this.attr( \"contenteditable\" ) !== \"false\",\n\t\t\tsettings, staticRules, existingRules, data, param, filtered;\n\n\t\t// If nothing is selected, return empty object; can't chain anyway\n\t\tif ( element == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !element.form && isContentEditable ) {\n\t\t\telement.form = this.closest( \"form\" )[ 0 ];\n\t\t\telement.name = this.attr( \"name\" );\n\t\t}\n\n\t\tif ( element.form == null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( command ) {\n\t\t\tsettings = $.data( element.form, \"validator\" ).settings;\n\t\t\tstaticRules = settings.rules;\n\t\t\texistingRules = $.validator.staticRules( element );\n\t\t\tswitch ( command ) {\n\t\t\tcase \"add\":\n\t\t\t\t$.extend( existingRules, $.validator.normalizeRule( argument ) );\n\n\t\t\t\t// Remove messages from rules, but allow them to be set separately\n\t\t\t\tdelete existingRules.messages;\n\t\t\t\tstaticRules[ element.name ] = existingRules;\n\t\t\t\tif ( argument.messages ) {\n\t\t\t\t\tsettings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"remove\":\n\t\t\t\tif ( !argument ) {\n\t\t\t\t\tdelete staticRules[ element.name ];\n\t\t\t\t\treturn existingRules;\n\t\t\t\t}\n\t\t\t\tfiltered = {};\n\t\t\t\t$.each( argument.split( /\\s/ ), function( index, method ) {\n\t\t\t\t\tfiltered[ method ] = existingRules[ method ];\n\t\t\t\t\tdelete existingRules[ method ];\n\t\t\t\t} );\n\t\t\t\treturn filtered;\n\t\t\t}\n\t\t}\n\n\t\tdata = $.validator.normalizeRules(\n\t\t$.extend(\n\t\t\t{},\n\t\t\t$.validator.classRules( element ),\n\t\t\t$.validator.attributeRules( element ),\n\t\t\t$.validator.dataRules( element ),\n\t\t\t$.validator.staticRules( element )\n\t\t), element );\n\n\t\t// Make sure required is at front\n\t\tif ( data.required ) {\n\t\t\tparam = data.required;\n\t\t\tdelete data.required;\n\t\t\tdata = $.extend( { required: param }, data );\n\t\t}\n\n\t\t// Make sure remote is at back\n\t\tif ( data.remote ) {\n\t\t\tparam = data.remote;\n\t\t\tdelete data.remote;\n\t\t\tdata = $.extend( data, { remote: param } );\n\t\t}\n\n\t\treturn data;\n\t}\n} );\n\n// JQuery trim is deprecated, provide a trim method based on String.prototype.trim\nvar trim = function( str ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim#Polyfill\n\treturn str.replace( /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\" );\n};\n\n// Custom selectors\n$.extend( $.expr.pseudos || $.expr[ \":\" ], {\t\t// '|| $.expr[ \":\" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support\n\n\t// https://jqueryvalidation.org/blank-selector/\n\tblank: function( a ) {\n\t\treturn !trim( \"\" + $( a ).val() );\n\t},\n\n\t// https://jqueryvalidation.org/filled-selector/\n\tfilled: function( a ) {\n\t\tvar val = $( a ).val();\n\t\treturn val !== null && !!trim( \"\" + val );\n\t},\n\n\t// https://jqueryvalidation.org/unchecked-selector/\n\tunchecked: function( a ) {\n\t\treturn !$( a ).prop( \"checked\" );\n\t}\n} );\n\n// Constructor for validator\n$.validator = function( options, form ) {\n\tthis.settings = $.extend( true, {}, $.validator.defaults, options );\n\tthis.currentForm = form;\n\tthis.init();\n};\n\n// https://jqueryvalidation.org/jQuery.validator.format/\n$.validator.format = function( source, params ) {\n\tif ( arguments.length === 1 ) {\n\t\treturn function() {\n\t\t\tvar args = $.makeArray( arguments );\n\t\t\targs.unshift( source );\n\t\t\treturn $.validator.format.apply( this, args );\n\t\t};\n\t}\n\tif ( params === undefined ) {\n\t\treturn source;\n\t}\n\tif ( arguments.length > 2 && params.constructor !== Array  ) {\n\t\tparams = $.makeArray( arguments ).slice( 1 );\n\t}\n\tif ( params.constructor !== Array ) {\n\t\tparams = [ params ];\n\t}\n\t$.each( params, function( i, n ) {\n\t\tsource = source.replace( new RegExp( \"\\\\{\" + i + \"\\\\}\", \"g\" ), function() {\n\t\t\treturn n;\n\t\t} );\n\t} );\n\treturn source;\n};\n\n$.extend( $.validator, {\n\n\tdefaults: {\n\t\tmessages: {},\n\t\tgroups: {},\n\t\trules: {},\n\t\terrorClass: \"error\",\n\t\tpendingClass: \"pending\",\n\t\tvalidClass: \"valid\",\n\t\terrorElement: \"label\",\n\t\tfocusCleanup: false,\n\t\tfocusInvalid: true,\n\t\terrorContainer: $( [] ),\n\t\terrorLabelContainer: $( [] ),\n\t\tonsubmit: true,\n\t\tignore: \":hidden\",\n\t\tignoreTitle: false,\n\t\tonfocusin: function( element ) {\n\t\t\tthis.lastActive = element;\n\n\t\t\t// Hide error label and remove error class on focus if enabled\n\t\t\tif ( this.settings.focusCleanup ) {\n\t\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t\tthis.hideThese( this.errorsFor( element ) );\n\t\t\t}\n\t\t},\n\t\tonfocusout: function( element ) {\n\t\t\tif ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {\n\t\t\t\tthis.element( element );\n\t\t\t}\n\t\t},\n\t\tonkeyup: function( element, event ) {\n\n\t\t\t// Avoid revalidate the field when pressing one of the following keys\n\t\t\t// Shift       => 16\n\t\t\t// Ctrl        => 17\n\t\t\t// Alt         => 18\n\t\t\t// Caps lock   => 20\n\t\t\t// End         => 35\n\t\t\t// Home        => 36\n\t\t\t// Left arrow  => 37\n\t\t\t// Up arrow    => 38\n\t\t\t// Right arrow => 39\n\t\t\t// Down arrow  => 40\n\t\t\t// Insert      => 45\n\t\t\t// Num lock    => 144\n\t\t\t// AltGr key   => 225\n\t\t\tvar excludedKeys = [\n\t\t\t\t16, 17, 18, 20, 35, 36, 37,\n\t\t\t\t38, 39, 40, 45, 144, 225\n\t\t\t];\n\n\t\t\tif ( event.which === 9 && this.elementValue( element ) === \"\" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {\n\t\t\t\treturn;\n\t\t\t} else if ( element.name in this.submitted || element.name in this.invalid ) {\n\t\t\t\tthis.element( element );\n\t\t\t}\n\t\t},\n\t\tonclick: function( element ) {\n\n\t\t\t// Click on selects, radiobuttons and checkboxes\n\t\t\tif ( element.name in this.submitted ) {\n\t\t\t\tthis.element( element );\n\n\t\t\t// Or option elements, check parent select in that case\n\t\t\t} else if ( element.parentNode.name in this.submitted ) {\n\t\t\t\tthis.element( element.parentNode );\n\t\t\t}\n\t\t},\n\t\thighlight: function( element, errorClass, validClass ) {\n\t\t\tif ( element.type === \"radio\" ) {\n\t\t\t\tthis.findByName( element.name ).addClass( errorClass ).removeClass( validClass );\n\t\t\t} else {\n\t\t\t\t$( element ).addClass( errorClass ).removeClass( validClass );\n\t\t\t}\n\t\t},\n\t\tunhighlight: function( element, errorClass, validClass ) {\n\t\t\tif ( element.type === \"radio\" ) {\n\t\t\t\tthis.findByName( element.name ).removeClass( errorClass ).addClass( validClass );\n\t\t\t} else {\n\t\t\t\t$( element ).removeClass( errorClass ).addClass( validClass );\n\t\t\t}\n\t\t}\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.setDefaults/\n\tsetDefaults: function( settings ) {\n\t\t$.extend( $.validator.defaults, settings );\n\t},\n\n\tmessages: {\n\t\trequired: \"This field is required.\",\n\t\tremote: \"Please fix this field.\",\n\t\temail: \"Please enter a valid email address.\",\n\t\turl: \"Please enter a valid URL.\",\n\t\tdate: \"Please enter a valid date.\",\n\t\tdateISO: \"Please enter a valid date (ISO).\",\n\t\tnumber: \"Please enter a valid number.\",\n\t\tdigits: \"Please enter only digits.\",\n\t\tequalTo: \"Please enter the same value again.\",\n\t\tmaxlength: $.validator.format( \"Please enter no more than {0} characters.\" ),\n\t\tminlength: $.validator.format( \"Please enter at least {0} characters.\" ),\n\t\trangelength: $.validator.format( \"Please enter a value between {0} and {1} characters long.\" ),\n\t\trange: $.validator.format( \"Please enter a value between {0} and {1}.\" ),\n\t\tmax: $.validator.format( \"Please enter a value less than or equal to {0}.\" ),\n\t\tmin: $.validator.format( \"Please enter a value greater than or equal to {0}.\" ),\n\t\tstep: $.validator.format( \"Please enter a multiple of {0}.\" )\n\t},\n\n\tautoCreateRanges: false,\n\n\tprototype: {\n\n\t\tinit: function() {\n\t\t\tthis.labelContainer = $( this.settings.errorLabelContainer );\n\t\t\tthis.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );\n\t\t\tthis.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );\n\t\t\tthis.submitted = {};\n\t\t\tthis.valueCache = {};\n\t\t\tthis.pendingRequest = 0;\n\t\t\tthis.pending = {};\n\t\t\tthis.invalid = {};\n\t\t\tthis.reset();\n\n\t\t\tvar currentForm = this.currentForm,\n\t\t\t\tgroups = ( this.groups = {} ),\n\t\t\t\trules;\n\t\t\t$.each( this.settings.groups, function( key, value ) {\n\t\t\t\tif ( typeof value === \"string\" ) {\n\t\t\t\t\tvalue = value.split( /\\s/ );\n\t\t\t\t}\n\t\t\t\t$.each( value, function( index, name ) {\n\t\t\t\t\tgroups[ name ] = key;\n\t\t\t\t} );\n\t\t\t} );\n\t\t\trules = this.settings.rules;\n\t\t\t$.each( rules, function( key, value ) {\n\t\t\t\trules[ key ] = $.validator.normalizeRule( value );\n\t\t\t} );\n\n\t\t\tfunction delegate( event ) {\n\t\t\t\tvar isContentEditable = typeof $( this ).attr( \"contenteditable\" ) !== \"undefined\" && $( this ).attr( \"contenteditable\" ) !== \"false\";\n\n\t\t\t\t// Set form expando on contenteditable\n\t\t\t\tif ( !this.form && isContentEditable ) {\n\t\t\t\t\tthis.form = $( this ).closest( \"form\" )[ 0 ];\n\t\t\t\t\tthis.name = $( this ).attr( \"name\" );\n\t\t\t\t}\n\n\t\t\t\t// Ignore the element if it belongs to another form. This will happen mainly\n\t\t\t\t// when setting the `form` attribute of an input to the id of another form.\n\t\t\t\tif ( currentForm !== this.form ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar validator = $.data( this.form, \"validator\" ),\n\t\t\t\t\teventType = \"on\" + event.type.replace( /^validate/, \"\" ),\n\t\t\t\t\tsettings = validator.settings;\n\t\t\t\tif ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {\n\t\t\t\t\tsettings[ eventType ].call( validator, this, event );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$( this.currentForm )\n\t\t\t\t.on( \"focusin.validate focusout.validate keyup.validate\",\n\t\t\t\t\t\":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], \" +\n\t\t\t\t\t\"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], \" +\n\t\t\t\t\t\"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], \" +\n\t\t\t\t\t\"[type='radio'], [type='checkbox'], [contenteditable], [type='button']\", delegate )\n\n\t\t\t\t// Support: Chrome, oldIE\n\t\t\t\t// \"select\" is provided as event.target when clicking a option\n\t\t\t\t.on( \"click.validate\", \"select, option, [type='radio'], [type='checkbox']\", delegate );\n\n\t\t\tif ( this.settings.invalidHandler ) {\n\t\t\t\t$( this.currentForm ).on( \"invalid-form.validate\", this.settings.invalidHandler );\n\t\t\t}\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.form/\n\t\tform: function() {\n\t\t\tthis.checkForm();\n\t\t\t$.extend( this.submitted, this.errorMap );\n\t\t\tthis.invalid = $.extend( {}, this.errorMap );\n\t\t\tif ( !this.valid() ) {\n\t\t\t\t$( this.currentForm ).triggerHandler( \"invalid-form\", [ this ] );\n\t\t\t}\n\t\t\tthis.showErrors();\n\t\t\treturn this.valid();\n\t\t},\n\n\t\tcheckForm: function() {\n\t\t\tthis.prepareForm();\n\t\t\tfor ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {\n\t\t\t\tthis.check( elements[ i ] );\n\t\t\t}\n\t\t\treturn this.valid();\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.element/\n\t\telement: function( element ) {\n\t\t\tvar cleanElement = this.clean( element ),\n\t\t\t\tcheckElement = this.validationTargetFor( cleanElement ),\n\t\t\t\tv = this,\n\t\t\t\tresult = true,\n\t\t\t\trs, group;\n\n\t\t\tif ( checkElement === undefined ) {\n\t\t\t\tdelete this.invalid[ cleanElement.name ];\n\t\t\t} else {\n\t\t\t\tthis.prepareElement( checkElement );\n\t\t\t\tthis.currentElements = $( checkElement );\n\n\t\t\t\t// If this element is grouped, then validate all group elements already\n\t\t\t\t// containing a value\n\t\t\t\tgroup = this.groups[ checkElement.name ];\n\t\t\t\tif ( group ) {\n\t\t\t\t\t$.each( this.groups, function( name, testgroup ) {\n\t\t\t\t\t\tif ( testgroup === group && name !== checkElement.name ) {\n\t\t\t\t\t\t\tcleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );\n\t\t\t\t\t\t\tif ( cleanElement && cleanElement.name in v.invalid ) {\n\t\t\t\t\t\t\t\tv.currentElements.push( cleanElement );\n\t\t\t\t\t\t\t\tresult = v.check( cleanElement ) && result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\trs = this.check( checkElement ) !== false;\n\t\t\t\tresult = result && rs;\n\t\t\t\tif ( rs ) {\n\t\t\t\t\tthis.invalid[ checkElement.name ] = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.invalid[ checkElement.name ] = true;\n\t\t\t\t}\n\n\t\t\t\tif ( !this.numberOfInvalids() ) {\n\n\t\t\t\t\t// Hide error containers on last error\n\t\t\t\t\tthis.toHide = this.toHide.add( this.containers );\n\t\t\t\t}\n\t\t\t\tthis.showErrors();\n\n\t\t\t\t// Add aria-invalid status for screen readers\n\t\t\t\t$( element ).attr( \"aria-invalid\", !rs );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.showErrors/\n\t\tshowErrors: function( errors ) {\n\t\t\tif ( errors ) {\n\t\t\t\tvar validator = this;\n\n\t\t\t\t// Add items to error list and map\n\t\t\t\t$.extend( this.errorMap, errors );\n\t\t\t\tthis.errorList = $.map( this.errorMap, function( message, name ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmessage: message,\n\t\t\t\t\t\telement: validator.findByName( name )[ 0 ]\n\t\t\t\t\t};\n\t\t\t\t} );\n\n\t\t\t\t// Remove items from success list\n\t\t\t\tthis.successList = $.grep( this.successList, function( element ) {\n\t\t\t\t\treturn !( element.name in errors );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tif ( this.settings.showErrors ) {\n\t\t\t\tthis.settings.showErrors.call( this, this.errorMap, this.errorList );\n\t\t\t} else {\n\t\t\t\tthis.defaultShowErrors();\n\t\t\t}\n\t\t},\n\n\t\t// https://jqueryvalidation.org/Validator.resetForm/\n\t\tresetForm: function() {\n\t\t\tif ( $.fn.resetForm ) {\n\t\t\t\t$( this.currentForm ).resetForm();\n\t\t\t}\n\t\t\tthis.invalid = {};\n\t\t\tthis.submitted = {};\n\t\t\tthis.prepareForm();\n\t\t\tthis.hideErrors();\n\t\t\tvar elements = this.elements()\n\t\t\t\t.removeData( \"previousValue\" )\n\t\t\t\t.removeAttr( \"aria-invalid\" );\n\n\t\t\tthis.resetElements( elements );\n\t\t},\n\n\t\tresetElements: function( elements ) {\n\t\t\tvar i;\n\n\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\tfor ( i = 0; elements[ i ]; i++ ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, elements[ i ],\n\t\t\t\t\t\tthis.settings.errorClass, \"\" );\n\t\t\t\t\tthis.findByName( elements[ i ].name ).removeClass( this.settings.validClass );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements\n\t\t\t\t\t.removeClass( this.settings.errorClass )\n\t\t\t\t\t.removeClass( this.settings.validClass );\n\t\t\t}\n\t\t},\n\n\t\tnumberOfInvalids: function() {\n\t\t\treturn this.objectLength( this.invalid );\n\t\t},\n\n\t\tobjectLength: function( obj ) {\n\t\t\t/* jshint unused: false */\n\t\t\tvar count = 0,\n\t\t\t\ti;\n\t\t\tfor ( i in obj ) {\n\n\t\t\t\t// This check allows counting elements with empty error\n\t\t\t\t// message as invalid elements\n\t\t\t\tif ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\n\t\thideErrors: function() {\n\t\t\tthis.hideThese( this.toHide );\n\t\t},\n\n\t\thideThese: function( errors ) {\n\t\t\terrors.not( this.containers ).text( \"\" );\n\t\t\tthis.addWrapper( errors ).hide();\n\t\t},\n\n\t\tvalid: function() {\n\t\t\treturn this.size() === 0;\n\t\t},\n\n\t\tsize: function() {\n\t\t\treturn this.errorList.length;\n\t\t},\n\n\t\tfocusInvalid: function() {\n\t\t\tif ( this.settings.focusInvalid ) {\n\t\t\t\ttry {\n\t\t\t\t\t$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )\n\t\t\t\t\t.filter( \":visible\" )\n\t\t\t\t\t.trigger( \"focus\" )\n\n\t\t\t\t\t// Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find\n\t\t\t\t\t.trigger( \"focusin\" );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// Ignore IE throwing errors when focusing hidden elements\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tfindLastActive: function() {\n\t\t\tvar lastActive = this.lastActive;\n\t\t\treturn lastActive && $.grep( this.errorList, function( n ) {\n\t\t\t\treturn n.element.name === lastActive.name;\n\t\t\t} ).length === 1 && lastActive;\n\t\t},\n\n\t\telements: function() {\n\t\t\tvar validator = this,\n\t\t\t\trulesCache = {};\n\n\t\t\t// Select all valid inputs inside the form (no submit or reset buttons)\n\t\t\treturn $( this.currentForm )\n\t\t\t.find( \"input, select, textarea, [contenteditable]\" )\n\t\t\t.not( \":submit, :reset, :image, :disabled\" )\n\t\t\t.not( this.settings.ignore )\n\t\t\t.filter( function() {\n\t\t\t\tvar name = this.name || $( this ).attr( \"name\" ); // For contenteditable\n\t\t\t\tvar isContentEditable = typeof $( this ).attr( \"contenteditable\" ) !== \"undefined\" && $( this ).attr( \"contenteditable\" ) !== \"false\";\n\n\t\t\t\tif ( !name && validator.settings.debug && window.console ) {\n\t\t\t\t\tconsole.error( \"%o has no name assigned\", this );\n\t\t\t\t}\n\n\t\t\t\t// Set form expando on contenteditable\n\t\t\t\tif ( isContentEditable ) {\n\t\t\t\t\tthis.form = $( this ).closest( \"form\" )[ 0 ];\n\t\t\t\t\tthis.name = name;\n\t\t\t\t}\n\n\t\t\t\t// Ignore elements that belong to other/nested forms\n\t\t\t\tif ( this.form !== validator.currentForm ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Select only the first element for each name, and only those with rules specified\n\t\t\t\tif ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\trulesCache[ name ] = true;\n\t\t\t\treturn true;\n\t\t\t} );\n\t\t},\n\n\t\tclean: function( selector ) {\n\t\t\treturn $( selector )[ 0 ];\n\t\t},\n\n\t\terrors: function() {\n\t\t\tvar errorClass = this.settings.errorClass.split( \" \" ).join( \".\" );\n\t\t\treturn $( this.settings.errorElement + \".\" + errorClass, this.errorContext );\n\t\t},\n\n\t\tresetInternals: function() {\n\t\t\tthis.successList = [];\n\t\t\tthis.errorList = [];\n\t\t\tthis.errorMap = {};\n\t\t\tthis.toShow = $( [] );\n\t\t\tthis.toHide = $( [] );\n\t\t},\n\n\t\treset: function() {\n\t\t\tthis.resetInternals();\n\t\t\tthis.currentElements = $( [] );\n\t\t},\n\n\t\tprepareForm: function() {\n\t\t\tthis.reset();\n\t\t\tthis.toHide = this.errors().add( this.containers );\n\t\t},\n\n\t\tprepareElement: function( element ) {\n\t\t\tthis.reset();\n\t\t\tthis.toHide = this.errorsFor( element );\n\t\t},\n\n\t\telementValue: function( element ) {\n\t\t\tvar $element = $( element ),\n\t\t\t\ttype = element.type,\n\t\t\t\tisContentEditable = typeof $element.attr( \"contenteditable\" ) !== \"undefined\" && $element.attr( \"contenteditable\" ) !== \"false\",\n\t\t\t\tval, idx;\n\n\t\t\tif ( type === \"radio\" || type === \"checkbox\" ) {\n\t\t\t\treturn this.findByName( element.name ).filter( \":checked\" ).val();\n\t\t\t} else if ( type === \"number\" && typeof element.validity !== \"undefined\" ) {\n\t\t\t\treturn element.validity.badInput ? \"NaN\" : $element.val();\n\t\t\t}\n\n\t\t\tif ( isContentEditable ) {\n\t\t\t\tval = $element.text();\n\t\t\t} else {\n\t\t\t\tval = $element.val();\n\t\t\t}\n\n\t\t\tif ( type === \"file\" ) {\n\n\t\t\t\t// Modern browser (chrome & safari)\n\t\t\t\tif ( val.substr( 0, 12 ) === \"C:\\\\fakepath\\\\\" ) {\n\t\t\t\t\treturn val.substr( 12 );\n\t\t\t\t}\n\n\t\t\t\t// Legacy browsers\n\t\t\t\t// Unix-based path\n\t\t\t\tidx = val.lastIndexOf( \"/\" );\n\t\t\t\tif ( idx >= 0 ) {\n\t\t\t\t\treturn val.substr( idx + 1 );\n\t\t\t\t}\n\n\t\t\t\t// Windows-based path\n\t\t\t\tidx = val.lastIndexOf( \"\\\\\" );\n\t\t\t\tif ( idx >= 0 ) {\n\t\t\t\t\treturn val.substr( idx + 1 );\n\t\t\t\t}\n\n\t\t\t\t// Just the file name\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\tif ( typeof val === \"string\" ) {\n\t\t\t\treturn val.replace( /\\r/g, \"\" );\n\t\t\t}\n\t\t\treturn val;\n\t\t},\n\n\t\tcheck: function( element ) {\n\t\t\telement = this.validationTargetFor( this.clean( element ) );\n\n\t\t\tvar rules = $( element ).rules(),\n\t\t\t\trulesCount = $.map( rules, function( n, i ) {\n\t\t\t\t\treturn i;\n\t\t\t\t} ).length,\n\t\t\t\tdependencyMismatch = false,\n\t\t\t\tval = this.elementValue( element ),\n\t\t\t\tresult, method, rule, normalizer;\n\n\t\t\t// Prioritize the local normalizer defined for this element over the global one\n\t\t\t// if the former exists, otherwise user the global one in case it exists.\n\t\t\tif ( typeof rules.normalizer === \"function\" ) {\n\t\t\t\tnormalizer = rules.normalizer;\n\t\t\t} else if (\ttypeof this.settings.normalizer === \"function\" ) {\n\t\t\t\tnormalizer = this.settings.normalizer;\n\t\t\t}\n\n\t\t\t// If normalizer is defined, then call it to retreive the changed value instead\n\t\t\t// of using the real one.\n\t\t\t// Note that `this` in the normalizer is `element`.\n\t\t\tif ( normalizer ) {\n\t\t\t\tval = normalizer.call( element, val );\n\n\t\t\t\t// Delete the normalizer from rules to avoid treating it as a pre-defined method.\n\t\t\t\tdelete rules.normalizer;\n\t\t\t}\n\n\t\t\tfor ( method in rules ) {\n\t\t\t\trule = { method: method, parameters: rules[ method ] };\n\t\t\t\ttry {\n\t\t\t\t\tresult = $.validator.methods[ method ].call( this, val, element, rule.parameters );\n\n\t\t\t\t\t// If a method indicates that the field is optional and therefore valid,\n\t\t\t\t\t// don't mark it as valid when there are no other rules\n\t\t\t\t\tif ( result === \"dependency-mismatch\" && rulesCount === 1 ) {\n\t\t\t\t\t\tdependencyMismatch = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdependencyMismatch = false;\n\n\t\t\t\t\tif ( result === \"pending\" ) {\n\t\t\t\t\t\tthis.toHide = this.toHide.not( this.errorsFor( element ) );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !result ) {\n\t\t\t\t\t\tthis.formatAndAdd( element, rule );\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tif ( this.settings.debug && window.console ) {\n\t\t\t\t\t\tconsole.log( \"Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\", e );\n\t\t\t\t\t}\n\t\t\t\t\tif ( e instanceof TypeError ) {\n\t\t\t\t\t\te.message += \".  Exception occurred when checking element \" + element.id + \", check the '\" + rule.method + \"' method.\";\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( dependencyMismatch ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( this.objectLength( rules ) ) {\n\t\t\t\tthis.successList.push( element );\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t// Return the custom message for the given element and validation method\n\t\t// specified in the element's HTML5 data attribute\n\t\t// return the generic message if present and no method specific message is present\n\t\tcustomDataMessage: function( element, method ) {\n\t\t\treturn $( element ).data( \"msg\" + method.charAt( 0 ).toUpperCase() +\n\t\t\t\tmethod.substring( 1 ).toLowerCase() ) || $( element ).data( \"msg\" );\n\t\t},\n\n\t\t// Return the custom message for the given element name and validation method\n\t\tcustomMessage: function( name, method ) {\n\t\t\tvar m = this.settings.messages[ name ];\n\t\t\treturn m && ( m.constructor === String ? m : m[ method ] );\n\t\t},\n\n\t\t// Return the first defined argument, allowing empty strings\n\t\tfindDefined: function() {\n\t\t\tfor ( var i = 0; i < arguments.length; i++ ) {\n\t\t\t\tif ( arguments[ i ] !== undefined ) {\n\t\t\t\t\treturn arguments[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t},\n\n\t\t// The second parameter 'rule' used to be a string, and extended to an object literal\n\t\t// of the following form:\n\t\t// rule = {\n\t\t//     method: \"method name\",\n\t\t//     parameters: \"the given method parameters\"\n\t\t// }\n\t\t//\n\t\t// The old behavior still supported, kept to maintain backward compatibility with\n\t\t// old code, and will be removed in the next major release.\n\t\tdefaultMessage: function( element, rule ) {\n\t\t\tif ( typeof rule === \"string\" ) {\n\t\t\t\trule = { method: rule };\n\t\t\t}\n\n\t\t\tvar message = this.findDefined(\n\t\t\t\t\tthis.customMessage( element.name, rule.method ),\n\t\t\t\t\tthis.customDataMessage( element, rule.method ),\n\n\t\t\t\t\t// 'title' is never undefined, so handle empty string as undefined\n\t\t\t\t\t!this.settings.ignoreTitle && element.title || undefined,\n\t\t\t\t\t$.validator.messages[ rule.method ],\n\t\t\t\t\t\"<strong>Warning: No message defined for \" + element.name + \"</strong>\"\n\t\t\t\t),\n\t\t\t\ttheregex = /\\$?\\{(\\d+)\\}/g;\n\t\t\tif ( typeof message === \"function\" ) {\n\t\t\t\tmessage = message.call( this, rule.parameters, element );\n\t\t\t} else if ( theregex.test( message ) ) {\n\t\t\t\tmessage = $.validator.format( message.replace( theregex, \"{$1}\" ), rule.parameters );\n\t\t\t}\n\n\t\t\treturn message;\n\t\t},\n\n\t\tformatAndAdd: function( element, rule ) {\n\t\t\tvar message = this.defaultMessage( element, rule );\n\n\t\t\tthis.errorList.push( {\n\t\t\t\tmessage: message,\n\t\t\t\telement: element,\n\t\t\t\tmethod: rule.method\n\t\t\t} );\n\n\t\t\tthis.errorMap[ element.name ] = message;\n\t\t\tthis.submitted[ element.name ] = message;\n\t\t},\n\n\t\taddWrapper: function( toToggle ) {\n\t\t\tif ( this.settings.wrapper ) {\n\t\t\t\ttoToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );\n\t\t\t}\n\t\t\treturn toToggle;\n\t\t},\n\n\t\tdefaultShowErrors: function() {\n\t\t\tvar i, elements, error;\n\t\t\tfor ( i = 0; this.errorList[ i ]; i++ ) {\n\t\t\t\terror = this.errorList[ i ];\n\t\t\t\tif ( this.settings.highlight ) {\n\t\t\t\t\tthis.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t\tthis.showLabel( error.element, error.message );\n\t\t\t}\n\t\t\tif ( this.errorList.length ) {\n\t\t\t\tthis.toShow = this.toShow.add( this.containers );\n\t\t\t}\n\t\t\tif ( this.settings.success ) {\n\t\t\t\tfor ( i = 0; this.successList[ i ]; i++ ) {\n\t\t\t\t\tthis.showLabel( this.successList[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( this.settings.unhighlight ) {\n\t\t\t\tfor ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {\n\t\t\t\t\tthis.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.toHide = this.toHide.not( this.toShow );\n\t\t\tthis.hideErrors();\n\t\t\tthis.addWrapper( this.toShow ).show();\n\t\t},\n\n\t\tvalidElements: function() {\n\t\t\treturn this.currentElements.not( this.invalidElements() );\n\t\t},\n\n\t\tinvalidElements: function() {\n\t\t\treturn $( this.errorList ).map( function() {\n\t\t\t\treturn this.element;\n\t\t\t} );\n\t\t},\n\n\t\tshowLabel: function( element, message ) {\n\t\t\tvar place, group, errorID, v,\n\t\t\t\terror = this.errorsFor( element ),\n\t\t\t\telementID = this.idOrName( element ),\n\t\t\t\tdescribedBy = $( element ).attr( \"aria-describedby\" );\n\n\t\t\tif ( error.length ) {\n\n\t\t\t\t// Refresh error/success class\n\t\t\t\terror.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );\n\n\t\t\t\t// Replace message on existing label\n\t\t\t\terror.html( message );\n\t\t\t} else {\n\n\t\t\t\t// Create error element\n\t\t\t\terror = $( \"<\" + this.settings.errorElement + \">\" )\n\t\t\t\t\t.attr( \"id\", elementID + \"-error\" )\n\t\t\t\t\t.addClass( this.settings.errorClass )\n\t\t\t\t\t.html( message || \"\" );\n\n\t\t\t\t// Maintain reference to the element to be placed into the DOM\n\t\t\t\tplace = error;\n\t\t\t\tif ( this.settings.wrapper ) {\n\n\t\t\t\t\t// Make sure the element is visible, even in IE\n\t\t\t\t\t// actually showing the wrapped element is handled elsewhere\n\t\t\t\t\tplace = error.hide().show().wrap( \"<\" + this.settings.wrapper + \"/>\" ).parent();\n\t\t\t\t}\n\t\t\t\tif ( this.labelContainer.length ) {\n\t\t\t\t\tthis.labelContainer.append( place );\n\t\t\t\t} else if ( this.settings.errorPlacement ) {\n\t\t\t\t\tthis.settings.errorPlacement.call( this, place, $( element ) );\n\t\t\t\t} else {\n\t\t\t\t\tplace.insertAfter( element );\n\t\t\t\t}\n\n\t\t\t\t// Link error back to the element\n\t\t\t\tif ( error.is( \"label\" ) ) {\n\n\t\t\t\t\t// If the error is a label, then associate using 'for'\n\t\t\t\t\terror.attr( \"for\", elementID );\n\n\t\t\t\t\t// If the element is not a child of an associated label, then it's necessary\n\t\t\t\t\t// to explicitly apply aria-describedby\n\t\t\t\t} else if ( error.parents( \"label[for='\" + this.escapeCssMeta( elementID ) + \"']\" ).length === 0 ) {\n\t\t\t\t\terrorID = error.attr( \"id\" );\n\n\t\t\t\t\t// Respect existing non-error aria-describedby\n\t\t\t\t\tif ( !describedBy ) {\n\t\t\t\t\t\tdescribedBy = errorID;\n\t\t\t\t\t} else if ( !describedBy.match( new RegExp( \"\\\\b\" + this.escapeCssMeta( errorID ) + \"\\\\b\" ) ) ) {\n\n\t\t\t\t\t\t// Add to end of list if not already present\n\t\t\t\t\t\tdescribedBy += \" \" + errorID;\n\t\t\t\t\t}\n\t\t\t\t\t$( element ).attr( \"aria-describedby\", describedBy );\n\n\t\t\t\t\t// If this element is grouped, then assign to all elements in the same group\n\t\t\t\t\tgroup = this.groups[ element.name ];\n\t\t\t\t\tif ( group ) {\n\t\t\t\t\t\tv = this;\n\t\t\t\t\t\t$.each( v.groups, function( name, testgroup ) {\n\t\t\t\t\t\t\tif ( testgroup === group ) {\n\t\t\t\t\t\t\t\t$( \"[name='\" + v.escapeCssMeta( name ) + \"']\", v.currentForm )\n\t\t\t\t\t\t\t\t\t.attr( \"aria-describedby\", error.attr( \"id\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !message && this.settings.success ) {\n\t\t\t\terror.text( \"\" );\n\t\t\t\tif ( typeof this.settings.success === \"string\" ) {\n\t\t\t\t\terror.addClass( this.settings.success );\n\t\t\t\t} else {\n\t\t\t\t\tthis.settings.success( error, element );\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.toShow = this.toShow.add( error );\n\t\t},\n\n\t\terrorsFor: function( element ) {\n\t\t\tvar name = this.escapeCssMeta( this.idOrName( element ) ),\n\t\t\t\tdescriber = $( element ).attr( \"aria-describedby\" ),\n\t\t\t\tselector = \"label[for='\" + name + \"'], label[for='\" + name + \"'] *\";\n\n\t\t\t// 'aria-describedby' should directly reference the error element\n\t\t\tif ( describer ) {\n\t\t\t\tselector = selector + \", #\" + this.escapeCssMeta( describer )\n\t\t\t\t\t.replace( /\\s+/g, \", #\" );\n\t\t\t}\n\n\t\t\treturn this\n\t\t\t\t.errors()\n\t\t\t\t.filter( selector );\n\t\t},\n\n\t\t// See https://api.jquery.com/category/selectors/, for CSS\n\t\t// meta-characters that should be escaped in order to be used with JQuery\n\t\t// as a literal part of a name/id or any selector.\n\t\tescapeCssMeta: function( string ) {\n\t\t\tif ( string === undefined ) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn string.replace( /([\\\\!\"#$%&'()*+,./:;<=>?@\\[\\]^`{|}~])/g, \"\\\\$1\" );\n\t\t},\n\n\t\tidOrName: function( element ) {\n\t\t\treturn this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );\n\t\t},\n\n\t\tvalidationTargetFor: function( element ) {\n\n\t\t\t// If radio/checkbox, validate first element in group instead\n\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\telement = this.findByName( element.name );\n\t\t\t}\n\n\t\t\t// Always apply ignore filter\n\t\t\treturn $( element ).not( this.settings.ignore )[ 0 ];\n\t\t},\n\n\t\tcheckable: function( element ) {\n\t\t\treturn ( /radio|checkbox/i ).test( element.type );\n\t\t},\n\n\t\tfindByName: function( name ) {\n\t\t\treturn $( this.currentForm ).find( \"[name='\" + this.escapeCssMeta( name ) + \"']\" );\n\t\t},\n\n\t\tgetLength: function( value, element ) {\n\t\t\tswitch ( element.nodeName.toLowerCase() ) {\n\t\t\tcase \"select\":\n\t\t\t\treturn $( \"option:selected\", element ).length;\n\t\t\tcase \"input\":\n\t\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\t\treturn this.findByName( element.name ).filter( \":checked\" ).length;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value.length;\n\t\t},\n\n\t\tdepend: function( param, element ) {\n\t\t\treturn this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;\n\t\t},\n\n\t\tdependTypes: {\n\t\t\t\"boolean\": function( param ) {\n\t\t\t\treturn param;\n\t\t\t},\n\t\t\t\"string\": function( param, element ) {\n\t\t\t\treturn !!$( param, element.form ).length;\n\t\t\t},\n\t\t\t\"function\": function( param, element ) {\n\t\t\t\treturn param( element );\n\t\t\t}\n\t\t},\n\n\t\toptional: function( element ) {\n\t\t\tvar val = this.elementValue( element );\n\t\t\treturn !$.validator.methods.required.call( this, val, element ) && \"dependency-mismatch\";\n\t\t},\n\n\t\tstartRequest: function( element ) {\n\t\t\tif ( !this.pending[ element.name ] ) {\n\t\t\t\tthis.pendingRequest++;\n\t\t\t\t$( element ).addClass( this.settings.pendingClass );\n\t\t\t\tthis.pending[ element.name ] = true;\n\t\t\t}\n\t\t},\n\n\t\tstopRequest: function( element, valid ) {\n\t\t\tthis.pendingRequest--;\n\n\t\t\t// Sometimes synchronization fails, make sure pendingRequest is never < 0\n\t\t\tif ( this.pendingRequest < 0 ) {\n\t\t\t\tthis.pendingRequest = 0;\n\t\t\t}\n\t\t\tdelete this.pending[ element.name ];\n\t\t\t$( element ).removeClass( this.settings.pendingClass );\n\t\t\tif ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() && this.pendingRequest === 0 ) {\n\t\t\t\t$( this.currentForm ).trigger( \"submit\" );\n\n\t\t\t\t// Remove the hidden input that was used as a replacement for the\n\t\t\t\t// missing submit button. The hidden input is added by `handle()`\n\t\t\t\t// to ensure that the value of the used submit button is passed on\n\t\t\t\t// for scripted submits triggered by this method\n\t\t\t\tif ( this.submitButton ) {\n\t\t\t\t\t$( \"input:hidden[name='\" + this.submitButton.name + \"']\", this.currentForm ).remove();\n\t\t\t\t}\n\n\t\t\t\tthis.formSubmitted = false;\n\t\t\t} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {\n\t\t\t\t$( this.currentForm ).triggerHandler( \"invalid-form\", [ this ] );\n\t\t\t\tthis.formSubmitted = false;\n\t\t\t}\n\t\t},\n\n\t\tpreviousValue: function( element, method ) {\n\t\t\tmethod = typeof method === \"string\" && method || \"remote\";\n\n\t\t\treturn $.data( element, \"previousValue\" ) || $.data( element, \"previousValue\", {\n\t\t\t\told: null,\n\t\t\t\tvalid: true,\n\t\t\t\tmessage: this.defaultMessage( element, { method: method } )\n\t\t\t} );\n\t\t},\n\n\t\t// Cleans up all forms and elements, removes validator-specific events\n\t\tdestroy: function() {\n\t\t\tthis.resetForm();\n\n\t\t\t$( this.currentForm )\n\t\t\t\t.off( \".validate\" )\n\t\t\t\t.removeData( \"validator\" )\n\t\t\t\t.find( \".validate-equalTo-blur\" )\n\t\t\t\t\t.off( \".validate-equalTo\" )\n\t\t\t\t\t.removeClass( \"validate-equalTo-blur\" )\n\t\t\t\t.find( \".validate-lessThan-blur\" )\n\t\t\t\t\t.off( \".validate-lessThan\" )\n\t\t\t\t\t.removeClass( \"validate-lessThan-blur\" )\n\t\t\t\t.find( \".validate-lessThanEqual-blur\" )\n\t\t\t\t\t.off( \".validate-lessThanEqual\" )\n\t\t\t\t\t.removeClass( \"validate-lessThanEqual-blur\" )\n\t\t\t\t.find( \".validate-greaterThanEqual-blur\" )\n\t\t\t\t\t.off( \".validate-greaterThanEqual\" )\n\t\t\t\t\t.removeClass( \"validate-greaterThanEqual-blur\" )\n\t\t\t\t.find( \".validate-greaterThan-blur\" )\n\t\t\t\t\t.off( \".validate-greaterThan\" )\n\t\t\t\t\t.removeClass( \"validate-greaterThan-blur\" );\n\t\t}\n\n\t},\n\n\tclassRuleSettings: {\n\t\trequired: { required: true },\n\t\temail: { email: true },\n\t\turl: { url: true },\n\t\tdate: { date: true },\n\t\tdateISO: { dateISO: true },\n\t\tnumber: { number: true },\n\t\tdigits: { digits: true },\n\t\tcreditcard: { creditcard: true }\n\t},\n\n\taddClassRules: function( className, rules ) {\n\t\tif ( className.constructor === String ) {\n\t\t\tthis.classRuleSettings[ className ] = rules;\n\t\t} else {\n\t\t\t$.extend( this.classRuleSettings, className );\n\t\t}\n\t},\n\n\tclassRules: function( element ) {\n\t\tvar rules = {},\n\t\t\tclasses = $( element ).attr( \"class\" );\n\n\t\tif ( classes ) {\n\t\t\t$.each( classes.split( \" \" ), function() {\n\t\t\t\tif ( this in $.validator.classRuleSettings ) {\n\t\t\t\t\t$.extend( rules, $.validator.classRuleSettings[ this ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\treturn rules;\n\t},\n\n\tnormalizeAttributeRule: function( rules, type, method, value ) {\n\n\t\t// Convert the value to a number for number inputs, and for text for backwards compability\n\t\t// allows type=\"date\" and others to be compared as strings\n\t\tif ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {\n\t\t\tvalue = Number( value );\n\n\t\t\t// Support Opera Mini, which returns NaN for undefined minlength\n\t\t\tif ( isNaN( value ) ) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif ( value || value === 0 ) {\n\t\t\trules[ method ] = value;\n\t\t} else if ( type === method && type !== \"range\" ) {\n\n\t\t\t// Exception: the jquery validate 'range' method\n\t\t\t// does not test for the html5 'range' type\n\t\t\trules[ type === \"date\" ? \"dateISO\" : method ] = true;\n\t\t}\n\t},\n\n\tattributeRules: function( element ) {\n\t\tvar rules = {},\n\t\t\t$element = $( element ),\n\t\t\ttype = element.getAttribute( \"type\" ),\n\t\t\tmethod, value;\n\n\t\tfor ( method in $.validator.methods ) {\n\n\t\t\t// Support for <input required> in both html5 and older browsers\n\t\t\tif ( method === \"required\" ) {\n\t\t\t\tvalue = element.getAttribute( method );\n\n\t\t\t\t// Some browsers return an empty string for the required attribute\n\t\t\t\t// and non-HTML5 browsers might have required=\"\" markup\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\tvalue = true;\n\t\t\t\t}\n\n\t\t\t\t// Force non-HTML5 browsers to return bool\n\t\t\t\tvalue = !!value;\n\t\t\t} else {\n\t\t\t\tvalue = $element.attr( method );\n\t\t\t}\n\n\t\t\tthis.normalizeAttributeRule( rules, type, method, value );\n\t\t}\n\n\t\t// 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs\n\t\tif ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {\n\t\t\tdelete rules.maxlength;\n\t\t}\n\n\t\treturn rules;\n\t},\n\n\tdataRules: function( element ) {\n\t\tvar rules = {},\n\t\t\t$element = $( element ),\n\t\t\ttype = element.getAttribute( \"type\" ),\n\t\t\tmethod, value;\n\n\t\tfor ( method in $.validator.methods ) {\n\t\t\tvalue = $element.data( \"rule\" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );\n\n\t\t\t// Cast empty attributes like `data-rule-required` to `true`\n\t\t\tif ( value === \"\" ) {\n\t\t\t\tvalue = true;\n\t\t\t}\n\n\t\t\tthis.normalizeAttributeRule( rules, type, method, value );\n\t\t}\n\t\treturn rules;\n\t},\n\n\tstaticRules: function( element ) {\n\t\tvar rules = {},\n\t\t\tvalidator = $.data( element.form, \"validator\" );\n\n\t\tif ( validator.settings.rules ) {\n\t\t\trules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};\n\t\t}\n\t\treturn rules;\n\t},\n\n\tnormalizeRules: function( rules, element ) {\n\n\t\t// Handle dependency check\n\t\t$.each( rules, function( prop, val ) {\n\n\t\t\t// Ignore rule when param is explicitly false, eg. required:false\n\t\t\tif ( val === false ) {\n\t\t\t\tdelete rules[ prop ];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( val.param || val.depends ) {\n\t\t\t\tvar keepRule = true;\n\t\t\t\tswitch ( typeof val.depends ) {\n\t\t\t\tcase \"string\":\n\t\t\t\t\tkeepRule = !!$( val.depends, element.form ).length;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"function\":\n\t\t\t\t\tkeepRule = val.depends.call( element, element );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( keepRule ) {\n\t\t\t\t\trules[ prop ] = val.param !== undefined ? val.param : true;\n\t\t\t\t} else {\n\t\t\t\t\t$.data( element.form, \"validator\" ).resetElements( $( element ) );\n\t\t\t\t\tdelete rules[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t// Evaluate parameters\n\t\t$.each( rules, function( rule, parameter ) {\n\t\t\trules[ rule ] = typeof parameter === \"function\" && rule !== \"normalizer\" ? parameter( element ) : parameter;\n\t\t} );\n\n\t\t// Clean number parameters\n\t\t$.each( [ \"minlength\", \"maxlength\" ], function() {\n\t\t\tif ( rules[ this ] ) {\n\t\t\t\trules[ this ] = Number( rules[ this ] );\n\t\t\t}\n\t\t} );\n\t\t$.each( [ \"rangelength\", \"range\" ], function() {\n\t\t\tvar parts;\n\t\t\tif ( rules[ this ] ) {\n\t\t\t\tif ( Array.isArray( rules[ this ] ) ) {\n\t\t\t\t\trules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];\n\t\t\t\t} else if ( typeof rules[ this ] === \"string\" ) {\n\t\t\t\t\tparts = rules[ this ].replace( /[\\[\\]]/g, \"\" ).split( /[\\s,]+/ );\n\t\t\t\t\trules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\tif ( $.validator.autoCreateRanges ) {\n\n\t\t\t// Auto-create ranges\n\t\t\tif ( rules.min != null && rules.max != null ) {\n\t\t\t\trules.range = [ rules.min, rules.max ];\n\t\t\t\tdelete rules.min;\n\t\t\t\tdelete rules.max;\n\t\t\t}\n\t\t\tif ( rules.minlength != null && rules.maxlength != null ) {\n\t\t\t\trules.rangelength = [ rules.minlength, rules.maxlength ];\n\t\t\t\tdelete rules.minlength;\n\t\t\t\tdelete rules.maxlength;\n\t\t\t}\n\t\t}\n\n\t\treturn rules;\n\t},\n\n\t// Converts a simple string to a {string: true} rule, e.g., \"required\" to {required:true}\n\tnormalizeRule: function( data ) {\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tvar transformed = {};\n\t\t\t$.each( data.split( /\\s/ ), function() {\n\t\t\t\ttransformed[ this ] = true;\n\t\t\t} );\n\t\t\tdata = transformed;\n\t\t}\n\t\treturn data;\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.addMethod/\n\taddMethod: function( name, method, message ) {\n\t\t$.validator.methods[ name ] = method;\n\t\t$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];\n\t\tif ( method.length < 3 ) {\n\t\t\t$.validator.addClassRules( name, $.validator.normalizeRule( name ) );\n\t\t}\n\t},\n\n\t// https://jqueryvalidation.org/jQuery.validator.methods/\n\tmethods: {\n\n\t\t// https://jqueryvalidation.org/required-method/\n\t\trequired: function( value, element, param ) {\n\n\t\t\t// Check if dependency is met\n\t\t\tif ( !this.depend( param, element ) ) {\n\t\t\t\treturn \"dependency-mismatch\";\n\t\t\t}\n\t\t\tif ( element.nodeName.toLowerCase() === \"select\" ) {\n\n\t\t\t\t// Could be an array for select-multiple or a string, both are fine this way\n\t\t\t\tvar val = $( element ).val();\n\t\t\t\treturn val && val.length > 0;\n\t\t\t}\n\t\t\tif ( this.checkable( element ) ) {\n\t\t\t\treturn this.getLength( value, element ) > 0;\n\t\t\t}\n\t\t\treturn value !== undefined && value !== null && value.length > 0;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/email-method/\n\t\temail: function( value, element ) {\n\n\t\t\t// From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\n\t\t\t// Retrieved 2014-01-14\n\t\t\t// If you have a problem with this implementation, report a bug against the above spec\n\t\t\t// Or use custom methods to implement your own email validation\n\t\t\treturn this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/url-method/\n\t\turl: function( value, element ) {\n\n\t\t\t// Copyright (c) 2010-2013 Diego Perini, MIT licensed\n\t\t\t// https://gist.github.com/dperini/729294\n\t\t\t// see also https://mathiasbynens.be/demo/url-regex\n\t\t\t// modified to allow protocol-relative URLs\n\t\t\treturn this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\\/\\/)(?:(?:[^\\]\\[?\\/<~#`!@$^&*()+=}|:\";',>{ ]|%[0-9A-Fa-f]{2})+(?::(?:[^\\]\\[?\\/<~#`!@$^&*()+=}|:\";',>{ ]|%[0-9A-Fa-f]{2})*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/date-method/\n\t\tdate: ( function() {\n\t\t\tvar called = false;\n\n\t\t\treturn function( value, element ) {\n\t\t\t\tif ( !called ) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif ( this.settings.debug && window.console ) {\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t\"The `date` method is deprecated and will be removed in version '2.0.0'.\\n\" +\n\t\t\t\t\t\t\t\"Please don't use it, since it relies on the Date constructor, which\\n\" +\n\t\t\t\t\t\t\t\"behaves very differently across browsers and locales. Use `dateISO`\\n\" +\n\t\t\t\t\t\t\t\"instead or one of the locale specific methods in `localizations/`\\n\" +\n\t\t\t\t\t\t\t\"and `additional-methods.js`.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );\n\t\t\t};\n\t\t}() ),\n\n\t\t// https://jqueryvalidation.org/dateISO-method/\n\t\tdateISO: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^\\d{4}[\\/\\-](0?[1-9]|1[012])[\\/\\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/number-method/\n\t\tnumber: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^(?:-?\\d+|-?\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/digits-method/\n\t\tdigits: function( value, element ) {\n\t\t\treturn this.optional( element ) || /^\\d+$/.test( value );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/minlength-method/\n\t\tminlength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || length >= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/maxlength-method/\n\t\tmaxlength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || length <= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/rangelength-method/\n\t\trangelength: function( value, element, param ) {\n\t\t\tvar length = Array.isArray( value ) ? value.length : this.getLength( value, element );\n\t\t\treturn this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/min-method/\n\t\tmin: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || value >= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/max-method/\n\t\tmax: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || value <= param;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/range-method/\n\t\trange: function( value, element, param ) {\n\t\t\treturn this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );\n\t\t},\n\n\t\t// https://jqueryvalidation.org/step-method/\n\t\tstep: function( value, element, param ) {\n\t\t\tvar type = $( element ).attr( \"type\" ),\n\t\t\t\terrorMessage = \"Step attribute on input type \" + type + \" is not supported.\",\n\t\t\t\tsupportedTypes = [ \"text\", \"number\", \"range\" ],\n\t\t\t\tre = new RegExp( \"\\\\b\" + type + \"\\\\b\" ),\n\t\t\t\tnotSupported = type && !re.test( supportedTypes.join() ),\n\t\t\t\tdecimalPlaces = function( num ) {\n\t\t\t\t\tvar match = ( \"\" + num ).match( /(?:\\.(\\d+))?$/ );\n\t\t\t\t\tif ( !match ) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Number of digits right of decimal point.\n\t\t\t\t\treturn match[ 1 ] ? match[ 1 ].length : 0;\n\t\t\t\t},\n\t\t\t\ttoInt = function( num ) {\n\t\t\t\t\treturn Math.round( num * Math.pow( 10, decimals ) );\n\t\t\t\t},\n\t\t\t\tvalid = true,\n\t\t\t\tdecimals;\n\n\t\t\t// Works only for text, number and range input types\n\t\t\t// TODO find a way to support input types date, datetime, datetime-local, month, time and week\n\t\t\tif ( notSupported ) {\n\t\t\t\tthrow new Error( errorMessage );\n\t\t\t}\n\n\t\t\tdecimals = decimalPlaces( param );\n\n\t\t\t// Value can't have too many decimals\n\t\t\tif ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\treturn this.optional( element ) || valid;\n\t\t},\n\n\t\t// https://jqueryvalidation.org/equalTo-method/\n\t\tequalTo: function( value, element, param ) {\n\n\t\t\t// Bind to the blur event of the target in order to revalidate whenever the target field is updated\n\t\t\tvar target = $( param );\n\t\t\tif ( this.settings.onfocusout && target.not( \".validate-equalTo-blur\" ).length ) {\n\t\t\t\ttarget.addClass( \"validate-equalTo-blur\" ).on( \"blur.validate-equalTo\", function() {\n\t\t\t\t\t$( element ).valid();\n\t\t\t\t} );\n\t\t\t}\n\t\t\treturn value === target.val();\n\t\t},\n\n\t\t// https://jqueryvalidation.org/remote-method/\n\t\tremote: function( value, element, param, method ) {\n\t\t\tif ( this.optional( element ) ) {\n\t\t\t\treturn \"dependency-mismatch\";\n\t\t\t}\n\n\t\t\tmethod = typeof method === \"string\" && method || \"remote\";\n\n\t\t\tvar previous = this.previousValue( element, method ),\n\t\t\t\tvalidator, data, optionDataString;\n\n\t\t\tif ( !this.settings.messages[ element.name ] ) {\n\t\t\t\tthis.settings.messages[ element.name ] = {};\n\t\t\t}\n\t\t\tprevious.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];\n\t\t\tthis.settings.messages[ element.name ][ method ] = previous.message;\n\n\t\t\tparam = typeof param === \"string\" && { url: param } || param;\n\t\t\toptionDataString = $.param( $.extend( { data: value }, param.data ) );\n\t\t\tif ( previous.old === optionDataString ) {\n\t\t\t\treturn previous.valid;\n\t\t\t}\n\n\t\t\tprevious.old = optionDataString;\n\t\t\tvalidator = this;\n\t\t\tthis.startRequest( element );\n\t\t\tdata = {};\n\t\t\tdata[ element.name ] = value;\n\t\t\t$.ajax( $.extend( true, {\n\t\t\t\tmode: \"abort\",\n\t\t\t\tport: \"validate\" + element.name,\n\t\t\t\tdataType: \"json\",\n\t\t\t\tdata: data,\n\t\t\t\tcontext: validator.currentForm,\n\t\t\t\tsuccess: function( response ) {\n\t\t\t\t\tvar valid = response === true || response === \"true\",\n\t\t\t\t\t\terrors, message, submitted;\n\n\t\t\t\t\tvalidator.settings.messages[ element.name ][ method ] = previous.originalMessage;\n\t\t\t\t\tif ( valid ) {\n\t\t\t\t\t\tsubmitted = validator.formSubmitted;\n\t\t\t\t\t\tvalidator.resetInternals();\n\t\t\t\t\t\tvalidator.toHide = validator.errorsFor( element );\n\t\t\t\t\t\tvalidator.formSubmitted = submitted;\n\t\t\t\t\t\tvalidator.successList.push( element );\n\t\t\t\t\t\tvalidator.invalid[ element.name ] = false;\n\t\t\t\t\t\tvalidator.showErrors();\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors = {};\n\t\t\t\t\t\tmessage = response || validator.defaultMessage( element, { method: method, parameters: value } );\n\t\t\t\t\t\terrors[ element.name ] = previous.message = message;\n\t\t\t\t\t\tvalidator.invalid[ element.name ] = true;\n\t\t\t\t\t\tvalidator.showErrors( errors );\n\t\t\t\t\t}\n\t\t\t\t\tprevious.valid = valid;\n\t\t\t\t\tvalidator.stopRequest( element, valid );\n\t\t\t\t}\n\t\t\t}, param ) );\n\t\t\treturn \"pending\";\n\t\t}\n\t}\n\n} );\n", "function methodTest( methodName ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods[ methodName ],\n\t\telement = $( \"#firstname\" )[ 0 ];\n\n\treturn function( value, param ) {\n\t\telement.value = value;\n\t\treturn method.call( v, value, element, param );\n\t};\n}\n\n/**\n * Creates a dummy DOM file input with FileList\n * @param filename\n * @param mimeType\n * @returns {{}}\n */\nfunction acceptFileDummyInput( filename, mimeType ) {\n\n\tfunction dummy() {\n\t\treturn file;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/FileList\n\tvar file = {\n\t\t\tname: filename,\n\t\t\tsize: 500001,\n\t\t\ttype: mimeType\n\t\t},\n\t\tfileList = {\n\t\t\t0: file,\n\t\t\tlength: 1,\n\t\t\titem: dummy\n\t\t};\n\n\treturn {\n\t\ttype: \"file\",\n\t\tfiles: fileList,\n\t\tnodeName: \"INPUT\",\n\t\tvalue: \"/tmp/fake_value\",\n\t\thasAttribute: function() { return false; }\n\t};\n}\n\nfunction fileDummyInput( selectedFiles ) {\n\tvar aFiles = [],\n\t\toFiles;\n\n\tfor ( var i = 0; i < selectedFiles.length; i++ ) {\n\t\taFiles.push( {\n\t\t\tname: selectedFiles[ i ].name,\n\t\t\tsize: selectedFiles[ i ].size,\n\t\t\ttype: \"image/jpeg\"\n\t\t} );\n\t}\n\n\t//Convert the array of objects to an object.\n\toFiles = aFiles.reduce( function( acc, cur, i ) {\n\t\tacc[ i ] = cur;\n\t\treturn acc;\n\t}, {} );\n\n\t//Add the \"length\" property to the object.\n\toFiles.length = selectedFiles.length;\n\n\t//Add the \"item()\" method to the object.\n\toFiles.item = function( i ) { return aFiles[ i ]; };\n\n\treturn {\n\t\ttype: \"file\",\n\t\tfiles: oFiles,\n\t\tnodeName: \"INPUT\",\n\t\tvalue: \"/tmp/fake_value\",\n\t\thasAttribute: function() { return false; }\n\t};\n}\n\nQUnit.module( \"methods\" );\n\nQUnit.test( \"default messages\", function( assert ) {\n\tvar m = $.validator.methods;\n\t$.each( m, function( key ) {\n\t\tassert.ok( jQuery.validator.messages[ key ], key + \" has a default message.\" );\n\t} );\n} );\n\nQUnit.test( \"digit\", function( assert ) {\n\tvar method = methodTest( \"digits\" );\n\tassert.ok( method( \"123\" ), \"Valid digits\" );\n\tassert.ok( !method( \"123.000\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"123.000,00\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"123.0.0,0\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"x123\" ), \"Invalid digits\" );\n\tassert.ok( !method( \"100.100,0,0\" ), \"Invalid digits\" );\n} );\n\nQUnit.test( \"url\", function( assert ) {\n\tvar method = methodTest( \"url\" );\n\tassert.ok( method( \"http://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"https://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"ftp://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"http://www.f\u00f8tex.dk/\" ), \"Valid url, danish unicode characters\" );\n\tassert.ok( method( \"http://b\u00f6sendorfer.de/\" ), \"Valid url, german unicode characters\" );\n\tassert.ok( method( \"http://142.42.1.1\" ), \"Valid IP Address\" );\n\tassert.ok( method( \"http://pro.photography\" ), \"Valid long TLD\" );\n\tassert.ok( method( \"//code.jquery.com/jquery-1.11.3.min.js\" ), \"Valid protocol-relative url\" );\n\tassert.ok( method( \"//142.42.1.1\" ), \"Valid protocol-relative IP Address\" );\n\tassert.ok( !method( \"htp://code.jquery.com/jquery-1.11.3.min.js\" ), \"Invalid protocol\" );\n\tassert.ok( !method( \"http://192.168.8.\" ), \"Invalid IP Address\" );\n\tassert.ok( !method( \"http://bassistance\" ), \"Invalid url\" ); // Valid\n\tassert.ok( !method( \"http://bassistance.\" ), \"Invalid url\" ); // Valid\n\tassert.ok( !method( \"http://bassistance,de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://bassistance;de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://.bassistancede\" ), \"Invalid url\" );\n\tassert.ok( !method( \"bassistance.de\" ), \"Invalid url\" );\n} );\n\nQUnit.test( \"url2 (tld optional)\", function( assert ) {\n\tvar method = methodTest( \"url2\" );\n\tassert.ok( method( \"http://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"https://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"ftp://bassistance.de/jquery/plugin.php?bla=blu\" ), \"Valid url\" );\n\tassert.ok( method( \"http://www.f\u00f8tex.dk/\" ), \"Valid url, danish unicode characters\" );\n\tassert.ok( method( \"http://b\u00f6sendorfer.de/\" ), \"Valid url, german unicode characters\" );\n\tassert.ok( method( \"http://142.42.1.1\" ), \"Valid IP Address\" );\n\tassert.ok( method( \"http://bassistance\" ), \"Valid URL (optional TLD)\" );\n\tassert.ok( method( \"http://bassistance.\" ), \"Valid URL (optional TLD)\" );\n\tassert.ok( !method( \"http://192.168.8.\" ), \"Invalid IP Address\" );\n\tassert.ok( !method( \"http://bassistance,de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://bassistance;de\" ), \"Invalid url\" );\n\tassert.ok( !method( \"http://.bassistancede\" ), \"Invalid url\" );\n\tassert.ok( !method( \"bassistance.de\" ), \"Invalid url\" );\n} );\n\nQUnit.test( \"email\", function( assert ) {\n\tvar method = methodTest( \"email\" );\n\tassert.ok( method( \"name@domain.tld\" ), \"Valid email\" );\n\tassert.ok( method( \"name@domain.tl\" ), \"Valid email\" );\n\tassert.ok( method( \"bart+bart@tokbox.com\" ), \"Valid email\" );\n\tassert.ok( method( \"bart+bart@tokbox.travel\" ), \"Valid email\" );\n\tassert.ok( method( \"n@d.tld\" ), \"Valid email\" );\n\tassert.ok( method( \"bla.blu@g.mail.com\" ), \"Valid email\" );\n\tassert.ok( method( \"name@domain\" ), \"Valid email\" );\n\tassert.ok( method( \"name.@domain.tld\" ), \"Valid email\" );\n\tassert.ok( method( \"name@website.a\" ), \"Valid email\" );\n\tassert.ok( method( \"name@pro.photography\" ), \"Valid email\" );\n\tassert.ok( !method( \"ole@f\u00f8tex.dk\" ), \"Invalid email\" );\n\tassert.ok( !method( \"j\u00f6rn@bassistance.de\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name\" ), \"Invalid email\" );\n\tassert.ok( !method( \"test@test-.com\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name@\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name,@domain.tld\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name;@domain.tld\" ), \"Invalid email\" );\n\tassert.ok( !method( \"name;@domain.tld.\" ), \"Invalid email\" );\n} );\n\nQUnit.test( \"number\", function( assert ) {\n\tvar method = methodTest( \"number\" );\n\tassert.ok( method( \"123\" ), \"Valid number\" );\n\tassert.ok( method( \"-123\" ), \"Valid number\" );\n\tassert.ok( method( \"123,000\" ), \"Valid number\" );\n\tassert.ok( method( \"-123,000\" ), \"Valid number\" );\n\tassert.ok( method( \"123,000.00\" ), \"Valid number\" );\n\tassert.ok( method( \"-123,000.00\" ), \"Valid number\" );\n\tassert.ok( !method( \"-\" ), \"Invalid number\" );\n\tassert.ok( !method( \"123.000,00\" ), \"Invalid number\" );\n\tassert.ok( !method( \"123.0.0,0\" ), \"Invalid number\" );\n\tassert.ok( !method( \"x123\" ), \"Invalid number\" );\n\tassert.ok( !method( \"100.100,0,0\" ), \"Invalid number\" );\n\n\tassert.ok( method( \"\" ), \"Blank is valid\" );\n\tassert.ok( method( \"123\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123000\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123000.12\" ), \"Valid decimal\" );\n\tassert.ok( method( \"-123000.12\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123.000\" ), \"Valid decimal\" );\n\tassert.ok( method( \"123,000.00\" ), \"Valid decimal\" );\n\tassert.ok( method( \"-123,000.00\" ), \"Valid decimal\" );\n\tassert.ok( method( \".100\" ), \"Valid decimal\" );\n\tassert.ok( !method( \"1230,000.00\" ), \"Invalid decimal\" );\n\tassert.ok( !method( \"123.0.0,0\" ), \"Invalid decimal\" );\n\tassert.ok( !method( \"x123\" ), \"Invalid decimal\" );\n\tassert.ok( !method( \"100.100,0,0\" ), \"Invalid decimal\" );\n} );\n\n/* Disabled for now, need to figure out how to test localized methods\nQUnit.test(\"numberDE\", function( assert ) {\n\tvar method = methodTest(\"numberDE\");\n\tassert.ok( method( \"123\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"-123\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"123.000\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"-123.000\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"123.000,00\" ), \"Valid numberDE\" );\n\tassert.ok( method( \"-123.000,00\" ), \"Valid numberDE\" );\n\tassert.ok(!method( \"123,000.00\" ), \"Invalid numberDE\" );\n\tassert.ok(!method( \"123,0,0.0\" ), \"Invalid numberDE\" );\n\tassert.ok(!method( \"x123\" ), \"Invalid numberDE\" );\n\tassert.ok(!method( \"100,100.0.0\" ), \"Invalid numberDE\" );\n\n\tassert.ok( method( \"\" ), \"Blank is valid\" );\n\tassert.ok( method( \"123\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123000\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123000,12\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"-123000,12\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123.000\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"123.000,00\" ), \"Valid decimalDE\" );\n\tassert.ok( method( \"-123.000,00\" ), \"Valid decimalDE\" )\n\tassert.ok(!method( \"123.0.0,0\" ), \"Invalid decimalDE\" );\n\tassert.ok(!method( \"x123\" ), \"Invalid decimalDE\" );\n\tassert.ok(!method( \"100,100.0.0\" ), \"Invalid decimalDE\" );\n});\n*/\n\nQUnit.test( \"date\", function( assert ) {\n\tvar method = methodTest( \"date\" );\n\tassert.ok( method( \"06/06/1990\" ), \"Valid date\" );\n\tassert.ok( method( \"6/6/06\" ), \"Valid date\" );\n\tassert.ok( !method( \"1990x-06-06\" ), \"Invalid date\" );\n} );\n\nQUnit.test( \"dateISO\", function( assert ) {\n\tvar method = methodTest( \"dateISO\" );\n\tassert.ok( method( \"1990-06-06\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-01-01\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-01-31\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-12-01\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-12-31\" ), \"Valid date\" );\n\tassert.ok( method( \"1990/06/06\" ), \"Valid date\" );\n\tassert.ok( method( \"1990-6-6\" ), \"Valid date\" );\n\tassert.ok( method( \"1990/6/6\" ), \"Valid date\" );\n\tassert.ok( !method( \"1990-106-06\" ), \"Invalid date\" );\n\tassert.ok( !method( \"190-06-06\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-00-06\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-13-01\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-01-00\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-01-32\" ), \"Invalid date\" );\n\tassert.ok( !method( \"1990-13-32\" ), \"Invalid date\" );\n} );\n\n/* Disabled for now, need to figure out how to test localized methods\nQUnit.test(\"dateDE\", function( assert ) {\n\tvar method = methodTest(\"dateDE\");\n\tassert.ok( method( \"03.06.1984\" ), \"Valid dateDE\" );\n\tassert.ok( method( \"3.6.84\" ), \"Valid dateDE\" );\n\tassert.ok(!method( \"6-6-06\" ), \"Invalid dateDE\" );\n\tassert.ok(!method( \"1990-06-06\" ), \"Invalid dateDE\" );\n\tassert.ok(!method( \"06/06/1990\" ), \"Invalid dateDE\" );\n\tassert.ok(!method( \"6/6/06\" ), \"Invalid dateDE\" );\n});\n*/\n\nQUnit.test( \"required\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.required,\n\t\te = $( \"#text1, #text1b, #hidden2, #select1, #select2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ] ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ] ), \"Invalid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ] ), \"Invalid text input\" );\n\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ] ), \"Invalid select\" );\n\tassert.ok( method.call( v, e[ 4 ].value, e[ 4 ] ), \"Valid select\" );\n\n\te = $( \"#area1, #area2, #pw1, #pw2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ] ), \"Valid textarea\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ] ), \"Invalid textarea\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ] ), \"Valid password input\" );\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ] ), \"Invalid password input\" );\n\n\te = $( \"#radio1, #radio2, #radio3\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ] ), \"Invalid radio\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ] ), \"Valid radio\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ] ), \"Valid radio\" );\n\n\te = $( \"#check1, #check2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ] ), \"Valid checkbox\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ] ), \"Invalid checkbox\" );\n\n\te = $( \"#select1, #select2, #select3, #select4\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ] ), \"Invalid select\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ] ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ] ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ] ), \"Valid select\" );\n} );\n\nQUnit.test( \"required with dependencies\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.required,\n\t\te = $( \"#hidden2, #select1, #area2, #radio1, #check2\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], \"asffsaa\" ), \"Valid text input due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], \"input\" ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], function() { return false; } ), \"Valid text input due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], function() { return true; } ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], \"asfsfa\" ), \"Valid select due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], \"input\" ), \"Invalid select\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], \"asfsafsfa\" ), \"Valid textarea due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], \"input\" ), \"Invalid textarea\" );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ], \"asfsafsfa\" ), \"Valid radio due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ], \"input\" ), \"Invalid radio\" );\n\tassert.ok( method.call( v, e[ 4 ].value, e[ 4 ], \"asfsafsfa\" ), \"Valid checkbox due to dependency not met\" );\n\tassert.ok( !method.call( v, e[ 4 ].value, e[ 4 ], \"input\" ), \"Invalid checkbox\" );\n} );\n\nQUnit.test( \"minlength\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.minlength,\n\t\tparam = 2,\n\t\te = $( \"#text1, #text1c, #text2, #text3\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ], param ), \"Valid text input\" );\n\n\te = $( \"#check1, #check2, #check3\" );\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid checkbox\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid checkbox\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid checkbox\" );\n\n\te = $( \"#select1, #select2, #select3, #select4, #select5\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid select \" + e[ 0 ].id );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid select \" + e[ 1 ].id );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid select \" + e[ 2 ].id );\n\tassert.ok( method.call( v, e[ 3 ].value, e[ 3 ], param ), \"Valid select \" + e[ 3 ].id );\n\tassert.ok( method.call( v, e[ 4 ].value, e[ 4 ], param ), \"Valid select \" + e[ 4 ].id );\n} );\n\nQUnit.test( \"maxlength\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.maxlength,\n\t\tparam = 4,\n\t\te = $( \"#text1, #text2, #text3\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n\n\te = $( \"#check1, #check2, #check3\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid checkbox\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid checkbox\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid checkbox\" );\n\n\te = $( \"#select1, #select2, #select3, #select4\" );\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid select\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid select\" );\n\tassert.ok( !method.call( v, e[ 3 ].value, e[ 3 ], param ), \"Invalid select\" );\n} );\n\nQUnit.test( \"rangelength\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.rangelength,\n\t\tparam = [ 2, 4 ],\n\t\te = $( \"#text1, #text2, #text3\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n} );\n\nQUnit.test( \"min\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.min,\n\t\tparam = 8,\n\t\te = $( \"#value1, #value2, #value3\" );\n\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid text input\" );\n} );\n\nQUnit.test( \"max\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.max,\n\t\tparam = 12,\n\t\te = $( \"#value1, #value2, #value3\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n} );\n\nQUnit.test( \"range\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.range,\n\t\tparam = [ 4, 12 ],\n\t\te = $( \"#value1, #value2, #value3\" );\n\n\tassert.ok( !method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Invalid text input\" );\n} );\n\nQUnit.test( \"step\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.step,\n\t\tparam = 1000,\n\t\te = $( \"#value1, #value2, #value3, #value4\" );\n\n\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Valid text input\" );\n\tassert.ok( !method.call( v, e[ 1 ].value, e[ 1 ], param ), \"Invalid text input\" );\n\tassert.ok( method.call( v, e[ 2 ].value, e[ 2 ], param ), \"Valid text input\" );\n} );\n\nQUnit.test( \"#1760 - step modulo/remainder regression tests\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.step,\n\t\tparam = 0.00125,\n\t\te = $( \"#value4\" );\n\n\tfor ( var i = 1; i <= 1000; i++ ) {\n\t\te[ 0 ].value = ( param * 100000 * i ) / 100000;\n\t\tassert.ok( method.call( v, e[ 0 ].value, e[ 0 ], param ), \"Ensure \" + e[ 0 ].value + \" % \" + param + \" === 0 is valid\" );\n\t}\n} );\n\nQUnit.test( \"lessThan\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.lessThan,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( !method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( !method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n} );\n\nQUnit.test( \"lessThanEqual\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.lessThanEqual,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( !method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n} );\n\nQUnit.test( \"equalTo\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.equalTo,\n\t\te = $( \"#text1, #text2\" );\n\n\tassert.ok( method.call( v, \"Test\", e[ 0 ], \"#text1\" ), \"Text input\" );\n\tassert.ok( method.call( v, \"T\", e[ 1 ], \"#text2\" ), \"Another one\" );\n} );\n\nQUnit.test( \"greaterThanEqual\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.greaterThanEqual,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( !method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n\tassert.ok( method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n} );\n\nQUnit.test( \"greaterThan\", function( assert ) {\n\tvar v = jQuery( \"#form\" ).validate(),\n\t\tmethod = $.validator.methods.greaterThan,\n\t\te = $( \"#value2\" );\n\n\tassert.ok( !method.call( v, \"1\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( !method.call( v, \"10\", e[ 0 ], \"#value2\" ), \"Invalid integer\" );\n\tassert.ok( method.call( v, \"11\", e[ 0 ], \"#value2\" ), \"Valid integer\" );\n} );\n\nQUnit.test( \"extension\", function( assert ) {\n\tvar method = methodTest( \"extension\" ),\n\t\tv;\n\tassert.ok( method( \"picture.gif\" ), \"Valid default accept type\" );\n\tassert.ok( method( \"picture.jpg\" ), \"Valid default accept type\" );\n\tassert.ok( method( \"picture.jpeg\" ), \"Valid default accept type\" );\n\tassert.ok( method( \"picture.png\" ), \"Valid default accept type\" );\n\tassert.ok( !method( \"picture.pgn\" ), \"Invalid default accept type\" );\n\n\tv = jQuery( \"#form\" ).validate();\n\tmethod = function( value, param ) {\n\t\treturn $.validator.methods.extension.call( v, value, $( \"#text1\" )[ 0 ], param );\n\t};\n\tassert.ok( method( \"picture.doc\", \"doc\" ), \"Valid custom accept type\" );\n\tassert.ok( method( \"picture.pdf\", \"doc|pdf\" ), \"Valid custom accept type\" );\n\tassert.ok( method( \"picture.pdf\", \"pdf|doc\" ), \"Valid custom accept type\" );\n\tassert.ok( !method( \"picture.pdf\", \"doc\" ), \"Invalid custom accept type\" );\n\tassert.ok( !method( \"picture.doc\", \"pdf\" ), \"Invalid custom accept type\" );\n\n\tassert.ok( method( \"picture.pdf\", \"doc,pdf\" ), \"Valid custom accept type, comma separated\" );\n\tassert.ok( method( \"picture.pdf\", \"pdf,doc\" ), \"Valid custom accept type, comma separated\" );\n\tassert.ok( !method( \"picture.pdf\", \"gop,top\" ), \"Invalid custom accept type, comma separated\" );\n} );\n\nQUnit.test( \"remote\", function( assert ) {\n\tassert.expect( 7 );\n\tvar e = $( \"#username\" ),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: true,\n\t\t\t\t\tremote: \"users.php\"\n\t\t\t\t}\n\t\t\t},\n\t\t\tmessages: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: \"Please\",\n\t\t\t\t\tremote: jQuery.validator.format( \"{0} in use\" )\n\t\t\t\t}\n\t\t\t}\n\t\t} ),\n\t\tdone = assert.async();\n\n\t$( document ).ajaxStop( function() {\n\t\t$( document ).unbind( \"ajaxStop\" );\n\t\tassert.equal( v.size(), 1, \"There must be one error\" );\n\t\tassert.equal( v.errorList[ 0 ].message, \"Peter in use\" );\n\n\t\t$( document ).ajaxStop( function() {\n\t\t\t$( document ).unbind( \"ajaxStop\" );\n\t\t\tassert.equal( v.size(), 1, \"There must be one error\" );\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"Peter2 in use\" );\n\t\t\tdone();\n\t\t} );\n\t\te.val( \"Peter2\" );\n\t\tassert.strictEqual( v.element( e ), true, \"new value, new request; dependency-mismatch considered as valid though\" );\n\t} );\n\tassert.strictEqual( v.element( e ), false, \"invalid element, nothing entered yet\" );\n\te.val( \"Peter\" );\n\tassert.strictEqual( v.element( e ), true, \"still invalid, because remote validation must block until it returns; dependency-mismatch considered as valid though\" );\n} );\n\nQUnit.test( \"remote, pending class added to element while call outstanding\", function( assert ) {\n\tassert.expect( 3 );\n\tvar e = $( \"#username\" ),\n\t\tdone = assert.async(),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\tremote: {\n\t\t\t\t\t\turl: \"users.php\",\n\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\tassert.strictEqual( e.hasClass( \"pending\" ), false, \"not pending since ajax call complete\" );\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\tassert.strictEqual( e.hasClass( \"pending\" ), false, \"not pending since no data entered\" );\n\te.val( \"Peter\" );\n\n\t// This fires off the validation:\n\tv.element( e );\n\tassert.strictEqual( e.hasClass( \"pending\" ), true, \"pending while validation outstanding\" );\n} );\n\nQUnit.test( \"remote, customized ajax options\", function( assert ) {\n\tassert.expect( 2 );\n\tvar done = assert.async();\n\t$( \"#userForm\" ).validate( {\n\t\trules: {\n\t\t\tusername: {\n\t\t\t\trequired: true,\n\t\t\t\tremote: {\n\t\t\t\t\turl: \"users.php\",\n\t\t\t\t\ttype: \"POST\",\n\t\t\t\t\tbeforeSend: function( request, settings ) {\n\t\t\t\t\t\tassert.deepEqual( settings.type, \"POST\" );\n\t\t\t\t\t\tassert.deepEqual( settings.data, \"username=asdf&email=email.com\" );\n\t\t\t\t\t},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\temail: function() {\n\t\t\t\t\t\t\treturn \"email.com\";\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\tdone();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\t$( \"#username\" ).val( \"asdf\" );\n\t$( \"#userForm\" ).valid();\n} );\n\nQUnit.test( \"remote extensions\", function( assert ) {\n\tassert.expect( 5 );\n\tvar e = $( \"#username\" ),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: true,\n\t\t\t\t\tremote: \"users2.php\"\n\t\t\t\t}\n\t\t\t},\n\t\t\tmessages: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: \"Please\"\n\t\t\t\t}\n\t\t\t}\n\t\t} ),\n\t\tdone = assert.async();\n\n\t$( document ).ajaxStop( function() {\n\t\t$( document ).unbind( \"ajaxStop\" );\n\t\tif ( v.size() !== 0 ) {\n\t\t\tassert.ok( \"There must be one error\" );\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"asdf is already taken, please try something else\" );\n\t\t\tv.element( e );\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"asdf is already taken, please try something else\", \"message doesn't change on revalidation\" );\n\t\t}\n\t\tdone();\n\t} );\n\tassert.strictEqual( v.element( e ), false, \"invalid element, nothing entered yet\" );\n\te.val( \"asdf\" );\n\tassert.strictEqual( v.element( e ), true, \"still invalid, because remote validation must block until it returns; dependency-mismatch considered as valid though\" );\n} );\n\nQUnit.test( \"remote, data previous querystring\", function( assert ) {\n\tassert.expect( 4 );\n\tvar succeeded = 0,\n\t\t$f = $( \"#firstnamec\" ),\n\t\t$l = $( \"#lastnamec\" ),\n\t\tdone1 = assert.async(),\n\t\tdone2 = assert.async(),\n\t\tdone3 = assert.async(),\n\t\tv = $( \"#testForm1clean\" ).validate( {\n\t\t\trules: {\n\t\t\t\tlastname: {\n\t\t\t\t\tremote: {\n\t\t\t\t\t\turl: \"users.php\",\n\t\t\t\t\t\ttype: \"POST\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tfirstname: function() {\n\t\t\t\t\t\t\t\treturn $f.val();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\tsucceeded++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t$f.val( \"first-name\" );\n\t$l.val( \"last-name\" );\n\tassert.strictEqual( succeeded, 0, \"no valid call means no successful validation\" );\n\tv.element( $l );\n\tsetTimeout( function() {\n\t\tassert.strictEqual( succeeded, 1, \"first valid check should submit given first name\" );\n\t\tdone1();\n\t\tv.element( $l );\n\t\tsetTimeout( function() {\n\t\t\tassert.strictEqual( succeeded, 1, \"second valid check should not resubmit given same first name\" );\n\t\t\tdone2();\n\t\t\t$f.val( \"different-first-name\" );\n\t\t\tv.element( $l );\n\t\t\tsetTimeout( function() {\n\t\t\t\tassert.strictEqual( succeeded, 2, \"third valid check should resubmit given different first name\" );\n\t\t\t\tdone3();\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n\nQUnit.test( \"remote, highlight all invalid fields\", function( assert ) {\n\tassert.expect( 3 );\n\n\tvar done = assert.async(),\n\t\t$form = $( \"#testForm1\" ),\n\t\t$firstnameField = $form.find( \"input[name='firstname']\" ),\n\t\t$lastnameField = $form.find( \"input[name='lastname']\" ),\n\t\t$somethingField = $form.find( \"input[name='something']\" ),\n\t\tvalidateOptions = {\n\t        rules: {\n\t\t\t\tfirstname: {\n\t                required: true\n\t            },\n\t            lastname: {\n\t                required: true\n\t            },\n\t\t\t\tsomething: {\n\t                required: true,\n\t                remote: {\n\t                    url: \"response.php\",\n\t                    type: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tresponseText: \"false\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t$firstnameField.val( \"\" );\n\t$lastnameField.val( \"\" );\n\t$somethingField.val( \"something value\" );\n\n\t$form.validate( validateOptions );\n\t$form.valid();\n\n\tsetTimeout( function() {\n\t\tassert.equal( $firstnameField.hasClass( \"error\" ), true, \"Field 'firstname' should have a '.error' class\" );\n\t\tassert.equal( $lastnameField.hasClass( \"error\" ), true, \"Field 'lastname' should have a '.error' class\" );\n\t\tassert.equal( $somethingField.hasClass( \"error\" ), true, \"Field 'something' should have a '.error' class\" );\n\t\tdone();\n\t}, 500 );\n} );\nQUnit.test( \"remote, unhighlighted should be invoked after being highlighted/invalid\", function( assert ) {\n\tassert.expect( 6 );\n\n\tvar done1 = assert.async(),\n\t\tdone2 = assert.async(),\n\t\t$form = $( \"#testForm25\" ),\n\t\t$somethingField = $form.find( \"input[name='something25']\" ),\n\t\tresponseText = \"false\",\n\t\tresponse = function() { return responseText; },\n\t\tvalidateOptions = {\n\t\t\thighlight: function( e ) {\n\t\t\t\t$( e ).addClass( \"error\" );\n\t\t\t\tassert.ok( true, \"highlight should be called\" );\n\t\t\t},\n\t\t\tunhighlight: function( e ) {\n\t\t\t\t$( e ).removeClass( \"error\" );\n\t\t\t\tassert.ok( true, \"unhighlight should be called\" );\n\t\t\t},\n\t        rules: {\n\t\t\t\tsomething25: {\n\t                required: true,\n\t                remote: {\n\t                    url: \"response.php\",\n\t                    type: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tresponseText: response\n\t\t\t\t\t\t},\n\t\t\t\t\t\tasync: false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t$somethingField.val( \"something value\" );\n\tvar v = $form.validate( validateOptions );\n\tv.element( $somethingField );\n\n\tsetTimeout( function() {\n\t\tassert.equal( $somethingField.hasClass( \"error\" ), true, \"Field 'something' should have the error class\" );\n\t\tdone1();\n\t\t$somethingField.val( \"something value 2\" );\n\t\tresponseText = \"true\";\n\n\t\tv.element( $somethingField );\n\n\t\tsetTimeout( function() {\n\t\t\tassert.equal( $somethingField.hasClass( \"error\" ), false, \"Field 'something' should not have the error class\" );\n\t\t\tdone2();\n\t\t}, 500 );\n\t}, 500 );\n} );\n\nQUnit.test( \"Fix #697: remote validation uses wrong error messages\", function( assert ) {\n\tvar e = $( \"#username\" ),\n\t\tdone1 = assert.async(),\n\t\tdone2 = assert.async(),\n\t\tdone3 = assert.async(),\n\t\tv = $( \"#userForm\" ).validate( {\n\t\t\trules: {\n\t\t\t\tusername: {\n\t\t\t\t\trequired: true,\n\t\t\t\t\tremote: {\n\t\t\t\t\t\turl: \"users.php\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tmessages: {\n\t\t\t\tusername: {\n\t\t\t\t\tremote: $.validator.format( \"{0} in use\" )\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t$( \"#userForm\" ).valid();\n\n\te.val( \"Peter\" );\n\tv.element( e );\n\tsetTimeout( function() {\n\t\tassert.equal( v.errorList[ 0 ].message, \"Peter in use\" );\n\t\tdone1();\n\n\t\te.val( \"something\" );\n\t\tv.element( e );\n\n\t\te.val( \"Peter\" );\n\t\tv.element( e );\n\t\tsetTimeout( function() {\n\t\t\tassert.equal( v.errorList[ 0 ].message, \"Peter in use\" );\n\t\t\tdone2();\n\n\t\t\te.val( \"asdf\" );\n\t\t\tv.element( e );\n\t\t\tsetTimeout( function() {\n\t\t\t\tassert.equal( v.errorList[ 0 ].message, \"asdf in use\", \"error message should be updated\" );\n\t\t\t\tdone3();\n\t\t\t} );\n\t\t} );\n\t} );\n} );\n\nQUnit.module( \"additional methods\" );\n\nQUnit.test( \"phone (us)\", function( assert ) {\n\tvar method = methodTest( \"phoneUS\" );\n\tassert.ok( method( \"1(212)-999-2345\" ), \"Valid US phone number\" );\n\tassert.ok( method( \"212 999 2344\" ), \"Valid US phone number\" );\n\tassert.ok( method( \"212-999-0983\" ), \"Valid US phone number\" );\n\tassert.ok( method( \"234-911-5678\" ), \"Valid US phone number\" );\n\tassert.ok( !method( \"111-123-5434\" ), \"Invalid US phone number. Area Code cannot start with 1\" );\n\tassert.ok( !method( \"212 123 4567\" ), \"Invalid US phone number. NXX cannot start with 1\" );\n\tassert.ok( !method( \"911-333-5678\" ), \"Invalid US phone number, because the area code cannot be in the form N11\" );\n\tassert.ok( method( \"234-912-5678\" ), \"Valid US phone number\" );\n} );\n\nQUnit.test( \"phoneUK\", function( assert ) {\n\tvar method = methodTest( \"phoneUK\" );\n\tassert.ok( method( \"0117 333 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0121 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"01633 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"01298 28555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"015395 55555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"016977 3999\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"020 3000 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"024 7500 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0333 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0500 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"055 3555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"07122 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"07222 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"07322 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0800 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0800 355555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0843 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0872 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0903 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"0983 555 5555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"(07122) 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"(07222) 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"(07322) 555555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"+44 7122 555 555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"+44 7222 555 555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( method( \"+44 7322 555 555\" ), \"Valid UK Phone Number\" );\n\tassert.ok( !method( \"7222 555555\" ), \"Invalid UK Phone Number\" );\n\tassert.ok( !method( \"+44 07222 555555\" ), \"Invalid UK Phone Number\" );\n} );\n\nQUnit.test( \"mobileUK\", function( assert ) {\n\tvar method = methodTest( \"mobileUK\" );\n\tassert.ok( method( \"07134234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"07334234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"07624234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"07734234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447134234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447334234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447624234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( method( \"+447734234323\" ), \"Valid UK Mobile Number\" );\n\tassert.ok( !method( \"07034234323\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"0753423432\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"07604234323\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"077342343234\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"044342343234\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+44753423432\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+447604234323\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+4477342343234\" ), \"Invalid UK Mobile Number\" );\n\tassert.ok( !method( \"+4444342343234\" ), \"Invalid UK Mobile Number\" );\n} );\n\nQUnit.test( \"mobileRU\", function( assert ) {\n\tvar method = methodTest( \"mobileRU\" );\n\tassert.ok( method( \"+74957207089\" ), \"Valid RU Mobile Number\" );\n\tassert.ok( method( \"84957207089\" ), \"Valid RU Mobile Number\" );\n\tassert.ok( !method( \"+447604234323\" ), \"Invalid RU Mobile Number\" );\n\tassert.ok( !method( \"9477342343234\" ), \"Invalid RU Mobile Number\" );\n\tassert.ok( !method( \"344342343234\" ), \"Invalid RU Mobile Number\" );\n} );\n\nQUnit.test( \"dateITA\", function( assert ) {\n\tvar method = methodTest( \"dateITA\" );\n\tassert.ok( method( \"01/01/1900\" ), \"Valid date ITA\" );\n\tassert.ok( method( \"17/10/2010\" ), \"Valid date ITA\" );\n\tassert.ok( !method( \"01/13/1990\" ), \"Invalid date ITA\" );\n\tassert.ok( !method( \"01.01.1900\" ), \"Invalid date ITA\" );\n\tassert.ok( !method( \"01/01/199\" ), \"Invalid date ITA\" );\n} );\n\nQUnit.test( \"dateFA\", function( assert ) {\n\tvar method = methodTest( \"dateFA\" );\n\n\tassert.ok( method( \"1342/12/29\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1342/12/30\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1361/6/31\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1321/11/30\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1361/1/1\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/3/3\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/03/3\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/3/03\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1020/03/03\" ), \"Valid date FA\" );\n\tassert.ok( method( \"1001/7/30\" ), \"Valid date FA\" );\n\n\tassert.ok( !method( \"1000/1/32\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"1323/12/31\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"1361/0/11\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"63/4/4\" ), \"Invalid date FA\" );\n\tassert.ok( !method( \"15/6/1361\" ), \"Invalid date FA\" );\n} );\n\nQUnit.test( \"iban\", function( assert ) {\n\tvar method = methodTest( \"iban\" );\n\tassert.ok( method( \"NL20INGB0001234567\" ), \"Valid IBAN\" );\n\tassert.ok( method( \"DE68 2105 0170 0012 3456 78\" ), \"Valid IBAN\" );\n\tassert.ok( method( \"NL20 INGB0001234567\" ), \"Valid IBAN: invalid spacing\" );\n\tassert.ok( method( \"NL20 INGB 00 0123 4567\" ), \"Valid IBAN: invalid spacing\" );\n\tassert.ok( method( \"XX40INGB000123456712341234\" ), \"Valid (more or less) IBAN: unknown country, but checksum OK\" );\n\n\tassert.ok( !method( \"1\" ), \"Invalid IBAN: too short\" );\n\tassert.ok( !method( \"NL20INGB000123456\" ), \"Invalid IBAN: too short\" );\n\tassert.ok( !method( \"NL20INGB00012345678\" ), \"Invalid IBAN: too long\" );\n\tassert.ok( !method( \"NL20INGB0001234566\" ), \"Invalid IBAN: checksum incorrect\" );\n\tassert.ok( !method( \"DE68 2105 0170 0012 3456 7\" ), \"Invalid IBAN: too short\" );\n\tassert.ok( !method( \"DE68 2105 0170 0012 3456 789\" ), \"Invalid IBAN: too long\" );\n\tassert.ok( !method( \"DE68 2105 0170 0012 3456 79\" ), \"Invalid IBAN: checksum incorrect\" );\n\n\tassert.ok( !method( \"NL54INGB00012345671234\" ), \"Invalid IBAN too long, BUT CORRECT CHECKSUM\" );\n\tassert.ok( !method( \"XX00INGB000123456712341234\" ), \"Invalid IBAN: unknown country and checksum incorrect\" );\n\n\t// Sample IBANs for different countries\n\tassert.ok( method( \"AL47 2121 1009 0000 0002 3569 8741\" ), \"Valid IBAN - AL\" );\n\tassert.ok( method( \"AD12 0001 2030 2003 5910 0100\" ), \"Valid IBAN - AD\" );\n\tassert.ok( method( \"AT61 1904 3002 3457 3201\" ), \"Valid IBAN - AT\" );\n\tassert.ok( method( \"AZ21 NABZ 0000 0000 1370 1000 1944\" ), \"Valid IBAN - AZ\" );\n\tassert.ok( method( \"BH67 BMAG 0000 1299 1234 56\" ), \"Valid IBAN - BH\" );\n\tassert.ok( method( \"BE62 5100 0754 7061\" ), \"Valid IBAN - BE\" );\n\tassert.ok( method( \"BA39 1290 0794 0102 8494\" ), \"Valid IBAN - BA\" );\n\tassert.ok( method( \"BG80 BNBG 9661 1020 3456 78\" ), \"Valid IBAN - BG\" );\n\tassert.ok( method( \"HR12 1001 0051 8630 0016 0\" ), \"Valid IBAN - HR\" );\n\tassert.ok( method( \"CH93 0076 2011 6238 5295 7\" ), \"Valid IBAN - CH\" );\n\tassert.ok( method( \"CY17 0020 0128 0000 0012 0052 7600\" ), \"Valid IBAN - CY\" );\n\tassert.ok( method( \"CZ65 0800 0000 1920 0014 5399\" ), \"Valid IBAN - CZ\" );\n\tassert.ok( method( \"DK50 0040 0440 1162 43\" ), \"Valid IBAN - DK\" );\n\tassert.ok( method( \"EE38 2200 2210 2014 5685\" ), \"Valid IBAN - EE\" );\n\tassert.ok( method( \"FO97 5432 0388 8999 44\" ), \"Valid IBAN - FO\" );\n\tassert.ok( method( \"FI21 1234 5600 0007 85\" ), \"Valid IBAN - FI\" );\n\tassert.ok( method( \"FR14 2004 1010 0505 0001 3M02 606\" ), \"Valid IBAN - FR\" );\n\tassert.ok( method( \"GE29 NB00 0000 0101 9049 17\" ), \"Valid IBAN - GE\" );\n\tassert.ok( method( \"DE89 3704 0044 0532 0130 00\" ), \"Valid IBAN - DE\" );\n\tassert.ok( method( \"GI75 NWBK 0000 0000 7099 453\" ), \"Valid IBAN - GI\" );\n\tassert.ok( method( \"GR16 0110 1250 0000 0001 2300 695\" ), \"Valid IBAN - GR\" );\n\tassert.ok( method( \"GL56 0444 9876 5432 10\" ), \"Valid IBAN - GL\" );\n\tassert.ok( method( \"HU42 1177 3016 1111 1018 0000 0000\" ), \"Valid IBAN - HU\" );\n\tassert.ok( method( \"IS14 0159 2600 7654 5510 7303 39\" ), \"Valid IBAN - IS\" );\n\tassert.ok( method( \"IE29 AIBK 9311 5212 3456 78\" ), \"Valid IBAN - IE\" );\n\tassert.ok( method( \"IL62 0108 0000 0009 9999 999\" ), \"Valid IBAN - IL\" );\n\tassert.ok( method( \"IT40 S054 2811 1010 0000 0123 456\" ), \"Valid IBAN - IT\" );\n\tassert.ok( method( \"LV80 BANK 0000 4351 9500 1\" ), \"Valid IBAN - LV\" );\n\tassert.ok( method( \"LB62 0999 0000 0001 0019 0122 9114\" ), \"Valid IBAN - LB\" );\n\tassert.ok( method( \"LI21 0881 0000 2324 013A A\" ), \"Valid IBAN - LI\" );\n\tassert.ok( method( \"LT12 1000 0111 0100 1000\" ), \"Valid IBAN - LT\" );\n\tassert.ok( method( \"LU28 0019 4006 4475 0000\" ), \"Valid IBAN - LU\" );\n\tassert.ok( method( \"MK07 2501 2000 0058 984\" ), \"Valid IBAN - MK\" );\n\tassert.ok( method( \"MT84 MALT 0110 0001 2345 MTLC AST0 01S\" ), \"Valid IBAN - MT\" );\n\tassert.ok( method( \"MU17 BOMM 0101 1010 3030 0200 000M UR\" ), \"Valid IBAN - MU\" );\n\tassert.ok( method( \"MD24 AG00 0225 1000 1310 4168\" ), \"Valid IBAN - MD\" );\n\tassert.ok( method( \"MC93 2005 2222 1001 1223 3M44 555\" ), \"Valid IBAN - MC\" );\n\tassert.ok( method( \"ME25 5050 0001 2345 6789 51\" ), \"Valid IBAN - ME\" );\n\tassert.ok( method( \"NL39 RABO 0300 0652 64\" ), \"Valid IBAN - NL\" );\n\tassert.ok( method( \"NO93 8601 1117 947\" ), \"Valid IBAN - NO\" );\n\tassert.ok( method( \"PK36 SCBL 0000 0011 2345 6702\" ), \"Valid IBAN - PK\" );\n\tassert.ok( method( \"PL60 1020 1026 0000 0422 7020 1111\" ), \"Valid IBAN - PL\" );\n\tassert.ok( method( \"PT50 0002 0123 1234 5678 9015 4\" ), \"Valid IBAN - PT\" );\n\tassert.ok( method( \"RO49 AAAA 1B31 0075 9384 0000\" ), \"Valid IBAN - RO\" );\n\tassert.ok( method( \"SM86 U032 2509 8000 0000 0270 100\" ), \"Valid IBAN - SM\" );\n\tassert.ok( method( \"SA03 8000 0000 6080 1016 7519\" ), \"Valid IBAN - SA\" );\n\tassert.ok( method( \"RS35 2600 0560 1001 6113 79\" ), \"Valid IBAN - RS\" );\n\tassert.ok( method( \"SK31 1200 0000 1987 4263 7541\" ), \"Valid IBAN - SK\" );\n\tassert.ok( method( \"SI56 1910 0000 0123 438\" ), \"Valid IBAN - SI\" );\n\tassert.ok( method( \"ES80 2310 0001 1800 0001 2345\" ), \"Valid IBAN - ES\" );\n\tassert.ok( method( \"SE35 5000 0000 0549 1000 0003\" ), \"Valid IBAN - SE\" );\n\tassert.ok( method( \"CH93 0076 2011 6238 5295 7\" ), \"Valid IBAN - CH\" );\n\tassert.ok( method( \"TN59 1000 6035 1835 9847 8831\" ), \"Valid IBAN - TN\" );\n\tassert.ok( method( \"TR33 0006 1005 1978 6457 8413 26\" ), \"Valid IBAN - TR\" );\n\tassert.ok( method( \"AE07 0331 2345 6789 0123 456\" ), \"Valid IBAN - AE\" );\n\tassert.ok( method( \"GB29 NWBK 6016 1331 9268 19\" ), \"Valid IBAN - GB\" );\n} );\n\n/**\n * BIC tests (For BIC definition take a look on the implementation itself)\n */\nQUnit.test( \"bic\", function( assert ) {\n\tvar method = methodTest( \"bic\" );\n\n\tassert.ok( !method( \"PBNKDEF\" ), \"Invalid BIC: too short\" );\n\tassert.ok( !method( \"DEUTDEFFA1\" ), \"Invalid BIC: disallowed length\" );\n\tassert.ok( !method( \"PBNKDEFFXXX1\" ), \"Invalid BIC: too long\" );\n\tassert.ok( !method( \"1BNKDEFF\" ), \"Invalid BIC: invalid digit\" );\n\tassert.ok( !method( \"PBNKDE1F\" ), \"Invalid BIC: invalid digit\" );\n\tassert.ok( !method( \"PBNKDEFO\" ), \"Invalid BIC: invalid char\" );\n\tassert.ok( !method( \"INGDDEFFXAA\" ), \"Invalid BIC: invalid char\" );\n\tassert.ok( !method( \"DEUTDEF0\" ), \"Invalid BIC: invalid digit\" );\n\n\tassert.ok( method( \"DEUTDEFF\" ), \"Valid BIC\" );\n\tassert.ok( method( \"DEUTDEFFXXX\" ), \"Valid BIC\" );\n\tassert.ok( method( \"PBNKDE2F\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDEFF101\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDEF2134\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDE91XXX\" ), \"Valid BIC\" );\n\tassert.ok( method( \"INGDDEF2\" ), \"Valid BIC\" );\n\tassert.ok( method( \"AAFFFRP1\" ), \"Valid BIC\" );\n\tassert.ok( method( \"DEUTDEFFAB1\" ), \"Valid BIC\" );\n\tassert.ok( method( \"DEUTDEFFAXX\" ), \"Valid BIC\" );\n\tassert.ok( method( \"SSKNDE77XXX\" ), \"Valid BIC\" );\n\n\t// BIC accept also lowercased values\n\tassert.ok( !method( \"pbnkdef\" ), \"Invalid BIC: too short\" );\n\tassert.ok( !method( \"deutdeffa1\" ), \"Invalid BIC: disallowed length\" );\n\tassert.ok( !method( \"pbnkdeffxxx1\" ), \"Invalid BIC: too long\" );\n\tassert.ok( !method( \"1bnkdeff\" ), \"Invalid BIC: invalid digit\" );\n\tassert.ok( !method( \"ingddeffxaa\" ), \"Invalid BIC: invalid char\" );\n\n\tassert.ok( method( \"deutdeff\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"deutdeffxxx\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"pbnkde2f\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"ingdde91xxx\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"ingddef2\" ), \"Valid BIC (lowercase value)\" );\n\tassert.ok( method( \"deutdeffab1\" ), \"Valid BIC (lowercase value)\" );\n} );\n\nQUnit.test( \"postcodeUK\", function( assert ) {\n\tvar method = methodTest( \"postcodeUK\" );\n\tassert.ok( method( \"AA9A 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"A9A 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"A9 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"A99 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"AA9 9AA\" ), \"Valid postcode\" );\n\tassert.ok( method( \"AA99 9AA\" ), \"Valid postcode\" );\n\n\t// Channel Island\n\tassert.ok( !method( \"AAAA 9AA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"AA-2640\" ), \"Invalid postcode\" );\n\n\tassert.ok( !method( \"AAA AAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"AA AAAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"A AAAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"AAAAA\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"999 999\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"99 9999\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"9 9999\" ), \"Invalid postcode\" );\n\tassert.ok( !method( \"99999\" ), \"Invalid postcode\" );\n} );\n\nQUnit.test( \"dateNL\", function( assert ) {\n\tvar method = methodTest( \"dateNL\" );\n\tassert.ok( method( \"01-01-1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"01.01.1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"01/01/1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"01-01-00\" ), \"Valid date NL\" );\n\tassert.ok( method( \"1-01-1900\" ), \"Valid date NL\" );\n\tassert.ok( method( \"10-10-1900\" ), \"Valid date NL\" );\n\tassert.ok( !method( \"0-01-1900\" ), \"Invalid date NL\" );\n\tassert.ok( !method( \"00-01-1900\" ), \"Invalid date NL\" );\n\tassert.ok( !method( \"35-01-1990\" ), \"Invalid date NL\" );\n\tassert.ok( !method( \"01.01.190\" ), \"Invalid date NL\" );\n} );\n\nQUnit.test( \"phoneNL\", function( assert ) {\n\tvar method = methodTest( \"phoneNL\" );\n\tassert.ok( method( \"0701234567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"0687654321\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"020-1234567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"020 - 12 34 567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"010-2345678\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"+3120-1234567\" ), \"Valid phone NL\" );\n\tassert.ok( method( \"+31(0)10-2345678\" ), \"Valid phone NL\" );\n\tassert.ok( !method( \"020-123456\" ), \"Invalid phone NL: too short\" );\n\tassert.ok( !method( \"020-12345678\" ), \"Invalid phone NL: too long\" );\n\tassert.ok( !method( \"-0201234567\" ), \"Invalid phone NL\" );\n\tassert.ok( !method( \"+310201234567\" ), \"Invalid phone NL: no 0 after +31 allowed\" );\n} );\n\nQUnit.test( \"mobileNL\", function( assert ) {\n\tvar method = methodTest( \"mobileNL\" );\n\tassert.ok( method( \"0612345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"06-12345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"06-12 345 678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"+316-12345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( method( \"+31(0)6-12345678\" ), \"Valid NL Mobile Number\" );\n\tassert.ok( !method( \"abcdefghij\" ), \"Invalid NL Mobile Number: text\" );\n\tassert.ok( !method( \"0123456789\" ), \"Invalid NL Mobile Number: should start with 06\" );\n\tassert.ok( !method( \"0823456789\" ), \"Invalid NL Mobile Number: should start with 06\" );\n\tassert.ok( !method( \"06-1234567\" ), \"Invalid NL Mobile Number: too short\" );\n\tassert.ok( !method( \"06-123456789\" ), \"Invalid NL Mobile Number: too long\" );\n\tassert.ok( !method( \"-0612345678\" ), \"Invalid NL Mobile Number\" );\n\tassert.ok( !method( \"+310612345678\" ), \"Invalid NL Mobile Number: no 0 after +31 allowed\" );\n} );\n\nQUnit.test( \"postalcodeNL\", function( assert ) {\n\tvar method = methodTest( \"postalcodeNL\" );\n\tassert.ok( method( \"1234AB\" ), \"Valid NL Postal Code\" );\n\tassert.ok( method( \"1234ab\" ), \"Valid NL Postal Code\" );\n\tassert.ok( method( \"1234 AB\" ), \"Valid NL Postal Code\" );\n\tassert.ok( method( \"6789YZ\" ), \"Valid NL Postal Code\" );\n\tassert.ok( !method( \"123AA\" ), \"Invalid NL Postal Code: not enough digits\" );\n\tassert.ok( !method( \"12345ZZ\" ), \"Invalid NL Postal Code: too many digits\" );\n\tassert.ok( !method( \"1234  AA\" ), \"Invalid NL Postal Code: too many spaces\" );\n\tassert.ok( !method( \"AA1234\" ), \"Invalid NL Postal Code\" );\n\tassert.ok( !method( \"1234-AA\" ), \"Invalid NL Postal Code\" );\n} );\n\nQUnit.test( \"bankaccountNL\", function( assert ) {\n\tvar method = methodTest( \"bankaccountNL\" );\n\tassert.ok( method( \"755490975\" ), \"Valid NL bank account\" );\n\tassert.ok( method( \"75 54 90 975\" ), \"Valid NL bank account\" );\n\tassert.ok( method( \"123456789\" ), \"Valid NL bank account\" );\n\tassert.ok( method( \"12 34 56 789\" ), \"Valid NL bank account\" );\n\tassert.ok( !method( \"12 3456789\" ), \"Valid NL bank account: inconsistent spaces\" );\n\tassert.ok( !method( \"123 45 67 89\" ), \"Valid NL bank account: incorrect spaces\" );\n\tassert.ok( !method( \"755490971\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"755490973\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"755490979\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"123456781\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"123456784\" ), \"Invalid NL bank account\" );\n\tassert.ok( !method( \"123456788\" ), \"Invalid NL bank account\" );\n} );\n\nQUnit.test( \"giroaccountNL\", function( assert ) {\n\tvar method = methodTest( \"giroaccountNL\" );\n\tassert.ok( method( \"123\" ), \"Valid NL giro  account\" );\n\tassert.ok( method( \"1234567\" ), \"Valid NL giro account\" );\n\tassert.ok( !method( \"123456788\" ), \"Invalid NL giro account\" );\n} );\n\nQUnit.test( \"bankorgiroaccountNL\", function( assert ) {\n\tvar method = methodTest( \"bankorgiroaccountNL\" );\n\tassert.ok( method( \"123\" ), \"Valid NL giro account\" );\n\tassert.ok( method( \"1234567\" ), \"Valid NL giro account\" );\n\tassert.ok( method( \"123456789\" ), \"Valid NL bank account\" );\n\tassert.ok( !method( \"12345678\" ), \"Invalid NL bank or giro account\" );\n\tassert.ok( !method( \"123456788\" ), \"Invalid NL bank or giro account\" );\n} );\n\nQUnit.test( \"time\", function( assert ) {\n\tvar method = methodTest( \"time\" );\n\tassert.ok( method( \"00:00\" ), \"Valid time, lower bound\" );\n\tassert.ok( method( \"23:59\" ), \"Valid time, upper bound\" );\n\tassert.ok( method( \"3:59\" ), \"Valid time, single digit hour\" );\n\tassert.ok( !method( \"12\" ), \"Invalid time\" );\n\tassert.ok( !method( \"29:59\" ), \"Invalid time\" );\n\tassert.ok( !method( \"00:60\" ), \"Invalid time\" );\n\tassert.ok( !method( \"24:60\" ), \"Invalid time\" );\n\tassert.ok( !method( \"24:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"30:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"29:59\" ), \"Invalid time\" );\n\tassert.ok( !method( \"120:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"12:001\" ), \"Invalid time\" );\n\tassert.ok( !method( \"12:00a\" ), \"Invalid time\" );\n} );\n\nQUnit.test( \"time12h\", function( assert ) {\n\tvar method = methodTest( \"time12h\" );\n\tassert.ok( method( \"12:00 AM\" ), \"Valid time, lower bound, am\" );\n\tassert.ok( method( \"11:59 AM\" ), \"Valid time, upper bound, am\" );\n\tassert.ok( method( \"12:00AM\" ), \"Valid time, no space, am\" );\n\tassert.ok( method( \"12:00PM\" ), \"Valid time, no space, pm\" );\n\tassert.ok( method( \"12:00 PM\" ), \"Valid time, lower bound, pm\" );\n\tassert.ok( method( \"11:59 PM\" ), \"Valid time, upper bound, pm\" );\n\tassert.ok( method( \"11:59 am\" ), \"Valid time, also accept lowercase\" );\n\tassert.ok( method( \"11:59 pm\" ), \"Valid time, also accept lowercase\" );\n\tassert.ok( method( \"1:59 pm\" ), \"Valid time, single hour, no leading 0\" );\n\tassert.ok( method( \"01:59 pm\" ), \"Valid time, single hour, leading 0\" );\n\tassert.ok( !method( \"12:00\" ), \"Invalid time\" );\n\tassert.ok( !method( \"9\" ), \"Invalid time\" );\n\tassert.ok( !method( \"9 am\" ), \"Invalid time\" );\n\tassert.ok( !method( \"12:61 am\" ), \"Invalid time\" );\n\tassert.ok( !method( \"13:00 am\" ), \"Invalid time\" );\n\tassert.ok( !method( \"00:00 am\" ), \"Invalid time\" );\n} );\n\nQUnit.test( \"minWords\", function( assert ) {\n\tvar method = methodTest( \"minWords\" );\n\tassert.ok( method( \"hello worlds\", 2 ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>hello</b> world\", 2 ), \"html, valid\" );\n\tassert.ok( !method( \"hello\", 2 ), \"plain text, invalid\" );\n\tassert.ok( !method( \"<b>world</b>\", 2 ), \"html, invalid\" );\n\tassert.ok( !method( \"world <br/>\", 2 ), \"html, invalid\" );\n} );\n\nQUnit.test( \"maxWords\", function( assert ) {\n\tvar method = methodTest( \"maxWords\" );\n\tassert.ok( method( \"hello\", 2 ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>world</b>\", 2 ), \"html, valid\" );\n\tassert.ok( method( \"world <br/>\", 2 ), \"html, valid\" );\n\tassert.ok( method( \"hello worlds\", 2 ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>hello</b> world\", 2 ), \"html, valid\" );\n\tassert.ok( !method( \"hello 123 world\", 2 ), \"plain text, invalid\" );\n\tassert.ok( !method( \"<b>hello</b> 123 world\", 2 ), \"html, invalid\" );\n} );\n\nQUnit.test( \"rangeWords\", function( assert ) {\n\tvar method = methodTest( \"rangeWords\" );\n\tassert.ok( method( \"hello\", [ 0, 2 ] ), \"plain text, valid\" );\n\tassert.ok( method( \"hello worlds\", [ 0, 2 ] ), \"plain text, valid\" );\n\tassert.ok( method( \"<b>hello</b> world\", [ 0, 2 ] ), \"html, valid\" );\n\tassert.ok( !method( \"hello worlds what is up\", [ 0, 2 ] ), \"plain text, invalid\" );\n\tassert.ok( !method( \"<b>Hello</b> <b>world</b> <b>hello</b>\", [ 0, 2 ] ), \"html, invalid\" );\n} );\n\nQUnit.test( \"pattern\", function( assert ) {\n\tvar method = methodTest( \"pattern\" );\n\tassert.ok( method( \"AR1004\", \"AR\\\\d{4}\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( method( \"AR1004\", /^AR\\d{4}$/ ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"BR1004\", /^AR\\d{4}$/ ), \"Invalid format for the given RegExp\" );\n\tassert.ok( method( \"1ABC\", \"[0-9][A-Z]{3}\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"ABC\", \"[0-9][A-Z]{3}\" ), \"Invalid format for the given RegExp\" );\n\tassert.ok( !method( \"1ABC DEF\", \"[0-9][A-Z]{3}\" ), \"Invalid format for the given RegExp\" );\n\tassert.ok( method( \"1ABCdef\", \"[a-zA-Z0-9]+\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"1ABC def\", \"[a-zA-Z0-9]+\" ), \"Invalid format for the given RegExp\" );\n\tassert.ok( method( \"2014-10-02\", \"[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])\" ), \"Correct format for the given RegExp\" );\n\tassert.ok( !method( \"02-10-2014\", \"[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])\" ), \"Invalid format for the given RegExp\" );\n} );\n\nfunction testCardTypeByNumber( assert, number, cardname, expected ) {\n\t$( \"#cardnumber\" ).val( number );\n\tvar actual = $( \"#ccform\" ).valid();\n\tassert.equal( actual, expected, $.validator.format( \"Expect card number {0} to validate to {1}, actually validated to \", number, expected ) );\n}\n\nQUnit.test( \"creditcardtypes, all\", function( assert ) {\n\t$( \"#ccform\" ).validate( {\n\t\trules: {\n\t\t\tcardnumber: {\n\t\t\t\tcreditcard: true,\n\t\t\t\tcreditcardtypes: {\n\t\t\t\t\tall: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1111\", \"VISA\", true );\n\ttestCardTypeByNumber( assert, \"2211-1111-1111-1114\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"5111-1111-1111-1118\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"6111-1111-1111-1116\", \"Discover\", true );\n\ttestCardTypeByNumber( assert, \"3400-0000-0000-009\", \"AMEX\", true );\n\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1110\", \"VISA\", false );\n\ttestCardTypeByNumber( assert, \"5432-1111-1111-1111\", \"MasterCard\", false );\n\ttestCardTypeByNumber( assert, \"6611-6611-6611-6611\", \"Discover\", false );\n\ttestCardTypeByNumber( assert, \"3777-7777-7777-7777\", \"AMEX\", false );\n} );\n\nQUnit.test( \"creditcardtypes, visa\", function( assert ) {\n\t$( \"#ccform\" ).validate( {\n\t\trules: {\n\t\t\tcardnumber: {\n\t\t\t\tcreditcard: true,\n\t\t\t\tcreditcardtypes: {\n\t\t\t\t\tvisa: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1111\", \"VISA\", true );\n\ttestCardTypeByNumber( assert, \"5111-1111-1111-1118\", \"MasterCard\", false );\n\ttestCardTypeByNumber( assert, \"6111-1111-1111-1116\", \"Discover\", false );\n\ttestCardTypeByNumber( assert, \"3400-0000-0000-009\", \"AMEX\", false );\n} );\n\nQUnit.test( \"creditcardtypes, mastercard\", function( assert ) {\n\t$( \"#ccform\" ).validate( {\n\t\trules: {\n\t\t\tcardnumber: {\n\t\t\t\tcreditcard: true,\n\t\t\t\tcreditcardtypes: {\n\t\t\t\t\tmastercard: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\ttestCardTypeByNumber( assert, \"2211-1111-1111-1114\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"5111-1111-1111-1118\", \"MasterCard\", true );\n\ttestCardTypeByNumber( assert, \"6111-1111-1111-1116\", \"Discover\", false );\n\ttestCardTypeByNumber( assert, \"3400-0000-0000-009\", \"AMEX\", false );\n\ttestCardTypeByNumber( assert, \"4111-1111-1111-1111\", \"VISA\", false );\n} );\n\nfunction fillFormWithValuesAndExpect( assert, formSelector, inputValues, expected ) {\n\tvar i, actual;\n\n\tfor ( i = 0; i < inputValues.length; i++ ) {\n\t\t$( formSelector + \" input:eq(\" + i + \")\" ).val( inputValues[ i ] );\n\t}\n\tactual = $( formSelector ).valid();\n\tassert.equal( actual, expected, $.validator.format( \"Filled inputs of form '{0}' with {1} values ({2})\", formSelector, inputValues.length, inputValues.toString() ) );\n\n}\n\nQUnit.test( \"require_from_group\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tdiscount: { require_from_group: [ 2, \".productInfo\" ] }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], false );\n\t$( \"#productInfo input[type='checkbox']\" ).attr( \"checked\", \"checked\" );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], true );\n\t$( \"#productInfo input[type='checkbox']\" ).removeAttr( \"checked\" );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\" ], true );\n} );\n\nQUnit.test( \"require_from_group preserve other rules\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tcolor: { require_from_group: [ 2, \".productInfo\" ] },\n\t\t\tsupplier: { required: true }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ \"\", \"\", \"\", \"Acme\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"\", \"\", \"Acme\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"\", \"Acme\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\", \"Acme\" ], true );\n} );\n\nQUnit.test( \"skip_or_fill_minimum\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber:  { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tcolor:       { skip_or_fill_minimum: [ 2, \".productInfo\" ] }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123 ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\" ], true );\n} );\n\nQUnit.test( \"skip_or_fill_minimum preserve other rules\", function( assert ) {\n\t$( \"#productInfo\" ).validate( {\n\t\trules: {\n\t\t\tpartnumber:  { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tdescription: { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tcolor:       { skip_or_fill_minimum: [ 2, \".productInfo\" ] },\n\t\t\tsupplier: { required: true }\n\t\t}\n\t} );\n\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ \"\", \"\", \"\", \"Acme\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"\", \"\", \"Acme\" ], false );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"\", \"Acme\" ], true );\n\tfillFormWithValuesAndExpect( assert, \"#productInfo\", [ 123, \"widget\", \"red\", \"Acme\" ], true );\n} );\n\nQUnit.test( \"zipcodeUS\", function( assert ) {\n\tvar method = methodTest( \"zipcodeUS\" );\n\tassert.ok( method( \"12345\" ), \"Valid zip\" );\n\tassert.ok( method( \"12345-2345\" ), \"Valid zip\" );\n\tassert.ok( method( \"90210-4567\" ), \"Valid zip\" );\n\tassert.ok( !method( \"1\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"1234\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"123-23\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"12345-43\" ), \"Invalid zip\" );\n\tassert.ok( !method( \"123456-7890\" ), \"Invalid zip\" );\n} );\n\nQUnit.test( \"nifES\", function( assert ) {\n\tvar method = methodTest( \"nifES\" );\n\tassert.ok( method( \"11441059P\" ), \"NIF valid\" );\n\tassert.ok( method( \"80054306T\" ), \"NIF valid\" );\n\tassert.ok( method( \"76048581R\" ), \"NIF valid\" );\n\tassert.ok( method( \"28950849J\" ), \"NIF valid\" );\n\tassert.ok( method( \"34048598L\" ), \"NIF valid\" );\n\tassert.ok( method( \"28311529R\" ), \"NIF valid\" );\n\tassert.ok( method( \"34673804Q\" ), \"NIF valid\" );\n\tassert.ok( method( \"92133247P\" ), \"NIF valid\" );\n\tassert.ok( method( \"77149717N\" ), \"NIF valid\" );\n\tassert.ok( method( \"15762034L\" ), \"NIF valid\" );\n\tassert.ok( method( \"05122654W\" ), \"NIF valid\" );\n\tassert.ok( method( \"05122654w\" ), \"NIF valid: lower case\" );\n\tassert.ok( method( \"M1503708Z\" ), \"NIF valid. Temporary foreign nif\" );\n\tassert.ok( !method( \"1144105R\" ), \"NIF invalid: less than 8 digits without zero\" );\n\tassert.ok( !method( \"11441059 R\" ), \"NIF invalid: white space\" );\n\tassert.ok( !method( \"11441059\" ), \"NIF invalid: no letter\" );\n\tassert.ok( !method( \"11441059PR\" ), \"NIF invalid: two letters\" );\n\tassert.ok( !method( \"11440059R\" ), \"NIF invalid: wrong number\" );\n\tassert.ok( !method( \"11441059S\" ), \"NIF invalid: wrong letter\" );\n\tassert.ok( !method( \"114410598R\" ), \"NIF invalid: > 8 digits\" );\n\tassert.ok( !method( \"11441059-R\" ), \"NIF invalid: dash\" );\n\tassert.ok( !method( \"asdasdasd\" ), \"NIF invalid: all letters\" );\n\tassert.ok( !method( \"11.144.059R\" ), \"NIF invalid: two dots\" );\n\tassert.ok( !method( \"05.122.654R\" ), \"NIF invalid: starts with 0 and dots\" );\n\tassert.ok( !method( \"5.122.654-R\" ), \"NIF invalid:  dots and dash\" );\n\tassert.ok( !method( \"05.122.654-R\" ), \"NIF invalid: starts with zero and dot and dash\" );\n} );\n\nQUnit.test( \"nieES\", function( assert ) {\n\tvar method = methodTest( \"nieES\" );\n\tassert.ok( method( \"X0093999K\" ), \"NIE valid\" );\n\tassert.ok( method( \"X1923000Q\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z9669587R\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z8945005B\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z6663465W\" ), \"NIE valid\" );\n\tassert.ok( method( \"Y7875935J\" ), \"NIE valid\" );\n\tassert.ok( method( \"X3390130E\" ), \"NIE valid\" );\n\tassert.ok( method( \"Y7699182S\" ), \"NIE valid\" );\n\tassert.ok( method( \"Y1524243R\" ), \"NIE valid\" );\n\tassert.ok( method( \"X3744072V\" ), \"NIE valid\" );\n\tassert.ok( method( \"X7436800A\" ), \"NIE valid\" );\n\tassert.ok( method( \"X00002153Z\" ), \"NIE valid\" );\n\tassert.ok( method( \"X02323232W\" ), \"NIE valid\" );\n\tassert.ok( method( \"Z0569549M\" ), \"NIE valid\" );\n\tassert.ok( method( \"X0479906B\" ), \"NIE valid\" );\n\tassert.ok( method( \"y7875935j\" ), \"NIE valid: lower case\" );\n\n\tassert.ok( !method( \"X0093999 K\" ), \"NIE invalid: white space\" );\n\tassert.ok( !method( \"X 0093999 K\" ), \"NIE invalid:  white space\" );\n\tassert.ok( !method( \"11441059\" ), \"NIE invalid: no letter\" );\n\tassert.ok( !method( \"11441059PR\" ), \"NIE invalid: two letters\" );\n\tassert.ok( !method( \"11440059R\" ), \"NIE invalid: wrong number\" );\n\tassert.ok( !method( \"11441059S\" ), \"NIE invalid: wrong letter\" );\n\tassert.ok( !method( \"114410598R\" ), \"NIE invalid: > 8 digits\" );\n\tassert.ok( !method( \"11441059-R\" ), \"NIE invalid: dash\" );\n\tassert.ok( !method( \"asdasdasd\" ), \"NIE invalid: all letters\" );\n\tassert.ok( !method( \"11.144.059R\" ), \"NIE invalid: two dots\" );\n\tassert.ok( !method( \"05.122.654R\" ), \"NIE invalid: starts with 0 and dots\" );\n\tassert.ok( !method( \"5.122.654-R\" ), \"NIE invalid: dots and dash\" );\n\tassert.ok( !method( \"05.122.654-R\" ), \"NIE invalid: starts with zero and dot and dash\" );\n} );\n\nQUnit.test( \"cifES\", function( assert ) {\n\tvar method = methodTest( \"cifES\" );\n\tassert.ok( method( \"A58818501\" ), \"CIF valid\" );\n\tassert.ok( method( \"A79082244\" ), \"CIF valid\" );\n\tassert.ok( method( \"A60917978\" ), \"CIF valid\" );\n\tassert.ok( method( \"A39000013\" ), \"CIF valid\" );\n\tassert.ok( method( \"A28315182\" ), \"CIF valid\" );\n\tassert.ok( method( \"A75409573\" ), \"CIF valid\" );\n\tassert.ok( method( \"A34396994\" ), \"CIF valid\" );\n\tassert.ok( method( \"A08153538\" ), \"CIF valid\" );\n\tassert.ok( method( \"A09681396\" ), \"CIF valid\" );\n\tassert.ok( method( \"A06706303\" ), \"CIF valid\" );\n\tassert.ok( method( \"A66242173\" ), \"CIF valid\" );\n\tassert.ok( method( \"A61416699\" ), \"CIF valid\" );\n\tassert.ok( method( \"A99545444\" ), \"CIF valid\" );\n\tassert.ok( method( \"A10407252\" ), \"CIF valid\" );\n\tassert.ok( method( \"A76170885\" ), \"CIF valid\" );\n\tassert.ok( method( \"A83535047\" ), \"CIF valid\" );\n\tassert.ok( method( \"A46031969\" ), \"CIF valid\" );\n\tassert.ok( method( \"A97252910\" ), \"CIF valid\" );\n\tassert.ok( method( \"A79082244\" ), \"CIF valid\" );\n\tassert.ok( !method( \"A7908224D\" ), \"CIF invalid: digit control must be a number (4)\" );\n\n\tassert.ok( method( \"B71413892\" ), \"CIF valid\" );\n\tassert.ok( method( \"B37484755\" ), \"CIF valid\" );\n\tassert.ok( method( \"B15940893\" ), \"CIF valid\" );\n\tassert.ok( method( \"B55429161\" ), \"CIF valid\" );\n\tassert.ok( method( \"B93337087\" ), \"CIF valid\" );\n\tassert.ok( method( \"B43522192\" ), \"CIF valid\" );\n\tassert.ok( method( \"B38624334\" ), \"CIF valid\" );\n\tassert.ok( method( \"B21920426\" ), \"CIF valid\" );\n\tassert.ok( method( \"B74940156\" ), \"CIF valid\" );\n\tassert.ok( method( \"B46125746\" ), \"CIF valid\" );\n\tassert.ok( method( \"B67077537\" ), \"CIF valid\" );\n\tassert.ok( method( \"B21283155\" ), \"CIF valid\" );\n\tassert.ok( method( \"B57104176\" ), \"CIF valid\" );\n\tassert.ok( method( \"B25060179\" ), \"CIF valid\" );\n\tassert.ok( method( \"B06536338\" ), \"CIF valid\" );\n\tassert.ok( method( \"B50964592\" ), \"CIF valid\" );\n\tassert.ok( method( \"B15653330\" ), \"CIF valid\" );\n\tassert.ok( method( \"B83524710\" ), \"CIF valid\" );\n\tassert.ok( !method( \"B8352471J\" ), \"CIF invalid: digit control must be a number (0)\" );\n\n\tassert.ok( !method( \"C27827551\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827552\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827553\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827554\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827555\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827556\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827557\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827558\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C27827550\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755A\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755B\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755C\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755D\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755E\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755F\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755G\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755H\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( !method( \"C2782755J\" ), \"CIF invalid: wrong digit control\" );\n\tassert.ok( method( \"C2782755I\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\tassert.ok( method( \"C27827559\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"E48911572\" ), \"CIF valid\" );\n\tassert.ok( method( \"E93928703\" ), \"CIF valid\" );\n\tassert.ok( method( \"E17472952\" ), \"CIF valid\" );\n\tassert.ok( !method( \"E1747295B\" ), \"CIF invalid: digit control must be a number (2)\" );\n\n\tassert.ok( method( \"F41190612\" ), \"CIF valid\" );\n\tassert.ok( method( \"F4119061B\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"G72102064\" ), \"CIF valid\" );\n\tassert.ok( method( \"G32937757\" ), \"CIF valid\" );\n\tassert.ok( method( \"G8984953C\" ), \"CIF valid\" );\n\tassert.ok( method( \"G3370454E\" ), \"CIF valid\" );\n\tassert.ok( method( \"G33704545\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"H48911572\" ), \"CIF valid\" );\n\tassert.ok( method( \"H93928703\" ), \"CIF valid\" );\n\tassert.ok( method( \"H17472952\" ), \"CIF valid\" );\n\tassert.ok( !method( \"H1747295B\" ), \"CIF invalid: digit control must be a number (2)\" );\n\n\tassert.ok( !method( \"I48911572\" ), \"CIF invalid: starts with I\" );\n\n\tassert.ok( method( \"J85081081\" ), \"CIF valid\" );\n\tassert.ok( method( \"J8508108A\" ), \"CIF valid\" );\n\n\tassert.ok( method( \"K3902238I\" ), \"CIF valid\" );\n\tassert.ok( !method( \"K39022389\" ), \"CIF invalid. Digit control must be a letter (I)\" );\n\n\tassert.ok( method( \"M9916080F\" ), \"CIF valid\" );\n\tassert.ok( method( \"M1566151E\" ), \"CIF valid\" );\n\tassert.ok( method( \"M15661515\" ), \"CIF valid\" );\n\tassert.ok( method( \"M4778730D\" ), \"CIF valid\" );\n\n\tassert.ok( method( \"N1172218H\" ), \"CIF valid\" );\n\tassert.ok( method( \"N4094938J\" ), \"CIF valid\" );\n\tassert.ok( method( \"N40949380\" ), \"CIF valid. Digit control can be either a number or letter\" );\n\n\tassert.ok( method( \"P5141387J\" ), \"CIF valid\" );\n\tassert.ok( method( \"P9803881C\" ), \"CIF valid\" );\n\tassert.ok( !method( \"P98038813\" ), \"CIF invalid: digit control must be a letter (C)\" );\n\n\tassert.ok( method( \"Q5141387J\" ), \"CIF valid\" );\n\tassert.ok( method( \"Q9803881C\" ), \"CIF valid\" );\n\tassert.ok( !method( \"Q98038813\" ), \"CIF invalid: digit control must be a letter (C)\" );\n\n\tassert.ok( method( \"S5141387J\" ), \"CIF valid\" );\n\tassert.ok( method( \"S9803881C\" ), \"CIF valid\" );\n\tassert.ok( !method( \"S98038813\" ), \"CIF invalid: digit control must be a letter (C)\" );\n\tassert.ok( method( \"s98038813\" ), \"CIF valid: lower case\" );\n\n\tassert.ok( !method( \"X48911572\" ), \"CIF invalid: starts with X\" );\n\tassert.ok( !method( \"Y48911572\" ), \"CIF invalid: starts with Y\" );\n\tassert.ok( !method( \"Z48911572\" ), \"CIF invalid: starts with Z\" );\n\tassert.ok( !method( \"Z98038813\" ), \"CIF invalid: wrong letter\" );\n\tassert.ok( !method( \"B 43522192\" ), \"CIF invalid: white spaces\" );\n\tassert.ok( !method( \"43522192\" ), \"CIF invalid: missing letter\" );\n\tassert.ok( !method( \"BB43522192\" ), \"CIF invalid: two letters\" );\n\tassert.ok( !method( \"B53522192\" ), \"CIF invalid: wrong number\" );\n\tassert.ok( !method( \"B433522192\" ), \"CIF invalid: > 8 digits\" );\n\tassert.ok( !method( \"B3522192\" ), \"CIF invalid: < 8 digits\" );\n\tassert.ok( !method( \"B-43522192\" ), \"CIF invalid: dash\" );\n\tassert.ok( !method( \"Basdasdas\" ), \"CIF invalid: all letters\" );\n\tassert.ok( !method( \"B43.522.192\" ), \"CIF invalid: dots\" );\n\tassert.ok( !method( \"B-43.522.192\" ), \"CIF invalid: dots and dash\" );\n} );\n\nQUnit.test( \"nipPL\", function( assert ) {\n\tvar method = methodTest( \"nipPL\" );\n\tassert.ok( method( \"3514242002\" ), \"NIP valid\" );\n\tassert.ok( method( \"8117892840\" ), \"NIP valid\" );\n\tassert.ok( method( \"7249598309\" ), \"NIP valid\" );\n\tassert.ok( method( \"6853539166\" ), \"NIP valid\" );\n\tassert.ok( method( \"5715750580\" ), \"NIP valid\" );\n\tassert.ok( method( \"3496120813\" ), \"NIP valid\" );\n\tassert.ok( method( \"1565710251\" ), \"NIP valid\" );\n\tassert.ok( method( \"8190761165\" ), \"NIP valid\" );\n\tassert.ok( method( \"9487499667\" ), \"NIP valid\" );\n\tassert.ok( method( \"9283384684\" ), \"NIP valid\" );\n\tassert.ok( method( \"3887569138\" ), \"NIP valid\" );\n\tassert.ok( method( \"3962898856\" ), \"NIP valid\" );\n\tassert.ok( !method( \"76355753\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"454\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"234565545\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"543455\" ), \"NIP invalid: too short\" );\n\tassert.ok( !method( \"6345634563456\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"53453453455335\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"543453760902\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"43090012454\" ), \"NIP invalid: too long\" );\n\tassert.ok( !method( \"3958250194\" ), \"NIP invalid: wrong checksum\" );\n\tassert.ok( !method( \"3928541049\" ), \"NIP invalid: wrong checksum\" );\n\tassert.ok( !method( \"5920397295\" ), \"NIP invalid: wrong checksum\" );\n\tassert.ok( !method( \"9502947712\" ), \"NIP invalid: wrong checksum\" );\n} );\n\nQUnit.test( \"phonePL\", function( assert ) {\n    var method = methodTest( \"phonePL\" );\n\tassert.ok( method( \"+48 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \"00 48 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \"(+48) 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \"(48) 123 456 789\" ), \"Valid phone PL\" );\n\tassert.ok( method( \" 13 34 56 78  9 \" ), \"Valid phone PL\" );\n\tassert.ok( method( \"13 345 67 89\" ), \"Valid phone PL\" );\n\tassert.ok( !method( \"100 000 000\" ), \"Invalid phone PL: cannot start with 10x xxx xxx\" );\n\tassert.ok( !method( \"111 111 111\" ), \"Invalid phone PL: cannot start with 11x xxx xxx\" );\n\tassert.ok( !method( \"123 456 78\" ), \"Invalid phone PL: too short\" );\n\tassert.ok( !method( \"123 4567890\" ), \"Invalid phone PL: too long\" );\n\tassert.ok( !method( \"700 123 456\" ), \"Invalid phone PL: intelligent network, premium rate\" );\n\tassert.ok( !method( \"800 123 456\" ), \"Invalid phone PL: intelligent network, freephone\" );\n\tassert.ok( !method( \"980 000 000\" ), \"Invalid phone PL: cannot start with 98x xxx xxx\" );\n\tassert.ok( !method( \"990 000 000\" ), \"Invalid phone PL: cannot start with 99x xxx xxx\" );\n} );\n\nQUnit.test( \"maxWords\", function( assert ) {\n\tvar method = methodTest( \"maxWords\" ),\n\t\tmaxWords = 6;\n\n\tassert.ok( method( \"I am a sentence\", maxWords ), \"Max Words\" );\n\tassert.ok( !method( \"I'm way too long for this sentence!\", maxWords ), \"Too many words\" );\n\tassert.ok( method( \"Don\u2019t \u201ccount\u201d me as too long\", maxWords ), \"Right amount of words with smartquotes\" );\n\tassert.ok( !method( \"But you can \u201ccount\u201d me as too long\", maxWords ), \"Too many words with smartquotes\" );\n\tassert.ok( method( \"<div>Don\u2019t \u201ccount\u201d me as too long</div>\", maxWords ), \"Right amount of words with smartquotes w/ HTML\" );\n\tassert.ok( !method( \"<div>But you can \u201ccount\u201d me as too long</div>\", maxWords ), \"Too many words with smartquotes w/ HTML\" );\n} );\n\nQUnit.test( \"minWords\", function( assert ) {\n\tvar method = methodTest( \"minWords\" ),\n\t\tminWords = 6;\n\n\tassert.ok( !method( \"I am a short sentence\", minWords ), \"Max Words\" );\n\tassert.ok( method( \"I'm way too long for this sentence!\", minWords ), \"Too many words\" );\n\tassert.ok( !method( \"Don\u2019t \u201ccount\u201d me as short.\", minWords ), \"Right amount of words with smartquotes\" );\n\tassert.ok( method( \"But you can \u201ccount\u201d me as too short\", minWords ), \"Too many words with smartquotes\" );\n\tassert.ok( !method( \"<div>\u201cCount\u201d me as too short.</div>\", minWords ), \"Right amount of words with smartquotes w/ HTML\" );\n\tassert.ok( method( \"<div>But you can \u201ccount\u201d me as too long</div>\", minWords ), \"Too many words with smartquotes w/ HTML\" );\n} );\n\nQUnit.test( \"rangeWords\", function( assert ) {\n\tvar method = methodTest( \"rangeWords\" ),\n\t\trangeWords = [ 3, 6 ];\n\n\tassert.ok( !method( \"I'm going to be longer than \u201csix words!\u201d\", rangeWords ), \"Longer than 6 with smartquotes\" );\n\tassert.ok( method( \"I'm just the right amount!\", rangeWords ), \"In between\" );\n\tassert.ok( method( \"Super short sentence\u2019s.\", rangeWords ), \"Low end\" );\n\tassert.ok( !method( \"I\", rangeWords ), \"Too short\" );\n\tassert.ok( method( \"<div>\u201cCount\u201d me as perfect.</div>\", rangeWords ), \"Right amount of words with smartquotes w/ HTML\" );\n\tassert.ok( !method( \"<div>But you can \u201ccount\u201d me as too long</div>\", rangeWords ), \"Too many words with smartquotes w/ HTML\" );\n} );\n\nQUnit.test( \"currency\", function( assert ) { // Works with any symbol\n\tvar method = methodTest( \"currency\" );\n\tassert.ok( method( \"\u00a39\", \"\u00a3\" ), \"Symbol no decimal\" );\n\tassert.ok( method( \"\u00a39.9\", \"\u00a3\" ), \"\u00a3, one decimal\" );\n\tassert.ok( method( \"\u00a39.99\", \"\u00a3\" ), \"\u00a3, two decimal\" );\n\tassert.ok( method( \"\u00a39.90\", \"\u00a3\" ), \"Valid currency\" );\n\tassert.ok( method( \"\u00a39,999.9\", \"\u00a3\" ), \"\u00a3, thousand, comma separator, one decimal\" );\n\tassert.ok( method( \"\u00a39,999.99\", \"\u00a3\" ), \"\u00a3, thousand, comma separator, two decimal\" );\n\tassert.ok( method( \"\u00a39,999,999.9\", \"\u00a3\" ), \"\u00a3, million, comma separators, one decimal\" );\n\tassert.ok( method( \"9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9.9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9.99\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9.90\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9,999.9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9,999.99\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( method( \"9,999,999.9\", [ \"\u00a3\", false ] ), \"Valid currency\" );\n\tassert.ok( !method( \"9,\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9,99.99\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9,\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9.999\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9.999\", \"\u00a3\" ), \"Invalid currency\" );\n\tassert.ok( !method( \"9.99,9\", \"\u00a3\" ), \"Invalid currency\" );\n} );\n\nQUnit.test( \"postalCodeCA\", function( assert ) {\n\tvar method = methodTest( \"postalCodeCA\" );\n\tassert.ok( method( \"H0H0H0\" ), \"Valid Canadian postal code: all upper case with no space\" );\n\tassert.ok( method( \"H0H 0H0\" ), \"Valid Canadian postal code: all upper case with one space\" );\n\tassert.ok( method( \"H0H  0H0\" ), \"Valid Canadian postal code: all upper case with multiple spaces\" );\n\tassert.ok( method( \"h0h 0h0\" ), \"Valid Canadian postal code: all lower case with space\" );\n\tassert.ok( method( \"h0h0h0\" ), \"Valid Canadian postal code: all lower case with no space\" );\n\tassert.ok( !method( \"H0H-0H0\" ), \"Invalid Canadian postal code: dash used as separator\" );\n\tassert.ok( !method( \"H0H 0H\" ), \"Invalid Canadian postal code: too short\" );\n\tassert.ok( !method( \"Z0H 0H0\" ), \"Invalid Canadian postal code: only 'ABCEGHJKLMNPRSTVXY' are valid first characters for the Forward Sorting Area\" );\n\tassert.ok( !method( \"H0D 0H0\" ), \"Invalid Canadian postal code: only 'ABCEGHJKLMNPRSTVWXYZ' are valid third characters for the Forward Sorting Area\" );\n\tassert.ok( !method( \"H0H 0D0\" ), \"Invalid Canadian postal code: only 'ABCEGHJKLMNPRSTVWXYZ' are valid second characters for the Local Delivery Unit\" );\n} );\n\nQUnit.test( \"stateUS\", function( assert ) {\n\tvar method = methodTest( \"stateUS\" );\n\tassert.ok( method( \"AZ\" ), \"Valid US state\" );\n\tassert.ok( method( \"OH\" ), \"Valid US state\" );\n\tassert.ok( method( \"DC\" ), \"Valid US state\" );\n\tassert.ok( method( \"PR\", { includeTerritories: true } ), \"Valid US territory\" );\n\tassert.ok( method( \"AA\", { includeMilitary: true } ), \"Valid US military zone\" );\n\tassert.ok( method( \"me\", { caseSensitive: false } ), \"Valid US state\" );\n\tassert.ok( !method( \"az\", { caseSensitive: true } ), \"Must be capital letters\" );\n\tassert.ok( !method( \"mp\", { caseSensitive: false, includeTerritories: false } ), \"US territories not allowed\" );\n} );\n\nQUnit.test( \"postalcodeBR\", function( assert ) {\n\tvar method = methodTest( \"postalcodeBR\" );\n\tassert.ok( method( \"99999-999\" ), \"Valid BR Postal Code\" );\n\tassert.ok( method( \"99999999\" ), \"Valid BR Postal Code\" );\n\tassert.ok( method( \"99.999-999\" ), \"Valid BR Postal Code\" );\n\tassert.ok( !method( \"99.999999\" ), \"Invalid BR Postal Code\" );\n} );\n\nQUnit.test( \"cpfBR\", function( assert ) {\n\tvar method = methodTest( \"cpfBR\" );\n\tassert.ok( method( \"11144477735\" ), \"Valid CPF Number\" );\n\tassert.ok( method( \"263.946.533-30\" ), \"Valid CPF Number\" );\n\tassert.ok( method( \"325 861 044 47\" ), \"Valid CPF Number\" );\n\tassert.ok( method( \"859-684-732-40\" ), \"Valid CPF Number\" );\n\tassert.ok( !method( \"99999999999\" ), \"Invalid CPF Number: dump data\" );\n\tassert.ok( !method( \"1114447773\" ), \"Invalid CPF Number: < 11 digits\" );\n\tassert.ok( !method( \"111444777355\" ), \"Invalid CPF Number: > 11 digits\" );\n\tassert.ok( !method( \"11144477715\" ), \"Invalid CPF Number: 1st check number failed\" );\n\tassert.ok( !method( \"11144477737\" ), \"Invalid CPF Number: 2nd check number failed\" );\n} );\n\nQUnit.test( \"cnpjBR\", function( assert ) {\n\tvar method = methodTest( \"cnpjBR\" );\n\tassert.ok( method( \"18517604000175\" ), \"Valid CNPJ Number\" );\n\tassert.ok( method( \"18.517.604/0001-75\" ), \"Valid CNPJ Number\" );\n\tassert.ok( method( \"06994660000111\" ), \"Valid CNPJ Number\" );\n\tassert.ok( method( \"06.994.660/0001-11\" ), \"Valid CNPJ Number\" );\n\tassert.ok( !method( \"00000000000000\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"11111111111111\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"22222222222222\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"99999999999999\" ), \"Invalid CNPJ Number: dump data\" );\n\tassert.ok( !method( \"8517604000175\" ), \"Invalid CNPJ Number: < 14 digits\" );\n\tassert.ok( !method( \"8.517.604/0001-75\" ), \"Invalid CNPJ Number: < 14 digits\" );\n\tassert.ok( !method( \"1185176040001750\" ), \"Invalid CNPJ Number: > 14 digits\" );\n\tassert.ok( !method( \"18.517.604/0001-750\" ), \"Invalid CNPJ Number: > 14 digits\" );\n\tassert.ok( !method( \"18517604000174\" ), \"Invalid CNPJ Number\" );\n\tassert.ok( !method( \"18.517.604/0001-74\" ), \"Invalid CNPJ Number\" );\n\tassert.ok( !method( \"06994660000211\" ), \"Invalid CNPJ Number\" );\n\tassert.ok( !method( \"06.994.660/0002-11\" ), \"Invalid CNPJ Number\" );\n} );\n\nQUnit.test( \"nisBR\", function( assert ) {\n\tvar method = methodTest( \"nisBR\" );\n\tassert.ok( method( \"10757995753\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107.57995.75-3\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107.579.957-53\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107-579-957-53\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( method( \"107.579.957.5-3\" ), \"Valid NIS/PIS Number\" );\n\tassert.ok( !method( \"99999999999\" ), \"Invalid NIS/PIS Number: dump data\" );\n\tassert.ok( !method( \"1075799575\" ), \"Invalid  NIS/PIS Number: < 11 digits\" );\n\tassert.ok( !method( \"111444777355\" ), \"Invalid NIS/PIS Number: > 11 digits\" );\n\tassert.ok( !method( \"10757995752\" ), \"Invalid NIS/PIS Number: check number failed\" );\n} );\n\nQUnit.test( \"file accept - image wildcard\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"image/*\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - specified mime type\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.kml\", \"application/vnd.google-earth.kml+xml\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"application/vnd.google-earth.kml+xml\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - multiple mimetypes\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"image/png,video/jpeg\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - multiple mimetypes with wildcard\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.mp3\", \"audio/mpeg\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"image/*,audio/*\" );\n\tassert.ok( proxy(), \"the selected file for upload has specified mime type\" );\n} );\n\nQUnit.test( \"file accept - invalid mime type\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.kml\", \"foobar/vnd.google-earth.kml+xml\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.accept, new $.validator( {}, $form[ 0 ] ), null, input, \"application/vnd.google-earth.kml+xml\" );\n\tassert.equal( proxy(), false, \"the selected file for upload has invalid mime type\" );\n} );\n\nQUnit.test( \"file size - below max\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, \"500001\" );\n\tassert.ok( proxy(), \"the selected file for upload is smaller than max\" );\n} );\n\nQUnit.test( \"file size - over max\", function( assert ) {\n\tvar input = acceptFileDummyInput( \"test.png\", \"image/png\" ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, \"500000\" );\n\tassert.equal( proxy(), false, \"the selected file for upload is greater than max\" );\n} );\n\nQUnit.test( \"file maxsize - valid size\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.ok( proxy(), \"the size of the file does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxsize - valid size for each file\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.ok( proxy(), \"the size of the each file does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxsize - too big\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test.jpg\", size: 500001 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.equal( proxy(), false, \"the size of the file exceeds the maximum\" );\n} );\n\nQUnit.test( \"file maxsize - second file too big\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500001 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsize, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.equal( proxy(), false, \"the size of the second file exceeds the maximum\" );\n} );\n\nQUnit.test( \"file maxsizetotal - valid size\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 250000 }, { name: \"test2.jpg\", size: 250000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsizetotal, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.ok( proxy(), \"the size of the files together does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxsizetotal - too big\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 250000 }, { name: \"test2.jpg\", size: 250001 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxsizetotal, new $.validator( {}, $form[ 0 ] ), null, input, 500000 );\n\tassert.equal( proxy(), false, \"the size of the files together exceeds the maximum\" );\n} );\n\nQUnit.test( \"file maxfiles - valid number\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxfiles, new $.validator( {}, $form[ 0 ] ), null, input, 2 );\n\tassert.ok( proxy(), \"the number of files does not exceed the maximum\" );\n} );\n\nQUnit.test( \"file maxfiles - too many\", function( assert ) {\n\tvar selectedFiles = [ { name: \"test1.jpg\", size: 500000 }, { name: \"test2.jpg\", size: 500000 }, { name: \"test3.jpg\", size: 500000 } ],\n\t\tinput = fileDummyInput( selectedFiles ),\n\t\t$form = $( \"<form />\" ),\n\t\tproxy = $.proxy( $.validator.methods.maxfiles, new $.validator( {}, $form[ 0 ] ), null, input, 2 );\n\tassert.equal( proxy(), false, \"the number of files exceeds the maximum\" );\n} );\n"], "filenames": ["src/additional/url2.js", "src/core.js", "test/methods.js"], "buggy_code_start_loc": [3, 1419, 125], "buggy_code_end_loc": [4, 1420, 129], "fixing_code_start_loc": [3, 1419, 126], "fixing_code_end_loc": [4, 1420, 128], "type": "NVD-CWE-Other", "message": "The jQuery Validation Plugin (jquery-validation) provides drop-in validation for forms. Versions of jquery-validation prior to 1.19.5 are vulnerable to regular expression denial of service (ReDoS) when an attacker is able to supply arbitrary input to the url2 method. This is due to an incomplete fix for CVE-2021-43306. Users should upgrade to version 1.19.5 to receive a patch.", "other": {"cve": {"id": "CVE-2022-31147", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-14T20:15:08.483", "lastModified": "2022-07-21T01:24:32.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The jQuery Validation Plugin (jquery-validation) provides drop-in validation for forms. Versions of jquery-validation prior to 1.19.5 are vulnerable to regular expression denial of service (ReDoS) when an attacker is able to supply arbitrary input to the url2 method. This is due to an incomplete fix for CVE-2021-43306. Users should upgrade to version 1.19.5 to receive a patch."}, {"lang": "es", "value": "El plugin de comprobaci\u00f3n de jQuery (jquery-validation) proporciona una comprobaci\u00f3n directa para formularios. Las versiones de jquery-validation anteriores a 1.19.5 son vulnerables a una denegaci\u00f3n de servicio por expresi\u00f3n regular (ReDoS) cuando un atacante es capaz de suministrar una entrada arbitraria al m\u00e9todo url2. Esto es debido a una correcci\u00f3n incompleta de CVE-2021-43306. Los usuarios deben actualizar a versi\u00f3n 1.19.5 para recibir el parche"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jqueryvalidation:jquery_validation:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.19.5", "matchCriteriaId": "AF8AFEDC-6BEB-4434-888A-4A6D4FC39BBD"}]}]}], "references": [{"url": "https://github.com/jquery-validation/jquery-validation/commit/5bbd80d27fc6b607d2f7f106c89522051a9fb0dd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/jquery-validation/jquery-validation/security/advisories/GHSA-ffmh-x56j-9rc3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jquery-validation/jquery-validation/commit/5bbd80d27fc6b607d2f7f106c89522051a9fb0dd"}}