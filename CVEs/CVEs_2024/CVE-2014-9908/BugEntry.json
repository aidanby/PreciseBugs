{"buggy_code": ["/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.bluetooth;\n\nimport android.os.ParcelUuid;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.util.Log;\n\nimport java.io.Closeable;\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Locale;\nimport java.util.UUID;\nimport android.net.LocalSocket;\nimport java.nio.ByteOrder;\nimport java.nio.ByteBuffer;\n/**\n * A connected or connecting Bluetooth socket.\n *\n * <p>The interface for Bluetooth Sockets is similar to that of TCP sockets:\n * {@link java.net.Socket} and {@link java.net.ServerSocket}. On the server\n * side, use a {@link BluetoothServerSocket} to create a listening server\n * socket. When a connection is accepted by the {@link BluetoothServerSocket},\n * it will return a new {@link BluetoothSocket} to manage the connection.\n * On the client side, use a single {@link BluetoothSocket} to both initiate\n * an outgoing connection and to manage the connection.\n *\n * <p>The most common type of Bluetooth socket is RFCOMM, which is the type\n * supported by the Android APIs. RFCOMM is a connection-oriented, streaming\n * transport over Bluetooth. It is also known as the Serial Port Profile (SPP).\n *\n * <p>To create a {@link BluetoothSocket} for connecting to a known device, use\n * {@link BluetoothDevice#createRfcommSocketToServiceRecord\n * BluetoothDevice.createRfcommSocketToServiceRecord()}.\n * Then call {@link #connect()} to attempt a connection to the remote device.\n * This call will block until a connection is established or the connection\n * fails.\n *\n * <p>To create a {@link BluetoothSocket} as a server (or \"host\"), see the\n * {@link BluetoothServerSocket} documentation.\n *\n * <p>Once the socket is connected, whether initiated as a client or accepted\n * as a server, open the IO streams by calling {@link #getInputStream} and\n * {@link #getOutputStream} in order to retrieve {@link java.io.InputStream}\n * and {@link java.io.OutputStream} objects, respectively, which are\n * automatically connected to the socket.\n *\n * <p>{@link BluetoothSocket} is thread\n * safe. In particular, {@link #close} will always immediately abort ongoing\n * operations and close the socket.\n *\n * <p class=\"note\"><strong>Note:</strong>\n * Requires the {@link android.Manifest.permission#BLUETOOTH} permission.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about using Bluetooth, read the\n * <a href=\"{@docRoot}guide/topics/wireless/bluetooth.html\">Bluetooth</a> developer guide.</p>\n * </div>\n *\n * {@see BluetoothServerSocket}\n * {@see java.io.InputStream}\n * {@see java.io.OutputStream}\n */\npublic final class BluetoothSocket implements Closeable {\n    private static final String TAG = \"BluetoothSocket\";\n    private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE);\n\n    /** @hide */\n    public static final int MAX_RFCOMM_CHANNEL = 30;\n\n    /** Keep TYPE_ fields in sync with BluetoothSocket.cpp */\n    /*package*/ static final int TYPE_RFCOMM = 1;\n    /*package*/ static final int TYPE_SCO = 2;\n    /*package*/ static final int TYPE_L2CAP = 3;\n\n    /*package*/ static final int EBADFD = 77;\n    /*package*/ static final int EADDRINUSE = 98;\n\n    /*package*/ static final int SEC_FLAG_ENCRYPT = 1;\n    /*package*/ static final int SEC_FLAG_AUTH = 1 << 1;\n\n    private final int mType;  /* one of TYPE_RFCOMM etc */\n    private BluetoothDevice mDevice;    /* remote device */\n    private String mAddress;    /* remote address */\n    private final boolean mAuth;\n    private final boolean mEncrypt;\n    private final BluetoothInputStream mInputStream;\n    private final BluetoothOutputStream mOutputStream;\n    private final ParcelUuid mUuid;\n    private ParcelFileDescriptor mPfd;\n    private LocalSocket mSocket;\n    private InputStream mSocketIS;\n    private OutputStream mSocketOS;\n    private int mPort;  /* RFCOMM channel or L2CAP psm */\n    private int mFd;\n    private String mServiceName;\n    private static int PROXY_CONNECTION_TIMEOUT = 5000;\n\n    private static int SOCK_SIGNAL_SIZE = 16;\n\n    private enum SocketState {\n        INIT,\n        CONNECTED,\n        LISTENING,\n        CLOSED,\n    }\n\n    /** prevents all native calls after destroyNative() */\n    private volatile SocketState mSocketState;\n\n    /** protects mSocketState */\n    //private final ReentrantReadWriteLock mLock;\n\n    /**\n     * Construct a BluetoothSocket.\n     * @param type    type of socket\n     * @param fd      fd to use for connected socket, or -1 for a new socket\n     * @param auth    require the remote device to be authenticated\n     * @param encrypt require the connection to be encrypted\n     * @param device  remote device that this socket can connect to\n     * @param port    remote port\n     * @param uuid    SDP uuid\n     * @throws IOException On error, for example Bluetooth not available, or\n     *                     insufficient privileges\n     */\n    /*package*/ BluetoothSocket(int type, int fd, boolean auth, boolean encrypt,\n            BluetoothDevice device, int port, ParcelUuid uuid) throws IOException {\n        if (type == BluetoothSocket.TYPE_RFCOMM && uuid == null && fd == -1) {\n            if (port < 1 || port > MAX_RFCOMM_CHANNEL) {\n                throw new IOException(\"Invalid RFCOMM channel: \" + port);\n            }\n        }\n        if(uuid != null)\n            mUuid = uuid;\n        else mUuid = new ParcelUuid(new UUID(0, 0));\n        mType = type;\n        mAuth = auth;\n        mEncrypt = encrypt;\n        mDevice = device;\n        mPort = port;\n        mFd = fd;\n\n        mSocketState = SocketState.INIT;\n\n        if (device == null) {\n            // Server socket\n            mAddress = BluetoothAdapter.getDefaultAdapter().getAddress();\n        } else {\n            // Remote socket\n            mAddress = device.getAddress();\n        }\n        mInputStream = new BluetoothInputStream(this);\n        mOutputStream = new BluetoothOutputStream(this);\n    }\n    private BluetoothSocket(BluetoothSocket s) {\n        mUuid = s.mUuid;\n        mType = s.mType;\n        mAuth = s.mAuth;\n        mEncrypt = s.mEncrypt;\n        mPort = s.mPort;\n        mInputStream = new BluetoothInputStream(this);\n        mOutputStream = new BluetoothOutputStream(this);\n        mServiceName = s.mServiceName;\n    }\n    private BluetoothSocket acceptSocket(String RemoteAddr) throws IOException {\n        BluetoothSocket as = new BluetoothSocket(this);\n        as.mSocketState = SocketState.CONNECTED;\n        FileDescriptor[] fds = mSocket.getAncillaryFileDescriptors();\n        if (DBG) Log.d(TAG, \"socket fd passed by stack  fds: \" + fds);\n        if(fds == null || fds.length != 1) {\n            Log.e(TAG, \"socket fd passed from stack failed, fds: \" + fds);\n            as.close();\n            throw new IOException(\"bt socket acept failed\");\n        }\n        as.mSocket = new LocalSocket(fds[0]);\n        try {\n            as.mSocket.closeExternalFd();\n        } catch (IOException e) {\n            Log.e(TAG, \"closeExternalFd failed\");\n        }\n        as.mSocketIS = as.mSocket.getInputStream();\n        as.mSocketOS = as.mSocket.getOutputStream();\n        as.mAddress = RemoteAddr;\n        as.mDevice = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(RemoteAddr);\n        as.mPort = mPort;\n        return as;\n    }\n    /**\n     * Construct a BluetoothSocket from address. Used by native code.\n     * @param type    type of socket\n     * @param fd      fd to use for connected socket, or -1 for a new socket\n     * @param auth    require the remote device to be authenticated\n     * @param encrypt require the connection to be encrypted\n     * @param address remote device that this socket can connect to\n     * @param port    remote port\n     * @throws IOException On error, for example Bluetooth not available, or\n     *                     insufficient privileges\n     */\n    private BluetoothSocket(int type, int fd, boolean auth, boolean encrypt, String address,\n            int port) throws IOException {\n        this(type, fd, auth, encrypt, new BluetoothDevice(address), port, null);\n    }\n\n    /** @hide */\n    @Override\n    protected void finalize() throws Throwable {\n        try {\n            close();\n        } finally {\n            super.finalize();\n        }\n    }\n    private int getSecurityFlags() {\n        int flags = 0;\n        if(mAuth)\n            flags |= SEC_FLAG_AUTH;\n        if(mEncrypt)\n            flags |= SEC_FLAG_ENCRYPT;\n        return flags;\n    }\n\n    /**\n     * Get the remote device this socket is connecting, or connected, to.\n     * @return remote device\n     */\n    public BluetoothDevice getRemoteDevice() {\n        return mDevice;\n    }\n\n    /**\n     * Get the input stream associated with this socket.\n     * <p>The input stream will be returned even if the socket is not yet\n     * connected, but operations on that stream will throw IOException until\n     * the associated socket is connected.\n     * @return InputStream\n     */\n    public InputStream getInputStream() throws IOException {\n        return mInputStream;\n    }\n\n    /**\n     * Get the output stream associated with this socket.\n     * <p>The output stream will be returned even if the socket is not yet\n     * connected, but operations on that stream will throw IOException until\n     * the associated socket is connected.\n     * @return OutputStream\n     */\n    public OutputStream getOutputStream() throws IOException {\n        return mOutputStream;\n    }\n\n    /**\n     * Get the connection status of this socket, ie, whether there is an active connection with\n     * remote device.\n     * @return true if connected\n     *         false if not connected\n     */\n    public boolean isConnected() {\n        return mSocketState == SocketState.CONNECTED;\n    }\n\n    /*package*/ void setServiceName(String name) {\n        mServiceName = name;\n    }\n\n    /**\n     * Attempt to connect to a remote device.\n     * <p>This method will block until a connection is made or the connection\n     * fails. If this method returns without an exception then this socket\n     * is now connected.\n     * <p>Creating new connections to\n     * remote Bluetooth devices should not be attempted while device discovery\n     * is in progress. Device discovery is a heavyweight procedure on the\n     * Bluetooth adapter and will significantly slow a device connection.\n     * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing\n     * discovery. Discovery is not managed by the Activity,\n     * but is run as a system service, so an application should always call\n     * {@link BluetoothAdapter#cancelDiscovery()} even if it\n     * did not directly request a discovery, just to be sure.\n     * <p>{@link #close} can be used to abort this call from another thread.\n     * @throws IOException on error, for example connection failure\n     */\n    public void connect() throws IOException {\n        if (mDevice == null) throw new IOException(\"Connect is called on null device\");\n\n        try {\n            if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n            IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n            if (bluetoothProxy == null) throw new IOException(\"Bluetooth is off\");\n            mPfd = bluetoothProxy.connectSocket(mDevice, mType,\n                    mUuid, mPort, getSecurityFlags());\n            synchronized(this)\n            {\n                if (DBG) Log.d(TAG, \"connect(), SocketState: \" + mSocketState + \", mPfd: \" + mPfd);\n                if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n                if (mPfd == null) throw new IOException(\"bt socket connect failed\");\n                FileDescriptor fd = mPfd.getFileDescriptor();\n                mSocket = new LocalSocket(fd);\n                mSocketIS = mSocket.getInputStream();\n                mSocketOS = mSocket.getOutputStream();\n            }\n            int channel = readInt(mSocketIS);\n            if (channel <= 0)\n                throw new IOException(\"bt socket connect failed\");\n            mPort = channel;\n            waitSocketSignal(mSocketIS);\n            synchronized(this)\n            {\n                if (mSocketState == SocketState.CLOSED)\n                    throw new IOException(\"bt socket closed\");\n                mSocketState = SocketState.CONNECTED;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            throw new IOException(\"unable to send RPC: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Currently returns unix errno instead of throwing IOException,\n     * so that BluetoothAdapter can check the error code for EADDRINUSE\n     */\n    /*package*/ int bindListen() {\n        int ret;\n        if (mSocketState == SocketState.CLOSED) return EBADFD;\n        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n        if (bluetoothProxy == null) {\n            Log.e(TAG, \"bindListen fail, reason: bluetooth is off\");\n            return -1;\n        }\n        try {\n            mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName,\n                    mUuid, mPort, getSecurityFlags());\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            return -1;\n        }\n\n        // read out port number\n        try {\n            synchronized(this) {\n                if (DBG) Log.d(TAG, \"bindListen(), SocketState: \" + mSocketState + \", mPfd: \" +\n                                mPfd);\n                if(mSocketState != SocketState.INIT) return EBADFD;\n                if(mPfd == null) return -1;\n                FileDescriptor fd = mPfd.getFileDescriptor();\n                if (DBG) Log.d(TAG, \"bindListen(), new LocalSocket \");\n                mSocket = new LocalSocket(fd);\n                if (DBG) Log.d(TAG, \"bindListen(), new LocalSocket.getInputStream() \");\n                mSocketIS = mSocket.getInputStream();\n                mSocketOS = mSocket.getOutputStream();\n            }\n            if (DBG) Log.d(TAG, \"bindListen(), readInt mSocketIS: \" + mSocketIS);\n            int channel = readInt(mSocketIS);\n            synchronized(this) {\n                if(mSocketState == SocketState.INIT)\n                    mSocketState = SocketState.LISTENING;\n            }\n            if (DBG) Log.d(TAG, \"channel: \" + channel);\n            if (mPort == -1) {\n                mPort = channel;\n            } // else ASSERT(mPort == channel)\n            ret = 0;\n        } catch (IOException e) {\n            if (mPfd != null) {\n                try {\n                    mPfd.close();\n                } catch (IOException e1) {\n                    Log.e(TAG, \"bindListen, close mPfd: \" + e1);\n                }\n                mPfd = null;\n            }\n            Log.e(TAG, \"bindListen, fail to get port number, exception: \" + e);\n            return -1;\n        }\n        return ret;\n    }\n\n    /*package*/ BluetoothSocket accept(int timeout) throws IOException {\n        BluetoothSocket acceptedSocket;\n        if (mSocketState != SocketState.LISTENING) throw new IOException(\"bt socket is not in listen state\");\n        if(timeout > 0) {\n            Log.d(TAG, \"accept() set timeout (ms):\" + timeout);\n           mSocket.setSoTimeout(timeout);\n        }\n        String RemoteAddr = waitSocketSignal(mSocketIS);\n        if(timeout > 0)\n            mSocket.setSoTimeout(0);\n        synchronized(this)\n        {\n            if (mSocketState != SocketState.LISTENING)\n                throw new IOException(\"bt socket is not in listen state\");\n            acceptedSocket = acceptSocket(RemoteAddr);\n            //quick drop the reference of the file handle\n        }\n        return acceptedSocket;\n    }\n\n    /**\n     * setSocketOpt for the Buetooth Socket.\n     *\n     * @param optionName socket option name\n     * @param optionVal  socket option value\n     * @param optionLen  socket option length\n     * @return -1 on immediate error,\n     *               0 otherwise\n     * @hide\n     */\n    public int setSocketOpt(int optionName, byte [] optionVal, int optionLen) throws IOException {\n        int ret = 0;\n        if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n        if (bluetoothProxy == null) {\n            Log.e(TAG, \"setSocketOpt fail, reason: bluetooth is off\");\n            return -1;\n        }\n        try {\n            if(VDBG) Log.d(TAG, \"setSocketOpt(), mType: \" + mType + \" mPort: \" + mPort);\n            ret = bluetoothProxy.setSocketOpt(mType, mPort, optionName, optionVal, optionLen);\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            return -1;\n        }\n        return ret;\n    }\n\n    /**\n     * getSocketOpt for the Buetooth Socket.\n     *\n     * @param optionName socket option name\n     * @param optionVal  socket option value\n     * @return -1 on immediate error,\n     *               length of returned socket option otherwise\n     * @hide\n     */\n    public int getSocketOpt(int optionName, byte [] optionVal) throws IOException {\n        int ret = 0;\n        if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n        if (bluetoothProxy == null) {\n            Log.e(TAG, \"getSocketOpt fail, reason: bluetooth is off\");\n            return -1;\n        }\n        try {\n            if(VDBG) Log.d(TAG, \"getSocketOpt(), mType: \" + mType + \" mPort: \" + mPort);\n            ret = bluetoothProxy.getSocketOpt(mType, mPort, optionName, optionVal);\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            return -1;\n        }\n        return ret;\n    }\n\n    /*package*/ int available() throws IOException {\n        if (VDBG) Log.d(TAG, \"available: \" + mSocketIS);\n        return mSocketIS.available();\n    }\n    /**\n     * Wait until the data in sending queue is emptied. A polling version\n     * for flush implementation. Used to ensure the writing data afterwards will\n     * be packed in new RFCOMM frame.\n     * @throws IOException\n     *             if an i/o error occurs.\n     */\n    /*package*/ void flush() throws IOException {\n        if (mSocketOS == null) throw new IOException(\"flush is called on null OutputStream\");\n        if (VDBG) Log.d(TAG, \"flush: \" + mSocketOS);\n        mSocketOS.flush();\n    }\n\n    /*package*/ int read(byte[] b, int offset, int length) throws IOException {\n        if (mSocketIS == null) throw new IOException(\"read is called on null InputStream\");\n        if (VDBG) Log.d(TAG, \"read in:  \" + mSocketIS + \" len: \" + length);\n        int ret = mSocketIS.read(b, offset, length);\n        if(ret < 0)\n            throw new IOException(\"bt socket closed, read return: \" + ret);\n        if (VDBG) Log.d(TAG, \"read out:  \" + mSocketIS + \" ret: \" + ret);\n        return ret;\n    }\n\n    /*package*/ int write(byte[] b, int offset, int length) throws IOException {\n        if (mSocketOS == null) throw new IOException(\"write is called on null OutputStream\");\n        if (VDBG) Log.d(TAG, \"write: \" + mSocketOS + \" length: \" + length);\n        mSocketOS.write(b, offset, length);\n        // There is no good way to confirm since the entire process is asynchronous anyway\n        if (VDBG) Log.d(TAG, \"write out: \" + mSocketOS + \" length: \" + length);\n        return length;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (DBG) Log.d(TAG, \"close() in, this: \" + this + \", channel: \" + mPort + \", state: \" + mSocketState);\n        if(mSocketState == SocketState.CLOSED)\n            return;\n        else\n        {\n            synchronized(this)\n            {\n                 if(mSocketState == SocketState.CLOSED)\n                    return;\n                 mSocketState = SocketState.CLOSED;\n                 if (DBG) Log.d(TAG, \"close() this: \" + this + \", channel: \" + mPort + \", mSocketIS: \" + mSocketIS +\n                        \", mSocketOS: \" + mSocketOS + \"mSocket: \" + mSocket);\n                 if(mSocket != null) {\n                    if (DBG) Log.d(TAG, \"Closing mSocket: \" + mSocket);\n                    mSocket.shutdownInput();\n                    mSocket.shutdownOutput();\n                    mSocket.close();\n                    mSocket = null;\n                }\n                if (mPfd != null) {\n                    mPfd.close();\n                    mPfd = null;\n                }\n           }\n        }\n    }\n\n    /*package */ void removeChannel() {\n    }\n\n    /*package */ int getPort() {\n        return mPort;\n    }\n    private String convertAddr(final byte[] addr)  {\n        return String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                addr[0] , addr[1], addr[2], addr[3] , addr[4], addr[5]);\n    }\n    private String waitSocketSignal(InputStream is) throws IOException {\n        byte [] sig = new byte[SOCK_SIGNAL_SIZE];\n        int ret = readAll(is, sig);\n        if (VDBG) Log.d(TAG, \"waitSocketSignal read 16 bytes signal ret: \" + ret);\n        ByteBuffer bb = ByteBuffer.wrap(sig);\n        bb.order(ByteOrder.nativeOrder());\n        int size = bb.getShort();\n        if(size != SOCK_SIGNAL_SIZE)\n            throw new IOException(\"Connection failure, wrong signal size: \" + size);\n        byte [] addr = new byte[6];\n        bb.get(addr);\n        int channel = bb.getInt();\n        int status = bb.getInt();\n        String RemoteAddr = convertAddr(addr);\n        if (VDBG) Log.d(TAG, \"waitSocketSignal: sig size: \" + size + \", remote addr: \"\n                + RemoteAddr + \", channel: \" + channel + \", status: \" + status);\n        if(status != 0)\n            throw new IOException(\"Connection failure, status: \" + status);\n        return RemoteAddr;\n    }\n    private int readAll(InputStream is, byte[] b) throws IOException {\n        int left = b.length;\n        while(left > 0) {\n            int ret = is.read(b, b.length - left, left);\n            if(ret <= 0)\n                 throw new IOException(\"read failed, socket might closed or timeout, read ret: \" + ret);\n            left -= ret;\n            if(left != 0)\n                Log.w(TAG, \"readAll() looping, read partial size: \" + (b.length - left) +\n                            \", expect size: \" + b.length);\n        }\n        return b.length;\n    }\n\n    private int readInt(InputStream is) throws IOException {\n        byte[] ibytes = new byte[4];\n        int ret = readAll(is, ibytes);\n        if (VDBG) Log.d(TAG, \"inputStream.read ret: \" + ret);\n        ByteBuffer bb = ByteBuffer.wrap(ibytes);\n        bb.order(ByteOrder.nativeOrder());\n        return bb.getInt();\n    }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.bluetooth;\n\nimport android.os.ParcelUuid;\nimport android.os.ParcelFileDescriptor;\nimport android.os.RemoteException;\nimport android.util.Log;\n\nimport java.io.Closeable;\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Locale;\nimport java.util.UUID;\nimport android.net.LocalSocket;\nimport java.nio.ByteOrder;\nimport java.nio.ByteBuffer;\n/**\n * A connected or connecting Bluetooth socket.\n *\n * <p>The interface for Bluetooth Sockets is similar to that of TCP sockets:\n * {@link java.net.Socket} and {@link java.net.ServerSocket}. On the server\n * side, use a {@link BluetoothServerSocket} to create a listening server\n * socket. When a connection is accepted by the {@link BluetoothServerSocket},\n * it will return a new {@link BluetoothSocket} to manage the connection.\n * On the client side, use a single {@link BluetoothSocket} to both initiate\n * an outgoing connection and to manage the connection.\n *\n * <p>The most common type of Bluetooth socket is RFCOMM, which is the type\n * supported by the Android APIs. RFCOMM is a connection-oriented, streaming\n * transport over Bluetooth. It is also known as the Serial Port Profile (SPP).\n *\n * <p>To create a {@link BluetoothSocket} for connecting to a known device, use\n * {@link BluetoothDevice#createRfcommSocketToServiceRecord\n * BluetoothDevice.createRfcommSocketToServiceRecord()}.\n * Then call {@link #connect()} to attempt a connection to the remote device.\n * This call will block until a connection is established or the connection\n * fails.\n *\n * <p>To create a {@link BluetoothSocket} as a server (or \"host\"), see the\n * {@link BluetoothServerSocket} documentation.\n *\n * <p>Once the socket is connected, whether initiated as a client or accepted\n * as a server, open the IO streams by calling {@link #getInputStream} and\n * {@link #getOutputStream} in order to retrieve {@link java.io.InputStream}\n * and {@link java.io.OutputStream} objects, respectively, which are\n * automatically connected to the socket.\n *\n * <p>{@link BluetoothSocket} is thread\n * safe. In particular, {@link #close} will always immediately abort ongoing\n * operations and close the socket.\n *\n * <p class=\"note\"><strong>Note:</strong>\n * Requires the {@link android.Manifest.permission#BLUETOOTH} permission.\n *\n * <div class=\"special reference\">\n * <h3>Developer Guides</h3>\n * <p>For more information about using Bluetooth, read the\n * <a href=\"{@docRoot}guide/topics/wireless/bluetooth.html\">Bluetooth</a> developer guide.</p>\n * </div>\n *\n * {@see BluetoothServerSocket}\n * {@see java.io.InputStream}\n * {@see java.io.OutputStream}\n */\npublic final class BluetoothSocket implements Closeable {\n    private static final String TAG = \"BluetoothSocket\";\n    private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG);\n    private static final boolean VDBG = Log.isLoggable(TAG, Log.VERBOSE);\n\n    /** @hide */\n    public static final int MAX_RFCOMM_CHANNEL = 30;\n\n    /** Keep TYPE_ fields in sync with BluetoothSocket.cpp */\n    /*package*/ static final int TYPE_RFCOMM = 1;\n    /*package*/ static final int TYPE_SCO = 2;\n    /*package*/ static final int TYPE_L2CAP = 3;\n\n    /*package*/ static final int EBADFD = 77;\n    /*package*/ static final int EADDRINUSE = 98;\n\n    /*package*/ static final int SEC_FLAG_ENCRYPT = 1;\n    /*package*/ static final int SEC_FLAG_AUTH = 1 << 1;\n\n    private final int mType;  /* one of TYPE_RFCOMM etc */\n    private BluetoothDevice mDevice;    /* remote device */\n    private String mAddress;    /* remote address */\n    private final boolean mAuth;\n    private final boolean mEncrypt;\n    private final BluetoothInputStream mInputStream;\n    private final BluetoothOutputStream mOutputStream;\n    private final ParcelUuid mUuid;\n    private ParcelFileDescriptor mPfd;\n    private LocalSocket mSocket;\n    private InputStream mSocketIS;\n    private OutputStream mSocketOS;\n    private int mPort;  /* RFCOMM channel or L2CAP psm */\n    private int mFd;\n    private String mServiceName;\n    private static int PROXY_CONNECTION_TIMEOUT = 5000;\n\n    private static int SOCK_SIGNAL_SIZE = 16;\n\n    private enum SocketState {\n        INIT,\n        CONNECTED,\n        LISTENING,\n        CLOSED,\n    }\n\n    /** prevents all native calls after destroyNative() */\n    private volatile SocketState mSocketState;\n\n    /** protects mSocketState */\n    //private final ReentrantReadWriteLock mLock;\n\n    /**\n     * Construct a BluetoothSocket.\n     * @param type    type of socket\n     * @param fd      fd to use for connected socket, or -1 for a new socket\n     * @param auth    require the remote device to be authenticated\n     * @param encrypt require the connection to be encrypted\n     * @param device  remote device that this socket can connect to\n     * @param port    remote port\n     * @param uuid    SDP uuid\n     * @throws IOException On error, for example Bluetooth not available, or\n     *                     insufficient privileges\n     */\n    /*package*/ BluetoothSocket(int type, int fd, boolean auth, boolean encrypt,\n            BluetoothDevice device, int port, ParcelUuid uuid) throws IOException {\n        if (type == BluetoothSocket.TYPE_RFCOMM && uuid == null && fd == -1) {\n            if (port < 1 || port > MAX_RFCOMM_CHANNEL) {\n                throw new IOException(\"Invalid RFCOMM channel: \" + port);\n            }\n        }\n        if(uuid != null)\n            mUuid = uuid;\n        else mUuid = new ParcelUuid(new UUID(0, 0));\n        mType = type;\n        mAuth = auth;\n        mEncrypt = encrypt;\n        mDevice = device;\n        mPort = port;\n        mFd = fd;\n\n        mSocketState = SocketState.INIT;\n\n        if (device == null) {\n            // Server socket\n            mAddress = BluetoothAdapter.getDefaultAdapter().getAddress();\n        } else {\n            // Remote socket\n            mAddress = device.getAddress();\n        }\n        mInputStream = new BluetoothInputStream(this);\n        mOutputStream = new BluetoothOutputStream(this);\n    }\n    private BluetoothSocket(BluetoothSocket s) {\n        mUuid = s.mUuid;\n        mType = s.mType;\n        mAuth = s.mAuth;\n        mEncrypt = s.mEncrypt;\n        mPort = s.mPort;\n        mInputStream = new BluetoothInputStream(this);\n        mOutputStream = new BluetoothOutputStream(this);\n        mServiceName = s.mServiceName;\n    }\n    private BluetoothSocket acceptSocket(String RemoteAddr) throws IOException {\n        BluetoothSocket as = new BluetoothSocket(this);\n        as.mSocketState = SocketState.CONNECTED;\n        FileDescriptor[] fds = mSocket.getAncillaryFileDescriptors();\n        if (DBG) Log.d(TAG, \"socket fd passed by stack  fds: \" + fds);\n        if(fds == null || fds.length != 1) {\n            Log.e(TAG, \"socket fd passed from stack failed, fds: \" + fds);\n            as.close();\n            throw new IOException(\"bt socket acept failed\");\n        }\n        as.mSocket = new LocalSocket(fds[0]);\n        as.mPfd = new ParcelFileDescriptor(fds[0]);\n        try {\n            as.mSocket.closeExternalFd();\n        } catch (IOException e) {\n            Log.e(TAG, \"closeExternalFd failed\");\n        }\n        as.mSocketIS = as.mSocket.getInputStream();\n        as.mSocketOS = as.mSocket.getOutputStream();\n        as.mAddress = RemoteAddr;\n        as.mDevice = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(RemoteAddr);\n        as.mPort = mPort;\n        return as;\n    }\n    /**\n     * Construct a BluetoothSocket from address. Used by native code.\n     * @param type    type of socket\n     * @param fd      fd to use for connected socket, or -1 for a new socket\n     * @param auth    require the remote device to be authenticated\n     * @param encrypt require the connection to be encrypted\n     * @param address remote device that this socket can connect to\n     * @param port    remote port\n     * @throws IOException On error, for example Bluetooth not available, or\n     *                     insufficient privileges\n     */\n    private BluetoothSocket(int type, int fd, boolean auth, boolean encrypt, String address,\n            int port) throws IOException {\n        this(type, fd, auth, encrypt, new BluetoothDevice(address), port, null);\n    }\n\n    /** @hide */\n    @Override\n    protected void finalize() throws Throwable {\n        try {\n            close();\n        } finally {\n            super.finalize();\n        }\n    }\n    private int getSecurityFlags() {\n        int flags = 0;\n        if(mAuth)\n            flags |= SEC_FLAG_AUTH;\n        if(mEncrypt)\n            flags |= SEC_FLAG_ENCRYPT;\n        return flags;\n    }\n\n    /**\n     * Get the remote device this socket is connecting, or connected, to.\n     * @return remote device\n     */\n    public BluetoothDevice getRemoteDevice() {\n        return mDevice;\n    }\n\n    /**\n     * Get the input stream associated with this socket.\n     * <p>The input stream will be returned even if the socket is not yet\n     * connected, but operations on that stream will throw IOException until\n     * the associated socket is connected.\n     * @return InputStream\n     */\n    public InputStream getInputStream() throws IOException {\n        return mInputStream;\n    }\n\n    /**\n     * Get the output stream associated with this socket.\n     * <p>The output stream will be returned even if the socket is not yet\n     * connected, but operations on that stream will throw IOException until\n     * the associated socket is connected.\n     * @return OutputStream\n     */\n    public OutputStream getOutputStream() throws IOException {\n        return mOutputStream;\n    }\n\n    /**\n     * Get the connection status of this socket, ie, whether there is an active connection with\n     * remote device.\n     * @return true if connected\n     *         false if not connected\n     */\n    public boolean isConnected() {\n        return mSocketState == SocketState.CONNECTED;\n    }\n\n    /*package*/ void setServiceName(String name) {\n        mServiceName = name;\n    }\n\n    /**\n     * Attempt to connect to a remote device.\n     * <p>This method will block until a connection is made or the connection\n     * fails. If this method returns without an exception then this socket\n     * is now connected.\n     * <p>Creating new connections to\n     * remote Bluetooth devices should not be attempted while device discovery\n     * is in progress. Device discovery is a heavyweight procedure on the\n     * Bluetooth adapter and will significantly slow a device connection.\n     * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing\n     * discovery. Discovery is not managed by the Activity,\n     * but is run as a system service, so an application should always call\n     * {@link BluetoothAdapter#cancelDiscovery()} even if it\n     * did not directly request a discovery, just to be sure.\n     * <p>{@link #close} can be used to abort this call from another thread.\n     * @throws IOException on error, for example connection failure\n     */\n    public void connect() throws IOException {\n        if (mDevice == null) throw new IOException(\"Connect is called on null device\");\n\n        try {\n            if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n            IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n            if (bluetoothProxy == null) throw new IOException(\"Bluetooth is off\");\n            mPfd = bluetoothProxy.connectSocket(mDevice, mType,\n                    mUuid, mPort, getSecurityFlags());\n            synchronized(this)\n            {\n                if (DBG) Log.d(TAG, \"connect(), SocketState: \" + mSocketState + \", mPfd: \" + mPfd);\n                if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n                if (mPfd == null) throw new IOException(\"bt socket connect failed\");\n                FileDescriptor fd = mPfd.getFileDescriptor();\n                mSocket = new LocalSocket(fd);\n                mSocketIS = mSocket.getInputStream();\n                mSocketOS = mSocket.getOutputStream();\n            }\n            int channel = readInt(mSocketIS);\n            if (channel <= 0)\n                throw new IOException(\"bt socket connect failed\");\n            mPort = channel;\n            waitSocketSignal(mSocketIS);\n            synchronized(this)\n            {\n                if (mSocketState == SocketState.CLOSED)\n                    throw new IOException(\"bt socket closed\");\n                mSocketState = SocketState.CONNECTED;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            throw new IOException(\"unable to send RPC: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Currently returns unix errno instead of throwing IOException,\n     * so that BluetoothAdapter can check the error code for EADDRINUSE\n     */\n    /*package*/ int bindListen() {\n        int ret;\n        if (mSocketState == SocketState.CLOSED) return EBADFD;\n        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n        if (bluetoothProxy == null) {\n            Log.e(TAG, \"bindListen fail, reason: bluetooth is off\");\n            return -1;\n        }\n        try {\n            mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName,\n                    mUuid, mPort, getSecurityFlags());\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            return -1;\n        }\n\n        // read out port number\n        try {\n            synchronized(this) {\n                if (DBG) Log.d(TAG, \"bindListen(), SocketState: \" + mSocketState + \", mPfd: \" +\n                                mPfd);\n                if(mSocketState != SocketState.INIT) return EBADFD;\n                if(mPfd == null) return -1;\n                FileDescriptor fd = mPfd.getFileDescriptor();\n                if (DBG) Log.d(TAG, \"bindListen(), new LocalSocket \");\n                mSocket = new LocalSocket(fd);\n                if (DBG) Log.d(TAG, \"bindListen(), new LocalSocket.getInputStream() \");\n                mSocketIS = mSocket.getInputStream();\n                mSocketOS = mSocket.getOutputStream();\n            }\n            if (DBG) Log.d(TAG, \"bindListen(), readInt mSocketIS: \" + mSocketIS);\n            int channel = readInt(mSocketIS);\n            synchronized(this) {\n                if(mSocketState == SocketState.INIT)\n                    mSocketState = SocketState.LISTENING;\n            }\n            if (DBG) Log.d(TAG, \"channel: \" + channel);\n            if (mPort == -1) {\n                mPort = channel;\n            } // else ASSERT(mPort == channel)\n            ret = 0;\n        } catch (IOException e) {\n            if (mPfd != null) {\n                try {\n                    mPfd.close();\n                } catch (IOException e1) {\n                    Log.e(TAG, \"bindListen, close mPfd: \" + e1);\n                }\n                mPfd = null;\n            }\n            Log.e(TAG, \"bindListen, fail to get port number, exception: \" + e);\n            return -1;\n        }\n        return ret;\n    }\n\n    /*package*/ BluetoothSocket accept(int timeout) throws IOException {\n        BluetoothSocket acceptedSocket;\n        if (mSocketState != SocketState.LISTENING) throw new IOException(\"bt socket is not in listen state\");\n        if(timeout > 0) {\n            Log.d(TAG, \"accept() set timeout (ms):\" + timeout);\n           mSocket.setSoTimeout(timeout);\n        }\n        String RemoteAddr = waitSocketSignal(mSocketIS);\n        if(timeout > 0)\n            mSocket.setSoTimeout(0);\n        synchronized(this)\n        {\n            if (mSocketState != SocketState.LISTENING)\n                throw new IOException(\"bt socket is not in listen state\");\n            acceptedSocket = acceptSocket(RemoteAddr);\n            //quick drop the reference of the file handle\n        }\n        return acceptedSocket;\n    }\n\n    /**\n     * setSocketOpt for the Buetooth Socket.\n     *\n     * @param optionName socket option name\n     * @param optionVal  socket option value\n     * @param optionLen  socket option length\n     * @return -1 on immediate error,\n     *               0 otherwise\n     * @hide\n     */\n    public int setSocketOpt(int optionName, byte [] optionVal, int optionLen) throws IOException {\n        int ret = 0;\n        if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n        if (bluetoothProxy == null) {\n            Log.e(TAG, \"setSocketOpt fail, reason: bluetooth is off\");\n            return -1;\n        }\n        try {\n            if(VDBG) Log.d(TAG, \"setSocketOpt(), mType: \" + mType + \" mPort: \" + mPort);\n            ret = bluetoothProxy.setSocketOpt(mType, mPort, optionName, optionVal, optionLen);\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            return -1;\n        }\n        return ret;\n    }\n\n    /**\n     * getSocketOpt for the Buetooth Socket.\n     *\n     * @param optionName socket option name\n     * @param optionVal  socket option value\n     * @return -1 on immediate error,\n     *               length of returned socket option otherwise\n     * @hide\n     */\n    public int getSocketOpt(int optionName, byte [] optionVal) throws IOException {\n        int ret = 0;\n        if (mSocketState == SocketState.CLOSED) throw new IOException(\"socket closed\");\n        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);\n        if (bluetoothProxy == null) {\n            Log.e(TAG, \"getSocketOpt fail, reason: bluetooth is off\");\n            return -1;\n        }\n        try {\n            if(VDBG) Log.d(TAG, \"getSocketOpt(), mType: \" + mType + \" mPort: \" + mPort);\n            ret = bluetoothProxy.getSocketOpt(mType, mPort, optionName, optionVal);\n        } catch (RemoteException e) {\n            Log.e(TAG, Log.getStackTraceString(new Throwable()));\n            return -1;\n        }\n        return ret;\n    }\n\n    /*package*/ int available() throws IOException {\n        if (VDBG) Log.d(TAG, \"available: \" + mSocketIS);\n        return mSocketIS.available();\n    }\n    /**\n     * Wait until the data in sending queue is emptied. A polling version\n     * for flush implementation. Used to ensure the writing data afterwards will\n     * be packed in new RFCOMM frame.\n     * @throws IOException\n     *             if an i/o error occurs.\n     */\n    /*package*/ void flush() throws IOException {\n        if (mSocketOS == null) throw new IOException(\"flush is called on null OutputStream\");\n        if (VDBG) Log.d(TAG, \"flush: \" + mSocketOS);\n        mSocketOS.flush();\n    }\n\n    /*package*/ int read(byte[] b, int offset, int length) throws IOException {\n        if (mSocketIS == null) throw new IOException(\"read is called on null InputStream\");\n        if (VDBG) Log.d(TAG, \"read in:  \" + mSocketIS + \" len: \" + length);\n        int ret = mSocketIS.read(b, offset, length);\n        if(ret < 0)\n            throw new IOException(\"bt socket closed, read return: \" + ret);\n        if (VDBG) Log.d(TAG, \"read out:  \" + mSocketIS + \" ret: \" + ret);\n        return ret;\n    }\n\n    /*package*/ int write(byte[] b, int offset, int length) throws IOException {\n        if (mSocketOS == null) throw new IOException(\"write is called on null OutputStream\");\n        if (VDBG) Log.d(TAG, \"write: \" + mSocketOS + \" length: \" + length);\n        mSocketOS.write(b, offset, length);\n        // There is no good way to confirm since the entire process is asynchronous anyway\n        if (VDBG) Log.d(TAG, \"write out: \" + mSocketOS + \" length: \" + length);\n        return length;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (DBG) Log.d(TAG, \"close() in, this: \" + this + \", channel: \" + mPort + \", state: \" + mSocketState);\n        if(mSocketState == SocketState.CLOSED)\n            return;\n        else\n        {\n            synchronized(this)\n            {\n                 if(mSocketState == SocketState.CLOSED)\n                    return;\n                 mSocketState = SocketState.CLOSED;\n                 if (DBG) Log.d(TAG, \"close() this: \" + this + \", channel: \" + mPort + \", mSocketIS: \" + mSocketIS +\n                        \", mSocketOS: \" + mSocketOS + \"mSocket: \" + mSocket);\n                 if(mSocket != null) {\n                    if (DBG) Log.d(TAG, \"Closing mSocket: \" + mSocket);\n                    mSocket.shutdownInput();\n                    mSocket.shutdownOutput();\n                    mSocket.close();\n                    mSocket = null;\n                }\n                if (mPfd != null) {\n                    mPfd.close();\n                    mPfd = null;\n                }\n           }\n        }\n    }\n\n    /*package */ void removeChannel() {\n    }\n\n    /*package */ int getPort() {\n        return mPort;\n    }\n    private String convertAddr(final byte[] addr)  {\n        return String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                addr[0] , addr[1], addr[2], addr[3] , addr[4], addr[5]);\n    }\n    private String waitSocketSignal(InputStream is) throws IOException {\n        byte [] sig = new byte[SOCK_SIGNAL_SIZE];\n        int ret = readAll(is, sig);\n        if (VDBG) Log.d(TAG, \"waitSocketSignal read 16 bytes signal ret: \" + ret);\n        ByteBuffer bb = ByteBuffer.wrap(sig);\n        bb.order(ByteOrder.nativeOrder());\n        int size = bb.getShort();\n        if(size != SOCK_SIGNAL_SIZE)\n            throw new IOException(\"Connection failure, wrong signal size: \" + size);\n        byte [] addr = new byte[6];\n        bb.get(addr);\n        int channel = bb.getInt();\n        int status = bb.getInt();\n        String RemoteAddr = convertAddr(addr);\n        if (VDBG) Log.d(TAG, \"waitSocketSignal: sig size: \" + size + \", remote addr: \"\n                + RemoteAddr + \", channel: \" + channel + \", status: \" + status);\n        if(status != 0)\n            throw new IOException(\"Connection failure, status: \" + status);\n        return RemoteAddr;\n    }\n    private int readAll(InputStream is, byte[] b) throws IOException {\n        int left = b.length;\n        while(left > 0) {\n            int ret = is.read(b, b.length - left, left);\n            if(ret <= 0)\n                 throw new IOException(\"read failed, socket might closed or timeout, read ret: \" + ret);\n            left -= ret;\n            if(left != 0)\n                Log.w(TAG, \"readAll() looping, read partial size: \" + (b.length - left) +\n                            \", expect size: \" + b.length);\n        }\n        return b.length;\n    }\n\n    private int readInt(InputStream is) throws IOException {\n        byte[] ibytes = new byte[4];\n        int ret = readAll(is, ibytes);\n        if (VDBG) Log.d(TAG, \"inputStream.read ret: \" + ret);\n        ByteBuffer bb = ByteBuffer.wrap(ibytes);\n        bb.order(ByteOrder.nativeOrder());\n        return bb.getInt();\n    }\n}\n"], "filenames": ["core/java/android/bluetooth/BluetoothSocket.java"], "buggy_code_start_loc": [194], "buggy_code_end_loc": [194], "fixing_code_start_loc": [195], "fixing_code_end_loc": [196], "type": "NVD-CWE-noinfo", "message": "A Denial of Service vulnerability exists in Google Android 4.4.4, 5.0.2, and 5.1.1, which allows malicious users to block Bluetooh access (Android Bug ID A-28672558).", "other": {"cve": {"id": "CVE-2014-9908", "sourceIdentifier": "security@android.com", "published": "2020-01-08T15:15:11.103", "lastModified": "2020-01-13T21:01:20.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A Denial of Service vulnerability exists in Google Android 4.4.4, 5.0.2, and 5.1.1, which allows malicious users to block Bluetooh access (Android Bug ID A-28672558)."}, {"lang": "es", "value": "Existe una vulnerabilidad de denegaci\u00f3n de servicio en Google Android versiones 4.4.4, 5.0.2 y 5.1.1, lo que permite a usuarios maliciosos bloquear el acceso a Bluetooh (ID de Bug de Android A-28672558)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 6.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "98C32982-095C-4628-9958-118A3D3A9CAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:google:android:5.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "E9915371-C730-41F7-B86E-7E4DE0DF5385"}, {"vulnerable": true, "criteria": "cpe:2.3:o:google:android:5.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B1D94CDD-DE7B-444E-A3AE-AE9C9A779374"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/94167", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/Genymobile/f2ut_platform_frameworks_base/commit/f24cec326f5f65c693544fb0b92c37f633bacda2", "source": "security@android.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.93449", "source": "security@android.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Genymobile/f2ut_platform_frameworks_base/commit/f24cec326f5f65c693544fb0b92c37f633bacda2"}}