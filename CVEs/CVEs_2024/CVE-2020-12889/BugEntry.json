{"buggy_code": ["from canari.maltego.entities import Unknown, Hashtag\nfrom canari.maltego.transform import Transform\nfrom MISP_maltego.transforms.common.entities import MISPGalaxy\nfrom MISP_maltego.transforms.common.util import check_update, get_misp_connection, event_to_entity, object_to_entity, get_attribute_in_event, get_attribute_in_object, attribute_to_entity, get_entity_property, search_galaxy_cluster, galaxycluster_to_entity, tag_matches_note_prefix\nfrom canari.maltego.message import LinkDirection, Bookmark\n\n__author__ = 'Christophe Vandeplas'\n__copyright__ = 'Copyright 2018, MISP_maltego Project'\n__credits__ = []\n\n__license__ = 'AGPLv3'\n__version__ = '0.1'\n__maintainer__ = 'Christophe Vandeplas'\n__email__ = 'christophe@vandeplas.com'\n__status__ = 'Development'\n\n\nclass SearchInMISP(Transform):\n    \"\"\"Search an attribute, event in MISP, allowing the use of % at the front and end\"\"\"\n    input_type = Unknown\n    display_name = 'Search in MISP'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        link_label = 'Search result'\n\n        if 'properties.mispevent' in request.entity.fields:\n            misp = get_misp_connection(config, request.parameters)\n            # if event_id\n            try:\n                if request.entity.value == '0':\n                    return response\n                eventid = int(request.entity.value)\n                events_json = misp.search(controller='events', eventid=eventid, with_attachments=False)\n                for e in events_json:\n                    response += event_to_entity(e, link_label=link_label, link_direction=LinkDirection.OutputToInput)\n                return response\n            except ValueError:\n                pass\n            # if event_info string as value\n            events_json = misp.search(controller='events', eventinfo=request.entity.value, with_attachments=False)\n            for e in events_json:\n                response += event_to_entity(e, link_label=link_label, link_direction=LinkDirection.OutputToInput)\n            return response\n\n        # From galaxy or Hashtag\n        if 'properties.mispgalaxy' in request.entity.fields or 'properties.temp' in request.entity.fields:\n            if request.entity.value == '-':\n                return response\n            # First search in galaxies\n            keyword = get_entity_property(request.entity, 'Temp')\n            if not keyword:\n                keyword = request.entity.value\n            # assume the user is searching for a cluster based on a substring.\n            # Search in the list for those that match and return galaxy entities'\n            potential_clusters = search_galaxy_cluster(keyword)\n            # LATER check if duplicates are possible\n            if potential_clusters:\n                for potential_cluster in potential_clusters:\n                    new_entity = galaxycluster_to_entity(potential_cluster, link_label=link_label)\n                    # LATER support the type_filter - unfortunately this is not possible, we need Canari to tell us the original entity type\n                    if isinstance(new_entity, MISPGalaxy):\n                        response += new_entity\n\n            # from Hashtag search also in tags\n            if 'properties.temp' in request.entity.fields:\n                keyword = get_entity_property(request.entity, 'Temp')\n                if not keyword:\n                    keyword = request.entity.value\n                misp = get_misp_connection(config, request.parameters)\n                result = misp.direct_call('tags/search', {'name': keyword})\n                for t in result:\n                    # skip misp-galaxies as we have processed them earlier on\n                    if t['Tag']['name'].startswith('misp-galaxy'):\n                        continue\n                    # In this case we do not filter away those we add as notes, as people might want to pivot on it explicitly.\n                    response += Hashtag(t['Tag']['name'], link_label=link_label, bookmark=Bookmark.Green)\n\n            return response\n\n        # for all other normal entities\n        misp = get_misp_connection(config, request.parameters)\n        events_json = misp.search(controller='events', value=request.entity.value, with_attachments=False)\n        # we need to do really rebuild the Entity from scratch as request.entity is of type Unknown\n        for e in events_json:\n            # find the value as attribute\n            attr = get_attribute_in_event(e, request.entity.value, substring=True)\n            if attr:\n                for item in attribute_to_entity(attr, only_self=True):\n                    response += item\n            # find the value as object, and return the object\n            if 'Object' in e['Event']:\n                for o in e['Event']['Object']:\n                    if get_attribute_in_object(o, attribute_value=request.entity.value, substring=True).get('value'):\n                        response += object_to_entity(o, link_label=link_label)\n\n        return response\n\n# placeholder for https://github.com/MISP/MISP-maltego/issues/11\n# waiting for support of CIDR search through the REST API\n# @EnableDebugWindow\n# class NetblockToAttributes(Transform):\n#     display_name = 'to MISP Attributes'\n#     input_type = Netblock\n#     remote = True\n\n#     def do_transform(self, request, response, config):\n#         maltego_misp_attribute = request.entity\n#         misp = get_misp_connection(config, request.parameters)\n#         import ipaddress\n#         ip_start, ip_end = maltego_misp_attribute.value.split('-')\n#         # LATER make this work with IPv4 and IPv6\n#         # automagically detect the different CIDRs\n#         cidrs = ipaddress.summarize_address_range(ipaddress.IPv4Address(ip_start), ipaddress.IPv4Address(ip_end))\n#         for cidr in cidrs:\n#             print(str(cidr))\n#             attr_json = misp.search(controller='attributes', value=str(cidr), with_attachments=False)\n#             print(attr_json)\n#         return response\n\n\nclass AttributeToEvent(Transform):\n    input_type = Unknown\n    display_name = 'to MISP Event'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        # skip some Entities\n        skip = ['properties.mispevent']\n        for i in skip:\n            if i in request.entity.fields:\n                return response\n\n        if 'ipv4-range' in request.entity.fields:\n            # placeholder for https://github.com/MISP/MISP-maltego/issues/11\n            pass\n\n        misp = get_misp_connection(config, request.parameters)\n        # from Galaxy\n        if 'properties.mispgalaxy' in request.entity.fields:\n            tag_name = get_entity_property(request.entity, 'tag_name')\n            if not tag_name:\n                tag_name = request.entity.value\n            events_json = misp.search(controller='events', tags=tag_name, with_attachments=False)\n            for e in events_json:\n                response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n            return response\n        # from Object\n        elif 'properties.mispobject' in request.entity.fields:\n            if request.entity.fields.get('event_id'):\n                events_json = misp.search(controller='events', eventid=request.entity.fields.get('event_id').value, with_attachments=False)\n                for e in events_json:\n                    response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n                return response\n            else:\n                return response\n        # from Hashtag\n        elif 'properties.temp' in request.entity.fields:\n            tag_name = get_entity_property(request.entity, 'Temp')\n            if not tag_name:\n                tag_name = request.entity.value\n            events_json = misp.search(controller='events', tags=tag_name, with_attachments=False)\n            for e in events_json:\n                response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n            return response\n        # standard Entities (normal attributes)\n        else:\n            events_json = misp.search(controller='events', value=request.entity.value, with_attachments=False)\n\n        # return the MISPEvent or MISPObject of the attribute\n        for e in events_json:\n            # find the value as attribute\n            attr = get_attribute_in_event(e, request.entity.value)\n            if attr:\n                response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n            # find the value as object\n            if 'Object' in e['Event']:\n                for o in e['Event']['Object']:\n                    if get_attribute_in_object(o, attribute_value=request.entity.value).get('value'):\n                        response += object_to_entity(o, link_direction=LinkDirection.OutputToInput)\n\n        return response\n", "from canari.maltego.entities import Hash, URL, File, Person, Hashtag\nfrom canari.maltego.message import Label, LinkStyle, MaltegoException, Bookmark, LinkDirection, UIMessage, UIMessageType\nfrom canari.mode import is_local_exec_mode, is_remote_exec_mode\nfrom distutils.version import StrictVersion\nfrom MISP_maltego.transforms.common.entities import MISPEvent, MISPObject, MISPGalaxy\nfrom MISP_maltego.transforms.common.mappings import mapping_object_icon, mapping_misp_to_maltego, mapping_galaxy_icon, mapping_galaxy_type\nfrom pymisp import ExpandedPyMISP as PyMISP\nimport json\nimport os\nimport os.path\nimport requests\nimport tempfile\nimport time\n\n# FIXME from galaxy 'to MISP Event' is confusing\n\n__version__ = '1.4.4'  # also update version in setup.py\n\ntag_note_prefixes = ['tlp:', 'PAP:', 'de-vs:', 'euci:', 'fr-classif:', 'nato:']\n\nmisp_connection = None\nupdate_url = 'https://raw.githubusercontent.com/MISP/MISP-maltego/master/setup.py'\nlocal_path_root = os.path.join(tempfile.gettempdir(), 'MISP-maltego')\nlocal_path_version = os.path.join(local_path_root, 'versioncheck')\nif not os.path.exists(local_path_root):\n    os.mkdir(local_path_root)\n    os.chmod(local_path_root, mode=0o777)  # temporary workaround - see https://github.com/redcanari/canari3/issues/61\n\n\ndef check_update(config):\n    # Do not check updates if running as remote transform\n    if is_remote_exec_mode():\n        return None\n    # only raise the alert once a day/reboot to the user.\n    try:\n        if time.time() - os.path.getmtime(local_path_version) > 60 * 60 * 24:  # check the timestamp of the file\n            recheck = True\n        else:\n            recheck = False\n    except Exception:  # file does not exist, so check version\n        recheck = True\n    if not recheck:\n        return None\n    # remember we checked the version\n    from pathlib import Path\n    Path(local_path_version).touch()\n    # UIMessageType must be Fatal as otherwise it is not shown to the user.\n    if 'MISP_maltego.local.check_updates' not in config:\n        return UIMessage(\"'check_updates' parameter missing in '.canari/MISP_maltego.conf'. Please set 'check_updates = True/False'.\", type=UIMessageType.Fatal)\n    if config['MISP_maltego.local.check_updates']:\n        # check the version\n        r = requests.get(update_url)\n        for l in r.text.splitlines():\n            if 'version=' in l:\n                online_ver = l.strip().strip(',').split('=').pop().strip(\"'\")\n                if StrictVersion(online_ver) > StrictVersion(__version__):\n                    message = ('A new version of MISP-Maltego is available.\\n'\n                               'To upgrade, please:\\n'\n                               '    pip3 --upgrade MISP-maltego'\n                               '    canari create-profile MISP_maltego\\n'\n                               '    And import the newly generated .mtz bundle in Maltego (Import > Import Configuration)')\n                    return UIMessage(message, type=UIMessageType.Fatal)\n                break\n    return None\n\n\ndef get_misp_connection(config=None, parameters=None):\n    global misp_connection\n    if misp_connection:\n        return misp_connection\n    if not config:\n        raise MaltegoException(\"ERROR: MISP connection not yet established, and config not provided as parameter.\")\n    misp_verify = True\n    misp_debug = False\n    misp_url = None\n    misp_key = None\n    try:\n        if is_local_exec_mode():\n            misp_url = config['MISP_maltego.local.misp_url']\n            misp_key = config['MISP_maltego.local.misp_key']\n            if config['MISP_maltego.local.misp_verify'] in ['False', 'false', 0, 'no', 'No']:\n                misp_verify = False\n            if config['MISP_maltego.local.misp_debug'] in ['True', 'true', 1, 'yes', 'Yes']:\n                misp_debug = True\n        if is_remote_exec_mode():\n            try:\n                misp_url = parameters['mispurl'].value\n                misp_key = parameters['mispkey'].value\n            except AttributeError:\n                raise MaltegoException(\"ERROR: mispurl and mispkey need to be set to something valid\")\n        misp_connection = PyMISP(misp_url, misp_key, misp_verify, 'json', misp_debug, tool='misp_maltego')\n    except Exception:\n        if is_local_exec_mode():\n            raise MaltegoException(\"ERROR: Cannot connect to MISP server. Please verify your MISP_Maltego.conf settings.\")\n        if is_remote_exec_mode():\n            raise MaltegoException(\"ERROR: Cannot connect to MISP server. Please verify your settings (MISP URL and API key), and ensure the MISP server is reachable from the internet.\")\n    return misp_connection\n\n\ndef entity_obj_to_entity(entity_obj, v, t, **kwargs):\n    if entity_obj == Hash:\n        return entity_obj(v, _type=t, **kwargs)  # LATER type is conflicting with type of Entity, Report this as bug see line 326 /usr/local/lib/python3.5/dist-packages/canari/maltego/entities.py\n\n    return entity_obj(v, **kwargs)\n\n\ndef get_entity_property(entity, name):\n    for k, v in entity.fields.items():\n        if k == name:\n            return v.value\n    return None\n\n\ndef attribute_to_entity(a, link_label=None, event_tags=[], only_self=False):\n    # prepare some attributes to a better form\n    a['data'] = None  # empty the file content as we really don't need this here\n    if a['type'] == 'malware-sample':\n        a['type'] = 'filename|md5'\n    if a['type'] == 'regkey|value':  # LATER regkey|value => needs to be a special non-combined object\n        a['type'] = 'regkey'\n\n    combined_tags = event_tags\n    if 'Galaxy' in a and not only_self:\n        for g in a['Galaxy']:\n            for c in g['GalaxyCluster']:\n                yield galaxycluster_to_entity(c)\n\n    # complement the event tags with the attribute tags.\n    if 'Tag' in a and not only_self:\n            for t in a['Tag']:\n                combined_tags.append(t['name'])\n                # ignore all misp-galaxies\n                if t['name'].startswith('misp-galaxy'):\n                    continue\n                # ignore all those we add as notes\n                if tag_matches_note_prefix(t['name']):\n                    continue\n                yield Hashtag(t['name'], bookmark=Bookmark.Green)\n\n    notes = convert_tags_to_note(combined_tags)\n\n    # special cases\n    if a['type'] in ('url', 'uri'):\n        yield(URL(url=a['value'], short_title=a['value'], link_label=link_label, notes=notes, bookmark=Bookmark.Green))\n        return\n\n    # attribute is from an object, and a relation gives better understanding of the type of attribute\n    if a.get('object_relation') and mapping_misp_to_maltego.get(a['object_relation']):\n        entity_obj = mapping_misp_to_maltego[a['object_relation']][0]\n        yield entity_obj(a['value'], labels=[Label('comment', a.get('comment'))], link_label=link_label, notes=notes, bookmark=Bookmark.Green)\n\n    # combined attributes\n    elif '|' in a['type']:\n        t_1, t_2 = a['type'].split('|')\n        v_1, v_2 = a['value'].split('|')\n        if t_1 in mapping_misp_to_maltego:\n            entity_obj = mapping_misp_to_maltego[t_1][0]\n            labels = [Label('comment', a.get('comment'))]\n            if entity_obj == File:\n                labels.append(Label('hash', v_2))\n            yield entity_obj_to_entity(entity_obj, v_1, t_1, labels=labels, link_label=link_label, notes=notes, bookmark=Bookmark.Green)  # LATER change the comment to include the second part of the regkey\n        if t_2 in mapping_misp_to_maltego:\n            entity_obj = mapping_misp_to_maltego[t_2][0]\n            labels = [Label('comment', a.get('comment'))]\n            if entity_obj == Hash:\n                labels.append(Label('filename', v_1))\n            yield entity_obj_to_entity(entity_obj, v_2, t_2, labels=labels, link_label=link_label, notes=notes, bookmark=Bookmark.Green)  # LATER change the comment to include the first part of the regkey\n\n    # normal attributes\n    elif a['type'] in mapping_misp_to_maltego:\n        entity_obj = mapping_misp_to_maltego[a['type']][0]\n        yield entity_obj_to_entity(entity_obj, a['value'], a['type'], labels=[Label('comment', a.get('comment'))], link_label=link_label, notes=notes, bookmark=Bookmark.Green)\n\n    # not supported in our maltego mapping are not handled\n\n    # LATER : relationships from attributes - not yet supported by MISP yet, but there are references in the datamodel\n\n\ndef object_to_entity(o, link_label=None, link_direction=LinkDirection.InputToOutput):\n    misp = get_misp_connection()\n    # find a nice icon for it\n    try:\n        icon_url = mapping_object_icon[o['name']]\n    except KeyError:\n        # it's not in our mapping, just ignore and leave the default icon\n        icon_url = None\n    # Generate a human readable display-name:\n    # - find the first RequiredOneOf that exists\n    # - if none, use the first RequiredField\n    # LATER further finetune the human readable version of this object\n    o_template = misp.get_object_template(o['template_uuid'])\n    human_readable = None\n    try:\n        found = False\n        while not found:  # the while loop is broken once something is found, or the requiredOneOf has no elements left\n            required_ote_type = o_template['ObjectTemplate']['requirements']['requiredOneOf'].pop(0)\n            for ote in o_template['ObjectTemplateElement']:\n                if ote['object_relation'] == required_ote_type:\n                    required_a_type = ote['type']\n                    break\n            for a in o['Attribute']:\n                if a['type'] == required_a_type:\n                    human_readable = '{}:\\n{}'.format(o['name'], a['value'])\n                    found = True\n                    break\n    except Exception:\n        pass\n    if not human_readable:\n        try:\n            found = False\n            parts = []\n            for required_ote_type in o_template['ObjectTemplate']['requirements']['required']:\n                for ote in o_template['ObjectTemplateElement']:\n                    if ote['object_relation'] == required_ote_type:\n                        required_a_type = ote['type']\n                        break\n                for a in o['Attribute']:\n                    if a['type'] == required_a_type:\n                        parts.append(a['value'])\n                        break\n            human_readable = '{}:\\n{}'.format(o['name'], '|'.join(parts))\n        except Exception:\n            human_readable = o['name']\n    return MISPObject(\n        human_readable,\n        uuid=o['uuid'],\n        event_id=int(o['event_id']),\n        meta_category=o.get('meta_category'),\n        description=o.get('description'),\n        comment=o.get('comment'),\n        icon_url=icon_url,\n        link_label=link_label,\n        link_direction=link_direction,\n        bookmark=Bookmark.Green\n    )\n\n\ndef object_to_attributes(o, e):\n    # first process attributes from an object that belong together (eg: first-name + last-name), and remove them from the list\n    if o['name'] == 'person':\n        first_name = get_attribute_in_object(o, attribute_type='first-name', drop=True).get('value')\n        last_name = get_attribute_in_object(o, attribute_type='last-name', drop=True).get('value')\n        yield entity_obj_to_entity(Person, ' '.join([first_name, last_name]).strip(), 'person', lastname=last_name, firstnames=first_name, bookmark=Bookmark.Green)\n\n    # process normal attributes\n    for a in o['Attribute']:\n        for item in attribute_to_entity(a):\n            yield item\n\n\ndef object_to_relations(o, e):\n    # process forward and reverse references, so just loop over all the objects of the event\n    if 'Object' in e['Event']:\n        for eo in e['Event']['Object']:\n            if 'ObjectReference' in eo:\n                for ref in eo['ObjectReference']:\n                    # we have found original object. Expand to the related object and attributes\n                    if eo['uuid'] == o['uuid']:\n                        # the reference is an Object\n                        if ref.get('Object'):\n                            # get the full object in the event, as our objectReference included does not contain everything we need\n                            sub_object = get_object_in_event(ref['Object']['uuid'], e)\n                            yield object_to_entity(sub_object, link_label=ref['relationship_type'])\n                        # the reference is an Attribute\n                        if ref.get('Attribute'):\n                            ref['Attribute']['event_id'] = ref['event_id']   # LATER remove this ugly workaround - object can't be requested directly from MISP using the uuid, and to find a full object we need the event_id\n                            for item in attribute_to_entity(ref['Attribute'], link_label=ref['relationship_type']):\n                                yield item\n\n                    # reverse-lookup - this is another objects relating the original object\n                    if ref['referenced_uuid'] == o['uuid']:\n                        yield object_to_entity(eo, link_label=ref['relationship_type'], link_direction=LinkDirection.OutputToInput)\n\n\ndef get_object_in_event(uuid, e):\n    for o in e['Event']['Object']:\n        if o['uuid'] == uuid:\n            return o\n\n\ndef get_attribute_in_object(o, attribute_type=False, attribute_value=False, drop=False, substring=False):\n    '''Gets the first attribute of a specific type within an object'''\n    found_attribute = {'value': ''}\n    for i, a in enumerate(o['Attribute']):\n        if a['type'] == attribute_type:\n            found_attribute = a.copy()\n            if drop:    # drop the attribute from the object\n                o['Attribute'].pop(i)\n            break\n        if a['value'] == attribute_value:\n            found_attribute = a.copy()\n            if drop:    # drop the attribute from the object\n                o['Attribute'].pop(i)\n            break\n        if '|' in a['type'] or a['type'] == 'malware-sample':\n            if attribute_value in a['value'].split('|'):\n                found_attribute = a.copy()\n                if drop:    # drop the attribute from the object\n                    o['Attribute'].pop(i)\n                break\n        # TODO implement substring matching\n        if substring:\n            keyword = attribute_value.strip('%')\n            if attribute_value.startswith('%') and attribute_value.endswith('%'):\n                if attribute_value in a['value']:\n                    found_attribute = a.copy()\n                    if drop:    # drop the attribute from the object\n                        o['Attribute'].pop(i)\n                    break\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if attribute_value in val1 or attribute_value in val2:\n                        found_attribute = a.copy()\n                        if drop:    # drop the attribute from the object\n                            o['Attribute'].pop(i)\n                        break\n            elif attribute_value.startswith('%'):\n                if a['value'].endswith(keyword):\n                    found_attribute = a.copy()\n                    if drop:    # drop the attribute from the object\n                        o['Attribute'].pop(i)\n                    break\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.endswith(keyword) or val2.endswith(keyword):\n                        found_attribute = a.copy()\n                        if drop:    # drop the attribute from the object\n                            o['Attribute'].pop(i)\n                        break\n\n            elif attribute_value.endswith('%'):\n                if a['value'].startswith(keyword):\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.startswith(keyword) or val2.startswith(keyword):\n                        found_attribute = a.copy()\n                        if drop:    # drop the attribute from the object\n                            o['Attribute'].pop(i)\n                        break\n    return found_attribute\n\n\ndef get_attribute_in_event(e, attribute_value, substring=False):\n    for a in e['Event'][\"Attribute\"]:\n        if a['value'] == attribute_value:\n            return a\n        if '|' in a['type'] or a['type'] == 'malware-sample':\n            if attribute_value in a['value'].split('|'):\n                return a\n        if substring:\n            keyword = attribute_value.strip('%')\n            if attribute_value.startswith('%') and attribute_value.endswith('%'):\n                if attribute_value in a['value']:\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if attribute_value in val1 or attribute_value in val2:\n                        return a\n            elif attribute_value.startswith('%'):\n                if a['value'].endswith(keyword):\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.endswith(keyword) or val2.endswith(keyword):\n                        return a\n\n            elif attribute_value.endswith('%'):\n                if a['value'].startswith(keyword):\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.startswith(keyword) or val2.startswith(keyword):\n                        return a\n\n    return None\n\n\ndef convert_tags_to_note(tags):\n    if not tags:\n        return None\n    notes = []\n    for tag in tags:\n        for tag_note_prefix in tag_note_prefixes:\n            if tag.startswith(tag_note_prefix):\n                notes.append(tag)\n    return '\\n'.join(notes)\n\n\ndef tag_matches_note_prefix(tag):\n    for tag_note_prefix in tag_note_prefixes:\n        if tag.startswith(tag_note_prefix):\n            return True\n    return False\n\n\ndef event_to_entity(e, link_style=LinkStyle.Normal, link_label=None, link_direction=LinkDirection.InputToOutput):\n    tags = []\n    if 'Tag' in e['Event']:\n        for t in e['Event']['Tag']:\n            tags.append(t['name'])\n    notes = convert_tags_to_note(tags)\n    return MISPEvent(\n        e['Event']['id'],\n        uuid=e['Event']['uuid'],\n        info=e['Event']['info'],\n        link_style=link_style,\n        link_label=link_label,\n        link_direction=link_direction,\n        count_attributes=len(e['Event'].get('Attribute') or \"\"),\n        count_objects=len(e['Event'].get('Object') or \"\"),\n        notes=notes,\n        bookmark=Bookmark.Green)\n\n\ndef galaxycluster_to_entity(c, link_label=None, link_direction=LinkDirection.InputToOutput):\n    if 'meta' in c and 'uuid' in c['meta']:\n        c['uuid'] = c['meta']['uuid'].pop(0)\n\n    if 'meta' in c and 'synonyms' in c['meta']:\n        synonyms = ', '.join(c['meta']['synonyms'])\n    else:\n        synonyms = ''\n\n    galaxy_cluster = get_galaxy_cluster(uuid=c['uuid'])\n    # map the 'icon' name from the cluster to the icon filename of the intelligence-icons repository\n    try:\n        icon_url = mapping_galaxy_icon[galaxy_cluster['icon']]\n    except KeyError:\n        # it's not in our mapping, just ignore and leave the default icon\n        icon_url = None\n\n    # create the right sub-galaxy: ThreatActor, Software, AttackTechnique, ... or MISPGalaxy\n    try:\n        galaxy_type = mapping_galaxy_type[galaxy_cluster['type']]\n    except KeyError:\n        galaxy_type = MISPGalaxy\n    return galaxy_type(\n        '{}\\n{}'.format(c['type'], c['value']),\n        uuid=c['uuid'],\n        description=c.get('description'),\n        cluster_type=c.get('type'),\n        cluster_value=c.get('value'),\n        synonyms=synonyms,\n        tag_name=c['tag_name'],\n        link_label=link_label,\n        icon_url=icon_url,\n        link_direction=link_direction\n    )\n\n\n# LATER this uses the galaxies from github as the MISP web UI does not fully support the Galaxies in the webui.\n# See https://github.com/MISP/MISP/issues/3801\ngalaxy_archive_url = 'https://github.com/MISP/misp-galaxy/archive/master.zip'\nlocal_path_uuid_mapping = os.path.join(local_path_root, 'MISP_maltego_galaxy_mapping.json')\nlocal_path_clusters = os.path.join(local_path_root, 'misp-galaxy-master', 'clusters')\ngalaxy_cluster_uuids = None\n\n\ndef galaxy_update_local_copy(force=False):\n    import io\n    import json\n    import os\n    import requests\n    from zipfile import ZipFile\n\n    # some aging and automatic re-downloading\n    if not os.path.exists(local_path_uuid_mapping):\n        force = True\n    else:\n        # force update if cache is older than 24 hours\n        if time.time() - os.path.getmtime(local_path_uuid_mapping) > 60 * 60 * 24:\n            force = True\n\n    if force:\n        # create a lock to prevent two processes doing the same, and writing to the file at the same time\n        lockfile = local_path_uuid_mapping + '.lock'\n        from pathlib import Path\n        while os.path.exists(lockfile):\n            time.sleep(0.3)\n        Path(local_path_uuid_mapping + '.lock').touch()\n        # download the latest zip of the public galaxy\n        try:\n            resp = requests.get(galaxy_archive_url)\n            zf = ZipFile(io.BytesIO(resp.content))\n            zf.extractall(local_path_root)\n            zf.close()\n        except Exception:\n            raise(MaltegoException(\"ERROR: Could not download Galaxy data from htts://github.com/MISP/MISP-galaxy/. Please check internet connectivity.\"))\n\n        # generate the uuid mapping and save it to a file\n        galaxies_fnames = []\n        for f in os.listdir(local_path_clusters):\n            if '.json' in f:\n                galaxies_fnames.append(f)\n        galaxies_fnames.sort()\n\n        cluster_uuids = {}\n        for galaxy_fname in galaxies_fnames:\n            try:\n                fullPathClusters = os.path.join(local_path_clusters, galaxy_fname)\n                with open(fullPathClusters) as fp:\n                    galaxy = json.load(fp)\n                with open(fullPathClusters.replace('clusters', 'galaxies')) as fg:\n                    galaxy_main = json.load(fg)\n                for cluster in galaxy['values']:\n                    if 'uuid' not in cluster:\n                        continue\n                    # skip deprecated galaxies/clusters\n                    if galaxy_main['namespace'] == 'deprecated':\n                        continue\n                    # keep track of the cluster, but also enhance it to look like the cluster we receive when accessing the web.\n                    cluster_uuids[cluster['uuid']] = cluster\n                    cluster_uuids[cluster['uuid']]['type'] = galaxy['type']\n                    cluster_uuids[cluster['uuid']]['tag_name'] = 'misp-galaxy:{}=\"{}\"'.format(galaxy['type'], cluster['value'])\n                    if 'icon' in galaxy_main:\n                        cluster_uuids[cluster['uuid']]['icon'] = galaxy_main['icon']\n            except Exception:\n                # we ignore incorrect galaxies\n                pass\n\n        with open(local_path_uuid_mapping, 'w') as f:\n            json.dump(cluster_uuids, f)\n        # remove the lock\n        os.remove(lockfile)\n\n\ndef galaxy_load_cluster_mapping():\n    galaxy_update_local_copy()\n    with open(local_path_uuid_mapping, 'r') as f:\n        cluster_uuids = json.load(f)\n    return cluster_uuids\n\n\ndef get_galaxy_cluster(uuid=None, tag=None, request_entity=None):\n    global galaxy_cluster_uuids\n    if not galaxy_cluster_uuids:\n        galaxy_cluster_uuids = galaxy_load_cluster_mapping()\n\n    if uuid:\n        return galaxy_cluster_uuids.get(uuid)\n    if tag:\n        for item in galaxy_cluster_uuids.values():\n            if item['tag_name'] == tag:\n                return item\n    if request_entity:\n        if request_entity.uuid:\n            return get_galaxy_cluster(uuid=request_entity.uuid)\n        elif request_entity.tag_name:\n            return get_galaxy_cluster(tag=request_entity.tag_name)\n        elif request_entity.name:\n            return get_galaxy_cluster(tag=request_entity.name)\n\n\ndef search_galaxy_cluster(keyword):\n    keyword = keyword.lower()\n    global galaxy_cluster_uuids\n    if not galaxy_cluster_uuids:\n        galaxy_cluster_uuids = galaxy_load_cluster_mapping()\n\n    # % only at start\n    if keyword.startswith('%') and not keyword.endswith('%'):\n        keyword = keyword.strip('%')\n        for item in galaxy_cluster_uuids.values():\n            if item['value'].lower().endswith(keyword):\n                yield item\n            else:\n                if 'meta' in item and 'synonyms' in item['meta']:\n                    for synonym in item['meta']['synonyms']:\n                        if synonym.lower().endswith(keyword):\n                            yield item\n\n    # % only at end\n    elif keyword.endswith('%') and not keyword.startswith('%'):\n        keyword = keyword.strip('%')\n        for item in galaxy_cluster_uuids.values():\n            if item['value'].lower().startswith(keyword):\n                yield item\n            else:\n                if 'meta' in item and 'synonyms' in item['meta']:\n                    for synonym in item['meta']['synonyms']:\n                        if synonym.lower().startswith(keyword):\n                            yield item\n\n    # search substring assuming % at start and end\n    else:\n        keyword = keyword.strip('%')\n        for item in galaxy_cluster_uuids.values():\n            if keyword in item['value'].lower():\n                yield item\n            else:\n                if 'meta' in item and 'synonyms' in item['meta']:\n                    for synonym in item['meta']['synonyms']:\n                        if keyword in synonym.lower():\n                            yield item\n\n\ndef get_galaxies_relating(uuid):\n    global galaxy_cluster_uuids\n    if not galaxy_cluster_uuids:\n        galaxy_cluster_uuids = galaxy_load_cluster_mapping()\n\n    for item in galaxy_cluster_uuids.values():\n        if 'related' in item:\n            for related in item['related']:\n                if related['dest-uuid'] == uuid:\n                    yield item\n", "from canari.maltego.entities import Hashtag\nfrom canari.maltego.transform import Transform\nfrom MISP_maltego.transforms.common.entities import MISPEvent, MISPObject\nfrom MISP_maltego.transforms.common.util import check_update, get_misp_connection, attribute_to_entity, event_to_entity, galaxycluster_to_entity, object_to_entity, object_to_attributes, object_to_relations, tag_matches_note_prefix\nfrom canari.maltego.message import LinkStyle\n\n\n__author__ = 'Christophe Vandeplas'\n__copyright__ = 'Copyright 2018, MISP_maltego Project'\n__credits__ = []\n\n__license__ = 'AGPLv3'\n__version__ = '0.1'\n__maintainer__ = 'Christophe Vandeplas'\n__email__ = 'christophe@vandeplas.com'\n__status__ = 'Development'\n\n# FIXME have a more human readable version of the MISP event value in the graph. change entity + event_to_entity + do_transform\n\n\nclass EventToTransform(Transform):\n    input_type = None\n    \"\"\"Generic EventTo class containing multiple reusable functions for the subclasses.\"\"\"\n\n    def __init__(self):\n        self.request = None\n        self.response = None\n        self.config = None\n        self.misp = None\n        self.event_json = None\n        self.event_tags = None\n\n    def do_transform(self, request, response, config):\n        self.request = request\n        self.response = response\n        self.config = config\n        self.response += check_update(config)\n        maltego_misp_event = request.entity\n        self.misp = get_misp_connection(config, request.parameters)\n        event_id = maltego_misp_event.id\n        search_result = self.misp.search(controller='events', eventid=event_id, with_attachments=False)\n        if search_result:\n            self.event_json = search_result.pop()\n        else:\n            return False\n\n        self.response += event_to_entity(self.event_json)\n        return True\n\n    def gen_response_tags(self, gen_response=True):\n        self.event_tags = []\n        if 'Tag' in self.event_json['Event']:\n            for t in self.event_json['Event']['Tag']:\n                self.event_tags.append(t['name'])\n                # ignore all misp-galaxies\n                if t['name'].startswith('misp-galaxy'):\n                    continue\n                # ignore all those we add as notes\n                if tag_matches_note_prefix(t['name']):\n                    continue\n                if gen_response:\n                    self.response += Hashtag(t['name'])\n\n    def gen_response_galaxies(self):\n        for g in self.event_json['Event']['Galaxy']:\n            for c in g['GalaxyCluster']:\n                self.response += galaxycluster_to_entity(c)\n\n    def gen_response_attributes(self):\n        if not self.event_tags:\n            self.gen_response_tags(gen_response=False)\n        for a in self.event_json['Event'][\"Attribute\"]:\n            for entity in attribute_to_entity(a, event_tags=self.event_tags):\n                if entity:\n                    self.response += entity\n\n    def gen_response_objects(self):\n        for o in self.event_json['Event']['Object']:\n            self.response += object_to_entity(o)\n\n    def gen_response_relations(self):\n        for e in self.event_json['Event']['RelatedEvent']:\n            self.response += event_to_entity(e, link_style=LinkStyle.DashDot)\n\n\nclass EventToAll(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Attributes, Objects, Tags, Galaxies'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_tags()\n            self.gen_response_galaxies()\n            self.gen_response_attributes()\n            self.gen_response_objects()\n\n        return self.response\n\n\nclass EventToAttributes(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Attributes'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_attributes()\n            self.gen_response_objects()\n\n        return self.response\n\n\nclass EventToTags(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Tags and Galaxies'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_tags()\n            self.gen_response_galaxies()\n\n        return self.response\n\n\nclass EventToGalaxies(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Galaxies'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_galaxies()\n\n        return self.response\n\n\nclass EventToObjects(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Objects'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_objects()\n\n        return self.response\n\n\nclass EventToRelations(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to related Events'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_relations()\n\n        return self.response\n\n\nclass ObjectToAttributes(Transform):\n    \"\"\"\"Expands an object to its attributes\"\"\"\n    input_type = MISPObject\n    description = 'Expands an Object to Attributes'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        maltego_object = request.entity\n        misp = get_misp_connection(config, request.parameters)\n        event_json = misp.get_event(maltego_object.event_id)\n        for o in event_json['Event']['Object']:\n            if o['uuid'] == maltego_object.uuid:\n                for entity in object_to_attributes(o, event_json):\n                    if entity:\n                        response += entity\n                for entity in object_to_relations(o, event_json):\n                    if entity:\n                        response += entity\n\n        return response\n\n\nclass ObjectToRelations(Transform):\n    \"\"\"Expands an object to the relations of the object\"\"\"\n    input_type = MISPObject\n    description = 'Expands an Object to Relations'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        maltego_object = request.entity\n        misp = get_misp_connection(config, request.parameters)\n        event_json = misp.get_event(maltego_object.event_id)\n        for o in event_json['Event']['Object']:\n            if o['uuid'] == maltego_object.uuid:\n                for entity in object_to_relations(o, event_json):\n                    if entity:\n                        response += entity\n\n        return response\n", "from canari.maltego.transform import Transform\nfrom MISP_maltego.transforms.common.entities import MISPEvent, MISPGalaxy, ThreatActor, Software, AttackTechnique\nfrom MISP_maltego.transforms.common.util import check_update, get_misp_connection, galaxycluster_to_entity, get_galaxy_cluster, get_galaxies_relating, search_galaxy_cluster, mapping_galaxy_icon\nfrom canari.maltego.message import UIMessageType, UIMessage, LinkDirection\n\n\n__author__ = 'Christophe Vandeplas'\n__copyright__ = 'Copyright 2018, MISP_maltego Project'\n__credits__ = []\n\n__license__ = 'AGPLv3'\n__version__ = '0.1'\n__maintainer__ = 'Christophe Vandeplas'\n__email__ = 'christophe@vandeplas.com'\n__status__ = 'Development'\n\n\nclass GalaxyToEvents(Transform):\n    \"\"\"Expands a Galaxy to multiple MISP Events.\"\"\"\n\n    # The transform input entity type.\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        misp = get_misp_connection(config, request.parameters)\n        if request.entity.tag_name:\n            tag_name = request.entity.tag_name\n        else:\n            tag_name = request.entity.value\n        events_json = misp.search(controller='events', tags=tag_name, with_attachments=False)\n        for e in events_json:\n            response += MISPEvent(e['Event']['id'], uuid=e['Event']['uuid'], info=e['Event']['info'], link_direction=LinkDirection.OutputToInput)\n        return response\n\n\nclass GalaxyToTransform(Transform):\n    input_type = None\n\n    def do_transform(self, request, response, config, type_filter=MISPGalaxy):\n        response += check_update(config)\n\n        current_cluster = get_galaxy_cluster(request_entity=request.entity)\n\n        # legacy - replaced by Search in MISP\n        if not current_cluster and request.entity.name != '-':\n            # maybe the user is searching for a cluster based on a substring.\n            # Search in the list for those that match and return galaxy entities\n            potential_clusters = search_galaxy_cluster(request.entity.name)\n            if potential_clusters:\n                for potential_cluster in potential_clusters:\n                    new_entity = galaxycluster_to_entity(potential_cluster, link_label='Search result')\n                    if isinstance(new_entity, type_filter):\n                        response += new_entity\n                return response\n        # end of legacy\n\n        if not current_cluster:\n            response += UIMessage(\"Galaxy Cluster UUID not in local mapping. Please update local cache; non-public UUID are not supported yet.\", type=UIMessageType.Inform)\n            return response\n        c = current_cluster\n\n        # update existing object\n        galaxy_cluster = get_galaxy_cluster(uuid=c['uuid'])\n        icon_url = None\n        if 'icon' in galaxy_cluster:  # map the 'icon' name from the cluster to the icon filename of the intelligence-icons repository\n            try:\n                icon_url = mapping_galaxy_icon[galaxy_cluster['icon']]\n            except Exception:\n                # it's not in our mapping, just ignore and leave the default Galaxy icon\n                pass\n        if c['meta'].get('synonyms'):\n            synonyms = ', '.join(c['meta']['synonyms'])\n        else:\n            synonyms = ''\n        request.entity.name = '{}\\n{}'.format(c['type'], c['value'])\n        request.entity.uuid = c['uuid']\n        request.entity.description = c.get('description')\n        request.entity.cluster_type = c.get('type')\n        request.entity.cluster_value = c.get('value')\n        request.entity.synonyms = synonyms\n        request.entity.tag_name = c['tag_name']\n        request.entity.icon_url = icon_url\n        # response += request.entity\n\n        # find related objects\n        if 'related' in current_cluster:\n            for related in current_cluster['related']:\n                related_cluster = get_galaxy_cluster(uuid=related['dest-uuid'])\n                if related_cluster:\n                    new_entity = galaxycluster_to_entity(related_cluster, link_label=related['type'])\n                    if isinstance(new_entity, type_filter):\n                        response += new_entity\n        # find objects that are relating to this one\n        for related in get_galaxies_relating(current_cluster['uuid']):\n            related_link_label = ''\n            for rel_in_rel in related['related']:\n                if rel_in_rel['dest-uuid'] == current_cluster['uuid']:\n                    related_link_label = rel_in_rel['type']\n                    break\n            new_entity = galaxycluster_to_entity(related, link_label=related_link_label, link_direction=LinkDirection.OutputToInput)\n            if isinstance(new_entity, type_filter):\n                response += new_entity\n        return response\n\n\nclass GalaxyToRelations(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related Galaxies and Clusters\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=MISPGalaxy):\n        return super().do_transform(request, response, config, type_filter)\n\n\nclass GalaxyToSoftware(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related Software/Tool Galaxies\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=Software):\n        return super().do_transform(request, response, config, type_filter)\n\n\nclass GalaxyToThreatActor(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related ThreatActor Galaxies\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=ThreatActor):\n        return super().do_transform(request, response, config, type_filter)\n\n\nclass GalaxyToAttackTechnique(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related Attack Techniques Galaxies\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=AttackTechnique):\n        return super().do_transform(request, response, config, type_filter)\n"], "fixing_code": ["from canari.maltego.entities import Unknown, Hashtag\nfrom canari.maltego.transform import Transform\nfrom MISP_maltego.transforms.common.entities import MISPGalaxy\nfrom MISP_maltego.transforms.common.util import check_update, MISPConnection, event_to_entity, get_attribute_in_event, get_attribute_in_object, attribute_to_entity, get_entity_property, search_galaxy_cluster, galaxycluster_to_entity\nfrom canari.maltego.message import LinkDirection, Bookmark\n\n__author__ = 'Christophe Vandeplas'\n__copyright__ = 'Copyright 2018, MISP_maltego Project'\n__credits__ = []\n\n__license__ = 'AGPLv3'\n__version__ = '0.1'\n__maintainer__ = 'Christophe Vandeplas'\n__email__ = 'christophe@vandeplas.com'\n__status__ = 'Development'\n\n\nclass SearchInMISP(Transform):\n    \"\"\"Search an attribute, event in MISP, allowing the use of % at the front and end\"\"\"\n    input_type = Unknown\n    display_name = 'Search in MISP'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        link_label = 'Search result'\n\n        if 'properties.mispevent' in request.entity.fields:\n            conn = MISPConnection(config, request.parameters)\n            # if event_id\n            try:\n                if request.entity.value == '0':\n                    return response\n                eventid = int(request.entity.value)\n                events_json = conn.misp.search(controller='events', eventid=eventid, with_attachments=False)\n                for e in events_json:\n                    response += event_to_entity(e, link_label=link_label, link_direction=LinkDirection.OutputToInput)\n                return response\n            except ValueError:\n                pass\n            # if event_info string as value\n            events_json = conn.misp.search(controller='events', eventinfo=request.entity.value, with_attachments=False)\n            for e in events_json:\n                response += event_to_entity(e, link_label=link_label, link_direction=LinkDirection.OutputToInput)\n            return response\n\n        # From galaxy or Hashtag\n        if 'properties.mispgalaxy' in request.entity.fields or 'properties.temp' in request.entity.fields:\n            if request.entity.value == '-':\n                return response\n            # First search in galaxies\n            keyword = get_entity_property(request.entity, 'Temp')\n            if not keyword:\n                keyword = request.entity.value\n            # assume the user is searching for a cluster based on a substring.\n            # Search in the list for those that match and return galaxy entities'\n            potential_clusters = search_galaxy_cluster(keyword)\n            # LATER check if duplicates are possible\n            if potential_clusters:\n                for potential_cluster in potential_clusters:\n                    new_entity = galaxycluster_to_entity(potential_cluster, link_label=link_label)\n                    # LATER support the type_filter - unfortunately this is not possible, we need Canari to tell us the original entity type\n                    if isinstance(new_entity, MISPGalaxy):\n                        response += new_entity\n\n            # from Hashtag search also in tags\n            if 'properties.temp' in request.entity.fields:\n                keyword = get_entity_property(request.entity, 'Temp')\n                if not keyword:\n                    keyword = request.entity.value\n                conn = MISPConnection(config, request.parameters)\n                result = conn.misp.direct_call('tags/search', {'name': keyword})\n                for t in result:\n                    # skip misp-galaxies as we have processed them earlier on\n                    if t['Tag']['name'].startswith('misp-galaxy'):\n                        continue\n                    # In this case we do not filter away those we add as notes, as people might want to pivot on it explicitly.\n                    response += Hashtag(t['Tag']['name'], link_label=link_label, bookmark=Bookmark.Green)\n\n            return response\n\n        # for all other normal entities\n        conn = MISPConnection(config, request.parameters)\n        events_json = conn.misp.search(controller='events', value=request.entity.value, with_attachments=False)\n        # we need to do really rebuild the Entity from scratch as request.entity is of type Unknown\n        for e in events_json:\n            # find the value as attribute\n            attr = get_attribute_in_event(e, request.entity.value, substring=True)\n            if attr:\n                for item in attribute_to_entity(attr, only_self=True):\n                    response += item\n            # find the value as object, and return the object\n            if 'Object' in e['Event']:\n                for o in e['Event']['Object']:\n                    if get_attribute_in_object(o, attribute_value=request.entity.value, substring=True).get('value'):\n                        response += conn.object_to_entity(o, link_label=link_label)\n\n        return response\n\n# placeholder for https://github.com/MISP/MISP-maltego/issues/11\n# waiting for support of CIDR search through the REST API\n# @EnableDebugWindow\n# class NetblockToAttributes(Transform):\n#     display_name = 'to MISP Attributes'\n#     input_type = Netblock\n#     remote = True\n\n#     def do_transform(self, request, response, config):\n#         maltego_misp_attribute = request.entity\n#         misp = get_misp_connection(config, request.parameters)\n#         import ipaddress\n#         ip_start, ip_end = maltego_misp_attribute.value.split('-')\n#         # LATER make this work with IPv4 and IPv6\n#         # automagically detect the different CIDRs\n#         cidrs = ipaddress.summarize_address_range(ipaddress.IPv4Address(ip_start), ipaddress.IPv4Address(ip_end))\n#         for cidr in cidrs:\n#             print(str(cidr))\n#             attr_json = misp.search(controller='attributes', value=str(cidr), with_attachments=False)\n#             print(attr_json)\n#         return response\n\n\nclass AttributeToEvent(Transform):\n    input_type = Unknown\n    display_name = 'to MISP Event'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        # skip some Entities\n        skip = ['properties.mispevent']\n        for i in skip:\n            if i in request.entity.fields:\n                return response\n\n        if 'ipv4-range' in request.entity.fields:\n            # placeholder for https://github.com/MISP/MISP-maltego/issues/11\n            pass\n\n        conn = MISPConnection(config, request.parameters)\n        # from Galaxy\n        if 'properties.mispgalaxy' in request.entity.fields:\n            tag_name = get_entity_property(request.entity, 'tag_name')\n            if not tag_name:\n                tag_name = request.entity.value\n            events_json = conn.misp.search(controller='events', tags=tag_name, with_attachments=False)\n            for e in events_json:\n                response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n            return response\n        # from Object\n        elif 'properties.mispobject' in request.entity.fields:\n            if request.entity.fields.get('event_id'):\n                events_json = conn.misp.search(controller='events', eventid=request.entity.fields.get('event_id').value, with_attachments=False)\n                for e in events_json:\n                    response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n                return response\n            else:\n                return response\n        # from Hashtag\n        elif 'properties.temp' in request.entity.fields:\n            tag_name = get_entity_property(request.entity, 'Temp')\n            if not tag_name:\n                tag_name = request.entity.value\n            events_json = conn.misp.search(controller='events', tags=tag_name, with_attachments=False)\n            for e in events_json:\n                response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n            return response\n        # standard Entities (normal attributes)\n        else:\n            events_json = conn.misp.search(controller='events', value=request.entity.value, with_attachments=False)\n\n        # return the MISPEvent or MISPObject of the attribute\n        for e in events_json:\n            # find the value as attribute\n            attr = get_attribute_in_event(e, request.entity.value)\n            if attr:\n                response += event_to_entity(e, link_direction=LinkDirection.OutputToInput)\n            # find the value as object\n            if 'Object' in e['Event']:\n                for o in e['Event']['Object']:\n                    if get_attribute_in_object(o, attribute_value=request.entity.value).get('value'):\n                        response += conn.object_to_entity(o, link_direction=LinkDirection.OutputToInput)\n\n        return response\n", "from canari.maltego.entities import Hash, URL, File, Person, Hashtag\nfrom canari.maltego.message import Label, LinkStyle, MaltegoException, Bookmark, LinkDirection, UIMessage, UIMessageType\nfrom canari.mode import is_local_exec_mode, is_remote_exec_mode\nfrom distutils.version import StrictVersion\nfrom MISP_maltego.transforms.common.entities import MISPEvent, MISPObject, MISPGalaxy\nfrom MISP_maltego.transforms.common.mappings import mapping_object_icon, mapping_misp_to_maltego, mapping_galaxy_icon, mapping_galaxy_type\nfrom pymisp import ExpandedPyMISP as PyMISP\nimport json\nimport os\nimport os.path\nimport requests\nimport tempfile\nimport time\n\n# FIXME from galaxy 'to MISP Event' is confusing\n\n__version__ = '1.4.4'  # also update version in setup.py\n\ntag_note_prefixes = ['tlp:', 'PAP:', 'de-vs:', 'euci:', 'fr-classif:', 'nato:']\n\nupdate_url = 'https://raw.githubusercontent.com/MISP/MISP-maltego/master/setup.py'\nlocal_path_root = os.path.join(tempfile.gettempdir(), 'MISP-maltego')\nlocal_path_version = os.path.join(local_path_root, 'versioncheck')\nif not os.path.exists(local_path_root):\n    os.mkdir(local_path_root)\n    os.chmod(local_path_root, mode=0o777)  # temporary workaround - see https://github.com/redcanari/canari3/issues/61\n\n\ndef check_update(config):\n    # Do not check updates if running as remote transform\n    if is_remote_exec_mode():\n        return None\n    # only raise the alert once a day/reboot to the user.\n    try:\n        if time.time() - os.path.getmtime(local_path_version) > 60 * 60 * 24:  # check the timestamp of the file\n            recheck = True\n        else:\n            recheck = False\n    except Exception:  # file does not exist, so check version\n        recheck = True\n    if not recheck:\n        return None\n    # remember we checked the version\n    from pathlib import Path\n    Path(local_path_version).touch()\n    # UIMessageType must be Fatal as otherwise it is not shown to the user.\n    if 'MISP_maltego.local.check_updates' not in config:\n        return UIMessage(\"'check_updates' parameter missing in '.canari/MISP_maltego.conf'. Please set 'check_updates = True/False'.\", type=UIMessageType.Fatal)\n    if config['MISP_maltego.local.check_updates']:\n        # check the version\n        r = requests.get(update_url)\n        for l in r.text.splitlines():\n            if 'version=' in l:\n                online_ver = l.strip().strip(',').split('=').pop().strip(\"'\")\n                if StrictVersion(online_ver) > StrictVersion(__version__):\n                    message = ('A new version of MISP-Maltego is available.\\n'\n                               'To upgrade, please:\\n'\n                               '    pip3 --upgrade MISP-maltego'\n                               '    canari create-profile MISP_maltego\\n'\n                               '    And import the newly generated .mtz bundle in Maltego (Import > Import Configuration)')\n                    return UIMessage(message, type=UIMessageType.Fatal)\n                break\n    return None\n\n\nclass MISPConnection():\n    def __init__(self, config=None, parameters=None):\n        self.misp = None\n\n        if not config:\n            raise MaltegoException(\"ERROR: MISP connection not yet established, and config not provided as parameter.\")\n        misp_verify = True\n        misp_debug = False\n        misp_url = None\n        misp_key = None\n        try:\n            if is_local_exec_mode():\n                misp_url = config['MISP_maltego.local.misp_url']\n                misp_key = config['MISP_maltego.local.misp_key']\n                if config['MISP_maltego.local.misp_verify'] in ['False', 'false', 0, 'no', 'No']:\n                    misp_verify = False\n                if config['MISP_maltego.local.misp_debug'] in ['True', 'true', 1, 'yes', 'Yes']:\n                    misp_debug = True\n            else:\n                try:\n                    misp_url = parameters['mispurl'].value\n                    misp_key = parameters['mispkey'].value\n                except AttributeError:\n                    raise MaltegoException(\"ERROR: mispurl and mispkey need to be set to something valid\")\n            self.misp = PyMISP(misp_url, misp_key, misp_verify, 'json', misp_debug, tool='misp_maltego')\n        except Exception:\n            if is_local_exec_mode():\n                raise MaltegoException(\"ERROR: Cannot connect to MISP server. Please verify your MISP_Maltego.conf settings.\")\n            else:\n                raise MaltegoException(\"ERROR: Cannot connect to MISP server. Please verify your settings (MISP URL and API key), and ensure the MISP server is reachable from the internet.\")\n\n    def object_to_entity(self, o, link_label=None, link_direction=LinkDirection.InputToOutput):\n        # find a nice icon for it\n        try:\n            icon_url = mapping_object_icon[o['name']]\n        except KeyError:\n            # it's not in our mapping, just ignore and leave the default icon\n            icon_url = None\n        # Generate a human readable display-name:\n        # - find the first RequiredOneOf that exists\n        # - if none, use the first RequiredField\n        # LATER further finetune the human readable version of this object\n        o_template = self.misp.get_object_template(o['template_uuid'])\n        human_readable = None\n        try:\n            found = False\n            while not found:  # the while loop is broken once something is found, or the requiredOneOf has no elements left\n                required_ote_type = o_template['ObjectTemplate']['requirements']['requiredOneOf'].pop(0)\n                for ote in o_template['ObjectTemplateElement']:\n                    if ote['object_relation'] == required_ote_type:\n                        required_a_type = ote['type']\n                        break\n                for a in o['Attribute']:\n                    if a['type'] == required_a_type:\n                        human_readable = '{}:\\n{}'.format(o['name'], a['value'])\n                        found = True\n                        break\n        except Exception:\n            pass\n        if not human_readable:\n            try:\n                found = False\n                parts = []\n                for required_ote_type in o_template['ObjectTemplate']['requirements']['required']:\n                    for ote in o_template['ObjectTemplateElement']:\n                        if ote['object_relation'] == required_ote_type:\n                            required_a_type = ote['type']\n                            break\n                    for a in o['Attribute']:\n                        if a['type'] == required_a_type:\n                            parts.append(a['value'])\n                            break\n                human_readable = '{}:\\n{}'.format(o['name'], '|'.join(parts))\n            except Exception:\n                human_readable = o['name']\n        return MISPObject(\n            human_readable,\n            uuid=o['uuid'],\n            event_id=int(o['event_id']),\n            meta_category=o.get('meta_category'),\n            description=o.get('description'),\n            comment=o.get('comment'),\n            icon_url=icon_url,\n            link_label=link_label,\n            link_direction=link_direction,\n            bookmark=Bookmark.Green\n        )\n\n    def object_to_relations(self, o, e):\n        # process forward and reverse references, so just loop over all the objects of the event\n        if 'Object' in e['Event']:\n            for eo in e['Event']['Object']:\n                if 'ObjectReference' in eo:\n                    for ref in eo['ObjectReference']:\n                        # we have found original object. Expand to the related object and attributes\n                        if eo['uuid'] == o['uuid']:\n                            # the reference is an Object\n                            if ref.get('Object'):\n                                # get the full object in the event, as our objectReference included does not contain everything we need\n                                sub_object = get_object_in_event(ref['Object']['uuid'], e)\n                                yield self.object_to_entity(sub_object, link_label=ref['relationship_type'])\n                            # the reference is an Attribute\n                            if ref.get('Attribute'):\n                                ref['Attribute']['event_id'] = ref['event_id']   # LATER remove this ugly workaround - object can't be requested directly from MISP using the uuid, and to find a full object we need the event_id\n                                for item in attribute_to_entity(ref['Attribute'], link_label=ref['relationship_type']):\n                                    yield item\n\n                        # reverse-lookup - this is another objects relating the original object\n                        if ref['referenced_uuid'] == o['uuid']:\n                            yield self.object_to_entity(eo, link_label=ref['relationship_type'], link_direction=LinkDirection.OutputToInput)\n\n\ndef entity_obj_to_entity(entity_obj, v, t, **kwargs):\n    if entity_obj == Hash:\n        return entity_obj(v, _type=t, **kwargs)  # LATER type is conflicting with type of Entity, Report this as bug see line 326 /usr/local/lib/python3.5/dist-packages/canari/maltego/entities.py\n\n    return entity_obj(v, **kwargs)\n\n\ndef get_entity_property(entity, name):\n    for k, v in entity.fields.items():\n        if k == name:\n            return v.value\n    return None\n\n\ndef attribute_to_entity(a, link_label=None, event_tags=[], only_self=False):\n    # prepare some attributes to a better form\n    a['data'] = None  # empty the file content as we really don't need this here\n    if a['type'] == 'malware-sample':\n        a['type'] = 'filename|md5'\n    if a['type'] == 'regkey|value':  # LATER regkey|value => needs to be a special non-combined object\n        a['type'] = 'regkey'\n\n    combined_tags = event_tags\n    if 'Galaxy' in a and not only_self:\n        for g in a['Galaxy']:\n            for c in g['GalaxyCluster']:\n                yield galaxycluster_to_entity(c)\n\n    # complement the event tags with the attribute tags.\n    if 'Tag' in a and not only_self:\n            for t in a['Tag']:\n                combined_tags.append(t['name'])\n                # ignore all misp-galaxies\n                if t['name'].startswith('misp-galaxy'):\n                    continue\n                # ignore all those we add as notes\n                if tag_matches_note_prefix(t['name']):\n                    continue\n                yield Hashtag(t['name'], bookmark=Bookmark.Green)\n\n    notes = convert_tags_to_note(combined_tags)\n\n    # special cases\n    if a['type'] in ('url', 'uri'):\n        yield(URL(url=a['value'], short_title=a['value'], link_label=link_label, notes=notes, bookmark=Bookmark.Green))\n        return\n\n    # attribute is from an object, and a relation gives better understanding of the type of attribute\n    if a.get('object_relation') and mapping_misp_to_maltego.get(a['object_relation']):\n        entity_obj = mapping_misp_to_maltego[a['object_relation']][0]\n        yield entity_obj(a['value'], labels=[Label('comment', a.get('comment'))], link_label=link_label, notes=notes, bookmark=Bookmark.Green)\n\n    # combined attributes\n    elif '|' in a['type']:\n        t_1, t_2 = a['type'].split('|')\n        v_1, v_2 = a['value'].split('|')\n        if t_1 in mapping_misp_to_maltego:\n            entity_obj = mapping_misp_to_maltego[t_1][0]\n            labels = [Label('comment', a.get('comment'))]\n            if entity_obj == File:\n                labels.append(Label('hash', v_2))\n            yield entity_obj_to_entity(entity_obj, v_1, t_1, labels=labels, link_label=link_label, notes=notes, bookmark=Bookmark.Green)  # LATER change the comment to include the second part of the regkey\n        if t_2 in mapping_misp_to_maltego:\n            entity_obj = mapping_misp_to_maltego[t_2][0]\n            labels = [Label('comment', a.get('comment'))]\n            if entity_obj == Hash:\n                labels.append(Label('filename', v_1))\n            yield entity_obj_to_entity(entity_obj, v_2, t_2, labels=labels, link_label=link_label, notes=notes, bookmark=Bookmark.Green)  # LATER change the comment to include the first part of the regkey\n\n    # normal attributes\n    elif a['type'] in mapping_misp_to_maltego:\n        entity_obj = mapping_misp_to_maltego[a['type']][0]\n        yield entity_obj_to_entity(entity_obj, a['value'], a['type'], labels=[Label('comment', a.get('comment'))], link_label=link_label, notes=notes, bookmark=Bookmark.Green)\n\n    # not supported in our maltego mapping are not handled\n\n    # LATER : relationships from attributes - not yet supported by MISP yet, but there are references in the datamodel\n\n\ndef object_to_attributes(o, e):\n    # first process attributes from an object that belong together (eg: first-name + last-name), and remove them from the list\n    if o['name'] == 'person':\n        first_name = get_attribute_in_object(o, attribute_type='first-name', drop=True).get('value')\n        last_name = get_attribute_in_object(o, attribute_type='last-name', drop=True).get('value')\n        yield entity_obj_to_entity(Person, ' '.join([first_name, last_name]).strip(), 'person', lastname=last_name, firstnames=first_name, bookmark=Bookmark.Green)\n\n    # process normal attributes\n    for a in o['Attribute']:\n        for item in attribute_to_entity(a):\n            yield item\n\n\ndef get_object_in_event(uuid, e):\n    for o in e['Event']['Object']:\n        if o['uuid'] == uuid:\n            return o\n\n\ndef get_attribute_in_object(o, attribute_type=False, attribute_value=False, drop=False, substring=False):\n    '''Gets the first attribute of a specific type within an object'''\n    found_attribute = {'value': ''}\n    for i, a in enumerate(o['Attribute']):\n        if a['type'] == attribute_type:\n            found_attribute = a.copy()\n            if drop:    # drop the attribute from the object\n                o['Attribute'].pop(i)\n            break\n        if a['value'] == attribute_value:\n            found_attribute = a.copy()\n            if drop:    # drop the attribute from the object\n                o['Attribute'].pop(i)\n            break\n        if '|' in a['type'] or a['type'] == 'malware-sample':\n            if attribute_value in a['value'].split('|'):\n                found_attribute = a.copy()\n                if drop:    # drop the attribute from the object\n                    o['Attribute'].pop(i)\n                break\n        # TODO implement substring matching\n        if substring:\n            keyword = attribute_value.strip('%')\n            if attribute_value.startswith('%') and attribute_value.endswith('%'):\n                if attribute_value in a['value']:\n                    found_attribute = a.copy()\n                    if drop:    # drop the attribute from the object\n                        o['Attribute'].pop(i)\n                    break\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if attribute_value in val1 or attribute_value in val2:\n                        found_attribute = a.copy()\n                        if drop:    # drop the attribute from the object\n                            o['Attribute'].pop(i)\n                        break\n            elif attribute_value.startswith('%'):\n                if a['value'].endswith(keyword):\n                    found_attribute = a.copy()\n                    if drop:    # drop the attribute from the object\n                        o['Attribute'].pop(i)\n                    break\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.endswith(keyword) or val2.endswith(keyword):\n                        found_attribute = a.copy()\n                        if drop:    # drop the attribute from the object\n                            o['Attribute'].pop(i)\n                        break\n\n            elif attribute_value.endswith('%'):\n                if a['value'].startswith(keyword):\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.startswith(keyword) or val2.startswith(keyword):\n                        found_attribute = a.copy()\n                        if drop:    # drop the attribute from the object\n                            o['Attribute'].pop(i)\n                        break\n    return found_attribute\n\n\ndef get_attribute_in_event(e, attribute_value, substring=False):\n    for a in e['Event'][\"Attribute\"]:\n        if a['value'] == attribute_value:\n            return a\n        if '|' in a['type'] or a['type'] == 'malware-sample':\n            if attribute_value in a['value'].split('|'):\n                return a\n        if substring:\n            keyword = attribute_value.strip('%')\n            if attribute_value.startswith('%') and attribute_value.endswith('%'):\n                if attribute_value in a['value']:\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if attribute_value in val1 or attribute_value in val2:\n                        return a\n            elif attribute_value.startswith('%'):\n                if a['value'].endswith(keyword):\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.endswith(keyword) or val2.endswith(keyword):\n                        return a\n\n            elif attribute_value.endswith('%'):\n                if a['value'].startswith(keyword):\n                    return a\n                if '|' in a['type'] or a['type'] == 'malware-sample':\n                    val1, val2 = a['value'].split('|')\n                    if val1.startswith(keyword) or val2.startswith(keyword):\n                        return a\n\n    return None\n\n\ndef convert_tags_to_note(tags):\n    if not tags:\n        return None\n    notes = []\n    for tag in tags:\n        for tag_note_prefix in tag_note_prefixes:\n            if tag.startswith(tag_note_prefix):\n                notes.append(tag)\n    return '\\n'.join(notes)\n\n\ndef tag_matches_note_prefix(tag):\n    for tag_note_prefix in tag_note_prefixes:\n        if tag.startswith(tag_note_prefix):\n            return True\n    return False\n\n\ndef event_to_entity(e, link_style=LinkStyle.Normal, link_label=None, link_direction=LinkDirection.InputToOutput):\n    tags = []\n    if 'Tag' in e['Event']:\n        for t in e['Event']['Tag']:\n            tags.append(t['name'])\n    notes = convert_tags_to_note(tags)\n    return MISPEvent(\n        e['Event']['id'],\n        uuid=e['Event']['uuid'],\n        info=e['Event']['info'],\n        link_style=link_style,\n        link_label=link_label,\n        link_direction=link_direction,\n        count_attributes=len(e['Event'].get('Attribute') or \"\"),\n        count_objects=len(e['Event'].get('Object') or \"\"),\n        notes=notes,\n        bookmark=Bookmark.Green)\n\n\ndef galaxycluster_to_entity(c, link_label=None, link_direction=LinkDirection.InputToOutput):\n    if 'meta' in c and 'uuid' in c['meta']:\n        c['uuid'] = c['meta']['uuid'].pop(0)\n\n    if 'meta' in c and 'synonyms' in c['meta']:\n        synonyms = ', '.join(c['meta']['synonyms'])\n    else:\n        synonyms = ''\n\n    galaxy_cluster = get_galaxy_cluster(uuid=c['uuid'])\n    # map the 'icon' name from the cluster to the icon filename of the intelligence-icons repository\n    try:\n        icon_url = mapping_galaxy_icon[galaxy_cluster['icon']]\n    except KeyError:\n        # it's not in our mapping, just ignore and leave the default icon\n        icon_url = None\n\n    # create the right sub-galaxy: ThreatActor, Software, AttackTechnique, ... or MISPGalaxy\n    try:\n        galaxy_type = mapping_galaxy_type[galaxy_cluster['type']]\n    except KeyError:\n        galaxy_type = MISPGalaxy\n    return galaxy_type(\n        '{}\\n{}'.format(c['type'], c['value']),\n        uuid=c['uuid'],\n        description=c.get('description'),\n        cluster_type=c.get('type'),\n        cluster_value=c.get('value'),\n        synonyms=synonyms,\n        tag_name=c['tag_name'],\n        link_label=link_label,\n        icon_url=icon_url,\n        link_direction=link_direction\n    )\n\n\n# LATER this uses the galaxies from github as the MISP web UI does not fully support the Galaxies in the webui.\n# See https://github.com/MISP/MISP/issues/3801\ngalaxy_archive_url = 'https://github.com/MISP/misp-galaxy/archive/master.zip'\nlocal_path_uuid_mapping = os.path.join(local_path_root, 'MISP_maltego_galaxy_mapping.json')\nlocal_path_clusters = os.path.join(local_path_root, 'misp-galaxy-master', 'clusters')\ngalaxy_cluster_uuids = None\n\n\ndef galaxy_update_local_copy(force=False):\n    import io\n    import json\n    import os\n    import requests\n    from zipfile import ZipFile\n\n    # some aging and automatic re-downloading\n    if not os.path.exists(local_path_uuid_mapping):\n        force = True\n    else:\n        # force update if cache is older than 24 hours\n        if time.time() - os.path.getmtime(local_path_uuid_mapping) > 60 * 60 * 24:\n            force = True\n\n    if force:\n        # create a lock to prevent two processes doing the same, and writing to the file at the same time\n        lockfile = local_path_uuid_mapping + '.lock'\n        from pathlib import Path\n        while os.path.exists(lockfile):\n            time.sleep(0.3)\n        Path(local_path_uuid_mapping + '.lock').touch()\n        # download the latest zip of the public galaxy\n        try:\n            resp = requests.get(galaxy_archive_url)\n            zf = ZipFile(io.BytesIO(resp.content))\n            zf.extractall(local_path_root)\n            zf.close()\n        except Exception:\n            raise(MaltegoException(\"ERROR: Could not download Galaxy data from htts://github.com/MISP/MISP-galaxy/. Please check internet connectivity.\"))\n\n        # generate the uuid mapping and save it to a file\n        galaxies_fnames = []\n        for f in os.listdir(local_path_clusters):\n            if '.json' in f:\n                galaxies_fnames.append(f)\n        galaxies_fnames.sort()\n\n        cluster_uuids = {}\n        for galaxy_fname in galaxies_fnames:\n            try:\n                fullPathClusters = os.path.join(local_path_clusters, galaxy_fname)\n                with open(fullPathClusters) as fp:\n                    galaxy = json.load(fp)\n                with open(fullPathClusters.replace('clusters', 'galaxies')) as fg:\n                    galaxy_main = json.load(fg)\n                for cluster in galaxy['values']:\n                    if 'uuid' not in cluster:\n                        continue\n                    # skip deprecated galaxies/clusters\n                    if galaxy_main['namespace'] == 'deprecated':\n                        continue\n                    # keep track of the cluster, but also enhance it to look like the cluster we receive when accessing the web.\n                    cluster_uuids[cluster['uuid']] = cluster\n                    cluster_uuids[cluster['uuid']]['type'] = galaxy['type']\n                    cluster_uuids[cluster['uuid']]['tag_name'] = 'misp-galaxy:{}=\"{}\"'.format(galaxy['type'], cluster['value'])\n                    if 'icon' in galaxy_main:\n                        cluster_uuids[cluster['uuid']]['icon'] = galaxy_main['icon']\n            except Exception:\n                # we ignore incorrect galaxies\n                pass\n\n        with open(local_path_uuid_mapping, 'w') as f:\n            json.dump(cluster_uuids, f)\n        # remove the lock\n        os.remove(lockfile)\n\n\ndef galaxy_load_cluster_mapping():\n    galaxy_update_local_copy()\n    with open(local_path_uuid_mapping, 'r') as f:\n        cluster_uuids = json.load(f)\n    return cluster_uuids\n\n\ndef get_galaxy_cluster(uuid=None, tag=None, request_entity=None):\n    global galaxy_cluster_uuids\n    if not galaxy_cluster_uuids:\n        galaxy_cluster_uuids = galaxy_load_cluster_mapping()\n\n    if uuid:\n        return galaxy_cluster_uuids.get(uuid)\n    if tag:\n        for item in galaxy_cluster_uuids.values():\n            if item['tag_name'] == tag:\n                return item\n    if request_entity:\n        if request_entity.uuid:\n            return get_galaxy_cluster(uuid=request_entity.uuid)\n        elif request_entity.tag_name:\n            return get_galaxy_cluster(tag=request_entity.tag_name)\n        elif request_entity.name:\n            return get_galaxy_cluster(tag=request_entity.name)\n\n\ndef search_galaxy_cluster(keyword):\n    keyword = keyword.lower()\n    global galaxy_cluster_uuids\n    if not galaxy_cluster_uuids:\n        galaxy_cluster_uuids = galaxy_load_cluster_mapping()\n\n    # % only at start\n    if keyword.startswith('%') and not keyword.endswith('%'):\n        keyword = keyword.strip('%')\n        for item in galaxy_cluster_uuids.values():\n            if item['value'].lower().endswith(keyword):\n                yield item\n            else:\n                if 'meta' in item and 'synonyms' in item['meta']:\n                    for synonym in item['meta']['synonyms']:\n                        if synonym.lower().endswith(keyword):\n                            yield item\n\n    # % only at end\n    elif keyword.endswith('%') and not keyword.startswith('%'):\n        keyword = keyword.strip('%')\n        for item in galaxy_cluster_uuids.values():\n            if item['value'].lower().startswith(keyword):\n                yield item\n            else:\n                if 'meta' in item and 'synonyms' in item['meta']:\n                    for synonym in item['meta']['synonyms']:\n                        if synonym.lower().startswith(keyword):\n                            yield item\n\n    # search substring assuming % at start and end\n    else:\n        keyword = keyword.strip('%')\n        for item in galaxy_cluster_uuids.values():\n            if keyword in item['value'].lower():\n                yield item\n            else:\n                if 'meta' in item and 'synonyms' in item['meta']:\n                    for synonym in item['meta']['synonyms']:\n                        if keyword in synonym.lower():\n                            yield item\n\n\ndef get_galaxies_relating(uuid):\n    global galaxy_cluster_uuids\n    if not galaxy_cluster_uuids:\n        galaxy_cluster_uuids = galaxy_load_cluster_mapping()\n\n    for item in galaxy_cluster_uuids.values():\n        if 'related' in item:\n            for related in item['related']:\n                if related['dest-uuid'] == uuid:\n                    yield item\n", "from canari.maltego.entities import Hashtag\nfrom canari.maltego.transform import Transform\nfrom MISP_maltego.transforms.common.entities import MISPEvent, MISPObject\nfrom MISP_maltego.transforms.common.util import check_update, MISPConnection, attribute_to_entity, event_to_entity, galaxycluster_to_entity, object_to_attributes, tag_matches_note_prefix\nfrom canari.maltego.message import LinkStyle\n\n\n__author__ = 'Christophe Vandeplas'\n__copyright__ = 'Copyright 2018, MISP_maltego Project'\n__credits__ = []\n\n__license__ = 'AGPLv3'\n__version__ = '0.1'\n__maintainer__ = 'Christophe Vandeplas'\n__email__ = 'christophe@vandeplas.com'\n__status__ = 'Development'\n\n# TODO have a more human readable version of the MISP event value in the graph. change entity + event_to_entity + do_transform\n\n\nclass EventToTransform(Transform):\n    input_type = None\n    \"\"\"Generic EventTo class containing multiple reusable functions for the subclasses.\"\"\"\n\n    def __init__(self):\n        self.request = None\n        self.response = None\n        self.config = None\n        self.conn = None\n        self.event_json = None\n        self.event_tags = None\n\n    def do_transform(self, request, response, config):\n        self.request = request\n        self.response = response\n        self.config = config\n        self.response += check_update(config)\n        maltego_misp_event = request.entity\n        self.conn = MISPConnection(config, request.parameters)\n        event_id = maltego_misp_event.id\n        search_result = self.conn.misp.search(controller='events', eventid=event_id, with_attachments=False)\n        if search_result:\n            self.event_json = search_result.pop()\n        else:\n            return False\n\n        self.response += event_to_entity(self.event_json)\n        return True\n\n    def gen_response_tags(self, gen_response=True):\n        self.event_tags = []\n        if 'Tag' in self.event_json['Event']:\n            for t in self.event_json['Event']['Tag']:\n                self.event_tags.append(t['name'])\n                # ignore all misp-galaxies\n                if t['name'].startswith('misp-galaxy'):\n                    continue\n                # ignore all those we add as notes\n                if tag_matches_note_prefix(t['name']):\n                    continue\n                if gen_response:\n                    self.response += Hashtag(t['name'])\n\n    def gen_response_galaxies(self):\n        for g in self.event_json['Event']['Galaxy']:\n            for c in g['GalaxyCluster']:\n                self.response += galaxycluster_to_entity(c)\n\n    def gen_response_attributes(self):\n        if not self.event_tags:\n            self.gen_response_tags(gen_response=False)\n        for a in self.event_json['Event'][\"Attribute\"]:\n            for entity in attribute_to_entity(a, event_tags=self.event_tags):\n                if entity:\n                    self.response += entity\n\n    def gen_response_objects(self):\n        for o in self.event_json['Event']['Object']:\n            self.response += self.conn.object_to_entity(o)\n\n    def gen_response_relations(self):\n        for e in self.event_json['Event']['RelatedEvent']:\n            self.response += event_to_entity(e, link_style=LinkStyle.DashDot)\n\n\nclass EventToAll(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Attributes, Objects, Tags, Galaxies'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_tags()\n            self.gen_response_galaxies()\n            self.gen_response_attributes()\n            self.gen_response_objects()\n\n        return self.response\n\n\nclass EventToAttributes(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Attributes'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_attributes()\n            self.gen_response_objects()\n\n        return self.response\n\n\nclass EventToTags(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Tags and Galaxies'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_tags()\n            self.gen_response_galaxies()\n\n        return self.response\n\n\nclass EventToGalaxies(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Galaxies'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_galaxies()\n\n        return self.response\n\n\nclass EventToObjects(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to Objects'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_objects()\n\n        return self.response\n\n\nclass EventToRelations(EventToTransform):\n    input_type = MISPEvent\n    description = 'Expands an Event to related Events'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        if super().do_transform(request, response, config):\n            self.gen_response_relations()\n\n        return self.response\n\n\nclass ObjectToAttributes(Transform):\n    \"\"\"\"Expands an object to its attributes\"\"\"\n    input_type = MISPObject\n    description = 'Expands an Object to Attributes'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        maltego_object = request.entity\n        conn = MISPConnection(config, request.parameters)\n        event_json = conn.misp.get_event(maltego_object.event_id)\n        for o in event_json['Event']['Object']:\n            if o['uuid'] == maltego_object.uuid:\n                for entity in object_to_attributes(o, event_json):\n                    if entity:\n                        response += entity\n                for entity in conn.object_to_relations(o, event_json):\n                    if entity:\n                        response += entity\n\n        return response\n\n\nclass ObjectToRelations(Transform):\n    \"\"\"Expands an object to the relations of the object\"\"\"\n    input_type = MISPObject\n    description = 'Expands an Object to Relations'\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        maltego_object = request.entity\n        conn = MISPConnection(config, request.parameters)\n        event_json = conn.misp.get_event(maltego_object.event_id)\n        for o in event_json['Event']['Object']:\n            if o['uuid'] == maltego_object.uuid:\n                for entity in conn.object_to_relations(o, event_json):\n                    if entity:\n                        response += entity\n\n        return response\n", "from canari.maltego.transform import Transform\nfrom MISP_maltego.transforms.common.entities import MISPEvent, MISPGalaxy, ThreatActor, Software, AttackTechnique\nfrom MISP_maltego.transforms.common.util import check_update, MISPConnection, galaxycluster_to_entity, get_galaxy_cluster, get_galaxies_relating, search_galaxy_cluster, mapping_galaxy_icon\nfrom canari.maltego.message import UIMessageType, UIMessage, LinkDirection\n\n\n__author__ = 'Christophe Vandeplas'\n__copyright__ = 'Copyright 2018, MISP_maltego Project'\n__credits__ = []\n\n__license__ = 'AGPLv3'\n__version__ = '0.1'\n__maintainer__ = 'Christophe Vandeplas'\n__email__ = 'christophe@vandeplas.com'\n__status__ = 'Development'\n\n\nclass GalaxyToEvents(Transform):\n    \"\"\"Expands a Galaxy to multiple MISP Events.\"\"\"\n\n    # The transform input entity type.\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config):\n        response += check_update(config)\n        conn = MISPConnection(config, request.parameters)\n        if request.entity.tag_name:\n            tag_name = request.entity.tag_name\n        else:\n            tag_name = request.entity.value\n        events_json = conn.misp.search(controller='events', tags=tag_name, with_attachments=False)\n        for e in events_json:\n            response += MISPEvent(e['Event']['id'], uuid=e['Event']['uuid'], info=e['Event']['info'], link_direction=LinkDirection.OutputToInput)\n        return response\n\n\nclass GalaxyToTransform(Transform):\n    input_type = None\n\n    def do_transform(self, request, response, config, type_filter=MISPGalaxy):\n        response += check_update(config)\n\n        current_cluster = get_galaxy_cluster(request_entity=request.entity)\n\n        # legacy - replaced by Search in MISP\n        if not current_cluster and request.entity.name != '-':\n            # maybe the user is searching for a cluster based on a substring.\n            # Search in the list for those that match and return galaxy entities\n            potential_clusters = search_galaxy_cluster(request.entity.name)\n            if potential_clusters:\n                for potential_cluster in potential_clusters:\n                    new_entity = galaxycluster_to_entity(potential_cluster, link_label='Search result')\n                    if isinstance(new_entity, type_filter):\n                        response += new_entity\n                return response\n        # end of legacy\n\n        if not current_cluster:\n            response += UIMessage(\"Galaxy Cluster UUID not in local mapping. Please update local cache; non-public UUID are not supported yet.\", type=UIMessageType.Inform)\n            return response\n        c = current_cluster\n\n        # update existing object\n        galaxy_cluster = get_galaxy_cluster(uuid=c['uuid'])\n        icon_url = None\n        if 'icon' in galaxy_cluster:  # map the 'icon' name from the cluster to the icon filename of the intelligence-icons repository\n            try:\n                icon_url = mapping_galaxy_icon[galaxy_cluster['icon']]\n            except Exception:\n                # it's not in our mapping, just ignore and leave the default Galaxy icon\n                pass\n        if c['meta'].get('synonyms'):\n            synonyms = ', '.join(c['meta']['synonyms'])\n        else:\n            synonyms = ''\n        request.entity.name = '{}\\n{}'.format(c['type'], c['value'])\n        request.entity.uuid = c['uuid']\n        request.entity.description = c.get('description')\n        request.entity.cluster_type = c.get('type')\n        request.entity.cluster_value = c.get('value')\n        request.entity.synonyms = synonyms\n        request.entity.tag_name = c['tag_name']\n        request.entity.icon_url = icon_url\n        # response += request.entity\n\n        # find related objects\n        if 'related' in current_cluster:\n            for related in current_cluster['related']:\n                related_cluster = get_galaxy_cluster(uuid=related['dest-uuid'])\n                if related_cluster:\n                    new_entity = galaxycluster_to_entity(related_cluster, link_label=related['type'])\n                    if isinstance(new_entity, type_filter):\n                        response += new_entity\n        # find objects that are relating to this one\n        for related in get_galaxies_relating(current_cluster['uuid']):\n            related_link_label = ''\n            for rel_in_rel in related['related']:\n                if rel_in_rel['dest-uuid'] == current_cluster['uuid']:\n                    related_link_label = rel_in_rel['type']\n                    break\n            new_entity = galaxycluster_to_entity(related, link_label=related_link_label, link_direction=LinkDirection.OutputToInput)\n            if isinstance(new_entity, type_filter):\n                response += new_entity\n        return response\n\n\nclass GalaxyToRelations(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related Galaxies and Clusters\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=MISPGalaxy):\n        return super().do_transform(request, response, config, type_filter)\n\n\nclass GalaxyToSoftware(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related Software/Tool Galaxies\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=Software):\n        return super().do_transform(request, response, config, type_filter)\n\n\nclass GalaxyToThreatActor(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related ThreatActor Galaxies\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=ThreatActor):\n        return super().do_transform(request, response, config, type_filter)\n\n\nclass GalaxyToAttackTechnique(GalaxyToTransform):\n    \"\"\"Expands a Galaxy to related Attack Techniques Galaxies\"\"\"\n    input_type = MISPGalaxy\n    remote = True\n\n    def do_transform(self, request, response, config, type_filter=AttackTechnique):\n        return super().do_transform(request, response, config, type_filter)\n"], "filenames": ["src/MISP_maltego/transforms/attributetoevent.py", "src/MISP_maltego/transforms/common/util.py", "src/MISP_maltego/transforms/eventtoattributes.py", "src/MISP_maltego/transforms/galaxytoevent.py"], "buggy_code_start_loc": [4, 21, 4, 3], "buggy_code_end_loc": [183, 273, 200, 33], "fixing_code_start_loc": [4, 20, 4, 3], "fixing_code_end_loc": [183, 267, 200, 33], "type": "NVD-CWE-noinfo", "message": "MISP MISP-maltego 1.4.4 incorrectly shares a MISP connection across users in a remote-transform use case.", "other": {"cve": {"id": "CVE-2020-12889", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-15T18:15:13.727", "lastModified": "2020-05-19T13:38:45.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MISP MISP-maltego 1.4.4 incorrectly shares a MISP connection across users in a remote-transform use case."}, {"lang": "es", "value": "MISP MISP-maltego versi\u00f3n 1.4.4, comparte incorrectamente una conexi\u00f3n  MISP entre usuarios en un caso de uso de transformaci\u00f3n remota."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp-maltego:1.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "5603066C-16E0-4F5D-9CB3-71E138725EAD"}]}]}], "references": [{"url": "https://github.com/MISP/MISP-maltego/commit/3ccde66dab4096ab5663e69f352992cc73e1160b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MISP/MISP-maltego/commit/3ccde66dab4096ab5663e69f352992cc73e1160b"}}