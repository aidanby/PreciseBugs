{"buggy_code": ["/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved,\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifndef __ENCAP_HELPERS_H\n#define __ENCAP_HELPERS_H\n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n#include <string.h>\n\n#include \"katran/lib/linux_includes/bpf.h\"\n#include \"katran/lib/linux_includes/bpf_endian.h\"\n#include \"katran/lib/linux_includes/bpf_helpers.h\"\n\n#include \"katran/lib/bpf/balancer_consts.h\"\n#include \"katran/lib/bpf/csum_helpers.h\"\n\n__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}\n\n__attribute__((__always_inline__)) static inline void create_v6_hdr(\n    struct ipv6hdr* ip6h,\n    __u8 tc,\n    __u32* saddr,\n    __u32* daddr,\n    __u16 payload_len,\n    __u8 proto) {\n  ip6h->version = 6;\n  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\n#ifdef COPY_INNER_PACKET_TOS\n  ip6h->priority = (tc & 0xF0) >> 4;\n  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;\n#else\n  ip6h->priority = DEFAULT_TOS;\n#endif\n  ip6h->nexthdr = proto;\n  ip6h->payload_len = bpf_htons(payload_len);\n  ip6h->hop_limit = DEFAULT_TTL;\n  memcpy(ip6h->saddr.s6_addr32, saddr, 16);\n  memcpy(ip6h->daddr.s6_addr32, daddr, 16);\n}\n\n__attribute__((__always_inline__)) static inline void create_udp_hdr(\n    struct udphdr* udph,\n    __u16 sport,\n    __u16 dport,\n    __u16 len,\n    __u16 csum) {\n  udph->source = sport;\n  udph->dest = bpf_htons(dport);\n  udph->len = bpf_htons(len);\n  udph->check = csum;\n}\n\n#endif // of __ENCAP_HELPERS_H\n", "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifndef __HANDLE_ICMP_H\n#define __HANDLE_ICMP_H\n\n/*\n * This file contains all routines which are responsible for parsing\n * and handling ICMP packets\n */\n\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <stddef.h>\n\n#include \"katran/lib/linux_includes/bpf.h\"\n#include \"katran/lib/linux_includes/bpf_endian.h\"\n\n#include \"katran/lib/bpf/balancer_consts.h\"\n#include \"katran/lib/bpf/balancer_helpers.h\"\n#include \"katran/lib/bpf/balancer_maps.h\"\n#include \"katran/lib/bpf/balancer_structs.h\"\n\n__attribute__((__always_inline__)) static inline int swap_mac_and_send(\n    void* data,\n    void* data_end) {\n  struct ethhdr* eth;\n  unsigned char tmp_mac[ETH_ALEN];\n  eth = data;\n  memcpy(tmp_mac, eth->h_source, ETH_ALEN);\n  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);\n  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);\n  return XDP_TX;\n}\n\n__attribute__((__always_inline__)) static inline void swap_mac(\n    void* data,\n    struct ethhdr* orig_eth) {\n  struct ethhdr* eth;\n  eth = data;\n  memcpy(eth->h_source, orig_eth->h_dest, ETH_ALEN);\n  memcpy(eth->h_dest, orig_eth->h_source, ETH_ALEN);\n  eth->h_proto = orig_eth->h_proto;\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp_reply(\n    void* data,\n    void* data_end) {\n  struct iphdr* iph;\n  struct icmphdr* icmp_hdr;\n  __u32 tmp_addr = 0;\n  __u64 csum = 0;\n  __u64 off = 0;\n\n  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +\n       sizeof(struct icmphdr)) > data_end) {\n    return XDP_DROP;\n  }\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  icmp_hdr->type = ICMP_ECHOREPLY;\n  // the only diff between icmp echo and reply hdrs is type;\n  // in first case it's 8; in second it's 0; so instead of recalc\n  // checksum from ground up we will just adjust it.\n  icmp_hdr->checksum += 0x0008;\n  iph->ttl = DEFAULT_TTL;\n  tmp_addr = iph->daddr;\n  iph->daddr = iph->saddr;\n  iph->saddr = tmp_addr;\n  iph->check = 0;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n  return swap_mac_and_send(data, data_end);\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp6_reply(\n    void* data,\n    void* data_end) {\n  struct ipv6hdr* ip6h;\n  struct icmp6hdr* icmp_hdr;\n  __be32 tmp_addr[4];\n  __u64 off = 0;\n  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +\n       sizeof(struct icmp6hdr)) > data_end) {\n    return XDP_DROP;\n  }\n  off += sizeof(struct ethhdr);\n  ip6h = data + off;\n  off += sizeof(struct ipv6hdr);\n  icmp_hdr = data + off;\n  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;\n  // the only diff between icmp echo and reply hdrs is type;\n  // in first case it's 128; in second it's 129; so instead of recalc\n  // checksum from ground up we will just adjust it.\n  icmp_hdr->icmp6_cksum -= 0x0001;\n  ip6h->hop_limit = DEFAULT_TTL;\n  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);\n  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);\n  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);\n  return swap_mac_and_send(data, data_end);\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp4_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct iphdr *iph, *orig_iph;\n  struct ethhdr* orig_eth;\n  struct icmphdr* icmp_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  off += sizeof(struct icmphdr);\n  orig_iph = data + off;\n  icmp_hdr->type = ICMP_DEST_UNREACH;\n  icmp_hdr->code = ICMP_FRAG_NEEDED;\n  icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp_hdr->checksum = 0;\n  ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n  icmp_hdr->checksum = csum;\n  iph->ttl = DEFAULT_TTL;\n  iph->daddr = orig_iph->saddr;\n  iph->saddr = orig_iph->daddr;\n  iph->frag_off = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->protocol = IPPROTO_ICMP;\n  iph->tos = 0;\n  iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n  iph->check = 0;\n  csum = 0;\n  ipv4_csum(iph, sizeof(struct iphdr), &csum);\n  iph->check = csum;\n  return XDP_TX;\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp6_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct ipv6hdr) + (int)sizeof(struct icmp6hdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP6_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct ipv6hdr *ip6h, *orig_ip6h;\n  struct ethhdr* orig_eth;\n  struct icmp6hdr* icmp6_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  ip6h = data + off;\n  off += sizeof(struct ipv6hdr);\n  icmp6_hdr = data + off;\n  off += sizeof(struct icmp6hdr);\n  orig_ip6h = data + off;\n  ip6h->version = 6;\n  ip6h->priority = 0;\n  ip6h->nexthdr = IPPROTO_ICMPV6;\n  ip6h->hop_limit = DEFAULT_TTL;\n  ip6h->payload_len = bpf_htons(ICMP6_TOOBIG_PAYLOAD_SIZE);\n  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\n  memcpy(ip6h->daddr.s6_addr32, orig_ip6h->saddr.s6_addr32, 16);\n  memcpy(ip6h->saddr.s6_addr32, orig_ip6h->daddr.s6_addr32, 16);\n  icmp6_hdr->icmp6_type = ICMPV6_PKT_TOOBIG;\n  icmp6_hdr->icmp6_code = 0;\n  icmp6_hdr->icmp6_mtu = bpf_htonl(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp6_hdr->icmp6_cksum = 0;\n  ipv6_csum(icmp6_hdr, ICMP6_TOOBIG_PAYLOAD_SIZE, &csum, ip6h);\n  icmp6_hdr->icmp6_cksum = csum;\n  return XDP_TX;\n}\n\n__attribute__((__always_inline__)) static inline int\nsend_icmp_too_big(struct xdp_md* xdp, bool is_ipv6, int pckt_size) {\n  int offset = pckt_size;\n  if (is_ipv6) {\n    offset -= ICMP6_TOOBIG_SIZE;\n  } else {\n    offset -= ICMP_TOOBIG_SIZE;\n  }\n  if (bpf_xdp_adjust_tail(xdp, 0 - offset)) {\n    return XDP_DROP;\n  }\n  if (is_ipv6) {\n    return send_icmp6_too_big(xdp);\n  } else {\n    return send_icmp4_too_big(xdp);\n  }\n}\n\n__attribute__((__always_inline__)) static inline int parse_icmpv6(\n    void* data,\n    void* data_end,\n    __u64 off,\n    struct packet_description* pckt) {\n  struct icmp6hdr* icmp_hdr;\n  struct ipv6hdr* ip6h;\n  icmp_hdr = data + off;\n  if (icmp_hdr + 1 > data_end) {\n    return XDP_DROP;\n  }\n  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {\n    return send_icmp6_reply(data, data_end);\n  }\n  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&\n      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {\n    return XDP_PASS;\n  }\n\n  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {\n    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;\n    struct lb_stats* icmp_ptb_v6_stats =\n        bpf_map_lookup_elem(&stats, &stats_key);\n    if (!icmp_ptb_v6_stats) {\n      return XDP_DROP;\n    }\n    icmp_ptb_v6_stats->v1 += 1;\n    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);\n    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {\n      icmp_ptb_v6_stats->v2 += 1;\n    }\n  }\n\n  off += sizeof(struct icmp6hdr);\n  // data partition of icmp 'pkt too big' contains header (and as much data as\n  // as possible) of the packet, which has trigered this icmp.\n  ip6h = data + off;\n  if (ip6h + 1 > data_end) {\n    return XDP_DROP;\n  }\n  pckt->flow.proto = ip6h->nexthdr;\n  pckt->flags |= F_ICMP;\n  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);\n  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);\n  return FURTHER_PROCESSING;\n}\n\n__attribute__((__always_inline__)) static inline int parse_icmp(\n    void* data,\n    void* data_end,\n    __u64 off,\n    struct packet_description* pckt) {\n  struct icmphdr* icmp_hdr;\n  struct iphdr* iph;\n  icmp_hdr = data + off;\n  if (icmp_hdr + 1 > data_end) {\n    return XDP_DROP;\n  }\n  if (icmp_hdr->type == ICMP_ECHO) {\n    return send_icmp_reply(data, data_end);\n  }\n  if (icmp_hdr->type != ICMP_DEST_UNREACH) {\n    return XDP_PASS;\n  }\n\n  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {\n    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;\n    struct lb_stats* icmp_ptb_v4_stats =\n        bpf_map_lookup_elem(&stats, &stats_key);\n    if (!icmp_ptb_v4_stats) {\n      return XDP_DROP;\n    }\n    icmp_ptb_v4_stats->v1 += 1;\n    __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);\n    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {\n      icmp_ptb_v4_stats->v2 += 1;\n    }\n  }\n\n  off += sizeof(struct icmphdr);\n  iph = data + off;\n  if (iph + 1 > data_end) {\n    return XDP_DROP;\n  }\n  if (iph->ihl != 5) {\n    return XDP_DROP;\n  }\n  pckt->flow.proto = iph->protocol;\n  pckt->flags |= F_ICMP;\n  pckt->flow.src = iph->daddr;\n  pckt->flow.dst = iph->saddr;\n  return FURTHER_PROCESSING;\n}\n\n// icmp messages with code that quic server would ignore\n__attribute__((__always_inline__)) static inline bool\nignorable_quic_icmp_code(void* data, void* data_end, bool is_ipv6) {\n  __u64 off = sizeof(struct ethhdr);\n  if (is_ipv6) {\n    struct icmp6hdr* icmp_hdr = data + off + sizeof(struct ipv6hdr);\n    return (\n        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||\n        (icmp_hdr->icmp6_code == ICMPV6_PORT_UNREACH));\n  } else {\n    struct icmphdr* icmp_hdr = data + off + sizeof(struct iphdr);\n    return (\n        (icmp_hdr->code == ICMP_PORT_UNREACH) ||\n        (icmp_hdr->code == ICMP_HOST_UNREACH));\n  }\n}\n\n#endif // of __HANDLE_ICMP_H\n"], "fixing_code": ["/* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved,\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifndef __ENCAP_HELPERS_H\n#define __ENCAP_HELPERS_H\n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n#include <string.h>\n\n#include \"katran/lib/linux_includes/bpf.h\"\n#include \"katran/lib/linux_includes/bpf_endian.h\"\n#include \"katran/lib/linux_includes/bpf_helpers.h\"\n\n#include \"katran/lib/bpf/balancer_consts.h\"\n#include \"katran/lib/bpf/csum_helpers.h\"\n\n__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}\n\n__attribute__((__always_inline__)) static inline void create_v6_hdr(\n    struct ipv6hdr* ip6h,\n    __u8 tc,\n    __u32* saddr,\n    __u32* daddr,\n    __u16 payload_len,\n    __u8 proto) {\n  ip6h->version = 6;\n  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\n#ifdef COPY_INNER_PACKET_TOS\n  ip6h->priority = (tc & 0xF0) >> 4;\n  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;\n#else\n  ip6h->priority = DEFAULT_TOS;\n#endif\n  ip6h->nexthdr = proto;\n  ip6h->payload_len = bpf_htons(payload_len);\n  ip6h->hop_limit = DEFAULT_TTL;\n  memcpy(ip6h->saddr.s6_addr32, saddr, 16);\n  memcpy(ip6h->daddr.s6_addr32, daddr, 16);\n}\n\n__attribute__((__always_inline__)) static inline void create_udp_hdr(\n    struct udphdr* udph,\n    __u16 sport,\n    __u16 dport,\n    __u16 len,\n    __u16 csum) {\n  udph->source = sport;\n  udph->dest = bpf_htons(dport);\n  udph->len = bpf_htons(len);\n  udph->check = csum;\n}\n\n#endif // of __ENCAP_HELPERS_H\n", "/* Copyright (C) 2018-present, Facebook, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifndef __HANDLE_ICMP_H\n#define __HANDLE_ICMP_H\n\n/*\n * This file contains all routines which are responsible for parsing\n * and handling ICMP packets\n */\n\n#include <linux/icmp.h>\n#include <linux/icmpv6.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <stddef.h>\n\n#include \"katran/lib/linux_includes/bpf.h\"\n#include \"katran/lib/linux_includes/bpf_endian.h\"\n\n#include \"katran/lib/bpf/balancer_consts.h\"\n#include \"katran/lib/bpf/balancer_helpers.h\"\n#include \"katran/lib/bpf/balancer_maps.h\"\n#include \"katran/lib/bpf/balancer_structs.h\"\n\n__attribute__((__always_inline__)) static inline int swap_mac_and_send(\n    void* data,\n    void* data_end) {\n  struct ethhdr* eth;\n  unsigned char tmp_mac[ETH_ALEN];\n  eth = data;\n  memcpy(tmp_mac, eth->h_source, ETH_ALEN);\n  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);\n  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);\n  return XDP_TX;\n}\n\n__attribute__((__always_inline__)) static inline void swap_mac(\n    void* data,\n    struct ethhdr* orig_eth) {\n  struct ethhdr* eth;\n  eth = data;\n  memcpy(eth->h_source, orig_eth->h_dest, ETH_ALEN);\n  memcpy(eth->h_dest, orig_eth->h_source, ETH_ALEN);\n  eth->h_proto = orig_eth->h_proto;\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp_reply(\n    void* data,\n    void* data_end) {\n  struct iphdr* iph;\n  struct icmphdr* icmp_hdr;\n  __u32 tmp_addr = 0;\n  __u64 csum = 0;\n  __u64 off = 0;\n\n  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +\n       sizeof(struct icmphdr)) > data_end) {\n    return XDP_DROP;\n  }\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  icmp_hdr->type = ICMP_ECHOREPLY;\n  // the only diff between icmp echo and reply hdrs is type;\n  // in first case it's 8; in second it's 0; so instead of recalc\n  // checksum from ground up we will just adjust it.\n  icmp_hdr->checksum += 0x0008;\n  iph->ttl = DEFAULT_TTL;\n  tmp_addr = iph->daddr;\n  iph->daddr = iph->saddr;\n  iph->saddr = tmp_addr;\n  iph->check = 0;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n  return swap_mac_and_send(data, data_end);\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp6_reply(\n    void* data,\n    void* data_end) {\n  struct ipv6hdr* ip6h;\n  struct icmp6hdr* icmp_hdr;\n  __be32 tmp_addr[4];\n  __u64 off = 0;\n  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +\n       sizeof(struct icmp6hdr)) > data_end) {\n    return XDP_DROP;\n  }\n  off += sizeof(struct ethhdr);\n  ip6h = data + off;\n  off += sizeof(struct ipv6hdr);\n  icmp_hdr = data + off;\n  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;\n  // the only diff between icmp echo and reply hdrs is type;\n  // in first case it's 128; in second it's 129; so instead of recalc\n  // checksum from ground up we will just adjust it.\n  icmp_hdr->icmp6_cksum -= 0x0001;\n  ip6h->hop_limit = DEFAULT_TTL;\n  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);\n  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);\n  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);\n  return swap_mac_and_send(data, data_end);\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp4_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct iphdr *iph, *orig_iph;\n  struct ethhdr* orig_eth;\n  struct icmphdr* icmp_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  off += sizeof(struct icmphdr);\n  orig_iph = data + off;\n  icmp_hdr->type = ICMP_DEST_UNREACH;\n  icmp_hdr->code = ICMP_FRAG_NEEDED;\n  icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp_hdr->un.frag.__unused = 0;\n  icmp_hdr->checksum = 0;\n  ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n  icmp_hdr->checksum = csum;\n  iph->ttl = DEFAULT_TTL;\n  iph->daddr = orig_iph->saddr;\n  iph->saddr = orig_iph->daddr;\n  iph->frag_off = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->protocol = IPPROTO_ICMP;\n  iph->tos = 0;\n  iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n  iph->id = 0;\n  iph->check = 0;\n  csum = 0;\n  ipv4_csum(iph, sizeof(struct iphdr), &csum);\n  iph->check = csum;\n  return XDP_TX;\n}\n\n__attribute__((__always_inline__)) static inline int send_icmp6_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct ipv6hdr) + (int)sizeof(struct icmp6hdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP6_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct ipv6hdr *ip6h, *orig_ip6h;\n  struct ethhdr* orig_eth;\n  struct icmp6hdr* icmp6_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  ip6h = data + off;\n  off += sizeof(struct ipv6hdr);\n  icmp6_hdr = data + off;\n  off += sizeof(struct icmp6hdr);\n  orig_ip6h = data + off;\n  ip6h->version = 6;\n  ip6h->priority = 0;\n  ip6h->nexthdr = IPPROTO_ICMPV6;\n  ip6h->hop_limit = DEFAULT_TTL;\n  ip6h->payload_len = bpf_htons(ICMP6_TOOBIG_PAYLOAD_SIZE);\n  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));\n  memcpy(ip6h->daddr.s6_addr32, orig_ip6h->saddr.s6_addr32, 16);\n  memcpy(ip6h->saddr.s6_addr32, orig_ip6h->daddr.s6_addr32, 16);\n  icmp6_hdr->icmp6_type = ICMPV6_PKT_TOOBIG;\n  icmp6_hdr->icmp6_code = 0;\n  icmp6_hdr->icmp6_mtu = bpf_htonl(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp6_hdr->icmp6_cksum = 0;\n  ipv6_csum(icmp6_hdr, ICMP6_TOOBIG_PAYLOAD_SIZE, &csum, ip6h);\n  icmp6_hdr->icmp6_cksum = csum;\n  return XDP_TX;\n}\n\n__attribute__((__always_inline__)) static inline int\nsend_icmp_too_big(struct xdp_md* xdp, bool is_ipv6, int pckt_size) {\n  int offset = pckt_size;\n  if (is_ipv6) {\n    offset -= ICMP6_TOOBIG_SIZE;\n  } else {\n    offset -= ICMP_TOOBIG_SIZE;\n  }\n  if (bpf_xdp_adjust_tail(xdp, 0 - offset)) {\n    return XDP_DROP;\n  }\n  if (is_ipv6) {\n    return send_icmp6_too_big(xdp);\n  } else {\n    return send_icmp4_too_big(xdp);\n  }\n}\n\n__attribute__((__always_inline__)) static inline int parse_icmpv6(\n    void* data,\n    void* data_end,\n    __u64 off,\n    struct packet_description* pckt) {\n  struct icmp6hdr* icmp_hdr;\n  struct ipv6hdr* ip6h;\n  icmp_hdr = data + off;\n  if (icmp_hdr + 1 > data_end) {\n    return XDP_DROP;\n  }\n  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {\n    return send_icmp6_reply(data, data_end);\n  }\n  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&\n      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {\n    return XDP_PASS;\n  }\n\n  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {\n    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;\n    struct lb_stats* icmp_ptb_v6_stats =\n        bpf_map_lookup_elem(&stats, &stats_key);\n    if (!icmp_ptb_v6_stats) {\n      return XDP_DROP;\n    }\n    icmp_ptb_v6_stats->v1 += 1;\n    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);\n    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {\n      icmp_ptb_v6_stats->v2 += 1;\n    }\n  }\n\n  off += sizeof(struct icmp6hdr);\n  // data partition of icmp 'pkt too big' contains header (and as much data as\n  // as possible) of the packet, which has trigered this icmp.\n  ip6h = data + off;\n  if (ip6h + 1 > data_end) {\n    return XDP_DROP;\n  }\n  pckt->flow.proto = ip6h->nexthdr;\n  pckt->flags |= F_ICMP;\n  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);\n  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);\n  return FURTHER_PROCESSING;\n}\n\n__attribute__((__always_inline__)) static inline int parse_icmp(\n    void* data,\n    void* data_end,\n    __u64 off,\n    struct packet_description* pckt) {\n  struct icmphdr* icmp_hdr;\n  struct iphdr* iph;\n  icmp_hdr = data + off;\n  if (icmp_hdr + 1 > data_end) {\n    return XDP_DROP;\n  }\n  if (icmp_hdr->type == ICMP_ECHO) {\n    return send_icmp_reply(data, data_end);\n  }\n  if (icmp_hdr->type != ICMP_DEST_UNREACH) {\n    return XDP_PASS;\n  }\n\n  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {\n    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;\n    struct lb_stats* icmp_ptb_v4_stats =\n        bpf_map_lookup_elem(&stats, &stats_key);\n    if (!icmp_ptb_v4_stats) {\n      return XDP_DROP;\n    }\n    icmp_ptb_v4_stats->v1 += 1;\n    __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);\n    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {\n      icmp_ptb_v4_stats->v2 += 1;\n    }\n  }\n\n  off += sizeof(struct icmphdr);\n  iph = data + off;\n  if (iph + 1 > data_end) {\n    return XDP_DROP;\n  }\n  if (iph->ihl != 5) {\n    return XDP_DROP;\n  }\n  pckt->flow.proto = iph->protocol;\n  pckt->flags |= F_ICMP;\n  pckt->flow.src = iph->daddr;\n  pckt->flow.dst = iph->saddr;\n  return FURTHER_PROCESSING;\n}\n\n// icmp messages with code that quic server would ignore\n__attribute__((__always_inline__)) static inline bool\nignorable_quic_icmp_code(void* data, void* data_end, bool is_ipv6) {\n  __u64 off = sizeof(struct ethhdr);\n  if (is_ipv6) {\n    struct icmp6hdr* icmp_hdr = data + off + sizeof(struct ipv6hdr);\n    return (\n        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||\n        (icmp_hdr->icmp6_code == ICMPV6_PORT_UNREACH));\n  } else {\n    struct icmphdr* icmp_hdr = data + off + sizeof(struct iphdr);\n    return (\n        (icmp_hdr->code == ICMP_PORT_UNREACH) ||\n        (icmp_hdr->code == ICMP_HOST_UNREACH));\n  }\n}\n\n#endif // of __HANDLE_ICMP_H\n"], "filenames": ["katran/lib/bpf/encap_helpers.h", "katran/lib/bpf/handle_icmp.h"], "buggy_code_start_loc": [50, 147], "buggy_code_end_loc": [50, 159], "fixing_code_start_loc": [51, 148], "fixing_code_end_loc": [52, 162], "type": "CWE-665", "message": "Katran could disclose non-initialized kernel memory as part of an IP header. The issue was present for IPv4 encapsulation and ICMP (v4) Too Big packet generation. After a bpf_xdp_adjust_head call, Katran code didn\u2019t initialize the Identification field for the IPv4 header, resulting in writing content of kernel memory in that field of IP header. The issue affected all Katran versions prior to commit 6a03106ac1eab39d0303662963589ecb2374c97f", "other": {"cve": {"id": "CVE-2023-49062", "sourceIdentifier": "cve-assign@fb.com", "published": "2023-11-28T16:15:07.023", "lastModified": "2023-12-04T19:46:20.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Katran could disclose non-initialized kernel memory as part of an IP header. The issue was present for IPv4 encapsulation and ICMP (v4) Too Big packet generation. After a bpf_xdp_adjust_head call, Katran code didn\u2019t initialize the Identification field for the IPv4 header, resulting in writing content of kernel memory in that field of IP header. The issue affected all Katran versions prior to commit 6a03106ac1eab39d0303662963589ecb2374c97f"}, {"lang": "es", "value": "Katran podr\u00eda revelar memoria del kernel no inicializada como parte de un encabezado IP. El problema estaba presente en la encapsulaci\u00f3n IPv4 y en la generaci\u00f3n de paquetes ICMP (v4) Too Big. Despu\u00e9s de una llamada a bpf_xdp_adjust_head, el c\u00f3digo Katran no inicializ\u00f3 el campo de identificaci\u00f3n para el encabezado IPv4, lo que result\u00f3 en la escritura del contenido de la memoria del kernel en ese campo del encabezado IP. El problema afect\u00f3 a todas las versiones de Katran antes del commit 6a03106ac1eab39d0303662963589ecb2374c97f"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:katran:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-11-15", "matchCriteriaId": "C62809AA-C0F4-4F93-B42B-431F9A0A1762"}]}]}], "references": [{"url": "https://github.com/facebookincubator/katran/commit/6a03106ac1eab39d0303662963589ecb2374c97f", "source": "cve-assign@fb.com", "tags": ["Patch"]}, {"url": "https://www.facebook.com/security/advisories/cve-2023-49062", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebookincubator/katran/commit/6a03106ac1eab39d0303662963589ecb2374c97f"}}