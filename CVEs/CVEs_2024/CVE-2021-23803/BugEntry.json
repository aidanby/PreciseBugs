{"buggy_code": ["<?php\n\n/**\n * This file is part of the Latte (https://latte.nette.org)\n * Copyright (c) 2008 David Grudl (https://davidgrudl.com)\n */\n\ndeclare(strict_types=1);\n\nnamespace Latte;\n\n\n/**\n * Latte parser.\n */\nclass Parser\n{\n\tuse Strict;\n\n\t/** @internal regular expression for single & double quoted PHP string */\n\tpublic const RE_STRING = '\\'(?:\\\\\\\\.|[^\\'\\\\\\\\])*+\\'|\"(?:\\\\\\\\.|[^\"\\\\\\\\])*+\"';\n\n\t/** @internal HTML tag name for Latte needs (actually is [a-zA-Z][^\\s/>]*) */\n\tpublic const RE_TAG_NAME = '[a-zA-Z][a-zA-Z0-9:_.-]*';\n\n\t/** @internal special HTML attribute prefix */\n\tpublic const N_PREFIX = 'n:';\n\n\t/** Context-aware escaping content types */\n\tpublic const\n\t\tCONTENT_HTML = Engine::CONTENT_HTML,\n\t\tCONTENT_XHTML = Engine::CONTENT_XHTML,\n\t\tCONTENT_XML = Engine::CONTENT_XML,\n\t\tCONTENT_TEXT = Engine::CONTENT_TEXT;\n\n\t/** @internal states */\n\tpublic const\n\t\tCONTEXT_NONE = 'none',\n\t\tCONTEXT_MACRO = 'macro',\n\t\tCONTEXT_HTML_TEXT = 'htmlText',\n\t\tCONTEXT_HTML_TAG = 'htmlTag',\n\t\tCONTEXT_HTML_ATTRIBUTE = 'htmlAttribute',\n\t\tCONTEXT_HTML_COMMENT = 'htmlComment',\n\t\tCONTEXT_HTML_CDATA = 'htmlCData';\n\n\t/** @var string default macro tag syntax */\n\tpublic $defaultSyntax = 'latte';\n\n\t/** @var array<string, array{string, string}> */\n\tpublic $syntaxes = [\n\t\t'latte' => ['\\{(?![\\s\\'\"{}])', '\\}'], // {...}\n\t\t'double' => ['\\{\\{(?![\\s\\'\"{}])', '\\}\\}'], // {{...}}\n\t\t'off' => ['\\{(?=/syntax\\})', '\\}'], // {/syntax}\n\t];\n\n\t/** @var string[] */\n\tprivate $delimiters;\n\n\t/** @var string source template */\n\tprivate $input;\n\n\t/** @var Token[] */\n\tprivate $output;\n\n\t/** @var int  position on source template */\n\tprivate $offset;\n\n\t/** @var int */\n\tprivate $line;\n\n\t/** @var array{string, mixed} */\n\tprivate $context = [self::CONTEXT_HTML_TEXT, null];\n\n\t/** @var string|null */\n\tprivate $lastHtmlTag;\n\n\t/** @var string|null used by filter() */\n\tprivate $syntaxEndTag;\n\n\t/** @var int */\n\tprivate $syntaxEndLevel = 0;\n\n\t/** @var bool */\n\tprivate $xmlMode;\n\n\n\t/**\n\t * Process all {macros} and <tags/>.\n\t * @return Token[]\n\t */\n\tpublic function parse(string $input): array\n\t{\n\t\tif (Helpers::startsWith($input, \"\\u{FEFF}\")) { // BOM\n\t\t\t$input = substr($input, 3);\n\t\t}\n\n\t\t$this->input = $input = str_replace(\"\\r\\n\", \"\\n\", $input);\n\t\t$this->offset = 0;\n\t\t$this->line = 1;\n\t\t$this->output = [];\n\n\t\tif (!preg_match('##u', $input)) {\n\t\t\tpreg_match('#(?:[\\x00-\\x7F]|[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3})*+#A', $input, $m);\n\t\t\t$this->line += substr_count($m[0], \"\\n\");\n\t\t\tthrow new \\InvalidArgumentException('Template is not valid UTF-8 stream.');\n\t\t}\n\n\t\t$this->setSyntax($this->defaultSyntax);\n\t\t$this->lastHtmlTag = $this->syntaxEndTag = null;\n\n\t\t$tokenCount = 0;\n\t\twhile ($this->offset < strlen($input)) {\n\t\t\tif ($this->{'context' . $this->context[0]}() === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile ($tokenCount < count($this->output)) {\n\t\t\t\t$this->filter($this->output[$tokenCount++]);\n\t\t\t}\n\t\t}\n\t\tif ($this->context[0] === self::CONTEXT_MACRO) {\n\t\t\tthrow new CompileException('Malformed tag.');\n\t\t}\n\n\t\tif ($this->offset < strlen($input)) {\n\t\t\t$this->addToken(Token::TEXT, substr($this->input, $this->offset));\n\t\t}\n\t\treturn $this->output;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_TEXT.\n\t */\n\tprivate function contextHtmlText(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?:(?<=\\n|^)[ \\t]*)?<(?P<closing>/?)(?P<tag>' . self::RE_TAG_NAME . ')|  ##  begin of HTML tag <tag </tag - ignores <!DOCTYPE\n\t\t\t<(?P<htmlcomment>!(?:--(?!>))?|\\?)|     ##  begin of <!, <!--, <!DOCTYPE, <?\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (!empty($matches['htmlcomment'])) { // <! <?\n\t\t\t$this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);\n\t\t\t$end = $matches['htmlcomment'] === '!--'\n\t\t\t\t? '--'\n\t\t\t\t: ($matches['htmlcomment'] === '?' && $this->xmlMode ? '\\?' : '');\n\t\t\t$this->setContext(self::CONTEXT_HTML_COMMENT, $end);\n\t\t\treturn true;\n\n\t\t} elseif (!empty($matches['tag'])) { // <tag or </tag\n\t\t\t$token = $this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);\n\t\t\t$token->name = $matches['tag'];\n\t\t\t$token->closing = (bool) $matches['closing'];\n\t\t\t$this->lastHtmlTag = $matches['closing'] . strtolower($matches['tag']);\n\t\t\t$this->setContext(self::CONTEXT_HTML_TAG);\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_CDATA.\n\t */\n\tprivate function contextHtmlCData(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t</(?P<tag>' . $this->lastHtmlTag . ')(?=[\\s/>])| ##  end HTML tag </tag\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (empty($matches['tag'])) {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t\t// </tag\n\t\t$token = $this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);\n\t\t$token->name = $this->lastHtmlTag;\n\t\t$token->closing = true;\n\t\t$this->lastHtmlTag = '/' . $this->lastHtmlTag;\n\t\t$this->setContext(self::CONTEXT_HTML_TAG);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_TAG.\n\t */\n\tprivate function contextHtmlTag(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<end>\\s?/?>)([ \\t]*\\n)?|  ##  end of HTML tag\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')|\n\t\t\t\\s*(?P<attr>[^\\s\"\\'>/={]+)(?:\\s*=\\s*(?P<value>[\"\\']|[^\\s\"\\'=<>`{]+))? ## beginning of HTML attribute\n\t\t~xsi');\n\n\t\tif (!empty($matches['end'])) { // end of HTML tag />\n\t\t\t$this->addToken(Token::HTML_TAG_END, $matches[0]);\n\t\t\t$empty = strpos($matches[0], '/') !== false;\n\t\t\t$this->setContext(!$this->xmlMode && !$empty && in_array($this->lastHtmlTag, ['script', 'style'], true) ? self::CONTEXT_HTML_CDATA : self::CONTEXT_HTML_TEXT);\n\t\t\treturn true;\n\n\t\t} elseif (isset($matches['attr']) && $matches['attr'] !== '') { // HTML attribute\n\t\t\t$token = $this->addToken(Token::HTML_ATTRIBUTE_BEGIN, $matches[0]);\n\t\t\t$token->name = $matches['attr'];\n\t\t\t$token->value = $matches['value'] ?? '';\n\n\t\t\tif ($token->value === '\"' || $token->value === \"'\") { // attribute = \"'\n\t\t\t\tif (Helpers::startsWith($token->name, self::N_PREFIX)) {\n\t\t\t\t\t$token->value = '';\n\t\t\t\t\tif ($m = $this->match('~(.*?)' . $matches['value'] . '~xsi')) {\n\t\t\t\t\t\t$token->value = $m[1];\n\t\t\t\t\t\t$token->text .= $m[0];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$this->setContext(self::CONTEXT_HTML_ATTRIBUTE, $matches['value']);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_ATTRIBUTE.\n\t */\n\tprivate function contextHtmlAttribute(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<quote>' . $this->context[1] . ')|  ##  end of HTML attribute\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (empty($matches['quote'])) {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t\t// (attribute end) '\"\n\t\t$this->addToken(Token::HTML_ATTRIBUTE_END, $matches[0]);\n\t\t$this->setContext(self::CONTEXT_HTML_TAG);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_COMMENT.\n\t */\n\tprivate function contextHtmlComment(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<htmlcomment>' . $this->context[1] . '>)|   ##  end of HTML comment\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (empty($matches['htmlcomment'])) {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t\t// -->\n\t\t$this->addToken(Token::HTML_TAG_END, $matches[0]);\n\t\t$this->setContext(self::CONTEXT_HTML_TEXT);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_NONE.\n\t */\n\tprivate function contextNone(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\t\treturn $this->processMacro($matches);\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_MACRO.\n\t */\n\tprivate function contextMacro(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<comment>\\*.*?\\*' . $this->delimiters[1] . '\\n{0,2})|\n\t\t\t(?P<macro>(?>\n\t\t\t\t' . self::RE_STRING . '|\n\t\t\t\t\\{(?>' . self::RE_STRING . '|[^\\'\"{}])*+\\}|\n\t\t\t\t[^\\'\"{}]+\n\t\t\t)++)\n\t\t\t' . $this->delimiters[1] . '\n\t\t\t(?P<rmargin>[ \\t]*(?=\\n))?\n\t\t~xsiA');\n\n\t\tif (!empty($matches['macro'])) {\n\t\t\t$token = $this->addToken(Token::MACRO_TAG, $this->context[1][1] . $matches[0]);\n\t\t\t[$token->name, $token->value, $token->modifiers, $token->empty, $token->closing] = $this->parseMacroTag($matches['macro']);\n\t\t\t$this->context = $this->context[1][0];\n\t\t\treturn true;\n\n\t\t} elseif (!empty($matches['comment'])) {\n\t\t\t$this->addToken(Token::COMMENT, $this->context[1][1] . $matches[0]);\n\t\t\t$this->context = $this->context[1][0];\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthrow new CompileException('Malformed tag contents.');\n\t\t}\n\t}\n\n\n\t/**\n\t * @param  string[]  $matches\n\t */\n\tprivate function processMacro(array $matches): bool\n\t{\n\t\tif (empty($matches['macro'])) {\n\t\t\treturn false;\n\t\t}\n\t\t// {macro} or {* *}\n\t\t$this->setContext(self::CONTEXT_MACRO, [$this->context, $matches['macro']]);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Matches next token.\n\t * @return string[]\n\t */\n\tprivate function match(string $re): array\n\t{\n\t\tif (!preg_match($re, $this->input, $matches, PREG_OFFSET_CAPTURE, $this->offset)) {\n\t\t\tif (preg_last_error()) {\n\t\t\t\tthrow new RegexpException(null, preg_last_error());\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\t$value = substr($this->input, $this->offset, $matches[0][1] - $this->offset);\n\t\tif ($value !== '') {\n\t\t\t$this->addToken(Token::TEXT, $value);\n\t\t}\n\t\t$this->offset = $matches[0][1] + strlen($matches[0][0]);\n\t\tforeach ($matches as $k => $v) {\n\t\t\t$matches[$k] = $v[0];\n\t\t}\n\t\treturn $matches;\n\t}\n\n\n\t/**\n\t * @param  string  $type  Parser::CONTENT_HTML, CONTENT_XHTML, CONTENT_XML or CONTENT_TEXT\n\t * @return static\n\t */\n\tpublic function setContentType(string $type)\n\t{\n\t\tif (in_array($type, [self::CONTENT_HTML, self::CONTENT_XHTML, self::CONTENT_XML], true)) {\n\t\t\t$this->setContext(self::CONTEXT_HTML_TEXT);\n\t\t\t$this->xmlMode = $type === self::CONTENT_XML;\n\t\t} else {\n\t\t\t$this->setContext(self::CONTEXT_NONE);\n\t\t}\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * @param  mixed  $quote\n\t * @return static\n\t */\n\tpublic function setContext(string $context, $quote = null)\n\t{\n\t\t$this->context = [$context, $quote];\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * Changes macro tag delimiters.\n\t * @return static\n\t */\n\tpublic function setSyntax(string $type)\n\t{\n\t\t$type = $type ?: $this->defaultSyntax;\n\t\tif (!isset($this->syntaxes[$type])) {\n\t\t\tthrow new \\InvalidArgumentException(\"Unknown syntax '$type'\");\n\t\t}\n\n\t\t$this->setDelimiters($this->syntaxes[$type][0], $this->syntaxes[$type][1]);\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * Changes macro tag delimiters (as regular expression).\n\t * @return static\n\t */\n\tpublic function setDelimiters(string $left, string $right)\n\t{\n\t\t$this->delimiters = [$left, $right];\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * Parses macro tag to name, arguments a modifiers parts.\n\t * @param  string  $tag  {name arguments | modifiers}\n\t * @return array{string, string, string, bool, bool}|null\n\t * @internal\n\t */\n\tpublic function parseMacroTag(string $tag): ?array\n\t{\n\t\tif (!preg_match('~^\n\t\t\t(?P<closing>/?)\n\t\t\t(\n\t\t\t\t(?P<name>\\?|[a-z]\\w*+(?:[.:-]\\w+)*+(?!::|\\(|\\\\\\\\))|   ## ?, name, /name, but not function( or class:: or namespace\\\n\t\t\t\t(?P<shortname>=|_(?!_)|)      ## expression, =expression, ...\n\t\t\t)(?P<args>(?:' . self::RE_STRING . '|[^\\'\"])*?)\n\t\t\t(?P<modifiers>(?<!\\|)\\|[a-z](?P<modArgs>(?:' . self::RE_STRING . '|(?:\\((?P>modArgs)\\))|[^\\'\"/()]|/(?=.))*+))?\n\t\t\t(?P<empty>/?$)\n\t\t()$~Disx', $tag, $match)) {\n\t\t\tif (preg_last_error()) {\n\t\t\t\tthrow new RegexpException(null, preg_last_error());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif ($match['name'] === '') {\n\t\t\t$match['name'] = $match['shortname'] ?: ($match['closing'] ? '' : '=');\n\t\t}\n\t\treturn [$match['name'], trim($match['args']), $match['modifiers'], (bool) $match['empty'], (bool) $match['closing']];\n\t}\n\n\n\tprivate function addToken(string $type, string $text): Token\n\t{\n\t\t$this->output[] = $token = new Token;\n\t\t$token->type = $type;\n\t\t$token->text = $text;\n\t\t$token->line = $this->line;\n\t\t$this->line += substr_count($text, \"\\n\");\n\t\treturn $token;\n\t}\n\n\n\tpublic function getLine(): int\n\t{\n\t\treturn $this->line;\n\t}\n\n\n\t/**\n\t * Process low-level macros.\n\t */\n\tprotected function filter(Token $token): void\n\t{\n\t\tif ($token->type === Token::MACRO_TAG && $token->name === '/syntax') {\n\t\t\t$this->setSyntax($this->defaultSyntax);\n\t\t\t$token->type = Token::COMMENT;\n\n\t\t} elseif ($token->type === Token::MACRO_TAG && $token->name === 'syntax') {\n\t\t\t$this->setSyntax($token->value);\n\t\t\t$token->type = Token::COMMENT;\n\n\t\t} elseif ($token->type === Token::HTML_ATTRIBUTE_BEGIN && $token->name === 'n:syntax') {\n\t\t\t$this->setSyntax($token->value);\n\t\t\t$this->syntaxEndTag = $this->lastHtmlTag;\n\t\t\t$this->syntaxEndLevel = 1;\n\t\t\t$token->type = Token::COMMENT;\n\n\t\t} elseif ($token->type === Token::HTML_TAG_BEGIN && $this->lastHtmlTag === $this->syntaxEndTag) {\n\t\t\t$this->syntaxEndLevel++;\n\n\t\t} elseif (\n\t\t\t$token->type === Token::HTML_TAG_END\n\t\t\t&& $this->lastHtmlTag === ('/' . $this->syntaxEndTag)\n\t\t\t&& --$this->syntaxEndLevel === 0\n\t\t) {\n\t\t\t$this->setSyntax($this->defaultSyntax);\n\n\t\t} elseif ($token->type === Token::MACRO_TAG && $token->name === 'contentType') {\n\t\t\tif (strpos($token->value, 'html') !== false) {\n\t\t\t\t$this->setContentType(self::CONTENT_HTML);\n\t\t\t} elseif (strpos($token->value, 'xml') !== false) {\n\t\t\t\t$this->setContentType(self::CONTENT_XML);\n\t\t\t} else {\n\t\t\t\t$this->setContentType(self::CONTENT_TEXT);\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * Test: Latte\\Parser errors.\n */\n\ndeclare(strict_types=1);\n\nuse Latte\\Parser;\nuse Tester\\Assert;\n\n\nrequire __DIR__ . '/../bootstrap.php';\n\n\ntest('', function () {\n\t$parser = new Parser;\n\t$parser->parse(\"\\n{a}\");\n\t$parser->parse('');\n\tAssert::same(1, $parser->getLine());\n});\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\\xA0\\xA0\");\n}, InvalidArgumentException::class, 'Template is not valid UTF-8 stream.');\nAssert::same(1, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\u017elu\u0165ou\u010dk\u00fd\\n\\xA0\\xA0\");\n}, InvalidArgumentException::class, 'Template is not valid UTF-8 stream.');\nAssert::same(2, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"{var \\n'abc}\");\n}, Latte\\CompileException::class, 'Malformed tag contents.');\nAssert::same(1, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\\n{* \\n'abc}\");\n}, Latte\\CompileException::class, 'Malformed tag contents.');\nAssert::same(2, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse('{');\n}, Latte\\CompileException::class, 'Malformed tag.');\nAssert::same(1, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\\n{\");\n}, Latte\\CompileException::class, 'Malformed tag.');\nAssert::same(2, $parser->getLine());\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of the Latte (https://latte.nette.org)\n * Copyright (c) 2008 David Grudl (https://davidgrudl.com)\n */\n\ndeclare(strict_types=1);\n\nnamespace Latte;\n\n\n/**\n * Latte parser.\n */\nclass Parser\n{\n\tuse Strict;\n\n\t/** @internal regular expression for single & double quoted PHP string */\n\tpublic const RE_STRING = '\\'(?:\\\\\\\\.|[^\\'\\\\\\\\])*+\\'|\"(?:\\\\\\\\.|[^\"\\\\\\\\])*+\"';\n\n\t/** @internal HTML tag name for Latte needs (actually is [a-zA-Z][^\\s/>]*) */\n\tpublic const RE_TAG_NAME = '[a-zA-Z][a-zA-Z0-9:_.-]*';\n\n\t/** @internal special HTML attribute prefix */\n\tpublic const N_PREFIX = 'n:';\n\n\t/** Context-aware escaping content types */\n\tpublic const\n\t\tCONTENT_HTML = Engine::CONTENT_HTML,\n\t\tCONTENT_XHTML = Engine::CONTENT_XHTML,\n\t\tCONTENT_XML = Engine::CONTENT_XML,\n\t\tCONTENT_TEXT = Engine::CONTENT_TEXT;\n\n\t/** @internal states */\n\tpublic const\n\t\tCONTEXT_NONE = 'none',\n\t\tCONTEXT_MACRO = 'macro',\n\t\tCONTEXT_HTML_TEXT = 'htmlText',\n\t\tCONTEXT_HTML_TAG = 'htmlTag',\n\t\tCONTEXT_HTML_ATTRIBUTE = 'htmlAttribute',\n\t\tCONTEXT_HTML_COMMENT = 'htmlComment',\n\t\tCONTEXT_HTML_CDATA = 'htmlCData';\n\n\t/** @var string default macro tag syntax */\n\tpublic $defaultSyntax = 'latte';\n\n\t/** @var array<string, array{string, string}> */\n\tpublic $syntaxes = [\n\t\t'latte' => ['\\{(?![\\s\\'\"{}])', '\\}'], // {...}\n\t\t'double' => ['\\{\\{(?![\\s\\'\"{}])', '\\}\\}'], // {{...}}\n\t\t'off' => ['\\{(?=/syntax\\})', '\\}'], // {/syntax}\n\t];\n\n\t/** @var string[] */\n\tprivate $delimiters;\n\n\t/** @var string source template */\n\tprivate $input;\n\n\t/** @var Token[] */\n\tprivate $output;\n\n\t/** @var int  position on source template */\n\tprivate $offset;\n\n\t/** @var int */\n\tprivate $line;\n\n\t/** @var array{string, mixed} */\n\tprivate $context = [self::CONTEXT_HTML_TEXT, null];\n\n\t/** @var string|null */\n\tprivate $lastHtmlTag;\n\n\t/** @var string|null used by filter() */\n\tprivate $syntaxEndTag;\n\n\t/** @var int */\n\tprivate $syntaxEndLevel = 0;\n\n\t/** @var bool */\n\tprivate $xmlMode;\n\n\n\t/**\n\t * Process all {macros} and <tags/>.\n\t * @return Token[]\n\t */\n\tpublic function parse(string $input): array\n\t{\n\t\tif (Helpers::startsWith($input, \"\\u{FEFF}\")) { // BOM\n\t\t\t$input = substr($input, 3);\n\t\t}\n\n\t\tif (preg_match('#[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]#', $input, $m, PREG_OFFSET_CAPTURE)) {\n\t\t\ttrigger_error('Template contains control character \\x' . dechex(ord($m[0][0])) . ' on line ' . (substr_count($input, \"\\n\", 0, $m[0][1]) + 1) . '.', E_USER_WARNING);\n\t\t\t$input = preg_replace('#[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]#', '', $input);\n\t\t}\n\n\t\t$this->input = $input = str_replace(\"\\r\\n\", \"\\n\", $input);\n\t\t$this->offset = 0;\n\t\t$this->line = 1;\n\t\t$this->output = [];\n\n\t\tif (!preg_match('##u', $input)) {\n\t\t\tpreg_match('#(?:[\\x00-\\x7F]|[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3})*+#A', $input, $m);\n\t\t\t$this->line += substr_count($m[0], \"\\n\");\n\t\t\tthrow new \\InvalidArgumentException('Template is not valid UTF-8 stream.');\n\t\t}\n\n\t\t$this->setSyntax($this->defaultSyntax);\n\t\t$this->lastHtmlTag = $this->syntaxEndTag = null;\n\n\t\t$tokenCount = 0;\n\t\twhile ($this->offset < strlen($input)) {\n\t\t\tif ($this->{'context' . $this->context[0]}() === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile ($tokenCount < count($this->output)) {\n\t\t\t\t$this->filter($this->output[$tokenCount++]);\n\t\t\t}\n\t\t}\n\t\tif ($this->context[0] === self::CONTEXT_MACRO) {\n\t\t\tthrow new CompileException('Malformed tag.');\n\t\t}\n\n\t\tif ($this->offset < strlen($input)) {\n\t\t\t$this->addToken(Token::TEXT, substr($this->input, $this->offset));\n\t\t}\n\t\treturn $this->output;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_TEXT.\n\t */\n\tprivate function contextHtmlText(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?:(?<=\\n|^)[ \\t]*)?<(?P<closing>/?)(?P<tag>' . self::RE_TAG_NAME . ')|  ##  begin of HTML tag <tag </tag - ignores <!DOCTYPE\n\t\t\t<(?P<htmlcomment>!(?:--(?!>))?|\\?)|     ##  begin of <!, <!--, <!DOCTYPE, <?\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (!empty($matches['htmlcomment'])) { // <! <?\n\t\t\t$this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);\n\t\t\t$end = $matches['htmlcomment'] === '!--'\n\t\t\t\t? '--'\n\t\t\t\t: ($matches['htmlcomment'] === '?' && $this->xmlMode ? '\\?' : '');\n\t\t\t$this->setContext(self::CONTEXT_HTML_COMMENT, $end);\n\t\t\treturn true;\n\n\t\t} elseif (!empty($matches['tag'])) { // <tag or </tag\n\t\t\t$token = $this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);\n\t\t\t$token->name = $matches['tag'];\n\t\t\t$token->closing = (bool) $matches['closing'];\n\t\t\t$this->lastHtmlTag = $matches['closing'] . strtolower($matches['tag']);\n\t\t\t$this->setContext(self::CONTEXT_HTML_TAG);\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_CDATA.\n\t */\n\tprivate function contextHtmlCData(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t</(?P<tag>' . $this->lastHtmlTag . ')(?=[\\s/>])| ##  end HTML tag </tag\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (empty($matches['tag'])) {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t\t// </tag\n\t\t$token = $this->addToken(Token::HTML_TAG_BEGIN, $matches[0]);\n\t\t$token->name = $this->lastHtmlTag;\n\t\t$token->closing = true;\n\t\t$this->lastHtmlTag = '/' . $this->lastHtmlTag;\n\t\t$this->setContext(self::CONTEXT_HTML_TAG);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_TAG.\n\t */\n\tprivate function contextHtmlTag(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<end>\\s?/?>)([ \\t]*\\n)?|  ##  end of HTML tag\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')|\n\t\t\t\\s*(?P<attr>[^\\s\"\\'>/={]+)(?:\\s*=\\s*(?P<value>[\"\\']|[^\\s\"\\'=<>`{]+))? ## beginning of HTML attribute\n\t\t~xsi');\n\n\t\tif (!empty($matches['end'])) { // end of HTML tag />\n\t\t\t$this->addToken(Token::HTML_TAG_END, $matches[0]);\n\t\t\t$empty = strpos($matches[0], '/') !== false;\n\t\t\t$this->setContext(!$this->xmlMode && !$empty && in_array($this->lastHtmlTag, ['script', 'style'], true) ? self::CONTEXT_HTML_CDATA : self::CONTEXT_HTML_TEXT);\n\t\t\treturn true;\n\n\t\t} elseif (isset($matches['attr']) && $matches['attr'] !== '') { // HTML attribute\n\t\t\t$token = $this->addToken(Token::HTML_ATTRIBUTE_BEGIN, $matches[0]);\n\t\t\t$token->name = $matches['attr'];\n\t\t\t$token->value = $matches['value'] ?? '';\n\n\t\t\tif ($token->value === '\"' || $token->value === \"'\") { // attribute = \"'\n\t\t\t\tif (Helpers::startsWith($token->name, self::N_PREFIX)) {\n\t\t\t\t\t$token->value = '';\n\t\t\t\t\tif ($m = $this->match('~(.*?)' . $matches['value'] . '~xsi')) {\n\t\t\t\t\t\t$token->value = $m[1];\n\t\t\t\t\t\t$token->text .= $m[0];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$this->setContext(self::CONTEXT_HTML_ATTRIBUTE, $matches['value']);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_ATTRIBUTE.\n\t */\n\tprivate function contextHtmlAttribute(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<quote>' . $this->context[1] . ')|  ##  end of HTML attribute\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (empty($matches['quote'])) {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t\t// (attribute end) '\"\n\t\t$this->addToken(Token::HTML_ATTRIBUTE_END, $matches[0]);\n\t\t$this->setContext(self::CONTEXT_HTML_TAG);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_HTML_COMMENT.\n\t */\n\tprivate function contextHtmlComment(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<htmlcomment>' . $this->context[1] . '>)|   ##  end of HTML comment\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\n\t\tif (empty($matches['htmlcomment'])) {\n\t\t\treturn $this->processMacro($matches);\n\t\t}\n\t\t// -->\n\t\t$this->addToken(Token::HTML_TAG_END, $matches[0]);\n\t\t$this->setContext(self::CONTEXT_HTML_TEXT);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_NONE.\n\t */\n\tprivate function contextNone(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<macro>' . $this->delimiters[0] . ')\n\t\t~xsi');\n\t\treturn $this->processMacro($matches);\n\t}\n\n\n\t/**\n\t * Handles CONTEXT_MACRO.\n\t */\n\tprivate function contextMacro(): bool\n\t{\n\t\t$matches = $this->match('~\n\t\t\t(?P<comment>\\*.*?\\*' . $this->delimiters[1] . '\\n{0,2})|\n\t\t\t(?P<macro>(?>\n\t\t\t\t' . self::RE_STRING . '|\n\t\t\t\t\\{(?>' . self::RE_STRING . '|[^\\'\"{}])*+\\}|\n\t\t\t\t[^\\'\"{}]+\n\t\t\t)++)\n\t\t\t' . $this->delimiters[1] . '\n\t\t\t(?P<rmargin>[ \\t]*(?=\\n))?\n\t\t~xsiA');\n\n\t\tif (!empty($matches['macro'])) {\n\t\t\t$token = $this->addToken(Token::MACRO_TAG, $this->context[1][1] . $matches[0]);\n\t\t\t[$token->name, $token->value, $token->modifiers, $token->empty, $token->closing] = $this->parseMacroTag($matches['macro']);\n\t\t\t$this->context = $this->context[1][0];\n\t\t\treturn true;\n\n\t\t} elseif (!empty($matches['comment'])) {\n\t\t\t$this->addToken(Token::COMMENT, $this->context[1][1] . $matches[0]);\n\t\t\t$this->context = $this->context[1][0];\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthrow new CompileException('Malformed tag contents.');\n\t\t}\n\t}\n\n\n\t/**\n\t * @param  string[]  $matches\n\t */\n\tprivate function processMacro(array $matches): bool\n\t{\n\t\tif (empty($matches['macro'])) {\n\t\t\treturn false;\n\t\t}\n\t\t// {macro} or {* *}\n\t\t$this->setContext(self::CONTEXT_MACRO, [$this->context, $matches['macro']]);\n\t\treturn true;\n\t}\n\n\n\t/**\n\t * Matches next token.\n\t * @return string[]\n\t */\n\tprivate function match(string $re): array\n\t{\n\t\tif (!preg_match($re, $this->input, $matches, PREG_OFFSET_CAPTURE, $this->offset)) {\n\t\t\tif (preg_last_error()) {\n\t\t\t\tthrow new RegexpException(null, preg_last_error());\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\t$value = substr($this->input, $this->offset, $matches[0][1] - $this->offset);\n\t\tif ($value !== '') {\n\t\t\t$this->addToken(Token::TEXT, $value);\n\t\t}\n\t\t$this->offset = $matches[0][1] + strlen($matches[0][0]);\n\t\tforeach ($matches as $k => $v) {\n\t\t\t$matches[$k] = $v[0];\n\t\t}\n\t\treturn $matches;\n\t}\n\n\n\t/**\n\t * @param  string  $type  Parser::CONTENT_HTML, CONTENT_XHTML, CONTENT_XML or CONTENT_TEXT\n\t * @return static\n\t */\n\tpublic function setContentType(string $type)\n\t{\n\t\tif (in_array($type, [self::CONTENT_HTML, self::CONTENT_XHTML, self::CONTENT_XML], true)) {\n\t\t\t$this->setContext(self::CONTEXT_HTML_TEXT);\n\t\t\t$this->xmlMode = $type === self::CONTENT_XML;\n\t\t} else {\n\t\t\t$this->setContext(self::CONTEXT_NONE);\n\t\t}\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * @param  mixed  $quote\n\t * @return static\n\t */\n\tpublic function setContext(string $context, $quote = null)\n\t{\n\t\t$this->context = [$context, $quote];\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * Changes macro tag delimiters.\n\t * @return static\n\t */\n\tpublic function setSyntax(string $type)\n\t{\n\t\t$type = $type ?: $this->defaultSyntax;\n\t\tif (!isset($this->syntaxes[$type])) {\n\t\t\tthrow new \\InvalidArgumentException(\"Unknown syntax '$type'\");\n\t\t}\n\n\t\t$this->setDelimiters($this->syntaxes[$type][0], $this->syntaxes[$type][1]);\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * Changes macro tag delimiters (as regular expression).\n\t * @return static\n\t */\n\tpublic function setDelimiters(string $left, string $right)\n\t{\n\t\t$this->delimiters = [$left, $right];\n\t\treturn $this;\n\t}\n\n\n\t/**\n\t * Parses macro tag to name, arguments a modifiers parts.\n\t * @param  string  $tag  {name arguments | modifiers}\n\t * @return array{string, string, string, bool, bool}|null\n\t * @internal\n\t */\n\tpublic function parseMacroTag(string $tag): ?array\n\t{\n\t\tif (!preg_match('~^\n\t\t\t(?P<closing>/?)\n\t\t\t(\n\t\t\t\t(?P<name>\\?|[a-z]\\w*+(?:[.:-]\\w+)*+(?!::|\\(|\\\\\\\\))|   ## ?, name, /name, but not function( or class:: or namespace\\\n\t\t\t\t(?P<shortname>=|_(?!_)|)      ## expression, =expression, ...\n\t\t\t)(?P<args>(?:' . self::RE_STRING . '|[^\\'\"])*?)\n\t\t\t(?P<modifiers>(?<!\\|)\\|[a-z](?P<modArgs>(?:' . self::RE_STRING . '|(?:\\((?P>modArgs)\\))|[^\\'\"/()]|/(?=.))*+))?\n\t\t\t(?P<empty>/?$)\n\t\t()$~Disx', $tag, $match)) {\n\t\t\tif (preg_last_error()) {\n\t\t\t\tthrow new RegexpException(null, preg_last_error());\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif ($match['name'] === '') {\n\t\t\t$match['name'] = $match['shortname'] ?: ($match['closing'] ? '' : '=');\n\t\t}\n\t\treturn [$match['name'], trim($match['args']), $match['modifiers'], (bool) $match['empty'], (bool) $match['closing']];\n\t}\n\n\n\tprivate function addToken(string $type, string $text): Token\n\t{\n\t\t$this->output[] = $token = new Token;\n\t\t$token->type = $type;\n\t\t$token->text = $text;\n\t\t$token->line = $this->line;\n\t\t$this->line += substr_count($text, \"\\n\");\n\t\treturn $token;\n\t}\n\n\n\tpublic function getLine(): int\n\t{\n\t\treturn $this->line;\n\t}\n\n\n\t/**\n\t * Process low-level macros.\n\t */\n\tprotected function filter(Token $token): void\n\t{\n\t\tif ($token->type === Token::MACRO_TAG && $token->name === '/syntax') {\n\t\t\t$this->setSyntax($this->defaultSyntax);\n\t\t\t$token->type = Token::COMMENT;\n\n\t\t} elseif ($token->type === Token::MACRO_TAG && $token->name === 'syntax') {\n\t\t\t$this->setSyntax($token->value);\n\t\t\t$token->type = Token::COMMENT;\n\n\t\t} elseif ($token->type === Token::HTML_ATTRIBUTE_BEGIN && $token->name === 'n:syntax') {\n\t\t\t$this->setSyntax($token->value);\n\t\t\t$this->syntaxEndTag = $this->lastHtmlTag;\n\t\t\t$this->syntaxEndLevel = 1;\n\t\t\t$token->type = Token::COMMENT;\n\n\t\t} elseif ($token->type === Token::HTML_TAG_BEGIN && $this->lastHtmlTag === $this->syntaxEndTag) {\n\t\t\t$this->syntaxEndLevel++;\n\n\t\t} elseif (\n\t\t\t$token->type === Token::HTML_TAG_END\n\t\t\t&& $this->lastHtmlTag === ('/' . $this->syntaxEndTag)\n\t\t\t&& --$this->syntaxEndLevel === 0\n\t\t) {\n\t\t\t$this->setSyntax($this->defaultSyntax);\n\n\t\t} elseif ($token->type === Token::MACRO_TAG && $token->name === 'contentType') {\n\t\t\tif (strpos($token->value, 'html') !== false) {\n\t\t\t\t$this->setContentType(self::CONTENT_HTML);\n\t\t\t} elseif (strpos($token->value, 'xml') !== false) {\n\t\t\t\t$this->setContentType(self::CONTENT_XML);\n\t\t\t} else {\n\t\t\t\t$this->setContentType(self::CONTENT_TEXT);\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * Test: Latte\\Parser errors.\n */\n\ndeclare(strict_types=1);\n\nuse Latte\\Parser;\nuse Tester\\Assert;\n\n\nrequire __DIR__ . '/../bootstrap.php';\n\n\ntest('', function () {\n\t$parser = new Parser;\n\t$parser->parse(\"\\n{a}\");\n\t$parser->parse('');\n\tAssert::same(1, $parser->getLine());\n});\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\\xA0\\xA0\");\n}, InvalidArgumentException::class, 'Template is not valid UTF-8 stream.');\nAssert::same(1, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\u017elu\u0165ou\u010dk\u00fd\\n\\xA0\\xA0\");\n}, InvalidArgumentException::class, 'Template is not valid UTF-8 stream.');\nAssert::same(2, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"{var \\n'abc}\");\n}, Latte\\CompileException::class, 'Malformed tag contents.');\nAssert::same(1, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\\n{* \\n'abc}\");\n}, Latte\\CompileException::class, 'Malformed tag contents.');\nAssert::same(2, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse('{');\n}, Latte\\CompileException::class, 'Malformed tag.');\nAssert::same(1, $parser->getLine());\n\n\nAssert::exception(function () use (&$parser) {\n\t$parser = new Parser;\n\t$parser->parse(\"\\n{\");\n}, Latte\\CompileException::class, 'Malformed tag.');\nAssert::same(2, $parser->getLine());\n\n\nAssert::error(function () use (&$res) {\n\t$parser = new Parser;\n\t$res = $parser->parse(\"a\\x00\\x1F\\x7Fb\");\n}, E_USER_WARNING, 'Template contains control character \\x0 on line 1.');\nAssert::same('ab', $res[0]->text);\n"], "filenames": ["src/Latte/Compiler/Parser.php", "tests/Latte/Parser.errors.phpt"], "buggy_code_start_loc": [94, 62], "buggy_code_end_loc": [94, 62], "fixing_code_start_loc": [95, 63], "fixing_code_end_loc": [100, 70], "type": "CWE-863", "message": "This affects the package latte/latte before 2.10.6. There is a way to bypass allowFunctions that will affect the security of the application. When the template is set to allow/disallow the use of certain functions, adding control characters (x00-x08) after the function will bypass these restrictions.", "other": {"cve": {"id": "CVE-2021-23803", "sourceIdentifier": "report@snyk.io", "published": "2021-12-17T20:15:08.287", "lastModified": "2021-12-27T19:33:59.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package latte/latte before 2.10.6. There is a way to bypass allowFunctions that will affect the security of the application. When the template is set to allow/disallow the use of certain functions, adding control characters (x00-x08) after the function will bypass these restrictions."}, {"lang": "es", "value": "Esto afecta al paquete latte/latte versiones anteriores a 2.10.6. Se presenta una forma de omitir allowFunctions que afectar\u00e1 a la seguridad de la aplicaci\u00f3n. Cuando la plantilla est\u00e1 configurada para permitir/no permitir el uso de determinadas funciones, a\u00f1adir caracteres de control (x00-x08) despu\u00e9s de la funci\u00f3n omitir\u00e1 estas restricciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nette:latte:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.10.6", "matchCriteriaId": "00AE17FB-69B0-4BCB-AD34-D90B054D01A3"}]}]}], "references": [{"url": "https://github.com/nette/latte/commit/227c86eda9a8a6d060ea8501923e768b6d992210", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nette/latte/issues/279", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-PHP-LATTELATTE-1932226", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nette/latte/commit/227c86eda9a8a6d060ea8501923e768b6d992210"}}