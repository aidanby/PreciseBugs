{"buggy_code": ["/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.remote;\n\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.domain.JobResult;\nimport com.thoughtworks.go.domain.JobState;\nimport com.thoughtworks.go.server.service.AgentRuntimeInfo;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport org.springframework.remoting.support.RemoteInvocationResult;\nimport org.springframework.web.util.NestedServletException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport static java.lang.String.format;\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n\n/**\n * Custom invoker service exporter that validates UUID authorization on agent requests. This prevents compromised agents\n * (or any other attack masquerading as an authenticated agent) from acting on behalf of another agent.\n */\npublic class AgentRemoteInvokerServiceExporter extends HttpInvokerServiceExporter {\n    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(AgentRemoteInvokerServiceExporter.class);\n    private static final Set<MethodSignature> KNOWN_METHODS_NEEDING_UUID_VALIDATION = Set.of(\n            new MethodSignature(\"ping\", AgentRuntimeInfo.class),\n            new MethodSignature(\"getWork\", AgentRuntimeInfo.class),\n            new MethodSignature(\"reportCurrentStatus\", AgentRuntimeInfo.class, JobIdentifier.class, JobState.class),\n            new MethodSignature(\"reportCompleting\", AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class),\n            new MethodSignature(\"reportCompleted\", AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class),\n            new MethodSignature(\"isIgnored\", AgentRuntimeInfo.class, JobIdentifier.class),\n            new MethodSignature(\"getCookie\", AgentRuntimeInfo.class)\n    );\n\n    @Override\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            RemoteInvocation invocation = readRemoteInvocation(request);\n\n            if (!authorized(request, response, invocation)) {\n                return;\n            }\n\n            RemoteInvocationResult result = invokeAndCreateResult(invocation, getProxy());\n            writeRemoteInvocationResult(request, response, result);\n        } catch (ClassNotFoundException ex) {\n            throw new NestedServletException(\"Class not found during deserialization\", ex);\n        }\n    }\n\n    /**\n     * Verifies that the agent UUID from the deserialized payload matches the UUID permitted by the agent authentication\n     * filter.\n     *\n     * @param request    the {@link HttpServletRequest}\n     * @param response   the {@link HttpServletResponse}\n     * @param invocation the deserialized {@link RemoteInvocation} payload\n     * @return true if authorized; false otherwise\n     * @throws IOException on error while writing a response back to the client\n     */\n    private boolean authorized(HttpServletRequest request, HttpServletResponse response, RemoteInvocation invocation) throws IOException {\n        final String uuid = request.getHeader(\"X-Agent-GUID\"); // should never be null since we passed the auth filter\n        final MethodSignature current = new MethodSignature(invocation);\n\n        LOG.debug(format(\"Checking authorization for agent [%s] on invocation: %s\", uuid, invocation));\n\n        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.contains(current)) {\n            final String askingFor = AgentUUID.fromRuntimeInfo0(invocation.getArguments());\n\n            if (!uuid.equals(askingFor)) {\n                LOG.error(format(\"DENYING REQUEST: Agent [%s] is attempting a request on behalf of [%s]: %s\", uuid, askingFor, invocation));\n                reject(response, SC_FORBIDDEN, \"Not allowing request on behalf of another agent\");\n                return false;\n            }\n        } else {\n            LOG.error(format(\"DENYING REQUEST: Agent [%s] is requesting an unknown method invocation: %s\", uuid, invocation));\n            reject(response, SC_BAD_REQUEST, format(\"Unknown invocation: %s\", invocation));\n            return false;\n        }\n\n        LOG.debug(format(\"ALLOWING REQUEST: Agent [%s] is authorized to invoke: %s\", uuid, invocation));\n        return true;\n    }\n\n    /**\n     * Returns a plaintext error response back to the agent on failure\n     *\n     * @param response   the {@link HttpServletResponse}\n     * @param statusCode the HTTP status code\n     * @param msg        the error message\n     * @throws IOException on error while writing a response back to the client\n     */\n    private void reject(HttpServletResponse response, int statusCode, String msg) throws IOException {\n        response.setStatus(statusCode);\n        response.setContentType(\"text/plain\");\n        final PrintWriter writer = response.getWriter();\n        writer.println(msg);\n        writer.flush();\n        writer.close();\n    }\n\n    /**\n     * Just a container class to hold functions to extract the agent UUID from deserialized payloads\n     */\n    private static class AgentUUID {\n        private static String fromRuntimeInfo0(Object[] args) {\n            return ((AgentRuntimeInfo) args[0]).getIdentifier().getUuid();\n        }\n    }\n\n    /**\n     * Helper class to make RMI method matching easier\n     */\n    private static class MethodSignature {\n        private final String name;\n        private final Class<?>[] paramTypes;\n\n        private MethodSignature(RemoteInvocation invocation) {\n            this(invocation.getMethodName(), invocation.getParameterTypes());\n        }\n\n        private MethodSignature(String name, Class<?>... paramTypes) {\n            this.name = name;\n            this.paramTypes = paramTypes;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            MethodSignature that = (MethodSignature) o;\n            return Objects.equals(name, that.name) && Arrays.equals(paramTypes, that.paramTypes);\n        }\n\n        @Override\n        public int hashCode() {\n            int result = Objects.hash(name);\n            result = 31 * result + Arrays.hashCode(paramTypes);\n            return result;\n        }\n    }\n}\n", "/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.remote;\n\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.domain.JobResult;\nimport com.thoughtworks.go.domain.JobState;\nimport com.thoughtworks.go.http.mocks.MockHttpServletRequest;\nimport com.thoughtworks.go.http.mocks.MockHttpServletResponse;\nimport com.thoughtworks.go.server.messaging.BuildRepositoryMessageProducer;\nimport com.thoughtworks.go.server.service.AgentRuntimeInfo;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport org.springframework.remoting.support.RemoteInvocationResult;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.lang.reflect.InvocationTargetException;\n\nimport static javax.servlet.http.HttpServletResponse.*;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.mockito.Mockito.*;\nimport static org.mockito.MockitoAnnotations.openMocks;\n\npublic class AgentRemoteInvokerServiceExporterTest {\n    private static final String AGENT_UUID = \"123-456-789\";\n\n    private MockHttpServletRequest req;\n\n    private MockHttpServletResponse res;\n\n    @Mock\n    private BuildRepositoryMessageProducer target;\n\n    @BeforeEach\n    void setup() throws Exception {\n        openMocks(this).close();\n        req = new MockHttpServletRequest();\n        req.addHeader(\"X-Agent-GUID\", AGENT_UUID);\n        res = new MockHttpServletResponse();\n    }\n\n    @Test\n    void isIgnored_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"isIgnored\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class}, new Object[]{agent, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, only()).isIgnored(agent, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void isIgnored_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"isIgnored\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class}, new Object[]{agent, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, never()).isIgnored(any(AgentRuntimeInfo.class), any(JobIdentifier.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void ping_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"ping\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}), target);\n        invoker.handleRequest(req, res);\n        verify(target, only()).ping(agent);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void ping_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"ping\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}), target);\n        invoker.handleRequest(req, res);\n        verify(target, never()).ping(any(AgentRuntimeInfo.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void getWork_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getWork\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}), target);\n        invoker.handleRequest(req, res);\n        verify(target, only()).getWork(agent);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void getWork_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getWork\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}), target);\n        invoker.handleRequest(req, res);\n        verify(target, never()).getWork(any(AgentRuntimeInfo.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void getCookie_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getCookie\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}), target);\n        invoker.handleRequest(req, res);\n        verify(target, only()).getCookie(agent);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void getCookie_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getCookie\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}), target);\n        invoker.handleRequest(req, res);\n        verify(target, never()).getCookie(any(AgentRuntimeInfo.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void reportCurrentStatus_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCurrentStatus\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobState.class}, new Object[]{agent, null, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, only()).reportCurrentStatus(agent, null, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void reportCurrentStatus_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCurrentStatus\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobState.class}, new Object[]{agent, null, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, never()).reportCurrentStatus(any(AgentRuntimeInfo.class), any(JobIdentifier.class), any(JobState.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void reportCompleting_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleting\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, only()).reportCompleting(agent, null, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void reportCompleting_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleting\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, never()).reportCompleting(any(AgentRuntimeInfo.class), any(JobIdentifier.class), any(JobResult.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void reportCompleted_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleted\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, only()).reportCompleted(agent, null, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void reportCompleted_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleted\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}), target);\n        invoker.handleRequest(req, res);\n        verify(target, never()).reportCompleted(any(AgentRuntimeInfo.class), any(JobIdentifier.class), any(JobResult.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void rejectsUnknownMethod() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"nonexistent\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}), target);\n        invoker.handleRequest(req, res);\n        verifyNoInteractions(target);\n        assertEquals(SC_BAD_REQUEST, res.getStatus());\n    }\n\n    private AgentRuntimeInfo runtimeInfo(String uuid) {\n        return new AgentRuntimeInfo(identifier(uuid), null, null, null);\n    }\n\n    private AgentIdentifier identifier(String uuid) {\n        return new AgentIdentifier(null, null, uuid);\n    }\n\n    private static AgentRemoteInvokerServiceExporter deserializingWith(final RemoteInvocation invocation, final BuildRepositoryMessageProducer proxy) {\n        final AgentRemoteInvokerServiceExporter invoker = new AgentRemoteInvokerServiceExporter() {\n            @Override\n            protected Object getProxyForService() {\n                return proxy;\n            }\n\n            @Override\n            protected RemoteInvocation readRemoteInvocation(HttpServletRequest request) {\n                return invocation;\n            }\n\n            @Override\n            protected RemoteInvocationResult invokeAndCreateResult(RemoteInvocation invocation, Object targetObject) {\n                try {\n                    invocation.invoke(targetObject);\n                    return new RemoteInvocationResult(true);\n                } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                    e.printStackTrace();\n                    fail(\"invoke() failed; should never get here. error: \" + e.getMessage());\n                    return new RemoteInvocationResult(false);\n                }\n            }\n\n            @Override\n            protected void writeRemoteInvocationResult(HttpServletRequest request, HttpServletResponse response, RemoteInvocationResult result) {\n                if ((Boolean) result.getValue()) {\n                    response.setStatus(SC_OK);\n                } else {\n                    response.setStatus(SC_INTERNAL_SERVER_ERROR);\n                }\n            }\n        };\n        invoker.prepare();\n        return invoker;\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.remote;\n\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.domain.JobResult;\nimport com.thoughtworks.go.domain.JobState;\nimport com.thoughtworks.go.server.service.AgentRuntimeInfo;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport org.springframework.remoting.support.RemoteInvocationResult;\nimport org.springframework.web.util.NestedServletException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport static com.thoughtworks.go.util.SystemEnvironment.AGENT_EXTRA_PROPERTIES;\nimport static java.lang.String.format;\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * Custom invoker service exporter that validates UUID authorization on agent requests. This prevents compromised agents\n * (or any other attack masquerading as an authenticated agent) from acting on behalf of another agent.\n */\npublic class AgentRemoteInvokerServiceExporter extends HttpInvokerServiceExporter {\n    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(AgentRemoteInvokerServiceExporter.class);\n    private static final Set<MethodSignature> KNOWN_METHODS_NEEDING_UUID_VALIDATION = Set.of(\n            new MethodSignature(\"ping\", AgentRuntimeInfo.class),\n            new MethodSignature(\"getWork\", AgentRuntimeInfo.class),\n            new MethodSignature(\"reportCurrentStatus\", AgentRuntimeInfo.class, JobIdentifier.class, JobState.class),\n            new MethodSignature(\"reportCompleting\", AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class),\n            new MethodSignature(\"reportCompleted\", AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class),\n            new MethodSignature(\"isIgnored\", AgentRuntimeInfo.class, JobIdentifier.class),\n            new MethodSignature(\"getCookie\", AgentRuntimeInfo.class)\n    );\n\n    private final SystemEnvironment env;\n\n    public AgentRemoteInvokerServiceExporter() {\n        this(new SystemEnvironment());\n    }\n\n    public AgentRemoteInvokerServiceExporter(SystemEnvironment env) {\n        this.env = env;\n    }\n\n    @Override\n    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (rejectRMI()) {\n            // yes, ideally, this should be short-circuited in the agent auth filter, but keeping this logic here has\n            // some advantages:\n            //   - it keeps all deprecated RMI logic in one place so it's easier to remove (just remove this class)\n            //   - it's 100% reliable by virtue of its proximity to the RMI invocation code and can't be thwarted by\n            //     some clever URI encoding to circumvent the uri path test that we would need to write at the filter\n            //     level in order to selectively apply this logic to the RMI endpoint and not the JSON API endpoint\n            reject(response, SC_GONE, \"This RMI endpoint is disabled.\");\n            return;\n        }\n\n        try {\n            RemoteInvocation invocation = readRemoteInvocation(request);\n\n            if (!authorized(request, response, invocation)) {\n                return;\n            }\n\n            RemoteInvocationResult result = invokeAndCreateResult(invocation, getProxy());\n            writeRemoteInvocationResult(request, response, result);\n        } catch (ClassNotFoundException ex) {\n            throw new NestedServletException(\"Class not found during deserialization\", ex);\n        }\n    }\n\n    private boolean rejectRMI() {\n        final String props = env.get(AGENT_EXTRA_PROPERTIES).toLowerCase();\n        return !Arrays.asList(props.split(\"\\\\s+\")).contains(\"gocd.agent.remoting.legacy=true\");\n    }\n\n    /**\n     * Verifies that the agent UUID from the deserialized payload matches the UUID permitted by the agent authentication\n     * filter.\n     *\n     * @param request    the {@link HttpServletRequest}\n     * @param response   the {@link HttpServletResponse}\n     * @param invocation the deserialized {@link RemoteInvocation} payload\n     * @return true if authorized; false otherwise\n     * @throws IOException on error while writing a response back to the client\n     */\n    private boolean authorized(HttpServletRequest request, HttpServletResponse response, RemoteInvocation invocation) throws IOException {\n        final String uuid = request.getHeader(\"X-Agent-GUID\"); // should never be null since we passed the auth filter\n        final MethodSignature current = new MethodSignature(invocation);\n\n        LOG.debug(format(\"Checking authorization for agent [%s] on invocation: %s\", uuid, invocation));\n\n        if (KNOWN_METHODS_NEEDING_UUID_VALIDATION.contains(current)) {\n            final String askingFor = AgentUUID.fromRuntimeInfo0(invocation.getArguments());\n\n            if (!uuid.equals(askingFor)) {\n                LOG.error(format(\"DENYING REQUEST: Agent [%s] is attempting a request on behalf of [%s]: %s\", uuid, askingFor, invocation));\n                reject(response, SC_FORBIDDEN, \"Not allowing request on behalf of another agent\");\n                return false;\n            }\n        } else {\n            LOG.error(format(\"DENYING REQUEST: Agent [%s] is requesting an unknown method invocation: %s\", uuid, invocation));\n            reject(response, SC_BAD_REQUEST, format(\"Unknown invocation: %s\", invocation));\n            return false;\n        }\n\n        LOG.debug(format(\"ALLOWING REQUEST: Agent [%s] is authorized to invoke: %s\", uuid, invocation));\n        return true;\n    }\n\n    /**\n     * Returns a plaintext error response back to the agent on failure\n     *\n     * @param response   the {@link HttpServletResponse}\n     * @param statusCode the HTTP status code\n     * @param msg        the error message\n     * @throws IOException on error while writing a response back to the client\n     */\n    private void reject(HttpServletResponse response, int statusCode, String msg) throws IOException {\n        response.setStatus(statusCode);\n        response.setContentType(\"text/plain\");\n        final PrintWriter writer = response.getWriter();\n        writer.println(msg);\n        writer.flush();\n        writer.close();\n    }\n\n    /**\n     * Just a container class to hold functions to extract the agent UUID from deserialized payloads\n     */\n    private static class AgentUUID {\n        private static String fromRuntimeInfo0(Object[] args) {\n            return ((AgentRuntimeInfo) args[0]).getIdentifier().getUuid();\n        }\n    }\n\n    /**\n     * Helper class to make RMI method matching easier\n     */\n    private static class MethodSignature {\n        private final String name;\n        private final Class<?>[] paramTypes;\n\n        private MethodSignature(RemoteInvocation invocation) {\n            this(invocation.getMethodName(), invocation.getParameterTypes());\n        }\n\n        private MethodSignature(String name, Class<?>... paramTypes) {\n            this.name = name;\n            this.paramTypes = paramTypes;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            MethodSignature that = (MethodSignature) o;\n            return Objects.equals(name, that.name) && Arrays.equals(paramTypes, that.paramTypes);\n        }\n\n        @Override\n        public int hashCode() {\n            int result = Objects.hash(name);\n            result = 31 * result + Arrays.hashCode(paramTypes);\n            return result;\n        }\n    }\n}\n", "/*\n * Copyright 2021 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.thoughtworks.go.remote;\n\nimport com.thoughtworks.go.domain.JobIdentifier;\nimport com.thoughtworks.go.domain.JobResult;\nimport com.thoughtworks.go.domain.JobState;\nimport com.thoughtworks.go.http.mocks.MockHttpServletRequest;\nimport com.thoughtworks.go.http.mocks.MockHttpServletResponse;\nimport com.thoughtworks.go.server.messaging.BuildRepositoryMessageProducer;\nimport com.thoughtworks.go.server.service.AgentRuntimeInfo;\nimport com.thoughtworks.go.util.SystemEnvironment;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.springframework.remoting.support.RemoteInvocation;\nimport org.springframework.remoting.support.RemoteInvocationResult;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.lang.reflect.InvocationTargetException;\n\nimport static com.thoughtworks.go.util.SystemEnvironment.AGENT_EXTRA_PROPERTIES;\nimport static javax.servlet.http.HttpServletResponse.*;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.mockito.Mockito.*;\nimport static org.mockito.MockitoAnnotations.openMocks;\n\npublic class AgentRemoteInvokerServiceExporterTest {\n    private static final String AGENT_UUID = \"123-456-789\";\n\n    private MockHttpServletRequest req;\n\n    private MockHttpServletResponse res;\n\n    @Mock\n    private SystemEnvironment env;\n\n    @Mock\n    private BuildRepositoryMessageProducer target;\n\n    @BeforeEach\n    void setup() throws Exception {\n        openMocks(this).close();\n        when(env.get(AGENT_EXTRA_PROPERTIES)).thenReturn(\"gocd.agent.remoting.legacy=true\");\n        req = new MockHttpServletRequest();\n        req.addHeader(\"X-Agent-GUID\", AGENT_UUID);\n        res = new MockHttpServletResponse();\n    }\n\n    @Test\n    void rejectsWhenLegacyDisabled() throws Exception {\n        when(env.get(AGENT_EXTRA_PROPERTIES)).thenReturn(\"\");\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"ping\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).ping(agent);\n        assertEquals(SC_GONE, res.getStatus());\n    }\n\n    @Test\n    void isIgnored_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"isIgnored\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class}, new Object[]{agent, null}));\n        invoker.handleRequest(req, res);\n        verify(target, only()).isIgnored(agent, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void isIgnored_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"isIgnored\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class}, new Object[]{agent, null}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).isIgnored(any(AgentRuntimeInfo.class), any(JobIdentifier.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void ping_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"ping\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verify(target, only()).ping(agent);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void ping_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"ping\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).ping(any(AgentRuntimeInfo.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void getWork_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getWork\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verify(target, only()).getWork(agent);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void getWork_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getWork\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).getWork(any(AgentRuntimeInfo.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void getCookie_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getCookie\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verify(target, only()).getCookie(agent);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void getCookie_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"getCookie\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).getCookie(any(AgentRuntimeInfo.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void reportCurrentStatus_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCurrentStatus\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobState.class}, new Object[]{agent, null, null}));\n        invoker.handleRequest(req, res);\n        verify(target, only()).reportCurrentStatus(agent, null, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void reportCurrentStatus_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCurrentStatus\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobState.class}, new Object[]{agent, null, null}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).reportCurrentStatus(any(AgentRuntimeInfo.class), any(JobIdentifier.class), any(JobState.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void reportCompleting_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleting\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}));\n        invoker.handleRequest(req, res);\n        verify(target, only()).reportCompleting(agent, null, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void reportCompleting_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleting\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).reportCompleting(any(AgentRuntimeInfo.class), any(JobIdentifier.class), any(JobResult.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void reportCompleted_allowedForSameUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleted\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}));\n        invoker.handleRequest(req, res);\n        verify(target, only()).reportCompleted(agent, null, null);\n        assertEquals(SC_OK, res.getStatus());\n    }\n\n    @Test\n    void reportCompleted_rejectedForDifferentUUID() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(\"other\");\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"reportCompleted\", new Class[]{AgentRuntimeInfo.class, JobIdentifier.class, JobResult.class}, new Object[]{agent, null, null}));\n        invoker.handleRequest(req, res);\n        verify(target, never()).reportCompleted(any(AgentRuntimeInfo.class), any(JobIdentifier.class), any(JobResult.class));\n        assertEquals(SC_FORBIDDEN, res.getStatus());\n    }\n\n    @Test\n    void rejectsUnknownMethod() throws Exception {\n        final AgentRuntimeInfo agent = runtimeInfo(AGENT_UUID);\n        final AgentRemoteInvokerServiceExporter invoker = deserializingWith(new RemoteInvocation(\"nonexistent\", new Class[]{AgentRuntimeInfo.class}, new Object[]{agent}));\n        invoker.handleRequest(req, res);\n        verifyNoInteractions(target);\n        assertEquals(SC_BAD_REQUEST, res.getStatus());\n    }\n\n    private AgentRuntimeInfo runtimeInfo(String uuid) {\n        return new AgentRuntimeInfo(identifier(uuid), null, null, null);\n    }\n\n    private AgentIdentifier identifier(String uuid) {\n        return new AgentIdentifier(null, null, uuid);\n    }\n\n    private AgentRemoteInvokerServiceExporter deserializingWith(final RemoteInvocation invocation) {\n        final AgentRemoteInvokerServiceExporter invoker = new AgentRemoteInvokerServiceExporter(env) {\n            @Override\n            protected Object getProxyForService() {\n                return target;\n            }\n\n            @Override\n            protected RemoteInvocation readRemoteInvocation(HttpServletRequest request) {\n                return invocation;\n            }\n\n            @Override\n            protected RemoteInvocationResult invokeAndCreateResult(RemoteInvocation invocation, Object targetObject) {\n                try {\n                    invocation.invoke(targetObject);\n                    return new RemoteInvocationResult(true);\n                } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                    e.printStackTrace();\n                    fail(\"invoke() failed; should never get here. error: \" + e.getMessage());\n                    return new RemoteInvocationResult(false);\n                }\n            }\n\n            @Override\n            protected void writeRemoteInvocationResult(HttpServletRequest request, HttpServletResponse response, RemoteInvocationResult result) {\n                if ((Boolean) result.getValue()) {\n                    response.setStatus(SC_OK);\n                } else {\n                    response.setStatus(SC_INTERNAL_SERVER_ERROR);\n                }\n            }\n        };\n        invoker.prepare();\n        return invoker;\n    }\n}\n"], "filenames": ["server/src/main/java/com/thoughtworks/go/remote/AgentRemoteInvokerServiceExporter.java", "server/src/test-fast/java/com/thoughtworks/go/remote/AgentRemoteInvokerServiceExporterTest.java"], "buggy_code_start_loc": [22, 25], "buggy_code_end_loc": [71, 208], "fixing_code_start_loc": [23, 26], "fixing_code_end_loc": [99, 224], "type": "CWE-502", "message": "GoCD is a continuous delivery server. GoCD helps you automate and streamline the build-test-release cycle for continuous delivery of your product. GoCD versions prior to 21.1.0 are vulnerable to remote code execution on the server from a malicious or compromised agent. The Spring RemoteInvocation endpoint exposed agent communication and allowed deserialization of arbitrary java objects, as well as subsequent remote code execution. Exploitation requires agent-level authentication, thus an attacker would need to either compromise an existing agent, its network communication or register a new agent to practically exploit this vulnerability. This issue is fixed in GoCD version 21.1.0. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-39311", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-14T20:15:16.183", "lastModified": "2022-10-19T17:12:31.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GoCD is a continuous delivery server. GoCD helps you automate and streamline the build-test-release cycle for continuous delivery of your product. GoCD versions prior to 21.1.0 are vulnerable to remote code execution on the server from a malicious or compromised agent. The Spring RemoteInvocation endpoint exposed agent communication and allowed deserialization of arbitrary java objects, as well as subsequent remote code execution. Exploitation requires agent-level authentication, thus an attacker would need to either compromise an existing agent, its network communication or register a new agent to practically exploit this vulnerability. This issue is fixed in GoCD version 21.1.0. There are currently no known workarounds."}, {"lang": "es", "value": "GoCD es un servidor de entrega continua. GoCD le ayuda a automatizar y agilizar el ciclo de construcci\u00f3n-prueba-lanzamiento para la entrega continua de su producto. Las versiones de GoCD anteriores a la 21.1.0 son vulnerables a la ejecuci\u00f3n remota de c\u00f3digo en el servidor desde un agente malicioso o comprometido. El endpoint de Spring RemoteInvocation expon\u00eda la comunicaci\u00f3n con el agente y permit\u00eda la deserializaci\u00f3n de objetos java arbitrarios, as\u00ed como la posterior ejecuci\u00f3n de c\u00f3digo remoto. La explotaci\u00f3n requiere autenticaci\u00f3n a nivel de agente, por lo que un atacante necesitar\u00eda comprometer un agente existente, su comunicaci\u00f3n de red o registrar un nuevo agente para explotar pr\u00e1cticamente esta vulnerabilidad. Este problema ha sido corregido en GoCD versi\u00f3n 21.1.0. Actualmente no se presentan mitigaciones conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thoughtworks:gocd:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.1.0", "matchCriteriaId": "AE600F59-5CB0-4E7F-B58F-16121BF8F61E"}]}]}], "references": [{"url": "https://github.com/gocd/gocd/commit/7b88b70d6f7f429562d5cab49a80ea856e34cdc8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gocd/gocd/security/advisories/GHSA-2hjh-3p3p-8hcm", "source": "security-advisories@github.com", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://www.gocd.org/releases/#21-1-0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gocd/gocd/commit/7b88b70d6f7f429562d5cab49a80ea856e34cdc8"}}