{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n/*\n *  linux/arch/x86_64/entry.S\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 2000, 2001, 2002  Andi Kleen SuSE Labs\n *  Copyright (C) 2000  Pavel Machek <pavel@suse.cz>\n *\n * entry.S contains the system-call and fault low-level handling routines.\n *\n * Some of this is documented in Documentation/x86/entry_64.txt\n *\n * A note on terminology:\n * - iret frame:\tArchitecture defined interrupt frame from SS to RIP\n *\t\t\tat the top of the kernel process stack.\n *\n * Some macro usage:\n * - ENTRY/END:\t\tDefine functions in the symbol table.\n * - TRACE_IRQ_*:\tTrace hardirq state for lock debugging.\n * - idtentry:\t\tDefine exception entry points.\n */\n#include <linux/linkage.h>\n#include <asm/segment.h>\n#include <asm/cache.h>\n#include <asm/errno.h>\n#include <asm/asm-offsets.h>\n#include <asm/msr.h>\n#include <asm/unistd.h>\n#include <asm/thread_info.h>\n#include <asm/hw_irq.h>\n#include <asm/page_types.h>\n#include <asm/irqflags.h>\n#include <asm/paravirt.h>\n#include <asm/percpu.h>\n#include <asm/asm.h>\n#include <asm/smap.h>\n#include <asm/pgtable_types.h>\n#include <asm/export.h>\n#include <asm/frame.h>\n#include <asm/nospec-branch.h>\n#include <linux/err.h>\n\n#include \"calling.h\"\n\n.code64\n.section .entry.text, \"ax\"\n\n#ifdef CONFIG_PARAVIRT\nENTRY(native_usergs_sysret64)\n\tUNWIND_HINT_EMPTY\n\tswapgs\n\tsysretq\nEND(native_usergs_sysret64)\n#endif /* CONFIG_PARAVIRT */\n\n.macro TRACE_IRQS_FLAGS flags:req\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tbt\t$9, \\flags\t\t/* interrupts off? */\n\tjnc\t1f\n\tTRACE_IRQS_ON\n1:\n#endif\n.endm\n\n.macro TRACE_IRQS_IRETQ\n\tTRACE_IRQS_FLAGS EFLAGS(%rsp)\n.endm\n\n/*\n * When dynamic function tracer is enabled it will add a breakpoint\n * to all locations that it is about to modify, sync CPUs, update\n * all the code, sync CPUs, then remove the breakpoints. In this time\n * if lockdep is enabled, it might jump back into the debug handler\n * outside the updating of the IST protection. (TRACE_IRQS_ON/OFF).\n *\n * We need to change the IDT table before calling TRACE_IRQS_ON/OFF to\n * make sure the stack pointer does not get reset back to the top\n * of the debug stack, and instead just reuses the current stack.\n */\n#if defined(CONFIG_DYNAMIC_FTRACE) && defined(CONFIG_TRACE_IRQFLAGS)\n\n.macro TRACE_IRQS_OFF_DEBUG\n\tcall\tdebug_stack_set_zero\n\tTRACE_IRQS_OFF\n\tcall\tdebug_stack_reset\n.endm\n\n.macro TRACE_IRQS_ON_DEBUG\n\tcall\tdebug_stack_set_zero\n\tTRACE_IRQS_ON\n\tcall\tdebug_stack_reset\n.endm\n\n.macro TRACE_IRQS_IRETQ_DEBUG\n\tbt\t$9, EFLAGS(%rsp)\t\t/* interrupts off? */\n\tjnc\t1f\n\tTRACE_IRQS_ON_DEBUG\n1:\n.endm\n\n#else\n# define TRACE_IRQS_OFF_DEBUG\t\t\tTRACE_IRQS_OFF\n# define TRACE_IRQS_ON_DEBUG\t\t\tTRACE_IRQS_ON\n# define TRACE_IRQS_IRETQ_DEBUG\t\t\tTRACE_IRQS_IRETQ\n#endif\n\n/*\n * 64-bit SYSCALL instruction entry. Up to 6 arguments in registers.\n *\n * This is the only entry point used for 64-bit system calls.  The\n * hardware interface is reasonably well designed and the register to\n * argument mapping Linux uses fits well with the registers that are\n * available when SYSCALL is used.\n *\n * SYSCALL instructions can be found inlined in libc implementations as\n * well as some other programs and libraries.  There are also a handful\n * of SYSCALL instructions in the vDSO used, for example, as a\n * clock_gettimeofday fallback.\n *\n * 64-bit SYSCALL saves rip to rcx, clears rflags.RF, then saves rflags to r11,\n * then loads new ss, cs, and rip from previously programmed MSRs.\n * rflags gets masked by a value from another MSR (so CLD and CLAC\n * are not needed). SYSCALL does not save anything on the stack\n * and does not change rsp.\n *\n * Registers on entry:\n * rax  system call number\n * rcx  return address\n * r11  saved rflags (note: r11 is callee-clobbered register in C ABI)\n * rdi  arg0\n * rsi  arg1\n * rdx  arg2\n * r10  arg3 (needs to be moved to rcx to conform to C ABI)\n * r8   arg4\n * r9   arg5\n * (note: r12-r15, rbp, rbx are callee-preserved in C ABI)\n *\n * Only called from user space.\n *\n * When user can change pt_regs->foo always force IRET. That is because\n * it deals with uncanonical addresses better. SYSRET has trouble\n * with them due to bugs in both AMD and Intel CPUs.\n */\n\n\t.pushsection .entry_trampoline, \"ax\"\n\n/*\n * The code in here gets remapped into cpu_entry_area's trampoline.  This means\n * that the assembler and linker have the wrong idea as to where this code\n * lives (and, in fact, it's mapped more than once, so it's not even at a\n * fixed address).  So we can't reference any symbols outside the entry\n * trampoline and expect it to work.\n *\n * Instead, we carefully abuse %rip-relative addressing.\n * _entry_trampoline(%rip) refers to the start of the remapped) entry\n * trampoline.  We can thus find cpu_entry_area with this macro:\n */\n\n#define CPU_ENTRY_AREA \\\n\t_entry_trampoline - CPU_ENTRY_AREA_entry_trampoline(%rip)\n\n/* The top word of the SYSENTER stack is hot and is usable as scratch space. */\n#define RSP_SCRATCH\tCPU_ENTRY_AREA_entry_stack + \\\n\t\t\tSIZEOF_entry_stack - 8 + CPU_ENTRY_AREA\n\nENTRY(entry_SYSCALL_64_trampoline)\n\tUNWIND_HINT_EMPTY\n\tswapgs\n\n\t/* Stash the user RSP. */\n\tmovq\t%rsp, RSP_SCRATCH\n\n\t/* Note: using %rsp as a scratch reg. */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp\n\n\t/* Load the top of the task stack into RSP */\n\tmovq\tCPU_ENTRY_AREA_tss + TSS_sp1 + CPU_ENTRY_AREA, %rsp\n\n\t/* Start building the simulated IRET frame. */\n\tpushq\t$__USER_DS\t\t\t/* pt_regs->ss */\n\tpushq\tRSP_SCRATCH\t\t\t/* pt_regs->sp */\n\tpushq\t%r11\t\t\t\t/* pt_regs->flags */\n\tpushq\t$__USER_CS\t\t\t/* pt_regs->cs */\n\tpushq\t%rcx\t\t\t\t/* pt_regs->ip */\n\n\t/*\n\t * x86 lacks a near absolute jump, and we can't jump to the real\n\t * entry text with a relative jump.  We could push the target\n\t * address and then use retq, but this destroys the pipeline on\n\t * many CPUs (wasting over 20 cycles on Sandy Bridge).  Instead,\n\t * spill RDI and restore it in a second-stage trampoline.\n\t */\n\tpushq\t%rdi\n\tmovq\t$entry_SYSCALL_64_stage2, %rdi\n\tJMP_NOSPEC %rdi\nEND(entry_SYSCALL_64_trampoline)\n\n\t.popsection\n\nENTRY(entry_SYSCALL_64_stage2)\n\tUNWIND_HINT_EMPTY\n\tpopq\t%rdi\n\tjmp\tentry_SYSCALL_64_after_hwframe\nEND(entry_SYSCALL_64_stage2)\n\nENTRY(entry_SYSCALL_64)\n\tUNWIND_HINT_EMPTY\n\t/*\n\t * Interrupts are off on entry.\n\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,\n\t * it is too small to ever cause noticeable irq latency.\n\t */\n\n\tswapgs\n\t/*\n\t * This path is only taken when PAGE_TABLE_ISOLATION is disabled so it\n\t * is not required to switch CR3.\n\t */\n\tmovq\t%rsp, PER_CPU_VAR(rsp_scratch)\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n\t/* Construct struct pt_regs on stack */\n\tpushq\t$__USER_DS\t\t\t/* pt_regs->ss */\n\tpushq\tPER_CPU_VAR(rsp_scratch)\t/* pt_regs->sp */\n\tpushq\t%r11\t\t\t\t/* pt_regs->flags */\n\tpushq\t$__USER_CS\t\t\t/* pt_regs->cs */\n\tpushq\t%rcx\t\t\t\t/* pt_regs->ip */\nGLOBAL(entry_SYSCALL_64_after_hwframe)\n\tpushq\t%rax\t\t\t\t/* pt_regs->orig_ax */\n\n\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS\n\n\tTRACE_IRQS_OFF\n\n\t/* IRQs are off. */\n\tmovq\t%rsp, %rdi\n\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */\n\n\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */\n\n\t/*\n\t * Try to use SYSRET instead of IRET if we're returning to\n\t * a completely clean 64-bit userspace context.  If we're not,\n\t * go to the slow exit path.\n\t */\n\tmovq\tRCX(%rsp), %rcx\n\tmovq\tRIP(%rsp), %r11\n\n\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\t/*\n\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP\n\t * in kernel space.  This essentially lets the user take over\n\t * the kernel, since userspace controls RSP.\n\t *\n\t * If width of \"canonical tail\" ever becomes variable, this will need\n\t * to be updated to remain correct on both old and new CPUs.\n\t *\n\t * Change top bits to match most significant bit (47th or 56th bit\n\t * depending on paging mode) in the address.\n\t */\n\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx\n\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx\n\n\t/* If this changed %rcx, it was not canonical */\n\tcmpq\t%rcx, %r11\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\tmovq\tR11(%rsp), %r11\n\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\t/*\n\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot\n\t * restore RF properly. If the slowpath sets it for whatever reason, we\n\t * need to restore it correctly.\n\t *\n\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a\n\t * trap from userspace immediately after SYSRET.  This would cause an\n\t * infinite loop whenever #DB happens with register state that satisfies\n\t * the opportunistic SYSRET conditions.  For example, single-stepping\n\t * this user code:\n\t *\n\t *           movq\t$stuck_here, %rcx\n\t *           pushfq\n\t *           popq %r11\n\t *   stuck_here:\n\t *\n\t * would never get past 'stuck_here'.\n\t */\n\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11\n\tjnz\tswapgs_restore_regs_and_return_to_usermode\n\n\t/* nothing to check for RSP */\n\n\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\t/*\n\t * We win! This label is here just for ease of understanding\n\t * perf profiles. Nothing jumps here.\n\t */\nsyscall_return_via_sysret:\n\t/* rcx and r11 are already restored (see code above) */\n\tUNWIND_HINT_EMPTY\n\tPOP_REGS pop_rdi=0 skip_r11rcx=1\n\n\t/*\n\t * Now all regs are restored except RSP and RDI.\n\t * Save old stack pointer and switch to trampoline stack.\n\t */\n\tmovq\t%rsp, %rdi\n\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp\n\n\tpushq\tRSP-RDI(%rdi)\t/* RSP */\n\tpushq\t(%rdi)\t\t/* RDI */\n\n\t/*\n\t * We are on the trampoline stack.  All regs except RDI are live.\n\t * We can do future final exit work right here.\n\t */\n\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi\n\n\tpopq\t%rdi\n\tpopq\t%rsp\n\tUSERGS_SYSRET64\nEND(entry_SYSCALL_64)\n\n/*\n * %rdi: prev task\n * %rsi: next task\n */\nENTRY(__switch_to_asm)\n\tUNWIND_HINT_FUNC\n\t/*\n\t * Save callee-saved registers\n\t * This must match the order in inactive_task_frame\n\t */\n\tpushq\t%rbp\n\tpushq\t%rbx\n\tpushq\t%r12\n\tpushq\t%r13\n\tpushq\t%r14\n\tpushq\t%r15\n\n\t/* switch stack */\n\tmovq\t%rsp, TASK_threadsp(%rdi)\n\tmovq\tTASK_threadsp(%rsi), %rsp\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\tmovq\tTASK_stack_canary(%rsi), %rbx\n\tmovq\t%rbx, PER_CPU_VAR(irq_stack_union)+stack_canary_offset\n#endif\n\n#ifdef CONFIG_RETPOLINE\n\t/*\n\t * When switching from a shallower to a deeper call stack\n\t * the RSB may either underflow or use entries populated\n\t * with userspace addresses. On CPUs where those concerns\n\t * exist, overwrite the RSB with entries which capture\n\t * speculative execution to prevent attack.\n\t */\n\tFILL_RETURN_BUFFER %r12, RSB_CLEAR_LOOPS, X86_FEATURE_RSB_CTXSW\n#endif\n\n\t/* restore callee-saved registers */\n\tpopq\t%r15\n\tpopq\t%r14\n\tpopq\t%r13\n\tpopq\t%r12\n\tpopq\t%rbx\n\tpopq\t%rbp\n\n\tjmp\t__switch_to\nEND(__switch_to_asm)\n\n/*\n * A newly forked process directly context switches into this address.\n *\n * rax: prev task we switched from\n * rbx: kernel thread func (NULL for user thread)\n * r12: kernel thread arg\n */\nENTRY(ret_from_fork)\n\tUNWIND_HINT_EMPTY\n\tmovq\t%rax, %rdi\n\tcall\tschedule_tail\t\t\t/* rdi: 'prev' task parameter */\n\n\ttestq\t%rbx, %rbx\t\t\t/* from kernel_thread? */\n\tjnz\t1f\t\t\t\t/* kernel threads are uncommon */\n\n2:\n\tUNWIND_HINT_REGS\n\tmovq\t%rsp, %rdi\n\tcall\tsyscall_return_slowpath\t/* returns with IRQs disabled */\n\tTRACE_IRQS_ON\t\t\t/* user mode is traced as IRQS on */\n\tjmp\tswapgs_restore_regs_and_return_to_usermode\n\n1:\n\t/* kernel thread */\n\tmovq\t%r12, %rdi\n\tCALL_NOSPEC %rbx\n\t/*\n\t * A kernel thread is allowed to return here after successfully\n\t * calling do_execve().  Exit to userspace to complete the execve()\n\t * syscall.\n\t */\n\tmovq\t$0, RAX(%rsp)\n\tjmp\t2b\nEND(ret_from_fork)\n\n/*\n * Build the entry stubs with some assembler magic.\n * We pack 1 stub into every 8-byte block.\n */\n\t.align 8\nENTRY(irq_entries_start)\n    vector=FIRST_EXTERNAL_VECTOR\n    .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)\n\tUNWIND_HINT_IRET_REGS\n\tpushq\t$(~vector+0x80)\t\t\t/* Note: always in signed byte range */\n\tjmp\tcommon_interrupt\n\t.align\t8\n\tvector=vector+1\n    .endr\nEND(irq_entries_start)\n\n.macro DEBUG_ENTRY_ASSERT_IRQS_OFF\n#ifdef CONFIG_DEBUG_ENTRY\n\tpushq %rax\n\tSAVE_FLAGS(CLBR_RAX)\n\ttestl $X86_EFLAGS_IF, %eax\n\tjz .Lokay_\\@\n\tud2\n.Lokay_\\@:\n\tpopq %rax\n#endif\n.endm\n\n/*\n * Enters the IRQ stack if we're not already using it.  NMI-safe.  Clobbers\n * flags and puts old RSP into old_rsp, and leaves all other GPRs alone.\n * Requires kernel GSBASE.\n *\n * The invariant is that, if irq_count != -1, then the IRQ stack is in use.\n */\n.macro ENTER_IRQ_STACK regs=1 old_rsp save_ret=0\n\tDEBUG_ENTRY_ASSERT_IRQS_OFF\n\n\t.if \\save_ret\n\t/*\n\t * If save_ret is set, the original stack contains one additional\n\t * entry -- the return address. Therefore, move the address one\n\t * entry below %rsp to \\old_rsp.\n\t */\n\tleaq\t8(%rsp), \\old_rsp\n\t.else\n\tmovq\t%rsp, \\old_rsp\n\t.endif\n\n\t.if \\regs\n\tUNWIND_HINT_REGS base=\\old_rsp\n\t.endif\n\n\tincl\tPER_CPU_VAR(irq_count)\n\tjnz\t.Lirq_stack_push_old_rsp_\\@\n\n\t/*\n\t * Right now, if we just incremented irq_count to zero, we've\n\t * claimed the IRQ stack but we haven't switched to it yet.\n\t *\n\t * If anything is added that can interrupt us here without using IST,\n\t * it must be *extremely* careful to limit its stack usage.  This\n\t * could include kprobes and a hypothetical future IST-less #DB\n\t * handler.\n\t *\n\t * The OOPS unwinder relies on the word at the top of the IRQ\n\t * stack linking back to the previous RSP for the entire time we're\n\t * on the IRQ stack.  For this to work reliably, we need to write\n\t * it before we actually move ourselves to the IRQ stack.\n\t */\n\n\tmovq\t\\old_rsp, PER_CPU_VAR(irq_stack_union + IRQ_STACK_SIZE - 8)\n\tmovq\tPER_CPU_VAR(irq_stack_ptr), %rsp\n\n#ifdef CONFIG_DEBUG_ENTRY\n\t/*\n\t * If the first movq above becomes wrong due to IRQ stack layout\n\t * changes, the only way we'll notice is if we try to unwind right\n\t * here.  Assert that we set up the stack right to catch this type\n\t * of bug quickly.\n\t */\n\tcmpq\t-8(%rsp), \\old_rsp\n\tje\t.Lirq_stack_okay\\@\n\tud2\n\t.Lirq_stack_okay\\@:\n#endif\n\n.Lirq_stack_push_old_rsp_\\@:\n\tpushq\t\\old_rsp\n\n\t.if \\regs\n\tUNWIND_HINT_REGS indirect=1\n\t.endif\n\n\t.if \\save_ret\n\t/*\n\t * Push the return address to the stack. This return address can\n\t * be found at the \"real\" original RSP, which was offset by 8 at\n\t * the beginning of this macro.\n\t */\n\tpushq\t-8(\\old_rsp)\n\t.endif\n.endm\n\n/*\n * Undoes ENTER_IRQ_STACK.\n */\n.macro LEAVE_IRQ_STACK regs=1\n\tDEBUG_ENTRY_ASSERT_IRQS_OFF\n\t/* We need to be off the IRQ stack before decrementing irq_count. */\n\tpopq\t%rsp\n\n\t.if \\regs\n\tUNWIND_HINT_REGS\n\t.endif\n\n\t/*\n\t * As in ENTER_IRQ_STACK, irq_count == 0, we are still claiming\n\t * the irq stack but we're not on it.\n\t */\n\n\tdecl\tPER_CPU_VAR(irq_count)\n.endm\n\n/*\n * Interrupt entry helper function.\n *\n * Entry runs with interrupts off. Stack layout at entry:\n * +----------------------------------------------------+\n * | regs->ss\t\t\t\t\t\t|\n * | regs->rsp\t\t\t\t\t\t|\n * | regs->eflags\t\t\t\t\t|\n * | regs->cs\t\t\t\t\t\t|\n * | regs->ip\t\t\t\t\t\t|\n * +----------------------------------------------------+\n * | regs->orig_ax = ~(interrupt number)\t\t|\n * +----------------------------------------------------+\n * | return address\t\t\t\t\t|\n * +----------------------------------------------------+\n */\nENTRY(interrupt_entry)\n\tUNWIND_HINT_FUNC\n\tASM_CLAC\n\tcld\n\n\ttestb\t$3, CS-ORIG_RAX+8(%rsp)\n\tjz\t1f\n\tSWAPGS\n\n\t/*\n\t * Switch to the thread stack. The IRET frame and orig_ax are\n\t * on the stack, as well as the return address. RDI..R12 are\n\t * not (yet) on the stack and space has not (yet) been\n\t * allocated for them.\n\t */\n\tpushq\t%rdi\n\n\t/* Need to switch before accessing the thread stack. */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rdi\n\tmovq\t%rsp, %rdi\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n\t /*\n\t  * We have RDI, return address, and orig_ax on the stack on\n\t  * top of the IRET frame. That means offset=24\n\t  */\n\tUNWIND_HINT_IRET_REGS base=%rdi offset=24\n\n\tpushq\t7*8(%rdi)\t\t/* regs->ss */\n\tpushq\t6*8(%rdi)\t\t/* regs->rsp */\n\tpushq\t5*8(%rdi)\t\t/* regs->eflags */\n\tpushq\t4*8(%rdi)\t\t/* regs->cs */\n\tpushq\t3*8(%rdi)\t\t/* regs->ip */\n\tpushq\t2*8(%rdi)\t\t/* regs->orig_ax */\n\tpushq\t8(%rdi)\t\t\t/* return address */\n\tUNWIND_HINT_FUNC\n\n\tmovq\t(%rdi), %rdi\n1:\n\n\tPUSH_AND_CLEAR_REGS save_ret=1\n\tENCODE_FRAME_POINTER 8\n\n\ttestb\t$3, CS+8(%rsp)\n\tjz\t1f\n\n\t/*\n\t * IRQ from user mode.\n\t *\n\t * We need to tell lockdep that IRQs are off.  We can't do this until\n\t * we fix gsbase, and we should do it before enter_from_user_mode\n\t * (which can take locks).  Since TRACE_IRQS_OFF is idempotent,\n\t * the simplest way to handle it is to just call it twice if\n\t * we enter from user mode.  There's no reason to optimize this since\n\t * TRACE_IRQS_OFF is a no-op if lockdep is off.\n\t */\n\tTRACE_IRQS_OFF\n\n\tCALL_enter_from_user_mode\n\n1:\n\tENTER_IRQ_STACK old_rsp=%rdi save_ret=1\n\t/* We entered an interrupt context - irqs are off: */\n\tTRACE_IRQS_OFF\n\n\tret\nEND(interrupt_entry)\n\n\n/* Interrupt entry/exit. */\n\n\t/*\n\t * The interrupt stubs push (~vector+0x80) onto the stack and\n\t * then jump to common_interrupt.\n\t */\n\t.p2align CONFIG_X86_L1_CACHE_SHIFT\ncommon_interrupt:\n\taddq\t$-0x80, (%rsp)\t\t\t/* Adjust vector to [-256, -1] range */\n\tcall\tinterrupt_entry\n\tUNWIND_HINT_REGS indirect=1\n\tcall\tdo_IRQ\t/* rdi points to pt_regs */\n\t/* 0(%rsp): old RSP */\nret_from_intr:\n\tDISABLE_INTERRUPTS(CLBR_ANY)\n\tTRACE_IRQS_OFF\n\n\tLEAVE_IRQ_STACK\n\n\ttestb\t$3, CS(%rsp)\n\tjz\tretint_kernel\n\n\t/* Interrupt came from user space */\nGLOBAL(retint_user)\n\tmov\t%rsp,%rdi\n\tcall\tprepare_exit_to_usermode\n\tTRACE_IRQS_IRETQ\n\nGLOBAL(swapgs_restore_regs_and_return_to_usermode)\n#ifdef CONFIG_DEBUG_ENTRY\n\t/* Assert that pt_regs indicates user mode. */\n\ttestb\t$3, CS(%rsp)\n\tjnz\t1f\n\tud2\n1:\n#endif\n\tPOP_REGS pop_rdi=0\n\n\t/*\n\t * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.\n\t * Save old stack pointer and switch to trampoline stack.\n\t */\n\tmovq\t%rsp, %rdi\n\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp\n\n\t/* Copy the IRET frame to the trampoline stack. */\n\tpushq\t6*8(%rdi)\t/* SS */\n\tpushq\t5*8(%rdi)\t/* RSP */\n\tpushq\t4*8(%rdi)\t/* EFLAGS */\n\tpushq\t3*8(%rdi)\t/* CS */\n\tpushq\t2*8(%rdi)\t/* RIP */\n\n\t/* Push user RDI on the trampoline stack. */\n\tpushq\t(%rdi)\n\n\t/*\n\t * We are on the trampoline stack.  All regs except RDI are live.\n\t * We can do future final exit work right here.\n\t */\n\n\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi\n\n\t/* Restore RDI. */\n\tpopq\t%rdi\n\tSWAPGS\n\tINTERRUPT_RETURN\n\n\n/* Returning to kernel space */\nretint_kernel:\n#ifdef CONFIG_PREEMPT\n\t/* Interrupts are off */\n\t/* Check if we need preemption */\n\tbt\t$9, EFLAGS(%rsp)\t\t/* were interrupts off? */\n\tjnc\t1f\n0:\tcmpl\t$0, PER_CPU_VAR(__preempt_count)\n\tjnz\t1f\n\tcall\tpreempt_schedule_irq\n\tjmp\t0b\n1:\n#endif\n\t/*\n\t * The iretq could re-enable interrupts:\n\t */\n\tTRACE_IRQS_IRETQ\n\nGLOBAL(restore_regs_and_return_to_kernel)\n#ifdef CONFIG_DEBUG_ENTRY\n\t/* Assert that pt_regs indicates kernel mode. */\n\ttestb\t$3, CS(%rsp)\n\tjz\t1f\n\tud2\n1:\n#endif\n\tPOP_REGS\n\taddq\t$8, %rsp\t/* skip regs->orig_ax */\n\t/*\n\t * ARCH_HAS_MEMBARRIER_SYNC_CORE rely on IRET core serialization\n\t * when returning from IPI handler.\n\t */\n\tINTERRUPT_RETURN\n\nENTRY(native_iret)\n\tUNWIND_HINT_IRET_REGS\n\t/*\n\t * Are we returning to a stack segment from the LDT?  Note: in\n\t * 64-bit mode SS:RSP on the exception stack is always valid.\n\t */\n#ifdef CONFIG_X86_ESPFIX64\n\ttestb\t$4, (SS-RIP)(%rsp)\n\tjnz\tnative_irq_return_ldt\n#endif\n\n.global native_irq_return_iret\nnative_irq_return_iret:\n\t/*\n\t * This may fault.  Non-paranoid faults on return to userspace are\n\t * handled by fixup_bad_iret.  These include #SS, #GP, and #NP.\n\t * Double-faults due to espfix64 are handled in do_double_fault.\n\t * Other faults here are fatal.\n\t */\n\tiretq\n\n#ifdef CONFIG_X86_ESPFIX64\nnative_irq_return_ldt:\n\t/*\n\t * We are running with user GSBASE.  All GPRs contain their user\n\t * values.  We have a percpu ESPFIX stack that is eight slots\n\t * long (see ESPFIX_STACK_SIZE).  espfix_waddr points to the bottom\n\t * of the ESPFIX stack.\n\t *\n\t * We clobber RAX and RDI in this code.  We stash RDI on the\n\t * normal stack and RAX on the ESPFIX stack.\n\t *\n\t * The ESPFIX stack layout we set up looks like this:\n\t *\n\t * --- top of ESPFIX stack ---\n\t * SS\n\t * RSP\n\t * RFLAGS\n\t * CS\n\t * RIP  <-- RSP points here when we're done\n\t * RAX  <-- espfix_waddr points here\n\t * --- bottom of ESPFIX stack ---\n\t */\n\n\tpushq\t%rdi\t\t\t\t/* Stash user RDI */\n\tSWAPGS\t\t\t\t\t/* to kernel GS */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rdi\t/* to kernel CR3 */\n\n\tmovq\tPER_CPU_VAR(espfix_waddr), %rdi\n\tmovq\t%rax, (0*8)(%rdi)\t\t/* user RAX */\n\tmovq\t(1*8)(%rsp), %rax\t\t/* user RIP */\n\tmovq\t%rax, (1*8)(%rdi)\n\tmovq\t(2*8)(%rsp), %rax\t\t/* user CS */\n\tmovq\t%rax, (2*8)(%rdi)\n\tmovq\t(3*8)(%rsp), %rax\t\t/* user RFLAGS */\n\tmovq\t%rax, (3*8)(%rdi)\n\tmovq\t(5*8)(%rsp), %rax\t\t/* user SS */\n\tmovq\t%rax, (5*8)(%rdi)\n\tmovq\t(4*8)(%rsp), %rax\t\t/* user RSP */\n\tmovq\t%rax, (4*8)(%rdi)\n\t/* Now RAX == RSP. */\n\n\tandl\t$0xffff0000, %eax\t\t/* RAX = (RSP & 0xffff0000) */\n\n\t/*\n\t * espfix_stack[31:16] == 0.  The page tables are set up such that\n\t * (espfix_stack | (X & 0xffff0000)) points to a read-only alias of\n\t * espfix_waddr for any X.  That is, there are 65536 RO aliases of\n\t * the same page.  Set up RSP so that RSP[31:16] contains the\n\t * respective 16 bits of the /userspace/ RSP and RSP nonetheless\n\t * still points to an RO alias of the ESPFIX stack.\n\t */\n\torq\tPER_CPU_VAR(espfix_stack), %rax\n\n\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi\n\tSWAPGS\t\t\t\t\t/* to user GS */\n\tpopq\t%rdi\t\t\t\t/* Restore user RDI */\n\n\tmovq\t%rax, %rsp\n\tUNWIND_HINT_IRET_REGS offset=8\n\n\t/*\n\t * At this point, we cannot write to the stack any more, but we can\n\t * still read.\n\t */\n\tpopq\t%rax\t\t\t\t/* Restore user RAX */\n\n\t/*\n\t * RSP now points to an ordinary IRET frame, except that the page\n\t * is read-only and RSP[31:16] are preloaded with the userspace\n\t * values.  We can now IRET back to userspace.\n\t */\n\tjmp\tnative_irq_return_iret\n#endif\nEND(common_interrupt)\n\n/*\n * APIC interrupts.\n */\n.macro apicinterrupt3 num sym do_sym\nENTRY(\\sym)\n\tUNWIND_HINT_IRET_REGS\n\tpushq\t$~(\\num)\n.Lcommon_\\sym:\n\tcall\tinterrupt_entry\n\tUNWIND_HINT_REGS indirect=1\n\tcall\t\\do_sym\t/* rdi points to pt_regs */\n\tjmp\tret_from_intr\nEND(\\sym)\n.endm\n\n/* Make sure APIC interrupt handlers end up in the irqentry section: */\n#define PUSH_SECTION_IRQENTRY\t.pushsection .irqentry.text, \"ax\"\n#define POP_SECTION_IRQENTRY\t.popsection\n\n.macro apicinterrupt num sym do_sym\nPUSH_SECTION_IRQENTRY\napicinterrupt3 \\num \\sym \\do_sym\nPOP_SECTION_IRQENTRY\n.endm\n\n#ifdef CONFIG_SMP\napicinterrupt3 IRQ_MOVE_CLEANUP_VECTOR\t\tirq_move_cleanup_interrupt\tsmp_irq_move_cleanup_interrupt\napicinterrupt3 REBOOT_VECTOR\t\t\treboot_interrupt\t\tsmp_reboot_interrupt\n#endif\n\n#ifdef CONFIG_X86_UV\napicinterrupt3 UV_BAU_MESSAGE\t\t\tuv_bau_message_intr1\t\tuv_bau_message_interrupt\n#endif\n\napicinterrupt LOCAL_TIMER_VECTOR\t\tapic_timer_interrupt\t\tsmp_apic_timer_interrupt\napicinterrupt X86_PLATFORM_IPI_VECTOR\t\tx86_platform_ipi\t\tsmp_x86_platform_ipi\n\n#ifdef CONFIG_HAVE_KVM\napicinterrupt3 POSTED_INTR_VECTOR\t\tkvm_posted_intr_ipi\t\tsmp_kvm_posted_intr_ipi\napicinterrupt3 POSTED_INTR_WAKEUP_VECTOR\tkvm_posted_intr_wakeup_ipi\tsmp_kvm_posted_intr_wakeup_ipi\napicinterrupt3 POSTED_INTR_NESTED_VECTOR\tkvm_posted_intr_nested_ipi\tsmp_kvm_posted_intr_nested_ipi\n#endif\n\n#ifdef CONFIG_X86_MCE_THRESHOLD\napicinterrupt THRESHOLD_APIC_VECTOR\t\tthreshold_interrupt\t\tsmp_threshold_interrupt\n#endif\n\n#ifdef CONFIG_X86_MCE_AMD\napicinterrupt DEFERRED_ERROR_VECTOR\t\tdeferred_error_interrupt\tsmp_deferred_error_interrupt\n#endif\n\n#ifdef CONFIG_X86_THERMAL_VECTOR\napicinterrupt THERMAL_APIC_VECTOR\t\tthermal_interrupt\t\tsmp_thermal_interrupt\n#endif\n\n#ifdef CONFIG_SMP\napicinterrupt CALL_FUNCTION_SINGLE_VECTOR\tcall_function_single_interrupt\tsmp_call_function_single_interrupt\napicinterrupt CALL_FUNCTION_VECTOR\t\tcall_function_interrupt\t\tsmp_call_function_interrupt\napicinterrupt RESCHEDULE_VECTOR\t\t\treschedule_interrupt\t\tsmp_reschedule_interrupt\n#endif\n\napicinterrupt ERROR_APIC_VECTOR\t\t\terror_interrupt\t\t\tsmp_error_interrupt\napicinterrupt SPURIOUS_APIC_VECTOR\t\tspurious_interrupt\t\tsmp_spurious_interrupt\n\n#ifdef CONFIG_IRQ_WORK\napicinterrupt IRQ_WORK_VECTOR\t\t\tirq_work_interrupt\t\tsmp_irq_work_interrupt\n#endif\n\n/*\n * Exception entry points.\n */\n#define CPU_TSS_IST(x) PER_CPU_VAR(cpu_tss_rw) + (TSS_ist + ((x) - 1) * 8)\n\n.macro idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1\nENTRY(\\sym)\n\tUNWIND_HINT_IRET_REGS offset=\\has_error_code*8\n\n\t/* Sanity check */\n\t.if \\shift_ist != -1 && \\paranoid == 0\n\t.error \"using shift_ist requires paranoid=1\"\n\t.endif\n\n\tASM_CLAC\n\n\t.if \\has_error_code == 0\n\tpushq\t$-1\t\t\t\t/* ORIG_RAX: no syscall to restart */\n\t.endif\n\n\t.if \\paranoid < 2\n\ttestb\t$3, CS-ORIG_RAX(%rsp)\t\t/* If coming from userspace, switch stacks */\n\tjnz\t.Lfrom_usermode_switch_stack_\\@\n\t.endif\n\n\t.if \\paranoid\n\tcall\tparanoid_entry\n\t.else\n\tcall\terror_entry\n\t.endif\n\tUNWIND_HINT_REGS\n\t/* returned flag: ebx=0: need swapgs on exit, ebx=1: don't need it */\n\n\t.if \\paranoid\n\t.if \\shift_ist != -1\n\tTRACE_IRQS_OFF_DEBUG\t\t\t/* reload IDT in case of recursion */\n\t.else\n\tTRACE_IRQS_OFF\n\t.endif\n\t.endif\n\n\tmovq\t%rsp, %rdi\t\t\t/* pt_regs pointer */\n\n\t.if \\has_error_code\n\tmovq\tORIG_RAX(%rsp), %rsi\t\t/* get error code */\n\tmovq\t$-1, ORIG_RAX(%rsp)\t\t/* no syscall to restart */\n\t.else\n\txorl\t%esi, %esi\t\t\t/* no error code */\n\t.endif\n\n\t.if \\shift_ist != -1\n\tsubq\t$EXCEPTION_STKSZ, CPU_TSS_IST(\\shift_ist)\n\t.endif\n\n\tcall\t\\do_sym\n\n\t.if \\shift_ist != -1\n\taddq\t$EXCEPTION_STKSZ, CPU_TSS_IST(\\shift_ist)\n\t.endif\n\n\t/* these procedures expect \"no swapgs\" flag in ebx */\n\t.if \\paranoid\n\tjmp\tparanoid_exit\n\t.else\n\tjmp\terror_exit\n\t.endif\n\n\t.if \\paranoid < 2\n\t/*\n\t * Entry from userspace.  Switch stacks and treat it\n\t * as a normal entry.  This means that paranoid handlers\n\t * run in real process context if user_mode(regs).\n\t */\n.Lfrom_usermode_switch_stack_\\@:\n\tcall\terror_entry\n\n\tmovq\t%rsp, %rdi\t\t\t/* pt_regs pointer */\n\n\t.if \\has_error_code\n\tmovq\tORIG_RAX(%rsp), %rsi\t\t/* get error code */\n\tmovq\t$-1, ORIG_RAX(%rsp)\t\t/* no syscall to restart */\n\t.else\n\txorl\t%esi, %esi\t\t\t/* no error code */\n\t.endif\n\n\tcall\t\\do_sym\n\n\tjmp\terror_exit\t\t\t/* %ebx: no swapgs flag */\n\t.endif\nEND(\\sym)\n.endm\n\nidtentry divide_error\t\t\tdo_divide_error\t\t\thas_error_code=0\nidtentry overflow\t\t\tdo_overflow\t\t\thas_error_code=0\nidtentry bounds\t\t\t\tdo_bounds\t\t\thas_error_code=0\nidtentry invalid_op\t\t\tdo_invalid_op\t\t\thas_error_code=0\nidtentry device_not_available\t\tdo_device_not_available\t\thas_error_code=0\nidtentry double_fault\t\t\tdo_double_fault\t\t\thas_error_code=1 paranoid=2\nidtentry coprocessor_segment_overrun\tdo_coprocessor_segment_overrun\thas_error_code=0\nidtentry invalid_TSS\t\t\tdo_invalid_TSS\t\t\thas_error_code=1\nidtentry segment_not_present\t\tdo_segment_not_present\t\thas_error_code=1\nidtentry spurious_interrupt_bug\t\tdo_spurious_interrupt_bug\thas_error_code=0\nidtentry coprocessor_error\t\tdo_coprocessor_error\t\thas_error_code=0\nidtentry alignment_check\t\tdo_alignment_check\t\thas_error_code=1\nidtentry simd_coprocessor_error\t\tdo_simd_coprocessor_error\thas_error_code=0\n\n\n\t/*\n\t * Reload gs selector with exception handling\n\t * edi:  new selector\n\t */\nENTRY(native_load_gs_index)\n\tFRAME_BEGIN\n\tpushfq\n\tDISABLE_INTERRUPTS(CLBR_ANY & ~CLBR_RDI)\n\tTRACE_IRQS_OFF\n\tSWAPGS\n.Lgs_change:\n\tmovl\t%edi, %gs\n2:\tALTERNATIVE \"\", \"mfence\", X86_BUG_SWAPGS_FENCE\n\tSWAPGS\n\tTRACE_IRQS_FLAGS (%rsp)\n\tpopfq\n\tFRAME_END\n\tret\nENDPROC(native_load_gs_index)\nEXPORT_SYMBOL(native_load_gs_index)\n\n\t_ASM_EXTABLE(.Lgs_change, bad_gs)\n\t.section .fixup, \"ax\"\n\t/* running with kernelgs */\nbad_gs:\n\tSWAPGS\t\t\t\t\t/* switch back to user gs */\n.macro ZAP_GS\n\t/* This can't be a string because the preprocessor needs to see it. */\n\tmovl $__USER_DS, %eax\n\tmovl %eax, %gs\n.endm\n\tALTERNATIVE \"\", \"ZAP_GS\", X86_BUG_NULL_SEG\n\txorl\t%eax, %eax\n\tmovl\t%eax, %gs\n\tjmp\t2b\n\t.previous\n\n/* Call softirq on interrupt stack. Interrupts are off. */\nENTRY(do_softirq_own_stack)\n\tpushq\t%rbp\n\tmov\t%rsp, %rbp\n\tENTER_IRQ_STACK regs=0 old_rsp=%r11\n\tcall\t__do_softirq\n\tLEAVE_IRQ_STACK regs=0\n\tleaveq\n\tret\nENDPROC(do_softirq_own_stack)\n\n#ifdef CONFIG_XEN\nidtentry hypervisor_callback xen_do_hypervisor_callback has_error_code=0\n\n/*\n * A note on the \"critical region\" in our callback handler.\n * We want to avoid stacking callback handlers due to events occurring\n * during handling of the last event. To do this, we keep events disabled\n * until we've done all processing. HOWEVER, we must enable events before\n * popping the stack frame (can't be done atomically) and so it would still\n * be possible to get enough handler activations to overflow the stack.\n * Although unlikely, bugs of that kind are hard to track down, so we'd\n * like to avoid the possibility.\n * So, on entry to the handler we detect whether we interrupted an\n * existing activation in its critical region -- if so, we pop the current\n * activation and restart the handler using the previous one.\n */\nENTRY(xen_do_hypervisor_callback)\t\t/* do_hypervisor_callback(struct *pt_regs) */\n\n/*\n * Since we don't modify %rdi, evtchn_do_upall(struct *pt_regs) will\n * see the correct pointer to the pt_regs\n */\n\tUNWIND_HINT_FUNC\n\tmovq\t%rdi, %rsp\t\t\t/* we don't return, adjust the stack frame */\n\tUNWIND_HINT_REGS\n\n\tENTER_IRQ_STACK old_rsp=%r10\n\tcall\txen_evtchn_do_upcall\n\tLEAVE_IRQ_STACK\n\n#ifndef CONFIG_PREEMPT\n\tcall\txen_maybe_preempt_hcall\n#endif\n\tjmp\terror_exit\nEND(xen_do_hypervisor_callback)\n\n/*\n * Hypervisor uses this for application faults while it executes.\n * We get here for two reasons:\n *  1. Fault while reloading DS, ES, FS or GS\n *  2. Fault while executing IRET\n * Category 1 we do not need to fix up as Xen has already reloaded all segment\n * registers that could be reloaded and zeroed the others.\n * Category 2 we fix up by killing the current process. We cannot use the\n * normal Linux return path in this case because if we use the IRET hypercall\n * to pop the stack frame we end up in an infinite loop of failsafe callbacks.\n * We distinguish between categories by comparing each saved segment register\n * with its current contents: any discrepancy means we in category 1.\n */\nENTRY(xen_failsafe_callback)\n\tUNWIND_HINT_EMPTY\n\tmovl\t%ds, %ecx\n\tcmpw\t%cx, 0x10(%rsp)\n\tjne\t1f\n\tmovl\t%es, %ecx\n\tcmpw\t%cx, 0x18(%rsp)\n\tjne\t1f\n\tmovl\t%fs, %ecx\n\tcmpw\t%cx, 0x20(%rsp)\n\tjne\t1f\n\tmovl\t%gs, %ecx\n\tcmpw\t%cx, 0x28(%rsp)\n\tjne\t1f\n\t/* All segments match their saved values => Category 2 (Bad IRET). */\n\tmovq\t(%rsp), %rcx\n\tmovq\t8(%rsp), %r11\n\taddq\t$0x30, %rsp\n\tpushq\t$0\t\t\t\t/* RIP */\n\tUNWIND_HINT_IRET_REGS offset=8\n\tjmp\tgeneral_protection\n1:\t/* Segment mismatch => Category 1 (Bad segment). Retry the IRET. */\n\tmovq\t(%rsp), %rcx\n\tmovq\t8(%rsp), %r11\n\taddq\t$0x30, %rsp\n\tUNWIND_HINT_IRET_REGS\n\tpushq\t$-1 /* orig_ax = -1 => not a system call */\n\tPUSH_AND_CLEAR_REGS\n\tENCODE_FRAME_POINTER\n\tjmp\terror_exit\nEND(xen_failsafe_callback)\n\napicinterrupt3 HYPERVISOR_CALLBACK_VECTOR \\\n\txen_hvm_callback_vector xen_evtchn_do_upcall\n\n#endif /* CONFIG_XEN */\n\n#if IS_ENABLED(CONFIG_HYPERV)\napicinterrupt3 HYPERVISOR_CALLBACK_VECTOR \\\n\thyperv_callback_vector hyperv_vector_handler\n\napicinterrupt3 HYPERV_REENLIGHTENMENT_VECTOR \\\n\thyperv_reenlightenment_vector hyperv_reenlightenment_intr\n#endif /* CONFIG_HYPERV */\n\nidtentry debug\t\t\tdo_debug\t\thas_error_code=0\tparanoid=1 shift_ist=DEBUG_STACK\nidtentry int3\t\t\tdo_int3\t\t\thas_error_code=0\tparanoid=1 shift_ist=DEBUG_STACK\nidtentry stack_segment\t\tdo_stack_segment\thas_error_code=1\n\n#ifdef CONFIG_XEN\nidtentry xennmi\t\t\tdo_nmi\t\t\thas_error_code=0\nidtentry xendebug\t\tdo_debug\t\thas_error_code=0\nidtentry xenint3\t\tdo_int3\t\t\thas_error_code=0\n#endif\n\nidtentry general_protection\tdo_general_protection\thas_error_code=1\nidtentry page_fault\t\tdo_page_fault\t\thas_error_code=1\n\n#ifdef CONFIG_KVM_GUEST\nidtentry async_page_fault\tdo_async_page_fault\thas_error_code=1\n#endif\n\n#ifdef CONFIG_X86_MCE\nidtentry machine_check\t\tdo_mce\t\t\thas_error_code=0\tparanoid=1\n#endif\n\n/*\n * Save all registers in pt_regs, and switch gs if needed.\n * Use slow, but surefire \"are we in kernel?\" check.\n * Return: ebx=0: need swapgs on exit, ebx=1: otherwise\n */\nENTRY(paranoid_entry)\n\tUNWIND_HINT_FUNC\n\tcld\n\tPUSH_AND_CLEAR_REGS save_ret=1\n\tENCODE_FRAME_POINTER 8\n\tmovl\t$1, %ebx\n\tmovl\t$MSR_GS_BASE, %ecx\n\trdmsr\n\ttestl\t%edx, %edx\n\tjs\t1f\t\t\t\t/* negative -> in kernel */\n\tSWAPGS\n\txorl\t%ebx, %ebx\n\n1:\n\tSAVE_AND_SWITCH_TO_KERNEL_CR3 scratch_reg=%rax save_reg=%r14\n\n\tret\nEND(paranoid_entry)\n\n/*\n * \"Paranoid\" exit path from exception stack.  This is invoked\n * only on return from non-NMI IST interrupts that came\n * from kernel space.\n *\n * We may be returning to very strange contexts (e.g. very early\n * in syscall entry), so checking for preemption here would\n * be complicated.  Fortunately, we there's no good reason\n * to try to handle preemption here.\n *\n * On entry, ebx is \"no swapgs\" flag (1: don't need swapgs, 0: need it)\n */\nENTRY(paranoid_exit)\n\tUNWIND_HINT_REGS\n\tDISABLE_INTERRUPTS(CLBR_ANY)\n\tTRACE_IRQS_OFF_DEBUG\n\ttestl\t%ebx, %ebx\t\t\t/* swapgs needed? */\n\tjnz\t.Lparanoid_exit_no_swapgs\n\tTRACE_IRQS_IRETQ\n\tRESTORE_CR3\tscratch_reg=%rbx save_reg=%r14\n\tSWAPGS_UNSAFE_STACK\n\tjmp\t.Lparanoid_exit_restore\n.Lparanoid_exit_no_swapgs:\n\tTRACE_IRQS_IRETQ_DEBUG\n\tRESTORE_CR3\tscratch_reg=%rbx save_reg=%r14\n.Lparanoid_exit_restore:\n\tjmp restore_regs_and_return_to_kernel\nEND(paranoid_exit)\n\n/*\n * Save all registers in pt_regs, and switch GS if needed.\n * Return: EBX=0: came from user mode; EBX=1: otherwise\n */\nENTRY(error_entry)\n\tUNWIND_HINT_FUNC\n\tcld\n\tPUSH_AND_CLEAR_REGS save_ret=1\n\tENCODE_FRAME_POINTER 8\n\ttestb\t$3, CS+8(%rsp)\n\tjz\t.Lerror_kernelspace\n\n\t/*\n\t * We entered from user mode or we're pretending to have entered\n\t * from user mode due to an IRET fault.\n\t */\n\tSWAPGS\n\t/* We have user CR3.  Change to kernel CR3. */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rax\n\n.Lerror_entry_from_usermode_after_swapgs:\n\t/* Put us onto the real thread stack. */\n\tpopq\t%r12\t\t\t\t/* save return addr in %12 */\n\tmovq\t%rsp, %rdi\t\t\t/* arg0 = pt_regs pointer */\n\tcall\tsync_regs\n\tmovq\t%rax, %rsp\t\t\t/* switch stack */\n\tENCODE_FRAME_POINTER\n\tpushq\t%r12\n\n\t/*\n\t * We need to tell lockdep that IRQs are off.  We can't do this until\n\t * we fix gsbase, and we should do it before enter_from_user_mode\n\t * (which can take locks).\n\t */\n\tTRACE_IRQS_OFF\n\tCALL_enter_from_user_mode\n\tret\n\n.Lerror_entry_done:\n\tTRACE_IRQS_OFF\n\tret\n\n\t/*\n\t * There are two places in the kernel that can potentially fault with\n\t * usergs. Handle them here.  B stepping K8s sometimes report a\n\t * truncated RIP for IRET exceptions returning to compat mode. Check\n\t * for these here too.\n\t */\n.Lerror_kernelspace:\n\tincl\t%ebx\n\tleaq\tnative_irq_return_iret(%rip), %rcx\n\tcmpq\t%rcx, RIP+8(%rsp)\n\tje\t.Lerror_bad_iret\n\tmovl\t%ecx, %eax\t\t\t/* zero extend */\n\tcmpq\t%rax, RIP+8(%rsp)\n\tje\t.Lbstep_iret\n\tcmpq\t$.Lgs_change, RIP+8(%rsp)\n\tjne\t.Lerror_entry_done\n\n\t/*\n\t * hack: .Lgs_change can fail with user gsbase.  If this happens, fix up\n\t * gsbase and proceed.  We'll fix up the exception and land in\n\t * .Lgs_change's error handler with kernel gsbase.\n\t */\n\tSWAPGS\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rax\n\tjmp .Lerror_entry_done\n\n.Lbstep_iret:\n\t/* Fix truncated RIP */\n\tmovq\t%rcx, RIP+8(%rsp)\n\t/* fall through */\n\n.Lerror_bad_iret:\n\t/*\n\t * We came from an IRET to user mode, so we have user\n\t * gsbase and CR3.  Switch to kernel gsbase and CR3:\n\t */\n\tSWAPGS\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rax\n\n\t/*\n\t * Pretend that the exception came from user mode: set up pt_regs\n\t * as if we faulted immediately after IRET and clear EBX so that\n\t * error_exit knows that we will be returning to user mode.\n\t */\n\tmov\t%rsp, %rdi\n\tcall\tfixup_bad_iret\n\tmov\t%rax, %rsp\n\tdecl\t%ebx\n\tjmp\t.Lerror_entry_from_usermode_after_swapgs\nEND(error_entry)\n\n\n/*\n * On entry, EBX is a \"return to kernel mode\" flag:\n *   1: already in kernel mode, don't need SWAPGS\n *   0: user gsbase is loaded, we need SWAPGS and standard preparation for return to usermode\n */\nENTRY(error_exit)\n\tUNWIND_HINT_REGS\n\tDISABLE_INTERRUPTS(CLBR_ANY)\n\tTRACE_IRQS_OFF\n\ttestl\t%ebx, %ebx\n\tjnz\tretint_kernel\n\tjmp\tretint_user\nEND(error_exit)\n\n/*\n * Runs on exception stack.  Xen PV does not go through this path at all,\n * so we can use real assembly here.\n *\n * Registers:\n *\t%r14: Used to save/restore the CR3 of the interrupted context\n *\t      when PAGE_TABLE_ISOLATION is in use.  Do not clobber.\n */\nENTRY(nmi)\n\tUNWIND_HINT_IRET_REGS\n\n\t/*\n\t * We allow breakpoints in NMIs. If a breakpoint occurs, then\n\t * the iretq it performs will take us out of NMI context.\n\t * This means that we can have nested NMIs where the next\n\t * NMI is using the top of the stack of the previous NMI. We\n\t * can't let it execute because the nested NMI will corrupt the\n\t * stack of the previous NMI. NMI handlers are not re-entrant\n\t * anyway.\n\t *\n\t * To handle this case we do the following:\n\t *  Check the a special location on the stack that contains\n\t *  a variable that is set when NMIs are executing.\n\t *  The interrupted task's stack is also checked to see if it\n\t *  is an NMI stack.\n\t *  If the variable is not set and the stack is not the NMI\n\t *  stack then:\n\t *    o Set the special variable on the stack\n\t *    o Copy the interrupt frame into an \"outermost\" location on the\n\t *      stack\n\t *    o Copy the interrupt frame into an \"iret\" location on the stack\n\t *    o Continue processing the NMI\n\t *  If the variable is set or the previous stack is the NMI stack:\n\t *    o Modify the \"iret\" location to jump to the repeat_nmi\n\t *    o return back to the first NMI\n\t *\n\t * Now on exit of the first NMI, we first clear the stack variable\n\t * The NMI stack will tell any nested NMIs at that point that it is\n\t * nested. Then we pop the stack normally with iret, and if there was\n\t * a nested NMI that updated the copy interrupt stack frame, a\n\t * jump will be made to the repeat_nmi code that will handle the second\n\t * NMI.\n\t *\n\t * However, espfix prevents us from directly returning to userspace\n\t * with a single IRET instruction.  Similarly, IRET to user mode\n\t * can fault.  We therefore handle NMIs from user space like\n\t * other IST entries.\n\t */\n\n\tASM_CLAC\n\n\t/* Use %rdx as our temp variable throughout */\n\tpushq\t%rdx\n\n\ttestb\t$3, CS-RIP+8(%rsp)\n\tjz\t.Lnmi_from_kernel\n\n\t/*\n\t * NMI from user mode.  We need to run on the thread stack, but we\n\t * can't go through the normal entry paths: NMIs are masked, and\n\t * we don't want to enable interrupts, because then we'll end\n\t * up in an awkward situation in which IRQs are on but NMIs\n\t * are off.\n\t *\n\t * We also must not push anything to the stack before switching\n\t * stacks lest we corrupt the \"NMI executing\" variable.\n\t */\n\n\tswapgs\n\tcld\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rdx\n\tmovq\t%rsp, %rdx\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\tUNWIND_HINT_IRET_REGS base=%rdx offset=8\n\tpushq\t5*8(%rdx)\t/* pt_regs->ss */\n\tpushq\t4*8(%rdx)\t/* pt_regs->rsp */\n\tpushq\t3*8(%rdx)\t/* pt_regs->flags */\n\tpushq\t2*8(%rdx)\t/* pt_regs->cs */\n\tpushq\t1*8(%rdx)\t/* pt_regs->rip */\n\tUNWIND_HINT_IRET_REGS\n\tpushq   $-1\t\t/* pt_regs->orig_ax */\n\tPUSH_AND_CLEAR_REGS rdx=(%rdx)\n\tENCODE_FRAME_POINTER\n\n\t/*\n\t * At this point we no longer need to worry about stack damage\n\t * due to nesting -- we're on the normal thread stack and we're\n\t * done with the NMI stack.\n\t */\n\n\tmovq\t%rsp, %rdi\n\tmovq\t$-1, %rsi\n\tcall\tdo_nmi\n\n\t/*\n\t * Return back to user mode.  We must *not* do the normal exit\n\t * work, because we don't want to enable interrupts.\n\t */\n\tjmp\tswapgs_restore_regs_and_return_to_usermode\n\n.Lnmi_from_kernel:\n\t/*\n\t * Here's what our stack frame will look like:\n\t * +---------------------------------------------------------+\n\t * | original SS                                             |\n\t * | original Return RSP                                     |\n\t * | original RFLAGS                                         |\n\t * | original CS                                             |\n\t * | original RIP                                            |\n\t * +---------------------------------------------------------+\n\t * | temp storage for rdx                                    |\n\t * +---------------------------------------------------------+\n\t * | \"NMI executing\" variable                                |\n\t * +---------------------------------------------------------+\n\t * | iret SS          } Copied from \"outermost\" frame        |\n\t * | iret Return RSP  } on each loop iteration; overwritten  |\n\t * | iret RFLAGS      } by a nested NMI to force another     |\n\t * | iret CS          } iteration if needed.                 |\n\t * | iret RIP         }                                      |\n\t * +---------------------------------------------------------+\n\t * | outermost SS          } initialized in first_nmi;       |\n\t * | outermost Return RSP  } will not be changed before      |\n\t * | outermost RFLAGS      } NMI processing is done.         |\n\t * | outermost CS          } Copied to \"iret\" frame on each  |\n\t * | outermost RIP         } iteration.                      |\n\t * +---------------------------------------------------------+\n\t * | pt_regs                                                 |\n\t * +---------------------------------------------------------+\n\t *\n\t * The \"original\" frame is used by hardware.  Before re-enabling\n\t * NMIs, we need to be done with it, and we need to leave enough\n\t * space for the asm code here.\n\t *\n\t * We return by executing IRET while RSP points to the \"iret\" frame.\n\t * That will either return for real or it will loop back into NMI\n\t * processing.\n\t *\n\t * The \"outermost\" frame is copied to the \"iret\" frame on each\n\t * iteration of the loop, so each iteration starts with the \"iret\"\n\t * frame pointing to the final return target.\n\t */\n\n\t/*\n\t * Determine whether we're a nested NMI.\n\t *\n\t * If we interrupted kernel code between repeat_nmi and\n\t * end_repeat_nmi, then we are a nested NMI.  We must not\n\t * modify the \"iret\" frame because it's being written by\n\t * the outer NMI.  That's okay; the outer NMI handler is\n\t * about to about to call do_nmi anyway, so we can just\n\t * resume the outer NMI.\n\t */\n\n\tmovq\t$repeat_nmi, %rdx\n\tcmpq\t8(%rsp), %rdx\n\tja\t1f\n\tmovq\t$end_repeat_nmi, %rdx\n\tcmpq\t8(%rsp), %rdx\n\tja\tnested_nmi_out\n1:\n\n\t/*\n\t * Now check \"NMI executing\".  If it's set, then we're nested.\n\t * This will not detect if we interrupted an outer NMI just\n\t * before IRET.\n\t */\n\tcmpl\t$1, -8(%rsp)\n\tje\tnested_nmi\n\n\t/*\n\t * Now test if the previous stack was an NMI stack.  This covers\n\t * the case where we interrupt an outer NMI after it clears\n\t * \"NMI executing\" but before IRET.  We need to be careful, though:\n\t * there is one case in which RSP could point to the NMI stack\n\t * despite there being no NMI active: naughty userspace controls\n\t * RSP at the very beginning of the SYSCALL targets.  We can\n\t * pull a fast one on naughty userspace, though: we program\n\t * SYSCALL to mask DF, so userspace cannot cause DF to be set\n\t * if it controls the kernel's RSP.  We set DF before we clear\n\t * \"NMI executing\".\n\t */\n\tlea\t6*8(%rsp), %rdx\n\t/* Compare the NMI stack (rdx) with the stack we came from (4*8(%rsp)) */\n\tcmpq\t%rdx, 4*8(%rsp)\n\t/* If the stack pointer is above the NMI stack, this is a normal NMI */\n\tja\tfirst_nmi\n\n\tsubq\t$EXCEPTION_STKSZ, %rdx\n\tcmpq\t%rdx, 4*8(%rsp)\n\t/* If it is below the NMI stack, it is a normal NMI */\n\tjb\tfirst_nmi\n\n\t/* Ah, it is within the NMI stack. */\n\n\ttestb\t$(X86_EFLAGS_DF >> 8), (3*8 + 1)(%rsp)\n\tjz\tfirst_nmi\t/* RSP was user controlled. */\n\n\t/* This is a nested NMI. */\n\nnested_nmi:\n\t/*\n\t * Modify the \"iret\" frame to point to repeat_nmi, forcing another\n\t * iteration of NMI handling.\n\t */\n\tsubq\t$8, %rsp\n\tleaq\t-10*8(%rsp), %rdx\n\tpushq\t$__KERNEL_DS\n\tpushq\t%rdx\n\tpushfq\n\tpushq\t$__KERNEL_CS\n\tpushq\t$repeat_nmi\n\n\t/* Put stack back */\n\taddq\t$(6*8), %rsp\n\nnested_nmi_out:\n\tpopq\t%rdx\n\n\t/* We are returning to kernel mode, so this cannot result in a fault. */\n\tiretq\n\nfirst_nmi:\n\t/* Restore rdx. */\n\tmovq\t(%rsp), %rdx\n\n\t/* Make room for \"NMI executing\". */\n\tpushq\t$0\n\n\t/* Leave room for the \"iret\" frame */\n\tsubq\t$(5*8), %rsp\n\n\t/* Copy the \"original\" frame to the \"outermost\" frame */\n\t.rept 5\n\tpushq\t11*8(%rsp)\n\t.endr\n\tUNWIND_HINT_IRET_REGS\n\n\t/* Everything up to here is safe from nested NMIs */\n\n#ifdef CONFIG_DEBUG_ENTRY\n\t/*\n\t * For ease of testing, unmask NMIs right away.  Disabled by\n\t * default because IRET is very expensive.\n\t */\n\tpushq\t$0\t\t/* SS */\n\tpushq\t%rsp\t\t/* RSP (minus 8 because of the previous push) */\n\taddq\t$8, (%rsp)\t/* Fix up RSP */\n\tpushfq\t\t\t/* RFLAGS */\n\tpushq\t$__KERNEL_CS\t/* CS */\n\tpushq\t$1f\t\t/* RIP */\n\tiretq\t\t\t/* continues at repeat_nmi below */\n\tUNWIND_HINT_IRET_REGS\n1:\n#endif\n\nrepeat_nmi:\n\t/*\n\t * If there was a nested NMI, the first NMI's iret will return\n\t * here. But NMIs are still enabled and we can take another\n\t * nested NMI. The nested NMI checks the interrupted RIP to see\n\t * if it is between repeat_nmi and end_repeat_nmi, and if so\n\t * it will just return, as we are about to repeat an NMI anyway.\n\t * This makes it safe to copy to the stack frame that a nested\n\t * NMI will update.\n\t *\n\t * RSP is pointing to \"outermost RIP\".  gsbase is unknown, but, if\n\t * we're repeating an NMI, gsbase has the same value that it had on\n\t * the first iteration.  paranoid_entry will load the kernel\n\t * gsbase if needed before we call do_nmi.  \"NMI executing\"\n\t * is zero.\n\t */\n\tmovq\t$1, 10*8(%rsp)\t\t/* Set \"NMI executing\". */\n\n\t/*\n\t * Copy the \"outermost\" frame to the \"iret\" frame.  NMIs that nest\n\t * here must not modify the \"iret\" frame while we're writing to\n\t * it or it will end up containing garbage.\n\t */\n\taddq\t$(10*8), %rsp\n\t.rept 5\n\tpushq\t-6*8(%rsp)\n\t.endr\n\tsubq\t$(5*8), %rsp\nend_repeat_nmi:\n\n\t/*\n\t * Everything below this point can be preempted by a nested NMI.\n\t * If this happens, then the inner NMI will change the \"iret\"\n\t * frame to point back to repeat_nmi.\n\t */\n\tpushq\t$-1\t\t\t\t/* ORIG_RAX: no syscall to restart */\n\n\t/*\n\t * Use paranoid_entry to handle SWAPGS, but no need to use paranoid_exit\n\t * as we should not be calling schedule in NMI context.\n\t * Even with normal interrupts enabled. An NMI should not be\n\t * setting NEED_RESCHED or anything that normal interrupts and\n\t * exceptions might do.\n\t */\n\tcall\tparanoid_entry\n\tUNWIND_HINT_REGS\n\n\t/* paranoidentry do_nmi, 0; without TRACE_IRQS_OFF */\n\tmovq\t%rsp, %rdi\n\tmovq\t$-1, %rsi\n\tcall\tdo_nmi\n\n\tRESTORE_CR3 scratch_reg=%r15 save_reg=%r14\n\n\ttestl\t%ebx, %ebx\t\t\t/* swapgs needed? */\n\tjnz\tnmi_restore\nnmi_swapgs:\n\tSWAPGS_UNSAFE_STACK\nnmi_restore:\n\tPOP_REGS\n\n\t/*\n\t * Skip orig_ax and the \"outermost\" frame to point RSP at the \"iret\"\n\t * at the \"iret\" frame.\n\t */\n\taddq\t$6*8, %rsp\n\n\t/*\n\t * Clear \"NMI executing\".  Set DF first so that we can easily\n\t * distinguish the remaining code between here and IRET from\n\t * the SYSCALL entry and exit paths.\n\t *\n\t * We arguably should just inspect RIP instead, but I (Andy) wrote\n\t * this code when I had the misapprehension that Xen PV supported\n\t * NMIs, and Xen PV would break that approach.\n\t */\n\tstd\n\tmovq\t$0, 5*8(%rsp)\t\t/* clear \"NMI executing\" */\n\n\t/*\n\t * iretq reads the \"iret\" frame and exits the NMI stack in a\n\t * single instruction.  We are returning to kernel mode, so this\n\t * cannot result in a fault.  Similarly, we don't need to worry\n\t * about espfix64 on the way back to kernel mode.\n\t */\n\tiretq\nEND(nmi)\n\nENTRY(ignore_sysret)\n\tUNWIND_HINT_EMPTY\n\tmov\t$-ENOSYS, %eax\n\tsysret\nEND(ignore_sysret)\n\nENTRY(rewind_stack_do_exit)\n\tUNWIND_HINT_FUNC\n\t/* Prevent any naive code from trying to unwind to our caller. */\n\txorl\t%ebp, %ebp\n\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rax\n\tleaq\t-PTREGS_SIZE(%rax), %rsp\n\tUNWIND_HINT_FUNC sp_offset=PTREGS_SIZE\n\n\tcall\tdo_exit\nEND(rewind_stack_do_exit)\n", "/*\n * Interrupt descriptor table related code\n *\n * This file is licensed under the GPL V2\n */\n#include <linux/interrupt.h>\n\n#include <asm/traps.h>\n#include <asm/proto.h>\n#include <asm/desc.h>\n\nstruct idt_data {\n\tunsigned int\tvector;\n\tunsigned int\tsegment;\n\tstruct idt_bits\tbits;\n\tconst void\t*addr;\n};\n\n#define DPL0\t\t0x0\n#define DPL3\t\t0x3\n\n#define DEFAULT_STACK\t0\n\n#define G(_vector, _addr, _ist, _type, _dpl, _segment)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.vector\t\t= _vector,\t\t\\\n\t\t.bits.ist\t= _ist,\t\t\t\\\n\t\t.bits.type\t= _type,\t\t\\\n\t\t.bits.dpl\t= _dpl,\t\t\t\\\n\t\t.bits.p\t\t= 1,\t\t\t\\\n\t\t.addr\t\t= _addr,\t\t\\\n\t\t.segment\t= _segment,\t\t\\\n\t}\n\n/* Interrupt gate */\n#define INTG(_vector, _addr)\t\t\t\t\\\n\tG(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)\n\n/* System interrupt gate */\n#define SYSG(_vector, _addr)\t\t\t\t\\\n\tG(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL3, __KERNEL_CS)\n\n/* Interrupt gate with interrupt stack */\n#define ISTG(_vector, _addr, _ist)\t\t\t\\\n\tG(_vector, _addr, _ist, GATE_INTERRUPT, DPL0, __KERNEL_CS)\n\n/* System interrupt gate with interrupt stack */\n#define SISTG(_vector, _addr, _ist)\t\t\t\\\n\tG(_vector, _addr, _ist, GATE_INTERRUPT, DPL3, __KERNEL_CS)\n\n/* Task gate */\n#define TSKG(_vector, _gdt)\t\t\t\t\\\n\tG(_vector, NULL, DEFAULT_STACK, GATE_TASK, DPL0, _gdt << 3)\n\n/*\n * Early traps running on the DEFAULT_STACK because the other interrupt\n * stacks work only after cpu_init().\n */\nstatic const __initconst struct idt_data early_idts[] = {\n\tINTG(X86_TRAP_DB,\t\tdebug),\n\tSYSG(X86_TRAP_BP,\t\tint3),\n#ifdef CONFIG_X86_32\n\tINTG(X86_TRAP_PF,\t\tpage_fault),\n#endif\n};\n\n/*\n * The default IDT entries which are set up in trap_init() before\n * cpu_init() is invoked. Interrupt stacks cannot be used at that point and\n * the traps which use them are reinitialized with IST after cpu_init() has\n * set up TSS.\n */\nstatic const __initconst struct idt_data def_idts[] = {\n\tINTG(X86_TRAP_DE,\t\tdivide_error),\n\tINTG(X86_TRAP_NMI,\t\tnmi),\n\tINTG(X86_TRAP_BR,\t\tbounds),\n\tINTG(X86_TRAP_UD,\t\tinvalid_op),\n\tINTG(X86_TRAP_NM,\t\tdevice_not_available),\n\tINTG(X86_TRAP_OLD_MF,\t\tcoprocessor_segment_overrun),\n\tINTG(X86_TRAP_TS,\t\tinvalid_TSS),\n\tINTG(X86_TRAP_NP,\t\tsegment_not_present),\n\tINTG(X86_TRAP_SS,\t\tstack_segment),\n\tINTG(X86_TRAP_GP,\t\tgeneral_protection),\n\tINTG(X86_TRAP_SPURIOUS,\t\tspurious_interrupt_bug),\n\tINTG(X86_TRAP_MF,\t\tcoprocessor_error),\n\tINTG(X86_TRAP_AC,\t\talignment_check),\n\tINTG(X86_TRAP_XF,\t\tsimd_coprocessor_error),\n\n#ifdef CONFIG_X86_32\n\tTSKG(X86_TRAP_DF,\t\tGDT_ENTRY_DOUBLEFAULT_TSS),\n#else\n\tINTG(X86_TRAP_DF,\t\tdouble_fault),\n#endif\n\tINTG(X86_TRAP_DB,\t\tdebug),\n\n#ifdef CONFIG_X86_MCE\n\tINTG(X86_TRAP_MC,\t\t&machine_check),\n#endif\n\n\tSYSG(X86_TRAP_OF,\t\toverflow),\n#if defined(CONFIG_IA32_EMULATION)\n\tSYSG(IA32_SYSCALL_VECTOR,\tentry_INT80_compat),\n#elif defined(CONFIG_X86_32)\n\tSYSG(IA32_SYSCALL_VECTOR,\tentry_INT80_32),\n#endif\n};\n\n/*\n * The APIC and SMP idt entries\n */\nstatic const __initconst struct idt_data apic_idts[] = {\n#ifdef CONFIG_SMP\n\tINTG(RESCHEDULE_VECTOR,\t\treschedule_interrupt),\n\tINTG(CALL_FUNCTION_VECTOR,\tcall_function_interrupt),\n\tINTG(CALL_FUNCTION_SINGLE_VECTOR, call_function_single_interrupt),\n\tINTG(IRQ_MOVE_CLEANUP_VECTOR,\tirq_move_cleanup_interrupt),\n\tINTG(REBOOT_VECTOR,\t\treboot_interrupt),\n#endif\n\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tINTG(THERMAL_APIC_VECTOR,\tthermal_interrupt),\n#endif\n\n#ifdef CONFIG_X86_MCE_THRESHOLD\n\tINTG(THRESHOLD_APIC_VECTOR,\tthreshold_interrupt),\n#endif\n\n#ifdef CONFIG_X86_MCE_AMD\n\tINTG(DEFERRED_ERROR_VECTOR,\tdeferred_error_interrupt),\n#endif\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\tINTG(LOCAL_TIMER_VECTOR,\tapic_timer_interrupt),\n\tINTG(X86_PLATFORM_IPI_VECTOR,\tx86_platform_ipi),\n# ifdef CONFIG_HAVE_KVM\n\tINTG(POSTED_INTR_VECTOR,\tkvm_posted_intr_ipi),\n\tINTG(POSTED_INTR_WAKEUP_VECTOR, kvm_posted_intr_wakeup_ipi),\n\tINTG(POSTED_INTR_NESTED_VECTOR, kvm_posted_intr_nested_ipi),\n# endif\n# ifdef CONFIG_IRQ_WORK\n\tINTG(IRQ_WORK_VECTOR,\t\tirq_work_interrupt),\n# endif\n\tINTG(SPURIOUS_APIC_VECTOR,\tspurious_interrupt),\n\tINTG(ERROR_APIC_VECTOR,\t\terror_interrupt),\n#endif\n};\n\n#ifdef CONFIG_X86_64\n/*\n * Early traps running on the DEFAULT_STACK because the other interrupt\n * stacks work only after cpu_init().\n */\nstatic const __initconst struct idt_data early_pf_idts[] = {\n\tINTG(X86_TRAP_PF,\t\tpage_fault),\n};\n\n/*\n * Override for the debug_idt. Same as the default, but with interrupt\n * stack set to DEFAULT_STACK (0). Required for NMI trap handling.\n */\nstatic const __initconst struct idt_data dbg_idts[] = {\n\tINTG(X86_TRAP_DB,\tdebug),\n\tINTG(X86_TRAP_BP,\tint3),\n};\n#endif\n\n/* Must be page-aligned because the real IDT is used in a fixmap. */\ngate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;\n\nstruct desc_ptr idt_descr __ro_after_init = {\n\t.size\t\t= (IDT_ENTRIES * 2 * sizeof(unsigned long)) - 1,\n\t.address\t= (unsigned long) idt_table,\n};\n\n#ifdef CONFIG_X86_64\n/* No need to be aligned, but done to keep all IDTs defined the same way. */\ngate_desc debug_idt_table[IDT_ENTRIES] __page_aligned_bss;\n\n/*\n * The exceptions which use Interrupt stacks. They are setup after\n * cpu_init() when the TSS has been initialized.\n */\nstatic const __initconst struct idt_data ist_idts[] = {\n\tISTG(X86_TRAP_DB,\tdebug,\t\tDEBUG_STACK),\n\tISTG(X86_TRAP_NMI,\tnmi,\t\tNMI_STACK),\n\tSISTG(X86_TRAP_BP,\tint3,\t\tDEBUG_STACK),\n\tISTG(X86_TRAP_DF,\tdouble_fault,\tDOUBLEFAULT_STACK),\n#ifdef CONFIG_X86_MCE\n\tISTG(X86_TRAP_MC,\t&machine_check,\tMCE_STACK),\n#endif\n};\n\n/*\n * Override for the debug_idt. Same as the default, but with interrupt\n * stack set to DEFAULT_STACK (0). Required for NMI trap handling.\n */\nconst struct desc_ptr debug_idt_descr = {\n\t.size\t\t= IDT_ENTRIES * 16 - 1,\n\t.address\t= (unsigned long) debug_idt_table,\n};\n#endif\n\nstatic inline void idt_init_desc(gate_desc *gate, const struct idt_data *d)\n{\n\tunsigned long addr = (unsigned long) d->addr;\n\n\tgate->offset_low\t= (u16) addr;\n\tgate->segment\t\t= (u16) d->segment;\n\tgate->bits\t\t= d->bits;\n\tgate->offset_middle\t= (u16) (addr >> 16);\n#ifdef CONFIG_X86_64\n\tgate->offset_high\t= (u32) (addr >> 32);\n\tgate->reserved\t\t= 0;\n#endif\n}\n\nstatic void\nidt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)\n{\n\tgate_desc desc;\n\n\tfor (; size > 0; t++, size--) {\n\t\tidt_init_desc(&desc, t);\n\t\twrite_idt_entry(idt, t->vector, &desc);\n\t\tif (sys)\n\t\t\tset_bit(t->vector, system_vectors);\n\t}\n}\n\nstatic void set_intr_gate(unsigned int n, const void *addr)\n{\n\tstruct idt_data data;\n\n\tBUG_ON(n > 0xFF);\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.vector\t= n;\n\tdata.addr\t= addr;\n\tdata.segment\t= __KERNEL_CS;\n\tdata.bits.type\t= GATE_INTERRUPT;\n\tdata.bits.p\t= 1;\n\n\tidt_setup_from_table(idt_table, &data, 1, false);\n}\n\n/**\n * idt_setup_early_traps - Initialize the idt table with early traps\n *\n * On X8664 these traps do not use interrupt stacks as they can't work\n * before cpu_init() is invoked and sets up TSS. The IST variants are\n * installed after that.\n */\nvoid __init idt_setup_early_traps(void)\n{\n\tidt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),\n\t\t\t     true);\n\tload_idt(&idt_descr);\n}\n\n/**\n * idt_setup_traps - Initialize the idt table with default traps\n */\nvoid __init idt_setup_traps(void)\n{\n\tidt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), true);\n}\n\n#ifdef CONFIG_X86_64\n/**\n * idt_setup_early_pf - Initialize the idt table with early pagefault handler\n *\n * On X8664 this does not use interrupt stacks as they can't work before\n * cpu_init() is invoked and sets up TSS. The IST variant is installed\n * after that.\n *\n * FIXME: Why is 32bit and 64bit installing the PF handler at different\n * places in the early setup code?\n */\nvoid __init idt_setup_early_pf(void)\n{\n\tidt_setup_from_table(idt_table, early_pf_idts,\n\t\t\t     ARRAY_SIZE(early_pf_idts), true);\n}\n\n/**\n * idt_setup_ist_traps - Initialize the idt table with traps using IST\n */\nvoid __init idt_setup_ist_traps(void)\n{\n\tidt_setup_from_table(idt_table, ist_idts, ARRAY_SIZE(ist_idts), true);\n}\n\n/**\n * idt_setup_debugidt_traps - Initialize the debug idt table with debug traps\n */\nvoid __init idt_setup_debugidt_traps(void)\n{\n\tmemcpy(&debug_idt_table, &idt_table, IDT_ENTRIES * 16);\n\n\tidt_setup_from_table(debug_idt_table, dbg_idts, ARRAY_SIZE(dbg_idts), false);\n}\n#endif\n\n/**\n * idt_setup_apic_and_irq_gates - Setup APIC/SMP and normal interrupt gates\n */\nvoid __init idt_setup_apic_and_irq_gates(void)\n{\n\tint i = FIRST_EXTERNAL_VECTOR;\n\tvoid *entry;\n\n\tidt_setup_from_table(idt_table, apic_idts, ARRAY_SIZE(apic_idts), true);\n\n\tfor_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) {\n\t\tentry = irq_entries_start + 8 * (i - FIRST_EXTERNAL_VECTOR);\n\t\tset_intr_gate(i, entry);\n\t}\n\n\tfor_each_clear_bit_from(i, system_vectors, NR_VECTORS) {\n#ifdef CONFIG_X86_LOCAL_APIC\n\t\tset_bit(i, system_vectors);\n\t\tset_intr_gate(i, spurious_interrupt);\n#else\n\t\tentry = irq_entries_start + 8 * (i - FIRST_EXTERNAL_VECTOR);\n\t\tset_intr_gate(i, entry);\n#endif\n\t}\n}\n\n/**\n * idt_setup_early_handler - Initializes the idt table with early handlers\n */\nvoid __init idt_setup_early_handler(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_EXCEPTION_VECTORS; i++)\n\t\tset_intr_gate(i, early_idt_handler_array[i]);\n#ifdef CONFIG_X86_32\n\tfor ( ; i < NR_VECTORS; i++)\n\t\tset_intr_gate(i, early_ignore_irq);\n#endif\n\tload_idt(&idt_descr);\n}\n\n/**\n * idt_invalidate - Invalidate interrupt descriptor table\n * @addr:\tThe virtual address of the 'invalid' IDT\n */\nvoid idt_invalidate(void *addr)\n{\n\tstruct desc_ptr idt = { .address = (unsigned long) addr, .size = 0 };\n\n\tload_idt(&idt);\n}\n\nvoid __init update_intr_gate(unsigned int n, const void *addr)\n{\n\tif (WARN_ON_ONCE(!test_bit(n, system_vectors)))\n\t\treturn;\n\tset_intr_gate(n, addr);\n}\n\nvoid alloc_intr_gate(unsigned int n, const void *addr)\n{\n\tBUG_ON(n < FIRST_SYSTEM_VECTOR);\n\tif (!test_and_set_bit(n, system_vectors))\n\t\tset_intr_gate(n, addr);\n}\n", "/*\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 2000, 2001, 2002 Andi Kleen, SuSE Labs\n *\n *  Pentium III FXSR, SSE support\n *\tGareth Hughes <gareth@valinux.com>, May 2000\n */\n\n/*\n * Handle hardware traps and faults.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/context_tracking.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/uaccess.h>\n#include <linux/kdebug.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/ptrace.h>\n#include <linux/uprobes.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kexec.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/bug.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/io.h>\n\n#if defined(CONFIG_EDAC)\n#include <linux/edac.h>\n#endif\n\n#include <asm/stacktrace.h>\n#include <asm/processor.h>\n#include <asm/debugreg.h>\n#include <linux/atomic.h>\n#include <asm/text-patching.h>\n#include <asm/ftrace.h>\n#include <asm/traps.h>\n#include <asm/desc.h>\n#include <asm/fpu/internal.h>\n#include <asm/cpu_entry_area.h>\n#include <asm/mce.h>\n#include <asm/fixmap.h>\n#include <asm/mach_traps.h>\n#include <asm/alternative.h>\n#include <asm/fpu/xstate.h>\n#include <asm/trace/mpx.h>\n#include <asm/mpx.h>\n#include <asm/vm86.h>\n#include <asm/umip.h>\n\n#ifdef CONFIG_X86_64\n#include <asm/x86_init.h>\n#include <asm/pgalloc.h>\n#include <asm/proto.h>\n#else\n#include <asm/processor-flags.h>\n#include <asm/setup.h>\n#include <asm/proto.h>\n#endif\n\nDECLARE_BITMAP(system_vectors, NR_VECTORS);\n\nstatic inline void cond_local_irq_enable(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_enable();\n}\n\nstatic inline void cond_local_irq_disable(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_disable();\n}\n\n/*\n * In IST context, we explicitly disable preemption.  This serves two\n * purposes: it makes it much less likely that we would accidentally\n * schedule in IST context and it will force a warning if we somehow\n * manage to schedule by accident.\n */\nvoid ist_enter(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\t} else {\n\t\t/*\n\t\t * We might have interrupted pretty much anything.  In\n\t\t * fact, if we're a machine check, we can even interrupt\n\t\t * NMI processing.  We don't want in_nmi() to return true,\n\t\t * but we need to notify RCU.\n\t\t */\n\t\trcu_nmi_enter();\n\t}\n\n\tpreempt_disable();\n\n\t/* This code is a bit fragile.  Test it. */\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"ist_enter didn't work\");\n}\n\nvoid ist_exit(struct pt_regs *regs)\n{\n\tpreempt_enable_no_resched();\n\n\tif (!user_mode(regs))\n\t\trcu_nmi_exit();\n}\n\n/**\n * ist_begin_non_atomic() - begin a non-atomic section in an IST exception\n * @regs:\tregs passed to the IST exception handler\n *\n * IST exception handlers normally cannot schedule.  As a special\n * exception, if the exception interrupted userspace code (i.e.\n * user_mode(regs) would return true) and the exception was not\n * a double fault, it can be safe to schedule.  ist_begin_non_atomic()\n * begins a non-atomic section within an ist_enter()/ist_exit() region.\n * Callers are responsible for enabling interrupts themselves inside\n * the non-atomic section, and callers must call ist_end_non_atomic()\n * before ist_exit().\n */\nvoid ist_begin_non_atomic(struct pt_regs *regs)\n{\n\tBUG_ON(!user_mode(regs));\n\n\t/*\n\t * Sanity check: we need to be on the normal thread stack.  This\n\t * will catch asm bugs and any attempt to use ist_preempt_enable\n\t * from double_fault.\n\t */\n\tBUG_ON(!on_thread_stack());\n\n\tpreempt_enable_no_resched();\n}\n\n/**\n * ist_end_non_atomic() - begin a non-atomic section in an IST exception\n *\n * Ends a non-atomic section started with ist_begin_non_atomic().\n */\nvoid ist_end_non_atomic(void)\n{\n\tpreempt_disable();\n}\n\nint is_valid_bugaddr(unsigned long addr)\n{\n\tunsigned short ud;\n\n\tif (addr < TASK_SIZE_MAX)\n\t\treturn 0;\n\n\tif (probe_kernel_address((unsigned short *)addr, ud))\n\t\treturn 0;\n\n\treturn ud == INSN_UD0 || ud == INSN_UD2;\n}\n\nint fixup_bug(struct pt_regs *regs, int trapnr)\n{\n\tif (trapnr != X86_TRAP_UD)\n\t\treturn 0;\n\n\tswitch (report_bug(regs->ip, regs)) {\n\tcase BUG_TRAP_TYPE_NONE:\n\tcase BUG_TRAP_TYPE_BUG:\n\t\tbreak;\n\n\tcase BUG_TRAP_TYPE_WARN:\n\t\tregs->ip += LEN_UD2;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic nokprobe_inline int\ndo_trap_no_signal(struct task_struct *tsk, int trapnr, char *str,\n\t\t  struct pt_regs *regs,\tlong error_code)\n{\n\tif (v8086_mode(regs)) {\n\t\t/*\n\t\t * Traps 0, 1, 3, 4, and 5 should be forwarded to vm86.\n\t\t * On nmi (interrupt 2), do_trap should not be called.\n\t\t */\n\t\tif (trapnr < X86_TRAP_UD) {\n\t\t\tif (!handle_vm86_trap((struct kernel_vm86_regs *) regs,\n\t\t\t\t\t\terror_code, trapnr))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (!user_mode(regs)) {\n\t\tif (fixup_exception(regs, trapnr))\n\t\t\treturn 0;\n\n\t\ttsk->thread.error_code = error_code;\n\t\ttsk->thread.trap_nr = trapnr;\n\t\tdie(str, regs, error_code);\n\t}\n\n\treturn -1;\n}\n\nstatic siginfo_t *fill_trap_info(struct pt_regs *regs, int signr, int trapnr,\n\t\t\t\tsiginfo_t *info)\n{\n\tunsigned long siaddr;\n\tint sicode;\n\n\tswitch (trapnr) {\n\tdefault:\n\t\treturn SEND_SIG_PRIV;\n\n\tcase X86_TRAP_DE:\n\t\tsicode = FPE_INTDIV;\n\t\tsiaddr = uprobe_get_trap_addr(regs);\n\t\tbreak;\n\tcase X86_TRAP_UD:\n\t\tsicode = ILL_ILLOPN;\n\t\tsiaddr = uprobe_get_trap_addr(regs);\n\t\tbreak;\n\tcase X86_TRAP_AC:\n\t\tsicode = BUS_ADRALN;\n\t\tsiaddr = 0;\n\t\tbreak;\n\t}\n\n\tinfo->si_signo = signr;\n\tinfo->si_errno = 0;\n\tinfo->si_code = sicode;\n\tinfo->si_addr = (void __user *)siaddr;\n\treturn info;\n}\n\nstatic void\ndo_trap(int trapnr, int signr, char *str, struct pt_regs *regs,\n\tlong error_code, siginfo_t *info)\n{\n\tstruct task_struct *tsk = current;\n\n\n\tif (!do_trap_no_signal(tsk, trapnr, str, regs, error_code))\n\t\treturn;\n\t/*\n\t * We want error_code and trap_nr set for userspace faults and\n\t * kernelspace faults which result in die(), but not\n\t * kernelspace faults which are fixed up.  die() gives the\n\t * process no chance to handle the signal and notice the\n\t * kernel fault information, so that won't result in polluting\n\t * the information about previously queued, but not yet\n\t * delivered, faults.  See also do_general_protection below.\n\t */\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = trapnr;\n\n\tif (show_unhandled_signals && unhandled_signal(tsk, signr) &&\n\t    printk_ratelimit()) {\n\t\tpr_info(\"%s[%d] trap %s ip:%lx sp:%lx error:%lx\",\n\t\t\ttsk->comm, tsk->pid, str,\n\t\t\tregs->ip, regs->sp, error_code);\n\t\tprint_vma_addr(KERN_CONT \" in \", regs->ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tforce_sig_info(signr, info ?: SEND_SIG_PRIV, tsk);\n}\nNOKPROBE_SYMBOL(do_trap);\n\nstatic void do_error_trap(struct pt_regs *regs, long error_code, char *str,\n\t\t\t  unsigned long trapnr, int signr)\n{\n\tsiginfo_t info;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\n\t/*\n\t * WARN*()s end up here; fix them up before we call the\n\t * notifier chain.\n\t */\n\tif (!user_mode(regs) && fixup_bug(regs, trapnr))\n\t\treturn;\n\n\tif (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=\n\t\t\tNOTIFY_STOP) {\n\t\tcond_local_irq_enable(regs);\n\t\tdo_trap(trapnr, signr, str, regs, error_code,\n\t\t\tfill_trap_info(regs, signr, trapnr, &info));\n\t}\n}\n\n#define DO_ERROR(trapnr, signr, str, name)\t\t\t\t\\\ndotraplinkage void do_##name(struct pt_regs *regs, long error_code)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tdo_error_trap(regs, error_code, str, trapnr, signr);\t\t\\\n}\n\nDO_ERROR(X86_TRAP_DE,     SIGFPE,  \"divide error\",\t\tdivide_error)\nDO_ERROR(X86_TRAP_OF,     SIGSEGV, \"overflow\",\t\t\toverflow)\nDO_ERROR(X86_TRAP_UD,     SIGILL,  \"invalid opcode\",\t\tinvalid_op)\nDO_ERROR(X86_TRAP_OLD_MF, SIGFPE,  \"coprocessor segment overrun\",coprocessor_segment_overrun)\nDO_ERROR(X86_TRAP_TS,     SIGSEGV, \"invalid TSS\",\t\tinvalid_TSS)\nDO_ERROR(X86_TRAP_NP,     SIGBUS,  \"segment not present\",\tsegment_not_present)\nDO_ERROR(X86_TRAP_SS,     SIGBUS,  \"stack segment\",\t\tstack_segment)\nDO_ERROR(X86_TRAP_AC,     SIGBUS,  \"alignment check\",\t\talignment_check)\n\n#ifdef CONFIG_VMAP_STACK\n__visible void __noreturn handle_stack_overflow(const char *message,\n\t\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\t\tunsigned long fault_address)\n{\n\tprintk(KERN_EMERG \"BUG: stack guard page was hit at %p (stack is %p..%p)\\n\",\n\t\t (void *)fault_address, current->stack,\n\t\t (char *)current->stack + THREAD_SIZE - 1);\n\tdie(message, regs, 0);\n\n\t/* Be absolutely certain we don't return. */\n\tpanic(message);\n}\n#endif\n\n#ifdef CONFIG_X86_64\n/* Runs on IST stack */\ndotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)\n{\n\tstatic const char str[] = \"double fault\";\n\tstruct task_struct *tsk = current;\n#ifdef CONFIG_VMAP_STACK\n\tunsigned long cr2;\n#endif\n\n#ifdef CONFIG_X86_ESPFIX64\n\textern unsigned char native_irq_return_iret[];\n\n\t/*\n\t * If IRET takes a non-IST fault on the espfix64 stack, then we\n\t * end up promoting it to a doublefault.  In that case, take\n\t * advantage of the fact that we're not using the normal (TSS.sp0)\n\t * stack right now.  We can write a fake #GP(0) frame at TSS.sp0\n\t * and then modify our own IRET frame so that, when we return,\n\t * we land directly at the #GP(0) vector with the stack already\n\t * set up according to its expectations.\n\t *\n\t * The net result is that our #GP handler will think that we\n\t * entered from usermode with the bad user context.\n\t *\n\t * No need for ist_enter here because we don't use RCU.\n\t */\n\tif (((long)regs->sp >> P4D_SHIFT) == ESPFIX_PGD_ENTRY &&\n\t\tregs->cs == __KERNEL_CS &&\n\t\tregs->ip == (unsigned long)native_irq_return_iret)\n\t{\n\t\tstruct pt_regs *gpregs = (struct pt_regs *)this_cpu_read(cpu_tss_rw.x86_tss.sp0) - 1;\n\n\t\t/*\n\t\t * regs->sp points to the failing IRET frame on the\n\t\t * ESPFIX64 stack.  Copy it to the entry stack.  This fills\n\t\t * in gpregs->ss through gpregs->ip.\n\t\t *\n\t\t */\n\t\tmemmove(&gpregs->ip, (void *)regs->sp, 5*8);\n\t\tgpregs->orig_ax = 0;  /* Missing (lost) #GP error code */\n\n\t\t/*\n\t\t * Adjust our frame so that we return straight to the #GP\n\t\t * vector with the expected RSP value.  This is safe because\n\t\t * we won't enable interupts or schedule before we invoke\n\t\t * general_protection, so nothing will clobber the stack\n\t\t * frame we just set up.\n\t\t */\n\t\tregs->ip = (unsigned long)general_protection;\n\t\tregs->sp = (unsigned long)&gpregs->orig_ax;\n\n\t\treturn;\n\t}\n#endif\n\n\tist_enter(regs);\n\tnotify_die(DIE_TRAP, str, regs, error_code, X86_TRAP_DF, SIGSEGV);\n\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = X86_TRAP_DF;\n\n#ifdef CONFIG_VMAP_STACK\n\t/*\n\t * If we overflow the stack into a guard page, the CPU will fail\n\t * to deliver #PF and will send #DF instead.  Similarly, if we\n\t * take any non-IST exception while too close to the bottom of\n\t * the stack, the processor will get a page fault while\n\t * delivering the exception and will generate a double fault.\n\t *\n\t * According to the SDM (footnote in 6.15 under \"Interrupt 14 -\n\t * Page-Fault Exception (#PF):\n\t *\n\t *   Processors update CR2 whenever a page fault is detected. If a\n\t *   second page fault occurs while an earlier page fault is being\n\t *   delivered, the faulting linear address of the second fault will\n\t *   overwrite the contents of CR2 (replacing the previous\n\t *   address). These updates to CR2 occur even if the page fault\n\t *   results in a double fault or occurs during the delivery of a\n\t *   double fault.\n\t *\n\t * The logic below has a small possibility of incorrectly diagnosing\n\t * some errors as stack overflows.  For example, if the IDT or GDT\n\t * gets corrupted such that #GP delivery fails due to a bad descriptor\n\t * causing #GP and we hit this condition while CR2 coincidentally\n\t * points to the stack guard page, we'll think we overflowed the\n\t * stack.  Given that we're going to panic one way or another\n\t * if this happens, this isn't necessarily worth fixing.\n\t *\n\t * If necessary, we could improve the test by only diagnosing\n\t * a stack overflow if the saved RSP points within 47 bytes of\n\t * the bottom of the stack: if RSP == tsk_stack + 48 and we\n\t * take an exception, the stack is already aligned and there\n\t * will be enough room SS, RSP, RFLAGS, CS, RIP, and a\n\t * possible error code, so a stack overflow would *not* double\n\t * fault.  With any less space left, exception delivery could\n\t * fail, and, as a practical matter, we've overflowed the\n\t * stack even if the actual trigger for the double fault was\n\t * something else.\n\t */\n\tcr2 = read_cr2();\n\tif ((unsigned long)task_stack_page(tsk) - 1 - cr2 < PAGE_SIZE)\n\t\thandle_stack_overflow(\"kernel stack overflow (double-fault)\", regs, cr2);\n#endif\n\n#ifdef CONFIG_DOUBLEFAULT\n\tdf_debug(regs, error_code);\n#endif\n\t/*\n\t * This is always a kernel trap and never fixable (and thus must\n\t * never return).\n\t */\n\tfor (;;)\n\t\tdie(str, regs, error_code);\n}\n#endif\n\ndotraplinkage void do_bounds(struct pt_regs *regs, long error_code)\n{\n\tconst struct mpx_bndcsr *bndcsr;\n\tsiginfo_t *info;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tif (notify_die(DIE_TRAP, \"bounds\", regs, error_code,\n\t\t\tX86_TRAP_BR, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\tcond_local_irq_enable(regs);\n\n\tif (!user_mode(regs))\n\t\tdie(\"bounds\", regs, error_code);\n\n\tif (!cpu_feature_enabled(X86_FEATURE_MPX)) {\n\t\t/* The exception is not from Intel MPX */\n\t\tgoto exit_trap;\n\t}\n\n\t/*\n\t * We need to look at BNDSTATUS to resolve this exception.\n\t * A NULL here might mean that it is in its 'init state',\n\t * which is all zeros which indicates MPX was not\n\t * responsible for the exception.\n\t */\n\tbndcsr = get_xsave_field_ptr(XFEATURE_MASK_BNDCSR);\n\tif (!bndcsr)\n\t\tgoto exit_trap;\n\n\ttrace_bounds_exception_mpx(bndcsr);\n\t/*\n\t * The error code field of the BNDSTATUS register communicates status\n\t * information of a bound range exception #BR or operation involving\n\t * bound directory.\n\t */\n\tswitch (bndcsr->bndstatus & MPX_BNDSTA_ERROR_CODE) {\n\tcase 2:\t/* Bound directory has invalid entry. */\n\t\tif (mpx_handle_bd_fault())\n\t\t\tgoto exit_trap;\n\t\tbreak; /* Success, it was handled */\n\tcase 1: /* Bound violation. */\n\t\tinfo = mpx_generate_siginfo(regs);\n\t\tif (IS_ERR(info)) {\n\t\t\t/*\n\t\t\t * We failed to decode the MPX instruction.  Act as if\n\t\t\t * the exception was not caused by MPX.\n\t\t\t */\n\t\t\tgoto exit_trap;\n\t\t}\n\t\t/*\n\t\t * Success, we decoded the instruction and retrieved\n\t\t * an 'info' containing the address being accessed\n\t\t * which caused the exception.  This information\n\t\t * allows and application to possibly handle the\n\t\t * #BR exception itself.\n\t\t */\n\t\tdo_trap(X86_TRAP_BR, SIGSEGV, \"bounds\", regs, error_code, info);\n\t\tkfree(info);\n\t\tbreak;\n\tcase 0: /* No exception caused by Intel MPX operations. */\n\t\tgoto exit_trap;\n\tdefault:\n\t\tdie(\"bounds\", regs, error_code);\n\t}\n\n\treturn;\n\nexit_trap:\n\t/*\n\t * This path out is for all the cases where we could not\n\t * handle the exception in some way (like allocating a\n\t * table or telling userspace about it.  We will also end\n\t * up here if the kernel has MPX turned off at compile\n\t * time..\n\t */\n\tdo_trap(X86_TRAP_BR, SIGSEGV, \"bounds\", regs, error_code, NULL);\n}\n\ndotraplinkage void\ndo_general_protection(struct pt_regs *regs, long error_code)\n{\n\tstruct task_struct *tsk;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tcond_local_irq_enable(regs);\n\n\tif (static_cpu_has(X86_FEATURE_UMIP)) {\n\t\tif (user_mode(regs) && fixup_umip_exception(regs))\n\t\t\treturn;\n\t}\n\n\tif (v8086_mode(regs)) {\n\t\tlocal_irq_enable();\n\t\thandle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);\n\t\treturn;\n\t}\n\n\ttsk = current;\n\tif (!user_mode(regs)) {\n\t\tif (fixup_exception(regs, X86_TRAP_GP))\n\t\t\treturn;\n\n\t\ttsk->thread.error_code = error_code;\n\t\ttsk->thread.trap_nr = X86_TRAP_GP;\n\t\tif (notify_die(DIE_GPF, \"general protection fault\", regs, error_code,\n\t\t\t       X86_TRAP_GP, SIGSEGV) != NOTIFY_STOP)\n\t\t\tdie(\"general protection fault\", regs, error_code);\n\t\treturn;\n\t}\n\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = X86_TRAP_GP;\n\n\tif (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&\n\t\t\tprintk_ratelimit()) {\n\t\tpr_info(\"%s[%d] general protection ip:%lx sp:%lx error:%lx\",\n\t\t\ttsk->comm, task_pid_nr(tsk),\n\t\t\tregs->ip, regs->sp, error_code);\n\t\tprint_vma_addr(KERN_CONT \" in \", regs->ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tforce_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);\n}\nNOKPROBE_SYMBOL(do_general_protection);\n\n/* May run on IST stack. */\ndotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * ftrace must be first, everything else may cause a recursive crash.\n\t * See note by declaration of modifying_ftrace_code in ftrace.c\n\t */\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */\n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\n\t/*\n\t * Let others (NMI) know that the debug stack is in use\n\t * as we may switch to the interrupt stack.\n\t */\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}\nNOKPROBE_SYMBOL(do_int3);\n\n#ifdef CONFIG_X86_64\n/*\n * Help handler running on a per-cpu (IST or entry trampoline) stack\n * to switch to the normal thread stack if the interrupted code was in\n * user mode. The actual stack switch is done in entry_64.S\n */\nasmlinkage __visible notrace struct pt_regs *sync_regs(struct pt_regs *eregs)\n{\n\tstruct pt_regs *regs = (struct pt_regs *)this_cpu_read(cpu_current_top_of_stack) - 1;\n\tif (regs != eregs)\n\t\t*regs = *eregs;\n\treturn regs;\n}\nNOKPROBE_SYMBOL(sync_regs);\n\nstruct bad_iret_stack {\n\tvoid *error_entry_ret;\n\tstruct pt_regs regs;\n};\n\nasmlinkage __visible notrace\nstruct bad_iret_stack *fixup_bad_iret(struct bad_iret_stack *s)\n{\n\t/*\n\t * This is called from entry_64.S early in handling a fault\n\t * caused by a bad iret to user mode.  To handle the fault\n\t * correctly, we want to move our stack frame to where it would\n\t * be had we entered directly on the entry stack (rather than\n\t * just below the IRET frame) and we want to pretend that the\n\t * exception came from the IRET target.\n\t */\n\tstruct bad_iret_stack *new_stack =\n\t\t(struct bad_iret_stack *)this_cpu_read(cpu_tss_rw.x86_tss.sp0) - 1;\n\n\t/* Copy the IRET target to the new stack. */\n\tmemmove(&new_stack->regs.ip, (void *)s->regs.sp, 5*8);\n\n\t/* Copy the remainder of the stack from the current stack. */\n\tmemmove(new_stack, s, offsetof(struct bad_iret_stack, regs.ip));\n\n\tBUG_ON(!user_mode(&new_stack->regs));\n\treturn new_stack;\n}\nNOKPROBE_SYMBOL(fixup_bad_iret);\n#endif\n\nstatic bool is_sysenter_singlestep(struct pt_regs *regs)\n{\n\t/*\n\t * We don't try for precision here.  If we're anywhere in the region of\n\t * code that can be single-stepped in the SYSENTER entry path, then\n\t * assume that this is a useless single-step trap due to SYSENTER\n\t * being invoked with TF set.  (We don't know in advance exactly\n\t * which instructions will be hit because BTF could plausibly\n\t * be set.)\n\t */\n#ifdef CONFIG_X86_32\n\treturn (regs->ip - (unsigned long)__begin_SYSENTER_singlestep_region) <\n\t\t(unsigned long)__end_SYSENTER_singlestep_region -\n\t\t(unsigned long)__begin_SYSENTER_singlestep_region;\n#elif defined(CONFIG_IA32_EMULATION)\n\treturn (regs->ip - (unsigned long)entry_SYSENTER_compat) <\n\t\t(unsigned long)__end_entry_SYSENTER_compat -\n\t\t(unsigned long)entry_SYSENTER_compat;\n#else\n\treturn false;\n#endif\n}\n\n/*\n * Our handling of the processor debug registers is non-trivial.\n * We do not clear them on entry and exit from the kernel. Therefore\n * it is possible to get a watchpoint trap here from inside the kernel.\n * However, the code in ./ptrace.c has ensured that the user can\n * only set watchpoints on userspace addresses. Therefore the in-kernel\n * watchpoint trap can only occur in code which is reading/writing\n * from user space. Such code must not hold kernel locks (since it\n * can equally take a page fault), therefore it is safe to call\n * force_sig_info even though that claims and releases locks.\n *\n * Code in ./signal.c ensures that the debug control register\n * is restored before we deliver any signal, and therefore that\n * user code runs with the correct debug control register even though\n * we clear it here.\n *\n * Being careful here means that we don't have to be as careful in a\n * lot of more complicated places (task switching can be a bit lazy\n * about restoring all the debug state, and ptrace doesn't have to\n * find every occurrence of the TF bit that could be saved away even\n * by user code)\n *\n * May run on IST stack.\n */\ndotraplinkage void do_debug(struct pt_regs *regs, long error_code)\n{\n\tstruct task_struct *tsk = current;\n\tint user_icebp = 0;\n\tunsigned long dr6;\n\tint si_code;\n\n\tist_enter(regs);\n\n\tget_debugreg(dr6, 6);\n\t/*\n\t * The Intel SDM says:\n\t *\n\t *   Certain debug exceptions may clear bits 0-3. The remaining\n\t *   contents of the DR6 register are never cleared by the\n\t *   processor. To avoid confusion in identifying debug\n\t *   exceptions, debug handlers should clear the register before\n\t *   returning to the interrupted task.\n\t *\n\t * Keep it simple: clear DR6 immediately.\n\t */\n\tset_debugreg(0, 6);\n\n\t/* Filter out all the reserved bits which are preset to 1 */\n\tdr6 &= ~DR6_RESERVED;\n\n\t/*\n\t * The SDM says \"The processor clears the BTF flag when it\n\t * generates a debug exception.\"  Clear TIF_BLOCKSTEP to keep\n\t * TIF_BLOCKSTEP in sync with the hardware BTF flag.\n\t */\n\tclear_tsk_thread_flag(tsk, TIF_BLOCKSTEP);\n\n\tif (unlikely(!user_mode(regs) && (dr6 & DR_STEP) &&\n\t\t     is_sysenter_singlestep(regs))) {\n\t\tdr6 &= ~DR_STEP;\n\t\tif (!dr6)\n\t\t\tgoto exit;\n\t\t/*\n\t\t * else we might have gotten a single-step trap and hit a\n\t\t * watchpoint at the same time, in which case we should fall\n\t\t * through and handle the watchpoint.\n\t\t */\n\t}\n\n\t/*\n\t * If dr6 has no reason to give us about the origin of this trap,\n\t * then it's very likely the result of an icebp/int01 trap.\n\t * User wants a sigtrap for that.\n\t */\n\tif (!dr6 && user_mode(regs))\n\t\tuser_icebp = 1;\n\n\t/* Store the virtualized DR6 value */\n\ttsk->thread.debugreg6 = dr6;\n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_debug_handler(regs))\n\t\tgoto exit;\n#endif\n\n\tif (notify_die(DIE_DEBUG, \"debug\", regs, (long)&dr6, error_code,\n\t\t\t\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\n\t/*\n\t * Let others (NMI) know that the debug stack is in use\n\t * as we may switch to the interrupt stack.\n\t */\n\tdebug_stack_usage_inc();\n\n\t/* It's safe to allow irq's after DR6 has been saved */\n\tcond_local_irq_enable(regs);\n\n\tif (v8086_mode(regs)) {\n\t\thandle_vm86_trap((struct kernel_vm86_regs *) regs, error_code,\n\t\t\t\t\tX86_TRAP_DB);\n\t\tcond_local_irq_disable(regs);\n\t\tdebug_stack_usage_dec();\n\t\tgoto exit;\n\t}\n\n\tif (WARN_ON_ONCE((dr6 & DR_STEP) && !user_mode(regs))) {\n\t\t/*\n\t\t * Historical junk that used to handle SYSENTER single-stepping.\n\t\t * This should be unreachable now.  If we survive for a while\n\t\t * without anyone hitting this warning, we'll turn this into\n\t\t * an oops.\n\t\t */\n\t\ttsk->thread.debugreg6 &= ~DR_STEP;\n\t\tset_tsk_thread_flag(tsk, TIF_SINGLESTEP);\n\t\tregs->flags &= ~X86_EFLAGS_TF;\n\t}\n\tsi_code = get_si_code(tsk->thread.debugreg6);\n\tif (tsk->thread.debugreg6 & (DR_STEP | DR_TRAP_BITS) || user_icebp)\n\t\tsend_sigtrap(tsk, regs, error_code, si_code);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\n\nexit:\n\tist_exit(regs);\n}\nNOKPROBE_SYMBOL(do_debug);\n\n/*\n * Note that we play around with the 'TS' bit in an attempt to get\n * the correct behaviour even in the presence of the asynchronous\n * IRQ13 behaviour\n */\nstatic void math_error(struct pt_regs *regs, int error_code, int trapnr)\n{\n\tstruct task_struct *task = current;\n\tstruct fpu *fpu = &task->thread.fpu;\n\tsiginfo_t info;\n\tchar *str = (trapnr == X86_TRAP_MF) ? \"fpu exception\" :\n\t\t\t\t\t\t\"simd exception\";\n\n\tif (notify_die(DIE_TRAP, str, regs, error_code, trapnr, SIGFPE) == NOTIFY_STOP)\n\t\treturn;\n\tcond_local_irq_enable(regs);\n\n\tif (!user_mode(regs)) {\n\t\tif (!fixup_exception(regs, trapnr)) {\n\t\t\ttask->thread.error_code = error_code;\n\t\t\ttask->thread.trap_nr = trapnr;\n\t\t\tdie(str, regs, error_code);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Save the info for the exception handler and clear the error.\n\t */\n\tfpu__save(fpu);\n\n\ttask->thread.trap_nr\t= trapnr;\n\ttask->thread.error_code = error_code;\n\tinfo.si_signo\t\t= SIGFPE;\n\tinfo.si_errno\t\t= 0;\n\tinfo.si_addr\t\t= (void __user *)uprobe_get_trap_addr(regs);\n\n\tinfo.si_code = fpu__exception_code(fpu, trapnr);\n\n\t/* Retry when we get spurious exceptions: */\n\tif (!info.si_code)\n\t\treturn;\n\n\tforce_sig_info(SIGFPE, &info, task);\n}\n\ndotraplinkage void do_coprocessor_error(struct pt_regs *regs, long error_code)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tmath_error(regs, error_code, X86_TRAP_MF);\n}\n\ndotraplinkage void\ndo_simd_coprocessor_error(struct pt_regs *regs, long error_code)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tmath_error(regs, error_code, X86_TRAP_XF);\n}\n\ndotraplinkage void\ndo_spurious_interrupt_bug(struct pt_regs *regs, long error_code)\n{\n\tcond_local_irq_enable(regs);\n}\n\ndotraplinkage void\ndo_device_not_available(struct pt_regs *regs, long error_code)\n{\n\tunsigned long cr0;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\n#ifdef CONFIG_MATH_EMULATION\n\tif (!boot_cpu_has(X86_FEATURE_FPU) && (read_cr0() & X86_CR0_EM)) {\n\t\tstruct math_emu_info info = { };\n\n\t\tcond_local_irq_enable(regs);\n\n\t\tinfo.regs = regs;\n\t\tmath_emulate(&info);\n\t\treturn;\n\t}\n#endif\n\n\t/* This should not happen. */\n\tcr0 = read_cr0();\n\tif (WARN(cr0 & X86_CR0_TS, \"CR0.TS was set\")) {\n\t\t/* Try to fix it up and carry on. */\n\t\twrite_cr0(cr0 & ~X86_CR0_TS);\n\t} else {\n\t\t/*\n\t\t * Something terrible happened, and we're better off trying\n\t\t * to kill the task than getting stuck in a never-ending\n\t\t * loop of #NM faults.\n\t\t */\n\t\tdie(\"unexpected #NM exception\", regs, error_code);\n\t}\n}\nNOKPROBE_SYMBOL(do_device_not_available);\n\n#ifdef CONFIG_X86_32\ndotraplinkage void do_iret_error(struct pt_regs *regs, long error_code)\n{\n\tsiginfo_t info;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tlocal_irq_enable();\n\n\tinfo.si_signo = SIGILL;\n\tinfo.si_errno = 0;\n\tinfo.si_code = ILL_BADSTK;\n\tinfo.si_addr = NULL;\n\tif (notify_die(DIE_TRAP, \"iret exception\", regs, error_code,\n\t\t\tX86_TRAP_IRET, SIGILL) != NOTIFY_STOP) {\n\t\tdo_trap(X86_TRAP_IRET, SIGILL, \"iret exception\", regs, error_code,\n\t\t\t&info);\n\t}\n}\n#endif\n\nvoid __init trap_init(void)\n{\n\t/* Init cpu_entry_area before IST entries are set up */\n\tsetup_cpu_entry_areas();\n\n\tidt_setup_traps();\n\n\t/*\n\t * Set the IDT descriptor to a fixed read-only location, so that the\n\t * \"sidt\" instruction will not leak the location of the kernel, and\n\t * to defend the IDT against arbitrary memory write vulnerabilities.\n\t * It will be reloaded in cpu_init() */\n\tcea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),\n\t\t    PAGE_KERNEL_RO);\n\tidt_descr.address = CPU_ENTRY_AREA_RO_IDT;\n\n\t/*\n\t * Should be a barrier for any external CPU state:\n\t */\n\tcpu_init();\n\n\tidt_setup_ist_traps();\n\n\tx86_init.irqs.trap_init();\n\n\tidt_setup_debugidt_traps();\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n/*\n *  linux/arch/x86_64/entry.S\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 2000, 2001, 2002  Andi Kleen SuSE Labs\n *  Copyright (C) 2000  Pavel Machek <pavel@suse.cz>\n *\n * entry.S contains the system-call and fault low-level handling routines.\n *\n * Some of this is documented in Documentation/x86/entry_64.txt\n *\n * A note on terminology:\n * - iret frame:\tArchitecture defined interrupt frame from SS to RIP\n *\t\t\tat the top of the kernel process stack.\n *\n * Some macro usage:\n * - ENTRY/END:\t\tDefine functions in the symbol table.\n * - TRACE_IRQ_*:\tTrace hardirq state for lock debugging.\n * - idtentry:\t\tDefine exception entry points.\n */\n#include <linux/linkage.h>\n#include <asm/segment.h>\n#include <asm/cache.h>\n#include <asm/errno.h>\n#include <asm/asm-offsets.h>\n#include <asm/msr.h>\n#include <asm/unistd.h>\n#include <asm/thread_info.h>\n#include <asm/hw_irq.h>\n#include <asm/page_types.h>\n#include <asm/irqflags.h>\n#include <asm/paravirt.h>\n#include <asm/percpu.h>\n#include <asm/asm.h>\n#include <asm/smap.h>\n#include <asm/pgtable_types.h>\n#include <asm/export.h>\n#include <asm/frame.h>\n#include <asm/nospec-branch.h>\n#include <linux/err.h>\n\n#include \"calling.h\"\n\n.code64\n.section .entry.text, \"ax\"\n\n#ifdef CONFIG_PARAVIRT\nENTRY(native_usergs_sysret64)\n\tUNWIND_HINT_EMPTY\n\tswapgs\n\tsysretq\nEND(native_usergs_sysret64)\n#endif /* CONFIG_PARAVIRT */\n\n.macro TRACE_IRQS_FLAGS flags:req\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tbt\t$9, \\flags\t\t/* interrupts off? */\n\tjnc\t1f\n\tTRACE_IRQS_ON\n1:\n#endif\n.endm\n\n.macro TRACE_IRQS_IRETQ\n\tTRACE_IRQS_FLAGS EFLAGS(%rsp)\n.endm\n\n/*\n * When dynamic function tracer is enabled it will add a breakpoint\n * to all locations that it is about to modify, sync CPUs, update\n * all the code, sync CPUs, then remove the breakpoints. In this time\n * if lockdep is enabled, it might jump back into the debug handler\n * outside the updating of the IST protection. (TRACE_IRQS_ON/OFF).\n *\n * We need to change the IDT table before calling TRACE_IRQS_ON/OFF to\n * make sure the stack pointer does not get reset back to the top\n * of the debug stack, and instead just reuses the current stack.\n */\n#if defined(CONFIG_DYNAMIC_FTRACE) && defined(CONFIG_TRACE_IRQFLAGS)\n\n.macro TRACE_IRQS_OFF_DEBUG\n\tcall\tdebug_stack_set_zero\n\tTRACE_IRQS_OFF\n\tcall\tdebug_stack_reset\n.endm\n\n.macro TRACE_IRQS_ON_DEBUG\n\tcall\tdebug_stack_set_zero\n\tTRACE_IRQS_ON\n\tcall\tdebug_stack_reset\n.endm\n\n.macro TRACE_IRQS_IRETQ_DEBUG\n\tbt\t$9, EFLAGS(%rsp)\t\t/* interrupts off? */\n\tjnc\t1f\n\tTRACE_IRQS_ON_DEBUG\n1:\n.endm\n\n#else\n# define TRACE_IRQS_OFF_DEBUG\t\t\tTRACE_IRQS_OFF\n# define TRACE_IRQS_ON_DEBUG\t\t\tTRACE_IRQS_ON\n# define TRACE_IRQS_IRETQ_DEBUG\t\t\tTRACE_IRQS_IRETQ\n#endif\n\n/*\n * 64-bit SYSCALL instruction entry. Up to 6 arguments in registers.\n *\n * This is the only entry point used for 64-bit system calls.  The\n * hardware interface is reasonably well designed and the register to\n * argument mapping Linux uses fits well with the registers that are\n * available when SYSCALL is used.\n *\n * SYSCALL instructions can be found inlined in libc implementations as\n * well as some other programs and libraries.  There are also a handful\n * of SYSCALL instructions in the vDSO used, for example, as a\n * clock_gettimeofday fallback.\n *\n * 64-bit SYSCALL saves rip to rcx, clears rflags.RF, then saves rflags to r11,\n * then loads new ss, cs, and rip from previously programmed MSRs.\n * rflags gets masked by a value from another MSR (so CLD and CLAC\n * are not needed). SYSCALL does not save anything on the stack\n * and does not change rsp.\n *\n * Registers on entry:\n * rax  system call number\n * rcx  return address\n * r11  saved rflags (note: r11 is callee-clobbered register in C ABI)\n * rdi  arg0\n * rsi  arg1\n * rdx  arg2\n * r10  arg3 (needs to be moved to rcx to conform to C ABI)\n * r8   arg4\n * r9   arg5\n * (note: r12-r15, rbp, rbx are callee-preserved in C ABI)\n *\n * Only called from user space.\n *\n * When user can change pt_regs->foo always force IRET. That is because\n * it deals with uncanonical addresses better. SYSRET has trouble\n * with them due to bugs in both AMD and Intel CPUs.\n */\n\n\t.pushsection .entry_trampoline, \"ax\"\n\n/*\n * The code in here gets remapped into cpu_entry_area's trampoline.  This means\n * that the assembler and linker have the wrong idea as to where this code\n * lives (and, in fact, it's mapped more than once, so it's not even at a\n * fixed address).  So we can't reference any symbols outside the entry\n * trampoline and expect it to work.\n *\n * Instead, we carefully abuse %rip-relative addressing.\n * _entry_trampoline(%rip) refers to the start of the remapped) entry\n * trampoline.  We can thus find cpu_entry_area with this macro:\n */\n\n#define CPU_ENTRY_AREA \\\n\t_entry_trampoline - CPU_ENTRY_AREA_entry_trampoline(%rip)\n\n/* The top word of the SYSENTER stack is hot and is usable as scratch space. */\n#define RSP_SCRATCH\tCPU_ENTRY_AREA_entry_stack + \\\n\t\t\tSIZEOF_entry_stack - 8 + CPU_ENTRY_AREA\n\nENTRY(entry_SYSCALL_64_trampoline)\n\tUNWIND_HINT_EMPTY\n\tswapgs\n\n\t/* Stash the user RSP. */\n\tmovq\t%rsp, RSP_SCRATCH\n\n\t/* Note: using %rsp as a scratch reg. */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp\n\n\t/* Load the top of the task stack into RSP */\n\tmovq\tCPU_ENTRY_AREA_tss + TSS_sp1 + CPU_ENTRY_AREA, %rsp\n\n\t/* Start building the simulated IRET frame. */\n\tpushq\t$__USER_DS\t\t\t/* pt_regs->ss */\n\tpushq\tRSP_SCRATCH\t\t\t/* pt_regs->sp */\n\tpushq\t%r11\t\t\t\t/* pt_regs->flags */\n\tpushq\t$__USER_CS\t\t\t/* pt_regs->cs */\n\tpushq\t%rcx\t\t\t\t/* pt_regs->ip */\n\n\t/*\n\t * x86 lacks a near absolute jump, and we can't jump to the real\n\t * entry text with a relative jump.  We could push the target\n\t * address and then use retq, but this destroys the pipeline on\n\t * many CPUs (wasting over 20 cycles on Sandy Bridge).  Instead,\n\t * spill RDI and restore it in a second-stage trampoline.\n\t */\n\tpushq\t%rdi\n\tmovq\t$entry_SYSCALL_64_stage2, %rdi\n\tJMP_NOSPEC %rdi\nEND(entry_SYSCALL_64_trampoline)\n\n\t.popsection\n\nENTRY(entry_SYSCALL_64_stage2)\n\tUNWIND_HINT_EMPTY\n\tpopq\t%rdi\n\tjmp\tentry_SYSCALL_64_after_hwframe\nEND(entry_SYSCALL_64_stage2)\n\nENTRY(entry_SYSCALL_64)\n\tUNWIND_HINT_EMPTY\n\t/*\n\t * Interrupts are off on entry.\n\t * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON,\n\t * it is too small to ever cause noticeable irq latency.\n\t */\n\n\tswapgs\n\t/*\n\t * This path is only taken when PAGE_TABLE_ISOLATION is disabled so it\n\t * is not required to switch CR3.\n\t */\n\tmovq\t%rsp, PER_CPU_VAR(rsp_scratch)\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n\t/* Construct struct pt_regs on stack */\n\tpushq\t$__USER_DS\t\t\t/* pt_regs->ss */\n\tpushq\tPER_CPU_VAR(rsp_scratch)\t/* pt_regs->sp */\n\tpushq\t%r11\t\t\t\t/* pt_regs->flags */\n\tpushq\t$__USER_CS\t\t\t/* pt_regs->cs */\n\tpushq\t%rcx\t\t\t\t/* pt_regs->ip */\nGLOBAL(entry_SYSCALL_64_after_hwframe)\n\tpushq\t%rax\t\t\t\t/* pt_regs->orig_ax */\n\n\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS\n\n\tTRACE_IRQS_OFF\n\n\t/* IRQs are off. */\n\tmovq\t%rsp, %rdi\n\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */\n\n\tTRACE_IRQS_IRETQ\t\t/* we're about to change IF */\n\n\t/*\n\t * Try to use SYSRET instead of IRET if we're returning to\n\t * a completely clean 64-bit userspace context.  If we're not,\n\t * go to the slow exit path.\n\t */\n\tmovq\tRCX(%rsp), %rcx\n\tmovq\tRIP(%rsp), %r11\n\n\tcmpq\t%rcx, %r11\t/* SYSRET requires RCX == RIP */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\t/*\n\t * On Intel CPUs, SYSRET with non-canonical RCX/RIP will #GP\n\t * in kernel space.  This essentially lets the user take over\n\t * the kernel, since userspace controls RSP.\n\t *\n\t * If width of \"canonical tail\" ever becomes variable, this will need\n\t * to be updated to remain correct on both old and new CPUs.\n\t *\n\t * Change top bits to match most significant bit (47th or 56th bit\n\t * depending on paging mode) in the address.\n\t */\n\tshl\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx\n\tsar\t$(64 - (__VIRTUAL_MASK_SHIFT+1)), %rcx\n\n\t/* If this changed %rcx, it was not canonical */\n\tcmpq\t%rcx, %r11\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\tcmpq\t$__USER_CS, CS(%rsp)\t\t/* CS must match SYSRET */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\tmovq\tR11(%rsp), %r11\n\tcmpq\t%r11, EFLAGS(%rsp)\t\t/* R11 == RFLAGS */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\t/*\n\t * SYSCALL clears RF when it saves RFLAGS in R11 and SYSRET cannot\n\t * restore RF properly. If the slowpath sets it for whatever reason, we\n\t * need to restore it correctly.\n\t *\n\t * SYSRET can restore TF, but unlike IRET, restoring TF results in a\n\t * trap from userspace immediately after SYSRET.  This would cause an\n\t * infinite loop whenever #DB happens with register state that satisfies\n\t * the opportunistic SYSRET conditions.  For example, single-stepping\n\t * this user code:\n\t *\n\t *           movq\t$stuck_here, %rcx\n\t *           pushfq\n\t *           popq %r11\n\t *   stuck_here:\n\t *\n\t * would never get past 'stuck_here'.\n\t */\n\ttestq\t$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11\n\tjnz\tswapgs_restore_regs_and_return_to_usermode\n\n\t/* nothing to check for RSP */\n\n\tcmpq\t$__USER_DS, SS(%rsp)\t\t/* SS must match SYSRET */\n\tjne\tswapgs_restore_regs_and_return_to_usermode\n\n\t/*\n\t * We win! This label is here just for ease of understanding\n\t * perf profiles. Nothing jumps here.\n\t */\nsyscall_return_via_sysret:\n\t/* rcx and r11 are already restored (see code above) */\n\tUNWIND_HINT_EMPTY\n\tPOP_REGS pop_rdi=0 skip_r11rcx=1\n\n\t/*\n\t * Now all regs are restored except RSP and RDI.\n\t * Save old stack pointer and switch to trampoline stack.\n\t */\n\tmovq\t%rsp, %rdi\n\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp\n\n\tpushq\tRSP-RDI(%rdi)\t/* RSP */\n\tpushq\t(%rdi)\t\t/* RDI */\n\n\t/*\n\t * We are on the trampoline stack.  All regs except RDI are live.\n\t * We can do future final exit work right here.\n\t */\n\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi\n\n\tpopq\t%rdi\n\tpopq\t%rsp\n\tUSERGS_SYSRET64\nEND(entry_SYSCALL_64)\n\n/*\n * %rdi: prev task\n * %rsi: next task\n */\nENTRY(__switch_to_asm)\n\tUNWIND_HINT_FUNC\n\t/*\n\t * Save callee-saved registers\n\t * This must match the order in inactive_task_frame\n\t */\n\tpushq\t%rbp\n\tpushq\t%rbx\n\tpushq\t%r12\n\tpushq\t%r13\n\tpushq\t%r14\n\tpushq\t%r15\n\n\t/* switch stack */\n\tmovq\t%rsp, TASK_threadsp(%rdi)\n\tmovq\tTASK_threadsp(%rsi), %rsp\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\tmovq\tTASK_stack_canary(%rsi), %rbx\n\tmovq\t%rbx, PER_CPU_VAR(irq_stack_union)+stack_canary_offset\n#endif\n\n#ifdef CONFIG_RETPOLINE\n\t/*\n\t * When switching from a shallower to a deeper call stack\n\t * the RSB may either underflow or use entries populated\n\t * with userspace addresses. On CPUs where those concerns\n\t * exist, overwrite the RSB with entries which capture\n\t * speculative execution to prevent attack.\n\t */\n\tFILL_RETURN_BUFFER %r12, RSB_CLEAR_LOOPS, X86_FEATURE_RSB_CTXSW\n#endif\n\n\t/* restore callee-saved registers */\n\tpopq\t%r15\n\tpopq\t%r14\n\tpopq\t%r13\n\tpopq\t%r12\n\tpopq\t%rbx\n\tpopq\t%rbp\n\n\tjmp\t__switch_to\nEND(__switch_to_asm)\n\n/*\n * A newly forked process directly context switches into this address.\n *\n * rax: prev task we switched from\n * rbx: kernel thread func (NULL for user thread)\n * r12: kernel thread arg\n */\nENTRY(ret_from_fork)\n\tUNWIND_HINT_EMPTY\n\tmovq\t%rax, %rdi\n\tcall\tschedule_tail\t\t\t/* rdi: 'prev' task parameter */\n\n\ttestq\t%rbx, %rbx\t\t\t/* from kernel_thread? */\n\tjnz\t1f\t\t\t\t/* kernel threads are uncommon */\n\n2:\n\tUNWIND_HINT_REGS\n\tmovq\t%rsp, %rdi\n\tcall\tsyscall_return_slowpath\t/* returns with IRQs disabled */\n\tTRACE_IRQS_ON\t\t\t/* user mode is traced as IRQS on */\n\tjmp\tswapgs_restore_regs_and_return_to_usermode\n\n1:\n\t/* kernel thread */\n\tmovq\t%r12, %rdi\n\tCALL_NOSPEC %rbx\n\t/*\n\t * A kernel thread is allowed to return here after successfully\n\t * calling do_execve().  Exit to userspace to complete the execve()\n\t * syscall.\n\t */\n\tmovq\t$0, RAX(%rsp)\n\tjmp\t2b\nEND(ret_from_fork)\n\n/*\n * Build the entry stubs with some assembler magic.\n * We pack 1 stub into every 8-byte block.\n */\n\t.align 8\nENTRY(irq_entries_start)\n    vector=FIRST_EXTERNAL_VECTOR\n    .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)\n\tUNWIND_HINT_IRET_REGS\n\tpushq\t$(~vector+0x80)\t\t\t/* Note: always in signed byte range */\n\tjmp\tcommon_interrupt\n\t.align\t8\n\tvector=vector+1\n    .endr\nEND(irq_entries_start)\n\n.macro DEBUG_ENTRY_ASSERT_IRQS_OFF\n#ifdef CONFIG_DEBUG_ENTRY\n\tpushq %rax\n\tSAVE_FLAGS(CLBR_RAX)\n\ttestl $X86_EFLAGS_IF, %eax\n\tjz .Lokay_\\@\n\tud2\n.Lokay_\\@:\n\tpopq %rax\n#endif\n.endm\n\n/*\n * Enters the IRQ stack if we're not already using it.  NMI-safe.  Clobbers\n * flags and puts old RSP into old_rsp, and leaves all other GPRs alone.\n * Requires kernel GSBASE.\n *\n * The invariant is that, if irq_count != -1, then the IRQ stack is in use.\n */\n.macro ENTER_IRQ_STACK regs=1 old_rsp save_ret=0\n\tDEBUG_ENTRY_ASSERT_IRQS_OFF\n\n\t.if \\save_ret\n\t/*\n\t * If save_ret is set, the original stack contains one additional\n\t * entry -- the return address. Therefore, move the address one\n\t * entry below %rsp to \\old_rsp.\n\t */\n\tleaq\t8(%rsp), \\old_rsp\n\t.else\n\tmovq\t%rsp, \\old_rsp\n\t.endif\n\n\t.if \\regs\n\tUNWIND_HINT_REGS base=\\old_rsp\n\t.endif\n\n\tincl\tPER_CPU_VAR(irq_count)\n\tjnz\t.Lirq_stack_push_old_rsp_\\@\n\n\t/*\n\t * Right now, if we just incremented irq_count to zero, we've\n\t * claimed the IRQ stack but we haven't switched to it yet.\n\t *\n\t * If anything is added that can interrupt us here without using IST,\n\t * it must be *extremely* careful to limit its stack usage.  This\n\t * could include kprobes and a hypothetical future IST-less #DB\n\t * handler.\n\t *\n\t * The OOPS unwinder relies on the word at the top of the IRQ\n\t * stack linking back to the previous RSP for the entire time we're\n\t * on the IRQ stack.  For this to work reliably, we need to write\n\t * it before we actually move ourselves to the IRQ stack.\n\t */\n\n\tmovq\t\\old_rsp, PER_CPU_VAR(irq_stack_union + IRQ_STACK_SIZE - 8)\n\tmovq\tPER_CPU_VAR(irq_stack_ptr), %rsp\n\n#ifdef CONFIG_DEBUG_ENTRY\n\t/*\n\t * If the first movq above becomes wrong due to IRQ stack layout\n\t * changes, the only way we'll notice is if we try to unwind right\n\t * here.  Assert that we set up the stack right to catch this type\n\t * of bug quickly.\n\t */\n\tcmpq\t-8(%rsp), \\old_rsp\n\tje\t.Lirq_stack_okay\\@\n\tud2\n\t.Lirq_stack_okay\\@:\n#endif\n\n.Lirq_stack_push_old_rsp_\\@:\n\tpushq\t\\old_rsp\n\n\t.if \\regs\n\tUNWIND_HINT_REGS indirect=1\n\t.endif\n\n\t.if \\save_ret\n\t/*\n\t * Push the return address to the stack. This return address can\n\t * be found at the \"real\" original RSP, which was offset by 8 at\n\t * the beginning of this macro.\n\t */\n\tpushq\t-8(\\old_rsp)\n\t.endif\n.endm\n\n/*\n * Undoes ENTER_IRQ_STACK.\n */\n.macro LEAVE_IRQ_STACK regs=1\n\tDEBUG_ENTRY_ASSERT_IRQS_OFF\n\t/* We need to be off the IRQ stack before decrementing irq_count. */\n\tpopq\t%rsp\n\n\t.if \\regs\n\tUNWIND_HINT_REGS\n\t.endif\n\n\t/*\n\t * As in ENTER_IRQ_STACK, irq_count == 0, we are still claiming\n\t * the irq stack but we're not on it.\n\t */\n\n\tdecl\tPER_CPU_VAR(irq_count)\n.endm\n\n/*\n * Interrupt entry helper function.\n *\n * Entry runs with interrupts off. Stack layout at entry:\n * +----------------------------------------------------+\n * | regs->ss\t\t\t\t\t\t|\n * | regs->rsp\t\t\t\t\t\t|\n * | regs->eflags\t\t\t\t\t|\n * | regs->cs\t\t\t\t\t\t|\n * | regs->ip\t\t\t\t\t\t|\n * +----------------------------------------------------+\n * | regs->orig_ax = ~(interrupt number)\t\t|\n * +----------------------------------------------------+\n * | return address\t\t\t\t\t|\n * +----------------------------------------------------+\n */\nENTRY(interrupt_entry)\n\tUNWIND_HINT_FUNC\n\tASM_CLAC\n\tcld\n\n\ttestb\t$3, CS-ORIG_RAX+8(%rsp)\n\tjz\t1f\n\tSWAPGS\n\n\t/*\n\t * Switch to the thread stack. The IRET frame and orig_ax are\n\t * on the stack, as well as the return address. RDI..R12 are\n\t * not (yet) on the stack and space has not (yet) been\n\t * allocated for them.\n\t */\n\tpushq\t%rdi\n\n\t/* Need to switch before accessing the thread stack. */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rdi\n\tmovq\t%rsp, %rdi\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n\t /*\n\t  * We have RDI, return address, and orig_ax on the stack on\n\t  * top of the IRET frame. That means offset=24\n\t  */\n\tUNWIND_HINT_IRET_REGS base=%rdi offset=24\n\n\tpushq\t7*8(%rdi)\t\t/* regs->ss */\n\tpushq\t6*8(%rdi)\t\t/* regs->rsp */\n\tpushq\t5*8(%rdi)\t\t/* regs->eflags */\n\tpushq\t4*8(%rdi)\t\t/* regs->cs */\n\tpushq\t3*8(%rdi)\t\t/* regs->ip */\n\tpushq\t2*8(%rdi)\t\t/* regs->orig_ax */\n\tpushq\t8(%rdi)\t\t\t/* return address */\n\tUNWIND_HINT_FUNC\n\n\tmovq\t(%rdi), %rdi\n1:\n\n\tPUSH_AND_CLEAR_REGS save_ret=1\n\tENCODE_FRAME_POINTER 8\n\n\ttestb\t$3, CS+8(%rsp)\n\tjz\t1f\n\n\t/*\n\t * IRQ from user mode.\n\t *\n\t * We need to tell lockdep that IRQs are off.  We can't do this until\n\t * we fix gsbase, and we should do it before enter_from_user_mode\n\t * (which can take locks).  Since TRACE_IRQS_OFF is idempotent,\n\t * the simplest way to handle it is to just call it twice if\n\t * we enter from user mode.  There's no reason to optimize this since\n\t * TRACE_IRQS_OFF is a no-op if lockdep is off.\n\t */\n\tTRACE_IRQS_OFF\n\n\tCALL_enter_from_user_mode\n\n1:\n\tENTER_IRQ_STACK old_rsp=%rdi save_ret=1\n\t/* We entered an interrupt context - irqs are off: */\n\tTRACE_IRQS_OFF\n\n\tret\nEND(interrupt_entry)\n\n\n/* Interrupt entry/exit. */\n\n\t/*\n\t * The interrupt stubs push (~vector+0x80) onto the stack and\n\t * then jump to common_interrupt.\n\t */\n\t.p2align CONFIG_X86_L1_CACHE_SHIFT\ncommon_interrupt:\n\taddq\t$-0x80, (%rsp)\t\t\t/* Adjust vector to [-256, -1] range */\n\tcall\tinterrupt_entry\n\tUNWIND_HINT_REGS indirect=1\n\tcall\tdo_IRQ\t/* rdi points to pt_regs */\n\t/* 0(%rsp): old RSP */\nret_from_intr:\n\tDISABLE_INTERRUPTS(CLBR_ANY)\n\tTRACE_IRQS_OFF\n\n\tLEAVE_IRQ_STACK\n\n\ttestb\t$3, CS(%rsp)\n\tjz\tretint_kernel\n\n\t/* Interrupt came from user space */\nGLOBAL(retint_user)\n\tmov\t%rsp,%rdi\n\tcall\tprepare_exit_to_usermode\n\tTRACE_IRQS_IRETQ\n\nGLOBAL(swapgs_restore_regs_and_return_to_usermode)\n#ifdef CONFIG_DEBUG_ENTRY\n\t/* Assert that pt_regs indicates user mode. */\n\ttestb\t$3, CS(%rsp)\n\tjnz\t1f\n\tud2\n1:\n#endif\n\tPOP_REGS pop_rdi=0\n\n\t/*\n\t * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.\n\t * Save old stack pointer and switch to trampoline stack.\n\t */\n\tmovq\t%rsp, %rdi\n\tmovq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp\n\n\t/* Copy the IRET frame to the trampoline stack. */\n\tpushq\t6*8(%rdi)\t/* SS */\n\tpushq\t5*8(%rdi)\t/* RSP */\n\tpushq\t4*8(%rdi)\t/* EFLAGS */\n\tpushq\t3*8(%rdi)\t/* CS */\n\tpushq\t2*8(%rdi)\t/* RIP */\n\n\t/* Push user RDI on the trampoline stack. */\n\tpushq\t(%rdi)\n\n\t/*\n\t * We are on the trampoline stack.  All regs except RDI are live.\n\t * We can do future final exit work right here.\n\t */\n\n\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi\n\n\t/* Restore RDI. */\n\tpopq\t%rdi\n\tSWAPGS\n\tINTERRUPT_RETURN\n\n\n/* Returning to kernel space */\nretint_kernel:\n#ifdef CONFIG_PREEMPT\n\t/* Interrupts are off */\n\t/* Check if we need preemption */\n\tbt\t$9, EFLAGS(%rsp)\t\t/* were interrupts off? */\n\tjnc\t1f\n0:\tcmpl\t$0, PER_CPU_VAR(__preempt_count)\n\tjnz\t1f\n\tcall\tpreempt_schedule_irq\n\tjmp\t0b\n1:\n#endif\n\t/*\n\t * The iretq could re-enable interrupts:\n\t */\n\tTRACE_IRQS_IRETQ\n\nGLOBAL(restore_regs_and_return_to_kernel)\n#ifdef CONFIG_DEBUG_ENTRY\n\t/* Assert that pt_regs indicates kernel mode. */\n\ttestb\t$3, CS(%rsp)\n\tjz\t1f\n\tud2\n1:\n#endif\n\tPOP_REGS\n\taddq\t$8, %rsp\t/* skip regs->orig_ax */\n\t/*\n\t * ARCH_HAS_MEMBARRIER_SYNC_CORE rely on IRET core serialization\n\t * when returning from IPI handler.\n\t */\n\tINTERRUPT_RETURN\n\nENTRY(native_iret)\n\tUNWIND_HINT_IRET_REGS\n\t/*\n\t * Are we returning to a stack segment from the LDT?  Note: in\n\t * 64-bit mode SS:RSP on the exception stack is always valid.\n\t */\n#ifdef CONFIG_X86_ESPFIX64\n\ttestb\t$4, (SS-RIP)(%rsp)\n\tjnz\tnative_irq_return_ldt\n#endif\n\n.global native_irq_return_iret\nnative_irq_return_iret:\n\t/*\n\t * This may fault.  Non-paranoid faults on return to userspace are\n\t * handled by fixup_bad_iret.  These include #SS, #GP, and #NP.\n\t * Double-faults due to espfix64 are handled in do_double_fault.\n\t * Other faults here are fatal.\n\t */\n\tiretq\n\n#ifdef CONFIG_X86_ESPFIX64\nnative_irq_return_ldt:\n\t/*\n\t * We are running with user GSBASE.  All GPRs contain their user\n\t * values.  We have a percpu ESPFIX stack that is eight slots\n\t * long (see ESPFIX_STACK_SIZE).  espfix_waddr points to the bottom\n\t * of the ESPFIX stack.\n\t *\n\t * We clobber RAX and RDI in this code.  We stash RDI on the\n\t * normal stack and RAX on the ESPFIX stack.\n\t *\n\t * The ESPFIX stack layout we set up looks like this:\n\t *\n\t * --- top of ESPFIX stack ---\n\t * SS\n\t * RSP\n\t * RFLAGS\n\t * CS\n\t * RIP  <-- RSP points here when we're done\n\t * RAX  <-- espfix_waddr points here\n\t * --- bottom of ESPFIX stack ---\n\t */\n\n\tpushq\t%rdi\t\t\t\t/* Stash user RDI */\n\tSWAPGS\t\t\t\t\t/* to kernel GS */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rdi\t/* to kernel CR3 */\n\n\tmovq\tPER_CPU_VAR(espfix_waddr), %rdi\n\tmovq\t%rax, (0*8)(%rdi)\t\t/* user RAX */\n\tmovq\t(1*8)(%rsp), %rax\t\t/* user RIP */\n\tmovq\t%rax, (1*8)(%rdi)\n\tmovq\t(2*8)(%rsp), %rax\t\t/* user CS */\n\tmovq\t%rax, (2*8)(%rdi)\n\tmovq\t(3*8)(%rsp), %rax\t\t/* user RFLAGS */\n\tmovq\t%rax, (3*8)(%rdi)\n\tmovq\t(5*8)(%rsp), %rax\t\t/* user SS */\n\tmovq\t%rax, (5*8)(%rdi)\n\tmovq\t(4*8)(%rsp), %rax\t\t/* user RSP */\n\tmovq\t%rax, (4*8)(%rdi)\n\t/* Now RAX == RSP. */\n\n\tandl\t$0xffff0000, %eax\t\t/* RAX = (RSP & 0xffff0000) */\n\n\t/*\n\t * espfix_stack[31:16] == 0.  The page tables are set up such that\n\t * (espfix_stack | (X & 0xffff0000)) points to a read-only alias of\n\t * espfix_waddr for any X.  That is, there are 65536 RO aliases of\n\t * the same page.  Set up RSP so that RSP[31:16] contains the\n\t * respective 16 bits of the /userspace/ RSP and RSP nonetheless\n\t * still points to an RO alias of the ESPFIX stack.\n\t */\n\torq\tPER_CPU_VAR(espfix_stack), %rax\n\n\tSWITCH_TO_USER_CR3_STACK scratch_reg=%rdi\n\tSWAPGS\t\t\t\t\t/* to user GS */\n\tpopq\t%rdi\t\t\t\t/* Restore user RDI */\n\n\tmovq\t%rax, %rsp\n\tUNWIND_HINT_IRET_REGS offset=8\n\n\t/*\n\t * At this point, we cannot write to the stack any more, but we can\n\t * still read.\n\t */\n\tpopq\t%rax\t\t\t\t/* Restore user RAX */\n\n\t/*\n\t * RSP now points to an ordinary IRET frame, except that the page\n\t * is read-only and RSP[31:16] are preloaded with the userspace\n\t * values.  We can now IRET back to userspace.\n\t */\n\tjmp\tnative_irq_return_iret\n#endif\nEND(common_interrupt)\n\n/*\n * APIC interrupts.\n */\n.macro apicinterrupt3 num sym do_sym\nENTRY(\\sym)\n\tUNWIND_HINT_IRET_REGS\n\tpushq\t$~(\\num)\n.Lcommon_\\sym:\n\tcall\tinterrupt_entry\n\tUNWIND_HINT_REGS indirect=1\n\tcall\t\\do_sym\t/* rdi points to pt_regs */\n\tjmp\tret_from_intr\nEND(\\sym)\n.endm\n\n/* Make sure APIC interrupt handlers end up in the irqentry section: */\n#define PUSH_SECTION_IRQENTRY\t.pushsection .irqentry.text, \"ax\"\n#define POP_SECTION_IRQENTRY\t.popsection\n\n.macro apicinterrupt num sym do_sym\nPUSH_SECTION_IRQENTRY\napicinterrupt3 \\num \\sym \\do_sym\nPOP_SECTION_IRQENTRY\n.endm\n\n#ifdef CONFIG_SMP\napicinterrupt3 IRQ_MOVE_CLEANUP_VECTOR\t\tirq_move_cleanup_interrupt\tsmp_irq_move_cleanup_interrupt\napicinterrupt3 REBOOT_VECTOR\t\t\treboot_interrupt\t\tsmp_reboot_interrupt\n#endif\n\n#ifdef CONFIG_X86_UV\napicinterrupt3 UV_BAU_MESSAGE\t\t\tuv_bau_message_intr1\t\tuv_bau_message_interrupt\n#endif\n\napicinterrupt LOCAL_TIMER_VECTOR\t\tapic_timer_interrupt\t\tsmp_apic_timer_interrupt\napicinterrupt X86_PLATFORM_IPI_VECTOR\t\tx86_platform_ipi\t\tsmp_x86_platform_ipi\n\n#ifdef CONFIG_HAVE_KVM\napicinterrupt3 POSTED_INTR_VECTOR\t\tkvm_posted_intr_ipi\t\tsmp_kvm_posted_intr_ipi\napicinterrupt3 POSTED_INTR_WAKEUP_VECTOR\tkvm_posted_intr_wakeup_ipi\tsmp_kvm_posted_intr_wakeup_ipi\napicinterrupt3 POSTED_INTR_NESTED_VECTOR\tkvm_posted_intr_nested_ipi\tsmp_kvm_posted_intr_nested_ipi\n#endif\n\n#ifdef CONFIG_X86_MCE_THRESHOLD\napicinterrupt THRESHOLD_APIC_VECTOR\t\tthreshold_interrupt\t\tsmp_threshold_interrupt\n#endif\n\n#ifdef CONFIG_X86_MCE_AMD\napicinterrupt DEFERRED_ERROR_VECTOR\t\tdeferred_error_interrupt\tsmp_deferred_error_interrupt\n#endif\n\n#ifdef CONFIG_X86_THERMAL_VECTOR\napicinterrupt THERMAL_APIC_VECTOR\t\tthermal_interrupt\t\tsmp_thermal_interrupt\n#endif\n\n#ifdef CONFIG_SMP\napicinterrupt CALL_FUNCTION_SINGLE_VECTOR\tcall_function_single_interrupt\tsmp_call_function_single_interrupt\napicinterrupt CALL_FUNCTION_VECTOR\t\tcall_function_interrupt\t\tsmp_call_function_interrupt\napicinterrupt RESCHEDULE_VECTOR\t\t\treschedule_interrupt\t\tsmp_reschedule_interrupt\n#endif\n\napicinterrupt ERROR_APIC_VECTOR\t\t\terror_interrupt\t\t\tsmp_error_interrupt\napicinterrupt SPURIOUS_APIC_VECTOR\t\tspurious_interrupt\t\tsmp_spurious_interrupt\n\n#ifdef CONFIG_IRQ_WORK\napicinterrupt IRQ_WORK_VECTOR\t\t\tirq_work_interrupt\t\tsmp_irq_work_interrupt\n#endif\n\n/*\n * Exception entry points.\n */\n#define CPU_TSS_IST(x) PER_CPU_VAR(cpu_tss_rw) + (TSS_ist + ((x) - 1) * 8)\n\n.macro idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1\nENTRY(\\sym)\n\tUNWIND_HINT_IRET_REGS offset=\\has_error_code*8\n\n\t/* Sanity check */\n\t.if \\shift_ist != -1 && \\paranoid == 0\n\t.error \"using shift_ist requires paranoid=1\"\n\t.endif\n\n\tASM_CLAC\n\n\t.if \\has_error_code == 0\n\tpushq\t$-1\t\t\t\t/* ORIG_RAX: no syscall to restart */\n\t.endif\n\n\t.if \\paranoid < 2\n\ttestb\t$3, CS-ORIG_RAX(%rsp)\t\t/* If coming from userspace, switch stacks */\n\tjnz\t.Lfrom_usermode_switch_stack_\\@\n\t.endif\n\n\t.if \\paranoid\n\tcall\tparanoid_entry\n\t.else\n\tcall\terror_entry\n\t.endif\n\tUNWIND_HINT_REGS\n\t/* returned flag: ebx=0: need swapgs on exit, ebx=1: don't need it */\n\n\t.if \\paranoid\n\t.if \\shift_ist != -1\n\tTRACE_IRQS_OFF_DEBUG\t\t\t/* reload IDT in case of recursion */\n\t.else\n\tTRACE_IRQS_OFF\n\t.endif\n\t.endif\n\n\tmovq\t%rsp, %rdi\t\t\t/* pt_regs pointer */\n\n\t.if \\has_error_code\n\tmovq\tORIG_RAX(%rsp), %rsi\t\t/* get error code */\n\tmovq\t$-1, ORIG_RAX(%rsp)\t\t/* no syscall to restart */\n\t.else\n\txorl\t%esi, %esi\t\t\t/* no error code */\n\t.endif\n\n\t.if \\shift_ist != -1\n\tsubq\t$EXCEPTION_STKSZ, CPU_TSS_IST(\\shift_ist)\n\t.endif\n\n\tcall\t\\do_sym\n\n\t.if \\shift_ist != -1\n\taddq\t$EXCEPTION_STKSZ, CPU_TSS_IST(\\shift_ist)\n\t.endif\n\n\t/* these procedures expect \"no swapgs\" flag in ebx */\n\t.if \\paranoid\n\tjmp\tparanoid_exit\n\t.else\n\tjmp\terror_exit\n\t.endif\n\n\t.if \\paranoid < 2\n\t/*\n\t * Entry from userspace.  Switch stacks and treat it\n\t * as a normal entry.  This means that paranoid handlers\n\t * run in real process context if user_mode(regs).\n\t */\n.Lfrom_usermode_switch_stack_\\@:\n\tcall\terror_entry\n\n\tmovq\t%rsp, %rdi\t\t\t/* pt_regs pointer */\n\n\t.if \\has_error_code\n\tmovq\tORIG_RAX(%rsp), %rsi\t\t/* get error code */\n\tmovq\t$-1, ORIG_RAX(%rsp)\t\t/* no syscall to restart */\n\t.else\n\txorl\t%esi, %esi\t\t\t/* no error code */\n\t.endif\n\n\tcall\t\\do_sym\n\n\tjmp\terror_exit\t\t\t/* %ebx: no swapgs flag */\n\t.endif\nEND(\\sym)\n.endm\n\nidtentry divide_error\t\t\tdo_divide_error\t\t\thas_error_code=0\nidtentry overflow\t\t\tdo_overflow\t\t\thas_error_code=0\nidtentry bounds\t\t\t\tdo_bounds\t\t\thas_error_code=0\nidtentry invalid_op\t\t\tdo_invalid_op\t\t\thas_error_code=0\nidtentry device_not_available\t\tdo_device_not_available\t\thas_error_code=0\nidtentry double_fault\t\t\tdo_double_fault\t\t\thas_error_code=1 paranoid=2\nidtentry coprocessor_segment_overrun\tdo_coprocessor_segment_overrun\thas_error_code=0\nidtentry invalid_TSS\t\t\tdo_invalid_TSS\t\t\thas_error_code=1\nidtentry segment_not_present\t\tdo_segment_not_present\t\thas_error_code=1\nidtentry spurious_interrupt_bug\t\tdo_spurious_interrupt_bug\thas_error_code=0\nidtentry coprocessor_error\t\tdo_coprocessor_error\t\thas_error_code=0\nidtentry alignment_check\t\tdo_alignment_check\t\thas_error_code=1\nidtentry simd_coprocessor_error\t\tdo_simd_coprocessor_error\thas_error_code=0\n\n\n\t/*\n\t * Reload gs selector with exception handling\n\t * edi:  new selector\n\t */\nENTRY(native_load_gs_index)\n\tFRAME_BEGIN\n\tpushfq\n\tDISABLE_INTERRUPTS(CLBR_ANY & ~CLBR_RDI)\n\tTRACE_IRQS_OFF\n\tSWAPGS\n.Lgs_change:\n\tmovl\t%edi, %gs\n2:\tALTERNATIVE \"\", \"mfence\", X86_BUG_SWAPGS_FENCE\n\tSWAPGS\n\tTRACE_IRQS_FLAGS (%rsp)\n\tpopfq\n\tFRAME_END\n\tret\nENDPROC(native_load_gs_index)\nEXPORT_SYMBOL(native_load_gs_index)\n\n\t_ASM_EXTABLE(.Lgs_change, bad_gs)\n\t.section .fixup, \"ax\"\n\t/* running with kernelgs */\nbad_gs:\n\tSWAPGS\t\t\t\t\t/* switch back to user gs */\n.macro ZAP_GS\n\t/* This can't be a string because the preprocessor needs to see it. */\n\tmovl $__USER_DS, %eax\n\tmovl %eax, %gs\n.endm\n\tALTERNATIVE \"\", \"ZAP_GS\", X86_BUG_NULL_SEG\n\txorl\t%eax, %eax\n\tmovl\t%eax, %gs\n\tjmp\t2b\n\t.previous\n\n/* Call softirq on interrupt stack. Interrupts are off. */\nENTRY(do_softirq_own_stack)\n\tpushq\t%rbp\n\tmov\t%rsp, %rbp\n\tENTER_IRQ_STACK regs=0 old_rsp=%r11\n\tcall\t__do_softirq\n\tLEAVE_IRQ_STACK regs=0\n\tleaveq\n\tret\nENDPROC(do_softirq_own_stack)\n\n#ifdef CONFIG_XEN\nidtentry hypervisor_callback xen_do_hypervisor_callback has_error_code=0\n\n/*\n * A note on the \"critical region\" in our callback handler.\n * We want to avoid stacking callback handlers due to events occurring\n * during handling of the last event. To do this, we keep events disabled\n * until we've done all processing. HOWEVER, we must enable events before\n * popping the stack frame (can't be done atomically) and so it would still\n * be possible to get enough handler activations to overflow the stack.\n * Although unlikely, bugs of that kind are hard to track down, so we'd\n * like to avoid the possibility.\n * So, on entry to the handler we detect whether we interrupted an\n * existing activation in its critical region -- if so, we pop the current\n * activation and restart the handler using the previous one.\n */\nENTRY(xen_do_hypervisor_callback)\t\t/* do_hypervisor_callback(struct *pt_regs) */\n\n/*\n * Since we don't modify %rdi, evtchn_do_upall(struct *pt_regs) will\n * see the correct pointer to the pt_regs\n */\n\tUNWIND_HINT_FUNC\n\tmovq\t%rdi, %rsp\t\t\t/* we don't return, adjust the stack frame */\n\tUNWIND_HINT_REGS\n\n\tENTER_IRQ_STACK old_rsp=%r10\n\tcall\txen_evtchn_do_upcall\n\tLEAVE_IRQ_STACK\n\n#ifndef CONFIG_PREEMPT\n\tcall\txen_maybe_preempt_hcall\n#endif\n\tjmp\terror_exit\nEND(xen_do_hypervisor_callback)\n\n/*\n * Hypervisor uses this for application faults while it executes.\n * We get here for two reasons:\n *  1. Fault while reloading DS, ES, FS or GS\n *  2. Fault while executing IRET\n * Category 1 we do not need to fix up as Xen has already reloaded all segment\n * registers that could be reloaded and zeroed the others.\n * Category 2 we fix up by killing the current process. We cannot use the\n * normal Linux return path in this case because if we use the IRET hypercall\n * to pop the stack frame we end up in an infinite loop of failsafe callbacks.\n * We distinguish between categories by comparing each saved segment register\n * with its current contents: any discrepancy means we in category 1.\n */\nENTRY(xen_failsafe_callback)\n\tUNWIND_HINT_EMPTY\n\tmovl\t%ds, %ecx\n\tcmpw\t%cx, 0x10(%rsp)\n\tjne\t1f\n\tmovl\t%es, %ecx\n\tcmpw\t%cx, 0x18(%rsp)\n\tjne\t1f\n\tmovl\t%fs, %ecx\n\tcmpw\t%cx, 0x20(%rsp)\n\tjne\t1f\n\tmovl\t%gs, %ecx\n\tcmpw\t%cx, 0x28(%rsp)\n\tjne\t1f\n\t/* All segments match their saved values => Category 2 (Bad IRET). */\n\tmovq\t(%rsp), %rcx\n\tmovq\t8(%rsp), %r11\n\taddq\t$0x30, %rsp\n\tpushq\t$0\t\t\t\t/* RIP */\n\tUNWIND_HINT_IRET_REGS offset=8\n\tjmp\tgeneral_protection\n1:\t/* Segment mismatch => Category 1 (Bad segment). Retry the IRET. */\n\tmovq\t(%rsp), %rcx\n\tmovq\t8(%rsp), %r11\n\taddq\t$0x30, %rsp\n\tUNWIND_HINT_IRET_REGS\n\tpushq\t$-1 /* orig_ax = -1 => not a system call */\n\tPUSH_AND_CLEAR_REGS\n\tENCODE_FRAME_POINTER\n\tjmp\terror_exit\nEND(xen_failsafe_callback)\n\napicinterrupt3 HYPERVISOR_CALLBACK_VECTOR \\\n\txen_hvm_callback_vector xen_evtchn_do_upcall\n\n#endif /* CONFIG_XEN */\n\n#if IS_ENABLED(CONFIG_HYPERV)\napicinterrupt3 HYPERVISOR_CALLBACK_VECTOR \\\n\thyperv_callback_vector hyperv_vector_handler\n\napicinterrupt3 HYPERV_REENLIGHTENMENT_VECTOR \\\n\thyperv_reenlightenment_vector hyperv_reenlightenment_intr\n#endif /* CONFIG_HYPERV */\n\nidtentry debug\t\t\tdo_debug\t\thas_error_code=0\tparanoid=1 shift_ist=DEBUG_STACK\nidtentry int3\t\t\tdo_int3\t\t\thas_error_code=0\nidtentry stack_segment\t\tdo_stack_segment\thas_error_code=1\n\n#ifdef CONFIG_XEN\nidtentry xennmi\t\t\tdo_nmi\t\t\thas_error_code=0\nidtentry xendebug\t\tdo_debug\t\thas_error_code=0\nidtentry xenint3\t\tdo_int3\t\t\thas_error_code=0\n#endif\n\nidtentry general_protection\tdo_general_protection\thas_error_code=1\nidtentry page_fault\t\tdo_page_fault\t\thas_error_code=1\n\n#ifdef CONFIG_KVM_GUEST\nidtentry async_page_fault\tdo_async_page_fault\thas_error_code=1\n#endif\n\n#ifdef CONFIG_X86_MCE\nidtentry machine_check\t\tdo_mce\t\t\thas_error_code=0\tparanoid=1\n#endif\n\n/*\n * Save all registers in pt_regs, and switch gs if needed.\n * Use slow, but surefire \"are we in kernel?\" check.\n * Return: ebx=0: need swapgs on exit, ebx=1: otherwise\n */\nENTRY(paranoid_entry)\n\tUNWIND_HINT_FUNC\n\tcld\n\tPUSH_AND_CLEAR_REGS save_ret=1\n\tENCODE_FRAME_POINTER 8\n\tmovl\t$1, %ebx\n\tmovl\t$MSR_GS_BASE, %ecx\n\trdmsr\n\ttestl\t%edx, %edx\n\tjs\t1f\t\t\t\t/* negative -> in kernel */\n\tSWAPGS\n\txorl\t%ebx, %ebx\n\n1:\n\tSAVE_AND_SWITCH_TO_KERNEL_CR3 scratch_reg=%rax save_reg=%r14\n\n\tret\nEND(paranoid_entry)\n\n/*\n * \"Paranoid\" exit path from exception stack.  This is invoked\n * only on return from non-NMI IST interrupts that came\n * from kernel space.\n *\n * We may be returning to very strange contexts (e.g. very early\n * in syscall entry), so checking for preemption here would\n * be complicated.  Fortunately, we there's no good reason\n * to try to handle preemption here.\n *\n * On entry, ebx is \"no swapgs\" flag (1: don't need swapgs, 0: need it)\n */\nENTRY(paranoid_exit)\n\tUNWIND_HINT_REGS\n\tDISABLE_INTERRUPTS(CLBR_ANY)\n\tTRACE_IRQS_OFF_DEBUG\n\ttestl\t%ebx, %ebx\t\t\t/* swapgs needed? */\n\tjnz\t.Lparanoid_exit_no_swapgs\n\tTRACE_IRQS_IRETQ\n\tRESTORE_CR3\tscratch_reg=%rbx save_reg=%r14\n\tSWAPGS_UNSAFE_STACK\n\tjmp\t.Lparanoid_exit_restore\n.Lparanoid_exit_no_swapgs:\n\tTRACE_IRQS_IRETQ_DEBUG\n\tRESTORE_CR3\tscratch_reg=%rbx save_reg=%r14\n.Lparanoid_exit_restore:\n\tjmp restore_regs_and_return_to_kernel\nEND(paranoid_exit)\n\n/*\n * Save all registers in pt_regs, and switch GS if needed.\n * Return: EBX=0: came from user mode; EBX=1: otherwise\n */\nENTRY(error_entry)\n\tUNWIND_HINT_FUNC\n\tcld\n\tPUSH_AND_CLEAR_REGS save_ret=1\n\tENCODE_FRAME_POINTER 8\n\ttestb\t$3, CS+8(%rsp)\n\tjz\t.Lerror_kernelspace\n\n\t/*\n\t * We entered from user mode or we're pretending to have entered\n\t * from user mode due to an IRET fault.\n\t */\n\tSWAPGS\n\t/* We have user CR3.  Change to kernel CR3. */\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rax\n\n.Lerror_entry_from_usermode_after_swapgs:\n\t/* Put us onto the real thread stack. */\n\tpopq\t%r12\t\t\t\t/* save return addr in %12 */\n\tmovq\t%rsp, %rdi\t\t\t/* arg0 = pt_regs pointer */\n\tcall\tsync_regs\n\tmovq\t%rax, %rsp\t\t\t/* switch stack */\n\tENCODE_FRAME_POINTER\n\tpushq\t%r12\n\n\t/*\n\t * We need to tell lockdep that IRQs are off.  We can't do this until\n\t * we fix gsbase, and we should do it before enter_from_user_mode\n\t * (which can take locks).\n\t */\n\tTRACE_IRQS_OFF\n\tCALL_enter_from_user_mode\n\tret\n\n.Lerror_entry_done:\n\tTRACE_IRQS_OFF\n\tret\n\n\t/*\n\t * There are two places in the kernel that can potentially fault with\n\t * usergs. Handle them here.  B stepping K8s sometimes report a\n\t * truncated RIP for IRET exceptions returning to compat mode. Check\n\t * for these here too.\n\t */\n.Lerror_kernelspace:\n\tincl\t%ebx\n\tleaq\tnative_irq_return_iret(%rip), %rcx\n\tcmpq\t%rcx, RIP+8(%rsp)\n\tje\t.Lerror_bad_iret\n\tmovl\t%ecx, %eax\t\t\t/* zero extend */\n\tcmpq\t%rax, RIP+8(%rsp)\n\tje\t.Lbstep_iret\n\tcmpq\t$.Lgs_change, RIP+8(%rsp)\n\tjne\t.Lerror_entry_done\n\n\t/*\n\t * hack: .Lgs_change can fail with user gsbase.  If this happens, fix up\n\t * gsbase and proceed.  We'll fix up the exception and land in\n\t * .Lgs_change's error handler with kernel gsbase.\n\t */\n\tSWAPGS\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rax\n\tjmp .Lerror_entry_done\n\n.Lbstep_iret:\n\t/* Fix truncated RIP */\n\tmovq\t%rcx, RIP+8(%rsp)\n\t/* fall through */\n\n.Lerror_bad_iret:\n\t/*\n\t * We came from an IRET to user mode, so we have user\n\t * gsbase and CR3.  Switch to kernel gsbase and CR3:\n\t */\n\tSWAPGS\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rax\n\n\t/*\n\t * Pretend that the exception came from user mode: set up pt_regs\n\t * as if we faulted immediately after IRET and clear EBX so that\n\t * error_exit knows that we will be returning to user mode.\n\t */\n\tmov\t%rsp, %rdi\n\tcall\tfixup_bad_iret\n\tmov\t%rax, %rsp\n\tdecl\t%ebx\n\tjmp\t.Lerror_entry_from_usermode_after_swapgs\nEND(error_entry)\n\n\n/*\n * On entry, EBX is a \"return to kernel mode\" flag:\n *   1: already in kernel mode, don't need SWAPGS\n *   0: user gsbase is loaded, we need SWAPGS and standard preparation for return to usermode\n */\nENTRY(error_exit)\n\tUNWIND_HINT_REGS\n\tDISABLE_INTERRUPTS(CLBR_ANY)\n\tTRACE_IRQS_OFF\n\ttestl\t%ebx, %ebx\n\tjnz\tretint_kernel\n\tjmp\tretint_user\nEND(error_exit)\n\n/*\n * Runs on exception stack.  Xen PV does not go through this path at all,\n * so we can use real assembly here.\n *\n * Registers:\n *\t%r14: Used to save/restore the CR3 of the interrupted context\n *\t      when PAGE_TABLE_ISOLATION is in use.  Do not clobber.\n */\nENTRY(nmi)\n\tUNWIND_HINT_IRET_REGS\n\n\t/*\n\t * We allow breakpoints in NMIs. If a breakpoint occurs, then\n\t * the iretq it performs will take us out of NMI context.\n\t * This means that we can have nested NMIs where the next\n\t * NMI is using the top of the stack of the previous NMI. We\n\t * can't let it execute because the nested NMI will corrupt the\n\t * stack of the previous NMI. NMI handlers are not re-entrant\n\t * anyway.\n\t *\n\t * To handle this case we do the following:\n\t *  Check the a special location on the stack that contains\n\t *  a variable that is set when NMIs are executing.\n\t *  The interrupted task's stack is also checked to see if it\n\t *  is an NMI stack.\n\t *  If the variable is not set and the stack is not the NMI\n\t *  stack then:\n\t *    o Set the special variable on the stack\n\t *    o Copy the interrupt frame into an \"outermost\" location on the\n\t *      stack\n\t *    o Copy the interrupt frame into an \"iret\" location on the stack\n\t *    o Continue processing the NMI\n\t *  If the variable is set or the previous stack is the NMI stack:\n\t *    o Modify the \"iret\" location to jump to the repeat_nmi\n\t *    o return back to the first NMI\n\t *\n\t * Now on exit of the first NMI, we first clear the stack variable\n\t * The NMI stack will tell any nested NMIs at that point that it is\n\t * nested. Then we pop the stack normally with iret, and if there was\n\t * a nested NMI that updated the copy interrupt stack frame, a\n\t * jump will be made to the repeat_nmi code that will handle the second\n\t * NMI.\n\t *\n\t * However, espfix prevents us from directly returning to userspace\n\t * with a single IRET instruction.  Similarly, IRET to user mode\n\t * can fault.  We therefore handle NMIs from user space like\n\t * other IST entries.\n\t */\n\n\tASM_CLAC\n\n\t/* Use %rdx as our temp variable throughout */\n\tpushq\t%rdx\n\n\ttestb\t$3, CS-RIP+8(%rsp)\n\tjz\t.Lnmi_from_kernel\n\n\t/*\n\t * NMI from user mode.  We need to run on the thread stack, but we\n\t * can't go through the normal entry paths: NMIs are masked, and\n\t * we don't want to enable interrupts, because then we'll end\n\t * up in an awkward situation in which IRQs are on but NMIs\n\t * are off.\n\t *\n\t * We also must not push anything to the stack before switching\n\t * stacks lest we corrupt the \"NMI executing\" variable.\n\t */\n\n\tswapgs\n\tcld\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rdx\n\tmovq\t%rsp, %rdx\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\tUNWIND_HINT_IRET_REGS base=%rdx offset=8\n\tpushq\t5*8(%rdx)\t/* pt_regs->ss */\n\tpushq\t4*8(%rdx)\t/* pt_regs->rsp */\n\tpushq\t3*8(%rdx)\t/* pt_regs->flags */\n\tpushq\t2*8(%rdx)\t/* pt_regs->cs */\n\tpushq\t1*8(%rdx)\t/* pt_regs->rip */\n\tUNWIND_HINT_IRET_REGS\n\tpushq   $-1\t\t/* pt_regs->orig_ax */\n\tPUSH_AND_CLEAR_REGS rdx=(%rdx)\n\tENCODE_FRAME_POINTER\n\n\t/*\n\t * At this point we no longer need to worry about stack damage\n\t * due to nesting -- we're on the normal thread stack and we're\n\t * done with the NMI stack.\n\t */\n\n\tmovq\t%rsp, %rdi\n\tmovq\t$-1, %rsi\n\tcall\tdo_nmi\n\n\t/*\n\t * Return back to user mode.  We must *not* do the normal exit\n\t * work, because we don't want to enable interrupts.\n\t */\n\tjmp\tswapgs_restore_regs_and_return_to_usermode\n\n.Lnmi_from_kernel:\n\t/*\n\t * Here's what our stack frame will look like:\n\t * +---------------------------------------------------------+\n\t * | original SS                                             |\n\t * | original Return RSP                                     |\n\t * | original RFLAGS                                         |\n\t * | original CS                                             |\n\t * | original RIP                                            |\n\t * +---------------------------------------------------------+\n\t * | temp storage for rdx                                    |\n\t * +---------------------------------------------------------+\n\t * | \"NMI executing\" variable                                |\n\t * +---------------------------------------------------------+\n\t * | iret SS          } Copied from \"outermost\" frame        |\n\t * | iret Return RSP  } on each loop iteration; overwritten  |\n\t * | iret RFLAGS      } by a nested NMI to force another     |\n\t * | iret CS          } iteration if needed.                 |\n\t * | iret RIP         }                                      |\n\t * +---------------------------------------------------------+\n\t * | outermost SS          } initialized in first_nmi;       |\n\t * | outermost Return RSP  } will not be changed before      |\n\t * | outermost RFLAGS      } NMI processing is done.         |\n\t * | outermost CS          } Copied to \"iret\" frame on each  |\n\t * | outermost RIP         } iteration.                      |\n\t * +---------------------------------------------------------+\n\t * | pt_regs                                                 |\n\t * +---------------------------------------------------------+\n\t *\n\t * The \"original\" frame is used by hardware.  Before re-enabling\n\t * NMIs, we need to be done with it, and we need to leave enough\n\t * space for the asm code here.\n\t *\n\t * We return by executing IRET while RSP points to the \"iret\" frame.\n\t * That will either return for real or it will loop back into NMI\n\t * processing.\n\t *\n\t * The \"outermost\" frame is copied to the \"iret\" frame on each\n\t * iteration of the loop, so each iteration starts with the \"iret\"\n\t * frame pointing to the final return target.\n\t */\n\n\t/*\n\t * Determine whether we're a nested NMI.\n\t *\n\t * If we interrupted kernel code between repeat_nmi and\n\t * end_repeat_nmi, then we are a nested NMI.  We must not\n\t * modify the \"iret\" frame because it's being written by\n\t * the outer NMI.  That's okay; the outer NMI handler is\n\t * about to about to call do_nmi anyway, so we can just\n\t * resume the outer NMI.\n\t */\n\n\tmovq\t$repeat_nmi, %rdx\n\tcmpq\t8(%rsp), %rdx\n\tja\t1f\n\tmovq\t$end_repeat_nmi, %rdx\n\tcmpq\t8(%rsp), %rdx\n\tja\tnested_nmi_out\n1:\n\n\t/*\n\t * Now check \"NMI executing\".  If it's set, then we're nested.\n\t * This will not detect if we interrupted an outer NMI just\n\t * before IRET.\n\t */\n\tcmpl\t$1, -8(%rsp)\n\tje\tnested_nmi\n\n\t/*\n\t * Now test if the previous stack was an NMI stack.  This covers\n\t * the case where we interrupt an outer NMI after it clears\n\t * \"NMI executing\" but before IRET.  We need to be careful, though:\n\t * there is one case in which RSP could point to the NMI stack\n\t * despite there being no NMI active: naughty userspace controls\n\t * RSP at the very beginning of the SYSCALL targets.  We can\n\t * pull a fast one on naughty userspace, though: we program\n\t * SYSCALL to mask DF, so userspace cannot cause DF to be set\n\t * if it controls the kernel's RSP.  We set DF before we clear\n\t * \"NMI executing\".\n\t */\n\tlea\t6*8(%rsp), %rdx\n\t/* Compare the NMI stack (rdx) with the stack we came from (4*8(%rsp)) */\n\tcmpq\t%rdx, 4*8(%rsp)\n\t/* If the stack pointer is above the NMI stack, this is a normal NMI */\n\tja\tfirst_nmi\n\n\tsubq\t$EXCEPTION_STKSZ, %rdx\n\tcmpq\t%rdx, 4*8(%rsp)\n\t/* If it is below the NMI stack, it is a normal NMI */\n\tjb\tfirst_nmi\n\n\t/* Ah, it is within the NMI stack. */\n\n\ttestb\t$(X86_EFLAGS_DF >> 8), (3*8 + 1)(%rsp)\n\tjz\tfirst_nmi\t/* RSP was user controlled. */\n\n\t/* This is a nested NMI. */\n\nnested_nmi:\n\t/*\n\t * Modify the \"iret\" frame to point to repeat_nmi, forcing another\n\t * iteration of NMI handling.\n\t */\n\tsubq\t$8, %rsp\n\tleaq\t-10*8(%rsp), %rdx\n\tpushq\t$__KERNEL_DS\n\tpushq\t%rdx\n\tpushfq\n\tpushq\t$__KERNEL_CS\n\tpushq\t$repeat_nmi\n\n\t/* Put stack back */\n\taddq\t$(6*8), %rsp\n\nnested_nmi_out:\n\tpopq\t%rdx\n\n\t/* We are returning to kernel mode, so this cannot result in a fault. */\n\tiretq\n\nfirst_nmi:\n\t/* Restore rdx. */\n\tmovq\t(%rsp), %rdx\n\n\t/* Make room for \"NMI executing\". */\n\tpushq\t$0\n\n\t/* Leave room for the \"iret\" frame */\n\tsubq\t$(5*8), %rsp\n\n\t/* Copy the \"original\" frame to the \"outermost\" frame */\n\t.rept 5\n\tpushq\t11*8(%rsp)\n\t.endr\n\tUNWIND_HINT_IRET_REGS\n\n\t/* Everything up to here is safe from nested NMIs */\n\n#ifdef CONFIG_DEBUG_ENTRY\n\t/*\n\t * For ease of testing, unmask NMIs right away.  Disabled by\n\t * default because IRET is very expensive.\n\t */\n\tpushq\t$0\t\t/* SS */\n\tpushq\t%rsp\t\t/* RSP (minus 8 because of the previous push) */\n\taddq\t$8, (%rsp)\t/* Fix up RSP */\n\tpushfq\t\t\t/* RFLAGS */\n\tpushq\t$__KERNEL_CS\t/* CS */\n\tpushq\t$1f\t\t/* RIP */\n\tiretq\t\t\t/* continues at repeat_nmi below */\n\tUNWIND_HINT_IRET_REGS\n1:\n#endif\n\nrepeat_nmi:\n\t/*\n\t * If there was a nested NMI, the first NMI's iret will return\n\t * here. But NMIs are still enabled and we can take another\n\t * nested NMI. The nested NMI checks the interrupted RIP to see\n\t * if it is between repeat_nmi and end_repeat_nmi, and if so\n\t * it will just return, as we are about to repeat an NMI anyway.\n\t * This makes it safe to copy to the stack frame that a nested\n\t * NMI will update.\n\t *\n\t * RSP is pointing to \"outermost RIP\".  gsbase is unknown, but, if\n\t * we're repeating an NMI, gsbase has the same value that it had on\n\t * the first iteration.  paranoid_entry will load the kernel\n\t * gsbase if needed before we call do_nmi.  \"NMI executing\"\n\t * is zero.\n\t */\n\tmovq\t$1, 10*8(%rsp)\t\t/* Set \"NMI executing\". */\n\n\t/*\n\t * Copy the \"outermost\" frame to the \"iret\" frame.  NMIs that nest\n\t * here must not modify the \"iret\" frame while we're writing to\n\t * it or it will end up containing garbage.\n\t */\n\taddq\t$(10*8), %rsp\n\t.rept 5\n\tpushq\t-6*8(%rsp)\n\t.endr\n\tsubq\t$(5*8), %rsp\nend_repeat_nmi:\n\n\t/*\n\t * Everything below this point can be preempted by a nested NMI.\n\t * If this happens, then the inner NMI will change the \"iret\"\n\t * frame to point back to repeat_nmi.\n\t */\n\tpushq\t$-1\t\t\t\t/* ORIG_RAX: no syscall to restart */\n\n\t/*\n\t * Use paranoid_entry to handle SWAPGS, but no need to use paranoid_exit\n\t * as we should not be calling schedule in NMI context.\n\t * Even with normal interrupts enabled. An NMI should not be\n\t * setting NEED_RESCHED or anything that normal interrupts and\n\t * exceptions might do.\n\t */\n\tcall\tparanoid_entry\n\tUNWIND_HINT_REGS\n\n\t/* paranoidentry do_nmi, 0; without TRACE_IRQS_OFF */\n\tmovq\t%rsp, %rdi\n\tmovq\t$-1, %rsi\n\tcall\tdo_nmi\n\n\tRESTORE_CR3 scratch_reg=%r15 save_reg=%r14\n\n\ttestl\t%ebx, %ebx\t\t\t/* swapgs needed? */\n\tjnz\tnmi_restore\nnmi_swapgs:\n\tSWAPGS_UNSAFE_STACK\nnmi_restore:\n\tPOP_REGS\n\n\t/*\n\t * Skip orig_ax and the \"outermost\" frame to point RSP at the \"iret\"\n\t * at the \"iret\" frame.\n\t */\n\taddq\t$6*8, %rsp\n\n\t/*\n\t * Clear \"NMI executing\".  Set DF first so that we can easily\n\t * distinguish the remaining code between here and IRET from\n\t * the SYSCALL entry and exit paths.\n\t *\n\t * We arguably should just inspect RIP instead, but I (Andy) wrote\n\t * this code when I had the misapprehension that Xen PV supported\n\t * NMIs, and Xen PV would break that approach.\n\t */\n\tstd\n\tmovq\t$0, 5*8(%rsp)\t\t/* clear \"NMI executing\" */\n\n\t/*\n\t * iretq reads the \"iret\" frame and exits the NMI stack in a\n\t * single instruction.  We are returning to kernel mode, so this\n\t * cannot result in a fault.  Similarly, we don't need to worry\n\t * about espfix64 on the way back to kernel mode.\n\t */\n\tiretq\nEND(nmi)\n\nENTRY(ignore_sysret)\n\tUNWIND_HINT_EMPTY\n\tmov\t$-ENOSYS, %eax\n\tsysret\nEND(ignore_sysret)\n\nENTRY(rewind_stack_do_exit)\n\tUNWIND_HINT_FUNC\n\t/* Prevent any naive code from trying to unwind to our caller. */\n\txorl\t%ebp, %ebp\n\n\tmovq\tPER_CPU_VAR(cpu_current_top_of_stack), %rax\n\tleaq\t-PTREGS_SIZE(%rax), %rsp\n\tUNWIND_HINT_FUNC sp_offset=PTREGS_SIZE\n\n\tcall\tdo_exit\nEND(rewind_stack_do_exit)\n", "/*\n * Interrupt descriptor table related code\n *\n * This file is licensed under the GPL V2\n */\n#include <linux/interrupt.h>\n\n#include <asm/traps.h>\n#include <asm/proto.h>\n#include <asm/desc.h>\n\nstruct idt_data {\n\tunsigned int\tvector;\n\tunsigned int\tsegment;\n\tstruct idt_bits\tbits;\n\tconst void\t*addr;\n};\n\n#define DPL0\t\t0x0\n#define DPL3\t\t0x3\n\n#define DEFAULT_STACK\t0\n\n#define G(_vector, _addr, _ist, _type, _dpl, _segment)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.vector\t\t= _vector,\t\t\\\n\t\t.bits.ist\t= _ist,\t\t\t\\\n\t\t.bits.type\t= _type,\t\t\\\n\t\t.bits.dpl\t= _dpl,\t\t\t\\\n\t\t.bits.p\t\t= 1,\t\t\t\\\n\t\t.addr\t\t= _addr,\t\t\\\n\t\t.segment\t= _segment,\t\t\\\n\t}\n\n/* Interrupt gate */\n#define INTG(_vector, _addr)\t\t\t\t\\\n\tG(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)\n\n/* System interrupt gate */\n#define SYSG(_vector, _addr)\t\t\t\t\\\n\tG(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL3, __KERNEL_CS)\n\n/* Interrupt gate with interrupt stack */\n#define ISTG(_vector, _addr, _ist)\t\t\t\\\n\tG(_vector, _addr, _ist, GATE_INTERRUPT, DPL0, __KERNEL_CS)\n\n/* System interrupt gate with interrupt stack */\n#define SISTG(_vector, _addr, _ist)\t\t\t\\\n\tG(_vector, _addr, _ist, GATE_INTERRUPT, DPL3, __KERNEL_CS)\n\n/* Task gate */\n#define TSKG(_vector, _gdt)\t\t\t\t\\\n\tG(_vector, NULL, DEFAULT_STACK, GATE_TASK, DPL0, _gdt << 3)\n\n/*\n * Early traps running on the DEFAULT_STACK because the other interrupt\n * stacks work only after cpu_init().\n */\nstatic const __initconst struct idt_data early_idts[] = {\n\tINTG(X86_TRAP_DB,\t\tdebug),\n\tSYSG(X86_TRAP_BP,\t\tint3),\n#ifdef CONFIG_X86_32\n\tINTG(X86_TRAP_PF,\t\tpage_fault),\n#endif\n};\n\n/*\n * The default IDT entries which are set up in trap_init() before\n * cpu_init() is invoked. Interrupt stacks cannot be used at that point and\n * the traps which use them are reinitialized with IST after cpu_init() has\n * set up TSS.\n */\nstatic const __initconst struct idt_data def_idts[] = {\n\tINTG(X86_TRAP_DE,\t\tdivide_error),\n\tINTG(X86_TRAP_NMI,\t\tnmi),\n\tINTG(X86_TRAP_BR,\t\tbounds),\n\tINTG(X86_TRAP_UD,\t\tinvalid_op),\n\tINTG(X86_TRAP_NM,\t\tdevice_not_available),\n\tINTG(X86_TRAP_OLD_MF,\t\tcoprocessor_segment_overrun),\n\tINTG(X86_TRAP_TS,\t\tinvalid_TSS),\n\tINTG(X86_TRAP_NP,\t\tsegment_not_present),\n\tINTG(X86_TRAP_SS,\t\tstack_segment),\n\tINTG(X86_TRAP_GP,\t\tgeneral_protection),\n\tINTG(X86_TRAP_SPURIOUS,\t\tspurious_interrupt_bug),\n\tINTG(X86_TRAP_MF,\t\tcoprocessor_error),\n\tINTG(X86_TRAP_AC,\t\talignment_check),\n\tINTG(X86_TRAP_XF,\t\tsimd_coprocessor_error),\n\n#ifdef CONFIG_X86_32\n\tTSKG(X86_TRAP_DF,\t\tGDT_ENTRY_DOUBLEFAULT_TSS),\n#else\n\tINTG(X86_TRAP_DF,\t\tdouble_fault),\n#endif\n\tINTG(X86_TRAP_DB,\t\tdebug),\n\n#ifdef CONFIG_X86_MCE\n\tINTG(X86_TRAP_MC,\t\t&machine_check),\n#endif\n\n\tSYSG(X86_TRAP_OF,\t\toverflow),\n#if defined(CONFIG_IA32_EMULATION)\n\tSYSG(IA32_SYSCALL_VECTOR,\tentry_INT80_compat),\n#elif defined(CONFIG_X86_32)\n\tSYSG(IA32_SYSCALL_VECTOR,\tentry_INT80_32),\n#endif\n};\n\n/*\n * The APIC and SMP idt entries\n */\nstatic const __initconst struct idt_data apic_idts[] = {\n#ifdef CONFIG_SMP\n\tINTG(RESCHEDULE_VECTOR,\t\treschedule_interrupt),\n\tINTG(CALL_FUNCTION_VECTOR,\tcall_function_interrupt),\n\tINTG(CALL_FUNCTION_SINGLE_VECTOR, call_function_single_interrupt),\n\tINTG(IRQ_MOVE_CLEANUP_VECTOR,\tirq_move_cleanup_interrupt),\n\tINTG(REBOOT_VECTOR,\t\treboot_interrupt),\n#endif\n\n#ifdef CONFIG_X86_THERMAL_VECTOR\n\tINTG(THERMAL_APIC_VECTOR,\tthermal_interrupt),\n#endif\n\n#ifdef CONFIG_X86_MCE_THRESHOLD\n\tINTG(THRESHOLD_APIC_VECTOR,\tthreshold_interrupt),\n#endif\n\n#ifdef CONFIG_X86_MCE_AMD\n\tINTG(DEFERRED_ERROR_VECTOR,\tdeferred_error_interrupt),\n#endif\n\n#ifdef CONFIG_X86_LOCAL_APIC\n\tINTG(LOCAL_TIMER_VECTOR,\tapic_timer_interrupt),\n\tINTG(X86_PLATFORM_IPI_VECTOR,\tx86_platform_ipi),\n# ifdef CONFIG_HAVE_KVM\n\tINTG(POSTED_INTR_VECTOR,\tkvm_posted_intr_ipi),\n\tINTG(POSTED_INTR_WAKEUP_VECTOR, kvm_posted_intr_wakeup_ipi),\n\tINTG(POSTED_INTR_NESTED_VECTOR, kvm_posted_intr_nested_ipi),\n# endif\n# ifdef CONFIG_IRQ_WORK\n\tINTG(IRQ_WORK_VECTOR,\t\tirq_work_interrupt),\n# endif\n\tINTG(SPURIOUS_APIC_VECTOR,\tspurious_interrupt),\n\tINTG(ERROR_APIC_VECTOR,\t\terror_interrupt),\n#endif\n};\n\n#ifdef CONFIG_X86_64\n/*\n * Early traps running on the DEFAULT_STACK because the other interrupt\n * stacks work only after cpu_init().\n */\nstatic const __initconst struct idt_data early_pf_idts[] = {\n\tINTG(X86_TRAP_PF,\t\tpage_fault),\n};\n\n/*\n * Override for the debug_idt. Same as the default, but with interrupt\n * stack set to DEFAULT_STACK (0). Required for NMI trap handling.\n */\nstatic const __initconst struct idt_data dbg_idts[] = {\n\tINTG(X86_TRAP_DB,\tdebug),\n};\n#endif\n\n/* Must be page-aligned because the real IDT is used in a fixmap. */\ngate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;\n\nstruct desc_ptr idt_descr __ro_after_init = {\n\t.size\t\t= (IDT_ENTRIES * 2 * sizeof(unsigned long)) - 1,\n\t.address\t= (unsigned long) idt_table,\n};\n\n#ifdef CONFIG_X86_64\n/* No need to be aligned, but done to keep all IDTs defined the same way. */\ngate_desc debug_idt_table[IDT_ENTRIES] __page_aligned_bss;\n\n/*\n * The exceptions which use Interrupt stacks. They are setup after\n * cpu_init() when the TSS has been initialized.\n */\nstatic const __initconst struct idt_data ist_idts[] = {\n\tISTG(X86_TRAP_DB,\tdebug,\t\tDEBUG_STACK),\n\tISTG(X86_TRAP_NMI,\tnmi,\t\tNMI_STACK),\n\tISTG(X86_TRAP_DF,\tdouble_fault,\tDOUBLEFAULT_STACK),\n#ifdef CONFIG_X86_MCE\n\tISTG(X86_TRAP_MC,\t&machine_check,\tMCE_STACK),\n#endif\n};\n\n/*\n * Override for the debug_idt. Same as the default, but with interrupt\n * stack set to DEFAULT_STACK (0). Required for NMI trap handling.\n */\nconst struct desc_ptr debug_idt_descr = {\n\t.size\t\t= IDT_ENTRIES * 16 - 1,\n\t.address\t= (unsigned long) debug_idt_table,\n};\n#endif\n\nstatic inline void idt_init_desc(gate_desc *gate, const struct idt_data *d)\n{\n\tunsigned long addr = (unsigned long) d->addr;\n\n\tgate->offset_low\t= (u16) addr;\n\tgate->segment\t\t= (u16) d->segment;\n\tgate->bits\t\t= d->bits;\n\tgate->offset_middle\t= (u16) (addr >> 16);\n#ifdef CONFIG_X86_64\n\tgate->offset_high\t= (u32) (addr >> 32);\n\tgate->reserved\t\t= 0;\n#endif\n}\n\nstatic void\nidt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)\n{\n\tgate_desc desc;\n\n\tfor (; size > 0; t++, size--) {\n\t\tidt_init_desc(&desc, t);\n\t\twrite_idt_entry(idt, t->vector, &desc);\n\t\tif (sys)\n\t\t\tset_bit(t->vector, system_vectors);\n\t}\n}\n\nstatic void set_intr_gate(unsigned int n, const void *addr)\n{\n\tstruct idt_data data;\n\n\tBUG_ON(n > 0xFF);\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.vector\t= n;\n\tdata.addr\t= addr;\n\tdata.segment\t= __KERNEL_CS;\n\tdata.bits.type\t= GATE_INTERRUPT;\n\tdata.bits.p\t= 1;\n\n\tidt_setup_from_table(idt_table, &data, 1, false);\n}\n\n/**\n * idt_setup_early_traps - Initialize the idt table with early traps\n *\n * On X8664 these traps do not use interrupt stacks as they can't work\n * before cpu_init() is invoked and sets up TSS. The IST variants are\n * installed after that.\n */\nvoid __init idt_setup_early_traps(void)\n{\n\tidt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),\n\t\t\t     true);\n\tload_idt(&idt_descr);\n}\n\n/**\n * idt_setup_traps - Initialize the idt table with default traps\n */\nvoid __init idt_setup_traps(void)\n{\n\tidt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), true);\n}\n\n#ifdef CONFIG_X86_64\n/**\n * idt_setup_early_pf - Initialize the idt table with early pagefault handler\n *\n * On X8664 this does not use interrupt stacks as they can't work before\n * cpu_init() is invoked and sets up TSS. The IST variant is installed\n * after that.\n *\n * FIXME: Why is 32bit and 64bit installing the PF handler at different\n * places in the early setup code?\n */\nvoid __init idt_setup_early_pf(void)\n{\n\tidt_setup_from_table(idt_table, early_pf_idts,\n\t\t\t     ARRAY_SIZE(early_pf_idts), true);\n}\n\n/**\n * idt_setup_ist_traps - Initialize the idt table with traps using IST\n */\nvoid __init idt_setup_ist_traps(void)\n{\n\tidt_setup_from_table(idt_table, ist_idts, ARRAY_SIZE(ist_idts), true);\n}\n\n/**\n * idt_setup_debugidt_traps - Initialize the debug idt table with debug traps\n */\nvoid __init idt_setup_debugidt_traps(void)\n{\n\tmemcpy(&debug_idt_table, &idt_table, IDT_ENTRIES * 16);\n\n\tidt_setup_from_table(debug_idt_table, dbg_idts, ARRAY_SIZE(dbg_idts), false);\n}\n#endif\n\n/**\n * idt_setup_apic_and_irq_gates - Setup APIC/SMP and normal interrupt gates\n */\nvoid __init idt_setup_apic_and_irq_gates(void)\n{\n\tint i = FIRST_EXTERNAL_VECTOR;\n\tvoid *entry;\n\n\tidt_setup_from_table(idt_table, apic_idts, ARRAY_SIZE(apic_idts), true);\n\n\tfor_each_clear_bit_from(i, system_vectors, FIRST_SYSTEM_VECTOR) {\n\t\tentry = irq_entries_start + 8 * (i - FIRST_EXTERNAL_VECTOR);\n\t\tset_intr_gate(i, entry);\n\t}\n\n\tfor_each_clear_bit_from(i, system_vectors, NR_VECTORS) {\n#ifdef CONFIG_X86_LOCAL_APIC\n\t\tset_bit(i, system_vectors);\n\t\tset_intr_gate(i, spurious_interrupt);\n#else\n\t\tentry = irq_entries_start + 8 * (i - FIRST_EXTERNAL_VECTOR);\n\t\tset_intr_gate(i, entry);\n#endif\n\t}\n}\n\n/**\n * idt_setup_early_handler - Initializes the idt table with early handlers\n */\nvoid __init idt_setup_early_handler(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_EXCEPTION_VECTORS; i++)\n\t\tset_intr_gate(i, early_idt_handler_array[i]);\n#ifdef CONFIG_X86_32\n\tfor ( ; i < NR_VECTORS; i++)\n\t\tset_intr_gate(i, early_ignore_irq);\n#endif\n\tload_idt(&idt_descr);\n}\n\n/**\n * idt_invalidate - Invalidate interrupt descriptor table\n * @addr:\tThe virtual address of the 'invalid' IDT\n */\nvoid idt_invalidate(void *addr)\n{\n\tstruct desc_ptr idt = { .address = (unsigned long) addr, .size = 0 };\n\n\tload_idt(&idt);\n}\n\nvoid __init update_intr_gate(unsigned int n, const void *addr)\n{\n\tif (WARN_ON_ONCE(!test_bit(n, system_vectors)))\n\t\treturn;\n\tset_intr_gate(n, addr);\n}\n\nvoid alloc_intr_gate(unsigned int n, const void *addr)\n{\n\tBUG_ON(n < FIRST_SYSTEM_VECTOR);\n\tif (!test_and_set_bit(n, system_vectors))\n\t\tset_intr_gate(n, addr);\n}\n", "/*\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 2000, 2001, 2002 Andi Kleen, SuSE Labs\n *\n *  Pentium III FXSR, SSE support\n *\tGareth Hughes <gareth@valinux.com>, May 2000\n */\n\n/*\n * Handle hardware traps and faults.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/context_tracking.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/kprobes.h>\n#include <linux/uaccess.h>\n#include <linux/kdebug.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/ptrace.h>\n#include <linux/uprobes.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/kexec.h>\n#include <linux/sched.h>\n#include <linux/sched/task_stack.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/bug.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/io.h>\n\n#if defined(CONFIG_EDAC)\n#include <linux/edac.h>\n#endif\n\n#include <asm/stacktrace.h>\n#include <asm/processor.h>\n#include <asm/debugreg.h>\n#include <linux/atomic.h>\n#include <asm/text-patching.h>\n#include <asm/ftrace.h>\n#include <asm/traps.h>\n#include <asm/desc.h>\n#include <asm/fpu/internal.h>\n#include <asm/cpu_entry_area.h>\n#include <asm/mce.h>\n#include <asm/fixmap.h>\n#include <asm/mach_traps.h>\n#include <asm/alternative.h>\n#include <asm/fpu/xstate.h>\n#include <asm/trace/mpx.h>\n#include <asm/mpx.h>\n#include <asm/vm86.h>\n#include <asm/umip.h>\n\n#ifdef CONFIG_X86_64\n#include <asm/x86_init.h>\n#include <asm/pgalloc.h>\n#include <asm/proto.h>\n#else\n#include <asm/processor-flags.h>\n#include <asm/setup.h>\n#include <asm/proto.h>\n#endif\n\nDECLARE_BITMAP(system_vectors, NR_VECTORS);\n\nstatic inline void cond_local_irq_enable(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_enable();\n}\n\nstatic inline void cond_local_irq_disable(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_disable();\n}\n\n/*\n * In IST context, we explicitly disable preemption.  This serves two\n * purposes: it makes it much less likely that we would accidentally\n * schedule in IST context and it will force a warning if we somehow\n * manage to schedule by accident.\n */\nvoid ist_enter(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\t} else {\n\t\t/*\n\t\t * We might have interrupted pretty much anything.  In\n\t\t * fact, if we're a machine check, we can even interrupt\n\t\t * NMI processing.  We don't want in_nmi() to return true,\n\t\t * but we need to notify RCU.\n\t\t */\n\t\trcu_nmi_enter();\n\t}\n\n\tpreempt_disable();\n\n\t/* This code is a bit fragile.  Test it. */\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"ist_enter didn't work\");\n}\n\nvoid ist_exit(struct pt_regs *regs)\n{\n\tpreempt_enable_no_resched();\n\n\tif (!user_mode(regs))\n\t\trcu_nmi_exit();\n}\n\n/**\n * ist_begin_non_atomic() - begin a non-atomic section in an IST exception\n * @regs:\tregs passed to the IST exception handler\n *\n * IST exception handlers normally cannot schedule.  As a special\n * exception, if the exception interrupted userspace code (i.e.\n * user_mode(regs) would return true) and the exception was not\n * a double fault, it can be safe to schedule.  ist_begin_non_atomic()\n * begins a non-atomic section within an ist_enter()/ist_exit() region.\n * Callers are responsible for enabling interrupts themselves inside\n * the non-atomic section, and callers must call ist_end_non_atomic()\n * before ist_exit().\n */\nvoid ist_begin_non_atomic(struct pt_regs *regs)\n{\n\tBUG_ON(!user_mode(regs));\n\n\t/*\n\t * Sanity check: we need to be on the normal thread stack.  This\n\t * will catch asm bugs and any attempt to use ist_preempt_enable\n\t * from double_fault.\n\t */\n\tBUG_ON(!on_thread_stack());\n\n\tpreempt_enable_no_resched();\n}\n\n/**\n * ist_end_non_atomic() - begin a non-atomic section in an IST exception\n *\n * Ends a non-atomic section started with ist_begin_non_atomic().\n */\nvoid ist_end_non_atomic(void)\n{\n\tpreempt_disable();\n}\n\nint is_valid_bugaddr(unsigned long addr)\n{\n\tunsigned short ud;\n\n\tif (addr < TASK_SIZE_MAX)\n\t\treturn 0;\n\n\tif (probe_kernel_address((unsigned short *)addr, ud))\n\t\treturn 0;\n\n\treturn ud == INSN_UD0 || ud == INSN_UD2;\n}\n\nint fixup_bug(struct pt_regs *regs, int trapnr)\n{\n\tif (trapnr != X86_TRAP_UD)\n\t\treturn 0;\n\n\tswitch (report_bug(regs->ip, regs)) {\n\tcase BUG_TRAP_TYPE_NONE:\n\tcase BUG_TRAP_TYPE_BUG:\n\t\tbreak;\n\n\tcase BUG_TRAP_TYPE_WARN:\n\t\tregs->ip += LEN_UD2;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic nokprobe_inline int\ndo_trap_no_signal(struct task_struct *tsk, int trapnr, char *str,\n\t\t  struct pt_regs *regs,\tlong error_code)\n{\n\tif (v8086_mode(regs)) {\n\t\t/*\n\t\t * Traps 0, 1, 3, 4, and 5 should be forwarded to vm86.\n\t\t * On nmi (interrupt 2), do_trap should not be called.\n\t\t */\n\t\tif (trapnr < X86_TRAP_UD) {\n\t\t\tif (!handle_vm86_trap((struct kernel_vm86_regs *) regs,\n\t\t\t\t\t\terror_code, trapnr))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (!user_mode(regs)) {\n\t\tif (fixup_exception(regs, trapnr))\n\t\t\treturn 0;\n\n\t\ttsk->thread.error_code = error_code;\n\t\ttsk->thread.trap_nr = trapnr;\n\t\tdie(str, regs, error_code);\n\t}\n\n\treturn -1;\n}\n\nstatic siginfo_t *fill_trap_info(struct pt_regs *regs, int signr, int trapnr,\n\t\t\t\tsiginfo_t *info)\n{\n\tunsigned long siaddr;\n\tint sicode;\n\n\tswitch (trapnr) {\n\tdefault:\n\t\treturn SEND_SIG_PRIV;\n\n\tcase X86_TRAP_DE:\n\t\tsicode = FPE_INTDIV;\n\t\tsiaddr = uprobe_get_trap_addr(regs);\n\t\tbreak;\n\tcase X86_TRAP_UD:\n\t\tsicode = ILL_ILLOPN;\n\t\tsiaddr = uprobe_get_trap_addr(regs);\n\t\tbreak;\n\tcase X86_TRAP_AC:\n\t\tsicode = BUS_ADRALN;\n\t\tsiaddr = 0;\n\t\tbreak;\n\t}\n\n\tinfo->si_signo = signr;\n\tinfo->si_errno = 0;\n\tinfo->si_code = sicode;\n\tinfo->si_addr = (void __user *)siaddr;\n\treturn info;\n}\n\nstatic void\ndo_trap(int trapnr, int signr, char *str, struct pt_regs *regs,\n\tlong error_code, siginfo_t *info)\n{\n\tstruct task_struct *tsk = current;\n\n\n\tif (!do_trap_no_signal(tsk, trapnr, str, regs, error_code))\n\t\treturn;\n\t/*\n\t * We want error_code and trap_nr set for userspace faults and\n\t * kernelspace faults which result in die(), but not\n\t * kernelspace faults which are fixed up.  die() gives the\n\t * process no chance to handle the signal and notice the\n\t * kernel fault information, so that won't result in polluting\n\t * the information about previously queued, but not yet\n\t * delivered, faults.  See also do_general_protection below.\n\t */\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = trapnr;\n\n\tif (show_unhandled_signals && unhandled_signal(tsk, signr) &&\n\t    printk_ratelimit()) {\n\t\tpr_info(\"%s[%d] trap %s ip:%lx sp:%lx error:%lx\",\n\t\t\ttsk->comm, tsk->pid, str,\n\t\t\tregs->ip, regs->sp, error_code);\n\t\tprint_vma_addr(KERN_CONT \" in \", regs->ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tforce_sig_info(signr, info ?: SEND_SIG_PRIV, tsk);\n}\nNOKPROBE_SYMBOL(do_trap);\n\nstatic void do_error_trap(struct pt_regs *regs, long error_code, char *str,\n\t\t\t  unsigned long trapnr, int signr)\n{\n\tsiginfo_t info;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\n\t/*\n\t * WARN*()s end up here; fix them up before we call the\n\t * notifier chain.\n\t */\n\tif (!user_mode(regs) && fixup_bug(regs, trapnr))\n\t\treturn;\n\n\tif (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=\n\t\t\tNOTIFY_STOP) {\n\t\tcond_local_irq_enable(regs);\n\t\tdo_trap(trapnr, signr, str, regs, error_code,\n\t\t\tfill_trap_info(regs, signr, trapnr, &info));\n\t}\n}\n\n#define DO_ERROR(trapnr, signr, str, name)\t\t\t\t\\\ndotraplinkage void do_##name(struct pt_regs *regs, long error_code)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tdo_error_trap(regs, error_code, str, trapnr, signr);\t\t\\\n}\n\nDO_ERROR(X86_TRAP_DE,     SIGFPE,  \"divide error\",\t\tdivide_error)\nDO_ERROR(X86_TRAP_OF,     SIGSEGV, \"overflow\",\t\t\toverflow)\nDO_ERROR(X86_TRAP_UD,     SIGILL,  \"invalid opcode\",\t\tinvalid_op)\nDO_ERROR(X86_TRAP_OLD_MF, SIGFPE,  \"coprocessor segment overrun\",coprocessor_segment_overrun)\nDO_ERROR(X86_TRAP_TS,     SIGSEGV, \"invalid TSS\",\t\tinvalid_TSS)\nDO_ERROR(X86_TRAP_NP,     SIGBUS,  \"segment not present\",\tsegment_not_present)\nDO_ERROR(X86_TRAP_SS,     SIGBUS,  \"stack segment\",\t\tstack_segment)\nDO_ERROR(X86_TRAP_AC,     SIGBUS,  \"alignment check\",\t\talignment_check)\n\n#ifdef CONFIG_VMAP_STACK\n__visible void __noreturn handle_stack_overflow(const char *message,\n\t\t\t\t\t\tstruct pt_regs *regs,\n\t\t\t\t\t\tunsigned long fault_address)\n{\n\tprintk(KERN_EMERG \"BUG: stack guard page was hit at %p (stack is %p..%p)\\n\",\n\t\t (void *)fault_address, current->stack,\n\t\t (char *)current->stack + THREAD_SIZE - 1);\n\tdie(message, regs, 0);\n\n\t/* Be absolutely certain we don't return. */\n\tpanic(message);\n}\n#endif\n\n#ifdef CONFIG_X86_64\n/* Runs on IST stack */\ndotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)\n{\n\tstatic const char str[] = \"double fault\";\n\tstruct task_struct *tsk = current;\n#ifdef CONFIG_VMAP_STACK\n\tunsigned long cr2;\n#endif\n\n#ifdef CONFIG_X86_ESPFIX64\n\textern unsigned char native_irq_return_iret[];\n\n\t/*\n\t * If IRET takes a non-IST fault on the espfix64 stack, then we\n\t * end up promoting it to a doublefault.  In that case, take\n\t * advantage of the fact that we're not using the normal (TSS.sp0)\n\t * stack right now.  We can write a fake #GP(0) frame at TSS.sp0\n\t * and then modify our own IRET frame so that, when we return,\n\t * we land directly at the #GP(0) vector with the stack already\n\t * set up according to its expectations.\n\t *\n\t * The net result is that our #GP handler will think that we\n\t * entered from usermode with the bad user context.\n\t *\n\t * No need for ist_enter here because we don't use RCU.\n\t */\n\tif (((long)regs->sp >> P4D_SHIFT) == ESPFIX_PGD_ENTRY &&\n\t\tregs->cs == __KERNEL_CS &&\n\t\tregs->ip == (unsigned long)native_irq_return_iret)\n\t{\n\t\tstruct pt_regs *gpregs = (struct pt_regs *)this_cpu_read(cpu_tss_rw.x86_tss.sp0) - 1;\n\n\t\t/*\n\t\t * regs->sp points to the failing IRET frame on the\n\t\t * ESPFIX64 stack.  Copy it to the entry stack.  This fills\n\t\t * in gpregs->ss through gpregs->ip.\n\t\t *\n\t\t */\n\t\tmemmove(&gpregs->ip, (void *)regs->sp, 5*8);\n\t\tgpregs->orig_ax = 0;  /* Missing (lost) #GP error code */\n\n\t\t/*\n\t\t * Adjust our frame so that we return straight to the #GP\n\t\t * vector with the expected RSP value.  This is safe because\n\t\t * we won't enable interupts or schedule before we invoke\n\t\t * general_protection, so nothing will clobber the stack\n\t\t * frame we just set up.\n\t\t */\n\t\tregs->ip = (unsigned long)general_protection;\n\t\tregs->sp = (unsigned long)&gpregs->orig_ax;\n\n\t\treturn;\n\t}\n#endif\n\n\tist_enter(regs);\n\tnotify_die(DIE_TRAP, str, regs, error_code, X86_TRAP_DF, SIGSEGV);\n\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = X86_TRAP_DF;\n\n#ifdef CONFIG_VMAP_STACK\n\t/*\n\t * If we overflow the stack into a guard page, the CPU will fail\n\t * to deliver #PF and will send #DF instead.  Similarly, if we\n\t * take any non-IST exception while too close to the bottom of\n\t * the stack, the processor will get a page fault while\n\t * delivering the exception and will generate a double fault.\n\t *\n\t * According to the SDM (footnote in 6.15 under \"Interrupt 14 -\n\t * Page-Fault Exception (#PF):\n\t *\n\t *   Processors update CR2 whenever a page fault is detected. If a\n\t *   second page fault occurs while an earlier page fault is being\n\t *   delivered, the faulting linear address of the second fault will\n\t *   overwrite the contents of CR2 (replacing the previous\n\t *   address). These updates to CR2 occur even if the page fault\n\t *   results in a double fault or occurs during the delivery of a\n\t *   double fault.\n\t *\n\t * The logic below has a small possibility of incorrectly diagnosing\n\t * some errors as stack overflows.  For example, if the IDT or GDT\n\t * gets corrupted such that #GP delivery fails due to a bad descriptor\n\t * causing #GP and we hit this condition while CR2 coincidentally\n\t * points to the stack guard page, we'll think we overflowed the\n\t * stack.  Given that we're going to panic one way or another\n\t * if this happens, this isn't necessarily worth fixing.\n\t *\n\t * If necessary, we could improve the test by only diagnosing\n\t * a stack overflow if the saved RSP points within 47 bytes of\n\t * the bottom of the stack: if RSP == tsk_stack + 48 and we\n\t * take an exception, the stack is already aligned and there\n\t * will be enough room SS, RSP, RFLAGS, CS, RIP, and a\n\t * possible error code, so a stack overflow would *not* double\n\t * fault.  With any less space left, exception delivery could\n\t * fail, and, as a practical matter, we've overflowed the\n\t * stack even if the actual trigger for the double fault was\n\t * something else.\n\t */\n\tcr2 = read_cr2();\n\tif ((unsigned long)task_stack_page(tsk) - 1 - cr2 < PAGE_SIZE)\n\t\thandle_stack_overflow(\"kernel stack overflow (double-fault)\", regs, cr2);\n#endif\n\n#ifdef CONFIG_DOUBLEFAULT\n\tdf_debug(regs, error_code);\n#endif\n\t/*\n\t * This is always a kernel trap and never fixable (and thus must\n\t * never return).\n\t */\n\tfor (;;)\n\t\tdie(str, regs, error_code);\n}\n#endif\n\ndotraplinkage void do_bounds(struct pt_regs *regs, long error_code)\n{\n\tconst struct mpx_bndcsr *bndcsr;\n\tsiginfo_t *info;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tif (notify_die(DIE_TRAP, \"bounds\", regs, error_code,\n\t\t\tX86_TRAP_BR, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\tcond_local_irq_enable(regs);\n\n\tif (!user_mode(regs))\n\t\tdie(\"bounds\", regs, error_code);\n\n\tif (!cpu_feature_enabled(X86_FEATURE_MPX)) {\n\t\t/* The exception is not from Intel MPX */\n\t\tgoto exit_trap;\n\t}\n\n\t/*\n\t * We need to look at BNDSTATUS to resolve this exception.\n\t * A NULL here might mean that it is in its 'init state',\n\t * which is all zeros which indicates MPX was not\n\t * responsible for the exception.\n\t */\n\tbndcsr = get_xsave_field_ptr(XFEATURE_MASK_BNDCSR);\n\tif (!bndcsr)\n\t\tgoto exit_trap;\n\n\ttrace_bounds_exception_mpx(bndcsr);\n\t/*\n\t * The error code field of the BNDSTATUS register communicates status\n\t * information of a bound range exception #BR or operation involving\n\t * bound directory.\n\t */\n\tswitch (bndcsr->bndstatus & MPX_BNDSTA_ERROR_CODE) {\n\tcase 2:\t/* Bound directory has invalid entry. */\n\t\tif (mpx_handle_bd_fault())\n\t\t\tgoto exit_trap;\n\t\tbreak; /* Success, it was handled */\n\tcase 1: /* Bound violation. */\n\t\tinfo = mpx_generate_siginfo(regs);\n\t\tif (IS_ERR(info)) {\n\t\t\t/*\n\t\t\t * We failed to decode the MPX instruction.  Act as if\n\t\t\t * the exception was not caused by MPX.\n\t\t\t */\n\t\t\tgoto exit_trap;\n\t\t}\n\t\t/*\n\t\t * Success, we decoded the instruction and retrieved\n\t\t * an 'info' containing the address being accessed\n\t\t * which caused the exception.  This information\n\t\t * allows and application to possibly handle the\n\t\t * #BR exception itself.\n\t\t */\n\t\tdo_trap(X86_TRAP_BR, SIGSEGV, \"bounds\", regs, error_code, info);\n\t\tkfree(info);\n\t\tbreak;\n\tcase 0: /* No exception caused by Intel MPX operations. */\n\t\tgoto exit_trap;\n\tdefault:\n\t\tdie(\"bounds\", regs, error_code);\n\t}\n\n\treturn;\n\nexit_trap:\n\t/*\n\t * This path out is for all the cases where we could not\n\t * handle the exception in some way (like allocating a\n\t * table or telling userspace about it.  We will also end\n\t * up here if the kernel has MPX turned off at compile\n\t * time..\n\t */\n\tdo_trap(X86_TRAP_BR, SIGSEGV, \"bounds\", regs, error_code, NULL);\n}\n\ndotraplinkage void\ndo_general_protection(struct pt_regs *regs, long error_code)\n{\n\tstruct task_struct *tsk;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tcond_local_irq_enable(regs);\n\n\tif (static_cpu_has(X86_FEATURE_UMIP)) {\n\t\tif (user_mode(regs) && fixup_umip_exception(regs))\n\t\t\treturn;\n\t}\n\n\tif (v8086_mode(regs)) {\n\t\tlocal_irq_enable();\n\t\thandle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);\n\t\treturn;\n\t}\n\n\ttsk = current;\n\tif (!user_mode(regs)) {\n\t\tif (fixup_exception(regs, X86_TRAP_GP))\n\t\t\treturn;\n\n\t\ttsk->thread.error_code = error_code;\n\t\ttsk->thread.trap_nr = X86_TRAP_GP;\n\t\tif (notify_die(DIE_GPF, \"general protection fault\", regs, error_code,\n\t\t\t       X86_TRAP_GP, SIGSEGV) != NOTIFY_STOP)\n\t\t\tdie(\"general protection fault\", regs, error_code);\n\t\treturn;\n\t}\n\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_nr = X86_TRAP_GP;\n\n\tif (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&\n\t\t\tprintk_ratelimit()) {\n\t\tpr_info(\"%s[%d] general protection ip:%lx sp:%lx error:%lx\",\n\t\t\ttsk->comm, task_pid_nr(tsk),\n\t\t\tregs->ip, regs->sp, error_code);\n\t\tprint_vma_addr(KERN_CONT \" in \", regs->ip);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tforce_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);\n}\nNOKPROBE_SYMBOL(do_general_protection);\n\ndotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/*\n\t * ftrace must be first, everything else may cause a recursive crash.\n\t * See note by declaration of modifying_ftrace_code in ftrace.c\n\t */\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\n\t/*\n\t * Use ist_enter despite the fact that we don't use an IST stack.\n\t * We can be called from a kprobe in non-CONTEXT_KERNEL kernel\n\t * mode or even during context tracking state changes.\n\t *\n\t * This means that we can't schedule.  That's okay.\n\t */\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */\n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\nexit:\n\tist_exit(regs);\n}\nNOKPROBE_SYMBOL(do_int3);\n\n#ifdef CONFIG_X86_64\n/*\n * Help handler running on a per-cpu (IST or entry trampoline) stack\n * to switch to the normal thread stack if the interrupted code was in\n * user mode. The actual stack switch is done in entry_64.S\n */\nasmlinkage __visible notrace struct pt_regs *sync_regs(struct pt_regs *eregs)\n{\n\tstruct pt_regs *regs = (struct pt_regs *)this_cpu_read(cpu_current_top_of_stack) - 1;\n\tif (regs != eregs)\n\t\t*regs = *eregs;\n\treturn regs;\n}\nNOKPROBE_SYMBOL(sync_regs);\n\nstruct bad_iret_stack {\n\tvoid *error_entry_ret;\n\tstruct pt_regs regs;\n};\n\nasmlinkage __visible notrace\nstruct bad_iret_stack *fixup_bad_iret(struct bad_iret_stack *s)\n{\n\t/*\n\t * This is called from entry_64.S early in handling a fault\n\t * caused by a bad iret to user mode.  To handle the fault\n\t * correctly, we want to move our stack frame to where it would\n\t * be had we entered directly on the entry stack (rather than\n\t * just below the IRET frame) and we want to pretend that the\n\t * exception came from the IRET target.\n\t */\n\tstruct bad_iret_stack *new_stack =\n\t\t(struct bad_iret_stack *)this_cpu_read(cpu_tss_rw.x86_tss.sp0) - 1;\n\n\t/* Copy the IRET target to the new stack. */\n\tmemmove(&new_stack->regs.ip, (void *)s->regs.sp, 5*8);\n\n\t/* Copy the remainder of the stack from the current stack. */\n\tmemmove(new_stack, s, offsetof(struct bad_iret_stack, regs.ip));\n\n\tBUG_ON(!user_mode(&new_stack->regs));\n\treturn new_stack;\n}\nNOKPROBE_SYMBOL(fixup_bad_iret);\n#endif\n\nstatic bool is_sysenter_singlestep(struct pt_regs *regs)\n{\n\t/*\n\t * We don't try for precision here.  If we're anywhere in the region of\n\t * code that can be single-stepped in the SYSENTER entry path, then\n\t * assume that this is a useless single-step trap due to SYSENTER\n\t * being invoked with TF set.  (We don't know in advance exactly\n\t * which instructions will be hit because BTF could plausibly\n\t * be set.)\n\t */\n#ifdef CONFIG_X86_32\n\treturn (regs->ip - (unsigned long)__begin_SYSENTER_singlestep_region) <\n\t\t(unsigned long)__end_SYSENTER_singlestep_region -\n\t\t(unsigned long)__begin_SYSENTER_singlestep_region;\n#elif defined(CONFIG_IA32_EMULATION)\n\treturn (regs->ip - (unsigned long)entry_SYSENTER_compat) <\n\t\t(unsigned long)__end_entry_SYSENTER_compat -\n\t\t(unsigned long)entry_SYSENTER_compat;\n#else\n\treturn false;\n#endif\n}\n\n/*\n * Our handling of the processor debug registers is non-trivial.\n * We do not clear them on entry and exit from the kernel. Therefore\n * it is possible to get a watchpoint trap here from inside the kernel.\n * However, the code in ./ptrace.c has ensured that the user can\n * only set watchpoints on userspace addresses. Therefore the in-kernel\n * watchpoint trap can only occur in code which is reading/writing\n * from user space. Such code must not hold kernel locks (since it\n * can equally take a page fault), therefore it is safe to call\n * force_sig_info even though that claims and releases locks.\n *\n * Code in ./signal.c ensures that the debug control register\n * is restored before we deliver any signal, and therefore that\n * user code runs with the correct debug control register even though\n * we clear it here.\n *\n * Being careful here means that we don't have to be as careful in a\n * lot of more complicated places (task switching can be a bit lazy\n * about restoring all the debug state, and ptrace doesn't have to\n * find every occurrence of the TF bit that could be saved away even\n * by user code)\n *\n * May run on IST stack.\n */\ndotraplinkage void do_debug(struct pt_regs *regs, long error_code)\n{\n\tstruct task_struct *tsk = current;\n\tint user_icebp = 0;\n\tunsigned long dr6;\n\tint si_code;\n\n\tist_enter(regs);\n\n\tget_debugreg(dr6, 6);\n\t/*\n\t * The Intel SDM says:\n\t *\n\t *   Certain debug exceptions may clear bits 0-3. The remaining\n\t *   contents of the DR6 register are never cleared by the\n\t *   processor. To avoid confusion in identifying debug\n\t *   exceptions, debug handlers should clear the register before\n\t *   returning to the interrupted task.\n\t *\n\t * Keep it simple: clear DR6 immediately.\n\t */\n\tset_debugreg(0, 6);\n\n\t/* Filter out all the reserved bits which are preset to 1 */\n\tdr6 &= ~DR6_RESERVED;\n\n\t/*\n\t * The SDM says \"The processor clears the BTF flag when it\n\t * generates a debug exception.\"  Clear TIF_BLOCKSTEP to keep\n\t * TIF_BLOCKSTEP in sync with the hardware BTF flag.\n\t */\n\tclear_tsk_thread_flag(tsk, TIF_BLOCKSTEP);\n\n\tif (unlikely(!user_mode(regs) && (dr6 & DR_STEP) &&\n\t\t     is_sysenter_singlestep(regs))) {\n\t\tdr6 &= ~DR_STEP;\n\t\tif (!dr6)\n\t\t\tgoto exit;\n\t\t/*\n\t\t * else we might have gotten a single-step trap and hit a\n\t\t * watchpoint at the same time, in which case we should fall\n\t\t * through and handle the watchpoint.\n\t\t */\n\t}\n\n\t/*\n\t * If dr6 has no reason to give us about the origin of this trap,\n\t * then it's very likely the result of an icebp/int01 trap.\n\t * User wants a sigtrap for that.\n\t */\n\tif (!dr6 && user_mode(regs))\n\t\tuser_icebp = 1;\n\n\t/* Store the virtualized DR6 value */\n\ttsk->thread.debugreg6 = dr6;\n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_debug_handler(regs))\n\t\tgoto exit;\n#endif\n\n\tif (notify_die(DIE_DEBUG, \"debug\", regs, (long)&dr6, error_code,\n\t\t\t\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\n\t/*\n\t * Let others (NMI) know that the debug stack is in use\n\t * as we may switch to the interrupt stack.\n\t */\n\tdebug_stack_usage_inc();\n\n\t/* It's safe to allow irq's after DR6 has been saved */\n\tcond_local_irq_enable(regs);\n\n\tif (v8086_mode(regs)) {\n\t\thandle_vm86_trap((struct kernel_vm86_regs *) regs, error_code,\n\t\t\t\t\tX86_TRAP_DB);\n\t\tcond_local_irq_disable(regs);\n\t\tdebug_stack_usage_dec();\n\t\tgoto exit;\n\t}\n\n\tif (WARN_ON_ONCE((dr6 & DR_STEP) && !user_mode(regs))) {\n\t\t/*\n\t\t * Historical junk that used to handle SYSENTER single-stepping.\n\t\t * This should be unreachable now.  If we survive for a while\n\t\t * without anyone hitting this warning, we'll turn this into\n\t\t * an oops.\n\t\t */\n\t\ttsk->thread.debugreg6 &= ~DR_STEP;\n\t\tset_tsk_thread_flag(tsk, TIF_SINGLESTEP);\n\t\tregs->flags &= ~X86_EFLAGS_TF;\n\t}\n\tsi_code = get_si_code(tsk->thread.debugreg6);\n\tif (tsk->thread.debugreg6 & (DR_STEP | DR_TRAP_BITS) || user_icebp)\n\t\tsend_sigtrap(tsk, regs, error_code, si_code);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\n\nexit:\n\tist_exit(regs);\n}\nNOKPROBE_SYMBOL(do_debug);\n\n/*\n * Note that we play around with the 'TS' bit in an attempt to get\n * the correct behaviour even in the presence of the asynchronous\n * IRQ13 behaviour\n */\nstatic void math_error(struct pt_regs *regs, int error_code, int trapnr)\n{\n\tstruct task_struct *task = current;\n\tstruct fpu *fpu = &task->thread.fpu;\n\tsiginfo_t info;\n\tchar *str = (trapnr == X86_TRAP_MF) ? \"fpu exception\" :\n\t\t\t\t\t\t\"simd exception\";\n\n\tif (notify_die(DIE_TRAP, str, regs, error_code, trapnr, SIGFPE) == NOTIFY_STOP)\n\t\treturn;\n\tcond_local_irq_enable(regs);\n\n\tif (!user_mode(regs)) {\n\t\tif (!fixup_exception(regs, trapnr)) {\n\t\t\ttask->thread.error_code = error_code;\n\t\t\ttask->thread.trap_nr = trapnr;\n\t\t\tdie(str, regs, error_code);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t * Save the info for the exception handler and clear the error.\n\t */\n\tfpu__save(fpu);\n\n\ttask->thread.trap_nr\t= trapnr;\n\ttask->thread.error_code = error_code;\n\tinfo.si_signo\t\t= SIGFPE;\n\tinfo.si_errno\t\t= 0;\n\tinfo.si_addr\t\t= (void __user *)uprobe_get_trap_addr(regs);\n\n\tinfo.si_code = fpu__exception_code(fpu, trapnr);\n\n\t/* Retry when we get spurious exceptions: */\n\tif (!info.si_code)\n\t\treturn;\n\n\tforce_sig_info(SIGFPE, &info, task);\n}\n\ndotraplinkage void do_coprocessor_error(struct pt_regs *regs, long error_code)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tmath_error(regs, error_code, X86_TRAP_MF);\n}\n\ndotraplinkage void\ndo_simd_coprocessor_error(struct pt_regs *regs, long error_code)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tmath_error(regs, error_code, X86_TRAP_XF);\n}\n\ndotraplinkage void\ndo_spurious_interrupt_bug(struct pt_regs *regs, long error_code)\n{\n\tcond_local_irq_enable(regs);\n}\n\ndotraplinkage void\ndo_device_not_available(struct pt_regs *regs, long error_code)\n{\n\tunsigned long cr0;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\n#ifdef CONFIG_MATH_EMULATION\n\tif (!boot_cpu_has(X86_FEATURE_FPU) && (read_cr0() & X86_CR0_EM)) {\n\t\tstruct math_emu_info info = { };\n\n\t\tcond_local_irq_enable(regs);\n\n\t\tinfo.regs = regs;\n\t\tmath_emulate(&info);\n\t\treturn;\n\t}\n#endif\n\n\t/* This should not happen. */\n\tcr0 = read_cr0();\n\tif (WARN(cr0 & X86_CR0_TS, \"CR0.TS was set\")) {\n\t\t/* Try to fix it up and carry on. */\n\t\twrite_cr0(cr0 & ~X86_CR0_TS);\n\t} else {\n\t\t/*\n\t\t * Something terrible happened, and we're better off trying\n\t\t * to kill the task than getting stuck in a never-ending\n\t\t * loop of #NM faults.\n\t\t */\n\t\tdie(\"unexpected #NM exception\", regs, error_code);\n\t}\n}\nNOKPROBE_SYMBOL(do_device_not_available);\n\n#ifdef CONFIG_X86_32\ndotraplinkage void do_iret_error(struct pt_regs *regs, long error_code)\n{\n\tsiginfo_t info;\n\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n\tlocal_irq_enable();\n\n\tinfo.si_signo = SIGILL;\n\tinfo.si_errno = 0;\n\tinfo.si_code = ILL_BADSTK;\n\tinfo.si_addr = NULL;\n\tif (notify_die(DIE_TRAP, \"iret exception\", regs, error_code,\n\t\t\tX86_TRAP_IRET, SIGILL) != NOTIFY_STOP) {\n\t\tdo_trap(X86_TRAP_IRET, SIGILL, \"iret exception\", regs, error_code,\n\t\t\t&info);\n\t}\n}\n#endif\n\nvoid __init trap_init(void)\n{\n\t/* Init cpu_entry_area before IST entries are set up */\n\tsetup_cpu_entry_areas();\n\n\tidt_setup_traps();\n\n\t/*\n\t * Set the IDT descriptor to a fixed read-only location, so that the\n\t * \"sidt\" instruction will not leak the location of the kernel, and\n\t * to defend the IDT against arbitrary memory write vulnerabilities.\n\t * It will be reloaded in cpu_init() */\n\tcea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),\n\t\t    PAGE_KERNEL_RO);\n\tidt_descr.address = CPU_ENTRY_AREA_RO_IDT;\n\n\t/*\n\t * Should be a barrier for any external CPU state:\n\t */\n\tcpu_init();\n\n\tidt_setup_ist_traps();\n\n\tx86_init.irqs.trap_init();\n\n\tidt_setup_debugidt_traps();\n}\n"], "filenames": ["arch/x86/entry/entry_64.S", "arch/x86/kernel/idt.c", "arch/x86/kernel/traps.c"], "buggy_code_start_loc": [1141, 163, 580], "buggy_code_end_loc": [1142, 187, 621], "fixing_code_start_loc": [1141, 162, 579], "fixing_code_end_loc": [1142, 184, 622], "type": "CWE-362", "message": "A statement in the System Programming Guide of the Intel 64 and IA-32 Architectures Software Developer's Manual (SDM) was mishandled in the development of some or all operating-system kernels, resulting in unexpected behavior for #DB exceptions that are deferred by MOV SS or POP SS, as demonstrated by (for example) privilege escalation in Windows, macOS, some Xen configurations, or FreeBSD, or a Linux kernel crash. The MOV to SS and POP SS instructions inhibit interrupts (including NMIs), data breakpoints, and single step trap exceptions until the instruction boundary following the next instruction (SDM Vol. 3A; section 6.8.3). (The inhibited data breakpoints are those on memory accessed by the MOV to SS or POP to SS instruction itself.) Note that debug exceptions are not inhibited by the interrupt enable (EFLAGS.IF) system flag (SDM Vol. 3A; section 2.3). If the instruction following the MOV to SS or POP to SS instruction is an instruction like SYSCALL, SYSENTER, INT 3, etc. that transfers control to the operating system at CPL < 3, the debug exception is delivered after the transfer to CPL < 3 is complete. OS kernels may not expect this order of events and may therefore experience unexpected behavior when it occurs.", "other": {"cve": {"id": "CVE-2018-8897", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-08T18:29:00.547", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A statement in the System Programming Guide of the Intel 64 and IA-32 Architectures Software Developer's Manual (SDM) was mishandled in the development of some or all operating-system kernels, resulting in unexpected behavior for #DB exceptions that are deferred by MOV SS or POP SS, as demonstrated by (for example) privilege escalation in Windows, macOS, some Xen configurations, or FreeBSD, or a Linux kernel crash. The MOV to SS and POP SS instructions inhibit interrupts (including NMIs), data breakpoints, and single step trap exceptions until the instruction boundary following the next instruction (SDM Vol. 3A; section 6.8.3). (The inhibited data breakpoints are those on memory accessed by the MOV to SS or POP to SS instruction itself.) Note that debug exceptions are not inhibited by the interrupt enable (EFLAGS.IF) system flag (SDM Vol. 3A; section 2.3). If the instruction following the MOV to SS or POP to SS instruction is an instruction like SYSCALL, SYSENTER, INT 3, etc. that transfers control to the operating system at CPL < 3, the debug exception is delivered after the transfer to CPL < 3 is complete. OS kernels may not expect this order of events and may therefore experience unexpected behavior when it occurs."}, {"lang": "es", "value": "Una declaraci\u00f3n en la gu\u00eda de programaci\u00f3n de sistemas del Manual del desarrollador de software (SDM) de las arquitecturas Intel 64 e IA-32 se manej\u00f3 incorrectamente en el desarrollo de algunos o todos los n\u00facleos del sistema operativo, lo que provoc\u00f3 un comportamiento inesperado para las excepciones #DB que son diferidas por MOV SS o POP SS, tal y como queda demostrado con (por ejemplo) el escalado de privilegios en Windows, macOS, algunas configuraciones Xen o FreeBSD, o un fallo del kernel de Linux. Las instrucciones de MOV a SS y POP SS inhiben interrupciones (incluyendo NMI), puntos de interrupci\u00f3n de datos y excepciones de trampas de un paso hasta los l\u00edmites de la instrucci\u00f3n que siguen a la siguiente instrucci\u00f3n (SDM Vol. 3A; secci\u00f3n 6.8.3). (Los puntos de interrupci\u00f3n de datos inhibidos son aquellos en la memoria a los que accede a la propia instrucci\u00f3n MOV a SS o POP a SS). Tenga en cuenta que las excepciones de depuraci\u00f3n no est\u00e1n inhibidas por el indicador del sistema de habilitaci\u00f3n de interrupciones (EFLAGS.IF) (SDM Vol. 3A; secci\u00f3n 2.3). Si la instrucci\u00f3n que sigue a la instrucci\u00f3n MOV a SS o POP a SS es una instrucci\u00f3n como SYSCALL, SYSENTER, INT 3, etc. que transfiere el control al sistema operativo a CPL < 3, la excepci\u00f3n de depuraci\u00f3n se entrega despu\u00e9s de que la transferencia a CPL < 3 se haya completado. Es posible que los kernels del sistema operativo no esperen este orden de eventos y, por lo tanto, puedan experimentar un comportamiento inesperado cuando ocurra."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_virtualization_manager:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "46DFC288-53F5-4D8E-BD2F-4E828735F915"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:6.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "5FCF191B-971A-4945-AB14-08091689BE2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:6.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "BCEA97B9-A443-4F87-81B4-B3F0E94AC18E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:6.5:*:*:*:*:*:*:*", "matchCriteriaId": "56434D13-7A7B-495C-A135-2688C706A065"}, {"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "405F950F-0772-41A3-8B72-B67151CC1376"}, {"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "B5647AEA-DCE6-4950-A7EB-05465ECDDE16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "68A35129-70B0-4EA9-A0A2-51AC277649D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "55FD399E-959A-4FB6-B049-AA73F0DFF9CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:citrix:xenserver:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "49422CA5-DF4B-4FE4-B408-81B637BE1287"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:synology:skynas:-:*:*:*:*:*:*:*", "matchCriteriaId": "7C997777-BE79-4F77-90D7-E1A71D474D88"}, {"vulnerable": true, "criteria": "cpe:2.3:o:synology:diskstation_manager:5.2:*:*:*:*:*:*:*", "matchCriteriaId": "01527614-8A68-48DC-B0A0-F4AA99489221"}, {"vulnerable": true, "criteria": "cpe:2.3:o:synology:diskstation_manager:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "65372FA7-B54B-4298-99BF-483E9FEBA253"}, {"vulnerable": true, "criteria": "cpe:2.3:o:synology:diskstation_manager:6.1:*:*:*:*:*:*:*", "matchCriteriaId": "3D04EA1A-F8E0-415B-8786-1C8C0F08E132"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.13.4", "matchCriteriaId": "D053772A-D0AE-474A-AE49-26A251C4B5D4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:xen:xen:-:*:*:*:*:*:x86:*", "matchCriteriaId": "BAB3DD44-8D3F-493C-936C-E0D6C63685C4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:freebsd:freebsd:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.1", "matchCriteriaId": "702C5136-33B6-4F0F-8FF7-C2BE3668DE70"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://openwall.com/lists/oss-security/2018/05/08/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://openwall.com/lists/oss-security/2018/05/08/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.huawei.com/en/psirt/security-advisories/huawei-sa-20190921-01-debug-en", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/104071", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1040744", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1040849", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1040861", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1040866", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1040882", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1318", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1319", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1345", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1346", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1347", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1348", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1349", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1350", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1351", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1352", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1353", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1354", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1355", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1524", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1567074", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/can1357/CVE-2018-8897/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://help.ecostruxureit.com/display/public/UADCE725/Security+fixes+in+StruxureWare+Data+Center+Expert+v7.6.0", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2018/05/msg00015.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/06/msg00000.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://patchwork.kernel.org/patch/10386677/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8897", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180927-0002/", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/HT208742", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.citrix.com/article/CTX234679", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://svnweb.freebsd.org/base?view=revision&revision=333368", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3641-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3641-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4196", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4201", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/44697/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.exploit-db.com/exploits/45024/", "source": "cve@mitre.org"}, {"url": "https://www.freebsd.org/security/advisories/FreeBSD-SA-18:06.debugreg.asc", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.kb.cert.org/vuls/id/631579", "source": "cve@mitre.org"}, {"url": "https://www.synology.com/support/security/Synology_SA_18_21", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.triplefault.io/2018/05/spurious-db-exceptions-with-pop-ss.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://xenbits.xen.org/xsa/advisory-260.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9"}}