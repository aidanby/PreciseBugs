{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/nodes_x3d.h>\n#include <gpac/nodes_svg.h>\n#include <gpac/events.h>\n#include <gpac/base_coding.h>\n\n#ifndef __SYMBIAN32__\n#include <wchar.h>\n#endif\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\n/*for QP types*/\n#include \"../bifs/quant.h\"\n\nstruct _scenedump\n{\n\t/*the scene we're dumping - set at each SceneReplace or mannually*/\n\tGF_SceneGraph *sg;\n#ifndef GPAC_DISABLE_VRML\n\t/*the proto we're dumping*/\n\tGF_Proto *current_proto;\n#endif\n\tFILE *trace;\n\tu32 indent;\n\tchar *filename;\n\n\tGF_SceneDumpFormat dump_mode;\n\tu16 CurrentESID;\n\tu8 ind_char;\n\tBool XMLDump, X3DDump, LSRDump;\n\n\tGF_List *dump_nodes;\n\n\t/*nodes created through conditionals while parsing but not applied*/\n\tGF_List *mem_def_nodes;\n\n\tBool skip_scene_replace;\n\t/*for route insert/replace in conditionals in current scene replace*/\n\tGF_List *current_com_list;\n\tGF_List *inserted_routes;\n\n\tBool in_text;\n};\n\nstatic GF_Err gf_dump_vrml_route(GF_SceneDumper *sdump, GF_Route *r, u32 dump_type);\nstatic void gf_dump_vrml_node(GF_SceneDumper *sdump, GF_Node *node, Bool in_list, char *fieldContainer);\n\n#ifndef GPAC_DISABLE_SVG\nvoid gf_dump_svg_element(GF_SceneDumper *sdump, GF_Node *n, GF_Node *parent, Bool is_root);\n#endif\n\nGF_EXPORT\nGF_SceneDumper *gf_sm_dumper_new(GF_SceneGraph *graph, char *_rad_name, Bool is_final_name, char indent_char, GF_SceneDumpFormat dump_mode)\n{\n\tGF_SceneDumper *tmp;\n\tif (!graph) return NULL;\n\tGF_SAFEALLOC(tmp, GF_SceneDumper);\n\tif (!tmp) return NULL;\n\n\t/*store original*/\n\ttmp->dump_mode = dump_mode;\n\n#ifndef GPAC_DISABLE_SVG\n\tif ((graph->RootNode && (graph->RootNode->sgprivate->tag>=GF_NODE_RANGE_LAST_VRML) )\n\t        || (dump_mode==GF_SM_DUMP_LASER) || (dump_mode==GF_SM_DUMP_SVG)) {\n\t\ttmp->XMLDump = GF_TRUE;\n\t\tif (dump_mode==GF_SM_DUMP_LASER) {\n\t\t\ttmp->LSRDump = GF_TRUE;\n\t\t}\n\t\tif (_rad_name) {\n\t\t\tconst char* ext_name = tmp->LSRDump ? \".xsr\" : \".svg\";\n\t\t\ttmp->filename = (char *)gf_malloc(strlen(_rad_name) + strlen(ext_name) + 1);\n\t\t\tstrcpy(tmp->filename, _rad_name);\n\t\t\tif (!is_final_name) strcat(tmp->filename, ext_name);\n\t\t\ttmp->trace = gf_fopen(tmp->filename, \"wt\");\n\t\t\tif (!tmp->trace) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\ttmp->trace = stdout;\n\t\t}\n\t} else\n#endif\n\t{\n\n\t\tif (dump_mode==GF_SM_DUMP_AUTO_TXT) {\n\t\t\tif (!graph->RootNode || (graph->RootNode->sgprivate->tag<=GF_NODE_RANGE_LAST_MPEG4) ) {\n\t\t\t\tdump_mode = GF_SM_DUMP_BT;\n\t\t\t} else if (graph->RootNode->sgprivate->tag<=GF_NODE_RANGE_LAST_X3D) {\n\t\t\t\tdump_mode = GF_SM_DUMP_X3D_VRML;\n\t\t\t}\n\t\t}\n\t\telse if (dump_mode==GF_SM_DUMP_AUTO_XML) {\n\t\t\tif (!graph->RootNode || (graph->RootNode->sgprivate->tag<=GF_NODE_RANGE_LAST_MPEG4) ) {\n\t\t\t\tdump_mode = GF_SM_DUMP_XMTA;\n\t\t\t} else {\n\t\t\t\tdump_mode = GF_SM_DUMP_X3D_XML;\n\t\t\t}\n\t\t}\n\n\t\tif (_rad_name) {\n\t\t\tconst char* ext_name;\n\t\t\tswitch (dump_mode) {\n\t\t\tcase GF_SM_DUMP_X3D_XML:\n\t\t\t\text_name = \".x3d\";\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_XMTA:\n\t\t\t\text_name = \".xmt\";\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_X3D_VRML:\n\t\t\t\text_name = \".x3dv\";\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_VRML:\n\t\t\t\text_name = \".wrl\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\text_name = \".bt\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp->filename = (char *)gf_malloc(strlen(_rad_name ? _rad_name : \"\") + strlen(ext_name) + 1);\n\t\t\tstrcpy(tmp->filename, _rad_name ? _rad_name : \"\");\n\t\t\tif (!is_final_name) strcat(tmp->filename, ext_name);\n\t\t\ttmp->trace = gf_fopen(tmp->filename, \"wt\");\n\t\t\tif (!tmp->trace) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\ttmp->trace = stdout;\n\t\t\tswitch (dump_mode) {\n\t\t\tcase GF_SM_DUMP_X3D_XML:\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_XMTA:\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_X3D_VRML:\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ttmp->ind_char = indent_char;\n\ttmp->dump_nodes = gf_list_new();\n\ttmp->mem_def_nodes = gf_list_new();\n\ttmp->inserted_routes = gf_list_new();\n\ttmp->sg = graph;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_sm_dumper_set_extra_graph(GF_SceneDumper *sdump, GF_SceneGraph *extra)\n{\n\tsdump->sg = extra;\n}\n\nGF_EXPORT\nvoid gf_sm_dumper_del(GF_SceneDumper *sdump)\n{\n\tgf_list_del(sdump->dump_nodes);\n\twhile (gf_list_count(sdump->mem_def_nodes)) {\n\t\tGF_Node *tmp = (GF_Node *)gf_list_get(sdump->mem_def_nodes, 0);\n\t\tgf_list_rem(sdump->mem_def_nodes, 0);\n\t\tgf_node_unregister(tmp, NULL);\n\t}\n\tgf_list_del(sdump->mem_def_nodes);\n\tgf_list_del(sdump->inserted_routes);\n\tif (sdump->trace != stdout) gf_fclose(sdump->trace);\n\tif (sdump->filename) {\n\t\tgf_free(sdump->filename);\n\t\tsdump->filename = NULL;\n\t}\n\tgf_free(sdump);\n}\n\nchar *gf_sm_dump_get_name(GF_SceneDumper *bd)\n{\n\tif (!bd) return NULL;\n\treturn bd->filename;\n}\n\nstatic void gf_dump_setup(GF_SceneDumper *sdump, GF_Descriptor *root_od)\n{\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\t\tif (sdump->dump_mode==GF_SM_DUMP_XML) return;\n\t\tgf_fprintf(sdump->trace, \"<!-- %s Scene Dump -->\\n\",\n\t\t        (sdump->dump_mode==GF_SM_DUMP_SVG) ? \"SVG\" :\n\t\t        (sdump->dump_mode==GF_SM_DUMP_LASER) ? \"LASeR\" :\n\t\t        sdump->X3DDump ? \"X3D\" : \"XMT-A\"\n\t\t       );\n\t}\n\tif (sdump->dump_mode==GF_SM_DUMP_SVG) return;\n\tif (sdump->LSRDump) {\n\t\tgf_fprintf(sdump->trace, \"<saf:SAFSession xmlns:saf=\\\"urn:mpeg:mpeg4:SAF:2005\\\" >\\n\");\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tif (root_od) {\n\t\t\tGF_ObjectDescriptor *iod = (GF_ObjectDescriptor *)root_od;\n\t\t\tu32 i, count;\n\t\t\tgf_fprintf(sdump->trace, \"<saf:sceneHeader>\\n\");\n\t\t\tcount = gf_list_count(iod->ESDescriptors);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_LASERConfig lsrcfg;\n\t\t\t\tGF_ESD *esd = (GF_ESD *)gf_list_get(iod->ESDescriptors, i);\n\t\t\t\tif (!esd || !esd->decoderConfig) continue;\n\t\t\t\tif (esd->decoderConfig->streamType != GF_STREAM_SCENE) continue;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication != 0x09) continue;\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo || !esd->decoderConfig->decoderSpecificInfo->data) continue;\n\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &lsrcfg);\n\t\t\t\tgf_odf_dump_desc((GF_Descriptor*)&lsrcfg, sdump->trace, 1, 1);\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"</saf:sceneHeader>\\n\");\n\t\t}\n#endif\n\t\treturn;\n\t}\n\n\tif (!sdump->X3DDump) {\n\t\t/*setup XMT*/\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<XMT-A xmlns=\\\"urn:mpeg:mpeg4:xmta:schema:2002\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"urn:mpeg:mpeg4:xmta:schema:2002 xmt-a.xsd\\\">\\n\");\n\t\t\tgf_fprintf(sdump->trace, \" <Header>\\n\");\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\tif (root_od) gf_odf_dump_desc(root_od, sdump->trace, 1, 1);\n#endif\n\t\t\tgf_fprintf(sdump->trace, \" </Header>\\n\");\n\t\t\tgf_fprintf(sdump->trace, \" <Body>\\n\");\n\t\t\tif (!root_od) {\n\t\t\t\tgf_fprintf(sdump->trace, \"  <Replace>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (sdump->dump_mode==GF_SM_DUMP_VRML) {\n\t\t\t\tgf_fprintf(sdump->trace, \"#VRML V2.0\\n\");\n\t\t\t} else {\n\t\t\t\t/*dump root OD*/\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\t\tif (root_od) gf_odf_dump_desc(root_od, sdump->trace, 0, 0);\n#endif\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t} else {\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<!DOCTYPE X3D PUBLIC \\\"ISO//Web3D//DTD X3D 3.0//EN\\\" \\\"http://www.web3d.org/specifications/x3d-3.0.dtd\\\">\\n\");\n\t\t\tgf_fprintf(sdump->trace, \"<X3D xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsd:noNamespaceSchemaLocation=\\\"http://www.web3d.org/specifications/x3d-3.0.xsd\\\" version=\\\"3.0\\\">\\n\");\n\t\t\tgf_fprintf(sdump->trace, \"<head>\\n\");\n\t\t\tgf_fprintf(sdump->trace, \"<meta content=\\\"X3D File Converted/Dumped by GPAC Version %s - %s\\\" name=\\\"generator\\\"/>\\n\", gf_gpac_version(), gf_gpac_copyright() );\n\t\t\tgf_fprintf(sdump->trace, \"</head>\\n\");\n\t\t\tgf_fprintf(sdump->trace, \" <Scene>\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"#X3D V3.0\\n\\n\");\n\t\t}\n\t}\n}\n\nstatic void gf_dump_finalize(GF_SceneDumper *sdump, GF_Descriptor *root_od)\n{\n\tif (sdump->dump_mode==GF_SM_DUMP_SVG) return;\n\n\tif (sdump->LSRDump) {\n\t\tgf_fprintf(sdump->trace, \"<saf:endOfSAFSession/>\\n</saf:SAFSession>\\n\");\n\t\treturn;\n\t}\n\tif (!sdump->XMLDump) return;\n\n\tif (!sdump->X3DDump) {\n\t\tif (!root_od) {\n\t\t\tgf_fprintf(sdump->trace, \"  </Replace>\\n\");\n\t\t}\n\t\tgf_fprintf(sdump->trace, \" </Body>\\n\");\n\t\tgf_fprintf(sdump->trace, \"</XMT-A>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \" </Scene>\\n\");\n\t\tgf_fprintf(sdump->trace, \"</X3D>\\n\");\n\t}\n}\n\nstatic Bool gf_dump_vrml_is_def_node(GF_SceneDumper *sdump, GF_Node *node)\n{\n\ts32 i = gf_list_find(sdump->dump_nodes, node);\n\tif (i>=0) return 0;\n\tgf_list_add(sdump->dump_nodes, node);\n\treturn 1;\n}\n\nstatic GF_Node *gf_dump_find_node(GF_SceneDumper *sdump, u32 ID)\n{\n\tGF_Node *ret = gf_sg_find_node(sdump->sg, ID);\n\tif (ret) return ret;\n\treturn NULL;\n}\n\n#define DUMP_IND(sdump)\t\\\n\tif (sdump->trace) {\t\t\\\n\t\tu32 z;\t\\\n\t\tfor (z=0; z<sdump->indent; z++) gf_fprintf(sdump->trace, \"%c\", sdump->ind_char);\t\\\n\t}\n\n\nstatic void StartElement(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tDUMP_IND(sdump);\n\tif (!sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"%s {\\n\", name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"<%s\", name);\n\t}\n}\n\nstatic void EndElementHeader(GF_SceneDumper *sdump, Bool has_sub_el)\n{\n\tif (!sdump->trace) return;\n\tif (sdump->XMLDump) {\n\t\tif (has_sub_el) {\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t}\n\t}\n}\n\nstatic void EndElement(GF_SceneDumper *sdump, const char *name, Bool had_sub_el)\n{\n\tif (!sdump->trace) return;\n\tif (!sdump->XMLDump) {\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t} else {\n\t\tif (had_sub_el) {\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</%s>\\n\", name);\n\t\t}\n\t}\n}\n\nstatic void StartAttribute(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tif (!sdump->XMLDump) {\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"%s \", name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", name);\n\t}\n}\n\nstatic void EndAttribute(GF_SceneDumper *sdump)\n{\n\tif (!sdump->trace) return;\n\tif (!sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t}\n}\n\n\nstatic void StartList(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tDUMP_IND(sdump);\n\tif (!sdump->XMLDump) {\n\t\tif (name)\n\t\t\tgf_fprintf(sdump->trace, \"%s [\\n\", name);\n\t\telse\n\t\t\tgf_fprintf(sdump->trace, \"[\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"<%s>\\n\", name);\n\t}\n}\n\nstatic void EndList(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tDUMP_IND(sdump);\n\tif (!sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"</%s>\\n\", name);\n\t}\n}\n\n\nstatic void scene_dump_utf_string(GF_SceneDumper *sdump, Bool escape_xml, char *str)\n{\n\tu32 len, i;\n\tu16 *uniLine;\n\tif (!str) return;\n\tlen = (u32) strlen(str);\n\tif (!len) return;\n\tuniLine = (u16*)gf_malloc(sizeof(u16) * len*4);\n\tlen = gf_utf8_mbstowcs(uniLine, len, (const char **) &str);\n\tif (len != GF_UTF8_FAIL) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\t//if (uniLine[i] == (u16) '\\\"') gf_fprintf(sdump->trace, \"\\\\\");\n\t\t\tswitch (uniLine[i]) {\n\t\t\tcase '\\'':\n\t\t\t\tif (escape_xml) gf_fprintf(sdump->trace, \"&apos;\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"'\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\"':\n\t\t\t\tif (escape_xml) gf_fprintf(sdump->trace, \"&quot;\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tgf_fprintf(sdump->trace, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tgf_fprintf(sdump->trace, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tgf_fprintf(sdump->trace, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\t\t/* Does nothing : gf_fprintf(sdump->trace, \"\");, fflush instead ?*/\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (uniLine[i]<128) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"%c\", (u8) uniLine[i]);\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"&#%d;\", uniLine[i]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tgf_free(uniLine);\n}\n\n#ifndef GPAC_DISABLE_VRML\n\nstatic void scene_dump_vrml_id(GF_SceneDumper *sdump, GF_Node *node)\n{\n\tu32 id;\n\tconst char *node_name;\n\tif (!sdump->trace) return;\n\t/*FIXME - optimize id/name fetch*/\n\tnode_name = gf_node_get_name_and_id(node, &id);\n\tif (node_name)\n\t\tgf_fprintf(sdump->trace, \"%s\", node_name);\n\telse\n\t\tgf_fprintf(sdump->trace, \"N%d\", id - 1);\n}\n\nstatic Bool scene_dump_vrml_find_route_name(GF_SceneDumper *sdump, u32 ID, const char **outName)\n{\n\tGF_Route *r;\n\tu32 i;\n\tGF_Command *com;\n\tr = gf_sg_route_find(sdump->sg, ID);\n\tif (r) {\n\t\t(*outName) = r->name;\n\t\treturn 1;\n\t}\n\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(sdump->inserted_routes, &i))) {\n\t\tif (com->tag == GF_SG_ROUTE_INSERT) {\n\t\t\tif (com->RouteID==ID) {\n\t\t\t\t(*outName) = com->def_name;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (!sdump->current_com_list) return 0;\n\ti=1;\n\twhile ((com = (GF_Command *)gf_list_enum(sdump->current_com_list, &i))) {\n\t\tif ((com->tag == GF_SG_ROUTE_INSERT) || (com->tag == GF_SG_ROUTE_REPLACE)) {\n\t\t\tif (com->RouteID==ID) {\n\t\t\t\t(*outName) = com->def_name;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else return 0;\n\t}\n\treturn 0;\n}\n\nstatic void scene_dump_vrml_route_id(GF_SceneDumper *sdump, u32 routeID, char *rName)\n{\n\tif (!sdump->trace) return;\n\tif (!rName) scene_dump_vrml_find_route_name(sdump, routeID, (const char **) &rName);\n\n\tif (rName)\n\t\tgf_fprintf(sdump->trace, \"%s\", rName);\n\telse\n\t\tgf_fprintf(sdump->trace, \"R%d\", routeID - 1);\n}\n\n\nstatic void gf_dump_vrml_sffield(GF_SceneDumper *sdump, u32 type, void *ptr, Bool is_mf, GF_Node *node)\n{\n\tswitch (type) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\tgf_fprintf(sdump->trace, \"%s\", * ((SFBool *)ptr) ? \"true\" : \"false\");\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\tgf_fprintf(sdump->trace, \"%d\", * ((SFInt32 *)ptr) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tgf_fprintf(sdump->trace, \"%g\", FIX2FLT( * ((SFFloat *)ptr) ) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFDOUBLE:\n\t\tgf_fprintf(sdump->trace, \"%g\", * ((SFDouble *)ptr) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tgf_fprintf(sdump->trace, \"%g\", * ((SFTime *)ptr) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g\", FIX2FLT( ((SFColor *)ptr)->red ), FIX2FLT( ((SFColor *)ptr)->green ), FIX2FLT( ((SFColor *)ptr)->blue ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g %g\", FIX2FLT( ((SFColorRGBA *)ptr)->red ), FIX2FLT( ((SFColorRGBA *)ptr)->green ), FIX2FLT( ((SFColorRGBA *)ptr)->blue ), FIX2FLT( ((SFColorRGBA *)ptr)->alpha ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tgf_fprintf(sdump->trace, \"%g %g\", FIX2FLT( ((SFVec2f *)ptr)->x ), FIX2FLT( ((SFVec2f *)ptr)->y ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2D:\n\t\tgf_fprintf(sdump->trace, \"%g %g\", ((SFVec2d *)ptr)->x, ((SFVec2d *)ptr)->y);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g\", FIX2FLT( ((SFVec3f *)ptr)->x ), FIX2FLT( ((SFVec3f *)ptr)->y ), FIX2FLT( ((SFVec3f *)ptr)->z ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3D:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g\", ((SFVec3d *)ptr)->x, ((SFVec3d *)ptr)->y, ((SFVec3d *)ptr)->z);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g %g\", FIX2FLT( ((SFRotation *)ptr)->x ), FIX2FLT( ((SFRotation *)ptr)->y ), FIX2FLT( ((SFRotation *)ptr)->z ), FIX2FLT( ((SFRotation *)ptr)->q ) );\n\t\tbreak;\n\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)ptr;\n\t\tif (ar->node) {\n\t\t\tGF_FieldInfo pinfo;\n\t\t\tgf_node_get_field(ar->node, ar->fieldIndex, &pinfo);\n\t\t\tscene_dump_vrml_id(sdump, ar->node);\n\t\t\tgf_fprintf(sdump->trace, \".%s\", pinfo.name);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t{\n\t\tu32 len, i;\n\t\tchar *str;\n\t\tstr = (char*)((SFScript *)ptr)->script_text;\n\t\tif (!str) {\n\t\t\tif (!sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\\\"\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlen = (u32)strlen(str);\n\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"\\\"%s\\\"\", str);\n\t\t}\n\t\telse {\n\t\t\tu16 *uniLine;\n\n\t\t\tuniLine = (u16*)gf_malloc(sizeof(short) * (len + 1));\n\t\t\tlen = gf_utf8_mbstowcs(uniLine, len, (const char **)&str);\n\n\t\t\tif (len != GF_UTF8_FAIL) {\n\t\t\t\tfor (i = 0; i<len; i++) {\n\n\t\t\t\t\tswitch (uniLine[i]) {\n\t\t\t\t\tcase '&':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&amp;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&lt;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&gt;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&apos;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/*FIXME: how the heck can we preserve newlines and spaces of JavaScript in\n\t\t\t\t\t\tan XML attribute in any viewer ? */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (uniLine[i]<128) {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"%c\", (u8)uniLine[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&#%d;\", uniLine[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tgf_free(uniLine);\n\t}\n\t\tDUMP_IND(sdump);\n\t}\n\tbreak;\n\n\tcase GF_SG_VRML_SFSTRING:\n\t{\n\t\tchar *str;\n\t\tif (sdump->XMLDump) {\n\t\t\tif (is_mf) gf_fprintf(sdump->trace, sdump->X3DDump ? \"\\\"\" : \"&quot;\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t\t}\n\t\t/*dump in unicode*/\n\t\tstr = ((SFString *)ptr)->buffer;\n\n\t\tif (node && (gf_node_get_tag(node)==TAG_MPEG4_BitWrapper)) {\n\t\t\tu32 bufsize = 37 + ((M_BitWrapper*)node)->buffer_len * 2 + 3;\n\t\t\tstr = gf_malloc(sizeof(char) * bufsize);\n\t\t\tif (str) {\n\t\t\t\ts32 res;\n\t\t\t\tstrcpy(str, \"data:application/octet-string;base64,\");\n\t\t\t\tres = gf_base64_encode(((M_BitWrapper*)node)->buffer.buffer, ((M_BitWrapper*)node)->buffer_len, str+37, bufsize-37);\n\t\t\t\tif (res<0) {\n\t\t\t\t\tgf_free(str);\n\t\t\t\t\tstr = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tstr[res+37] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (str && str[0]) {\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tscene_dump_utf_string(sdump, 1, str);\n\t\t\t} else if (!strchr(str, '\\\"')) {\n\t\t\t\tgf_fprintf(sdump->trace, \"%s\", str);\n\t\t\t} else {\n\t\t\t\tu32 i, len = (u32)strlen(str);\n\t\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\t\tif (str[i]=='\\\"') gf_fputc('\\\\', sdump->trace);\n\t\t\t\t\tgf_fputc(str[i], sdump->trace);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (node && (gf_node_get_tag(node)==TAG_MPEG4_BitWrapper)) {\n\t\t\tif (str) gf_free(str);\n\t\t}\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (is_mf) gf_fprintf(sdump->trace, sdump->X3DDump ? \"\\\"\" : \"&quot;\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t\t}\n\t}\n\tbreak;\n\n\tcase GF_SG_VRML_SFURL:\n\t\tif (((SFURL *)ptr)->url) {\n#if 0\n\t\t\tu32 len;\n\t\t\tchar *str;\n\t\t\tshort uniLine[5000];\n\t\t\tstr = ((SFURL *)ptr)->url;\n\t\t\tlen = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &str);\n\t\t\tif (len != GF_UTF8_FAIL) {\n\t\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n\t\t\t\tfwprintf(sdump->trace, (unsigned short *) uniLine);\n\t\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n\t\t\t}\n#else\n\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n\t\t\tgf_fprintf(sdump->trace, \"%s\", ((SFURL *)ptr)->url);\n\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n#endif\n\t\t} else {\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"&quot;od://od%d&quot;\", ((SFURL *)ptr)->OD_ID);\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"od:%d\", ((SFURL *)ptr)->OD_ID);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t{\n\t\tu32 i, count;\n\t\tSFImage *img = (SFImage *)ptr;\n\t\tgf_fprintf(sdump->trace, \"%d %d %d\", img->width, img->height, img->numComponents);\n\t\tcount = img->width * img->height * img->numComponents;\n\t\tfor (i=0; i<count; ) {\n\t\t\tswitch (img->numComponents) {\n\t\t\tcase 1:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X\", img->pixels[i]);\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X%02X\", img->pixels[i], img->pixels[i+1]);\n\t\t\t\ti+=2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X%02X%02X\", img->pixels[i], img->pixels[i+1], img->pixels[i+2]);\n\t\t\t\ti+=3;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X%02X%02X%02X\", img->pixels[i], img->pixels[i+1], img->pixels[i+2], img->pixels[i+3]);\n\t\t\t\ti+=4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\n\nstatic void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}\n\nstatic void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tBool needs_field_container;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\t\tEndElementHeader(sdump, 1);\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tneeds_field_container = 0;\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tu32 count, nb_ndt;\n\t\t\tGF_FieldInfo info;\n\t\t\tif (!strcmp(field.name, \"children\")) {\n\t\t\t\tneeds_field_container = 0;\n\t\t\t} else {\n\t\t\t\tnb_ndt = 0;\n\t\t\t\tcount = gf_node_get_field_count(node);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tgf_node_get_field(node, i, &info);\n\t\t\t\t\tif ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;\n\t\t\t\t\tif (info.NDTtype==field.NDTtype) nb_ndt++;\n\t\t\t\t}\n\t\t\t\tneeds_field_container = (nb_ndt>1) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!sdump->X3DDump) {\n\t\t\tif (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";\n\t\t}\n#endif\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert(list);\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;\n\t\tStartElement(sdump, (char *) field.name);\n\t\tEndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t\tif (!gf_list_count(cb->commandList)) {\n\t\t\t/*the arch does not allow for that (we would need a codec and so on, or decompress the command list\n\t\t\tin all cases...)*/\n\t\t\tif (sdump->trace && cb->bufferSize) {\n\t\t\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);\n\t\t}\n\t\tsdump->indent--;\n\t\tEndElement(sdump, (char *) field.name, 1);\n\t}\n\treturn;\n\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tif (sdump->XMLDump) {\n\t\t\tMFAttrRef *ar = (MFAttrRef *)field.far_ptr;\n\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\n\t\t\tfor (i=0; i<ar->count; i++) {\n\t\t\t\tif (ar->vals[i].node) {\n\t\t\t\t\tGF_FieldInfo pinfo;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tgf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<store node=\\\"\");\n\t\t\t\t\tscene_dump_vrml_id(sdump, ar->vals[i].node);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tStartAttribute(sdump, field.name);\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\tEndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tStartAttribute(sdump, field.name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");\n\t\tif (mffield) {\n\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);\n\t\t\t}\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}\n\nstatic const char *GetXMTFieldTypeName(u32 fieldType)\n{\n\tswitch (fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\treturn \"Boolean\";\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn \"Integer\";\n\tcase GF_SG_VRML_SFCOLOR:\n\t\treturn \"Color\";\n\tcase GF_SG_VRML_SFVEC2F:\n\t\treturn \"Vector2\";\n\tcase GF_SG_VRML_SFIMAGE:\n\t\treturn \"Image\";\n\tcase GF_SG_VRML_SFTIME:\n\t\treturn \"Time\";\n\tcase GF_SG_VRML_SFFLOAT:\n\t\treturn \"Float\";\n\tcase GF_SG_VRML_SFVEC3F:\n\t\treturn \"Vector3\";\n\tcase GF_SG_VRML_SFROTATION:\n\t\treturn \"Rotation\";\n\tcase GF_SG_VRML_SFSTRING:\n\t\treturn \"String\";\n\tcase GF_SG_VRML_SFNODE:\n\t\treturn \"Node\";\n\tcase GF_SG_VRML_MFBOOL:\n\t\treturn \"Booleans\";\n\tcase GF_SG_VRML_MFINT32:\n\t\treturn \"Integers\";\n\tcase GF_SG_VRML_MFCOLOR:\n\t\treturn \"Colors\";\n\tcase GF_SG_VRML_MFVEC2F:\n\t\treturn \"Vector2Array\";\n\tcase GF_SG_VRML_MFIMAGE:\n\t\treturn \"Images\";\n\tcase GF_SG_VRML_MFTIME:\n\t\treturn \"Times\";\n\tcase GF_SG_VRML_MFFLOAT:\n\t\treturn \"Floats\";\n\tcase GF_SG_VRML_MFVEC3F:\n\t\treturn \"Vector3Array\";\n\tcase GF_SG_VRML_MFROTATION:\n\t\treturn \"Rotations\";\n\tcase GF_SG_VRML_MFSTRING:\n\t\treturn \"Strings\";\n\tcase GF_SG_VRML_MFNODE:\n\t\treturn \"Nodes\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\nstatic const char *GetXMTFieldTypeValueName(u32 fieldType)\n{\n\tswitch (fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\treturn \"booleanValue\";\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn \"intValue\";\n\tcase GF_SG_VRML_SFCOLOR:\n\t\treturn \"colorValue\";\n\tcase GF_SG_VRML_SFVEC2F:\n\t\treturn \"vector2Value\";\n\tcase GF_SG_VRML_SFIMAGE:\n\t\treturn \"imageValue\";\n\tcase GF_SG_VRML_SFTIME:\n\t\treturn \"timeValue\";\n\tcase GF_SG_VRML_SFFLOAT:\n\t\treturn \"floatValue\";\n\tcase GF_SG_VRML_SFVEC3F:\n\t\treturn \"vector3Value\";\n\tcase GF_SG_VRML_SFROTATION:\n\t\treturn \"rotationValue\";\n\tcase GF_SG_VRML_SFSTRING:\n\t\treturn \"stringValue\";\n\tcase GF_SG_VRML_MFBOOL:\n\t\treturn \"booleanArrayValue\";\n\tcase GF_SG_VRML_MFINT32:\n\t\treturn \"intArrayValue\";\n\tcase GF_SG_VRML_MFCOLOR:\n\t\treturn \"colorArrayValue\";\n\tcase GF_SG_VRML_MFVEC2F:\n\t\treturn \"vector2ArrayValue\";\n\tcase GF_SG_VRML_MFIMAGE:\n\t\treturn \"imageArrayValue\";\n\tcase GF_SG_VRML_MFTIME:\n\t\treturn \"timeArrayValue\";\n\tcase GF_SG_VRML_MFFLOAT:\n\t\treturn \"floatArrayValue\";\n\tcase GF_SG_VRML_MFVEC3F:\n\t\treturn \"vector3ArrayValue\";\n\tcase GF_SG_VRML_MFROTATION:\n\t\treturn \"rotationArrayValue\";\n\tcase GF_SG_VRML_MFSTRING:\n\t\treturn \"stringArrayValue\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n/*field dumping for proto declaration and Script*/\nstatic void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tif (!sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\tsdump->indent++;\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"<node>\");\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</node>\");\n\t\t\t\t\t\tsdump->indent--;\n\t\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (field.far_ptr) {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tif (field.far_ptr)\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t} else if (field.far_ptr) {\n\t\t\t\t\tgf_dump_vrml_simple_field(sdump, field, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t} else if (field.far_ptr) {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" [\");\n\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\twhile (l) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, l->node, 1, NULL);\n\t\t\t\t\t\tl = l->next;\n\t\t\t\t\t}\n\t\t\t\t\tsdump->indent--;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/*field dumping for proto instance*/\nstatic void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\tsdump->indent++;\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<node>\");\n\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</node>\");\n\t\t\tsdump->indent--;\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t}\n\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t}\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\twhile (list) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\tlist = list->next;\n\t\t\t\t}\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tif (mffield) {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic GF_Route *gf_dump_vrml_get_IS(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(sdump->current_proto->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif ((r->ToNode==node) && (r->ToField.fieldIndex==field->fieldIndex)) return r;\n\t}\n\tif (!node || !node->sgprivate->interact || !node->sgprivate->interact->routes) return NULL;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(node->sgprivate->interact->routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromField.fieldIndex == field->fieldIndex) return r;\n\t}\n\treturn NULL;\n}\n\nstatic void gf_dump_vrml_IS_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool isScript, Bool skip_is)\n{\n\tGF_FieldInfo pfield;\n\n\tGF_Route *r = gf_dump_vrml_get_IS(sdump, node, &field);\n\tif (r->FromNode) {\n\t\tpfield.fieldIndex = r->ToField.fieldIndex;\n\t\tgf_sg_proto_get_field(sdump->current_proto, NULL, &pfield);\n\t} else {\n\t\tpfield.fieldIndex = r->FromField.fieldIndex;\n\t\tgf_sg_proto_get_field(sdump->current_proto, NULL, &pfield);\n\t}\n\n\tif (!sdump->XMLDump) {\n\t\tDUMP_IND(sdump);\n\t\tif (isScript) gf_fprintf(sdump->trace, \"%s %s \", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType));\n\t\tgf_fprintf(sdump->trace, \"%s IS %s\\n\", field.name, pfield.name);\n\t} else {\n\t\tif (!skip_is) {\n\t\t\tStartElement(sdump, \"IS\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"<connect nodeField=\\\"%s\\\" protoField=\\\"%s\\\"/>\\n\", field.name, pfield.name);\n\t\tif (!skip_is) {\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"IS\", 1);\n\t\t}\n\t}\n}\n\nstatic Bool scene_dump_vrml_can_dump(GF_SceneDumper *sdump, GF_Node *node)\n{\n#ifndef GPAC_DISABLE_VRML\n\tu32 tag;\n\n\tif (node->sgprivate->tag==TAG_ProtoNode) return 1;\n\n\tif (sdump->X3DDump || (sdump->dump_mode==GF_SM_DUMP_VRML)) {\n\t\tif (node->sgprivate->tag>=GF_NODE_RANGE_FIRST_X3D) return 1;\n\t\tif (node->sgprivate->tag==TAG_MPEG4_Rectangle) return 1;\n\t\tif (node->sgprivate->tag==TAG_MPEG4_Circle) return 1;\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(gf_node_get_class_name(node));\n\t\treturn tag ? 1 : 0;\n#else\n\t\treturn 0;\n#endif\n\t} else {\n\t\tif (node->sgprivate->tag<=GF_NODE_RANGE_LAST_MPEG4) return 1;\n#ifndef GPAC_DISABLE_X3D\n\t\tif (node->sgprivate->tag==TAG_X3D_Rectangle2D) return 1;\n\t\tif (node->sgprivate->tag==TAG_X3D_Circle2D) return 1;\n#endif\n\t\ttag = gf_node_mpeg4_type_by_class_name(gf_node_get_class_name(node));\n\t\treturn tag ? 1 : 0;\n\t}\n#else\n\treturn 1;\n#endif\n}\n\nstatic void gf_dump_vrml_node(GF_SceneDumper *sdump, GF_Node *node, Bool in_list, char *fieldContainer)\n{\n\tu32 i, count, to_dump, sub_el, ID;\n\tu32 *def_fields;\n\tBool isDEF, isScript, isProto, hasISed;\n\tchar *name;\n\tGF_Node *base;\n\tGF_FieldInfo field, base_field;\n\n\tif (!node) {\n\t\tgf_fprintf(sdump->trace, \"NULL\");\n\t\treturn;\n\t}\n\n\t/*this dumper works only for VRML like graphs*/\n\tif (node->sgprivate->tag>GF_NODE_RANGE_LAST_X3D) return;\n\n\tif (!scene_dump_vrml_can_dump(sdump, node)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[Scene Dump] node %s not part of %s standard - removing\\n\", gf_node_get_class_name(node), sdump->X3DDump ? \"X3D\" : (sdump->dump_mode==GF_SM_DUMP_VRML) ? \"VRML\" : \"MPEG4\"));\n\t\tif (!in_list) gf_fprintf(sdump->trace, \"NULL\");\n\t\treturn;\n\t}\n\n\t/*convert whatever possible*/\n\tname = (char*)gf_node_get_class_name(node);\n#ifndef GPAC_DISABLE_VRML\n\tif (sdump->X3DDump) {\n\t\tif (node->sgprivate->tag == TAG_MPEG4_Circle) name = \"Circle2D\";\n\t\telse if (node->sgprivate->tag == TAG_MPEG4_Rectangle) name = \"Rectangle2D\";\n#ifndef GPAC_DISABLE_X3D\n\t} else {\n\t\tif (node->sgprivate->tag == TAG_X3D_Circle2D) name = \"Circle\";\n\t\telse if (node->sgprivate->tag == TAG_X3D_Rectangle2D) name = \"Rectangle\";\n#endif\n\t}\n#endif\n\n\n\n\tisProto = (gf_node_get_tag(node) == TAG_ProtoNode) ? 1 : 0;\n\tID = gf_node_get_id(node);\n\tisDEF = 0;\n\tif (ID) {\n\t\tisDEF = gf_dump_vrml_is_def_node(sdump, node);\n\t\tif (!isDEF) {\n\t\t\tif (!sdump->XMLDump) {\n\t\t\t\tif (in_list) DUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"USE \");\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tif (in_list) gf_fprintf(sdump->trace, \"\\n\");\n\t\t\t} else {\n\t\t\t\tif (isProto) {\n\t\t\t\t\tStartElement(sdump, \"ProtoInstance\");\n\t\t\t\t\tStartAttribute(sdump, \"name\");\n\t\t\t\t\tgf_fprintf(sdump->trace, \"%s\", name);\n\t\t\t\t\tEndAttribute(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tStartElement(sdump, name);\n\t\t\t\t}\n\t\t\t\tStartAttribute(sdump, \"USE\");\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tEndElementHeader(sdump, 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*get all fields*/\n\tcount = gf_node_get_field_count(node);\n\tdef_fields = (u32*)gf_malloc(sizeof(u32) * count);\n\n\tbase = NULL;\n\tswitch (gf_node_get_tag(node)) {\n#ifndef GPAC_DISABLE_VRML\n#ifndef GPAC_DISABLE_X3D\n\tcase TAG_X3D_Script:\n#endif\n\tcase TAG_MPEG4_Script:\n\t\tisScript = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tisScript = 0;\n\t\tbreak;\n\t}\n\n\n\tif (!isScript) {\n\t\tif (isProto) {\n\t\t\tbase = gf_sg_proto_create_instance(node->sgprivate->scenegraph, ((GF_ProtoInstance *)node)->proto_interface);\n\t\t} else {\n\t\t\tbase = gf_node_new(node->sgprivate->scenegraph, node->sgprivate->tag);\n\t\t}\n\t}\n\n\tif (base) gf_node_register(base, NULL);\n\n\thasISed = 0;\n\tto_dump = sub_el = 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (isScript) {\n\t\t\t/*dyn script fields are complex types*/\n\t\t\tdef_fields[i] = (i>2) ? 2 : 1;\n\t\t} else {\n\t\t\tdef_fields[i] = 0;\n\t\t}\n\n\t\tgf_node_get_field(node, i, &field);\n\n\t\tif (sdump->current_proto) {\n\t\t\tif (gf_dump_vrml_get_IS(sdump, node, &field) != NULL) {\n\t\t\t\tdef_fields[i] = 3;\n\t\t\t\tif ((field.fieldType == GF_SG_VRML_SFNODE) || (field.fieldType == GF_SG_VRML_MFNODE))\n\t\t\t\t\tdef_fields[i] = sdump->XMLDump ? 4 : 3;\n\t\t\t\t/*in XMT the ISed is not an attribute*/\n\t\t\t\tif (sdump->XMLDump) sub_el++;\n\t\t\t\tto_dump++;\n\t\t\t\thasISed = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!isScript && ((field.eventType == GF_SG_EVENT_IN) || (field.eventType == GF_SG_EVENT_OUT)) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*proto instance in XMT lists all fields as elements*/\n\t\tif (sdump->XMLDump && isProto) {\n\t\t\tdef_fields[i] = 2;\n\t\t\tto_dump++;\n\t\t\tsub_el++;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (field.fieldType) {\n\t\tcase GF_SG_VRML_SFNODE:\n\t\t\tif (* (GF_Node **) field.far_ptr) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tif (* (GF_ChildNodeItem**) field.far_ptr) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\t{\n\t\t\tSFCommandBuffer *p = (SFCommandBuffer *)field.far_ptr;\n\t\t\tif (p->bufferSize || gf_list_count(p->commandList)) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase GF_SG_VRML_MFATTRREF:\n\t\t{\n\t\t\tMFAttrRef *p = (MFAttrRef*)field.far_ptr;\n\t\t\tif (p->count) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tif (isScript) {\n\t\t\t\tto_dump++;\n\t\t\t} else {\n\t\t\t\tgf_node_get_field(base, i, &base_field);\n\t\t\t\tif (!gf_sg_vrml_field_equal(base_field.far_ptr, field.far_ptr, field.fieldType)) {\n\t\t\t\t\tdef_fields[i] = 1;\n\t\t\t\t\tto_dump++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (base) gf_node_unregister(base, NULL);\n\n\tif (!to_dump) {\n\t\tif (in_list) DUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tif (isDEF) {\n\t\t\t\tgf_fprintf(sdump->trace, \"DEF \");\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"%s {}\\n\", name);\n\t\t} else {\n\t\t\tif (isDEF) {\n\t\t\t\tif (isProto) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<ProtoInstance name=\\\"%s\\\" DEF=\\\"\", name);\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<%s DEF=\\\"\", name);\n\t\t\t\t}\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t} else {\n\t\t\t\tif (isProto) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<ProtoInstance name=\\\"%s\\\"/>\\n\", name);\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<%s/>\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_free(def_fields);\n\t\treturn;\n\t}\n\n\tif (!sdump->XMLDump) {\n\t\tif (in_list) DUMP_IND(sdump);\n\t\tif (isDEF) {\n\t\t\tgf_fprintf(sdump->trace, \"DEF \");\n\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t}\n\t\tgf_fprintf(sdump->trace, \"%s {\\n\", name);\n\t} else {\n\t\tif (isProto) {\n\t\t\tStartElement(sdump, \"ProtoInstance\");\n\t\t\tStartAttribute(sdump, \"name\");\n\t\t\tgf_fprintf(sdump->trace, \"%s\", name);\n\t\t\tEndAttribute(sdump);\n\t\t} else {\n\t\t\tStartElement(sdump, name);\n\t\t}\n\t\tif (isDEF) {\n\t\t\tStartAttribute(sdump, \"DEF\");\n\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n\n\tsdump->indent ++;\n\tfor (i=0; i<count; i++) {\n\t\tswitch (def_fields[i]) {\n\t\t/*regular field*/\n\t\tcase 1:\n\t\t\tgf_node_get_field(node, i, &field);\n\t\t\tif (!isScript) {\n\t\t\t\tgf_dump_vrml_field(sdump, node, field);\n\t\t\t}\n\t\t\t/*special script dump case, static fields except url*/\n\t\t\telse if (i==1 || i==2) {\n\t\t\t\tif (*((SFBool *)field.far_ptr)) gf_dump_vrml_field(sdump, node, field);\n\t\t\t}\n\t\t\t/*in bt first dump fields - in XMT first dump url*/\n\t\t\telse if (i && !sdump->XMLDump) {\n\t\t\t\tgf_dump_vrml_dyn_field(sdump, node, field, 0);\n\t\t\t} else if (!i && sdump->XMLDump) {\n\t\t\t\tgf_dump_vrml_field(sdump, node, field);\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IS field*/\n\t\tcase 3:\n\t\t\tif (sdump->XMLDump) break;\n\t\t\tgf_node_get_field(node, i, &field);\n\t\t\tgf_dump_vrml_IS_field(sdump, node, field, isScript, 0);\n\t\t\tdef_fields[i] = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fieldContainer) gf_fprintf(sdump->trace, \" fieldContainer=\\\"%s\\\"\", fieldContainer);\n\n\tif (isScript) sub_el = 1;\n\tEndElementHeader(sdump, sub_el ? 1 : 0);\n\n\tif (sub_el) {\n\t\t/*dump all normal IS elements for XMT*/\n\t\tif (hasISed && sdump->XMLDump) {\n\t\t\tStartElement(sdump, \"IS\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (def_fields[i]==3) {\n\t\t\t\tgf_node_get_field(node, i, &field);\n\t\t\t\tgf_dump_vrml_IS_field(sdump, node, field, isScript, 1);\n\t\t\t}\n\t\t}\n\t\tif (hasISed && sdump->XMLDump) {\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"IS\", 1);\n\t\t}\n\t\t/*dump all sub elements and complex IS*/\n\t\tfor (i=0; i<count; i++) {\n\t\t\tswitch (def_fields[i]) {\n\t\t\tcase 2:\n\t\t\t\tgf_node_get_field(node, i, &field);\n\t\t\t\tif (!isScript) {\n\t\t\t\t\tif (isProto && sdump->XMLDump) {\n\t\t\t\t\t\tgf_dump_vrml_proto_field(sdump, node, field);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_dump_vrml_field(sdump, node, field);\n\t\t\t\t\t}\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_X3D\n\t\t\t\t\t/*X3D script metadata, NOT DYN*/\n\t\t\t\t\tif ((i==3) && (node->sgprivate->tag==TAG_X3D_Script) ) {\n\t\t\t\t\t\tif (*((GF_Node **)field.far_ptr)) gf_dump_vrml_field(sdump, node, field);\n\t\t\t\t\t} else\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tgf_dump_vrml_dyn_field(sdump, node, field, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tgf_node_get_field(node, i, &field);\n\t\t\t\tgf_dump_vrml_IS_field(sdump, node, field, isScript, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*finally dump script - XMT dumping is broken!!*/\n\tif (isScript && !sdump->XMLDump) {\n\t\tgf_node_get_field(node, 0, &field);\n\t\tgf_dump_vrml_field(sdump, node, field);\n\t}\n\n\tsdump->indent --;\n\tif (!sdump->XMLDump && !in_list) {\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\");\n\t} else {\n\t\tEndElement(sdump, isProto ? \"ProtoInstance\" : name, sub_el);\n\t}\n\tgf_free(def_fields);\n}\n\n\nstatic GF_Err DumpMultipleIndexedReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tu32 i;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tgf_node_get_field(com->node, inf->fieldIndex, &field);\n\tfield.fieldType = inf->fieldType;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace extended=\\\"indices\\\" atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\">\\n\", field.name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"MULTIPLEINDREPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s [\\n\", field.name);\n\t}\n\tsdump->indent++;\n\ti=0;\n\twhile ((inf = (GF_CommandField *) gf_list_enum(com->command_fields, &i))) {\n\t\tfield.far_ptr = inf->field_ptr;\n\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<repValue position=\\\"%d\\\" \", inf->pos);\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"%d BY \", inf->pos);\n\t\t}\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"/>\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t}\n\tsdump->indent--;\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpMultipleReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tu32 i;\n\tGF_FieldInfo info;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace extended=\\\"fields\\\" atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\n\t\tsdump->indent++;\n\t\ti=0;\n\t\twhile ((inf = (GF_CommandField *) gf_list_enum(com->command_fields, &i))) {\n\t\t\tgf_node_get_field(com->node, inf->fieldIndex, &info);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (gf_sg_vrml_get_sf_type(info.fieldType) != GF_SG_VRML_SFNODE) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<repField atField=\\\"%s\\\" \", info.name);\n\t\t\t\tgf_dump_vrml_simple_field(sdump, info, com->node);\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<repField>\");\n\t\t\t\tgf_dump_vrml_field(sdump, com->node, info);\n\t\t\t\tgf_fprintf(sdump->trace, \"</repField>\\n\");\n\t\t\t}\n\t\t}\n\t\tsdump->indent--;\n\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"MULTIPLEREPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \" {\\n\");\n\t\tsdump->indent++;\n\t\ti=0;\n\t\twhile ((inf = (GF_CommandField *) gf_list_enum(com->command_fields, &i))) {\n\t\t\tgf_node_get_field(com->node, inf->fieldIndex, &info);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\tgf_dump_vrml_field(sdump, com->node, info);\n\t\t}\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpGlobalQP(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace extended=\\\"globalQuant\\\">\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"GLOBALQP \");\n\t}\n\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Replace>\\n\");\n\telse gf_fprintf(sdump->trace, \"\\n\");\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpNodeInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_CommandField *inf;\n\tchar posname[20];\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tswitch (inf->pos) {\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tcase -1:\n\t\tstrcpy(posname, \"END\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Insert atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" position=\\\"%s\\\">\", posname);\n\t} else {\n\t\tif (inf->pos==-1) {\n\t\t\tgf_fprintf(sdump->trace, \"APPEND TO \");\n\t\t}\n\t\telse gf_fprintf(sdump->trace, \"INSERT AT \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".children\");\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \" \");\n\t}\n\n\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Insert>\");\n\tgf_fprintf(sdump->trace, \"\\n\");\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpRouteInsert(GF_SceneDumper *sdump, GF_Command *com, Bool is_scene_replace)\n{\n\tGF_Route r;\n\n\tmemset(&r, 0, sizeof(GF_Route));\n\tr.ID = com->RouteID;\n\tr.name = com->def_name;\n\tr.FromNode = gf_dump_find_node(sdump, com->fromNodeID);\n\tr.FromField.fieldIndex = com->fromFieldIndex;\n\tr.ToNode = gf_dump_find_node(sdump, com->toNodeID);\n\tr.ToField.fieldIndex = com->toFieldIndex;\n\n\tgf_list_add(sdump->inserted_routes, com);\n\n\tif (is_scene_replace) {\n\t\tgf_dump_vrml_route(sdump, &r, 0);\n\t} else {\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<Insert>\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"INSERT \");\n\t\t}\n\t\tgf_dump_vrml_route(sdump, &r, 2);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Insert>\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpIndexInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_Err e;\n\tGF_FieldInfo field, sffield;\n\tGF_CommandField *inf;\n\tchar posname[20];\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tswitch (inf->pos) {\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tcase -1:\n\t\tstrcpy(posname, \"END\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Insert atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" position=\\\"%s\\\"\", field.name, posname);\n\t} else {\n\t\tif (inf->pos==-1) {\n\t\t\tgf_fprintf(sdump->trace, \"APPEND TO \");\n\t\t}\n\t\telse gf_fprintf(sdump->trace, \"INSERT AT \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \" \");\n\t}\n\n\tmemcpy(&sffield, &field, sizeof(GF_FieldInfo));\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\tif (field.fieldType==GF_SG_VRML_MFNODE) {\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\\n\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Insert>\");\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t} else {\n\t\tsffield.far_ptr = inf->field_ptr;\n\t\tgf_dump_vrml_simple_field(sdump, sffield, com->node);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"/>\");\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn e;\n}\n\nstatic GF_Err DumpIndexDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar posname[20];\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tswitch (inf->pos) {\n\tcase -1:\n\t\tstrcpy(posname, sdump->XMLDump ? \"END\" : \"LAST\");\n\t\tbreak;\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\tgf_node_get_field(com->node, inf->fieldIndex, &field);\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Delete atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" position=\\\"%s\\\"/>\", field.name, posname);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"DELETE \");\n\t\tif (inf->pos==-1) gf_fprintf(sdump->trace, \"%s \", posname);\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpNodeDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tif (com->tag==GF_SG_NODE_DELETE_EX) {\n\t\t\tgf_fprintf(sdump->trace, \"<Delete extended=\\\"deleteOrder\\\" atNode=\\\"\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"<Delete atNode=\\\"\");\n\t\t}\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t} else {\n\t\tif (com->tag==GF_SG_NODE_DELETE_EX) gf_fprintf(sdump->trace, \"X\");\n\t\tgf_fprintf(sdump->trace, \"DELETE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpRouteDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Delete atRoute=\\\"\");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, com->def_name);\n\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"DELETE ROUTE \");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, com->def_name);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\n\nstatic GF_Err DumpNodeReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\">\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpFieldReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_Err e;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" \", field.name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s BY \", field.name);\n\t}\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Replace>\");\n\t\telse gf_fprintf(sdump->trace, \"\\n\");\n\t\tbreak;\n\tcase GF_SG_VRML_MFNODE:\n\t{\n\t\tGF_ChildNodeItem *tmp;\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \">\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \" [\\n\");\n\t\t}\n\t\tsdump->indent++;\n\t\ttmp = inf->node_list;\n\t\twhile (tmp) {\n\t\t\tgf_dump_vrml_node(sdump, tmp->node, 1, NULL);\n\t\t\ttmp = tmp->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"</Replace>\");\n\t\t} else {\n\t\t\tEndList(sdump, NULL);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\tif (sdump->XMLDump) {\n\t\t\tSFCommandBuffer *cb = (SFCommandBuffer*)inf->field_ptr;\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent+1, 0);\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t\t} else {\n\t\t\tSFCommandBuffer *cb = (SFCommandBuffer*)inf->field_ptr;\n\t\t\tgf_fprintf(sdump->trace, \" {\\n\");\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent+1, 0);\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfield.far_ptr = inf->field_ptr;\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"/>\");\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn e;\n}\n\n\nstatic GF_Err DumpIndexReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar posname[20];\n\tGF_Err e;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tswitch (inf->pos) {\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tcase -1:\n\t\tstrcpy(posname, sdump->XMLDump ? \"END\" : \"LAST\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" position=\\\"%s\\\"\", field.name, posname);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE \");\n\t\tif (inf->pos==-1) gf_fprintf(sdump->trace, \"%s \", posname);\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t}\n\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\\n\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, (sdump->XMLDump) ? \"</Replace>\\n\" : \"\\n\");\n\t} else {\n\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tfield.far_ptr = inf->field_ptr;\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? \"/>\\n\" : \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpXReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar posname[20];\n\tGF_Err e;\n\tGF_FieldInfo field, idxField;\n\tGF_Node *toNode, *target;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\tif (e) return e;\n\n\ttoNode = target = NULL;\n\t/*indexed replacement with index given by other node field*/\n\tif (com->toNodeID) {\n\t\ttoNode = gf_sg_find_node(com->in_scene, com->toNodeID);\n\t\tif (!toNode) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = gf_node_get_field(toNode, com->toFieldIndex, &idxField);\n\t\tif (e) return e;\n\t}\n\telse {\n\t\t/*indexed replacement */\n\t\tif (inf->pos>=-1) {\n\t\t\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tswitch (inf->pos) {\n\t\t\tcase 0:\n\t\t\t\tstrcpy(posname, \"BEGIN\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tstrcpy(posname, sdump->XMLDump ? \"END\" : \"LAST\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(posname, \"%d\", inf->pos);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\t}\n\t}\n\tfield.far_ptr = inf->field_ptr;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\"\", field.name);\n\n\t\tif (toNode) {\n\t\t\tgf_fprintf(sdump->trace, \" atIndexNode=\\\"\");\n\t\t\tscene_dump_vrml_id(sdump, toNode);\n\t\t\tgf_fprintf(sdump->trace, \"\\\" atIndexField=\\\"%s\\\"\", idxField.name);\n\n\t\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\t}\n\t\tif (com->ChildNodeTag) {\n\t\t\tGF_FieldInfo cfield;\n\t\t\tGF_Node *cnode;\n\n\t\t\tif (com->ChildNodeTag>0) {\n\t\t\t\tcnode = gf_node_new(com->in_scene, com->ChildNodeTag);\n\t\t\t} else {\n\t\t\t\tGF_Proto *proto = gf_sg_find_proto(com->in_scene, -com->ChildNodeTag , NULL);\n\t\t\t\tif (!proto) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tcnode = gf_sg_proto_create_instance(com->in_scene, proto);\n\t\t\t}\n\t\t\tif (!cnode) return GF_SG_UNKNOWN_NODE;\n\t\t\tgf_node_register(cnode, NULL);\n\t\t\tgf_node_get_field(cnode, com->child_field, &cfield);\n\t\t\tgf_fprintf(sdump->trace, \" atChildField=\\\"%s\\\"\", cfield.name);\n\t\t\tgf_node_unregister(cnode, NULL);\n\n\t\t\tfield.fieldType = cfield.fieldType;\n\t\t}\n\n\t\tif (com->fromNodeID) {\n\t\t\ttarget = gf_sg_find_node(com->in_scene, com->fromNodeID);\n\t\t\tif (!target) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\te = gf_node_get_field(target, com->fromFieldIndex, &idxField);\n\t\t\tif (e) return e;\n\n\t\t\tgf_fprintf(sdump->trace, \" fromNode=\\\"\");\n\t\t\tscene_dump_vrml_id(sdump, target);\n\t\t\tgf_fprintf(sdump->trace, \"\\\" fromField=\\\"%s\\\">\\n\", idxField.name);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tif (inf->pos>=-1) gf_fprintf(sdump->trace, \" position=\\\"%s\\\"\", posname);\n\t\t}\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"XREPLACE \");\n\t\tif (inf->pos==-1) gf_fprintf(sdump->trace, \"%s \", posname);\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (toNode) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t\tscene_dump_vrml_id(sdump, toNode);\n\t\t\tgf_fprintf(sdump->trace, \".%s]\", idxField.name);\n\t\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\t}\n\t\telse if (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tif (com->ChildNodeTag) {\n\t\t\tGF_FieldInfo cfield;\n\t\t\tGF_Node *cnode;\n\t\t\tif (com->ChildNodeTag>0) {\n\t\t\t\tcnode = gf_node_new(com->in_scene, com->ChildNodeTag);\n\t\t\t} else {\n\t\t\t\tGF_Proto *proto = gf_sg_find_proto(com->in_scene, -com->ChildNodeTag , NULL);\n\t\t\t\tif (!proto) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tcnode = gf_sg_proto_create_instance(com->in_scene, proto);\n\t\t\t}\n\t\t\tif (!cnode) return GF_SG_UNKNOWN_NODE;\n\t\t\tgf_node_register(cnode, NULL);\n\t\t\tgf_node_get_field(cnode, com->child_field, &cfield);\n\t\t\tgf_fprintf(sdump->trace, \".%s\", cfield.name);\n\t\t\tgf_node_unregister(cnode, NULL);\n\t\t\tfield.fieldType = cfield.fieldType;\n\t\t}\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t}\n\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\\n\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, (sdump->XMLDump) ? \"</Replace>\\n\" : \"\\n\");\n\t} else {\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? \"/>\\n\" : \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpRouteReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tconst char *name;\n\tGF_Route r2;\n\n\tif (!scene_dump_vrml_find_route_name(sdump, com->RouteID, &name)) return GF_BAD_PARAM;\n\n\tmemset(&r2, 0, sizeof(GF_Route));\n\tr2.FromNode = gf_dump_find_node(sdump, com->fromNodeID);\n\tr2.FromField.fieldIndex = com->fromFieldIndex;\n\tr2.ToNode = gf_dump_find_node(sdump, com->toNodeID);\n\tr2.ToField.fieldIndex = com->toFieldIndex;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atRoute=\\\"\");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, (char *) name);\n\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE ROUTE \");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, (char *) name);\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t}\n\tgf_dump_vrml_route(sdump, &r2, 1);\n\tif (sdump->XMLDump ) gf_fprintf(sdump->trace, \"</Replace>\");\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_dump_vrml_route(GF_SceneDumper *sdump, GF_Route *r, u32 dump_type)\n{\n\tchar toNodeBuf[100], fromNodeBuf[100], *to_node_p, *from_node_p;\n\tconst char *node_name;\n\tu32 id;\n\tif (!r->is_setup) {\n\t\tgf_node_get_field(r->FromNode, r->FromField.fieldIndex, &r->FromField);\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &r->ToField);\n\t\tr->is_setup = 1;\n\t}\n\tif (!r->FromNode || !r->ToNode) return GF_BAD_PARAM;\n\n\tif (sdump->XMLDump || !dump_type) DUMP_IND(sdump);\n\n\tto_node_p = toNodeBuf;\n\tfrom_node_p = fromNodeBuf;\n\tnode_name = gf_node_get_name_and_id(r->FromNode, &id);\n\tif (node_name) {\n\t\tconst char *to_name;\n\t\tfrom_node_p = (char *)node_name;\n\t\tto_name = gf_node_get_name(r->ToNode);\n\t\tif (to_name) {\n\t\t\tto_node_p = (char *) to_name;\n\t\t} else {\n\t\t\tid = gf_node_get_id(r->ToNode);\n\t\t\tsprintf(toNodeBuf, \"node_%d\", id);\n\t\t}\n\t} else {\n\t\tsprintf(fromNodeBuf, \"N%d\", id-1);\n\t\tsprintf(toNodeBuf, \"N%d\", gf_node_get_id(r->ToNode) - 1);\n\t}\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<ROUTE\");\n\t\tif (r->ID) {\n\t\t\tStartAttribute(sdump, \"DEF\");\n\t\t\tscene_dump_vrml_route_id(sdump, r->ID, r->name);\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\tgf_fprintf(sdump->trace, \" fromNode=\\\"%s\\\" fromField=\\\"%s\\\" toNode=\\\"%s\\\" toField=\\\"%s\\\"/>\\n\", from_node_p, r->FromField.name, to_node_p, r->ToField.name);\n\t} else {\n\t\tif (dump_type==2) gf_fprintf(sdump->trace, \"ROUTE \");\n\t\tif (r->ID) {\n\t\t\tgf_fprintf(sdump->trace, \"DEF \");\n\t\t\tscene_dump_vrml_route_id(sdump, r->ID, r->name);\n\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t}\n\t\tif (dump_type==1) {\n\t\t\tgf_fprintf(sdump->trace, \"%s.%s TO %s.%s\\n\", from_node_p, r->FromField.name, to_node_p, r->ToField.name);\n\t\t} else {\n\t\t\tif (dump_type!=2) gf_fprintf(sdump->trace, \"ROUTE \");\n\t\t\tgf_fprintf(sdump->trace, \"%s.%s TO %s.%s\\n\", from_node_p, r->FromField.name, to_node_p, r->ToField.name);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpProtos(GF_SceneDumper *sdump, GF_List *protoList)\n{\n#ifdef GPAC_DISABLE_VRML\n\treturn GF_OK;\n#else\n\tu32 i, j, count;\n\tGF_FieldInfo field;\n\tGF_Err e;\n\tGF_SceneGraph *prev_sg;\n\tGF_Proto *proto, *prev_proto;\n\n\tprev_proto = sdump->current_proto;\n\n\ti=0;\n\twhile ((proto = (GF_Proto*)gf_list_enum(protoList, &i))) {\n\t\tsdump->current_proto = proto;\n\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, proto->ExternProto.count ? \"EXTERNPROTO \" : \"PROTO \");\n\t\t\tgf_fprintf(sdump->trace, \"%s [\\n\", proto->Name);\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"<ProtoDeclare name=\\\"%s\\\" protoID=\\\"%d\\\"\", proto->Name, proto->ID);\n\t\t\tif (proto->ExternProto.count) {\n\t\t\t\tgf_fprintf(sdump->trace, \" locations=\\\"\");\n\t\t\t\tgf_dump_vrml_sffield(sdump, GF_SG_VRML_SFURL, &proto->ExternProto.vals[0], 0, NULL);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t}\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) gf_fprintf(sdump->trace, \"<ProtoInterface>\");\n\n\t\tsdump->indent++;\n\t\tcount = gf_list_count(proto->proto_fields);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ProtoFieldInterface *pf = (GF_ProtoFieldInterface *)gf_list_get(proto->proto_fields, j);\n\t\t\tfield.fieldIndex = pf->ALL_index;\n\t\t\tfield.eventType = pf->EventType;\n\t\t\tfield.far_ptr = pf->def_value;\n\t\t\tfield.fieldType = pf->FieldType;\n\t\t\tfield.name = pf->FieldName;\n\t\t\tfield.NDTtype = NDT_SFWorldNode;\n\t\t\tfield.on_event_in = NULL;\n\n\t\t\tgf_dump_vrml_dyn_field(sdump, NULL, field, pf->QP_Type ? 1 : 0);\n\n\t\t\tif (!pf->QP_Type) continue;\n\n\t\t\t/*dump interface coding - BT/TXT extensions, not supported by any other tool*/\n\t\t\tsdump->indent++;\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tconst char *quant_catname = \"unknown\";\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t\tswitch (pf->QP_Type) {\n\t\t\t\tcase QC_3DPOS: quant_catname = \"position3D\"; break;\n\t\t\t\tcase QC_2DPOS: quant_catname = \"position2D\"; break;\n\t\t\t\tcase QC_ORDER: quant_catname = \"drawingOrder\"; break;\n\t\t\t\tcase QC_COLOR: quant_catname = \"color\"; break;\n\t\t\t\tcase QC_TEXTURE_COORD: quant_catname = \"textureCoordinate\"; break;\n\t\t\t\tcase QC_ANGLE: quant_catname = \"angle\"; break;\n\t\t\t\tcase QC_SCALE: quant_catname = \"scale\"; break;\n\t\t\t\tcase QC_INTERPOL_KEYS: quant_catname = \"keys\"; break;\n\t\t\t\tcase QC_NORMALS: quant_catname = \"normals\"; break;\n\t\t\t\tcase QC_ROTATION: quant_catname = \"rotations\"; break;\n\t\t\t\tcase QC_SIZE_3D: quant_catname = \"size3D\"; break;\n\t\t\t\tcase QC_SIZE_2D: quant_catname = \"size2D\"; break;\n\t\t\t\tcase QC_LINEAR_SCALAR: quant_catname = \"linear\"; break;\n\t\t\t\tcase QC_COORD_INDEX:quant_catname = \"coordIndex\"; break;\n\t\t\t\t}\n#endif\n\t\t\t\tgf_fprintf(sdump->trace, \"<InterfaceCodingParameters quantCategoy=\\\"%s\\\"\", quant_catname);\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"{QP %d\", pf->QP_Type);\n\t\t\t}\n#ifndef GPAC_DISABLE_BIFS\n\t\t\tif (pf->QP_Type==QC_LINEAR_SCALAR) gf_fprintf(sdump->trace, sdump->XMLDump ? \" nbBits=\\\"%d\\\"\" : \" nbBits %d\", pf->NumBits);\n\t\t\tif (pf->hasMinMax) {\n\t\t\t\tswitch (pf->QP_Type) {\n\t\t\t\tcase QC_LINEAR_SCALAR:\n\t\t\t\tcase QC_COORD_INDEX:\n\t\t\t\t\tif (sdump->XMLDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" intMin=\\\"%d\\\" intMax=\\\"%d\\\"\", *((SFInt32 *)pf->qp_min_value), *((SFInt32 *)pf->qp_max_value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" b {%d %d}\", *((SFInt32 *)pf->qp_min_value), *((SFInt32 *)pf->qp_max_value));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (sdump->XMLDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" floatMin=\\\"%g\\\" floatMax=\\\"%g\\\"\", FIX2FLT( *((SFFloat *)pf->qp_min_value) ), FIX2FLT( *((SFFloat *)pf->qp_max_value) ));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" b {%g %g}\", FIX2FLT( *((SFFloat *)pf->qp_min_value) ), FIX2FLT( *((SFFloat *)pf->qp_max_value) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? \"/>\\n\" : \"}\\n\");\n\t\t\tsdump->indent--;\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t}\n\n\t\t}\n\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sdump->X3DDump) gf_fprintf(sdump->trace, \"</ProtoInterface>\\n\");\n\n\t\tif (proto->ExternProto.count) {\n\t\t\tif (!sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \" \\\"\");\n\t\t\t\tgf_dump_vrml_sffield(sdump, GF_SG_VRML_SFURL, &proto->ExternProto.vals[0], 0, NULL);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\\n\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"</ProtoDeclare>\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \" {\\n\");\n\n\t\tsdump->indent++;\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) gf_fprintf(sdump->trace, \"<ProtoBody>\\n\");\n\n\t\te = DumpProtos(sdump, proto->sub_graph->protos);\n\t\tif (e) return e;\n\n\t\t/*set namespace to the proto one*/\n\t\tprev_sg = sdump->sg;\n\t\tsdump->sg = gf_sg_proto_get_graph(proto);\n\n\t\tcount = gf_list_count(proto->node_code);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_Node *n = (GF_Node*)gf_list_get(proto->node_code, j);\n\t\t\tgf_dump_vrml_node(sdump, n, 1, NULL);\n\t\t}\n\t\tcount = gf_list_count(proto->sub_graph->Routes);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_Route *r = (GF_Route *)gf_list_get(proto->sub_graph->Routes, j);\n\t\t\tif (r->IS_route) continue;\n\t\t\tgf_dump_vrml_route(sdump, r, 0);\n\t\t}\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) gf_fprintf(sdump->trace, \"</ProtoBody>\\n\");\n\n\t\t/*restore namespace*/\n\t\tsdump->sg = prev_sg;\n\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"</ProtoDeclare>\\n\");\n\t\t}\n\t}\n\tsdump->current_proto = prev_proto;\n\treturn GF_OK;\n#endif\n}\n\nstatic GF_Err DumpSceneReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tif (sdump->XMLDump) {\n\t\tif (!sdump->X3DDump) {\n\t\t\tStartElement(sdump, \"Replace\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\t\t//scene tag is already dumped with X3D header\n\t\tif (!sdump->X3DDump) StartElement(sdump, \"Scene\");\n\t\tif (!sdump->X3DDump && com->use_names) {\n\t\t\tStartAttribute(sdump, \"USENAMES\");\n\t\t\tgf_fprintf(sdump->trace, \"%s\", com->use_names ? \"true\" : \"false\");\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\tif (!sdump->X3DDump) EndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t} else {\n\t\tif (!sdump->skip_scene_replace) {\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"REPLACE SCENE BY \");\n\t\t}\n\t}\n\tDumpProtos(sdump, com->new_proto_list);\n\tgf_dump_vrml_node(sdump, com->node, 0, NULL);\n\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"\\n\\n\");\n\n\tif (com->aggregated) {\n\t\tu32 i, count;\n\t\tcount = gf_list_count(com->node->sgprivate->scenegraph->Routes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Route *r = (GF_Route *)gf_list_get(com->node->sgprivate->scenegraph->Routes, i);\n\t\t\tif (r->IS_route) continue;\n\t\t\tgf_dump_vrml_route(sdump, r, 0);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpProtoInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Insert extended=\\\"proto\\\">\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"INSERTPROTO [\\n\");\n\t}\n\tsdump->indent++;\n\tDumpProtos(sdump, com->new_proto_list);\n\tsdump->indent--;\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"</Insert>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_VRML*/\n\n\n#ifndef GPAC_DISABLE_SVG\nstatic char *lsr_format_node_id(GF_Node *n, u32 NodeID, char *str)\n{\n\tif (!n) sprintf(str, \"N%d\", NodeID-1);\n\telse {\n\t\tconst char *name = gf_node_get_name_and_id(n, &NodeID);\n\t\tif (name) sprintf(str, \"%s\", name);\n\t\telse sprintf(str, \"N%d\", NodeID - 1);\n\t}\n\treturn str;\n}\n\nstatic char szLSRName[1024];\n\nstatic char *sd_get_lsr_namespace(GF_SceneGraph *sg)\n{\n\tchar *lsrns = (char *) gf_sg_get_namespace_qname(sg, GF_XMLNS_LASER);\n\tif (lsrns) {\n\t\tsprintf(szLSRName, \"%s:\", lsrns);\n\t\treturn szLSRName;\n\t}\n\treturn \"\";\n}\n\nstatic GF_Err DumpLSRNewScene(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tgf_fprintf(sdump->trace, \"<%sNewScene>\\n\", lsrns);\n\tgf_dump_svg_element(sdump, com->node, NULL, 0);\n\tgf_fprintf(sdump->trace, \"</%sNewScene>\\n\", lsrns);\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRAddReplaceInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[100];\n\tBool is_text = 0;\n\tGF_CommandField *f;\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\n\tconst char *com_name = (com->tag==GF_SG_LSR_REPLACE) ? \"Replace\" : ( (com->tag==GF_SG_LSR_ADD) ? \"Add\" : \"Insert\" );\n\n\tDUMP_IND(sdump);\n\n\tgf_fprintf(sdump->trace, \"<%s%s ref=\\\"%s\\\" \", lsrns, com_name, lsr_format_node_id(com->node, com->RouteID, szID));\n\tf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tif (f && (f->pos>=0) ) gf_fprintf(sdump->trace, \"index=\\\"%d\\\" \", f->pos);\n\tif (f) {\n\t\tGF_FieldInfo info;\n\t\tif (!f->new_node && !f->node_list) {\n\t\t\tchar *att_name = NULL;\n\t\t\tif (f->fieldType==SVG_Transform_Scale_datatype) att_name = \"scale\";\n\t\t\telse if (f->fieldType==SVG_Transform_Rotate_datatype) att_name = \"rotation\";\n\t\t\telse if (f->fieldType==SVG_Transform_Translate_datatype) att_name = \"translation\";\n\t\t\telse if (f->fieldIndex==(u32) -1) att_name = \"textContent\";\n\t\t\telse {\n\t\t\t\tif (!com->node) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tatt_name = (char*) gf_svg_get_attribute_name(com->node, f->fieldIndex);\n\t\t\t}\n\n\t\t\tgf_fprintf(sdump->trace, \"attributeName=\\\"%s\\\" \", att_name);\n\t\t\tif (f->field_ptr) {\n\t\t\t\tchar *att;\n\t\t\t\tinfo.far_ptr = f->field_ptr;\n\t\t\t\tinfo.fieldIndex = f->fieldIndex;\n\t\t\t\tinfo.fieldType = f->fieldType;\n\t\t\t\tinfo.name = att_name;\n\n\t\t\t\tif ((s32) f->pos >= 0) {\n\t\t\t\t\tatt = gf_svg_dump_attribute_indexed(com->node, &info);\n\t\t\t\t} else {\n\t\t\t\t\tatt = gf_svg_dump_attribute(com->node, &info);\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"value=\\\"%s\\\" \", att ? att : \"\");\n\t\t\t\tif (att) gf_free(att);\n\t\t\t}\n\n\t\t\tif (com->fromNodeID) {\n\t\t\t\tGF_FieldInfo op_info;\n\t\t\t\tGF_Node *op = gf_sg_find_node(sdump->sg, com->fromNodeID);\n\t\t\t\tgf_fprintf(sdump->trace, \"operandElementId=\\\"%s\\\" \", lsr_format_node_id(op, com->RouteID, szID));\n\t\t\t\tgf_node_get_field(op, com->fromFieldIndex, &op_info);\n\t\t\t\tgf_fprintf(sdump->trace, \"operandAttributeName=\\\"%s\\\" \", op_info.name);\n\t\t\t}\n\n\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (f->new_node && f->new_node->sgprivate->tag==TAG_DOMText) is_text = 1;\n\t\t/*if fieldIndex (eg attributeName) is set, this is children replacement*/\n\t\tif (f->fieldIndex>0)\n\t\t\tgf_fprintf(sdump->trace, \"attributeName=\\\"children\\\" \");\n\t}\n\n\n\tgf_fprintf(sdump->trace, \">\");\n\tif (!is_text) {\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\tsdump->indent++;\n\t}\n\tif (f) {\n\t\tif (f->new_node) {\n\t\t\tgf_dump_svg_element(sdump, f->new_node, com->node, 0);\n\t\t} else if (f->node_list) {\n\t\t\tGF_ChildNodeItem *list = f->node_list;\n\t\t\twhile (list) {\n\t\t\t\tgf_dump_svg_element(sdump, list->node, com->node, 0);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_text) {\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t}\n\tgf_fprintf(sdump->trace, \"</%s%s>\\n\", lsrns, com_name);\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[1024];\n\tGF_CommandField *f;\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<%sDelete ref=\\\"%s\\\" \", lsrns, lsr_format_node_id(com->node, com->RouteID, szID));\n\tf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tif (f && (f->pos>=0) ) gf_fprintf(sdump->trace, \"index=\\\"%d\\\" \", f->pos);\n\tgf_fprintf(sdump->trace, \"/>\\n\");\n\treturn GF_OK;\n}\n#ifdef GPAC_UNUSED_FUNC\nstatic GF_Err DumpLSRInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\n\nstatic GF_Err SD_SetSceneGraph(GF_SceneDumper *sdump, GF_SceneGraph *sg)\n{\n\tif (sdump) sdump->sg = sg;\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRClean(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRRestore(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\nstatic GF_Err DumpLSRSave(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_UNUSED_FUNC*/\n\nstatic GF_Err DumpLSRSendEvent(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[1024];\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<%sSendEvent ref=\\\"%s\\\" event=\\\"%s\\\"\", lsrns,\n\t        lsr_format_node_id(com->node, com->RouteID, szID),\n\t        gf_dom_event_get_name(com->send_event_name)\n\t       );\n\tif (com->send_event_name <= GF_EVENT_MOUSEWHEEL)\n\t\tgf_fprintf(sdump->trace, \" pointvalue=\\\"%g %g\\\"\", FIX2FLT(com->send_event_x), FIX2FLT(com->send_event_y) );\n\n\tswitch (com->send_event_name) {\n\tcase GF_EVENT_KEYDOWN:\n\tcase GF_EVENT_LONGKEYPRESS:\n\tcase GF_EVENT_REPEAT_KEY:\n\tcase GF_EVENT_SHORT_ACCESSKEY:\n\t\tif (com->send_event_integer) {\n\t\t\tgf_fprintf(sdump->trace, \" stringvalue=\\\"%s\\\"\", gf_dom_get_key_name(com->send_event_integer) );\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tif (com->send_event_integer)\n\t\t\tgf_fprintf(sdump->trace, \" intvalue=\\\"%d\\\"\", com->send_event_integer);\n\t\tif (com->send_event_string)\n\t\t\tgf_fprintf(sdump->trace, \" stringvalue=\\\"%s\\\"\", com->send_event_string);\n\t\tbreak;\n\t}\n\n\tgf_fprintf(sdump->trace, \"/>\\n\");\n\treturn GF_OK;\n}\nstatic GF_Err DumpLSRActivate(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[1024];\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tDUMP_IND(sdump);\n\tif (com->tag==GF_SG_LSR_ACTIVATE) {\n\t\tgf_fprintf(sdump->trace, \"<%sActivate ref=\\\"%s\\\" />\\n\", lsrns, lsr_format_node_id(com->node, com->RouteID, szID));\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"<%sDeactivate ref=\\\"%s\\\" />\\n\", lsrns, lsr_format_node_id(com->node, com->RouteID, szID));\n\t}\n\treturn GF_OK;\n}\n\n#endif\n\nGF_EXPORT\nGF_Err gf_sm_dump_command_list(GF_SceneDumper *sdump, GF_List *comList, u32 indent, Bool skip_first_replace)\n{\n\tGF_Err e;\n\tu32 i, count;\n\tu32 prev_ind;\n#ifndef GPAC_DISABLE_VRML\n\tu32 remain = 0, has_scene_replace = 0;\n#endif\n\tBool prev_skip;\n\n\tif (!sdump || !sdump->trace|| !comList || !sdump->sg) return GF_BAD_PARAM;\n\n\tprev_skip = sdump->skip_scene_replace;\n\tsdump->skip_scene_replace = skip_first_replace;\n\tprev_ind  = sdump->indent;\n\tsdump->indent = indent;\n\n\te = GF_OK;\n\tcount = gf_list_count(comList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Command *com = (GF_Command *) gf_list_get(comList, i);\n\t\tif (i\n#ifndef GPAC_DISABLE_VRML\n\t\t\t&& !remain\n#endif\n\t\t\t&& (sdump->X3DDump || (sdump->dump_mode==GF_SM_DUMP_VRML))\n\t\t) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[Scene Dump] MPEG-4 Commands found, not supported in %s - skipping\\n\", sdump->X3DDump ? \"X3D\" : \"VRML\"));\n\t\t\tbreak;\n\t\t}\n#ifndef GPAC_DISABLE_VRML\n\t\tif (has_scene_replace && (com->tag != GF_SG_ROUTE_INSERT)) {\n\t\t\thas_scene_replace = 0;\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, \"Scene\", 1);\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, \"Replace\", 1);\n\t\t\t} else {\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\nAT 0 {\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tswitch (com->tag) {\n#ifndef GPAC_DISABLE_VRML\n\t\t/*insert commands*/\n\t\tcase GF_SG_NODE_INSERT:\n\t\t\te = DumpNodeInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_INDEXED_INSERT:\n\t\t\te = DumpIndexInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_ROUTE_INSERT:\n\t\t\te = DumpRouteInsert(sdump, com, has_scene_replace);\n\t\t\tif (remain) remain--;\n\t\t\tbreak;\n\t\t/*delete commands*/\n\t\tcase GF_SG_NODE_DELETE:\n\t\t\te = DumpNodeDelete(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_INDEXED_DELETE:\n\t\t\te = DumpIndexDelete(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_ROUTE_DELETE:\n\t\t\te = DumpRouteDelete(sdump, com);\n\t\t\tbreak;\n\t\t/*replace commands*/\n\t\tcase GF_SG_NODE_REPLACE:\n\t\t\te = DumpNodeReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_REPLACE:\n\t\t\te = DumpFieldReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_INDEXED_REPLACE:\n\t\t\te = DumpIndexReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\te = DumpRouteReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_XREPLACE:\n\t\t\te = DumpXReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_SCENE_REPLACE:\n\t\t\t/*we don't support replace scene in conditional*/\n\t\t\tassert(!sdump->current_com_list);\n\t\t\tsdump->current_com_list = comList;\n\t\t\te = DumpSceneReplace(sdump, com);\n\t\t\tsdump->current_com_list = NULL;\n\t\t\thas_scene_replace = 1;\n\t\t\tremain = count - i - 1;\n\t\t\tbreak;\n\t\t/*extended commands*/\n\t\tcase GF_SG_PROTO_INSERT:\n\t\t\te = DumpProtoInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_PROTO_DELETE_ALL:\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<Delete extended=\\\"allProtos\\\"/>\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"DELETEPROTO ALL\\n\");\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\tcase GF_SG_PROTO_DELETE:\n\t\t{\n\t\t\tu32 j;\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<Delete extended=\\\"protos\\\" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"DELETEPROTO [\");\n\t\t\t}\n\t\t\tfor (j=0; j<com->del_proto_list_size; j++) {\n\t\t\t\tif (j) gf_fprintf(sdump->trace, \" \");\n\t\t\t\tgf_fprintf(sdump->trace, \"%d\", com->del_proto_list[j]);\n\t\t\t}\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t}\n\t\tbreak;\n\t\tcase GF_SG_GLOBAL_QUANTIZER:\n\t\t\te = DumpGlobalQP(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_MULTIPLE_REPLACE:\n\t\t\te = DumpMultipleReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_MULTIPLE_INDEXED_REPLACE:\n\t\t\te = DumpMultipleIndexedReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_NODE_DELETE_EX:\n\t\t\te = DumpNodeDelete(sdump, com);\n\t\t\tbreak;\n\n#endif\n\n\n#ifndef GPAC_DISABLE_SVG\n\t\t/*laser commands*/\n\t\tcase GF_SG_LSR_NEW_SCENE:\n\t\t\te = DumpLSRNewScene(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_ADD:\n\t\t\te = DumpLSRAddReplaceInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_CLEAN:\n\t\t\t//e = DumpLSRClean(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_REPLACE:\n\t\t\te = DumpLSRAddReplaceInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_DELETE:\n\t\t\te = DumpLSRDelete(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_INSERT:\n\t\t\te = DumpLSRAddReplaceInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_RESTORE:\n\t\t\t//e = DumpLSRRestore(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_SAVE:\n\t\t\t//e = DumpLSRSave(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_SEND_EVENT:\n\t\t\te = DumpLSRSendEvent(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_ACTIVATE:\n\t\tcase GF_SG_LSR_DEACTIVATE:\n\t\t\te = DumpLSRActivate(sdump, com);\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (e) break;\n\n\n\t\tif (sdump->skip_scene_replace\n#ifndef GPAC_DISABLE_VRML\n\t\t\t&& !has_scene_replace\n#endif\n\t\t) {\n\t\t\tsdump->skip_scene_replace = 0;\n\t\t\tif (!sdump->XMLDump && (i+1<count)) {\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\nAT 0 {\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_VRML\n\tif (remain && !sdump->XMLDump) {\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t}\n#endif\n\n\tif (has_scene_replace && sdump->XMLDump) {\n\t\tsdump->indent--;\n\t\tif (!sdump->X3DDump) {\n\t\t\tEndElement(sdump, \"Scene\", 1);\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"Replace\", 1);\n\t\t}\n\t}\n\n\tsdump->indent = prev_ind;\n\tsdump->skip_scene_replace = prev_skip;\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_SVG\nvoid gf_dump_svg_element(GF_SceneDumper *sdump, GF_Node *n, GF_Node *parent, Bool is_root)\n{\n\tGF_ChildNodeItem *list;\n\tchar attName[100], *attValue;\n\tu32 nID;\n\tSVG_Element *svg = (SVG_Element *)n;\n\tGF_FieldInfo info;\n\tSVGAttribute *att;\n\tu32 tag, ns;\n\tif (!n) return;\n\n\tnID = gf_node_get_id(n);\n\ttag = n->sgprivate->tag;\n\t/*remove undef listener/handlers*/\n\tif (!nID) {\n\t\tswitch (tag) {\n\t\tcase TAG_SVG_listener:\n\t\t\tif ((0) && gf_node_get_attribute_by_tag(n, TAG_XMLEV_ATT_handler, 0, 0, &info)==GF_OK) {\n\t\t\t\tif (((XMLRI*)info.far_ptr)->target && !gf_node_get_id(((XMLRI*)info.far_ptr)->target) )\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_SVG_handler:\n\t\t\t/*this handler was not declared in the graph*/\n\t\t\tif (!n->sgprivate->parents || (n->sgprivate->parents->node != parent))\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase TAG_DOMText:\n\t\t{\n\t\t\tGF_DOMText *txt = (GF_DOMText *)n;\n\t\t\tif (txt->textContent) {\n\t\t\t\tif ((txt->type==GF_DOM_TEXT_CDATA)\n\t\t\t\t\t|| (parent && (parent->sgprivate->tag == TAG_SVG_script))\n\t\t\t\t\t|| (parent && (parent->sgprivate->tag == TAG_SVG_handler))\n\t\t\t\t) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<![CDATA[\");\n\t\t\t\t\tgf_fprintf(sdump->trace, \"%s\", txt->textContent);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"]]>\");\n\t\t\t\t} else if (txt->type==GF_DOM_TEXT_REGULAR) {\n\t\t\t\t\tscene_dump_utf_string(sdump, 0, txt->textContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t\t}\n\t}\n\n\tif (!sdump->in_text) {\n\t\tDUMP_IND(sdump);\n\t}\n\n\t/*register all namespaces specified on this element */\n\tgf_xml_push_namespaces((GF_DOMNode *)n);\n\n\tgf_fprintf(sdump->trace, \"<%s\", gf_node_get_class_name(n));\n\tns = gf_xml_get_element_namespace(n);\n\n\tif (nID) {\n\t\tchar attID[100];\n\t\tgf_fprintf(sdump->trace, \" id=\\\"%s\\\"\", lsr_format_node_id(n, 0, attID));\n\t}\n\tatt = svg->attributes;\n\twhile (att) {\n\t\tif (att->data_type==SVG_ID_datatype) {\n\t\t\tatt = att->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo.fieldIndex = att->tag;\n\t\tinfo.fieldType = att->data_type;\n\t\tif (att->tag==TAG_DOM_ATT_any) {\n\t\t\tu32 att_ns = ((GF_DOMFullAttribute*)att)->xmlns;\n\t\t\tinfo.name = ((GF_DOMFullAttribute*)att)->name;\n\t\t\tif ((att_ns != ns) && strncmp(info.name, \"xmlns\", 5)) {\n\t\t\t\tsprintf(attName, \"%s:%s\", gf_sg_get_namespace_qname(gf_node_get_graph(n), att_ns), ((GF_DOMFullAttribute*)att)->name);\n\t\t\t\tinfo.name = attName;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.name = gf_svg_get_attribute_name(n, att->tag);\n\t\t}\n\n\t\tif (att->data_type==XMLRI_datatype) {\n\t\t\tXMLRI *xlink = (XMLRI *)att->data;\n\t\t\tif (xlink->type==XMLRI_ELEMENTID) {\n\t\t\t\tif (!xlink->target || !gf_node_get_id((GF_Node*)xlink->target) ) {\n\t\t\t\t\tatt = att->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (parent && (parent == (GF_Node *) xlink->target)) {\n\t\t\t\t\tatt = att->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (xlink->type==XMLRI_STREAMID) {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"#stream%d\\\"\", info.name, xlink->lsr_stream_id);\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"%s\\\"\", info.name, xlink->string);\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tinfo.far_ptr = att->data;\n\t\tattValue = gf_svg_dump_attribute((GF_Node*)svg, &info);\n\t\tif (attValue) {\n\t\t\tif (/*strcmp(info.name, \"xmlns\") &&*/ (info.fieldType = (u32) strlen(attValue)))\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"%s\\\"\", info.name, attValue);\n\t\t\tgf_free(attValue);\n\t\t}\n\t\tatt = att->next;\n\t}\n\n\tgf_dom_event_dump_listeners(n, sdump->trace);\n\tif (svg->children) {\n\t\tgf_fprintf(sdump->trace, \">\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"/>\");\n\t\treturn;\n\t}\n\n\tif (n->sgprivate->tag==TAG_LSR_conditional) {\n\t\tGF_DOMUpdates *up = svg->children ? (GF_DOMUpdates *)svg->children->node : NULL;\n\t\tsdump->indent++;\n\t\tif (up && (up->sgprivate->tag==TAG_DOMUpdates)) {\n\t\t\tif (gf_list_count(up->updates)) {\n\t\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t\t\tgf_sm_dump_command_list(sdump, up->updates, sdump->indent, 0);\n\t\t\t} else if (up->data) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<!-- WARNING: LASeR scripts cannot be dumped at run-time -->\\n\");\n\t\t\t}\n\t\t}\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"</%s>\\n\", gf_node_get_class_name(n));\n\t\treturn;\n\t}\n\n\tif (tag==TAG_SVG_text || tag==TAG_SVG_textArea) sdump->in_text = 1;\n\tsdump->indent++;\n\tlist = svg->children;\n\twhile (list) {\n\t\tif (!sdump->in_text) gf_fprintf(sdump->trace, \"\\n\");\n\t\tgf_dump_svg_element(sdump, list->node, n, 0);\n\t\tlist = list->next;\n\t}\n\tif (!sdump->in_text) gf_fprintf(sdump->trace, \"\\n\");\n\tsdump->indent--;\n\tif (!sdump->in_text) DUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"</%s>\", gf_node_get_class_name(n));\n\tif (tag==TAG_SVG_text || tag==TAG_SVG_textArea) sdump->in_text = 0;\n\t/*removes all namespaces specified on this element */\n\tgf_xml_pop_namespaces((GF_DOMNode *)n);\n}\n#endif\n\nstatic void gf_sm_dump_saf_hdr(GF_SceneDumper *dumper, char *unit_name, u64 au_time, Bool is_rap)\n{\n\tgf_fprintf(dumper->trace, \"<saf:%s\", unit_name);\n\tif (au_time) gf_fprintf(dumper->trace, \" time=\\\"\"LLD\"\\\"\", au_time);\n\tif (is_rap) gf_fprintf(dumper->trace, \" rap=\\\"true\\\"\");\n\tgf_fprintf(dumper->trace, \">\\n\");\n}\n\nstatic void dump_od_to_saf(GF_SceneDumper *dumper, GF_AUContext *au, u32 indent)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(au->commands);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, c2;\n\t\tGF_ODUpdate *com = (GF_ODUpdate *)gf_list_get(au->commands, i);\n\t\tif (com->tag != GF_ODF_OD_UPDATE_TAG) continue;\n\n\t\tc2 = gf_list_count(com->objectDescriptors);\n\t\tfor (j=0; j<c2; j++) {\n\t\t\tGF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(com->objectDescriptors, j);\n\t\t\tGF_ESD *esd = (GF_ESD *) gf_list_get(od->ESDescriptors, 0);\n\t\t\tGF_MuxInfo *mux;\n\t\t\tif (!esd || (esd->tag != GF_ODF_ESD_TAG)) {\n\t\t\t\tif (od->URLString) {\n\t\t\t\t\tgf_fprintf(dumper->trace, \"<saf:RemoteStreamHeader streamID=\\\"stream%d\\\" url=\\\"%s\\\"\", au->owner->ESID, od->URLString);\n\t\t\t\t\tif (au->timing) gf_fprintf(dumper->trace, \" time=\\\"\"LLD\"\\\"\", au->timing);\n\t\t\t\t\tgf_fprintf(dumper->trace, \"/>\\n\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmux = (GF_MuxInfo *)gf_list_get(esd->extensionDescriptors, 0);\n\t\t\tif (!mux || (mux->tag!=GF_ODF_MUXINFO_TAG)) mux = NULL;\n\n\n\t\t\tgf_fprintf(dumper->trace, \"<saf:mediaHeader streamID=\\\"stream%d\\\"\", esd->ESID);\n\t\t\tif (esd->decoderConfig) {\n\t\t\t\tgf_fprintf(dumper->trace, \" streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" timeStampResolution=\\\"%d\\\"\", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);\n\t\t\t}\n\t\t\tif (au->timing) gf_fprintf(dumper->trace, \" time=\\\"\"LLD\"\\\"\", au->timing);\n\t\t\tif (mux && mux->file_name) gf_fprintf(dumper->trace, \" source=\\\"%s\\\"\", mux->file_name);\n\t\t\tgf_fprintf(dumper->trace, \"/>\\n\");\n\t\t}\n\n\n\t}\n\tgf_fprintf(dumper->trace, \"</saf:mediaUnit>\\n\");\n}\n\n#ifndef GPAC_DISABLE_SVG\nstatic GF_Err SD_DumpDOMElement(GF_SceneDumper *sdump, GF_DOMFullNode *node)\n{\n\tconst char *ns;\n\tu32 child_type = 0;\n\tGF_DOMFullAttribute *att;\n\tGF_ChildNodeItem *child;\n\tGF_DOMText *txt;\n\tns = gf_sg_get_namespace_qname(node->sgprivate->scenegraph, node->ns);\n\n\tDUMP_IND(sdump);\n\tif (ns) gf_fprintf(sdump->trace, \"<%s:%s\", ns, node->name);\n\telse gf_fprintf(sdump->trace, \"<%s\", node->name);\n\tatt = (GF_DOMFullAttribute *)node->attributes;\n\twhile (att) {\n\t\tgf_fprintf(sdump->trace, \" %s=\\\"%s\\\"\", att->name, (char *) att->data);\n\t\tatt = (GF_DOMFullAttribute *)att->next;\n\t}\n\tif (!node->children) {\n\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\treturn GF_OK;\n\t}\n\tgf_fprintf(sdump->trace, \">\");\n\tsdump->indent++;\n\tchild = node->children;\n\twhile (child) {\n\t\tswitch(child->node->sgprivate->tag) {\n\t\tcase TAG_DOMFullNode:\n\t\t\tif (!child_type) gf_fprintf(sdump->trace, \"\\n\");\n\t\t\tchild_type = 1;\n\t\t\tSD_DumpDOMElement(sdump, (GF_DOMFullNode*)child->node);\n\t\t\tbreak;\n\t\tcase TAG_DOMText:\n\t\t\tchild_type = 2;\n\t\t\ttxt = (GF_DOMText *)child->node;\n\t\t\tif (txt->type==GF_DOM_TEXT_REGULAR) {\n\t\t\t\tscene_dump_utf_string(sdump, 0, txt->textContent);\n\t\t\t} else if (txt->type==GF_DOM_TEXT_CDATA) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<![CDATA[\");\n\t\t\t\tgf_fprintf(sdump->trace, \"%s\", txt->textContent);\n\t\t\t\tgf_fprintf(sdump->trace, \"]]>\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tchild = child->next;\n\t}\n\n\tsdump->indent--;\n\tif (child_type!=2) {\n\t\tDUMP_IND(sdump);\n\t}\n\n\tif (ns) gf_fprintf(sdump->trace, \"</%s:%s>\\n\", ns, node->name);\n\telse gf_fprintf(sdump->trace, \"</%s>\\n\", node->name);\n\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_sm_dump_graph(GF_SceneDumper *sdump, Bool skip_proto, Bool skip_routes)\n{\n\tu32 tag;\n\tif (!sdump->trace || !sdump->sg || !sdump->sg->RootNode) return GF_BAD_PARAM;\n\n\ttag = sdump->sg->RootNode->sgprivate->tag;\n\n\tif (tag<=GF_NODE_RANGE_LAST_X3D) {\n\t\tgf_dump_setup(sdump, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tStartElement(sdump, \"Scene\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\n#ifndef GPAC_DISABLE_VRML\n\t\tGF_Err e;\n\t\tif (!skip_proto) {\n\t\t\te = DumpProtos(sdump, sdump->sg->protos);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tif (sdump->X3DDump) {\n\t\t\tGF_ChildNodeItem *list = ((GF_ParentNode *)sdump->sg->RootNode)->children;\n\t\t\twhile (list) {\n\t\t\t\tgf_dump_vrml_node(sdump, list->node, 0, NULL);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_dump_vrml_node(sdump, sdump->sg->RootNode, 0, NULL);\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"\\n\\n\");\n\t\tif (!skip_routes) {\n\t\t\tGF_Route *r;\n\t\t\tu32 i=0;\n\t\t\twhile ((r = (GF_Route*)gf_list_enum(sdump->sg->Routes, &i))) {\n\t\t\t\tif (r->IS_route || (r->graph!=sdump->sg)) continue;\n\t\t\t\te = gf_dump_vrml_route(sdump, r, 0);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tif (sdump->XMLDump) {\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"Scene\", 1);\n\t\t}\n#endif /*GPAC_DISABLE_VRML*/\n\n\t\tgf_dump_finalize(sdump, NULL);\n\t\treturn GF_OK;\n\t}\n#ifndef GPAC_DISABLE_SVG\n\telse if ((tag>=GF_NODE_RANGE_FIRST_SVG) && (tag<=GF_NODE_RANGE_LAST_SVG)) {\n\t\tsdump->dump_mode = GF_SM_DUMP_SVG;\n\t\tgf_dump_setup(sdump, NULL);\n\t\tgf_dump_svg_element(sdump, sdump->sg->RootNode, NULL, 1);\n\t\treturn GF_OK;\n\t}\n\telse if (tag==TAG_DOMFullNode) {\n\t\tsdump->dump_mode = GF_SM_DUMP_XML;\n\t\tgf_dump_setup(sdump, NULL);\n\t\tSD_DumpDOMElement(sdump, (GF_DOMFullNode*)sdump->sg->RootNode);\n\t}\n#endif\n\n\treturn GF_OK;\n}\n\n\n\n\nstatic void ReorderAUContext(GF_List *sample_list, GF_AUContext *au, Bool lsr_dump)\n{\n\tu64 autime, time;\n\tu32 i;\n\tBool has_base;\n\tGF_AUContext *ptr;\n\n\t/*\n\t\tthis happens when converting from bt to xmt\n\t\tNOTE: Comment is wrong? this happens when just loading BT\n\t*/\n\tif (!au->timing_sec) {\n\t\tau->timing_sec = (Double) (s64) au->timing;\n\t\t/* Hack to avoid timescale=0 which happens when loading a BT with no SLConfig*/\n\t\tif (!au->owner->timeScale) au->owner->timeScale = 1000;\n\t\tau->timing_sec /= au->owner->timeScale;\n\t}\n\t/*this happens when converting from xmt to bt*/\n\tif (!au->timing) {\n\t\tassert(au->owner->timeScale);\n\t\tau->timing = (u64) (au->timing_sec * au->owner->timeScale);\n\t}\n\n\tautime = au->timing + au->owner->imp_exp_time;\n\thas_base = 0;\n\ti=0;\n\twhile ((ptr = (GF_AUContext*)gf_list_enum(sample_list, &i))) {\n\t\ttime = ptr->timing + ptr->owner->imp_exp_time;\n\t\tif (\n\t\t    /*time ordered*/\n\t\t    (time > autime)\n\t\t    /*set bifs first for first AU*/\n\t\t    || (!has_base && (time == autime) && (ptr->owner->streamType < au->owner->streamType) )\n\t\t    /*set OD first for laser*/\n\t\t    || (lsr_dump && (au->owner->streamType==GF_STREAM_OD))\n\t\t) {\n\t\t\tgf_list_insert(sample_list, au, i-1);\n\t\t\treturn;\n\t\t}\n\n\t\thas_base = 0;\n\t\tif ( (ptr->owner->streamType == au->owner->streamType) && (time == autime) ) has_base = 1;\n\t}\n\tgf_list_add(sample_list, au);\n}\n\n\nGF_EXPORT\nGF_Err gf_sm_dump(GF_SceneManager *ctx, char *rad_name, Bool is_final_name, GF_SceneDumpFormat dump_mode)\n{\n\tGF_Err e;\n\tGF_List *sample_list;\n\tBool first_par;\n\tu32 i, j, indent, num_scene, num_od, first_bifs, num_tracks;\n\tDouble time;\n\tGF_SceneDumper *dumper;\n\tGF_StreamContext *sc;\n\tGF_AUContext *au;\n\tBool no_root_found = 1;\n\n\tsample_list = gf_list_new();\n\n\tnum_scene = num_od = 0;\n\tnum_tracks = 0;\n\tindent = 0;\n\tdumper = gf_sm_dumper_new(ctx->scene_graph, rad_name, is_final_name, ' ', dump_mode);\n\te = GF_OK;\n\t/*configure all systems streams we're dumping*/\n\ti=0;\n\twhile ((sc = (GF_StreamContext*)gf_list_enum(ctx->streams, &i))) {\n\n\t\tswitch (sc->streamType) {\n\t\tcase GF_STREAM_SCENE:\n\t\t\tnum_scene ++;\n\t\t\tnum_tracks ++;\n\t\t\tbreak;\n\t\tcase GF_STREAM_OD:\n\t\t\tnum_od ++;\n\t\t\tnum_tracks ++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tj=0;\n\t\twhile ((au = (GF_AUContext*)gf_list_enum(sc->AUs, &j))) {\n\t\t\tReorderAUContext(sample_list, au, dumper->LSRDump);\n\t\t\tif (dumper->dump_mode==GF_SM_DUMP_SVG) break;\n\t\t}\n\t\tif (dumper->dump_mode==GF_SM_DUMP_SVG) break;\n\t}\n\tfirst_bifs = (num_scene==1) ? 1 : 0;\n\tnum_scene = (num_scene>1) ? 1 : 0;\n\tnum_od = (num_od>1) ? 1 : 0;\n\n\tgf_dump_setup(dumper, (GF_Descriptor *) ctx->root_od);\n\n#ifndef GPAC_DISABLE_SVG\n\tif (dumper->dump_mode==GF_SM_DUMP_SVG) {\n\t\tau = (GF_AUContext*)gf_list_get(sample_list, 0);\n\t\tGF_Command *com = NULL;\n\t\tif (au) com = (GF_Command*)gf_list_get(au->commands, 0);\n\t\tif (!au) {\n\t\t\tgf_dump_svg_element(dumper, dumper->sg->RootNode, NULL, 1);\n\t\t} else if (!com || (com->tag!=GF_SG_LSR_NEW_SCENE) || !com->node) {\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tgf_dump_svg_element(dumper, com->node, NULL, 1);\n\t\t}\n\t\tgf_dump_finalize(dumper, (GF_Descriptor *) ctx->root_od);\n\t\tgf_sm_dumper_del(dumper);\n\t\tgf_list_del(sample_list);\n\t\treturn e;\n\t}\n#endif\n\n\ttime = dumper->LSRDump ? -1 : 0;\n\tfirst_par = 0;\n\n\twhile (gf_list_count(sample_list)) {\n\t\tau = (GF_AUContext*)gf_list_get(sample_list, 0);\n\t\tgf_list_rem(sample_list, 0);\n\n\t\tif (!dumper->XMLDump) {\n\n\t\t\tif (!first_bifs || (au->owner->streamType != GF_STREAM_SCENE) ) {\n\t\t\t\tif (au->flags & GF_SM_AU_RAP) gf_fprintf(dumper->trace, \"RAP \");\n\t\t\t\tgf_fprintf(dumper->trace, \"AT \"LLD\" \", au->timing);\n\t\t\t\tif ( (au->owner->streamType==GF_STREAM_OD && num_od) || (au->owner->streamType==GF_STREAM_SCENE && num_scene)) {\n\t\t\t\t\tgf_fprintf(dumper->trace, \"IN %d \", au->owner->ESID);\n\t\t\t\t}\n\t\t\t\tgf_fprintf(dumper->trace, \"{\\n\");\n\t\t\t\tindent++;\n\t\t\t}\n\n\t\t\tswitch (au->owner->streamType) {\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (dumper->LSRDump) {\n\t\t\t\t\tdump_od_to_saf(dumper, au, indent);\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\t\t\te = gf_odf_dump_com_list(au->commands, dumper->trace, indent+1, 0);\n#endif\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\te = gf_sm_dump_command_list(dumper, au->commands, indent, first_bifs);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (first_bifs) {\n\t\t\t\tfirst_bifs = 0;\n\t\t\t\tgf_fprintf(dumper->trace, \"\\n\");\n\n\t\t\t} else {\n\t\t\t\tindent--;\n\t\t\t\tgf_fprintf(dumper->trace, \"}\\n\\n\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (dumper->LSRDump) {\n/*\t\t\t\tif (time != au->timing_sec) {\n\t\t\t\t\ttime = au->timing_sec;\n\t\t\t\t}\n*/\n\t\t\t} else if (!time && !num_scene && first_bifs) {\n\t\t\t} else if (num_scene || num_od) {\n\t\t\t\tif (!first_par) {\n\t\t\t\t\tfirst_par = 1;\n\t\t\t\t\tindent += 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(dumper->trace, \" </par>\\n\");\n\t\t\t\t}\n\t\t\t\tgf_fprintf(dumper->trace, \" <par begin=\\\"%g\\\" atES_ID=\\\"es%d\\\" isRAP=\\\"%s\\\">\\n\", au->timing_sec, au->owner->ESID, (au->flags & GF_SM_AU_RAP) ? \"yes\" : \"no\");\n\t\t\t} else if (au->timing_sec>time) {\n\t\t\t\tif (!first_par) {\n\t\t\t\t\tfirst_par = 1;\n\t\t\t\t\tindent += 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(dumper->trace, \" </par>\\n\");\n\t\t\t\t}\n\t\t\t\tgf_fprintf(dumper->trace, \"<par begin=\\\"%g\\\">\\n\", au->timing_sec);\n\t\t\t}\n\t\t\tswitch (au->owner->streamType) {\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (dumper->LSRDump) {\n\t\t\t\t\tdump_od_to_saf(dumper, au, indent+1);\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\t\t\te = gf_odf_dump_com_list(au->commands, dumper->trace, indent+1, 1);\n#endif\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\tif (gf_list_count(au->commands)) {\n\t\t\t\t\tif (dumper->LSRDump)\n\t\t\t\t\t\tgf_sm_dump_saf_hdr(dumper, \"sceneUnit\", au->timing, au->flags & GF_SM_AU_RAP);\n\n\t\t\t\t\te = gf_sm_dump_command_list(dumper, au->commands, indent+1, first_bifs);\n\t\t\t\t\tfirst_bifs = 0;\n\t\t\t\t\tno_root_found = 0;\n\n\t\t\t\t\tif (dumper->LSRDump)\n\t\t\t\t\t\tgf_fprintf(dumper->trace, \"</saf:sceneUnit>\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttime = au->timing_sec;\n\t\t}\n\t\tif (dumper->X3DDump || (dumper->dump_mode==GF_SM_DUMP_VRML)) break;\n\t}\n\n#ifndef GPAC_DISABLE_VRML\n\tif (no_root_found && ctx->scene_graph->RootNode) {\n\t\tGF_Route *r;\n\t\tDumpProtos(dumper, ctx->scene_graph->protos);\n\t\tgf_dump_vrml_node(dumper, ctx->scene_graph->RootNode, 0, NULL);\n\t\ti=0;\n\t\tgf_fprintf(dumper->trace, \"\\n\");\n\t\twhile ((r = (GF_Route*)gf_list_enum(dumper->sg->Routes, &i))) {\n\t\t\tif (r->IS_route || (r->graph!=dumper->sg)) continue;\n\t\t\te = gf_dump_vrml_route(dumper, r, 0);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n#endif\n\n\n\t/*close command*/\n\tif (!dumper->X3DDump && first_par) gf_fprintf(dumper->trace, \" </par>\\n\");\n\n\tif (gf_list_count(sample_list) && (dumper->X3DDump || (dumper->dump_mode==GF_SM_DUMP_VRML)) ) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[Scene Dump] MPEG-4 Commands found, not supported in %s - skipping\\n\", dumper->X3DDump ? \"X3D\" : \"VRML\"));\n\t}\n\n\tgf_dump_finalize(dumper, (GF_Descriptor *) ctx->root_od);\n\tgf_sm_dumper_del(dumper);\n\tgf_list_del(sample_list);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_SCENE_DUMP*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Scene Management sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/scene_manager.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/internal/scenegraph_dev.h>\n#include <gpac/nodes_x3d.h>\n#include <gpac/nodes_svg.h>\n#include <gpac/events.h>\n#include <gpac/base_coding.h>\n\n#ifndef __SYMBIAN32__\n#include <wchar.h>\n#endif\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\n/*for QP types*/\n#include \"../bifs/quant.h\"\n\nstruct _scenedump\n{\n\t/*the scene we're dumping - set at each SceneReplace or mannually*/\n\tGF_SceneGraph *sg;\n#ifndef GPAC_DISABLE_VRML\n\t/*the proto we're dumping*/\n\tGF_Proto *current_proto;\n#endif\n\tFILE *trace;\n\tu32 indent;\n\tchar *filename;\n\n\tGF_SceneDumpFormat dump_mode;\n\tu16 CurrentESID;\n\tu8 ind_char;\n\tBool XMLDump, X3DDump, LSRDump;\n\n\tGF_List *dump_nodes;\n\n\t/*nodes created through conditionals while parsing but not applied*/\n\tGF_List *mem_def_nodes;\n\n\tBool skip_scene_replace;\n\t/*for route insert/replace in conditionals in current scene replace*/\n\tGF_List *current_com_list;\n\tGF_List *inserted_routes;\n\n\tBool in_text;\n};\n\nstatic GF_Err gf_dump_vrml_route(GF_SceneDumper *sdump, GF_Route *r, u32 dump_type);\nstatic void gf_dump_vrml_node(GF_SceneDumper *sdump, GF_Node *node, Bool in_list, char *fieldContainer);\n\n#ifndef GPAC_DISABLE_SVG\nvoid gf_dump_svg_element(GF_SceneDumper *sdump, GF_Node *n, GF_Node *parent, Bool is_root);\n#endif\n\nGF_EXPORT\nGF_SceneDumper *gf_sm_dumper_new(GF_SceneGraph *graph, char *_rad_name, Bool is_final_name, char indent_char, GF_SceneDumpFormat dump_mode)\n{\n\tGF_SceneDumper *tmp;\n\tif (!graph) return NULL;\n\tGF_SAFEALLOC(tmp, GF_SceneDumper);\n\tif (!tmp) return NULL;\n\n\t/*store original*/\n\ttmp->dump_mode = dump_mode;\n\n#ifndef GPAC_DISABLE_SVG\n\tif ((graph->RootNode && (graph->RootNode->sgprivate->tag>=GF_NODE_RANGE_LAST_VRML) )\n\t        || (dump_mode==GF_SM_DUMP_LASER) || (dump_mode==GF_SM_DUMP_SVG)) {\n\t\ttmp->XMLDump = GF_TRUE;\n\t\tif (dump_mode==GF_SM_DUMP_LASER) {\n\t\t\ttmp->LSRDump = GF_TRUE;\n\t\t}\n\t\tif (_rad_name) {\n\t\t\tconst char* ext_name = tmp->LSRDump ? \".xsr\" : \".svg\";\n\t\t\ttmp->filename = (char *)gf_malloc(strlen(_rad_name) + strlen(ext_name) + 1);\n\t\t\tstrcpy(tmp->filename, _rad_name);\n\t\t\tif (!is_final_name) strcat(tmp->filename, ext_name);\n\t\t\ttmp->trace = gf_fopen(tmp->filename, \"wt\");\n\t\t\tif (!tmp->trace) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\ttmp->trace = stdout;\n\t\t}\n\t} else\n#endif\n\t{\n\n\t\tif (dump_mode==GF_SM_DUMP_AUTO_TXT) {\n\t\t\tif (!graph->RootNode || (graph->RootNode->sgprivate->tag<=GF_NODE_RANGE_LAST_MPEG4) ) {\n\t\t\t\tdump_mode = GF_SM_DUMP_BT;\n\t\t\t} else if (graph->RootNode->sgprivate->tag<=GF_NODE_RANGE_LAST_X3D) {\n\t\t\t\tdump_mode = GF_SM_DUMP_X3D_VRML;\n\t\t\t}\n\t\t}\n\t\telse if (dump_mode==GF_SM_DUMP_AUTO_XML) {\n\t\t\tif (!graph->RootNode || (graph->RootNode->sgprivate->tag<=GF_NODE_RANGE_LAST_MPEG4) ) {\n\t\t\t\tdump_mode = GF_SM_DUMP_XMTA;\n\t\t\t} else {\n\t\t\t\tdump_mode = GF_SM_DUMP_X3D_XML;\n\t\t\t}\n\t\t}\n\n\t\tif (_rad_name) {\n\t\t\tconst char* ext_name;\n\t\t\tswitch (dump_mode) {\n\t\t\tcase GF_SM_DUMP_X3D_XML:\n\t\t\t\text_name = \".x3d\";\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_XMTA:\n\t\t\t\text_name = \".xmt\";\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_X3D_VRML:\n\t\t\t\text_name = \".x3dv\";\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_VRML:\n\t\t\t\text_name = \".wrl\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\text_name = \".bt\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp->filename = (char *)gf_malloc(strlen(_rad_name ? _rad_name : \"\") + strlen(ext_name) + 1);\n\t\t\tstrcpy(tmp->filename, _rad_name ? _rad_name : \"\");\n\t\t\tif (!is_final_name) strcat(tmp->filename, ext_name);\n\t\t\ttmp->trace = gf_fopen(tmp->filename, \"wt\");\n\t\t\tif (!tmp->trace) {\n\t\t\t\tgf_free(tmp);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\ttmp->trace = stdout;\n\t\t\tswitch (dump_mode) {\n\t\t\tcase GF_SM_DUMP_X3D_XML:\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_XMTA:\n\t\t\t\ttmp->XMLDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_SM_DUMP_X3D_VRML:\n\t\t\t\ttmp->X3DDump = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ttmp->ind_char = indent_char;\n\ttmp->dump_nodes = gf_list_new();\n\ttmp->mem_def_nodes = gf_list_new();\n\ttmp->inserted_routes = gf_list_new();\n\ttmp->sg = graph;\n\treturn tmp;\n}\n\nGF_EXPORT\nvoid gf_sm_dumper_set_extra_graph(GF_SceneDumper *sdump, GF_SceneGraph *extra)\n{\n\tsdump->sg = extra;\n}\n\nGF_EXPORT\nvoid gf_sm_dumper_del(GF_SceneDumper *sdump)\n{\n\tgf_list_del(sdump->dump_nodes);\n\twhile (gf_list_count(sdump->mem_def_nodes)) {\n\t\tGF_Node *tmp = (GF_Node *)gf_list_get(sdump->mem_def_nodes, 0);\n\t\tgf_list_rem(sdump->mem_def_nodes, 0);\n\t\tgf_node_unregister(tmp, NULL);\n\t}\n\tgf_list_del(sdump->mem_def_nodes);\n\tgf_list_del(sdump->inserted_routes);\n\tif (sdump->trace != stdout) gf_fclose(sdump->trace);\n\tif (sdump->filename) {\n\t\tgf_free(sdump->filename);\n\t\tsdump->filename = NULL;\n\t}\n\tgf_free(sdump);\n}\n\nchar *gf_sm_dump_get_name(GF_SceneDumper *bd)\n{\n\tif (!bd) return NULL;\n\treturn bd->filename;\n}\n\nstatic void gf_dump_setup(GF_SceneDumper *sdump, GF_Descriptor *root_od)\n{\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\t\tif (sdump->dump_mode==GF_SM_DUMP_XML) return;\n\t\tgf_fprintf(sdump->trace, \"<!-- %s Scene Dump -->\\n\",\n\t\t        (sdump->dump_mode==GF_SM_DUMP_SVG) ? \"SVG\" :\n\t\t        (sdump->dump_mode==GF_SM_DUMP_LASER) ? \"LASeR\" :\n\t\t        sdump->X3DDump ? \"X3D\" : \"XMT-A\"\n\t\t       );\n\t}\n\tif (sdump->dump_mode==GF_SM_DUMP_SVG) return;\n\tif (sdump->LSRDump) {\n\t\tgf_fprintf(sdump->trace, \"<saf:SAFSession xmlns:saf=\\\"urn:mpeg:mpeg4:SAF:2005\\\" >\\n\");\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\tif (root_od) {\n\t\t\tGF_ObjectDescriptor *iod = (GF_ObjectDescriptor *)root_od;\n\t\t\tu32 i, count;\n\t\t\tgf_fprintf(sdump->trace, \"<saf:sceneHeader>\\n\");\n\t\t\tcount = gf_list_count(iod->ESDescriptors);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_LASERConfig lsrcfg;\n\t\t\t\tGF_ESD *esd = (GF_ESD *)gf_list_get(iod->ESDescriptors, i);\n\t\t\t\tif (!esd || !esd->decoderConfig) continue;\n\t\t\t\tif (esd->decoderConfig->streamType != GF_STREAM_SCENE) continue;\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication != 0x09) continue;\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo || !esd->decoderConfig->decoderSpecificInfo->data) continue;\n\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &lsrcfg);\n\t\t\t\tgf_odf_dump_desc((GF_Descriptor*)&lsrcfg, sdump->trace, 1, 1);\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"</saf:sceneHeader>\\n\");\n\t\t}\n#endif\n\t\treturn;\n\t}\n\n\tif (!sdump->X3DDump) {\n\t\t/*setup XMT*/\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<XMT-A xmlns=\\\"urn:mpeg:mpeg4:xmta:schema:2002\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"urn:mpeg:mpeg4:xmta:schema:2002 xmt-a.xsd\\\">\\n\");\n\t\t\tgf_fprintf(sdump->trace, \" <Header>\\n\");\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\tif (root_od) gf_odf_dump_desc(root_od, sdump->trace, 1, 1);\n#endif\n\t\t\tgf_fprintf(sdump->trace, \" </Header>\\n\");\n\t\t\tgf_fprintf(sdump->trace, \" <Body>\\n\");\n\t\t\tif (!root_od) {\n\t\t\t\tgf_fprintf(sdump->trace, \"  <Replace>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (sdump->dump_mode==GF_SM_DUMP_VRML) {\n\t\t\t\tgf_fprintf(sdump->trace, \"#VRML V2.0\\n\");\n\t\t\t} else {\n\t\t\t\t/*dump root OD*/\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\t\tif (root_od) gf_odf_dump_desc(root_od, sdump->trace, 0, 0);\n#endif\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t} else {\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<!DOCTYPE X3D PUBLIC \\\"ISO//Web3D//DTD X3D 3.0//EN\\\" \\\"http://www.web3d.org/specifications/x3d-3.0.dtd\\\">\\n\");\n\t\t\tgf_fprintf(sdump->trace, \"<X3D xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsd:noNamespaceSchemaLocation=\\\"http://www.web3d.org/specifications/x3d-3.0.xsd\\\" version=\\\"3.0\\\">\\n\");\n\t\t\tgf_fprintf(sdump->trace, \"<head>\\n\");\n\t\t\tgf_fprintf(sdump->trace, \"<meta content=\\\"X3D File Converted/Dumped by GPAC Version %s - %s\\\" name=\\\"generator\\\"/>\\n\", gf_gpac_version(), gf_gpac_copyright() );\n\t\t\tgf_fprintf(sdump->trace, \"</head>\\n\");\n\t\t\tgf_fprintf(sdump->trace, \" <Scene>\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"#X3D V3.0\\n\\n\");\n\t\t}\n\t}\n}\n\nstatic void gf_dump_finalize(GF_SceneDumper *sdump, GF_Descriptor *root_od)\n{\n\tif (sdump->dump_mode==GF_SM_DUMP_SVG) return;\n\n\tif (sdump->LSRDump) {\n\t\tgf_fprintf(sdump->trace, \"<saf:endOfSAFSession/>\\n</saf:SAFSession>\\n\");\n\t\treturn;\n\t}\n\tif (!sdump->XMLDump) return;\n\n\tif (!sdump->X3DDump) {\n\t\tif (!root_od) {\n\t\t\tgf_fprintf(sdump->trace, \"  </Replace>\\n\");\n\t\t}\n\t\tgf_fprintf(sdump->trace, \" </Body>\\n\");\n\t\tgf_fprintf(sdump->trace, \"</XMT-A>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \" </Scene>\\n\");\n\t\tgf_fprintf(sdump->trace, \"</X3D>\\n\");\n\t}\n}\n\nstatic Bool gf_dump_vrml_is_def_node(GF_SceneDumper *sdump, GF_Node *node)\n{\n\ts32 i = gf_list_find(sdump->dump_nodes, node);\n\tif (i>=0) return 0;\n\tgf_list_add(sdump->dump_nodes, node);\n\treturn 1;\n}\n\nstatic GF_Node *gf_dump_find_node(GF_SceneDumper *sdump, u32 ID)\n{\n\tGF_Node *ret = gf_sg_find_node(sdump->sg, ID);\n\tif (ret) return ret;\n\treturn NULL;\n}\n\n#define DUMP_IND(sdump)\t\\\n\tif (sdump->trace) {\t\t\\\n\t\tu32 z;\t\\\n\t\tfor (z=0; z<sdump->indent; z++) gf_fprintf(sdump->trace, \"%c\", sdump->ind_char);\t\\\n\t}\n\n\nstatic void StartElement(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tDUMP_IND(sdump);\n\tif (!sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"%s {\\n\", name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"<%s\", name);\n\t}\n}\n\nstatic void EndElementHeader(GF_SceneDumper *sdump, Bool has_sub_el)\n{\n\tif (!sdump->trace) return;\n\tif (sdump->XMLDump) {\n\t\tif (has_sub_el) {\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t}\n\t}\n}\n\nstatic void EndElement(GF_SceneDumper *sdump, const char *name, Bool had_sub_el)\n{\n\tif (!sdump->trace) return;\n\tif (!sdump->XMLDump) {\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t} else {\n\t\tif (had_sub_el) {\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</%s>\\n\", name);\n\t\t}\n\t}\n}\n\nstatic void StartAttribute(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tif (!sdump->XMLDump) {\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"%s \", name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", name);\n\t}\n}\n\nstatic void EndAttribute(GF_SceneDumper *sdump)\n{\n\tif (!sdump->trace) return;\n\tif (!sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t}\n}\n\n\nstatic void StartList(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tDUMP_IND(sdump);\n\tif (!sdump->XMLDump) {\n\t\tif (name)\n\t\t\tgf_fprintf(sdump->trace, \"%s [\\n\", name);\n\t\telse\n\t\t\tgf_fprintf(sdump->trace, \"[\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"<%s>\\n\", name);\n\t}\n}\n\nstatic void EndList(GF_SceneDumper *sdump, const char *name)\n{\n\tif (!sdump->trace) return;\n\tDUMP_IND(sdump);\n\tif (!sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"</%s>\\n\", name);\n\t}\n}\n\n\nstatic void scene_dump_utf_string(GF_SceneDumper *sdump, Bool escape_xml, char *str)\n{\n\tu32 len, i;\n\tu16 *uniLine;\n\tif (!str) return;\n\tlen = (u32) strlen(str);\n\tif (!len) return;\n\tuniLine = (u16*)gf_malloc(sizeof(u16) * len*4);\n\tlen = gf_utf8_mbstowcs(uniLine, len, (const char **) &str);\n\tif (len != GF_UTF8_FAIL) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\t//if (uniLine[i] == (u16) '\\\"') gf_fprintf(sdump->trace, \"\\\\\");\n\t\t\tswitch (uniLine[i]) {\n\t\t\tcase '\\'':\n\t\t\t\tif (escape_xml) gf_fprintf(sdump->trace, \"&apos;\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"'\");\n\t\t\t\tbreak;\n\t\t\tcase '\\\"':\n\t\t\t\tif (escape_xml) gf_fprintf(sdump->trace, \"&quot;\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"\\\"\");\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\tgf_fprintf(sdump->trace, \"&amp;\");\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tgf_fprintf(sdump->trace, \"&gt;\");\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tgf_fprintf(sdump->trace, \"&lt;\");\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\t\t/* Does nothing : gf_fprintf(sdump->trace, \"\");, fflush instead ?*/\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (uniLine[i]<128) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"%c\", (u8) uniLine[i]);\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"&#%d;\", uniLine[i]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tgf_free(uniLine);\n}\n\n#ifndef GPAC_DISABLE_VRML\n\nstatic void scene_dump_vrml_id(GF_SceneDumper *sdump, GF_Node *node)\n{\n\tu32 id;\n\tconst char *node_name;\n\tif (!sdump->trace) return;\n\t/*FIXME - optimize id/name fetch*/\n\tnode_name = gf_node_get_name_and_id(node, &id);\n\tif (node_name)\n\t\tgf_fprintf(sdump->trace, \"%s\", node_name);\n\telse\n\t\tgf_fprintf(sdump->trace, \"N%d\", id - 1);\n}\n\nstatic Bool scene_dump_vrml_find_route_name(GF_SceneDumper *sdump, u32 ID, const char **outName)\n{\n\tGF_Route *r;\n\tu32 i;\n\tGF_Command *com;\n\tr = gf_sg_route_find(sdump->sg, ID);\n\tif (r) {\n\t\t(*outName) = r->name;\n\t\treturn 1;\n\t}\n\n\ti=0;\n\twhile ((com = (GF_Command *)gf_list_enum(sdump->inserted_routes, &i))) {\n\t\tif (com->tag == GF_SG_ROUTE_INSERT) {\n\t\t\tif (com->RouteID==ID) {\n\t\t\t\t(*outName) = com->def_name;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (!sdump->current_com_list) return 0;\n\ti=1;\n\twhile ((com = (GF_Command *)gf_list_enum(sdump->current_com_list, &i))) {\n\t\tif ((com->tag == GF_SG_ROUTE_INSERT) || (com->tag == GF_SG_ROUTE_REPLACE)) {\n\t\t\tif (com->RouteID==ID) {\n\t\t\t\t(*outName) = com->def_name;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else return 0;\n\t}\n\treturn 0;\n}\n\nstatic void scene_dump_vrml_route_id(GF_SceneDumper *sdump, u32 routeID, char *rName)\n{\n\tif (!sdump->trace) return;\n\tif (!rName) scene_dump_vrml_find_route_name(sdump, routeID, (const char **) &rName);\n\n\tif (rName)\n\t\tgf_fprintf(sdump->trace, \"%s\", rName);\n\telse\n\t\tgf_fprintf(sdump->trace, \"R%d\", routeID - 1);\n}\n\n\nstatic void gf_dump_vrml_sffield(GF_SceneDumper *sdump, u32 type, void *ptr, Bool is_mf, GF_Node *node)\n{\n\tswitch (type) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\tgf_fprintf(sdump->trace, \"%s\", * ((SFBool *)ptr) ? \"true\" : \"false\");\n\t\tbreak;\n\tcase GF_SG_VRML_SFINT32:\n\t\tgf_fprintf(sdump->trace, \"%d\", * ((SFInt32 *)ptr) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\tgf_fprintf(sdump->trace, \"%g\", FIX2FLT( * ((SFFloat *)ptr) ) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFDOUBLE:\n\t\tgf_fprintf(sdump->trace, \"%g\", * ((SFDouble *)ptr) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFTIME:\n\t\tgf_fprintf(sdump->trace, \"%g\", * ((SFTime *)ptr) );\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g\", FIX2FLT( ((SFColor *)ptr)->red ), FIX2FLT( ((SFColor *)ptr)->green ), FIX2FLT( ((SFColor *)ptr)->blue ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLORRGBA:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g %g\", FIX2FLT( ((SFColorRGBA *)ptr)->red ), FIX2FLT( ((SFColorRGBA *)ptr)->green ), FIX2FLT( ((SFColorRGBA *)ptr)->blue ), FIX2FLT( ((SFColorRGBA *)ptr)->alpha ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\tgf_fprintf(sdump->trace, \"%g %g\", FIX2FLT( ((SFVec2f *)ptr)->x ), FIX2FLT( ((SFVec2f *)ptr)->y ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC2D:\n\t\tgf_fprintf(sdump->trace, \"%g %g\", ((SFVec2d *)ptr)->x, ((SFVec2d *)ptr)->y);\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g\", FIX2FLT( ((SFVec3f *)ptr)->x ), FIX2FLT( ((SFVec3f *)ptr)->y ), FIX2FLT( ((SFVec3f *)ptr)->z ));\n\t\tbreak;\n\tcase GF_SG_VRML_SFVEC3D:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g\", ((SFVec3d *)ptr)->x, ((SFVec3d *)ptr)->y, ((SFVec3d *)ptr)->z);\n\t\tbreak;\n\tcase GF_SG_VRML_SFROTATION:\n\t\tgf_fprintf(sdump->trace, \"%g %g %g %g\", FIX2FLT( ((SFRotation *)ptr)->x ), FIX2FLT( ((SFRotation *)ptr)->y ), FIX2FLT( ((SFRotation *)ptr)->z ), FIX2FLT( ((SFRotation *)ptr)->q ) );\n\t\tbreak;\n\n\tcase GF_SG_VRML_SFATTRREF:\n\t{\n\t\tSFAttrRef *ar = (SFAttrRef *)ptr;\n\t\tif (ar->node) {\n\t\t\tGF_FieldInfo pinfo;\n\t\t\tgf_node_get_field(ar->node, ar->fieldIndex, &pinfo);\n\t\t\tscene_dump_vrml_id(sdump, ar->node);\n\t\t\tgf_fprintf(sdump->trace, \".%s\", pinfo.name);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFSCRIPT:\n\t{\n\t\tu32 len, i;\n\t\tchar *str;\n\t\tstr = (char*)((SFScript *)ptr)->script_text;\n\t\tif (!str) {\n\t\t\tif (!sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\\\"\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlen = (u32)strlen(str);\n\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"\\\"%s\\\"\", str);\n\t\t}\n\t\telse {\n\t\t\tu16 *uniLine;\n\n\t\t\tuniLine = (u16*)gf_malloc(sizeof(short) * (len + 1));\n\t\t\tlen = gf_utf8_mbstowcs(uniLine, len, (const char **)&str);\n\n\t\t\tif (len != GF_UTF8_FAIL) {\n\t\t\t\tfor (i = 0; i<len; i++) {\n\n\t\t\t\t\tswitch (uniLine[i]) {\n\t\t\t\t\tcase '&':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&amp;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '<':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&lt;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '>':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&gt;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '\\'':\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&apos;\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t/*FIXME: how the heck can we preserve newlines and spaces of JavaScript in\n\t\t\t\t\t\tan XML attribute in any viewer ? */\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (uniLine[i]<128) {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"%c\", (u8)uniLine[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"&#%d;\", uniLine[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\tgf_free(uniLine);\n\t}\n\t\tDUMP_IND(sdump);\n\t}\n\tbreak;\n\n\tcase GF_SG_VRML_SFSTRING:\n\t{\n\t\tchar *str;\n\t\tif (sdump->XMLDump) {\n\t\t\tif (is_mf) gf_fprintf(sdump->trace, sdump->X3DDump ? \"\\\"\" : \"&quot;\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t\t}\n\t\t/*dump in unicode*/\n\t\tstr = ((SFString *)ptr)->buffer;\n\n\t\tif (node && (gf_node_get_tag(node)==TAG_MPEG4_BitWrapper)) {\n\t\t\tu32 bufsize = 37 + ((M_BitWrapper*)node)->buffer_len * 2 + 3;\n\t\t\tstr = gf_malloc(sizeof(char) * bufsize);\n\t\t\tif (str) {\n\t\t\t\ts32 res;\n\t\t\t\tstrcpy(str, \"data:application/octet-string;base64,\");\n\t\t\t\tres = gf_base64_encode(((M_BitWrapper*)node)->buffer.buffer, ((M_BitWrapper*)node)->buffer_len, str+37, bufsize-37);\n\t\t\t\tif (res<0) {\n\t\t\t\t\tgf_free(str);\n\t\t\t\t\tstr = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tstr[res+37] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (str && str[0]) {\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tscene_dump_utf_string(sdump, 1, str);\n\t\t\t} else if (!strchr(str, '\\\"')) {\n\t\t\t\tgf_fprintf(sdump->trace, \"%s\", str);\n\t\t\t} else {\n\t\t\t\tu32 i, len = (u32)strlen(str);\n\t\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\t\tif (str[i]=='\\\"') gf_fputc('\\\\', sdump->trace);\n\t\t\t\t\tgf_fputc(str[i], sdump->trace);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (node && (gf_node_get_tag(node)==TAG_MPEG4_BitWrapper)) {\n\t\t\tif (str) gf_free(str);\n\t\t}\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (is_mf) gf_fprintf(sdump->trace, sdump->X3DDump ? \"\\\"\" : \"&quot;\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t\t}\n\t}\n\tbreak;\n\n\tcase GF_SG_VRML_SFURL:\n\t\tif (((SFURL *)ptr)->url) {\n#if 0\n\t\t\tu32 len;\n\t\t\tchar *str;\n\t\t\tshort uniLine[5000];\n\t\t\tstr = ((SFURL *)ptr)->url;\n\t\t\tlen = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &str);\n\t\t\tif (len != GF_UTF8_FAIL) {\n\t\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n\t\t\t\tfwprintf(sdump->trace, (unsigned short *) uniLine);\n\t\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n\t\t\t}\n#else\n\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n\t\t\tgf_fprintf(sdump->trace, \"%s\", ((SFURL *)ptr)->url);\n\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? (sdump->X3DDump ?  \"'\" : \"&quot;\") : \"\\\"\");\n#endif\n\t\t} else {\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"&quot;od://od%d&quot;\", ((SFURL *)ptr)->OD_ID);\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"od:%d\", ((SFURL *)ptr)->OD_ID);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_SG_VRML_SFIMAGE:\n\t{\n\t\tu32 i, count;\n\t\tSFImage *img = (SFImage *)ptr;\n\t\tgf_fprintf(sdump->trace, \"%d %d %d\", img->width, img->height, img->numComponents);\n\t\tcount = img->width * img->height * img->numComponents;\n\t\tfor (i=0; i<count; ) {\n\t\t\tswitch (img->numComponents) {\n\t\t\tcase 1:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X\", img->pixels[i]);\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X%02X\", img->pixels[i], img->pixels[i+1]);\n\t\t\t\ti+=2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X%02X%02X\", img->pixels[i], img->pixels[i+1], img->pixels[i+2]);\n\t\t\t\ti+=3;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tgf_fprintf(sdump->trace, \" 0x%02X%02X%02X%02X\", img->pixels[i], img->pixels[i+1], img->pixels[i+2], img->pixels[i+3]);\n\t\t\t\ti+=4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\t}\n}\n\n\nstatic void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}\n\nstatic void gf_dump_vrml_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tBool needs_field_container;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\t\tEndElementHeader(sdump, 1);\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tif (!sdump->X3DDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tneeds_field_container = 0;\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tu32 count, nb_ndt;\n\t\t\tGF_FieldInfo info;\n\t\t\tif (!strcmp(field.name, \"children\")) {\n\t\t\t\tneeds_field_container = 0;\n\t\t\t} else {\n\t\t\t\tnb_ndt = 0;\n\t\t\t\tcount = gf_node_get_field_count(node);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tgf_node_get_field(node, i, &info);\n\t\t\t\t\tif ((info.eventType==GF_SG_EVENT_IN) || (info.eventType==GF_SG_EVENT_OUT)) continue;\n\t\t\t\t\tif (info.NDTtype==field.NDTtype) nb_ndt++;\n\t\t\t\t}\n\t\t\t\tneeds_field_container = (nb_ndt>1) ? 1 : 0;\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_X3D\n\t\tif (!sdump->X3DDump) {\n\t\t\tif (gf_node_get_tag(node)==TAG_X3D_Switch) field.name = \"choice\";\n\t\t}\n#endif\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert(list);\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) StartList(sdump, field.name);\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, needs_field_container ? (char *) field.name : NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (!sdump->XMLDump || !sdump->X3DDump) EndList(sdump, field.name);\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t{\n\t\tSFCommandBuffer *cb = (SFCommandBuffer *)field.far_ptr;\n\t\tStartElement(sdump, (char *) field.name);\n\t\tEndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t\tif (!gf_list_count(cb->commandList)) {\n\t\t\t/*the arch does not allow for that (we would need a codec and so on, or decompress the command list\n\t\t\tin all cases...)*/\n\t\t\tif (sdump->trace && cb->bufferSize) {\n\t\t\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"<!--SFCommandBuffer cannot be dumped while playing - use MP4Box instead-->\\n\");\n\t\t\t\telse gf_fprintf(sdump->trace, \"#SFCommandBuffer cannot be dumped while playing - use MP4Box instead\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent, 0);\n\t\t}\n\t\tsdump->indent--;\n\t\tEndElement(sdump, (char *) field.name, 1);\n\t}\n\treturn;\n\n\tcase GF_SG_VRML_MFATTRREF:\n\t\tif (sdump->XMLDump) {\n\t\t\tMFAttrRef *ar = (MFAttrRef *)field.far_ptr;\n\t\t\tStartElement(sdump, (char *) field.name);\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\n\t\t\tfor (i=0; i<ar->count; i++) {\n\t\t\t\tif (ar->vals[i].node) {\n\t\t\t\t\tGF_FieldInfo pinfo;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tgf_node_get_field(ar->vals[i].node, ar->vals[i].fieldIndex, &pinfo);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<store node=\\\"\");\n\t\t\t\t\tscene_dump_vrml_id(sdump, ar->vals[i].node);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\" field=\\\"%s\\\"/>\\n\", pinfo.name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, (char *) field.name, 1);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tStartAttribute(sdump, field.name);\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\tEndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\'\", (char *) field.name);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tStartAttribute(sdump, field.name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tStartAttribute(sdump, field.name);\n\t\t}\n\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"[\");\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, node);\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"]\");\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) {\n\t\t\tswitch (sf_type) {\n\t\t\tcase GF_SG_VRML_SFSTRING:\n\t\t\tcase GF_SG_VRML_SFSCRIPT:\n\t\t\tcase GF_SG_VRML_SFURL:\n\t\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}\n\nstatic const char *GetXMTFieldTypeName(u32 fieldType)\n{\n\tswitch (fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\treturn \"Boolean\";\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn \"Integer\";\n\tcase GF_SG_VRML_SFCOLOR:\n\t\treturn \"Color\";\n\tcase GF_SG_VRML_SFVEC2F:\n\t\treturn \"Vector2\";\n\tcase GF_SG_VRML_SFIMAGE:\n\t\treturn \"Image\";\n\tcase GF_SG_VRML_SFTIME:\n\t\treturn \"Time\";\n\tcase GF_SG_VRML_SFFLOAT:\n\t\treturn \"Float\";\n\tcase GF_SG_VRML_SFVEC3F:\n\t\treturn \"Vector3\";\n\tcase GF_SG_VRML_SFROTATION:\n\t\treturn \"Rotation\";\n\tcase GF_SG_VRML_SFSTRING:\n\t\treturn \"String\";\n\tcase GF_SG_VRML_SFNODE:\n\t\treturn \"Node\";\n\tcase GF_SG_VRML_MFBOOL:\n\t\treturn \"Booleans\";\n\tcase GF_SG_VRML_MFINT32:\n\t\treturn \"Integers\";\n\tcase GF_SG_VRML_MFCOLOR:\n\t\treturn \"Colors\";\n\tcase GF_SG_VRML_MFVEC2F:\n\t\treturn \"Vector2Array\";\n\tcase GF_SG_VRML_MFIMAGE:\n\t\treturn \"Images\";\n\tcase GF_SG_VRML_MFTIME:\n\t\treturn \"Times\";\n\tcase GF_SG_VRML_MFFLOAT:\n\t\treturn \"Floats\";\n\tcase GF_SG_VRML_MFVEC3F:\n\t\treturn \"Vector3Array\";\n\tcase GF_SG_VRML_MFROTATION:\n\t\treturn \"Rotations\";\n\tcase GF_SG_VRML_MFSTRING:\n\t\treturn \"Strings\";\n\tcase GF_SG_VRML_MFNODE:\n\t\treturn \"Nodes\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\nstatic const char *GetXMTFieldTypeValueName(u32 fieldType)\n{\n\tswitch (fieldType) {\n\tcase GF_SG_VRML_SFBOOL:\n\t\treturn \"booleanValue\";\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn \"intValue\";\n\tcase GF_SG_VRML_SFCOLOR:\n\t\treturn \"colorValue\";\n\tcase GF_SG_VRML_SFVEC2F:\n\t\treturn \"vector2Value\";\n\tcase GF_SG_VRML_SFIMAGE:\n\t\treturn \"imageValue\";\n\tcase GF_SG_VRML_SFTIME:\n\t\treturn \"timeValue\";\n\tcase GF_SG_VRML_SFFLOAT:\n\t\treturn \"floatValue\";\n\tcase GF_SG_VRML_SFVEC3F:\n\t\treturn \"vector3Value\";\n\tcase GF_SG_VRML_SFROTATION:\n\t\treturn \"rotationValue\";\n\tcase GF_SG_VRML_SFSTRING:\n\t\treturn \"stringValue\";\n\tcase GF_SG_VRML_MFBOOL:\n\t\treturn \"booleanArrayValue\";\n\tcase GF_SG_VRML_MFINT32:\n\t\treturn \"intArrayValue\";\n\tcase GF_SG_VRML_MFCOLOR:\n\t\treturn \"colorArrayValue\";\n\tcase GF_SG_VRML_MFVEC2F:\n\t\treturn \"vector2ArrayValue\";\n\tcase GF_SG_VRML_MFIMAGE:\n\t\treturn \"imageArrayValue\";\n\tcase GF_SG_VRML_MFTIME:\n\t\treturn \"timeArrayValue\";\n\tcase GF_SG_VRML_MFFLOAT:\n\t\treturn \"floatArrayValue\";\n\tcase GF_SG_VRML_MFVEC3F:\n\t\treturn \"vector3ArrayValue\";\n\tcase GF_SG_VRML_MFROTATION:\n\t\treturn \"rotationArrayValue\";\n\tcase GF_SG_VRML_MFSTRING:\n\t\treturn \"stringArrayValue\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n/*field dumping for proto declaration and Script*/\nstatic void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tif (!sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\tsdump->indent++;\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"<node>\");\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</node>\");\n\t\t\t\t\t\tsdump->indent--;\n\t\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (field.far_ptr) {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\t\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tif (field.far_ptr)\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\t\t} else if (field.far_ptr) {\n\t\t\t\t\tgf_dump_vrml_simple_field(sdump, field, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t} else if (field.far_ptr) {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"%s %s %s\", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name);\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tgf_fprintf(sdump->trace, \" [\");\n\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\twhile (l) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, l->node, 1, NULL);\n\t\t\t\t\t\tl = l->next;\n\t\t\t\t\t}\n\t\t\t\t\tsdump->indent--;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" accessType=\\\"%s\\\"\",\n\t\t\t\t        field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1));\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<field name=\\\"%s\\\" type=\\\"%s\\\" vrml97Hint=\\\"%s\\\"\",\n\t\t\t\t        field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0));\n\t\t\t}\n\n\t\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\t\twhile (list) {\n\t\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\t\tlist = list->next;\n\t\t\t\t\t}\n\t\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\t\tsdump->indent++;\n\t\t\t\t\tDUMP_IND(sdump);\n\t\t\t\t\tif (!has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (has_sublist)\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/*field dumping for proto instance*/\nstatic void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)\n{\n\tu32 i, sf_type;\n\tvoid *slot_ptr;\n\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (field.fieldType == GF_SG_VRML_SFNODE) {\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\tsdump->indent++;\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<node>\");\n\t\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</node>\");\n\t\t\tsdump->indent--;\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t} else {\n\t\t\tif (sdump->X3DDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t}\n\t\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);\n\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t}\n\t} else {\n\t\tGenMFField *mffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t\tif ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {\n\t\t\tif (sf_type == GF_SG_VRML_SFNODE) {\n\t\t\t\tGF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;\n\t\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");\n\t\t\t\twhile (list) {\n\t\t\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\t\t\tlist = list->next;\n\t\t\t\t}\n\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic GF_Route *gf_dump_vrml_get_IS(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(sdump->current_proto->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif ((r->ToNode==node) && (r->ToField.fieldIndex==field->fieldIndex)) return r;\n\t}\n\tif (!node || !node->sgprivate->interact || !node->sgprivate->interact->routes) return NULL;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(node->sgprivate->interact->routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromField.fieldIndex == field->fieldIndex) return r;\n\t}\n\treturn NULL;\n}\n\nstatic void gf_dump_vrml_IS_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool isScript, Bool skip_is)\n{\n\tGF_FieldInfo pfield;\n\n\tGF_Route *r = gf_dump_vrml_get_IS(sdump, node, &field);\n\tif (r->FromNode) {\n\t\tpfield.fieldIndex = r->ToField.fieldIndex;\n\t\tgf_sg_proto_get_field(sdump->current_proto, NULL, &pfield);\n\t} else {\n\t\tpfield.fieldIndex = r->FromField.fieldIndex;\n\t\tgf_sg_proto_get_field(sdump->current_proto, NULL, &pfield);\n\t}\n\n\tif (!sdump->XMLDump) {\n\t\tDUMP_IND(sdump);\n\t\tif (isScript) gf_fprintf(sdump->trace, \"%s %s \", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType));\n\t\tgf_fprintf(sdump->trace, \"%s IS %s\\n\", field.name, pfield.name);\n\t} else {\n\t\tif (!skip_is) {\n\t\t\tStartElement(sdump, \"IS\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"<connect nodeField=\\\"%s\\\" protoField=\\\"%s\\\"/>\\n\", field.name, pfield.name);\n\t\tif (!skip_is) {\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"IS\", 1);\n\t\t}\n\t}\n}\n\nstatic Bool scene_dump_vrml_can_dump(GF_SceneDumper *sdump, GF_Node *node)\n{\n#ifndef GPAC_DISABLE_VRML\n\tu32 tag;\n\n\tif (node->sgprivate->tag==TAG_ProtoNode) return 1;\n\n\tif (sdump->X3DDump || (sdump->dump_mode==GF_SM_DUMP_VRML)) {\n\t\tif (node->sgprivate->tag>=GF_NODE_RANGE_FIRST_X3D) return 1;\n\t\tif (node->sgprivate->tag==TAG_MPEG4_Rectangle) return 1;\n\t\tif (node->sgprivate->tag==TAG_MPEG4_Circle) return 1;\n#ifndef GPAC_DISABLE_X3D\n\t\ttag = gf_node_x3d_type_by_class_name(gf_node_get_class_name(node));\n\t\treturn tag ? 1 : 0;\n#else\n\t\treturn 0;\n#endif\n\t} else {\n\t\tif (node->sgprivate->tag<=GF_NODE_RANGE_LAST_MPEG4) return 1;\n#ifndef GPAC_DISABLE_X3D\n\t\tif (node->sgprivate->tag==TAG_X3D_Rectangle2D) return 1;\n\t\tif (node->sgprivate->tag==TAG_X3D_Circle2D) return 1;\n#endif\n\t\ttag = gf_node_mpeg4_type_by_class_name(gf_node_get_class_name(node));\n\t\treturn tag ? 1 : 0;\n\t}\n#else\n\treturn 1;\n#endif\n}\n\nstatic void gf_dump_vrml_node(GF_SceneDumper *sdump, GF_Node *node, Bool in_list, char *fieldContainer)\n{\n\tu32 i, count, to_dump, sub_el, ID;\n\tu32 *def_fields;\n\tBool isDEF, isScript, isProto, hasISed;\n\tchar *name;\n\tGF_Node *base;\n\tGF_FieldInfo field, base_field;\n\n\tif (!node) {\n\t\tgf_fprintf(sdump->trace, \"NULL\");\n\t\treturn;\n\t}\n\n\t/*this dumper works only for VRML like graphs*/\n\tif (node->sgprivate->tag>GF_NODE_RANGE_LAST_X3D) return;\n\n\tif (!scene_dump_vrml_can_dump(sdump, node)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[Scene Dump] node %s not part of %s standard - removing\\n\", gf_node_get_class_name(node), sdump->X3DDump ? \"X3D\" : (sdump->dump_mode==GF_SM_DUMP_VRML) ? \"VRML\" : \"MPEG4\"));\n\t\tif (!in_list) gf_fprintf(sdump->trace, \"NULL\");\n\t\treturn;\n\t}\n\n\t/*convert whatever possible*/\n\tname = (char*)gf_node_get_class_name(node);\n#ifndef GPAC_DISABLE_VRML\n\tif (sdump->X3DDump) {\n\t\tif (node->sgprivate->tag == TAG_MPEG4_Circle) name = \"Circle2D\";\n\t\telse if (node->sgprivate->tag == TAG_MPEG4_Rectangle) name = \"Rectangle2D\";\n#ifndef GPAC_DISABLE_X3D\n\t} else {\n\t\tif (node->sgprivate->tag == TAG_X3D_Circle2D) name = \"Circle\";\n\t\telse if (node->sgprivate->tag == TAG_X3D_Rectangle2D) name = \"Rectangle\";\n#endif\n\t}\n#endif\n\n\n\n\tisProto = (gf_node_get_tag(node) == TAG_ProtoNode) ? 1 : 0;\n\tID = gf_node_get_id(node);\n\tisDEF = 0;\n\tif (ID) {\n\t\tisDEF = gf_dump_vrml_is_def_node(sdump, node);\n\t\tif (!isDEF) {\n\t\t\tif (!sdump->XMLDump) {\n\t\t\t\tif (in_list) DUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"USE \");\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tif (in_list) gf_fprintf(sdump->trace, \"\\n\");\n\t\t\t} else {\n\t\t\t\tif (isProto) {\n\t\t\t\t\tStartElement(sdump, \"ProtoInstance\");\n\t\t\t\t\tStartAttribute(sdump, \"name\");\n\t\t\t\t\tgf_fprintf(sdump->trace, \"%s\", name);\n\t\t\t\t\tEndAttribute(sdump);\n\t\t\t\t} else {\n\t\t\t\t\tStartElement(sdump, name);\n\t\t\t\t}\n\t\t\t\tStartAttribute(sdump, \"USE\");\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tEndAttribute(sdump);\n\t\t\t\tEndElementHeader(sdump, 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*get all fields*/\n\tcount = gf_node_get_field_count(node);\n\tdef_fields = (u32*)gf_malloc(sizeof(u32) * count);\n\n\tbase = NULL;\n\tswitch (gf_node_get_tag(node)) {\n#ifndef GPAC_DISABLE_VRML\n#ifndef GPAC_DISABLE_X3D\n\tcase TAG_X3D_Script:\n#endif\n\tcase TAG_MPEG4_Script:\n\t\tisScript = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tisScript = 0;\n\t\tbreak;\n\t}\n\n\n\tif (!isScript) {\n\t\tif (isProto) {\n\t\t\tbase = gf_sg_proto_create_instance(node->sgprivate->scenegraph, ((GF_ProtoInstance *)node)->proto_interface);\n\t\t} else {\n\t\t\tbase = gf_node_new(node->sgprivate->scenegraph, node->sgprivate->tag);\n\t\t}\n\t}\n\n\tif (base) gf_node_register(base, NULL);\n\n\thasISed = 0;\n\tto_dump = sub_el = 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (isScript) {\n\t\t\t/*dyn script fields are complex types*/\n\t\t\tdef_fields[i] = (i>2) ? 2 : 1;\n\t\t} else {\n\t\t\tdef_fields[i] = 0;\n\t\t}\n\n\t\tgf_node_get_field(node, i, &field);\n\n\t\tif (sdump->current_proto) {\n\t\t\tif (gf_dump_vrml_get_IS(sdump, node, &field) != NULL) {\n\t\t\t\tdef_fields[i] = 3;\n\t\t\t\tif ((field.fieldType == GF_SG_VRML_SFNODE) || (field.fieldType == GF_SG_VRML_MFNODE))\n\t\t\t\t\tdef_fields[i] = sdump->XMLDump ? 4 : 3;\n\t\t\t\t/*in XMT the ISed is not an attribute*/\n\t\t\t\tif (sdump->XMLDump) sub_el++;\n\t\t\t\tto_dump++;\n\t\t\t\thasISed = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!isScript && ((field.eventType == GF_SG_EVENT_IN) || (field.eventType == GF_SG_EVENT_OUT)) ) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*proto instance in XMT lists all fields as elements*/\n\t\tif (sdump->XMLDump && isProto) {\n\t\t\tdef_fields[i] = 2;\n\t\t\tto_dump++;\n\t\t\tsub_el++;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (field.fieldType) {\n\t\tcase GF_SG_VRML_SFNODE:\n\t\t\tif (* (GF_Node **) field.far_ptr) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_MFNODE:\n\t\t\tif (* (GF_ChildNodeItem**) field.far_ptr) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\t{\n\t\t\tSFCommandBuffer *p = (SFCommandBuffer *)field.far_ptr;\n\t\t\tif (p->bufferSize || gf_list_count(p->commandList)) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase GF_SG_VRML_MFATTRREF:\n\t\t{\n\t\t\tMFAttrRef *p = (MFAttrRef*)field.far_ptr;\n\t\t\tif (p->count) {\n\t\t\t\tdef_fields[i] = 2;\n\t\t\t\tto_dump++;\n\t\t\t\tsub_el++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tif (isScript) {\n\t\t\t\tto_dump++;\n\t\t\t} else {\n\t\t\t\tgf_node_get_field(base, i, &base_field);\n\t\t\t\tif (!gf_sg_vrml_field_equal(base_field.far_ptr, field.far_ptr, field.fieldType)) {\n\t\t\t\t\tdef_fields[i] = 1;\n\t\t\t\t\tto_dump++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (base) gf_node_unregister(base, NULL);\n\n\tif (!to_dump) {\n\t\tif (in_list) DUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tif (isDEF) {\n\t\t\t\tgf_fprintf(sdump->trace, \"DEF \");\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \"%s {}\\n\", name);\n\t\t} else {\n\t\t\tif (isDEF) {\n\t\t\t\tif (isProto) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<ProtoInstance name=\\\"%s\\\" DEF=\\\"\", name);\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<%s DEF=\\\"\", name);\n\t\t\t\t}\n\t\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t} else {\n\t\t\t\tif (isProto) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<ProtoInstance name=\\\"%s\\\"/>\\n\", name);\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<%s/>\\n\", name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_free(def_fields);\n\t\treturn;\n\t}\n\n\tif (!sdump->XMLDump) {\n\t\tif (in_list) DUMP_IND(sdump);\n\t\tif (isDEF) {\n\t\t\tgf_fprintf(sdump->trace, \"DEF \");\n\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t}\n\t\tgf_fprintf(sdump->trace, \"%s {\\n\", name);\n\t} else {\n\t\tif (isProto) {\n\t\t\tStartElement(sdump, \"ProtoInstance\");\n\t\t\tStartAttribute(sdump, \"name\");\n\t\t\tgf_fprintf(sdump->trace, \"%s\", name);\n\t\t\tEndAttribute(sdump);\n\t\t} else {\n\t\t\tStartElement(sdump, name);\n\t\t}\n\t\tif (isDEF) {\n\t\t\tStartAttribute(sdump, \"DEF\");\n\t\t\tscene_dump_vrml_id(sdump, node);\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n\n\tsdump->indent ++;\n\tfor (i=0; i<count; i++) {\n\t\tswitch (def_fields[i]) {\n\t\t/*regular field*/\n\t\tcase 1:\n\t\t\tgf_node_get_field(node, i, &field);\n\t\t\tif (!isScript) {\n\t\t\t\tgf_dump_vrml_field(sdump, node, field);\n\t\t\t}\n\t\t\t/*special script dump case, static fields except url*/\n\t\t\telse if (i==1 || i==2) {\n\t\t\t\tif (*((SFBool *)field.far_ptr)) gf_dump_vrml_field(sdump, node, field);\n\t\t\t}\n\t\t\t/*in bt first dump fields - in XMT first dump url*/\n\t\t\telse if (i && !sdump->XMLDump) {\n\t\t\t\tgf_dump_vrml_dyn_field(sdump, node, field, 0);\n\t\t\t} else if (!i && sdump->XMLDump) {\n\t\t\t\tgf_dump_vrml_field(sdump, node, field);\n\t\t\t}\n\t\t\tbreak;\n\t\t/*IS field*/\n\t\tcase 3:\n\t\t\tif (sdump->XMLDump) break;\n\t\t\tgf_node_get_field(node, i, &field);\n\t\t\tgf_dump_vrml_IS_field(sdump, node, field, isScript, 0);\n\t\t\tdef_fields[i] = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fieldContainer) gf_fprintf(sdump->trace, \" fieldContainer=\\\"%s\\\"\", fieldContainer);\n\n\tif (isScript) sub_el = 1;\n\tEndElementHeader(sdump, sub_el ? 1 : 0);\n\n\tif (sub_el) {\n\t\t/*dump all normal IS elements for XMT*/\n\t\tif (hasISed && sdump->XMLDump) {\n\t\t\tStartElement(sdump, \"IS\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (def_fields[i]==3) {\n\t\t\t\tgf_node_get_field(node, i, &field);\n\t\t\t\tgf_dump_vrml_IS_field(sdump, node, field, isScript, 1);\n\t\t\t}\n\t\t}\n\t\tif (hasISed && sdump->XMLDump) {\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"IS\", 1);\n\t\t}\n\t\t/*dump all sub elements and complex IS*/\n\t\tfor (i=0; i<count; i++) {\n\t\t\tswitch (def_fields[i]) {\n\t\t\tcase 2:\n\t\t\t\tgf_node_get_field(node, i, &field);\n\t\t\t\tif (!isScript) {\n\t\t\t\t\tif (isProto && sdump->XMLDump) {\n\t\t\t\t\t\tgf_dump_vrml_proto_field(sdump, node, field);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_dump_vrml_field(sdump, node, field);\n\t\t\t\t\t}\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_X3D\n\t\t\t\t\t/*X3D script metadata, NOT DYN*/\n\t\t\t\t\tif ((i==3) && (node->sgprivate->tag==TAG_X3D_Script) ) {\n\t\t\t\t\t\tif (*((GF_Node **)field.far_ptr)) gf_dump_vrml_field(sdump, node, field);\n\t\t\t\t\t} else\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tgf_dump_vrml_dyn_field(sdump, node, field, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tgf_node_get_field(node, i, &field);\n\t\t\t\tgf_dump_vrml_IS_field(sdump, node, field, isScript, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*finally dump script - XMT dumping is broken!!*/\n\tif (isScript && !sdump->XMLDump) {\n\t\tgf_node_get_field(node, 0, &field);\n\t\tgf_dump_vrml_field(sdump, node, field);\n\t}\n\n\tsdump->indent --;\n\tif (!sdump->XMLDump && !in_list) {\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\");\n\t} else {\n\t\tEndElement(sdump, isProto ? \"ProtoInstance\" : name, sub_el);\n\t}\n\tgf_free(def_fields);\n}\n\n\nstatic GF_Err DumpMultipleIndexedReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tu32 i;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tgf_node_get_field(com->node, inf->fieldIndex, &field);\n\tfield.fieldType = inf->fieldType;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace extended=\\\"indices\\\" atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\">\\n\", field.name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"MULTIPLEINDREPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s [\\n\", field.name);\n\t}\n\tsdump->indent++;\n\ti=0;\n\twhile ((inf = (GF_CommandField *) gf_list_enum(com->command_fields, &i))) {\n\t\tfield.far_ptr = inf->field_ptr;\n\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<repValue position=\\\"%d\\\" \", inf->pos);\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"%d BY \", inf->pos);\n\t\t}\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"/>\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t}\n\t}\n\tsdump->indent--;\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpMultipleReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tu32 i;\n\tGF_FieldInfo info;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace extended=\\\"fields\\\" atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\n\t\tsdump->indent++;\n\t\ti=0;\n\t\twhile ((inf = (GF_CommandField *) gf_list_enum(com->command_fields, &i))) {\n\t\t\tgf_node_get_field(com->node, inf->fieldIndex, &info);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (gf_sg_vrml_get_sf_type(info.fieldType) != GF_SG_VRML_SFNODE) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<repField atField=\\\"%s\\\" \", info.name);\n\t\t\t\tgf_dump_vrml_simple_field(sdump, info, com->node);\n\t\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"<repField>\");\n\t\t\t\tgf_dump_vrml_field(sdump, com->node, info);\n\t\t\t\tgf_fprintf(sdump->trace, \"</repField>\\n\");\n\t\t\t}\n\t\t}\n\t\tsdump->indent--;\n\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"MULTIPLEREPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \" {\\n\");\n\t\tsdump->indent++;\n\t\ti=0;\n\t\twhile ((inf = (GF_CommandField *) gf_list_enum(com->command_fields, &i))) {\n\t\t\tgf_node_get_field(com->node, inf->fieldIndex, &info);\n\t\t\tinfo.far_ptr = inf->field_ptr;\n\t\t\tgf_dump_vrml_field(sdump, com->node, info);\n\t\t}\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpGlobalQP(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace extended=\\\"globalQuant\\\">\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"GLOBALQP \");\n\t}\n\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Replace>\\n\");\n\telse gf_fprintf(sdump->trace, \"\\n\");\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpNodeInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_CommandField *inf;\n\tchar posname[20];\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tswitch (inf->pos) {\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tcase -1:\n\t\tstrcpy(posname, \"END\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Insert atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" position=\\\"%s\\\">\", posname);\n\t} else {\n\t\tif (inf->pos==-1) {\n\t\t\tgf_fprintf(sdump->trace, \"APPEND TO \");\n\t\t}\n\t\telse gf_fprintf(sdump->trace, \"INSERT AT \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".children\");\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \" \");\n\t}\n\n\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Insert>\");\n\tgf_fprintf(sdump->trace, \"\\n\");\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpRouteInsert(GF_SceneDumper *sdump, GF_Command *com, Bool is_scene_replace)\n{\n\tGF_Route r;\n\n\tmemset(&r, 0, sizeof(GF_Route));\n\tr.ID = com->RouteID;\n\tr.name = com->def_name;\n\tr.FromNode = gf_dump_find_node(sdump, com->fromNodeID);\n\tr.FromField.fieldIndex = com->fromFieldIndex;\n\tr.ToNode = gf_dump_find_node(sdump, com->toNodeID);\n\tr.ToField.fieldIndex = com->toFieldIndex;\n\n\tgf_list_add(sdump->inserted_routes, com);\n\n\tif (is_scene_replace) {\n\t\tgf_dump_vrml_route(sdump, &r, 0);\n\t} else {\n\t\tDUMP_IND(sdump);\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"<Insert>\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"INSERT \");\n\t\t}\n\t\tgf_dump_vrml_route(sdump, &r, 2);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Insert>\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpIndexInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_Err e;\n\tGF_FieldInfo field, sffield;\n\tGF_CommandField *inf;\n\tchar posname[20];\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tswitch (inf->pos) {\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tcase -1:\n\t\tstrcpy(posname, \"END\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Insert atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" position=\\\"%s\\\"\", field.name, posname);\n\t} else {\n\t\tif (inf->pos==-1) {\n\t\t\tgf_fprintf(sdump->trace, \"APPEND TO \");\n\t\t}\n\t\telse gf_fprintf(sdump->trace, \"INSERT AT \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \" \");\n\t}\n\n\tmemcpy(&sffield, &field, sizeof(GF_FieldInfo));\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\tif (field.fieldType==GF_SG_VRML_MFNODE) {\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\\n\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Insert>\");\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t} else {\n\t\tsffield.far_ptr = inf->field_ptr;\n\t\tgf_dump_vrml_simple_field(sdump, sffield, com->node);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"/>\");\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn e;\n}\n\nstatic GF_Err DumpIndexDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar posname[20];\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\tswitch (inf->pos) {\n\tcase -1:\n\t\tstrcpy(posname, sdump->XMLDump ? \"END\" : \"LAST\");\n\t\tbreak;\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\tgf_node_get_field(com->node, inf->fieldIndex, &field);\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Delete atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" position=\\\"%s\\\"/>\", field.name, posname);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"DELETE \");\n\t\tif (inf->pos==-1) gf_fprintf(sdump->trace, \"%s \", posname);\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpNodeDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tif (com->tag==GF_SG_NODE_DELETE_EX) {\n\t\t\tgf_fprintf(sdump->trace, \"<Delete extended=\\\"deleteOrder\\\" atNode=\\\"\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"<Delete atNode=\\\"\");\n\t\t}\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t} else {\n\t\tif (com->tag==GF_SG_NODE_DELETE_EX) gf_fprintf(sdump->trace, \"X\");\n\t\tgf_fprintf(sdump->trace, \"DELETE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpRouteDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Delete atRoute=\\\"\");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, com->def_name);\n\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"DELETE ROUTE \");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, com->def_name);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\n\nstatic GF_Err DumpNodeReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\">\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpFieldReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tGF_Err e;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" \", field.name);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE \");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s BY \", field.name);\n\t}\n\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"</Replace>\");\n\t\telse gf_fprintf(sdump->trace, \"\\n\");\n\t\tbreak;\n\tcase GF_SG_VRML_MFNODE:\n\t{\n\t\tGF_ChildNodeItem *tmp;\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \">\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \" [\\n\");\n\t\t}\n\t\tsdump->indent++;\n\t\ttmp = inf->node_list;\n\t\twhile (tmp) {\n\t\t\tgf_dump_vrml_node(sdump, tmp->node, 1, NULL);\n\t\t\ttmp = tmp->next;\n\t\t}\n\t\tsdump->indent--;\n\t\tif (sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"</Replace>\");\n\t\t} else {\n\t\t\tEndList(sdump, NULL);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\tif (sdump->XMLDump) {\n\t\t\tSFCommandBuffer *cb = (SFCommandBuffer*)inf->field_ptr;\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent+1, 0);\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"</Replace>\\n\");\n\t\t} else {\n\t\t\tSFCommandBuffer *cb = (SFCommandBuffer*)inf->field_ptr;\n\t\t\tgf_fprintf(sdump->trace, \" {\\n\");\n\t\t\tgf_sm_dump_command_list(sdump, cb->commandList, sdump->indent+1, 0);\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfield.far_ptr = inf->field_ptr;\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \"/>\");\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t}\n\treturn e;\n}\n\n\nstatic GF_Err DumpIndexReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar posname[20];\n\tGF_Err e;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tswitch (inf->pos) {\n\tcase 0:\n\t\tstrcpy(posname, \"BEGIN\");\n\t\tbreak;\n\tcase -1:\n\t\tstrcpy(posname, sdump->XMLDump ? \"END\" : \"LAST\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(posname, \"%d\", inf->pos);\n\t\tbreak;\n\t}\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\" position=\\\"%s\\\"\", field.name, posname);\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE \");\n\t\tif (inf->pos==-1) gf_fprintf(sdump->trace, \"%s \", posname);\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t}\n\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\\n\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, (sdump->XMLDump) ? \"</Replace>\\n\" : \"\\n\");\n\t} else {\n\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tfield.far_ptr = inf->field_ptr;\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? \"/>\\n\" : \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpXReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar posname[20];\n\tGF_Err e;\n\tGF_FieldInfo field, idxField;\n\tGF_Node *toNode, *target;\n\tGF_CommandField *inf;\n\tif (!gf_list_count(com->command_fields)) return GF_OK;\n\tinf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\n\te = gf_node_get_field(com->node, inf->fieldIndex, &field);\n\tif (e) return e;\n\n\ttoNode = target = NULL;\n\t/*indexed replacement with index given by other node field*/\n\tif (com->toNodeID) {\n\t\ttoNode = gf_sg_find_node(com->in_scene, com->toNodeID);\n\t\tif (!toNode) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = gf_node_get_field(toNode, com->toFieldIndex, &idxField);\n\t\tif (e) return e;\n\t}\n\telse {\n\t\t/*indexed replacement */\n\t\tif (inf->pos>=-1) {\n\t\t\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tswitch (inf->pos) {\n\t\t\tcase 0:\n\t\t\t\tstrcpy(posname, \"BEGIN\");\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tstrcpy(posname, sdump->XMLDump ? \"END\" : \"LAST\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(posname, \"%d\", inf->pos);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\t}\n\t}\n\tfield.far_ptr = inf->field_ptr;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atNode=\\\"\");\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \"\\\" atField=\\\"%s\\\"\", field.name);\n\n\t\tif (toNode) {\n\t\t\tgf_fprintf(sdump->trace, \" atIndexNode=\\\"\");\n\t\t\tscene_dump_vrml_id(sdump, toNode);\n\t\t\tgf_fprintf(sdump->trace, \"\\\" atIndexField=\\\"%s\\\"\", idxField.name);\n\n\t\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\t}\n\t\tif (com->ChildNodeTag) {\n\t\t\tGF_FieldInfo cfield;\n\t\t\tGF_Node *cnode;\n\n\t\t\tif (com->ChildNodeTag>0) {\n\t\t\t\tcnode = gf_node_new(com->in_scene, com->ChildNodeTag);\n\t\t\t} else {\n\t\t\t\tGF_Proto *proto = gf_sg_find_proto(com->in_scene, -com->ChildNodeTag , NULL);\n\t\t\t\tif (!proto) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tcnode = gf_sg_proto_create_instance(com->in_scene, proto);\n\t\t\t}\n\t\t\tif (!cnode) return GF_SG_UNKNOWN_NODE;\n\t\t\tgf_node_register(cnode, NULL);\n\t\t\tgf_node_get_field(cnode, com->child_field, &cfield);\n\t\t\tgf_fprintf(sdump->trace, \" atChildField=\\\"%s\\\"\", cfield.name);\n\t\t\tgf_node_unregister(cnode, NULL);\n\n\t\t\tfield.fieldType = cfield.fieldType;\n\t\t}\n\n\t\tif (com->fromNodeID) {\n\t\t\ttarget = gf_sg_find_node(com->in_scene, com->fromNodeID);\n\t\t\tif (!target) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\te = gf_node_get_field(target, com->fromFieldIndex, &idxField);\n\t\t\tif (e) return e;\n\n\t\t\tgf_fprintf(sdump->trace, \" fromNode=\\\"\");\n\t\t\tscene_dump_vrml_id(sdump, target);\n\t\t\tgf_fprintf(sdump->trace, \"\\\" fromField=\\\"%s\\\">\\n\", idxField.name);\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tif (inf->pos>=-1) gf_fprintf(sdump->trace, \" position=\\\"%s\\\"\", posname);\n\t\t}\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"XREPLACE \");\n\t\tif (inf->pos==-1) gf_fprintf(sdump->trace, \"%s \", posname);\n\t\tscene_dump_vrml_id(sdump, com->node);\n\t\tgf_fprintf(sdump->trace, \".%s\", field.name);\n\t\tif (toNode) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t\tscene_dump_vrml_id(sdump, toNode);\n\t\t\tgf_fprintf(sdump->trace, \".%s]\", idxField.name);\n\t\t\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\t}\n\t\telse if (inf->pos!=-1) gf_fprintf(sdump->trace, \"[%d]\", inf->pos);\n\t\tif (com->ChildNodeTag) {\n\t\t\tGF_FieldInfo cfield;\n\t\t\tGF_Node *cnode;\n\t\t\tif (com->ChildNodeTag>0) {\n\t\t\t\tcnode = gf_node_new(com->in_scene, com->ChildNodeTag);\n\t\t\t} else {\n\t\t\t\tGF_Proto *proto = gf_sg_find_proto(com->in_scene, -com->ChildNodeTag , NULL);\n\t\t\t\tif (!proto) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tcnode = gf_sg_proto_create_instance(com->in_scene, proto);\n\t\t\t}\n\t\t\tif (!cnode) return GF_SG_UNKNOWN_NODE;\n\t\t\tgf_node_register(cnode, NULL);\n\t\t\tgf_node_get_field(cnode, com->child_field, &cfield);\n\t\t\tgf_fprintf(sdump->trace, \".%s\", cfield.name);\n\t\t\tgf_node_unregister(cnode, NULL);\n\t\t\tfield.fieldType = cfield.fieldType;\n\t\t}\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t}\n\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tif (sdump->XMLDump) gf_fprintf(sdump->trace, \">\\n\");\n\t\tgf_dump_vrml_node(sdump, inf->new_node, 0, NULL);\n\t\tgf_fprintf(sdump->trace, (sdump->XMLDump) ? \"</Replace>\\n\" : \"\\n\");\n\t} else {\n\t\tgf_dump_vrml_simple_field(sdump, field, com->node);\n\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? \"/>\\n\" : \"\\n\");\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpRouteReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tconst char *name;\n\tGF_Route r2;\n\n\tif (!scene_dump_vrml_find_route_name(sdump, com->RouteID, &name)) return GF_BAD_PARAM;\n\n\tmemset(&r2, 0, sizeof(GF_Route));\n\tr2.FromNode = gf_dump_find_node(sdump, com->fromNodeID);\n\tr2.FromField.fieldIndex = com->fromFieldIndex;\n\tr2.ToNode = gf_dump_find_node(sdump, com->toNodeID);\n\tr2.ToField.fieldIndex = com->toFieldIndex;\n\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Replace atRoute=\\\"\");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, (char *) name);\n\t\tgf_fprintf(sdump->trace, \"\\\">\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"REPLACE ROUTE \");\n\t\tscene_dump_vrml_route_id(sdump, com->RouteID, (char *) name);\n\t\tgf_fprintf(sdump->trace, \" BY \");\n\t}\n\tgf_dump_vrml_route(sdump, &r2, 1);\n\tif (sdump->XMLDump ) gf_fprintf(sdump->trace, \"</Replace>\");\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_dump_vrml_route(GF_SceneDumper *sdump, GF_Route *r, u32 dump_type)\n{\n\tchar toNodeBuf[100], fromNodeBuf[100], *to_node_p, *from_node_p;\n\tconst char *node_name;\n\tu32 id;\n\tif (!r->is_setup) {\n\t\tgf_node_get_field(r->FromNode, r->FromField.fieldIndex, &r->FromField);\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &r->ToField);\n\t\tr->is_setup = 1;\n\t}\n\tif (!r->FromNode || !r->ToNode) return GF_BAD_PARAM;\n\n\tif (sdump->XMLDump || !dump_type) DUMP_IND(sdump);\n\n\tto_node_p = toNodeBuf;\n\tfrom_node_p = fromNodeBuf;\n\tnode_name = gf_node_get_name_and_id(r->FromNode, &id);\n\tif (node_name) {\n\t\tconst char *to_name;\n\t\tfrom_node_p = (char *)node_name;\n\t\tto_name = gf_node_get_name(r->ToNode);\n\t\tif (to_name) {\n\t\t\tto_node_p = (char *) to_name;\n\t\t} else {\n\t\t\tid = gf_node_get_id(r->ToNode);\n\t\t\tsprintf(toNodeBuf, \"node_%d\", id);\n\t\t}\n\t} else {\n\t\tsprintf(fromNodeBuf, \"N%d\", id-1);\n\t\tsprintf(toNodeBuf, \"N%d\", gf_node_get_id(r->ToNode) - 1);\n\t}\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<ROUTE\");\n\t\tif (r->ID) {\n\t\t\tStartAttribute(sdump, \"DEF\");\n\t\t\tscene_dump_vrml_route_id(sdump, r->ID, r->name);\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\tgf_fprintf(sdump->trace, \" fromNode=\\\"%s\\\" fromField=\\\"%s\\\" toNode=\\\"%s\\\" toField=\\\"%s\\\"/>\\n\", from_node_p, r->FromField.name, to_node_p, r->ToField.name);\n\t} else {\n\t\tif (dump_type==2) gf_fprintf(sdump->trace, \"ROUTE \");\n\t\tif (r->ID) {\n\t\t\tgf_fprintf(sdump->trace, \"DEF \");\n\t\t\tscene_dump_vrml_route_id(sdump, r->ID, r->name);\n\t\t\tgf_fprintf(sdump->trace, \" \");\n\t\t}\n\t\tif (dump_type==1) {\n\t\t\tgf_fprintf(sdump->trace, \"%s.%s TO %s.%s\\n\", from_node_p, r->FromField.name, to_node_p, r->ToField.name);\n\t\t} else {\n\t\t\tif (dump_type!=2) gf_fprintf(sdump->trace, \"ROUTE \");\n\t\t\tgf_fprintf(sdump->trace, \"%s.%s TO %s.%s\\n\", from_node_p, r->FromField.name, to_node_p, r->ToField.name);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err DumpProtos(GF_SceneDumper *sdump, GF_List *protoList)\n{\n#ifdef GPAC_DISABLE_VRML\n\treturn GF_OK;\n#else\n\tu32 i, j, count;\n\tGF_FieldInfo field;\n\tGF_Err e;\n\tGF_SceneGraph *prev_sg;\n\tGF_Proto *proto, *prev_proto;\n\n\tprev_proto = sdump->current_proto;\n\n\ti=0;\n\twhile ((proto = (GF_Proto*)gf_list_enum(protoList, &i))) {\n\t\tsdump->current_proto = proto;\n\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, proto->ExternProto.count ? \"EXTERNPROTO \" : \"PROTO \");\n\t\t\tgf_fprintf(sdump->trace, \"%s [\\n\", proto->Name);\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"<ProtoDeclare name=\\\"%s\\\" protoID=\\\"%d\\\"\", proto->Name, proto->ID);\n\t\t\tif (proto->ExternProto.count) {\n\t\t\t\tgf_fprintf(sdump->trace, \" locations=\\\"\");\n\t\t\t\tgf_dump_vrml_sffield(sdump, GF_SG_VRML_SFURL, &proto->ExternProto.vals[0], 0, NULL);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\");\n\t\t\t}\n\t\t\tgf_fprintf(sdump->trace, \">\\n\");\n\t\t}\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) gf_fprintf(sdump->trace, \"<ProtoInterface>\");\n\n\t\tsdump->indent++;\n\t\tcount = gf_list_count(proto->proto_fields);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_ProtoFieldInterface *pf = (GF_ProtoFieldInterface *)gf_list_get(proto->proto_fields, j);\n\t\t\tfield.fieldIndex = pf->ALL_index;\n\t\t\tfield.eventType = pf->EventType;\n\t\t\tfield.far_ptr = pf->def_value;\n\t\t\tfield.fieldType = pf->FieldType;\n\t\t\tfield.name = pf->FieldName;\n\t\t\tfield.NDTtype = NDT_SFWorldNode;\n\t\t\tfield.on_event_in = NULL;\n\n\t\t\tgf_dump_vrml_dyn_field(sdump, NULL, field, pf->QP_Type ? 1 : 0);\n\n\t\t\tif (!pf->QP_Type) continue;\n\n\t\t\t/*dump interface coding - BT/TXT extensions, not supported by any other tool*/\n\t\t\tsdump->indent++;\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tconst char *quant_catname = \"unknown\";\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t\tswitch (pf->QP_Type) {\n\t\t\t\tcase QC_3DPOS: quant_catname = \"position3D\"; break;\n\t\t\t\tcase QC_2DPOS: quant_catname = \"position2D\"; break;\n\t\t\t\tcase QC_ORDER: quant_catname = \"drawingOrder\"; break;\n\t\t\t\tcase QC_COLOR: quant_catname = \"color\"; break;\n\t\t\t\tcase QC_TEXTURE_COORD: quant_catname = \"textureCoordinate\"; break;\n\t\t\t\tcase QC_ANGLE: quant_catname = \"angle\"; break;\n\t\t\t\tcase QC_SCALE: quant_catname = \"scale\"; break;\n\t\t\t\tcase QC_INTERPOL_KEYS: quant_catname = \"keys\"; break;\n\t\t\t\tcase QC_NORMALS: quant_catname = \"normals\"; break;\n\t\t\t\tcase QC_ROTATION: quant_catname = \"rotations\"; break;\n\t\t\t\tcase QC_SIZE_3D: quant_catname = \"size3D\"; break;\n\t\t\t\tcase QC_SIZE_2D: quant_catname = \"size2D\"; break;\n\t\t\t\tcase QC_LINEAR_SCALAR: quant_catname = \"linear\"; break;\n\t\t\t\tcase QC_COORD_INDEX:quant_catname = \"coordIndex\"; break;\n\t\t\t\t}\n#endif\n\t\t\t\tgf_fprintf(sdump->trace, \"<InterfaceCodingParameters quantCategoy=\\\"%s\\\"\", quant_catname);\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"{QP %d\", pf->QP_Type);\n\t\t\t}\n#ifndef GPAC_DISABLE_BIFS\n\t\t\tif (pf->QP_Type==QC_LINEAR_SCALAR) gf_fprintf(sdump->trace, sdump->XMLDump ? \" nbBits=\\\"%d\\\"\" : \" nbBits %d\", pf->NumBits);\n\t\t\tif (pf->hasMinMax) {\n\t\t\t\tswitch (pf->QP_Type) {\n\t\t\t\tcase QC_LINEAR_SCALAR:\n\t\t\t\tcase QC_COORD_INDEX:\n\t\t\t\t\tif (sdump->XMLDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" intMin=\\\"%d\\\" intMax=\\\"%d\\\"\", *((SFInt32 *)pf->qp_min_value), *((SFInt32 *)pf->qp_max_value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" b {%d %d}\", *((SFInt32 *)pf->qp_min_value), *((SFInt32 *)pf->qp_max_value));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (sdump->XMLDump) {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" floatMin=\\\"%g\\\" floatMax=\\\"%g\\\"\", FIX2FLT( *((SFFloat *)pf->qp_min_value) ), FIX2FLT( *((SFFloat *)pf->qp_max_value) ));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_fprintf(sdump->trace, \" b {%g %g}\", FIX2FLT( *((SFFloat *)pf->qp_min_value) ), FIX2FLT( *((SFFloat *)pf->qp_max_value) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tgf_fprintf(sdump->trace, sdump->XMLDump ? \"/>\\n\" : \"}\\n\");\n\t\t\tsdump->indent--;\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</field>\\n\");\n\t\t\t}\n\n\t\t}\n\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sdump->X3DDump) gf_fprintf(sdump->trace, \"</ProtoInterface>\\n\");\n\n\t\tif (proto->ExternProto.count) {\n\t\t\tif (!sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \" \\\"\");\n\t\t\t\tgf_dump_vrml_sffield(sdump, GF_SG_VRML_SFURL, &proto->ExternProto.vals[0], 0, NULL);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\\n\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"</ProtoDeclare>\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \" {\\n\");\n\n\t\tsdump->indent++;\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) gf_fprintf(sdump->trace, \"<ProtoBody>\\n\");\n\n\t\te = DumpProtos(sdump, proto->sub_graph->protos);\n\t\tif (e) return e;\n\n\t\t/*set namespace to the proto one*/\n\t\tprev_sg = sdump->sg;\n\t\tsdump->sg = gf_sg_proto_get_graph(proto);\n\n\t\tcount = gf_list_count(proto->node_code);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_Node *n = (GF_Node*)gf_list_get(proto->node_code, j);\n\t\t\tgf_dump_vrml_node(sdump, n, 1, NULL);\n\t\t}\n\t\tcount = gf_list_count(proto->sub_graph->Routes);\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_Route *r = (GF_Route *)gf_list_get(proto->sub_graph->Routes, j);\n\t\t\tif (r->IS_route) continue;\n\t\t\tgf_dump_vrml_route(sdump, r, 0);\n\t\t}\n\n\t\tif (sdump->XMLDump && sdump->X3DDump) gf_fprintf(sdump->trace, \"</ProtoBody>\\n\");\n\n\t\t/*restore namespace*/\n\t\tsdump->sg = prev_sg;\n\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t\t} else {\n\t\t\tgf_fprintf(sdump->trace, \"</ProtoDeclare>\\n\");\n\t\t}\n\t}\n\tsdump->current_proto = prev_proto;\n\treturn GF_OK;\n#endif\n}\n\nstatic GF_Err DumpSceneReplace(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tif (sdump->XMLDump) {\n\t\tif (!sdump->X3DDump) {\n\t\t\tStartElement(sdump, \"Replace\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\t\t//scene tag is already dumped with X3D header\n\t\tif (!sdump->X3DDump) StartElement(sdump, \"Scene\");\n\t\tif (!sdump->X3DDump && com->use_names) {\n\t\t\tStartAttribute(sdump, \"USENAMES\");\n\t\t\tgf_fprintf(sdump->trace, \"%s\", com->use_names ? \"true\" : \"false\");\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t\tif (!sdump->X3DDump) EndElementHeader(sdump, 1);\n\t\tsdump->indent++;\n\t} else {\n\t\tif (!sdump->skip_scene_replace) {\n\t\t\tDUMP_IND(sdump);\n\t\t\tgf_fprintf(sdump->trace, \"REPLACE SCENE BY \");\n\t\t}\n\t}\n\tDumpProtos(sdump, com->new_proto_list);\n\tgf_dump_vrml_node(sdump, com->node, 0, NULL);\n\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"\\n\\n\");\n\n\tif (com->aggregated) {\n\t\tu32 i, count;\n\t\tcount = gf_list_count(com->node->sgprivate->scenegraph->Routes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Route *r = (GF_Route *)gf_list_get(com->node->sgprivate->scenegraph->Routes, i);\n\t\t\tif (r->IS_route) continue;\n\t\t\tgf_dump_vrml_route(sdump, r, 0);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpProtoInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"<Insert extended=\\\"proto\\\">\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"INSERTPROTO [\\n\");\n\t}\n\tsdump->indent++;\n\tDumpProtos(sdump, com->new_proto_list);\n\tsdump->indent--;\n\tDUMP_IND(sdump);\n\tif (sdump->XMLDump) {\n\t\tgf_fprintf(sdump->trace, \"</Insert>\\n\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_VRML*/\n\n\n#ifndef GPAC_DISABLE_SVG\nstatic char *lsr_format_node_id(GF_Node *n, u32 NodeID, char *str)\n{\n\tif (!n) sprintf(str, \"N%d\", NodeID-1);\n\telse {\n\t\tconst char *name = gf_node_get_name_and_id(n, &NodeID);\n\t\tif (name) sprintf(str, \"%s\", name);\n\t\telse sprintf(str, \"N%d\", NodeID - 1);\n\t}\n\treturn str;\n}\n\nstatic char szLSRName[1024];\n\nstatic char *sd_get_lsr_namespace(GF_SceneGraph *sg)\n{\n\tchar *lsrns = (char *) gf_sg_get_namespace_qname(sg, GF_XMLNS_LASER);\n\tif (lsrns) {\n\t\tsprintf(szLSRName, \"%s:\", lsrns);\n\t\treturn szLSRName;\n\t}\n\treturn \"\";\n}\n\nstatic GF_Err DumpLSRNewScene(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tgf_fprintf(sdump->trace, \"<%sNewScene>\\n\", lsrns);\n\tgf_dump_svg_element(sdump, com->node, NULL, 0);\n\tgf_fprintf(sdump->trace, \"</%sNewScene>\\n\", lsrns);\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRAddReplaceInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[100];\n\tBool is_text = 0;\n\tGF_CommandField *f;\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\n\tconst char *com_name = (com->tag==GF_SG_LSR_REPLACE) ? \"Replace\" : ( (com->tag==GF_SG_LSR_ADD) ? \"Add\" : \"Insert\" );\n\n\tDUMP_IND(sdump);\n\n\tgf_fprintf(sdump->trace, \"<%s%s ref=\\\"%s\\\" \", lsrns, com_name, lsr_format_node_id(com->node, com->RouteID, szID));\n\tf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tif (f && (f->pos>=0) ) gf_fprintf(sdump->trace, \"index=\\\"%d\\\" \", f->pos);\n\tif (f) {\n\t\tGF_FieldInfo info;\n\t\tif (!f->new_node && !f->node_list) {\n\t\t\tchar *att_name = NULL;\n\t\t\tif (f->fieldType==SVG_Transform_Scale_datatype) att_name = \"scale\";\n\t\t\telse if (f->fieldType==SVG_Transform_Rotate_datatype) att_name = \"rotation\";\n\t\t\telse if (f->fieldType==SVG_Transform_Translate_datatype) att_name = \"translation\";\n\t\t\telse if (f->fieldIndex==(u32) -1) att_name = \"textContent\";\n\t\t\telse {\n\t\t\t\tif (!com->node) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tatt_name = (char*) gf_svg_get_attribute_name(com->node, f->fieldIndex);\n\t\t\t}\n\n\t\t\tgf_fprintf(sdump->trace, \"attributeName=\\\"%s\\\" \", att_name);\n\t\t\tif (f->field_ptr) {\n\t\t\t\tchar *att;\n\t\t\t\tinfo.far_ptr = f->field_ptr;\n\t\t\t\tinfo.fieldIndex = f->fieldIndex;\n\t\t\t\tinfo.fieldType = f->fieldType;\n\t\t\t\tinfo.name = att_name;\n\n\t\t\t\tif ((s32) f->pos >= 0) {\n\t\t\t\t\tatt = gf_svg_dump_attribute_indexed(com->node, &info);\n\t\t\t\t} else {\n\t\t\t\t\tatt = gf_svg_dump_attribute(com->node, &info);\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"value=\\\"%s\\\" \", att ? att : \"\");\n\t\t\t\tif (att) gf_free(att);\n\t\t\t}\n\n\t\t\tif (com->fromNodeID) {\n\t\t\t\tGF_FieldInfo op_info;\n\t\t\t\tGF_Node *op = gf_sg_find_node(sdump->sg, com->fromNodeID);\n\t\t\t\tgf_fprintf(sdump->trace, \"operandElementId=\\\"%s\\\" \", lsr_format_node_id(op, com->RouteID, szID));\n\t\t\t\tgf_node_get_field(op, com->fromFieldIndex, &op_info);\n\t\t\t\tgf_fprintf(sdump->trace, \"operandAttributeName=\\\"%s\\\" \", op_info.name);\n\t\t\t}\n\n\t\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (f->new_node && f->new_node->sgprivate->tag==TAG_DOMText) is_text = 1;\n\t\t/*if fieldIndex (eg attributeName) is set, this is children replacement*/\n\t\tif (f->fieldIndex>0)\n\t\t\tgf_fprintf(sdump->trace, \"attributeName=\\\"children\\\" \");\n\t}\n\n\n\tgf_fprintf(sdump->trace, \">\");\n\tif (!is_text) {\n\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\tsdump->indent++;\n\t}\n\tif (f) {\n\t\tif (f->new_node) {\n\t\t\tgf_dump_svg_element(sdump, f->new_node, com->node, 0);\n\t\t} else if (f->node_list) {\n\t\t\tGF_ChildNodeItem *list = f->node_list;\n\t\t\twhile (list) {\n\t\t\t\tgf_dump_svg_element(sdump, list->node, com->node, 0);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_text) {\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t}\n\tgf_fprintf(sdump->trace, \"</%s%s>\\n\", lsrns, com_name);\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRDelete(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[1024];\n\tGF_CommandField *f;\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<%sDelete ref=\\\"%s\\\" \", lsrns, lsr_format_node_id(com->node, com->RouteID, szID));\n\tf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\tif (f && (f->pos>=0) ) gf_fprintf(sdump->trace, \"index=\\\"%d\\\" \", f->pos);\n\tgf_fprintf(sdump->trace, \"/>\\n\");\n\treturn GF_OK;\n}\n#ifdef GPAC_UNUSED_FUNC\nstatic GF_Err DumpLSRInsert(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\n\nstatic GF_Err SD_SetSceneGraph(GF_SceneDumper *sdump, GF_SceneGraph *sg)\n{\n\tif (sdump) sdump->sg = sg;\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRClean(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\n\nstatic GF_Err DumpLSRRestore(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\nstatic GF_Err DumpLSRSave(GF_SceneDumper *sdump, GF_Command *com)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_UNUSED_FUNC*/\n\nstatic GF_Err DumpLSRSendEvent(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[1024];\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tDUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"<%sSendEvent ref=\\\"%s\\\" event=\\\"%s\\\"\", lsrns,\n\t        lsr_format_node_id(com->node, com->RouteID, szID),\n\t        gf_dom_event_get_name(com->send_event_name)\n\t       );\n\tif (com->send_event_name <= GF_EVENT_MOUSEWHEEL)\n\t\tgf_fprintf(sdump->trace, \" pointvalue=\\\"%g %g\\\"\", FIX2FLT(com->send_event_x), FIX2FLT(com->send_event_y) );\n\n\tswitch (com->send_event_name) {\n\tcase GF_EVENT_KEYDOWN:\n\tcase GF_EVENT_LONGKEYPRESS:\n\tcase GF_EVENT_REPEAT_KEY:\n\tcase GF_EVENT_SHORT_ACCESSKEY:\n\t\tif (com->send_event_integer) {\n\t\t\tgf_fprintf(sdump->trace, \" stringvalue=\\\"%s\\\"\", gf_dom_get_key_name(com->send_event_integer) );\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tif (com->send_event_integer)\n\t\t\tgf_fprintf(sdump->trace, \" intvalue=\\\"%d\\\"\", com->send_event_integer);\n\t\tif (com->send_event_string)\n\t\t\tgf_fprintf(sdump->trace, \" stringvalue=\\\"%s\\\"\", com->send_event_string);\n\t\tbreak;\n\t}\n\n\tgf_fprintf(sdump->trace, \"/>\\n\");\n\treturn GF_OK;\n}\nstatic GF_Err DumpLSRActivate(GF_SceneDumper *sdump, GF_Command *com)\n{\n\tchar szID[1024];\n\tchar *lsrns = sd_get_lsr_namespace(com->in_scene);\n\tDUMP_IND(sdump);\n\tif (com->tag==GF_SG_LSR_ACTIVATE) {\n\t\tgf_fprintf(sdump->trace, \"<%sActivate ref=\\\"%s\\\" />\\n\", lsrns, lsr_format_node_id(com->node, com->RouteID, szID));\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"<%sDeactivate ref=\\\"%s\\\" />\\n\", lsrns, lsr_format_node_id(com->node, com->RouteID, szID));\n\t}\n\treturn GF_OK;\n}\n\n#endif\n\nGF_EXPORT\nGF_Err gf_sm_dump_command_list(GF_SceneDumper *sdump, GF_List *comList, u32 indent, Bool skip_first_replace)\n{\n\tGF_Err e;\n\tu32 i, count;\n\tu32 prev_ind;\n#ifndef GPAC_DISABLE_VRML\n\tu32 remain = 0, has_scene_replace = 0;\n#endif\n\tBool prev_skip;\n\n\tif (!sdump || !sdump->trace|| !comList || !sdump->sg) return GF_BAD_PARAM;\n\n\tprev_skip = sdump->skip_scene_replace;\n\tsdump->skip_scene_replace = skip_first_replace;\n\tprev_ind  = sdump->indent;\n\tsdump->indent = indent;\n\n\te = GF_OK;\n\tcount = gf_list_count(comList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Command *com = (GF_Command *) gf_list_get(comList, i);\n\t\tif (i\n#ifndef GPAC_DISABLE_VRML\n\t\t\t&& !remain\n#endif\n\t\t\t&& (sdump->X3DDump || (sdump->dump_mode==GF_SM_DUMP_VRML))\n\t\t) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[Scene Dump] MPEG-4 Commands found, not supported in %s - skipping\\n\", sdump->X3DDump ? \"X3D\" : \"VRML\"));\n\t\t\tbreak;\n\t\t}\n#ifndef GPAC_DISABLE_VRML\n\t\tif (has_scene_replace && (com->tag != GF_SG_ROUTE_INSERT)) {\n\t\t\thas_scene_replace = 0;\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, \"Scene\", 1);\n\t\t\t\tsdump->indent--;\n\t\t\t\tEndElement(sdump, \"Replace\", 1);\n\t\t\t} else {\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\nAT 0 {\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tswitch (com->tag) {\n#ifndef GPAC_DISABLE_VRML\n\t\t/*insert commands*/\n\t\tcase GF_SG_NODE_INSERT:\n\t\t\te = DumpNodeInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_INDEXED_INSERT:\n\t\t\te = DumpIndexInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_ROUTE_INSERT:\n\t\t\te = DumpRouteInsert(sdump, com, has_scene_replace);\n\t\t\tif (remain) remain--;\n\t\t\tbreak;\n\t\t/*delete commands*/\n\t\tcase GF_SG_NODE_DELETE:\n\t\t\te = DumpNodeDelete(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_INDEXED_DELETE:\n\t\t\te = DumpIndexDelete(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_ROUTE_DELETE:\n\t\t\te = DumpRouteDelete(sdump, com);\n\t\t\tbreak;\n\t\t/*replace commands*/\n\t\tcase GF_SG_NODE_REPLACE:\n\t\t\te = DumpNodeReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_FIELD_REPLACE:\n\t\t\te = DumpFieldReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_INDEXED_REPLACE:\n\t\t\te = DumpIndexReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_ROUTE_REPLACE:\n\t\t\te = DumpRouteReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_XREPLACE:\n\t\t\te = DumpXReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_SCENE_REPLACE:\n\t\t\t/*we don't support replace scene in conditional*/\n\t\t\tassert(!sdump->current_com_list);\n\t\t\tsdump->current_com_list = comList;\n\t\t\te = DumpSceneReplace(sdump, com);\n\t\t\tsdump->current_com_list = NULL;\n\t\t\thas_scene_replace = 1;\n\t\t\tremain = count - i - 1;\n\t\t\tbreak;\n\t\t/*extended commands*/\n\t\tcase GF_SG_PROTO_INSERT:\n\t\t\te = DumpProtoInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_PROTO_DELETE_ALL:\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<Delete extended=\\\"allProtos\\\"/>\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"DELETEPROTO ALL\\n\");\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\tcase GF_SG_PROTO_DELETE:\n\t\t{\n\t\t\tu32 j;\n\t\t\tDUMP_IND(sdump);\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<Delete extended=\\\"protos\\\" value=\\\"\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"DELETEPROTO [\");\n\t\t\t}\n\t\t\tfor (j=0; j<com->del_proto_list_size; j++) {\n\t\t\t\tif (j) gf_fprintf(sdump->trace, \" \");\n\t\t\t\tgf_fprintf(sdump->trace, \"%d\", com->del_proto_list[j]);\n\t\t\t}\n\t\t\tif (sdump->XMLDump) {\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \"]\\n\");\n\t\t\t}\n\t\t\te = GF_OK;\n\t\t}\n\t\tbreak;\n\t\tcase GF_SG_GLOBAL_QUANTIZER:\n\t\t\te = DumpGlobalQP(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_MULTIPLE_REPLACE:\n\t\t\te = DumpMultipleReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_MULTIPLE_INDEXED_REPLACE:\n\t\t\te = DumpMultipleIndexedReplace(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_NODE_DELETE_EX:\n\t\t\te = DumpNodeDelete(sdump, com);\n\t\t\tbreak;\n\n#endif\n\n\n#ifndef GPAC_DISABLE_SVG\n\t\t/*laser commands*/\n\t\tcase GF_SG_LSR_NEW_SCENE:\n\t\t\te = DumpLSRNewScene(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_ADD:\n\t\t\te = DumpLSRAddReplaceInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_CLEAN:\n\t\t\t//e = DumpLSRClean(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_REPLACE:\n\t\t\te = DumpLSRAddReplaceInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_DELETE:\n\t\t\te = DumpLSRDelete(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_INSERT:\n\t\t\te = DumpLSRAddReplaceInsert(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_RESTORE:\n\t\t\t//e = DumpLSRRestore(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_SAVE:\n\t\t\t//e = DumpLSRSave(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_SEND_EVENT:\n\t\t\te = DumpLSRSendEvent(sdump, com);\n\t\t\tbreak;\n\t\tcase GF_SG_LSR_ACTIVATE:\n\t\tcase GF_SG_LSR_DEACTIVATE:\n\t\t\te = DumpLSRActivate(sdump, com);\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (e) break;\n\n\n\t\tif (sdump->skip_scene_replace\n#ifndef GPAC_DISABLE_VRML\n\t\t\t&& !has_scene_replace\n#endif\n\t\t) {\n\t\t\tsdump->skip_scene_replace = 0;\n\t\t\tif (!sdump->XMLDump && (i+1<count)) {\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"\\nAT 0 {\\n\");\n\t\t\t\tsdump->indent++;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_VRML\n\tif (remain && !sdump->XMLDump) {\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"}\\n\");\n\t}\n#endif\n\n\tif (has_scene_replace && sdump->XMLDump) {\n\t\tsdump->indent--;\n\t\tif (!sdump->X3DDump) {\n\t\t\tEndElement(sdump, \"Scene\", 1);\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"Replace\", 1);\n\t\t}\n\t}\n\n\tsdump->indent = prev_ind;\n\tsdump->skip_scene_replace = prev_skip;\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_SVG\nvoid gf_dump_svg_element(GF_SceneDumper *sdump, GF_Node *n, GF_Node *parent, Bool is_root)\n{\n\tGF_ChildNodeItem *list;\n\tchar attName[100], *attValue;\n\tu32 nID;\n\tSVG_Element *svg = (SVG_Element *)n;\n\tGF_FieldInfo info;\n\tSVGAttribute *att;\n\tu32 tag, ns;\n\tif (!n) return;\n\n\tnID = gf_node_get_id(n);\n\ttag = n->sgprivate->tag;\n\t/*remove undef listener/handlers*/\n\tif (!nID) {\n\t\tswitch (tag) {\n\t\tcase TAG_SVG_listener:\n\t\t\tif ((0) && gf_node_get_attribute_by_tag(n, TAG_XMLEV_ATT_handler, 0, 0, &info)==GF_OK) {\n\t\t\t\tif (((XMLRI*)info.far_ptr)->target && !gf_node_get_id(((XMLRI*)info.far_ptr)->target) )\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TAG_SVG_handler:\n\t\t\t/*this handler was not declared in the graph*/\n\t\t\tif (!n->sgprivate->parents || (n->sgprivate->parents->node != parent))\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase TAG_DOMText:\n\t\t{\n\t\t\tGF_DOMText *txt = (GF_DOMText *)n;\n\t\t\tif (txt->textContent) {\n\t\t\t\tif ((txt->type==GF_DOM_TEXT_CDATA)\n\t\t\t\t\t|| (parent && (parent->sgprivate->tag == TAG_SVG_script))\n\t\t\t\t\t|| (parent && (parent->sgprivate->tag == TAG_SVG_handler))\n\t\t\t\t) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \"<![CDATA[\");\n\t\t\t\t\tgf_fprintf(sdump->trace, \"%s\", txt->textContent);\n\t\t\t\t\tgf_fprintf(sdump->trace, \"]]>\");\n\t\t\t\t} else if (txt->type==GF_DOM_TEXT_REGULAR) {\n\t\t\t\t\tscene_dump_utf_string(sdump, 0, txt->textContent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t\t}\n\t}\n\n\tif (!sdump->in_text) {\n\t\tDUMP_IND(sdump);\n\t}\n\n\t/*register all namespaces specified on this element */\n\tgf_xml_push_namespaces((GF_DOMNode *)n);\n\n\tgf_fprintf(sdump->trace, \"<%s\", gf_node_get_class_name(n));\n\tns = gf_xml_get_element_namespace(n);\n\n\tif (nID) {\n\t\tchar attID[100];\n\t\tgf_fprintf(sdump->trace, \" id=\\\"%s\\\"\", lsr_format_node_id(n, 0, attID));\n\t}\n\tatt = svg->attributes;\n\twhile (att) {\n\t\tif (att->data_type==SVG_ID_datatype) {\n\t\t\tatt = att->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo.fieldIndex = att->tag;\n\t\tinfo.fieldType = att->data_type;\n\t\tif (att->tag==TAG_DOM_ATT_any) {\n\t\t\tu32 att_ns = ((GF_DOMFullAttribute*)att)->xmlns;\n\t\t\tinfo.name = ((GF_DOMFullAttribute*)att)->name;\n\t\t\tif ((att_ns != ns) && strncmp(info.name, \"xmlns\", 5)) {\n\t\t\t\tsprintf(attName, \"%s:%s\", gf_sg_get_namespace_qname(gf_node_get_graph(n), att_ns), ((GF_DOMFullAttribute*)att)->name);\n\t\t\t\tinfo.name = attName;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.name = gf_svg_get_attribute_name(n, att->tag);\n\t\t}\n\n\t\tif (att->data_type==XMLRI_datatype) {\n\t\t\tXMLRI *xlink = (XMLRI *)att->data;\n\t\t\tif (xlink->type==XMLRI_ELEMENTID) {\n\t\t\t\tif (!xlink->target || !gf_node_get_id((GF_Node*)xlink->target) ) {\n\t\t\t\t\tatt = att->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (parent && (parent == (GF_Node *) xlink->target)) {\n\t\t\t\t\tatt = att->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (xlink->type==XMLRI_STREAMID) {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"#stream%d\\\"\", info.name, xlink->lsr_stream_id);\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"%s\\\"\", info.name, xlink->string);\n\t\t\t\tatt = att->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tinfo.far_ptr = att->data;\n\t\tattValue = gf_svg_dump_attribute((GF_Node*)svg, &info);\n\t\tif (attValue) {\n\t\t\tif (/*strcmp(info.name, \"xmlns\") &&*/ (info.fieldType = (u32) strlen(attValue)))\n\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"%s\\\"\", info.name, attValue);\n\t\t\tgf_free(attValue);\n\t\t}\n\t\tatt = att->next;\n\t}\n\n\tgf_dom_event_dump_listeners(n, sdump->trace);\n\tif (svg->children) {\n\t\tgf_fprintf(sdump->trace, \">\");\n\t} else {\n\t\tgf_fprintf(sdump->trace, \"/>\");\n\t\treturn;\n\t}\n\n\tif (n->sgprivate->tag==TAG_LSR_conditional) {\n\t\tGF_DOMUpdates *up = svg->children ? (GF_DOMUpdates *)svg->children->node : NULL;\n\t\tsdump->indent++;\n\t\tif (up && (up->sgprivate->tag==TAG_DOMUpdates)) {\n\t\t\tif (gf_list_count(up->updates)) {\n\t\t\t\tgf_fprintf(sdump->trace, \"\\n\");\n\t\t\t\tgf_sm_dump_command_list(sdump, up->updates, sdump->indent, 0);\n\t\t\t} else if (up->data) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<!-- WARNING: LASeR scripts cannot be dumped at run-time -->\\n\");\n\t\t\t}\n\t\t}\n\t\tsdump->indent--;\n\t\tDUMP_IND(sdump);\n\t\tgf_fprintf(sdump->trace, \"</%s>\\n\", gf_node_get_class_name(n));\n\t\treturn;\n\t}\n\n\tif (tag==TAG_SVG_text || tag==TAG_SVG_textArea) sdump->in_text = 1;\n\tsdump->indent++;\n\tlist = svg->children;\n\twhile (list) {\n\t\tif (!sdump->in_text) gf_fprintf(sdump->trace, \"\\n\");\n\t\tgf_dump_svg_element(sdump, list->node, n, 0);\n\t\tlist = list->next;\n\t}\n\tif (!sdump->in_text) gf_fprintf(sdump->trace, \"\\n\");\n\tsdump->indent--;\n\tif (!sdump->in_text) DUMP_IND(sdump);\n\tgf_fprintf(sdump->trace, \"</%s>\", gf_node_get_class_name(n));\n\tif (tag==TAG_SVG_text || tag==TAG_SVG_textArea) sdump->in_text = 0;\n\t/*removes all namespaces specified on this element */\n\tgf_xml_pop_namespaces((GF_DOMNode *)n);\n}\n#endif\n\nstatic void gf_sm_dump_saf_hdr(GF_SceneDumper *dumper, char *unit_name, u64 au_time, Bool is_rap)\n{\n\tgf_fprintf(dumper->trace, \"<saf:%s\", unit_name);\n\tif (au_time) gf_fprintf(dumper->trace, \" time=\\\"\"LLD\"\\\"\", au_time);\n\tif (is_rap) gf_fprintf(dumper->trace, \" rap=\\\"true\\\"\");\n\tgf_fprintf(dumper->trace, \">\\n\");\n}\n\nstatic void dump_od_to_saf(GF_SceneDumper *dumper, GF_AUContext *au, u32 indent)\n{\n\tu32 i, count;\n\n\tcount = gf_list_count(au->commands);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, c2;\n\t\tGF_ODUpdate *com = (GF_ODUpdate *)gf_list_get(au->commands, i);\n\t\tif (com->tag != GF_ODF_OD_UPDATE_TAG) continue;\n\n\t\tc2 = gf_list_count(com->objectDescriptors);\n\t\tfor (j=0; j<c2; j++) {\n\t\t\tGF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(com->objectDescriptors, j);\n\t\t\tGF_ESD *esd = (GF_ESD *) gf_list_get(od->ESDescriptors, 0);\n\t\t\tGF_MuxInfo *mux;\n\t\t\tif (!esd || (esd->tag != GF_ODF_ESD_TAG)) {\n\t\t\t\tif (od->URLString) {\n\t\t\t\t\tgf_fprintf(dumper->trace, \"<saf:RemoteStreamHeader streamID=\\\"stream%d\\\" url=\\\"%s\\\"\", au->owner->ESID, od->URLString);\n\t\t\t\t\tif (au->timing) gf_fprintf(dumper->trace, \" time=\\\"\"LLD\"\\\"\", au->timing);\n\t\t\t\t\tgf_fprintf(dumper->trace, \"/>\\n\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmux = (GF_MuxInfo *)gf_list_get(esd->extensionDescriptors, 0);\n\t\t\tif (!mux || (mux->tag!=GF_ODF_MUXINFO_TAG)) mux = NULL;\n\n\n\t\t\tgf_fprintf(dumper->trace, \"<saf:mediaHeader streamID=\\\"stream%d\\\"\", esd->ESID);\n\t\t\tif (esd->decoderConfig) {\n\t\t\t\tgf_fprintf(dumper->trace, \" streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" timeStampResolution=\\\"%d\\\"\", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale);\n\t\t\t}\n\t\t\tif (au->timing) gf_fprintf(dumper->trace, \" time=\\\"\"LLD\"\\\"\", au->timing);\n\t\t\tif (mux && mux->file_name) gf_fprintf(dumper->trace, \" source=\\\"%s\\\"\", mux->file_name);\n\t\t\tgf_fprintf(dumper->trace, \"/>\\n\");\n\t\t}\n\n\n\t}\n\tgf_fprintf(dumper->trace, \"</saf:mediaUnit>\\n\");\n}\n\n#ifndef GPAC_DISABLE_SVG\nstatic GF_Err SD_DumpDOMElement(GF_SceneDumper *sdump, GF_DOMFullNode *node)\n{\n\tconst char *ns;\n\tu32 child_type = 0;\n\tGF_DOMFullAttribute *att;\n\tGF_ChildNodeItem *child;\n\tGF_DOMText *txt;\n\tns = gf_sg_get_namespace_qname(node->sgprivate->scenegraph, node->ns);\n\n\tDUMP_IND(sdump);\n\tif (ns) gf_fprintf(sdump->trace, \"<%s:%s\", ns, node->name);\n\telse gf_fprintf(sdump->trace, \"<%s\", node->name);\n\tatt = (GF_DOMFullAttribute *)node->attributes;\n\twhile (att) {\n\t\tgf_fprintf(sdump->trace, \" %s=\\\"%s\\\"\", att->name, (char *) att->data);\n\t\tatt = (GF_DOMFullAttribute *)att->next;\n\t}\n\tif (!node->children) {\n\t\tgf_fprintf(sdump->trace, \"/>\\n\");\n\t\treturn GF_OK;\n\t}\n\tgf_fprintf(sdump->trace, \">\");\n\tsdump->indent++;\n\tchild = node->children;\n\twhile (child) {\n\t\tswitch(child->node->sgprivate->tag) {\n\t\tcase TAG_DOMFullNode:\n\t\t\tif (!child_type) gf_fprintf(sdump->trace, \"\\n\");\n\t\t\tchild_type = 1;\n\t\t\tSD_DumpDOMElement(sdump, (GF_DOMFullNode*)child->node);\n\t\t\tbreak;\n\t\tcase TAG_DOMText:\n\t\t\tchild_type = 2;\n\t\t\ttxt = (GF_DOMText *)child->node;\n\t\t\tif (txt->type==GF_DOM_TEXT_REGULAR) {\n\t\t\t\tscene_dump_utf_string(sdump, 0, txt->textContent);\n\t\t\t} else if (txt->type==GF_DOM_TEXT_CDATA) {\n\t\t\t\tgf_fprintf(sdump->trace, \"<![CDATA[\");\n\t\t\t\tgf_fprintf(sdump->trace, \"%s\", txt->textContent);\n\t\t\t\tgf_fprintf(sdump->trace, \"]]>\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tchild = child->next;\n\t}\n\n\tsdump->indent--;\n\tif (child_type!=2) {\n\t\tDUMP_IND(sdump);\n\t}\n\n\tif (ns) gf_fprintf(sdump->trace, \"</%s:%s>\\n\", ns, node->name);\n\telse gf_fprintf(sdump->trace, \"</%s>\\n\", node->name);\n\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_sm_dump_graph(GF_SceneDumper *sdump, Bool skip_proto, Bool skip_routes)\n{\n\tu32 tag;\n\tif (!sdump->trace || !sdump->sg || !sdump->sg->RootNode) return GF_BAD_PARAM;\n\n\ttag = sdump->sg->RootNode->sgprivate->tag;\n\n\tif (tag<=GF_NODE_RANGE_LAST_X3D) {\n\t\tgf_dump_setup(sdump, NULL);\n\n\t\tif (sdump->XMLDump) {\n\t\t\tStartElement(sdump, \"Scene\");\n\t\t\tEndElementHeader(sdump, 1);\n\t\t\tsdump->indent++;\n\t\t}\n\n#ifndef GPAC_DISABLE_VRML\n\t\tGF_Err e;\n\t\tif (!skip_proto) {\n\t\t\te = DumpProtos(sdump, sdump->sg->protos);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tif (sdump->X3DDump) {\n\t\t\tGF_ChildNodeItem *list = ((GF_ParentNode *)sdump->sg->RootNode)->children;\n\t\t\twhile (list) {\n\t\t\t\tgf_dump_vrml_node(sdump, list->node, 0, NULL);\n\t\t\t\tlist = list->next;\n\t\t\t}\n\t\t} else {\n\t\t\tgf_dump_vrml_node(sdump, sdump->sg->RootNode, 0, NULL);\n\t\t}\n\t\tif (!sdump->XMLDump) gf_fprintf(sdump->trace, \"\\n\\n\");\n\t\tif (!skip_routes) {\n\t\t\tGF_Route *r;\n\t\t\tu32 i=0;\n\t\t\twhile ((r = (GF_Route*)gf_list_enum(sdump->sg->Routes, &i))) {\n\t\t\t\tif (r->IS_route || (r->graph!=sdump->sg)) continue;\n\t\t\t\te = gf_dump_vrml_route(sdump, r, 0);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tif (sdump->XMLDump) {\n\t\t\tsdump->indent--;\n\t\t\tEndElement(sdump, \"Scene\", 1);\n\t\t}\n#endif /*GPAC_DISABLE_VRML*/\n\n\t\tgf_dump_finalize(sdump, NULL);\n\t\treturn GF_OK;\n\t}\n#ifndef GPAC_DISABLE_SVG\n\telse if ((tag>=GF_NODE_RANGE_FIRST_SVG) && (tag<=GF_NODE_RANGE_LAST_SVG)) {\n\t\tsdump->dump_mode = GF_SM_DUMP_SVG;\n\t\tgf_dump_setup(sdump, NULL);\n\t\tgf_dump_svg_element(sdump, sdump->sg->RootNode, NULL, 1);\n\t\treturn GF_OK;\n\t}\n\telse if (tag==TAG_DOMFullNode) {\n\t\tsdump->dump_mode = GF_SM_DUMP_XML;\n\t\tgf_dump_setup(sdump, NULL);\n\t\tSD_DumpDOMElement(sdump, (GF_DOMFullNode*)sdump->sg->RootNode);\n\t}\n#endif\n\n\treturn GF_OK;\n}\n\n\n\n\nstatic void ReorderAUContext(GF_List *sample_list, GF_AUContext *au, Bool lsr_dump)\n{\n\tu64 autime, time;\n\tu32 i;\n\tBool has_base;\n\tGF_AUContext *ptr;\n\n\t/*\n\t\tthis happens when converting from bt to xmt\n\t\tNOTE: Comment is wrong? this happens when just loading BT\n\t*/\n\tif (!au->timing_sec) {\n\t\tau->timing_sec = (Double) (s64) au->timing;\n\t\t/* Hack to avoid timescale=0 which happens when loading a BT with no SLConfig*/\n\t\tif (!au->owner->timeScale) au->owner->timeScale = 1000;\n\t\tau->timing_sec /= au->owner->timeScale;\n\t}\n\t/*this happens when converting from xmt to bt*/\n\tif (!au->timing) {\n\t\tassert(au->owner->timeScale);\n\t\tau->timing = (u64) (au->timing_sec * au->owner->timeScale);\n\t}\n\n\tautime = au->timing + au->owner->imp_exp_time;\n\thas_base = 0;\n\ti=0;\n\twhile ((ptr = (GF_AUContext*)gf_list_enum(sample_list, &i))) {\n\t\ttime = ptr->timing + ptr->owner->imp_exp_time;\n\t\tif (\n\t\t    /*time ordered*/\n\t\t    (time > autime)\n\t\t    /*set bifs first for first AU*/\n\t\t    || (!has_base && (time == autime) && (ptr->owner->streamType < au->owner->streamType) )\n\t\t    /*set OD first for laser*/\n\t\t    || (lsr_dump && (au->owner->streamType==GF_STREAM_OD))\n\t\t) {\n\t\t\tgf_list_insert(sample_list, au, i-1);\n\t\t\treturn;\n\t\t}\n\n\t\thas_base = 0;\n\t\tif ( (ptr->owner->streamType == au->owner->streamType) && (time == autime) ) has_base = 1;\n\t}\n\tgf_list_add(sample_list, au);\n}\n\n\nGF_EXPORT\nGF_Err gf_sm_dump(GF_SceneManager *ctx, char *rad_name, Bool is_final_name, GF_SceneDumpFormat dump_mode)\n{\n\tGF_Err e;\n\tGF_List *sample_list;\n\tBool first_par;\n\tu32 i, j, indent, num_scene, num_od, first_bifs, num_tracks;\n\tDouble time;\n\tGF_SceneDumper *dumper;\n\tGF_StreamContext *sc;\n\tGF_AUContext *au;\n\tBool no_root_found = 1;\n\n\tsample_list = gf_list_new();\n\n\tnum_scene = num_od = 0;\n\tnum_tracks = 0;\n\tindent = 0;\n\tdumper = gf_sm_dumper_new(ctx->scene_graph, rad_name, is_final_name, ' ', dump_mode);\n\te = GF_OK;\n\t/*configure all systems streams we're dumping*/\n\ti=0;\n\twhile ((sc = (GF_StreamContext*)gf_list_enum(ctx->streams, &i))) {\n\n\t\tswitch (sc->streamType) {\n\t\tcase GF_STREAM_SCENE:\n\t\t\tnum_scene ++;\n\t\t\tnum_tracks ++;\n\t\t\tbreak;\n\t\tcase GF_STREAM_OD:\n\t\t\tnum_od ++;\n\t\t\tnum_tracks ++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tj=0;\n\t\twhile ((au = (GF_AUContext*)gf_list_enum(sc->AUs, &j))) {\n\t\t\tReorderAUContext(sample_list, au, dumper->LSRDump);\n\t\t\tif (dumper->dump_mode==GF_SM_DUMP_SVG) break;\n\t\t}\n\t\tif (dumper->dump_mode==GF_SM_DUMP_SVG) break;\n\t}\n\tfirst_bifs = (num_scene==1) ? 1 : 0;\n\tnum_scene = (num_scene>1) ? 1 : 0;\n\tnum_od = (num_od>1) ? 1 : 0;\n\n\tgf_dump_setup(dumper, (GF_Descriptor *) ctx->root_od);\n\n#ifndef GPAC_DISABLE_SVG\n\tif (dumper->dump_mode==GF_SM_DUMP_SVG) {\n\t\tau = (GF_AUContext*)gf_list_get(sample_list, 0);\n\t\tGF_Command *com = NULL;\n\t\tif (au) com = (GF_Command*)gf_list_get(au->commands, 0);\n\t\tif (!au) {\n\t\t\tgf_dump_svg_element(dumper, dumper->sg->RootNode, NULL, 1);\n\t\t} else if (!com || (com->tag!=GF_SG_LSR_NEW_SCENE) || !com->node) {\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t} else {\n\t\t\tgf_dump_svg_element(dumper, com->node, NULL, 1);\n\t\t}\n\t\tgf_dump_finalize(dumper, (GF_Descriptor *) ctx->root_od);\n\t\tgf_sm_dumper_del(dumper);\n\t\tgf_list_del(sample_list);\n\t\treturn e;\n\t}\n#endif\n\n\ttime = dumper->LSRDump ? -1 : 0;\n\tfirst_par = 0;\n\n\twhile (gf_list_count(sample_list)) {\n\t\tau = (GF_AUContext*)gf_list_get(sample_list, 0);\n\t\tgf_list_rem(sample_list, 0);\n\n\t\tif (!dumper->XMLDump) {\n\n\t\t\tif (!first_bifs || (au->owner->streamType != GF_STREAM_SCENE) ) {\n\t\t\t\tif (au->flags & GF_SM_AU_RAP) gf_fprintf(dumper->trace, \"RAP \");\n\t\t\t\tgf_fprintf(dumper->trace, \"AT \"LLD\" \", au->timing);\n\t\t\t\tif ( (au->owner->streamType==GF_STREAM_OD && num_od) || (au->owner->streamType==GF_STREAM_SCENE && num_scene)) {\n\t\t\t\t\tgf_fprintf(dumper->trace, \"IN %d \", au->owner->ESID);\n\t\t\t\t}\n\t\t\t\tgf_fprintf(dumper->trace, \"{\\n\");\n\t\t\t\tindent++;\n\t\t\t}\n\n\t\t\tswitch (au->owner->streamType) {\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (dumper->LSRDump) {\n\t\t\t\t\tdump_od_to_saf(dumper, au, indent);\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\t\t\te = gf_odf_dump_com_list(au->commands, dumper->trace, indent+1, 0);\n#endif\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\te = gf_sm_dump_command_list(dumper, au->commands, indent, first_bifs);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (first_bifs) {\n\t\t\t\tfirst_bifs = 0;\n\t\t\t\tgf_fprintf(dumper->trace, \"\\n\");\n\n\t\t\t} else {\n\t\t\t\tindent--;\n\t\t\t\tgf_fprintf(dumper->trace, \"}\\n\\n\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (dumper->LSRDump) {\n/*\t\t\t\tif (time != au->timing_sec) {\n\t\t\t\t\ttime = au->timing_sec;\n\t\t\t\t}\n*/\n\t\t\t} else if (!time && !num_scene && first_bifs) {\n\t\t\t} else if (num_scene || num_od) {\n\t\t\t\tif (!first_par) {\n\t\t\t\t\tfirst_par = 1;\n\t\t\t\t\tindent += 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(dumper->trace, \" </par>\\n\");\n\t\t\t\t}\n\t\t\t\tgf_fprintf(dumper->trace, \" <par begin=\\\"%g\\\" atES_ID=\\\"es%d\\\" isRAP=\\\"%s\\\">\\n\", au->timing_sec, au->owner->ESID, (au->flags & GF_SM_AU_RAP) ? \"yes\" : \"no\");\n\t\t\t} else if (au->timing_sec>time) {\n\t\t\t\tif (!first_par) {\n\t\t\t\t\tfirst_par = 1;\n\t\t\t\t\tindent += 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(dumper->trace, \" </par>\\n\");\n\t\t\t\t}\n\t\t\t\tgf_fprintf(dumper->trace, \"<par begin=\\\"%g\\\">\\n\", au->timing_sec);\n\t\t\t}\n\t\t\tswitch (au->owner->streamType) {\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tif (dumper->LSRDump) {\n\t\t\t\t\tdump_od_to_saf(dumper, au, indent+1);\n\t\t\t\t} else {\n#ifndef GPAC_DISABLE_OD_DUMP\n\t\t\t\t\te = gf_odf_dump_com_list(au->commands, dumper->trace, indent+1, 1);\n#endif\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\tif (gf_list_count(au->commands)) {\n\t\t\t\t\tif (dumper->LSRDump)\n\t\t\t\t\t\tgf_sm_dump_saf_hdr(dumper, \"sceneUnit\", au->timing, au->flags & GF_SM_AU_RAP);\n\n\t\t\t\t\te = gf_sm_dump_command_list(dumper, au->commands, indent+1, first_bifs);\n\t\t\t\t\tfirst_bifs = 0;\n\t\t\t\t\tno_root_found = 0;\n\n\t\t\t\t\tif (dumper->LSRDump)\n\t\t\t\t\t\tgf_fprintf(dumper->trace, \"</saf:sceneUnit>\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttime = au->timing_sec;\n\t\t}\n\t\tif (dumper->X3DDump || (dumper->dump_mode==GF_SM_DUMP_VRML)) break;\n\t}\n\n#ifndef GPAC_DISABLE_VRML\n\tif (no_root_found && ctx->scene_graph->RootNode) {\n\t\tGF_Route *r;\n\t\tDumpProtos(dumper, ctx->scene_graph->protos);\n\t\tgf_dump_vrml_node(dumper, ctx->scene_graph->RootNode, 0, NULL);\n\t\ti=0;\n\t\tgf_fprintf(dumper->trace, \"\\n\");\n\t\twhile ((r = (GF_Route*)gf_list_enum(dumper->sg->Routes, &i))) {\n\t\t\tif (r->IS_route || (r->graph!=dumper->sg)) continue;\n\t\t\te = gf_dump_vrml_route(dumper, r, 0);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n#endif\n\n\n\t/*close command*/\n\tif (!dumper->X3DDump && first_par) gf_fprintf(dumper->trace, \" </par>\\n\");\n\n\tif (gf_list_count(sample_list) && (dumper->X3DDump || (dumper->dump_mode==GF_SM_DUMP_VRML)) ) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[Scene Dump] MPEG-4 Commands found, not supported in %s - skipping\\n\", dumper->X3DDump ? \"X3D\" : \"VRML\"));\n\t}\n\n\tgf_dump_finalize(dumper, (GF_Descriptor *) ctx->root_od);\n\tgf_sm_dumper_del(dumper);\n\tgf_list_del(sample_list);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_SCENE_DUMP*/\n"], "filenames": ["src/scene_manager/scene_dump.c"], "buggy_code_start_loc": [788], "buggy_code_end_loc": [1272], "fixing_code_start_loc": [788], "fixing_code_end_loc": [1268], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.", "other": {"cve": {"id": "CVE-2022-2549", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-27T15:15:08.550", "lastModified": "2022-08-03T16:37:10.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV."}, {"lang": "es", "value": "Una Desreferencia de Puntero NULL en el repositorio de GitHub gpac/gpac versiones anteriores a 2.1.0-DEV"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.0", "matchCriteriaId": "6FDA7EFB-AFD8-40D1-B517-04A825BC302A"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/0102c5d4db7fdbf08b5b591b2a6264de33867a07", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c93083dc-177c-4ba0-ba83-9d7fb29a5537", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/0102c5d4db7fdbf08b5b591b2a6264de33867a07"}}