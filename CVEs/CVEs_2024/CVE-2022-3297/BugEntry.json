{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * insexpand.c: functions for Insert mode completion\n */\n\n#include \"vim.h\"\n\n/*\n * Definitions used for CTRL-X submode.\n * Note: If you change CTRL-X submode, you must also maintain ctrl_x_msgs[] and\n * ctrl_x_mode_names[] below.\n */\n# define CTRL_X_WANT_IDENT\t0x100\n\n# define CTRL_X_NORMAL\t\t0  // CTRL-N CTRL-P completion, default\n# define CTRL_X_NOT_DEFINED_YET\t1\n# define CTRL_X_SCROLL\t\t2\n# define CTRL_X_WHOLE_LINE\t3\n# define CTRL_X_FILES\t\t4\n# define CTRL_X_TAGS\t\t(5 + CTRL_X_WANT_IDENT)\n# define CTRL_X_PATH_PATTERNS\t(6 + CTRL_X_WANT_IDENT)\n# define CTRL_X_PATH_DEFINES\t(7 + CTRL_X_WANT_IDENT)\n# define CTRL_X_FINISHED\t\t8\n# define CTRL_X_DICTIONARY\t(9 + CTRL_X_WANT_IDENT)\n# define CTRL_X_THESAURUS\t(10 + CTRL_X_WANT_IDENT)\n# define CTRL_X_CMDLINE\t\t11\n# define CTRL_X_FUNCTION\t12\n# define CTRL_X_OMNI\t\t13\n# define CTRL_X_SPELL\t\t14\n# define CTRL_X_LOCAL_MSG\t15\t// only used in \"ctrl_x_msgs\"\n# define CTRL_X_EVAL\t\t16\t// for builtin function complete()\n# define CTRL_X_CMDLINE_CTRL_X\t17\t// CTRL-X typed in CTRL_X_CMDLINE\n\n# define CTRL_X_MSG(i) ctrl_x_msgs[(i) & ~CTRL_X_WANT_IDENT]\n\n// Message for CTRL-X mode, index is ctrl_x_mode.\nstatic char *ctrl_x_msgs[] =\n{\n    N_(\" Keyword completion (^N^P)\"), // CTRL_X_NORMAL, ^P/^N compl.\n    N_(\" ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)\"),\n    NULL, // CTRL_X_SCROLL: depends on state\n    N_(\" Whole line completion (^L^N^P)\"),\n    N_(\" File name completion (^F^N^P)\"),\n    N_(\" Tag completion (^]^N^P)\"),\n    N_(\" Path pattern completion (^N^P)\"),\n    N_(\" Definition completion (^D^N^P)\"),\n    NULL, // CTRL_X_FINISHED\n    N_(\" Dictionary completion (^K^N^P)\"),\n    N_(\" Thesaurus completion (^T^N^P)\"),\n    N_(\" Command-line completion (^V^N^P)\"),\n    N_(\" User defined completion (^U^N^P)\"),\n    N_(\" Omni completion (^O^N^P)\"),\n    N_(\" Spelling suggestion (s^N^P)\"),\n    N_(\" Keyword Local completion (^N^P)\"),\n    NULL,   // CTRL_X_EVAL doesn't use msg.\n    N_(\" Command-line completion (^V^N^P)\"),\n};\n\n#if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL)\nstatic char *ctrl_x_mode_names[] = {\n\t\"keyword\",\n\t\"ctrl_x\",\n\t\"scroll\",\n\t\"whole_line\",\n\t\"files\",\n\t\"tags\",\n\t\"path_patterns\",\n\t\"path_defines\",\n\t\"unknown\",\t    // CTRL_X_FINISHED\n\t\"dictionary\",\n\t\"thesaurus\",\n\t\"cmdline\",\n\t\"function\",\n\t\"omni\",\n\t\"spell\",\n\tNULL,\t\t    // CTRL_X_LOCAL_MSG only used in \"ctrl_x_msgs\"\n\t\"eval\",\n\t\"cmdline\",\n};\n#endif\n\n/*\n * Array indexes used for cp_text[].\n */\n#define CPT_ABBR\t0\t// \"abbr\"\n#define CPT_MENU\t1\t// \"menu\"\n#define CPT_KIND\t2\t// \"kind\"\n#define CPT_INFO\t3\t// \"info\"\n#define CPT_COUNT\t4\t// Number of entries\n\n/*\n * Structure used to store one match for insert completion.\n */\ntypedef struct compl_S compl_T;\nstruct compl_S\n{\n    compl_T\t*cp_next;\n    compl_T\t*cp_prev;\n    char_u\t*cp_str;\t// matched text\n    char_u\t*(cp_text[CPT_COUNT]);\t// text for the menu\n#ifdef FEAT_EVAL\n    typval_T\tcp_user_data;\n#endif\n    char_u\t*cp_fname;\t// file containing the match, allocated when\n\t\t\t\t// cp_flags has CP_FREE_FNAME\n    int\t\tcp_flags;\t// CP_ values\n    int\t\tcp_number;\t// sequence number\n};\n\n// values for cp_flags\n# define CP_ORIGINAL_TEXT   1\t// the original text when the expansion begun\n# define CP_FREE_FNAME\t    2\t// cp_fname is allocated\n# define CP_CONT_S_IPOS\t    4\t// use CONT_S_IPOS for compl_cont_status\n# define CP_EQUAL\t    8\t// ins_compl_equal() always returns TRUE\n# define CP_ICASE\t    16\t// ins_compl_equal() ignores case\n# define CP_FAST\t    32\t// use fast_breakcheck instead of ui_breakcheck\n\nstatic char e_hitend[] = N_(\"Hit end of paragraph\");\n\n/*\n * All the current matches are stored in a list.\n * \"compl_first_match\" points to the start of the list.\n * \"compl_curr_match\" points to the currently selected entry.\n * \"compl_shown_match\" is different from compl_curr_match during\n * ins_compl_get_exp().\n * \"compl_old_match\" points to previous \"compl_curr_match\".\n */\nstatic compl_T    *compl_first_match = NULL;\nstatic compl_T    *compl_curr_match = NULL;\nstatic compl_T    *compl_shown_match = NULL;\nstatic compl_T    *compl_old_match = NULL;\n\n// After using a cursor key <Enter> selects a match in the popup menu,\n// otherwise it inserts a line break.\nstatic int\t  compl_enter_selects = FALSE;\n\n// When \"compl_leader\" is not NULL only matches that start with this string\n// are used.\nstatic char_u\t  *compl_leader = NULL;\n\nstatic int\t  compl_get_longest = FALSE;\t// put longest common string\n\t\t\t\t\t\t// in compl_leader\n\nstatic int\t  compl_no_insert = FALSE;\t// FALSE: select & insert\n\t\t\t\t\t\t// TRUE: noinsert\nstatic int\t  compl_no_select = FALSE;\t// FALSE: select & insert\n\t\t\t\t\t\t// TRUE: noselect\nstatic int\t  compl_longest = FALSE;\t// FALSE: insert full match\n\t\t\t\t\t\t// TRUE: insert longest prefix\n\n// Selected one of the matches.  When FALSE the match was edited or using the\n// longest common string.\nstatic int\t  compl_used_match;\n\n// didn't finish finding completions.\nstatic int\t  compl_was_interrupted = FALSE;\n\n// Set when character typed while looking for matches and it means we should\n// stop looking for matches.\nstatic int\t  compl_interrupted = FALSE;\n\nstatic int\t  compl_restarting = FALSE;\t// don't insert match\n\n// When the first completion is done \"compl_started\" is set.  When it's\n// FALSE the word to be completed must be located.\nstatic int\t  compl_started = FALSE;\n\n// Which Ctrl-X mode are we in?\nstatic int\t  ctrl_x_mode = CTRL_X_NORMAL;\n\nstatic int\t  compl_matches = 0;\t    // number of completion matches\nstatic char_u\t  *compl_pattern = NULL;\nstatic int\t  compl_direction = FORWARD;\nstatic int\t  compl_shows_dir = FORWARD;\nstatic int\t  compl_pending = 0;\t    // > 1 for postponed CTRL-N\nstatic pos_T\t  compl_startpos;\n// Length in bytes of the text being completed (this is deleted to be replaced\n// by the match.)\nstatic int\t  compl_length = 0;\nstatic colnr_T\t  compl_col = 0;\t    // column where the text starts\n\t\t\t\t\t    // that is being completed\nstatic char_u\t  *compl_orig_text = NULL;  // text as it was before\n\t\t\t\t\t    // completion started\nstatic int\t  compl_cont_mode = 0;\nstatic expand_T\t  compl_xp;\n\n// List of flags for method of completion.\nstatic int\t  compl_cont_status = 0;\n# define CONT_ADDING\t1\t// \"normal\" or \"adding\" expansion\n# define CONT_INTRPT\t(2 + 4)\t// a ^X interrupted the current expansion\n\t\t\t\t// it's set only iff N_ADDS is set\n# define CONT_N_ADDS\t4\t// next ^X<> will add-new or expand-current\n# define CONT_S_IPOS\t8\t// next ^X<> will set initial_pos?\n\t\t\t\t// if so, word-wise-expansion will set SOL\n# define CONT_SOL\t16\t// pattern includes start of line, just for\n\t\t\t\t// word-wise expansion, not set for ^X^L\n# define CONT_LOCAL\t32\t// for ctrl_x_mode 0, ^X^P/^X^N do a local\n\t\t\t\t// expansion, (eg use complete=.)\n\nstatic int\t  compl_opt_refresh_always = FALSE;\nstatic int\t  compl_opt_suppress_empty = FALSE;\n\nstatic int ins_compl_add(char_u *str, int len, char_u *fname, char_u **cptext, typval_T *user_data, int cdir, int flags, int adup);\nstatic void ins_compl_longest_match(compl_T *match);\nstatic void ins_compl_del_pum(void);\nstatic void ins_compl_files(int count, char_u **files, int thesaurus, int flags, regmatch_T *regmatch, char_u *buf, int *dir);\nstatic char_u *find_line_end(char_u *ptr);\nstatic void ins_compl_free(void);\nstatic int  ins_compl_need_restart(void);\nstatic void ins_compl_new_leader(void);\nstatic int  get_compl_len(void);\nstatic void ins_compl_restart(void);\nstatic void ins_compl_set_original_text(char_u *str);\nstatic void ins_compl_fixRedoBufForLeader(char_u *ptr_arg);\n# if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL)\nstatic void ins_compl_add_list(list_T *list);\nstatic void ins_compl_add_dict(dict_T *dict);\n# endif\nstatic int  ins_compl_key2dir(int c);\nstatic int  ins_compl_pum_key(int c);\nstatic int  ins_compl_key2count(int c);\nstatic void show_pum(int prev_w_wrow, int prev_w_leftcol);\nstatic unsigned  quote_meta(char_u *dest, char_u *str, int len);\n\n#ifdef FEAT_SPELL\nstatic void spell_back_to_badword(void);\nstatic int  spell_bad_len = 0;\t// length of located bad word\n#endif\n\n/*\n * CTRL-X pressed in Insert mode.\n */\n    void\nins_ctrl_x(void)\n{\n    if (!ctrl_x_mode_cmdline())\n    {\n\t// if the next ^X<> won't ADD nothing, then reset compl_cont_status\n\tif (compl_cont_status & CONT_N_ADDS)\n\t    compl_cont_status |= CONT_INTRPT;\n\telse\n\t    compl_cont_status = 0;\n\t// We're not sure which CTRL-X mode it will be yet\n\tctrl_x_mode = CTRL_X_NOT_DEFINED_YET;\n\tedit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));\n\tedit_submode_pre = NULL;\n\tshowmode();\n    }\n    else\n\t// CTRL-X in CTRL-X CTRL-V mode behaves differently to make CTRL-X\n\t// CTRL-V look like CTRL-N\n\tctrl_x_mode = CTRL_X_CMDLINE_CTRL_X;\n\n    may_trigger_modechanged();\n}\n\n/*\n * Functions to check the current CTRL-X mode.\n */\nint ctrl_x_mode_none(void) { return ctrl_x_mode == 0; }\nint ctrl_x_mode_normal(void) { return ctrl_x_mode == CTRL_X_NORMAL; }\nint ctrl_x_mode_scroll(void) { return ctrl_x_mode == CTRL_X_SCROLL; }\nint ctrl_x_mode_whole_line(void) { return ctrl_x_mode == CTRL_X_WHOLE_LINE; }\nint ctrl_x_mode_files(void) { return ctrl_x_mode == CTRL_X_FILES; }\nint ctrl_x_mode_tags(void) { return ctrl_x_mode == CTRL_X_TAGS; }\nint ctrl_x_mode_path_patterns(void) {\n\t\t\t\t  return ctrl_x_mode == CTRL_X_PATH_PATTERNS; }\nint ctrl_x_mode_path_defines(void) {\n\t\t\t\t   return ctrl_x_mode == CTRL_X_PATH_DEFINES; }\nint ctrl_x_mode_dictionary(void) { return ctrl_x_mode == CTRL_X_DICTIONARY; }\nint ctrl_x_mode_thesaurus(void) { return ctrl_x_mode == CTRL_X_THESAURUS; }\nint ctrl_x_mode_cmdline(void) {\n\treturn ctrl_x_mode == CTRL_X_CMDLINE\n\t\t|| ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X; }\nint ctrl_x_mode_function(void) { return ctrl_x_mode == CTRL_X_FUNCTION; }\nint ctrl_x_mode_omni(void) { return ctrl_x_mode == CTRL_X_OMNI; }\nint ctrl_x_mode_spell(void) { return ctrl_x_mode == CTRL_X_SPELL; }\nstatic int ctrl_x_mode_eval(void) { return ctrl_x_mode == CTRL_X_EVAL; }\nint ctrl_x_mode_line_or_eval(void) {\n       return ctrl_x_mode == CTRL_X_WHOLE_LINE || ctrl_x_mode == CTRL_X_EVAL; }\n\n/*\n * Whether other than default completion has been selected.\n */\n    int\nctrl_x_mode_not_default(void)\n{\n    return ctrl_x_mode != CTRL_X_NORMAL;\n}\n\n/*\n * Whether CTRL-X was typed without a following character,\n * not including when in CTRL-X CTRL-V mode.\n */\n    int\nctrl_x_mode_not_defined_yet(void)\n{\n    return ctrl_x_mode == CTRL_X_NOT_DEFINED_YET;\n}\n\n/*\n * Return TRUE if currently in \"normal\" or \"adding\" insert completion matches\n * state\n */\n    int\ncompl_status_adding(void)\n{\n    return compl_cont_status & CONT_ADDING;\n}\n\n/*\n * Return TRUE if the completion pattern includes start of line, just for\n * word-wise expansion.\n */\n    int\ncompl_status_sol(void)\n{\n    return compl_cont_status & CONT_SOL;\n}\n\n/*\n * Return TRUE if ^X^P/^X^N will do a local completion (i.e. use complete=.)\n */\n    int\ncompl_status_local(void)\n{\n    return compl_cont_status & CONT_LOCAL;\n}\n\n/*\n * Clear the completion status flags\n */\n    void\ncompl_status_clear(void)\n{\n    compl_cont_status = 0;\n}\n\n/*\n * Return TRUE if completion is using the forward direction matches\n */\n    static int\ncompl_dir_forward(void)\n{\n    return compl_direction == FORWARD;\n}\n\n/*\n * Return TRUE if currently showing forward completion matches\n */\n    static int\ncompl_shows_dir_forward(void)\n{\n    return compl_shows_dir == FORWARD;\n}\n\n/*\n * Return TRUE if currently showing backward completion matches\n */\n    static int\ncompl_shows_dir_backward(void)\n{\n    return compl_shows_dir == BACKWARD;\n}\n\n/*\n * Return TRUE if the 'dictionary' or 'thesaurus' option can be used.\n */\n    int\nhas_compl_option(int dict_opt)\n{\n    if (dict_opt ? (*curbuf->b_p_dict == NUL && *p_dict == NUL\n#ifdef FEAT_SPELL\n\t\t\t\t\t\t\t&& !curwin->w_p_spell\n#endif\n\t\t\t\t\t\t\t)\n\t\t : (*curbuf->b_p_tsr == NUL && *p_tsr == NUL\n#ifdef FEAT_COMPL_FUNC\n\t\t     && *curbuf->b_p_tsrfu == NUL && *p_tsrfu == NUL\n#endif\n\t\t   ))\n    {\n\tctrl_x_mode = CTRL_X_NORMAL;\n\tedit_submode = NULL;\n\tmsg_attr(dict_opt ? _(\"'dictionary' option is empty\")\n\t\t\t  : _(\"'thesaurus' option is empty\"),\n\t\t\t\t\t\t\t      HL_ATTR(HLF_E));\n\tif (emsg_silent == 0 && !in_assert_fails)\n\t{\n\t    vim_beep(BO_COMPL);\n\t    setcursor();\n\t    out_flush();\n#ifdef FEAT_EVAL\n\t    if (!get_vim_var_nr(VV_TESTING))\n#endif\n\t\tui_delay(2004L, FALSE);\n\t}\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Is the character \"c\" a valid key to go to or keep us in CTRL-X mode?\n * This depends on the current mode.\n */\n    int\nvim_is_ctrl_x_key(int c)\n{\n    // Always allow ^R - let its results then be checked\n    if (c == Ctrl_R)\n\treturn TRUE;\n\n    // Accept <PageUp> and <PageDown> if the popup menu is visible.\n    if (ins_compl_pum_key(c))\n\treturn TRUE;\n\n    switch (ctrl_x_mode)\n    {\n\tcase 0:\t\t    // Not in any CTRL-X mode\n\t    return (c == Ctrl_N || c == Ctrl_P || c == Ctrl_X);\n\tcase CTRL_X_NOT_DEFINED_YET:\n\tcase CTRL_X_CMDLINE_CTRL_X:\n\t    return (   c == Ctrl_X || c == Ctrl_Y || c == Ctrl_E\n\t\t    || c == Ctrl_L || c == Ctrl_F || c == Ctrl_RSB\n\t\t    || c == Ctrl_I || c == Ctrl_D || c == Ctrl_P\n\t\t    || c == Ctrl_N || c == Ctrl_T || c == Ctrl_V\n\t\t    || c == Ctrl_Q || c == Ctrl_U || c == Ctrl_O\n\t\t    || c == Ctrl_S || c == Ctrl_K || c == 's'\n\t\t    || c == Ctrl_Z);\n\tcase CTRL_X_SCROLL:\n\t    return (c == Ctrl_Y || c == Ctrl_E);\n\tcase CTRL_X_WHOLE_LINE:\n\t    return (c == Ctrl_L || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_FILES:\n\t    return (c == Ctrl_F || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_DICTIONARY:\n\t    return (c == Ctrl_K || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_THESAURUS:\n\t    return (c == Ctrl_T || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_TAGS:\n\t    return (c == Ctrl_RSB || c == Ctrl_P || c == Ctrl_N);\n#ifdef FEAT_FIND_ID\n\tcase CTRL_X_PATH_PATTERNS:\n\t    return (c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_PATH_DEFINES:\n\t    return (c == Ctrl_D || c == Ctrl_P || c == Ctrl_N);\n#endif\n\tcase CTRL_X_CMDLINE:\n\t    return (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_P || c == Ctrl_N\n\t\t    || c == Ctrl_X);\n#ifdef FEAT_COMPL_FUNC\n\tcase CTRL_X_FUNCTION:\n\t    return (c == Ctrl_U || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_OMNI:\n\t    return (c == Ctrl_O || c == Ctrl_P || c == Ctrl_N);\n#endif\n\tcase CTRL_X_SPELL:\n\t    return (c == Ctrl_S || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_EVAL:\n\t    return (c == Ctrl_P || c == Ctrl_N);\n    }\n    internal_error(\"vim_is_ctrl_x_key()\");\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"match\" is the original text when the completion began.\n */\n    static int\nmatch_at_original_text(compl_T *match)\n{\n    return match->cp_flags & CP_ORIGINAL_TEXT;\n}\n\n/*\n * Returns TRUE if \"match\" is the first match in the completion list.\n */\n    static int\nis_first_match(compl_T *match)\n{\n    return match == compl_first_match;\n}\n\n/*\n * Return TRUE when character \"c\" is part of the item currently being\n * completed.  Used to decide whether to abandon complete mode when the menu\n * is visible.\n */\n    int\nins_compl_accept_char(int c)\n{\n    if (ctrl_x_mode & CTRL_X_WANT_IDENT)\n\t// When expanding an identifier only accept identifier chars.\n\treturn vim_isIDc(c);\n\n    switch (ctrl_x_mode)\n    {\n\tcase CTRL_X_FILES:\n\t    // When expanding file name only accept file name chars. But not\n\t    // path separators, so that \"proto/<Tab>\" expands files in\n\t    // \"proto\", not \"proto/\" as a whole\n\t    return vim_isfilec(c) && !vim_ispathsep(c);\n\n\tcase CTRL_X_CMDLINE:\n\tcase CTRL_X_CMDLINE_CTRL_X:\n\tcase CTRL_X_OMNI:\n\t    // Command line and Omni completion can work with just about any\n\t    // printable character, but do stop at white space.\n\t    return vim_isprintc(c) && !VIM_ISWHITE(c);\n\n\tcase CTRL_X_WHOLE_LINE:\n\t    // For while line completion a space can be part of the line.\n\t    return vim_isprintc(c);\n    }\n    return vim_iswordc(c);\n}\n\n/*\n * Get the completed text by inferring the case of the originally typed text.\n * If the result is in allocated memory \"tofree\" is set to it.\n */\n    static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    *p = NUL;\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}\n\n/*\n * This is like ins_compl_add(), but if 'ic' and 'inf' are set, then the\n * case of the originally typed text is used, and the case of the completed\n * text is inferred, ie this tries to work out what case you probably wanted\n * the rest of the word to be in -- webb\n */\n    int\nins_compl_add_infercase(\n    char_u\t*str_arg,\n    int\t\tlen,\n    int\t\ticase,\n    char_u\t*fname,\n    int\t\tdir,\n    int\t\tcont_s_ipos)  // next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tchar_len;\t\t// count multi-byte characters\n    int\t\tcompl_char_len;\n    int\t\tmin_len;\n    int\t\tflags = 0;\n    int\t\tres;\n    char_u\t*tofree = NULL;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t// Infer case of completed part.\n\n\t// Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++char_len;\n\t    }\n\t}\n\telse\n\t    char_len = len;\n\n\t// Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    compl_char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++compl_char_len;\n\t    }\n\t}\n\telse\n\t    compl_char_len = compl_length;\n\n\t// \"char_len\" may be smaller than \"compl_char_len\" when using\n\t// thesaurus, only use the minimum when comparing.\n\tmin_len = char_len < compl_char_len ? char_len : compl_char_len;\n\n\tstr = ins_compl_infercase_gettext(str, char_len,\n\t\t\t\t\t  compl_char_len, min_len, &tofree);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n    vim_free(tofree);\n    return res;\n}\n\n/*\n * Add a match to the list of matches. The arguments are:\n *     str       - text of the match to add\n *     len       - length of \"str\". If -1, then the length of \"str\" is\n *\t\t   computed.\n *     fname     - file name to associate with this match.\n *     cptext    - list of strings to use with this match (for abbr, menu, info\n *\t\t   and kind)\n *     user_data - user supplied data (any vim type) for this match\n *     cdir\t - match direction. If 0, use \"compl_direction\".\n *     flags_arg - match flags (cp_flags)\n *     adup\t - accept this match even if it is already present.\n * If \"cdir\" is FORWARD, then the match is added after the current match.\n * Otherwise, it is added before the current match.\n *\n * If the given string is already in the list of completions, then return\n * NOTDONE, otherwise add it to the list and return OK.  If there is an error,\n * maybe because alloc() returns NULL, then FAIL is returned.\n */\n    static int\nins_compl_add(\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*fname,\n    char_u\t**cptext,\t    // extra text for popup menu or NULL\n    typval_T\t*user_data UNUSED,  // \"user_data\" entry or NULL\n    int\t\tcdir,\n    int\t\tflags_arg,\n    int\t\tadup)\t\t// accept duplicate match\n{\n    compl_T\t*match;\n    int\t\tdir = (cdir == 0 ? compl_direction : cdir);\n    int\t\tflags = flags_arg;\n\n    if (flags & CP_FAST)\n\tfast_breakcheck();\n    else\n\tui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // If the same match is already present, don't add it.\n    if (compl_first_match != NULL && !adup)\n    {\n\tmatch = compl_first_match;\n\tdo\n\t{\n\t    if (!match_at_original_text(match)\n\t\t    && STRNCMP(match->cp_str, str, len) == 0\n\t\t    && ((int)STRLEN(match->cp_str) <= len\n\t\t\t\t\t\t || match->cp_str[len] == NUL))\n\t\treturn NOTDONE;\n\t    match = match->cp_next;\n\t} while (match != NULL && !is_first_match(match));\n    }\n\n    // Remove any popup menu before changing the list of matches.\n    ins_compl_del_pum();\n\n    // Allocate a new match structure.\n    // Copy the values to the new match structure.\n    match = ALLOC_CLEAR_ONE(compl_T);\n    if (match == NULL)\n\treturn FAIL;\n    match->cp_number = -1;\n    if (flags & CP_ORIGINAL_TEXT)\n\tmatch->cp_number = 0;\n    if ((match->cp_str = vim_strnsave(str, len)) == NULL)\n    {\n\tvim_free(match);\n\treturn FAIL;\n    }\n\n    // match-fname is:\n    // - compl_curr_match->cp_fname if it is a string equal to fname.\n    // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.\n    // - NULL otherwise.\t--Acevedo\n    if (fname != NULL\n\t    && compl_curr_match != NULL\n\t    && compl_curr_match->cp_fname != NULL\n\t    && STRCMP(fname, compl_curr_match->cp_fname) == 0)\n\tmatch->cp_fname = compl_curr_match->cp_fname;\n    else if (fname != NULL)\n    {\n\tmatch->cp_fname = vim_strsave(fname);\n\tflags |= CP_FREE_FNAME;\n    }\n    else\n\tmatch->cp_fname = NULL;\n    match->cp_flags = flags;\n\n    if (cptext != NULL)\n    {\n\tint i;\n\n\tfor (i = 0; i < CPT_COUNT; ++i)\n\t    if (cptext[i] != NULL && *cptext[i] != NUL)\n\t\tmatch->cp_text[i] = vim_strsave(cptext[i]);\n    }\n#ifdef FEAT_EVAL\n    if (user_data != NULL)\n\tmatch->cp_user_data = *user_data;\n#endif\n\n    // Link the new match structure after (FORWARD) or before (BACKWARD) the\n    // current match in the list of matches .\n    if (compl_first_match == NULL)\n\tmatch->cp_next = match->cp_prev = NULL;\n    else if (dir == FORWARD)\n    {\n\tmatch->cp_next = compl_curr_match->cp_next;\n\tmatch->cp_prev = compl_curr_match;\n    }\n    else\t// BACKWARD\n    {\n\tmatch->cp_next = compl_curr_match;\n\tmatch->cp_prev = compl_curr_match->cp_prev;\n    }\n    if (match->cp_next)\n\tmatch->cp_next->cp_prev = match;\n    if (match->cp_prev)\n\tmatch->cp_prev->cp_next = match;\n    else\t// if there's nothing before, it is the first match\n\tcompl_first_match = match;\n    compl_curr_match = match;\n\n    // Find the longest common string if still doing that.\n    if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0)\n\tins_compl_longest_match(match);\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"str[len]\" matches with match->cp_str, considering\n * match->cp_flags.\n */\n    static int\nins_compl_equal(compl_T *match, char_u *str, int len)\n{\n    if (match->cp_flags & CP_EQUAL)\n\treturn TRUE;\n    if (match->cp_flags & CP_ICASE)\n\treturn STRNICMP(match->cp_str, str, (size_t)len) == 0;\n    return STRNCMP(match->cp_str, str, (size_t)len) == 0;\n}\n\n/*\n * Reduce the longest common string for match \"match\".\n */\n    static void\nins_compl_longest_match(compl_T *match)\n{\n    char_u\t*p, *s;\n    int\t\tc1, c2;\n    int\t\thad_match;\n\n    if (compl_leader == NULL)\n    {\n\t// First match, use it as a whole.\n\tcompl_leader = vim_strsave(match->cp_str);\n\tif (compl_leader == NULL)\n\t    return;\n\n\thad_match = (curwin->w_cursor.col > compl_col);\n\tins_compl_delete();\n\tins_bytes(compl_leader + get_compl_len());\n\tins_redraw(FALSE);\n\n\t// When the match isn't there (to avoid matching itself) remove it\n\t// again after redrawing.\n\tif (!had_match)\n\t    ins_compl_delete();\n\tcompl_used_match = FALSE;\n\n\treturn;\n    }\n\n    // Reduce the text if this match differs from compl_leader.\n    p = compl_leader;\n    s = match->cp_str;\n    while (*p != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    c1 = mb_ptr2char(p);\n\t    c2 = mb_ptr2char(s);\n\t}\n\telse\n\t{\n\t    c1 = *p;\n\t    c2 = *s;\n\t}\n\tif ((match->cp_flags & CP_ICASE)\n\t\t? (MB_TOLOWER(c1) != MB_TOLOWER(c2)) : (c1 != c2))\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    MB_PTR_ADV(p);\n\t    MB_PTR_ADV(s);\n\t}\n\telse\n\t{\n\t    ++p;\n\t    ++s;\n\t}\n    }\n\n    if (*p != NUL)\n    {\n\t// Leader was shortened, need to change the inserted text.\n\t*p = NUL;\n\thad_match = (curwin->w_cursor.col > compl_col);\n\tins_compl_delete();\n\tins_bytes(compl_leader + get_compl_len());\n\tins_redraw(FALSE);\n\n\t// When the match isn't there (to avoid matching itself) remove it\n\t// again after redrawing.\n\tif (!had_match)\n\t    ins_compl_delete();\n    }\n\n    compl_used_match = FALSE;\n}\n\n/*\n * Add an array of matches to the list of matches.\n * Frees matches[].\n */\n    static void\nins_compl_add_matches(\n    int\t\tnum_matches,\n    char_u\t**matches,\n    int\t\ticase)\n{\n    int\t\ti;\n    int\t\tadd_r = OK;\n    int\t\tdir = compl_direction;\n\n    for (i = 0; i < num_matches && add_r != FAIL; i++)\n\tif ((add_r = ins_compl_add(matches[i], -1, NULL, NULL, NULL, dir,\n\t\t\t       CP_FAST | (icase ? CP_ICASE : 0), FALSE)) == OK)\n\t    // if dir was BACKWARD then honor it just once\n\t    dir = FORWARD;\n    FreeWild(num_matches, matches);\n}\n\n/*\n * Make the completion list cyclic.\n * Return the number of matches (excluding the original).\n */\n    static int\nins_compl_make_cyclic(void)\n{\n    compl_T *match;\n    int\t    count = 0;\n\n    if (compl_first_match == NULL)\n\treturn 0;\n\n    // Find the end of the list.\n    match = compl_first_match;\n    // there's always an entry for the compl_orig_text, it doesn't count.\n    while (match->cp_next != NULL && !is_first_match(match->cp_next))\n    {\n\tmatch = match->cp_next;\n\t++count;\n    }\n    match->cp_next = compl_first_match;\n    compl_first_match->cp_prev = match;\n\n    return count;\n}\n\n/*\n * Return whether there currently is a shown match.\n */\n    int\nins_compl_has_shown_match(void)\n{\n    return compl_shown_match == NULL\n\t|| compl_shown_match != compl_shown_match->cp_next;\n}\n\n/*\n * Return whether the shown match is long enough.\n */\n    int\nins_compl_long_shown_match(void)\n{\n    return (int)STRLEN(compl_shown_match->cp_str)\n\t\t\t\t\t    > curwin->w_cursor.col - compl_col;\n}\n\n/*\n * Set variables that store noselect and noinsert behavior from the\n * 'completeopt' value.\n */\n    void\ncompleteopt_was_set(void)\n{\n    compl_no_insert = FALSE;\n    compl_no_select = FALSE;\n    compl_longest = FALSE;\n    if (strstr((char *)p_cot, \"noselect\") != NULL)\n\tcompl_no_select = TRUE;\n    if (strstr((char *)p_cot, \"noinsert\") != NULL)\n\tcompl_no_insert = TRUE;\n    if (strstr((char *)p_cot, \"longest\") != NULL)\n\tcompl_longest = TRUE;\n}\n\n\n// \"compl_match_array\" points the currently displayed list of entries in the\n// popup menu.  It is NULL when there is no popup menu.\nstatic pumitem_T *compl_match_array = NULL;\nstatic int compl_match_arraysize;\n\n/*\n * Update the screen and when there is any scrolling remove the popup menu.\n */\n    static void\nins_compl_upd_pum(void)\n{\n    int\t\th;\n\n    if (compl_match_array == NULL)\n\treturn;\n\n    h = curwin->w_cline_height;\n    // Update the screen later, before drawing the popup menu over it.\n    pum_call_update_screen();\n    if (h != curwin->w_cline_height)\n\tins_compl_del_pum();\n}\n\n/*\n * Remove any popup menu.\n */\n    static void\nins_compl_del_pum(void)\n{\n    if (compl_match_array == NULL)\n\treturn;\n\n    pum_undisplay();\n    VIM_CLEAR(compl_match_array);\n}\n\n/*\n * Return TRUE if the popup menu should be displayed.\n */\n    int\npum_wanted(void)\n{\n    // 'completeopt' must contain \"menu\" or \"menuone\"\n    if (vim_strchr(p_cot, 'm') == NULL)\n\treturn FALSE;\n\n    // The display looks bad on a B&W display.\n    if (t_colors < 8\n#ifdef FEAT_GUI\n\t    && !gui.in_use\n#endif\n\t    )\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if there are two or more matches to be shown in the popup menu.\n * One if 'completopt' contains \"menuone\".\n */\n    static int\npum_enough_matches(void)\n{\n    compl_T     *compl;\n    int\t\ti;\n\n    // Don't display the popup menu if there are no matches or there is only\n    // one (ignoring the original text).\n    compl = compl_first_match;\n    i = 0;\n    do\n    {\n\tif (compl == NULL || (!match_at_original_text(compl) && ++i == 2))\n\t    break;\n\tcompl = compl->cp_next;\n    } while (!is_first_match(compl));\n\n    if (strstr((char *)p_cot, \"menuone\") != NULL)\n\treturn (i >= 1);\n    return (i >= 2);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Allocate Dict for the completed item.\n * { word, abbr, menu, kind, info }\n */\n    static dict_T *\nins_compl_dict_alloc(compl_T *match)\n{\n    dict_T *dict = dict_alloc_lock(VAR_FIXED);\n\n    if (dict == NULL)\n\treturn NULL;\n\n    dict_add_string(dict, \"word\", match->cp_str);\n    dict_add_string(dict, \"abbr\", match->cp_text[CPT_ABBR]);\n    dict_add_string(dict, \"menu\", match->cp_text[CPT_MENU]);\n    dict_add_string(dict, \"kind\", match->cp_text[CPT_KIND]);\n    dict_add_string(dict, \"info\", match->cp_text[CPT_INFO]);\n    if (match->cp_user_data.v_type == VAR_UNKNOWN)\n\tdict_add_string(dict, \"user_data\", (char_u *)\"\");\n    else\n\tdict_add_tv(dict, \"user_data\", &match->cp_user_data);\n\n    return dict;\n}\n\n/*\n * Trigger the CompleteChanged autocmd event. Invoked each time the Insert mode\n * completion menu is changed.\n */\n    static void\ntrigger_complete_changed_event(int cur)\n{\n    dict_T\t    *v_event;\n    dict_T\t    *item;\n    static int\t    recursive = FALSE;\n    save_v_event_T  save_v_event;\n\n    if (recursive)\n\treturn;\n\n    if (cur < 0)\n\titem = dict_alloc();\n    else\n\titem = ins_compl_dict_alloc(compl_curr_match);\n    if (item == NULL)\n\treturn;\n    v_event = get_v_event(&save_v_event);\n    dict_add_dict(v_event, \"completed_item\", item);\n    pum_set_event_info(v_event);\n    dict_set_items_ro(v_event);\n\n    recursive = TRUE;\n    textlock++;\n    apply_autocmds(EVENT_COMPLETECHANGED, NULL, NULL, FALSE, curbuf);\n    textlock--;\n    recursive = FALSE;\n\n    restore_v_event(v_event, &save_v_event);\n}\n#endif\n\n/*\n * Build a popup menu to show the completion matches.\n * Returns the popup menu entry that should be selected. Returns -1 if nothing\n * should be selected.\n */\n    static int\nins_compl_build_pum(void)\n{\n    compl_T     *compl;\n    compl_T     *shown_compl = NULL;\n    int\t\tdid_find_shown_match = FALSE;\n    int\t\tshown_match_ok = FALSE;\n    int\t\ti;\n    int\t\tcur = -1;\n    int\t\tlead_len = 0;\n\n    // Need to build the popup menu list.\n    compl_match_arraysize = 0;\n    compl = compl_first_match;\n    if (compl_leader != NULL)\n\tlead_len = (int)STRLEN(compl_leader);\n\n    do\n    {\n\tif (!match_at_original_text(compl)\n\t\t&& (compl_leader == NULL\n\t\t    || ins_compl_equal(compl, compl_leader, lead_len)))\n\t    ++compl_match_arraysize;\n\tcompl = compl->cp_next;\n    } while (compl != NULL && !is_first_match(compl));\n\n    if (compl_match_arraysize == 0)\n\treturn -1;\n\n    compl_match_array = ALLOC_CLEAR_MULT(pumitem_T, compl_match_arraysize);\n    if (compl_match_array == NULL)\n\treturn -1;\n\n    // If the current match is the original text don't find the first\n    // match after it, don't highlight anything.\n    if (match_at_original_text(compl_shown_match))\n\tshown_match_ok = TRUE;\n\n    i = 0;\n    compl = compl_first_match;\n    do\n    {\n\tif (!match_at_original_text(compl)\n\t\t&& (compl_leader == NULL\n\t\t    || ins_compl_equal(compl, compl_leader, lead_len)))\n\t{\n\t    if (!shown_match_ok)\n\t    {\n\t\tif (compl == compl_shown_match || did_find_shown_match)\n\t\t{\n\t\t    // This item is the shown match or this is the\n\t\t    // first displayed item after the shown match.\n\t\t    compl_shown_match = compl;\n\t\t    did_find_shown_match = TRUE;\n\t\t    shown_match_ok = TRUE;\n\t\t}\n\t\telse\n\t\t    // Remember this displayed match for when the\n\t\t    // shown match is just below it.\n\t\t    shown_compl = compl;\n\t\tcur = i;\n\t    }\n\n\t    if (compl->cp_text[CPT_ABBR] != NULL)\n\t\tcompl_match_array[i].pum_text =\n\t\t    compl->cp_text[CPT_ABBR];\n\t    else\n\t\tcompl_match_array[i].pum_text = compl->cp_str;\n\t    compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];\n\t    compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];\n\t    if (compl->cp_text[CPT_MENU] != NULL)\n\t\tcompl_match_array[i++].pum_extra =\n\t\t    compl->cp_text[CPT_MENU];\n\t    else\n\t\tcompl_match_array[i++].pum_extra = compl->cp_fname;\n\t}\n\n\tif (compl == compl_shown_match)\n\t{\n\t    did_find_shown_match = TRUE;\n\n\t    // When the original text is the shown match don't set\n\t    // compl_shown_match.\n\t    if (match_at_original_text(compl))\n\t\tshown_match_ok = TRUE;\n\n\t    if (!shown_match_ok && shown_compl != NULL)\n\t    {\n\t\t// The shown match isn't displayed, set it to the\n\t\t// previously displayed match.\n\t\tcompl_shown_match = shown_compl;\n\t\tshown_match_ok = TRUE;\n\t    }\n\t}\n\tcompl = compl->cp_next;\n    } while (compl != NULL && !is_first_match(compl));\n\n    if (!shown_match_ok)    // no displayed match at all\n\tcur = -1;\n\n    return cur;\n}\n\n/*\n * Show the popup menu for the list of matches.\n * Also adjusts \"compl_shown_match\" to an entry that is actually displayed.\n */\n    void\nins_compl_show_pum(void)\n{\n    int\t\ti;\n    int\t\tcur = -1;\n    colnr_T\tcol;\n\n    if (!pum_wanted() || !pum_enough_matches())\n\treturn;\n\n#if defined(FEAT_EVAL)\n    // Dirty hard-coded hack: remove any matchparen highlighting.\n    do_cmdline_cmd((char_u *)\"if exists('g:loaded_matchparen')|:3match none|endif\");\n#endif\n\n    // Update the screen later, before drawing the popup menu over it.\n    pum_call_update_screen();\n\n    if (compl_match_array == NULL)\n\t// Need to build the popup menu list.\n\tcur = ins_compl_build_pum();\n    else\n    {\n\t// popup menu already exists, only need to find the current item.\n\tfor (i = 0; i < compl_match_arraysize; ++i)\n\t    if (compl_match_array[i].pum_text == compl_shown_match->cp_str\n\t\t    || compl_match_array[i].pum_text\n\t\t\t\t      == compl_shown_match->cp_text[CPT_ABBR])\n\t    {\n\t\tcur = i;\n\t\tbreak;\n\t    }\n    }\n\n    if (compl_match_array == NULL)\n\treturn;\n\n    // In Replace mode when a $ is displayed at the end of the line only\n    // part of the screen would be updated.  We do need to redraw here.\n    dollar_vcol = -1;\n\n    // Compute the screen column of the start of the completed text.\n    // Use the cursor to get all wrapping and other settings right.\n    col = curwin->w_cursor.col;\n    curwin->w_cursor.col = compl_col;\n    pum_display(compl_match_array, compl_match_arraysize, cur);\n    curwin->w_cursor.col = col;\n\n#ifdef FEAT_EVAL\n    if (has_completechanged())\n\ttrigger_complete_changed_event(cur);\n#endif\n}\n\n#define DICT_FIRST\t(1)\t// use just first element in \"dict\"\n#define DICT_EXACT\t(2)\t// \"dict\" is the exact name of a file\n\n/*\n * Add any identifiers that match the given pattern \"pat\" in the list of\n * dictionary files \"dict_start\" to the list of completions.\n */\n    static void\nins_compl_dictionaries(\n    char_u\t*dict_start,\n    char_u\t*pat,\n    int\t\tflags,\t\t// DICT_FIRST and/or DICT_EXACT\n    int\t\tthesaurus)\t// Thesaurus completion\n{\n    char_u\t*dict = dict_start;\n    char_u\t*ptr;\n    char_u\t*buf;\n    regmatch_T\tregmatch;\n    char_u\t**files;\n    int\t\tcount;\n    int\t\tsave_p_scs;\n    int\t\tdir = compl_direction;\n\n    if (*dict == NUL)\n    {\n#ifdef FEAT_SPELL\n\t// When 'dictionary' is empty and spell checking is enabled use\n\t// \"spell\".\n\tif (!thesaurus && curwin->w_p_spell)\n\t    dict = (char_u *)\"spell\";\n\telse\n#endif\n\t    return;\n    }\n\n    buf = alloc(LSIZE);\n    if (buf == NULL)\n\treturn;\n    regmatch.regprog = NULL;\t// so that we can goto theend\n\n    // If 'infercase' is set, don't use 'smartcase' here\n    save_p_scs = p_scs;\n    if (curbuf->b_p_inf)\n\tp_scs = FALSE;\n\n    // When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern\n    // to only match at the start of a line.  Otherwise just match the\n    // pattern. Also need to double backslashes.\n    if (ctrl_x_mode_line_or_eval())\n    {\n\tchar_u *pat_esc = vim_strsave_escaped(pat, (char_u *)\"\\\\\");\n\tsize_t len;\n\n\tif (pat_esc == NULL)\n\t    goto theend;\n\tlen = STRLEN(pat_esc) + 10;\n\tptr = alloc(len);\n\tif (ptr == NULL)\n\t{\n\t    vim_free(pat_esc);\n\t    goto theend;\n\t}\n\tvim_snprintf((char *)ptr, len, \"^\\\\s*\\\\zs\\\\V%s\", pat_esc);\n\tregmatch.regprog = vim_regcomp(ptr, RE_MAGIC);\n\tvim_free(pat_esc);\n\tvim_free(ptr);\n    }\n    else\n    {\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog == NULL)\n\t    goto theend;\n    }\n\n    // ignore case depends on 'ignorecase', 'smartcase' and \"pat\"\n    regmatch.rm_ic = ignorecase(pat);\n    while (*dict != NUL && !got_int && !compl_interrupted)\n    {\n\t// copy one dictionary file name into buf\n\tif (flags == DICT_EXACT)\n\t{\n\t    count = 1;\n\t    files = &dict;\n\t}\n\telse\n\t{\n\t    // Expand wildcards in the dictionary name, but do not allow\n\t    // backticks (for security, the 'dict' option may have been set in\n\t    // a modeline).\n\t    copy_option_part(&dict, buf, LSIZE, \",\");\n# ifdef FEAT_SPELL\n\t    if (!thesaurus && STRCMP(buf, \"spell\") == 0)\n\t\tcount = -1;\n\t    else\n# endif\n\t\tif (vim_strchr(buf, '`') != NULL\n\t\t    || expand_wildcards(1, &buf, &count, &files,\n\t\t\t\t\t\t     EW_FILE|EW_SILENT) != OK)\n\t\tcount = 0;\n\t}\n\n# ifdef FEAT_SPELL\n\tif (count == -1)\n\t{\n\t    // Complete from active spelling.  Skip \"\\<\" in the pattern, we\n\t    // don't use it as a RE.\n\t    if (pat[0] == '\\\\' && pat[1] == '<')\n\t\tptr = pat + 2;\n\t    else\n\t\tptr = pat;\n\t    spell_dump_compl(ptr, regmatch.rm_ic, &dir, 0);\n\t}\n\telse\n# endif\n\t    if (count > 0)\t// avoid warning for using \"files\" uninit\n\t{\n\t    ins_compl_files(count, files, thesaurus, flags,\n\t\t\t\t\t\t\t&regmatch, buf, &dir);\n\t    if (flags != DICT_EXACT)\n\t\tFreeWild(count, files);\n\t}\n\tif (flags != 0)\n\t    break;\n    }\n\ntheend:\n    p_scs = save_p_scs;\n    vim_regfree(regmatch.regprog);\n    vim_free(buf);\n}\n\n/*\n * Add all the words in the line \"*buf_arg\" from the thesaurus file \"fname\"\n * skipping the word at 'skip_word'.  Returns OK on success.\n */\n    static int\nthesaurus_add_words_in_line(\n\tchar_u\t*fname,\n\tchar_u\t**buf_arg,\n\tint\tdir,\n\tchar_u\t*skip_word)\n{\n    int\t\tstatus = OK;\n    char_u\t*ptr;\n    char_u\t*wstart;\n\n    // Add the other matches on the line\n    ptr = *buf_arg;\n    while (!got_int)\n    {\n\t// Find start of the next word.  Skip white\n\t// space and punctuation.\n\tptr = find_word_start(ptr);\n\tif (*ptr == NUL || *ptr == NL)\n\t    break;\n\twstart = ptr;\n\n\t// Find end of the word.\n\tif (has_mbyte)\n\t    // Japanese words may have characters in\n\t    // different classes, only separate words\n\t    // with single-byte non-word characters.\n\t    while (*ptr != NUL)\n\t    {\n\t\tint l = (*mb_ptr2len)(ptr);\n\n\t\tif (l < 2 && !vim_iswordc(*ptr))\n\t\t    break;\n\t\tptr += l;\n\t    }\n\telse\n\t    ptr = find_word_end(ptr);\n\n\t// Add the word. Skip the regexp match.\n\tif (wstart != skip_word)\n\t{\n\t    status = ins_compl_add_infercase(wstart, (int)(ptr - wstart), p_ic,\n\t\t\t\t\t\t\tfname, dir, FALSE);\n\t    if (status == FAIL)\n\t\tbreak;\n\t}\n    }\n\n    *buf_arg = ptr;\n    return status;\n}\n\n/*\n * Process \"count\" dictionary/thesaurus \"files\" and add the text matching\n * \"regmatch\".\n */\n    static void\nins_compl_files(\n    int\t\tcount,\n    char_u\t**files,\n    int\t\tthesaurus,\n    int\t\tflags,\n    regmatch_T\t*regmatch,\n    char_u\t*buf,\n    int\t\t*dir)\n{\n    char_u\t*ptr;\n    int\t\ti;\n    FILE\t*fp;\n    int\t\tadd_r;\n\n    for (i = 0; i < count && !got_int && !compl_interrupted; i++)\n    {\n\tfp = mch_fopen((char *)files[i], \"r\");  // open dictionary file\n\tif (flags != DICT_EXACT)\n\t{\n\t    msg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t      _(\"Scanning dictionary: %s\"), (char *)files[i]);\n\t    (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t}\n\n\tif (fp == NULL)\n\t    continue;\n\n\t// Read dictionary file line by line.\n\t// Check each line for a match.\n\twhile (!got_int && !compl_interrupted && !vim_fgets(buf, LSIZE, fp))\n\t{\n\t    ptr = buf;\n\t    while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf)))\n\t    {\n\t\tptr = regmatch->startp[0];\n\t\tif (ctrl_x_mode_line_or_eval())\n\t\t    ptr = find_line_end(ptr);\n\t\telse\n\t\t    ptr = find_word_end(ptr);\n\t\tadd_r = ins_compl_add_infercase(regmatch->startp[0],\n\t\t\t(int)(ptr - regmatch->startp[0]),\n\t\t\tp_ic, files[i], *dir, FALSE);\n\t\tif (thesaurus)\n\t\t{\n\t\t    // For a thesaurus, add all the words in the line\n\t\t    ptr = buf;\n\t\t    add_r = thesaurus_add_words_in_line(files[i], &ptr, *dir,\n\t\t\t\t\t\t\tregmatch->startp[0]);\n\t\t}\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    *dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t\t// avoid expensive call to vim_regexec() when at end\n\t\t// of line\n\t\tif (*ptr == '\\n' || got_int)\n\t\t    break;\n\t    }\n\t    line_breakcheck();\n\t    ins_compl_check_keys(50, FALSE);\n\t}\n\tfclose(fp);\n    }\n}\n\n/*\n * Find the start of the next word.\n * Returns a pointer to the first char of the word.  Also stops at a NUL.\n */\n    char_u *\nfind_word_start(char_u *ptr)\n{\n    if (has_mbyte)\n\twhile (*ptr != NUL && *ptr != '\\n' && mb_get_class(ptr) <= 1)\n\t    ptr += (*mb_ptr2len)(ptr);\n    else\n\twhile (*ptr != NUL && *ptr != '\\n' && !vim_iswordc(*ptr))\n\t    ++ptr;\n    return ptr;\n}\n\n/*\n * Find the end of the word.  Assumes it starts inside a word.\n * Returns a pointer to just after the word.\n */\n    char_u *\nfind_word_end(char_u *ptr)\n{\n    int\t\tstart_class;\n\n    if (has_mbyte)\n    {\n\tstart_class = mb_get_class(ptr);\n\tif (start_class > 1)\n\t    while (*ptr != NUL)\n\t    {\n\t\tptr += (*mb_ptr2len)(ptr);\n\t\tif (mb_get_class(ptr) != start_class)\n\t\t    break;\n\t    }\n    }\n    else\n\twhile (vim_iswordc(*ptr))\n\t    ++ptr;\n    return ptr;\n}\n\n/*\n * Find the end of the line, omitting CR and NL at the end.\n * Returns a pointer to just after the line.\n */\n    static char_u *\nfind_line_end(char_u *ptr)\n{\n    char_u\t*s;\n\n    s = ptr + STRLEN(ptr);\n    while (s > ptr && (s[-1] == CAR || s[-1] == NL))\n\t--s;\n    return s;\n}\n\n/*\n * Free the list of completions\n */\n    static void\nins_compl_free(void)\n{\n    compl_T *match;\n    int\t    i;\n\n    VIM_CLEAR(compl_pattern);\n    VIM_CLEAR(compl_leader);\n\n    if (compl_first_match == NULL)\n\treturn;\n\n    ins_compl_del_pum();\n    pum_clear();\n\n    compl_curr_match = compl_first_match;\n    do\n    {\n\tmatch = compl_curr_match;\n\tcompl_curr_match = compl_curr_match->cp_next;\n\tvim_free(match->cp_str);\n\t// several entries may use the same fname, free it just once.\n\tif (match->cp_flags & CP_FREE_FNAME)\n\t    vim_free(match->cp_fname);\n\tfor (i = 0; i < CPT_COUNT; ++i)\n\t    vim_free(match->cp_text[i]);\n#ifdef FEAT_EVAL\n\tclear_tv(&match->cp_user_data);\n#endif\n\tvim_free(match);\n    } while (compl_curr_match != NULL && !is_first_match(compl_curr_match));\n    compl_first_match = compl_curr_match = NULL;\n    compl_shown_match = NULL;\n    compl_old_match = NULL;\n}\n\n/*\n * Reset/clear the completion state.\n */\n    void\nins_compl_clear(void)\n{\n    compl_cont_status = 0;\n    compl_started = FALSE;\n    compl_matches = 0;\n    VIM_CLEAR(compl_pattern);\n    VIM_CLEAR(compl_leader);\n    edit_submode_extra = NULL;\n    VIM_CLEAR(compl_orig_text);\n    compl_enter_selects = FALSE;\n#ifdef FEAT_EVAL\n    // clear v:completed_item\n    set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc_lock(VAR_FIXED));\n#endif\n}\n\n/*\n * Return TRUE when Insert completion is active.\n */\n    int\nins_compl_active(void)\n{\n    return compl_started;\n}\n\n/*\n * Selected one of the matches.  When FALSE the match was edited or using the\n * longest common string.\n */\n    int\nins_compl_used_match(void)\n{\n    return compl_used_match;\n}\n\n/*\n * Initialize get longest common string.\n */\n    void\nins_compl_init_get_longest(void)\n{\n    compl_get_longest = FALSE;\n}\n\n/*\n * Returns TRUE when insert completion is interrupted.\n */\n    int\nins_compl_interrupted(void)\n{\n    return compl_interrupted;\n}\n\n/*\n * Returns TRUE if the <Enter> key selects a match in the completion popup\n * menu.\n */\n    int\nins_compl_enter_selects(void)\n{\n    return compl_enter_selects;\n}\n\n/*\n * Return the column where the text starts that is being completed\n */\n    colnr_T\nins_compl_col(void)\n{\n    return compl_col;\n}\n\n/*\n * Return the length in bytes of the text being completed\n */\n    int\nins_compl_len(void)\n{\n    return compl_length;\n}\n\n/*\n * Delete one character before the cursor and show the subset of the matches\n * that match the word that is now before the cursor.\n * Returns the character to be used, NUL if the work is done and another char\n * to be got from the user.\n */\n    int\nins_compl_bs(void)\n{\n    char_u\t*line;\n    char_u\t*p;\n\n    line = ml_get_curline();\n    p = line + curwin->w_cursor.col;\n    MB_PTR_BACK(line, p);\n\n    // Stop completion when the whole word was deleted.  For Omni completion\n    // allow the word to be deleted, we won't match everything.\n    // Respect the 'backspace' option.\n    if ((int)(p - line) - (int)compl_col < 0\n\t    || ((int)(p - line) - (int)compl_col == 0 && !ctrl_x_mode_omni())\n\t    || ctrl_x_mode_eval()\n\t    || (!can_bs(BS_START) && (int)(p - line) - (int)compl_col\n\t\t\t\t\t\t\t- compl_length < 0))\n\treturn K_BS;\n\n    // Deleted more than what was used to find matches or didn't finish\n    // finding all matches: need to look for matches all over again.\n    if (curwin->w_cursor.col <= compl_col + compl_length\n\t\t\t\t\t\t  || ins_compl_need_restart())\n\tins_compl_restart();\n\n    vim_free(compl_leader);\n    compl_leader = vim_strnsave(line + compl_col, (p - line) - compl_col);\n    if (compl_leader == NULL)\n\treturn K_BS;\n\n    ins_compl_new_leader();\n    if (compl_shown_match != NULL)\n\t// Make sure current match is not a hidden item.\n\tcompl_curr_match = compl_shown_match;\n    return NUL;\n}\n\n/*\n * Return TRUE when we need to find matches again, ins_compl_restart() is to\n * be called.\n */\n    static int\nins_compl_need_restart(void)\n{\n    // Return TRUE if we didn't complete finding matches or when the\n    // 'completefunc' returned \"always\" in the \"refresh\" dictionary item.\n    return compl_was_interrupted\n\t|| ((ctrl_x_mode_function() || ctrl_x_mode_omni())\n\t\t\t\t\t\t  && compl_opt_refresh_always);\n}\n\n/*\n * Called after changing \"compl_leader\".\n * Show the popup menu with a different set of matches.\n * May also search for matches again if the previous search was interrupted.\n */\n    static void\nins_compl_new_leader(void)\n{\n    ins_compl_del_pum();\n    ins_compl_delete();\n    ins_bytes(compl_leader + get_compl_len());\n    compl_used_match = FALSE;\n\n    if (compl_started)\n\tins_compl_set_original_text(compl_leader);\n    else\n    {\n#ifdef FEAT_SPELL\n\tspell_bad_len = 0;\t// need to redetect bad word\n#endif\n\t// Matches were cleared, need to search for them now.  Before drawing\n\t// the popup menu display the changed text before the cursor.  Set\n\t// \"compl_restarting\" to avoid that the first match is inserted.\n\tpum_call_update_screen();\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    // Show the cursor after the match, not after the redrawn text.\n\t    setcursor();\n\t    out_flush_cursor(FALSE, FALSE);\n\t}\n#endif\n\tcompl_restarting = TRUE;\n\tif (ins_complete(Ctrl_N, TRUE) == FAIL)\n\t    compl_cont_status = 0;\n\tcompl_restarting = FALSE;\n    }\n\n    compl_enter_selects = !compl_used_match;\n\n    // Show the popup menu with a different set of matches.\n    ins_compl_show_pum();\n\n    // Don't let Enter select the original text when there is no popup menu.\n    if (compl_match_array == NULL)\n\tcompl_enter_selects = FALSE;\n}\n\n/*\n * Return the length of the completion, from the completion start column to\n * the cursor column.  Making sure it never goes below zero.\n */\n    static int\nget_compl_len(void)\n{\n    int off = (int)curwin->w_cursor.col - (int)compl_col;\n\n    if (off < 0)\n\treturn 0;\n    return off;\n}\n\n/*\n * Append one character to the match leader.  May reduce the number of\n * matches.\n */\n    void\nins_compl_addleader(int c)\n{\n    int\t\tcc;\n\n    if (stop_arrow() == FAIL)\n\treturn;\n    if (has_mbyte && (cc = (*mb_char2len)(c)) > 1)\n    {\n\tchar_u\tbuf[MB_MAXBYTES + 1];\n\n\t(*mb_char2bytes)(c, buf);\n\tbuf[cc] = NUL;\n\tins_char_bytes(buf, cc);\n\tif (compl_opt_refresh_always)\n\t    AppendToRedobuff(buf);\n    }\n    else\n    {\n\tins_char(c);\n\tif (compl_opt_refresh_always)\n\t    AppendCharToRedobuff(c);\n    }\n\n    // If we didn't complete finding matches we must search again.\n    if (ins_compl_need_restart())\n\tins_compl_restart();\n\n    // When 'always' is set, don't reset compl_leader. While completing,\n    // cursor doesn't point original position, changing compl_leader would\n    // break redo.\n    if (!compl_opt_refresh_always)\n    {\n\tvim_free(compl_leader);\n\tcompl_leader = vim_strnsave(ml_get_curline() + compl_col,\n\t\t\t\t\t     curwin->w_cursor.col - compl_col);\n\tif (compl_leader != NULL)\n\t    ins_compl_new_leader();\n    }\n}\n\n/*\n * Setup for finding completions again without leaving CTRL-X mode.  Used when\n * BS or a key was typed while still searching for matches.\n */\n    static void\nins_compl_restart(void)\n{\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    compl_cont_status = 0;\n    compl_cont_mode = 0;\n}\n\n/*\n * Set the first match, the original text.\n */\n    static void\nins_compl_set_original_text(char_u *str)\n{\n    char_u\t*p;\n\n    // Replace the original text entry.\n    // The CP_ORIGINAL_TEXT flag is either at the first item or might possibly\n    // be at the last item for backward completion\n    if (match_at_original_text(compl_first_match))\t// safety check\n    {\n\tp = vim_strsave(str);\n\tif (p != NULL)\n\t{\n\t    vim_free(compl_first_match->cp_str);\n\t    compl_first_match->cp_str = p;\n\t}\n    }\n    else if (compl_first_match->cp_prev != NULL\n\t    && match_at_original_text(compl_first_match->cp_prev))\n    {\n       p = vim_strsave(str);\n       if (p != NULL)\n       {\n\t   vim_free(compl_first_match->cp_prev->cp_str);\n\t   compl_first_match->cp_prev->cp_str = p;\n       }\n    }\n}\n\n/*\n * Append one character to the match leader.  May reduce the number of\n * matches.\n */\n    void\nins_compl_addfrommatch(void)\n{\n    char_u\t*p;\n    int\t\tlen = (int)curwin->w_cursor.col - (int)compl_col;\n    int\t\tc;\n    compl_T\t*cp;\n\n    p = compl_shown_match->cp_str;\n    if ((int)STRLEN(p) <= len)   // the match is too short\n    {\n\t// When still at the original match use the first entry that matches\n\t// the leader.\n\tif (!match_at_original_text(compl_shown_match))\n\t    return;\n\n\tp = NULL;\n\tfor (cp = compl_shown_match->cp_next; cp != NULL\n\t\t&& !is_first_match(cp); cp = cp->cp_next)\n\t{\n\t    if (compl_leader == NULL\n\t\t    || ins_compl_equal(cp, compl_leader,\n\t\t\t(int)STRLEN(compl_leader)))\n\t    {\n\t\tp = cp->cp_str;\n\t\tbreak;\n\t    }\n\t}\n\tif (p == NULL || (int)STRLEN(p) <= len)\n\t    return;\n    }\n    p += len;\n    c = PTR2CHAR(p);\n    ins_compl_addleader(c);\n}\n\n/*\n * Set the CTRL-X completion mode based on the key \"c\" typed after a CTRL-X.\n * Uses the global variables: ctrl_x_mode, edit_submode, edit_submode_pre,\n * compl_cont_mode and compl_cont_status.\n * Returns TRUE when the character is not to be inserted.\n */\n    static int\nset_ctrl_x_mode(int c)\n{\n    int retval = FALSE;\n\n    switch (c)\n    {\n\tcase Ctrl_E:\n\tcase Ctrl_Y:\n\t    // scroll the window one line up or down\n\t    ctrl_x_mode = CTRL_X_SCROLL;\n\t    if (!(State & REPLACE_FLAG))\n\t\tedit_submode = (char_u *)_(\" (insert) Scroll (^E/^Y)\");\n\t    else\n\t\tedit_submode = (char_u *)_(\" (replace) Scroll (^E/^Y)\");\n\t    edit_submode_pre = NULL;\n\t    showmode();\n\t    break;\n\tcase Ctrl_L:\n\t    // complete whole line\n\t    ctrl_x_mode = CTRL_X_WHOLE_LINE;\n\t    break;\n\tcase Ctrl_F:\n\t    // complete filenames\n\t    ctrl_x_mode = CTRL_X_FILES;\n\t    break;\n\tcase Ctrl_K:\n\t    // complete words from a dictionary\n\t    ctrl_x_mode = CTRL_X_DICTIONARY;\n\t    break;\n\tcase Ctrl_R:\n\t    // Register insertion without exiting CTRL-X mode\n\t    // Simply allow ^R to happen without affecting ^X mode\n\t    break;\n\tcase Ctrl_T:\n\t    // complete words from a thesaurus\n\t    ctrl_x_mode = CTRL_X_THESAURUS;\n\t    break;\n#ifdef FEAT_COMPL_FUNC\n\tcase Ctrl_U:\n\t    // user defined completion\n\t    ctrl_x_mode = CTRL_X_FUNCTION;\n\t    break;\n\tcase Ctrl_O:\n\t    // omni completion\n\t    ctrl_x_mode = CTRL_X_OMNI;\n\t    break;\n#endif\n\tcase 's':\n\tcase Ctrl_S:\n\t    // complete spelling suggestions\n\t    ctrl_x_mode = CTRL_X_SPELL;\n#ifdef FEAT_SPELL\n\t    ++emsg_off;\t// Avoid getting the E756 error twice.\n\t    spell_back_to_badword();\n\t    --emsg_off;\n#endif\n\t    break;\n\tcase Ctrl_RSB:\n\t    // complete tag names\n\t    ctrl_x_mode = CTRL_X_TAGS;\n\t    break;\n#ifdef FEAT_FIND_ID\n\tcase Ctrl_I:\n\tcase K_S_TAB:\n\t    // complete keywords from included files\n\t    ctrl_x_mode = CTRL_X_PATH_PATTERNS;\n\t    break;\n\tcase Ctrl_D:\n\t    // complete definitions from included files\n\t    ctrl_x_mode = CTRL_X_PATH_DEFINES;\n\t    break;\n#endif\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t    // complete vim commands\n\t    ctrl_x_mode = CTRL_X_CMDLINE;\n\t    break;\n\tcase Ctrl_Z:\n\t    // stop completion\n\t    ctrl_x_mode = CTRL_X_NORMAL;\n\t    edit_submode = NULL;\n\t    showmode();\n\t    retval = TRUE;\n\t    break;\n\tcase Ctrl_P:\n\tcase Ctrl_N:\n\t    // ^X^P means LOCAL expansion if nothing interrupted (eg we\n\t    // just started ^X mode, or there were enough ^X's to cancel\n\t    // the previous mode, say ^X^F^X^X^P or ^P^X^X^X^P, see below)\n\t    // do normal expansion when interrupting a different mode (say\n\t    // ^X^F^X^P or ^P^X^X^P, see below)\n\t    // nothing changes if interrupting mode 0, (eg, the flag\n\t    // doesn't change when going to ADDING mode  -- Acevedo\n\t    if (!(compl_cont_status & CONT_INTRPT))\n\t\tcompl_cont_status |= CONT_LOCAL;\n\t    else if (compl_cont_mode != 0)\n\t\tcompl_cont_status &= ~CONT_LOCAL;\n\t    // FALLTHROUGH\n\tdefault:\n\t    // If we have typed at least 2 ^X's... for modes != 0, we set\n\t    // compl_cont_status = 0 (eg, as if we had just started ^X\n\t    // mode).\n\t    // For mode 0, we set \"compl_cont_mode\" to an impossible\n\t    // value, in both cases ^X^X can be used to restart the same\n\t    // mode (avoiding ADDING mode).\n\t    // Undocumented feature: In a mode != 0 ^X^P and ^X^X^P start\n\t    // 'complete' and local ^P expansions respectively.\n\t    // In mode 0 an extra ^X is needed since ^X^P goes to ADDING\n\t    // mode  -- Acevedo\n\t    if (c == Ctrl_X)\n\t    {\n\t\tif (compl_cont_mode != 0)\n\t\t    compl_cont_status = 0;\n\t\telse\n\t\t    compl_cont_mode = CTRL_X_NOT_DEFINED_YET;\n\t    }\n\t    ctrl_x_mode = CTRL_X_NORMAL;\n\t    edit_submode = NULL;\n\t    showmode();\n\t    break;\n    }\n\n    return retval;\n}\n\n/*\n * Stop insert completion mode\n */\n    static int\nins_compl_stop(int c, int prev_mode, int retval)\n{\n    char_u\t*ptr;\n    int\t\twant_cindent;\n\n    // Get here when we have finished typing a sequence of ^N and\n    // ^P or other completion characters in CTRL-X mode.  Free up\n    // memory that was used, and make sure we can redo the insert.\n    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)\n    {\n\t// If any of the original typed text has been changed, eg when\n\t// ignorecase is set, we must add back-spaces to the redo\n\t// buffer.  We add as few as necessary to delete just the part\n\t// of the original text that has changed.\n\t// When using the longest match, edited the match or used\n\t// CTRL-E then don't use the current match.\n\tif (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)\n\t    ptr = compl_curr_match->cp_str;\n\telse\n\t    ptr = NULL;\n\tins_compl_fixRedoBufForLeader(ptr);\n    }\n\n    want_cindent = (get_can_cindent() && cindent_on());\n\n    // When completing whole lines: fix indent for 'cindent'.\n    // Otherwise, break line if it's too long.\n    if (compl_cont_mode == CTRL_X_WHOLE_LINE)\n    {\n\t// re-indent the current line\n\tif (want_cindent)\n\t{\n\t    do_c_expr_indent();\n\t    want_cindent = FALSE;\t// don't do it again\n\t}\n    }\n    else\n    {\n\tint prev_col = curwin->w_cursor.col;\n\n\t// put the cursor on the last char, for 'tw' formatting\n\tif (prev_col > 0)\n\t    dec_cursor();\n\t// only format when something was inserted\n\tif (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)\n\t    insertchar(NUL, 0, -1);\n\tif (prev_col > 0\n\t\t&& ml_get_curline()[curwin->w_cursor.col] != NUL)\n\t    inc_cursor();\n    }\n\n    // If the popup menu is displayed pressing CTRL-Y means accepting\n    // the selection without inserting anything.  When\n    // compl_enter_selects is set the Enter key does the same.\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n\n    // CTRL-E means completion is Ended, go back to the typed text.\n    // but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tchar_u *p = NULL;\n\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    p = compl_leader;\n\telse if (compl_first_match != NULL)\n\t    p = compl_orig_text;\n\tif (p != NULL)\n\t{\n\t    int\t    compl_len = get_compl_len();\n\t    int\t    len = (int)STRLEN(p);\n\n\t    if (len > compl_len)\n\t\tins_bytes_len(p + compl_len, len - compl_len);\n\t}\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n\n    // Trigger the CompleteDonePre event to give scripts a chance to\n    // act upon the completion before clearing the info, and restore\n    // ctrl_x_mode, so that complete_info() can be used.\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);\n\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    if (!shortmess(SHM_COMPLETIONMENU))\n\tmsg_clr_cmdline();\t// necessary for \"noshowmode\"\n    ctrl_x_mode = CTRL_X_NORMAL;\n    compl_enter_selects = FALSE;\n    if (edit_submode != NULL)\n    {\n\tedit_submode = NULL;\n\tshowmode();\n    }\n\n#ifdef FEAT_CMDWIN\n    if (c == Ctrl_C && cmdwin_type != 0)\n\t// Avoid the popup menu remains displayed when leaving the\n\t// command line window.\n\tupdate_screen(0);\n#endif\n    // Indent now if a key was typed that is in 'cinkeys'.\n    if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))\n\tdo_c_expr_indent();\n    // Trigger the CompleteDone event to give scripts a chance to act\n    // upon the end of completion.\n    ins_apply_autocmds(EVENT_COMPLETEDONE);\n\n    return retval;\n}\n\n/*\n * Prepare for Insert mode completion, or stop it.\n * Called just after typing a character in Insert mode.\n * Returns TRUE when the character is not to be inserted;\n */\n    int\nins_compl_prep(int c)\n{\n    int\t\tretval = FALSE;\n    int\t\tprev_mode = ctrl_x_mode;\n\n    // Forget any previous 'special' messages if this is actually\n    // a ^X mode key - bar ^R, in which case we wait to see what it gives us.\n    if (c != Ctrl_R && vim_is_ctrl_x_key(c))\n\tedit_submode_extra = NULL;\n\n    // Ignore end of Select mode mapping and mouse scroll buttons.\n    if (c == K_SELECT || c == K_MOUSEDOWN || c == K_MOUSEUP\n\t    || c == K_MOUSELEFT || c == K_MOUSERIGHT\n\t    || c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\treturn retval;\n\n#ifdef FEAT_PROP_POPUP\n    // Ignore mouse events in a popup window\n    if (is_mouse_key(c))\n    {\n\t// Ignore drag and release events, the position does not need to be in\n\t// the popup and it may have just closed.\n\tif (c == K_LEFTRELEASE\n\t\t|| c == K_LEFTRELEASE_NM\n\t\t|| c == K_MIDDLERELEASE\n\t\t|| c == K_RIGHTRELEASE\n\t\t|| c == K_X1RELEASE\n\t\t|| c == K_X2RELEASE\n\t\t|| c == K_LEFTDRAG\n\t\t|| c == K_MIDDLEDRAG\n\t\t|| c == K_RIGHTDRAG\n\t\t|| c == K_X1DRAG\n\t\t|| c == K_X2DRAG)\n\t    return retval;\n\tif (popup_visible)\n\t{\n\t    int\t    row = mouse_row;\n\t    int\t    col = mouse_col;\n\t    win_T   *wp = mouse_find_win(&row, &col, FIND_POPUP);\n\n\t    if (wp != NULL && WIN_IS_POPUP(wp))\n\t\treturn retval;\n\t}\n    }\n#endif\n\n    if (ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X && c != Ctrl_X)\n    {\n\tif (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_Z || ins_compl_pum_key(c)\n\t\t|| !vim_is_ctrl_x_key(c))\n\t{\n\t    // Not starting another completion mode.\n\t    ctrl_x_mode = CTRL_X_CMDLINE;\n\n\t    // CTRL-X CTRL-Z should stop completion without inserting anything\n\t    if (c == Ctrl_Z)\n\t\tretval = TRUE;\n\t}\n\telse\n\t{\n\t    ctrl_x_mode = CTRL_X_CMDLINE;\n\n\t    // Other CTRL-X keys first stop completion, then start another\n\t    // completion mode.\n\t    ins_compl_prep(' ');\n\t    ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;\n\t}\n    }\n\n    // Set \"compl_get_longest\" when finding the first matches.\n    if (ctrl_x_mode_not_defined_yet()\n\t\t\t   || (ctrl_x_mode_normal() && !compl_started))\n    {\n\tcompl_get_longest = compl_longest;\n\tcompl_used_match = TRUE;\n\n    }\n\n    if (ctrl_x_mode_not_defined_yet())\n\t// We have just typed CTRL-X and aren't quite sure which CTRL-X mode\n\t// it will be yet.  Now we decide.\n\tretval = set_ctrl_x_mode(c);\n    else if (ctrl_x_mode_not_default())\n    {\n\t// We're already in CTRL-X mode, do we stay in it?\n\tif (!vim_is_ctrl_x_key(c))\n\t{\n\t    if (ctrl_x_mode_scroll())\n\t\tctrl_x_mode = CTRL_X_NORMAL;\n\t    else\n\t\tctrl_x_mode = CTRL_X_FINISHED;\n\t    edit_submode = NULL;\n\t}\n\tshowmode();\n    }\n\n    if (compl_started || ctrl_x_mode == CTRL_X_FINISHED)\n    {\n\t// Show error message from attempted keyword completion (probably\n\t// 'Pattern not found') until another key is hit, then go back to\n\t// showing what mode we are in.\n\tshowmode();\n\tif ((ctrl_x_mode_normal() && c != Ctrl_N && c != Ctrl_P\n\t\t\t\t       && c != Ctrl_R && !ins_compl_pum_key(c))\n\t\t|| ctrl_x_mode == CTRL_X_FINISHED)\n\t    retval = ins_compl_stop(c, prev_mode, retval);\n    }\n    else if (ctrl_x_mode == CTRL_X_LOCAL_MSG)\n\t// Trigger the CompleteDone event to give scripts a chance to act\n\t// upon the (possibly failed) completion.\n\tins_apply_autocmds(EVENT_COMPLETEDONE);\n\n    may_trigger_modechanged();\n\n    // reset continue_* if we left expansion-mode, if we stay they'll be\n    // (re)set properly in ins_complete()\n    if (!vim_is_ctrl_x_key(c))\n    {\n\tcompl_cont_status = 0;\n\tcompl_cont_mode = 0;\n    }\n\n    return retval;\n}\n\n/*\n * Fix the redo buffer for the completion leader replacing some of the typed\n * text.  This inserts backspaces and appends the changed text.\n * \"ptr\" is the known leader text or NUL.\n */\n    static void\nins_compl_fixRedoBufForLeader(char_u *ptr_arg)\n{\n    int\t    len;\n    char_u  *p;\n    char_u  *ptr = ptr_arg;\n\n    if (ptr == NULL)\n    {\n\tif (compl_leader != NULL)\n\t    ptr = compl_leader;\n\telse\n\t    return;  // nothing to do\n    }\n    if (compl_orig_text != NULL)\n    {\n\tp = compl_orig_text;\n\tfor (len = 0; p[len] != NUL && p[len] == ptr[len]; ++len)\n\t    ;\n\tif (len > 0)\n\t    len -= (*mb_head_off)(p, p + len);\n\tfor (p += len; *p != NUL; MB_PTR_ADV(p))\n\t    AppendCharToRedobuff(K_BS);\n    }\n    else\n\tlen = 0;\n    if (ptr != NULL)\n\tAppendToRedobuffLit(ptr + len, -1);\n}\n\n/*\n * Loops through the list of windows, loaded-buffers or non-loaded-buffers\n * (depending on flag) starting from buf and looking for a non-scanned\n * buffer (other than curbuf).\tcurbuf is special, if it is called with\n * buf=curbuf then it has to be the first call for a given flag/expansion.\n *\n * Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo\n */\n    static buf_T *\nins_compl_next_buf(buf_T *buf, int flag)\n{\n    static win_T *wp = NULL;\n\n    if (flag == 'w')\t\t// just windows\n    {\n\tif (buf == curbuf || wp == NULL)  // first call for this flag/expansion\n\t    wp = curwin;\n\twhile ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin\n\t\t&& wp->w_buffer->b_scanned)\n\t    ;\n\tbuf = wp->w_buffer;\n    }\n    else\n\t// 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'\n\t// (unlisted buffers)\n\t// When completing whole lines skip unloaded buffers.\n\twhile ((buf = (buf->b_next != NULL ? buf->b_next : firstbuf)) != curbuf\n\t\t&& ((flag == 'U'\n\t\t\t? buf->b_p_bl\n\t\t\t: (!buf->b_p_bl\n\t\t\t    || (buf->b_ml.ml_mfp == NULL) != (flag == 'u')))\n\t\t    || buf->b_scanned))\n\t    ;\n    return buf;\n}\n\n#ifdef FEAT_COMPL_FUNC\n\n# ifdef FEAT_EVAL\nstatic callback_T cfu_cb;\t    // 'completefunc' callback function\nstatic callback_T ofu_cb;\t    // 'omnifunc' callback function\nstatic callback_T tsrfu_cb;\t    // 'thesaurusfunc' callback function\n# endif\n\n/*\n * Copy a global callback function to a buffer local callback.\n */\n    static void\ncopy_global_to_buflocal_cb(callback_T *globcb, callback_T *bufcb)\n{\n    free_callback(bufcb);\n    if (globcb->cb_name != NULL && *globcb->cb_name != NUL)\n\tcopy_callback(bufcb, globcb);\n}\n\n/*\n * Parse the 'completefunc' option value and set the callback function.\n * Invoked when the 'completefunc' option is set. The option value can be a\n * name of a function (string), or function(<name>) or funcref(<name>) or a\n * lambda expression.\n */\n    int\nset_completefunc_option(void)\n{\n    int\tretval;\n\n    retval = option_set_callback_func(curbuf->b_p_cfu, &cfu_cb);\n    if (retval == OK)\n\tset_buflocal_cfu_callback(curbuf);\n\n    return retval;\n}\n\n/*\n * Copy the global 'completefunc' callback function to the buffer-local\n * 'completefunc' callback for \"buf\".\n */\n    void\nset_buflocal_cfu_callback(buf_T *buf UNUSED)\n{\n# ifdef FEAT_EVAL\n    copy_global_to_buflocal_cb(&cfu_cb, &buf->b_cfu_cb);\n# endif\n}\n\n/*\n * Parse the 'omnifunc' option value and set the callback function.\n * Invoked when the 'omnifunc' option is set. The option value can be a\n * name of a function (string), or function(<name>) or funcref(<name>) or a\n * lambda expression.\n */\n    int\nset_omnifunc_option(void)\n{\n    int\tretval;\n\n    retval = option_set_callback_func(curbuf->b_p_ofu, &ofu_cb);\n    if (retval == OK)\n\tset_buflocal_ofu_callback(curbuf);\n\n    return retval;\n}\n\n/*\n * Copy the global 'omnifunc' callback function to the buffer-local 'omnifunc'\n * callback for \"buf\".\n */\n    void\nset_buflocal_ofu_callback(buf_T *buf UNUSED)\n{\n# ifdef FEAT_EVAL\n    copy_global_to_buflocal_cb(&ofu_cb, &buf->b_ofu_cb);\n# endif\n}\n\n/*\n * Parse the 'thesaurusfunc' option value and set the callback function.\n * Invoked when the 'thesaurusfunc' option is set. The option value can be a\n * name of a function (string), or function(<name>) or funcref(<name>) or a\n * lambda expression.\n */\n    int\nset_thesaurusfunc_option(void)\n{\n    int\tretval;\n\n    if (*curbuf->b_p_tsrfu != NUL)\n    {\n\t// buffer-local option set\n\tretval = option_set_callback_func(curbuf->b_p_tsrfu,\n\t\t\t\t\t\t\t&curbuf->b_tsrfu_cb);\n    }\n    else\n    {\n\t// global option set\n\tretval = option_set_callback_func(p_tsrfu, &tsrfu_cb);\n    }\n\n    return retval;\n}\n\n/*\n * Mark the global 'completefunc' 'omnifunc' and 'thesaurusfunc' callbacks with\n * \"copyID\" so that they are not garbage collected.\n */\n    int\nset_ref_in_insexpand_funcs(int copyID)\n{\n    int abort = FALSE;\n\n    abort = set_ref_in_callback(&cfu_cb, copyID);\n    abort = abort || set_ref_in_callback(&ofu_cb, copyID);\n    abort = abort || set_ref_in_callback(&tsrfu_cb, copyID);\n\n    return abort;\n}\n\n/*\n * Get the user-defined completion function name for completion \"type\"\n */\n    static char_u *\nget_complete_funcname(int type)\n{\n    switch (type)\n    {\n\tcase CTRL_X_FUNCTION:\n\t    return curbuf->b_p_cfu;\n\tcase CTRL_X_OMNI:\n\t    return curbuf->b_p_ofu;\n\tcase CTRL_X_THESAURUS:\n\t    return *curbuf->b_p_tsrfu == NUL ? p_tsrfu : curbuf->b_p_tsrfu;\n\tdefault:\n\t    return (char_u *)\"\";\n    }\n}\n\n/*\n * Get the callback to use for insert mode completion.\n */\n    static callback_T *\nget_insert_callback(int type)\n{\n    if (type == CTRL_X_FUNCTION)\n\treturn &curbuf->b_cfu_cb;\n    if (type == CTRL_X_OMNI)\n\treturn &curbuf->b_ofu_cb;\n    // CTRL_X_THESAURUS\n    return (*curbuf->b_p_tsrfu != NUL) ? &curbuf->b_tsrfu_cb : &tsrfu_cb;\n}\n\n/*\n * Execute user defined complete function 'completefunc', 'omnifunc' or\n * 'thesaurusfunc', and get matches in \"matches\".\n * \"type\" is either CTRL_X_OMNI or CTRL_X_FUNCTION or CTRL_X_THESAURUS.\n */\n    static void\nexpand_by_function(int type, char_u *base)\n{\n    list_T      *matchlist = NULL;\n    dict_T\t*matchdict = NULL;\n    typval_T\targs[3];\n    char_u\t*funcname;\n    pos_T\tpos;\n    callback_T\t*cb;\n    typval_T\trettv;\n    int\t\tsave_State = State;\n    int\t\tretval;\n\n    funcname = get_complete_funcname(type);\n    if (*funcname == NUL)\n\treturn;\n\n    // Call 'completefunc' to obtain the list of matches.\n    args[0].v_type = VAR_NUMBER;\n    args[0].vval.v_number = 0;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = base != NULL ? base : (char_u *)\"\";\n    args[2].v_type = VAR_UNKNOWN;\n\n    pos = curwin->w_cursor;\n    // Lock the text to avoid weird things from happening.  Also disallow\n    // switching to another window, it should not be needed and may end up in\n    // Insert mode in another buffer.\n    ++textlock;\n\n    cb = get_insert_callback(type);\n    retval = call_callback(cb, 0, &rettv, 2, args);\n\n    // Call a function, which returns a list or dict.\n    if (retval == OK)\n    {\n\tswitch (rettv.v_type)\n\t{\n\t    case VAR_LIST:\n\t\tmatchlist = rettv.vval.v_list;\n\t\tbreak;\n\t    case VAR_DICT:\n\t\tmatchdict = rettv.vval.v_dict;\n\t\tbreak;\n\t    case VAR_SPECIAL:\n\t\tif (rettv.vval.v_number == VVAL_NONE)\n\t\t    compl_opt_suppress_empty = TRUE;\n\t\t// FALLTHROUGH\n\t    default:\n\t\t// TODO: Give error message?\n\t\tclear_tv(&rettv);\n\t\tbreak;\n\t}\n    }\n    --textlock;\n\n    curwin->w_cursor = pos;\t// restore the cursor position\n    validate_cursor();\n    if (!EQUAL_POS(curwin->w_cursor, pos))\n    {\n\temsg(_(e_complete_function_deleted_text));\n\tgoto theend;\n    }\n\n    if (matchlist != NULL)\n\tins_compl_add_list(matchlist);\n    else if (matchdict != NULL)\n\tins_compl_add_dict(matchdict);\n\ntheend:\n    // Restore State, it might have been changed.\n    State = save_State;\n\n    if (matchdict != NULL)\n\tdict_unref(matchdict);\n    if (matchlist != NULL)\n\tlist_unref(matchlist);\n}\n#endif // FEAT_COMPL_FUNC\n\n#if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add a match to the list of matches from a typeval_T.\n * If the given string is already in the list of completions, then return\n * NOTDONE, otherwise add it to the list and return OK.  If there is an error,\n * maybe because alloc() returns NULL, then FAIL is returned.\n * When \"fast\" is TRUE use fast_breakcheck() instead of ui_breakcheck().\n */\n    static int\nins_compl_add_tv(typval_T *tv, int dir, int fast)\n{\n    char_u\t*word;\n    int\t\tdup = FALSE;\n    int\t\tempty = FALSE;\n    int\t\tflags = fast ? CP_FAST : 0;\n    char_u\t*(cptext[CPT_COUNT]);\n    typval_T\tuser_data;\n    int\t\tstatus;\n\n    user_data.v_type = VAR_UNKNOWN;\n    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)\n    {\n\tword = dict_get_string(tv->vval.v_dict, \"word\", FALSE);\n\tcptext[CPT_ABBR] = dict_get_string(tv->vval.v_dict, \"abbr\", FALSE);\n\tcptext[CPT_MENU] = dict_get_string(tv->vval.v_dict, \"menu\", FALSE);\n\tcptext[CPT_KIND] = dict_get_string(tv->vval.v_dict, \"kind\", FALSE);\n\tcptext[CPT_INFO] = dict_get_string(tv->vval.v_dict, \"info\", FALSE);\n\tdict_get_tv(tv->vval.v_dict, \"user_data\", &user_data);\n\tif (dict_get_string(tv->vval.v_dict, \"icase\", FALSE) != NULL\n\t\t\t\t  && dict_get_number(tv->vval.v_dict, \"icase\"))\n\t    flags |= CP_ICASE;\n\tif (dict_get_string(tv->vval.v_dict, \"dup\", FALSE) != NULL)\n\t    dup = dict_get_number(tv->vval.v_dict, \"dup\");\n\tif (dict_get_string(tv->vval.v_dict, \"empty\", FALSE) != NULL)\n\t    empty = dict_get_number(tv->vval.v_dict, \"empty\");\n\tif (dict_get_string(tv->vval.v_dict, \"equal\", FALSE) != NULL\n\t\t\t\t  && dict_get_number(tv->vval.v_dict, \"equal\"))\n\t    flags |= CP_EQUAL;\n    }\n    else\n    {\n\tword = tv_get_string_chk(tv);\n\tCLEAR_FIELD(cptext);\n    }\n    if (word == NULL || (!empty && *word == NUL))\n    {\n\tclear_tv(&user_data);\n\treturn FAIL;\n    }\n    status = ins_compl_add(word, -1, NULL, cptext, &user_data, dir, flags, dup);\n    if (status != OK)\n\tclear_tv(&user_data);\n    return status;\n}\n\n/*\n * Add completions from a list.\n */\n    static void\nins_compl_add_list(list_T *list)\n{\n    listitem_T\t*li;\n    int\t\tdir = compl_direction;\n\n    // Go through the List with matches and add each of them.\n    CHECK_LIST_MATERIALIZE(list);\n    FOR_ALL_LIST_ITEMS(list, li)\n    {\n\tif (ins_compl_add_tv(&li->li_tv, dir, TRUE) == OK)\n\t    // if dir was BACKWARD then honor it just once\n\t    dir = FORWARD;\n\telse if (did_emsg)\n\t    break;\n    }\n}\n\n/*\n * Add completions from a dict.\n */\n    static void\nins_compl_add_dict(dict_T *dict)\n{\n    dictitem_T\t*di_refresh;\n    dictitem_T\t*di_words;\n\n    // Check for optional \"refresh\" item.\n    compl_opt_refresh_always = FALSE;\n    di_refresh = dict_find(dict, (char_u *)\"refresh\", 7);\n    if (di_refresh != NULL && di_refresh->di_tv.v_type == VAR_STRING)\n    {\n\tchar_u\t*v = di_refresh->di_tv.vval.v_string;\n\n\tif (v != NULL && STRCMP(v, (char_u *)\"always\") == 0)\n\t    compl_opt_refresh_always = TRUE;\n    }\n\n    // Add completions from a \"words\" list.\n    di_words = dict_find(dict, (char_u *)\"words\", 5);\n    if (di_words != NULL && di_words->di_tv.v_type == VAR_LIST)\n\tins_compl_add_list(di_words->di_tv.vval.v_list);\n}\n\n/*\n * Start completion for the complete() function.\n * \"startcol\" is where the matched text starts (1 is first column).\n * \"list\" is the list of matches.\n */\n    static void\nset_completion(colnr_T startcol, list_T *list)\n{\n    int save_w_wrow = curwin->w_wrow;\n    int save_w_leftcol = curwin->w_leftcol;\n    int flags = CP_ORIGINAL_TEXT;\n\n    // If already doing completions stop it.\n    if (ctrl_x_mode_not_default())\n\tins_compl_prep(' ');\n    ins_compl_clear();\n    ins_compl_free();\n    compl_get_longest = compl_longest;\n\n    compl_direction = FORWARD;\n    if (startcol > curwin->w_cursor.col)\n\tstartcol = curwin->w_cursor.col;\n    compl_col = startcol;\n    compl_length = (int)curwin->w_cursor.col - (int)startcol;\n    // compl_pattern doesn't need to be set\n    compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);\n    if (p_ic)\n\tflags |= CP_ICASE;\n    if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,\n\t\t\t\t\t      -1, NULL, NULL, NULL, 0,\n\t\t\t\t\t      flags | CP_FAST, FALSE) != OK)\n\treturn;\n\n    ctrl_x_mode = CTRL_X_EVAL;\n\n    ins_compl_add_list(list);\n    compl_matches = ins_compl_make_cyclic();\n    compl_started = TRUE;\n    compl_used_match = TRUE;\n    compl_cont_status = 0;\n\n    compl_curr_match = compl_first_match;\n    int no_select = compl_no_select || compl_longest;\n    if (compl_no_insert || no_select)\n    {\n\tins_complete(K_DOWN, FALSE);\n\tif (no_select)\n\t    // Down/Up has no real effect.\n\t    ins_complete(K_UP, FALSE);\n    }\n    else\n\tins_complete(Ctrl_N, FALSE);\n    compl_enter_selects = compl_no_insert;\n\n    // Lazily show the popup menu, unless we got interrupted.\n    if (!compl_interrupted)\n\tshow_pum(save_w_wrow, save_w_leftcol);\n    may_trigger_modechanged();\n    out_flush();\n}\n\n/*\n * \"complete()\" function\n */\n    void\nf_complete(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    int\t    startcol;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_list_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if ((State & MODE_INSERT) == 0)\n    {\n\temsg(_(e_complete_can_only_be_used_in_insert_mode));\n\treturn;\n    }\n\n    // Check for undo allowed here, because if something was already inserted\n    // the line was already saved for undo and this check isn't done.\n    if (!undo_allowed())\n\treturn;\n\n    if (check_for_nonnull_list_arg(argvars, 1) != FAIL)\n    {\n\tstartcol = (int)tv_get_number_chk(&argvars[0], NULL);\n\tif (startcol > 0)\n\t    set_completion(startcol - 1, argvars[1].vval.v_list);\n    }\n}\n\n/*\n * \"complete_add()\" function\n */\n    void\nf_complete_add(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_or_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = ins_compl_add_tv(&argvars[0], 0, FALSE);\n}\n\n/*\n * \"complete_check()\" function\n */\n    void\nf_complete_check(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\tsaved = RedrawingDisabled;\n\n    RedrawingDisabled = 0;\n    ins_compl_check_keys(0, TRUE);\n    rettv->vval.v_number = ins_compl_interrupted();\n    RedrawingDisabled = saved;\n}\n\n/*\n * Return Insert completion mode name string\n */\n    static char_u *\nins_compl_mode(void)\n{\n    if (ctrl_x_mode_not_defined_yet() || ctrl_x_mode_scroll() || compl_started)\n\treturn (char_u *)ctrl_x_mode_names[ctrl_x_mode & ~CTRL_X_WANT_IDENT];\n\n    return (char_u *)\"\";\n}\n\n/*\n * Assign the sequence number to all the completion matches which don't have\n * one assigned yet.\n */\n    static void\nins_compl_update_sequence_numbers()\n{\n    int\t\tnumber = 0;\n    compl_T\t*match;\n\n    if (compl_dir_forward())\n    {\n\t// search backwards for the first valid (!= -1) number.\n\t// This should normally succeed already at the first loop\n\t// cycle, so it's fast!\n\tfor (match = compl_curr_match->cp_prev; match != NULL\n\t\t&& !is_first_match(match); match = match->cp_prev)\n\t    if (match->cp_number != -1)\n\t    {\n\t\tnumber = match->cp_number;\n\t\tbreak;\n\t    }\n\tif (match != NULL)\n\t    // go up and assign all numbers which are not assigned\n\t    // yet\n\t    for (match = match->cp_next;\n\t\t    match != NULL && match->cp_number == -1;\n\t\t\t\t\t   match = match->cp_next)\n\t\tmatch->cp_number = ++number;\n    }\n    else // BACKWARD\n    {\n\t// search forwards (upwards) for the first valid (!= -1)\n\t// number.  This should normally succeed already at the\n\t// first loop cycle, so it's fast!\n\tfor (match = compl_curr_match->cp_next; match != NULL\n\t\t&& !is_first_match(match); match = match->cp_next)\n\t    if (match->cp_number != -1)\n\t    {\n\t\tnumber = match->cp_number;\n\t\tbreak;\n\t    }\n\tif (match != NULL)\n\t    // go down and assign all numbers which are not\n\t    // assigned yet\n\t    for (match = match->cp_prev; match\n\t\t    && match->cp_number == -1;\n\t\t\t\t\t   match = match->cp_prev)\n\t\tmatch->cp_number = ++number;\n    }\n}\n\n/*\n * Get complete information\n */\n    static void\nget_complete_info(list_T *what_list, dict_T *retdict)\n{\n    int\t\tret = OK;\n    listitem_T\t*item;\n#define CI_WHAT_MODE\t\t0x01\n#define CI_WHAT_PUM_VISIBLE\t0x02\n#define CI_WHAT_ITEMS\t\t0x04\n#define CI_WHAT_SELECTED\t0x08\n#define CI_WHAT_INSERTED\t0x10\n#define CI_WHAT_ALL\t\t0xff\n    int\t\twhat_flag;\n\n    if (what_list == NULL)\n\twhat_flag = CI_WHAT_ALL;\n    else\n    {\n\twhat_flag = 0;\n\tCHECK_LIST_MATERIALIZE(what_list);\n\tFOR_ALL_LIST_ITEMS(what_list, item)\n\t{\n\t    char_u *what = tv_get_string(&item->li_tv);\n\n\t    if (STRCMP(what, \"mode\") == 0)\n\t\twhat_flag |= CI_WHAT_MODE;\n\t    else if (STRCMP(what, \"pum_visible\") == 0)\n\t\twhat_flag |= CI_WHAT_PUM_VISIBLE;\n\t    else if (STRCMP(what, \"items\") == 0)\n\t\twhat_flag |= CI_WHAT_ITEMS;\n\t    else if (STRCMP(what, \"selected\") == 0)\n\t\twhat_flag |= CI_WHAT_SELECTED;\n\t    else if (STRCMP(what, \"inserted\") == 0)\n\t\twhat_flag |= CI_WHAT_INSERTED;\n\t}\n    }\n\n    if (ret == OK && (what_flag & CI_WHAT_MODE))\n\tret = dict_add_string(retdict, \"mode\", ins_compl_mode());\n\n    if (ret == OK && (what_flag & CI_WHAT_PUM_VISIBLE))\n\tret = dict_add_number(retdict, \"pum_visible\", pum_visible());\n\n    if (ret == OK && (what_flag & CI_WHAT_ITEMS))\n    {\n\tlist_T\t    *li;\n\tdict_T\t    *di;\n\tcompl_T     *match;\n\n\tli = list_alloc();\n\tif (li == NULL)\n\t    return;\n\tret = dict_add_list(retdict, \"items\", li);\n\tif (ret == OK && compl_first_match != NULL)\n\t{\n\t    match = compl_first_match;\n\t    do\n\t    {\n\t\tif (!match_at_original_text(match))\n\t\t{\n\t\t    di = dict_alloc();\n\t\t    if (di == NULL)\n\t\t\treturn;\n\t\t    ret = list_append_dict(li, di);\n\t\t    if (ret != OK)\n\t\t\treturn;\n\t\t    dict_add_string(di, \"word\", match->cp_str);\n\t\t    dict_add_string(di, \"abbr\", match->cp_text[CPT_ABBR]);\n\t\t    dict_add_string(di, \"menu\", match->cp_text[CPT_MENU]);\n\t\t    dict_add_string(di, \"kind\", match->cp_text[CPT_KIND]);\n\t\t    dict_add_string(di, \"info\", match->cp_text[CPT_INFO]);\n\t\t    if (match->cp_user_data.v_type == VAR_UNKNOWN)\n\t\t\t// Add an empty string for backwards compatibility\n\t\t\tdict_add_string(di, \"user_data\", (char_u *)\"\");\n\t\t    else\n\t\t\tdict_add_tv(di, \"user_data\", &match->cp_user_data);\n\t\t}\n\t\tmatch = match->cp_next;\n\t    }\n\t    while (match != NULL && !is_first_match(match));\n\t}\n    }\n\n    if (ret == OK && (what_flag & CI_WHAT_SELECTED))\n    {\n\tif (compl_curr_match != NULL && compl_curr_match->cp_number == -1)\n\t    ins_compl_update_sequence_numbers();\n\tret = dict_add_number(retdict, \"selected\", compl_curr_match != NULL\n\t\t\t\t      ? compl_curr_match->cp_number - 1 : -1);\n    }\n\n    if (ret == OK && (what_flag & CI_WHAT_INSERTED))\n    {\n\t// TODO\n    }\n}\n\n/*\n * \"complete_info()\" function\n */\n    void\nf_complete_info(typval_T *argvars, typval_T *rettv)\n{\n    list_T\t*what_list = NULL;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tif (check_for_list_arg(argvars, 0) == FAIL)\n\t    return;\n\twhat_list = argvars[0].vval.v_list;\n    }\n    get_complete_info(what_list, rettv->vval.v_dict);\n}\n#endif\n\n/*\n * Returns TRUE when using a user-defined function for thesaurus completion.\n */\n    static int\nthesaurus_func_complete(int type UNUSED)\n{\n#ifdef FEAT_COMPL_FUNC\n    return type == CTRL_X_THESAURUS\n\t\t&& (*curbuf->b_p_tsrfu != NUL || *p_tsrfu != NUL);\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return value of process_next_cpt_value()\n */\nenum\n{\n    INS_COMPL_CPT_OK = 1,\n    INS_COMPL_CPT_CONT,\n    INS_COMPL_CPT_END\n};\n\n/*\n * state information used for getting the next set of insert completion\n * matches.\n */\ntypedef struct\n{\n    char_u\t*e_cpt;\t\t\t// current entry in 'complete'\n    buf_T\t*ins_buf;\t\t// buffer being scanned\n    pos_T\t*cur_match_pos;\t\t\t// current match position\n    pos_T\tprev_match_pos;\t\t// previous match position\n    int\t\tset_match_pos;\t\t// save first_match_pos/last_match_pos\n    pos_T\tfirst_match_pos;\t// first match position\n    pos_T\tlast_match_pos;\t\t// last match position\n    int\t\tfound_all;\t\t// found all matches of a certain type.\n    char_u\t*dict;\t\t\t// dictionary file to search\n    int\t\tdict_f;\t\t\t// \"dict\" is an exact file name or not\n} ins_compl_next_state_T;\n\n/*\n * Process the next 'complete' option value in st->e_cpt.\n *\n * If successful, the arguments are set as below:\n *   st->cpt - pointer to the next option value in \"st->cpt\"\n *   compl_type_arg - type of insert mode completion to use\n *   st->found_all - all matches of this type are found\n *   st->ins_buf - search for completions in this buffer\n *   st->first_match_pos - position of the first completion match\n *   st->last_match_pos - position of the last completion match\n *   st->set_match_pos - TRUE if the first match position should be saved to\n *\t\t\t    avoid loops after the search wraps around.\n *   st->dict - name of the dictionary or thesaurus file to search\n *   st->dict_f - flag specifying whether \"dict\" is an exact file name or not\n *\n * Returns INS_COMPL_CPT_OK if the next value is processed successfully.\n * Returns INS_COMPL_CPT_CONT to skip the current completion source matching\n * the \"st->e_cpt\" option value and process the next matching source.\n * Returns INS_COMPL_CPT_END if all the values in \"st->e_cpt\" are processed.\n */\n    static int\nprocess_next_cpt_value(\n\tins_compl_next_state_T *st,\n\tint\t\t*compl_type_arg,\n\tpos_T\t\t*start_match_pos)\n{\n    int\t    compl_type = -1;\n    int\t    status = INS_COMPL_CPT_OK;\n\n    st->found_all = FALSE;\n\n    while (*st->e_cpt == ',' || *st->e_cpt == ' ')\n\tst->e_cpt++;\n\n    if (*st->e_cpt == '.' && !curbuf->b_scanned)\n    {\n\tst->ins_buf = curbuf;\n\tst->first_match_pos = *start_match_pos;\n\t// Move the cursor back one character so that ^N can match the\n\t// word immediately after the cursor.\n\tif (ctrl_x_mode_normal() && dec(&st->first_match_pos) < 0)\n\t{\n\t    // Move the cursor to after the last character in the\n\t    // buffer, so that word at start of buffer is found\n\t    // correctly.\n\t    st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count;\n\t    st->first_match_pos.col =\n\t\t(colnr_T)STRLEN(ml_get(st->first_match_pos.lnum));\n\t}\n\tst->last_match_pos = st->first_match_pos;\n\tcompl_type = 0;\n\n\t// Remember the first match so that the loop stops when we\n\t// wrap and come back there a second time.\n\tst->set_match_pos = TRUE;\n    }\n    else if (vim_strchr((char_u *)\"buwU\", *st->e_cpt) != NULL\n\t    && (st->ins_buf = ins_compl_next_buf(st->ins_buf, *st->e_cpt)) != curbuf)\n    {\n\t// Scan a buffer, but not the current one.\n\tif (st->ins_buf->b_ml.ml_mfp != NULL)   // loaded buffer\n\t{\n\t    compl_started = TRUE;\n\t    st->first_match_pos.col = st->last_match_pos.col = 0;\n\t    st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count + 1;\n\t    st->last_match_pos.lnum = 0;\n\t    compl_type = 0;\n\t}\n\telse\t// unloaded buffer, scan like dictionary\n\t{\n\t    st->found_all = TRUE;\n\t    if (st->ins_buf->b_fname == NULL)\n\t    {\n\t\tstatus = INS_COMPL_CPT_CONT;\n\t\tgoto done;\n\t    }\n\t    compl_type = CTRL_X_DICTIONARY;\n\t    st->dict = st->ins_buf->b_fname;\n\t    st->dict_f = DICT_EXACT;\n\t}\n\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),\n\t\tst->ins_buf->b_fname == NULL\n\t\t    ? buf_spname(st->ins_buf)\n\t\t    : st->ins_buf->b_sfname == NULL\n\t\t\t? st->ins_buf->b_fname\n\t\t\t: st->ins_buf->b_sfname);\n\t(void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n    }\n    else if (*st->e_cpt == NUL)\n\tstatus = INS_COMPL_CPT_END;\n    else\n    {\n\tif (ctrl_x_mode_line_or_eval())\n\t    compl_type = -1;\n\telse if (*st->e_cpt == 'k' || *st->e_cpt == 's')\n\t{\n\t    if (*st->e_cpt == 'k')\n\t\tcompl_type = CTRL_X_DICTIONARY;\n\t    else\n\t\tcompl_type = CTRL_X_THESAURUS;\n\t    if (*++st->e_cpt != ',' && *st->e_cpt != NUL)\n\t    {\n\t\tst->dict = st->e_cpt;\n\t\tst->dict_f = DICT_FIRST;\n\t    }\n\t}\n#ifdef FEAT_FIND_ID\n\telse if (*st->e_cpt == 'i')\n\t    compl_type = CTRL_X_PATH_PATTERNS;\n\telse if (*st->e_cpt == 'd')\n\t    compl_type = CTRL_X_PATH_DEFINES;\n#endif\n\telse if (*st->e_cpt == ']' || *st->e_cpt == 't')\n\t{\n\t    msg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t    compl_type = CTRL_X_TAGS;\n\t    vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning tags.\"));\n\t    (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t}\n\telse\n\t    compl_type = -1;\n\n\t// in any case e_cpt is advanced to the next entry\n\t(void)copy_option_part(&st->e_cpt, IObuff, IOSIZE, \",\");\n\n\tst->found_all = TRUE;\n\tif (compl_type == -1)\n\t    status = INS_COMPL_CPT_CONT;\n    }\n\ndone:\n    *compl_type_arg = compl_type;\n    return status;\n}\n\n#ifdef FEAT_FIND_ID\n/*\n * Get the next set of identifiers or defines matching \"compl_pattern\" in\n * included files.\n */\n    static void\nget_next_include_file_completion(int compl_type)\n{\n    find_pattern_in_path(compl_pattern, compl_direction,\n\t    (int)STRLEN(compl_pattern), FALSE, FALSE,\n\t    (compl_type == CTRL_X_PATH_DEFINES\n\t     && !(compl_cont_status & CONT_SOL))\n\t    ? FIND_DEFINE : FIND_ANY, 1L, ACTION_EXPAND,\n\t    (linenr_T)1, (linenr_T)MAXLNUM);\n}\n#endif\n\n/*\n * Get the next set of words matching \"compl_pattern\" in dictionary or\n * thesaurus files.\n */\n    static void\nget_next_dict_tsr_completion(int compl_type, char_u *dict, int dict_f)\n{\n#ifdef FEAT_COMPL_FUNC\n    if (thesaurus_func_complete(compl_type))\n\texpand_by_function(compl_type, compl_pattern);\n    else\n#endif\n\tins_compl_dictionaries(\n\t\tdict != NULL ? dict\n\t\t: (compl_type == CTRL_X_THESAURUS\n\t\t    ? (*curbuf->b_p_tsr == NUL ? p_tsr : curbuf->b_p_tsr)\n\t\t    : (*curbuf->b_p_dict == NUL ? p_dict : curbuf->b_p_dict)),\n\t\tcompl_pattern,\n\t\tdict != NULL ? dict_f : 0,\n\t\tcompl_type == CTRL_X_THESAURUS);\n}\n\n/*\n * Get the next set of tag names matching \"compl_pattern\".\n */\n    static void\nget_next_tag_completion(void)\n{\n    int\t\tsave_p_ic;\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    // set p_ic according to p_ic, p_scs and pat for find_tags().\n    save_p_ic = p_ic;\n    p_ic = ignorecase(compl_pattern);\n\n    // Find up to TAG_MANY matches.  Avoids that an enormous number\n    // of matches is found when compl_pattern is empty\n    g_tag_at_cursor = TRUE;\n    if (find_tags(compl_pattern, &num_matches, &matches,\n\t\tTAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP\n\t\t| (ctrl_x_mode_not_default() ? TAG_VERBOSE : 0),\n\t\tTAG_MANY, curbuf->b_ffname) == OK && num_matches > 0)\n\tins_compl_add_matches(num_matches, matches, p_ic);\n    g_tag_at_cursor = FALSE;\n    p_ic = save_p_ic;\n}\n\n/*\n * Get the next set of filename matching \"compl_pattern\".\n */\n    static void\nget_next_filename_completion(void)\n{\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    if (expand_wildcards(1, &compl_pattern, &num_matches, &matches,\n\t\tEW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) != OK)\n\treturn;\n\n    // May change home directory back to \"~\".\n    tilde_replace(compl_pattern, num_matches, matches);\n#ifdef BACKSLASH_IN_FILENAME\n    if (curbuf->b_p_csl[0] != NUL)\n    {\n\tint\t    i;\n\n\tfor (i = 0; i < num_matches; ++i)\n\t{\n\t    char_u\t*ptr = matches[i];\n\n\t    while (*ptr != NUL)\n\t    {\n\t\tif (curbuf->b_p_csl[0] == 's' && *ptr == '\\\\')\n\t\t    *ptr = '/';\n\t\telse if (curbuf->b_p_csl[0] == 'b' && *ptr == '/')\n\t\t    *ptr = '\\\\';\n\t\tptr += (*mb_ptr2len)(ptr);\n\t    }\n\t}\n    }\n#endif\n    ins_compl_add_matches(num_matches, matches, p_fic || p_wic);\n}\n\n/*\n * Get the next set of command-line completions matching \"compl_pattern\".\n */\n    static void\nget_next_cmdline_completion()\n{\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    if (expand_cmdline(&compl_xp, compl_pattern,\n\t\t(int)STRLEN(compl_pattern),\n\t\t&num_matches, &matches) == EXPAND_OK)\n\tins_compl_add_matches(num_matches, matches, FALSE);\n}\n\n/*\n * Get the next set of spell suggestions matching \"compl_pattern\".\n */\n    static void\nget_next_spell_completion(linenr_T lnum UNUSED)\n{\n#ifdef FEAT_SPELL\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    num_matches = expand_spelling(lnum, compl_pattern, &matches);\n    if (num_matches > 0)\n\tins_compl_add_matches(num_matches, matches, p_ic);\n    else\n\tvim_free(matches);\n#endif\n}\n\n/*\n * Return the next word or line from buffer \"ins_buf\" at position\n * \"cur_match_pos\" for completion.  The length of the match is set in \"len\".\n */\n    static char_u *\nins_comp_get_next_word_or_line(\n\tbuf_T\t*ins_buf,\t\t// buffer being scanned\n\tpos_T\t*cur_match_pos,\t\t// current match position\n\tint\t*match_len,\n\tint\t*cont_s_ipos)\t\t// next ^X<> will set initial_pos\n{\n    char_u\t*ptr;\n    int\t\tlen;\n\n    *match_len = 0;\n    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +\n\tcur_match_pos->col;\n    if (ctrl_x_mode_line_or_eval())\n    {\n\tif (compl_status_adding())\n\t{\n\t    if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)\n\t\treturn NULL;\n\t    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t    if (!p_paste)\n\t\tptr = skipwhite(ptr);\n\t}\n\tlen = (int)STRLEN(ptr);\n    }\n    else\n    {\n\tchar_u\t*tmp_ptr = ptr;\n\n\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))\n\t{\n\t    tmp_ptr += compl_length;\n\t    // Skip if already inside a word.\n\t    if (vim_iswordp(tmp_ptr))\n\t\treturn NULL;\n\t    // Find start of next word.\n\t    tmp_ptr = find_word_start(tmp_ptr);\n\t}\n\t// Find end of this word.\n\ttmp_ptr = find_word_end(tmp_ptr);\n\tlen = (int)(tmp_ptr - ptr);\n\n\tif (compl_status_adding() && len == compl_length)\n\t{\n\t    if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)\n\t    {\n\t\t// Try next line, if any. the new word will be\n\t\t// \"join\" as if the normal command \"J\" was used.\n\t\t// IOSIZE is always greater than\n\t\t// compl_length, so the next STRNCPY always\n\t\t// works -- Acevedo\n\t\tSTRNCPY(IObuff, ptr, len);\n\t\tptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t\ttmp_ptr = ptr = skipwhite(ptr);\n\t\t// Find start of next word.\n\t\ttmp_ptr = find_word_start(tmp_ptr);\n\t\t// Find end of next word.\n\t\ttmp_ptr = find_word_end(tmp_ptr);\n\t\tif (tmp_ptr > ptr)\n\t\t{\n\t\t    if (*ptr != ')' && IObuff[len - 1] != TAB)\n\t\t    {\n\t\t\tif (IObuff[len - 1] != ' ')\n\t\t\t    IObuff[len++] = ' ';\n\t\t\t// IObuf =~ \"\\k.* \", thus len >= 2\n\t\t\tif (p_js\n\t\t\t\t&& (IObuff[len - 2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP)\n\t\t\t\t\t== NULL\n\t\t\t\t\t&& (IObuff[len - 2] == '?'\n\t\t\t\t\t    || IObuff[len - 2] == '!'))))\n\t\t\t    IObuff[len++] = ' ';\n\t\t    }\n\t\t    // copy as much as possible of the new word\n\t\t    if (tmp_ptr - ptr >= IOSIZE - len)\n\t\t\ttmp_ptr = ptr + IOSIZE - len - 1;\n\t\t    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);\n\t\t    len += (int)(tmp_ptr - ptr);\n\t\t    *cont_s_ipos = TRUE;\n\t\t}\n\t\tIObuff[len] = NUL;\n\t\tptr = IObuff;\n\t    }\n\t    if (len == compl_length)\n\t\treturn NULL;\n\t}\n    }\n\n    *match_len = len;\n    return ptr;\n}\n\n/*\n * Get the next set of words matching \"compl_pattern\" for default completion(s)\n * (normal ^P/^N and ^X^L).\n * Search for \"compl_pattern\" in the buffer \"st->ins_buf\" starting from the\n * position \"st->start_pos\" in the \"compl_direction\" direction. If\n * \"st->set_match_pos\" is TRUE, then set the \"st->first_match_pos\" and\n * \"st->last_match_pos\".\n * Returns OK if a new next match is found, otherwise returns FAIL.\n */\n    static int\nget_next_default_completion(ins_compl_next_state_T *st, pos_T *start_pos)\n{\n    int\t\tfound_new_match = FAIL;\n    int\t\tsave_p_scs;\n    int\t\tsave_p_ws;\n    int\t\tlooped_around = FALSE;\n    char_u\t*ptr;\n    int\t\tlen;\n\n    // If 'infercase' is set, don't use 'smartcase' here\n    save_p_scs = p_scs;\n    if (st->ins_buf->b_p_inf)\n\tp_scs = FALSE;\n\n    //\tBuffers other than curbuf are scanned from the beginning or the\n    //\tend but never from the middle, thus setting nowrapscan in this\n    //\tbuffer is a good idea, on the other hand, we always set\n    //\twrapscan for curbuf to avoid missing matches -- Acevedo,Webb\n    save_p_ws = p_ws;\n    if (st->ins_buf != curbuf)\n\tp_ws = FALSE;\n    else if (*st->e_cpt == '.')\n\tp_ws = TRUE;\n    looped_around = FALSE;\n    for (;;)\n    {\n\tint\tcont_s_ipos = FALSE;\n\n\t++msg_silent;  // Don't want messages for wrapscan.\n\n\t// ctrl_x_mode_line_or_eval() || word-wise search that\n\t// has added a word that was at the beginning of the line\n\tif (ctrl_x_mode_line_or_eval() || (compl_cont_status & CONT_SOL))\n\t    found_new_match = search_for_exact_line(st->ins_buf,\n\t\t\t    st->cur_match_pos, compl_direction, compl_pattern);\n\telse\n\t    found_new_match = searchit(NULL, st->ins_buf, st->cur_match_pos,\n\t\t\t\tNULL, compl_direction, compl_pattern, 1L,\n\t\t\t\tSEARCH_KEEP + SEARCH_NFMSG, RE_LAST, NULL);\n\t--msg_silent;\n\tif (!compl_started || st->set_match_pos)\n\t{\n\t    // set \"compl_started\" even on fail\n\t    compl_started = TRUE;\n\t    st->first_match_pos = *st->cur_match_pos;\n\t    st->last_match_pos = *st->cur_match_pos;\n\t    st->set_match_pos = FALSE;\n\t}\n\telse if (st->first_match_pos.lnum == st->last_match_pos.lnum\n\t\t&& st->first_match_pos.col == st->last_match_pos.col)\n\t{\n\t    found_new_match = FAIL;\n\t}\n\telse if (compl_dir_forward()\n\t\t&& (st->prev_match_pos.lnum > st->cur_match_pos->lnum\n\t\t    || (st->prev_match_pos.lnum == st->cur_match_pos->lnum\n\t\t\t&& st->prev_match_pos.col >= st->cur_match_pos->col)))\n\t{\n\t    if (looped_around)\n\t\tfound_new_match = FAIL;\n\t    else\n\t\tlooped_around = TRUE;\n\t}\n\telse if (!compl_dir_forward()\n\t\t&& (st->prev_match_pos.lnum < st->cur_match_pos->lnum\n\t\t    || (st->prev_match_pos.lnum == st->cur_match_pos->lnum\n\t\t\t&& st->prev_match_pos.col <= st->cur_match_pos->col)))\n\t{\n\t    if (looped_around)\n\t\tfound_new_match = FAIL;\n\t    else\n\t\tlooped_around = TRUE;\n\t}\n\tst->prev_match_pos = *st->cur_match_pos;\n\tif (found_new_match == FAIL)\n\t    break;\n\n\t// when ADDING, the text before the cursor matches, skip it\n\tif (compl_status_adding() && st->ins_buf == curbuf\n\t\t&& start_pos->lnum == st->cur_match_pos->lnum\n\t\t&& start_pos->col  == st->cur_match_pos->col)\n\t    continue;\n\n\tptr = ins_comp_get_next_word_or_line(st->ins_buf, st->cur_match_pos,\n\t\t\t\t\t\t\t&len, &cont_s_ipos);\n\tif (ptr == NULL)\n\t    continue;\n\n\tif (ins_compl_add_infercase(ptr, len, p_ic,\n\t\t    st->ins_buf == curbuf ? NULL : st->ins_buf->b_sfname,\n\t\t    0, cont_s_ipos) != NOTDONE)\n\t{\n\t    found_new_match = OK;\n\t    break;\n\t}\n    }\n    p_scs = save_p_scs;\n    p_ws = save_p_ws;\n\n    return found_new_match;\n}\n\n/*\n * get the next set of completion matches for \"type\".\n * Returns TRUE if a new match is found. Otherwise returns FALSE.\n */\n    static int\nget_next_completion_match(int type, ins_compl_next_state_T *st, pos_T *ini)\n{\n    int\tfound_new_match = FALSE;\n\n    switch (type)\n    {\n\tcase -1:\n\t    break;\n#ifdef FEAT_FIND_ID\n\tcase CTRL_X_PATH_PATTERNS:\n\tcase CTRL_X_PATH_DEFINES:\n\t    get_next_include_file_completion(type);\n\t    break;\n#endif\n\n\tcase CTRL_X_DICTIONARY:\n\tcase CTRL_X_THESAURUS:\n\t    get_next_dict_tsr_completion(type, st->dict, st->dict_f);\n\t    st->dict = NULL;\n\t    break;\n\n\tcase CTRL_X_TAGS:\n\t    get_next_tag_completion();\n\t    break;\n\n\tcase CTRL_X_FILES:\n\t    get_next_filename_completion();\n\t    break;\n\n\tcase CTRL_X_CMDLINE:\n\tcase CTRL_X_CMDLINE_CTRL_X:\n\t    get_next_cmdline_completion();\n\t    break;\n\n#ifdef FEAT_COMPL_FUNC\n\tcase CTRL_X_FUNCTION:\n\tcase CTRL_X_OMNI:\n\t    expand_by_function(type, compl_pattern);\n\t    break;\n#endif\n\n\tcase CTRL_X_SPELL:\n\t    get_next_spell_completion(st->first_match_pos.lnum);\n\t    break;\n\n\tdefault:\t// normal ^P/^N and ^X^L\n\t    found_new_match = get_next_default_completion(st, ini);\n\t    if (found_new_match == FAIL && st->ins_buf == curbuf)\n\t\tst->found_all = TRUE;\n    }\n\n    // check if compl_curr_match has changed, (e.g. other type of\n    // expansion added something)\n    if (type != 0 && compl_curr_match != compl_old_match)\n\tfound_new_match = OK;\n\n    return found_new_match;\n}\n\n/*\n * Get the next expansion(s), using \"compl_pattern\".\n * The search starts at position \"ini\" in curbuf and in the direction\n * compl_direction.\n * When \"compl_started\" is FALSE start at that position, otherwise continue\n * where we stopped searching before.\n * This may return before finding all the matches.\n * Return the total number of matches or -1 if still unknown -- Acevedo\n */\n    static int\nins_compl_get_exp(pos_T *ini)\n{\n    static ins_compl_next_state_T st;\n    int\t\ti;\n    int\t\tfound_new_match;\n    int\t\ttype = ctrl_x_mode;\n\n    if (!compl_started)\n    {\n\tFOR_ALL_BUFFERS(st.ins_buf)\n\t    st.ins_buf->b_scanned = 0;\n\tst.found_all = FALSE;\n\tst.ins_buf = curbuf;\n\tst.e_cpt = (compl_cont_status & CONT_LOCAL)\n\t\t\t\t\t    ? (char_u *)\".\" : curbuf->b_p_cpt;\n\tst.last_match_pos = st.first_match_pos = *ini;\n    }\n    else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))\n\tst.ins_buf = curbuf;  // In case the buffer was wiped out.\n\n    compl_old_match = compl_curr_match;\t// remember the last current match\n    st.cur_match_pos = (compl_dir_forward())\n\t\t\t\t? &st.last_match_pos : &st.first_match_pos;\n\n    // For ^N/^P loop over all the flags/windows/buffers in 'complete'.\n    for (;;)\n    {\n\tfound_new_match = FAIL;\n\tst.set_match_pos = FALSE;\n\n\t// For ^N/^P pick a new entry from e_cpt if compl_started is off,\n\t// or if found_all says this entry is done.  For ^X^L only use the\n\t// entries from 'complete' that look in loaded buffers.\n\tif ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())\n\t\t\t\t\t&& (!compl_started || st.found_all))\n\t{\n\t    int status = process_next_cpt_value(&st, &type, ini);\n\n\t    if (status == INS_COMPL_CPT_END)\n\t\tbreak;\n\t    if (status == INS_COMPL_CPT_CONT)\n\t\tcontinue;\n\t}\n\n\t// If complete() was called then compl_pattern has been reset.  The\n\t// following won't work then, bail out.\n\tif (compl_pattern == NULL)\n\t    break;\n\n\t// get the next set of completion matches\n\tfound_new_match = get_next_completion_match(type, &st, ini);\n\n\t// break the loop for specialized modes (use 'complete' just for the\n\t// generic ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new\n\t// match\n\tif ((ctrl_x_mode_not_default() && !ctrl_x_mode_line_or_eval())\n\t\t\t\t\t\t|| found_new_match != FAIL)\n\t{\n\t    if (got_int)\n\t\tbreak;\n\t    // Fill the popup menu as soon as possible.\n\t    if (type != -1)\n\t\tins_compl_check_keys(0, FALSE);\n\n\t    if ((ctrl_x_mode_not_default()\n\t\t\t&& !ctrl_x_mode_line_or_eval()) || compl_interrupted)\n\t\tbreak;\n\t    compl_started = TRUE;\n\t}\n\telse\n\t{\n\t    // Mark a buffer scanned when it has been scanned completely\n\t    if (type == 0 || type == CTRL_X_PATH_PATTERNS)\n\t\tst.ins_buf->b_scanned = TRUE;\n\n\t    compl_started = FALSE;\n\t}\n    }\n    compl_started = TRUE;\n\n    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())\n\t    && *st.e_cpt == NUL)\t\t// Got to end of 'complete'\n\tfound_new_match = FAIL;\n\n    i = -1;\t\t// total of matches, unknown\n    if (found_new_match == FAIL || (ctrl_x_mode_not_default()\n\t\t\t\t\t       && !ctrl_x_mode_line_or_eval()))\n\ti = ins_compl_make_cyclic();\n\n    if (compl_old_match != NULL)\n    {\n\t// If several matches were added (FORWARD) or the search failed and has\n\t// just been made cyclic then we have to move compl_curr_match to the\n\t// next or previous entry (if any) -- Acevedo\n\tcompl_curr_match = compl_dir_forward() ? compl_old_match->cp_next\n\t\t\t\t\t\t    : compl_old_match->cp_prev;\n\tif (compl_curr_match == NULL)\n\t    compl_curr_match = compl_old_match;\n    }\n    may_trigger_modechanged();\n\n    return i;\n}\n\n/*\n * Update \"compl_shown_match\" to the actually shown match, it may differ when\n * \"compl_leader\" is used to omit some of the matches.\n */\n    static void\nins_compl_update_shown_match(void)\n{\n    while (!ins_compl_equal(compl_shown_match,\n\t\tcompl_leader, (int)STRLEN(compl_leader))\n\t    && compl_shown_match->cp_next != NULL\n\t    && !is_first_match(compl_shown_match->cp_next))\n\tcompl_shown_match = compl_shown_match->cp_next;\n\n    // If we didn't find it searching forward, and compl_shows_dir is\n    // backward, find the last match.\n    if (compl_shows_dir_backward()\n\t    && !ins_compl_equal(compl_shown_match,\n\t\tcompl_leader, (int)STRLEN(compl_leader))\n\t    && (compl_shown_match->cp_next == NULL\n\t\t|| is_first_match(compl_shown_match->cp_next)))\n    {\n\twhile (!ins_compl_equal(compl_shown_match,\n\t\t    compl_leader, (int)STRLEN(compl_leader))\n\t\t&& compl_shown_match->cp_prev != NULL\n\t\t&& !is_first_match(compl_shown_match->cp_prev))\n\t    compl_shown_match = compl_shown_match->cp_prev;\n    }\n}\n\n/*\n * Delete the old text being completed.\n */\n    void\nins_compl_delete(void)\n{\n    int\t    col;\n\n    // In insert mode: Delete the typed part.\n    // In replace mode: Put the old characters back, if any.\n    col = compl_col + (compl_status_adding() ? compl_length : 0);\n    if ((int)curwin->w_cursor.col > col)\n    {\n\tif (stop_arrow() == FAIL)\n\t    return;\n\tbackspace_until_column(col);\n    }\n\n    // TODO: is this sufficient for redrawing?  Redrawing everything causes\n    // flicker, thus we can't do that.\n    changed_cline_bef_curs();\n#ifdef FEAT_EVAL\n    // clear v:completed_item\n    set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc_lock(VAR_FIXED));\n#endif\n}\n\n/*\n * Insert the new text being completed.\n * \"in_compl_func\" is TRUE when called from complete_check().\n */\n    void\nins_compl_insert(int in_compl_func)\n{\n    int compl_len = get_compl_len();\n\n    // Make sure we don't go over the end of the string, this can happen with\n    // illegal bytes.\n    if (compl_len < (int)STRLEN(compl_shown_match->cp_str))\n\tins_bytes(compl_shown_match->cp_str + compl_len);\n    if (match_at_original_text(compl_shown_match))\n\tcompl_used_match = FALSE;\n    else\n\tcompl_used_match = TRUE;\n#ifdef FEAT_EVAL\n    {\n\tdict_T *dict = ins_compl_dict_alloc(compl_shown_match);\n\n\tset_vim_var_dict(VV_COMPLETED_ITEM, dict);\n    }\n#endif\n    if (!in_compl_func)\n\tcompl_curr_match = compl_shown_match;\n}\n\n/*\n * show the file name for the completion match (if any).  Truncate the file\n * name to avoid a wait for return.\n */\n    static void\nins_compl_show_filename(void)\n{\n    char\t*lead = _(\"match in file\");\n    int\t\tspace = sc_col - vim_strsize((char_u *)lead) - 2;\n    char_u\t*s;\n    char_u\t*e;\n\n    if (space <= 0)\n\treturn;\n\n    // We need the tail that fits.  With double-byte encoding going\n    // back from the end is very slow, thus go from the start and keep\n    // the text that fits in \"space\" between \"s\" and \"e\".\n    for (s = e = compl_shown_match->cp_fname; *e != NUL; MB_PTR_ADV(e))\n    {\n\tspace -= ptr2cells(e);\n\twhile (space < 0)\n\t{\n\t    space += ptr2cells(s);\n\t    MB_PTR_ADV(s);\n\t}\n    }\n    msg_hist_off = TRUE;\n    vim_snprintf((char *)IObuff, IOSIZE, \"%s %s%s\", lead,\n\t    s > compl_shown_match->cp_fname ? \"<\" : \"\", s);\n    msg((char *)IObuff);\n    msg_hist_off = FALSE;\n    redraw_cmdline = FALSE;\t    // don't overwrite!\n}\n\n/*\n * Find the next set of matches for completion. Repeat the completion \"todo\"\n * times.  The number of matches found is returned in 'num_matches'.\n *\n * If \"allow_get_expansion\" is TRUE, then ins_compl_get_exp() may be called to\n * get more completions. If it is FALSE, then do nothing when there are no more\n * completions in the given direction.\n *\n * If \"advance\" is TRUE, then completion will move to the first match.\n * Otherwise, the original text will be shown.\n *\n * Returns OK on success and -1 if the number of matches are unknown.\n */\n    static int\nfind_next_completion_match(\n\tint\tallow_get_expansion,\n\tint\ttodo,\t\t// repeat completion this many times\n\tint\tadvance,\n\tint\t*num_matches)\n{\n    int\t    found_end = FALSE;\n    compl_T *found_compl = NULL;\n\n    while (--todo >= 0)\n    {\n\tif (compl_shows_dir_forward() && compl_shown_match->cp_next != NULL)\n\t{\n\t    compl_shown_match = compl_shown_match->cp_next;\n\t    found_end = (compl_first_match != NULL\n\t\t    && (is_first_match(compl_shown_match->cp_next)\n\t\t\t|| is_first_match(compl_shown_match)));\n\t}\n\telse if (compl_shows_dir_backward()\n\t\t&& compl_shown_match->cp_prev != NULL)\n\t{\n\t    found_end = is_first_match(compl_shown_match);\n\t    compl_shown_match = compl_shown_match->cp_prev;\n\t    found_end |= is_first_match(compl_shown_match);\n\t}\n\telse\n\t{\n\t    if (!allow_get_expansion)\n\t    {\n\t\tif (advance)\n\t\t{\n\t\t    if (compl_shows_dir_backward())\n\t\t\tcompl_pending -= todo + 1;\n\t\t    else\n\t\t\tcompl_pending += todo + 1;\n\t\t}\n\t\treturn -1;\n\t    }\n\n\t    if (!compl_no_select && advance)\n\t    {\n\t\tif (compl_shows_dir_backward())\n\t\t    --compl_pending;\n\t\telse\n\t\t    ++compl_pending;\n\t    }\n\n\t    // Find matches.\n\t    *num_matches = ins_compl_get_exp(&compl_startpos);\n\n\t    // handle any pending completions\n\t    while (compl_pending != 0 && compl_direction == compl_shows_dir\n\t\t    && advance)\n\t    {\n\t\tif (compl_pending > 0 && compl_shown_match->cp_next != NULL)\n\t\t{\n\t\t    compl_shown_match = compl_shown_match->cp_next;\n\t\t    --compl_pending;\n\t\t}\n\t\tif (compl_pending < 0 && compl_shown_match->cp_prev != NULL)\n\t\t{\n\t\t    compl_shown_match = compl_shown_match->cp_prev;\n\t\t    ++compl_pending;\n\t\t}\n\t\telse\n\t\t    break;\n\t    }\n\t    found_end = FALSE;\n\t}\n\tif (!match_at_original_text(compl_shown_match)\n\t\t&& compl_leader != NULL\n\t\t&& !ins_compl_equal(compl_shown_match,\n\t\t    compl_leader, (int)STRLEN(compl_leader)))\n\t    ++todo;\n\telse\n\t    // Remember a matching item.\n\t    found_compl = compl_shown_match;\n\n\t// Stop at the end of the list when we found a usable match.\n\tif (found_end)\n\t{\n\t    if (found_compl != NULL)\n\t    {\n\t\tcompl_shown_match = found_compl;\n\t\tbreak;\n\t    }\n\t    todo = 1;\t    // use first usable match after wrapping around\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Fill in the next completion in the current direction.\n * If \"allow_get_expansion\" is TRUE, then we may call ins_compl_get_exp() to\n * get more completions.  If it is FALSE, then we just do nothing when there\n * are no more completions in a given direction.  The latter case is used when\n * we are still in the middle of finding completions, to allow browsing\n * through the ones found so far.\n * Return the total number of matches, or -1 if still unknown -- webb.\n *\n * compl_curr_match is currently being used by ins_compl_get_exp(), so we use\n * compl_shown_match here.\n *\n * Note that this function may be called recursively once only.  First with\n * \"allow_get_expansion\" TRUE, which calls ins_compl_get_exp(), which in turn\n * calls this function with \"allow_get_expansion\" FALSE.\n */\n    static int\nins_compl_next(\n    int\t    allow_get_expansion,\n    int\t    count,\t\t// repeat completion this many times; should\n\t\t\t\t// be at least 1\n    int\t    insert_match,\t// Insert the newly selected match\n    int\t    in_compl_func)\t// called from complete_check()\n{\n    int\t    num_matches = -1;\n    int\t    todo = count;\n    int\t    advance;\n    int\t    started = compl_started;\n\n    // When user complete function return -1 for findstart which is next\n    // time of 'always', compl_shown_match become NULL.\n    if (compl_shown_match == NULL)\n\treturn -1;\n\n    if (compl_leader != NULL && !match_at_original_text(compl_shown_match))\n\t// Update \"compl_shown_match\" to the actually shown match\n\tins_compl_update_shown_match();\n\n    if (allow_get_expansion && insert_match\n\t    && (!(compl_get_longest || compl_restarting) || compl_used_match))\n\t// Delete old text to be replaced\n\tins_compl_delete();\n\n    // When finding the longest common text we stick at the original text,\n    // don't let CTRL-N or CTRL-P move to the first match.\n    advance = count != 1 || !allow_get_expansion || !compl_get_longest;\n\n    // When restarting the search don't insert the first match either.\n    if (compl_restarting)\n    {\n\tadvance = FALSE;\n\tcompl_restarting = FALSE;\n    }\n\n    // Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap\n    // around.\n    if (find_next_completion_match(allow_get_expansion, todo, advance,\n\t\t\t\t\t\t\t&num_matches) == -1)\n\treturn -1;\n\n    // Insert the text of the new completion, or the compl_leader.\n    if (compl_no_insert && !started)\n    {\n\tins_bytes(compl_orig_text + get_compl_len());\n\tcompl_used_match = FALSE;\n    }\n    else if (insert_match)\n    {\n\tif (!compl_get_longest || compl_used_match)\n\t    ins_compl_insert(in_compl_func);\n\telse\n\t    ins_bytes(compl_leader + get_compl_len());\n    }\n    else\n\tcompl_used_match = FALSE;\n\n    if (!allow_get_expansion)\n    {\n\t// may undisplay the popup menu first\n\tins_compl_upd_pum();\n\n\tif (pum_enough_matches())\n\t    // Will display the popup menu, don't redraw yet to avoid flicker.\n\t    pum_call_update_screen();\n\telse\n\t    // Not showing the popup menu yet, redraw to show the user what was\n\t    // inserted.\n\t    update_screen(0);\n\n\t// display the updated popup menu\n\tins_compl_show_pum();\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    // Show the cursor after the match, not after the redrawn text.\n\t    setcursor();\n\t    out_flush_cursor(FALSE, FALSE);\n\t}\n#endif\n\n\t// Delete old text to be replaced, since we're still searching and\n\t// don't want to match ourselves!\n\tins_compl_delete();\n    }\n\n    // Enter will select a match when the match wasn't inserted and the popup\n    // menu is visible.\n    if (compl_no_insert && !started)\n\tcompl_enter_selects = TRUE;\n    else\n\tcompl_enter_selects = !insert_match && compl_match_array != NULL;\n\n    // Show the file name for the match (if any)\n    if (compl_shown_match->cp_fname != NULL)\n\tins_compl_show_filename();\n\n    return num_matches;\n}\n\n/*\n * Call this while finding completions, to check whether the user has hit a key\n * that should change the currently displayed completion, or exit completion\n * mode.  Also, when compl_pending is not zero, show a completion as soon as\n * possible. -- webb\n * \"frequency\" specifies out of how many calls we actually check.\n * \"in_compl_func\" is TRUE when called from complete_check(), don't set\n * compl_curr_match.\n */\n    void\nins_compl_check_keys(int frequency, int in_compl_func)\n{\n    static int\tcount = 0;\n    int\t\tc;\n\n    // Don't check when reading keys from a script, :normal or feedkeys().\n    // That would break the test scripts.  But do check for keys when called\n    // from complete_check().\n    if (!in_compl_func && (using_script() || ex_normal_busy))\n\treturn;\n\n    // Only do this at regular intervals\n    if (++count < frequency)\n\treturn;\n    count = 0;\n\n    // Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()\n    // can't do its work correctly.\n    c = vpeekc_any();\n    if (c != NUL)\n    {\n\tif (vim_is_ctrl_x_key(c) && c != Ctrl_X && c != Ctrl_R)\n\t{\n\t    c = safe_vgetc();\t// Eat the character\n\t    compl_shows_dir = ins_compl_key2dir(c);\n\t    (void)ins_compl_next(FALSE, ins_compl_key2count(c),\n\t\t\t\t      c != K_UP && c != K_DOWN, in_compl_func);\n\t}\n\telse\n\t{\n\t    // Need to get the character to have KeyTyped set.  We'll put it\n\t    // back with vungetc() below.  But skip K_IGNORE.\n\t    c = safe_vgetc();\n\t    if (c != K_IGNORE)\n\t    {\n\t\t// Don't interrupt completion when the character wasn't typed,\n\t\t// e.g., when doing @q to replay keys.\n\t\tif (c != Ctrl_R && KeyTyped)\n\t\t    compl_interrupted = TRUE;\n\n\t\tvungetc(c);\n\t    }\n\t}\n    }\n    if (compl_pending != 0 && !got_int && !compl_no_insert)\n    {\n\tint todo = compl_pending > 0 ? compl_pending : -compl_pending;\n\n\tcompl_pending = 0;\n\t(void)ins_compl_next(FALSE, todo, TRUE, in_compl_func);\n    }\n}\n\n/*\n * Decide the direction of Insert mode complete from the key typed.\n * Returns BACKWARD or FORWARD.\n */\n    static int\nins_compl_key2dir(int c)\n{\n    if (c == Ctrl_P || c == Ctrl_L\n\t    || c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP || c == K_UP)\n\treturn BACKWARD;\n    return FORWARD;\n}\n\n/*\n * Return TRUE for keys that are used for completion only when the popup menu\n * is visible.\n */\n    static int\nins_compl_pum_key(int c)\n{\n    return pum_visible() && (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP\n\t\t     || c == K_PAGEDOWN || c == K_KPAGEDOWN || c == K_S_DOWN\n\t\t     || c == K_UP || c == K_DOWN);\n}\n\n/*\n * Decide the number of completions to move forward.\n * Returns 1 for most keys, height of the popup menu for page-up/down keys.\n */\n    static int\nins_compl_key2count(int c)\n{\n    int\t\th;\n\n    if (ins_compl_pum_key(c) && c != K_UP && c != K_DOWN)\n    {\n\th = pum_get_height();\n\tif (h > 3)\n\t    h -= 2; // keep some context\n\treturn h;\n    }\n    return 1;\n}\n\n/*\n * Return TRUE if completion with \"c\" should insert the match, FALSE if only\n * to change the currently selected completion.\n */\n    static int\nins_compl_use_match(int c)\n{\n    switch (c)\n    {\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_S_UP:\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Get the pattern, column and length for normal completion (CTRL-N CTRL-P\n * completion)\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n * Uses the global variables: compl_cont_status and ctrl_x_mode\n */\n    static int\nget_normal_compl_info(char_u *line, int startcol, colnr_T curs_col)\n{\n    if ((compl_cont_status & CONT_SOL) || ctrl_x_mode_path_defines())\n    {\n\tif (!compl_status_adding())\n\t{\n\t    while (--startcol >= 0 && vim_isIDc(line[startcol]))\n\t\t;\n\t    compl_col += ++startcol;\n\t    compl_length = curs_col - startcol;\n\t}\n\tif (p_ic)\n\t    compl_pattern = str_foldcase(line + compl_col,\n\t\t    compl_length, NULL, 0);\n\telse\n\t    compl_pattern = vim_strnsave(line + compl_col, compl_length);\n\tif (compl_pattern == NULL)\n\t    return FAIL;\n    }\n    else if (compl_status_adding())\n    {\n\tchar_u\t    *prefix = (char_u *)\"\\\\<\";\n\n\t// we need up to 2 extra chars for the prefix\n\tcompl_pattern = alloc(quote_meta(NULL, line + compl_col,\n\t\t    compl_length) + 2);\n\tif (compl_pattern == NULL)\n\t    return FAIL;\n\tif (!vim_iswordp(line + compl_col)\n\t\t|| (compl_col > 0\n\t\t    && (vim_iswordp(mb_prevptr(line, line + compl_col)))))\n\t    prefix = (char_u *)\"\";\n\tSTRCPY((char *)compl_pattern, prefix);\n\t(void)quote_meta(compl_pattern + STRLEN(prefix),\n\t\tline + compl_col, compl_length);\n    }\n    else if (--startcol < 0\n\t    || !vim_iswordp(mb_prevptr(line, line + startcol + 1)))\n    {\n\t// Match any word of at least two chars\n\tcompl_pattern = vim_strsave((char_u *)\"\\\\<\\\\k\\\\k\");\n\tif (compl_pattern == NULL)\n\t    return FAIL;\n\tcompl_col += curs_col;\n\tcompl_length = 0;\n    }\n    else\n    {\n\t// Search the point of change class of multibyte character\n\t// or not a word single byte character backward.\n\tif (has_mbyte)\n\t{\n\t    int base_class;\n\t    int head_off;\n\n\t    startcol -= (*mb_head_off)(line, line + startcol);\n\t    base_class = mb_get_class(line + startcol);\n\t    while (--startcol >= 0)\n\t    {\n\t\thead_off = (*mb_head_off)(line, line + startcol);\n\t\tif (base_class != mb_get_class(line + startcol\n\t\t\t    - head_off))\n\t\t    break;\n\t\tstartcol -= head_off;\n\t    }\n\t}\n\telse\n\t    while (--startcol >= 0 && vim_iswordc(line[startcol]))\n\t\t;\n\tcompl_col += ++startcol;\n\tcompl_length = (int)curs_col - startcol;\n\tif (compl_length == 1)\n\t{\n\t    // Only match word with at least two chars -- webb\n\t    // there's no need to call quote_meta,\n\t    // alloc(7) is enough  -- Acevedo\n\t    compl_pattern = alloc(7);\n\t    if (compl_pattern == NULL)\n\t\treturn FAIL;\n\t    STRCPY((char *)compl_pattern, \"\\\\<\");\n\t    (void)quote_meta(compl_pattern + 2, line + compl_col, 1);\n\t    STRCAT((char *)compl_pattern, \"\\\\k\");\n\t}\n\telse\n\t{\n\t    compl_pattern = alloc(quote_meta(NULL, line + compl_col,\n\t\t\tcompl_length) + 2);\n\t    if (compl_pattern == NULL)\n\t\treturn FAIL;\n\t    STRCPY((char *)compl_pattern, \"\\\\<\");\n\t    (void)quote_meta(compl_pattern + 2, line + compl_col,\n\t\t    compl_length);\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for whole line completion or for the\n * complete() function.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n */\n    static int\nget_wholeline_compl_info(char_u *line, colnr_T curs_col)\n{\n    compl_col = (colnr_T)getwhitecols(line);\n    compl_length = (int)curs_col - (int)compl_col;\n    if (compl_length < 0)\t// cursor in indent: empty pattern\n\tcompl_length = 0;\n    if (p_ic)\n\tcompl_pattern = str_foldcase(line + compl_col, compl_length,\n\t\tNULL, 0);\n    else\n\tcompl_pattern = vim_strnsave(line + compl_col, compl_length);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for filename completion.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n */\n    static int\nget_filename_compl_info(char_u *line, int startcol, colnr_T curs_col)\n{\n    // Go back to just before the first filename character.\n    if (startcol > 0)\n    {\n\tchar_u\t*p = line + startcol;\n\n\tMB_PTR_BACK(line, p);\n\twhile (p > line && vim_isfilec(PTR2CHAR(p)))\n\t    MB_PTR_BACK(line, p);\n\tif (p == line && vim_isfilec(PTR2CHAR(p)))\n\t    startcol = 0;\n\telse\n\t    startcol = (int)(p - line) + 1;\n    }\n\n    compl_col += startcol;\n    compl_length = (int)curs_col - startcol;\n    compl_pattern = addstar(line + compl_col, compl_length, EXPAND_FILES);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for command-line completion.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n */\n    static int\nget_cmdline_compl_info(char_u *line, colnr_T curs_col)\n{\n    compl_pattern = vim_strnsave(line, curs_col);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n    set_cmd_context(&compl_xp, compl_pattern,\n\t    (int)STRLEN(compl_pattern), curs_col, FALSE);\n    if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL\n\t    || compl_xp.xp_context == EXPAND_NOTHING)\n\t// No completion possible, use an empty pattern to get a\n\t// \"pattern not found\" message.\n\tcompl_col = curs_col;\n    else\n\tcompl_col = (int)(compl_xp.xp_pattern - compl_pattern);\n    compl_length = curs_col - compl_col;\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for user defined completion ('omnifunc',\n * 'completefunc' and 'thesaurusfunc')\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n * Uses the global variable: spell_bad_len\n */\n    static int\nget_userdefined_compl_info(colnr_T curs_col UNUSED)\n{\n    int\t\tret = FAIL;\n\n#ifdef FEAT_COMPL_FUNC\n    // Call user defined function 'completefunc' with \"a:findstart\"\n    // set to 1 to obtain the length of text to use for completion.\n    char_u\t*line;\n    typval_T\targs[3];\n    int\t\tcol;\n    char_u\t*funcname;\n    pos_T\tpos;\n    int\t\tsave_State = State;\n    callback_T\t*cb;\n\n    // Call 'completefunc' or 'omnifunc' or 'thesaurusfunc' and get pattern\n    // length as a string\n    funcname = get_complete_funcname(ctrl_x_mode);\n    if (*funcname == NUL)\n    {\n\tsemsg(_(e_option_str_is_not_set), ctrl_x_mode_function()\n\t\t? \"completefunc\" : \"omnifunc\");\n\treturn FAIL;\n    }\n\n    args[0].v_type = VAR_NUMBER;\n    args[0].vval.v_number = 1;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = (char_u *)\"\";\n    args[2].v_type = VAR_UNKNOWN;\n    pos = curwin->w_cursor;\n    ++textlock;\n    cb = get_insert_callback(ctrl_x_mode);\n    col = call_callback_retnr(cb, 2, args);\n    --textlock;\n\n    State = save_State;\n    curwin->w_cursor = pos;\t// restore the cursor position\n    validate_cursor();\n    if (!EQUAL_POS(curwin->w_cursor, pos))\n    {\n\temsg(_(e_complete_function_deleted_text));\n\treturn FAIL;\n    }\n\n    // Return value -2 means the user complete function wants to cancel the\n    // complete without an error, do the same if the function did not execute\n    // successfully.\n    if (col == -2 || aborting())\n\treturn FAIL;\n    // Return value -3 does the same as -2 and leaves CTRL-X mode.\n    if (col == -3)\n    {\n\tctrl_x_mode = CTRL_X_NORMAL;\n\tedit_submode = NULL;\n\tif (!shortmess(SHM_COMPLETIONMENU))\n\t    msg_clr_cmdline();\n\treturn FAIL;\n    }\n\n    // Reset extended parameters of completion, when starting new\n    // completion.\n    compl_opt_refresh_always = FALSE;\n    compl_opt_suppress_empty = FALSE;\n\n    if (col < 0)\n\tcol = curs_col;\n    compl_col = col;\n    if (compl_col > curs_col)\n\tcompl_col = curs_col;\n\n    // Setup variables for completion.  Need to obtain \"line\" again,\n    // it may have become invalid.\n    line = ml_get(curwin->w_cursor.lnum);\n    compl_length = curs_col - compl_col;\n    compl_pattern = vim_strnsave(line + compl_col, compl_length);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    ret = OK;\n#endif\n\n    return ret;\n}\n\n/*\n * Get the pattern, column and length for spell completion.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n * Uses the global variable: spell_bad_len\n */\n    static int\nget_spell_compl_info(int startcol UNUSED, colnr_T curs_col UNUSED)\n{\n    int\t\tret = FAIL;\n#ifdef FEAT_SPELL\n    char_u\t*line;\n\n    if (spell_bad_len > 0)\n\tcompl_col = curs_col - spell_bad_len;\n    else\n\tcompl_col = spell_word_start(startcol);\n    if (compl_col >= (colnr_T)startcol)\n    {\n\tcompl_length = 0;\n\tcompl_col = curs_col;\n    }\n    else\n    {\n\tspell_expand_check_cap(compl_col);\n\tcompl_length = (int)curs_col - compl_col;\n    }\n    // Need to obtain \"line\" again, it may have become invalid.\n    line = ml_get(curwin->w_cursor.lnum);\n    compl_pattern = vim_strnsave(line + compl_col, compl_length);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    ret = OK;\n#endif\n\n    return ret;\n}\n\n/*\n * Get the completion pattern, column and length.\n * \"startcol\" - start column number of the completion pattern/text\n * \"cur_col\" - current cursor column\n * On return, \"line_invalid\" is set to TRUE, if the current line may have\n * become invalid and needs to be fetched again.\n * Returns OK on success.\n */\n    static int\ncompl_get_info(char_u *line, int startcol, colnr_T curs_col, int *line_invalid)\n{\n    if (ctrl_x_mode_normal()\n\t    || (ctrl_x_mode & CTRL_X_WANT_IDENT\n\t\t&& !thesaurus_func_complete(ctrl_x_mode)))\n    {\n\treturn get_normal_compl_info(line, startcol, curs_col);\n    }\n    else if (ctrl_x_mode_line_or_eval())\n    {\n\treturn get_wholeline_compl_info(line, curs_col);\n    }\n    else if (ctrl_x_mode_files())\n    {\n\treturn get_filename_compl_info(line, startcol, curs_col);\n    }\n    else if (ctrl_x_mode == CTRL_X_CMDLINE)\n    {\n\treturn get_cmdline_compl_info(line, curs_col);\n    }\n    else if (ctrl_x_mode_function() || ctrl_x_mode_omni()\n\t    || thesaurus_func_complete(ctrl_x_mode))\n    {\n\tif (get_userdefined_compl_info(curs_col) == FAIL)\n\t    return FAIL;\n\t*line_invalid = TRUE;\t// \"line\" may have become invalid\n    }\n    else if (ctrl_x_mode_spell())\n    {\n\tif (get_spell_compl_info(startcol, curs_col) == FAIL)\n\t    return FAIL;\n\t*line_invalid = TRUE;\t// \"line\" may have become invalid\n    }\n    else\n    {\n\tinternal_error(\"ins_complete()\");\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Continue an interrupted completion mode search in \"line\".\n *\n * If this same ctrl_x_mode has been interrupted use the text from\n * \"compl_startpos\" to the cursor as a pattern to add a new word instead of\n * expand the one before the cursor, in word-wise if \"compl_startpos\" is not in\n * the same line as the cursor then fix it (the line has been split because it\n * was longer than 'tw').  if SOL is set then skip the previous pattern, a word\n * at the beginning of the line has been inserted, we'll look for that.\n */\n    static void\nins_compl_continue_search(char_u *line)\n{\n    // it is a continued search\n    compl_cont_status &= ~CONT_INTRPT;\t// remove INTRPT\n    if (ctrl_x_mode_normal() || ctrl_x_mode_path_patterns()\n\t\t\t\t\t\t|| ctrl_x_mode_path_defines())\n    {\n\tif (compl_startpos.lnum != curwin->w_cursor.lnum)\n\t{\n\t    // line (probably) wrapped, set compl_startpos to the\n\t    // first non_blank in the line, if it is not a wordchar\n\t    // include it to get a better pattern, but then we don't\n\t    // want the \"\\\\<\" prefix, check it below\n\t    compl_col = (colnr_T)getwhitecols(line);\n\t    compl_startpos.col = compl_col;\n\t    compl_startpos.lnum = curwin->w_cursor.lnum;\n\t    compl_cont_status &= ~CONT_SOL;   // clear SOL if present\n\t}\n\telse\n\t{\n\t    // S_IPOS was set when we inserted a word that was at the\n\t    // beginning of the line, which means that we'll go to SOL\n\t    // mode but first we need to redefine compl_startpos\n\t    if (compl_cont_status & CONT_S_IPOS)\n\t    {\n\t\tcompl_cont_status |= CONT_SOL;\n\t\tcompl_startpos.col = (colnr_T)(skipwhite(\n\t\t\t    line + compl_length\n\t\t\t    + compl_startpos.col) - line);\n\t    }\n\t    compl_col = compl_startpos.col;\n\t}\n\tcompl_length = curwin->w_cursor.col - (int)compl_col;\n\t// IObuff is used to add a \"word from the next line\" would we\n\t// have enough space?  just being paranoid\n#define\tMIN_SPACE 75\n\tif (compl_length > (IOSIZE - MIN_SPACE))\n\t{\n\t    compl_cont_status &= ~CONT_SOL;\n\t    compl_length = (IOSIZE - MIN_SPACE);\n\t    compl_col = curwin->w_cursor.col - compl_length;\n\t}\n\tcompl_cont_status |= CONT_ADDING | CONT_N_ADDS;\n\tif (compl_length < 1)\n\t    compl_cont_status &= CONT_LOCAL;\n    }\n    else if (ctrl_x_mode_line_or_eval())\n\tcompl_cont_status = CONT_ADDING | CONT_N_ADDS;\n    else\n\tcompl_cont_status = 0;\n}\n\n/*\n * start insert mode completion\n */\n    static int\nins_compl_start(void)\n{\n    char_u\t*line;\n    int\t\tstartcol = 0;\t    // column where searched text starts\n    colnr_T\tcurs_col;\t    // cursor column\n    int\t\tline_invalid = FALSE;\n    int\t\tsave_did_ai = did_ai;\n    int\t\tflags = CP_ORIGINAL_TEXT;\n\n    // First time we hit ^N or ^P (in a row, I mean)\n\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (stop_arrow() == FAIL)\n\treturn FAIL;\n\n    line = ml_get(curwin->w_cursor.lnum);\n    curs_col = curwin->w_cursor.col;\n    compl_pending = 0;\n\n    if ((compl_cont_status & CONT_INTRPT) == CONT_INTRPT\n\t    && compl_cont_mode == ctrl_x_mode)\n\t// this same ctrl-x_mode was interrupted previously. Continue the\n\t// completion.\n\tins_compl_continue_search(line);\n    else\n\tcompl_cont_status &= CONT_LOCAL;\n\n    if (!compl_status_adding())\t// normal expansion\n    {\n\tcompl_cont_mode = ctrl_x_mode;\n\tif (ctrl_x_mode_not_default())\n\t    // Remove LOCAL if ctrl_x_mode != CTRL_X_NORMAL\n\t    compl_cont_status = 0;\n\tcompl_cont_status |= CONT_N_ADDS;\n\tcompl_startpos = curwin->w_cursor;\n\tstartcol = (int)curs_col;\n\tcompl_col = 0;\n    }\n\n    // Work out completion pattern and original text -- webb\n    if (compl_get_info(line, startcol, curs_col, &line_invalid) == FAIL)\n    {\n\tif (ctrl_x_mode_function() || ctrl_x_mode_omni()\n\t\t\t\t|| thesaurus_func_complete(ctrl_x_mode))\n\t    // restore did_ai, so that adding comment leader works\n\t    did_ai = save_did_ai;\n\treturn FAIL;\n    }\n    // If \"line\" was changed while getting completion info get it again.\n    if (line_invalid)\n\tline = ml_get(curwin->w_cursor.lnum);\n\n    if (compl_status_adding())\n    {\n\tedit_submode_pre = (char_u *)_(\" Adding\");\n\tif (ctrl_x_mode_line_or_eval())\n\t{\n\t    // Insert a new line, keep indentation but ignore 'comments'.\n\t    char_u *old = curbuf->b_p_com;\n\n\t    curbuf->b_p_com = (char_u *)\"\";\n\t    compl_startpos.lnum = curwin->w_cursor.lnum;\n\t    compl_startpos.col = compl_col;\n\t    ins_eol('\\r');\n\t    curbuf->b_p_com = old;\n\t    compl_length = 0;\n\t    compl_col = curwin->w_cursor.col;\n\t}\n    }\n    else\n    {\n\tedit_submode_pre = NULL;\n\tcompl_startpos.col = compl_col;\n    }\n\n    if (compl_cont_status & CONT_LOCAL)\n\tedit_submode = (char_u *)_(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);\n    else\n\tedit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));\n\n    // If any of the original typed text has been changed we need to fix\n    // the redo buffer.\n    ins_compl_fixRedoBufForLeader(NULL);\n\n    // Always add completion for the original text.\n    vim_free(compl_orig_text);\n    compl_orig_text = vim_strnsave(line + compl_col, compl_length);\n    if (p_ic)\n\tflags |= CP_ICASE;\n    if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,\n\t\t-1, NULL, NULL, NULL, 0, flags, FALSE) != OK)\n    {\n\tVIM_CLEAR(compl_pattern);\n\tVIM_CLEAR(compl_orig_text);\n\treturn FAIL;\n    }\n\n    // showmode might reset the internal line pointers, so it must\n    // be called before line = ml_get(), or when this address is no\n    // longer needed.  -- Acevedo.\n    edit_submode_extra = (char_u *)_(\"-- Searching...\");\n    edit_submode_highl = HLF_COUNT;\n    showmode();\n    edit_submode_extra = NULL;\n    out_flush();\n\n    return OK;\n}\n\n/*\n * display the completion status message\n */\n    static void\nins_compl_show_statusmsg(void)\n{\n    // we found no match if the list has only the \"compl_orig_text\"-entry\n    if (is_first_match(compl_first_match->cp_next))\n    {\n\tedit_submode_extra = compl_status_adding() && compl_length > 1\n\t\t\t\t? (char_u *)_(e_hitend)\n\t\t\t\t: (char_u *)_(e_pattern_not_found);\n\tedit_submode_highl = HLF_E;\n    }\n\n    if (edit_submode_extra == NULL)\n    {\n\tif (match_at_original_text(compl_curr_match))\n\t{\n\t    edit_submode_extra = (char_u *)_(\"Back at original\");\n\t    edit_submode_highl = HLF_W;\n\t}\n\telse if (compl_cont_status & CONT_S_IPOS)\n\t{\n\t    edit_submode_extra = (char_u *)_(\"Word from other line\");\n\t    edit_submode_highl = HLF_COUNT;\n\t}\n\telse if (compl_curr_match->cp_next == compl_curr_match->cp_prev)\n\t{\n\t    edit_submode_extra = (char_u *)_(\"The only match\");\n\t    edit_submode_highl = HLF_COUNT;\n\t    compl_curr_match->cp_number = 1;\n\t}\n\telse\n\t{\n#if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL)\n\t    // Update completion sequence number when needed.\n\t    if (compl_curr_match->cp_number == -1)\n\t\tins_compl_update_sequence_numbers();\n#endif\n\t    // The match should always have a sequence number now, this is\n\t    // just a safety check.\n\t    if (compl_curr_match->cp_number != -1)\n\t    {\n\t\t// Space for 10 text chars. + 2x10-digit no.s = 31.\n\t\t// Translations may need more than twice that.\n\t\tstatic char_u match_ref[81];\n\n\t\tif (compl_matches > 0)\n\t\t    vim_snprintf((char *)match_ref, sizeof(match_ref),\n\t\t\t    _(\"match %d of %d\"),\n\t\t\t    compl_curr_match->cp_number, compl_matches);\n\t\telse\n\t\t    vim_snprintf((char *)match_ref, sizeof(match_ref),\n\t\t\t    _(\"match %d\"),\n\t\t\t    compl_curr_match->cp_number);\n\t\tedit_submode_extra = match_ref;\n\t\tedit_submode_highl = HLF_R;\n\t\tif (dollar_vcol >= 0)\n\t\t    curs_columns(FALSE);\n\t    }\n\t}\n    }\n\n    // Show a message about what (completion) mode we're in.\n    if (!compl_opt_suppress_empty)\n    {\n\tshowmode();\n\tif (!shortmess(SHM_COMPLETIONMENU))\n\t{\n\t    if (edit_submode_extra != NULL)\n\t    {\n\t\tif (!p_smd)\n\t\t{\n\t\t    msg_hist_off = TRUE;\n\t\t    msg_attr((char *)edit_submode_extra,\n\t\t\t    edit_submode_highl < HLF_COUNT\n\t\t\t    ? HL_ATTR(edit_submode_highl) : 0);\n\t\t    msg_hist_off = FALSE;\n\t\t}\n\t    }\n\t    else\n\t\tmsg_clr_cmdline();\t// necessary for \"noshowmode\"\n\t}\n    }\n}\n\n/*\n * Do Insert mode completion.\n * Called when character \"c\" was typed, which has a meaning for completion.\n * Returns OK if completion was done, FAIL if something failed (out of mem).\n */\n    int\nins_complete(int c, int enable_pum)\n{\n    int\t\tn;\n    int\t\tsave_w_wrow;\n    int\t\tsave_w_leftcol;\n    int\t\tinsert_match;\n\n    compl_direction = ins_compl_key2dir(c);\n    insert_match = ins_compl_use_match(c);\n\n    if (!compl_started)\n    {\n\tif (ins_compl_start() == FAIL)\n\t    return FAIL;\n    }\n    else if (insert_match && stop_arrow() == FAIL)\n\treturn FAIL;\n\n    compl_shown_match = compl_curr_match;\n    compl_shows_dir = compl_direction;\n\n    // Find next match (and following matches).\n    save_w_wrow = curwin->w_wrow;\n    save_w_leftcol = curwin->w_leftcol;\n    n = ins_compl_next(TRUE, ins_compl_key2count(c), insert_match, FALSE);\n\n    // may undisplay the popup menu\n    ins_compl_upd_pum();\n\n    if (n > 1)\t\t// all matches have been found\n\tcompl_matches = n;\n    compl_curr_match = compl_shown_match;\n    compl_direction = compl_shows_dir;\n\n    // Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert\n    // mode.\n    if (got_int && !global_busy)\n    {\n\t(void)vgetc();\n\tgot_int = FALSE;\n    }\n\n    // we found no match if the list has only the \"compl_orig_text\"-entry\n    if (is_first_match(compl_first_match->cp_next))\n    {\n\t// remove N_ADDS flag, so next ^X<> won't try to go to ADDING mode,\n\t// because we couldn't expand anything at first place, but if we used\n\t// ^P, ^N, ^X^I or ^X^D we might want to add-expand a single-char-word\n\t// (such as M in M'exico) if not tried already.  -- Acevedo\n\tif (compl_length > 1\n\t\t|| compl_status_adding()\n\t\t|| (ctrl_x_mode_not_default()\n\t\t    && !ctrl_x_mode_path_patterns()\n\t\t    && !ctrl_x_mode_path_defines()))\n\t    compl_cont_status &= ~CONT_N_ADDS;\n    }\n\n    if (compl_curr_match->cp_flags & CP_CONT_S_IPOS)\n\tcompl_cont_status |= CONT_S_IPOS;\n    else\n\tcompl_cont_status &= ~CONT_S_IPOS;\n\n    ins_compl_show_statusmsg();\n\n    // Show the popup menu, unless we got interrupted.\n    if (enable_pum && !compl_interrupted)\n\tshow_pum(save_w_wrow, save_w_leftcol);\n\n    compl_was_interrupted = compl_interrupted;\n    compl_interrupted = FALSE;\n\n    return OK;\n}\n\n/*\n * Remove (if needed) and show the popup menu\n */\n    static void\nshow_pum(int prev_w_wrow, int prev_w_leftcol)\n{\n    // RedrawingDisabled may be set when invoked through complete().\n    int n = RedrawingDisabled;\n\n    RedrawingDisabled = 0;\n\n    // If the cursor moved or the display scrolled we need to remove the pum\n    // first.\n    setcursor();\n    if (prev_w_wrow != curwin->w_wrow || prev_w_leftcol != curwin->w_leftcol)\n\tins_compl_del_pum();\n\n    ins_compl_show_pum();\n    setcursor();\n    RedrawingDisabled = n;\n}\n\n/*\n * Looks in the first \"len\" chars. of \"src\" for search-metachars.\n * If dest is not NULL the chars. are copied there quoting (with\n * a backslash) the metachars, and dest would be NUL terminated.\n * Returns the length (needed) of dest\n */\n    static unsigned\nquote_meta(char_u *dest, char_u *src, int len)\n{\n    unsigned\tm = (unsigned)len + 1;  // one extra for the NUL\n\n    for ( ; --len >= 0; src++)\n    {\n\tswitch (*src)\n\t{\n\t    case '.':\n\t    case '*':\n\t    case '[':\n\t\tif (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus())\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case '~':\n\t\tif (!magic_isset())\t// quote these only if magic is set\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case '\\\\':\n\t\tif (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus())\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case '^':\t\t// currently it's not needed.\n\t    case '$':\n\t\tm++;\n\t\tif (dest != NULL)\n\t\t    *dest++ = '\\\\';\n\t\tbreak;\n\t}\n\tif (dest != NULL)\n\t    *dest++ = *src;\n\t// Copy remaining bytes of a multibyte character.\n\tif (has_mbyte)\n\t{\n\t    int i, mb_len;\n\n\t    mb_len = (*mb_ptr2len)(src) - 1;\n\t    if (mb_len > 0 && len >= mb_len)\n\t\tfor (i = 0; i < mb_len; ++i)\n\t\t{\n\t\t    --len;\n\t\t    ++src;\n\t\t    if (dest != NULL)\n\t\t\t*dest++ = *src;\n\t\t}\n\t}\n    }\n    if (dest != NULL)\n\t*dest = NUL;\n\n    return m;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_insexpand_stuff(void)\n{\n    VIM_CLEAR(compl_orig_text);\n# ifdef FEAT_EVAL\n    free_callback(&cfu_cb);\n    free_callback(&ofu_cb);\n    free_callback(&tsrfu_cb);\n# endif\n}\n#endif\n\n#ifdef FEAT_SPELL\n/*\n * Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly\n * spelled word, if there is one.\n */\n    static void\nspell_back_to_badword(void)\n{\n    pos_T\ttpos = curwin->w_cursor;\n\n    spell_bad_len = spell_move_to(curwin, BACKWARD, TRUE, TRUE, NULL);\n    if (curwin->w_cursor.col != tpos.col)\n\tstart_arrow(&tpos);\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n#ifdef FEAT_DIFF\n\t    if (lnum == wp->w_topline)\n\t\tn = plines_win_nofill(wp, lnum, TRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\tn = plines_win(wp, lnum, TRUE);\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\t// win_line() will redraw the number column and cursorline only.\n\tredraw_win_later(wp, UPD_VALID);\n    }\n}\n\n#ifdef FEAT_SYN_HL\n/*\n * Redraw when w_virtcol changes and 'cursorcolumn' is set or 'cursorlineopt'\n * contains \"screenline\".\n */\n    static void\nredraw_for_cursorcolumn(win_T *wp)\n{\n    if ((wp->w_valid & VALID_VIRTCOL) == 0 && !pum_visible())\n    {\n\t// When 'cursorcolumn' is set need to redraw with UPD_SOME_VALID.\n\tif (wp->w_p_cuc)\n\t    redraw_win_later(wp, UPD_SOME_VALID);\n\t// When 'cursorlineopt' contains \"screenline\" need to redraw with\n\t// UPD_VALID.\n\telse if (wp->w_p_cul && (wp->w_p_culopt_flags & CULOPT_SCRLINE))\n\t    redraw_win_later(wp, UPD_VALID);\n    }\n}\n#endif\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(UPD_NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t   >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(UPD_NOT_VALID);\n\t}\n\telse\n\t    redraw_later(UPD_VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long\tso = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Update w_curswant.\n */\n    void\nupdate_curswant_force(void)\n{\n    validate_virtcol();\n    curwin->w_curswant = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t- curwin->w_virtcol_first_char\n#endif\n\t;\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Update w_curswant if w_set_curswant is set.\n */\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n\tupdate_curswant_force();\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, UPD_NOT_VALID);\n}\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Display of line has changed for \"buf\", invalidate cursor position and\n * w_botline.\n */\n    void\nchanged_line_display_buf(buf_T *buf)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf)\n\t    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t|VALID_CROW|VALID_CHEIGHT\n\t\t\t\t|VALID_TOPLINE|VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n#ifdef FEAT_DIFF\n\t\t&& (lnum != wp->w_topline || !wp->w_p_diff)\n#endif\n\t\t)\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    wp->w_cline_row += plines_win_nofill(wp, lnum++, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    wp->w_cline_row += plines_win(wp, lnum++, TRUE);\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_VIRTCOL))\n    {\n#ifdef FEAT_PROP_POPUP\n\twp->w_virtcol_first_char = 0;\n#endif\n\tgetvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n#ifdef FEAT_SYN_HL\n\tredraw_for_cursorcolumn(wp);\n#endif\n\twp->w_valid |= VALID_VIRTCOL;\n    }\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CHEIGHT))\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    curwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t  + curwin->w_topfill;\n\telse\n#endif\n\t    curwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\tcurwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n\tcurwin->w_valid |= VALID_CHEIGHT;\n    }\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n    if (!(curwin->w_valid & VALID_WCOL))\n    {\n\tcol = curwin->w_virtcol;\n\toff = curwin_col_off();\n\tcol += off;\n\twidth = curwin->w_width - off + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_p_wrap\n\t\t&& col >= (colnr_T)curwin->w_width\n\t\t&& width > 0)\n\t    // use same formula as what is used in curs_columns()\n\t    col -= ((col - curwin->w_width) / width + 1) * width;\n\tif (col > (int)curwin->w_leftcol)\n\t    col -= curwin->w_leftcol;\n\telse\n\t    col = 0;\n\tcurwin->w_wcol = col;\n\n\tcurwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n\tcurwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n    }\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n#ifdef FEAT_CMDWIN\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#endif\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's 8 if 'number' or 'relativenumber' is on and 'n' is in\n * 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth = 0;\n    int\t\ttextwidth;\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long\tso = get_scrolloff_value();\n    long\tsiso = get_sidescrolloff_value();\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    if (!skip_update_topline)\n\tupdate_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n#ifdef FEAT_PROP_POPUP\n    // will be set by getvvcol() but not reset\n    curwin->w_virtcol_first_char = 0;\n#endif\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    textwidth = curwin->w_width - extra;\n    if (textwidth <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth = textwidth + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n#ifdef FEAT_LINEBREAK\n\t    char_u *sbr;\n#endif\n\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width + 1;\n\t    curwin->w_wcol -= n * width;\n\t    curwin->w_wrow += n;\n\n#ifdef FEAT_LINEBREAK\n\t    // When cursor wraps to first char of next line in Insert\n\t    // mode, the 'showbreak' string isn't shown, backup to first\n\t    // column\n\t    sbr = get_showbreak_value(curwin);\n\t    if (*sbr && *ml_get_cursor() == NUL\n\t\t\t\t    && curwin->w_wcol == vim_strsize(sbr))\n\t\tcurwin->w_wcol = 0;\n#endif\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n#ifdef FEAT_PROP_POPUP\n\tif (curwin->w_virtcol_first_char > 0)\n\t{\n\t    int cols = (curwin->w_width - extra);\n\t    int rows = cols > 0 ? curwin->w_virtcol_first_char / cols : 1;\n\n\t    // each \"above\" text prop shifts the text one row down\n\t    curwin->w_wrow += rows;\n\t    curwin->w_wcol -= rows * cols;\n\t    endcol -= rows * cols;\n\t    curwin->w_cline_height = rows + 1;\n\t}\n#endif\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= textwidth / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - textwidth / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width - so)\n\t    extra += 2;\n\n\tif (extra == 3 || p_lines <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    curwin->w_skipcol = n * width;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less than 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width - curwin->w_virtcol\n\t\t\t\t     + width - 1) / width;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width;\n\t\tcurwin->w_skipcol -= extra * width;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less than 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\tcurwin->w_wrow -= curwin->w_skipcol / width;\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(UPD_NOT_VALID);\n\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(curwin);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol is valid, avoid check_cursor_moved() thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    int\t\trowoff = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T\t    off;\n\tcolnr_T\t    col;\n\tint\t    width;\n\tlinenr_T    lnum = pos->lnum;\n#ifdef FEAT_FOLDING\n\tint\t    is_folded;\n\n\tis_folded = hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n\trow = plines_m_win(wp, wp->w_topline, lnum - 1) + 1;\n#ifdef FEAT_FOLDING\n\tif (is_folded)\n\t{\n\t    row += W_WINROW(wp);\n\t    coloff = wp->w_wincol + 1;\n\t}\n\telse\n#endif\n\t{\n\t    getvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t    // similar to what is done in validate_cursor_col()\n\t    col = scol;\n\t    off = win_col_off(wp);\n\t    col += off;\n\t    width = wp->w_width - off + win_col_off2(wp);\n\n\t    // long line wrapping, adjust row\n\t    if (wp->w_p_wrap\n\t\t    && col >= (colnr_T)wp->w_width\n\t\t    && width > 0)\n\t    {\n\t\t// use same formula as what is used in curs_columns()\n\t\trowoff = ((col - wp->w_width) / width + 1);\n\t\tcol -= rowoff * width;\n\t    }\n\t    col -= wp->w_leftcol;\n\t    if (col >= wp->w_width)\n\t\tcol = -1;\n\t    if (col >= 0 && row + rowoff <= wp->w_height)\n\t    {\n\t\tcoloff = col - scol + wp->w_wincol + 1;\n\t\trow += W_WINROW(wp);\n\t    }\n\t    else\n\t\t// character is left, right or below of the window\n\t\trow = rowoff = scol = ccol = ecol = 0;\n\t}\n    }\n    *rowp = row + rowoff;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n\n/*\n * \"virtcol2col({winid}, {lnum}, {col})\" function\n */\n    void\nf_virtcol2col(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    win_T\t*wp;\n    linenr_T\tlnum;\n    int\t\tscreencol;\n    int\t\terror = FALSE;\n\n    rettv->vval.v_number = -1;\n\n    if (check_for_number_arg(argvars, 0) == FAIL\n\t    || check_for_number_arg(argvars, 1) == FAIL\n\t    || check_for_number_arg(argvars, 2) == FAIL)\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    lnum = tv_get_number_chk(&argvars[1], &error);\n    if (error || lnum < 0 || lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    screencol = tv_get_number_chk(&argvars[2], &error);\n    if (error || screencol < 0)\n\treturn;\n\n    rettv->vval.v_number = vcol2col(wp, lnum, screencol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    while (line_count-- > 0)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    if (curwin->w_topline == 1)\n\t\tbreak;\n\t    --curwin->w_topline;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t    // A sequence of folded lines only counts for one logical line\n\t    if (hasFolding(curwin->w_topline, &first, NULL))\n\t    {\n\t\t++done;\n\t\tif (!byfold)\n\t\t    line_count -= curwin->w_topline - first - 1;\n\t\tcurwin->w_botline -= curwin->w_topline - first;\n\t\tcurwin->w_topline = first;\n\t    }\n\t    else\n#endif\n\t\tdone += PLINES_NOFILL(curwin->w_topline);\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n#if defined(FEAT_FOLDING) || defined(FEAT_DIFF)\n    linenr_T\tlnum;\n\n    if (\n# ifdef FEAT_FOLDING\n\t    (byfold && hasAnyFolding(curwin))\n#  ifdef FEAT_DIFF\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_DIFF\n\t    curwin->w_p_diff\n# endif\n\t    )\n    {\n\t// count each sequence of folded lines as one logical line\n\tlnum = curwin->w_topline;\n\twhile (line_count--)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t\t++lnum;\n# ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t    }\n\t}\n\t// approximate w_botline\n\tcurwin->w_botline += lnum - curwin->w_topline;\n\tcurwin->w_topline = lnum;\n    }\n    else\n#endif\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill > 0)\n    {\n\tn = plines_win_nofill(wp, wp->w_topline, TRUE);\n\tif (wp->w_topfill + n > wp->w_height)\n\t{\n\t    if (down && wp->w_topline > 1)\n\t    {\n\t\t--wp->w_topline;\n\t\twp->w_topfill = 0;\n\t    }\n\t    else\n\t    {\n\t\twp->w_topfill = wp->w_height - n;\n\t\tif (wp->w_topfill < 0)\n\t\t    wp->w_topfill = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t/*\n\t * If scrolling is needed, scroll at least 'sj' lines.\n\t */\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * When scrolling scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL || used + loff.height > curwin->w_height)\n\t\tbreak;\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is below botline, we will at least scroll by the height\n    // of the cursor line.  Correct for empty lines, which are really part of\n    // botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE);\n    else\n\tscrollup(line_count, TRUE);\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n    while (topline > 1)\n    {\n\tif (below <= above)\t    // add a line below the cursor first\n\t{\n\t    if (boff.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tbotline_forw(&boff);\n\t\tused += boff.height;\n\t\tif (used > curwin->w_height)\n\t\t    break;\n\t\tbelow += boff.height;\n\t    }\n\t    else\n\t    {\n\t\t++below;\t    // count a \"~\" line\n\t\tif (atend)\n\t\t    ++used;\n\t    }\n\t}\n\n\tif (below > above)\t    // add a line above the cursor\n\t{\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL)\n\t\tused = MAXCOL;\n\t    else\n\t\tused += loff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    above += loff.height;\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n\tcurwin->w_topline = topline;\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long\tso = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * move screen 'count' pages up or down and update screen\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long\tso = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(UPD_VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(UPD_VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\trestart_edit_save;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    restart_edit_save = restart_edit;\n\t    restart_edit = TRUE;\n\t    check_cursor();\n\n\t    // Avoid a scroll here for the cursor position, 'scrollbind' is\n\t    // more important.\n\t    if (!curwin->w_p_scb)\n\t\tvalidate_cursor();\n\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(UPD_VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Test for insert completion\n\nsource screendump.vim\nsource check.vim\nimport './vim9.vim' as v9\n\n\" Test for insert expansion\nfunc Test_ins_complete()\n  edit test_ins_complete.vim\n  \" The files in the current directory interferes with the files\n  \" used by this test. So use a separate directory for the test.\n  call mkdir('Xcpldir')\n  cd Xcpldir\n\n  set ff=unix\n  call writefile([\"test11\\t36Gepeto\\t/Tag/\",\n\t      \\ \"asd\\ttest11file\\t36G\",\n\t      \\ \"Makefile\\tto\\trun\"], 'Xtestfile')\n  call writefile(['', 'start of testfile',\n\t      \\ 'ru',\n\t      \\ 'run1',\n\t      \\ 'run2',\n\t      \\ 'STARTTEST',\n\t      \\ 'ENDTEST',\n\t      \\ 'end of testfile'], 'Xtestdata')\n  set ff&\n\n  enew!\n  edit Xtestdata\n  new\n  call append(0, ['#include \"Xtestfile\"', ''])\n  call cursor(2, 1)\n\n  set cot=\n  set cpt=.,w\n  \" add-expands (word from next line) from other window\n  exe \"normal iru\\<C-N>\\<C-N>\\<C-X>\\<C-N>\\<Esc>\\<C-A>\"\n  call assert_equal('run1 run3', getline('.'))\n  \" add-expands (current buffer first)\n  exe \"normal o\\<C-P>\\<C-X>\\<C-N>\"\n  call assert_equal('run3 run3', getline('.'))\n  \" Local expansion, ends in an empty line (unless it becomes a global\n  \" expansion)\n  exe \"normal o\\<C-X>\\<C-P>\\<C-P>\\<C-P>\\<C-P>\\<C-P>\"\n  call assert_equal('', getline('.'))\n  \" starts Local and switches to global add-expansion\n  exe \"normal o\\<C-X>\\<C-P>\\<C-P>\\<C-X>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-N>\"\n  call assert_equal('run1 run2', getline('.'))\n\n  set cpt=.,\\ ,w,i\n  \" i-add-expands and switches to local\n  exe \"normal OM\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal(\"Makefile\\tto\\trun3\", getline('.'))\n  \" add-expands lines (it would end in an empty line if it didn't ignore\n  \" itself)\n  exe \"normal o\\<C-X>\\<C-L>\\<C-X>\\<C-L>\\<C-P>\\<C-P>\"\n  call assert_equal(\"Makefile\\tto\\trun3\", getline('.'))\n  call assert_equal(\"Makefile\\tto\\trun3\", getline(line('.') - 1))\n\n  set cpt=kXtestfile\n  \" checks k-expansion, and file expansion (use Xtest11 instead of test11,\n  \" because TEST11.OUT may match first on DOS)\n  write Xtest11.one\n  write Xtest11.two\n  exe \"normal o\\<C-N>\\<Esc>IX\\<Esc>A\\<C-X>\\<C-F>\\<C-N>\"\n  call assert_equal('Xtest11.two', getline('.'))\n\n  \" use CTRL-X CTRL-F to complete Xtest11.one, remove it and then use CTRL-X\n  \" CTRL-F again to verify this doesn't cause trouble.\n  exe \"normal oXt\\<C-X>\\<C-F>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<C-X>\\<C-F>\"\n  call assert_equal('Xtest11.one', getline('.'))\n  normal ddk\n\n  \" Test for expanding a non-existing filename\n  exe \"normal oa1b2X3Y4\\<C-X>\\<C-F>\"\n  call assert_equal('a1b2X3Y4', getline('.'))\n  normal ddk\n\n  set cpt=w\n  \" checks make_cyclic in other window\n  exe \"normal oST\\<C-N>\\<C-P>\\<C-P>\\<C-P>\\<C-P>\"\n  call assert_equal('STARTTEST', getline('.'))\n\n  set cpt=u nohid\n  \" checks unloaded buffer expansion\n  only\n  exe \"normal oEN\\<C-N>\"\n  call assert_equal('ENDTEST', getline('.'))\n  \" checks adding mode abortion\n  exe \"normal ounl\\<C-N>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal('unless', getline('.'))\n\n  set cpt=t,d def=^\\\\k* tags=Xtestfile notagbsearch\n  \" tag expansion, define add-expansion interrupted\n  exe \"normal o\\<C-X>\\<C-]>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\\<C-X>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\"\n  call assert_equal('test11file\t36Gepeto\t/Tag/ asd', getline('.'))\n  \" t-expansion\n  exe \"normal oa\\<C-N>\\<Esc>\"\n  call assert_equal('asd', getline('.'))\n\n  %bw!\n  call delete('Xtestfile')\n  call delete('Xtest11.one')\n  call delete('Xtest11.two')\n  call delete('Xtestdata')\n  set cpt& cot& def& tags& tagbsearch& hidden&\n  cd ..\n  call delete('Xcpldir', 'rf')\nendfunc\n\nfunc Test_ins_complete_invalid_byte()\n  if has('unix') && executable('base64')\n    \" this weird command was causing an illegal memory access\n    call writefile(['bm9ybTlvMDCAMM4Dbw4OGA4ODg=='], 'Xinvalid64')\n    call system('base64 -d Xinvalid64 > Xinvalid')\n    call writefile(['qa!'], 'Xexit')\n    call RunVim([], [], \" -i NONE -n -X -Z -e -m -s -S Xinvalid -S Xexit\")\n    call delete('Xinvalid64')\n    call delete('Xinvalid')\n    call delete('Xexit')\n  endif\nendfunc\n\nfunc Test_omni_dash()\n  func Omni(findstart, base)\n    if a:findstart\n        return 5\n    else\n        echom a:base\n\treturn ['-help', '-v']\n    endif\n  endfunc\n  set omnifunc=Omni\n  new\n  exe \"normal Gofind -\\<C-x>\\<C-o>\"\n  call assert_equal(\"find -help\", getline('$'))\n\n  bwipe!\n  delfunc Omni\n  set omnifunc=\nendfunc\n\nfunc Test_omni_throw()\n  let g:CallCount = 0\n  func Omni(findstart, base)\n    let g:CallCount += 1\n    if a:findstart\n      throw \"he he he\"\n    endif\n  endfunc\n  set omnifunc=Omni\n  new\n  try\n    exe \"normal ifoo\\<C-x>\\<C-o>\"\n    call assert_false(v:true, 'command should have failed')\n  catch\n    call assert_exception('he he he')\n    call assert_equal(1, g:CallCount)\n  endtry\n\n  bwipe!\n  delfunc Omni\n  unlet g:CallCount\n  set omnifunc=\nendfunc\n\nfunc Test_omni_autoload()\n  let save_rtp = &rtp\n  set rtp=Xruntime/some\n  let dir = 'Xruntime/some/autoload'\n  call mkdir(dir, 'p')\n\n  let lines =<< trim END\n      vim9script\n      export def Func(findstart: bool, base: string): any\n          if findstart\n              return 1\n          else\n              return ['match']\n          endif\n      enddef\n      {\n          eval 1 + 2\n      }\n  END\n  call writefile(lines, dir .. '/omni.vim')\n\n  new\n  setlocal omnifunc=omni#Func\n  call feedkeys(\"i\\<C-X>\\<C-O>\\<Esc>\", 'xt')\n\n  bwipe!\n  call delete('Xruntime', 'rf')\n  set omnifunc=\n  let &rtp = save_rtp\nendfunc\n\nfunc Test_completefunc_args()\n  let s:args = []\n  func! CompleteFunc(findstart, base)\n    let s:args += [[a:findstart, empty(a:base)]]\n  endfunc\n  new\n\n  set completefunc=CompleteFunc\n  call feedkeys(\"i\\<C-X>\\<C-U>\\<Esc>\", 'x')\n  call assert_equal([1, 1], s:args[0])\n  call assert_equal(0, s:args[1][0])\n  set completefunc=\n\n  let s:args = []\n  set omnifunc=CompleteFunc\n  call feedkeys(\"i\\<C-X>\\<C-O>\\<Esc>\", 'x')\n  call assert_equal([1, 1], s:args[0])\n  call assert_equal(0, s:args[1][0])\n  set omnifunc=\n\n  bwipe!\n  unlet s:args\n  delfunc CompleteFunc\nendfunc\n\nfunc s:CompleteDone_CompleteFuncNone( findstart, base )\n  if a:findstart\n    return 0\n  endif\n\n  return v:none\nendfunc\n\nfunc s:CompleteDone_CompleteFuncDict( findstart, base )\n  if a:findstart\n    return 0\n  endif\n\n  return {\n\t  \\ 'words': [\n\t    \\ {\n\t      \\ 'word': 'aword',\n\t      \\ 'abbr': 'wrd',\n\t      \\ 'menu': 'extra text',\n\t      \\ 'info': 'words are cool',\n\t      \\ 'kind': 'W',\n\t      \\ 'user_data': 'test'\n\t    \\ }\n\t  \\ ]\n\t\\ }\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemNone()\n  let s:called_completedone = 1\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemDict(pre)\n  call assert_equal( 'aword',          v:completed_item[ 'word' ] )\n  call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )\n  call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )\n  call assert_equal( 'words are cool', v:completed_item[ 'info' ] )\n  call assert_equal( 'W',              v:completed_item[ 'kind' ] )\n  call assert_equal( 'test',           v:completed_item[ 'user_data' ] )\n\n  if a:pre\n    call assert_equal('function', complete_info().mode)\n  endif\n\n  let s:called_completedone = 1\nendfunc\n\nfunc Test_CompleteDoneNone()\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemNone()\n  let oldline = join(map(range(&columns), 'nr2char(screenchar(&lines-1, v:val+1))'), '')\n\n  set completefunc=<SID>CompleteDone_CompleteFuncNone\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n  let newline = join(map(range(&columns), 'nr2char(screenchar(&lines-1, v:val+1))'), '')\n\n  call assert_true(s:called_completedone)\n  call assert_equal(oldline, newline)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc Test_CompleteDoneDict()\n  au CompleteDonePre * :call <SID>CompleteDone_CheckCompletedItemDict(1)\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDict(0)\n\n  set completefunc=<SID>CompleteDone_CompleteFuncDict\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n\n  call assert_equal('test', v:completed_item[ 'user_data' ])\n  call assert_true(s:called_completedone)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc s:CompleteDone_CompleteFuncDictNoUserData(findstart, base)\n  if a:findstart\n    return 0\n  endif\n\n  return {\n\t  \\ 'words': [\n\t    \\ {\n\t      \\ 'word': 'aword',\n\t      \\ 'abbr': 'wrd',\n\t      \\ 'menu': 'extra text',\n\t      \\ 'info': 'words are cool',\n\t      \\ 'kind': 'W',\n\t      \\ 'user_data': ['one', 'two'],\n\t    \\ }\n\t  \\ ]\n\t\\ }\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemDictNoUserData()\n  call assert_equal( 'aword',          v:completed_item[ 'word' ] )\n  call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )\n  call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )\n  call assert_equal( 'words are cool', v:completed_item[ 'info' ] )\n  call assert_equal( 'W',              v:completed_item[ 'kind' ] )\n  call assert_equal( ['one', 'two'],   v:completed_item[ 'user_data' ] )\n\n  let s:called_completedone = 1\nendfunc\n\nfunc Test_CompleteDoneDictNoUserData()\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDictNoUserData()\n\n  set completefunc=<SID>CompleteDone_CompleteFuncDictNoUserData\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n\n  call assert_equal(['one', 'two'], v:completed_item[ 'user_data' ])\n  call assert_true(s:called_completedone)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc s:CompleteDone_CompleteFuncList(findstart, base)\n  if a:findstart\n    return 0\n  endif\n\n  return [ 'aword' ]\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemList()\n  call assert_equal( 'aword', v:completed_item[ 'word' ] )\n  call assert_equal( '',      v:completed_item[ 'abbr' ] )\n  call assert_equal( '',      v:completed_item[ 'menu' ] )\n  call assert_equal( '',      v:completed_item[ 'info' ] )\n  call assert_equal( '',      v:completed_item[ 'kind' ] )\n  call assert_equal( '',      v:completed_item[ 'user_data' ] )\n\n  let s:called_completedone = 1\nendfunc\n\nfunc Test_CompleteDoneList()\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemList()\n\n  set completefunc=<SID>CompleteDone_CompleteFuncList\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n\n  call assert_equal('', v:completed_item[ 'user_data' ])\n  call assert_true(s:called_completedone)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc Test_CompleteDone_undo()\n  au CompleteDone * call append(0, \"prepend1\")\n  new\n  call setline(1, [\"line1\", \"line2\"])\n  call feedkeys(\"Go\\<C-X>\\<C-N>\\<CR>\\<ESC>\", \"tx\")\n  call assert_equal([\"prepend1\", \"line1\", \"line2\", \"line1\", \"\"],\n              \\     getline(1, '$'))\n  undo\n  call assert_equal([\"line1\", \"line2\"], getline(1, '$'))\n  bwipe!\n  au! CompleteDone\nendfunc\n\nfunc Test_CompleteDone_modify()\n  let value = {\n        \\ 'word': '',\n        \\ 'abbr': '',\n        \\ 'menu': '',\n        \\ 'info': '',\n        \\ 'kind': '',\n        \\ 'user_data': '',\n        \\ }\n  let v:completed_item = value\n  call assert_equal(value, v:completed_item)\nendfunc\n\nfunc CompleteTest(findstart, query)\n  if a:findstart\n    return col('.')\n  endif\n  return ['matched']\nendfunc\n\nfunc Test_completefunc_info()\n  new\n  set completeopt=menuone\n  set completefunc=CompleteTest\n  call feedkeys(\"i\\<C-X>\\<C-U>\\<C-R>\\<C-R>=string(complete_info())\\<CR>\\<ESC>\", \"tx\")\n  call assert_equal(\"matched{'pum_visible': 1, 'mode': 'function', 'selected': 0, 'items': [{'word': 'matched', 'menu': '', 'user_data': '', 'info': '', 'kind': '', 'abbr': ''}]}\", getline(1))\n  bwipe!\n  set completeopt&\n  set completefunc&\nendfunc\n\n\" Check that when using feedkeys() typeahead does not interrupt searching for\n\" completions.\nfunc Test_compl_feedkeys()\n  new\n  set completeopt=menuone,noselect\n  call feedkeys(\"ajump ju\\<C-X>\\<C-N>\\<C-P>\\<ESC>\", \"tx\")\n  call assert_equal(\"jump jump\", getline(1))\n  bwipe!\n  set completeopt&\nendfunc\n\n\" Test for insert path completion with completeslash option\nfunc Test_ins_completeslash()\n  CheckMSWindows\n\n  call mkdir('Xcpldir')\n  let orig_shellslash = &shellslash\n  set cpt&\n  new\n\n  set noshellslash\n\n  set completeslash=\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir\\', getline('.'))\n\n  set completeslash=backslash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir\\', getline('.'))\n\n  set completeslash=slash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir/', getline('.'))\n\n  set shellslash\n\n  set completeslash=\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir/', getline('.'))\n\n  set completeslash=backslash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir\\', getline('.'))\n\n  set completeslash=slash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir/', getline('.'))\n  %bw!\n  call delete('Xcpldir', 'rf')\n\n  set noshellslash\n  set completeslash=slash\n  call assert_true(stridx(globpath(&rtp, 'syntax/*.vim', 1, 1)[0], '\\') != -1)\n\n  let &shellslash = orig_shellslash\n  set completeslash=\nendfunc\n\nfunc Test_pum_stopped_by_timer()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['hello', 'hullo', 'heeee', ''])\n    func StartCompl()\n      call timer_start(100, { -> execute('stopinsert') })\n      call feedkeys(\"Gah\\<C-N>\")\n    endfunc\n  END\n\n  call writefile(lines, 'Xpumscript')\n  let buf = RunVimInTerminal('-S Xpumscript', #{rows: 12})\n  call term_sendkeys(buf, \":call StartCompl()\\<CR>\")\n  call TermWait(buf, 200)\n  call term_sendkeys(buf, \"k\")\n  call VerifyScreenDump(buf, 'Test_pum_stopped_by_timer', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xpumscript')\nendfunc\n\nfunc Test_complete_stopinsert_startinsert()\n  nnoremap <F2> <Cmd>startinsert<CR>\n  inoremap <F2> <Cmd>stopinsert<CR>\n  \" This just checks if this causes an error\n  call feedkeys(\"i\\<C-X>\\<C-N>\\<F2>\\<F2>\", 'x')\n  nunmap <F2>\n  iunmap <F2>\nendfunc\n\nfunc Test_pum_with_folds_two_tabs()\n  CheckScreendump\n\n  let lines =<< trim END\n    set fdm=marker\n    call setline(1, ['\" x {{{1', '\" a some text'])\n    call setline(3, range(&lines)->map({_, val -> '\" a' .. val}))\n    norm! zm\n    tab sp\n    call feedkeys('2Gzv', 'xt')\n    call feedkeys(\"0fa\", 'xt')\n  END\n\n  call writefile(lines, 'Xpumscript')\n  let buf = RunVimInTerminal('-S Xpumscript', #{rows: 10})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"a\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_pum_with_folds_two_tabs', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('Xpumscript')\nendfunc\n\nfunc Test_pum_with_preview_win()\n  CheckScreendump\n\n  let lines =<< trim END\n      funct Omni_test(findstart, base)\n\tif a:findstart\n\t  return col(\".\") - 1\n\tendif\n\treturn [#{word: \"one\", info: \"1info\"}, #{word: \"two\", info: \"2info\"}, #{word: \"three\", info: \"3info\"}]\n      endfunc\n      set omnifunc=Omni_test\n      set completeopt+=longest\n  END\n\n  call writefile(lines, 'Xpreviewscript')\n  let buf = RunVimInTerminal('-S Xpreviewscript', #{rows: 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"Gi\\<C-X>\\<C-O>\")\n  call TermWait(buf, 100)\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_pum_with_preview_win', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('Xpreviewscript')\nendfunc\n\nfunc Test_scrollbar_on_wide_char()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['a', '            \u554a\u554a\u554a',\n                        \\ '             \u54e6\u54e6\u54e6',\n                        \\ '              \u5443\u5443\u5443'])\n    call setline(5, range(10)->map({i, v -> 'aa' .. v .. 'bb'}))\n  END\n  call writefile(lines, 'Xwidescript')\n  let buf = RunVimInTerminal('-S Xwidescript', #{rows: 10})\n  call term_sendkeys(buf, \"A\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_scrollbar_on_wide_char', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xwidescript')\nendfunc\n\n\" Test for inserting the tag search pattern in insert mode\nfunc Test_ins_compl_tag_sft()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t/^int first() {}$/\",\n        \\ \"second\\tXfoo\\t/^int second() {}$/\",\n        \\ \"third\\tXfoo\\t/^int third() {}$/\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  set showfulltag\n  exe \"normal isec\\<C-X>\\<C-]>\\<C-N>\\<CR>\"\n  call assert_equal('int second() {}', getline(1))\n  set noshowfulltag\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe!\nendfunc\n\n\" Test for 'completefunc' deleting text\nfunc Test_completefunc_error()\n  new\n  \" delete text when called for the first time\n  func CompleteFunc(findstart, base)\n    if a:findstart == 1\n      normal dd\n      return col('.') - 1\n    endif\n    return ['a', 'b']\n  endfunc\n  set completefunc=CompleteFunc\n  call setline(1, ['', 'abcd', ''])\n  call assert_fails('exe \"normal 2G$a\\<C-X>\\<C-U>\"', 'E565:')\n\n  \" delete text when called for the second time\n  func CompleteFunc2(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    normal dd\n    return ['a', 'b']\n  endfunc\n  set completefunc=CompleteFunc2\n  call setline(1, ['', 'abcd', ''])\n  call assert_fails('exe \"normal 2G$a\\<C-X>\\<C-U>\"', 'E565:')\n\n  \" Jump to a different window from the complete function\n  func CompleteFunc3(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    wincmd p\n    return ['a', 'b']\n  endfunc\n  set completefunc=CompleteFunc3\n  new\n  call assert_fails('exe \"normal a\\<C-X>\\<C-U>\"', 'E565:')\n  close!\n\n  set completefunc&\n  delfunc CompleteFunc\n  delfunc CompleteFunc2\n  delfunc CompleteFunc3\n  close!\nendfunc\n\n\" Test for returning non-string values from 'completefunc'\nfunc Test_completefunc_invalid_data()\n  new\n  func! CompleteFunc(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    return [{}, '', 'moon']\n  endfunc\n  set completefunc=CompleteFunc\n  exe \"normal i\\<C-X>\\<C-U>\"\n  call assert_equal('moon', getline(1))\n  set completefunc&\n  close!\nendfunc\n\n\" Test for errors in using complete() function\nfunc Test_complete_func_error()\n  call assert_fails('call complete(1, [\"a\"])', 'E785:')\n  func ListColors()\n    call complete(col('.'), \"blue\")\n  endfunc\n  call assert_fails('exe \"normal i\\<C-R>=ListColors()\\<CR>\"', 'E1211:')\n  func ListMonths()\n    call complete(col('.'), test_null_list())\n  endfunc\n  call assert_fails('exe \"normal i\\<C-R>=ListMonths()\\<CR>\"', 'E1298:')\n  delfunc ListColors\n  delfunc ListMonths\n  call assert_fails('call complete_info({})', 'E1211:')\n  call assert_equal([], complete_info(['items']).items)\nendfunc\n\n\" Test for recursively starting completion mode using complete()\nfunc Test_recursive_complete_func()\n  func ListColors()\n    call complete(5, [\"red\", \"blue\"])\n    return ''\n  endfunc\n  new\n  call setline(1, ['a1', 'a2'])\n  set complete=.\n  exe \"normal Goa\\<C-X>\\<C-L>\\<C-R>=ListColors()\\<CR>\\<C-N>\"\n  call assert_equal('a2blue', getline(3))\n  delfunc ListColors\n  bw!\nendfunc\n\n\" Test for using complete() with completeopt+=longest\nfunc Test_complete_with_longest()\n  new\n  inoremap <buffer> <f3> <cmd>call complete(1, [\"iaax\", \"iaay\", \"iaaz\"])<cr>\n\n  \" default: insert first match\n  set completeopt&\n  call setline(1, ['i'])\n  exe \"normal Aa\\<f3>\\<esc>\"\n  call assert_equal('iaax', getline(1))\n\n  \" with longest: insert longest prefix\n  set completeopt+=longest\n  call setline(1, ['i'])\n  exe \"normal Aa\\<f3>\\<esc>\"\n  call assert_equal('iaa', getline(1))\n  set completeopt&\n  bwipe!\nendfunc\n\n\n\" Test for completing words following a completed word in a line\nfunc Test_complete_wrapscan()\n  \" complete words from another buffer\n  new\n  call setline(1, ['one two', 'three four'])\n  new\n  setlocal complete=w\n  call feedkeys(\"itw\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\", 'xt')\n  call assert_equal('two three four', getline(1))\n  close!\n  \" complete words from the current buffer\n  setlocal complete=.\n  %d\n  call setline(1, ['one two', ''])\n  call cursor(2, 1)\n  call feedkeys(\"ion\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\", 'xt')\n  call assert_equal('one two one two', getline(2))\n  close!\nendfunc\n\n\" Test for completing special characters\nfunc Test_complete_special_chars()\n  new\n  call setline(1, 'int .*[-\\^$ func float')\n  call feedkeys(\"oin\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\", 'xt')\n  call assert_equal('int .*[-\\^$ func float', getline(2))\n  close!\nendfunc\n\n\" Test for completion when text is wrapped across lines.\nfunc Test_complete_across_line()\n  new\n  call setline(1, ['red green blue', 'one two three'])\n  setlocal textwidth=20\n  exe \"normal 2G$a re\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(['one two three red', 'green blue one'], getline(2, '$'))\n  close!\nendfunc\n\n\" Test for completing words with a '.' at the end of a word.\nfunc Test_complete_joinspaces()\n  new\n  call setline(1, ['one two.', 'three. four'])\n  set joinspaces\n  exe \"normal Goon\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(\"one two.  three. four\", getline(3))\n  set joinspaces&\n  bw!\nendfunc\n\n\" Test for using CTRL-L to add one character when completing matching\nfunc Test_complete_add_onechar()\n  new\n  call setline(1, ['wool', 'woodwork'])\n  call feedkeys(\"Gowoo\\<C-P>\\<C-P>\\<C-P>\\<C-L>f\", 'xt')\n  call assert_equal('woof', getline(3))\n\n  \" use 'ignorecase' and backspace to erase characters from the prefix string\n  \" and then add letters using CTRL-L\n  %d\n  set ignorecase backspace=2\n  setlocal complete=.\n  call setline(1, ['workhorse', 'workload'])\n  normal Go\n  exe \"normal aWOR\\<C-P>\\<bs>\\<bs>\\<bs>\\<bs>\\<bs>\\<bs>\\<C-L>r\\<C-L>\\<C-L>\"\n  call assert_equal('workh', getline(3))\n  set ignorecase& backspace&\n  close!\nendfunc\n\n\" Test for using CTRL-X CTRL-L to complete whole lines lines\nfunc Test_complete_wholeline()\n  new\n  \" complete one-line\n  call setline(1, ['a1', 'a2'])\n  exe \"normal ggoa\\<C-X>\\<C-L>\"\n  call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))\n  \" go to the next match (wrapping around the buffer)\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\"\n  call assert_equal(['a1', 'a', 'a2'], getline(1, '$'))\n  \" go to the next match\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\\<C-N>\"\n  call assert_equal(['a1', 'a2', 'a2'], getline(1, '$'))\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\\<C-N>\\<C-N>\"\n  call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))\n  \" repeat the test using CTRL-L\n  \" go to the next match (wrapping around the buffer)\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\"\n  call assert_equal(['a1', 'a2', 'a2'], getline(1, '$'))\n  \" go to the next match\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\\<C-L>\"\n  call assert_equal(['a1', 'a', 'a2'], getline(1, '$'))\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\\<C-L>\\<C-L>\"\n  call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))\n  %d\n  \" use CTRL-X CTRL-L to add one more line\n  call setline(1, ['a1', 'b1'])\n  setlocal complete=.\n  exe \"normal ggOa\\<C-X>\\<C-L>\\<C-X>\\<C-L>\\<C-X>\\<C-L>\"\n  call assert_equal(['a1', 'b1', '', 'a1', 'b1'], getline(1, '$'))\n  bw!\nendfunc\n\n\" Test insert completion with 'cindent' (adjust the indent)\nfunc Test_complete_with_cindent()\n  new\n  setlocal cindent\n  call setline(1, ['if (i == 1)', \"    j = 2;\"])\n  exe \"normal Go{\\<CR>i\\<C-X>\\<C-L>\\<C-X>\\<C-L>\\<CR>}\"\n  call assert_equal(['{', \"\\tif (i == 1)\", \"\\t\\tj = 2;\", '}'], getline(3, '$'))\n\n  %d\n  call setline(1, ['when while', '{', ''])\n  setlocal cinkeys+==while\n  exe \"normal Giwh\\<C-P> \"\n  call assert_equal(\"\\twhile \", getline('$'))\n  close!\nendfunc\n\n\" Test for <CTRL-X> <CTRL-V> completion. Complete commands and functions\nfunc Test_complete_cmdline()\n  new\n  exe \"normal icaddb\\<C-X>\\<C-V>\"\n  call assert_equal('caddbuffer', getline(1))\n  exe \"normal ocall getqf\\<C-X>\\<C-V>\"\n  call assert_equal('call getqflist(', getline(2))\n  exe \"normal oabcxyz(\\<C-X>\\<C-V>\"\n  call assert_equal('abcxyz(', getline(3))\n  com! -buffer TestCommand1 echo 'TestCommand1'\n  com! -buffer TestCommand2 echo 'TestCommand2'\n  write TestCommand1Test\n  write TestCommand2Test\n  \" Test repeating <CTRL-X> <CTRL-V> and switching to another CTRL-X mode\n  exe \"normal oT\\<C-X>\\<C-V>\\<C-X>\\<C-V>\\<C-X>\\<C-F>\\<Esc>\"\n  call assert_equal('TestCommand2Test', getline(4))\n  call delete('TestCommand1Test')\n  call delete('TestCommand2Test')\n  delcom TestCommand1\n  delcom TestCommand2\n  close!\nendfunc\n\n\" Test for <CTRL-X> <CTRL-Z> stopping completion without changing the match\nfunc Test_complete_stop()\n  new\n  func Save_mode1()\n    let g:mode1 = mode(1)\n    return ''\n  endfunc\n  func Save_mode2()\n    let g:mode2 = mode(1)\n    return ''\n  endfunc\n  inoremap <F1> <C-R>=Save_mode1()<CR>\n  inoremap <F2> <C-R>=Save_mode2()<CR>\n  call setline(1, ['aaa bbb ccc '])\n  exe \"normal A\\<C-N>\\<C-P>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc ', getline(1))\n  exe \"normal A\\<C-N>\\<Down>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc aaa', getline(1))\n  set completeopt+=noselect\n  exe \"normal A \\<C-N>\\<Down>\\<Down>\\<C-L>\\<C-L>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc aaa bb', getline(1))\n  set completeopt&\n  exe \"normal A d\\<C-N>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc aaa bb d', getline(1))\n  com! -buffer TestCommand1 echo 'TestCommand1'\n  com! -buffer TestCommand2 echo 'TestCommand2'\n  exe \"normal oT\\<C-X>\\<C-V>\\<C-X>\\<C-V>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('TestCommand2', getline(2))\n  delcom TestCommand1\n  delcom TestCommand2\n  unlet g:mode1\n  unlet g:mode2\n  iunmap <F1>\n  iunmap <F2>\n  delfunc Save_mode1\n  delfunc Save_mode2\n  close!\nendfunc\n\n\" Test for typing CTRL-R in insert completion mode to insert a register\n\" content.\nfunc Test_complete_reginsert()\n  new\n  call setline(1, ['a1', 'a12', 'a123', 'a1234'])\n\n  \" if a valid CTRL-X mode key is returned from <C-R>=, then it should be\n  \" processed. Otherwise, CTRL-X mode should be stopped and the key should be\n  \" inserted.\n  exe \"normal Goa\\<C-P>\\<C-R>=\\\"\\\\<C-P>\\\"\\<CR>\"\n  call assert_equal('a123', getline(5))\n  let @r = \"\\<C-P>\\<C-P>\"\n  exe \"normal GCa\\<C-P>\\<C-R>r\"\n  call assert_equal('a12', getline(5))\n  exe \"normal GCa\\<C-P>\\<C-R>=\\\"x\\\"\\<CR>\"\n  call assert_equal('a1234x', getline(5))\n  bw!\nendfunc\n\nfunc Test_issue_7021()\n  CheckMSWindows\n\n  let orig_shellslash = &shellslash\n  set noshellslash\n\n  set completeslash=slash\n  call assert_false(expand('~') =~ '/')\n\n  let &shellslash = orig_shellslash\n  set completeslash=\nendfunc\n\n\" Test for 'longest' setting in 'completeopt' with latin1 and utf-8 encodings\nfunc Test_complete_longest_match()\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    set complete=.\n    set completeopt=menu,longest\n    call setline(1, ['pfx_a1', 'pfx_a12', 'pfx_a123', 'pfx_b1'])\n    exe \"normal Gopfx\\<C-P>\"\n    call assert_equal('pfx_', getline(5))\n    bw!\n  endfor\n\n  \" Test for completing additional words with longest match set\n  new\n  call setline(1, ['abc1', 'abd2'])\n  exe \"normal Goab\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal('ab', getline(3))\n  bw!\n  set complete& completeopt&\nendfunc\n\n\" Test for removing the first displayed completion match and selecting the\n\" match just before that.\nfunc Test_complete_erase_firstmatch()\n  new\n  call setline(1, ['a12', 'a34', 'a56'])\n  set complete=.\n  exe \"normal Goa\\<C-P>\\<BS>\\<BS>3\\<CR>\"\n  call assert_equal('a34', getline('$'))\n  set complete&\n  bw!\nendfunc\n\n\" Test for completing words from unloaded buffers\nfunc Test_complete_from_unloadedbuf()\n  call writefile(['abc'], \"Xfile1\")\n  call writefile(['def'], \"Xfile2\")\n  edit Xfile1\n  edit Xfile2\n  new | close\n  enew\n  bunload Xfile1 Xfile2\n  set complete=u\n  \" complete from an unloaded buffer\n  exe \"normal! ia\\<C-P>\"\n  call assert_equal('abc', getline(1))\n  exe \"normal! od\\<C-P>\"\n  call assert_equal('def', getline(2))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\n  call delete(\"Xfile2\")\nendfunc\n\n\" Test for completing whole lines from unloaded buffers\nfunc Test_complete_wholeline_unloadedbuf()\n  call writefile(['a line1', 'a line2', 'a line3'], \"Xfile1\")\n  edit Xfile1\n  enew\n  set complete=u\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a line2', getline(1))\n  %d\n  \" completing from an unlisted buffer should fail\n  bdel Xfile1\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a', getline(1))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\nendfunc\n\n\" Test for completing words from unlisted buffers\nfunc Test_complete_from_unlistedbuf()\n  call writefile(['abc'], \"Xfile1\")\n  call writefile(['def'], \"Xfile2\")\n  edit Xfile1\n  edit Xfile2\n  new | close\n  bdel Xfile1 Xfile2\n  set complete=U\n  \" complete from an unlisted buffer\n  exe \"normal! ia\\<C-P>\"\n  call assert_equal('abc', getline(1))\n  exe \"normal! od\\<C-P>\"\n  call assert_equal('def', getline(2))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\n  call delete(\"Xfile2\")\nendfunc\n\n\" Test for completing whole lines from unlisted buffers\nfunc Test_complete_wholeline_unlistedbuf()\n  call writefile(['a line1', 'a line2', 'a line3'], \"Xfile1\")\n  edit Xfile1\n  enew\n  set complete=U\n  \" completing from a unloaded buffer should fail\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a', getline(1))\n  %d\n  bdel Xfile1\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a line2', getline(1))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\nendfunc\n\n\" Test for adding a multibyte character using CTRL-L in completion mode\nfunc Test_complete_mbyte_char_add()\n  new\n  set complete=.\n  call setline(1, 'ab\u0117')\n  exe \"normal! oa\\<C-P>\\<BS>\\<BS>\\<C-L>\\<C-L>\"\n  call assert_equal('ab\u0117', getline(2))\n  \" Test for a leader with multibyte character\n  %d\n  call setline(1, 'ab\u0117\u0115')\n  exe \"normal! oab\u0117\\<C-P>\"\n  call assert_equal('ab\u0117\u0115', getline(2))\n  bw!\nendfunc\n\n\" Test for using <C-X><C-P> for local expansion even if 'complete' is set to\n\" not to complete matches from the local buffer. Also test using multiple\n\" <C-X> to cancel the current completion mode.\nfunc Test_complete_local_expansion()\n  new\n  set complete=t\n  call setline(1, ['abc', 'def'])\n  exe \"normal! Go\\<C-X>\\<C-P>\"\n  call assert_equal(\"def\", getline(3))\n  exe \"normal! Go\\<C-P>\"\n  call assert_equal(\"\", getline(4))\n  exe \"normal! Go\\<C-X>\\<C-N>\"\n  call assert_equal(\"abc\", getline(5))\n  exe \"normal! Go\\<C-N>\"\n  call assert_equal(\"\", getline(6))\n\n  \" use multiple <C-X> to cancel the previous completion mode\n  exe \"normal! Go\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(\"\", getline(7))\n  exe \"normal! Go\\<C-P>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal(\"\", getline(8))\n  exe \"normal! Go\\<C-P>\\<C-X>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal(\"abc\", getline(9))\n\n  \" interrupt the current completion mode\n  set completeopt=menu,noinsert\n  exe \"normal! Go\\<C-X>\\<C-F>\\<C-X>\\<C-X>\\<C-P>\\<C-Y>\"\n  call assert_equal(\"abc\", getline(10))\n\n  \" when only one <C-X> is used to interrupt, do normal expansion\n  exe \"normal! Go\\<C-X>\\<C-F>\\<C-X>\\<C-P>\"\n  call assert_equal(\"\", getline(11))\n  set completeopt&\n\n  \" using two <C-X> in non-completion mode and restarting the same mode\n  exe \"normal! God\\<C-X>\\<C-X>\\<C-P>\\<C-X>\\<C-X>\\<C-P>\\<C-Y>\"\n  call assert_equal(\"def\", getline(12))\n\n  \" test for adding a match from the original empty text\n  %d\n  call setline(1, 'abc def g')\n  exe \"normal! o\\<C-X>\\<C-P>\\<C-N>\\<C-X>\\<C-P>\"\n  call assert_equal('def', getline(2))\n  exe \"normal! 0C\\<C-X>\\<C-N>\\<C-P>\\<C-X>\\<C-N>\"\n  call assert_equal('abc', getline(2))\n\n  bw!\nendfunc\n\n\" Test for undoing changes after a insert-mode completion\nfunc Test_complete_undo()\n  new\n  set complete=.\n  \" undo with 'ignorecase'\n  call setline(1, ['ABOVE', 'BELOW'])\n  set ignorecase\n  exe \"normal! Goab\\<C-G>u\\<C-P>\"\n  call assert_equal(\"ABOVE\", getline(3))\n  undo\n  call assert_equal(\"ab\", getline(3))\n  set ignorecase&\n  %d\n  \" undo with longest match\n  set completeopt=menu,longest\n  call setline(1, ['above', 'about'])\n  exe \"normal! Goa\\<C-G>u\\<C-P>\"\n  call assert_equal(\"abo\", getline(3))\n  undo\n  call assert_equal(\"a\", getline(3))\n  set completeopt&\n  %d\n  \" undo for line completion\n  call setline(1, ['above that change', 'below that change'])\n  exe \"normal! Goabove\\<C-G>u\\<C-X>\\<C-L>\"\n  call assert_equal(\"above that change\", getline(3))\n  undo\n  call assert_equal(\"above\", getline(3))\n\n  bw!\nendfunc\n\n\" Test for completing a very long word\nfunc Test_complete_long_word()\n  set complete&\n  new\n  call setline(1, repeat('x', 950) .. ' one two three')\n  exe \"normal! Gox\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(repeat('x', 950) .. ' one two three', getline(2))\n  %d\n  \" should fail when more than 950 characters are in a word\n  call setline(1, repeat('x', 951) .. ' one two three')\n  exe \"normal! Gox\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(repeat('x', 951), getline(2))\n\n  \" Test for adding a very long word to an existing completion\n  %d\n  call setline(1, ['abc', repeat('x', 1016) .. '012345'])\n  exe \"normal! Goab\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal('abc ' .. repeat('x', 1016) .. '0123', getline(3))\n  bw!\nendfunc\n\n\" Test for some fields in the complete items used by complete()\nfunc Test_complete_items()\n  func CompleteItems(idx)\n    let items = [[#{word: \"one\", dup: 1, user_data: 'u1'}, #{word: \"one\", dup: 1, user_data: 'u2'}],\n          \\ [#{word: \"one\", dup: 0, user_data: 'u3'}, #{word: \"one\", dup: 0, user_data: 'u4'}],\n          \\ [#{word: \"one\", icase: 1, user_data: 'u7'}, #{word: \"oNE\", icase: 1, user_data: 'u8'}],\n          \\ [#{user_data: 'u9'}],\n          \\ [#{word: \"\", user_data: 'u10'}],\n          \\ [#{word: \"\", empty: 1, user_data: 'u11'}]]\n    call complete(col('.'), items[a:idx])\n    return ''\n  endfunc\n  new\n  exe \"normal! i\\<C-R>=CompleteItems(0)\\<CR>\\<C-N>\\<C-Y>\"\n  call assert_equal('u2', v:completed_item.user_data)\n  call assert_equal('one', getline(1))\n  exe \"normal! o\\<C-R>=CompleteItems(1)\\<CR>\\<C-Y>\"\n  call assert_equal('u3', v:completed_item.user_data)\n  call assert_equal('one', getline(2))\n  exe \"normal! o\\<C-R>=CompleteItems(1)\\<CR>\\<C-N>\"\n  call assert_equal('', getline(3))\n  set completeopt=menu,noinsert\n  exe \"normal! o\\<C-R>=CompleteItems(2)\\<CR>one\\<C-N>\\<C-Y>\"\n  call assert_equal('oNE', getline(4))\n  call assert_equal('u8', v:completed_item.user_data)\n  set completeopt&\n  exe \"normal! o\\<C-R>=CompleteItems(3)\\<CR>\"\n  call assert_equal('', getline(5))\n  exe \"normal! o\\<C-R>=CompleteItems(4)\\<CR>\"\n  call assert_equal('', getline(6))\n  exe \"normal! o\\<C-R>=CompleteItems(5)\\<CR>\"\n  call assert_equal('', getline(7))\n  call assert_equal('u11', v:completed_item.user_data)\n  \" pass invalid argument to complete()\n  let cmd = \"normal! o\\<C-R>=complete(1, [[]])\\<CR>\"\n  call assert_fails('exe cmd', 'E730:')\n  bw!\n  delfunc CompleteItems\nendfunc\n\n\" Test for the \"refresh\" item in the dict returned by an insert completion\n\" function\nfunc Test_complete_item_refresh_always()\n  let g:CallCount = 0\n  func! Tcomplete(findstart, base)\n    if a:findstart\n      \" locate the start of the word\n      let line = getline('.')\n      let start = col('.') - 1\n      while start > 0 && line[start - 1] =~ '\\a'\n        let start -= 1\n      endwhile\n      return start\n    else\n      let g:CallCount += 1\n      let res = [\"update1\", \"update12\", \"update123\"]\n      return #{words: res, refresh: 'always'}\n    endif\n  endfunc\n  new\n  set completeopt=menu,longest\n  set completefunc=Tcomplete\n  exe \"normal! iup\\<C-X>\\<C-U>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\"\n  call assert_equal('up', getline(1))\n  call assert_equal(2, g:CallCount)\n  set completeopt&\n  set completefunc&\n  bw!\n  delfunc Tcomplete\nendfunc\n\n\" Test for completing from a thesaurus file without read permission\nfunc Test_complete_unreadable_thesaurus_file()\n  CheckUnix\n  CheckNotRoot\n\n  call writefile(['about', 'above'], 'Xunrfile')\n  call setfperm('Xunrfile', '---r--r--')\n  new\n  set complete=sXfile\n  exe \"normal! ia\\<C-P>\"\n  call assert_equal('a', getline(1))\n  bw!\n  call delete('Xunrfile')\n  set complete&\nendfunc\n\n\" Test to ensure 'Scanning...' messages are not recorded in messages history\nfunc Test_z1_complete_no_history()\n  new\n  messages clear\n  let currmess = execute('messages')\n  setlocal dictionary=README.txt\n  exe \"normal owh\\<C-X>\\<C-K>\"\n  exe \"normal owh\\<C-N>\"\n  call assert_equal(currmess, execute('messages'))\n  bwipe!\nendfunc\n\n\" A mapping is not used for the key after CTRL-X.\nfunc Test_no_mapping_for_ctrl_x_key()\n  new\n  inoremap <buffer> <C-K> <Cmd>let was_mapped = 'yes'<CR>\n  setlocal dictionary=README.txt\n  call feedkeys(\"aexam\\<C-X>\\<C-K> \", 'xt')\n  call assert_equal('example ', getline(1))\n  call assert_false(exists('was_mapped'))\n  bwipe!\nendfunc\n\n\" Test for different ways of setting the 'completefunc' option\nfunc Test_completefunc_callback()\n  func CompleteFunc1(callnr, findstart, base)\n    call add(g:CompleteFunc1Args, [a:callnr, a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  func CompleteFunc2(findstart, base)\n    call add(g:CompleteFunc2Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a global function name\n    LET &completefunc = 'g:CompleteFunc2'\n    new\n    call setline(1, 'global')\n    LET g:CompleteFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'global']], g:CompleteFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set completefunc=function('g:CompleteFunc1',\\ [10])\n    new\n    call setline(1, 'one')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[10, 1, ''], [10, 0, 'one']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'completefunc'\n    VAR Fn = function('g:CompleteFunc1', [11])\n    LET &completefunc = Fn\n    new\n    call setline(1, 'two')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[11, 1, ''], [11, 0, 'two']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using string(funcref_variable) to set 'completefunc'\n    LET Fn = function('g:CompleteFunc1', [12])\n    LET &completefunc = string(Fn)\n    new\n    call setline(1, 'two')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[12, 1, ''], [12, 0, 'two']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set completefunc=funcref('g:CompleteFunc1',\\ [13])\n    new\n    call setline(1, 'three')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[13, 1, ''], [13, 0, 'three']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'completefunc'\n    LET Fn = funcref('g:CompleteFunc1', [14])\n    LET &completefunc = Fn\n    new\n    call setline(1, 'four')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[14, 1, ''], [14, 0, 'four']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'completefunc'\n    LET Fn = funcref('g:CompleteFunc1', [15])\n    LET &completefunc = string(Fn)\n    new\n    call setline(1, 'four')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[15, 1, ''], [15, 0, 'four']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a, b LMIDDLE g:CompleteFunc1(16, a, b) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set completefunc=\" .. optval\n    new\n    call setline(1, 'five')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[16, 1, ''], [16, 0, 'five']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to a lambda expression\n    LET &completefunc = LSTART a, b LMIDDLE g:CompleteFunc1(17, a, b) LEND\n    new\n    call setline(1, 'six')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[17, 1, ''], [17, 0, 'six']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to string(lambda_expression)\n    LET &completefunc = 'LSTART a, b LMIDDLE g:CompleteFunc1(18, a, b) LEND'\n    new\n    call setline(1, 'six')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[18, 1, ''], [18, 0, 'six']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b LMIDDLE g:CompleteFunc1(19, a, b) LEND\n    LET &completefunc = Lambda\n    new\n    call setline(1, 'seven')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[19, 1, ''], [19, 0, 'seven']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b LMIDDLE g:CompleteFunc1(20, a, b) LEND\n    LET &completefunc = string(Lambda)\n    new\n    call setline(1, 'seven')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[20, 1, ''], [20, 0, 'seven']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b LMIDDLE strlen(a) LEND\n    LET &completefunc = Lambda\n    new\n    call setline(1, 'eight')\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    bw!\n\n    #\" Test for clearing the 'completefunc' option\n    set completefunc=''\n    set completefunc&\n    call assert_fails(\"set completefunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set completefunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'completefunc' to a non-existing function\n    set completefunc=g:CompleteFunc2\n    call setline(1, 'five')\n    call assert_fails(\"set completefunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &completefunc = function('NonExistingFunc')\", 'E700:')\n    LET g:CompleteFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'five']], g:CompleteFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:CompleteFunc3(findstart, base)\n    call add(g:CompleteFunc3Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  set completefunc=s:CompleteFunc3\n  new\n  call setline(1, 'script1')\n  let g:CompleteFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script1']], g:CompleteFunc3Args)\n  bw!\n\n  let &completefunc = 's:CompleteFunc3'\n  new\n  call setline(1, 'script2')\n  let g:CompleteFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script2']], g:CompleteFunc3Args)\n  bw!\n  delfunc s:CompleteFunc3\n\n  \" In Vim9 script s: can be omitted\n  let lines =<< trim END\n      vim9script\n      var CompleteFunc4Args = []\n      def CompleteFunc4(findstart: bool, base: string): any\n        add(CompleteFunc4Args, [findstart, base])\n        return findstart ? 0 : []\n      enddef\n      set completefunc=CompleteFunc4\n      new\n      setline(1, 'script1')\n      feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n      assert_equal([[1, ''], [0, 'script1']], CompleteFunc4Args)\n      bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" invalid return value\n  let &completefunc = {a -> 'abc'}\n  call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set completefunc=(a,\\ b)\\ =>\\ g:CompleteFunc1(21,\\ a,\\ b)\n  new | only\n  let g:CompleteFunc1Args = []\n  call assert_fails('call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", \"x\")', 'E117:')\n  call assert_equal([], g:CompleteFunc1Args)\n\n  \" set 'completefunc' to a partial with dict. This used to cause a crash.\n  func SetCompleteFunc()\n    let params = {'complete': function('g:DictCompleteFunc')}\n    let &completefunc = params.complete\n  endfunc\n  func g:DictCompleteFunc(_) dict\n  endfunc\n  call SetCompleteFunc()\n  new\n  call SetCompleteFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set completefunc=\n  wincmd w\n  set completefunc=\n  %bw!\n  delfunc g:DictCompleteFunc\n  delfunc SetCompleteFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9CompleteFunc(callnr: number, findstart: number, base: string): any\n      add(g:Vim9completeFuncArgs, [callnr, findstart, base])\n      return findstart ? 0 : []\n    enddef\n\n    # Test for using a def function with completefunc\n    set completefunc=function('Vim9CompleteFunc',\\ [60])\n    new | only\n    setline(1, 'one')\n    g:Vim9completeFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    assert_equal([[60, 1, ''], [60, 0, 'one']], g:Vim9completeFuncArgs)\n    bw!\n\n    # Test for using a global function name\n    &completefunc = g:CompleteFunc2\n    new | only\n    setline(1, 'two')\n    g:CompleteFunc2Args = []\n    feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'two']], g:CompleteFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalCompleteFunc(findstart: number, base: string): any\n      add(g:LocalCompleteFuncArgs, [findstart, base])\n      return findstart ? 0 : []\n    enddef\n    &completefunc = LocalCompleteFunc\n    new | only\n    setline(1, 'three')\n    g:LocalCompleteFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'three']], g:LocalCompleteFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  set completefunc&\n  delfunc CompleteFunc1\n  delfunc CompleteFunc2\n  unlet g:CompleteFunc1Args g:CompleteFunc2Args\n  %bw!\nendfunc\n\n\" Test for different ways of setting the 'omnifunc' option\nfunc Test_omnifunc_callback()\n  func OmniFunc1(callnr, findstart, base)\n    call add(g:OmniFunc1Args, [a:callnr, a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  func OmniFunc2(findstart, base)\n    call add(g:OmniFunc2Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &omnifunc = 'g:OmniFunc2'\n    new\n    call setline(1, 'zero')\n    LET g:OmniFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'zero']], g:OmniFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set omnifunc=function('g:OmniFunc1',\\ [10])\n    new\n    call setline(1, 'one')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[10, 1, ''], [10, 0, 'one']], g:OmniFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'omnifunc'\n    VAR Fn = function('g:OmniFunc1', [11])\n    LET &omnifunc = Fn\n    new\n    call setline(1, 'two')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[11, 1, ''], [11, 0, 'two']], g:OmniFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'omnifunc'\n    LET Fn = function('g:OmniFunc1', [12])\n    LET &omnifunc = string(Fn)\n    new\n    call setline(1, 'two')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[12, 1, ''], [12, 0, 'two']], g:OmniFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set omnifunc=funcref('g:OmniFunc1',\\ [13])\n    new\n    call setline(1, 'three')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[13, 1, ''], [13, 0, 'three']], g:OmniFunc1Args)\n    bw!\n\n    #\" Use let to set 'omnifunc' to a funcref\n    LET Fn = funcref('g:OmniFunc1', [14])\n    LET &omnifunc = Fn\n    new\n    call setline(1, 'four')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[14, 1, ''], [14, 0, 'four']], g:OmniFunc1Args)\n    bw!\n\n    #\" Using a string(funcref) to set 'omnifunc'\n    LET Fn = funcref(\"g:OmniFunc1\", [15])\n    LET &omnifunc = string(Fn)\n    new\n    call setline(1, 'four')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[15, 1, ''], [15, 0, 'four']], g:OmniFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a, b LMIDDLE g:OmniFunc1(16, a, b) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set omnifunc=\" .. optval\n    new\n    call setline(1, 'five')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[16, 1, ''], [16, 0, 'five']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a lambda expression\n    LET &omnifunc = LSTART a, b LMIDDLE g:OmniFunc1(17, a, b) LEND\n    new\n    call setline(1, 'six')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[17, 1, ''], [17, 0, 'six']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a string(lambda_expression)\n    LET &omnifunc = 'LSTART a, b LMIDDLE g:OmniFunc1(18, a, b) LEND'\n    new\n    call setline(1, 'six')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[18, 1, ''], [18, 0, 'six']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b LMIDDLE g:OmniFunc1(19, a, b) LEND\n    LET &omnifunc = Lambda\n    new\n    call setline(1, 'seven')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[19, 1, ''], [19, 0, 'seven']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b LMIDDLE g:OmniFunc1(20, a, b) LEND\n    LET &omnifunc = string(Lambda)\n    new\n    call setline(1, 'seven')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[20, 1, ''], [20, 0, 'seven']], g:OmniFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b LMIDDLE strlen(a) LEND\n    LET &omnifunc = Lambda\n    new\n    call setline(1, 'eight')\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    bw!\n\n    #\" Test for clearing the 'omnifunc' option\n    set omnifunc=''\n    set omnifunc&\n    call assert_fails(\"set omnifunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set omnifunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'omnifunc' to a non-existing function\n    set omnifunc=g:OmniFunc2\n    call setline(1, 'nine')\n    call assert_fails(\"set omnifunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &omnifunc = function('NonExistingFunc')\", 'E700:')\n    LET g:OmniFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'nine']], g:OmniFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:OmniFunc3(findstart, base)\n    call add(g:OmniFunc3Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  set omnifunc=s:OmniFunc3\n  new\n  call setline(1, 'script1')\n  let g:OmniFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script1']], g:OmniFunc3Args)\n  bw!\n\n  let &omnifunc = 's:OmniFunc3'\n  new\n  call setline(1, 'script2')\n  let g:OmniFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script2']], g:OmniFunc3Args)\n  bw!\n  delfunc s:OmniFunc3\n\n  \" invalid return value\n  let &omnifunc = {a -> 'abc'}\n  call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set omnifunc=(a,\\ b)\\ =>\\ OmniFunc1(21,\\ a,\\ b)\n  new | only\n  let g:OmniFunc1Args = []\n  call assert_fails('call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", \"x\")', 'E117:')\n  call assert_equal([], g:OmniFunc1Args)\n\n  \" set 'omnifunc' to a partial with dict. This used to cause a crash.\n  func SetOmniFunc()\n    let params = {'omni': function('g:DictOmniFunc')}\n    let &omnifunc = params.omni\n  endfunc\n  func g:DictOmniFunc(_) dict\n  endfunc\n  call SetOmniFunc()\n  new\n  call SetOmniFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set omnifunc=\n  wincmd w\n  set omnifunc=\n  %bw!\n  delfunc g:DictOmniFunc\n  delfunc SetOmniFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9omniFunc(callnr: number, findstart: number, base: string): any\n      add(g:Vim9omniFunc_Args, [callnr, findstart, base])\n      return findstart ? 0 : []\n    enddef\n\n    # Test for using a def function with omnifunc\n    set omnifunc=function('Vim9omniFunc',\\ [60])\n    new | only\n    setline(1, 'one')\n    g:Vim9omniFunc_Args = []\n    feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    assert_equal([[60, 1, ''], [60, 0, 'one']], g:Vim9omniFunc_Args)\n    bw!\n\n    # Test for using a global function name\n    &omnifunc = g:OmniFunc2\n    new | only\n    setline(1, 'two')\n    g:OmniFunc2Args = []\n    feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'two']], g:OmniFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalOmniFunc(findstart: number, base: string): any\n      add(g:LocalOmniFuncArgs, [findstart, base])\n      return findstart ? 0 : []\n    enddef\n    &omnifunc = LocalOmniFunc\n    new | only\n    setline(1, 'three')\n    g:LocalOmniFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'three']], g:LocalOmniFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  set omnifunc&\n  delfunc OmniFunc1\n  delfunc OmniFunc2\n  unlet g:OmniFunc1Args g:OmniFunc2Args\n  %bw!\nendfunc\n\n\" Test for different ways of setting the 'thesaurusfunc' option\nfunc Test_thesaurusfunc_callback()\n  func TsrFunc1(callnr, findstart, base)\n    call add(g:TsrFunc1Args, [a:callnr, a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  func TsrFunc2(findstart, base)\n    call add(g:TsrFunc2Args, [a:findstart, a:base])\n    return a:findstart ? 0 : ['sunday']\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &thesaurusfunc = 'g:TsrFunc2'\n    new\n    call setline(1, 'zero')\n    LET g:TsrFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'zero']], g:TsrFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set thesaurusfunc=function('g:TsrFunc1',\\ [10])\n    new\n    call setline(1, 'one')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[10, 1, ''], [10, 0, 'one']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'thesaurusfunc'\n    VAR Fn = function('g:TsrFunc1', [11])\n    LET &thesaurusfunc = Fn\n    new\n    call setline(1, 'two')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[11, 1, ''], [11, 0, 'two']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'thesaurusfunc'\n    LET Fn = function('g:TsrFunc1', [12])\n    LET &thesaurusfunc = string(Fn)\n    new\n    call setline(1, 'two')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[12, 1, ''], [12, 0, 'two']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set thesaurusfunc=funcref('g:TsrFunc1',\\ [13])\n    new\n    call setline(1, 'three')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[13, 1, ''], [13, 0, 'three']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'thesaurusfunc'\n    LET Fn = funcref('g:TsrFunc1', [14])\n    LET &thesaurusfunc = Fn\n    new\n    call setline(1, 'four')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[14, 1, ''], [14, 0, 'four']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'thesaurusfunc'\n    LET Fn = funcref('g:TsrFunc1', [15])\n    LET &thesaurusfunc = string(Fn)\n    new\n    call setline(1, 'four')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[15, 1, ''], [15, 0, 'four']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function\n    VAR optval = \"LSTART a, b LMIDDLE g:TsrFunc1(16, a, b) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set thesaurusfunc=\" .. optval\n    new\n    call setline(1, 'five')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[16, 1, ''], [16, 0, 'five']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with set\n    LET &thesaurusfunc = LSTART a, b LMIDDLE g:TsrFunc1(17, a, b) LEND\n    new\n    call setline(1, 'six')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[17, 1, ''], [17, 0, 'six']], g:TsrFunc1Args)\n    bw!\n\n    #\" Set 'thesaurusfunc' to a string(lambda expression)\n    LET &thesaurusfunc = 'LSTART a, b LMIDDLE g:TsrFunc1(18, a, b) LEND'\n    new\n    call setline(1, 'six')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[18, 1, ''], [18, 0, 'six']], g:TsrFunc1Args)\n    bw!\n\n    #\" Set 'thesaurusfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b LMIDDLE g:TsrFunc1(19, a, b) LEND\n    LET &thesaurusfunc = Lambda\n    new\n    call setline(1, 'seven')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[19, 1, ''], [19, 0, 'seven']], g:TsrFunc1Args)\n    bw!\n\n    #\" Set 'thesaurusfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b LMIDDLE g:TsrFunc1(20, a, b) LEND\n    LET &thesaurusfunc = string(Lambda)\n    new\n    call setline(1, 'seven')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[20, 1, ''], [20, 0, 'seven']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b LMIDDLE strlen(a) LEND\n    LET &thesaurusfunc = Lambda\n    new\n    call setline(1, 'eight')\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    bw!\n\n    #\" Test for clearing the 'thesaurusfunc' option\n    set thesaurusfunc=''\n    set thesaurusfunc&\n    call assert_fails(\"set thesaurusfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set thesaurusfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'thesaurusfunc' to a non-existing function\n    set thesaurusfunc=g:TsrFunc2\n    call setline(1, 'ten')\n    call assert_fails(\"set thesaurusfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &thesaurusfunc = function('NonExistingFunc')\", 'E700:')\n    LET g:TsrFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'ten']], g:TsrFunc2Args)\n    bw!\n\n    #\" Use a buffer-local value and a global value\n    set thesaurusfunc&\n    setlocal thesaurusfunc=function('g:TsrFunc1',\\ [22])\n    call setline(1, 'sun')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")\n    call assert_equal('sun', getline(1))\n    call assert_equal([[22, 1, ''], [22, 0, 'sun']], g:TsrFunc1Args)\n    new\n    call setline(1, 'sun')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")\n    call assert_equal('sun', getline(1))\n    call assert_equal([], g:TsrFunc1Args)\n    set thesaurusfunc=function('g:TsrFunc1',\\ [23])\n    wincmd w\n    call setline(1, 'sun')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")\n    call assert_equal('sun', getline(1))\n    call assert_equal([[22, 1, ''], [22, 0, 'sun']], g:TsrFunc1Args)\n    :%bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TsrFunc3(findstart, base)\n    call add(g:TsrFunc3Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  set tsrfu=s:TsrFunc3\n  new\n  call setline(1, 'script1')\n  let g:TsrFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script1']], g:TsrFunc3Args)\n  bw!\n\n  let &tsrfu = 's:TsrFunc3'\n  new\n  call setline(1, 'script2')\n  let g:TsrFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script2']], g:TsrFunc3Args)\n  bw!\n  delfunc s:TsrFunc3\n\n  \" invalid return value\n  let &thesaurusfunc = {a -> 'abc'}\n  call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set thesaurusfunc=(a,\\ b)\\ =>\\ TsrFunc1(21,\\ a,\\ b)\n  new | only\n  let g:TsrFunc1Args = []\n  call assert_fails('call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")', 'E117:')\n  call assert_equal([], g:TsrFunc1Args)\n  bw!\n\n  \" set 'thesaurusfunc' to a partial with dict. This used to cause a crash.\n  func SetTsrFunc()\n    let params = {'thesaurus': function('g:DictTsrFunc')}\n    let &thesaurusfunc = params.thesaurus\n  endfunc\n  func g:DictTsrFunc(_) dict\n  endfunc\n  call SetTsrFunc()\n  new\n  call SetTsrFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set thesaurusfunc=\n  wincmd w\n  %bw!\n  delfunc SetTsrFunc\n\n  \" set buffer-local 'thesaurusfunc' to a partial with dict. This used to\n  \" cause a crash.\n  func SetLocalTsrFunc()\n    let params = {'thesaurus': function('g:DictTsrFunc')}\n    let &l:thesaurusfunc = params.thesaurus\n  endfunc\n  call SetLocalTsrFunc()\n  call test_garbagecollect_now()\n  call SetLocalTsrFunc()\n  set thesaurusfunc=\n  bw!\n  delfunc g:DictTsrFunc\n  delfunc SetLocalTsrFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9tsrFunc(callnr: number, findstart: number, base: string): any\n      add(g:Vim9tsrFunc_Args, [callnr, findstart, base])\n      return findstart ? 0 : []\n    enddef\n\n    # Test for using a def function with thesaurusfunc\n    set thesaurusfunc=function('Vim9tsrFunc',\\ [60])\n    new | only\n    setline(1, 'one')\n    g:Vim9tsrFunc_Args = []\n    feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    assert_equal([[60, 1, ''], [60, 0, 'one']], g:Vim9tsrFunc_Args)\n    bw!\n\n    # Test for using a global function name\n    &thesaurusfunc = g:TsrFunc2\n    new | only\n    setline(1, 'two')\n    g:TsrFunc2Args = []\n    feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'two']], g:TsrFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalTsrFunc(findstart: number, base: string): any\n      add(g:LocalTsrFuncArgs, [findstart, base])\n      return findstart ? 0 : []\n    enddef\n    &thesaurusfunc = LocalTsrFunc\n    new | only\n    setline(1, 'three')\n    g:LocalTsrFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'three']], g:LocalTsrFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  set thesaurusfunc&\n  delfunc TsrFunc1\n  delfunc TsrFunc2\n  unlet g:TsrFunc1Args g:TsrFunc2Args\n  %bw!\nendfunc\n\nfunc FooBarComplete(findstart, base)\n  if a:findstart\n    return col('.') - 1\n  else\n    return [\"Foo\", \"Bar\", \"}\"]\n  endif\nendfunc\n\nfunc Test_complete_smartindent()\n  new\n  setlocal smartindent completefunc=FooBarComplete\n\n  exe \"norm! o{\\<cr>\\<c-x>\\<c-u>\\<c-p>}\\<cr>\\<esc>\"\n  let result = getline(1,'$')\n  call assert_equal(['', '{','}',''], result)\n  bw!\n  delfunction! FooBarComplete\nendfunc\n\nfunc Test_complete_overrun()\n  \" this was going past the end of the copied text\n  new\n  sil norm si\u0094\u00140\u0003s\u000f0\u0018\f\u0005\n  bwipe!\nendfunc\n\nfunc Test_infercase_very_long_line()\n  \" this was truncating the line when inferring case\n  new\n  let longLine = \"blah \"->repeat(300)\n  let verylongLine = \"blah \"->repeat(400)\n  call setline(1, verylongLine)\n  call setline(2, longLine)\n  set ic infercase\n  exe \"normal 2Go\\<C-X>\\<C-L>\\<Esc>\"\n  call assert_equal(longLine, getline(3))\n\n  \" check that the too long text is NUL terminated\n  %del\n  norm o\n  norm 1987ax\n  exec \"norm ox\\<C-X>\\<C-L>\"\n  call assert_equal(repeat('x', 1987), getline(3))\n\n  bwipe!\n  set noic noinfercase\nendfunc\n\nfunc Test_ins_complete_add()\n  \" this was reading past the end of allocated memory\n  new\n  norm o\u007f\n  norm 7o\u0080\u0080\n  sil! norm o\u0010\u0018\u0010\u0018\u0010\n\n  bwipe!\nendfunc\n\nfunc Test_ins_complete_end_of_line()\n  \" this was reading past the end of the line\n  new  \n  norm 8o\u0080\u00fd\u00a0\n  sil! norm o\u0010\u0018\u0010\u0018\u0010\n\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * insexpand.c: functions for Insert mode completion\n */\n\n#include \"vim.h\"\n\n/*\n * Definitions used for CTRL-X submode.\n * Note: If you change CTRL-X submode, you must also maintain ctrl_x_msgs[] and\n * ctrl_x_mode_names[] below.\n */\n# define CTRL_X_WANT_IDENT\t0x100\n\n# define CTRL_X_NORMAL\t\t0  // CTRL-N CTRL-P completion, default\n# define CTRL_X_NOT_DEFINED_YET\t1\n# define CTRL_X_SCROLL\t\t2\n# define CTRL_X_WHOLE_LINE\t3\n# define CTRL_X_FILES\t\t4\n# define CTRL_X_TAGS\t\t(5 + CTRL_X_WANT_IDENT)\n# define CTRL_X_PATH_PATTERNS\t(6 + CTRL_X_WANT_IDENT)\n# define CTRL_X_PATH_DEFINES\t(7 + CTRL_X_WANT_IDENT)\n# define CTRL_X_FINISHED\t\t8\n# define CTRL_X_DICTIONARY\t(9 + CTRL_X_WANT_IDENT)\n# define CTRL_X_THESAURUS\t(10 + CTRL_X_WANT_IDENT)\n# define CTRL_X_CMDLINE\t\t11\n# define CTRL_X_FUNCTION\t12\n# define CTRL_X_OMNI\t\t13\n# define CTRL_X_SPELL\t\t14\n# define CTRL_X_LOCAL_MSG\t15\t// only used in \"ctrl_x_msgs\"\n# define CTRL_X_EVAL\t\t16\t// for builtin function complete()\n# define CTRL_X_CMDLINE_CTRL_X\t17\t// CTRL-X typed in CTRL_X_CMDLINE\n\n# define CTRL_X_MSG(i) ctrl_x_msgs[(i) & ~CTRL_X_WANT_IDENT]\n\n// Message for CTRL-X mode, index is ctrl_x_mode.\nstatic char *ctrl_x_msgs[] =\n{\n    N_(\" Keyword completion (^N^P)\"), // CTRL_X_NORMAL, ^P/^N compl.\n    N_(\" ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)\"),\n    NULL, // CTRL_X_SCROLL: depends on state\n    N_(\" Whole line completion (^L^N^P)\"),\n    N_(\" File name completion (^F^N^P)\"),\n    N_(\" Tag completion (^]^N^P)\"),\n    N_(\" Path pattern completion (^N^P)\"),\n    N_(\" Definition completion (^D^N^P)\"),\n    NULL, // CTRL_X_FINISHED\n    N_(\" Dictionary completion (^K^N^P)\"),\n    N_(\" Thesaurus completion (^T^N^P)\"),\n    N_(\" Command-line completion (^V^N^P)\"),\n    N_(\" User defined completion (^U^N^P)\"),\n    N_(\" Omni completion (^O^N^P)\"),\n    N_(\" Spelling suggestion (s^N^P)\"),\n    N_(\" Keyword Local completion (^N^P)\"),\n    NULL,   // CTRL_X_EVAL doesn't use msg.\n    N_(\" Command-line completion (^V^N^P)\"),\n};\n\n#if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL)\nstatic char *ctrl_x_mode_names[] = {\n\t\"keyword\",\n\t\"ctrl_x\",\n\t\"scroll\",\n\t\"whole_line\",\n\t\"files\",\n\t\"tags\",\n\t\"path_patterns\",\n\t\"path_defines\",\n\t\"unknown\",\t    // CTRL_X_FINISHED\n\t\"dictionary\",\n\t\"thesaurus\",\n\t\"cmdline\",\n\t\"function\",\n\t\"omni\",\n\t\"spell\",\n\tNULL,\t\t    // CTRL_X_LOCAL_MSG only used in \"ctrl_x_msgs\"\n\t\"eval\",\n\t\"cmdline\",\n};\n#endif\n\n/*\n * Array indexes used for cp_text[].\n */\n#define CPT_ABBR\t0\t// \"abbr\"\n#define CPT_MENU\t1\t// \"menu\"\n#define CPT_KIND\t2\t// \"kind\"\n#define CPT_INFO\t3\t// \"info\"\n#define CPT_COUNT\t4\t// Number of entries\n\n/*\n * Structure used to store one match for insert completion.\n */\ntypedef struct compl_S compl_T;\nstruct compl_S\n{\n    compl_T\t*cp_next;\n    compl_T\t*cp_prev;\n    char_u\t*cp_str;\t// matched text\n    char_u\t*(cp_text[CPT_COUNT]);\t// text for the menu\n#ifdef FEAT_EVAL\n    typval_T\tcp_user_data;\n#endif\n    char_u\t*cp_fname;\t// file containing the match, allocated when\n\t\t\t\t// cp_flags has CP_FREE_FNAME\n    int\t\tcp_flags;\t// CP_ values\n    int\t\tcp_number;\t// sequence number\n};\n\n// values for cp_flags\n# define CP_ORIGINAL_TEXT   1\t// the original text when the expansion begun\n# define CP_FREE_FNAME\t    2\t// cp_fname is allocated\n# define CP_CONT_S_IPOS\t    4\t// use CONT_S_IPOS for compl_cont_status\n# define CP_EQUAL\t    8\t// ins_compl_equal() always returns TRUE\n# define CP_ICASE\t    16\t// ins_compl_equal() ignores case\n# define CP_FAST\t    32\t// use fast_breakcheck instead of ui_breakcheck\n\nstatic char e_hitend[] = N_(\"Hit end of paragraph\");\n\n/*\n * All the current matches are stored in a list.\n * \"compl_first_match\" points to the start of the list.\n * \"compl_curr_match\" points to the currently selected entry.\n * \"compl_shown_match\" is different from compl_curr_match during\n * ins_compl_get_exp().\n * \"compl_old_match\" points to previous \"compl_curr_match\".\n */\nstatic compl_T    *compl_first_match = NULL;\nstatic compl_T    *compl_curr_match = NULL;\nstatic compl_T    *compl_shown_match = NULL;\nstatic compl_T    *compl_old_match = NULL;\n\n// After using a cursor key <Enter> selects a match in the popup menu,\n// otherwise it inserts a line break.\nstatic int\t  compl_enter_selects = FALSE;\n\n// When \"compl_leader\" is not NULL only matches that start with this string\n// are used.\nstatic char_u\t  *compl_leader = NULL;\n\nstatic int\t  compl_get_longest = FALSE;\t// put longest common string\n\t\t\t\t\t\t// in compl_leader\n\nstatic int\t  compl_no_insert = FALSE;\t// FALSE: select & insert\n\t\t\t\t\t\t// TRUE: noinsert\nstatic int\t  compl_no_select = FALSE;\t// FALSE: select & insert\n\t\t\t\t\t\t// TRUE: noselect\nstatic int\t  compl_longest = FALSE;\t// FALSE: insert full match\n\t\t\t\t\t\t// TRUE: insert longest prefix\n\n// Selected one of the matches.  When FALSE the match was edited or using the\n// longest common string.\nstatic int\t  compl_used_match;\n\n// didn't finish finding completions.\nstatic int\t  compl_was_interrupted = FALSE;\n\n// Set when character typed while looking for matches and it means we should\n// stop looking for matches.\nstatic int\t  compl_interrupted = FALSE;\n\nstatic int\t  compl_restarting = FALSE;\t// don't insert match\n\n// When the first completion is done \"compl_started\" is set.  When it's\n// FALSE the word to be completed must be located.\nstatic int\t  compl_started = FALSE;\n\n// Which Ctrl-X mode are we in?\nstatic int\t  ctrl_x_mode = CTRL_X_NORMAL;\n\nstatic int\t  compl_matches = 0;\t    // number of completion matches\nstatic char_u\t  *compl_pattern = NULL;\nstatic int\t  compl_direction = FORWARD;\nstatic int\t  compl_shows_dir = FORWARD;\nstatic int\t  compl_pending = 0;\t    // > 1 for postponed CTRL-N\nstatic pos_T\t  compl_startpos;\n// Length in bytes of the text being completed (this is deleted to be replaced\n// by the match.)\nstatic int\t  compl_length = 0;\nstatic colnr_T\t  compl_col = 0;\t    // column where the text starts\n\t\t\t\t\t    // that is being completed\nstatic char_u\t  *compl_orig_text = NULL;  // text as it was before\n\t\t\t\t\t    // completion started\nstatic int\t  compl_cont_mode = 0;\nstatic expand_T\t  compl_xp;\n\n// List of flags for method of completion.\nstatic int\t  compl_cont_status = 0;\n# define CONT_ADDING\t1\t// \"normal\" or \"adding\" expansion\n# define CONT_INTRPT\t(2 + 4)\t// a ^X interrupted the current expansion\n\t\t\t\t// it's set only iff N_ADDS is set\n# define CONT_N_ADDS\t4\t// next ^X<> will add-new or expand-current\n# define CONT_S_IPOS\t8\t// next ^X<> will set initial_pos?\n\t\t\t\t// if so, word-wise-expansion will set SOL\n# define CONT_SOL\t16\t// pattern includes start of line, just for\n\t\t\t\t// word-wise expansion, not set for ^X^L\n# define CONT_LOCAL\t32\t// for ctrl_x_mode 0, ^X^P/^X^N do a local\n\t\t\t\t// expansion, (eg use complete=.)\n\nstatic int\t  compl_opt_refresh_always = FALSE;\nstatic int\t  compl_opt_suppress_empty = FALSE;\n\nstatic int ins_compl_add(char_u *str, int len, char_u *fname, char_u **cptext, typval_T *user_data, int cdir, int flags, int adup);\nstatic void ins_compl_longest_match(compl_T *match);\nstatic void ins_compl_del_pum(void);\nstatic void ins_compl_files(int count, char_u **files, int thesaurus, int flags, regmatch_T *regmatch, char_u *buf, int *dir);\nstatic char_u *find_line_end(char_u *ptr);\nstatic void ins_compl_free(void);\nstatic int  ins_compl_need_restart(void);\nstatic void ins_compl_new_leader(void);\nstatic int  get_compl_len(void);\nstatic void ins_compl_restart(void);\nstatic void ins_compl_set_original_text(char_u *str);\nstatic void ins_compl_fixRedoBufForLeader(char_u *ptr_arg);\n# if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL)\nstatic void ins_compl_add_list(list_T *list);\nstatic void ins_compl_add_dict(dict_T *dict);\n# endif\nstatic int  ins_compl_key2dir(int c);\nstatic int  ins_compl_pum_key(int c);\nstatic int  ins_compl_key2count(int c);\nstatic void show_pum(int prev_w_wrow, int prev_w_leftcol);\nstatic unsigned  quote_meta(char_u *dest, char_u *str, int len);\n\n#ifdef FEAT_SPELL\nstatic void spell_back_to_badword(void);\nstatic int  spell_bad_len = 0;\t// length of located bad word\n#endif\n\n/*\n * CTRL-X pressed in Insert mode.\n */\n    void\nins_ctrl_x(void)\n{\n    if (!ctrl_x_mode_cmdline())\n    {\n\t// if the next ^X<> won't ADD nothing, then reset compl_cont_status\n\tif (compl_cont_status & CONT_N_ADDS)\n\t    compl_cont_status |= CONT_INTRPT;\n\telse\n\t    compl_cont_status = 0;\n\t// We're not sure which CTRL-X mode it will be yet\n\tctrl_x_mode = CTRL_X_NOT_DEFINED_YET;\n\tedit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));\n\tedit_submode_pre = NULL;\n\tshowmode();\n    }\n    else\n\t// CTRL-X in CTRL-X CTRL-V mode behaves differently to make CTRL-X\n\t// CTRL-V look like CTRL-N\n\tctrl_x_mode = CTRL_X_CMDLINE_CTRL_X;\n\n    may_trigger_modechanged();\n}\n\n/*\n * Functions to check the current CTRL-X mode.\n */\nint ctrl_x_mode_none(void) { return ctrl_x_mode == 0; }\nint ctrl_x_mode_normal(void) { return ctrl_x_mode == CTRL_X_NORMAL; }\nint ctrl_x_mode_scroll(void) { return ctrl_x_mode == CTRL_X_SCROLL; }\nint ctrl_x_mode_whole_line(void) { return ctrl_x_mode == CTRL_X_WHOLE_LINE; }\nint ctrl_x_mode_files(void) { return ctrl_x_mode == CTRL_X_FILES; }\nint ctrl_x_mode_tags(void) { return ctrl_x_mode == CTRL_X_TAGS; }\nint ctrl_x_mode_path_patterns(void) {\n\t\t\t\t  return ctrl_x_mode == CTRL_X_PATH_PATTERNS; }\nint ctrl_x_mode_path_defines(void) {\n\t\t\t\t   return ctrl_x_mode == CTRL_X_PATH_DEFINES; }\nint ctrl_x_mode_dictionary(void) { return ctrl_x_mode == CTRL_X_DICTIONARY; }\nint ctrl_x_mode_thesaurus(void) { return ctrl_x_mode == CTRL_X_THESAURUS; }\nint ctrl_x_mode_cmdline(void) {\n\treturn ctrl_x_mode == CTRL_X_CMDLINE\n\t\t|| ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X; }\nint ctrl_x_mode_function(void) { return ctrl_x_mode == CTRL_X_FUNCTION; }\nint ctrl_x_mode_omni(void) { return ctrl_x_mode == CTRL_X_OMNI; }\nint ctrl_x_mode_spell(void) { return ctrl_x_mode == CTRL_X_SPELL; }\nstatic int ctrl_x_mode_eval(void) { return ctrl_x_mode == CTRL_X_EVAL; }\nint ctrl_x_mode_line_or_eval(void) {\n       return ctrl_x_mode == CTRL_X_WHOLE_LINE || ctrl_x_mode == CTRL_X_EVAL; }\n\n/*\n * Whether other than default completion has been selected.\n */\n    int\nctrl_x_mode_not_default(void)\n{\n    return ctrl_x_mode != CTRL_X_NORMAL;\n}\n\n/*\n * Whether CTRL-X was typed without a following character,\n * not including when in CTRL-X CTRL-V mode.\n */\n    int\nctrl_x_mode_not_defined_yet(void)\n{\n    return ctrl_x_mode == CTRL_X_NOT_DEFINED_YET;\n}\n\n/*\n * Return TRUE if currently in \"normal\" or \"adding\" insert completion matches\n * state\n */\n    int\ncompl_status_adding(void)\n{\n    return compl_cont_status & CONT_ADDING;\n}\n\n/*\n * Return TRUE if the completion pattern includes start of line, just for\n * word-wise expansion.\n */\n    int\ncompl_status_sol(void)\n{\n    return compl_cont_status & CONT_SOL;\n}\n\n/*\n * Return TRUE if ^X^P/^X^N will do a local completion (i.e. use complete=.)\n */\n    int\ncompl_status_local(void)\n{\n    return compl_cont_status & CONT_LOCAL;\n}\n\n/*\n * Clear the completion status flags\n */\n    void\ncompl_status_clear(void)\n{\n    compl_cont_status = 0;\n}\n\n/*\n * Return TRUE if completion is using the forward direction matches\n */\n    static int\ncompl_dir_forward(void)\n{\n    return compl_direction == FORWARD;\n}\n\n/*\n * Return TRUE if currently showing forward completion matches\n */\n    static int\ncompl_shows_dir_forward(void)\n{\n    return compl_shows_dir == FORWARD;\n}\n\n/*\n * Return TRUE if currently showing backward completion matches\n */\n    static int\ncompl_shows_dir_backward(void)\n{\n    return compl_shows_dir == BACKWARD;\n}\n\n/*\n * Return TRUE if the 'dictionary' or 'thesaurus' option can be used.\n */\n    int\nhas_compl_option(int dict_opt)\n{\n    if (dict_opt ? (*curbuf->b_p_dict == NUL && *p_dict == NUL\n#ifdef FEAT_SPELL\n\t\t\t\t\t\t\t&& !curwin->w_p_spell\n#endif\n\t\t\t\t\t\t\t)\n\t\t : (*curbuf->b_p_tsr == NUL && *p_tsr == NUL\n#ifdef FEAT_COMPL_FUNC\n\t\t     && *curbuf->b_p_tsrfu == NUL && *p_tsrfu == NUL\n#endif\n\t\t   ))\n    {\n\tctrl_x_mode = CTRL_X_NORMAL;\n\tedit_submode = NULL;\n\tmsg_attr(dict_opt ? _(\"'dictionary' option is empty\")\n\t\t\t  : _(\"'thesaurus' option is empty\"),\n\t\t\t\t\t\t\t      HL_ATTR(HLF_E));\n\tif (emsg_silent == 0 && !in_assert_fails)\n\t{\n\t    vim_beep(BO_COMPL);\n\t    setcursor();\n\t    out_flush();\n#ifdef FEAT_EVAL\n\t    if (!get_vim_var_nr(VV_TESTING))\n#endif\n\t\tui_delay(2004L, FALSE);\n\t}\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Is the character \"c\" a valid key to go to or keep us in CTRL-X mode?\n * This depends on the current mode.\n */\n    int\nvim_is_ctrl_x_key(int c)\n{\n    // Always allow ^R - let its results then be checked\n    if (c == Ctrl_R)\n\treturn TRUE;\n\n    // Accept <PageUp> and <PageDown> if the popup menu is visible.\n    if (ins_compl_pum_key(c))\n\treturn TRUE;\n\n    switch (ctrl_x_mode)\n    {\n\tcase 0:\t\t    // Not in any CTRL-X mode\n\t    return (c == Ctrl_N || c == Ctrl_P || c == Ctrl_X);\n\tcase CTRL_X_NOT_DEFINED_YET:\n\tcase CTRL_X_CMDLINE_CTRL_X:\n\t    return (   c == Ctrl_X || c == Ctrl_Y || c == Ctrl_E\n\t\t    || c == Ctrl_L || c == Ctrl_F || c == Ctrl_RSB\n\t\t    || c == Ctrl_I || c == Ctrl_D || c == Ctrl_P\n\t\t    || c == Ctrl_N || c == Ctrl_T || c == Ctrl_V\n\t\t    || c == Ctrl_Q || c == Ctrl_U || c == Ctrl_O\n\t\t    || c == Ctrl_S || c == Ctrl_K || c == 's'\n\t\t    || c == Ctrl_Z);\n\tcase CTRL_X_SCROLL:\n\t    return (c == Ctrl_Y || c == Ctrl_E);\n\tcase CTRL_X_WHOLE_LINE:\n\t    return (c == Ctrl_L || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_FILES:\n\t    return (c == Ctrl_F || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_DICTIONARY:\n\t    return (c == Ctrl_K || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_THESAURUS:\n\t    return (c == Ctrl_T || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_TAGS:\n\t    return (c == Ctrl_RSB || c == Ctrl_P || c == Ctrl_N);\n#ifdef FEAT_FIND_ID\n\tcase CTRL_X_PATH_PATTERNS:\n\t    return (c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_PATH_DEFINES:\n\t    return (c == Ctrl_D || c == Ctrl_P || c == Ctrl_N);\n#endif\n\tcase CTRL_X_CMDLINE:\n\t    return (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_P || c == Ctrl_N\n\t\t    || c == Ctrl_X);\n#ifdef FEAT_COMPL_FUNC\n\tcase CTRL_X_FUNCTION:\n\t    return (c == Ctrl_U || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_OMNI:\n\t    return (c == Ctrl_O || c == Ctrl_P || c == Ctrl_N);\n#endif\n\tcase CTRL_X_SPELL:\n\t    return (c == Ctrl_S || c == Ctrl_P || c == Ctrl_N);\n\tcase CTRL_X_EVAL:\n\t    return (c == Ctrl_P || c == Ctrl_N);\n    }\n    internal_error(\"vim_is_ctrl_x_key()\");\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"match\" is the original text when the completion began.\n */\n    static int\nmatch_at_original_text(compl_T *match)\n{\n    return match->cp_flags & CP_ORIGINAL_TEXT;\n}\n\n/*\n * Returns TRUE if \"match\" is the first match in the completion list.\n */\n    static int\nis_first_match(compl_T *match)\n{\n    return match == compl_first_match;\n}\n\n/*\n * Return TRUE when character \"c\" is part of the item currently being\n * completed.  Used to decide whether to abandon complete mode when the menu\n * is visible.\n */\n    int\nins_compl_accept_char(int c)\n{\n    if (ctrl_x_mode & CTRL_X_WANT_IDENT)\n\t// When expanding an identifier only accept identifier chars.\n\treturn vim_isIDc(c);\n\n    switch (ctrl_x_mode)\n    {\n\tcase CTRL_X_FILES:\n\t    // When expanding file name only accept file name chars. But not\n\t    // path separators, so that \"proto/<Tab>\" expands files in\n\t    // \"proto\", not \"proto/\" as a whole\n\t    return vim_isfilec(c) && !vim_ispathsep(c);\n\n\tcase CTRL_X_CMDLINE:\n\tcase CTRL_X_CMDLINE_CTRL_X:\n\tcase CTRL_X_OMNI:\n\t    // Command line and Omni completion can work with just about any\n\t    // printable character, but do stop at white space.\n\t    return vim_isprintc(c) && !VIM_ISWHITE(c);\n\n\tcase CTRL_X_WHOLE_LINE:\n\t    // For while line completion a space can be part of the line.\n\t    return vim_isprintc(c);\n    }\n    return vim_iswordc(c);\n}\n\n/*\n * Get the completed text by inferring the case of the originally typed text.\n * If the result is in allocated memory \"tofree\" is set to it.\n */\n    static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    *p = NUL;\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}\n\n/*\n * This is like ins_compl_add(), but if 'ic' and 'inf' are set, then the\n * case of the originally typed text is used, and the case of the completed\n * text is inferred, ie this tries to work out what case you probably wanted\n * the rest of the word to be in -- webb\n */\n    int\nins_compl_add_infercase(\n    char_u\t*str_arg,\n    int\t\tlen,\n    int\t\ticase,\n    char_u\t*fname,\n    int\t\tdir,\n    int\t\tcont_s_ipos)  // next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tchar_len;\t\t// count multi-byte characters\n    int\t\tcompl_char_len;\n    int\t\tmin_len;\n    int\t\tflags = 0;\n    int\t\tres;\n    char_u\t*tofree = NULL;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t// Infer case of completed part.\n\n\t// Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++char_len;\n\t    }\n\t}\n\telse\n\t    char_len = len;\n\n\t// Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    compl_char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++compl_char_len;\n\t    }\n\t}\n\telse\n\t    compl_char_len = compl_length;\n\n\t// \"char_len\" may be smaller than \"compl_char_len\" when using\n\t// thesaurus, only use the minimum when comparing.\n\tmin_len = char_len < compl_char_len ? char_len : compl_char_len;\n\n\tstr = ins_compl_infercase_gettext(str, char_len,\n\t\t\t\t\t  compl_char_len, min_len, &tofree);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n    vim_free(tofree);\n    return res;\n}\n\n/*\n * Add a match to the list of matches. The arguments are:\n *     str       - text of the match to add\n *     len       - length of \"str\". If -1, then the length of \"str\" is\n *\t\t   computed.\n *     fname     - file name to associate with this match.\n *     cptext    - list of strings to use with this match (for abbr, menu, info\n *\t\t   and kind)\n *     user_data - user supplied data (any vim type) for this match\n *     cdir\t - match direction. If 0, use \"compl_direction\".\n *     flags_arg - match flags (cp_flags)\n *     adup\t - accept this match even if it is already present.\n * If \"cdir\" is FORWARD, then the match is added after the current match.\n * Otherwise, it is added before the current match.\n *\n * If the given string is already in the list of completions, then return\n * NOTDONE, otherwise add it to the list and return OK.  If there is an error,\n * maybe because alloc() returns NULL, then FAIL is returned.\n */\n    static int\nins_compl_add(\n    char_u\t*str,\n    int\t\tlen,\n    char_u\t*fname,\n    char_u\t**cptext,\t    // extra text for popup menu or NULL\n    typval_T\t*user_data UNUSED,  // \"user_data\" entry or NULL\n    int\t\tcdir,\n    int\t\tflags_arg,\n    int\t\tadup)\t\t// accept duplicate match\n{\n    compl_T\t*match;\n    int\t\tdir = (cdir == 0 ? compl_direction : cdir);\n    int\t\tflags = flags_arg;\n\n    if (flags & CP_FAST)\n\tfast_breakcheck();\n    else\n\tui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // If the same match is already present, don't add it.\n    if (compl_first_match != NULL && !adup)\n    {\n\tmatch = compl_first_match;\n\tdo\n\t{\n\t    if (!match_at_original_text(match)\n\t\t    && STRNCMP(match->cp_str, str, len) == 0\n\t\t    && ((int)STRLEN(match->cp_str) <= len\n\t\t\t\t\t\t || match->cp_str[len] == NUL))\n\t\treturn NOTDONE;\n\t    match = match->cp_next;\n\t} while (match != NULL && !is_first_match(match));\n    }\n\n    // Remove any popup menu before changing the list of matches.\n    ins_compl_del_pum();\n\n    // Allocate a new match structure.\n    // Copy the values to the new match structure.\n    match = ALLOC_CLEAR_ONE(compl_T);\n    if (match == NULL)\n\treturn FAIL;\n    match->cp_number = -1;\n    if (flags & CP_ORIGINAL_TEXT)\n\tmatch->cp_number = 0;\n    if ((match->cp_str = vim_strnsave(str, len)) == NULL)\n    {\n\tvim_free(match);\n\treturn FAIL;\n    }\n\n    // match-fname is:\n    // - compl_curr_match->cp_fname if it is a string equal to fname.\n    // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.\n    // - NULL otherwise.\t--Acevedo\n    if (fname != NULL\n\t    && compl_curr_match != NULL\n\t    && compl_curr_match->cp_fname != NULL\n\t    && STRCMP(fname, compl_curr_match->cp_fname) == 0)\n\tmatch->cp_fname = compl_curr_match->cp_fname;\n    else if (fname != NULL)\n    {\n\tmatch->cp_fname = vim_strsave(fname);\n\tflags |= CP_FREE_FNAME;\n    }\n    else\n\tmatch->cp_fname = NULL;\n    match->cp_flags = flags;\n\n    if (cptext != NULL)\n    {\n\tint i;\n\n\tfor (i = 0; i < CPT_COUNT; ++i)\n\t    if (cptext[i] != NULL && *cptext[i] != NUL)\n\t\tmatch->cp_text[i] = vim_strsave(cptext[i]);\n    }\n#ifdef FEAT_EVAL\n    if (user_data != NULL)\n\tmatch->cp_user_data = *user_data;\n#endif\n\n    // Link the new match structure after (FORWARD) or before (BACKWARD) the\n    // current match in the list of matches .\n    if (compl_first_match == NULL)\n\tmatch->cp_next = match->cp_prev = NULL;\n    else if (dir == FORWARD)\n    {\n\tmatch->cp_next = compl_curr_match->cp_next;\n\tmatch->cp_prev = compl_curr_match;\n    }\n    else\t// BACKWARD\n    {\n\tmatch->cp_next = compl_curr_match;\n\tmatch->cp_prev = compl_curr_match->cp_prev;\n    }\n    if (match->cp_next)\n\tmatch->cp_next->cp_prev = match;\n    if (match->cp_prev)\n\tmatch->cp_prev->cp_next = match;\n    else\t// if there's nothing before, it is the first match\n\tcompl_first_match = match;\n    compl_curr_match = match;\n\n    // Find the longest common string if still doing that.\n    if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0)\n\tins_compl_longest_match(match);\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"str[len]\" matches with match->cp_str, considering\n * match->cp_flags.\n */\n    static int\nins_compl_equal(compl_T *match, char_u *str, int len)\n{\n    if (match->cp_flags & CP_EQUAL)\n\treturn TRUE;\n    if (match->cp_flags & CP_ICASE)\n\treturn STRNICMP(match->cp_str, str, (size_t)len) == 0;\n    return STRNCMP(match->cp_str, str, (size_t)len) == 0;\n}\n\n/*\n * Reduce the longest common string for match \"match\".\n */\n    static void\nins_compl_longest_match(compl_T *match)\n{\n    char_u\t*p, *s;\n    int\t\tc1, c2;\n    int\t\thad_match;\n\n    if (compl_leader == NULL)\n    {\n\t// First match, use it as a whole.\n\tcompl_leader = vim_strsave(match->cp_str);\n\tif (compl_leader == NULL)\n\t    return;\n\n\thad_match = (curwin->w_cursor.col > compl_col);\n\tins_compl_delete();\n\tins_bytes(compl_leader + get_compl_len());\n\tins_redraw(FALSE);\n\n\t// When the match isn't there (to avoid matching itself) remove it\n\t// again after redrawing.\n\tif (!had_match)\n\t    ins_compl_delete();\n\tcompl_used_match = FALSE;\n\n\treturn;\n    }\n\n    // Reduce the text if this match differs from compl_leader.\n    p = compl_leader;\n    s = match->cp_str;\n    while (*p != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    c1 = mb_ptr2char(p);\n\t    c2 = mb_ptr2char(s);\n\t}\n\telse\n\t{\n\t    c1 = *p;\n\t    c2 = *s;\n\t}\n\tif ((match->cp_flags & CP_ICASE)\n\t\t? (MB_TOLOWER(c1) != MB_TOLOWER(c2)) : (c1 != c2))\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    MB_PTR_ADV(p);\n\t    MB_PTR_ADV(s);\n\t}\n\telse\n\t{\n\t    ++p;\n\t    ++s;\n\t}\n    }\n\n    if (*p != NUL)\n    {\n\t// Leader was shortened, need to change the inserted text.\n\t*p = NUL;\n\thad_match = (curwin->w_cursor.col > compl_col);\n\tins_compl_delete();\n\tins_bytes(compl_leader + get_compl_len());\n\tins_redraw(FALSE);\n\n\t// When the match isn't there (to avoid matching itself) remove it\n\t// again after redrawing.\n\tif (!had_match)\n\t    ins_compl_delete();\n    }\n\n    compl_used_match = FALSE;\n}\n\n/*\n * Add an array of matches to the list of matches.\n * Frees matches[].\n */\n    static void\nins_compl_add_matches(\n    int\t\tnum_matches,\n    char_u\t**matches,\n    int\t\ticase)\n{\n    int\t\ti;\n    int\t\tadd_r = OK;\n    int\t\tdir = compl_direction;\n\n    for (i = 0; i < num_matches && add_r != FAIL; i++)\n\tif ((add_r = ins_compl_add(matches[i], -1, NULL, NULL, NULL, dir,\n\t\t\t       CP_FAST | (icase ? CP_ICASE : 0), FALSE)) == OK)\n\t    // if dir was BACKWARD then honor it just once\n\t    dir = FORWARD;\n    FreeWild(num_matches, matches);\n}\n\n/*\n * Make the completion list cyclic.\n * Return the number of matches (excluding the original).\n */\n    static int\nins_compl_make_cyclic(void)\n{\n    compl_T *match;\n    int\t    count = 0;\n\n    if (compl_first_match == NULL)\n\treturn 0;\n\n    // Find the end of the list.\n    match = compl_first_match;\n    // there's always an entry for the compl_orig_text, it doesn't count.\n    while (match->cp_next != NULL && !is_first_match(match->cp_next))\n    {\n\tmatch = match->cp_next;\n\t++count;\n    }\n    match->cp_next = compl_first_match;\n    compl_first_match->cp_prev = match;\n\n    return count;\n}\n\n/*\n * Return whether there currently is a shown match.\n */\n    int\nins_compl_has_shown_match(void)\n{\n    return compl_shown_match == NULL\n\t|| compl_shown_match != compl_shown_match->cp_next;\n}\n\n/*\n * Return whether the shown match is long enough.\n */\n    int\nins_compl_long_shown_match(void)\n{\n    return (int)STRLEN(compl_shown_match->cp_str)\n\t\t\t\t\t    > curwin->w_cursor.col - compl_col;\n}\n\n/*\n * Set variables that store noselect and noinsert behavior from the\n * 'completeopt' value.\n */\n    void\ncompleteopt_was_set(void)\n{\n    compl_no_insert = FALSE;\n    compl_no_select = FALSE;\n    compl_longest = FALSE;\n    if (strstr((char *)p_cot, \"noselect\") != NULL)\n\tcompl_no_select = TRUE;\n    if (strstr((char *)p_cot, \"noinsert\") != NULL)\n\tcompl_no_insert = TRUE;\n    if (strstr((char *)p_cot, \"longest\") != NULL)\n\tcompl_longest = TRUE;\n}\n\n\n// \"compl_match_array\" points the currently displayed list of entries in the\n// popup menu.  It is NULL when there is no popup menu.\nstatic pumitem_T *compl_match_array = NULL;\nstatic int compl_match_arraysize;\n\n/*\n * Update the screen and when there is any scrolling remove the popup menu.\n */\n    static void\nins_compl_upd_pum(void)\n{\n    int\t\th;\n\n    if (compl_match_array == NULL)\n\treturn;\n\n    h = curwin->w_cline_height;\n    // Update the screen later, before drawing the popup menu over it.\n    pum_call_update_screen();\n    if (h != curwin->w_cline_height)\n\tins_compl_del_pum();\n}\n\n/*\n * Remove any popup menu.\n */\n    static void\nins_compl_del_pum(void)\n{\n    if (compl_match_array == NULL)\n\treturn;\n\n    pum_undisplay();\n    VIM_CLEAR(compl_match_array);\n}\n\n/*\n * Return TRUE if the popup menu should be displayed.\n */\n    int\npum_wanted(void)\n{\n    // 'completeopt' must contain \"menu\" or \"menuone\"\n    if (vim_strchr(p_cot, 'm') == NULL)\n\treturn FALSE;\n\n    // The display looks bad on a B&W display.\n    if (t_colors < 8\n#ifdef FEAT_GUI\n\t    && !gui.in_use\n#endif\n\t    )\n\treturn FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if there are two or more matches to be shown in the popup menu.\n * One if 'completopt' contains \"menuone\".\n */\n    static int\npum_enough_matches(void)\n{\n    compl_T     *compl;\n    int\t\ti;\n\n    // Don't display the popup menu if there are no matches or there is only\n    // one (ignoring the original text).\n    compl = compl_first_match;\n    i = 0;\n    do\n    {\n\tif (compl == NULL || (!match_at_original_text(compl) && ++i == 2))\n\t    break;\n\tcompl = compl->cp_next;\n    } while (!is_first_match(compl));\n\n    if (strstr((char *)p_cot, \"menuone\") != NULL)\n\treturn (i >= 1);\n    return (i >= 2);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Allocate Dict for the completed item.\n * { word, abbr, menu, kind, info }\n */\n    static dict_T *\nins_compl_dict_alloc(compl_T *match)\n{\n    dict_T *dict = dict_alloc_lock(VAR_FIXED);\n\n    if (dict == NULL)\n\treturn NULL;\n\n    dict_add_string(dict, \"word\", match->cp_str);\n    dict_add_string(dict, \"abbr\", match->cp_text[CPT_ABBR]);\n    dict_add_string(dict, \"menu\", match->cp_text[CPT_MENU]);\n    dict_add_string(dict, \"kind\", match->cp_text[CPT_KIND]);\n    dict_add_string(dict, \"info\", match->cp_text[CPT_INFO]);\n    if (match->cp_user_data.v_type == VAR_UNKNOWN)\n\tdict_add_string(dict, \"user_data\", (char_u *)\"\");\n    else\n\tdict_add_tv(dict, \"user_data\", &match->cp_user_data);\n\n    return dict;\n}\n\n/*\n * Trigger the CompleteChanged autocmd event. Invoked each time the Insert mode\n * completion menu is changed.\n */\n    static void\ntrigger_complete_changed_event(int cur)\n{\n    dict_T\t    *v_event;\n    dict_T\t    *item;\n    static int\t    recursive = FALSE;\n    save_v_event_T  save_v_event;\n\n    if (recursive)\n\treturn;\n\n    if (cur < 0)\n\titem = dict_alloc();\n    else\n\titem = ins_compl_dict_alloc(compl_curr_match);\n    if (item == NULL)\n\treturn;\n    v_event = get_v_event(&save_v_event);\n    dict_add_dict(v_event, \"completed_item\", item);\n    pum_set_event_info(v_event);\n    dict_set_items_ro(v_event);\n\n    recursive = TRUE;\n    textlock++;\n    apply_autocmds(EVENT_COMPLETECHANGED, NULL, NULL, FALSE, curbuf);\n    textlock--;\n    recursive = FALSE;\n\n    restore_v_event(v_event, &save_v_event);\n}\n#endif\n\n/*\n * Build a popup menu to show the completion matches.\n * Returns the popup menu entry that should be selected. Returns -1 if nothing\n * should be selected.\n */\n    static int\nins_compl_build_pum(void)\n{\n    compl_T     *compl;\n    compl_T     *shown_compl = NULL;\n    int\t\tdid_find_shown_match = FALSE;\n    int\t\tshown_match_ok = FALSE;\n    int\t\ti;\n    int\t\tcur = -1;\n    int\t\tlead_len = 0;\n\n    // Need to build the popup menu list.\n    compl_match_arraysize = 0;\n    compl = compl_first_match;\n    if (compl_leader != NULL)\n\tlead_len = (int)STRLEN(compl_leader);\n\n    do\n    {\n\tif (!match_at_original_text(compl)\n\t\t&& (compl_leader == NULL\n\t\t    || ins_compl_equal(compl, compl_leader, lead_len)))\n\t    ++compl_match_arraysize;\n\tcompl = compl->cp_next;\n    } while (compl != NULL && !is_first_match(compl));\n\n    if (compl_match_arraysize == 0)\n\treturn -1;\n\n    compl_match_array = ALLOC_CLEAR_MULT(pumitem_T, compl_match_arraysize);\n    if (compl_match_array == NULL)\n\treturn -1;\n\n    // If the current match is the original text don't find the first\n    // match after it, don't highlight anything.\n    if (match_at_original_text(compl_shown_match))\n\tshown_match_ok = TRUE;\n\n    i = 0;\n    compl = compl_first_match;\n    do\n    {\n\tif (!match_at_original_text(compl)\n\t\t&& (compl_leader == NULL\n\t\t    || ins_compl_equal(compl, compl_leader, lead_len)))\n\t{\n\t    if (!shown_match_ok)\n\t    {\n\t\tif (compl == compl_shown_match || did_find_shown_match)\n\t\t{\n\t\t    // This item is the shown match or this is the\n\t\t    // first displayed item after the shown match.\n\t\t    compl_shown_match = compl;\n\t\t    did_find_shown_match = TRUE;\n\t\t    shown_match_ok = TRUE;\n\t\t}\n\t\telse\n\t\t    // Remember this displayed match for when the\n\t\t    // shown match is just below it.\n\t\t    shown_compl = compl;\n\t\tcur = i;\n\t    }\n\n\t    if (compl->cp_text[CPT_ABBR] != NULL)\n\t\tcompl_match_array[i].pum_text =\n\t\t    compl->cp_text[CPT_ABBR];\n\t    else\n\t\tcompl_match_array[i].pum_text = compl->cp_str;\n\t    compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];\n\t    compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];\n\t    if (compl->cp_text[CPT_MENU] != NULL)\n\t\tcompl_match_array[i++].pum_extra =\n\t\t    compl->cp_text[CPT_MENU];\n\t    else\n\t\tcompl_match_array[i++].pum_extra = compl->cp_fname;\n\t}\n\n\tif (compl == compl_shown_match)\n\t{\n\t    did_find_shown_match = TRUE;\n\n\t    // When the original text is the shown match don't set\n\t    // compl_shown_match.\n\t    if (match_at_original_text(compl))\n\t\tshown_match_ok = TRUE;\n\n\t    if (!shown_match_ok && shown_compl != NULL)\n\t    {\n\t\t// The shown match isn't displayed, set it to the\n\t\t// previously displayed match.\n\t\tcompl_shown_match = shown_compl;\n\t\tshown_match_ok = TRUE;\n\t    }\n\t}\n\tcompl = compl->cp_next;\n    } while (compl != NULL && !is_first_match(compl));\n\n    if (!shown_match_ok)    // no displayed match at all\n\tcur = -1;\n\n    return cur;\n}\n\n/*\n * Show the popup menu for the list of matches.\n * Also adjusts \"compl_shown_match\" to an entry that is actually displayed.\n */\n    void\nins_compl_show_pum(void)\n{\n    int\t\ti;\n    int\t\tcur = -1;\n    colnr_T\tcol;\n\n    if (!pum_wanted() || !pum_enough_matches())\n\treturn;\n\n#if defined(FEAT_EVAL)\n    // Dirty hard-coded hack: remove any matchparen highlighting.\n    do_cmdline_cmd((char_u *)\"if exists('g:loaded_matchparen')|:3match none|endif\");\n#endif\n\n    // Update the screen later, before drawing the popup menu over it.\n    pum_call_update_screen();\n\n    if (compl_match_array == NULL)\n\t// Need to build the popup menu list.\n\tcur = ins_compl_build_pum();\n    else\n    {\n\t// popup menu already exists, only need to find the current item.\n\tfor (i = 0; i < compl_match_arraysize; ++i)\n\t    if (compl_match_array[i].pum_text == compl_shown_match->cp_str\n\t\t    || compl_match_array[i].pum_text\n\t\t\t\t      == compl_shown_match->cp_text[CPT_ABBR])\n\t    {\n\t\tcur = i;\n\t\tbreak;\n\t    }\n    }\n\n    if (compl_match_array == NULL)\n\treturn;\n\n    // In Replace mode when a $ is displayed at the end of the line only\n    // part of the screen would be updated.  We do need to redraw here.\n    dollar_vcol = -1;\n\n    // Compute the screen column of the start of the completed text.\n    // Use the cursor to get all wrapping and other settings right.\n    col = curwin->w_cursor.col;\n    curwin->w_cursor.col = compl_col;\n    pum_display(compl_match_array, compl_match_arraysize, cur);\n    curwin->w_cursor.col = col;\n\n#ifdef FEAT_EVAL\n    if (has_completechanged())\n\ttrigger_complete_changed_event(cur);\n#endif\n}\n\n#define DICT_FIRST\t(1)\t// use just first element in \"dict\"\n#define DICT_EXACT\t(2)\t// \"dict\" is the exact name of a file\n\n/*\n * Add any identifiers that match the given pattern \"pat\" in the list of\n * dictionary files \"dict_start\" to the list of completions.\n */\n    static void\nins_compl_dictionaries(\n    char_u\t*dict_start,\n    char_u\t*pat,\n    int\t\tflags,\t\t// DICT_FIRST and/or DICT_EXACT\n    int\t\tthesaurus)\t// Thesaurus completion\n{\n    char_u\t*dict = dict_start;\n    char_u\t*ptr;\n    char_u\t*buf;\n    regmatch_T\tregmatch;\n    char_u\t**files;\n    int\t\tcount;\n    int\t\tsave_p_scs;\n    int\t\tdir = compl_direction;\n\n    if (*dict == NUL)\n    {\n#ifdef FEAT_SPELL\n\t// When 'dictionary' is empty and spell checking is enabled use\n\t// \"spell\".\n\tif (!thesaurus && curwin->w_p_spell)\n\t    dict = (char_u *)\"spell\";\n\telse\n#endif\n\t    return;\n    }\n\n    buf = alloc(LSIZE);\n    if (buf == NULL)\n\treturn;\n    regmatch.regprog = NULL;\t// so that we can goto theend\n\n    // If 'infercase' is set, don't use 'smartcase' here\n    save_p_scs = p_scs;\n    if (curbuf->b_p_inf)\n\tp_scs = FALSE;\n\n    // When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern\n    // to only match at the start of a line.  Otherwise just match the\n    // pattern. Also need to double backslashes.\n    if (ctrl_x_mode_line_or_eval())\n    {\n\tchar_u *pat_esc = vim_strsave_escaped(pat, (char_u *)\"\\\\\");\n\tsize_t len;\n\n\tif (pat_esc == NULL)\n\t    goto theend;\n\tlen = STRLEN(pat_esc) + 10;\n\tptr = alloc(len);\n\tif (ptr == NULL)\n\t{\n\t    vim_free(pat_esc);\n\t    goto theend;\n\t}\n\tvim_snprintf((char *)ptr, len, \"^\\\\s*\\\\zs\\\\V%s\", pat_esc);\n\tregmatch.regprog = vim_regcomp(ptr, RE_MAGIC);\n\tvim_free(pat_esc);\n\tvim_free(ptr);\n    }\n    else\n    {\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog == NULL)\n\t    goto theend;\n    }\n\n    // ignore case depends on 'ignorecase', 'smartcase' and \"pat\"\n    regmatch.rm_ic = ignorecase(pat);\n    while (*dict != NUL && !got_int && !compl_interrupted)\n    {\n\t// copy one dictionary file name into buf\n\tif (flags == DICT_EXACT)\n\t{\n\t    count = 1;\n\t    files = &dict;\n\t}\n\telse\n\t{\n\t    // Expand wildcards in the dictionary name, but do not allow\n\t    // backticks (for security, the 'dict' option may have been set in\n\t    // a modeline).\n\t    copy_option_part(&dict, buf, LSIZE, \",\");\n# ifdef FEAT_SPELL\n\t    if (!thesaurus && STRCMP(buf, \"spell\") == 0)\n\t\tcount = -1;\n\t    else\n# endif\n\t\tif (vim_strchr(buf, '`') != NULL\n\t\t    || expand_wildcards(1, &buf, &count, &files,\n\t\t\t\t\t\t     EW_FILE|EW_SILENT) != OK)\n\t\tcount = 0;\n\t}\n\n# ifdef FEAT_SPELL\n\tif (count == -1)\n\t{\n\t    // Complete from active spelling.  Skip \"\\<\" in the pattern, we\n\t    // don't use it as a RE.\n\t    if (pat[0] == '\\\\' && pat[1] == '<')\n\t\tptr = pat + 2;\n\t    else\n\t\tptr = pat;\n\t    spell_dump_compl(ptr, regmatch.rm_ic, &dir, 0);\n\t}\n\telse\n# endif\n\t    if (count > 0)\t// avoid warning for using \"files\" uninit\n\t{\n\t    ins_compl_files(count, files, thesaurus, flags,\n\t\t\t\t\t\t\t&regmatch, buf, &dir);\n\t    if (flags != DICT_EXACT)\n\t\tFreeWild(count, files);\n\t}\n\tif (flags != 0)\n\t    break;\n    }\n\ntheend:\n    p_scs = save_p_scs;\n    vim_regfree(regmatch.regprog);\n    vim_free(buf);\n}\n\n/*\n * Add all the words in the line \"*buf_arg\" from the thesaurus file \"fname\"\n * skipping the word at 'skip_word'.  Returns OK on success.\n */\n    static int\nthesaurus_add_words_in_line(\n\tchar_u\t*fname,\n\tchar_u\t**buf_arg,\n\tint\tdir,\n\tchar_u\t*skip_word)\n{\n    int\t\tstatus = OK;\n    char_u\t*ptr;\n    char_u\t*wstart;\n\n    // Add the other matches on the line\n    ptr = *buf_arg;\n    while (!got_int)\n    {\n\t// Find start of the next word.  Skip white\n\t// space and punctuation.\n\tptr = find_word_start(ptr);\n\tif (*ptr == NUL || *ptr == NL)\n\t    break;\n\twstart = ptr;\n\n\t// Find end of the word.\n\tif (has_mbyte)\n\t    // Japanese words may have characters in\n\t    // different classes, only separate words\n\t    // with single-byte non-word characters.\n\t    while (*ptr != NUL)\n\t    {\n\t\tint l = (*mb_ptr2len)(ptr);\n\n\t\tif (l < 2 && !vim_iswordc(*ptr))\n\t\t    break;\n\t\tptr += l;\n\t    }\n\telse\n\t    ptr = find_word_end(ptr);\n\n\t// Add the word. Skip the regexp match.\n\tif (wstart != skip_word)\n\t{\n\t    status = ins_compl_add_infercase(wstart, (int)(ptr - wstart), p_ic,\n\t\t\t\t\t\t\tfname, dir, FALSE);\n\t    if (status == FAIL)\n\t\tbreak;\n\t}\n    }\n\n    *buf_arg = ptr;\n    return status;\n}\n\n/*\n * Process \"count\" dictionary/thesaurus \"files\" and add the text matching\n * \"regmatch\".\n */\n    static void\nins_compl_files(\n    int\t\tcount,\n    char_u\t**files,\n    int\t\tthesaurus,\n    int\t\tflags,\n    regmatch_T\t*regmatch,\n    char_u\t*buf,\n    int\t\t*dir)\n{\n    char_u\t*ptr;\n    int\t\ti;\n    FILE\t*fp;\n    int\t\tadd_r;\n\n    for (i = 0; i < count && !got_int && !compl_interrupted; i++)\n    {\n\tfp = mch_fopen((char *)files[i], \"r\");  // open dictionary file\n\tif (flags != DICT_EXACT)\n\t{\n\t    msg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t    vim_snprintf((char *)IObuff, IOSIZE,\n\t\t\t      _(\"Scanning dictionary: %s\"), (char *)files[i]);\n\t    (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t}\n\n\tif (fp == NULL)\n\t    continue;\n\n\t// Read dictionary file line by line.\n\t// Check each line for a match.\n\twhile (!got_int && !compl_interrupted && !vim_fgets(buf, LSIZE, fp))\n\t{\n\t    ptr = buf;\n\t    while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf)))\n\t    {\n\t\tptr = regmatch->startp[0];\n\t\tif (ctrl_x_mode_line_or_eval())\n\t\t    ptr = find_line_end(ptr);\n\t\telse\n\t\t    ptr = find_word_end(ptr);\n\t\tadd_r = ins_compl_add_infercase(regmatch->startp[0],\n\t\t\t(int)(ptr - regmatch->startp[0]),\n\t\t\tp_ic, files[i], *dir, FALSE);\n\t\tif (thesaurus)\n\t\t{\n\t\t    // For a thesaurus, add all the words in the line\n\t\t    ptr = buf;\n\t\t    add_r = thesaurus_add_words_in_line(files[i], &ptr, *dir,\n\t\t\t\t\t\t\tregmatch->startp[0]);\n\t\t}\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    *dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t\t// avoid expensive call to vim_regexec() when at end\n\t\t// of line\n\t\tif (*ptr == '\\n' || got_int)\n\t\t    break;\n\t    }\n\t    line_breakcheck();\n\t    ins_compl_check_keys(50, FALSE);\n\t}\n\tfclose(fp);\n    }\n}\n\n/*\n * Find the start of the next word.\n * Returns a pointer to the first char of the word.  Also stops at a NUL.\n */\n    char_u *\nfind_word_start(char_u *ptr)\n{\n    if (has_mbyte)\n\twhile (*ptr != NUL && *ptr != '\\n' && mb_get_class(ptr) <= 1)\n\t    ptr += (*mb_ptr2len)(ptr);\n    else\n\twhile (*ptr != NUL && *ptr != '\\n' && !vim_iswordc(*ptr))\n\t    ++ptr;\n    return ptr;\n}\n\n/*\n * Find the end of the word.  Assumes it starts inside a word.\n * Returns a pointer to just after the word.\n */\n    char_u *\nfind_word_end(char_u *ptr)\n{\n    int\t\tstart_class;\n\n    if (has_mbyte)\n    {\n\tstart_class = mb_get_class(ptr);\n\tif (start_class > 1)\n\t    while (*ptr != NUL)\n\t    {\n\t\tptr += (*mb_ptr2len)(ptr);\n\t\tif (mb_get_class(ptr) != start_class)\n\t\t    break;\n\t    }\n    }\n    else\n\twhile (vim_iswordc(*ptr))\n\t    ++ptr;\n    return ptr;\n}\n\n/*\n * Find the end of the line, omitting CR and NL at the end.\n * Returns a pointer to just after the line.\n */\n    static char_u *\nfind_line_end(char_u *ptr)\n{\n    char_u\t*s;\n\n    s = ptr + STRLEN(ptr);\n    while (s > ptr && (s[-1] == CAR || s[-1] == NL))\n\t--s;\n    return s;\n}\n\n/*\n * Free the list of completions\n */\n    static void\nins_compl_free(void)\n{\n    compl_T *match;\n    int\t    i;\n\n    VIM_CLEAR(compl_pattern);\n    VIM_CLEAR(compl_leader);\n\n    if (compl_first_match == NULL)\n\treturn;\n\n    ins_compl_del_pum();\n    pum_clear();\n\n    compl_curr_match = compl_first_match;\n    do\n    {\n\tmatch = compl_curr_match;\n\tcompl_curr_match = compl_curr_match->cp_next;\n\tvim_free(match->cp_str);\n\t// several entries may use the same fname, free it just once.\n\tif (match->cp_flags & CP_FREE_FNAME)\n\t    vim_free(match->cp_fname);\n\tfor (i = 0; i < CPT_COUNT; ++i)\n\t    vim_free(match->cp_text[i]);\n#ifdef FEAT_EVAL\n\tclear_tv(&match->cp_user_data);\n#endif\n\tvim_free(match);\n    } while (compl_curr_match != NULL && !is_first_match(compl_curr_match));\n    compl_first_match = compl_curr_match = NULL;\n    compl_shown_match = NULL;\n    compl_old_match = NULL;\n}\n\n/*\n * Reset/clear the completion state.\n */\n    void\nins_compl_clear(void)\n{\n    compl_cont_status = 0;\n    compl_started = FALSE;\n    compl_matches = 0;\n    VIM_CLEAR(compl_pattern);\n    VIM_CLEAR(compl_leader);\n    edit_submode_extra = NULL;\n    VIM_CLEAR(compl_orig_text);\n    compl_enter_selects = FALSE;\n#ifdef FEAT_EVAL\n    // clear v:completed_item\n    set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc_lock(VAR_FIXED));\n#endif\n}\n\n/*\n * Return TRUE when Insert completion is active.\n */\n    int\nins_compl_active(void)\n{\n    return compl_started;\n}\n\n/*\n * Selected one of the matches.  When FALSE the match was edited or using the\n * longest common string.\n */\n    int\nins_compl_used_match(void)\n{\n    return compl_used_match;\n}\n\n/*\n * Initialize get longest common string.\n */\n    void\nins_compl_init_get_longest(void)\n{\n    compl_get_longest = FALSE;\n}\n\n/*\n * Returns TRUE when insert completion is interrupted.\n */\n    int\nins_compl_interrupted(void)\n{\n    return compl_interrupted;\n}\n\n/*\n * Returns TRUE if the <Enter> key selects a match in the completion popup\n * menu.\n */\n    int\nins_compl_enter_selects(void)\n{\n    return compl_enter_selects;\n}\n\n/*\n * Return the column where the text starts that is being completed\n */\n    colnr_T\nins_compl_col(void)\n{\n    return compl_col;\n}\n\n/*\n * Return the length in bytes of the text being completed\n */\n    int\nins_compl_len(void)\n{\n    return compl_length;\n}\n\n/*\n * Delete one character before the cursor and show the subset of the matches\n * that match the word that is now before the cursor.\n * Returns the character to be used, NUL if the work is done and another char\n * to be got from the user.\n */\n    int\nins_compl_bs(void)\n{\n    char_u\t*line;\n    char_u\t*p;\n\n    line = ml_get_curline();\n    p = line + curwin->w_cursor.col;\n    MB_PTR_BACK(line, p);\n\n    // Stop completion when the whole word was deleted.  For Omni completion\n    // allow the word to be deleted, we won't match everything.\n    // Respect the 'backspace' option.\n    if ((int)(p - line) - (int)compl_col < 0\n\t    || ((int)(p - line) - (int)compl_col == 0 && !ctrl_x_mode_omni())\n\t    || ctrl_x_mode_eval()\n\t    || (!can_bs(BS_START) && (int)(p - line) - (int)compl_col\n\t\t\t\t\t\t\t- compl_length < 0))\n\treturn K_BS;\n\n    // Deleted more than what was used to find matches or didn't finish\n    // finding all matches: need to look for matches all over again.\n    if (curwin->w_cursor.col <= compl_col + compl_length\n\t\t\t\t\t\t  || ins_compl_need_restart())\n\tins_compl_restart();\n\n    vim_free(compl_leader);\n    compl_leader = vim_strnsave(line + compl_col, (p - line) - compl_col);\n    if (compl_leader == NULL)\n\treturn K_BS;\n\n    ins_compl_new_leader();\n    if (compl_shown_match != NULL)\n\t// Make sure current match is not a hidden item.\n\tcompl_curr_match = compl_shown_match;\n    return NUL;\n}\n\n/*\n * Return TRUE when we need to find matches again, ins_compl_restart() is to\n * be called.\n */\n    static int\nins_compl_need_restart(void)\n{\n    // Return TRUE if we didn't complete finding matches or when the\n    // 'completefunc' returned \"always\" in the \"refresh\" dictionary item.\n    return compl_was_interrupted\n\t|| ((ctrl_x_mode_function() || ctrl_x_mode_omni())\n\t\t\t\t\t\t  && compl_opt_refresh_always);\n}\n\n/*\n * Called after changing \"compl_leader\".\n * Show the popup menu with a different set of matches.\n * May also search for matches again if the previous search was interrupted.\n */\n    static void\nins_compl_new_leader(void)\n{\n    ins_compl_del_pum();\n    ins_compl_delete();\n    ins_bytes(compl_leader + get_compl_len());\n    compl_used_match = FALSE;\n\n    if (compl_started)\n\tins_compl_set_original_text(compl_leader);\n    else\n    {\n#ifdef FEAT_SPELL\n\tspell_bad_len = 0;\t// need to redetect bad word\n#endif\n\t// Matches were cleared, need to search for them now.  Before drawing\n\t// the popup menu display the changed text before the cursor.  Set\n\t// \"compl_restarting\" to avoid that the first match is inserted.\n\tpum_call_update_screen();\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    // Show the cursor after the match, not after the redrawn text.\n\t    setcursor();\n\t    out_flush_cursor(FALSE, FALSE);\n\t}\n#endif\n\tcompl_restarting = TRUE;\n\tif (ins_complete(Ctrl_N, TRUE) == FAIL)\n\t    compl_cont_status = 0;\n\tcompl_restarting = FALSE;\n    }\n\n    compl_enter_selects = !compl_used_match;\n\n    // Show the popup menu with a different set of matches.\n    ins_compl_show_pum();\n\n    // Don't let Enter select the original text when there is no popup menu.\n    if (compl_match_array == NULL)\n\tcompl_enter_selects = FALSE;\n}\n\n/*\n * Return the length of the completion, from the completion start column to\n * the cursor column.  Making sure it never goes below zero.\n */\n    static int\nget_compl_len(void)\n{\n    int off = (int)curwin->w_cursor.col - (int)compl_col;\n\n    if (off < 0)\n\treturn 0;\n    return off;\n}\n\n/*\n * Append one character to the match leader.  May reduce the number of\n * matches.\n */\n    void\nins_compl_addleader(int c)\n{\n    int\t\tcc;\n\n    if (stop_arrow() == FAIL)\n\treturn;\n    if (has_mbyte && (cc = (*mb_char2len)(c)) > 1)\n    {\n\tchar_u\tbuf[MB_MAXBYTES + 1];\n\n\t(*mb_char2bytes)(c, buf);\n\tbuf[cc] = NUL;\n\tins_char_bytes(buf, cc);\n\tif (compl_opt_refresh_always)\n\t    AppendToRedobuff(buf);\n    }\n    else\n    {\n\tins_char(c);\n\tif (compl_opt_refresh_always)\n\t    AppendCharToRedobuff(c);\n    }\n\n    // If we didn't complete finding matches we must search again.\n    if (ins_compl_need_restart())\n\tins_compl_restart();\n\n    // When 'always' is set, don't reset compl_leader. While completing,\n    // cursor doesn't point original position, changing compl_leader would\n    // break redo.\n    if (!compl_opt_refresh_always)\n    {\n\tvim_free(compl_leader);\n\tcompl_leader = vim_strnsave(ml_get_curline() + compl_col,\n\t\t\t\t\t     curwin->w_cursor.col - compl_col);\n\tif (compl_leader != NULL)\n\t    ins_compl_new_leader();\n    }\n}\n\n/*\n * Setup for finding completions again without leaving CTRL-X mode.  Used when\n * BS or a key was typed while still searching for matches.\n */\n    static void\nins_compl_restart(void)\n{\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    compl_cont_status = 0;\n    compl_cont_mode = 0;\n}\n\n/*\n * Set the first match, the original text.\n */\n    static void\nins_compl_set_original_text(char_u *str)\n{\n    char_u\t*p;\n\n    // Replace the original text entry.\n    // The CP_ORIGINAL_TEXT flag is either at the first item or might possibly\n    // be at the last item for backward completion\n    if (match_at_original_text(compl_first_match))\t// safety check\n    {\n\tp = vim_strsave(str);\n\tif (p != NULL)\n\t{\n\t    vim_free(compl_first_match->cp_str);\n\t    compl_first_match->cp_str = p;\n\t}\n    }\n    else if (compl_first_match->cp_prev != NULL\n\t    && match_at_original_text(compl_first_match->cp_prev))\n    {\n       p = vim_strsave(str);\n       if (p != NULL)\n       {\n\t   vim_free(compl_first_match->cp_prev->cp_str);\n\t   compl_first_match->cp_prev->cp_str = p;\n       }\n    }\n}\n\n/*\n * Append one character to the match leader.  May reduce the number of\n * matches.\n */\n    void\nins_compl_addfrommatch(void)\n{\n    char_u\t*p;\n    int\t\tlen = (int)curwin->w_cursor.col - (int)compl_col;\n    int\t\tc;\n    compl_T\t*cp;\n\n    p = compl_shown_match->cp_str;\n    if ((int)STRLEN(p) <= len)   // the match is too short\n    {\n\t// When still at the original match use the first entry that matches\n\t// the leader.\n\tif (!match_at_original_text(compl_shown_match))\n\t    return;\n\n\tp = NULL;\n\tfor (cp = compl_shown_match->cp_next; cp != NULL\n\t\t&& !is_first_match(cp); cp = cp->cp_next)\n\t{\n\t    if (compl_leader == NULL\n\t\t    || ins_compl_equal(cp, compl_leader,\n\t\t\t(int)STRLEN(compl_leader)))\n\t    {\n\t\tp = cp->cp_str;\n\t\tbreak;\n\t    }\n\t}\n\tif (p == NULL || (int)STRLEN(p) <= len)\n\t    return;\n    }\n    p += len;\n    c = PTR2CHAR(p);\n    ins_compl_addleader(c);\n}\n\n/*\n * Set the CTRL-X completion mode based on the key \"c\" typed after a CTRL-X.\n * Uses the global variables: ctrl_x_mode, edit_submode, edit_submode_pre,\n * compl_cont_mode and compl_cont_status.\n * Returns TRUE when the character is not to be inserted.\n */\n    static int\nset_ctrl_x_mode(int c)\n{\n    int retval = FALSE;\n\n    switch (c)\n    {\n\tcase Ctrl_E:\n\tcase Ctrl_Y:\n\t    // scroll the window one line up or down\n\t    ctrl_x_mode = CTRL_X_SCROLL;\n\t    if (!(State & REPLACE_FLAG))\n\t\tedit_submode = (char_u *)_(\" (insert) Scroll (^E/^Y)\");\n\t    else\n\t\tedit_submode = (char_u *)_(\" (replace) Scroll (^E/^Y)\");\n\t    edit_submode_pre = NULL;\n\t    showmode();\n\t    break;\n\tcase Ctrl_L:\n\t    // complete whole line\n\t    ctrl_x_mode = CTRL_X_WHOLE_LINE;\n\t    break;\n\tcase Ctrl_F:\n\t    // complete filenames\n\t    ctrl_x_mode = CTRL_X_FILES;\n\t    break;\n\tcase Ctrl_K:\n\t    // complete words from a dictionary\n\t    ctrl_x_mode = CTRL_X_DICTIONARY;\n\t    break;\n\tcase Ctrl_R:\n\t    // Register insertion without exiting CTRL-X mode\n\t    // Simply allow ^R to happen without affecting ^X mode\n\t    break;\n\tcase Ctrl_T:\n\t    // complete words from a thesaurus\n\t    ctrl_x_mode = CTRL_X_THESAURUS;\n\t    break;\n#ifdef FEAT_COMPL_FUNC\n\tcase Ctrl_U:\n\t    // user defined completion\n\t    ctrl_x_mode = CTRL_X_FUNCTION;\n\t    break;\n\tcase Ctrl_O:\n\t    // omni completion\n\t    ctrl_x_mode = CTRL_X_OMNI;\n\t    break;\n#endif\n\tcase 's':\n\tcase Ctrl_S:\n\t    // complete spelling suggestions\n\t    ctrl_x_mode = CTRL_X_SPELL;\n#ifdef FEAT_SPELL\n\t    ++emsg_off;\t// Avoid getting the E756 error twice.\n\t    spell_back_to_badword();\n\t    --emsg_off;\n#endif\n\t    break;\n\tcase Ctrl_RSB:\n\t    // complete tag names\n\t    ctrl_x_mode = CTRL_X_TAGS;\n\t    break;\n#ifdef FEAT_FIND_ID\n\tcase Ctrl_I:\n\tcase K_S_TAB:\n\t    // complete keywords from included files\n\t    ctrl_x_mode = CTRL_X_PATH_PATTERNS;\n\t    break;\n\tcase Ctrl_D:\n\t    // complete definitions from included files\n\t    ctrl_x_mode = CTRL_X_PATH_DEFINES;\n\t    break;\n#endif\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t    // complete vim commands\n\t    ctrl_x_mode = CTRL_X_CMDLINE;\n\t    break;\n\tcase Ctrl_Z:\n\t    // stop completion\n\t    ctrl_x_mode = CTRL_X_NORMAL;\n\t    edit_submode = NULL;\n\t    showmode();\n\t    retval = TRUE;\n\t    break;\n\tcase Ctrl_P:\n\tcase Ctrl_N:\n\t    // ^X^P means LOCAL expansion if nothing interrupted (eg we\n\t    // just started ^X mode, or there were enough ^X's to cancel\n\t    // the previous mode, say ^X^F^X^X^P or ^P^X^X^X^P, see below)\n\t    // do normal expansion when interrupting a different mode (say\n\t    // ^X^F^X^P or ^P^X^X^P, see below)\n\t    // nothing changes if interrupting mode 0, (eg, the flag\n\t    // doesn't change when going to ADDING mode  -- Acevedo\n\t    if (!(compl_cont_status & CONT_INTRPT))\n\t\tcompl_cont_status |= CONT_LOCAL;\n\t    else if (compl_cont_mode != 0)\n\t\tcompl_cont_status &= ~CONT_LOCAL;\n\t    // FALLTHROUGH\n\tdefault:\n\t    // If we have typed at least 2 ^X's... for modes != 0, we set\n\t    // compl_cont_status = 0 (eg, as if we had just started ^X\n\t    // mode).\n\t    // For mode 0, we set \"compl_cont_mode\" to an impossible\n\t    // value, in both cases ^X^X can be used to restart the same\n\t    // mode (avoiding ADDING mode).\n\t    // Undocumented feature: In a mode != 0 ^X^P and ^X^X^P start\n\t    // 'complete' and local ^P expansions respectively.\n\t    // In mode 0 an extra ^X is needed since ^X^P goes to ADDING\n\t    // mode  -- Acevedo\n\t    if (c == Ctrl_X)\n\t    {\n\t\tif (compl_cont_mode != 0)\n\t\t    compl_cont_status = 0;\n\t\telse\n\t\t    compl_cont_mode = CTRL_X_NOT_DEFINED_YET;\n\t    }\n\t    ctrl_x_mode = CTRL_X_NORMAL;\n\t    edit_submode = NULL;\n\t    showmode();\n\t    break;\n    }\n\n    return retval;\n}\n\n/*\n * Stop insert completion mode\n */\n    static int\nins_compl_stop(int c, int prev_mode, int retval)\n{\n    char_u\t*ptr;\n    int\t\twant_cindent;\n\n    // Get here when we have finished typing a sequence of ^N and\n    // ^P or other completion characters in CTRL-X mode.  Free up\n    // memory that was used, and make sure we can redo the insert.\n    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)\n    {\n\t// If any of the original typed text has been changed, eg when\n\t// ignorecase is set, we must add back-spaces to the redo\n\t// buffer.  We add as few as necessary to delete just the part\n\t// of the original text that has changed.\n\t// When using the longest match, edited the match or used\n\t// CTRL-E then don't use the current match.\n\tif (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)\n\t    ptr = compl_curr_match->cp_str;\n\telse\n\t    ptr = NULL;\n\tins_compl_fixRedoBufForLeader(ptr);\n    }\n\n    want_cindent = (get_can_cindent() && cindent_on());\n\n    // When completing whole lines: fix indent for 'cindent'.\n    // Otherwise, break line if it's too long.\n    if (compl_cont_mode == CTRL_X_WHOLE_LINE)\n    {\n\t// re-indent the current line\n\tif (want_cindent)\n\t{\n\t    do_c_expr_indent();\n\t    want_cindent = FALSE;\t// don't do it again\n\t}\n    }\n    else\n    {\n\tint prev_col = curwin->w_cursor.col;\n\n\t// put the cursor on the last char, for 'tw' formatting\n\tif (prev_col > 0)\n\t    dec_cursor();\n\t// only format when something was inserted\n\tif (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)\n\t    insertchar(NUL, 0, -1);\n\tif (prev_col > 0\n\t\t&& ml_get_curline()[curwin->w_cursor.col] != NUL)\n\t    inc_cursor();\n    }\n\n    // If the popup menu is displayed pressing CTRL-Y means accepting\n    // the selection without inserting anything.  When\n    // compl_enter_selects is set the Enter key does the same.\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n\n    // CTRL-E means completion is Ended, go back to the typed text.\n    // but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tchar_u *p = NULL;\n\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    p = compl_leader;\n\telse if (compl_first_match != NULL)\n\t    p = compl_orig_text;\n\tif (p != NULL)\n\t{\n\t    int\t    compl_len = get_compl_len();\n\t    int\t    len = (int)STRLEN(p);\n\n\t    if (len > compl_len)\n\t\tins_bytes_len(p + compl_len, len - compl_len);\n\t}\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n\n    // Trigger the CompleteDonePre event to give scripts a chance to\n    // act upon the completion before clearing the info, and restore\n    // ctrl_x_mode, so that complete_info() can be used.\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);\n\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    if (!shortmess(SHM_COMPLETIONMENU))\n\tmsg_clr_cmdline();\t// necessary for \"noshowmode\"\n    ctrl_x_mode = CTRL_X_NORMAL;\n    compl_enter_selects = FALSE;\n    if (edit_submode != NULL)\n    {\n\tedit_submode = NULL;\n\tshowmode();\n    }\n\n#ifdef FEAT_CMDWIN\n    if (c == Ctrl_C && cmdwin_type != 0)\n\t// Avoid the popup menu remains displayed when leaving the\n\t// command line window.\n\tupdate_screen(0);\n#endif\n    // Indent now if a key was typed that is in 'cinkeys'.\n    if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))\n\tdo_c_expr_indent();\n    // Trigger the CompleteDone event to give scripts a chance to act\n    // upon the end of completion.\n    ins_apply_autocmds(EVENT_COMPLETEDONE);\n\n    return retval;\n}\n\n/*\n * Prepare for Insert mode completion, or stop it.\n * Called just after typing a character in Insert mode.\n * Returns TRUE when the character is not to be inserted;\n */\n    int\nins_compl_prep(int c)\n{\n    int\t\tretval = FALSE;\n    int\t\tprev_mode = ctrl_x_mode;\n\n    // Forget any previous 'special' messages if this is actually\n    // a ^X mode key - bar ^R, in which case we wait to see what it gives us.\n    if (c != Ctrl_R && vim_is_ctrl_x_key(c))\n\tedit_submode_extra = NULL;\n\n    // Ignore end of Select mode mapping and mouse scroll buttons.\n    if (c == K_SELECT || c == K_MOUSEDOWN || c == K_MOUSEUP\n\t    || c == K_MOUSELEFT || c == K_MOUSERIGHT\n\t    || c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\treturn retval;\n\n#ifdef FEAT_PROP_POPUP\n    // Ignore mouse events in a popup window\n    if (is_mouse_key(c))\n    {\n\t// Ignore drag and release events, the position does not need to be in\n\t// the popup and it may have just closed.\n\tif (c == K_LEFTRELEASE\n\t\t|| c == K_LEFTRELEASE_NM\n\t\t|| c == K_MIDDLERELEASE\n\t\t|| c == K_RIGHTRELEASE\n\t\t|| c == K_X1RELEASE\n\t\t|| c == K_X2RELEASE\n\t\t|| c == K_LEFTDRAG\n\t\t|| c == K_MIDDLEDRAG\n\t\t|| c == K_RIGHTDRAG\n\t\t|| c == K_X1DRAG\n\t\t|| c == K_X2DRAG)\n\t    return retval;\n\tif (popup_visible)\n\t{\n\t    int\t    row = mouse_row;\n\t    int\t    col = mouse_col;\n\t    win_T   *wp = mouse_find_win(&row, &col, FIND_POPUP);\n\n\t    if (wp != NULL && WIN_IS_POPUP(wp))\n\t\treturn retval;\n\t}\n    }\n#endif\n\n    if (ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X && c != Ctrl_X)\n    {\n\tif (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_Z || ins_compl_pum_key(c)\n\t\t|| !vim_is_ctrl_x_key(c))\n\t{\n\t    // Not starting another completion mode.\n\t    ctrl_x_mode = CTRL_X_CMDLINE;\n\n\t    // CTRL-X CTRL-Z should stop completion without inserting anything\n\t    if (c == Ctrl_Z)\n\t\tretval = TRUE;\n\t}\n\telse\n\t{\n\t    ctrl_x_mode = CTRL_X_CMDLINE;\n\n\t    // Other CTRL-X keys first stop completion, then start another\n\t    // completion mode.\n\t    ins_compl_prep(' ');\n\t    ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;\n\t}\n    }\n\n    // Set \"compl_get_longest\" when finding the first matches.\n    if (ctrl_x_mode_not_defined_yet()\n\t\t\t   || (ctrl_x_mode_normal() && !compl_started))\n    {\n\tcompl_get_longest = compl_longest;\n\tcompl_used_match = TRUE;\n\n    }\n\n    if (ctrl_x_mode_not_defined_yet())\n\t// We have just typed CTRL-X and aren't quite sure which CTRL-X mode\n\t// it will be yet.  Now we decide.\n\tretval = set_ctrl_x_mode(c);\n    else if (ctrl_x_mode_not_default())\n    {\n\t// We're already in CTRL-X mode, do we stay in it?\n\tif (!vim_is_ctrl_x_key(c))\n\t{\n\t    if (ctrl_x_mode_scroll())\n\t\tctrl_x_mode = CTRL_X_NORMAL;\n\t    else\n\t\tctrl_x_mode = CTRL_X_FINISHED;\n\t    edit_submode = NULL;\n\t}\n\tshowmode();\n    }\n\n    if (compl_started || ctrl_x_mode == CTRL_X_FINISHED)\n    {\n\t// Show error message from attempted keyword completion (probably\n\t// 'Pattern not found') until another key is hit, then go back to\n\t// showing what mode we are in.\n\tshowmode();\n\tif ((ctrl_x_mode_normal() && c != Ctrl_N && c != Ctrl_P\n\t\t\t\t       && c != Ctrl_R && !ins_compl_pum_key(c))\n\t\t|| ctrl_x_mode == CTRL_X_FINISHED)\n\t    retval = ins_compl_stop(c, prev_mode, retval);\n    }\n    else if (ctrl_x_mode == CTRL_X_LOCAL_MSG)\n\t// Trigger the CompleteDone event to give scripts a chance to act\n\t// upon the (possibly failed) completion.\n\tins_apply_autocmds(EVENT_COMPLETEDONE);\n\n    may_trigger_modechanged();\n\n    // reset continue_* if we left expansion-mode, if we stay they'll be\n    // (re)set properly in ins_complete()\n    if (!vim_is_ctrl_x_key(c))\n    {\n\tcompl_cont_status = 0;\n\tcompl_cont_mode = 0;\n    }\n\n    return retval;\n}\n\n/*\n * Fix the redo buffer for the completion leader replacing some of the typed\n * text.  This inserts backspaces and appends the changed text.\n * \"ptr\" is the known leader text or NUL.\n */\n    static void\nins_compl_fixRedoBufForLeader(char_u *ptr_arg)\n{\n    int\t    len;\n    char_u  *p;\n    char_u  *ptr = ptr_arg;\n\n    if (ptr == NULL)\n    {\n\tif (compl_leader != NULL)\n\t    ptr = compl_leader;\n\telse\n\t    return;  // nothing to do\n    }\n    if (compl_orig_text != NULL)\n    {\n\tp = compl_orig_text;\n\tfor (len = 0; p[len] != NUL && p[len] == ptr[len]; ++len)\n\t    ;\n\tif (len > 0)\n\t    len -= (*mb_head_off)(p, p + len);\n\tfor (p += len; *p != NUL; MB_PTR_ADV(p))\n\t    AppendCharToRedobuff(K_BS);\n    }\n    else\n\tlen = 0;\n    if (ptr != NULL)\n\tAppendToRedobuffLit(ptr + len, -1);\n}\n\n/*\n * Loops through the list of windows, loaded-buffers or non-loaded-buffers\n * (depending on flag) starting from buf and looking for a non-scanned\n * buffer (other than curbuf).\tcurbuf is special, if it is called with\n * buf=curbuf then it has to be the first call for a given flag/expansion.\n *\n * Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo\n */\n    static buf_T *\nins_compl_next_buf(buf_T *buf, int flag)\n{\n    static win_T *wp = NULL;\n\n    if (flag == 'w')\t\t// just windows\n    {\n\tif (buf == curbuf || !win_valid(wp))\n\t    // first call for this flag/expansion or window was closed\n\t    wp = curwin;\n\twhile ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin\n\t\t&& wp->w_buffer->b_scanned)\n\t    ;\n\tbuf = wp->w_buffer;\n    }\n    else\n\t// 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'\n\t// (unlisted buffers)\n\t// When completing whole lines skip unloaded buffers.\n\twhile ((buf = (buf->b_next != NULL ? buf->b_next : firstbuf)) != curbuf\n\t\t&& ((flag == 'U'\n\t\t\t? buf->b_p_bl\n\t\t\t: (!buf->b_p_bl\n\t\t\t    || (buf->b_ml.ml_mfp == NULL) != (flag == 'u')))\n\t\t    || buf->b_scanned))\n\t    ;\n    return buf;\n}\n\n#ifdef FEAT_COMPL_FUNC\n\n# ifdef FEAT_EVAL\nstatic callback_T cfu_cb;\t    // 'completefunc' callback function\nstatic callback_T ofu_cb;\t    // 'omnifunc' callback function\nstatic callback_T tsrfu_cb;\t    // 'thesaurusfunc' callback function\n# endif\n\n/*\n * Copy a global callback function to a buffer local callback.\n */\n    static void\ncopy_global_to_buflocal_cb(callback_T *globcb, callback_T *bufcb)\n{\n    free_callback(bufcb);\n    if (globcb->cb_name != NULL && *globcb->cb_name != NUL)\n\tcopy_callback(bufcb, globcb);\n}\n\n/*\n * Parse the 'completefunc' option value and set the callback function.\n * Invoked when the 'completefunc' option is set. The option value can be a\n * name of a function (string), or function(<name>) or funcref(<name>) or a\n * lambda expression.\n */\n    int\nset_completefunc_option(void)\n{\n    int\tretval;\n\n    retval = option_set_callback_func(curbuf->b_p_cfu, &cfu_cb);\n    if (retval == OK)\n\tset_buflocal_cfu_callback(curbuf);\n\n    return retval;\n}\n\n/*\n * Copy the global 'completefunc' callback function to the buffer-local\n * 'completefunc' callback for \"buf\".\n */\n    void\nset_buflocal_cfu_callback(buf_T *buf UNUSED)\n{\n# ifdef FEAT_EVAL\n    copy_global_to_buflocal_cb(&cfu_cb, &buf->b_cfu_cb);\n# endif\n}\n\n/*\n * Parse the 'omnifunc' option value and set the callback function.\n * Invoked when the 'omnifunc' option is set. The option value can be a\n * name of a function (string), or function(<name>) or funcref(<name>) or a\n * lambda expression.\n */\n    int\nset_omnifunc_option(void)\n{\n    int\tretval;\n\n    retval = option_set_callback_func(curbuf->b_p_ofu, &ofu_cb);\n    if (retval == OK)\n\tset_buflocal_ofu_callback(curbuf);\n\n    return retval;\n}\n\n/*\n * Copy the global 'omnifunc' callback function to the buffer-local 'omnifunc'\n * callback for \"buf\".\n */\n    void\nset_buflocal_ofu_callback(buf_T *buf UNUSED)\n{\n# ifdef FEAT_EVAL\n    copy_global_to_buflocal_cb(&ofu_cb, &buf->b_ofu_cb);\n# endif\n}\n\n/*\n * Parse the 'thesaurusfunc' option value and set the callback function.\n * Invoked when the 'thesaurusfunc' option is set. The option value can be a\n * name of a function (string), or function(<name>) or funcref(<name>) or a\n * lambda expression.\n */\n    int\nset_thesaurusfunc_option(void)\n{\n    int\tretval;\n\n    if (*curbuf->b_p_tsrfu != NUL)\n    {\n\t// buffer-local option set\n\tretval = option_set_callback_func(curbuf->b_p_tsrfu,\n\t\t\t\t\t\t\t&curbuf->b_tsrfu_cb);\n    }\n    else\n    {\n\t// global option set\n\tretval = option_set_callback_func(p_tsrfu, &tsrfu_cb);\n    }\n\n    return retval;\n}\n\n/*\n * Mark the global 'completefunc' 'omnifunc' and 'thesaurusfunc' callbacks with\n * \"copyID\" so that they are not garbage collected.\n */\n    int\nset_ref_in_insexpand_funcs(int copyID)\n{\n    int abort = FALSE;\n\n    abort = set_ref_in_callback(&cfu_cb, copyID);\n    abort = abort || set_ref_in_callback(&ofu_cb, copyID);\n    abort = abort || set_ref_in_callback(&tsrfu_cb, copyID);\n\n    return abort;\n}\n\n/*\n * Get the user-defined completion function name for completion \"type\"\n */\n    static char_u *\nget_complete_funcname(int type)\n{\n    switch (type)\n    {\n\tcase CTRL_X_FUNCTION:\n\t    return curbuf->b_p_cfu;\n\tcase CTRL_X_OMNI:\n\t    return curbuf->b_p_ofu;\n\tcase CTRL_X_THESAURUS:\n\t    return *curbuf->b_p_tsrfu == NUL ? p_tsrfu : curbuf->b_p_tsrfu;\n\tdefault:\n\t    return (char_u *)\"\";\n    }\n}\n\n/*\n * Get the callback to use for insert mode completion.\n */\n    static callback_T *\nget_insert_callback(int type)\n{\n    if (type == CTRL_X_FUNCTION)\n\treturn &curbuf->b_cfu_cb;\n    if (type == CTRL_X_OMNI)\n\treturn &curbuf->b_ofu_cb;\n    // CTRL_X_THESAURUS\n    return (*curbuf->b_p_tsrfu != NUL) ? &curbuf->b_tsrfu_cb : &tsrfu_cb;\n}\n\n/*\n * Execute user defined complete function 'completefunc', 'omnifunc' or\n * 'thesaurusfunc', and get matches in \"matches\".\n * \"type\" is either CTRL_X_OMNI or CTRL_X_FUNCTION or CTRL_X_THESAURUS.\n */\n    static void\nexpand_by_function(int type, char_u *base)\n{\n    list_T      *matchlist = NULL;\n    dict_T\t*matchdict = NULL;\n    typval_T\targs[3];\n    char_u\t*funcname;\n    pos_T\tpos;\n    callback_T\t*cb;\n    typval_T\trettv;\n    int\t\tsave_State = State;\n    int\t\tretval;\n\n    funcname = get_complete_funcname(type);\n    if (*funcname == NUL)\n\treturn;\n\n    // Call 'completefunc' to obtain the list of matches.\n    args[0].v_type = VAR_NUMBER;\n    args[0].vval.v_number = 0;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = base != NULL ? base : (char_u *)\"\";\n    args[2].v_type = VAR_UNKNOWN;\n\n    pos = curwin->w_cursor;\n    // Lock the text to avoid weird things from happening.  Also disallow\n    // switching to another window, it should not be needed and may end up in\n    // Insert mode in another buffer.\n    ++textlock;\n\n    cb = get_insert_callback(type);\n    retval = call_callback(cb, 0, &rettv, 2, args);\n\n    // Call a function, which returns a list or dict.\n    if (retval == OK)\n    {\n\tswitch (rettv.v_type)\n\t{\n\t    case VAR_LIST:\n\t\tmatchlist = rettv.vval.v_list;\n\t\tbreak;\n\t    case VAR_DICT:\n\t\tmatchdict = rettv.vval.v_dict;\n\t\tbreak;\n\t    case VAR_SPECIAL:\n\t\tif (rettv.vval.v_number == VVAL_NONE)\n\t\t    compl_opt_suppress_empty = TRUE;\n\t\t// FALLTHROUGH\n\t    default:\n\t\t// TODO: Give error message?\n\t\tclear_tv(&rettv);\n\t\tbreak;\n\t}\n    }\n    --textlock;\n\n    curwin->w_cursor = pos;\t// restore the cursor position\n    validate_cursor();\n    if (!EQUAL_POS(curwin->w_cursor, pos))\n    {\n\temsg(_(e_complete_function_deleted_text));\n\tgoto theend;\n    }\n\n    if (matchlist != NULL)\n\tins_compl_add_list(matchlist);\n    else if (matchdict != NULL)\n\tins_compl_add_dict(matchdict);\n\ntheend:\n    // Restore State, it might have been changed.\n    State = save_State;\n\n    if (matchdict != NULL)\n\tdict_unref(matchdict);\n    if (matchlist != NULL)\n\tlist_unref(matchlist);\n}\n#endif // FEAT_COMPL_FUNC\n\n#if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Add a match to the list of matches from a typeval_T.\n * If the given string is already in the list of completions, then return\n * NOTDONE, otherwise add it to the list and return OK.  If there is an error,\n * maybe because alloc() returns NULL, then FAIL is returned.\n * When \"fast\" is TRUE use fast_breakcheck() instead of ui_breakcheck().\n */\n    static int\nins_compl_add_tv(typval_T *tv, int dir, int fast)\n{\n    char_u\t*word;\n    int\t\tdup = FALSE;\n    int\t\tempty = FALSE;\n    int\t\tflags = fast ? CP_FAST : 0;\n    char_u\t*(cptext[CPT_COUNT]);\n    typval_T\tuser_data;\n    int\t\tstatus;\n\n    user_data.v_type = VAR_UNKNOWN;\n    if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)\n    {\n\tword = dict_get_string(tv->vval.v_dict, \"word\", FALSE);\n\tcptext[CPT_ABBR] = dict_get_string(tv->vval.v_dict, \"abbr\", FALSE);\n\tcptext[CPT_MENU] = dict_get_string(tv->vval.v_dict, \"menu\", FALSE);\n\tcptext[CPT_KIND] = dict_get_string(tv->vval.v_dict, \"kind\", FALSE);\n\tcptext[CPT_INFO] = dict_get_string(tv->vval.v_dict, \"info\", FALSE);\n\tdict_get_tv(tv->vval.v_dict, \"user_data\", &user_data);\n\tif (dict_get_string(tv->vval.v_dict, \"icase\", FALSE) != NULL\n\t\t\t\t  && dict_get_number(tv->vval.v_dict, \"icase\"))\n\t    flags |= CP_ICASE;\n\tif (dict_get_string(tv->vval.v_dict, \"dup\", FALSE) != NULL)\n\t    dup = dict_get_number(tv->vval.v_dict, \"dup\");\n\tif (dict_get_string(tv->vval.v_dict, \"empty\", FALSE) != NULL)\n\t    empty = dict_get_number(tv->vval.v_dict, \"empty\");\n\tif (dict_get_string(tv->vval.v_dict, \"equal\", FALSE) != NULL\n\t\t\t\t  && dict_get_number(tv->vval.v_dict, \"equal\"))\n\t    flags |= CP_EQUAL;\n    }\n    else\n    {\n\tword = tv_get_string_chk(tv);\n\tCLEAR_FIELD(cptext);\n    }\n    if (word == NULL || (!empty && *word == NUL))\n    {\n\tclear_tv(&user_data);\n\treturn FAIL;\n    }\n    status = ins_compl_add(word, -1, NULL, cptext, &user_data, dir, flags, dup);\n    if (status != OK)\n\tclear_tv(&user_data);\n    return status;\n}\n\n/*\n * Add completions from a list.\n */\n    static void\nins_compl_add_list(list_T *list)\n{\n    listitem_T\t*li;\n    int\t\tdir = compl_direction;\n\n    // Go through the List with matches and add each of them.\n    CHECK_LIST_MATERIALIZE(list);\n    FOR_ALL_LIST_ITEMS(list, li)\n    {\n\tif (ins_compl_add_tv(&li->li_tv, dir, TRUE) == OK)\n\t    // if dir was BACKWARD then honor it just once\n\t    dir = FORWARD;\n\telse if (did_emsg)\n\t    break;\n    }\n}\n\n/*\n * Add completions from a dict.\n */\n    static void\nins_compl_add_dict(dict_T *dict)\n{\n    dictitem_T\t*di_refresh;\n    dictitem_T\t*di_words;\n\n    // Check for optional \"refresh\" item.\n    compl_opt_refresh_always = FALSE;\n    di_refresh = dict_find(dict, (char_u *)\"refresh\", 7);\n    if (di_refresh != NULL && di_refresh->di_tv.v_type == VAR_STRING)\n    {\n\tchar_u\t*v = di_refresh->di_tv.vval.v_string;\n\n\tif (v != NULL && STRCMP(v, (char_u *)\"always\") == 0)\n\t    compl_opt_refresh_always = TRUE;\n    }\n\n    // Add completions from a \"words\" list.\n    di_words = dict_find(dict, (char_u *)\"words\", 5);\n    if (di_words != NULL && di_words->di_tv.v_type == VAR_LIST)\n\tins_compl_add_list(di_words->di_tv.vval.v_list);\n}\n\n/*\n * Start completion for the complete() function.\n * \"startcol\" is where the matched text starts (1 is first column).\n * \"list\" is the list of matches.\n */\n    static void\nset_completion(colnr_T startcol, list_T *list)\n{\n    int save_w_wrow = curwin->w_wrow;\n    int save_w_leftcol = curwin->w_leftcol;\n    int flags = CP_ORIGINAL_TEXT;\n\n    // If already doing completions stop it.\n    if (ctrl_x_mode_not_default())\n\tins_compl_prep(' ');\n    ins_compl_clear();\n    ins_compl_free();\n    compl_get_longest = compl_longest;\n\n    compl_direction = FORWARD;\n    if (startcol > curwin->w_cursor.col)\n\tstartcol = curwin->w_cursor.col;\n    compl_col = startcol;\n    compl_length = (int)curwin->w_cursor.col - (int)startcol;\n    // compl_pattern doesn't need to be set\n    compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);\n    if (p_ic)\n\tflags |= CP_ICASE;\n    if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,\n\t\t\t\t\t      -1, NULL, NULL, NULL, 0,\n\t\t\t\t\t      flags | CP_FAST, FALSE) != OK)\n\treturn;\n\n    ctrl_x_mode = CTRL_X_EVAL;\n\n    ins_compl_add_list(list);\n    compl_matches = ins_compl_make_cyclic();\n    compl_started = TRUE;\n    compl_used_match = TRUE;\n    compl_cont_status = 0;\n\n    compl_curr_match = compl_first_match;\n    int no_select = compl_no_select || compl_longest;\n    if (compl_no_insert || no_select)\n    {\n\tins_complete(K_DOWN, FALSE);\n\tif (no_select)\n\t    // Down/Up has no real effect.\n\t    ins_complete(K_UP, FALSE);\n    }\n    else\n\tins_complete(Ctrl_N, FALSE);\n    compl_enter_selects = compl_no_insert;\n\n    // Lazily show the popup menu, unless we got interrupted.\n    if (!compl_interrupted)\n\tshow_pum(save_w_wrow, save_w_leftcol);\n    may_trigger_modechanged();\n    out_flush();\n}\n\n/*\n * \"complete()\" function\n */\n    void\nf_complete(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    int\t    startcol;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_list_arg(argvars, 1) == FAIL))\n\treturn;\n\n    if ((State & MODE_INSERT) == 0)\n    {\n\temsg(_(e_complete_can_only_be_used_in_insert_mode));\n\treturn;\n    }\n\n    // Check for undo allowed here, because if something was already inserted\n    // the line was already saved for undo and this check isn't done.\n    if (!undo_allowed())\n\treturn;\n\n    if (check_for_nonnull_list_arg(argvars, 1) != FAIL)\n    {\n\tstartcol = (int)tv_get_number_chk(&argvars[0], NULL);\n\tif (startcol > 0)\n\t    set_completion(startcol - 1, argvars[1].vval.v_list);\n    }\n}\n\n/*\n * \"complete_add()\" function\n */\n    void\nf_complete_add(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script() && check_for_string_or_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = ins_compl_add_tv(&argvars[0], 0, FALSE);\n}\n\n/*\n * \"complete_check()\" function\n */\n    void\nf_complete_check(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    int\t\tsaved = RedrawingDisabled;\n\n    RedrawingDisabled = 0;\n    ins_compl_check_keys(0, TRUE);\n    rettv->vval.v_number = ins_compl_interrupted();\n    RedrawingDisabled = saved;\n}\n\n/*\n * Return Insert completion mode name string\n */\n    static char_u *\nins_compl_mode(void)\n{\n    if (ctrl_x_mode_not_defined_yet() || ctrl_x_mode_scroll() || compl_started)\n\treturn (char_u *)ctrl_x_mode_names[ctrl_x_mode & ~CTRL_X_WANT_IDENT];\n\n    return (char_u *)\"\";\n}\n\n/*\n * Assign the sequence number to all the completion matches which don't have\n * one assigned yet.\n */\n    static void\nins_compl_update_sequence_numbers()\n{\n    int\t\tnumber = 0;\n    compl_T\t*match;\n\n    if (compl_dir_forward())\n    {\n\t// search backwards for the first valid (!= -1) number.\n\t// This should normally succeed already at the first loop\n\t// cycle, so it's fast!\n\tfor (match = compl_curr_match->cp_prev; match != NULL\n\t\t&& !is_first_match(match); match = match->cp_prev)\n\t    if (match->cp_number != -1)\n\t    {\n\t\tnumber = match->cp_number;\n\t\tbreak;\n\t    }\n\tif (match != NULL)\n\t    // go up and assign all numbers which are not assigned\n\t    // yet\n\t    for (match = match->cp_next;\n\t\t    match != NULL && match->cp_number == -1;\n\t\t\t\t\t   match = match->cp_next)\n\t\tmatch->cp_number = ++number;\n    }\n    else // BACKWARD\n    {\n\t// search forwards (upwards) for the first valid (!= -1)\n\t// number.  This should normally succeed already at the\n\t// first loop cycle, so it's fast!\n\tfor (match = compl_curr_match->cp_next; match != NULL\n\t\t&& !is_first_match(match); match = match->cp_next)\n\t    if (match->cp_number != -1)\n\t    {\n\t\tnumber = match->cp_number;\n\t\tbreak;\n\t    }\n\tif (match != NULL)\n\t    // go down and assign all numbers which are not\n\t    // assigned yet\n\t    for (match = match->cp_prev; match\n\t\t    && match->cp_number == -1;\n\t\t\t\t\t   match = match->cp_prev)\n\t\tmatch->cp_number = ++number;\n    }\n}\n\n/*\n * Get complete information\n */\n    static void\nget_complete_info(list_T *what_list, dict_T *retdict)\n{\n    int\t\tret = OK;\n    listitem_T\t*item;\n#define CI_WHAT_MODE\t\t0x01\n#define CI_WHAT_PUM_VISIBLE\t0x02\n#define CI_WHAT_ITEMS\t\t0x04\n#define CI_WHAT_SELECTED\t0x08\n#define CI_WHAT_INSERTED\t0x10\n#define CI_WHAT_ALL\t\t0xff\n    int\t\twhat_flag;\n\n    if (what_list == NULL)\n\twhat_flag = CI_WHAT_ALL;\n    else\n    {\n\twhat_flag = 0;\n\tCHECK_LIST_MATERIALIZE(what_list);\n\tFOR_ALL_LIST_ITEMS(what_list, item)\n\t{\n\t    char_u *what = tv_get_string(&item->li_tv);\n\n\t    if (STRCMP(what, \"mode\") == 0)\n\t\twhat_flag |= CI_WHAT_MODE;\n\t    else if (STRCMP(what, \"pum_visible\") == 0)\n\t\twhat_flag |= CI_WHAT_PUM_VISIBLE;\n\t    else if (STRCMP(what, \"items\") == 0)\n\t\twhat_flag |= CI_WHAT_ITEMS;\n\t    else if (STRCMP(what, \"selected\") == 0)\n\t\twhat_flag |= CI_WHAT_SELECTED;\n\t    else if (STRCMP(what, \"inserted\") == 0)\n\t\twhat_flag |= CI_WHAT_INSERTED;\n\t}\n    }\n\n    if (ret == OK && (what_flag & CI_WHAT_MODE))\n\tret = dict_add_string(retdict, \"mode\", ins_compl_mode());\n\n    if (ret == OK && (what_flag & CI_WHAT_PUM_VISIBLE))\n\tret = dict_add_number(retdict, \"pum_visible\", pum_visible());\n\n    if (ret == OK && (what_flag & CI_WHAT_ITEMS))\n    {\n\tlist_T\t    *li;\n\tdict_T\t    *di;\n\tcompl_T     *match;\n\n\tli = list_alloc();\n\tif (li == NULL)\n\t    return;\n\tret = dict_add_list(retdict, \"items\", li);\n\tif (ret == OK && compl_first_match != NULL)\n\t{\n\t    match = compl_first_match;\n\t    do\n\t    {\n\t\tif (!match_at_original_text(match))\n\t\t{\n\t\t    di = dict_alloc();\n\t\t    if (di == NULL)\n\t\t\treturn;\n\t\t    ret = list_append_dict(li, di);\n\t\t    if (ret != OK)\n\t\t\treturn;\n\t\t    dict_add_string(di, \"word\", match->cp_str);\n\t\t    dict_add_string(di, \"abbr\", match->cp_text[CPT_ABBR]);\n\t\t    dict_add_string(di, \"menu\", match->cp_text[CPT_MENU]);\n\t\t    dict_add_string(di, \"kind\", match->cp_text[CPT_KIND]);\n\t\t    dict_add_string(di, \"info\", match->cp_text[CPT_INFO]);\n\t\t    if (match->cp_user_data.v_type == VAR_UNKNOWN)\n\t\t\t// Add an empty string for backwards compatibility\n\t\t\tdict_add_string(di, \"user_data\", (char_u *)\"\");\n\t\t    else\n\t\t\tdict_add_tv(di, \"user_data\", &match->cp_user_data);\n\t\t}\n\t\tmatch = match->cp_next;\n\t    }\n\t    while (match != NULL && !is_first_match(match));\n\t}\n    }\n\n    if (ret == OK && (what_flag & CI_WHAT_SELECTED))\n    {\n\tif (compl_curr_match != NULL && compl_curr_match->cp_number == -1)\n\t    ins_compl_update_sequence_numbers();\n\tret = dict_add_number(retdict, \"selected\", compl_curr_match != NULL\n\t\t\t\t      ? compl_curr_match->cp_number - 1 : -1);\n    }\n\n    if (ret == OK && (what_flag & CI_WHAT_INSERTED))\n    {\n\t// TODO\n    }\n}\n\n/*\n * \"complete_info()\" function\n */\n    void\nf_complete_info(typval_T *argvars, typval_T *rettv)\n{\n    list_T\t*what_list = NULL;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_list_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tif (check_for_list_arg(argvars, 0) == FAIL)\n\t    return;\n\twhat_list = argvars[0].vval.v_list;\n    }\n    get_complete_info(what_list, rettv->vval.v_dict);\n}\n#endif\n\n/*\n * Returns TRUE when using a user-defined function for thesaurus completion.\n */\n    static int\nthesaurus_func_complete(int type UNUSED)\n{\n#ifdef FEAT_COMPL_FUNC\n    return type == CTRL_X_THESAURUS\n\t\t&& (*curbuf->b_p_tsrfu != NUL || *p_tsrfu != NUL);\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return value of process_next_cpt_value()\n */\nenum\n{\n    INS_COMPL_CPT_OK = 1,\n    INS_COMPL_CPT_CONT,\n    INS_COMPL_CPT_END\n};\n\n/*\n * state information used for getting the next set of insert completion\n * matches.\n */\ntypedef struct\n{\n    char_u\t*e_cpt_copy;\t\t// copy of 'complete'\n    char_u\t*e_cpt;\t\t\t// current entry in \"e_cpt_copy\"\n    buf_T\t*ins_buf;\t\t// buffer being scanned\n    pos_T\t*cur_match_pos;\t\t// current match position\n    pos_T\tprev_match_pos;\t\t// previous match position\n    int\t\tset_match_pos;\t\t// save first_match_pos/last_match_pos\n    pos_T\tfirst_match_pos;\t// first match position\n    pos_T\tlast_match_pos;\t\t// last match position\n    int\t\tfound_all;\t\t// found all matches of a certain type.\n    char_u\t*dict;\t\t\t// dictionary file to search\n    int\t\tdict_f;\t\t\t// \"dict\" is an exact file name or not\n} ins_compl_next_state_T;\n\n/*\n * Process the next 'complete' option value in st->e_cpt.\n *\n * If successful, the arguments are set as below:\n *   st->cpt - pointer to the next option value in \"st->cpt\"\n *   compl_type_arg - type of insert mode completion to use\n *   st->found_all - all matches of this type are found\n *   st->ins_buf - search for completions in this buffer\n *   st->first_match_pos - position of the first completion match\n *   st->last_match_pos - position of the last completion match\n *   st->set_match_pos - TRUE if the first match position should be saved to\n *\t\t\t    avoid loops after the search wraps around.\n *   st->dict - name of the dictionary or thesaurus file to search\n *   st->dict_f - flag specifying whether \"dict\" is an exact file name or not\n *\n * Returns INS_COMPL_CPT_OK if the next value is processed successfully.\n * Returns INS_COMPL_CPT_CONT to skip the current completion source matching\n * the \"st->e_cpt\" option value and process the next matching source.\n * Returns INS_COMPL_CPT_END if all the values in \"st->e_cpt\" are processed.\n */\n    static int\nprocess_next_cpt_value(\n\tins_compl_next_state_T *st,\n\tint\t\t*compl_type_arg,\n\tpos_T\t\t*start_match_pos)\n{\n    int\t    compl_type = -1;\n    int\t    status = INS_COMPL_CPT_OK;\n\n    st->found_all = FALSE;\n\n    while (*st->e_cpt == ',' || *st->e_cpt == ' ')\n\tst->e_cpt++;\n\n    if (*st->e_cpt == '.' && !curbuf->b_scanned)\n    {\n\tst->ins_buf = curbuf;\n\tst->first_match_pos = *start_match_pos;\n\t// Move the cursor back one character so that ^N can match the\n\t// word immediately after the cursor.\n\tif (ctrl_x_mode_normal() && dec(&st->first_match_pos) < 0)\n\t{\n\t    // Move the cursor to after the last character in the\n\t    // buffer, so that word at start of buffer is found\n\t    // correctly.\n\t    st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count;\n\t    st->first_match_pos.col =\n\t\t(colnr_T)STRLEN(ml_get(st->first_match_pos.lnum));\n\t}\n\tst->last_match_pos = st->first_match_pos;\n\tcompl_type = 0;\n\n\t// Remember the first match so that the loop stops when we\n\t// wrap and come back there a second time.\n\tst->set_match_pos = TRUE;\n    }\n    else if (vim_strchr((char_u *)\"buwU\", *st->e_cpt) != NULL\n\t    && (st->ins_buf = ins_compl_next_buf(\n\t\t\t\t\t   st->ins_buf, *st->e_cpt)) != curbuf)\n    {\n\t// Scan a buffer, but not the current one.\n\tif (st->ins_buf->b_ml.ml_mfp != NULL)   // loaded buffer\n\t{\n\t    compl_started = TRUE;\n\t    st->first_match_pos.col = st->last_match_pos.col = 0;\n\t    st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count + 1;\n\t    st->last_match_pos.lnum = 0;\n\t    compl_type = 0;\n\t}\n\telse\t// unloaded buffer, scan like dictionary\n\t{\n\t    st->found_all = TRUE;\n\t    if (st->ins_buf->b_fname == NULL)\n\t    {\n\t\tstatus = INS_COMPL_CPT_CONT;\n\t\tgoto done;\n\t    }\n\t    compl_type = CTRL_X_DICTIONARY;\n\t    st->dict = st->ins_buf->b_fname;\n\t    st->dict_f = DICT_EXACT;\n\t}\n\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),\n\t\tst->ins_buf->b_fname == NULL\n\t\t    ? buf_spname(st->ins_buf)\n\t\t    : st->ins_buf->b_sfname == NULL\n\t\t\t? st->ins_buf->b_fname\n\t\t\t: st->ins_buf->b_sfname);\n\t(void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n    }\n    else if (*st->e_cpt == NUL)\n\tstatus = INS_COMPL_CPT_END;\n    else\n    {\n\tif (ctrl_x_mode_line_or_eval())\n\t    compl_type = -1;\n\telse if (*st->e_cpt == 'k' || *st->e_cpt == 's')\n\t{\n\t    if (*st->e_cpt == 'k')\n\t\tcompl_type = CTRL_X_DICTIONARY;\n\t    else\n\t\tcompl_type = CTRL_X_THESAURUS;\n\t    if (*++st->e_cpt != ',' && *st->e_cpt != NUL)\n\t    {\n\t\tst->dict = st->e_cpt;\n\t\tst->dict_f = DICT_FIRST;\n\t    }\n\t}\n#ifdef FEAT_FIND_ID\n\telse if (*st->e_cpt == 'i')\n\t    compl_type = CTRL_X_PATH_PATTERNS;\n\telse if (*st->e_cpt == 'd')\n\t    compl_type = CTRL_X_PATH_DEFINES;\n#endif\n\telse if (*st->e_cpt == ']' || *st->e_cpt == 't')\n\t{\n\t    msg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t    compl_type = CTRL_X_TAGS;\n\t    vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning tags.\"));\n\t    (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t}\n\telse\n\t    compl_type = -1;\n\n\t// in any case e_cpt is advanced to the next entry\n\t(void)copy_option_part(&st->e_cpt, IObuff, IOSIZE, \",\");\n\n\tst->found_all = TRUE;\n\tif (compl_type == -1)\n\t    status = INS_COMPL_CPT_CONT;\n    }\n\ndone:\n    *compl_type_arg = compl_type;\n    return status;\n}\n\n#ifdef FEAT_FIND_ID\n/*\n * Get the next set of identifiers or defines matching \"compl_pattern\" in\n * included files.\n */\n    static void\nget_next_include_file_completion(int compl_type)\n{\n    find_pattern_in_path(compl_pattern, compl_direction,\n\t    (int)STRLEN(compl_pattern), FALSE, FALSE,\n\t    (compl_type == CTRL_X_PATH_DEFINES\n\t     && !(compl_cont_status & CONT_SOL))\n\t    ? FIND_DEFINE : FIND_ANY, 1L, ACTION_EXPAND,\n\t    (linenr_T)1, (linenr_T)MAXLNUM);\n}\n#endif\n\n/*\n * Get the next set of words matching \"compl_pattern\" in dictionary or\n * thesaurus files.\n */\n    static void\nget_next_dict_tsr_completion(int compl_type, char_u *dict, int dict_f)\n{\n#ifdef FEAT_COMPL_FUNC\n    if (thesaurus_func_complete(compl_type))\n\texpand_by_function(compl_type, compl_pattern);\n    else\n#endif\n\tins_compl_dictionaries(\n\t\tdict != NULL ? dict\n\t\t: (compl_type == CTRL_X_THESAURUS\n\t\t    ? (*curbuf->b_p_tsr == NUL ? p_tsr : curbuf->b_p_tsr)\n\t\t    : (*curbuf->b_p_dict == NUL ? p_dict : curbuf->b_p_dict)),\n\t\tcompl_pattern,\n\t\tdict != NULL ? dict_f : 0,\n\t\tcompl_type == CTRL_X_THESAURUS);\n}\n\n/*\n * Get the next set of tag names matching \"compl_pattern\".\n */\n    static void\nget_next_tag_completion(void)\n{\n    int\t\tsave_p_ic;\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    // set p_ic according to p_ic, p_scs and pat for find_tags().\n    save_p_ic = p_ic;\n    p_ic = ignorecase(compl_pattern);\n\n    // Find up to TAG_MANY matches.  Avoids that an enormous number\n    // of matches is found when compl_pattern is empty\n    g_tag_at_cursor = TRUE;\n    if (find_tags(compl_pattern, &num_matches, &matches,\n\t\tTAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP\n\t\t| (ctrl_x_mode_not_default() ? TAG_VERBOSE : 0),\n\t\tTAG_MANY, curbuf->b_ffname) == OK && num_matches > 0)\n\tins_compl_add_matches(num_matches, matches, p_ic);\n    g_tag_at_cursor = FALSE;\n    p_ic = save_p_ic;\n}\n\n/*\n * Get the next set of filename matching \"compl_pattern\".\n */\n    static void\nget_next_filename_completion(void)\n{\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    if (expand_wildcards(1, &compl_pattern, &num_matches, &matches,\n\t\tEW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) != OK)\n\treturn;\n\n    // May change home directory back to \"~\".\n    tilde_replace(compl_pattern, num_matches, matches);\n#ifdef BACKSLASH_IN_FILENAME\n    if (curbuf->b_p_csl[0] != NUL)\n    {\n\tint\t    i;\n\n\tfor (i = 0; i < num_matches; ++i)\n\t{\n\t    char_u\t*ptr = matches[i];\n\n\t    while (*ptr != NUL)\n\t    {\n\t\tif (curbuf->b_p_csl[0] == 's' && *ptr == '\\\\')\n\t\t    *ptr = '/';\n\t\telse if (curbuf->b_p_csl[0] == 'b' && *ptr == '/')\n\t\t    *ptr = '\\\\';\n\t\tptr += (*mb_ptr2len)(ptr);\n\t    }\n\t}\n    }\n#endif\n    ins_compl_add_matches(num_matches, matches, p_fic || p_wic);\n}\n\n/*\n * Get the next set of command-line completions matching \"compl_pattern\".\n */\n    static void\nget_next_cmdline_completion()\n{\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    if (expand_cmdline(&compl_xp, compl_pattern,\n\t\t(int)STRLEN(compl_pattern),\n\t\t&num_matches, &matches) == EXPAND_OK)\n\tins_compl_add_matches(num_matches, matches, FALSE);\n}\n\n/*\n * Get the next set of spell suggestions matching \"compl_pattern\".\n */\n    static void\nget_next_spell_completion(linenr_T lnum UNUSED)\n{\n#ifdef FEAT_SPELL\n    char_u\t**matches;\n    int\t\tnum_matches;\n\n    num_matches = expand_spelling(lnum, compl_pattern, &matches);\n    if (num_matches > 0)\n\tins_compl_add_matches(num_matches, matches, p_ic);\n    else\n\tvim_free(matches);\n#endif\n}\n\n/*\n * Return the next word or line from buffer \"ins_buf\" at position\n * \"cur_match_pos\" for completion.  The length of the match is set in \"len\".\n */\n    static char_u *\nins_comp_get_next_word_or_line(\n\tbuf_T\t*ins_buf,\t\t// buffer being scanned\n\tpos_T\t*cur_match_pos,\t\t// current match position\n\tint\t*match_len,\n\tint\t*cont_s_ipos)\t\t// next ^X<> will set initial_pos\n{\n    char_u\t*ptr;\n    int\t\tlen;\n\n    *match_len = 0;\n    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +\n\tcur_match_pos->col;\n    if (ctrl_x_mode_line_or_eval())\n    {\n\tif (compl_status_adding())\n\t{\n\t    if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)\n\t\treturn NULL;\n\t    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t    if (!p_paste)\n\t\tptr = skipwhite(ptr);\n\t}\n\tlen = (int)STRLEN(ptr);\n    }\n    else\n    {\n\tchar_u\t*tmp_ptr = ptr;\n\n\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))\n\t{\n\t    tmp_ptr += compl_length;\n\t    // Skip if already inside a word.\n\t    if (vim_iswordp(tmp_ptr))\n\t\treturn NULL;\n\t    // Find start of next word.\n\t    tmp_ptr = find_word_start(tmp_ptr);\n\t}\n\t// Find end of this word.\n\ttmp_ptr = find_word_end(tmp_ptr);\n\tlen = (int)(tmp_ptr - ptr);\n\n\tif (compl_status_adding() && len == compl_length)\n\t{\n\t    if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)\n\t    {\n\t\t// Try next line, if any. the new word will be\n\t\t// \"join\" as if the normal command \"J\" was used.\n\t\t// IOSIZE is always greater than\n\t\t// compl_length, so the next STRNCPY always\n\t\t// works -- Acevedo\n\t\tSTRNCPY(IObuff, ptr, len);\n\t\tptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n\t\ttmp_ptr = ptr = skipwhite(ptr);\n\t\t// Find start of next word.\n\t\ttmp_ptr = find_word_start(tmp_ptr);\n\t\t// Find end of next word.\n\t\ttmp_ptr = find_word_end(tmp_ptr);\n\t\tif (tmp_ptr > ptr)\n\t\t{\n\t\t    if (*ptr != ')' && IObuff[len - 1] != TAB)\n\t\t    {\n\t\t\tif (IObuff[len - 1] != ' ')\n\t\t\t    IObuff[len++] = ' ';\n\t\t\t// IObuf =~ \"\\k.* \", thus len >= 2\n\t\t\tif (p_js\n\t\t\t\t&& (IObuff[len - 2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP)\n\t\t\t\t\t== NULL\n\t\t\t\t\t&& (IObuff[len - 2] == '?'\n\t\t\t\t\t    || IObuff[len - 2] == '!'))))\n\t\t\t    IObuff[len++] = ' ';\n\t\t    }\n\t\t    // copy as much as possible of the new word\n\t\t    if (tmp_ptr - ptr >= IOSIZE - len)\n\t\t\ttmp_ptr = ptr + IOSIZE - len - 1;\n\t\t    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);\n\t\t    len += (int)(tmp_ptr - ptr);\n\t\t    *cont_s_ipos = TRUE;\n\t\t}\n\t\tIObuff[len] = NUL;\n\t\tptr = IObuff;\n\t    }\n\t    if (len == compl_length)\n\t\treturn NULL;\n\t}\n    }\n\n    *match_len = len;\n    return ptr;\n}\n\n/*\n * Get the next set of words matching \"compl_pattern\" for default completion(s)\n * (normal ^P/^N and ^X^L).\n * Search for \"compl_pattern\" in the buffer \"st->ins_buf\" starting from the\n * position \"st->start_pos\" in the \"compl_direction\" direction. If\n * \"st->set_match_pos\" is TRUE, then set the \"st->first_match_pos\" and\n * \"st->last_match_pos\".\n * Returns OK if a new next match is found, otherwise returns FAIL.\n */\n    static int\nget_next_default_completion(ins_compl_next_state_T *st, pos_T *start_pos)\n{\n    int\t\tfound_new_match = FAIL;\n    int\t\tsave_p_scs;\n    int\t\tsave_p_ws;\n    int\t\tlooped_around = FALSE;\n    char_u\t*ptr;\n    int\t\tlen;\n\n    // If 'infercase' is set, don't use 'smartcase' here\n    save_p_scs = p_scs;\n    if (st->ins_buf->b_p_inf)\n\tp_scs = FALSE;\n\n    //\tBuffers other than curbuf are scanned from the beginning or the\n    //\tend but never from the middle, thus setting nowrapscan in this\n    //\tbuffer is a good idea, on the other hand, we always set\n    //\twrapscan for curbuf to avoid missing matches -- Acevedo,Webb\n    save_p_ws = p_ws;\n    if (st->ins_buf != curbuf)\n\tp_ws = FALSE;\n    else if (*st->e_cpt == '.')\n\tp_ws = TRUE;\n    looped_around = FALSE;\n    for (;;)\n    {\n\tint\tcont_s_ipos = FALSE;\n\n\t++msg_silent;  // Don't want messages for wrapscan.\n\n\t// ctrl_x_mode_line_or_eval() || word-wise search that\n\t// has added a word that was at the beginning of the line\n\tif (ctrl_x_mode_line_or_eval() || (compl_cont_status & CONT_SOL))\n\t    found_new_match = search_for_exact_line(st->ins_buf,\n\t\t\t    st->cur_match_pos, compl_direction, compl_pattern);\n\telse\n\t    found_new_match = searchit(NULL, st->ins_buf, st->cur_match_pos,\n\t\t\t\tNULL, compl_direction, compl_pattern, 1L,\n\t\t\t\tSEARCH_KEEP + SEARCH_NFMSG, RE_LAST, NULL);\n\t--msg_silent;\n\tif (!compl_started || st->set_match_pos)\n\t{\n\t    // set \"compl_started\" even on fail\n\t    compl_started = TRUE;\n\t    st->first_match_pos = *st->cur_match_pos;\n\t    st->last_match_pos = *st->cur_match_pos;\n\t    st->set_match_pos = FALSE;\n\t}\n\telse if (st->first_match_pos.lnum == st->last_match_pos.lnum\n\t\t&& st->first_match_pos.col == st->last_match_pos.col)\n\t{\n\t    found_new_match = FAIL;\n\t}\n\telse if (compl_dir_forward()\n\t\t&& (st->prev_match_pos.lnum > st->cur_match_pos->lnum\n\t\t    || (st->prev_match_pos.lnum == st->cur_match_pos->lnum\n\t\t\t&& st->prev_match_pos.col >= st->cur_match_pos->col)))\n\t{\n\t    if (looped_around)\n\t\tfound_new_match = FAIL;\n\t    else\n\t\tlooped_around = TRUE;\n\t}\n\telse if (!compl_dir_forward()\n\t\t&& (st->prev_match_pos.lnum < st->cur_match_pos->lnum\n\t\t    || (st->prev_match_pos.lnum == st->cur_match_pos->lnum\n\t\t\t&& st->prev_match_pos.col <= st->cur_match_pos->col)))\n\t{\n\t    if (looped_around)\n\t\tfound_new_match = FAIL;\n\t    else\n\t\tlooped_around = TRUE;\n\t}\n\tst->prev_match_pos = *st->cur_match_pos;\n\tif (found_new_match == FAIL)\n\t    break;\n\n\t// when ADDING, the text before the cursor matches, skip it\n\tif (compl_status_adding() && st->ins_buf == curbuf\n\t\t&& start_pos->lnum == st->cur_match_pos->lnum\n\t\t&& start_pos->col  == st->cur_match_pos->col)\n\t    continue;\n\n\tptr = ins_comp_get_next_word_or_line(st->ins_buf, st->cur_match_pos,\n\t\t\t\t\t\t\t&len, &cont_s_ipos);\n\tif (ptr == NULL)\n\t    continue;\n\n\tif (ins_compl_add_infercase(ptr, len, p_ic,\n\t\t    st->ins_buf == curbuf ? NULL : st->ins_buf->b_sfname,\n\t\t    0, cont_s_ipos) != NOTDONE)\n\t{\n\t    found_new_match = OK;\n\t    break;\n\t}\n    }\n    p_scs = save_p_scs;\n    p_ws = save_p_ws;\n\n    return found_new_match;\n}\n\n/*\n * get the next set of completion matches for \"type\".\n * Returns TRUE if a new match is found. Otherwise returns FALSE.\n */\n    static int\nget_next_completion_match(int type, ins_compl_next_state_T *st, pos_T *ini)\n{\n    int\tfound_new_match = FALSE;\n\n    switch (type)\n    {\n\tcase -1:\n\t    break;\n#ifdef FEAT_FIND_ID\n\tcase CTRL_X_PATH_PATTERNS:\n\tcase CTRL_X_PATH_DEFINES:\n\t    get_next_include_file_completion(type);\n\t    break;\n#endif\n\n\tcase CTRL_X_DICTIONARY:\n\tcase CTRL_X_THESAURUS:\n\t    get_next_dict_tsr_completion(type, st->dict, st->dict_f);\n\t    st->dict = NULL;\n\t    break;\n\n\tcase CTRL_X_TAGS:\n\t    get_next_tag_completion();\n\t    break;\n\n\tcase CTRL_X_FILES:\n\t    get_next_filename_completion();\n\t    break;\n\n\tcase CTRL_X_CMDLINE:\n\tcase CTRL_X_CMDLINE_CTRL_X:\n\t    get_next_cmdline_completion();\n\t    break;\n\n#ifdef FEAT_COMPL_FUNC\n\tcase CTRL_X_FUNCTION:\n\tcase CTRL_X_OMNI:\n\t    expand_by_function(type, compl_pattern);\n\t    break;\n#endif\n\n\tcase CTRL_X_SPELL:\n\t    get_next_spell_completion(st->first_match_pos.lnum);\n\t    break;\n\n\tdefault:\t// normal ^P/^N and ^X^L\n\t    found_new_match = get_next_default_completion(st, ini);\n\t    if (found_new_match == FAIL && st->ins_buf == curbuf)\n\t\tst->found_all = TRUE;\n    }\n\n    // check if compl_curr_match has changed, (e.g. other type of\n    // expansion added something)\n    if (type != 0 && compl_curr_match != compl_old_match)\n\tfound_new_match = OK;\n\n    return found_new_match;\n}\n\n/*\n * Get the next expansion(s), using \"compl_pattern\".\n * The search starts at position \"ini\" in curbuf and in the direction\n * compl_direction.\n * When \"compl_started\" is FALSE start at that position, otherwise continue\n * where we stopped searching before.\n * This may return before finding all the matches.\n * Return the total number of matches or -1 if still unknown -- Acevedo\n */\n    static int\nins_compl_get_exp(pos_T *ini)\n{\n    static ins_compl_next_state_T   st;\n    static int\t\t\t    st_cleared = FALSE;\n    int\t\ti;\n    int\t\tfound_new_match;\n    int\t\ttype = ctrl_x_mode;\n\n    if (!compl_started)\n    {\n\tbuf_T *buf;\n\n\tFOR_ALL_BUFFERS(buf)\n\t    buf->b_scanned = 0;\n\tif (!st_cleared)\n\t{\n\t    CLEAR_FIELD(st);\n\t    st_cleared = TRUE;\n\t}\n\tst.found_all = FALSE;\n\tst.ins_buf = curbuf;\n\tvim_free(st.e_cpt_copy);\n\t// Make a copy of 'complete', if case the buffer is wiped out.\n\tst.e_cpt_copy = vim_strsave((compl_cont_status & CONT_LOCAL)\n\t\t\t\t\t    ? (char_u *)\".\" : curbuf->b_p_cpt);\n\tst.e_cpt = st.e_cpt_copy == NULL ? (char_u *)\"\" : st.e_cpt_copy;\n\tst.last_match_pos = st.first_match_pos = *ini;\n    }\n    else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))\n\tst.ins_buf = curbuf;  // In case the buffer was wiped out.\n\n    compl_old_match = compl_curr_match;\t// remember the last current match\n    st.cur_match_pos = (compl_dir_forward())\n\t\t\t\t? &st.last_match_pos : &st.first_match_pos;\n\n    // For ^N/^P loop over all the flags/windows/buffers in 'complete'.\n    for (;;)\n    {\n\tfound_new_match = FAIL;\n\tst.set_match_pos = FALSE;\n\n\t// For ^N/^P pick a new entry from e_cpt if compl_started is off,\n\t// or if found_all says this entry is done.  For ^X^L only use the\n\t// entries from 'complete' that look in loaded buffers.\n\tif ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())\n\t\t\t\t\t&& (!compl_started || st.found_all))\n\t{\n\t    int status = process_next_cpt_value(&st, &type, ini);\n\n\t    if (status == INS_COMPL_CPT_END)\n\t\tbreak;\n\t    if (status == INS_COMPL_CPT_CONT)\n\t\tcontinue;\n\t}\n\n\t// If complete() was called then compl_pattern has been reset.  The\n\t// following won't work then, bail out.\n\tif (compl_pattern == NULL)\n\t    break;\n\n\t// get the next set of completion matches\n\tfound_new_match = get_next_completion_match(type, &st, ini);\n\n\t// break the loop for specialized modes (use 'complete' just for the\n\t// generic ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new\n\t// match\n\tif ((ctrl_x_mode_not_default() && !ctrl_x_mode_line_or_eval())\n\t\t\t\t\t\t|| found_new_match != FAIL)\n\t{\n\t    if (got_int)\n\t\tbreak;\n\t    // Fill the popup menu as soon as possible.\n\t    if (type != -1)\n\t\tins_compl_check_keys(0, FALSE);\n\n\t    if ((ctrl_x_mode_not_default()\n\t\t\t&& !ctrl_x_mode_line_or_eval()) || compl_interrupted)\n\t\tbreak;\n\t    compl_started = TRUE;\n\t}\n\telse\n\t{\n\t    // Mark a buffer scanned when it has been scanned completely\n\t    if (type == 0 || type == CTRL_X_PATH_PATTERNS)\n\t\tst.ins_buf->b_scanned = TRUE;\n\n\t    compl_started = FALSE;\n\t}\n    }\n    compl_started = TRUE;\n\n    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())\n\t    && *st.e_cpt == NUL)\t\t// Got to end of 'complete'\n\tfound_new_match = FAIL;\n\n    i = -1;\t\t// total of matches, unknown\n    if (found_new_match == FAIL || (ctrl_x_mode_not_default()\n\t\t\t\t\t       && !ctrl_x_mode_line_or_eval()))\n\ti = ins_compl_make_cyclic();\n\n    if (compl_old_match != NULL)\n    {\n\t// If several matches were added (FORWARD) or the search failed and has\n\t// just been made cyclic then we have to move compl_curr_match to the\n\t// next or previous entry (if any) -- Acevedo\n\tcompl_curr_match = compl_dir_forward() ? compl_old_match->cp_next\n\t\t\t\t\t\t    : compl_old_match->cp_prev;\n\tif (compl_curr_match == NULL)\n\t    compl_curr_match = compl_old_match;\n    }\n    may_trigger_modechanged();\n\n    return i;\n}\n\n/*\n * Update \"compl_shown_match\" to the actually shown match, it may differ when\n * \"compl_leader\" is used to omit some of the matches.\n */\n    static void\nins_compl_update_shown_match(void)\n{\n    while (!ins_compl_equal(compl_shown_match,\n\t\tcompl_leader, (int)STRLEN(compl_leader))\n\t    && compl_shown_match->cp_next != NULL\n\t    && !is_first_match(compl_shown_match->cp_next))\n\tcompl_shown_match = compl_shown_match->cp_next;\n\n    // If we didn't find it searching forward, and compl_shows_dir is\n    // backward, find the last match.\n    if (compl_shows_dir_backward()\n\t    && !ins_compl_equal(compl_shown_match,\n\t\tcompl_leader, (int)STRLEN(compl_leader))\n\t    && (compl_shown_match->cp_next == NULL\n\t\t|| is_first_match(compl_shown_match->cp_next)))\n    {\n\twhile (!ins_compl_equal(compl_shown_match,\n\t\t    compl_leader, (int)STRLEN(compl_leader))\n\t\t&& compl_shown_match->cp_prev != NULL\n\t\t&& !is_first_match(compl_shown_match->cp_prev))\n\t    compl_shown_match = compl_shown_match->cp_prev;\n    }\n}\n\n/*\n * Delete the old text being completed.\n */\n    void\nins_compl_delete(void)\n{\n    int\t    col;\n\n    // In insert mode: Delete the typed part.\n    // In replace mode: Put the old characters back, if any.\n    col = compl_col + (compl_status_adding() ? compl_length : 0);\n    if ((int)curwin->w_cursor.col > col)\n    {\n\tif (stop_arrow() == FAIL)\n\t    return;\n\tbackspace_until_column(col);\n    }\n\n    // TODO: is this sufficient for redrawing?  Redrawing everything causes\n    // flicker, thus we can't do that.\n    changed_cline_bef_curs();\n#ifdef FEAT_EVAL\n    // clear v:completed_item\n    set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc_lock(VAR_FIXED));\n#endif\n}\n\n/*\n * Insert the new text being completed.\n * \"in_compl_func\" is TRUE when called from complete_check().\n */\n    void\nins_compl_insert(int in_compl_func)\n{\n    int compl_len = get_compl_len();\n\n    // Make sure we don't go over the end of the string, this can happen with\n    // illegal bytes.\n    if (compl_len < (int)STRLEN(compl_shown_match->cp_str))\n\tins_bytes(compl_shown_match->cp_str + compl_len);\n    if (match_at_original_text(compl_shown_match))\n\tcompl_used_match = FALSE;\n    else\n\tcompl_used_match = TRUE;\n#ifdef FEAT_EVAL\n    {\n\tdict_T *dict = ins_compl_dict_alloc(compl_shown_match);\n\n\tset_vim_var_dict(VV_COMPLETED_ITEM, dict);\n    }\n#endif\n    if (!in_compl_func)\n\tcompl_curr_match = compl_shown_match;\n}\n\n/*\n * show the file name for the completion match (if any).  Truncate the file\n * name to avoid a wait for return.\n */\n    static void\nins_compl_show_filename(void)\n{\n    char\t*lead = _(\"match in file\");\n    int\t\tspace = sc_col - vim_strsize((char_u *)lead) - 2;\n    char_u\t*s;\n    char_u\t*e;\n\n    if (space <= 0)\n\treturn;\n\n    // We need the tail that fits.  With double-byte encoding going\n    // back from the end is very slow, thus go from the start and keep\n    // the text that fits in \"space\" between \"s\" and \"e\".\n    for (s = e = compl_shown_match->cp_fname; *e != NUL; MB_PTR_ADV(e))\n    {\n\tspace -= ptr2cells(e);\n\twhile (space < 0)\n\t{\n\t    space += ptr2cells(s);\n\t    MB_PTR_ADV(s);\n\t}\n    }\n    msg_hist_off = TRUE;\n    vim_snprintf((char *)IObuff, IOSIZE, \"%s %s%s\", lead,\n\t    s > compl_shown_match->cp_fname ? \"<\" : \"\", s);\n    msg((char *)IObuff);\n    msg_hist_off = FALSE;\n    redraw_cmdline = FALSE;\t    // don't overwrite!\n}\n\n/*\n * Find the next set of matches for completion. Repeat the completion \"todo\"\n * times.  The number of matches found is returned in 'num_matches'.\n *\n * If \"allow_get_expansion\" is TRUE, then ins_compl_get_exp() may be called to\n * get more completions. If it is FALSE, then do nothing when there are no more\n * completions in the given direction.\n *\n * If \"advance\" is TRUE, then completion will move to the first match.\n * Otherwise, the original text will be shown.\n *\n * Returns OK on success and -1 if the number of matches are unknown.\n */\n    static int\nfind_next_completion_match(\n\tint\tallow_get_expansion,\n\tint\ttodo,\t\t// repeat completion this many times\n\tint\tadvance,\n\tint\t*num_matches)\n{\n    int\t    found_end = FALSE;\n    compl_T *found_compl = NULL;\n\n    while (--todo >= 0)\n    {\n\tif (compl_shows_dir_forward() && compl_shown_match->cp_next != NULL)\n\t{\n\t    compl_shown_match = compl_shown_match->cp_next;\n\t    found_end = (compl_first_match != NULL\n\t\t    && (is_first_match(compl_shown_match->cp_next)\n\t\t\t|| is_first_match(compl_shown_match)));\n\t}\n\telse if (compl_shows_dir_backward()\n\t\t&& compl_shown_match->cp_prev != NULL)\n\t{\n\t    found_end = is_first_match(compl_shown_match);\n\t    compl_shown_match = compl_shown_match->cp_prev;\n\t    found_end |= is_first_match(compl_shown_match);\n\t}\n\telse\n\t{\n\t    if (!allow_get_expansion)\n\t    {\n\t\tif (advance)\n\t\t{\n\t\t    if (compl_shows_dir_backward())\n\t\t\tcompl_pending -= todo + 1;\n\t\t    else\n\t\t\tcompl_pending += todo + 1;\n\t\t}\n\t\treturn -1;\n\t    }\n\n\t    if (!compl_no_select && advance)\n\t    {\n\t\tif (compl_shows_dir_backward())\n\t\t    --compl_pending;\n\t\telse\n\t\t    ++compl_pending;\n\t    }\n\n\t    // Find matches.\n\t    *num_matches = ins_compl_get_exp(&compl_startpos);\n\n\t    // handle any pending completions\n\t    while (compl_pending != 0 && compl_direction == compl_shows_dir\n\t\t    && advance)\n\t    {\n\t\tif (compl_pending > 0 && compl_shown_match->cp_next != NULL)\n\t\t{\n\t\t    compl_shown_match = compl_shown_match->cp_next;\n\t\t    --compl_pending;\n\t\t}\n\t\tif (compl_pending < 0 && compl_shown_match->cp_prev != NULL)\n\t\t{\n\t\t    compl_shown_match = compl_shown_match->cp_prev;\n\t\t    ++compl_pending;\n\t\t}\n\t\telse\n\t\t    break;\n\t    }\n\t    found_end = FALSE;\n\t}\n\tif (!match_at_original_text(compl_shown_match)\n\t\t&& compl_leader != NULL\n\t\t&& !ins_compl_equal(compl_shown_match,\n\t\t    compl_leader, (int)STRLEN(compl_leader)))\n\t    ++todo;\n\telse\n\t    // Remember a matching item.\n\t    found_compl = compl_shown_match;\n\n\t// Stop at the end of the list when we found a usable match.\n\tif (found_end)\n\t{\n\t    if (found_compl != NULL)\n\t    {\n\t\tcompl_shown_match = found_compl;\n\t\tbreak;\n\t    }\n\t    todo = 1;\t    // use first usable match after wrapping around\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Fill in the next completion in the current direction.\n * If \"allow_get_expansion\" is TRUE, then we may call ins_compl_get_exp() to\n * get more completions.  If it is FALSE, then we just do nothing when there\n * are no more completions in a given direction.  The latter case is used when\n * we are still in the middle of finding completions, to allow browsing\n * through the ones found so far.\n * Return the total number of matches, or -1 if still unknown -- webb.\n *\n * compl_curr_match is currently being used by ins_compl_get_exp(), so we use\n * compl_shown_match here.\n *\n * Note that this function may be called recursively once only.  First with\n * \"allow_get_expansion\" TRUE, which calls ins_compl_get_exp(), which in turn\n * calls this function with \"allow_get_expansion\" FALSE.\n */\n    static int\nins_compl_next(\n    int\t    allow_get_expansion,\n    int\t    count,\t\t// repeat completion this many times; should\n\t\t\t\t// be at least 1\n    int\t    insert_match,\t// Insert the newly selected match\n    int\t    in_compl_func)\t// called from complete_check()\n{\n    int\t    num_matches = -1;\n    int\t    todo = count;\n    int\t    advance;\n    int\t    started = compl_started;\n    buf_T   *orig_curbuf = curbuf;\n\n    // When user complete function return -1 for findstart which is next\n    // time of 'always', compl_shown_match become NULL.\n    if (compl_shown_match == NULL)\n\treturn -1;\n\n    if (compl_leader != NULL && !match_at_original_text(compl_shown_match))\n\t// Update \"compl_shown_match\" to the actually shown match\n\tins_compl_update_shown_match();\n\n    if (allow_get_expansion && insert_match\n\t    && (!(compl_get_longest || compl_restarting) || compl_used_match))\n\t// Delete old text to be replaced\n\tins_compl_delete();\n\n    // When finding the longest common text we stick at the original text,\n    // don't let CTRL-N or CTRL-P move to the first match.\n    advance = count != 1 || !allow_get_expansion || !compl_get_longest;\n\n    // When restarting the search don't insert the first match either.\n    if (compl_restarting)\n    {\n\tadvance = FALSE;\n\tcompl_restarting = FALSE;\n    }\n\n    // Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap\n    // around.\n    if (find_next_completion_match(allow_get_expansion, todo, advance,\n\t\t\t\t\t\t\t&num_matches) == -1)\n\treturn -1;\n\n    if (curbuf != orig_curbuf)\n    {\n\t// In case some completion function switched buffer, don't want to\n\t// insert the completion elsewhere.\n\treturn -1;\n    }\n\n    // Insert the text of the new completion, or the compl_leader.\n    if (compl_no_insert && !started)\n    {\n\tins_bytes(compl_orig_text + get_compl_len());\n\tcompl_used_match = FALSE;\n    }\n    else if (insert_match)\n    {\n\tif (!compl_get_longest || compl_used_match)\n\t    ins_compl_insert(in_compl_func);\n\telse\n\t    ins_bytes(compl_leader + get_compl_len());\n    }\n    else\n\tcompl_used_match = FALSE;\n\n    if (!allow_get_expansion)\n    {\n\t// may undisplay the popup menu first\n\tins_compl_upd_pum();\n\n\tif (pum_enough_matches())\n\t    // Will display the popup menu, don't redraw yet to avoid flicker.\n\t    pum_call_update_screen();\n\telse\n\t    // Not showing the popup menu yet, redraw to show the user what was\n\t    // inserted.\n\t    update_screen(0);\n\n\t// display the updated popup menu\n\tins_compl_show_pum();\n#ifdef FEAT_GUI\n\tif (gui.in_use)\n\t{\n\t    // Show the cursor after the match, not after the redrawn text.\n\t    setcursor();\n\t    out_flush_cursor(FALSE, FALSE);\n\t}\n#endif\n\n\t// Delete old text to be replaced, since we're still searching and\n\t// don't want to match ourselves!\n\tins_compl_delete();\n    }\n\n    // Enter will select a match when the match wasn't inserted and the popup\n    // menu is visible.\n    if (compl_no_insert && !started)\n\tcompl_enter_selects = TRUE;\n    else\n\tcompl_enter_selects = !insert_match && compl_match_array != NULL;\n\n    // Show the file name for the match (if any)\n    if (compl_shown_match->cp_fname != NULL)\n\tins_compl_show_filename();\n\n    return num_matches;\n}\n\n/*\n * Call this while finding completions, to check whether the user has hit a key\n * that should change the currently displayed completion, or exit completion\n * mode.  Also, when compl_pending is not zero, show a completion as soon as\n * possible. -- webb\n * \"frequency\" specifies out of how many calls we actually check.\n * \"in_compl_func\" is TRUE when called from complete_check(), don't set\n * compl_curr_match.\n */\n    void\nins_compl_check_keys(int frequency, int in_compl_func)\n{\n    static int\tcount = 0;\n    int\t\tc;\n\n    // Don't check when reading keys from a script, :normal or feedkeys().\n    // That would break the test scripts.  But do check for keys when called\n    // from complete_check().\n    if (!in_compl_func && (using_script() || ex_normal_busy))\n\treturn;\n\n    // Only do this at regular intervals\n    if (++count < frequency)\n\treturn;\n    count = 0;\n\n    // Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()\n    // can't do its work correctly.\n    c = vpeekc_any();\n    if (c != NUL)\n    {\n\tif (vim_is_ctrl_x_key(c) && c != Ctrl_X && c != Ctrl_R)\n\t{\n\t    c = safe_vgetc();\t// Eat the character\n\t    compl_shows_dir = ins_compl_key2dir(c);\n\t    (void)ins_compl_next(FALSE, ins_compl_key2count(c),\n\t\t\t\t      c != K_UP && c != K_DOWN, in_compl_func);\n\t}\n\telse\n\t{\n\t    // Need to get the character to have KeyTyped set.  We'll put it\n\t    // back with vungetc() below.  But skip K_IGNORE.\n\t    c = safe_vgetc();\n\t    if (c != K_IGNORE)\n\t    {\n\t\t// Don't interrupt completion when the character wasn't typed,\n\t\t// e.g., when doing @q to replay keys.\n\t\tif (c != Ctrl_R && KeyTyped)\n\t\t    compl_interrupted = TRUE;\n\n\t\tvungetc(c);\n\t    }\n\t}\n    }\n    if (compl_pending != 0 && !got_int && !compl_no_insert)\n    {\n\tint todo = compl_pending > 0 ? compl_pending : -compl_pending;\n\n\tcompl_pending = 0;\n\t(void)ins_compl_next(FALSE, todo, TRUE, in_compl_func);\n    }\n}\n\n/*\n * Decide the direction of Insert mode complete from the key typed.\n * Returns BACKWARD or FORWARD.\n */\n    static int\nins_compl_key2dir(int c)\n{\n    if (c == Ctrl_P || c == Ctrl_L\n\t    || c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP || c == K_UP)\n\treturn BACKWARD;\n    return FORWARD;\n}\n\n/*\n * Return TRUE for keys that are used for completion only when the popup menu\n * is visible.\n */\n    static int\nins_compl_pum_key(int c)\n{\n    return pum_visible() && (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP\n\t\t     || c == K_PAGEDOWN || c == K_KPAGEDOWN || c == K_S_DOWN\n\t\t     || c == K_UP || c == K_DOWN);\n}\n\n/*\n * Decide the number of completions to move forward.\n * Returns 1 for most keys, height of the popup menu for page-up/down keys.\n */\n    static int\nins_compl_key2count(int c)\n{\n    int\t\th;\n\n    if (ins_compl_pum_key(c) && c != K_UP && c != K_DOWN)\n    {\n\th = pum_get_height();\n\tif (h > 3)\n\t    h -= 2; // keep some context\n\treturn h;\n    }\n    return 1;\n}\n\n/*\n * Return TRUE if completion with \"c\" should insert the match, FALSE if only\n * to change the currently selected completion.\n */\n    static int\nins_compl_use_match(int c)\n{\n    switch (c)\n    {\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_S_UP:\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Get the pattern, column and length for normal completion (CTRL-N CTRL-P\n * completion)\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n * Uses the global variables: compl_cont_status and ctrl_x_mode\n */\n    static int\nget_normal_compl_info(char_u *line, int startcol, colnr_T curs_col)\n{\n    if ((compl_cont_status & CONT_SOL) || ctrl_x_mode_path_defines())\n    {\n\tif (!compl_status_adding())\n\t{\n\t    while (--startcol >= 0 && vim_isIDc(line[startcol]))\n\t\t;\n\t    compl_col += ++startcol;\n\t    compl_length = curs_col - startcol;\n\t}\n\tif (p_ic)\n\t    compl_pattern = str_foldcase(line + compl_col,\n\t\t    compl_length, NULL, 0);\n\telse\n\t    compl_pattern = vim_strnsave(line + compl_col, compl_length);\n\tif (compl_pattern == NULL)\n\t    return FAIL;\n    }\n    else if (compl_status_adding())\n    {\n\tchar_u\t    *prefix = (char_u *)\"\\\\<\";\n\n\t// we need up to 2 extra chars for the prefix\n\tcompl_pattern = alloc(quote_meta(NULL, line + compl_col,\n\t\t    compl_length) + 2);\n\tif (compl_pattern == NULL)\n\t    return FAIL;\n\tif (!vim_iswordp(line + compl_col)\n\t\t|| (compl_col > 0\n\t\t    && (vim_iswordp(mb_prevptr(line, line + compl_col)))))\n\t    prefix = (char_u *)\"\";\n\tSTRCPY((char *)compl_pattern, prefix);\n\t(void)quote_meta(compl_pattern + STRLEN(prefix),\n\t\tline + compl_col, compl_length);\n    }\n    else if (--startcol < 0\n\t    || !vim_iswordp(mb_prevptr(line, line + startcol + 1)))\n    {\n\t// Match any word of at least two chars\n\tcompl_pattern = vim_strsave((char_u *)\"\\\\<\\\\k\\\\k\");\n\tif (compl_pattern == NULL)\n\t    return FAIL;\n\tcompl_col += curs_col;\n\tcompl_length = 0;\n    }\n    else\n    {\n\t// Search the point of change class of multibyte character\n\t// or not a word single byte character backward.\n\tif (has_mbyte)\n\t{\n\t    int base_class;\n\t    int head_off;\n\n\t    startcol -= (*mb_head_off)(line, line + startcol);\n\t    base_class = mb_get_class(line + startcol);\n\t    while (--startcol >= 0)\n\t    {\n\t\thead_off = (*mb_head_off)(line, line + startcol);\n\t\tif (base_class != mb_get_class(line + startcol\n\t\t\t    - head_off))\n\t\t    break;\n\t\tstartcol -= head_off;\n\t    }\n\t}\n\telse\n\t    while (--startcol >= 0 && vim_iswordc(line[startcol]))\n\t\t;\n\tcompl_col += ++startcol;\n\tcompl_length = (int)curs_col - startcol;\n\tif (compl_length == 1)\n\t{\n\t    // Only match word with at least two chars -- webb\n\t    // there's no need to call quote_meta,\n\t    // alloc(7) is enough  -- Acevedo\n\t    compl_pattern = alloc(7);\n\t    if (compl_pattern == NULL)\n\t\treturn FAIL;\n\t    STRCPY((char *)compl_pattern, \"\\\\<\");\n\t    (void)quote_meta(compl_pattern + 2, line + compl_col, 1);\n\t    STRCAT((char *)compl_pattern, \"\\\\k\");\n\t}\n\telse\n\t{\n\t    compl_pattern = alloc(quote_meta(NULL, line + compl_col,\n\t\t\tcompl_length) + 2);\n\t    if (compl_pattern == NULL)\n\t\treturn FAIL;\n\t    STRCPY((char *)compl_pattern, \"\\\\<\");\n\t    (void)quote_meta(compl_pattern + 2, line + compl_col,\n\t\t    compl_length);\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for whole line completion or for the\n * complete() function.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n */\n    static int\nget_wholeline_compl_info(char_u *line, colnr_T curs_col)\n{\n    compl_col = (colnr_T)getwhitecols(line);\n    compl_length = (int)curs_col - (int)compl_col;\n    if (compl_length < 0)\t// cursor in indent: empty pattern\n\tcompl_length = 0;\n    if (p_ic)\n\tcompl_pattern = str_foldcase(line + compl_col, compl_length,\n\t\tNULL, 0);\n    else\n\tcompl_pattern = vim_strnsave(line + compl_col, compl_length);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for filename completion.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n */\n    static int\nget_filename_compl_info(char_u *line, int startcol, colnr_T curs_col)\n{\n    // Go back to just before the first filename character.\n    if (startcol > 0)\n    {\n\tchar_u\t*p = line + startcol;\n\n\tMB_PTR_BACK(line, p);\n\twhile (p > line && vim_isfilec(PTR2CHAR(p)))\n\t    MB_PTR_BACK(line, p);\n\tif (p == line && vim_isfilec(PTR2CHAR(p)))\n\t    startcol = 0;\n\telse\n\t    startcol = (int)(p - line) + 1;\n    }\n\n    compl_col += startcol;\n    compl_length = (int)curs_col - startcol;\n    compl_pattern = addstar(line + compl_col, compl_length, EXPAND_FILES);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for command-line completion.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n */\n    static int\nget_cmdline_compl_info(char_u *line, colnr_T curs_col)\n{\n    compl_pattern = vim_strnsave(line, curs_col);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n    set_cmd_context(&compl_xp, compl_pattern,\n\t    (int)STRLEN(compl_pattern), curs_col, FALSE);\n    if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL\n\t    || compl_xp.xp_context == EXPAND_NOTHING)\n\t// No completion possible, use an empty pattern to get a\n\t// \"pattern not found\" message.\n\tcompl_col = curs_col;\n    else\n\tcompl_col = (int)(compl_xp.xp_pattern - compl_pattern);\n    compl_length = curs_col - compl_col;\n\n    return OK;\n}\n\n/*\n * Get the pattern, column and length for user defined completion ('omnifunc',\n * 'completefunc' and 'thesaurusfunc')\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n * Uses the global variable: spell_bad_len\n */\n    static int\nget_userdefined_compl_info(colnr_T curs_col UNUSED)\n{\n    int\t\tret = FAIL;\n\n#ifdef FEAT_COMPL_FUNC\n    // Call user defined function 'completefunc' with \"a:findstart\"\n    // set to 1 to obtain the length of text to use for completion.\n    char_u\t*line;\n    typval_T\targs[3];\n    int\t\tcol;\n    char_u\t*funcname;\n    pos_T\tpos;\n    int\t\tsave_State = State;\n    callback_T\t*cb;\n\n    // Call 'completefunc' or 'omnifunc' or 'thesaurusfunc' and get pattern\n    // length as a string\n    funcname = get_complete_funcname(ctrl_x_mode);\n    if (*funcname == NUL)\n    {\n\tsemsg(_(e_option_str_is_not_set), ctrl_x_mode_function()\n\t\t? \"completefunc\" : \"omnifunc\");\n\treturn FAIL;\n    }\n\n    args[0].v_type = VAR_NUMBER;\n    args[0].vval.v_number = 1;\n    args[1].v_type = VAR_STRING;\n    args[1].vval.v_string = (char_u *)\"\";\n    args[2].v_type = VAR_UNKNOWN;\n    pos = curwin->w_cursor;\n    ++textlock;\n    cb = get_insert_callback(ctrl_x_mode);\n    col = call_callback_retnr(cb, 2, args);\n    --textlock;\n\n    State = save_State;\n    curwin->w_cursor = pos;\t// restore the cursor position\n    validate_cursor();\n    if (!EQUAL_POS(curwin->w_cursor, pos))\n    {\n\temsg(_(e_complete_function_deleted_text));\n\treturn FAIL;\n    }\n\n    // Return value -2 means the user complete function wants to cancel the\n    // complete without an error, do the same if the function did not execute\n    // successfully.\n    if (col == -2 || aborting())\n\treturn FAIL;\n    // Return value -3 does the same as -2 and leaves CTRL-X mode.\n    if (col == -3)\n    {\n\tctrl_x_mode = CTRL_X_NORMAL;\n\tedit_submode = NULL;\n\tif (!shortmess(SHM_COMPLETIONMENU))\n\t    msg_clr_cmdline();\n\treturn FAIL;\n    }\n\n    // Reset extended parameters of completion, when starting new\n    // completion.\n    compl_opt_refresh_always = FALSE;\n    compl_opt_suppress_empty = FALSE;\n\n    if (col < 0)\n\tcol = curs_col;\n    compl_col = col;\n    if (compl_col > curs_col)\n\tcompl_col = curs_col;\n\n    // Setup variables for completion.  Need to obtain \"line\" again,\n    // it may have become invalid.\n    line = ml_get(curwin->w_cursor.lnum);\n    compl_length = curs_col - compl_col;\n    compl_pattern = vim_strnsave(line + compl_col, compl_length);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    ret = OK;\n#endif\n\n    return ret;\n}\n\n/*\n * Get the pattern, column and length for spell completion.\n * Sets the global variables: compl_col, compl_length and compl_pattern.\n * Uses the global variable: spell_bad_len\n */\n    static int\nget_spell_compl_info(int startcol UNUSED, colnr_T curs_col UNUSED)\n{\n    int\t\tret = FAIL;\n#ifdef FEAT_SPELL\n    char_u\t*line;\n\n    if (spell_bad_len > 0)\n\tcompl_col = curs_col - spell_bad_len;\n    else\n\tcompl_col = spell_word_start(startcol);\n    if (compl_col >= (colnr_T)startcol)\n    {\n\tcompl_length = 0;\n\tcompl_col = curs_col;\n    }\n    else\n    {\n\tspell_expand_check_cap(compl_col);\n\tcompl_length = (int)curs_col - compl_col;\n    }\n    // Need to obtain \"line\" again, it may have become invalid.\n    line = ml_get(curwin->w_cursor.lnum);\n    compl_pattern = vim_strnsave(line + compl_col, compl_length);\n    if (compl_pattern == NULL)\n\treturn FAIL;\n\n    ret = OK;\n#endif\n\n    return ret;\n}\n\n/*\n * Get the completion pattern, column and length.\n * \"startcol\" - start column number of the completion pattern/text\n * \"cur_col\" - current cursor column\n * On return, \"line_invalid\" is set to TRUE, if the current line may have\n * become invalid and needs to be fetched again.\n * Returns OK on success.\n */\n    static int\ncompl_get_info(char_u *line, int startcol, colnr_T curs_col, int *line_invalid)\n{\n    if (ctrl_x_mode_normal()\n\t    || (ctrl_x_mode & CTRL_X_WANT_IDENT\n\t\t&& !thesaurus_func_complete(ctrl_x_mode)))\n    {\n\treturn get_normal_compl_info(line, startcol, curs_col);\n    }\n    else if (ctrl_x_mode_line_or_eval())\n    {\n\treturn get_wholeline_compl_info(line, curs_col);\n    }\n    else if (ctrl_x_mode_files())\n    {\n\treturn get_filename_compl_info(line, startcol, curs_col);\n    }\n    else if (ctrl_x_mode == CTRL_X_CMDLINE)\n    {\n\treturn get_cmdline_compl_info(line, curs_col);\n    }\n    else if (ctrl_x_mode_function() || ctrl_x_mode_omni()\n\t    || thesaurus_func_complete(ctrl_x_mode))\n    {\n\tif (get_userdefined_compl_info(curs_col) == FAIL)\n\t    return FAIL;\n\t*line_invalid = TRUE;\t// \"line\" may have become invalid\n    }\n    else if (ctrl_x_mode_spell())\n    {\n\tif (get_spell_compl_info(startcol, curs_col) == FAIL)\n\t    return FAIL;\n\t*line_invalid = TRUE;\t// \"line\" may have become invalid\n    }\n    else\n    {\n\tinternal_error(\"ins_complete()\");\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Continue an interrupted completion mode search in \"line\".\n *\n * If this same ctrl_x_mode has been interrupted use the text from\n * \"compl_startpos\" to the cursor as a pattern to add a new word instead of\n * expand the one before the cursor, in word-wise if \"compl_startpos\" is not in\n * the same line as the cursor then fix it (the line has been split because it\n * was longer than 'tw').  if SOL is set then skip the previous pattern, a word\n * at the beginning of the line has been inserted, we'll look for that.\n */\n    static void\nins_compl_continue_search(char_u *line)\n{\n    // it is a continued search\n    compl_cont_status &= ~CONT_INTRPT;\t// remove INTRPT\n    if (ctrl_x_mode_normal() || ctrl_x_mode_path_patterns()\n\t\t\t\t\t\t|| ctrl_x_mode_path_defines())\n    {\n\tif (compl_startpos.lnum != curwin->w_cursor.lnum)\n\t{\n\t    // line (probably) wrapped, set compl_startpos to the\n\t    // first non_blank in the line, if it is not a wordchar\n\t    // include it to get a better pattern, but then we don't\n\t    // want the \"\\\\<\" prefix, check it below\n\t    compl_col = (colnr_T)getwhitecols(line);\n\t    compl_startpos.col = compl_col;\n\t    compl_startpos.lnum = curwin->w_cursor.lnum;\n\t    compl_cont_status &= ~CONT_SOL;   // clear SOL if present\n\t}\n\telse\n\t{\n\t    // S_IPOS was set when we inserted a word that was at the\n\t    // beginning of the line, which means that we'll go to SOL\n\t    // mode but first we need to redefine compl_startpos\n\t    if (compl_cont_status & CONT_S_IPOS)\n\t    {\n\t\tcompl_cont_status |= CONT_SOL;\n\t\tcompl_startpos.col = (colnr_T)(skipwhite(\n\t\t\t    line + compl_length\n\t\t\t    + compl_startpos.col) - line);\n\t    }\n\t    compl_col = compl_startpos.col;\n\t}\n\tcompl_length = curwin->w_cursor.col - (int)compl_col;\n\t// IObuff is used to add a \"word from the next line\" would we\n\t// have enough space?  just being paranoid\n#define\tMIN_SPACE 75\n\tif (compl_length > (IOSIZE - MIN_SPACE))\n\t{\n\t    compl_cont_status &= ~CONT_SOL;\n\t    compl_length = (IOSIZE - MIN_SPACE);\n\t    compl_col = curwin->w_cursor.col - compl_length;\n\t}\n\tcompl_cont_status |= CONT_ADDING | CONT_N_ADDS;\n\tif (compl_length < 1)\n\t    compl_cont_status &= CONT_LOCAL;\n    }\n    else if (ctrl_x_mode_line_or_eval())\n\tcompl_cont_status = CONT_ADDING | CONT_N_ADDS;\n    else\n\tcompl_cont_status = 0;\n}\n\n/*\n * start insert mode completion\n */\n    static int\nins_compl_start(void)\n{\n    char_u\t*line;\n    int\t\tstartcol = 0;\t    // column where searched text starts\n    colnr_T\tcurs_col;\t    // cursor column\n    int\t\tline_invalid = FALSE;\n    int\t\tsave_did_ai = did_ai;\n    int\t\tflags = CP_ORIGINAL_TEXT;\n\n    // First time we hit ^N or ^P (in a row, I mean)\n\n    did_ai = FALSE;\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (stop_arrow() == FAIL)\n\treturn FAIL;\n\n    line = ml_get(curwin->w_cursor.lnum);\n    curs_col = curwin->w_cursor.col;\n    compl_pending = 0;\n\n    if ((compl_cont_status & CONT_INTRPT) == CONT_INTRPT\n\t    && compl_cont_mode == ctrl_x_mode)\n\t// this same ctrl-x_mode was interrupted previously. Continue the\n\t// completion.\n\tins_compl_continue_search(line);\n    else\n\tcompl_cont_status &= CONT_LOCAL;\n\n    if (!compl_status_adding())\t// normal expansion\n    {\n\tcompl_cont_mode = ctrl_x_mode;\n\tif (ctrl_x_mode_not_default())\n\t    // Remove LOCAL if ctrl_x_mode != CTRL_X_NORMAL\n\t    compl_cont_status = 0;\n\tcompl_cont_status |= CONT_N_ADDS;\n\tcompl_startpos = curwin->w_cursor;\n\tstartcol = (int)curs_col;\n\tcompl_col = 0;\n    }\n\n    // Work out completion pattern and original text -- webb\n    if (compl_get_info(line, startcol, curs_col, &line_invalid) == FAIL)\n    {\n\tif (ctrl_x_mode_function() || ctrl_x_mode_omni()\n\t\t\t\t|| thesaurus_func_complete(ctrl_x_mode))\n\t    // restore did_ai, so that adding comment leader works\n\t    did_ai = save_did_ai;\n\treturn FAIL;\n    }\n    // If \"line\" was changed while getting completion info get it again.\n    if (line_invalid)\n\tline = ml_get(curwin->w_cursor.lnum);\n\n    if (compl_status_adding())\n    {\n\tedit_submode_pre = (char_u *)_(\" Adding\");\n\tif (ctrl_x_mode_line_or_eval())\n\t{\n\t    // Insert a new line, keep indentation but ignore 'comments'.\n\t    char_u *old = curbuf->b_p_com;\n\n\t    curbuf->b_p_com = (char_u *)\"\";\n\t    compl_startpos.lnum = curwin->w_cursor.lnum;\n\t    compl_startpos.col = compl_col;\n\t    ins_eol('\\r');\n\t    curbuf->b_p_com = old;\n\t    compl_length = 0;\n\t    compl_col = curwin->w_cursor.col;\n\t}\n    }\n    else\n    {\n\tedit_submode_pre = NULL;\n\tcompl_startpos.col = compl_col;\n    }\n\n    if (compl_cont_status & CONT_LOCAL)\n\tedit_submode = (char_u *)_(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);\n    else\n\tedit_submode = (char_u *)_(CTRL_X_MSG(ctrl_x_mode));\n\n    // If any of the original typed text has been changed we need to fix\n    // the redo buffer.\n    ins_compl_fixRedoBufForLeader(NULL);\n\n    // Always add completion for the original text.\n    vim_free(compl_orig_text);\n    compl_orig_text = vim_strnsave(line + compl_col, compl_length);\n    if (p_ic)\n\tflags |= CP_ICASE;\n    if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,\n\t\t-1, NULL, NULL, NULL, 0, flags, FALSE) != OK)\n    {\n\tVIM_CLEAR(compl_pattern);\n\tVIM_CLEAR(compl_orig_text);\n\treturn FAIL;\n    }\n\n    // showmode might reset the internal line pointers, so it must\n    // be called before line = ml_get(), or when this address is no\n    // longer needed.  -- Acevedo.\n    edit_submode_extra = (char_u *)_(\"-- Searching...\");\n    edit_submode_highl = HLF_COUNT;\n    showmode();\n    edit_submode_extra = NULL;\n    out_flush();\n\n    return OK;\n}\n\n/*\n * display the completion status message\n */\n    static void\nins_compl_show_statusmsg(void)\n{\n    // we found no match if the list has only the \"compl_orig_text\"-entry\n    if (is_first_match(compl_first_match->cp_next))\n    {\n\tedit_submode_extra = compl_status_adding() && compl_length > 1\n\t\t\t\t? (char_u *)_(e_hitend)\n\t\t\t\t: (char_u *)_(e_pattern_not_found);\n\tedit_submode_highl = HLF_E;\n    }\n\n    if (edit_submode_extra == NULL)\n    {\n\tif (match_at_original_text(compl_curr_match))\n\t{\n\t    edit_submode_extra = (char_u *)_(\"Back at original\");\n\t    edit_submode_highl = HLF_W;\n\t}\n\telse if (compl_cont_status & CONT_S_IPOS)\n\t{\n\t    edit_submode_extra = (char_u *)_(\"Word from other line\");\n\t    edit_submode_highl = HLF_COUNT;\n\t}\n\telse if (compl_curr_match->cp_next == compl_curr_match->cp_prev)\n\t{\n\t    edit_submode_extra = (char_u *)_(\"The only match\");\n\t    edit_submode_highl = HLF_COUNT;\n\t    compl_curr_match->cp_number = 1;\n\t}\n\telse\n\t{\n#if defined(FEAT_COMPL_FUNC) || defined(FEAT_EVAL)\n\t    // Update completion sequence number when needed.\n\t    if (compl_curr_match->cp_number == -1)\n\t\tins_compl_update_sequence_numbers();\n#endif\n\t    // The match should always have a sequence number now, this is\n\t    // just a safety check.\n\t    if (compl_curr_match->cp_number != -1)\n\t    {\n\t\t// Space for 10 text chars. + 2x10-digit no.s = 31.\n\t\t// Translations may need more than twice that.\n\t\tstatic char_u match_ref[81];\n\n\t\tif (compl_matches > 0)\n\t\t    vim_snprintf((char *)match_ref, sizeof(match_ref),\n\t\t\t    _(\"match %d of %d\"),\n\t\t\t    compl_curr_match->cp_number, compl_matches);\n\t\telse\n\t\t    vim_snprintf((char *)match_ref, sizeof(match_ref),\n\t\t\t    _(\"match %d\"),\n\t\t\t    compl_curr_match->cp_number);\n\t\tedit_submode_extra = match_ref;\n\t\tedit_submode_highl = HLF_R;\n\t\tif (dollar_vcol >= 0)\n\t\t    curs_columns(FALSE);\n\t    }\n\t}\n    }\n\n    // Show a message about what (completion) mode we're in.\n    if (!compl_opt_suppress_empty)\n    {\n\tshowmode();\n\tif (!shortmess(SHM_COMPLETIONMENU))\n\t{\n\t    if (edit_submode_extra != NULL)\n\t    {\n\t\tif (!p_smd)\n\t\t{\n\t\t    msg_hist_off = TRUE;\n\t\t    msg_attr((char *)edit_submode_extra,\n\t\t\t    edit_submode_highl < HLF_COUNT\n\t\t\t    ? HL_ATTR(edit_submode_highl) : 0);\n\t\t    msg_hist_off = FALSE;\n\t\t}\n\t    }\n\t    else\n\t\tmsg_clr_cmdline();\t// necessary for \"noshowmode\"\n\t}\n    }\n}\n\n/*\n * Do Insert mode completion.\n * Called when character \"c\" was typed, which has a meaning for completion.\n * Returns OK if completion was done, FAIL if something failed (out of mem).\n */\n    int\nins_complete(int c, int enable_pum)\n{\n    int\t\tn;\n    int\t\tsave_w_wrow;\n    int\t\tsave_w_leftcol;\n    int\t\tinsert_match;\n\n    compl_direction = ins_compl_key2dir(c);\n    insert_match = ins_compl_use_match(c);\n\n    if (!compl_started)\n    {\n\tif (ins_compl_start() == FAIL)\n\t    return FAIL;\n    }\n    else if (insert_match && stop_arrow() == FAIL)\n\treturn FAIL;\n\n    compl_shown_match = compl_curr_match;\n    compl_shows_dir = compl_direction;\n\n    // Find next match (and following matches).\n    save_w_wrow = curwin->w_wrow;\n    save_w_leftcol = curwin->w_leftcol;\n    n = ins_compl_next(TRUE, ins_compl_key2count(c), insert_match, FALSE);\n\n    // may undisplay the popup menu\n    ins_compl_upd_pum();\n\n    if (n > 1)\t\t// all matches have been found\n\tcompl_matches = n;\n    compl_curr_match = compl_shown_match;\n    compl_direction = compl_shows_dir;\n\n    // Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert\n    // mode.\n    if (got_int && !global_busy)\n    {\n\t(void)vgetc();\n\tgot_int = FALSE;\n    }\n\n    // we found no match if the list has only the \"compl_orig_text\"-entry\n    if (is_first_match(compl_first_match->cp_next))\n    {\n\t// remove N_ADDS flag, so next ^X<> won't try to go to ADDING mode,\n\t// because we couldn't expand anything at first place, but if we used\n\t// ^P, ^N, ^X^I or ^X^D we might want to add-expand a single-char-word\n\t// (such as M in M'exico) if not tried already.  -- Acevedo\n\tif (compl_length > 1\n\t\t|| compl_status_adding()\n\t\t|| (ctrl_x_mode_not_default()\n\t\t    && !ctrl_x_mode_path_patterns()\n\t\t    && !ctrl_x_mode_path_defines()))\n\t    compl_cont_status &= ~CONT_N_ADDS;\n    }\n\n    if (compl_curr_match->cp_flags & CP_CONT_S_IPOS)\n\tcompl_cont_status |= CONT_S_IPOS;\n    else\n\tcompl_cont_status &= ~CONT_S_IPOS;\n\n    ins_compl_show_statusmsg();\n\n    // Show the popup menu, unless we got interrupted.\n    if (enable_pum && !compl_interrupted)\n\tshow_pum(save_w_wrow, save_w_leftcol);\n\n    compl_was_interrupted = compl_interrupted;\n    compl_interrupted = FALSE;\n\n    return OK;\n}\n\n/*\n * Remove (if needed) and show the popup menu\n */\n    static void\nshow_pum(int prev_w_wrow, int prev_w_leftcol)\n{\n    // RedrawingDisabled may be set when invoked through complete().\n    int n = RedrawingDisabled;\n\n    RedrawingDisabled = 0;\n\n    // If the cursor moved or the display scrolled we need to remove the pum\n    // first.\n    setcursor();\n    if (prev_w_wrow != curwin->w_wrow || prev_w_leftcol != curwin->w_leftcol)\n\tins_compl_del_pum();\n\n    ins_compl_show_pum();\n    setcursor();\n    RedrawingDisabled = n;\n}\n\n/*\n * Looks in the first \"len\" chars. of \"src\" for search-metachars.\n * If dest is not NULL the chars. are copied there quoting (with\n * a backslash) the metachars, and dest would be NUL terminated.\n * Returns the length (needed) of dest\n */\n    static unsigned\nquote_meta(char_u *dest, char_u *src, int len)\n{\n    unsigned\tm = (unsigned)len + 1;  // one extra for the NUL\n\n    for ( ; --len >= 0; src++)\n    {\n\tswitch (*src)\n\t{\n\t    case '.':\n\t    case '*':\n\t    case '[':\n\t\tif (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus())\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case '~':\n\t\tif (!magic_isset())\t// quote these only if magic is set\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case '\\\\':\n\t\tif (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus())\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case '^':\t\t// currently it's not needed.\n\t    case '$':\n\t\tm++;\n\t\tif (dest != NULL)\n\t\t    *dest++ = '\\\\';\n\t\tbreak;\n\t}\n\tif (dest != NULL)\n\t    *dest++ = *src;\n\t// Copy remaining bytes of a multibyte character.\n\tif (has_mbyte)\n\t{\n\t    int i, mb_len;\n\n\t    mb_len = (*mb_ptr2len)(src) - 1;\n\t    if (mb_len > 0 && len >= mb_len)\n\t\tfor (i = 0; i < mb_len; ++i)\n\t\t{\n\t\t    --len;\n\t\t    ++src;\n\t\t    if (dest != NULL)\n\t\t\t*dest++ = *src;\n\t\t}\n\t}\n    }\n    if (dest != NULL)\n\t*dest = NUL;\n\n    return m;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_insexpand_stuff(void)\n{\n    VIM_CLEAR(compl_orig_text);\n# ifdef FEAT_EVAL\n    free_callback(&cfu_cb);\n    free_callback(&ofu_cb);\n    free_callback(&tsrfu_cb);\n# endif\n}\n#endif\n\n#ifdef FEAT_SPELL\n/*\n * Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly\n * spelled word, if there is one.\n */\n    static void\nspell_back_to_badword(void)\n{\n    pos_T\ttpos = curwin->w_cursor;\n\n    spell_bad_len = spell_move_to(curwin, BACKWARD, TRUE, TRUE, NULL);\n    if (curwin->w_cursor.col != tpos.col)\n\tstart_arrow(&tpos);\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * move.c: Functions for moving the cursor and scrolling text.\n *\n * There are two ways to move the cursor:\n * 1. Move the cursor directly, the text is scrolled to keep the cursor in the\n *    window.\n * 2. Scroll the text, the cursor is moved into the text visible in the\n *    window.\n * The 'scrolloff' option makes this a bit complicated.\n */\n\n#include \"vim.h\"\n\nstatic int scrolljump_value(void);\nstatic int check_top_offset(void);\nstatic void curs_rows(win_T *wp);\n\ntypedef struct\n{\n    linenr_T\t    lnum;\t// line number\n#ifdef FEAT_DIFF\n    int\t\t    fill;\t// filler lines\n#endif\n    int\t\t    height;\t// height of added line\n} lineoff_T;\n\nstatic void topline_back(lineoff_T *lp);\nstatic void botline_forw(lineoff_T *lp);\n\n/*\n * Compute wp->w_botline for the current wp->w_topline.  Can be called after\n * wp->w_topline changed.\n */\n    static void\ncomp_botline(win_T *wp)\n{\n    int\t\tn;\n    linenr_T\tlnum;\n    int\t\tdone;\n#ifdef FEAT_FOLDING\n    linenr_T    last;\n    int\t\tfolded;\n#endif\n\n    /*\n     * If w_cline_row is valid, start there.\n     * Otherwise have to start at w_topline.\n     */\n    check_cursor_moved(wp);\n    if (wp->w_valid & VALID_CROW)\n    {\n\tlnum = wp->w_cursor.lnum;\n\tdone = wp->w_cline_row;\n    }\n    else\n    {\n\tlnum = wp->w_topline;\n\tdone = 0;\n    }\n\n    for ( ; lnum <= wp->w_buffer->b_ml.ml_line_count; ++lnum)\n    {\n#ifdef FEAT_FOLDING\n\tlast = lnum;\n\tfolded = FALSE;\n\tif (hasFoldingWin(wp, lnum, NULL, &last, TRUE, NULL))\n\t{\n\t    n = 1;\n\t    folded = TRUE;\n\t}\n\telse\n#endif\n#ifdef FEAT_DIFF\n\t    if (lnum == wp->w_topline)\n\t\tn = plines_win_nofill(wp, lnum, TRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\tn = plines_win(wp, lnum, TRUE);\n\tif (\n#ifdef FEAT_FOLDING\n\t\tlnum <= wp->w_cursor.lnum && last >= wp->w_cursor.lnum\n#else\n\t\tlnum == wp->w_cursor.lnum\n#endif\n\t   )\n\t{\n\t    wp->w_cline_row = done;\n\t    wp->w_cline_height = n;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = folded;\n#endif\n\t    redraw_for_cursorline(wp);\n\t    wp->w_valid |= (VALID_CROW|VALID_CHEIGHT);\n\t}\n\tif (done + n > wp->w_height)\n\t    break;\n\tdone += n;\n#ifdef FEAT_FOLDING\n\tlnum = last;\n#endif\n    }\n\n    // wp->w_botline is the line that is just below the window\n    wp->w_botline = lnum;\n    wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\n    set_empty_rows(wp, done);\n}\n\n/*\n * Redraw when w_cline_row changes and 'relativenumber' or 'cursorline' is\n * set.\n */\n    void\nredraw_for_cursorline(win_T *wp)\n{\n    if ((wp->w_p_rnu\n#ifdef FEAT_SYN_HL\n\t\t|| wp->w_p_cul\n#endif\n\t\t)\n\t    && (wp->w_valid & VALID_CROW) == 0\n\t    && !pum_visible())\n    {\n\t// win_line() will redraw the number column and cursorline only.\n\tredraw_win_later(wp, UPD_VALID);\n    }\n}\n\n#ifdef FEAT_SYN_HL\n/*\n * Redraw when w_virtcol changes and 'cursorcolumn' is set or 'cursorlineopt'\n * contains \"screenline\".\n */\n    static void\nredraw_for_cursorcolumn(win_T *wp)\n{\n    if ((wp->w_valid & VALID_VIRTCOL) == 0 && !pum_visible())\n    {\n\t// When 'cursorcolumn' is set need to redraw with UPD_SOME_VALID.\n\tif (wp->w_p_cuc)\n\t    redraw_win_later(wp, UPD_SOME_VALID);\n\t// When 'cursorlineopt' contains \"screenline\" need to redraw with\n\t// UPD_VALID.\n\telse if (wp->w_p_cul && (wp->w_p_culopt_flags & CULOPT_SCRLINE))\n\t    redraw_win_later(wp, UPD_VALID);\n    }\n}\n#endif\n\n/*\n * Update curwin->w_topline and redraw if necessary.\n * Used to update the screen before printing a message.\n */\n    void\nupdate_topline_redraw(void)\n{\n    update_topline();\n    if (must_redraw)\n\tupdate_screen(0);\n}\n\n/*\n * Update curwin->w_topline to move the cursor onto the screen.\n */\n    void\nupdate_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long\t*so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(UPD_NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t   >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(UPD_NOT_VALID);\n\t}\n\telse\n\t    redraw_later(UPD_VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}\n\n/*\n * Return the scrolljump value to use for the current window.\n * When 'scrolljump' is positive use it as-is.\n * When 'scrolljump' is negative use it as a percentage of the window height.\n */\n    static int\nscrolljump_value(void)\n{\n    if (p_sj >= 0)\n\treturn (int)p_sj;\n    return (curwin->w_height * -p_sj) / 100;\n}\n\n/*\n * Return TRUE when there are not 'scrolloff' lines above the cursor for the\n * current window.\n */\n    static int\ncheck_top_offset(void)\n{\n    lineoff_T\tloff;\n    int\t\tn;\n    long\tso = get_scrolloff_value();\n\n    if (curwin->w_cursor.lnum < curwin->w_topline + so\n#ifdef FEAT_FOLDING\n\t\t    || hasAnyFolding(curwin)\n#endif\n\t    )\n    {\n\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n\tn = curwin->w_topfill;\t    // always have this context\n#else\n\tn = 0;\n#endif\n\t// Count the visible screen lines above the cursor line.\n\twhile (n < so)\n\t{\n\t    topline_back(&loff);\n\t    // Stop when included a line above the window.\n\t    if (loff.lnum < curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t    || (loff.lnum == curwin->w_topline && loff.fill > 0)\n#endif\n\t\t    )\n\t\tbreak;\n\t    n += loff.height;\n\t}\n\tif (n < so)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Update w_curswant.\n */\n    void\nupdate_curswant_force(void)\n{\n    validate_virtcol();\n    curwin->w_curswant = curwin->w_virtcol\n#ifdef FEAT_PROP_POPUP\n\t- curwin->w_virtcol_first_char\n#endif\n\t;\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Update w_curswant if w_set_curswant is set.\n */\n    void\nupdate_curswant(void)\n{\n    if (curwin->w_set_curswant)\n\tupdate_curswant_force();\n}\n\n/*\n * Check if the cursor has moved.  Set the w_valid flag accordingly.\n */\n    void\ncheck_cursor_moved(win_T *wp)\n{\n    if (wp->w_cursor.lnum != wp->w_valid_cursor.lnum)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t      |VALID_CHEIGHT|VALID_CROW|VALID_TOPLINE\n\t\t\t\t      |VALID_BOTLINE|VALID_BOTLINE_AP);\n\twp->w_valid_cursor = wp->w_cursor;\n\twp->w_valid_leftcol = wp->w_leftcol;\n    }\n    else if (wp->w_cursor.col != wp->w_valid_cursor.col\n\t     || wp->w_leftcol != wp->w_valid_leftcol\n\t     || wp->w_cursor.coladd != wp->w_valid_cursor.coladd)\n    {\n\twp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\twp->w_valid_cursor.col = wp->w_cursor.col;\n\twp->w_valid_leftcol = wp->w_leftcol;\n\twp->w_valid_cursor.coladd = wp->w_cursor.coladd;\n    }\n}\n\n/*\n * Call this function when some window settings have changed, which require\n * the cursor position, botline and topline to be recomputed and the window to\n * be redrawn.  E.g, when changing the 'wrap' option or folding.\n */\n    void\nchanged_window_setting(void)\n{\n    changed_window_setting_win(curwin);\n}\n\n    void\nchanged_window_setting_win(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP|VALID_TOPLINE);\n    redraw_win_later(wp, UPD_NOT_VALID);\n}\n\n/*\n * Set wp->w_topline to a certain number.\n */\n    void\nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(UPD_VALID);\n}\n\n/*\n * Call this function when the length of the cursor line (in screen\n * characters) has changed, and the change is before the cursor.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_cline_bef_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_cline_bef_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Call this function when the length of a line (in screen characters) above\n * the cursor have changed.\n * Need to take care of w_botline separately!\n */\n    void\nchanged_line_abv_curs(void)\n{\n    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n    void\nchanged_line_abv_curs_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL|VALID_CROW\n\t\t\t\t\t\t|VALID_CHEIGHT|VALID_TOPLINE);\n}\n\n/*\n * Display of line has changed for \"buf\", invalidate cursor position and\n * w_botline.\n */\n    void\nchanged_line_display_buf(buf_T *buf)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf)\n\t    wp->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL\n\t\t\t\t|VALID_CROW|VALID_CHEIGHT\n\t\t\t\t|VALID_TOPLINE|VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n/*\n * Make sure the value of curwin->w_botline is valid.\n */\n    void\nvalidate_botline(void)\n{\n    validate_botline_win(curwin);\n}\n\n/*\n * Make sure the value of wp->w_botline is valid.\n */\n    void\nvalidate_botline_win(win_T *wp)\n{\n    if (!(wp->w_valid & VALID_BOTLINE))\n\tcomp_botline(wp);\n}\n\n/*\n * Mark curwin->w_botline as invalid (because of some change in the buffer).\n */\n    void\ninvalidate_botline(void)\n{\n    curwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\ninvalidate_botline_win(win_T *wp)\n{\n    wp->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n}\n\n    void\napproximate_botline_win(\n    win_T\t*wp)\n{\n    wp->w_valid &= ~VALID_BOTLINE;\n}\n\n/*\n * Return TRUE if curwin->w_wrow and curwin->w_wcol are valid.\n */\n    int\ncursor_valid(void)\n{\n    check_cursor_moved(curwin);\n    return ((curwin->w_valid & (VALID_WROW|VALID_WCOL)) ==\n\t\t\t\t\t\t      (VALID_WROW|VALID_WCOL));\n}\n\n/*\n * Validate cursor position.  Makes sure w_wrow and w_wcol are valid.\n * w_topline must be valid, you may need to call update_topline() first!\n */\n    void\nvalidate_cursor(void)\n{\n    check_cursor();\n    check_cursor_moved(curwin);\n    if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))\n\tcurs_columns(TRUE);\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * validate w_cline_row.\n */\n    void\nvalidate_cline_row(void)\n{\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    update_topline();\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n}\n#endif\n\n/*\n * Compute wp->w_cline_row and wp->w_cline_height, based on the current value\n * of wp->w_topline.\n */\n    static void\ncurs_rows(win_T *wp)\n{\n    linenr_T\tlnum;\n    int\t\ti;\n    int\t\tall_invalid;\n    int\t\tvalid;\n#ifdef FEAT_FOLDING\n    long\tfold_count;\n#endif\n\n    // Check if wp->w_lines[].wl_size is invalid\n    all_invalid = (!redrawing()\n\t\t\t|| wp->w_lines_valid == 0\n\t\t\t|| wp->w_lines[0].wl_lnum > wp->w_topline);\n    i = 0;\n    wp->w_cline_row = 0;\n    for (lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i)\n    {\n\tvalid = FALSE;\n\tif (!all_invalid && i < wp->w_lines_valid)\n\t{\n\t    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)\n\t\tcontinue;\t\t// skip changed or deleted lines\n\t    if (wp->w_lines[i].wl_lnum == lnum)\n\t    {\n#ifdef FEAT_FOLDING\n\t\t// Check for newly inserted lines below this row, in which\n\t\t// case we need to check for folded lines.\n\t\tif (!wp->w_buffer->b_mod_set\n\t\t\t|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum\n\t\t\t|| wp->w_buffer->b_mod_top\n\t\t\t\t\t     > wp->w_lines[i].wl_lastlnum + 1)\n#endif\n\t\tvalid = TRUE;\n\t    }\n\t    else if (wp->w_lines[i].wl_lnum > lnum)\n\t\t--i;\t\t\t// hold at inserted lines\n\t}\n\tif (valid\n#ifdef FEAT_DIFF\n\t\t&& (lnum != wp->w_topline || !wp->w_p_diff)\n#endif\n\t\t)\n\t{\n#ifdef FEAT_FOLDING\n\t    lnum = wp->w_lines[i].wl_lastlnum + 1;\n\t    // Cursor inside folded lines, don't count this row\n\t    if (lnum > wp->w_cursor.lnum)\n\t\tbreak;\n#else\n\t    ++lnum;\n#endif\n\t    wp->w_cline_row += wp->w_lines[i].wl_size;\n\t}\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    fold_count = foldedCount(wp, lnum, NULL);\n\t    if (fold_count)\n\t    {\n\t\tlnum += fold_count;\n\t\tif (lnum > wp->w_cursor.lnum)\n\t\t    break;\n\t\t++wp->w_cline_row;\n\t    }\n\t    else\n#endif\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    wp->w_cline_row += plines_win_nofill(wp, lnum++, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    wp->w_cline_row += plines_win(wp, lnum++, TRUE);\n\t}\n    }\n\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_CHEIGHT))\n    {\n\tif (all_invalid\n\t\t|| i == wp->w_lines_valid\n\t\t|| (i < wp->w_lines_valid\n\t\t    && (!wp->w_lines[i].wl_valid\n\t\t\t|| wp->w_lines[i].wl_lnum != wp->w_cursor.lnum)))\n\t{\n#ifdef FEAT_DIFF\n\t    if (wp->w_cursor.lnum == wp->w_topline)\n\t\twp->w_cline_height = plines_win_nofill(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t\tTRUE) + wp->w_topfill;\n\t    else\n#endif\n\t\twp->w_cline_height = plines_win(wp, wp->w_cursor.lnum, TRUE);\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse if (i > wp->w_lines_valid)\n\t{\n\t    // a line that is too long to fit on the last screen line\n\t    wp->w_cline_height = 0;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,\n\t\t\t\t\t\t      NULL, NULL, TRUE, NULL);\n#endif\n\t}\n\telse\n\t{\n\t    wp->w_cline_height = wp->w_lines[i].wl_size;\n#ifdef FEAT_FOLDING\n\t    wp->w_cline_folded = wp->w_lines[i].wl_folded;\n#endif\n\t}\n    }\n\n    redraw_for_cursorline(curwin);\n    wp->w_valid |= VALID_CROW|VALID_CHEIGHT;\n\n}\n\n/*\n * Validate curwin->w_virtcol only.\n */\n    void\nvalidate_virtcol(void)\n{\n    validate_virtcol_win(curwin);\n}\n\n/*\n * Validate wp->w_virtcol only.\n */\n    void\nvalidate_virtcol_win(win_T *wp)\n{\n    check_cursor_moved(wp);\n    if (!(wp->w_valid & VALID_VIRTCOL))\n    {\n#ifdef FEAT_PROP_POPUP\n\twp->w_virtcol_first_char = 0;\n#endif\n\tgetvvcol(wp, &wp->w_cursor, NULL, &(wp->w_virtcol), NULL);\n#ifdef FEAT_SYN_HL\n\tredraw_for_cursorcolumn(wp);\n#endif\n\twp->w_valid |= VALID_VIRTCOL;\n    }\n}\n\n/*\n * Validate curwin->w_cline_height only.\n */\n    void\nvalidate_cheight(void)\n{\n    check_cursor_moved(curwin);\n    if (!(curwin->w_valid & VALID_CHEIGHT))\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    curwin->w_cline_height = plines_nofill(curwin->w_cursor.lnum)\n\t\t\t\t\t\t\t  + curwin->w_topfill;\n\telse\n#endif\n\t    curwin->w_cline_height = plines(curwin->w_cursor.lnum);\n#ifdef FEAT_FOLDING\n\tcurwin->w_cline_folded = hasFolding(curwin->w_cursor.lnum, NULL, NULL);\n#endif\n\tcurwin->w_valid |= VALID_CHEIGHT;\n    }\n}\n\n/*\n * Validate w_wcol and w_virtcol only.\n */\n    void\nvalidate_cursor_col(void)\n{\n    colnr_T off;\n    colnr_T col;\n    int     width;\n\n    validate_virtcol();\n    if (!(curwin->w_valid & VALID_WCOL))\n    {\n\tcol = curwin->w_virtcol;\n\toff = curwin_col_off();\n\tcol += off;\n\twidth = curwin->w_width - off + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_p_wrap\n\t\t&& col >= (colnr_T)curwin->w_width\n\t\t&& width > 0)\n\t    // use same formula as what is used in curs_columns()\n\t    col -= ((col - curwin->w_width) / width + 1) * width;\n\tif (col > (int)curwin->w_leftcol)\n\t    col -= curwin->w_leftcol;\n\telse\n\t    col = 0;\n\tcurwin->w_wcol = col;\n\n\tcurwin->w_valid |= VALID_WCOL;\n#ifdef FEAT_PROP_POPUP\n\tcurwin->w_flags &= ~WFLAG_WCOL_OFF_ADDED;\n#endif\n    }\n}\n\n/*\n * Compute offset of a window, occupied by absolute or relative line number,\n * fold column and sign column (these don't move when scrolling horizontally).\n */\n    int\nwin_col_off(win_T *wp)\n{\n    return (((wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) + 1 : 0)\n#ifdef FEAT_CMDWIN\n\t    + (cmdwin_type == 0 || wp != curwin ? 0 : 1)\n#endif\n#ifdef FEAT_FOLDING\n\t    + wp->w_p_fdc\n#endif\n#ifdef FEAT_SIGNS\n\t    + (signcolumn_on(wp) ? 2 : 0)\n#endif\n\t   );\n}\n\n    int\ncurwin_col_off(void)\n{\n    return win_col_off(curwin);\n}\n\n/*\n * Return the difference in column offset for the second screen line of a\n * wrapped line.  It's 8 if 'number' or 'relativenumber' is on and 'n' is in\n * 'cpoptions'.\n */\n    int\nwin_col_off2(win_T *wp)\n{\n    if ((wp->w_p_nu || wp->w_p_rnu) && vim_strchr(p_cpo, CPO_NUMCOL) != NULL)\n\treturn number_width(wp) + 1;\n    return 0;\n}\n\n    int\ncurwin_col_off2(void)\n{\n    return win_col_off2(curwin);\n}\n\n/*\n * Compute curwin->w_wcol and curwin->w_virtcol.\n * Also updates curwin->w_wrow and curwin->w_cline_row.\n * Also updates curwin->w_leftcol.\n */\n    void\ncurs_columns(\n    int\t\tmay_scroll)\t// when TRUE, may scroll horizontally\n{\n    int\t\tdiff;\n    int\t\textra;\t\t// offset for first screen line\n    int\t\toff_left, off_right;\n    int\t\tn;\n    int\t\tp_lines;\n    int\t\twidth = 0;\n    int\t\ttextwidth;\n    int\t\tnew_leftcol;\n    colnr_T\tstartcol;\n    colnr_T\tendcol;\n    colnr_T\tprev_skipcol;\n    long\tso = get_scrolloff_value();\n    long\tsiso = get_sidescrolloff_value();\n\n    /*\n     * First make sure that w_topline is valid (after moving the cursor).\n     */\n    if (!skip_update_topline)\n\tupdate_topline();\n\n    /*\n     * Next make sure that w_cline_row is valid.\n     */\n    if (!(curwin->w_valid & VALID_CROW))\n\tcurs_rows(curwin);\n\n#ifdef FEAT_PROP_POPUP\n    // will be set by getvvcol() but not reset\n    curwin->w_virtcol_first_char = 0;\n#endif\n\n    /*\n     * Compute the number of virtual columns.\n     */\n#ifdef FEAT_FOLDING\n    if (curwin->w_cline_folded)\n\t// In a folded line the cursor is always in the first column\n\tstartcol = curwin->w_virtcol = endcol = curwin->w_leftcol;\n    else\n#endif\n\tgetvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t&startcol, &(curwin->w_virtcol), &endcol);\n\n    // remove '$' from change command when cursor moves onto it\n    if (startcol > dollar_vcol)\n\tdollar_vcol = -1;\n\n    extra = curwin_col_off();\n    curwin->w_wcol = curwin->w_virtcol + extra;\n    endcol += extra;\n\n    /*\n     * Now compute w_wrow, counting screen lines from w_cline_row.\n     */\n    curwin->w_wrow = curwin->w_cline_row;\n\n    textwidth = curwin->w_width - extra;\n    if (textwidth <= 0)\n    {\n\t// No room for text, put cursor in last char of window.\n\t// If not wrapping, the last non-empty line.\n\tcurwin->w_wcol = curwin->w_width - 1;\n\tif (curwin->w_p_wrap)\n\t    curwin->w_wrow = curwin->w_height - 1;\n\telse\n\t    curwin->w_wrow = curwin->w_height - 1 - curwin->w_empty_rows;\n    }\n    else if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\twidth = textwidth + curwin_col_off2();\n\n\t// long line wrapping, adjust curwin->w_wrow\n\tif (curwin->w_wcol >= curwin->w_width)\n\t{\n#ifdef FEAT_LINEBREAK\n\t    char_u *sbr;\n#endif\n\n\t    // this same formula is used in validate_cursor_col()\n\t    n = (curwin->w_wcol - curwin->w_width) / width + 1;\n\t    curwin->w_wcol -= n * width;\n\t    curwin->w_wrow += n;\n\n#ifdef FEAT_LINEBREAK\n\t    // When cursor wraps to first char of next line in Insert\n\t    // mode, the 'showbreak' string isn't shown, backup to first\n\t    // column\n\t    sbr = get_showbreak_value(curwin);\n\t    if (*sbr && *ml_get_cursor() == NUL\n\t\t\t\t    && curwin->w_wcol == vim_strsize(sbr))\n\t\tcurwin->w_wcol = 0;\n#endif\n\t}\n    }\n\n    // No line wrapping: compute curwin->w_leftcol if scrolling is on and line\n    // is not folded.\n    // If scrolling is off, curwin->w_leftcol is assumed to be 0\n    else if (may_scroll\n#ifdef FEAT_FOLDING\n\t    && !curwin->w_cline_folded\n#endif\n\t    )\n    {\n#ifdef FEAT_PROP_POPUP\n\tif (curwin->w_virtcol_first_char > 0)\n\t{\n\t    int cols = (curwin->w_width - extra);\n\t    int rows = cols > 0 ? curwin->w_virtcol_first_char / cols : 1;\n\n\t    // each \"above\" text prop shifts the text one row down\n\t    curwin->w_wrow += rows;\n\t    curwin->w_wcol -= rows * cols;\n\t    endcol -= rows * cols;\n\t    curwin->w_cline_height = rows + 1;\n\t}\n#endif\n\t/*\n\t * If Cursor is left of the screen, scroll rightwards.\n\t * If Cursor is right of the screen, scroll leftwards\n\t * If we get closer to the edge than 'sidescrolloff', scroll a little\n\t * extra\n\t */\n\toff_left = (int)startcol - (int)curwin->w_leftcol - siso;\n\toff_right = (int)endcol - (int)(curwin->w_leftcol + curwin->w_width\n\t\t\t\t\t\t\t\t- siso) + 1;\n\tif (off_left < 0 || off_right > 0)\n\t{\n\t    if (off_left < 0)\n\t\tdiff = -off_left;\n\t    else\n\t\tdiff = off_right;\n\n\t    // When far off or not enough room on either side, put cursor in\n\t    // middle of window.\n\t    if (p_ss == 0 || diff >= textwidth / 2 || off_right >= off_left)\n\t\tnew_leftcol = curwin->w_wcol - extra - textwidth / 2;\n\t    else\n\t    {\n\t\tif (diff < p_ss)\n\t\t    diff = p_ss;\n\t\tif (off_left < 0)\n\t\t    new_leftcol = curwin->w_leftcol - diff;\n\t\telse\n\t\t    new_leftcol = curwin->w_leftcol + diff;\n\t    }\n\t    if (new_leftcol < 0)\n\t\tnew_leftcol = 0;\n\t    if (new_leftcol != (int)curwin->w_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = new_leftcol;\n\t\t// screen has to be redrawn with new curwin->w_leftcol\n\t\tredraw_later(UPD_NOT_VALID);\n\t    }\n\t}\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    }\n    else if (curwin->w_wcol > (int)curwin->w_leftcol)\n\tcurwin->w_wcol -= curwin->w_leftcol;\n    else\n\tcurwin->w_wcol = 0;\n\n#ifdef FEAT_DIFF\n    // Skip over filler lines.  At the top use w_topfill, there\n    // may be some filler lines above the window.\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_wrow += curwin->w_topfill;\n    else\n\tcurwin->w_wrow += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    prev_skipcol = curwin->w_skipcol;\n\n    p_lines = 0;\n\n    if ((curwin->w_wrow >= curwin->w_height\n\t\t|| ((prev_skipcol > 0\n\t\t\t|| curwin->w_wrow + so >= curwin->w_height)\n\t\t    && (p_lines =\n#ifdef FEAT_DIFF\n\t\t\tplines_win_nofill\n#else\n\t\t\tplines_win\n#endif\n\t\t\t(curwin, curwin->w_cursor.lnum, FALSE))\n\t\t\t\t\t\t    - 1 >= curwin->w_height))\n\t    && curwin->w_height != 0\n\t    && curwin->w_cursor.lnum == curwin->w_topline\n\t    && width > 0\n\t    && curwin->w_width != 0)\n    {\n\t// Cursor past end of screen.  Happens with a single line that does\n\t// not fit on screen.  Find a skipcol to show the text around the\n\t// cursor.  Avoid scrolling all the time. compute value of \"extra\":\n\t// 1: Less than 'scrolloff' lines above\n\t// 2: Less than 'scrolloff' lines below\n\t// 3: both of them\n\textra = 0;\n\tif (curwin->w_skipcol + so * width > curwin->w_virtcol)\n\t    extra = 1;\n\t// Compute last display line of the buffer line that we want at the\n\t// bottom of the window.\n\tif (p_lines == 0)\n\t    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);\n\t--p_lines;\n\tif (p_lines > curwin->w_wrow + so)\n\t    n = curwin->w_wrow + so;\n\telse\n\t    n = p_lines;\n\tif ((colnr_T)n >= curwin->w_height + curwin->w_skipcol / width - so)\n\t    extra += 2;\n\n\tif (extra == 3 || p_lines <= so * 2)\n\t{\n\t    // not enough room for 'scrolloff', put cursor in the middle\n\t    n = curwin->w_virtcol / width;\n\t    if (n > curwin->w_height / 2)\n\t\tn -= curwin->w_height / 2;\n\t    else\n\t\tn = 0;\n\t    // don't skip more than necessary\n\t    if (n > p_lines - curwin->w_height + 1)\n\t\tn = p_lines - curwin->w_height + 1;\n\t    curwin->w_skipcol = n * width;\n\t}\n\telse if (extra == 1)\n\t{\n\t    // less than 'scrolloff' lines above, decrease skipcol\n\t    extra = (curwin->w_skipcol + so * width - curwin->w_virtcol\n\t\t\t\t     + width - 1) / width;\n\t    if (extra > 0)\n\t    {\n\t\tif ((colnr_T)(extra * width) > curwin->w_skipcol)\n\t\t    extra = curwin->w_skipcol / width;\n\t\tcurwin->w_skipcol -= extra * width;\n\t    }\n\t}\n\telse if (extra == 2)\n\t{\n\t    // less than 'scrolloff' lines below, increase skipcol\n\t    endcol = (n - curwin->w_height + 1) * width;\n\t    while (endcol > curwin->w_virtcol)\n\t\tendcol -= width;\n\t    if (endcol > curwin->w_skipcol)\n\t\tcurwin->w_skipcol = endcol;\n\t}\n\n\tcurwin->w_wrow -= curwin->w_skipcol / width;\n\tif (curwin->w_wrow >= curwin->w_height)\n\t{\n\t    // small window, make sure cursor is in it\n\t    extra = curwin->w_wrow - curwin->w_height + 1;\n\t    curwin->w_skipcol += extra * width;\n\t    curwin->w_wrow -= extra;\n\t}\n\n\textra = ((int)prev_skipcol - (int)curwin->w_skipcol) / width;\n\tif (extra > 0)\n\t    win_ins_lines(curwin, 0, extra, FALSE, FALSE);\n\telse if (extra < 0)\n\t    win_del_lines(curwin, 0, -extra, FALSE, FALSE, 0);\n    }\n    else\n\tcurwin->w_skipcol = 0;\n    if (prev_skipcol != curwin->w_skipcol)\n\tredraw_later(UPD_NOT_VALID);\n\n#ifdef FEAT_SYN_HL\n    redraw_for_cursorcolumn(curwin);\n#endif\n#if defined(FEAT_PROP_POPUP) && defined(FEAT_TERMINAL)\n    if (popup_is_popup(curwin) && curbuf->b_term != NULL)\n    {\n\tcurwin->w_wrow += popup_top_extra(curwin);\n\tcurwin->w_wcol += popup_left_extra(curwin);\n\tcurwin->w_flags |= WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED;\n    }\n    else\n\tcurwin->w_flags &= ~(WFLAG_WCOL_OFF_ADDED + WFLAG_WROW_OFF_ADDED);\n#endif\n\n    // now w_leftcol is valid, avoid check_cursor_moved() thinking otherwise\n    curwin->w_valid_leftcol = curwin->w_leftcol;\n\n    curwin->w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;\n}\n\n#if (defined(FEAT_EVAL) || defined(FEAT_PROP_POPUP)) || defined(PROTO)\n/*\n * Compute the screen position of text character at \"pos\" in window \"wp\"\n * The resulting values are one-based, zero when character is not visible.\n */\n    void\ntextpos2screenpos(\n\twin_T\t*wp,\n\tpos_T\t*pos,\n\tint\t*rowp,\t// screen row\n\tint\t*scolp,\t// start screen column\n\tint\t*ccolp,\t// cursor screen column\n\tint\t*ecolp)\t// end screen column\n{\n    colnr_T\tscol = 0, ccol = 0, ecol = 0;\n    int\t\trow = 0;\n    int\t\trowoff = 0;\n    colnr_T\tcoloff = 0;\n\n    if (pos->lnum >= wp->w_topline && pos->lnum <= wp->w_botline)\n    {\n\tcolnr_T\t    off;\n\tcolnr_T\t    col;\n\tint\t    width;\n\tlinenr_T    lnum = pos->lnum;\n#ifdef FEAT_FOLDING\n\tint\t    is_folded;\n\n\tis_folded = hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n\trow = plines_m_win(wp, wp->w_topline, lnum - 1) + 1;\n#ifdef FEAT_FOLDING\n\tif (is_folded)\n\t{\n\t    row += W_WINROW(wp);\n\t    coloff = wp->w_wincol + 1;\n\t}\n\telse\n#endif\n\t{\n\t    getvcol(wp, pos, &scol, &ccol, &ecol);\n\n\t    // similar to what is done in validate_cursor_col()\n\t    col = scol;\n\t    off = win_col_off(wp);\n\t    col += off;\n\t    width = wp->w_width - off + win_col_off2(wp);\n\n\t    // long line wrapping, adjust row\n\t    if (wp->w_p_wrap\n\t\t    && col >= (colnr_T)wp->w_width\n\t\t    && width > 0)\n\t    {\n\t\t// use same formula as what is used in curs_columns()\n\t\trowoff = ((col - wp->w_width) / width + 1);\n\t\tcol -= rowoff * width;\n\t    }\n\t    col -= wp->w_leftcol;\n\t    if (col >= wp->w_width)\n\t\tcol = -1;\n\t    if (col >= 0 && row + rowoff <= wp->w_height)\n\t    {\n\t\tcoloff = col - scol + wp->w_wincol + 1;\n\t\trow += W_WINROW(wp);\n\t    }\n\t    else\n\t\t// character is left, right or below of the window\n\t\trow = rowoff = scol = ccol = ecol = 0;\n\t}\n    }\n    *rowp = row + rowoff;\n    *scolp = scol + coloff;\n    *ccolp = ccol + coloff;\n    *ecolp = ecol + coloff;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"screenpos({winid}, {lnum}, {col})\" function\n */\n    void\nf_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"row\", row);\n    dict_add_number(dict, \"col\", scol);\n    dict_add_number(dict, \"curscol\", ccol);\n    dict_add_number(dict, \"endcol\", ecol);\n}\n\n/*\n * \"virtcol2col({winid}, {lnum}, {col})\" function\n */\n    void\nf_virtcol2col(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    win_T\t*wp;\n    linenr_T\tlnum;\n    int\t\tscreencol;\n    int\t\terror = FALSE;\n\n    rettv->vval.v_number = -1;\n\n    if (check_for_number_arg(argvars, 0) == FAIL\n\t    || check_for_number_arg(argvars, 1) == FAIL\n\t    || check_for_number_arg(argvars, 2) == FAIL)\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    lnum = tv_get_number_chk(&argvars[1], &error);\n    if (error || lnum < 0 || lnum > wp->w_buffer->b_ml.ml_line_count)\n\treturn;\n\n    screencol = tv_get_number_chk(&argvars[2], &error);\n    if (error || screencol < 0)\n\treturn;\n\n    rettv->vval.v_number = vcol2col(wp, lnum, screencol);\n}\n#endif\n\n/*\n * Scroll the current window down by \"line_count\" logical lines.  \"CTRL-Y\"\n */\n    void\nscrolldown(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n    long\tdone = 0;\t// total # of physical lines done\n    int\t\twrow;\n    int\t\tmoved = FALSE;\n\n#ifdef FEAT_FOLDING\n    linenr_T\tfirst;\n\n    // Make sure w_topline is at the first of a sequence of folded lines.\n    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    validate_cursor();\t\t// w_wrow needs to be valid\n    while (line_count-- > 0)\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill < diff_check(curwin, curwin->w_topline)\n\t\t&& curwin->w_topfill < curwin->w_height - 1)\n\t{\n\t    ++curwin->w_topfill;\n\t    ++done;\n\t}\n\telse\n#endif\n\t{\n\t    if (curwin->w_topline == 1)\n\t\tbreak;\n\t    --curwin->w_topline;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n#ifdef FEAT_FOLDING\n\t    // A sequence of folded lines only counts for one logical line\n\t    if (hasFolding(curwin->w_topline, &first, NULL))\n\t    {\n\t\t++done;\n\t\tif (!byfold)\n\t\t    line_count -= curwin->w_topline - first - 1;\n\t\tcurwin->w_botline -= curwin->w_topline - first;\n\t\tcurwin->w_topline = first;\n\t    }\n\t    else\n#endif\n\t\tdone += PLINES_NOFILL(curwin->w_topline);\n\t}\n\t--curwin->w_botline;\t\t// approximate w_botline\n\tinvalidate_botline();\n    }\n    curwin->w_wrow += done;\t\t// keep w_wrow updated\n    curwin->w_cline_row += done;\t// keep w_cline_row updated\n\n#ifdef FEAT_DIFF\n    if (curwin->w_cursor.lnum == curwin->w_topline)\n\tcurwin->w_cline_row = 0;\n    check_topfill(curwin, TRUE);\n#endif\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and move the cursor onto the displayed part of the window.\n     */\n    wrow = curwin->w_wrow;\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tvalidate_cheight();\n\twrow += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    while (wrow >= curwin->w_height && curwin->w_cursor.lnum > 1)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(curwin->w_cursor.lnum, &first, NULL))\n\t{\n\t    --wrow;\n\t    if (first == 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n\t\tcurwin->w_cursor.lnum = first - 1;\n\t}\n\telse\n#endif\n\t    wrow -= plines(curwin->w_cursor.lnum--);\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tmoved = TRUE;\n    }\n    if (moved)\n    {\n#ifdef FEAT_FOLDING\n\t// Move cursor to first line of closed fold.\n\tfoldAdjustCursor();\n#endif\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n/*\n * Scroll the current window up by \"line_count\" logical lines.  \"CTRL-E\"\n */\n    void\nscrollup(\n    long\tline_count,\n    int\t\tbyfold UNUSED)\t// TRUE: count a closed fold as one line\n{\n#if defined(FEAT_FOLDING) || defined(FEAT_DIFF)\n    linenr_T\tlnum;\n\n    if (\n# ifdef FEAT_FOLDING\n\t    (byfold && hasAnyFolding(curwin))\n#  ifdef FEAT_DIFF\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_DIFF\n\t    curwin->w_p_diff\n# endif\n\t    )\n    {\n\t// count each sequence of folded lines as one logical line\n\tlnum = curwin->w_topline;\n\twhile (line_count--)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t\t--curwin->w_topfill;\n\t    else\n# endif\n\t    {\n# ifdef FEAT_FOLDING\n\t\tif (byfold)\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n# endif\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t\t++lnum;\n# ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, lnum);\n# endif\n\t    }\n\t}\n\t// approximate w_botline\n\tcurwin->w_botline += lnum - curwin->w_topline;\n\tcurwin->w_topline = lnum;\n    }\n    else\n#endif\n    {\n\tcurwin->w_topline += line_count;\n\tcurwin->w_botline += line_count;\t// approximate w_botline\n    }\n\n    if (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)\n\tcurwin->w_botline = curbuf->b_ml.ml_line_count + 1;\n\n#ifdef FEAT_DIFF\n    check_topfill(curwin, FALSE);\n#endif\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(curwin))\n\t// Make sure w_topline is at the first of a sequence of folded lines.\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n    {\n\tcurwin->w_cursor.lnum = curwin->w_topline;\n\tcurwin->w_valid &=\n\t      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);\n\tcoladvance(curwin->w_curswant);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Don't end up with too many filler lines in the window.\n */\n    void\ncheck_topfill(\n    win_T\t*wp,\n    int\t\tdown)\t// when TRUE scroll down when not enough space\n{\n    int\t\tn;\n\n    if (wp->w_topfill > 0)\n    {\n\tn = plines_win_nofill(wp, wp->w_topline, TRUE);\n\tif (wp->w_topfill + n > wp->w_height)\n\t{\n\t    if (down && wp->w_topline > 1)\n\t    {\n\t\t--wp->w_topline;\n\t\twp->w_topfill = 0;\n\t    }\n\t    else\n\t    {\n\t\twp->w_topfill = wp->w_height - n;\n\t\tif (wp->w_topfill < 0)\n\t\t    wp->w_topfill = 0;\n\t    }\n\t}\n    }\n}\n\n/*\n * Use as many filler lines as possible for w_topline.  Make sure w_topline\n * is still visible.\n */\n    static void\nmax_topfill(void)\n{\n    int\t\tn;\n\n    n = plines_nofill(curwin->w_topline);\n    if (n >= curwin->w_height)\n\tcurwin->w_topfill = 0;\n    else\n    {\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill + n > curwin->w_height)\n\t    curwin->w_topfill = curwin->w_height - n;\n    }\n}\n#endif\n\n/*\n * Scroll the screen one line down, but don't do it if it would move the\n * cursor off the screen.\n */\n    void\nscrolldown_clamp(void)\n{\n    int\t\tend_row;\n#ifdef FEAT_DIFF\n    int\t\tcan_fill = (curwin->w_topfill\n\t\t\t\t< diff_check_fill(curwin, curwin->w_topline));\n#endif\n\n    if (curwin->w_topline <= 1\n#ifdef FEAT_DIFF\n\t    && !can_fill\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the last row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go past 'scrolloff' lines from the screen end.\n     */\n    end_row = curwin->w_wrow;\n#ifdef FEAT_DIFF\n    if (can_fill)\n\t++end_row;\n    else\n\tend_row += plines_nofill(curwin->w_topline - 1);\n#else\n    end_row += plines(curwin->w_topline - 1);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_cheight();\n\tvalidate_virtcol();\n\tend_row += curwin->w_cline_height - 1 -\n\t    curwin->w_virtcol / curwin->w_width;\n    }\n    if (end_row < curwin->w_height - get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (can_fill)\n\t{\n\t    ++curwin->w_topfill;\n\t    check_topfill(curwin, TRUE);\n\t}\n\telse\n\t{\n\t    --curwin->w_topline;\n\t    curwin->w_topfill = 0;\n\t}\n#else\n\t--curwin->w_topline;\n#endif\n#ifdef FEAT_FOLDING\n\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t--curwin->w_botline;\t    // approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Scroll the screen one line up, but don't do it if it would move the cursor\n * off the screen.\n */\n    void\nscrollup_clamp(void)\n{\n    int\t    start_row;\n\n    if (curwin->w_topline == curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    && curwin->w_topfill == 0\n#endif\n\t    )\n\treturn;\n\n    validate_cursor();\t    // w_wrow needs to be valid\n\n    /*\n     * Compute the row number of the first row of the cursor line\n     * and make sure it doesn't go off the screen. Make sure the cursor\n     * doesn't go before 'scrolloff' lines from the screen start.\n     */\n#ifdef FEAT_DIFF\n    start_row = curwin->w_wrow - plines_nofill(curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#else\n    start_row = curwin->w_wrow - plines(curwin->w_topline);\n#endif\n    if (curwin->w_p_wrap && curwin->w_width != 0)\n    {\n\tvalidate_virtcol();\n\tstart_row -= curwin->w_virtcol / curwin->w_width;\n    }\n    if (start_row >= get_scrolloff_value())\n    {\n#ifdef FEAT_DIFF\n\tif (curwin->w_topfill > 0)\n\t    --curwin->w_topfill;\n\telse\n#endif\n\t{\n#ifdef FEAT_FOLDING\n\t    (void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t    ++curwin->w_topline;\n\t}\n\t++curwin->w_botline;\t\t// approximate w_botline\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n    }\n}\n\n/*\n * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines above the first one are incredibly high: MAXCOL.\n */\n    static void\ntopline_back(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t--lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum < 1)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, &lp->lnum, NULL))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n/*\n * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or\n * a (wrapped) text line.  Uses and sets \"lp->fill\".\n * Returns the height of the added line in \"lp->height\".\n * Lines below the last one are incredibly high.\n */\n    static void\nbotline_forw(lineoff_T *lp)\n{\n#ifdef FEAT_DIFF\n    if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))\n    {\n\t// Add a filler line.\n\t++lp->fill;\n\tlp->height = 1;\n    }\n    else\n#endif\n    {\n\t++lp->lnum;\n#ifdef FEAT_DIFF\n\tlp->fill = 0;\n#endif\n\tif (lp->lnum > curbuf->b_ml.ml_line_count)\n\t    lp->height = MAXCOL;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(lp->lnum, NULL, &lp->lnum))\n\t    // Add a closed fold\n\t    lp->height = 1;\n\telse\n#endif\n\t    lp->height = PLINES_NOFILL(lp->lnum);\n    }\n}\n\n#ifdef FEAT_DIFF\n/*\n * Switch from including filler lines below lp->lnum to including filler\n * lines above loff.lnum + 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\nbotline_topline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\t++lp->lnum;\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n    }\n}\n\n/*\n * Switch from including filler lines above lp->lnum to including filler\n * lines below loff.lnum - 1.  This keeps pointing to the same line.\n * When there are no filler lines nothing changes.\n */\n    static void\ntopline_botline(lineoff_T *lp)\n{\n    if (lp->fill > 0)\n    {\n\tlp->fill = diff_check_fill(curwin, lp->lnum) - lp->fill + 1;\n\t--lp->lnum;\n    }\n}\n#endif\n\n/*\n * Recompute topline to put the cursor at the top of the window.\n * Scroll at least \"min_scroll\" lines.\n * If \"always\" is TRUE, always set topline (for \"zt\").\n */\n    void\nscroll_cursor_top(int min_scroll, int always)\n{\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\tused;\n    int\t\ti;\n    linenr_T\ttop;\t\t// just above displayed lines\n    linenr_T\tbot;\t\t// just below displayed lines\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    linenr_T\told_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tnew_topline;\n    int\t\toff = get_scrolloff_value();\n\n    if (mouse_dragging > 0)\n\toff = mouse_dragging - 1;\n\n    /*\n     * Decrease topline until:\n     * - it has become 1\n     * - (part of) the cursor line is moved off the screen or\n     * - moved at least 'scrolljump' lines and\n     * - at least 'scrolloff' lines above and below the cursor\n     */\n    validate_cheight();\n    used = curwin->w_cline_height; // includes filler lines above\n    if (curwin->w_cursor.lnum < curwin->w_topline)\n\tscrolled = used;\n\n#ifdef FEAT_FOLDING\n    if (hasFolding(curwin->w_cursor.lnum, &top, &bot))\n    {\n\t--top;\n\t++bot;\n    }\n    else\n#endif\n    {\n\ttop = curwin->w_cursor.lnum - 1;\n\tbot = curwin->w_cursor.lnum + 1;\n    }\n    new_topline = top + 1;\n\n#ifdef FEAT_DIFF\n    // \"used\" already contains the number of filler lines above, don't add it\n    // again.\n    // Hide filler lines above cursor line by adding them to \"extra\".\n    extra += diff_check_fill(curwin, curwin->w_cursor.lnum);\n#endif\n\n    /*\n     * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,\n     * set new_topline and advance \"top\" and \"bot\" to include more lines.\n     */\n    while (top > 0)\n    {\n#ifdef FEAT_FOLDING\n\tif (hasFolding(top, &top, NULL))\n\t    // count one logical line for a sequence of folded lines\n\t    i = 1;\n\telse\n#endif\n\t    i = PLINES_NOFILL(top);\n\tused += i;\n\tif (extra + i <= off && bot < curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(bot, NULL, &bot))\n\t\t// count one logical line for a sequence of folded lines\n\t\t++used;\n\t    else\n#endif\n\t\tused += plines(bot);\n\t}\n\tif (used > curwin->w_height)\n\t    break;\n\tif (top < curwin->w_topline)\n\t    scrolled += i;\n\n\t/*\n\t * If scrolling is needed, scroll at least 'sj' lines.\n\t */\n\tif ((new_topline >= curwin->w_topline || scrolled > min_scroll)\n\t\t&& extra >= off)\n\t    break;\n\n\textra += i;\n\tnew_topline = top;\n\t--top;\n\t++bot;\n    }\n\n    /*\n     * If we don't have enough space, put cursor in the middle.\n     * This makes sure we get the same position when using \"k\" and \"j\"\n     * in a small window.\n     */\n    if (used > curwin->w_height)\n\tscroll_cursor_halfway(FALSE);\n    else\n    {\n\t/*\n\t * If \"always\" is FALSE, only adjust topline to a lower value, higher\n\t * value may happen with wrapping lines\n\t */\n\tif (new_topline < curwin->w_topline || always)\n\t    curwin->w_topline = new_topline;\n\tif (curwin->w_topline > curwin->w_cursor.lnum)\n\t    curwin->w_topline = curwin->w_cursor.lnum;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n\tif (curwin->w_topfill > 0 && extra > off)\n\t{\n\t    curwin->w_topfill -= extra - off;\n\t    if (curwin->w_topfill < 0)\n\t\tcurwin->w_topfill = 0;\n\t}\n\tcheck_topfill(curwin, FALSE);\n#endif\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &=\n\t\t      ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\tcurwin->w_valid |= VALID_TOPLINE;\n    }\n}\n\n/*\n * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\"\n * screen lines for text lines.\n */\n    void\nset_empty_rows(win_T *wp, int used)\n{\n#ifdef FEAT_DIFF\n    wp->w_filler_rows = 0;\n#endif\n    if (used == 0)\n\twp->w_empty_rows = 0;\t// single line that doesn't fit\n    else\n    {\n\twp->w_empty_rows = wp->w_height - used;\n#ifdef FEAT_DIFF\n\tif (wp->w_botline <= wp->w_buffer->b_ml.ml_line_count)\n\t{\n\t    wp->w_filler_rows = diff_check_fill(wp, wp->w_botline);\n\t    if (wp->w_empty_rows > wp->w_filler_rows)\n\t\twp->w_empty_rows -= wp->w_filler_rows;\n\t    else\n\t    {\n\t\twp->w_filler_rows = wp->w_empty_rows;\n\t\twp->w_empty_rows = 0;\n\t    }\n\t}\n#endif\n    }\n}\n\n/*\n * Recompute topline to put the cursor at the bottom of the window.\n * When scrolling scroll at least \"min_scroll\" lines.\n * If \"set_topbot\" is TRUE, set topline and botline first (for \"zb\").\n * This is messy stuff!!!\n */\n    void\nscroll_cursor_bot(int min_scroll, int set_topbot)\n{\n    int\t\tused;\n    int\t\tscrolled = 0;\n    int\t\textra = 0;\n    int\t\ti;\n    linenr_T\tline_count;\n    linenr_T\told_topline = curwin->w_topline;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n    int\t\tfill_below_window;\n#endif\n    linenr_T\told_botline = curwin->w_botline;\n    linenr_T\told_valid = curwin->w_valid;\n    int\t\told_empty_rows = curwin->w_empty_rows;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    long\tso = get_scrolloff_value();\n\n    cln = curwin->w_cursor.lnum;\n    if (set_topbot)\n    {\n\tused = 0;\n\tcurwin->w_botline = cln + 1;\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tfor (curwin->w_topline = curwin->w_botline;\n\t\tcurwin->w_topline > 1;\n\t\tcurwin->w_topline = loff.lnum)\n\t{\n\t    loff.lnum = curwin->w_topline;\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL || used + loff.height > curwin->w_height)\n\t\tbreak;\n\t    used += loff.height;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = loff.fill;\n#endif\n\t}\n\tset_empty_rows(curwin, used);\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tif (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t)\n\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n    }\n    else\n\tvalidate_botline();\n\n    // The lines of the cursor line itself are always used.\n#ifdef FEAT_DIFF\n    used = plines_nofill(cln);\n#else\n    validate_cheight();\n    used = curwin->w_cline_height;\n#endif\n\n    // If the cursor is below botline, we will at least scroll by the height\n    // of the cursor line.  Correct for empty lines, which are really part of\n    // botline.\n    if (cln >= curwin->w_botline)\n    {\n\tscrolled = used;\n\tif (cln == curwin->w_botline)\n\t    scrolled -= curwin->w_empty_rows;\n    }\n\n    /*\n     * Stop counting lines to scroll when\n     * - hitting start of the file\n     * - scrolled nothing or at least 'sj' lines\n     * - at least 'scrolloff' lines below the cursor\n     * - lines between botline and cursor have been counted\n     */\n#ifdef FEAT_FOLDING\n    if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum))\n#endif\n    {\n\tloff.lnum = cln;\n\tboff.lnum = cln;\n    }\n#ifdef FEAT_DIFF\n    loff.fill = 0;\n    boff.fill = 0;\n    fill_below_window = diff_check_fill(curwin, curwin->w_botline)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\n    while (loff.lnum > 1)\n    {\n\t// Stop when scrolled nothing or at least \"min_scroll\", found \"extra\"\n\t// context for 'scrolloff' and counted all lines below the window.\n\tif ((((scrolled <= 0 || scrolled >= min_scroll)\n\t\t    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))\n\t\t    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)\n\t\t&& loff.lnum <= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum < curwin->w_botline\n\t\t    || loff.fill >= fill_below_window)\n#endif\n\t\t)\n\t    break;\n\n\t// Add one line above\n\ttopline_back(&loff);\n\tif (loff.height == MAXCOL)\n\t    used = MAXCOL;\n\telse\n\t    used += loff.height;\n\tif (used > curwin->w_height)\n\t    break;\n\tif (loff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t&& (loff.lnum > curwin->w_botline\n\t\t    || loff.fill <= fill_below_window)\n#endif\n\t\t)\n\t{\n\t    // Count screen lines that are below the window.\n\t    scrolled += loff.height;\n\t    if (loff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && loff.fill == 0\n#endif\n\t\t    )\n\t\tscrolled -= curwin->w_empty_rows;\n\t}\n\n\tif (boff.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    // Add one line below\n\t    botline_forw(&boff);\n\t    used += boff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so)\n\t\t    || scrolled < min_scroll)\n\t    {\n\t\textra += boff.height;\n\t\tif (boff.lnum >= curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t|| (boff.lnum + 1 == curwin->w_botline\n\t\t\t    && boff.fill > curwin->w_filler_rows)\n#endif\n\t\t   )\n\t\t{\n\t\t    // Count screen lines that are below the window.\n\t\t    scrolled += boff.height;\n\t\t    if (boff.lnum == curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t    && boff.fill == 0\n#endif\n\t\t\t    )\n\t\t\tscrolled -= curwin->w_empty_rows;\n\t\t}\n\t    }\n\t}\n    }\n\n    // curwin->w_empty_rows is larger, no need to scroll\n    if (scrolled <= 0)\n\tline_count = 0;\n    // more than a screenfull, don't scroll but redraw\n    else if (used > curwin->w_height)\n\tline_count = used;\n    // scroll minimal number of lines\n    else\n    {\n\tline_count = 0;\n#ifdef FEAT_DIFF\n\tboff.fill = curwin->w_topfill;\n#endif\n\tboff.lnum = curwin->w_topline - 1;\n\tfor (i = 0; i < scrolled && boff.lnum < curwin->w_botline; )\n\t{\n\t    botline_forw(&boff);\n\t    i += boff.height;\n\t    ++line_count;\n\t}\n\tif (i < scrolled)\t// below curwin->w_botline, don't scroll\n\t    line_count = 9999;\n    }\n\n    /*\n     * Scroll up if the cursor is off the bottom of the screen a bit.\n     * Otherwise put it at 1/2 of the screen.\n     */\n    if (line_count >= curwin->w_height && line_count > min_scroll)\n\tscroll_cursor_halfway(FALSE);\n    else\n\tscrollup(line_count, TRUE);\n\n    /*\n     * If topline didn't change we need to restore w_botline and w_empty_rows\n     * (we changed them).\n     * If topline did change, update_screen() will set botline.\n     */\n    if (curwin->w_topline == old_topline && set_topbot)\n    {\n\tcurwin->w_botline = old_botline;\n\tcurwin->w_empty_rows = old_empty_rows;\n\tcurwin->w_valid = old_valid;\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Recompute topline to put the cursor halfway the window\n * If \"atend\" is TRUE, also put it halfway at the end of the file.\n */\n    void\nscroll_cursor_halfway(int atend)\n{\n    int\t\tabove = 0;\n    linenr_T\ttopline;\n#ifdef FEAT_DIFF\n    int\t\ttopfill = 0;\n#endif\n    int\t\tbelow = 0;\n    int\t\tused;\n    lineoff_T\tloff;\n    lineoff_T\tboff;\n#ifdef FEAT_DIFF\n    linenr_T\told_topline = curwin->w_topline;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    // if the width changed this needs to be updated first\n    may_update_popup_position();\n#endif\n    loff.lnum = boff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n    (void)hasFolding(loff.lnum, &loff.lnum, &boff.lnum);\n#endif\n#ifdef FEAT_DIFF\n    used = plines_nofill(loff.lnum);\n    loff.fill = 0;\n    boff.fill = 0;\n#else\n    used = plines(loff.lnum);\n#endif\n    topline = loff.lnum;\n    while (topline > 1)\n    {\n\tif (below <= above)\t    // add a line below the cursor first\n\t{\n\t    if (boff.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tbotline_forw(&boff);\n\t\tused += boff.height;\n\t\tif (used > curwin->w_height)\n\t\t    break;\n\t\tbelow += boff.height;\n\t    }\n\t    else\n\t    {\n\t\t++below;\t    // count a \"~\" line\n\t\tif (atend)\n\t\t    ++used;\n\t    }\n\t}\n\n\tif (below > above)\t    // add a line above the cursor\n\t{\n\t    topline_back(&loff);\n\t    if (loff.height == MAXCOL)\n\t\tused = MAXCOL;\n\t    else\n\t\tused += loff.height;\n\t    if (used > curwin->w_height)\n\t\tbreak;\n\t    above += loff.height;\n\t    topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t    topfill = loff.fill;\n#endif\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (!hasFolding(topline, &curwin->w_topline, NULL))\n#endif\n\tcurwin->w_topline = topline;\n#ifdef FEAT_DIFF\n    curwin->w_topfill = topfill;\n    if (old_topline > curwin->w_topline + curwin->w_height)\n\tcurwin->w_botfill = FALSE;\n    check_topfill(curwin, FALSE);\n#endif\n    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\n/*\n * Correct the cursor position so that it is in a part of the screen at least\n * 'scrolloff' lines from the top and bottom, if possible.\n * If not possible, put it at the same position as scroll_cursor_halfway().\n * When called topline must be valid!\n */\n    void\ncursor_correct(void)\n{\n    int\t\tabove = 0;\t    // screen lines above topline\n    linenr_T\ttopline;\n    int\t\tbelow = 0;\t    // screen lines below botline\n    linenr_T\tbotline;\n    int\t\tabove_wanted, below_wanted;\n    linenr_T\tcln;\t\t    // Cursor Line Number\n    int\t\tmax_off;\n    long\tso = get_scrolloff_value();\n\n    /*\n     * How many lines we would like to have above/below the cursor depends on\n     * whether the first/last line of the file is on screen.\n     */\n    above_wanted = so;\n    below_wanted = so;\n    if (mouse_dragging > 0)\n    {\n\tabove_wanted = mouse_dragging - 1;\n\tbelow_wanted = mouse_dragging - 1;\n    }\n    if (curwin->w_topline == 1)\n    {\n\tabove_wanted = 0;\n\tmax_off = curwin->w_height / 2;\n\tif (below_wanted > max_off)\n\t    below_wanted = max_off;\n    }\n    validate_botline();\n    if (curwin->w_botline == curbuf->b_ml.ml_line_count + 1\n\t    && mouse_dragging == 0)\n    {\n\tbelow_wanted = 0;\n\tmax_off = (curwin->w_height - 1) / 2;\n\tif (above_wanted > max_off)\n\t    above_wanted = max_off;\n    }\n\n    /*\n     * If there are sufficient file-lines above and below the cursor, we can\n     * return now.\n     */\n    cln = curwin->w_cursor.lnum;\n    if (cln >= curwin->w_topline + above_wanted\n\t    && cln < curwin->w_botline - below_wanted\n#ifdef FEAT_FOLDING\n\t    && !hasAnyFolding(curwin)\n#endif\n\t    )\n\treturn;\n\n    /*\n     * Narrow down the area where the cursor can be put by taking lines from\n     * the top and the bottom until:\n     * - the desired context lines are found\n     * - the lines from the top is past the lines from the bottom\n     */\n    topline = curwin->w_topline;\n    botline = curwin->w_botline - 1;\n#ifdef FEAT_DIFF\n    // count filler lines as context\n    above = curwin->w_topfill;\n    below = curwin->w_filler_rows;\n#endif\n    while ((above < above_wanted || below < below_wanted) && topline < botline)\n    {\n\tif (below < below_wanted && (below <= above || above >= above_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(botline, &botline, NULL))\n\t\t++below;\n\t    else\n#endif\n\t\tbelow += plines(botline);\n\t    --botline;\n\t}\n\tif (above < above_wanted && (above < below || below >= below_wanted))\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasFolding(topline, NULL, &topline))\n\t\t++above;\n\t    else\n#endif\n\t\tabove += PLINES_NOFILL(topline);\n#ifdef FEAT_DIFF\n\t    // Count filler lines below this line as context.\n\t    if (topline < botline)\n\t\tabove += diff_check_fill(curwin, topline + 1);\n#endif\n\t    ++topline;\n\t}\n    }\n    if (topline == botline || botline == 0)\n\tcurwin->w_cursor.lnum = topline;\n    else if (topline > botline)\n\tcurwin->w_cursor.lnum = botline;\n    else\n    {\n\tif (cln < topline && curwin->w_topline > 1)\n\t{\n\t    curwin->w_cursor.lnum = topline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n\tif (cln > botline && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_cursor.lnum = botline;\n\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW);\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n}\n\nstatic void get_scroll_overlap(lineoff_T *lp, int dir);\n\n/*\n * move screen 'count' pages up or down and update screen\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nonepage(int dir, long count)\n{\n    long\tn;\n    int\t\tretval = OK;\n    lineoff_T\tloff;\n    linenr_T\told_topline = curwin->w_topline;\n    long\tso = get_scrolloff_value();\n\n    if (curbuf->b_ml.ml_line_count == 1)    // nothing to do\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n\n    for ( ; count > 0; --count)\n    {\n\tvalidate_botline();\n\t/*\n\t * It's an error to move a page up when the first line is already on\n\t * the screen.\tIt's an error to move a page down when the last line\n\t * is on the screen and the topline is 'scrolloff' lines from the\n\t * last line.\n\t */\n\tif (dir == FORWARD\n\t\t? ((curwin->w_topline >= curbuf->b_ml.ml_line_count - so)\n\t\t    && curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t: (curwin->w_topline == 1\n#ifdef FEAT_DIFF\n\t\t    && curwin->w_topfill ==\n\t\t\t\t    diff_check_fill(curwin, curwin->w_topline)\n#endif\n\t\t    ))\n\t{\n\t    beep_flush();\n\t    retval = FAIL;\n\t    break;\n\t}\n\n#ifdef FEAT_DIFF\n\tloff.fill = 0;\n#endif\n\tif (dir == FORWARD)\n\t{\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling\n\t\tif (p_window <= 2)\n\t\t    ++curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline += p_window - 2;\n\t\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t    }\n\t    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// at end of file\n\t\tcurwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW);\n\t    }\n\t    else\n\t    {\n\t\t// For the overlap, start with the line just below the window\n\t\t// and go upwards.\n\t\tloff.lnum = curwin->w_botline;\n#ifdef FEAT_DIFF\n\t\tloff.fill = diff_check_fill(curwin, loff.lnum)\n\t\t\t\t\t\t      - curwin->w_filler_rows;\n#endif\n\t\tget_scroll_overlap(&loff, -1);\n\t\tcurwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = loff.fill;\n\t\tcheck_topfill(curwin, FALSE);\n#endif\n\t\tcurwin->w_cursor.lnum = curwin->w_topline;\n\t\tcurwin->w_valid &= ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|\n\t\t\t\t   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    }\n\t}\n\telse\t// dir == BACKWARDS\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topline == 1)\n\t    {\n\t\t// Include max number of filler lines\n\t\tmax_topfill();\n\t\tcontinue;\n\t    }\n#endif\n\t    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)\n\t    {\n\t\t// Vi compatible scrolling (sort of)\n\t\tif (p_window <= 2)\n\t\t    --curwin->w_topline;\n\t\telse\n\t\t    curwin->w_topline -= p_window - 2;\n\t\tif (curwin->w_topline < 1)\n\t\t    curwin->w_topline = 1;\n\t\tcurwin->w_cursor.lnum = curwin->w_topline + p_window - 1;\n\t\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcontinue;\n\t    }\n\n\t    // Find the line at the top of the window that is going to be the\n\t    // line at the bottom of the window.  Make sure this results in\n\t    // the same line as before doing CTRL-F.\n\t    loff.lnum = curwin->w_topline - 1;\n#ifdef FEAT_DIFF\n\t    loff.fill = diff_check_fill(curwin, loff.lnum + 1)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    get_scroll_overlap(&loff, 1);\n\n\t    if (loff.lnum >= curbuf->b_ml.ml_line_count)\n\t    {\n\t\tloff.lnum = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t    }\n\t    else\n\t    {\n\t\tbotline_topline(&loff);\n#endif\n\t    }\n\t    curwin->w_cursor.lnum = loff.lnum;\n\n\t    // Find the line just above the new topline to get the right line\n\t    // at the bottom of the window.\n\t    n = 0;\n\t    while (n <= curwin->w_height && loff.lnum >= 1)\n\t    {\n\t\ttopline_back(&loff);\n\t\tif (loff.height == MAXCOL)\n\t\t    n = MAXCOL;\n\t\telse\n\t\t    n += loff.height;\n\t    }\n\t    if (loff.lnum < 1)\t\t\t// at begin of file\n\t    {\n\t\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\t\tmax_topfill();\n#endif\n\t\tcurwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t    }\n\t    else\n\t    {\n\t\t// Go two lines forward again.\n#ifdef FEAT_DIFF\n\t\ttopline_botline(&loff);\n#endif\n\t\tbotline_forw(&loff);\n\t\tbotline_forw(&loff);\n#ifdef FEAT_DIFF\n\t\tbotline_topline(&loff);\n#endif\n#ifdef FEAT_FOLDING\n\t\t// We're at the wrong end of a fold now.\n\t\t(void)hasFolding(loff.lnum, &loff.lnum, NULL);\n#endif\n\n\t\t// Always scroll at least one line.  Avoid getting stuck on\n\t\t// very long lines.\n\t\tif (loff.lnum >= curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum > curwin->w_topline\n\t\t\t    || loff.fill >= curwin->w_topfill)\n#endif\n\t\t\t)\n\t\t{\n#ifdef FEAT_DIFF\n\t\t    // First try using the maximum number of filler lines.  If\n\t\t    // that's not enough, backup one line.\n\t\t    loff.fill = curwin->w_topfill;\n\t\t    if (curwin->w_topfill < diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t\t\tmax_topfill();\n\t\t    if (curwin->w_topfill == loff.fill)\n#endif\n\t\t    {\n\t\t\t--curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\t\tcurwin->w_topfill = 0;\n#endif\n\t\t    }\n\t\t    comp_botline(curwin);\n\t\t    curwin->w_cursor.lnum = curwin->w_botline - 1;\n\t\t    curwin->w_valid &=\n\t\t\t    ~(VALID_WCOL|VALID_CHEIGHT|VALID_WROW|VALID_CROW);\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_topline = loff.lnum;\n#ifdef FEAT_DIFF\n\t\t    curwin->w_topfill = loff.fill;\n\t\t    check_topfill(curwin, FALSE);\n#endif\n\t\t    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);\n\t\t}\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    foldAdjustCursor();\n#endif\n    cursor_correct();\n    check_cursor_col();\n    if (retval == OK)\n\tbeginline(BL_SOL | BL_FIX);\n    curwin->w_valid &= ~(VALID_WCOL|VALID_WROW|VALID_VIRTCOL);\n\n    if (retval == OK && dir == FORWARD)\n    {\n\t// Avoid the screen jumping up and down when 'scrolloff' is non-zero.\n\t// But make sure we scroll at least one line (happens with mix of long\n\t// wrapping lines and non-wrapping line).\n\tif (check_top_offset())\n\t{\n\t    scroll_cursor_top(1, FALSE);\n\t    if (curwin->w_topline <= old_topline\n\t\t\t\t  && old_topline < curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_topline = old_topline + 1;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    }\n\t}\n#ifdef FEAT_FOLDING\n\telse if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n    }\n\n    redraw_later(UPD_VALID);\n    return retval;\n}\n\n/*\n * Decide how much overlap to use for page-up or page-down scrolling.\n * This is symmetric, so that doing both keeps the same lines displayed.\n * Three lines are examined:\n *\n *  before CTRL-F\t    after CTRL-F / before CTRL-B\n *     etc.\t\t\tl1\n *  l1 last but one line\t------------\n *  l2 last text line\t\tl2 top text line\n *  -------------\t\tl3 second text line\n *  l3\t\t\t\t   etc.\n */\n    static void\nget_scroll_overlap(lineoff_T *lp, int dir)\n{\n    int\t\th1, h2, h3, h4;\n    int\t\tmin_height = curwin->w_height - 2;\n    lineoff_T\tloff0, loff1, loff2;\n\n#ifdef FEAT_DIFF\n    if (lp->fill > 0)\n\tlp->height = 1;\n    else\n\tlp->height = plines_nofill(lp->lnum);\n#else\n    lp->height = plines(lp->lnum);\n#endif\n    h1 = lp->height;\n    if (h1 > min_height)\n\treturn;\t\t// no overlap\n\n    loff0 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h2 = lp->height;\n    if (h2 == MAXCOL || h2 + h1 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff1 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h3 = lp->height;\n    if (h3 == MAXCOL || h3 + h2 > min_height)\n    {\n\t*lp = loff0;\t// no overlap\n\treturn;\n    }\n\n    loff2 = *lp;\n    if (dir > 0)\n\tbotline_forw(lp);\n    else\n\ttopline_back(lp);\n    h4 = lp->height;\n    if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)\n\t*lp = loff1;\t// 1 line overlap\n    else\n\t*lp = loff2;\t// 2 lines overlap\n}\n\n/*\n * Scroll 'scroll' lines up or down.\n */\n    void\nhalfpage(int flag, linenr_T Prenum)\n{\n    long\tscrolled = 0;\n    int\t\ti;\n    int\t\tn;\n    int\t\troom;\n\n    if (Prenum)\n\tcurwin->w_p_scr = (Prenum > curwin->w_height) ?\n\t\t\t\t\t\tcurwin->w_height : Prenum;\n    n = (curwin->w_p_scr <= curwin->w_height) ?\n\t\t\t\t    curwin->w_p_scr : curwin->w_height;\n\n    update_topline();\n    validate_botline();\n    room = curwin->w_empty_rows;\n#ifdef FEAT_DIFF\n    room += curwin->w_filler_rows;\n#endif\n    if (flag)\n    {\n\t/*\n\t * scroll the text up\n\t */\n\twhile (n > 0 && curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill > 0)\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t--curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, NULL, &curwin->w_topline);\n#endif\n\t\t++curwin->w_topline;\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = diff_check_fill(curwin, curwin->w_topline);\n#endif\n\n\t\tif (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_valid &=\n\t\t\t\t    ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t\t}\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW);\n\t    scrolled += i;\n\n\t    /*\n\t     * Correct w_botline for changed w_topline.\n\t     * Won't work when there are filler lines.\n\t     */\n#ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_valid &= ~(VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    else\n#endif\n\t    {\n\t\troom += i;\n\t\tdo\n\t\t{\n\t\t    i = plines(curwin->w_botline);\n\t\t    if (i > room)\n\t\t\tbreak;\n#ifdef FEAT_FOLDING\n\t\t    (void)hasFolding(curwin->w_botline, NULL,\n\t\t\t\t\t\t\t  &curwin->w_botline);\n#endif\n\t\t    ++curwin->w_botline;\n\t\t    room -= i;\n\t\t} while (curwin->w_botline <= curbuf->b_ml.ml_line_count);\n\t    }\n\t}\n\n\t/*\n\t * When hit bottom of the file: move cursor down.\n\t */\n\tif (n > 0)\n\t{\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n\t\t    ++curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum += n;\n\t    check_cursor_lnum();\n\t}\n    }\n    else\n    {\n\t/*\n\t * scroll the text down\n\t */\n\twhile (n > 0 && curwin->w_topline > 1)\n\t{\n#ifdef FEAT_DIFF\n\t    if (curwin->w_topfill < diff_check_fill(curwin, curwin->w_topline))\n\t    {\n\t\ti = 1;\n\t\t--n;\n\t\t++curwin->w_topfill;\n\t    }\n\t    else\n#endif\n\t    {\n\t\ti = PLINES_NOFILL(curwin->w_topline - 1);\n\t\tn -= i;\n\t\tif (n < 0 && scrolled > 0)\n\t\t    break;\n\t\t--curwin->w_topline;\n#ifdef FEAT_FOLDING\n\t\t(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n#ifdef FEAT_DIFF\n\t\tcurwin->w_topfill = 0;\n#endif\n\t    }\n\t    curwin->w_valid &= ~(VALID_CROW|VALID_WROW|\n\t\t\t\t\t      VALID_BOTLINE|VALID_BOTLINE_AP);\n\t    scrolled += i;\n\t    if (curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--curwin->w_cursor.lnum;\n\t\tcurwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);\n\t    }\n\t}\n\n\t/*\n\t * When hit top of the file: move cursor up.\n\t */\n\tif (n > 0)\n\t{\n\t    if (curwin->w_cursor.lnum <= (linenr_T)n)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    else\n# ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\twhile (--n >= 0 && curwin->w_cursor.lnum > 1)\n\t\t{\n\t\t    --curwin->w_cursor.lnum;\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t}\n\t    }\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum -= n;\n\t}\n    }\n# ifdef FEAT_FOLDING\n    // Move cursor to first line of closed fold.\n    foldAdjustCursor();\n# endif\n#ifdef FEAT_DIFF\n    check_topfill(curwin, !flag);\n#endif\n    cursor_correct();\n    beginline(BL_SOL | BL_FIX);\n    redraw_later(UPD_VALID);\n}\n\n    void\ndo_check_cursorbind(void)\n{\n    linenr_T\tline = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    colnr_T\tcoladd = curwin->w_cursor.coladd;\n    colnr_T\tcurswant = curwin->w_curswant;\n    int\t\tset_curswant = curwin->w_set_curswant;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\trestart_edit_save;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n\n    /*\n     * loop through the cursorbound windows\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_crb)\n\t{\n# ifdef FEAT_DIFF\n\t    if (curwin->w_p_diff)\n\t\tcurwin->w_cursor.lnum =\n\t\t\t\t diff_get_corresponding_line(old_curbuf, line);\n\t    else\n# endif\n\t\tcurwin->w_cursor.lnum = line;\n\t    curwin->w_cursor.col = col;\n\t    curwin->w_cursor.coladd = coladd;\n\t    curwin->w_curswant = curswant;\n\t    curwin->w_set_curswant = set_curswant;\n\n\t    // Make sure the cursor is in a valid position.  Temporarily set\n\t    // \"restart_edit\" to allow the cursor to be beyond the EOL.\n\t    restart_edit_save = restart_edit;\n\t    restart_edit = TRUE;\n\t    check_cursor();\n\n\t    // Avoid a scroll here for the cursor position, 'scrollbind' is\n\t    // more important.\n\t    if (!curwin->w_p_scb)\n\t\tvalidate_cursor();\n\n\t    restart_edit = restart_edit_save;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t    redraw_later(UPD_VALID);\n\n\t    // Only scroll when 'scrollbind' hasn't done this.\n\t    if (!curwin->w_p_scb)\n\t\tupdate_topline();\n\t    curwin->w_redr_status = TRUE;\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n", "\" Test for insert completion\n\nsource screendump.vim\nsource check.vim\nimport './vim9.vim' as v9\n\n\" Test for insert expansion\nfunc Test_ins_complete()\n  edit test_ins_complete.vim\n  \" The files in the current directory interferes with the files\n  \" used by this test. So use a separate directory for the test.\n  call mkdir('Xcpldir')\n  cd Xcpldir\n\n  set ff=unix\n  call writefile([\"test11\\t36Gepeto\\t/Tag/\",\n\t      \\ \"asd\\ttest11file\\t36G\",\n\t      \\ \"Makefile\\tto\\trun\"], 'Xtestfile')\n  call writefile(['', 'start of testfile',\n\t      \\ 'ru',\n\t      \\ 'run1',\n\t      \\ 'run2',\n\t      \\ 'STARTTEST',\n\t      \\ 'ENDTEST',\n\t      \\ 'end of testfile'], 'Xtestdata')\n  set ff&\n\n  enew!\n  edit Xtestdata\n  new\n  call append(0, ['#include \"Xtestfile\"', ''])\n  call cursor(2, 1)\n\n  set cot=\n  set cpt=.,w\n  \" add-expands (word from next line) from other window\n  exe \"normal iru\\<C-N>\\<C-N>\\<C-X>\\<C-N>\\<Esc>\\<C-A>\"\n  call assert_equal('run1 run3', getline('.'))\n  \" add-expands (current buffer first)\n  exe \"normal o\\<C-P>\\<C-X>\\<C-N>\"\n  call assert_equal('run3 run3', getline('.'))\n  \" Local expansion, ends in an empty line (unless it becomes a global\n  \" expansion)\n  exe \"normal o\\<C-X>\\<C-P>\\<C-P>\\<C-P>\\<C-P>\\<C-P>\"\n  call assert_equal('', getline('.'))\n  \" starts Local and switches to global add-expansion\n  exe \"normal o\\<C-X>\\<C-P>\\<C-P>\\<C-X>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-N>\"\n  call assert_equal('run1 run2', getline('.'))\n\n  set cpt=.,\\ ,w,i\n  \" i-add-expands and switches to local\n  exe \"normal OM\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal(\"Makefile\\tto\\trun3\", getline('.'))\n  \" add-expands lines (it would end in an empty line if it didn't ignore\n  \" itself)\n  exe \"normal o\\<C-X>\\<C-L>\\<C-X>\\<C-L>\\<C-P>\\<C-P>\"\n  call assert_equal(\"Makefile\\tto\\trun3\", getline('.'))\n  call assert_equal(\"Makefile\\tto\\trun3\", getline(line('.') - 1))\n\n  set cpt=kXtestfile\n  \" checks k-expansion, and file expansion (use Xtest11 instead of test11,\n  \" because TEST11.OUT may match first on DOS)\n  write Xtest11.one\n  write Xtest11.two\n  exe \"normal o\\<C-N>\\<Esc>IX\\<Esc>A\\<C-X>\\<C-F>\\<C-N>\"\n  call assert_equal('Xtest11.two', getline('.'))\n\n  \" use CTRL-X CTRL-F to complete Xtest11.one, remove it and then use CTRL-X\n  \" CTRL-F again to verify this doesn't cause trouble.\n  exe \"normal oXt\\<C-X>\\<C-F>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\\<C-X>\\<C-F>\"\n  call assert_equal('Xtest11.one', getline('.'))\n  normal ddk\n\n  \" Test for expanding a non-existing filename\n  exe \"normal oa1b2X3Y4\\<C-X>\\<C-F>\"\n  call assert_equal('a1b2X3Y4', getline('.'))\n  normal ddk\n\n  set cpt=w\n  \" checks make_cyclic in other window\n  exe \"normal oST\\<C-N>\\<C-P>\\<C-P>\\<C-P>\\<C-P>\"\n  call assert_equal('STARTTEST', getline('.'))\n\n  set cpt=u nohid\n  \" checks unloaded buffer expansion\n  only\n  exe \"normal oEN\\<C-N>\"\n  call assert_equal('ENDTEST', getline('.'))\n  \" checks adding mode abortion\n  exe \"normal ounl\\<C-N>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal('unless', getline('.'))\n\n  set cpt=t,d def=^\\\\k* tags=Xtestfile notagbsearch\n  \" tag expansion, define add-expansion interrupted\n  exe \"normal o\\<C-X>\\<C-]>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\\<C-X>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\\<C-X>\\<C-D>\"\n  call assert_equal('test11file\t36Gepeto\t/Tag/ asd', getline('.'))\n  \" t-expansion\n  exe \"normal oa\\<C-N>\\<Esc>\"\n  call assert_equal('asd', getline('.'))\n\n  %bw!\n  call delete('Xtestfile')\n  call delete('Xtest11.one')\n  call delete('Xtest11.two')\n  call delete('Xtestdata')\n  set cpt& cot& def& tags& tagbsearch& hidden&\n  cd ..\n  call delete('Xcpldir', 'rf')\nendfunc\n\nfunc Test_ins_complete_invalid_byte()\n  if has('unix') && executable('base64')\n    \" this weird command was causing an illegal memory access\n    call writefile(['bm9ybTlvMDCAMM4Dbw4OGA4ODg=='], 'Xinvalid64')\n    call system('base64 -d Xinvalid64 > Xinvalid')\n    call writefile(['qa!'], 'Xexit')\n    call RunVim([], [], \" -i NONE -n -X -Z -e -m -s -S Xinvalid -S Xexit\")\n    call delete('Xinvalid64')\n    call delete('Xinvalid')\n    call delete('Xexit')\n  endif\nendfunc\n\nfunc Test_omni_dash()\n  func Omni(findstart, base)\n    if a:findstart\n        return 5\n    else\n        echom a:base\n\treturn ['-help', '-v']\n    endif\n  endfunc\n  set omnifunc=Omni\n  new\n  exe \"normal Gofind -\\<C-x>\\<C-o>\"\n  call assert_equal(\"find -help\", getline('$'))\n\n  bwipe!\n  delfunc Omni\n  set omnifunc=\nendfunc\n\nfunc Test_omni_throw()\n  let g:CallCount = 0\n  func Omni(findstart, base)\n    let g:CallCount += 1\n    if a:findstart\n      throw \"he he he\"\n    endif\n  endfunc\n  set omnifunc=Omni\n  new\n  try\n    exe \"normal ifoo\\<C-x>\\<C-o>\"\n    call assert_false(v:true, 'command should have failed')\n  catch\n    call assert_exception('he he he')\n    call assert_equal(1, g:CallCount)\n  endtry\n\n  bwipe!\n  delfunc Omni\n  unlet g:CallCount\n  set omnifunc=\nendfunc\n\nfunc Test_omni_autoload()\n  let save_rtp = &rtp\n  set rtp=Xruntime/some\n  let dir = 'Xruntime/some/autoload'\n  call mkdir(dir, 'p')\n\n  let lines =<< trim END\n      vim9script\n      export def Func(findstart: bool, base: string): any\n          if findstart\n              return 1\n          else\n              return ['match']\n          endif\n      enddef\n      {\n          eval 1 + 2\n      }\n  END\n  call writefile(lines, dir .. '/omni.vim')\n\n  new\n  setlocal omnifunc=omni#Func\n  call feedkeys(\"i\\<C-X>\\<C-O>\\<Esc>\", 'xt')\n\n  bwipe!\n  call delete('Xruntime', 'rf')\n  set omnifunc=\n  let &rtp = save_rtp\nendfunc\n\nfunc Test_completefunc_args()\n  let s:args = []\n  func! CompleteFunc(findstart, base)\n    let s:args += [[a:findstart, empty(a:base)]]\n  endfunc\n  new\n\n  set completefunc=CompleteFunc\n  call feedkeys(\"i\\<C-X>\\<C-U>\\<Esc>\", 'x')\n  call assert_equal([1, 1], s:args[0])\n  call assert_equal(0, s:args[1][0])\n  set completefunc=\n\n  let s:args = []\n  set omnifunc=CompleteFunc\n  call feedkeys(\"i\\<C-X>\\<C-O>\\<Esc>\", 'x')\n  call assert_equal([1, 1], s:args[0])\n  call assert_equal(0, s:args[1][0])\n  set omnifunc=\n\n  bwipe!\n  unlet s:args\n  delfunc CompleteFunc\nendfunc\n\nfunc s:CompleteDone_CompleteFuncNone( findstart, base )\n  if a:findstart\n    return 0\n  endif\n\n  return v:none\nendfunc\n\nfunc s:CompleteDone_CompleteFuncDict( findstart, base )\n  if a:findstart\n    return 0\n  endif\n\n  return {\n\t  \\ 'words': [\n\t    \\ {\n\t      \\ 'word': 'aword',\n\t      \\ 'abbr': 'wrd',\n\t      \\ 'menu': 'extra text',\n\t      \\ 'info': 'words are cool',\n\t      \\ 'kind': 'W',\n\t      \\ 'user_data': 'test'\n\t    \\ }\n\t  \\ ]\n\t\\ }\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemNone()\n  let s:called_completedone = 1\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemDict(pre)\n  call assert_equal( 'aword',          v:completed_item[ 'word' ] )\n  call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )\n  call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )\n  call assert_equal( 'words are cool', v:completed_item[ 'info' ] )\n  call assert_equal( 'W',              v:completed_item[ 'kind' ] )\n  call assert_equal( 'test',           v:completed_item[ 'user_data' ] )\n\n  if a:pre\n    call assert_equal('function', complete_info().mode)\n  endif\n\n  let s:called_completedone = 1\nendfunc\n\nfunc Test_CompleteDoneNone()\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemNone()\n  let oldline = join(map(range(&columns), 'nr2char(screenchar(&lines-1, v:val+1))'), '')\n\n  set completefunc=<SID>CompleteDone_CompleteFuncNone\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n  let newline = join(map(range(&columns), 'nr2char(screenchar(&lines-1, v:val+1))'), '')\n\n  call assert_true(s:called_completedone)\n  call assert_equal(oldline, newline)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc Test_CompleteDoneDict()\n  au CompleteDonePre * :call <SID>CompleteDone_CheckCompletedItemDict(1)\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDict(0)\n\n  set completefunc=<SID>CompleteDone_CompleteFuncDict\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n\n  call assert_equal('test', v:completed_item[ 'user_data' ])\n  call assert_true(s:called_completedone)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc s:CompleteDone_CompleteFuncDictNoUserData(findstart, base)\n  if a:findstart\n    return 0\n  endif\n\n  return {\n\t  \\ 'words': [\n\t    \\ {\n\t      \\ 'word': 'aword',\n\t      \\ 'abbr': 'wrd',\n\t      \\ 'menu': 'extra text',\n\t      \\ 'info': 'words are cool',\n\t      \\ 'kind': 'W',\n\t      \\ 'user_data': ['one', 'two'],\n\t    \\ }\n\t  \\ ]\n\t\\ }\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemDictNoUserData()\n  call assert_equal( 'aword',          v:completed_item[ 'word' ] )\n  call assert_equal( 'wrd',            v:completed_item[ 'abbr' ] )\n  call assert_equal( 'extra text',     v:completed_item[ 'menu' ] )\n  call assert_equal( 'words are cool', v:completed_item[ 'info' ] )\n  call assert_equal( 'W',              v:completed_item[ 'kind' ] )\n  call assert_equal( ['one', 'two'],   v:completed_item[ 'user_data' ] )\n\n  let s:called_completedone = 1\nendfunc\n\nfunc Test_CompleteDoneDictNoUserData()\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemDictNoUserData()\n\n  set completefunc=<SID>CompleteDone_CompleteFuncDictNoUserData\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n\n  call assert_equal(['one', 'two'], v:completed_item[ 'user_data' ])\n  call assert_true(s:called_completedone)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc s:CompleteDone_CompleteFuncList(findstart, base)\n  if a:findstart\n    return 0\n  endif\n\n  return [ 'aword' ]\nendfunc\n\nfunc s:CompleteDone_CheckCompletedItemList()\n  call assert_equal( 'aword', v:completed_item[ 'word' ] )\n  call assert_equal( '',      v:completed_item[ 'abbr' ] )\n  call assert_equal( '',      v:completed_item[ 'menu' ] )\n  call assert_equal( '',      v:completed_item[ 'info' ] )\n  call assert_equal( '',      v:completed_item[ 'kind' ] )\n  call assert_equal( '',      v:completed_item[ 'user_data' ] )\n\n  let s:called_completedone = 1\nendfunc\n\nfunc Test_CompleteDoneList()\n  au CompleteDone * :call <SID>CompleteDone_CheckCompletedItemList()\n\n  set completefunc=<SID>CompleteDone_CompleteFuncList\n  execute \"normal a\\<C-X>\\<C-U>\\<C-Y>\"\n  set completefunc&\n\n  call assert_equal('', v:completed_item[ 'user_data' ])\n  call assert_true(s:called_completedone)\n\n  let s:called_completedone = 0\n  au! CompleteDone\nendfunc\n\nfunc Test_CompleteDone_undo()\n  au CompleteDone * call append(0, \"prepend1\")\n  new\n  call setline(1, [\"line1\", \"line2\"])\n  call feedkeys(\"Go\\<C-X>\\<C-N>\\<CR>\\<ESC>\", \"tx\")\n  call assert_equal([\"prepend1\", \"line1\", \"line2\", \"line1\", \"\"],\n              \\     getline(1, '$'))\n  undo\n  call assert_equal([\"line1\", \"line2\"], getline(1, '$'))\n  bwipe!\n  au! CompleteDone\nendfunc\n\nfunc Test_CompleteDone_modify()\n  let value = {\n        \\ 'word': '',\n        \\ 'abbr': '',\n        \\ 'menu': '',\n        \\ 'info': '',\n        \\ 'kind': '',\n        \\ 'user_data': '',\n        \\ }\n  let v:completed_item = value\n  call assert_equal(value, v:completed_item)\nendfunc\n\nfunc CompleteTest(findstart, query)\n  if a:findstart\n    return col('.')\n  endif\n  return ['matched']\nendfunc\n\nfunc Test_completefunc_info()\n  new\n  set completeopt=menuone\n  set completefunc=CompleteTest\n  call feedkeys(\"i\\<C-X>\\<C-U>\\<C-R>\\<C-R>=string(complete_info())\\<CR>\\<ESC>\", \"tx\")\n  call assert_equal(\"matched{'pum_visible': 1, 'mode': 'function', 'selected': 0, 'items': [{'word': 'matched', 'menu': '', 'user_data': '', 'info': '', 'kind': '', 'abbr': ''}]}\", getline(1))\n  bwipe!\n  set completeopt&\n  set completefunc&\nendfunc\n\n\" Check that when using feedkeys() typeahead does not interrupt searching for\n\" completions.\nfunc Test_compl_feedkeys()\n  new\n  set completeopt=menuone,noselect\n  call feedkeys(\"ajump ju\\<C-X>\\<C-N>\\<C-P>\\<ESC>\", \"tx\")\n  call assert_equal(\"jump jump\", getline(1))\n  bwipe!\n  set completeopt&\nendfunc\n\n\" Test for insert path completion with completeslash option\nfunc Test_ins_completeslash()\n  CheckMSWindows\n\n  call mkdir('Xcpldir')\n  let orig_shellslash = &shellslash\n  set cpt&\n  new\n\n  set noshellslash\n\n  set completeslash=\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir\\', getline('.'))\n\n  set completeslash=backslash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir\\', getline('.'))\n\n  set completeslash=slash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir/', getline('.'))\n\n  set shellslash\n\n  set completeslash=\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir/', getline('.'))\n\n  set completeslash=backslash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir\\', getline('.'))\n\n  set completeslash=slash\n  exe \"normal oXcp\\<C-X>\\<C-F>\"\n  call assert_equal('Xcpldir/', getline('.'))\n  %bw!\n  call delete('Xcpldir', 'rf')\n\n  set noshellslash\n  set completeslash=slash\n  call assert_true(stridx(globpath(&rtp, 'syntax/*.vim', 1, 1)[0], '\\') != -1)\n\n  let &shellslash = orig_shellslash\n  set completeslash=\nendfunc\n\nfunc Test_pum_stopped_by_timer()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['hello', 'hullo', 'heeee', ''])\n    func StartCompl()\n      call timer_start(100, { -> execute('stopinsert') })\n      call feedkeys(\"Gah\\<C-N>\")\n    endfunc\n  END\n\n  call writefile(lines, 'Xpumscript')\n  let buf = RunVimInTerminal('-S Xpumscript', #{rows: 12})\n  call term_sendkeys(buf, \":call StartCompl()\\<CR>\")\n  call TermWait(buf, 200)\n  call term_sendkeys(buf, \"k\")\n  call VerifyScreenDump(buf, 'Test_pum_stopped_by_timer', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xpumscript')\nendfunc\n\nfunc Test_complete_stopinsert_startinsert()\n  nnoremap <F2> <Cmd>startinsert<CR>\n  inoremap <F2> <Cmd>stopinsert<CR>\n  \" This just checks if this causes an error\n  call feedkeys(\"i\\<C-X>\\<C-N>\\<F2>\\<F2>\", 'x')\n  nunmap <F2>\n  iunmap <F2>\nendfunc\n\nfunc Test_pum_with_folds_two_tabs()\n  CheckScreendump\n\n  let lines =<< trim END\n    set fdm=marker\n    call setline(1, ['\" x {{{1', '\" a some text'])\n    call setline(3, range(&lines)->map({_, val -> '\" a' .. val}))\n    norm! zm\n    tab sp\n    call feedkeys('2Gzv', 'xt')\n    call feedkeys(\"0fa\", 'xt')\n  END\n\n  call writefile(lines, 'Xpumscript')\n  let buf = RunVimInTerminal('-S Xpumscript', #{rows: 10})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"a\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_pum_with_folds_two_tabs', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('Xpumscript')\nendfunc\n\nfunc Test_pum_with_preview_win()\n  CheckScreendump\n\n  let lines =<< trim END\n      funct Omni_test(findstart, base)\n\tif a:findstart\n\t  return col(\".\") - 1\n\tendif\n\treturn [#{word: \"one\", info: \"1info\"}, #{word: \"two\", info: \"2info\"}, #{word: \"three\", info: \"3info\"}]\n      endfunc\n      set omnifunc=Omni_test\n      set completeopt+=longest\n  END\n\n  call writefile(lines, 'Xpreviewscript')\n  let buf = RunVimInTerminal('-S Xpreviewscript', #{rows: 12})\n  call term_sendkeys(buf, \"Gi\\<C-X>\\<C-O>\")\n  call TermWait(buf, 200)\n  call term_sendkeys(buf, \"\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_pum_with_preview_win', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('Xpreviewscript')\nendfunc\n\nfunc Test_scrollbar_on_wide_char()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['a', '            \u554a\u554a\u554a',\n                        \\ '             \u54e6\u54e6\u54e6',\n                        \\ '              \u5443\u5443\u5443'])\n    call setline(5, range(10)->map({i, v -> 'aa' .. v .. 'bb'}))\n  END\n  call writefile(lines, 'Xwidescript')\n  let buf = RunVimInTerminal('-S Xwidescript', #{rows: 10})\n  call term_sendkeys(buf, \"A\\<C-N>\")\n  call VerifyScreenDump(buf, 'Test_scrollbar_on_wide_char', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xwidescript')\nendfunc\n\n\" Test for inserting the tag search pattern in insert mode\nfunc Test_ins_compl_tag_sft()\n  call writefile([\n        \\ \"!_TAG_FILE_ENCODING\\tutf-8\\t//\",\n        \\ \"first\\tXfoo\\t/^int first() {}$/\",\n        \\ \"second\\tXfoo\\t/^int second() {}$/\",\n        \\ \"third\\tXfoo\\t/^int third() {}$/\"],\n        \\ 'Xtags')\n  set tags=Xtags\n  let code =<< trim [CODE]\n    int first() {}\n    int second() {}\n    int third() {}\n  [CODE]\n  call writefile(code, 'Xfoo')\n\n  enew\n  set showfulltag\n  exe \"normal isec\\<C-X>\\<C-]>\\<C-N>\\<CR>\"\n  call assert_equal('int second() {}', getline(1))\n  set noshowfulltag\n\n  call delete('Xtags')\n  call delete('Xfoo')\n  set tags&\n  %bwipe!\nendfunc\n\n\" Test for 'completefunc' deleting text\nfunc Test_completefunc_error()\n  new\n  \" delete text when called for the first time\n  func CompleteFunc(findstart, base)\n    if a:findstart == 1\n      normal dd\n      return col('.') - 1\n    endif\n    return ['a', 'b']\n  endfunc\n  set completefunc=CompleteFunc\n  call setline(1, ['', 'abcd', ''])\n  call assert_fails('exe \"normal 2G$a\\<C-X>\\<C-U>\"', 'E565:')\n\n  \" delete text when called for the second time\n  func CompleteFunc2(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    normal dd\n    return ['a', 'b']\n  endfunc\n  set completefunc=CompleteFunc2\n  call setline(1, ['', 'abcd', ''])\n  call assert_fails('exe \"normal 2G$a\\<C-X>\\<C-U>\"', 'E565:')\n\n  \" Jump to a different window from the complete function\n  func CompleteFunc3(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    wincmd p\n    return ['a', 'b']\n  endfunc\n  set completefunc=CompleteFunc3\n  new\n  call assert_fails('exe \"normal a\\<C-X>\\<C-U>\"', 'E565:')\n  close!\n\n  set completefunc&\n  delfunc CompleteFunc\n  delfunc CompleteFunc2\n  delfunc CompleteFunc3\n  close!\nendfunc\n\n\" Test for returning non-string values from 'completefunc'\nfunc Test_completefunc_invalid_data()\n  new\n  func! CompleteFunc(findstart, base)\n    if a:findstart == 1\n      return col('.') - 1\n    endif\n    return [{}, '', 'moon']\n  endfunc\n  set completefunc=CompleteFunc\n  exe \"normal i\\<C-X>\\<C-U>\"\n  call assert_equal('moon', getline(1))\n  set completefunc&\n  close!\nendfunc\n\n\" Test for errors in using complete() function\nfunc Test_complete_func_error()\n  call assert_fails('call complete(1, [\"a\"])', 'E785:')\n  func ListColors()\n    call complete(col('.'), \"blue\")\n  endfunc\n  call assert_fails('exe \"normal i\\<C-R>=ListColors()\\<CR>\"', 'E1211:')\n  func ListMonths()\n    call complete(col('.'), test_null_list())\n  endfunc\n  call assert_fails('exe \"normal i\\<C-R>=ListMonths()\\<CR>\"', 'E1298:')\n  delfunc ListColors\n  delfunc ListMonths\n  call assert_fails('call complete_info({})', 'E1211:')\n  call assert_equal([], complete_info(['items']).items)\nendfunc\n\n\" Test for recursively starting completion mode using complete()\nfunc Test_recursive_complete_func()\n  func ListColors()\n    call complete(5, [\"red\", \"blue\"])\n    return ''\n  endfunc\n  new\n  call setline(1, ['a1', 'a2'])\n  set complete=.\n  exe \"normal Goa\\<C-X>\\<C-L>\\<C-R>=ListColors()\\<CR>\\<C-N>\"\n  call assert_equal('a2blue', getline(3))\n  delfunc ListColors\n  bw!\nendfunc\n\n\" Test for using complete() with completeopt+=longest\nfunc Test_complete_with_longest()\n  new\n  inoremap <buffer> <f3> <cmd>call complete(1, [\"iaax\", \"iaay\", \"iaaz\"])<cr>\n\n  \" default: insert first match\n  set completeopt&\n  call setline(1, ['i'])\n  exe \"normal Aa\\<f3>\\<esc>\"\n  call assert_equal('iaax', getline(1))\n\n  \" with longest: insert longest prefix\n  set completeopt+=longest\n  call setline(1, ['i'])\n  exe \"normal Aa\\<f3>\\<esc>\"\n  call assert_equal('iaa', getline(1))\n  set completeopt&\n  bwipe!\nendfunc\n\n\n\" Test for completing words following a completed word in a line\nfunc Test_complete_wrapscan()\n  \" complete words from another buffer\n  new\n  call setline(1, ['one two', 'three four'])\n  new\n  setlocal complete=w\n  call feedkeys(\"itw\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\", 'xt')\n  call assert_equal('two three four', getline(1))\n  close!\n  \" complete words from the current buffer\n  setlocal complete=.\n  %d\n  call setline(1, ['one two', ''])\n  call cursor(2, 1)\n  call feedkeys(\"ion\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\", 'xt')\n  call assert_equal('one two one two', getline(2))\n  close!\nendfunc\n\n\" Test for completing special characters\nfunc Test_complete_special_chars()\n  new\n  call setline(1, 'int .*[-\\^$ func float')\n  call feedkeys(\"oin\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\", 'xt')\n  call assert_equal('int .*[-\\^$ func float', getline(2))\n  close!\nendfunc\n\n\" Test for completion when text is wrapped across lines.\nfunc Test_complete_across_line()\n  new\n  call setline(1, ['red green blue', 'one two three'])\n  setlocal textwidth=20\n  exe \"normal 2G$a re\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(['one two three red', 'green blue one'], getline(2, '$'))\n  close!\nendfunc\n\n\" Test for completing words with a '.' at the end of a word.\nfunc Test_complete_joinspaces()\n  new\n  call setline(1, ['one two.', 'three. four'])\n  set joinspaces\n  exe \"normal Goon\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(\"one two.  three. four\", getline(3))\n  set joinspaces&\n  bw!\nendfunc\n\n\" Test for using CTRL-L to add one character when completing matching\nfunc Test_complete_add_onechar()\n  new\n  call setline(1, ['wool', 'woodwork'])\n  call feedkeys(\"Gowoo\\<C-P>\\<C-P>\\<C-P>\\<C-L>f\", 'xt')\n  call assert_equal('woof', getline(3))\n\n  \" use 'ignorecase' and backspace to erase characters from the prefix string\n  \" and then add letters using CTRL-L\n  %d\n  set ignorecase backspace=2\n  setlocal complete=.\n  call setline(1, ['workhorse', 'workload'])\n  normal Go\n  exe \"normal aWOR\\<C-P>\\<bs>\\<bs>\\<bs>\\<bs>\\<bs>\\<bs>\\<C-L>r\\<C-L>\\<C-L>\"\n  call assert_equal('workh', getline(3))\n  set ignorecase& backspace&\n  close!\nendfunc\n\n\" Test for using CTRL-X CTRL-L to complete whole lines lines\nfunc Test_complete_wholeline()\n  new\n  \" complete one-line\n  call setline(1, ['a1', 'a2'])\n  exe \"normal ggoa\\<C-X>\\<C-L>\"\n  call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))\n  \" go to the next match (wrapping around the buffer)\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\"\n  call assert_equal(['a1', 'a', 'a2'], getline(1, '$'))\n  \" go to the next match\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\\<C-N>\"\n  call assert_equal(['a1', 'a2', 'a2'], getline(1, '$'))\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\\<C-N>\\<C-N>\"\n  call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))\n  \" repeat the test using CTRL-L\n  \" go to the next match (wrapping around the buffer)\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\"\n  call assert_equal(['a1', 'a2', 'a2'], getline(1, '$'))\n  \" go to the next match\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\\<C-L>\"\n  call assert_equal(['a1', 'a', 'a2'], getline(1, '$'))\n  exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\\<C-L>\\<C-L>\"\n  call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))\n  %d\n  \" use CTRL-X CTRL-L to add one more line\n  call setline(1, ['a1', 'b1'])\n  setlocal complete=.\n  exe \"normal ggOa\\<C-X>\\<C-L>\\<C-X>\\<C-L>\\<C-X>\\<C-L>\"\n  call assert_equal(['a1', 'b1', '', 'a1', 'b1'], getline(1, '$'))\n  bw!\nendfunc\n\n\" Test insert completion with 'cindent' (adjust the indent)\nfunc Test_complete_with_cindent()\n  new\n  setlocal cindent\n  call setline(1, ['if (i == 1)', \"    j = 2;\"])\n  exe \"normal Go{\\<CR>i\\<C-X>\\<C-L>\\<C-X>\\<C-L>\\<CR>}\"\n  call assert_equal(['{', \"\\tif (i == 1)\", \"\\t\\tj = 2;\", '}'], getline(3, '$'))\n\n  %d\n  call setline(1, ['when while', '{', ''])\n  setlocal cinkeys+==while\n  exe \"normal Giwh\\<C-P> \"\n  call assert_equal(\"\\twhile \", getline('$'))\n  close!\nendfunc\n\n\" Test for <CTRL-X> <CTRL-V> completion. Complete commands and functions\nfunc Test_complete_cmdline()\n  new\n  exe \"normal icaddb\\<C-X>\\<C-V>\"\n  call assert_equal('caddbuffer', getline(1))\n  exe \"normal ocall getqf\\<C-X>\\<C-V>\"\n  call assert_equal('call getqflist(', getline(2))\n  exe \"normal oabcxyz(\\<C-X>\\<C-V>\"\n  call assert_equal('abcxyz(', getline(3))\n  com! -buffer TestCommand1 echo 'TestCommand1'\n  com! -buffer TestCommand2 echo 'TestCommand2'\n  write TestCommand1Test\n  write TestCommand2Test\n  \" Test repeating <CTRL-X> <CTRL-V> and switching to another CTRL-X mode\n  exe \"normal oT\\<C-X>\\<C-V>\\<C-X>\\<C-V>\\<C-X>\\<C-F>\\<Esc>\"\n  call assert_equal('TestCommand2Test', getline(4))\n  call delete('TestCommand1Test')\n  call delete('TestCommand2Test')\n  delcom TestCommand1\n  delcom TestCommand2\n  close!\nendfunc\n\n\" Test for <CTRL-X> <CTRL-Z> stopping completion without changing the match\nfunc Test_complete_stop()\n  new\n  func Save_mode1()\n    let g:mode1 = mode(1)\n    return ''\n  endfunc\n  func Save_mode2()\n    let g:mode2 = mode(1)\n    return ''\n  endfunc\n  inoremap <F1> <C-R>=Save_mode1()<CR>\n  inoremap <F2> <C-R>=Save_mode2()<CR>\n  call setline(1, ['aaa bbb ccc '])\n  exe \"normal A\\<C-N>\\<C-P>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc ', getline(1))\n  exe \"normal A\\<C-N>\\<Down>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc aaa', getline(1))\n  set completeopt+=noselect\n  exe \"normal A \\<C-N>\\<Down>\\<Down>\\<C-L>\\<C-L>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc aaa bb', getline(1))\n  set completeopt&\n  exe \"normal A d\\<C-N>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('aaa bbb ccc aaa bb d', getline(1))\n  com! -buffer TestCommand1 echo 'TestCommand1'\n  com! -buffer TestCommand2 echo 'TestCommand2'\n  exe \"normal oT\\<C-X>\\<C-V>\\<C-X>\\<C-V>\\<F1>\\<C-X>\\<C-Z>\\<F2>\\<Esc>\"\n  call assert_equal('ic', g:mode1)\n  call assert_equal('i', g:mode2)\n  call assert_equal('TestCommand2', getline(2))\n  delcom TestCommand1\n  delcom TestCommand2\n  unlet g:mode1\n  unlet g:mode2\n  iunmap <F1>\n  iunmap <F2>\n  delfunc Save_mode1\n  delfunc Save_mode2\n  close!\nendfunc\n\n\" Test for typing CTRL-R in insert completion mode to insert a register\n\" content.\nfunc Test_complete_reginsert()\n  new\n  call setline(1, ['a1', 'a12', 'a123', 'a1234'])\n\n  \" if a valid CTRL-X mode key is returned from <C-R>=, then it should be\n  \" processed. Otherwise, CTRL-X mode should be stopped and the key should be\n  \" inserted.\n  exe \"normal Goa\\<C-P>\\<C-R>=\\\"\\\\<C-P>\\\"\\<CR>\"\n  call assert_equal('a123', getline(5))\n  let @r = \"\\<C-P>\\<C-P>\"\n  exe \"normal GCa\\<C-P>\\<C-R>r\"\n  call assert_equal('a12', getline(5))\n  exe \"normal GCa\\<C-P>\\<C-R>=\\\"x\\\"\\<CR>\"\n  call assert_equal('a1234x', getline(5))\n  bw!\nendfunc\n\nfunc Test_issue_7021()\n  CheckMSWindows\n\n  let orig_shellslash = &shellslash\n  set noshellslash\n\n  set completeslash=slash\n  call assert_false(expand('~') =~ '/')\n\n  let &shellslash = orig_shellslash\n  set completeslash=\nendfunc\n\n\" Test for 'longest' setting in 'completeopt' with latin1 and utf-8 encodings\nfunc Test_complete_longest_match()\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n    new\n    set complete=.\n    set completeopt=menu,longest\n    call setline(1, ['pfx_a1', 'pfx_a12', 'pfx_a123', 'pfx_b1'])\n    exe \"normal Gopfx\\<C-P>\"\n    call assert_equal('pfx_', getline(5))\n    bw!\n  endfor\n\n  \" Test for completing additional words with longest match set\n  new\n  call setline(1, ['abc1', 'abd2'])\n  exe \"normal Goab\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal('ab', getline(3))\n  bw!\n  set complete& completeopt&\nendfunc\n\n\" Test for removing the first displayed completion match and selecting the\n\" match just before that.\nfunc Test_complete_erase_firstmatch()\n  new\n  call setline(1, ['a12', 'a34', 'a56'])\n  set complete=.\n  exe \"normal Goa\\<C-P>\\<BS>\\<BS>3\\<CR>\"\n  call assert_equal('a34', getline('$'))\n  set complete&\n  bw!\nendfunc\n\n\" Test for completing words from unloaded buffers\nfunc Test_complete_from_unloadedbuf()\n  call writefile(['abc'], \"Xfile1\")\n  call writefile(['def'], \"Xfile2\")\n  edit Xfile1\n  edit Xfile2\n  new | close\n  enew\n  bunload Xfile1 Xfile2\n  set complete=u\n  \" complete from an unloaded buffer\n  exe \"normal! ia\\<C-P>\"\n  call assert_equal('abc', getline(1))\n  exe \"normal! od\\<C-P>\"\n  call assert_equal('def', getline(2))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\n  call delete(\"Xfile2\")\nendfunc\n\n\" Test for completing whole lines from unloaded buffers\nfunc Test_complete_wholeline_unloadedbuf()\n  call writefile(['a line1', 'a line2', 'a line3'], \"Xfile1\")\n  edit Xfile1\n  enew\n  set complete=u\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a line2', getline(1))\n  %d\n  \" completing from an unlisted buffer should fail\n  bdel Xfile1\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a', getline(1))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\nendfunc\n\n\" Test for completing words from unlisted buffers\nfunc Test_complete_from_unlistedbuf()\n  call writefile(['abc'], \"Xfile1\")\n  call writefile(['def'], \"Xfile2\")\n  edit Xfile1\n  edit Xfile2\n  new | close\n  bdel Xfile1 Xfile2\n  set complete=U\n  \" complete from an unlisted buffer\n  exe \"normal! ia\\<C-P>\"\n  call assert_equal('abc', getline(1))\n  exe \"normal! od\\<C-P>\"\n  call assert_equal('def', getline(2))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\n  call delete(\"Xfile2\")\nendfunc\n\n\" Test for completing whole lines from unlisted buffers\nfunc Test_complete_wholeline_unlistedbuf()\n  call writefile(['a line1', 'a line2', 'a line3'], \"Xfile1\")\n  edit Xfile1\n  enew\n  set complete=U\n  \" completing from a unloaded buffer should fail\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a', getline(1))\n  %d\n  bdel Xfile1\n  exe \"normal! ia\\<C-X>\\<C-L>\\<C-P>\"\n  call assert_equal('a line2', getline(1))\n  set complete&\n  %bw!\n  call delete(\"Xfile1\")\nendfunc\n\n\" Test for adding a multibyte character using CTRL-L in completion mode\nfunc Test_complete_mbyte_char_add()\n  new\n  set complete=.\n  call setline(1, 'ab\u0117')\n  exe \"normal! oa\\<C-P>\\<BS>\\<BS>\\<C-L>\\<C-L>\"\n  call assert_equal('ab\u0117', getline(2))\n  \" Test for a leader with multibyte character\n  %d\n  call setline(1, 'ab\u0117\u0115')\n  exe \"normal! oab\u0117\\<C-P>\"\n  call assert_equal('ab\u0117\u0115', getline(2))\n  bw!\nendfunc\n\n\" Test for using <C-X><C-P> for local expansion even if 'complete' is set to\n\" not to complete matches from the local buffer. Also test using multiple\n\" <C-X> to cancel the current completion mode.\nfunc Test_complete_local_expansion()\n  new\n  set complete=t\n  call setline(1, ['abc', 'def'])\n  exe \"normal! Go\\<C-X>\\<C-P>\"\n  call assert_equal(\"def\", getline(3))\n  exe \"normal! Go\\<C-P>\"\n  call assert_equal(\"\", getline(4))\n  exe \"normal! Go\\<C-X>\\<C-N>\"\n  call assert_equal(\"abc\", getline(5))\n  exe \"normal! Go\\<C-N>\"\n  call assert_equal(\"\", getline(6))\n\n  \" use multiple <C-X> to cancel the previous completion mode\n  exe \"normal! Go\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(\"\", getline(7))\n  exe \"normal! Go\\<C-P>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal(\"\", getline(8))\n  exe \"normal! Go\\<C-P>\\<C-X>\\<C-X>\\<C-X>\\<C-P>\"\n  call assert_equal(\"abc\", getline(9))\n\n  \" interrupt the current completion mode\n  set completeopt=menu,noinsert\n  exe \"normal! Go\\<C-X>\\<C-F>\\<C-X>\\<C-X>\\<C-P>\\<C-Y>\"\n  call assert_equal(\"abc\", getline(10))\n\n  \" when only one <C-X> is used to interrupt, do normal expansion\n  exe \"normal! Go\\<C-X>\\<C-F>\\<C-X>\\<C-P>\"\n  call assert_equal(\"\", getline(11))\n  set completeopt&\n\n  \" using two <C-X> in non-completion mode and restarting the same mode\n  exe \"normal! God\\<C-X>\\<C-X>\\<C-P>\\<C-X>\\<C-X>\\<C-P>\\<C-Y>\"\n  call assert_equal(\"def\", getline(12))\n\n  \" test for adding a match from the original empty text\n  %d\n  call setline(1, 'abc def g')\n  exe \"normal! o\\<C-X>\\<C-P>\\<C-N>\\<C-X>\\<C-P>\"\n  call assert_equal('def', getline(2))\n  exe \"normal! 0C\\<C-X>\\<C-N>\\<C-P>\\<C-X>\\<C-N>\"\n  call assert_equal('abc', getline(2))\n\n  bw!\nendfunc\n\n\" Test for undoing changes after a insert-mode completion\nfunc Test_complete_undo()\n  new\n  set complete=.\n  \" undo with 'ignorecase'\n  call setline(1, ['ABOVE', 'BELOW'])\n  set ignorecase\n  exe \"normal! Goab\\<C-G>u\\<C-P>\"\n  call assert_equal(\"ABOVE\", getline(3))\n  undo\n  call assert_equal(\"ab\", getline(3))\n  set ignorecase&\n  %d\n  \" undo with longest match\n  set completeopt=menu,longest\n  call setline(1, ['above', 'about'])\n  exe \"normal! Goa\\<C-G>u\\<C-P>\"\n  call assert_equal(\"abo\", getline(3))\n  undo\n  call assert_equal(\"a\", getline(3))\n  set completeopt&\n  %d\n  \" undo for line completion\n  call setline(1, ['above that change', 'below that change'])\n  exe \"normal! Goabove\\<C-G>u\\<C-X>\\<C-L>\"\n  call assert_equal(\"above that change\", getline(3))\n  undo\n  call assert_equal(\"above\", getline(3))\n\n  bw!\nendfunc\n\n\" Test for completing a very long word\nfunc Test_complete_long_word()\n  set complete&\n  new\n  call setline(1, repeat('x', 950) .. ' one two three')\n  exe \"normal! Gox\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(repeat('x', 950) .. ' one two three', getline(2))\n  %d\n  \" should fail when more than 950 characters are in a word\n  call setline(1, repeat('x', 951) .. ' one two three')\n  exe \"normal! Gox\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal(repeat('x', 951), getline(2))\n\n  \" Test for adding a very long word to an existing completion\n  %d\n  call setline(1, ['abc', repeat('x', 1016) .. '012345'])\n  exe \"normal! Goab\\<C-P>\\<C-X>\\<C-P>\"\n  call assert_equal('abc ' .. repeat('x', 1016) .. '0123', getline(3))\n  bw!\nendfunc\n\n\" Test for some fields in the complete items used by complete()\nfunc Test_complete_items()\n  func CompleteItems(idx)\n    let items = [[#{word: \"one\", dup: 1, user_data: 'u1'}, #{word: \"one\", dup: 1, user_data: 'u2'}],\n          \\ [#{word: \"one\", dup: 0, user_data: 'u3'}, #{word: \"one\", dup: 0, user_data: 'u4'}],\n          \\ [#{word: \"one\", icase: 1, user_data: 'u7'}, #{word: \"oNE\", icase: 1, user_data: 'u8'}],\n          \\ [#{user_data: 'u9'}],\n          \\ [#{word: \"\", user_data: 'u10'}],\n          \\ [#{word: \"\", empty: 1, user_data: 'u11'}]]\n    call complete(col('.'), items[a:idx])\n    return ''\n  endfunc\n  new\n  exe \"normal! i\\<C-R>=CompleteItems(0)\\<CR>\\<C-N>\\<C-Y>\"\n  call assert_equal('u2', v:completed_item.user_data)\n  call assert_equal('one', getline(1))\n  exe \"normal! o\\<C-R>=CompleteItems(1)\\<CR>\\<C-Y>\"\n  call assert_equal('u3', v:completed_item.user_data)\n  call assert_equal('one', getline(2))\n  exe \"normal! o\\<C-R>=CompleteItems(1)\\<CR>\\<C-N>\"\n  call assert_equal('', getline(3))\n  set completeopt=menu,noinsert\n  exe \"normal! o\\<C-R>=CompleteItems(2)\\<CR>one\\<C-N>\\<C-Y>\"\n  call assert_equal('oNE', getline(4))\n  call assert_equal('u8', v:completed_item.user_data)\n  set completeopt&\n  exe \"normal! o\\<C-R>=CompleteItems(3)\\<CR>\"\n  call assert_equal('', getline(5))\n  exe \"normal! o\\<C-R>=CompleteItems(4)\\<CR>\"\n  call assert_equal('', getline(6))\n  exe \"normal! o\\<C-R>=CompleteItems(5)\\<CR>\"\n  call assert_equal('', getline(7))\n  call assert_equal('u11', v:completed_item.user_data)\n  \" pass invalid argument to complete()\n  let cmd = \"normal! o\\<C-R>=complete(1, [[]])\\<CR>\"\n  call assert_fails('exe cmd', 'E730:')\n  bw!\n  delfunc CompleteItems\nendfunc\n\n\" Test for the \"refresh\" item in the dict returned by an insert completion\n\" function\nfunc Test_complete_item_refresh_always()\n  let g:CallCount = 0\n  func! Tcomplete(findstart, base)\n    if a:findstart\n      \" locate the start of the word\n      let line = getline('.')\n      let start = col('.') - 1\n      while start > 0 && line[start - 1] =~ '\\a'\n        let start -= 1\n      endwhile\n      return start\n    else\n      let g:CallCount += 1\n      let res = [\"update1\", \"update12\", \"update123\"]\n      return #{words: res, refresh: 'always'}\n    endif\n  endfunc\n  new\n  set completeopt=menu,longest\n  set completefunc=Tcomplete\n  exe \"normal! iup\\<C-X>\\<C-U>\\<BS>\\<BS>\\<BS>\\<BS>\\<BS>\"\n  call assert_equal('up', getline(1))\n  call assert_equal(2, g:CallCount)\n  set completeopt&\n  set completefunc&\n  bw!\n  delfunc Tcomplete\nendfunc\n\n\" Test for completing from a thesaurus file without read permission\nfunc Test_complete_unreadable_thesaurus_file()\n  CheckUnix\n  CheckNotRoot\n\n  call writefile(['about', 'above'], 'Xunrfile')\n  call setfperm('Xunrfile', '---r--r--')\n  new\n  set complete=sXfile\n  exe \"normal! ia\\<C-P>\"\n  call assert_equal('a', getline(1))\n  bw!\n  call delete('Xunrfile')\n  set complete&\nendfunc\n\n\" Test to ensure 'Scanning...' messages are not recorded in messages history\nfunc Test_z1_complete_no_history()\n  new\n  messages clear\n  let currmess = execute('messages')\n  setlocal dictionary=README.txt\n  exe \"normal owh\\<C-X>\\<C-K>\"\n  exe \"normal owh\\<C-N>\"\n  call assert_equal(currmess, execute('messages'))\n  bwipe!\nendfunc\n\n\" A mapping is not used for the key after CTRL-X.\nfunc Test_no_mapping_for_ctrl_x_key()\n  new\n  inoremap <buffer> <C-K> <Cmd>let was_mapped = 'yes'<CR>\n  setlocal dictionary=README.txt\n  call feedkeys(\"aexam\\<C-X>\\<C-K> \", 'xt')\n  call assert_equal('example ', getline(1))\n  call assert_false(exists('was_mapped'))\n  bwipe!\nendfunc\n\n\" Test for different ways of setting the 'completefunc' option\nfunc Test_completefunc_callback()\n  func CompleteFunc1(callnr, findstart, base)\n    call add(g:CompleteFunc1Args, [a:callnr, a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  func CompleteFunc2(findstart, base)\n    call add(g:CompleteFunc2Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a global function name\n    LET &completefunc = 'g:CompleteFunc2'\n    new\n    call setline(1, 'global')\n    LET g:CompleteFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'global']], g:CompleteFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set completefunc=function('g:CompleteFunc1',\\ [10])\n    new\n    call setline(1, 'one')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[10, 1, ''], [10, 0, 'one']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'completefunc'\n    VAR Fn = function('g:CompleteFunc1', [11])\n    LET &completefunc = Fn\n    new\n    call setline(1, 'two')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[11, 1, ''], [11, 0, 'two']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using string(funcref_variable) to set 'completefunc'\n    LET Fn = function('g:CompleteFunc1', [12])\n    LET &completefunc = string(Fn)\n    new\n    call setline(1, 'two')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[12, 1, ''], [12, 0, 'two']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set completefunc=funcref('g:CompleteFunc1',\\ [13])\n    new\n    call setline(1, 'three')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[13, 1, ''], [13, 0, 'three']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'completefunc'\n    LET Fn = funcref('g:CompleteFunc1', [14])\n    LET &completefunc = Fn\n    new\n    call setline(1, 'four')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[14, 1, ''], [14, 0, 'four']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'completefunc'\n    LET Fn = funcref('g:CompleteFunc1', [15])\n    LET &completefunc = string(Fn)\n    new\n    call setline(1, 'four')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[15, 1, ''], [15, 0, 'four']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a, b LMIDDLE g:CompleteFunc1(16, a, b) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set completefunc=\" .. optval\n    new\n    call setline(1, 'five')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[16, 1, ''], [16, 0, 'five']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to a lambda expression\n    LET &completefunc = LSTART a, b LMIDDLE g:CompleteFunc1(17, a, b) LEND\n    new\n    call setline(1, 'six')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[17, 1, ''], [17, 0, 'six']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to string(lambda_expression)\n    LET &completefunc = 'LSTART a, b LMIDDLE g:CompleteFunc1(18, a, b) LEND'\n    new\n    call setline(1, 'six')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[18, 1, ''], [18, 0, 'six']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b LMIDDLE g:CompleteFunc1(19, a, b) LEND\n    LET &completefunc = Lambda\n    new\n    call setline(1, 'seven')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[19, 1, ''], [19, 0, 'seven']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Set 'completefunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b LMIDDLE g:CompleteFunc1(20, a, b) LEND\n    LET &completefunc = string(Lambda)\n    new\n    call setline(1, 'seven')\n    LET g:CompleteFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[20, 1, ''], [20, 0, 'seven']], g:CompleteFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b LMIDDLE strlen(a) LEND\n    LET &completefunc = Lambda\n    new\n    call setline(1, 'eight')\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    bw!\n\n    #\" Test for clearing the 'completefunc' option\n    set completefunc=''\n    set completefunc&\n    call assert_fails(\"set completefunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set completefunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'completefunc' to a non-existing function\n    set completefunc=g:CompleteFunc2\n    call setline(1, 'five')\n    call assert_fails(\"set completefunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &completefunc = function('NonExistingFunc')\", 'E700:')\n    LET g:CompleteFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'five']], g:CompleteFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:CompleteFunc3(findstart, base)\n    call add(g:CompleteFunc3Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  set completefunc=s:CompleteFunc3\n  new\n  call setline(1, 'script1')\n  let g:CompleteFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script1']], g:CompleteFunc3Args)\n  bw!\n\n  let &completefunc = 's:CompleteFunc3'\n  new\n  call setline(1, 'script2')\n  let g:CompleteFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script2']], g:CompleteFunc3Args)\n  bw!\n  delfunc s:CompleteFunc3\n\n  \" In Vim9 script s: can be omitted\n  let lines =<< trim END\n      vim9script\n      var CompleteFunc4Args = []\n      def CompleteFunc4(findstart: bool, base: string): any\n        add(CompleteFunc4Args, [findstart, base])\n        return findstart ? 0 : []\n      enddef\n      set completefunc=CompleteFunc4\n      new\n      setline(1, 'script1')\n      feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n      assert_equal([[1, ''], [0, 'script1']], CompleteFunc4Args)\n      bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" invalid return value\n  let &completefunc = {a -> 'abc'}\n  call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set completefunc=(a,\\ b)\\ =>\\ g:CompleteFunc1(21,\\ a,\\ b)\n  new | only\n  let g:CompleteFunc1Args = []\n  call assert_fails('call feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", \"x\")', 'E117:')\n  call assert_equal([], g:CompleteFunc1Args)\n\n  \" set 'completefunc' to a partial with dict. This used to cause a crash.\n  func SetCompleteFunc()\n    let params = {'complete': function('g:DictCompleteFunc')}\n    let &completefunc = params.complete\n  endfunc\n  func g:DictCompleteFunc(_) dict\n  endfunc\n  call SetCompleteFunc()\n  new\n  call SetCompleteFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set completefunc=\n  wincmd w\n  set completefunc=\n  %bw!\n  delfunc g:DictCompleteFunc\n  delfunc SetCompleteFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9CompleteFunc(callnr: number, findstart: number, base: string): any\n      add(g:Vim9completeFuncArgs, [callnr, findstart, base])\n      return findstart ? 0 : []\n    enddef\n\n    # Test for using a def function with completefunc\n    set completefunc=function('Vim9CompleteFunc',\\ [60])\n    new | only\n    setline(1, 'one')\n    g:Vim9completeFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    assert_equal([[60, 1, ''], [60, 0, 'one']], g:Vim9completeFuncArgs)\n    bw!\n\n    # Test for using a global function name\n    &completefunc = g:CompleteFunc2\n    new | only\n    setline(1, 'two')\n    g:CompleteFunc2Args = []\n    feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'two']], g:CompleteFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalCompleteFunc(findstart: number, base: string): any\n      add(g:LocalCompleteFuncArgs, [findstart, base])\n      return findstart ? 0 : []\n    enddef\n    &completefunc = LocalCompleteFunc\n    new | only\n    setline(1, 'three')\n    g:LocalCompleteFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-U>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'three']], g:LocalCompleteFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  set completefunc&\n  delfunc CompleteFunc1\n  delfunc CompleteFunc2\n  unlet g:CompleteFunc1Args g:CompleteFunc2Args\n  %bw!\nendfunc\n\n\" Test for different ways of setting the 'omnifunc' option\nfunc Test_omnifunc_callback()\n  func OmniFunc1(callnr, findstart, base)\n    call add(g:OmniFunc1Args, [a:callnr, a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  func OmniFunc2(findstart, base)\n    call add(g:OmniFunc2Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &omnifunc = 'g:OmniFunc2'\n    new\n    call setline(1, 'zero')\n    LET g:OmniFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'zero']], g:OmniFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set omnifunc=function('g:OmniFunc1',\\ [10])\n    new\n    call setline(1, 'one')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[10, 1, ''], [10, 0, 'one']], g:OmniFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'omnifunc'\n    VAR Fn = function('g:OmniFunc1', [11])\n    LET &omnifunc = Fn\n    new\n    call setline(1, 'two')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[11, 1, ''], [11, 0, 'two']], g:OmniFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'omnifunc'\n    LET Fn = function('g:OmniFunc1', [12])\n    LET &omnifunc = string(Fn)\n    new\n    call setline(1, 'two')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[12, 1, ''], [12, 0, 'two']], g:OmniFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set omnifunc=funcref('g:OmniFunc1',\\ [13])\n    new\n    call setline(1, 'three')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[13, 1, ''], [13, 0, 'three']], g:OmniFunc1Args)\n    bw!\n\n    #\" Use let to set 'omnifunc' to a funcref\n    LET Fn = funcref('g:OmniFunc1', [14])\n    LET &omnifunc = Fn\n    new\n    call setline(1, 'four')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[14, 1, ''], [14, 0, 'four']], g:OmniFunc1Args)\n    bw!\n\n    #\" Using a string(funcref) to set 'omnifunc'\n    LET Fn = funcref(\"g:OmniFunc1\", [15])\n    LET &omnifunc = string(Fn)\n    new\n    call setline(1, 'four')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[15, 1, ''], [15, 0, 'four']], g:OmniFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with set\n    VAR optval = \"LSTART a, b LMIDDLE g:OmniFunc1(16, a, b) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set omnifunc=\" .. optval\n    new\n    call setline(1, 'five')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[16, 1, ''], [16, 0, 'five']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a lambda expression\n    LET &omnifunc = LSTART a, b LMIDDLE g:OmniFunc1(17, a, b) LEND\n    new\n    call setline(1, 'six')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[17, 1, ''], [17, 0, 'six']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a string(lambda_expression)\n    LET &omnifunc = 'LSTART a, b LMIDDLE g:OmniFunc1(18, a, b) LEND'\n    new\n    call setline(1, 'six')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[18, 1, ''], [18, 0, 'six']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b LMIDDLE g:OmniFunc1(19, a, b) LEND\n    LET &omnifunc = Lambda\n    new\n    call setline(1, 'seven')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[19, 1, ''], [19, 0, 'seven']], g:OmniFunc1Args)\n    bw!\n\n    #\" Set 'omnifunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b LMIDDLE g:OmniFunc1(20, a, b) LEND\n    LET &omnifunc = string(Lambda)\n    new\n    call setline(1, 'seven')\n    LET g:OmniFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[20, 1, ''], [20, 0, 'seven']], g:OmniFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b LMIDDLE strlen(a) LEND\n    LET &omnifunc = Lambda\n    new\n    call setline(1, 'eight')\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    bw!\n\n    #\" Test for clearing the 'omnifunc' option\n    set omnifunc=''\n    set omnifunc&\n    call assert_fails(\"set omnifunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set omnifunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'omnifunc' to a non-existing function\n    set omnifunc=g:OmniFunc2\n    call setline(1, 'nine')\n    call assert_fails(\"set omnifunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &omnifunc = function('NonExistingFunc')\", 'E700:')\n    LET g:OmniFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'nine']], g:OmniFunc2Args)\n    bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:OmniFunc3(findstart, base)\n    call add(g:OmniFunc3Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  set omnifunc=s:OmniFunc3\n  new\n  call setline(1, 'script1')\n  let g:OmniFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script1']], g:OmniFunc3Args)\n  bw!\n\n  let &omnifunc = 's:OmniFunc3'\n  new\n  call setline(1, 'script2')\n  let g:OmniFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script2']], g:OmniFunc3Args)\n  bw!\n  delfunc s:OmniFunc3\n\n  \" invalid return value\n  let &omnifunc = {a -> 'abc'}\n  call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set omnifunc=(a,\\ b)\\ =>\\ OmniFunc1(21,\\ a,\\ b)\n  new | only\n  let g:OmniFunc1Args = []\n  call assert_fails('call feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", \"x\")', 'E117:')\n  call assert_equal([], g:OmniFunc1Args)\n\n  \" set 'omnifunc' to a partial with dict. This used to cause a crash.\n  func SetOmniFunc()\n    let params = {'omni': function('g:DictOmniFunc')}\n    let &omnifunc = params.omni\n  endfunc\n  func g:DictOmniFunc(_) dict\n  endfunc\n  call SetOmniFunc()\n  new\n  call SetOmniFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set omnifunc=\n  wincmd w\n  set omnifunc=\n  %bw!\n  delfunc g:DictOmniFunc\n  delfunc SetOmniFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9omniFunc(callnr: number, findstart: number, base: string): any\n      add(g:Vim9omniFunc_Args, [callnr, findstart, base])\n      return findstart ? 0 : []\n    enddef\n\n    # Test for using a def function with omnifunc\n    set omnifunc=function('Vim9omniFunc',\\ [60])\n    new | only\n    setline(1, 'one')\n    g:Vim9omniFunc_Args = []\n    feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    assert_equal([[60, 1, ''], [60, 0, 'one']], g:Vim9omniFunc_Args)\n    bw!\n\n    # Test for using a global function name\n    &omnifunc = g:OmniFunc2\n    new | only\n    setline(1, 'two')\n    g:OmniFunc2Args = []\n    feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'two']], g:OmniFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalOmniFunc(findstart: number, base: string): any\n      add(g:LocalOmniFuncArgs, [findstart, base])\n      return findstart ? 0 : []\n    enddef\n    &omnifunc = LocalOmniFunc\n    new | only\n    setline(1, 'three')\n    g:LocalOmniFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-O>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'three']], g:LocalOmniFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  set omnifunc&\n  delfunc OmniFunc1\n  delfunc OmniFunc2\n  unlet g:OmniFunc1Args g:OmniFunc2Args\n  %bw!\nendfunc\n\n\" Test for different ways of setting the 'thesaurusfunc' option\nfunc Test_thesaurusfunc_callback()\n  func TsrFunc1(callnr, findstart, base)\n    call add(g:TsrFunc1Args, [a:callnr, a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  func TsrFunc2(findstart, base)\n    call add(g:TsrFunc2Args, [a:findstart, a:base])\n    return a:findstart ? 0 : ['sunday']\n  endfunc\n\n  let lines =<< trim END\n    #\" Test for using a function name\n    LET &thesaurusfunc = 'g:TsrFunc2'\n    new\n    call setline(1, 'zero')\n    LET g:TsrFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'zero']], g:TsrFunc2Args)\n    bw!\n\n    #\" Test for using a function()\n    set thesaurusfunc=function('g:TsrFunc1',\\ [10])\n    new\n    call setline(1, 'one')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[10, 1, ''], [10, 0, 'one']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'thesaurusfunc'\n    VAR Fn = function('g:TsrFunc1', [11])\n    LET &thesaurusfunc = Fn\n    new\n    call setline(1, 'two')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[11, 1, ''], [11, 0, 'two']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'thesaurusfunc'\n    LET Fn = function('g:TsrFunc1', [12])\n    LET &thesaurusfunc = string(Fn)\n    new\n    call setline(1, 'two')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[12, 1, ''], [12, 0, 'two']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a funcref()\n    set thesaurusfunc=funcref('g:TsrFunc1',\\ [13])\n    new\n    call setline(1, 'three')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[13, 1, ''], [13, 0, 'three']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a funcref variable to set 'thesaurusfunc'\n    LET Fn = funcref('g:TsrFunc1', [14])\n    LET &thesaurusfunc = Fn\n    new\n    call setline(1, 'four')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[14, 1, ''], [14, 0, 'four']], g:TsrFunc1Args)\n    bw!\n\n    #\" Using a string(funcref_variable) to set 'thesaurusfunc'\n    LET Fn = funcref('g:TsrFunc1', [15])\n    LET &thesaurusfunc = string(Fn)\n    new\n    call setline(1, 'four')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[15, 1, ''], [15, 0, 'four']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function\n    VAR optval = \"LSTART a, b LMIDDLE g:TsrFunc1(16, a, b) LEND\"\n    LET optval = substitute(optval, ' ', '\\\\ ', 'g')\n    exe \"set thesaurusfunc=\" .. optval\n    new\n    call setline(1, 'five')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[16, 1, ''], [16, 0, 'five']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with set\n    LET &thesaurusfunc = LSTART a, b LMIDDLE g:TsrFunc1(17, a, b) LEND\n    new\n    call setline(1, 'six')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[17, 1, ''], [17, 0, 'six']], g:TsrFunc1Args)\n    bw!\n\n    #\" Set 'thesaurusfunc' to a string(lambda expression)\n    LET &thesaurusfunc = 'LSTART a, b LMIDDLE g:TsrFunc1(18, a, b) LEND'\n    new\n    call setline(1, 'six')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[18, 1, ''], [18, 0, 'six']], g:TsrFunc1Args)\n    bw!\n\n    #\" Set 'thesaurusfunc' to a variable with a lambda expression\n    VAR Lambda = LSTART a, b LMIDDLE g:TsrFunc1(19, a, b) LEND\n    LET &thesaurusfunc = Lambda\n    new\n    call setline(1, 'seven')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[19, 1, ''], [19, 0, 'seven']], g:TsrFunc1Args)\n    bw!\n\n    #\" Set 'thesaurusfunc' to a string(variable with a lambda expression)\n    LET Lambda = LSTART a, b LMIDDLE g:TsrFunc1(20, a, b) LEND\n    LET &thesaurusfunc = string(Lambda)\n    new\n    call setline(1, 'seven')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[20, 1, ''], [20, 0, 'seven']], g:TsrFunc1Args)\n    bw!\n\n    #\" Test for using a lambda function with incorrect return value\n    LET Lambda = LSTART a, b LMIDDLE strlen(a) LEND\n    LET &thesaurusfunc = Lambda\n    new\n    call setline(1, 'eight')\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    bw!\n\n    #\" Test for clearing the 'thesaurusfunc' option\n    set thesaurusfunc=''\n    set thesaurusfunc&\n    call assert_fails(\"set thesaurusfunc=function('abc')\", \"E700:\")\n    call assert_fails(\"set thesaurusfunc=funcref('abc')\", \"E700:\")\n\n    #\" set 'thesaurusfunc' to a non-existing function\n    set thesaurusfunc=g:TsrFunc2\n    call setline(1, 'ten')\n    call assert_fails(\"set thesaurusfunc=function('NonExistingFunc')\", 'E700:')\n    call assert_fails(\"LET &thesaurusfunc = function('NonExistingFunc')\", 'E700:')\n    LET g:TsrFunc2Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    call assert_equal([[1, ''], [0, 'ten']], g:TsrFunc2Args)\n    bw!\n\n    #\" Use a buffer-local value and a global value\n    set thesaurusfunc&\n    setlocal thesaurusfunc=function('g:TsrFunc1',\\ [22])\n    call setline(1, 'sun')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")\n    call assert_equal('sun', getline(1))\n    call assert_equal([[22, 1, ''], [22, 0, 'sun']], g:TsrFunc1Args)\n    new\n    call setline(1, 'sun')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")\n    call assert_equal('sun', getline(1))\n    call assert_equal([], g:TsrFunc1Args)\n    set thesaurusfunc=function('g:TsrFunc1',\\ [23])\n    wincmd w\n    call setline(1, 'sun')\n    LET g:TsrFunc1Args = []\n    call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")\n    call assert_equal('sun', getline(1))\n    call assert_equal([[22, 1, ''], [22, 0, 'sun']], g:TsrFunc1Args)\n    :%bw!\n  END\n  call v9.CheckLegacyAndVim9Success(lines)\n\n  \" Test for using a script-local function name\n  func s:TsrFunc3(findstart, base)\n    call add(g:TsrFunc3Args, [a:findstart, a:base])\n    return a:findstart ? 0 : []\n  endfunc\n  set tsrfu=s:TsrFunc3\n  new\n  call setline(1, 'script1')\n  let g:TsrFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script1']], g:TsrFunc3Args)\n  bw!\n\n  let &tsrfu = 's:TsrFunc3'\n  new\n  call setline(1, 'script2')\n  let g:TsrFunc3Args = []\n  call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n  call assert_equal([[1, ''], [0, 'script2']], g:TsrFunc3Args)\n  bw!\n  delfunc s:TsrFunc3\n\n  \" invalid return value\n  let &thesaurusfunc = {a -> 'abc'}\n  call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n\n  \" Using Vim9 lambda expression in legacy context should fail\n  set thesaurusfunc=(a,\\ b)\\ =>\\ TsrFunc1(21,\\ a,\\ b)\n  new | only\n  let g:TsrFunc1Args = []\n  call assert_fails('call feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", \"x\")', 'E117:')\n  call assert_equal([], g:TsrFunc1Args)\n  bw!\n\n  \" set 'thesaurusfunc' to a partial with dict. This used to cause a crash.\n  func SetTsrFunc()\n    let params = {'thesaurus': function('g:DictTsrFunc')}\n    let &thesaurusfunc = params.thesaurus\n  endfunc\n  func g:DictTsrFunc(_) dict\n  endfunc\n  call SetTsrFunc()\n  new\n  call SetTsrFunc()\n  bw\n  call test_garbagecollect_now()\n  new\n  set thesaurusfunc=\n  wincmd w\n  %bw!\n  delfunc SetTsrFunc\n\n  \" set buffer-local 'thesaurusfunc' to a partial with dict. This used to\n  \" cause a crash.\n  func SetLocalTsrFunc()\n    let params = {'thesaurus': function('g:DictTsrFunc')}\n    let &l:thesaurusfunc = params.thesaurus\n  endfunc\n  call SetLocalTsrFunc()\n  call test_garbagecollect_now()\n  call SetLocalTsrFunc()\n  set thesaurusfunc=\n  bw!\n  delfunc g:DictTsrFunc\n  delfunc SetLocalTsrFunc\n\n  \" Vim9 tests\n  let lines =<< trim END\n    vim9script\n\n    def Vim9tsrFunc(callnr: number, findstart: number, base: string): any\n      add(g:Vim9tsrFunc_Args, [callnr, findstart, base])\n      return findstart ? 0 : []\n    enddef\n\n    # Test for using a def function with thesaurusfunc\n    set thesaurusfunc=function('Vim9tsrFunc',\\ [60])\n    new | only\n    setline(1, 'one')\n    g:Vim9tsrFunc_Args = []\n    feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    assert_equal([[60, 1, ''], [60, 0, 'one']], g:Vim9tsrFunc_Args)\n    bw!\n\n    # Test for using a global function name\n    &thesaurusfunc = g:TsrFunc2\n    new | only\n    setline(1, 'two')\n    g:TsrFunc2Args = []\n    feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'two']], g:TsrFunc2Args)\n    bw!\n\n    # Test for using a script-local function name\n    def LocalTsrFunc(findstart: number, base: string): any\n      add(g:LocalTsrFuncArgs, [findstart, base])\n      return findstart ? 0 : []\n    enddef\n    &thesaurusfunc = LocalTsrFunc\n    new | only\n    setline(1, 'three')\n    g:LocalTsrFuncArgs = []\n    feedkeys(\"A\\<C-X>\\<C-T>\\<Esc>\", 'x')\n    assert_equal([[1, ''], [0, 'three']], g:LocalTsrFuncArgs)\n    bw!\n  END\n  call v9.CheckScriptSuccess(lines)\n\n  \" cleanup\n  set thesaurusfunc&\n  delfunc TsrFunc1\n  delfunc TsrFunc2\n  unlet g:TsrFunc1Args g:TsrFunc2Args\n  %bw!\nendfunc\n\nfunc FooBarComplete(findstart, base)\n  if a:findstart\n    return col('.') - 1\n  else\n    return [\"Foo\", \"Bar\", \"}\"]\n  endif\nendfunc\n\nfunc Test_complete_smartindent()\n  new\n  setlocal smartindent completefunc=FooBarComplete\n\n  exe \"norm! o{\\<cr>\\<c-x>\\<c-u>\\<c-p>}\\<cr>\\<esc>\"\n  let result = getline(1,'$')\n  call assert_equal(['', '{','}',''], result)\n  bw!\n  delfunction! FooBarComplete\nendfunc\n\nfunc Test_complete_overrun()\n  \" this was going past the end of the copied text\n  new\n  sil norm si\u0094\u00140\u0003s\u000f0\u0018\f\u0005\n  bwipe!\nendfunc\n\nfunc Test_infercase_very_long_line()\n  \" this was truncating the line when inferring case\n  new\n  let longLine = \"blah \"->repeat(300)\n  let verylongLine = \"blah \"->repeat(400)\n  call setline(1, verylongLine)\n  call setline(2, longLine)\n  set ic infercase\n  exe \"normal 2Go\\<C-X>\\<C-L>\\<Esc>\"\n  call assert_equal(longLine, getline(3))\n\n  \" check that the too long text is NUL terminated\n  %del\n  norm o\n  norm 1987ax\n  exec \"norm ox\\<C-X>\\<C-L>\"\n  call assert_equal(repeat('x', 1987), getline(3))\n\n  bwipe!\n  set noic noinfercase\nendfunc\n\nfunc Test_ins_complete_add()\n  \" this was reading past the end of allocated memory\n  new\n  norm o\u007f\n  norm 7o\u0080\u0080\n  sil! norm o\u0010\u0018\u0010\u0018\u0010\n\n  bwipe!\nendfunc\n\nfunc Test_ins_complete_end_of_line()\n  \" this was reading past the end of the line\n  new  \n  norm 8o\u0080\u00fd\u00a0\n  sil! norm o\u0010\u0018\u0010\u0018\u0010\n\n  bwipe!\nendfunc\n\nfunc s:Tagfunc(t,f,o)\n  bwipe!\n  return []\nendfunc\n\n\" This was using freed memory, since 'complete' was in a wiped out buffer.\n\" Also using a window that was closed.\nfunc Test_tagfunc_wipes_out_buffer()\n  new\n  set complete=.,t,w,b,u,i\n  se tagfunc=s:Tagfunc\n  sil norm i\u000e\n\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/insexpand.c", "src/move.c", "src/testdir/test_ins_complete.vim", "src/version.c"], "buggy_code_start_loc": [2493, 685, 550, 701], "buggy_code_end_loc": [4145, 685, 2175, 701], "fixing_code_start_loc": [2493, 686, 549, 702], "fixing_code_end_loc": [4168, 687, 2192, 704], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0579.", "other": {"cve": {"id": "CVE-2022-3297", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-25T19:15:09.673", "lastModified": "2023-05-03T12:16:21.147", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0579."}, {"lang": "es", "value": "Un Uso de Memoria Previamente liberada en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0579."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0579", "matchCriteriaId": "78AC82CF-9EBF-4B1B-BD1B-6253AEF2E5B0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/0ff01835a40f549c5c4a550502f62a2ac9ac447c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/1aa9ec92-0355-4710-bf85-5bce9effa01c", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/0ff01835a40f549c5c4a550502f62a2ac9ac447c"}}