{"buggy_code": ["package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/docker\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/api/types/filters\"\n\t\"github.com/docker/docker/api/types/network\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/go-connections/nat\"\n\t\"github.com/gorilla/websocket\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/shirou/gopsutil/v3/cpu\"\n\t\"github.com/shirou/gopsutil/v3/mem\"\n)\n\ntype ContainerService struct{}\n\ntype IContainerService interface {\n\tPage(req dto.PageContainer) (int64, interface{}, error)\n\tList() ([]string, error)\n\tPageNetwork(req dto.SearchWithPage) (int64, interface{}, error)\n\tListNetwork() ([]dto.Options, error)\n\tPageVolume(req dto.SearchWithPage) (int64, interface{}, error)\n\tListVolume() ([]dto.Options, error)\n\tPageCompose(req dto.SearchWithPage) (int64, interface{}, error)\n\tCreateCompose(req dto.ComposeCreate) (string, error)\n\tComposeOperation(req dto.ComposeOperation) error\n\tContainerCreate(req dto.ContainerOperate) error\n\tContainerUpdate(req dto.ContainerOperate) error\n\tContainerUpgrade(req dto.ContainerUpgrade) error\n\tContainerInfo(req dto.OperationWithName) (*dto.ContainerOperate, error)\n\tContainerListStats() ([]dto.ContainerListStats, error)\n\tLoadResouceLimit() (*dto.ResourceLimit, error)\n\tContainerLogClean(req dto.OperationWithName) error\n\tContainerOperation(req dto.ContainerOperation) error\n\tContainerLogs(wsConn *websocket.Conn, container, since, tail string, follow bool) error\n\tContainerStats(id string) (*dto.ContainerStats, error)\n\tInspect(req dto.InspectReq) (string, error)\n\tDeleteNetwork(req dto.BatchDelete) error\n\tCreateNetwork(req dto.NetworkCreate) error\n\tDeleteVolume(req dto.BatchDelete) error\n\tCreateVolume(req dto.VolumeCreate) error\n\tTestCompose(req dto.ComposeCreate) (bool, error)\n\tComposeUpdate(req dto.ComposeUpdate) error\n\tPrune(req dto.ContainerPrune) (dto.ContainerPruneReport, error)\n}\n\nfunc NewIContainerService() IContainerService {\n\treturn &ContainerService{}\n}\n\nfunc (u *ContainerService) Page(req dto.PageContainer) (int64, interface{}, error) {\n\tvar (\n\t\trecords []types.Container\n\t\tlist    []types.Container\n\t)\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\toptions := types.ContainerListOptions{All: true}\n\tif len(req.Filters) != 0 {\n\t\toptions.Filters = filters.NewArgs()\n\t\toptions.Filters.Add(\"label\", req.Filters)\n\t}\n\tlist, err = client.ContainerList(context.Background(), options)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tif len(req.Name) != 0 {\n\t\tlength, count := len(list), 0\n\t\tfor count < length {\n\t\t\tif !strings.Contains(list[count].Names[0][1:], req.Name) {\n\t\t\t\tlist = append(list[:count], list[(count+1):]...)\n\t\t\t\tlength--\n\t\t\t} else {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\tswitch req.OrderBy {\n\tcase \"name\":\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\tif req.Order == constant.OrderAsc {\n\t\t\t\treturn list[i].Names[0][1:] < list[j].Names[0][1:]\n\t\t\t}\n\t\t\treturn list[i].Names[0][1:] > list[j].Names[0][1:]\n\t\t})\n\tcase \"state\":\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\tif req.Order == constant.OrderAsc {\n\t\t\t\treturn list[i].State < list[j].State\n\t\t\t}\n\t\t\treturn list[i].State > list[j].State\n\t\t})\n\tdefault:\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\tif req.Order == constant.OrderAsc {\n\t\t\t\treturn list[i].Created < list[j].Created\n\t\t\t}\n\t\t\treturn list[i].Created > list[j].Created\n\t\t})\n\t}\n\n\ttotal, start, end := len(list), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\trecords = make([]types.Container, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\trecords = list[start:end]\n\t}\n\n\tbackDatas := make([]dto.ContainerInfo, len(records))\n\tfor i := 0; i < len(records); i++ {\n\t\titem := records[i]\n\t\tIsFromCompose := false\n\t\tif _, ok := item.Labels[composeProjectLabel]; ok {\n\t\t\tIsFromCompose = true\n\t\t}\n\t\tIsFromApp := false\n\t\tif created, ok := item.Labels[composeCreatedBy]; ok && created == \"Apps\" {\n\t\t\tIsFromApp = true\n\t\t}\n\n\t\tvar ports []string\n\t\tfor _, port := range item.Ports {\n\t\t\titemPortStr := fmt.Sprintf(\"%v/%s\", port.PrivatePort, port.Type)\n\t\t\tif port.PublicPort != 0 {\n\t\t\t\titemPortStr = fmt.Sprintf(\"%s:%v->%v/%s\", port.IP, port.PublicPort, port.PrivatePort, port.Type)\n\t\t\t}\n\t\t\tports = append(ports, itemPortStr)\n\t\t}\n\t\tbackDatas[i] = dto.ContainerInfo{\n\t\t\tContainerID:   item.ID,\n\t\t\tCreateTime:    time.Unix(item.Created, 0).Format(\"2006-01-02 15:04:05\"),\n\t\t\tName:          item.Names[0][1:],\n\t\t\tImageId:       strings.Split(item.ImageID, \":\")[1],\n\t\t\tImageName:     item.Image,\n\t\t\tState:         item.State,\n\t\t\tRunTime:       item.Status,\n\t\t\tPorts:         ports,\n\t\t\tIsFromApp:     IsFromApp,\n\t\t\tIsFromCompose: IsFromCompose,\n\t\t}\n\t}\n\n\treturn int64(total), backDatas, nil\n}\n\nfunc (u *ContainerService) List() ([]string, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcontainers, err := client.ContainerList(context.Background(), types.ContainerListOptions{All: true})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar datas []string\n\tfor _, container := range containers {\n\t\tfor _, name := range container.Names {\n\t\t\tif len(name) != 0 {\n\t\t\t\tdatas = append(datas, strings.TrimLeft(name, \"/\"))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn datas, nil\n}\n\nfunc (u *ContainerService) ContainerListStats() ([]dto.ContainerListStats, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlist, err := client.ContainerList(context.Background(), types.ContainerListOptions{All: true})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar datas []dto.ContainerListStats\n\tvar wg sync.WaitGroup\n\twg.Add(len(list))\n\tfor i := 0; i < len(list); i++ {\n\t\tgo func(item types.Container) {\n\t\t\tcpu, mem := loadCpuAndMem(client, item.ID)\n\t\t\tdatas = append(datas, dto.ContainerListStats{CPUPercent: cpu, MemoryPercent: mem, ContainerID: item.ID})\n\t\t\twg.Done()\n\t\t}(list[i])\n\t}\n\twg.Wait()\n\treturn datas, nil\n}\n\nfunc (u *ContainerService) Inspect(req dto.InspectReq) (string, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tvar inspectInfo interface{}\n\tswitch req.Type {\n\tcase \"container\":\n\t\tinspectInfo, err = client.ContainerInspect(context.Background(), req.ID)\n\tcase \"network\":\n\t\tinspectInfo, err = client.NetworkInspect(context.TODO(), req.ID, types.NetworkInspectOptions{})\n\tcase \"volume\":\n\t\tinspectInfo, err = client.VolumeInspect(context.TODO(), req.ID)\n\t}\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tbytes, err := json.Marshal(inspectInfo)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(bytes), nil\n}\n\nfunc (u *ContainerService) Prune(req dto.ContainerPrune) (dto.ContainerPruneReport, error) {\n\treport := dto.ContainerPruneReport{}\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn report, err\n\t}\n\tpruneFilters := filters.NewArgs()\n\tif req.WithTagAll {\n\t\tpruneFilters.Add(\"dangling\", \"false\")\n\t\tif req.PruneType != \"image\" {\n\t\t\tpruneFilters.Add(\"until\", \"24h\")\n\t\t}\n\t}\n\tswitch req.PruneType {\n\tcase \"container\":\n\t\trep, err := client.ContainersPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.ContainersDeleted)\n\t\treport.SpaceReclaimed = int(rep.SpaceReclaimed)\n\tcase \"image\":\n\t\trep, err := client.ImagesPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.ImagesDeleted)\n\t\treport.SpaceReclaimed = int(rep.SpaceReclaimed)\n\tcase \"network\":\n\t\trep, err := client.NetworksPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.NetworksDeleted)\n\tcase \"volume\":\n\t\trep, err := client.VolumesPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.VolumesDeleted)\n\t\treport.SpaceReclaimed = int(rep.SpaceReclaimed)\n\t}\n\treturn report, nil\n}\n\nfunc (u *ContainerService) LoadResouceLimit() (*dto.ResourceLimit, error) {\n\tcpuCounts, err := cpu.Counts(true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load cpu limit failed, err: %v\", err)\n\t}\n\tmemoryInfo, err := mem.VirtualMemory()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load memory limit failed, err: %v\", err)\n\t}\n\n\tdata := dto.ResourceLimit{\n\t\tCPU:    cpuCounts,\n\t\tMemory: int(memoryInfo.Total),\n\t}\n\treturn &data, nil\n}\n\nfunc (u *ContainerService) ContainerCreate(req dto.ContainerOperate) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := context.Background()\n\tnewContainer, _ := client.ContainerInspect(ctx, req.Name)\n\tif newContainer.ContainerJSONBase != nil {\n\t\treturn buserr.New(constant.ErrContainerName)\n\t}\n\n\tvar config container.Config\n\tvar hostConf container.HostConfig\n\tvar networkConf network.NetworkingConfig\n\tif err := loadConfigInfo(req, &config, &hostConf, &networkConf); err != nil {\n\t\treturn err\n\t}\n\n\tglobal.LOG.Infof(\"new container info %s has been made, now start to create\", req.Name)\n\n\tif !checkImageExist(client, req.Image) || req.ForcePull {\n\t\tif err := pullImages(ctx, client, req.Image); err != nil {\n\t\t\tif !req.ForcePull {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"force pull image %s failed, err: %v\", req.Image, err)\n\t\t}\n\t}\n\tcontainer, err := client.ContainerCreate(ctx, &config, &hostConf, &networkConf, &v1.Platform{}, req.Name)\n\tif err != nil {\n\t\t_ = client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})\n\t\treturn err\n\t}\n\tglobal.LOG.Infof(\"create container %s successful! now check if the container is started and delete the container information if it is not.\", req.Name)\n\tif err := client.ContainerStart(ctx, container.ID, types.ContainerStartOptions{}); err != nil {\n\t\t_ = client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})\n\t\treturn fmt.Errorf(\"create successful but start failed, err: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerInfo(req dto.OperationWithName) (*dto.ContainerOperate, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tctx := context.Background()\n\toldContainer, err := client.ContainerInspect(ctx, req.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar data dto.ContainerOperate\n\tdata.ContainerID = oldContainer.ID\n\tdata.Name = strings.ReplaceAll(oldContainer.Name, \"/\", \"\")\n\tdata.Image = oldContainer.Config.Image\n\tif oldContainer.NetworkSettings != nil {\n\t\tfor network := range oldContainer.NetworkSettings.Networks {\n\t\t\tdata.Network = network\n\t\t\tbreak\n\t\t}\n\t}\n\tdata.Cmd = oldContainer.Config.Cmd\n\tdata.Env = oldContainer.Config.Env\n\tdata.CPUShares = oldContainer.HostConfig.CPUShares\n\tfor key, val := range oldContainer.Config.Labels {\n\t\tdata.Labels = append(data.Labels, fmt.Sprintf(\"%s=%s\", key, val))\n\t}\n\tfor key, val := range oldContainer.HostConfig.PortBindings {\n\t\tvar itemPort dto.PortHelper\n\t\tif !strings.Contains(string(key), \"/\") {\n\t\t\tcontinue\n\t\t}\n\t\titemPort.ContainerPort = strings.Split(string(key), \"/\")[0]\n\t\titemPort.Protocol = strings.Split(string(key), \"/\")[1]\n\t\tfor _, binds := range val {\n\t\t\titemPort.HostIP = binds.HostIP\n\t\t\titemPort.HostPort = binds.HostPort\n\t\t\tdata.ExposedPorts = append(data.ExposedPorts, itemPort)\n\t\t}\n\t}\n\tdata.AutoRemove = oldContainer.HostConfig.AutoRemove\n\tdata.PublishAllPorts = oldContainer.HostConfig.PublishAllPorts\n\tdata.RestartPolicy = oldContainer.HostConfig.RestartPolicy.Name\n\tif oldContainer.HostConfig.NanoCPUs != 0 {\n\t\tdata.NanoCPUs = float64(oldContainer.HostConfig.NanoCPUs) / 1000000000\n\t}\n\tif oldContainer.HostConfig.Memory != 0 {\n\t\tdata.Memory = float64(oldContainer.HostConfig.Memory) / 1024 / 1024\n\t}\n\tfor _, bind := range oldContainer.HostConfig.Binds {\n\t\tparts := strings.Split(bind, \":\")\n\t\tif len(parts) != 3 {\n\t\t\tcontinue\n\t\t}\n\t\tdata.Volumes = append(data.Volumes, dto.VolumeHelper{SourceDir: parts[0], ContainerDir: parts[1], Mode: parts[2]})\n\t}\n\n\treturn &data, nil\n}\n\nfunc (u *ContainerService) ContainerUpdate(req dto.ContainerOperate) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := context.Background()\n\tnewContainer, _ := client.ContainerInspect(ctx, req.Name)\n\tif newContainer.ContainerJSONBase != nil && newContainer.ID != req.ContainerID {\n\t\treturn buserr.New(constant.ErrContainerName)\n\t}\n\n\toldContainer, err := client.ContainerInspect(ctx, req.ContainerID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !checkImageExist(client, req.Image) || req.ForcePull {\n\t\tif err := pullImages(ctx, client, req.Image); err != nil {\n\t\t\tif !req.ForcePull {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"force pull image %s failed, err: %v\", req.Image, err)\n\t\t}\n\t}\n\n\tif err := client.ContainerRemove(ctx, req.ContainerID, types.ContainerRemoveOptions{Force: true}); err != nil {\n\t\treturn err\n\t}\n\n\tconfig := oldContainer.Config\n\thostConf := oldContainer.HostConfig\n\tvar networkConf network.NetworkingConfig\n\tif err := loadConfigInfo(req, config, hostConf, &networkConf); err != nil {\n\t\treturn err\n\t}\n\n\tglobal.LOG.Infof(\"new container info %s has been update, now start to recreate\", req.Name)\n\tcontainer, err := client.ContainerCreate(ctx, config, hostConf, &networkConf, &v1.Platform{}, req.Name)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"recreate contianer failed, err: %v\", err)\n\t}\n\tglobal.LOG.Infof(\"update container %s successful! now check if the container is started.\", req.Name)\n\tif err := client.ContainerStart(ctx, container.ID, types.ContainerStartOptions{}); err != nil {\n\t\treturn fmt.Errorf(\"update successful but start failed, err: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerUpgrade(req dto.ContainerUpgrade) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := context.Background()\n\toldContainer, err := client.ContainerInspect(ctx, req.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !checkImageExist(client, req.Image) || req.ForcePull {\n\t\tif err := pullImages(ctx, client, req.Image); err != nil {\n\t\t\tif !req.ForcePull {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"force pull image %s failed, err: %v\", req.Image, err)\n\t\t}\n\t}\n\tconfig := oldContainer.Config\n\tconfig.Image = req.Image\n\thostConf := oldContainer.HostConfig\n\tvar networkConf network.NetworkingConfig\n\tif oldContainer.NetworkSettings != nil {\n\t\tfor networkKey := range oldContainer.NetworkSettings.Networks {\n\t\t\tnetworkConf.EndpointsConfig = map[string]*network.EndpointSettings{networkKey: {}}\n\t\t\tbreak\n\t\t}\n\t}\n\tif err := client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{Force: true}); err != nil {\n\t\treturn err\n\t}\n\n\tglobal.LOG.Infof(\"new container info %s has been update, now start to recreate\", req.Name)\n\tcontainer, err := client.ContainerCreate(ctx, config, hostConf, &network.NetworkingConfig{}, &v1.Platform{}, req.Name)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"recreate contianer failed, err: %v\", err)\n\t}\n\tglobal.LOG.Infof(\"update container %s successful! now check if the container is started.\", req.Name)\n\tif err := client.ContainerStart(ctx, container.ID, types.ContainerStartOptions{}); err != nil {\n\t\treturn fmt.Errorf(\"update successful but start failed, err: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerOperation(req dto.ContainerOperation) error {\n\tvar err error\n\tctx := context.Background()\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tglobal.LOG.Infof(\"start container %s operation %s\", req.Name, req.Operation)\n\tswitch req.Operation {\n\tcase constant.ContainerOpStart:\n\t\terr = client.ContainerStart(ctx, req.Name, types.ContainerStartOptions{})\n\tcase constant.ContainerOpStop:\n\t\terr = client.ContainerStop(ctx, req.Name, container.StopOptions{})\n\tcase constant.ContainerOpRestart:\n\t\terr = client.ContainerRestart(ctx, req.Name, container.StopOptions{})\n\tcase constant.ContainerOpKill:\n\t\terr = client.ContainerKill(ctx, req.Name, \"SIGKILL\")\n\tcase constant.ContainerOpPause:\n\t\terr = client.ContainerPause(ctx, req.Name)\n\tcase constant.ContainerOpUnpause:\n\t\terr = client.ContainerUnpause(ctx, req.Name)\n\tcase constant.ContainerOpRename:\n\t\tnewContainer, _ := client.ContainerInspect(ctx, req.NewName)\n\t\tif newContainer.ContainerJSONBase != nil {\n\t\t\treturn buserr.New(constant.ErrContainerName)\n\t\t}\n\t\terr = client.ContainerRename(ctx, req.Name, req.NewName)\n\tcase constant.ContainerOpRemove:\n\t\terr = client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})\n\t}\n\treturn err\n}\n\nfunc (u *ContainerService) ContainerLogClean(req dto.OperationWithName) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcontainer, err := client.ContainerInspect(context.Background(), req.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfile, err := os.OpenFile(container.LogPath, os.O_RDWR|os.O_CREATE, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tif err = file.Truncate(0); err != nil {\n\t\treturn err\n\t}\n\t_, _ = file.Seek(0, 0)\n\n\tfiles, _ := filepath.Glob(fmt.Sprintf(\"%s.*\", container.LogPath))\n\tfor _, file := range files {\n\t\t_ = os.Remove(file)\n\t}\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerLogs(wsConn *websocket.Conn, container, since, tail string, follow bool) error {\n\tcommand := fmt.Sprintf(\"docker logs %s\", container)\n\tif tail != \"0\" {\n\t\tcommand += \" -n \" + tail\n\t}\n\tif since != \"all\" {\n\t\tcommand += \" --since \" + since\n\t}\n\tif follow {\n\t\tcommand += \" -f\"\n\t}\n\tcommand += \" 2>&1\"\n\tcmd := exec.Command(\"bash\", \"-c\", command)\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, err := stdout.Read(buffer)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"read bytes from container log failed, err: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif err = wsConn.WriteMessage(websocket.TextMessage, buffer[:n]); err != nil {\n\t\t\tglobal.LOG.Errorf(\"send message with container log to ws failed, err: %v\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerStats(id string) (*dto.ContainerStats, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres, err := client.ContainerStats(context.TODO(), id, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\tres.Body.Close()\n\t\treturn nil, err\n\t}\n\tres.Body.Close()\n\tvar stats *types.StatsJSON\n\tif err := json.Unmarshal(body, &stats); err != nil {\n\t\treturn nil, err\n\t}\n\tvar data dto.ContainerStats\n\tdata.CPUPercent = calculateCPUPercentUnix(stats)\n\tdata.IORead, data.IOWrite = calculateBlockIO(stats.BlkioStats)\n\tdata.Memory = float64(stats.MemoryStats.Usage) / 1024 / 1024\n\tif cache, ok := stats.MemoryStats.Stats[\"cache\"]; ok {\n\t\tdata.Cache = float64(cache) / 1024 / 1024\n\t}\n\tdata.Memory = data.Memory - data.Cache\n\tdata.NetworkRX, data.NetworkTX = calculateNetwork(stats.Networks)\n\tdata.ShotTime = stats.Read\n\treturn &data, nil\n}\n\nfunc stringsToMap(list []string) map[string]string {\n\tvar lableMap = make(map[string]string)\n\tfor _, label := range list {\n\t\tif strings.Contains(label, \"=\") {\n\t\t\tsps := strings.SplitN(label, \"=\", 2)\n\t\t\tlableMap[sps[0]] = sps[1]\n\t\t}\n\t}\n\treturn lableMap\n}\n\nfunc calculateCPUPercentUnix(stats *types.StatsJSON) float64 {\n\tcpuPercent := 0.0\n\tcpuDelta := float64(stats.CPUStats.CPUUsage.TotalUsage) - float64(stats.PreCPUStats.CPUUsage.TotalUsage)\n\tsystemDelta := float64(stats.CPUStats.SystemUsage) - float64(stats.PreCPUStats.SystemUsage)\n\n\tif systemDelta > 0.0 && cpuDelta > 0.0 {\n\t\tcpuPercent = (cpuDelta / systemDelta) * 100.0\n\t\tif len(stats.CPUStats.CPUUsage.PercpuUsage) != 0 {\n\t\t\tcpuPercent = cpuPercent * float64(len(stats.CPUStats.CPUUsage.PercpuUsage))\n\t\t}\n\t}\n\treturn cpuPercent\n}\nfunc calculateMemPercentUnix(memStats types.MemoryStats) float64 {\n\tmemPercent := 0.0\n\tmemUsage := float64(memStats.Usage - memStats.Stats[\"cache\"])\n\tmemLimit := float64(memStats.Limit)\n\tif memUsage > 0.0 && memLimit > 0.0 {\n\t\tmemPercent = (memUsage / memLimit) * 100.0\n\t}\n\treturn memPercent\n}\nfunc calculateBlockIO(blkio types.BlkioStats) (blkRead float64, blkWrite float64) {\n\tfor _, bioEntry := range blkio.IoServiceBytesRecursive {\n\t\tswitch strings.ToLower(bioEntry.Op) {\n\t\tcase \"read\":\n\t\t\tblkRead = (blkRead + float64(bioEntry.Value)) / 1024 / 1024\n\t\tcase \"write\":\n\t\t\tblkWrite = (blkWrite + float64(bioEntry.Value)) / 1024 / 1024\n\t\t}\n\t}\n\treturn\n}\nfunc calculateNetwork(network map[string]types.NetworkStats) (float64, float64) {\n\tvar rx, tx float64\n\n\tfor _, v := range network {\n\t\trx += float64(v.RxBytes) / 1024\n\t\ttx += float64(v.TxBytes) / 1024\n\t}\n\treturn rx, tx\n}\n\nfunc checkImageExist(client *client.Client, image string) bool {\n\timages, err := client.ImageList(context.Background(), types.ImageListOptions{})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn false\n\t}\n\n\tfor _, img := range images {\n\t\tfor _, tag := range img.RepoTags {\n\t\t\tif tag == image || tag == image+\":latest\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc pullImages(ctx context.Context, client *client.Client, image string) error {\n\tout, err := client.ImagePull(ctx, image, types.ImagePullOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\t_, err = io.Copy(io.Discard, out)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc loadCpuAndMem(client *client.Client, container string) (float64, float64) {\n\tres, err := client.ContainerStats(context.Background(), container, false)\n\tif err != nil {\n\t\treturn 0, 0\n\t}\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\tres.Body.Close()\n\t\treturn 0, 0\n\t}\n\tres.Body.Close()\n\tvar stats *types.StatsJSON\n\tif err := json.Unmarshal(body, &stats); err != nil {\n\t\treturn 0, 0\n\t}\n\n\tCPUPercent := calculateCPUPercentUnix(stats)\n\tMemPercent := calculateMemPercentUnix(stats.MemoryStats)\n\treturn CPUPercent, MemPercent\n}\n\nfunc checkPortStats(ports []dto.PortHelper) (nat.PortMap, error) {\n\tportMap := make(nat.PortMap)\n\tif len(ports) == 0 {\n\t\treturn portMap, nil\n\t}\n\tfor _, port := range ports {\n\t\tif strings.Contains(port.ContainerPort, \"-\") {\n\t\t\tif !strings.Contains(port.HostPort, \"-\") {\n\t\t\t\treturn portMap, buserr.New(constant.ErrPortRules)\n\t\t\t}\n\t\t\thostStart, _ := strconv.Atoi(strings.Split(port.HostPort, \"-\")[0])\n\t\t\thostEnd, _ := strconv.Atoi(strings.Split(port.HostPort, \"-\")[1])\n\t\t\tcontainerStart, _ := strconv.Atoi(strings.Split(port.ContainerPort, \"-\")[0])\n\t\t\tcontainerEnd, _ := strconv.Atoi(strings.Split(port.ContainerPort, \"-\")[1])\n\t\t\tif (hostEnd-hostStart) <= 0 || (containerEnd-containerStart) <= 0 {\n\t\t\t\treturn portMap, buserr.New(constant.ErrPortRules)\n\t\t\t}\n\t\t\tif (containerEnd - containerStart) != (hostEnd - hostStart) {\n\t\t\t\treturn portMap, buserr.New(constant.ErrPortRules)\n\t\t\t}\n\t\t\tfor i := 0; i <= hostEnd-hostStart; i++ {\n\t\t\t\tbindItem := nat.PortBinding{HostPort: strconv.Itoa(hostStart + i), HostIP: port.HostIP}\n\t\t\t\tportMap[nat.Port(fmt.Sprintf(\"%d/%s\", containerStart+i, port.Protocol))] = []nat.PortBinding{bindItem}\n\t\t\t}\n\t\t\tfor i := hostStart; i <= hostEnd; i++ {\n\t\t\t\tif common.ScanPort(i) {\n\t\t\t\t\treturn portMap, buserr.WithDetail(constant.ErrPortInUsed, i, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tportItem := 0\n\t\t\tif strings.Contains(port.HostPort, \"-\") {\n\t\t\t\tportItem, _ = strconv.Atoi(strings.Split(port.HostPort, \"-\")[0])\n\t\t\t} else {\n\t\t\t\tportItem, _ = strconv.Atoi(port.HostPort)\n\t\t\t}\n\t\t\tif common.ScanPort(portItem) {\n\t\t\t\treturn portMap, buserr.WithDetail(constant.ErrPortInUsed, portItem, nil)\n\t\t\t}\n\t\t\tbindItem := nat.PortBinding{HostPort: strconv.Itoa(portItem), HostIP: port.HostIP}\n\t\t\tportMap[nat.Port(fmt.Sprintf(\"%s/%s\", port.ContainerPort, port.Protocol))] = []nat.PortBinding{bindItem}\n\t\t}\n\t}\n\treturn portMap, nil\n}\n\nfunc loadConfigInfo(req dto.ContainerOperate, config *container.Config, hostConf *container.HostConfig, networkConf *network.NetworkingConfig) error {\n\tportMap, err := checkPortStats(req.ExposedPorts)\n\tif err != nil {\n\t\treturn err\n\t}\n\texposeds := make(nat.PortSet)\n\tfor port := range portMap {\n\t\texposeds[port] = struct{}{}\n\t}\n\tconfig.Image = req.Image\n\tconfig.Cmd = req.Cmd\n\tconfig.Env = req.Env\n\tconfig.Labels = stringsToMap(req.Labels)\n\tconfig.ExposedPorts = exposeds\n\n\tnetworkConf.EndpointsConfig = map[string]*network.EndpointSettings{req.Network: {}}\n\n\thostConf.AutoRemove = req.AutoRemove\n\thostConf.CPUShares = req.CPUShares\n\thostConf.PublishAllPorts = req.PublishAllPorts\n\thostConf.RestartPolicy = container.RestartPolicy{Name: req.RestartPolicy}\n\tif req.RestartPolicy == \"on-failure\" {\n\t\thostConf.RestartPolicy.MaximumRetryCount = 5\n\t}\n\thostConf.NanoCPUs = int64(req.NanoCPUs * 1000000000)\n\thostConf.Memory = int64(req.Memory * 1024 * 1024)\n\thostConf.PortBindings = portMap\n\thostConf.Binds = []string{}\n\tconfig.Volumes = make(map[string]struct{})\n\tfor _, volume := range req.Volumes {\n\t\tconfig.Volumes[volume.ContainerDir] = struct{}{}\n\t\thostConf.Binds = append(hostConf.Binds, fmt.Sprintf(\"%s:%s:%s\", volume.SourceDir, volume.ContainerDir, volume.Mode))\n\t}\n\treturn nil\n}\n", "package service\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/app/model\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/compose\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/docker\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/filters\"\n\t\"golang.org/x/net/context\"\n)\n\nconst composeProjectLabel = \"com.docker.compose.project\"\nconst composeConfigLabel = \"com.docker.compose.project.config_files\"\nconst composeWorkdirLabel = \"com.docker.compose.project.working_dir\"\nconst composeCreatedBy = \"createdBy\"\n\nfunc (u *ContainerService) PageCompose(req dto.SearchWithPage) (int64, interface{}, error) {\n\tvar (\n\t\trecords   []dto.ComposeInfo\n\t\tBackDatas []dto.ComposeInfo\n\t)\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\toptions := types.ContainerListOptions{All: true}\n\toptions.Filters = filters.NewArgs()\n\toptions.Filters.Add(\"label\", composeProjectLabel)\n\n\tlist, err := client.ContainerList(context.Background(), options)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\tcomposeCreatedByLocal, _ := composeRepo.ListRecord()\n\tcomposeMap := make(map[string]dto.ComposeInfo)\n\tfor _, container := range list {\n\t\tif name, ok := container.Labels[composeProjectLabel]; ok {\n\t\t\tcontainerItem := dto.ComposeContainer{\n\t\t\t\tContainerID: container.ID,\n\t\t\t\tName:        container.Names[0][1:],\n\t\t\t\tState:       container.State,\n\t\t\t\tCreateTime:  time.Unix(container.Created, 0).Format(\"2006-01-02 15:04:05\"),\n\t\t\t}\n\t\t\tif compose, has := composeMap[name]; has {\n\t\t\t\tcompose.ContainerNumber++\n\t\t\t\tcompose.Containers = append(compose.Containers, containerItem)\n\t\t\t\tcomposeMap[name] = compose\n\t\t\t} else {\n\t\t\t\tconfig := container.Labels[composeConfigLabel]\n\t\t\t\tworkdir := container.Labels[composeWorkdirLabel]\n\t\t\t\tcomposeItem := dto.ComposeInfo{\n\t\t\t\t\tContainerNumber: 1,\n\t\t\t\t\tCreatedAt:       time.Unix(container.Created, 0).Format(\"2006-01-02 15:04:05\"),\n\t\t\t\t\tConfigFile:      config,\n\t\t\t\t\tWorkdir:         workdir,\n\t\t\t\t\tContainers:      []dto.ComposeContainer{containerItem},\n\t\t\t\t}\n\t\t\t\tcreatedBy, ok := container.Labels[composeCreatedBy]\n\t\t\t\tif ok {\n\t\t\t\t\tcomposeItem.CreatedBy = createdBy\n\t\t\t\t}\n\t\t\t\tif len(config) != 0 && len(workdir) != 0 && strings.Contains(config, workdir) {\n\t\t\t\t\tcomposeItem.Path = config\n\t\t\t\t} else {\n\t\t\t\t\tcomposeItem.Path = workdir\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < len(composeCreatedByLocal); i++ {\n\t\t\t\t\tif composeCreatedByLocal[i].Name == name {\n\t\t\t\t\t\tcomposeItem.CreatedBy = \"1Panel\"\n\t\t\t\t\t\tcomposeCreatedByLocal = append(composeCreatedByLocal[:i], composeCreatedByLocal[i+1:]...)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcomposeMap[name] = composeItem\n\t\t\t}\n\t\t}\n\t}\n\tfor _, item := range composeCreatedByLocal {\n\t\tif err := composeRepo.DeleteRecord(commonRepo.WithByID(item.ID)); err != nil {\n\t\t\tglobal.LOG.Error(err)\n\t\t}\n\t}\n\tfor key, value := range composeMap {\n\t\tvalue.Name = key\n\t\trecords = append(records, value)\n\t}\n\tif len(req.Info) != 0 {\n\t\tlength, count := len(records), 0\n\t\tfor count < length {\n\t\t\tif !strings.Contains(records[count].Name, req.Info) {\n\t\t\t\trecords = append(records[:count], records[(count+1):]...)\n\t\t\t\tlength--\n\t\t\t} else {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\tsort.Slice(records, func(i, j int) bool {\n\t\treturn records[i].CreatedAt > records[j].CreatedAt\n\t})\n\ttotal, start, end := len(records), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\tBackDatas = make([]dto.ComposeInfo, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\tBackDatas = records[start:end]\n\t}\n\treturn int64(total), BackDatas, nil\n}\n\nfunc (u *ContainerService) TestCompose(req dto.ComposeCreate) (bool, error) {\n\tcomposeItem, _ := composeRepo.GetRecord(commonRepo.WithByName(req.Name))\n\tif composeItem.ID != 0 {\n\t\treturn false, constant.ErrRecordExist\n\t}\n\tif err := u.loadPath(&req); err != nil {\n\t\treturn false, err\n\t}\n\tcmd := exec.Command(\"docker-compose\", \"-f\", req.Path, \"config\")\n\tstdout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn false, errors.New(string(stdout))\n\t}\n\treturn true, nil\n}\n\nfunc (u *ContainerService) CreateCompose(req dto.ComposeCreate) (string, error) {\n\tif err := u.loadPath(&req); err != nil {\n\t\treturn \"\", err\n\t}\n\tglobal.LOG.Infof(\"docker-compose.yml %s create successful, start to docker-compose up\", req.Name)\n\n\tif req.From == \"path\" {\n\t\treq.Name = path.Base(strings.ReplaceAll(req.Path, \"/\"+path.Base(req.Path), \"\"))\n\t}\n\tlogName := path.Dir(req.Path) + \"/compose.log\"\n\tfile, err := os.OpenFile(logName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tgo func() {\n\t\tdefer file.Close()\n\t\tcmd := exec.Command(\"docker-compose\", \"-f\", req.Path, \"up\", \"-d\")\n\t\tmultiWriter := io.MultiWriter(os.Stdout, file)\n\t\tcmd.Stdout = multiWriter\n\t\tcmd.Stderr = multiWriter\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tglobal.LOG.Errorf(\"docker-compose up %s failed, err: %v\", req.Name, err)\n\t\t\t_, _ = compose.Down(req.Path)\n\t\t\t_, _ = file.WriteString(\"docker-compose up failed!\")\n\t\t\treturn\n\t\t}\n\t\tglobal.LOG.Infof(\"docker-compose up %s successful!\", req.Name)\n\t\t_ = composeRepo.CreateRecord(&model.Compose{Name: req.Name})\n\t\t_, _ = file.WriteString(\"docker-compose up successful!\")\n\t}()\n\n\treturn logName, nil\n}\n\nfunc (u *ContainerService) ComposeOperation(req dto.ComposeOperation) error {\n\tif _, err := os.Stat(req.Path); err != nil {\n\t\treturn fmt.Errorf(\"load file with path %s failed, %v\", req.Path, err)\n\t}\n\tif stdout, err := compose.Operate(req.Path, req.Operation); err != nil {\n\t\treturn errors.New(string(stdout))\n\t}\n\tglobal.LOG.Infof(\"docker-compose %s %s successful\", req.Operation, req.Name)\n\tif req.Operation == \"down\" {\n\t\t_ = composeRepo.DeleteRecord(commonRepo.WithByName(req.Name))\n\t\tif req.WithFile {\n\t\t\t_ = os.RemoveAll(path.Dir(req.Path))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) ComposeUpdate(req dto.ComposeUpdate) error {\n\tif _, err := os.Stat(req.Path); err != nil {\n\t\treturn fmt.Errorf(\"load file with path %s failed, %v\", req.Path, err)\n\t}\n\tfile, err := os.OpenFile(req.Path, os.O_WRONLY|os.O_TRUNC, 0640)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\twrite := bufio.NewWriter(file)\n\t_, _ = write.WriteString(req.Content)\n\twrite.Flush()\n\n\tglobal.LOG.Infof(\"docker-compose.yml %s has been replaced, now start to docker-compose restart\", req.Path)\n\tif stdout, err := compose.Down(req.Path); err != nil {\n\t\treturn errors.New(string(stdout))\n\t}\n\tif stdout, err := compose.Up(req.Path); err != nil {\n\t\treturn errors.New(string(stdout))\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) loadPath(req *dto.ComposeCreate) error {\n\tif req.From == \"template\" || req.From == \"edit\" {\n\t\tdir := fmt.Sprintf(\"%s/docker/compose/%s\", constant.DataDir, req.Name)\n\t\tif _, err := os.Stat(dir); err != nil && os.IsNotExist(err) {\n\t\t\tif err = os.MkdirAll(dir, os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tpath := fmt.Sprintf(\"%s/docker-compose.yml\", dir)\n\t\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer file.Close()\n\t\twrite := bufio.NewWriter(file)\n\t\t_, _ = write.WriteString(string(req.File))\n\t\twrite.Flush()\n\t\treq.Path = path\n\t}\n\treturn nil\n}\n", "package service\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/app/model\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/compose\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/pkg/errors\"\n)\n\ntype MysqlService struct{}\n\ntype IMysqlService interface {\n\tSearchWithPage(search dto.SearchWithPage) (int64, interface{}, error)\n\tListDBName() ([]string, error)\n\tCreate(ctx context.Context, req dto.MysqlDBCreate) (*model.DatabaseMysql, error)\n\tChangeAccess(info dto.ChangeDBInfo) error\n\tChangePassword(info dto.ChangeDBInfo) error\n\tUpdateVariables(updates []dto.MysqlVariablesUpdate) error\n\tUpdateConfByFile(info dto.MysqlConfUpdateByFile) error\n\tUpdateDescription(req dto.UpdateDescription) error\n\tDeleteCheck(id uint) ([]string, error)\n\tDelete(ctx context.Context, req dto.MysqlDBDelete) error\n\tLoadStatus() (*dto.MysqlStatus, error)\n\tLoadVariables() (*dto.MysqlVariables, error)\n\tLoadBaseInfo() (*dto.DBBaseInfo, error)\n\tLoadRemoteAccess() (bool, error)\n}\n\nfunc NewIMysqlService() IMysqlService {\n\treturn &MysqlService{}\n}\n\nfunc (u *MysqlService) SearchWithPage(search dto.SearchWithPage) (int64, interface{}, error) {\n\ttotal, mysqls, err := mysqlRepo.Page(search.Page, search.PageSize, commonRepo.WithLikeName(search.Info), commonRepo.WithOrderRuleBy(search.OrderBy, search.Order))\n\tvar dtoMysqls []dto.MysqlDBInfo\n\tfor _, mysql := range mysqls {\n\t\tvar item dto.MysqlDBInfo\n\t\tif err := copier.Copy(&item, &mysql); err != nil {\n\t\t\treturn 0, nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t\t}\n\t\tdtoMysqls = append(dtoMysqls, item)\n\t}\n\treturn total, dtoMysqls, err\n}\n\nfunc (u *MysqlService) ListDBName() ([]string, error) {\n\tmysqls, err := mysqlRepo.List()\n\tvar dbNames []string\n\tfor _, mysql := range mysqls {\n\t\tdbNames = append(dbNames, mysql.Name)\n\t}\n\treturn dbNames, err\n}\n\nvar formatMap = map[string]string{\n\t\"utf8\":    \"utf8_general_ci\",\n\t\"utf8mb4\": \"utf8mb4_general_ci\",\n\t\"gbk\":     \"gbk_chinese_ci\",\n\t\"big5\":    \"big5_chinese_ci\",\n}\n\nfunc (u *MysqlService) Create(ctx context.Context, req dto.MysqlDBCreate) (*model.DatabaseMysql, error) {\n\tif req.Username == \"root\" {\n\t\treturn nil, errors.New(\"Cannot set root as user name\")\n\t}\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmysql, _ := mysqlRepo.Get(commonRepo.WithByName(req.Name))\n\tif mysql.ID != 0 {\n\t\treturn nil, constant.ErrRecordExist\n\t}\n\tif err := copier.Copy(&mysql, &req); err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t}\n\n\tcreateSql := fmt.Sprintf(\"create database `%s` default character set %s collate %s\", req.Name, req.Format, formatMap[req.Format])\n\tif err := excSQL(app.ContainerName, app.Password, createSql); err != nil {\n\t\tif strings.Contains(err.Error(), \"ERROR 1007\") {\n\t\t\treturn nil, buserr.New(constant.ErrDatabaseIsExist)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif err := u.createUser(app.ContainerName, app.Password, app.Version, req); err != nil {\n\t\treturn nil, err\n\t}\n\n\tglobal.LOG.Infof(\"create database %s successful!\", req.Name)\n\tmysql.MysqlName = app.Name\n\tif err := mysqlRepo.Create(ctx, &mysql); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &mysql, nil\n}\n\nfunc (u *MysqlService) UpdateDescription(req dto.UpdateDescription) error {\n\treturn mysqlRepo.Update(req.ID, map[string]interface{}{\"description\": req.Description})\n}\n\nfunc (u *MysqlService) DeleteCheck(id uint) ([]string, error) {\n\tvar appInUsed []string\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn appInUsed, err\n\t}\n\n\tdb, err := mysqlRepo.Get(commonRepo.WithByID(id))\n\tif err != nil {\n\t\treturn appInUsed, err\n\t}\n\n\tapps, _ := appInstallResourceRepo.GetBy(appInstallResourceRepo.WithLinkId(app.ID), appInstallResourceRepo.WithResourceId(db.ID))\n\tfor _, app := range apps {\n\t\tappInstall, _ := appInstallRepo.GetFirst(commonRepo.WithByID(app.AppInstallId))\n\t\tif appInstall.ID != 0 {\n\t\t\tappInUsed = append(appInUsed, appInstall.Name)\n\t\t}\n\t}\n\treturn appInUsed, nil\n}\n\nfunc (u *MysqlService) Delete(ctx context.Context, req dto.MysqlDBDelete) error {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil && !req.ForceDelete {\n\t\treturn err\n\t}\n\n\tdb, err := mysqlRepo.Get(commonRepo.WithByID(req.ID))\n\tif err != nil && !req.ForceDelete {\n\t\treturn err\n\t}\n\n\tif strings.HasPrefix(app.Version, \"5.6\") {\n\t\tif err := excSQL(app.ContainerName, app.Password, fmt.Sprintf(\"drop user '%s'@'%s'\", db.Username, db.Permission)); err != nil && !req.ForceDelete {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := excSQL(app.ContainerName, app.Password, fmt.Sprintf(\"drop user if exists '%s'@'%s'\", db.Username, db.Permission)); err != nil && !req.ForceDelete {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := excSQL(app.ContainerName, app.Password, fmt.Sprintf(\"drop database if exists `%s`\", db.Name)); err != nil && !req.ForceDelete {\n\t\treturn err\n\t}\n\tglobal.LOG.Info(\"execute delete database sql successful, now start to drop uploads and records\")\n\n\tuploadDir := fmt.Sprintf(\"%s/1panel/uploads/database/mysql/%s/%s\", global.CONF.System.BaseDir, app.Name, db.Name)\n\tif _, err := os.Stat(uploadDir); err == nil {\n\t\t_ = os.RemoveAll(uploadDir)\n\t}\n\tif req.DeleteBackup {\n\t\tlocalDir, err := loadLocalDir()\n\t\tif err != nil && !req.ForceDelete {\n\t\t\treturn err\n\t\t}\n\t\tbackupDir := fmt.Sprintf(\"%s/database/mysql/%s/%s\", localDir, db.MysqlName, db.Name)\n\t\tif _, err := os.Stat(backupDir); err == nil {\n\t\t\t_ = os.RemoveAll(backupDir)\n\t\t}\n\t\tglobal.LOG.Infof(\"delete database %s-%s backups successful\", app.Name, db.Name)\n\t}\n\t_ = backupRepo.DeleteRecord(ctx, commonRepo.WithByType(\"mysql\"), commonRepo.WithByName(app.Name), backupRepo.WithByDetailName(db.Name))\n\n\t_ = mysqlRepo.Delete(ctx, commonRepo.WithByID(db.ID))\n\treturn nil\n}\n\nfunc (u *MysqlService) ChangePassword(info dto.ChangeDBInfo) error {\n\tvar (\n\t\tmysql model.DatabaseMysql\n\t\terr   error\n\t)\n\tif info.ID != 0 {\n\t\tmysql, err = mysqlRepo.Get(commonRepo.WithByID(info.ID))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpasswordChangeCMD := fmt.Sprintf(\"set password for '%s'@'%s' = password('%s')\", mysql.Username, mysql.Permission, info.Value)\n\tif !strings.HasPrefix(app.Version, \"5.7\") && !strings.HasPrefix(app.Version, \"5.6\") {\n\t\tpasswordChangeCMD = fmt.Sprintf(\"ALTER USER '%s'@'%s' IDENTIFIED WITH mysql_native_password BY '%s';\", mysql.Username, mysql.Permission, info.Value)\n\t}\n\tif info.ID != 0 {\n\t\tappRess, _ := appInstallResourceRepo.GetBy(appInstallResourceRepo.WithLinkId(app.ID), appInstallResourceRepo.WithResourceId(mysql.ID))\n\t\tfor _, appRes := range appRess {\n\t\t\tappInstall, err := appInstallRepo.GetFirst(commonRepo.WithByID(appRes.AppInstallId))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tappModel, err := appRepo.GetFirst(commonRepo.WithByID(appInstall.AppId))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tglobal.LOG.Infof(\"start to update mysql password used by app %s-%s\", appModel.Key, appInstall.Name)\n\t\t\tif err := updateInstallInfoInDB(appModel.Key, appInstall.Name, \"user-password\", true, info.Value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := excuteSql(app.ContainerName, app.Password, passwordChangeCMD); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tglobal.LOG.Info(\"excute password change sql successful\")\n\t\t_ = mysqlRepo.Update(mysql.ID, map[string]interface{}{\"password\": info.Value})\n\t\treturn nil\n\t}\n\n\thosts, err := excuteSqlForRows(app.ContainerName, app.Password, \"select host from mysql.user where user='root';\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, host := range hosts {\n\t\tif host == \"%\" || host == \"localhost\" {\n\t\t\tpasswordRootChangeCMD := fmt.Sprintf(\"set password for 'root'@'%s' = password('%s')\", host, info.Value)\n\t\t\tif !strings.HasPrefix(app.Version, \"5.7\") && !strings.HasPrefix(app.Version, \"5.6\") {\n\t\t\t\tpasswordRootChangeCMD = fmt.Sprintf(\"alter user 'root'@'%s' identified with mysql_native_password BY '%s';\", host, info.Value)\n\t\t\t}\n\t\t\tif err := excuteSql(app.ContainerName, app.Password, passwordRootChangeCMD); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif err := updateInstallInfoInDB(\"mysql\", \"\", \"password\", false, info.Value); err != nil {\n\t\treturn err\n\t}\n\tif err := updateInstallInfoInDB(\"phpmyadmin\", \"\", \"password\", true, info.Value); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (u *MysqlService) ChangeAccess(info dto.ChangeDBInfo) error {\n\tvar (\n\t\tmysql model.DatabaseMysql\n\t\terr   error\n\t)\n\tif info.ID != 0 {\n\t\tmysql, err = mysqlRepo.Get(commonRepo.WithByID(info.ID))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.Value == mysql.Permission {\n\t\t\treturn nil\n\t\t}\n\t}\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif info.ID == 0 {\n\t\tmysql.Name = \"*\"\n\t\tmysql.Username = \"root\"\n\t\tmysql.Permission = \"%\"\n\t\tmysql.Password = app.Password\n\t}\n\n\tif info.Value != mysql.Permission {\n\t\tvar userlist []string\n\t\tif strings.Contains(mysql.Permission, \",\") {\n\t\t\tuserlist = strings.Split(mysql.Permission, \",\")\n\t\t} else {\n\t\t\tuserlist = append(userlist, mysql.Permission)\n\t\t}\n\t\tfor _, user := range userlist {\n\t\t\tif len(user) != 0 {\n\t\t\t\tif strings.HasPrefix(app.Version, \"5.6\") {\n\t\t\t\t\tif err := excuteSql(app.ContainerName, app.Password, fmt.Sprintf(\"drop user '%s'@'%s'\", mysql.Username, user)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif err := excuteSql(app.ContainerName, app.Password, fmt.Sprintf(\"drop user if exists '%s'@'%s'\", mysql.Username, user)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif info.ID == 0 {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := u.createUser(app.ContainerName, app.Password, app.Version, dto.MysqlDBCreate{\n\t\tUsername:   mysql.Username,\n\t\tName:       mysql.Name,\n\t\tPermission: info.Value,\n\t\tPassword:   mysql.Password,\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := excuteSql(app.ContainerName, app.Password, \"flush privileges\"); err != nil {\n\t\treturn err\n\t}\n\tif info.ID == 0 {\n\t\treturn nil\n\t}\n\n\t_ = mysqlRepo.Update(mysql.ID, map[string]interface{}{\"permission\": info.Value})\n\n\treturn nil\n}\n\nfunc (u *MysqlService) UpdateConfByFile(info dto.MysqlConfUpdateByFile) error {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tpath := fmt.Sprintf(\"%s/mysql/%s/conf/my.cnf\", constant.AppInstallDir, app.Name)\n\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0640)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\twrite := bufio.NewWriter(file)\n\t_, _ = write.WriteString(info.File)\n\twrite.Flush()\n\tif _, err := compose.Restart(fmt.Sprintf(\"%s/mysql/%s/docker-compose.yml\", constant.AppInstallDir, app.Name)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (u *MysqlService) UpdateVariables(updates []dto.MysqlVariablesUpdate) error {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar files []string\n\n\tpath := fmt.Sprintf(\"%s/mysql/%s/conf/my.cnf\", constant.AppInstallDir, app.Name)\n\tlineBytes, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfiles = strings.Split(string(lineBytes), \"\\n\")\n\n\tgroup := \"[mysqld]\"\n\tfor _, info := range updates {\n\t\tif !strings.HasPrefix(app.Version, \"5.7\") && !strings.HasPrefix(app.Version, \"5.6\") {\n\t\t\tif info.Param == \"query_cache_size\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif _, ok := info.Value.(float64); ok {\n\t\t\tfiles = updateMyCnf(files, group, info.Param, common.LoadSizeUnit(info.Value.(float64)))\n\t\t} else {\n\t\t\tfiles = updateMyCnf(files, group, info.Param, info.Value)\n\t\t}\n\t}\n\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = file.WriteString(strings.Join(files, \"\\n\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := compose.Restart(fmt.Sprintf(\"%s/mysql/%s/docker-compose.yml\", constant.AppInstallDir, app.Name)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (u *MysqlService) LoadBaseInfo() (*dto.DBBaseInfo, error) {\n\tvar data dto.DBBaseInfo\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata.ContainerName = app.ContainerName\n\tdata.Name = app.Name\n\tdata.Port = int64(app.Port)\n\n\treturn &data, nil\n}\n\nfunc (u *MysqlService) LoadRemoteAccess() (bool, error) {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\thosts, err := excuteSqlForRows(app.ContainerName, app.Password, \"select host from mysql.user where user='root';\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, host := range hosts {\n\t\tif host == \"%\" {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (u *MysqlService) LoadVariables() (*dto.MysqlVariables, error) {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvariableMap, err := excuteSqlForMaps(app.ContainerName, app.Password, \"show global variables;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar info dto.MysqlVariables\n\tarr, err := json.Marshal(variableMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_ = json.Unmarshal(arr, &info)\n\treturn &info, nil\n}\n\nfunc (u *MysqlService) LoadStatus() (*dto.MysqlStatus, error) {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstatusMap, err := excuteSqlForMaps(app.ContainerName, app.Password, \"show global status;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar info dto.MysqlStatus\n\tarr, err := json.Marshal(statusMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_ = json.Unmarshal(arr, &info)\n\n\tif value, ok := statusMap[\"Run\"]; ok {\n\t\tuptime, _ := strconv.Atoi(value)\n\t\tinfo.Run = time.Unix(time.Now().Unix()-int64(uptime), 0).Format(\"2006-01-02 15:04:05\")\n\t} else {\n\t\tif value, ok := statusMap[\"Uptime\"]; ok {\n\t\t\tuptime, _ := strconv.Atoi(value)\n\t\t\tinfo.Run = time.Unix(time.Now().Unix()-int64(uptime), 0).Format(\"2006-01-02 15:04:05\")\n\t\t}\n\t}\n\n\tinfo.File = \"OFF\"\n\tinfo.Position = \"OFF\"\n\trows, err := excuteSqlForRows(app.ContainerName, app.Password, \"show master status;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(rows) > 2 {\n\t\titemValue := strings.Split(rows[1], \"\\t\")\n\t\tif len(itemValue) > 2 {\n\t\t\tinfo.File = itemValue[0]\n\t\t\tinfo.Position = itemValue[1]\n\t\t}\n\t}\n\n\treturn &info, nil\n}\n\nfunc (u *MysqlService) createUser(container, password, version string, req dto.MysqlDBCreate) error {\n\tvar userlist []string\n\tif strings.Contains(req.Permission, \",\") {\n\t\tips := strings.Split(req.Permission, \",\")\n\t\tfor _, ip := range ips {\n\t\t\tif len(ip) != 0 {\n\t\t\t\tuserlist = append(userlist, fmt.Sprintf(\"'%s'@'%s'\", req.Username, ip))\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuserlist = append(userlist, fmt.Sprintf(\"'%s'@'%s'\", req.Username, req.Permission))\n\t}\n\n\tfor _, user := range userlist {\n\t\tif err := excSQL(container, password, fmt.Sprintf(\"create user %s identified by '%s';\", user, req.Password)); err != nil {\n\t\t\tif strings.Contains(err.Error(), \"ERROR 1396\") {\n\t\t\t\thandleCreateError(container, password, req.Name, userlist, false)\n\t\t\t\treturn buserr.New(constant.ErrUserIsExist)\n\t\t\t}\n\t\t\thandleCreateError(container, password, req.Name, userlist, true)\n\t\t\treturn err\n\t\t}\n\t\tgrantStr := fmt.Sprintf(\"grant all privileges on `%s`.* to %s\", req.Name, user)\n\t\tif req.Name == \"*\" {\n\t\t\tgrantStr = fmt.Sprintf(\"grant all privileges on *.* to %s\", user)\n\t\t}\n\t\tif strings.HasPrefix(version, \"5.7\") || strings.HasPrefix(version, \"5.6\") {\n\t\t\tgrantStr = fmt.Sprintf(\"%s identified by '%s' with grant option;\", grantStr, req.Password)\n\t\t}\n\t\tif err := excSQL(container, password, grantStr); err != nil {\n\t\t\thandleCreateError(container, password, req.Name, userlist, true)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\nfunc handleCreateError(contaienr, password, dbName string, userlist []string, dropUser bool) {\n\t_ = excSQL(contaienr, password, fmt.Sprintf(\"drop database `%s`\", dbName))\n\tif dropUser {\n\t\tfor _, user := range userlist {\n\t\t\tif err := excSQL(contaienr, password, fmt.Sprintf(\"drop user if exists %s\", user)); err != nil {\n\t\t\t\tglobal.LOG.Errorf(\"drop user failed, err: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc excuteSqlForMaps(containerName, password, command string) (map[string]string, error) {\n\tcmd := exec.Command(\"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn nil, errors.New(stdStr)\n\t}\n\n\trows := strings.Split(stdStr, \"\\n\")\n\trowMap := make(map[string]string)\n\tfor _, v := range rows {\n\t\titemRow := strings.Split(v, \"\\t\")\n\t\tif len(itemRow) == 2 {\n\t\t\trowMap[itemRow[0]] = itemRow[1]\n\t\t}\n\t}\n\treturn rowMap, nil\n}\n\nfunc excuteSqlForRows(containerName, password, command string) ([]string, error) {\n\tcmd := exec.Command(\"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn nil, errors.New(stdStr)\n\t}\n\treturn strings.Split(stdStr, \"\\n\"), nil\n}\n\nfunc excuteSql(containerName, password, command string) error {\n\tcmd := exec.Command(\"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn errors.New(stdStr)\n\t}\n\treturn nil\n}\n\nfunc excSQL(containerName, password, command string) error {\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel()\n\tcmd := exec.CommandContext(ctx, \"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tif ctx.Err() == context.DeadlineExceeded {\n\t\treturn buserr.WithDetail(constant.ErrExecTimeOut, containerName, nil)\n\t}\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn errors.New(stdStr)\n\t}\n\treturn nil\n}\n\nfunc updateMyCnf(oldFiles []string, group string, param string, value interface{}) []string {\n\tisOn := false\n\thasGroup := false\n\thasKey := false\n\tregItem, _ := regexp.Compile(`\\[*\\]`)\n\tvar newFiles []string\n\ti := 0\n\tfor _, line := range oldFiles {\n\t\ti++\n\t\tif strings.HasPrefix(line, group) {\n\t\t\tisOn = true\n\t\t\thasGroup = true\n\t\t\tnewFiles = append(newFiles, line)\n\t\t\tcontinue\n\t\t}\n\t\tif !isOn {\n\t\t\tnewFiles = append(newFiles, line)\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(line, param+\"=\") || strings.HasPrefix(line, \"# \"+param+\"=\") {\n\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s=%v\", param, value))\n\t\t\thasKey = true\n\t\t\tcontinue\n\t\t}\n\t\tif regItem.Match([]byte(line)) || i == len(oldFiles) {\n\t\t\tisOn = false\n\t\t\tif !hasKey {\n\t\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s=%v\", param, value))\n\t\t\t}\n\t\t\tnewFiles = append(newFiles, line)\n\t\t\tcontinue\n\t\t}\n\t\tnewFiles = append(newFiles, line)\n\t}\n\tif !hasGroup {\n\t\tnewFiles = append(newFiles, group+\"\\n\")\n\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s=%v\\n\", param, value))\n\t}\n\treturn newFiles\n}\n", "package service\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/firewall\"\n\tfireClient \"github.com/1Panel-dev/1Panel/backend/utils/firewall/client\"\n\t\"github.com/jinzhu/copier\"\n)\n\nconst confPath = \"/etc/sysctl.conf\"\n\ntype FirewallService struct{}\n\ntype IFirewallService interface {\n\tLoadBaseInfo() (dto.FirewallBaseInfo, error)\n\tSearchWithPage(search dto.RuleSearch) (int64, interface{}, error)\n\tOperateFirewall(operation string) error\n\tOperatePortRule(req dto.PortRuleOperate, reload bool) error\n\tOperateAddressRule(req dto.AddrRuleOperate, reload bool) error\n\tUpdatePortRule(req dto.PortRuleUpdate) error\n\tUpdateAddrRule(req dto.AddrRuleUpdate) error\n\tBatchOperateRule(req dto.BatchRuleOperate) error\n}\n\nfunc NewIFirewallService() IFirewallService {\n\treturn &FirewallService{}\n}\n\nfunc (u *FirewallService) LoadBaseInfo() (dto.FirewallBaseInfo, error) {\n\tvar baseInfo dto.FirewallBaseInfo\n\tbaseInfo.PingStatus = u.pingStatus()\n\tbaseInfo.Status = \"not running\"\n\tbaseInfo.Version = \"-\"\n\tbaseInfo.Name = \"-\"\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\tif err.Error() == \"no such type\" {\n\t\t\treturn baseInfo, nil\n\t\t}\n\t\treturn baseInfo, err\n\t}\n\tbaseInfo.Name = client.Name()\n\tbaseInfo.Status, err = client.Status()\n\tif err != nil {\n\t\treturn baseInfo, err\n\t}\n\tif baseInfo.Status == \"not running\" {\n\t\treturn baseInfo, err\n\t}\n\tbaseInfo.Version, err = client.Version()\n\tif err != nil {\n\t\treturn baseInfo, err\n\t}\n\treturn baseInfo, nil\n}\n\nfunc (u *FirewallService) SearchWithPage(req dto.RuleSearch) (int64, interface{}, error) {\n\tvar (\n\t\tdatas     []fireClient.FireInfo\n\t\tbackDatas []fireClient.FireInfo\n\t)\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tif req.Type == \"port\" {\n\t\tports, err := client.ListPort()\n\t\tif err != nil {\n\t\t\treturn 0, nil, err\n\t\t}\n\t\tif len(req.Info) != 0 {\n\t\t\tfor _, port := range ports {\n\t\t\t\tif strings.Contains(port.Port, req.Info) {\n\t\t\t\t\tdatas = append(datas, port)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdatas = ports\n\t\t}\n\t} else {\n\t\taddrs, err := client.ListAddress()\n\t\tif err != nil {\n\t\t\treturn 0, nil, err\n\t\t}\n\t\tif len(req.Info) != 0 {\n\t\t\tfor _, addr := range addrs {\n\t\t\t\tif strings.Contains(addr.Address, req.Info) {\n\t\t\t\t\tdatas = append(datas, addr)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdatas = addrs\n\t\t}\n\t}\n\ttotal, start, end := len(datas), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\tbackDatas = make([]fireClient.FireInfo, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\tbackDatas = datas[start:end]\n\t}\n\n\tif req.Type == \"port\" {\n\t\tapps := u.loadPortByApp()\n\t\tfor i := 0; i < len(backDatas); i++ {\n\t\t\tport, _ := strconv.Atoi(backDatas[i].Port)\n\t\t\tbackDatas[i].IsUsed = common.ScanPort(port)\n\t\t\tif backDatas[i].Protocol == \"udp\" {\n\t\t\t\tbackDatas[i].IsUsed = common.ScanUDPPort(port)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, app := range apps {\n\t\t\t\tif app.HttpPort == backDatas[i].Port || app.HttpsPort == backDatas[i].Port {\n\t\t\t\t\tbackDatas[i].APPName = app.AppName\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn int64(total), backDatas, nil\n}\n\nfunc (u *FirewallService) OperateFirewall(operation string) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch operation {\n\tcase \"start\":\n\t\tif err := client.Start(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := u.addPortsBeforeStart(client); err != nil {\n\t\t\t_ = client.Stop()\n\t\t\treturn err\n\t\t}\n\t\t_, _ = cmd.Exec(\"systemctl restart docker\")\n\t\treturn nil\n\tcase \"stop\":\n\t\tif err := client.Stop(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, _ = cmd.Exec(\"systemctl restart docker\")\n\t\treturn nil\n\tcase \"disablePing\":\n\t\treturn u.updatePingStatus(\"0\")\n\tcase \"enablePing\":\n\t\treturn u.updatePingStatus(\"1\")\n\t}\n\treturn fmt.Errorf(\"not support such operation: %s\", operation)\n}\n\nfunc (u *FirewallService) OperatePortRule(req dto.PortRuleOperate, reload bool) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif client.Name() == \"ufw\" {\n\t\treq.Port = strings.ReplaceAll(req.Port, \"-\", \":\")\n\t\tif req.Operation == \"remove\" && req.Protocol == \"tcp/udp\" {\n\t\t\treq.Protocol = \"\"\n\t\t\treturn u.operatePort(client, req)\n\t\t}\n\t}\n\tif req.Protocol == \"tcp/udp\" {\n\t\tif client.Name() == \"firewalld\" && strings.Contains(req.Port, \",\") {\n\t\t\tports := strings.Split(req.Port, \",\")\n\t\t\tfor _, port := range ports {\n\t\t\t\tif len(port) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treq.Port = port\n\t\t\t\treq.Protocol = \"tcp\"\n\t\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treq.Protocol = \"udp\"\n\t\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treq.Protocol = \"tcp\"\n\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treq.Protocol = \"udp\"\n\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif strings.Contains(req.Port, \",\") {\n\t\t\tports := strings.Split(req.Port, \",\")\n\t\t\tfor _, port := range ports {\n\t\t\t\treq.Port = port\n\t\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif reload {\n\t\treturn client.Reload()\n\t}\n\treturn nil\n}\n\nfunc (u *FirewallService) OperateAddressRule(req dto.AddrRuleOperate, reload bool) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar fireInfo fireClient.FireInfo\n\tif err := copier.Copy(&fireInfo, &req); err != nil {\n\t\treturn err\n\t}\n\n\taddressList := strings.Split(req.Address, \",\")\n\tfor _, addr := range addressList {\n\t\tif len(addr) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfireInfo.Address = addr\n\t\tif err := client.RichRules(fireInfo, req.Operation); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif reload {\n\t\treturn client.Reload()\n\t}\n\treturn nil\n}\n\nfunc (u *FirewallService) UpdatePortRule(req dto.PortRuleUpdate) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperatePortRule(req.OldRule, false); err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperatePortRule(req.NewRule, false); err != nil {\n\t\treturn err\n\t}\n\treturn client.Reload()\n}\n\nfunc (u *FirewallService) UpdateAddrRule(req dto.AddrRuleUpdate) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperateAddressRule(req.OldRule, false); err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperateAddressRule(req.NewRule, false); err != nil {\n\t\treturn err\n\t}\n\treturn client.Reload()\n}\n\nfunc (u *FirewallService) BatchOperateRule(req dto.BatchRuleOperate) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif req.Type == \"port\" {\n\t\tfor _, rule := range req.Rules {\n\t\t\tif err := u.OperatePortRule(rule, false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn client.Reload()\n\t}\n\tfor _, rule := range req.Rules {\n\t\titemRule := dto.AddrRuleOperate{Operation: rule.Operation, Address: rule.Address, Strategy: rule.Strategy}\n\t\tif err := u.OperateAddressRule(itemRule, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn client.Reload()\n}\n\nfunc OperateFirewallPort(oldPorts, newPorts []int) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, port := range newPorts {\n\n\t\tif err := client.Port(fireClient.FireInfo{Port: strconv.Itoa(port), Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, port := range oldPorts {\n\t\tif err := client.Port(fireClient.FireInfo{Port: strconv.Itoa(port), Protocol: \"tcp\", Strategy: \"accept\"}, \"remove\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn client.Reload()\n}\n\nfunc (u *FirewallService) operatePort(client firewall.FirewallClient, req dto.PortRuleOperate) error {\n\tvar fireInfo fireClient.FireInfo\n\tif err := copier.Copy(&fireInfo, &req); err != nil {\n\t\treturn err\n\t}\n\n\tif client.Name() == \"ufw\" {\n\t\tif len(fireInfo.Address) != 0 && fireInfo.Address != \"Anywhere\" {\n\t\t\treturn client.RichRules(fireInfo, req.Operation)\n\t\t}\n\t\treturn client.Port(fireInfo, req.Operation)\n\t}\n\n\tif len(fireInfo.Address) != 0 || fireInfo.Strategy == \"drop\" {\n\t\treturn client.RichRules(fireInfo, req.Operation)\n\t}\n\treturn client.Port(fireInfo, req.Operation)\n}\n\ntype portOfApp struct {\n\tAppName   string\n\tHttpPort  string\n\tHttpsPort string\n}\n\nfunc (u *FirewallService) loadPortByApp() []portOfApp {\n\tvar datas []portOfApp\n\tapps, err := appInstallRepo.ListBy()\n\tif err != nil {\n\t\treturn datas\n\t}\n\tfor i := 0; i < len(apps); i++ {\n\t\tdatas = append(datas, portOfApp{\n\t\t\tAppName:   apps[i].App.Key,\n\t\t\tHttpPort:  strconv.Itoa(apps[i].HttpPort),\n\t\t\tHttpsPort: strconv.Itoa(apps[i].HttpsPort),\n\t\t})\n\t}\n\tsystemPort, err := settingRepo.Get(settingRepo.WithByKey(\"ServerPort\"))\n\tif err != nil {\n\t\treturn datas\n\t}\n\tdatas = append(datas, portOfApp{AppName: \"1panel\", HttpPort: systemPort.Value})\n\n\treturn datas\n}\n\nfunc (u *FirewallService) pingStatus() string {\n\tif _, err := os.Stat(\"/etc/sysctl.conf\"); err != nil {\n\t\treturn constant.StatusNone\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\tcommand := fmt.Sprintf(\"%s cat /etc/sysctl.conf | grep net/ipv4/icmp_echo_ignore_all= \", sudo)\n\tstdout, _ := cmd.Exec(command)\n\tif stdout == \"net/ipv4/icmp_echo_ignore_all=1\\n\" {\n\t\treturn constant.StatusEnable\n\t}\n\treturn constant.StatusDisable\n}\n\nfunc (u *FirewallService) updatePingStatus(enable string) error {\n\tlineBytes, err := os.ReadFile(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfiles := strings.Split(string(lineBytes), \"\\n\")\n\tvar newFiles []string\n\thasLine := false\n\tfor _, line := range files {\n\t\tif strings.Contains(line, \"net/ipv4/icmp_echo_ignore_all\") || strings.HasPrefix(line, \"net/ipv4/icmp_echo_ignore_all\") {\n\t\t\tnewFiles = append(newFiles, \"net/ipv4/icmp_echo_ignore_all=\"+enable)\n\t\t\thasLine = true\n\t\t} else {\n\t\t\tnewFiles = append(newFiles, line)\n\t\t}\n\t}\n\tif !hasLine {\n\t\tnewFiles = append(newFiles, \"net/ipv4/icmp_echo_ignore_all=\"+enable)\n\t}\n\tfile, err := os.OpenFile(confPath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = file.WriteString(strings.Join(newFiles, \"\\n\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsudo := cmd.SudoHandleCmd()\n\tcommand := fmt.Sprintf(\"%s sysctl -p\", sudo)\n\tstdout, err := cmd.Exec(command)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"update ping status failed, err: %v\", stdout)\n\t}\n\n\treturn nil\n}\n\nfunc (u *FirewallService) addPortsBeforeStart(client firewall.FirewallClient) error {\n\tserverPort, err := settingRepo.Get(settingRepo.WithByKey(\"ServerPort\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: serverPort.Value, Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: \"22\", Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: \"80\", Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: \"443\", Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tapps := u.loadPortByApp()\n\tfor _, app := range apps {\n\t\tif err := client.Port(fireClient.FireInfo{Port: app.HttpPort, Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn client.Reload()\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/pkg/errors\"\n)\n\ntype ImageRepoService struct{}\n\ntype IImageRepoService interface {\n\tPage(search dto.SearchWithPage) (int64, interface{}, error)\n\tList() ([]dto.ImageRepoOption, error)\n\tLogin(req dto.OperateByID) error\n\tCreate(req dto.ImageRepoCreate) error\n\tUpdate(req dto.ImageRepoUpdate) error\n\tBatchDelete(req dto.ImageRepoDelete) error\n}\n\nfunc NewIImageRepoService() IImageRepoService {\n\treturn &ImageRepoService{}\n}\n\nfunc (u *ImageRepoService) Page(req dto.SearchWithPage) (int64, interface{}, error) {\n\ttotal, ops, err := imageRepoRepo.Page(req.Page, req.PageSize, commonRepo.WithLikeName(req.Info), commonRepo.WithOrderBy(\"created_at desc\"))\n\tvar dtoOps []dto.ImageRepoInfo\n\tfor _, op := range ops {\n\t\tvar item dto.ImageRepoInfo\n\t\tif err := copier.Copy(&item, &op); err != nil {\n\t\t\treturn 0, nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t\t}\n\t\tdtoOps = append(dtoOps, item)\n\t}\n\treturn total, dtoOps, err\n}\n\nfunc (u *ImageRepoService) Login(req dto.OperateByID) error {\n\trepo, err := imageRepoRepo.Get(commonRepo.WithByID(req.ID))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif repo.Auth {\n\t\tif err := u.CheckConn(repo.DownloadUrl, repo.Username, repo.Password); err != nil {\n\t\t\t_ = imageRepoRepo.Update(repo.ID, map[string]interface{}{\"status\": constant.StatusFailed, \"message\": err.Error()})\n\t\t\treturn err\n\t\t}\n\t}\n\t_ = imageRepoRepo.Update(repo.ID, map[string]interface{}{\"status\": constant.StatusSuccess})\n\treturn nil\n}\n\nfunc (u *ImageRepoService) List() ([]dto.ImageRepoOption, error) {\n\tops, err := imageRepoRepo.List(commonRepo.WithOrderBy(\"created_at desc\"))\n\tvar dtoOps []dto.ImageRepoOption\n\tfor _, op := range ops {\n\t\tif op.Status == constant.StatusSuccess {\n\t\t\tvar item dto.ImageRepoOption\n\t\t\tif err := copier.Copy(&item, &op); err != nil {\n\t\t\t\treturn nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t\t\t}\n\t\t\tdtoOps = append(dtoOps, item)\n\t\t}\n\t}\n\treturn dtoOps, err\n}\n\nfunc (u *ImageRepoService) Create(req dto.ImageRepoCreate) error {\n\tif cmd.CheckIllegal(req.Username, req.Password, req.DownloadUrl) {\n\t\treturn buserr.New(constant.ErrRepoConn)\n\t}\n\timageRepo, _ := imageRepoRepo.Get(commonRepo.WithByName(req.Name))\n\tif imageRepo.ID != 0 {\n\t\treturn constant.ErrRecordExist\n\t}\n\tif req.Protocol == \"http\" {\n\t\t_ = u.handleRegistries(req.DownloadUrl, \"\", \"create\")\n\t\tstdout, err := cmd.Exec(\"systemctl restart docker\")\n\t\tif err != nil {\n\t\t\treturn errors.New(string(stdout))\n\t\t}\n\t\tticker := time.NewTicker(3 * time.Second)\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*20)\n\t\tif err := func() error {\n\t\t\tfor range ticker.C {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn errors.New(\"the docker service cannot be restarted\")\n\t\t\t\tdefault:\n\t\t\t\t\tstdout, err := cmd.Exec(\"systemctl is-active docker\")\n\t\t\t\t\tif string(stdout) == \"active\\n\" && err == nil {\n\t\t\t\t\t\tglobal.LOG.Info(\"docker restart with new conf successful!\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := copier.Copy(&imageRepo, &req); err != nil {\n\t\treturn errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t}\n\n\timageRepo.Status = constant.StatusSuccess\n\tif req.Auth {\n\t\tif err := u.CheckConn(req.DownloadUrl, req.Username, req.Password); err != nil {\n\t\t\timageRepo.Status = constant.StatusFailed\n\t\t\timageRepo.Message = err.Error()\n\t\t}\n\t}\n\tif err := imageRepoRepo.Create(&imageRepo); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (u *ImageRepoService) BatchDelete(req dto.ImageRepoDelete) error {\n\tfor _, id := range req.Ids {\n\t\tif id == 1 {\n\t\t\treturn errors.New(\"The default value cannot be edit !\")\n\t\t}\n\t}\n\tif err := imageRepoRepo.Delete(commonRepo.WithIdsIn(req.Ids)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (u *ImageRepoService) Update(req dto.ImageRepoUpdate) error {\n\tif req.ID == 1 {\n\t\treturn errors.New(\"The default value cannot be deleted !\")\n\t}\n\tif cmd.CheckIllegal(req.Username, req.Password, req.DownloadUrl) {\n\t\treturn buserr.New(constant.ErrRepoConn)\n\t}\n\trepo, err := imageRepoRepo.Get(commonRepo.WithByID(req.ID))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif repo.DownloadUrl != req.DownloadUrl || (!repo.Auth && req.Auth) {\n\t\t_ = u.handleRegistries(req.DownloadUrl, repo.DownloadUrl, \"update\")\n\t\tif repo.Auth {\n\t\t\t_, _ = cmd.ExecWithCheck(\"docker\", \"logout\", repo.DownloadUrl)\n\t\t}\n\t\tstdout, err := cmd.Exec(\"systemctl restart docker\")\n\t\tif err != nil {\n\t\t\treturn errors.New(string(stdout))\n\t\t}\n\t}\n\n\tupMap := make(map[string]interface{})\n\tupMap[\"download_url\"] = req.DownloadUrl\n\tupMap[\"protocol\"] = req.Protocol\n\tupMap[\"username\"] = req.Username\n\tupMap[\"password\"] = req.Password\n\tupMap[\"auth\"] = req.Auth\n\n\tupMap[\"status\"] = constant.StatusSuccess\n\tupMap[\"message\"] = \"\"\n\tif req.Auth {\n\t\tif err := u.CheckConn(req.DownloadUrl, req.Username, req.Password); err != nil {\n\t\t\tupMap[\"status\"] = constant.StatusFailed\n\t\t\tupMap[\"message\"] = err.Error()\n\t\t}\n\t}\n\treturn imageRepoRepo.Update(req.ID, upMap)\n}\n\nfunc (u *ImageRepoService) CheckConn(host, user, password string) error {\n\tstdout, err := cmd.ExecWithCheck(\"docker\", \"login\", \"-u\", user, \"-p\", password, host)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stdout: %s, stderr: %v\", stdout, err)\n\t}\n\tif strings.Contains(string(stdout), \"Login Succeeded\") {\n\t\treturn nil\n\t}\n\treturn errors.New(string(stdout))\n}\n\nfunc (u *ImageRepoService) handleRegistries(newHost, delHost, handle string) error {\n\tif _, err := os.Stat(constant.DaemonJsonPath); err != nil && os.IsNotExist(err) {\n\t\tif err = os.MkdirAll(path.Dir(constant.DaemonJsonPath), os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, _ = os.Create(constant.DaemonJsonPath)\n\t}\n\n\tdaemonMap := make(map[string]interface{})\n\tfile, err := os.ReadFile(constant.DaemonJsonPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := json.Unmarshal(file, &daemonMap); err != nil {\n\t\treturn err\n\t}\n\n\tiRegistries := daemonMap[\"insecure-registries\"]\n\tregistries, _ := iRegistries.([]interface{})\n\tswitch handle {\n\tcase \"create\":\n\t\tregistries = common.RemoveRepeatElement(append(registries, newHost))\n\tcase \"update\":\n\t\tregistries = common.RemoveRepeatElement(append(registries, newHost))\n\t\tfor i, regi := range registries {\n\t\t\tif regi == delHost {\n\t\t\t\tregistries = append(registries[:i], registries[i+1:]...)\n\t\t\t}\n\t\t}\n\tcase \"delete\":\n\t\tfor i, regi := range registries {\n\t\t\tif regi == delHost {\n\t\t\t\tregistries = append(registries[:i], registries[i+1:]...)\n\t\t\t}\n\t\t}\n\t}\n\tif len(registries) == 0 {\n\t\tdelete(daemonMap, \"insecure-registries\")\n\t} else {\n\t\tdaemonMap[\"insecure-registries\"] = registries\n\t}\n\tnewJson, err := json.MarshalIndent(daemonMap, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.WriteFile(constant.DaemonJsonPath, newJson, 0640); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "package service\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/user\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/files\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/qqwry\"\n)\n\nconst sshPath = \"/etc/ssh/sshd_config\"\n\ntype SSHService struct{}\n\ntype ISSHService interface {\n\tGetSSHInfo() (*dto.SSHInfo, error)\n\tOperateSSH(operation string) error\n\tUpdateByFile(value string) error\n\tUpdate(key, value string) error\n\tGenerateSSH(req dto.GenerateSSH) error\n\tLoadSSHSecret(mode string) (string, error)\n\tLoadLog(req dto.SearchSSHLog) (*dto.SSHLog, error)\n}\n\nfunc NewISSHService() ISSHService {\n\treturn &SSHService{}\n}\n\nfunc (u *SSHService) GetSSHInfo() (*dto.SSHInfo, error) {\n\tdata := dto.SSHInfo{\n\t\tStatus:                 constant.StatusEnable,\n\t\tMessage:                \"\",\n\t\tPort:                   \"22\",\n\t\tListenAddress:          \"0.0.0.0\",\n\t\tPasswordAuthentication: \"yes\",\n\t\tPubkeyAuthentication:   \"yes\",\n\t\tPermitRootLogin:        \"yes\",\n\t\tUseDNS:                 \"yes\",\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\tstdout, err := cmd.Execf(\"%s systemctl status sshd\", sudo)\n\tif err != nil {\n\t\tdata.Message = stdout\n\t\tdata.Status = constant.StatusDisable\n\t}\n\tstdLines := strings.Split(stdout, \"\\n\")\n\tfor _, stdline := range stdLines {\n\t\tif strings.Contains(stdline, \"active (running)\") {\n\t\t\tdata.Status = constant.StatusEnable\n\t\t\tbreak\n\t\t}\n\t}\n\tsshConf, err := os.ReadFile(sshPath)\n\tif err != nil {\n\t\tdata.Message = err.Error()\n\t\tdata.Status = constant.StatusDisable\n\t}\n\tlines := strings.Split(string(sshConf), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.HasPrefix(line, \"Port \") {\n\t\t\tdata.Port = strings.ReplaceAll(line, \"Port \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"ListenAddress \") {\n\t\t\tdata.ListenAddress = strings.ReplaceAll(line, \"ListenAddress \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"PasswordAuthentication \") {\n\t\t\tdata.PasswordAuthentication = strings.ReplaceAll(line, \"PasswordAuthentication \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"PubkeyAuthentication \") {\n\t\t\tdata.PubkeyAuthentication = strings.ReplaceAll(line, \"PubkeyAuthentication \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"PermitRootLogin \") {\n\t\t\tdata.PermitRootLogin = strings.ReplaceAll(line, \"PermitRootLogin \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"UseDNS \") {\n\t\t\tdata.UseDNS = strings.ReplaceAll(line, \"UseDNS \", \"\")\n\t\t}\n\t}\n\treturn &data, nil\n}\n\nfunc (u *SSHService) OperateSSH(operation string) error {\n\tif operation == \"start\" || operation == \"stop\" || operation == \"restart\" {\n\t\tsudo := cmd.SudoHandleCmd()\n\t\tstdout, err := cmd.Execf(\"%s systemctl %s sshd\", sudo, operation)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s sshd failed, stdout: %s, err: %v\", operation, stdout, err)\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"not support such operation: %s\", operation)\n}\n\nfunc (u *SSHService) Update(key, value string) error {\n\tsshConf, err := os.ReadFile(sshPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlines := strings.Split(string(sshConf), \"\\n\")\n\tnewFiles := updateSSHConf(lines, key, value)\n\tif err := settingRepo.Update(key, value); err != nil {\n\t\treturn err\n\t}\n\tfile, err := os.OpenFile(sshPath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tif _, err = file.WriteString(strings.Join(newFiles, \"\\n\")); err != nil {\n\t\treturn err\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\tif key == \"Port\" {\n\t\tstdout, _ := cmd.Execf(\"%s getenforce\", sudo)\n\t\tif stdout == \"Enforcing\\n\" {\n\t\t\t_, _ = cmd.Execf(\"%s semanage port -a -t ssh_port_t -p tcp %s\", sudo, value)\n\t\t}\n\t}\n\t_, _ = cmd.Execf(\"%s systemctl restart sshd\", sudo)\n\treturn nil\n}\n\nfunc (u *SSHService) UpdateByFile(value string) error {\n\tfile, err := os.OpenFile(sshPath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tif _, err = file.WriteString(value); err != nil {\n\t\treturn err\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\t_, _ = cmd.Execf(\"%s systemctl restart sshd\", sudo)\n\treturn nil\n}\n\nfunc (u *SSHService) GenerateSSH(req dto.GenerateSSH) error {\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"load current user failed, err: %v\", err)\n\t}\n\tsecretFile := fmt.Sprintf(\"%s/.ssh/id_item_%s\", currentUser.HomeDir, req.EncryptionMode)\n\tsecretPubFile := fmt.Sprintf(\"%s/.ssh/id_item_%s.pub\", currentUser.HomeDir, req.EncryptionMode)\n\tauthFile := currentUser.HomeDir + \"/.ssh/authorized_keys\"\n\n\tcommand := fmt.Sprintf(\"ssh-keygen -t %s -f %s/.ssh/id_item_%s | echo y\", req.EncryptionMode, currentUser.HomeDir, req.EncryptionMode)\n\tif len(req.Password) != 0 {\n\t\tcommand = fmt.Sprintf(\"ssh-keygen -t %s -P %s -f %s/.ssh/id_item_%s | echo y\", req.EncryptionMode, req.Password, currentUser.HomeDir, req.EncryptionMode)\n\t}\n\tstdout, err := cmd.Exec(command)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"generate failed, err: %v, message: %s\", err, stdout)\n\t}\n\tdefer func() {\n\t\t_ = os.Remove(secretFile)\n\t}()\n\tdefer func() {\n\t\t_ = os.Remove(secretPubFile)\n\t}()\n\n\tif _, err := os.Stat(authFile); err != nil {\n\t\t_, _ = os.Create(authFile)\n\t}\n\tstdout1, err := cmd.Execf(\"cat %s >> %s/.ssh/authorized_keys\", secretPubFile, currentUser.HomeDir)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"generate failed, err: %v, message: %s\", err, stdout1)\n\t}\n\n\tfileOp := files.NewFileOp()\n\tif err := fileOp.Rename(secretFile, fmt.Sprintf(\"%s/.ssh/id_%s\", currentUser.HomeDir, req.EncryptionMode)); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.Rename(secretPubFile, fmt.Sprintf(\"%s/.ssh/id_%s.pub\", currentUser.HomeDir, req.EncryptionMode)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (u *SSHService) LoadSSHSecret(mode string) (string, error) {\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"load current user failed, err: %v\", err)\n\t}\n\n\thomeDir := currentUser.HomeDir\n\tif _, err := os.Stat(fmt.Sprintf(\"%s/.ssh/id_%s\", homeDir, mode)); err != nil {\n\t\treturn \"\", nil\n\t}\n\tfile, err := os.ReadFile(fmt.Sprintf(\"%s/.ssh/id_%s\", homeDir, mode))\n\treturn string(file), err\n}\n\nfunc (u *SSHService) LoadLog(req dto.SearchSSHLog) (*dto.SSHLog, error) {\n\tvar fileList []string\n\tvar data dto.SSHLog\n\tbaseDir := \"/var/log\"\n\tif err := filepath.Walk(baseDir, func(pathItem string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() && strings.HasPrefix(info.Name(), \"secure\") || strings.HasPrefix(info.Name(), \"auth\") {\n\t\t\tif strings.HasSuffix(info.Name(), \".gz\") {\n\t\t\t\tif err := handleGunzip(pathItem); err == nil {\n\t\t\t\t\tfileList = append(fileList, strings.ReplaceAll(pathItem, \".gz\", \"\"))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfileList = append(fileList, pathItem)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\tfileList = sortFileList(fileList)\n\n\tcommand := \"\"\n\tif len(req.Info) != 0 {\n\t\tcommand = fmt.Sprintf(\" | grep '%s'\", req.Info)\n\t}\n\n\tfor i := 0; i < len(fileList); i++ {\n\t\twithAppend := len(data.Logs) < req.Page*req.PageSize\n\t\tif req.Status != constant.StatusSuccess {\n\t\t\tif strings.HasPrefix(path.Base(fileList[i]), \"secure\") {\n\t\t\t\tcommandItem := fmt.Sprintf(\"cat %s | grep -a 'Failed password for' | grep -v 'invalid' %s\", fileList[i], command)\n\t\t\t\tdataItem, itemTotal := loadFailedSecureDatas(commandItem, withAppend)\n\t\t\t\tdata.FailedCount += itemTotal\n\t\t\t\tdata.TotalCount += itemTotal\n\t\t\t\tdata.Logs = append(data.Logs, dataItem...)\n\t\t\t}\n\t\t\tif strings.HasPrefix(path.Base(fileList[i]), \"auth.log\") {\n\t\t\t\tcommandItem := fmt.Sprintf(\"cat %s | grep -a 'Connection closed by authenticating user' | grep -a 'preauth' %s\", fileList[i], command)\n\t\t\t\tdataItem, itemTotal := loadFailedAuthDatas(commandItem, withAppend)\n\t\t\t\tdata.FailedCount += itemTotal\n\t\t\t\tdata.TotalCount += itemTotal\n\t\t\t\tdata.Logs = append(data.Logs, dataItem...)\n\t\t\t}\n\t\t}\n\t\tif req.Status != constant.StatusFailed {\n\t\t\tcommandItem := fmt.Sprintf(\"cat %s | grep -a Accepted %s\", fileList[i], command)\n\t\t\tdataItem, itemTotal := loadSuccessDatas(commandItem, withAppend)\n\t\t\tdata.TotalCount += itemTotal\n\t\t\tdata.Logs = append(data.Logs, dataItem...)\n\t\t}\n\t}\n\tdata.SuccessfulCount = data.TotalCount - data.FailedCount\n\tif len(data.Logs) < 1 {\n\t\treturn nil, nil\n\t}\n\n\tvar itemDatas []dto.SSHHistory\n\ttotal, start, end := len(data.Logs), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\titemDatas = make([]dto.SSHHistory, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\titemDatas = data.Logs[start:end]\n\t}\n\tdata.Logs = itemDatas\n\n\ttimeNow := time.Now()\n\tnyc, _ := time.LoadLocation(common.LoadTimeZone())\n\tqqWry, err := qqwry.NewQQwry()\n\tif err != nil {\n\t\tglobal.LOG.Errorf(\"load qqwry datas failed: %s\", err)\n\t}\n\tvar itemLogs []dto.SSHHistory\n\tfor i := 0; i < len(data.Logs); i++ {\n\t\tdata.Logs[i].Area = qqWry.Find(data.Logs[i].Address).Area\n\t\tdata.Logs[i].Date, _ = time.ParseInLocation(\"2006 Jan 2 15:04:05\", fmt.Sprintf(\"%d %s\", timeNow.Year(), data.Logs[i].DateStr), nyc)\n\t\titemLogs = append(itemLogs, data.Logs[i])\n\t}\n\tdata.Logs = itemLogs\n\n\treturn &data, nil\n}\n\nfunc sortFileList(fileNames []string) []string {\n\tif len(fileNames) < 2 {\n\t\treturn fileNames\n\t}\n\tif strings.HasPrefix(path.Base(fileNames[0]), \"secure\") {\n\t\tvar itemFile []string\n\t\tsort.Slice(fileNames, func(i, j int) bool {\n\t\t\treturn fileNames[i] > fileNames[j]\n\t\t})\n\t\titemFile = append(itemFile, fileNames[len(fileNames)-1])\n\t\titemFile = append(itemFile, fileNames[:len(fileNames)-2]...)\n\t\treturn itemFile\n\t}\n\tsort.Slice(fileNames, func(i, j int) bool {\n\t\treturn fileNames[i] < fileNames[j]\n\t})\n\treturn fileNames\n}\n\nfunc updateSSHConf(oldFiles []string, param string, value interface{}) []string {\n\thasKey := false\n\tvar newFiles []string\n\tfor _, line := range oldFiles {\n\t\tif strings.HasPrefix(line, param+\" \") {\n\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s %v\", param, value))\n\t\t\thasKey = true\n\t\t\tcontinue\n\t\t}\n\t\tnewFiles = append(newFiles, line)\n\t}\n\tif !hasKey {\n\t\tnewFiles = []string{}\n\t\tfor _, line := range oldFiles {\n\t\t\tif strings.HasPrefix(line, fmt.Sprintf(\"#%s \", param)) && !hasKey {\n\t\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s %v\", param, value))\n\t\t\t\thasKey = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewFiles = append(newFiles, line)\n\t\t}\n\t}\n\tif !hasKey {\n\t\tnewFiles = []string{}\n\t\tnewFiles = append(newFiles, oldFiles...)\n\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s %v\", param, value))\n\t}\n\treturn newFiles\n}\n\nfunc loadSuccessDatas(command string, withAppend bool) ([]dto.SSHHistory, int) {\n\tvar (\n\t\tdatas    []dto.SSHHistory\n\t\ttotalNum int\n\t)\n\tstdout2, err := cmd.Exec(command)\n\tif err == nil {\n\t\tlines := strings.Split(string(stdout2), \"\\n\")\n\t\tif len(lines) == 0 {\n\t\t\treturn datas, 0\n\t\t}\n\t\tfor i := len(lines) - 1; i >= 0; i-- {\n\t\t\tparts := strings.Fields(lines[i])\n\t\t\tif len(parts) < 14 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotalNum++\n\t\t\tif withAppend {\n\t\t\t\thistoryItem := dto.SSHHistory{\n\t\t\t\t\tDateStr:  fmt.Sprintf(\"%s %s %s\", parts[0], parts[1], parts[2]),\n\t\t\t\t\tAuthMode: parts[6],\n\t\t\t\t\tUser:     parts[8],\n\t\t\t\t\tAddress:  parts[10],\n\t\t\t\t\tPort:     parts[12],\n\t\t\t\t\tStatus:   constant.StatusSuccess,\n\t\t\t\t}\n\t\t\t\tdatas = append(datas, historyItem)\n\t\t\t}\n\t\t}\n\t}\n\treturn datas, totalNum\n}\n\nfunc loadFailedAuthDatas(command string, withAppend bool) ([]dto.SSHHistory, int) {\n\tvar (\n\t\tdatas    []dto.SSHHistory\n\t\ttotalNum int\n\t)\n\tstdout2, err := cmd.Exec(command)\n\tif err == nil {\n\t\tlines := strings.Split(string(stdout2), \"\\n\")\n\t\tif len(lines) == 0 {\n\t\t\treturn datas, 0\n\t\t}\n\t\tfor i := len(lines) - 1; i >= 0; i-- {\n\t\t\tparts := strings.Fields(lines[i])\n\t\t\tif len(parts) < 14 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotalNum++\n\t\t\tif withAppend {\n\t\t\t\thistoryItem := dto.SSHHistory{\n\t\t\t\t\tDateStr:  fmt.Sprintf(\"%s %s %s\", parts[0], parts[1], parts[2]),\n\t\t\t\t\tAuthMode: parts[8],\n\t\t\t\t\tUser:     parts[10],\n\t\t\t\t\tAddress:  parts[11],\n\t\t\t\t\tPort:     parts[13],\n\t\t\t\t\tStatus:   constant.StatusFailed,\n\t\t\t\t}\n\t\t\t\tif strings.Contains(lines[i], \": \") {\n\t\t\t\t\thistoryItem.Message = strings.Split(lines[i], \": \")[1]\n\t\t\t\t}\n\t\t\t\tdatas = append(datas, historyItem)\n\t\t\t}\n\t\t}\n\t}\n\treturn datas, totalNum\n}\n\nfunc loadFailedSecureDatas(command string, withAppend bool) ([]dto.SSHHistory, int) {\n\tvar (\n\t\tdatas    []dto.SSHHistory\n\t\ttotalNum int\n\t)\n\tstdout2, err := cmd.Exec(command)\n\tif err == nil {\n\t\tlines := strings.Split(string(stdout2), \"\\n\")\n\t\tif len(lines) == 0 {\n\t\t\treturn datas, 0\n\t\t}\n\t\tfor i := len(lines) - 1; i >= 0; i-- {\n\t\t\tparts := strings.Fields(lines[i])\n\t\t\tif len(parts) < 14 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotalNum++\n\t\t\tif withAppend {\n\t\t\t\thistoryItem := dto.SSHHistory{\n\t\t\t\t\tDateStr:  fmt.Sprintf(\"%s %s %s\", parts[0], parts[1], parts[2]),\n\t\t\t\t\tAuthMode: parts[6],\n\t\t\t\t\tUser:     parts[8],\n\t\t\t\t\tAddress:  parts[10],\n\t\t\t\t\tPort:     parts[12],\n\t\t\t\t\tStatus:   constant.StatusFailed,\n\t\t\t\t}\n\t\t\t\tif strings.Contains(lines[i], \": \") {\n\t\t\t\t\thistoryItem.Message = strings.Split(lines[i], \": \")[1]\n\t\t\t\t}\n\t\t\t\tdatas = append(datas, historyItem)\n\t\t\t}\n\t\t}\n\t}\n\treturn datas, totalNum\n}\n\nfunc handleGunzip(path string) error {\n\tif _, err := cmd.Execf(\"gunzip %s\", path); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "package constant\n\nimport (\n\t\"errors\"\n)\n\nconst (\n\tCodeSuccess           = 200\n\tCodeErrBadRequest     = 400\n\tCodeErrUnauthorized   = 401\n\tCodeErrUnSafety       = 402\n\tCodeErrForbidden      = 403\n\tCodeErrNotFound       = 404\n\tCodePasswordExpired   = 405\n\tCodeAuth              = 406\n\tCodeGlobalLoading     = 407\n\tCodeErrIP             = 408\n\tCodeErrDomain         = 409\n\tCodeErrInternalServer = 500\n\tCodeErrHeader         = 406\n)\n\n// internal\nvar (\n\tErrCaptchaCode     = errors.New(\"ErrCaptchaCode\")\n\tErrAuth            = errors.New(\"ErrAuth\")\n\tErrRecordExist     = errors.New(\"ErrRecordExist\")\n\tErrRecordNotFound  = errors.New(\"ErrRecordNotFound\")\n\tErrStructTransform = errors.New(\"ErrStructTransform\")\n\tErrInitialPassword = errors.New(\"ErrInitialPassword\")\n\tErrNotSupportType  = errors.New(\"ErrNotSupportType\")\n\tErrInvalidParams   = errors.New(\"ErrInvalidParams\")\n\n\tErrTokenParse = errors.New(\"ErrTokenParse\")\n)\n\n// api\nvar (\n\tErrTypeInternalServer  = \"ErrInternalServer\"\n\tErrTypeInvalidParams   = \"ErrInvalidParams\"\n\tErrTypeNotLogin        = \"ErrNotLogin\"\n\tErrTypePasswordExpired = \"ErrPasswordExpired\"\n\tErrNameIsExist         = \"ErrNameIsExist\"\n\tErrDemoEnvironment     = \"ErrDemoEnvironment\"\n)\n\n// app\nvar (\n\tErrPortInUsed          = \"ErrPortInUsed\"\n\tErrAppLimit            = \"ErrAppLimit\"\n\tErrFileToLarge         = \"ErrFileToLarge\"\n\tErrFileCanNotRead      = \"ErrFileCanNotRead\"\n\tErrNotInstall          = \"ErrNotInstall\"\n\tErrPortInOtherApp      = \"ErrPortInOtherApp\"\n\tErrDbUserNotValid      = \"ErrDbUserNotValid\"\n\tErrUpdateBuWebsite     = \"ErrUpdateBuWebsite\"\n\tErr1PanelNetworkFailed = \"Err1PanelNetworkFailed\"\n\tErrCmdTimeout          = \"ErrCmdTimeout\"\n\tErrFileParse           = \"ErrFileParse\"\n\tErrInstallDirNotFound  = \"ErrInstallDirNotFound\"\n\tErrContainerName       = \"ErrContainerName\"\n)\n\n// website\nvar (\n\tErrDomainIsExist      = \"ErrDomainIsExist\"\n\tErrAliasIsExist       = \"ErrAliasIsExist\"\n\tErrGroupIsUsed        = \"ErrGroupIsUsed\"\n\tErrUsernameIsExist    = \"ErrUsernameIsExist\"\n\tErrUsernameIsNotExist = \"ErrUsernameIsNotExist\"\n\tErrBackupMatch        = \"ErrBackupMatch\"\n\tErrBackupExist        = \"ErrBackupExist\"\n)\n\n// ssl\nvar (\n\tErrSSLCannotDelete     = \"ErrSSLCannotDelete\"\n\tErrAccountCannotDelete = \"ErrAccountCannotDelete\"\n\tErrSSLApply            = \"ErrSSLApply\"\n\tErrEmailIsExist        = \"ErrEmailIsExist\"\n)\n\n// file\nvar (\n\tErrPathNotFound     = \"ErrPathNotFound\"\n\tErrMovePathFailed   = \"ErrMovePathFailed\"\n\tErrLinkPathNotFound = \"ErrLinkPathNotFound\"\n\tErrFileIsExit       = \"ErrFileIsExit\"\n\tErrFileUpload       = \"ErrFileUpload\"\n\tErrFileDownloadDir  = \"ErrFileDownloadDir\"\n)\n\n// mysql\nvar (\n\tErrUserIsExist     = \"ErrUserIsExist\"\n\tErrDatabaseIsExist = \"ErrDatabaseIsExist\"\n\tErrExecTimeOut     = \"ErrExecTimeOut\"\n)\n\n// redis\nvar (\n\tErrTypeOfRedis = \"ErrTypeOfRedis\"\n)\n\n// container\nvar (\n\tErrInUsed       = \"ErrInUsed\"\n\tErrObjectInUsed = \"ErrObjectInUsed\"\n\tErrPortRules    = \"ErrPortRules\"\n\tErrRepoConn     = \"ErrRepoConn\"\n)\n\n// runtime\nvar (\n\tErrDirNotFound    = \"ErrDirNotFound\"\n\tErrFileNotExist   = \"ErrFileNotExist\"\n\tErrImageBuildErr  = \"ErrImageBuildErr\"\n\tErrImageExist     = \"ErrImageExist\"\n\tErrDelWithWebsite = \"ErrDelWithWebsite\"\n)\n\nvar (\n\tErrBackupInUsed = \"ErrBackupInUsed\"\n\tErrOSSConn      = \"ErrOSSConn\"\n)\n", "ErrInvalidParams: \"Request parameter error: {{ .detail }}\"\nErrTokenParse: \"Token generation error: {{ .detail }}\"\nErrInitialPassword: \"Initial password error\"\nErrInternalServer: \"Service internal error: {{ .detail }}\"\nErrRecordExist: \"Record already exists\"\nErrRecordNotFound: \"Records not found\"\nErrStructTransform: \"Type conversion failure: {{ .detail }}\"\nErrNotLogin: \"User is not Login: {{ .detail }}\"\nErrPasswordExpired: \"The current password has expired: {{ .detail }}\"\nErrNotSupportType: \"The system does not support the current type: {{ .detail }}\"\n\n#common\nErrNameIsExist: \"Name is already exist\"\nErrDemoEnvironment: \"Demo server, prohibit this operation!\"\nErrCmdTimeout: \"Command execution timed out\uff01\"\n\n#app\nErrPortInUsed: \"{{ .detail }} port already in use\"\nErrAppLimit: \"App exceeds install limit\"\nErrAppRequired: \"{{ .detail }} app is required\"\nErrNotInstall: \"App not installed\"\nErrPortInOtherApp: \"{{ .port }} port  already in use by  {{ .apps }}\"\nErrDbUserNotValid: \"Stock database, username and password do not match\uff01\"\nErrDockerComposeNotValid: \"docker-compose file format error!\"\nErrUpdateBuWebsite: 'The application was updated successfully, but the modification of the website configuration file failed, please check the configuration!'\nErr1PanelNetworkFailed: 'Default container network creation failed! {{ .detail }}'\nErrFileParse: 'Application docker-compose file parsing failed!'\nErrInstallDirNotFound: 'installation directory does not exist'\nAppStoreIsUpToDate: 'The app store is already up to date\uff01'\nLocalAppVersionNull: 'The {{.name}} app is not synced to version! Could not add to application list'\nLocalAppVersionErr: '{{.name}} failed to sync version {{.version}}! {{.err}}'\nErrFileNotFound: '{{.name}} file does not exist'\nErrFileParseApp: 'Failed to parse {{.name}} file {{.err}}'\nErrAppDirNull: 'version folder does not exist'\nLocalAppErr: \"App {{.name}} sync failed! {{.err}}\"\nErrContainerName: \"ContainerName is already exist\"\nErrAppSystemRestart: \"1Panel restart causes the task to terminate\"\nErrCreateHttpClient: \"Failed to create HTTP request {{.err}}\"\nErrHttpReqTimeOut: \"Request timed out {{.err}}\"\nErrHttpReqFailed: \"Request failed {{.err}}\"\nErrHttpReqNotFound: \"The file does not exist\"\nErrNoSuchHost: \"Network connection failed\"\nErrImagePullTimeOut: 'Image pull timeout'\nErrContainerNotFound: '{{ .name }} container does not exist'\nErrContainerMsg: '{{ .name }} container is abnormal, please check the log on the container page for details'\n\n#file\nErrFileCanNotRead: \"File can not read\"\nErrFileToLarge: \"file is too large\"\nErrPathNotFound: \"Path is not found\"\nErrMovePathFailed: \"The target path cannot contain the original path!\"\nErrLinkPathNotFound: \"Target path does not exist!\"\nErrFileIsExit: \"File already exists!\"\nErrFileUpload: \"Failed to upload file {{.name}}  {{.detail}}\"\nErrFileDownloadDir: \"Download folder not supported\"\n\n#website\nErrDomainIsExist: \"Domain is already exist\"\nErrAliasIsExist: \"Alias is already exist\"\nErrAppDelete: 'Other Website use this App'\nErrGroupIsUsed: 'The group is in use and cannot be deleted'\nErrBackupMatch: 'the backup file does not match the current partial data of the website: {{ .detail}}\"'\nErrBackupExist: 'the backup file corresponds to a portion of the original data that does not exist: {{ .detail}}\"'\n\n#ssl\nErrSSLCannotDelete: \"The certificate is being used by the website and cannot be removed\"\nErrAccountCannotDelete: \"The certificate associated with the account cannot be deleted\"\nErrSSLApply: \"The certificate continues to be signed successfully, but openresty reload fails, please check the configuration\uff01\"\nErrEmailIsExist: 'Email is already exist'\nErrSSLKeyNotFound: 'The private key file does not exist'\nErrSSLCertificateNotFound: 'The certificate file does not exist'\nErrSSLKeyFormat: 'Private key file verification error'\nErrSSLCertificateFormat: 'Certificate file format error, please use pem format'\n\n#mysql\nErrUserIsExist: \"The current user already exists. Please enter a new user\"\nErrDatabaseIsExist: \"The current database already exists. Please enter a new database\"\nErrExecTimeOut: \"SQL execution timed out, please check the {{ .detail }} container\"\n\n#redis\nErrTypeOfRedis: \"The recovery file type does not match the current persistence mode. Modify the file type and try again\"\n\n#container \nErrInUsed: \"{{ .detail }} is in use and cannot be deleted\"\nErrObjectInUsed: \"This object is in use and cannot be deleted\"\nErrRepoConn: \"The repository information contains illegal characters\"\nErrPortRules: \"The number of ports does not match, please re-enter!\"\n\n#runtime\nErrDirNotFound: \"The build folder does not exist! Please check file integrity\uff01\"\nErrFileNotExist: \"{{ .detail }} file does not exist! Please check source file integrity\uff01\"\nErrImageBuildErr: \"Image build failed\"\nErrImageExist: \"Image is already exist\uff01\"\nErrDelWithWebsite: \"The operating environment has been associated with a website and cannot be deleted\"\n\n#setting\nErrBackupInUsed: \"The backup account is already being used in a cronjob and cannot be deleted.\"\n\nErrOSSConn: \"Unable to successfully request the latest version. Please check if the server can connect to the external network environment.\"", "ErrInvalidParams: \"\u8acb\u6c42\u53c3\u6578\u932f\u8aa4: {{ .detail }}\"\nErrTokenParse: \"Token \u7522\u751f\u932f\u8aa4: {{ .detail }}\"\nErrInitialPassword: \"\u539f\u5bc6\u78bc\u932f\u8aa4\"\nErrInternalServer: \"\u4f3a\u670d\u5668\u5167\u90e8\u932f\u8aa4: {{ .detail }}\"\nErrRecordExist: \"\u8a18\u9304\u5df2\u5b58\u5728\"\nErrRecordNotFound: \"\u8a18\u9304\u672a\u627e\u5230\"\nErrStructTransform: \"\u985e\u578b\u8f49\u63db\u5931\u6557: {{ .detail }}\"\nErrNotLogin: \"\u7528\u6236\u672a\u767b\u5165: {{ .detail }}\"\nErrPasswordExpired: \"\u7576\u524d\u5bc6\u78bc\u5df2\u904e\u671f: {{ .detail }}\"\nErrNotSupportType: \"\u7cfb\u7d71\u66ab\u4e0d\u652f\u6301\u7576\u524d\u985e\u578b: {{ .detail }}\"\n\n#common\nErrNameIsExist: \"\u540d\u7a31\u5df2\u5b58\u5728\"\nErrDemoEnvironment: \"\u6f14\u793a\u4f3a\u670d\u5668\uff0c\u7981\u6b62\u6b64\u64cd\u4f5c!\"\nErrCmdTimeout: \"\u6307\u4ee4\u57f7\u884c\u8d85\u6642\uff01\"\n\n#app\nErrPortInUsed: \"{{ .detail }} \u7aef\u53e3\u5df2\u88ab\u4f54\u7528\uff01\"\nErrAppLimit: \"\u61c9\u7528\u8d85\u51fa\u5b89\u88dd\u6578\u91cf\u9650\u5236\"\nErrAppRequired: \"\u8acb\u5148\u5b89\u88dd {{ .detail }} \u61c9\u7528\"\nErrNotInstall: \"\u61c9\u7528\u672a\u5b89\u88dd\"\nErrPortInOtherApp: \"{{ .port }} \u7aef\u53e3\u5df2\u88ab {{ .apps }}\u4f54\u7528\uff01\"\nErrDbUserNotValid: \"\u5132\u5b58\u8cc7\u6599\u5eab\uff0c\u7528\u6236\u540d\u5bc6\u78bc\u4e0d\u5339\u914d\uff01\"\nErrDockerComposeNotValid: \"docker-compose \u6587\u4ef6\u683c\u5f0f\u932f\u8aa4\"\nErrUpdateBuWebsite: '\u61c9\u7528\u66f4\u65b0\u6210\u529f\uff0c\u4f46\u662f\u7db2\u7ad9\u914d\u7f6e\u6587\u4ef6\u4fee\u6539\u5931\u6557\uff0c\u8acb\u6aa2\u67e5\u914d\u7f6e\uff01'\nErr1PanelNetworkFailed: '\u9ed8\u8a8d\u5bb9\u5668\u7db2\u7d61\u5275\u5efa\u5931\u6557\uff01{{ .detail }}'\nErrFileParse: '\u61c9\u7528 docker-compose \u6587\u4ef6\u89e3\u6790\u5931\u6557!'\nErrInstallDirNotFound: '\u5b89\u88dd\u76ee\u9304\u4e0d\u5b58\u5728'\nAppStoreIsUpToDate: '\u61c9\u7528\u5546\u5e97\u5df2\u7d93\u662f\u6700\u65b0\u7248\u672c'\nLocalAppVersionNull: '{{.name}} \u61c9\u7528\u672a\u540c\u6b65\u5230\u7248\u672c\uff01\u7121\u6cd5\u6dfb\u52a0\u5230\u61c9\u7528\u5217\u8868'\nLocalAppVersionErr: '{{.name}} \u540c\u6b65\u7248\u672c {{.version}} \u5931\u6557\uff01{{.err}}'\nErrFileNotFound: '{{.name}} \u6587\u4ef6\u4e0d\u5b58\u5728'\nErrFileParseApp: '{{.name}} \u6587\u4ef6\u89e3\u6790\u5931\u6557 {{.err}}'\nErrAppDirNull: '\u7248\u672c\u8cc7\u6599\u593e\u4e0d\u5b58\u5728'\nLocalAppErr: \"\u61c9\u7528 {{.name}} \u540c\u6b65\u5931\u6557\uff01{{.err}}\"\nErrContainerName: \"\u5bb9\u5668\u540d\u7a31\u5df2\u5b58\u5728\"\nErrAppSystemRestart: \"1Panel \u91cd\u555f\u5c0e\u81f4\u4efb\u52d9\u4e2d\u65b7\"\nErrCreateHttpClient: \"\u5275\u5efaHTTP\u8acb\u6c42\u5931\u6557 {{.err}}\"\nErrHttpReqTimeOut: \"\u8acb\u6c42\u8d85\u6642 {{.err}}\"\nErrHttpReqFailed: \"\u8acb\u6c42\u5931\u6557 {{.err}}\"\nErrHttpReqNotFound: \"\u6587\u4ef6\u4e0d\u5b58\u5728\"\nErrNoSuchHost: \"\u7db2\u8def\u9023\u63a5\u5931\u6557\"\nErrImagePullTimeOut: \"\u93e1\u50cf\u62c9\u53d6\u8d85\u6642\"\nErrContainerNotFound: '{{ .name }} \u5bb9\u5668\u4e0d\u5b58\u5728'\nErrContainerMsg: '{{ .name }} \u5bb9\u5668\u7570\u5e38\uff0c\u5177\u9ad4\u8acb\u5728\u5bb9\u5668\u9801\u9762\u67e5\u770b\u65e5\u8a8c'\n\n#file\nErrFileCanNotRead: \"\u6b64\u6587\u4ef6\u4e0d\u652f\u6301\u9810\u89bd\"\nErrFileToLarge: \"\u6587\u4ef6\u8d85\u904e10M,\u7121\u6cd5\u6253\u958b\"\nErrPathNotFound: \"\u76ee\u9304\u4e0d\u5b58\u5728\"\nErrMovePathFailed: \"\u76ee\u6a19\u8def\u5f91\u4e0d\u80fd\u5305\u542b\u539f\u8def\u5f91\uff01\"\nErrLinkPathNotFound: \"\u76ee\u6a19\u8def\u5f91\u4e0d\u5b58\u5728!\"\nErrFileIsExit: \"\u6587\u4ef6\u5df2\u5b58\u5728\uff01\"\nErrFileUpload: \"{{ .name }} \u4e0a\u50b3\u6587\u4ef6\u5931\u6557 {{ .detail}}\"\nErrFileDownloadDir: \"\u4e0d\u652f\u6301\u4e0b\u8f09\u6587\u4ef6\u593e\"\n\n#website\nErrDomainIsExist: \"\u57df\u540d\u5df2\u5b58\u5728\"\nErrAliasIsExist: \"\u4ee3\u865f\u5df2\u5b58\u5728\"\nErrAppDelete: '\u5176\u4ed6\u7db2\u7ad9\u4f7f\u7528\u6b64\u61c9\u7528,\u7121\u6cd5\u522a\u9664'\nErrGroupIsUsed: '\u5206\u7d44\u6b63\u5728\u4f7f\u7528\u4e2d\uff0c\u7121\u6cd5\u522a\u9664'\nErrBackupMatch: '\u8a72\u5099\u4efd\u6587\u4ef6\u8207\u7576\u524d\u7db2\u7ad9\u90e8\u5206\u6578\u64da\u4e0d\u5339\u914d: {{ .detail}}\"'\nErrBackupExist: '\u8a72\u5099\u4efd\u6587\u4ef6\u5c0d\u61c9\u90e8\u5206\u539f\u6578\u64da\u4e0d\u5b58\u5728: {{ .detail}}\"'\n\n#ssl\nErrSSLCannotDelete: \"\u8b49\u66f8\u6b63\u5728\u88ab\u7db2\u7ad9\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\nErrAccountCannotDelete: \"\u5e33\u865f\u95dc\u806f\u8b49\u66f8\uff0c\u7121\u6cd5\u522a\u9664\"\nErrSSLApply: \"\u8b49\u66f8\u7e8c\u7c3d\u6210\u529f\uff0copenresty reload\u5931\u6557\uff0c\u8acb\u6aa2\u67e5\u914d\u7f6e\uff01\"\nErrEmailIsExist: '\u90f5\u7bb1\u5df2\u5b58\u5728'\nErrSSLKeyNotFound: '\u79c1\u9470\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLCertificateNotFound: '\u8b49\u66f8\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLKeyFormat: '\u79c1\u9470\u6587\u4ef6\u6821\u9a57\u932f\u8aa4'\nErrSSLCertificateFormat: '\u8b49\u66f8\u6587\u4ef6\u683c\u5f0f\u932f\u8aa4\uff0c\u8acb\u4f7f\u7528 pem \u683c\u5f0f'\n\n#mysql\nErrUserIsExist: \"\u7576\u524d\u7528\u6236\u5df2\u5b58\u5728\uff0c\u8acb\u91cd\u65b0\u8f38\u5165\"\nErrDatabaseIsExist: \"\u7576\u524d\u8cc7\u6599\u5eab\u5df2\u5b58\u5728\uff0c\u8acb\u91cd\u65b0\u8f38\u5165\"\nErrExecTimeOut: \"SQL \u57f7\u884c\u8d85\u6642\uff0c\u8acb\u6aa2\u67e5{{ .detail }}\u5bb9\u5668\"\n\n#redis\nErrTypeOfRedis: \"\u6062\u5fa9\u6587\u4ef6\u985e\u578b\u8207\u7576\u524d\u6301\u4e45\u5316\u65b9\u5f0f\u4e0d\u7b26\uff0c\u8acb\u4fee\u6539\u5f8c\u91cd\u8a66\"\n\n#container\nErrInUsed: \"{{ .detail }} \u6b63\u88ab\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\nErrObjectInUsed: \"\u8a72\u5c0d\u8c61\u6b63\u88ab\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\nErrRepoConn: \"\u5009\u5eab\u8cc7\u8a0a\u4e2d\u5b58\u5728\u4e0d\u5408\u6cd5\u7684\u5b57\u7b26\"\nErrPortRules: \"\u7aef\u53e3\u6578\u76ee\u4e0d\u5339\u914d\uff0c\u8acb\u91cd\u65b0\u8f38\u5165\uff01\"\n\n#runtime\nErrDirNotFound: \"build \u6587\u4ef6\u593e\u4e0d\u5b58\u5728\uff01\u8acb\u6aa2\u67e5\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrFileNotExist: \"{{ .detail }} \u6587\u4ef6\u4e0d\u5b58\u5728\uff01\u8acb\u6aa2\u67e5\u6e90\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrImageBuildErr: \"\u93e1\u50cf build \u5931\u6557\"\nErrImageExist: \"\u93e1\u50cf\u5df2\u5b58\u5728\uff01\"\nErrDelWithWebsite: \"\u904b\u884c\u74b0\u5883\u5df2\u7d93\u95dc\u806f\u7db2\u7ad9\uff0c\u7121\u6cd5\u522a\u9664\"\n\n#setting\nErrBackupInUsed: \"\u8a72\u5099\u4efd\u5e33\u865f\u5df2\u5728\u8a08\u5283\u4efb\u52d9\u4e2d\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\n\nErrOSSConn: \"\u7121\u6cd5\u6210\u529f\u8acb\u6c42\u6700\u65b0\u7248\u672c\uff0c\u8acb\u6aa2\u67e5\u4f3a\u670d\u5668\u662f\u5426\u80fd\u5920\u9023\u63a5\u5230\u5916\u90e8\u7db2\u7d61\u74b0\u5883\u3002\"\n", "ErrInvalidParams: \"\u8bf7\u6c42\u53c2\u6570\u9519\u8bef: {{ .detail }}\"\nErrTokenParse: \"Token \u751f\u6210\u9519\u8bef: {{ .detail }}\"\nErrInitialPassword: \"\u539f\u5bc6\u7801\u9519\u8bef\"\nErrInternalServer: \"\u670d\u52a1\u5185\u90e8\u9519\u8bef: {{ .detail }}\"\nErrRecordExist: \"\u8bb0\u5f55\u5df2\u5b58\u5728\"\nErrRecordNotFound: \"\u8bb0\u5f55\u672a\u80fd\u627e\u5230\"\nErrStructTransform: \"\u7c7b\u578b\u8f6c\u6362\u5931\u8d25: {{ .detail }}\"\nErrNotLogin: \"\u7528\u6237\u672a\u767b\u5f55: {{ .detail }}\"\nErrPasswordExpired: \"\u5f53\u524d\u5bc6\u7801\u5df2\u8fc7\u671f: {{ .detail }}\"\nErrNotSupportType: \"\u7cfb\u7edf\u6682\u4e0d\u652f\u6301\u5f53\u524d\u7c7b\u578b: {{ .detail }}\"\n\n#common\nErrNameIsExist: \"\u540d\u79f0\u5df2\u5b58\u5728\"\nErrDemoEnvironment: \"\u6f14\u793a\u670d\u52a1\u5668\uff0c\u7981\u6b62\u6b64\u64cd\u4f5c!\"\nErrCmdTimeout: \"\u547d\u4ee4\u6267\u884c\u8d85\u65f6\uff01\"\n\n#app\nErrPortInUsed: \"{{ .detail }} \u7aef\u53e3\u5df2\u88ab\u5360\u7528\uff01\"\nErrAppLimit: \"\u5e94\u7528\u8d85\u51fa\u5b89\u88c5\u6570\u91cf\u9650\u5236\"\nErrAppRequired: \"\u8bf7\u5148\u5b89\u88c5 {{ .detail }} \u5e94\u7528\"\nErrNotInstall: \"\u5e94\u7528\u672a\u5b89\u88c5\"\nErrPortInOtherApp: \"{{ .port }} \u7aef\u53e3\u5df2\u88ab {{ .apps }}\u5360\u7528\uff01\"\nErrDbUserNotValid: \"\u5b58\u91cf\u6570\u636e\u5e93\uff0c\u7528\u6237\u540d\u5bc6\u7801\u4e0d\u5339\u914d\uff01\"\nErrDockerComposeNotValid: \"docker-compose \u6587\u4ef6\u683c\u5f0f\u9519\u8bef\"\nErrUpdateBuWebsite: '\u5e94\u7528\u66f4\u65b0\u6210\u529f\uff0c\u4f46\u662f\u7f51\u7ad9\u914d\u7f6e\u6587\u4ef6\u4fee\u6539\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u914d\u7f6e\uff01'\nErr1PanelNetworkFailed: '\u9ed8\u8ba4\u5bb9\u5668\u7f51\u7edc\u521b\u5efa\u5931\u8d25\uff01{{ .detail }}'\nErrFileParse: '\u5e94\u7528 docker-compose \u6587\u4ef6\u89e3\u6790\u5931\u8d25!'\nErrInstallDirNotFound: '\u5b89\u88c5\u76ee\u5f55\u4e0d\u5b58\u5728'\nAppStoreIsUpToDate: '\u5e94\u7528\u5546\u5e97\u5df2\u7ecf\u662f\u6700\u65b0\u7248\u672c'\nLocalAppVersionNull: '{{.name}} \u5e94\u7528\u672a\u540c\u6b65\u5230\u7248\u672c\uff01\u65e0\u6cd5\u6dfb\u52a0\u5230\u5e94\u7528\u5217\u8868'\nLocalAppVersionErr: '{{.name}} \u540c\u6b65\u7248\u672c {{.version}} \u5931\u8d25\uff01{{.err}}'\nErrFileNotFound: '{{.name}} \u6587\u4ef6\u4e0d\u5b58\u5728'\nErrFileParseApp: '{{.name}} \u6587\u4ef6\u89e3\u6790\u5931\u8d25 {{.err}}'\nErrAppDirNull: '\u7248\u672c\u6587\u4ef6\u5939\u4e0d\u5b58\u5728'\nLocalAppErr: \"\u5e94\u7528 {{.name}} \u540c\u6b65\u5931\u8d25\uff01{{.err}}\"\nErrContainerName: \"\u5bb9\u5668\u540d\u79f0\u5df2\u5b58\u5728\"\nErrAppSystemRestart: \"1Panel \u91cd\u542f\u5bfc\u81f4\u4efb\u52a1\u7ec8\u6b62\"\nErrCreateHttpClient: \"\u521b\u5efaHTTP\u8bf7\u6c42\u5931\u8d25 {{.err}}\"\nErrHttpReqTimeOut: \"\u8bf7\u6c42\u8d85\u65f6 {{.err}}\"\nErrHttpReqFailed: \"\u8bf7\u6c42\u5931\u8d25 {{.err}}\"\nErrHttpReqNotFound: \"\u6587\u4ef6\u4e0d\u5b58\u5728\"\nErrNoSuchHost: \"\u7f51\u7edc\u8fde\u63a5\u5931\u8d25\"\nErrImagePullTimeOut: '\u955c\u50cf\u62c9\u53d6\u8d85\u65f6'\nErrContainerNotFound: '{{ .name }} \u5bb9\u5668\u4e0d\u5b58\u5728'\nErrContainerMsg: '{{ .name }} \u5bb9\u5668\u5f02\u5e38\uff0c\u5177\u4f53\u8bf7\u5728\u5bb9\u5668\u9875\u9762\u67e5\u770b\u65e5\u5fd7'\n\n#file\nErrFileCanNotRead: \"\u6b64\u6587\u4ef6\u4e0d\u652f\u6301\u9884\u89c8\"\nErrFileToLarge: \"\u6587\u4ef6\u8d85\u8fc710M,\u65e0\u6cd5\u6253\u5f00\"\nErrPathNotFound: \"\u76ee\u5f55\u4e0d\u5b58\u5728\"\nErrMovePathFailed: \"\u76ee\u6807\u8def\u5f84\u4e0d\u80fd\u5305\u542b\u539f\u8def\u5f84\uff01\"\nErrLinkPathNotFound: \"\u76ee\u6807\u8def\u5f84\u4e0d\u5b58\u5728!\"\nErrFileIsExit: \"\u6587\u4ef6\u5df2\u5b58\u5728\uff01\"\nErrFileUpload: \"{{ .name }} \u4e0a\u4f20\u6587\u4ef6\u5931\u8d25 {{ .detail}}\"\nErrFileDownloadDir: \"\u4e0d\u652f\u6301\u4e0b\u8f7d\u6587\u4ef6\u5939\"\n\n#website\nErrDomainIsExist: \"\u57df\u540d\u5df2\u5b58\u5728\"\nErrAliasIsExist: \"\u4ee3\u53f7\u5df2\u5b58\u5728\"\nErrAppDelete: '\u5176\u4ed6\u7f51\u7ad9\u4f7f\u7528\u6b64\u5e94\u7528,\u65e0\u6cd5\u5220\u9664'\nErrGroupIsUsed: '\u5206\u7ec4\u6b63\u5728\u4f7f\u7528\u4e2d\uff0c\u65e0\u6cd5\u5220\u9664'\nErrBackupMatch: '\u8be5\u5907\u4efd\u6587\u4ef6\u4e0e\u5f53\u524d\u7f51\u7ad9\u90e8\u5206\u6570\u636e\u4e0d\u5339\u914d {{ .detail}}\"'\nErrBackupExist: '\u8be5\u5907\u4efd\u6587\u4ef6\u5bf9\u5e94\u90e8\u5206\u6e90\u6570\u636e\u4e0d\u5b58\u5728 {{ .detail}}\"'\n\n#ssl\nErrSSLCannotDelete: \"\u8bc1\u4e66\u6b63\u5728\u88ab\u7f51\u7ad9\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrAccountCannotDelete: \"\u8d26\u53f7\u5173\u8054\u8bc1\u4e66\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrSSLApply: \"\u8bc1\u4e66\u7eed\u7b7e\u6210\u529f\uff0copenresty reload\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u914d\u7f6e\uff01\"\nErrEmailIsExist: '\u90ae\u7bb1\u5df2\u5b58\u5728'\nErrSSLKeyNotFound: '\u79c1\u94a5\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLCertificateNotFound: '\u8bc1\u4e66\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLKeyFormat: '\u79c1\u94a5\u6587\u4ef6\u6821\u9a8c\u5931\u8d25'\nErrSSLCertificateFormat: '\u8bc1\u4e66\u6587\u4ef6\u683c\u5f0f\u9519\u8bef\uff0c\u8bf7\u4f7f\u7528 pem \u683c\u5f0f'\n\n#mysql\nErrUserIsExist: \"\u5f53\u524d\u7528\u6237\u5df2\u5b58\u5728\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\"\nErrDatabaseIsExist: \"\u5f53\u524d\u6570\u636e\u5e93\u5df2\u5b58\u5728\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\"\nErrExecTimeOut: \"SQL \u6267\u884c\u8d85\u65f6\uff0c\u8bf7\u68c0\u67e5{{ .detail }}\u5bb9\u5668\"\n\n#redis\nErrTypeOfRedis: \"\u6062\u590d\u6587\u4ef6\u7c7b\u578b\u4e0e\u5f53\u524d\u6301\u4e45\u5316\u65b9\u5f0f\u4e0d\u7b26\uff0c\u8bf7\u4fee\u6539\u540e\u91cd\u8bd5\"\n\n#container \nErrInUsed: \"{{ .detail }} \u6b63\u88ab\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrObjectInUsed: \"\u8be5\u5bf9\u8c61\u6b63\u88ab\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrRepoConn: \"\u4ed3\u5e93\u4fe1\u606f\u4e2d\u5b58\u5728\u4e0d\u5408\u6cd5\u7684\u5b57\u7b26\"\nErrPortRules: \"\u7aef\u53e3\u6570\u76ee\u4e0d\u5339\u914d\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\uff01\"\n\n#runtime\nErrDirNotFound: \"build \u6587\u4ef6\u5939\u4e0d\u5b58\u5728\uff01\u8bf7\u68c0\u67e5\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrFileNotExist: \"{{ .detail }} \u6587\u4ef6\u4e0d\u5b58\u5728\uff01\u8bf7\u68c0\u67e5\u6e90\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrImageBuildErr: \"\u955c\u50cf build \u5931\u8d25\"\nErrImageExist: \"\u955c\u50cf\u5df2\u5b58\u5728\uff01\"\nErrDelWithWebsite: \"\u8fd0\u884c\u73af\u5883\u5df2\u7ecf\u5173\u8054\u7f51\u7ad9\uff0c\u65e0\u6cd5\u5220\u9664\"\n\n#setting\nErrBackupInUsed: \"\u8be5\u5907\u4efd\u8d26\u53f7\u5df2\u5728\u8ba1\u5212\u4efb\u52a1\u4e2d\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\n\nErrOSSConn: \"\u65e0\u6cd5\u6210\u529f\u8bf7\u6c42\u6700\u65b0\u7248\u672c\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u5668\u662f\u5426\u80fd\u591f\u8fde\u63a5\u5230\u5916\u90e8\u7f51\u7edc\u73af\u5883\u3002\"\n", "package client\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n)\n\ntype Firewall struct{}\n\nfunc NewFirewalld() (*Firewall, error) {\n\treturn &Firewall{}, nil\n}\n\nfunc (f *Firewall) Name() string {\n\treturn \"firewalld\"\n}\n\nfunc (f *Firewall) Status() (string, error) {\n\tstdout, _ := cmd.Exec(\"firewall-cmd --state\")\n\tif stdout == \"running\\n\" {\n\t\treturn \"running\", nil\n\t}\n\treturn \"not running\", nil\n}\n\nfunc (f *Firewall) Version() (string, error) {\n\tstdout, err := cmd.Exec(\"firewall-cmd --version\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"load the firewall version failed, err: %s\", stdout)\n\t}\n\treturn strings.ReplaceAll(stdout, \"\\n \", \"\"), nil\n}\n\nfunc (f *Firewall) Start() error {\n\tstdout, err := cmd.Exec(\"systemctl start firewalld\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"enable the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) Stop() error {\n\tstdout, err := cmd.Exec(\"systemctl stop firewalld\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stop the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) Reload() error {\n\tstdout, err := cmd.Exec(\"firewall-cmd --reload\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"reload firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) ListPort() ([]FireInfo, error) {\n\tstdout, err := cmd.Exec(\"firewall-cmd --zone=public --list-ports\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tports := strings.Split(strings.ReplaceAll(stdout, \"\\n\", \"\"), \" \")\n\tvar datas []FireInfo\n\tfor _, port := range ports {\n\t\tif len(port) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvar itemPort FireInfo\n\t\tif strings.Contains(port, \"/\") {\n\t\t\titemPort.Port = strings.Split(port, \"/\")[0]\n\t\t\titemPort.Protocol = strings.Split(port, \"/\")[1]\n\t\t}\n\t\titemPort.Strategy = \"accept\"\n\t\tdatas = append(datas, itemPort)\n\t}\n\n\tstdout1, err := cmd.Exec(\"firewall-cmd --zone=public --list-rich-rules\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trules := strings.Split(stdout1, \"\\n\")\n\tfor _, rule := range rules {\n\t\tif len(rule) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\titemRule := f.loadInfo(rule)\n\t\tif len(itemRule.Port) != 0 && itemRule.Family == \"ipv4\" {\n\t\t\tdatas = append(datas, itemRule)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Firewall) ListAddress() ([]FireInfo, error) {\n\tstdout, err := cmd.Exec(\"firewall-cmd --zone=public --list-rich-rules\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar datas []FireInfo\n\trules := strings.Split(stdout, \"\\n\")\n\tfor _, rule := range rules {\n\t\tif len(rule) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\titemRule := f.loadInfo(rule)\n\t\tif len(itemRule.Port) == 0 && len(itemRule.Address) != 0 {\n\t\t\tdatas = append(datas, itemRule)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Firewall) Port(port FireInfo, operation string) error {\n\tstdout, err := cmd.Execf(\"firewall-cmd --zone=public --%s-port=%s/%s --permanent\", operation, port.Port, port.Protocol)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) RichRules(rule FireInfo, operation string) error {\n\truleStr := \"\"\n\tif strings.Contains(rule.Address, \"-\") {\n\t\tstd, err := cmd.Execf(\"firewall-cmd --permanent --new-ipset=%s --type=hash:ip\", rule.Address)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"add new ipset failed, err: %s\", std)\n\t\t}\n\t\tstd2, err := cmd.Execf(\"firewall-cmd --permanent --ipset=%s --add-entry=%s\", rule.Address, rule.Address)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"add entry to ipset failed, err: %s\", std2)\n\t\t}\n\t\tif err := f.Reload(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\truleStr = fmt.Sprintf(\"rule source ipset=%s %s\", rule.Address, rule.Strategy)\n\t} else {\n\t\truleStr = \"rule family=ipv4 \"\n\t\tif len(rule.Address) != 0 {\n\t\t\truleStr += fmt.Sprintf(\"source address=%s \", rule.Address)\n\t\t}\n\t\tif len(rule.Port) != 0 {\n\t\t\truleStr += fmt.Sprintf(\"port port=%s \", rule.Port)\n\t\t}\n\t\tif len(rule.Protocol) != 0 {\n\t\t\truleStr += fmt.Sprintf(\"protocol=%s \", rule.Protocol)\n\t\t}\n\t\truleStr += rule.Strategy\n\t}\n\tstdout, err := cmd.Execf(\"firewall-cmd --zone=public --%s-rich-rule '%s' --permanent\", operation, ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s rich rules failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) PortForward(info Forward, operation string) error {\n\truleStr := fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Target)\n\tif len(info.Address) != 0 {\n\t\truleStr = fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toaddr=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Address, info.Target)\n\t}\n\n\tstdout, err := cmd.Exec(ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port forward failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) loadInfo(line string) FireInfo {\n\tvar itemRule FireInfo\n\truleInfo := strings.Split(strings.ReplaceAll(line, \"\\\"\", \"\"), \" \")\n\tfor _, item := range ruleInfo {\n\t\tswitch {\n\t\tcase strings.Contains(item, \"family=\"):\n\t\t\titemRule.Family = strings.ReplaceAll(item, \"family=\", \"\")\n\t\tcase strings.Contains(item, \"ipset=\"):\n\t\t\titemRule.Address = strings.ReplaceAll(item, \"ipset=\", \"\")\n\t\tcase strings.Contains(item, \"address=\"):\n\t\t\titemRule.Address = strings.ReplaceAll(item, \"address=\", \"\")\n\t\tcase strings.Contains(item, \"port=\"):\n\t\t\titemRule.Port = strings.ReplaceAll(item, \"port=\", \"\")\n\t\tcase strings.Contains(item, \"protocol=\"):\n\t\t\titemRule.Protocol = strings.ReplaceAll(item, \"protocol=\", \"\")\n\t\tcase item == \"accept\" || item == \"drop\" || item == \"reject\":\n\t\t\titemRule.Strategy = item\n\t\t}\n\t}\n\treturn itemRule\n}\n", "package client\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n)\n\ntype Ufw struct {\n\tCmdStr string\n}\n\nfunc NewUfw() (*Ufw, error) {\n\tvar ufw Ufw\n\tif cmd.HasNoPasswordSudo() {\n\t\tufw.CmdStr = \"sudo ufw\"\n\t} else {\n\t\tufw.CmdStr = \"ufw\"\n\t}\n\treturn &ufw, nil\n}\n\nfunc (f *Ufw) Name() string {\n\treturn \"ufw\"\n}\n\nfunc (f *Ufw) Status() (string, error) {\n\tstdout, _ := cmd.Execf(\"%s status | grep Status\", f.CmdStr)\n\tif stdout == \"Status: active\\n\" {\n\t\treturn \"running\", nil\n\t}\n\tstdout1, _ := cmd.Execf(\"%s status | grep \u72b6\u6001\", f.CmdStr)\n\tif stdout1 == \"\u72b6\u6001\uff1a \u6fc0\u6d3b\\n\" {\n\t\treturn \"running\", nil\n\t}\n\treturn \"not running\", nil\n}\n\nfunc (f *Ufw) Version() (string, error) {\n\tstdout, err := cmd.Execf(\"%s version | grep ufw\", f.CmdStr)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"load the firewall status failed, err: %s\", stdout)\n\t}\n\tinfo := strings.ReplaceAll(stdout, \"\\n\", \"\")\n\treturn strings.ReplaceAll(info, \"ufw \", \"\"), nil\n}\n\nfunc (f *Ufw) Start() error {\n\tstdout, err := cmd.Execf(\"echo y | %s enable\", f.CmdStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"enable the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) Stop() error {\n\tstdout, err := cmd.Execf(\"%s disable\", f.CmdStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stop the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) Reload() error {\n\treturn nil\n}\n\nfunc (f *Ufw) ListPort() ([]FireInfo, error) {\n\tstdout, err := cmd.Execf(\"%s status verbose\", f.CmdStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tportInfos := strings.Split(stdout, \"\\n\")\n\tvar datas []FireInfo\n\tisStart := false\n\tfor _, line := range portInfos {\n\t\tif strings.HasPrefix(line, \"-\") {\n\t\t\tisStart = true\n\t\t\tcontinue\n\t\t}\n\t\tif !isStart {\n\t\t\tcontinue\n\t\t}\n\t\titemFire := f.loadInfo(line, \"port\")\n\t\tif len(itemFire.Port) != 0 && itemFire.Port != \"Anywhere\" && !strings.Contains(itemFire.Port, \".\") {\n\t\t\titemFire.Port = strings.ReplaceAll(itemFire.Port, \":\", \"-\")\n\t\t\tdatas = append(datas, itemFire)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Ufw) ListAddress() ([]FireInfo, error) {\n\tstdout, err := cmd.Execf(\"%s status verbose\", f.CmdStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tportInfos := strings.Split(stdout, \"\\n\")\n\tvar datas []FireInfo\n\tisStart := false\n\tfor _, line := range portInfos {\n\t\tif strings.HasPrefix(line, \"-\") {\n\t\t\tisStart = true\n\t\t\tcontinue\n\t\t}\n\t\tif !isStart {\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.Contains(line, \" IN\") {\n\t\t\tcontinue\n\t\t}\n\t\titemFire := f.loadInfo(line, \"address\")\n\t\tif strings.Contains(itemFire.Port, \".\") {\n\t\t\titemFire.Address += (\"-\" + itemFire.Port)\n\t\t\titemFire.Port = \"\"\n\t\t}\n\t\tif len(itemFire.Port) == 0 && len(itemFire.Address) != 0 {\n\t\t\tdatas = append(datas, itemFire)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Ufw) Port(port FireInfo, operation string) error {\n\tswitch port.Strategy {\n\tcase \"accept\":\n\t\tport.Strategy = \"allow\"\n\tcase \"drop\":\n\t\tport.Strategy = \"deny\"\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupport strategy %s\", port.Strategy)\n\t}\n\n\tcommand := fmt.Sprintf(\"%s %s %s\", f.CmdStr, port.Strategy, port.Port)\n\tif operation == \"remove\" {\n\t\tcommand = fmt.Sprintf(\"%s delete %s %s\", f.CmdStr, port.Strategy, port.Port)\n\t}\n\tif len(port.Protocol) != 0 {\n\t\tcommand += fmt.Sprintf(\"/%s\", port.Protocol)\n\t}\n\tstdout, err := cmd.Exec(command)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) RichRules(rule FireInfo, operation string) error {\n\tswitch rule.Strategy {\n\tcase \"accept\":\n\t\trule.Strategy = \"allow\"\n\tcase \"drop\":\n\t\trule.Strategy = \"deny\"\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupport strategy %s\", rule.Strategy)\n\t}\n\n\truleStr := fmt.Sprintf(\"%s %s \", f.CmdStr, rule.Strategy)\n\tif operation == \"remove\" {\n\t\truleStr = fmt.Sprintf(\"%s delete %s \", f.CmdStr, rule.Strategy)\n\t}\n\tif len(rule.Protocol) != 0 {\n\t\truleStr += fmt.Sprintf(\"proto %s \", rule.Protocol)\n\t}\n\tif strings.Contains(rule.Address, \"-\") {\n\t\truleStr += fmt.Sprintf(\"from %s to %s \", strings.Split(rule.Address, \"-\")[0], strings.Split(rule.Address, \"-\")[1])\n\t} else {\n\t\truleStr += fmt.Sprintf(\"from %s \", rule.Address)\n\t}\n\tif len(rule.Port) != 0 {\n\t\truleStr += fmt.Sprintf(\"to any port %s \", rule.Port)\n\t}\n\n\tstdout, err := cmd.Exec(ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s rich rules failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) PortForward(info Forward, operation string) error {\n\truleStr := fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Target)\n\tif len(info.Address) != 0 {\n\t\truleStr = fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toaddr=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Address, info.Target)\n\t}\n\n\tstdout, err := cmd.Exec(ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port forward failed, err: %s\", operation, stdout)\n\t}\n\tif err := f.Reload(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) loadInfo(line string, fireType string) FireInfo {\n\tfields := strings.Fields(line)\n\tvar itemInfo FireInfo\n\tif len(fields) < 4 {\n\t\treturn itemInfo\n\t}\n\tif fields[1] == \"(v6)\" {\n\t\treturn itemInfo\n\t}\n\tif fields[0] == \"Anywhere\" && fireType != \"port\" {\n\t\titemInfo.Strategy = \"drop\"\n\t\tif fields[1] == \"ALLOW\" {\n\t\t\titemInfo.Strategy = \"accept\"\n\t\t}\n\t\titemInfo.Address = fields[3]\n\t\treturn itemInfo\n\t}\n\tif strings.Contains(fields[0], \"/\") {\n\t\titemInfo.Port = strings.Split(fields[0], \"/\")[0]\n\t\titemInfo.Protocol = strings.Split(fields[0], \"/\")[1]\n\t} else {\n\t\titemInfo.Port = fields[0]\n\t\titemInfo.Protocol = \"tcp/udp\"\n\t}\n\titemInfo.Family = \"ipv4\"\n\tif fields[1] == \"ALLOW\" {\n\t\titemInfo.Strategy = \"accept\"\n\t} else {\n\t\titemInfo.Strategy = \"drop\"\n\t}\n\titemInfo.Address = fields[3]\n\n\treturn itemInfo\n}\n"], "fixing_code": ["package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/docker\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/docker/docker/api/types/filters\"\n\t\"github.com/docker/docker/api/types/network\"\n\t\"github.com/docker/docker/client\"\n\t\"github.com/docker/go-connections/nat\"\n\t\"github.com/gorilla/websocket\"\n\tv1 \"github.com/opencontainers/image-spec/specs-go/v1\"\n\t\"github.com/shirou/gopsutil/v3/cpu\"\n\t\"github.com/shirou/gopsutil/v3/mem\"\n)\n\ntype ContainerService struct{}\n\ntype IContainerService interface {\n\tPage(req dto.PageContainer) (int64, interface{}, error)\n\tList() ([]string, error)\n\tPageNetwork(req dto.SearchWithPage) (int64, interface{}, error)\n\tListNetwork() ([]dto.Options, error)\n\tPageVolume(req dto.SearchWithPage) (int64, interface{}, error)\n\tListVolume() ([]dto.Options, error)\n\tPageCompose(req dto.SearchWithPage) (int64, interface{}, error)\n\tCreateCompose(req dto.ComposeCreate) (string, error)\n\tComposeOperation(req dto.ComposeOperation) error\n\tContainerCreate(req dto.ContainerOperate) error\n\tContainerUpdate(req dto.ContainerOperate) error\n\tContainerUpgrade(req dto.ContainerUpgrade) error\n\tContainerInfo(req dto.OperationWithName) (*dto.ContainerOperate, error)\n\tContainerListStats() ([]dto.ContainerListStats, error)\n\tLoadResouceLimit() (*dto.ResourceLimit, error)\n\tContainerLogClean(req dto.OperationWithName) error\n\tContainerOperation(req dto.ContainerOperation) error\n\tContainerLogs(wsConn *websocket.Conn, container, since, tail string, follow bool) error\n\tContainerStats(id string) (*dto.ContainerStats, error)\n\tInspect(req dto.InspectReq) (string, error)\n\tDeleteNetwork(req dto.BatchDelete) error\n\tCreateNetwork(req dto.NetworkCreate) error\n\tDeleteVolume(req dto.BatchDelete) error\n\tCreateVolume(req dto.VolumeCreate) error\n\tTestCompose(req dto.ComposeCreate) (bool, error)\n\tComposeUpdate(req dto.ComposeUpdate) error\n\tPrune(req dto.ContainerPrune) (dto.ContainerPruneReport, error)\n}\n\nfunc NewIContainerService() IContainerService {\n\treturn &ContainerService{}\n}\n\nfunc (u *ContainerService) Page(req dto.PageContainer) (int64, interface{}, error) {\n\tvar (\n\t\trecords []types.Container\n\t\tlist    []types.Container\n\t)\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\toptions := types.ContainerListOptions{All: true}\n\tif len(req.Filters) != 0 {\n\t\toptions.Filters = filters.NewArgs()\n\t\toptions.Filters.Add(\"label\", req.Filters)\n\t}\n\tlist, err = client.ContainerList(context.Background(), options)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tif len(req.Name) != 0 {\n\t\tlength, count := len(list), 0\n\t\tfor count < length {\n\t\t\tif !strings.Contains(list[count].Names[0][1:], req.Name) {\n\t\t\t\tlist = append(list[:count], list[(count+1):]...)\n\t\t\t\tlength--\n\t\t\t} else {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\tswitch req.OrderBy {\n\tcase \"name\":\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\tif req.Order == constant.OrderAsc {\n\t\t\t\treturn list[i].Names[0][1:] < list[j].Names[0][1:]\n\t\t\t}\n\t\t\treturn list[i].Names[0][1:] > list[j].Names[0][1:]\n\t\t})\n\tcase \"state\":\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\tif req.Order == constant.OrderAsc {\n\t\t\t\treturn list[i].State < list[j].State\n\t\t\t}\n\t\t\treturn list[i].State > list[j].State\n\t\t})\n\tdefault:\n\t\tsort.Slice(list, func(i, j int) bool {\n\t\t\tif req.Order == constant.OrderAsc {\n\t\t\t\treturn list[i].Created < list[j].Created\n\t\t\t}\n\t\t\treturn list[i].Created > list[j].Created\n\t\t})\n\t}\n\n\ttotal, start, end := len(list), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\trecords = make([]types.Container, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\trecords = list[start:end]\n\t}\n\n\tbackDatas := make([]dto.ContainerInfo, len(records))\n\tfor i := 0; i < len(records); i++ {\n\t\titem := records[i]\n\t\tIsFromCompose := false\n\t\tif _, ok := item.Labels[composeProjectLabel]; ok {\n\t\t\tIsFromCompose = true\n\t\t}\n\t\tIsFromApp := false\n\t\tif created, ok := item.Labels[composeCreatedBy]; ok && created == \"Apps\" {\n\t\t\tIsFromApp = true\n\t\t}\n\n\t\tvar ports []string\n\t\tfor _, port := range item.Ports {\n\t\t\titemPortStr := fmt.Sprintf(\"%v/%s\", port.PrivatePort, port.Type)\n\t\t\tif port.PublicPort != 0 {\n\t\t\t\titemPortStr = fmt.Sprintf(\"%s:%v->%v/%s\", port.IP, port.PublicPort, port.PrivatePort, port.Type)\n\t\t\t}\n\t\t\tports = append(ports, itemPortStr)\n\t\t}\n\t\tbackDatas[i] = dto.ContainerInfo{\n\t\t\tContainerID:   item.ID,\n\t\t\tCreateTime:    time.Unix(item.Created, 0).Format(\"2006-01-02 15:04:05\"),\n\t\t\tName:          item.Names[0][1:],\n\t\t\tImageId:       strings.Split(item.ImageID, \":\")[1],\n\t\t\tImageName:     item.Image,\n\t\t\tState:         item.State,\n\t\t\tRunTime:       item.Status,\n\t\t\tPorts:         ports,\n\t\t\tIsFromApp:     IsFromApp,\n\t\t\tIsFromCompose: IsFromCompose,\n\t\t}\n\t}\n\n\treturn int64(total), backDatas, nil\n}\n\nfunc (u *ContainerService) List() ([]string, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcontainers, err := client.ContainerList(context.Background(), types.ContainerListOptions{All: true})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar datas []string\n\tfor _, container := range containers {\n\t\tfor _, name := range container.Names {\n\t\t\tif len(name) != 0 {\n\t\t\t\tdatas = append(datas, strings.TrimLeft(name, \"/\"))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn datas, nil\n}\n\nfunc (u *ContainerService) ContainerListStats() ([]dto.ContainerListStats, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlist, err := client.ContainerList(context.Background(), types.ContainerListOptions{All: true})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar datas []dto.ContainerListStats\n\tvar wg sync.WaitGroup\n\twg.Add(len(list))\n\tfor i := 0; i < len(list); i++ {\n\t\tgo func(item types.Container) {\n\t\t\tcpu, mem := loadCpuAndMem(client, item.ID)\n\t\t\tdatas = append(datas, dto.ContainerListStats{CPUPercent: cpu, MemoryPercent: mem, ContainerID: item.ID})\n\t\t\twg.Done()\n\t\t}(list[i])\n\t}\n\twg.Wait()\n\treturn datas, nil\n}\n\nfunc (u *ContainerService) Inspect(req dto.InspectReq) (string, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tvar inspectInfo interface{}\n\tswitch req.Type {\n\tcase \"container\":\n\t\tinspectInfo, err = client.ContainerInspect(context.Background(), req.ID)\n\tcase \"network\":\n\t\tinspectInfo, err = client.NetworkInspect(context.TODO(), req.ID, types.NetworkInspectOptions{})\n\tcase \"volume\":\n\t\tinspectInfo, err = client.VolumeInspect(context.TODO(), req.ID)\n\t}\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tbytes, err := json.Marshal(inspectInfo)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(bytes), nil\n}\n\nfunc (u *ContainerService) Prune(req dto.ContainerPrune) (dto.ContainerPruneReport, error) {\n\treport := dto.ContainerPruneReport{}\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn report, err\n\t}\n\tpruneFilters := filters.NewArgs()\n\tif req.WithTagAll {\n\t\tpruneFilters.Add(\"dangling\", \"false\")\n\t\tif req.PruneType != \"image\" {\n\t\t\tpruneFilters.Add(\"until\", \"24h\")\n\t\t}\n\t}\n\tswitch req.PruneType {\n\tcase \"container\":\n\t\trep, err := client.ContainersPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.ContainersDeleted)\n\t\treport.SpaceReclaimed = int(rep.SpaceReclaimed)\n\tcase \"image\":\n\t\trep, err := client.ImagesPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.ImagesDeleted)\n\t\treport.SpaceReclaimed = int(rep.SpaceReclaimed)\n\tcase \"network\":\n\t\trep, err := client.NetworksPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.NetworksDeleted)\n\tcase \"volume\":\n\t\trep, err := client.VolumesPrune(context.Background(), pruneFilters)\n\t\tif err != nil {\n\t\t\treturn report, err\n\t\t}\n\t\treport.DeletedNumber = len(rep.VolumesDeleted)\n\t\treport.SpaceReclaimed = int(rep.SpaceReclaimed)\n\t}\n\treturn report, nil\n}\n\nfunc (u *ContainerService) LoadResouceLimit() (*dto.ResourceLimit, error) {\n\tcpuCounts, err := cpu.Counts(true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load cpu limit failed, err: %v\", err)\n\t}\n\tmemoryInfo, err := mem.VirtualMemory()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"load memory limit failed, err: %v\", err)\n\t}\n\n\tdata := dto.ResourceLimit{\n\t\tCPU:    cpuCounts,\n\t\tMemory: int(memoryInfo.Total),\n\t}\n\treturn &data, nil\n}\n\nfunc (u *ContainerService) ContainerCreate(req dto.ContainerOperate) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := context.Background()\n\tnewContainer, _ := client.ContainerInspect(ctx, req.Name)\n\tif newContainer.ContainerJSONBase != nil {\n\t\treturn buserr.New(constant.ErrContainerName)\n\t}\n\n\tvar config container.Config\n\tvar hostConf container.HostConfig\n\tvar networkConf network.NetworkingConfig\n\tif err := loadConfigInfo(req, &config, &hostConf, &networkConf); err != nil {\n\t\treturn err\n\t}\n\n\tglobal.LOG.Infof(\"new container info %s has been made, now start to create\", req.Name)\n\n\tif !checkImageExist(client, req.Image) || req.ForcePull {\n\t\tif err := pullImages(ctx, client, req.Image); err != nil {\n\t\t\tif !req.ForcePull {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"force pull image %s failed, err: %v\", req.Image, err)\n\t\t}\n\t}\n\tcontainer, err := client.ContainerCreate(ctx, &config, &hostConf, &networkConf, &v1.Platform{}, req.Name)\n\tif err != nil {\n\t\t_ = client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})\n\t\treturn err\n\t}\n\tglobal.LOG.Infof(\"create container %s successful! now check if the container is started and delete the container information if it is not.\", req.Name)\n\tif err := client.ContainerStart(ctx, container.ID, types.ContainerStartOptions{}); err != nil {\n\t\t_ = client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})\n\t\treturn fmt.Errorf(\"create successful but start failed, err: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerInfo(req dto.OperationWithName) (*dto.ContainerOperate, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tctx := context.Background()\n\toldContainer, err := client.ContainerInspect(ctx, req.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar data dto.ContainerOperate\n\tdata.ContainerID = oldContainer.ID\n\tdata.Name = strings.ReplaceAll(oldContainer.Name, \"/\", \"\")\n\tdata.Image = oldContainer.Config.Image\n\tif oldContainer.NetworkSettings != nil {\n\t\tfor network := range oldContainer.NetworkSettings.Networks {\n\t\t\tdata.Network = network\n\t\t\tbreak\n\t\t}\n\t}\n\tdata.Cmd = oldContainer.Config.Cmd\n\tdata.Env = oldContainer.Config.Env\n\tdata.CPUShares = oldContainer.HostConfig.CPUShares\n\tfor key, val := range oldContainer.Config.Labels {\n\t\tdata.Labels = append(data.Labels, fmt.Sprintf(\"%s=%s\", key, val))\n\t}\n\tfor key, val := range oldContainer.HostConfig.PortBindings {\n\t\tvar itemPort dto.PortHelper\n\t\tif !strings.Contains(string(key), \"/\") {\n\t\t\tcontinue\n\t\t}\n\t\titemPort.ContainerPort = strings.Split(string(key), \"/\")[0]\n\t\titemPort.Protocol = strings.Split(string(key), \"/\")[1]\n\t\tfor _, binds := range val {\n\t\t\titemPort.HostIP = binds.HostIP\n\t\t\titemPort.HostPort = binds.HostPort\n\t\t\tdata.ExposedPorts = append(data.ExposedPorts, itemPort)\n\t\t}\n\t}\n\tdata.AutoRemove = oldContainer.HostConfig.AutoRemove\n\tdata.PublishAllPorts = oldContainer.HostConfig.PublishAllPorts\n\tdata.RestartPolicy = oldContainer.HostConfig.RestartPolicy.Name\n\tif oldContainer.HostConfig.NanoCPUs != 0 {\n\t\tdata.NanoCPUs = float64(oldContainer.HostConfig.NanoCPUs) / 1000000000\n\t}\n\tif oldContainer.HostConfig.Memory != 0 {\n\t\tdata.Memory = float64(oldContainer.HostConfig.Memory) / 1024 / 1024\n\t}\n\tfor _, bind := range oldContainer.HostConfig.Binds {\n\t\tparts := strings.Split(bind, \":\")\n\t\tif len(parts) != 3 {\n\t\t\tcontinue\n\t\t}\n\t\tdata.Volumes = append(data.Volumes, dto.VolumeHelper{SourceDir: parts[0], ContainerDir: parts[1], Mode: parts[2]})\n\t}\n\n\treturn &data, nil\n}\n\nfunc (u *ContainerService) ContainerUpdate(req dto.ContainerOperate) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := context.Background()\n\tnewContainer, _ := client.ContainerInspect(ctx, req.Name)\n\tif newContainer.ContainerJSONBase != nil && newContainer.ID != req.ContainerID {\n\t\treturn buserr.New(constant.ErrContainerName)\n\t}\n\n\toldContainer, err := client.ContainerInspect(ctx, req.ContainerID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !checkImageExist(client, req.Image) || req.ForcePull {\n\t\tif err := pullImages(ctx, client, req.Image); err != nil {\n\t\t\tif !req.ForcePull {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"force pull image %s failed, err: %v\", req.Image, err)\n\t\t}\n\t}\n\n\tif err := client.ContainerRemove(ctx, req.ContainerID, types.ContainerRemoveOptions{Force: true}); err != nil {\n\t\treturn err\n\t}\n\n\tconfig := oldContainer.Config\n\thostConf := oldContainer.HostConfig\n\tvar networkConf network.NetworkingConfig\n\tif err := loadConfigInfo(req, config, hostConf, &networkConf); err != nil {\n\t\treturn err\n\t}\n\n\tglobal.LOG.Infof(\"new container info %s has been update, now start to recreate\", req.Name)\n\tcontainer, err := client.ContainerCreate(ctx, config, hostConf, &networkConf, &v1.Platform{}, req.Name)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"recreate contianer failed, err: %v\", err)\n\t}\n\tglobal.LOG.Infof(\"update container %s successful! now check if the container is started.\", req.Name)\n\tif err := client.ContainerStart(ctx, container.ID, types.ContainerStartOptions{}); err != nil {\n\t\treturn fmt.Errorf(\"update successful but start failed, err: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerUpgrade(req dto.ContainerUpgrade) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := context.Background()\n\toldContainer, err := client.ContainerInspect(ctx, req.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !checkImageExist(client, req.Image) || req.ForcePull {\n\t\tif err := pullImages(ctx, client, req.Image); err != nil {\n\t\t\tif !req.ForcePull {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"force pull image %s failed, err: %v\", req.Image, err)\n\t\t}\n\t}\n\tconfig := oldContainer.Config\n\tconfig.Image = req.Image\n\thostConf := oldContainer.HostConfig\n\tvar networkConf network.NetworkingConfig\n\tif oldContainer.NetworkSettings != nil {\n\t\tfor networkKey := range oldContainer.NetworkSettings.Networks {\n\t\t\tnetworkConf.EndpointsConfig = map[string]*network.EndpointSettings{networkKey: {}}\n\t\t\tbreak\n\t\t}\n\t}\n\tif err := client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{Force: true}); err != nil {\n\t\treturn err\n\t}\n\n\tglobal.LOG.Infof(\"new container info %s has been update, now start to recreate\", req.Name)\n\tcontainer, err := client.ContainerCreate(ctx, config, hostConf, &network.NetworkingConfig{}, &v1.Platform{}, req.Name)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"recreate contianer failed, err: %v\", err)\n\t}\n\tglobal.LOG.Infof(\"update container %s successful! now check if the container is started.\", req.Name)\n\tif err := client.ContainerStart(ctx, container.ID, types.ContainerStartOptions{}); err != nil {\n\t\treturn fmt.Errorf(\"update successful but start failed, err: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerOperation(req dto.ContainerOperation) error {\n\tvar err error\n\tctx := context.Background()\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tglobal.LOG.Infof(\"start container %s operation %s\", req.Name, req.Operation)\n\tswitch req.Operation {\n\tcase constant.ContainerOpStart:\n\t\terr = client.ContainerStart(ctx, req.Name, types.ContainerStartOptions{})\n\tcase constant.ContainerOpStop:\n\t\terr = client.ContainerStop(ctx, req.Name, container.StopOptions{})\n\tcase constant.ContainerOpRestart:\n\t\terr = client.ContainerRestart(ctx, req.Name, container.StopOptions{})\n\tcase constant.ContainerOpKill:\n\t\terr = client.ContainerKill(ctx, req.Name, \"SIGKILL\")\n\tcase constant.ContainerOpPause:\n\t\terr = client.ContainerPause(ctx, req.Name)\n\tcase constant.ContainerOpUnpause:\n\t\terr = client.ContainerUnpause(ctx, req.Name)\n\tcase constant.ContainerOpRename:\n\t\tnewContainer, _ := client.ContainerInspect(ctx, req.NewName)\n\t\tif newContainer.ContainerJSONBase != nil {\n\t\t\treturn buserr.New(constant.ErrContainerName)\n\t\t}\n\t\terr = client.ContainerRename(ctx, req.Name, req.NewName)\n\tcase constant.ContainerOpRemove:\n\t\terr = client.ContainerRemove(ctx, req.Name, types.ContainerRemoveOptions{RemoveVolumes: true, Force: true})\n\t}\n\treturn err\n}\n\nfunc (u *ContainerService) ContainerLogClean(req dto.OperationWithName) error {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcontainer, err := client.ContainerInspect(context.Background(), req.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfile, err := os.OpenFile(container.LogPath, os.O_RDWR|os.O_CREATE, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tif err = file.Truncate(0); err != nil {\n\t\treturn err\n\t}\n\t_, _ = file.Seek(0, 0)\n\n\tfiles, _ := filepath.Glob(fmt.Sprintf(\"%s.*\", container.LogPath))\n\tfor _, file := range files {\n\t\t_ = os.Remove(file)\n\t}\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerLogs(wsConn *websocket.Conn, container, since, tail string, follow bool) error {\n\tif cmd.CheckIllegal(container, since, tail) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\tcommand := fmt.Sprintf(\"docker logs %s\", container)\n\tif tail != \"0\" {\n\t\tcommand += \" -n \" + tail\n\t}\n\tif since != \"all\" {\n\t\tcommand += \" --since \" + since\n\t}\n\tif follow {\n\t\tcommand += \" -f\"\n\t}\n\tcommand += \" 2>&1\"\n\tcmd := exec.Command(\"bash\", \"-c\", command)\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\n\tbuffer := make([]byte, 1024)\n\tfor {\n\t\tn, err := stdout.Read(buffer)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tglobal.LOG.Errorf(\"read bytes from container log failed, err: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif err = wsConn.WriteMessage(websocket.TextMessage, buffer[:n]); err != nil {\n\t\t\tglobal.LOG.Errorf(\"send message with container log to ws failed, err: %v\", err)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (u *ContainerService) ContainerStats(id string) (*dto.ContainerStats, error) {\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres, err := client.ContainerStats(context.TODO(), id, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer res.Body.Close()\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\tres.Body.Close()\n\t\treturn nil, err\n\t}\n\tres.Body.Close()\n\tvar stats *types.StatsJSON\n\tif err := json.Unmarshal(body, &stats); err != nil {\n\t\treturn nil, err\n\t}\n\tvar data dto.ContainerStats\n\tdata.CPUPercent = calculateCPUPercentUnix(stats)\n\tdata.IORead, data.IOWrite = calculateBlockIO(stats.BlkioStats)\n\tdata.Memory = float64(stats.MemoryStats.Usage) / 1024 / 1024\n\tif cache, ok := stats.MemoryStats.Stats[\"cache\"]; ok {\n\t\tdata.Cache = float64(cache) / 1024 / 1024\n\t}\n\tdata.Memory = data.Memory - data.Cache\n\tdata.NetworkRX, data.NetworkTX = calculateNetwork(stats.Networks)\n\tdata.ShotTime = stats.Read\n\treturn &data, nil\n}\n\nfunc stringsToMap(list []string) map[string]string {\n\tvar lableMap = make(map[string]string)\n\tfor _, label := range list {\n\t\tif strings.Contains(label, \"=\") {\n\t\t\tsps := strings.SplitN(label, \"=\", 2)\n\t\t\tlableMap[sps[0]] = sps[1]\n\t\t}\n\t}\n\treturn lableMap\n}\n\nfunc calculateCPUPercentUnix(stats *types.StatsJSON) float64 {\n\tcpuPercent := 0.0\n\tcpuDelta := float64(stats.CPUStats.CPUUsage.TotalUsage) - float64(stats.PreCPUStats.CPUUsage.TotalUsage)\n\tsystemDelta := float64(stats.CPUStats.SystemUsage) - float64(stats.PreCPUStats.SystemUsage)\n\n\tif systemDelta > 0.0 && cpuDelta > 0.0 {\n\t\tcpuPercent = (cpuDelta / systemDelta) * 100.0\n\t\tif len(stats.CPUStats.CPUUsage.PercpuUsage) != 0 {\n\t\t\tcpuPercent = cpuPercent * float64(len(stats.CPUStats.CPUUsage.PercpuUsage))\n\t\t}\n\t}\n\treturn cpuPercent\n}\nfunc calculateMemPercentUnix(memStats types.MemoryStats) float64 {\n\tmemPercent := 0.0\n\tmemUsage := float64(memStats.Usage - memStats.Stats[\"cache\"])\n\tmemLimit := float64(memStats.Limit)\n\tif memUsage > 0.0 && memLimit > 0.0 {\n\t\tmemPercent = (memUsage / memLimit) * 100.0\n\t}\n\treturn memPercent\n}\nfunc calculateBlockIO(blkio types.BlkioStats) (blkRead float64, blkWrite float64) {\n\tfor _, bioEntry := range blkio.IoServiceBytesRecursive {\n\t\tswitch strings.ToLower(bioEntry.Op) {\n\t\tcase \"read\":\n\t\t\tblkRead = (blkRead + float64(bioEntry.Value)) / 1024 / 1024\n\t\tcase \"write\":\n\t\t\tblkWrite = (blkWrite + float64(bioEntry.Value)) / 1024 / 1024\n\t\t}\n\t}\n\treturn\n}\nfunc calculateNetwork(network map[string]types.NetworkStats) (float64, float64) {\n\tvar rx, tx float64\n\n\tfor _, v := range network {\n\t\trx += float64(v.RxBytes) / 1024\n\t\ttx += float64(v.TxBytes) / 1024\n\t}\n\treturn rx, tx\n}\n\nfunc checkImageExist(client *client.Client, image string) bool {\n\timages, err := client.ImageList(context.Background(), types.ImageListOptions{})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn false\n\t}\n\n\tfor _, img := range images {\n\t\tfor _, tag := range img.RepoTags {\n\t\t\tif tag == image || tag == image+\":latest\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc pullImages(ctx context.Context, client *client.Client, image string) error {\n\tout, err := client.ImagePull(ctx, image, types.ImagePullOptions{})\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\t_, err = io.Copy(io.Discard, out)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc loadCpuAndMem(client *client.Client, container string) (float64, float64) {\n\tres, err := client.ContainerStats(context.Background(), container, false)\n\tif err != nil {\n\t\treturn 0, 0\n\t}\n\n\tbody, err := io.ReadAll(res.Body)\n\tif err != nil {\n\t\tres.Body.Close()\n\t\treturn 0, 0\n\t}\n\tres.Body.Close()\n\tvar stats *types.StatsJSON\n\tif err := json.Unmarshal(body, &stats); err != nil {\n\t\treturn 0, 0\n\t}\n\n\tCPUPercent := calculateCPUPercentUnix(stats)\n\tMemPercent := calculateMemPercentUnix(stats.MemoryStats)\n\treturn CPUPercent, MemPercent\n}\n\nfunc checkPortStats(ports []dto.PortHelper) (nat.PortMap, error) {\n\tportMap := make(nat.PortMap)\n\tif len(ports) == 0 {\n\t\treturn portMap, nil\n\t}\n\tfor _, port := range ports {\n\t\tif strings.Contains(port.ContainerPort, \"-\") {\n\t\t\tif !strings.Contains(port.HostPort, \"-\") {\n\t\t\t\treturn portMap, buserr.New(constant.ErrPortRules)\n\t\t\t}\n\t\t\thostStart, _ := strconv.Atoi(strings.Split(port.HostPort, \"-\")[0])\n\t\t\thostEnd, _ := strconv.Atoi(strings.Split(port.HostPort, \"-\")[1])\n\t\t\tcontainerStart, _ := strconv.Atoi(strings.Split(port.ContainerPort, \"-\")[0])\n\t\t\tcontainerEnd, _ := strconv.Atoi(strings.Split(port.ContainerPort, \"-\")[1])\n\t\t\tif (hostEnd-hostStart) <= 0 || (containerEnd-containerStart) <= 0 {\n\t\t\t\treturn portMap, buserr.New(constant.ErrPortRules)\n\t\t\t}\n\t\t\tif (containerEnd - containerStart) != (hostEnd - hostStart) {\n\t\t\t\treturn portMap, buserr.New(constant.ErrPortRules)\n\t\t\t}\n\t\t\tfor i := 0; i <= hostEnd-hostStart; i++ {\n\t\t\t\tbindItem := nat.PortBinding{HostPort: strconv.Itoa(hostStart + i), HostIP: port.HostIP}\n\t\t\t\tportMap[nat.Port(fmt.Sprintf(\"%d/%s\", containerStart+i, port.Protocol))] = []nat.PortBinding{bindItem}\n\t\t\t}\n\t\t\tfor i := hostStart; i <= hostEnd; i++ {\n\t\t\t\tif common.ScanPort(i) {\n\t\t\t\t\treturn portMap, buserr.WithDetail(constant.ErrPortInUsed, i, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tportItem := 0\n\t\t\tif strings.Contains(port.HostPort, \"-\") {\n\t\t\t\tportItem, _ = strconv.Atoi(strings.Split(port.HostPort, \"-\")[0])\n\t\t\t} else {\n\t\t\t\tportItem, _ = strconv.Atoi(port.HostPort)\n\t\t\t}\n\t\t\tif common.ScanPort(portItem) {\n\t\t\t\treturn portMap, buserr.WithDetail(constant.ErrPortInUsed, portItem, nil)\n\t\t\t}\n\t\t\tbindItem := nat.PortBinding{HostPort: strconv.Itoa(portItem), HostIP: port.HostIP}\n\t\t\tportMap[nat.Port(fmt.Sprintf(\"%s/%s\", port.ContainerPort, port.Protocol))] = []nat.PortBinding{bindItem}\n\t\t}\n\t}\n\treturn portMap, nil\n}\n\nfunc loadConfigInfo(req dto.ContainerOperate, config *container.Config, hostConf *container.HostConfig, networkConf *network.NetworkingConfig) error {\n\tportMap, err := checkPortStats(req.ExposedPorts)\n\tif err != nil {\n\t\treturn err\n\t}\n\texposeds := make(nat.PortSet)\n\tfor port := range portMap {\n\t\texposeds[port] = struct{}{}\n\t}\n\tconfig.Image = req.Image\n\tconfig.Cmd = req.Cmd\n\tconfig.Env = req.Env\n\tconfig.Labels = stringsToMap(req.Labels)\n\tconfig.ExposedPorts = exposeds\n\n\tnetworkConf.EndpointsConfig = map[string]*network.EndpointSettings{req.Network: {}}\n\n\thostConf.AutoRemove = req.AutoRemove\n\thostConf.CPUShares = req.CPUShares\n\thostConf.PublishAllPorts = req.PublishAllPorts\n\thostConf.RestartPolicy = container.RestartPolicy{Name: req.RestartPolicy}\n\tif req.RestartPolicy == \"on-failure\" {\n\t\thostConf.RestartPolicy.MaximumRetryCount = 5\n\t}\n\thostConf.NanoCPUs = int64(req.NanoCPUs * 1000000000)\n\thostConf.Memory = int64(req.Memory * 1024 * 1024)\n\thostConf.PortBindings = portMap\n\thostConf.Binds = []string{}\n\tconfig.Volumes = make(map[string]struct{})\n\tfor _, volume := range req.Volumes {\n\t\tconfig.Volumes[volume.ContainerDir] = struct{}{}\n\t\thostConf.Binds = append(hostConf.Binds, fmt.Sprintf(\"%s:%s:%s\", volume.SourceDir, volume.ContainerDir, volume.Mode))\n\t}\n\treturn nil\n}\n", "package service\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/app/model\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/compose\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/docker\"\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/filters\"\n\t\"golang.org/x/net/context\"\n)\n\nconst composeProjectLabel = \"com.docker.compose.project\"\nconst composeConfigLabel = \"com.docker.compose.project.config_files\"\nconst composeWorkdirLabel = \"com.docker.compose.project.working_dir\"\nconst composeCreatedBy = \"createdBy\"\n\nfunc (u *ContainerService) PageCompose(req dto.SearchWithPage) (int64, interface{}, error) {\n\tvar (\n\t\trecords   []dto.ComposeInfo\n\t\tBackDatas []dto.ComposeInfo\n\t)\n\tclient, err := docker.NewDockerClient()\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\toptions := types.ContainerListOptions{All: true}\n\toptions.Filters = filters.NewArgs()\n\toptions.Filters.Add(\"label\", composeProjectLabel)\n\n\tlist, err := client.ContainerList(context.Background(), options)\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\n\tcomposeCreatedByLocal, _ := composeRepo.ListRecord()\n\tcomposeMap := make(map[string]dto.ComposeInfo)\n\tfor _, container := range list {\n\t\tif name, ok := container.Labels[composeProjectLabel]; ok {\n\t\t\tcontainerItem := dto.ComposeContainer{\n\t\t\t\tContainerID: container.ID,\n\t\t\t\tName:        container.Names[0][1:],\n\t\t\t\tState:       container.State,\n\t\t\t\tCreateTime:  time.Unix(container.Created, 0).Format(\"2006-01-02 15:04:05\"),\n\t\t\t}\n\t\t\tif compose, has := composeMap[name]; has {\n\t\t\t\tcompose.ContainerNumber++\n\t\t\t\tcompose.Containers = append(compose.Containers, containerItem)\n\t\t\t\tcomposeMap[name] = compose\n\t\t\t} else {\n\t\t\t\tconfig := container.Labels[composeConfigLabel]\n\t\t\t\tworkdir := container.Labels[composeWorkdirLabel]\n\t\t\t\tcomposeItem := dto.ComposeInfo{\n\t\t\t\t\tContainerNumber: 1,\n\t\t\t\t\tCreatedAt:       time.Unix(container.Created, 0).Format(\"2006-01-02 15:04:05\"),\n\t\t\t\t\tConfigFile:      config,\n\t\t\t\t\tWorkdir:         workdir,\n\t\t\t\t\tContainers:      []dto.ComposeContainer{containerItem},\n\t\t\t\t}\n\t\t\t\tcreatedBy, ok := container.Labels[composeCreatedBy]\n\t\t\t\tif ok {\n\t\t\t\t\tcomposeItem.CreatedBy = createdBy\n\t\t\t\t}\n\t\t\t\tif len(config) != 0 && len(workdir) != 0 && strings.Contains(config, workdir) {\n\t\t\t\t\tcomposeItem.Path = config\n\t\t\t\t} else {\n\t\t\t\t\tcomposeItem.Path = workdir\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < len(composeCreatedByLocal); i++ {\n\t\t\t\t\tif composeCreatedByLocal[i].Name == name {\n\t\t\t\t\t\tcomposeItem.CreatedBy = \"1Panel\"\n\t\t\t\t\t\tcomposeCreatedByLocal = append(composeCreatedByLocal[:i], composeCreatedByLocal[i+1:]...)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcomposeMap[name] = composeItem\n\t\t\t}\n\t\t}\n\t}\n\tfor _, item := range composeCreatedByLocal {\n\t\tif err := composeRepo.DeleteRecord(commonRepo.WithByID(item.ID)); err != nil {\n\t\t\tglobal.LOG.Error(err)\n\t\t}\n\t}\n\tfor key, value := range composeMap {\n\t\tvalue.Name = key\n\t\trecords = append(records, value)\n\t}\n\tif len(req.Info) != 0 {\n\t\tlength, count := len(records), 0\n\t\tfor count < length {\n\t\t\tif !strings.Contains(records[count].Name, req.Info) {\n\t\t\t\trecords = append(records[:count], records[(count+1):]...)\n\t\t\t\tlength--\n\t\t\t} else {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\tsort.Slice(records, func(i, j int) bool {\n\t\treturn records[i].CreatedAt > records[j].CreatedAt\n\t})\n\ttotal, start, end := len(records), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\tBackDatas = make([]dto.ComposeInfo, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\tBackDatas = records[start:end]\n\t}\n\treturn int64(total), BackDatas, nil\n}\n\nfunc (u *ContainerService) TestCompose(req dto.ComposeCreate) (bool, error) {\n\tif cmd.CheckIllegal(req.Path) {\n\t\treturn false, buserr.New(constant.ErrCmdIllegal)\n\t}\n\tcomposeItem, _ := composeRepo.GetRecord(commonRepo.WithByName(req.Name))\n\tif composeItem.ID != 0 {\n\t\treturn false, constant.ErrRecordExist\n\t}\n\tif err := u.loadPath(&req); err != nil {\n\t\treturn false, err\n\t}\n\tcmd := exec.Command(\"docker-compose\", \"-f\", req.Path, \"config\")\n\tstdout, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn false, errors.New(string(stdout))\n\t}\n\treturn true, nil\n}\n\nfunc (u *ContainerService) CreateCompose(req dto.ComposeCreate) (string, error) {\n\tif cmd.CheckIllegal(req.Name, req.Path) {\n\t\treturn \"\", buserr.New(constant.ErrCmdIllegal)\n\t}\n\tif err := u.loadPath(&req); err != nil {\n\t\treturn \"\", err\n\t}\n\tglobal.LOG.Infof(\"docker-compose.yml %s create successful, start to docker-compose up\", req.Name)\n\n\tif req.From == \"path\" {\n\t\treq.Name = path.Base(strings.ReplaceAll(req.Path, \"/\"+path.Base(req.Path), \"\"))\n\t}\n\tlogName := path.Dir(req.Path) + \"/compose.log\"\n\tfile, err := os.OpenFile(logName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tgo func() {\n\t\tdefer file.Close()\n\t\tcmd := exec.Command(\"docker-compose\", \"-f\", req.Path, \"up\", \"-d\")\n\t\tmultiWriter := io.MultiWriter(os.Stdout, file)\n\t\tcmd.Stdout = multiWriter\n\t\tcmd.Stderr = multiWriter\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tglobal.LOG.Errorf(\"docker-compose up %s failed, err: %v\", req.Name, err)\n\t\t\t_, _ = compose.Down(req.Path)\n\t\t\t_, _ = file.WriteString(\"docker-compose up failed!\")\n\t\t\treturn\n\t\t}\n\t\tglobal.LOG.Infof(\"docker-compose up %s successful!\", req.Name)\n\t\t_ = composeRepo.CreateRecord(&model.Compose{Name: req.Name})\n\t\t_, _ = file.WriteString(\"docker-compose up successful!\")\n\t}()\n\n\treturn logName, nil\n}\n\nfunc (u *ContainerService) ComposeOperation(req dto.ComposeOperation) error {\n\tif cmd.CheckIllegal(req.Path, req.Operation) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\tif _, err := os.Stat(req.Path); err != nil {\n\t\treturn fmt.Errorf(\"load file with path %s failed, %v\", req.Path, err)\n\t}\n\tif stdout, err := compose.Operate(req.Path, req.Operation); err != nil {\n\t\treturn errors.New(string(stdout))\n\t}\n\tglobal.LOG.Infof(\"docker-compose %s %s successful\", req.Operation, req.Name)\n\tif req.Operation == \"down\" {\n\t\t_ = composeRepo.DeleteRecord(commonRepo.WithByName(req.Name))\n\t\tif req.WithFile {\n\t\t\t_ = os.RemoveAll(path.Dir(req.Path))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) ComposeUpdate(req dto.ComposeUpdate) error {\n\tif cmd.CheckIllegal(req.Name, req.Path) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\tif _, err := os.Stat(req.Path); err != nil {\n\t\treturn fmt.Errorf(\"load file with path %s failed, %v\", req.Path, err)\n\t}\n\tfile, err := os.OpenFile(req.Path, os.O_WRONLY|os.O_TRUNC, 0640)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\twrite := bufio.NewWriter(file)\n\t_, _ = write.WriteString(req.Content)\n\twrite.Flush()\n\n\tglobal.LOG.Infof(\"docker-compose.yml %s has been replaced, now start to docker-compose restart\", req.Path)\n\tif stdout, err := compose.Down(req.Path); err != nil {\n\t\treturn errors.New(string(stdout))\n\t}\n\tif stdout, err := compose.Up(req.Path); err != nil {\n\t\treturn errors.New(string(stdout))\n\t}\n\n\treturn nil\n}\n\nfunc (u *ContainerService) loadPath(req *dto.ComposeCreate) error {\n\tif req.From == \"template\" || req.From == \"edit\" {\n\t\tdir := fmt.Sprintf(\"%s/docker/compose/%s\", constant.DataDir, req.Name)\n\t\tif _, err := os.Stat(dir); err != nil && os.IsNotExist(err) {\n\t\t\tif err = os.MkdirAll(dir, os.ModePerm); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tpath := fmt.Sprintf(\"%s/docker-compose.yml\", dir)\n\t\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer file.Close()\n\t\twrite := bufio.NewWriter(file)\n\t\t_, _ = write.WriteString(string(req.File))\n\t\twrite.Flush()\n\t\treq.Path = path\n\t}\n\treturn nil\n}\n", "package service\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/app/model\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/compose\"\n\t_ \"github.com/go-sql-driver/mysql\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/pkg/errors\"\n)\n\ntype MysqlService struct{}\n\ntype IMysqlService interface {\n\tSearchWithPage(search dto.SearchWithPage) (int64, interface{}, error)\n\tListDBName() ([]string, error)\n\tCreate(ctx context.Context, req dto.MysqlDBCreate) (*model.DatabaseMysql, error)\n\tChangeAccess(info dto.ChangeDBInfo) error\n\tChangePassword(info dto.ChangeDBInfo) error\n\tUpdateVariables(updates []dto.MysqlVariablesUpdate) error\n\tUpdateConfByFile(info dto.MysqlConfUpdateByFile) error\n\tUpdateDescription(req dto.UpdateDescription) error\n\tDeleteCheck(id uint) ([]string, error)\n\tDelete(ctx context.Context, req dto.MysqlDBDelete) error\n\tLoadStatus() (*dto.MysqlStatus, error)\n\tLoadVariables() (*dto.MysqlVariables, error)\n\tLoadBaseInfo() (*dto.DBBaseInfo, error)\n\tLoadRemoteAccess() (bool, error)\n}\n\nfunc NewIMysqlService() IMysqlService {\n\treturn &MysqlService{}\n}\n\nfunc (u *MysqlService) SearchWithPage(search dto.SearchWithPage) (int64, interface{}, error) {\n\ttotal, mysqls, err := mysqlRepo.Page(search.Page, search.PageSize, commonRepo.WithLikeName(search.Info), commonRepo.WithOrderRuleBy(search.OrderBy, search.Order))\n\tvar dtoMysqls []dto.MysqlDBInfo\n\tfor _, mysql := range mysqls {\n\t\tvar item dto.MysqlDBInfo\n\t\tif err := copier.Copy(&item, &mysql); err != nil {\n\t\t\treturn 0, nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t\t}\n\t\tdtoMysqls = append(dtoMysqls, item)\n\t}\n\treturn total, dtoMysqls, err\n}\n\nfunc (u *MysqlService) ListDBName() ([]string, error) {\n\tmysqls, err := mysqlRepo.List()\n\tvar dbNames []string\n\tfor _, mysql := range mysqls {\n\t\tdbNames = append(dbNames, mysql.Name)\n\t}\n\treturn dbNames, err\n}\n\nvar formatMap = map[string]string{\n\t\"utf8\":    \"utf8_general_ci\",\n\t\"utf8mb4\": \"utf8mb4_general_ci\",\n\t\"gbk\":     \"gbk_chinese_ci\",\n\t\"big5\":    \"big5_chinese_ci\",\n}\n\nfunc (u *MysqlService) Create(ctx context.Context, req dto.MysqlDBCreate) (*model.DatabaseMysql, error) {\n\tif cmd.CheckIllegal(req.Name, req.Username, req.Password, req.Format, req.Permission) {\n\t\treturn nil, buserr.New(constant.ErrCmdIllegal)\n\t}\n\n\tif req.Username == \"root\" {\n\t\treturn nil, errors.New(\"Cannot set root as user name\")\n\t}\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmysql, _ := mysqlRepo.Get(commonRepo.WithByName(req.Name))\n\tif mysql.ID != 0 {\n\t\treturn nil, constant.ErrRecordExist\n\t}\n\tif err := copier.Copy(&mysql, &req); err != nil {\n\t\treturn nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t}\n\n\tcreateSql := fmt.Sprintf(\"create database `%s` default character set %s collate %s\", req.Name, req.Format, formatMap[req.Format])\n\tif err := excSQL(app.ContainerName, app.Password, createSql); err != nil {\n\t\tif strings.Contains(err.Error(), \"ERROR 1007\") {\n\t\t\treturn nil, buserr.New(constant.ErrDatabaseIsExist)\n\t\t}\n\t\treturn nil, err\n\t}\n\tif err := u.createUser(app.ContainerName, app.Password, app.Version, req); err != nil {\n\t\treturn nil, err\n\t}\n\n\tglobal.LOG.Infof(\"create database %s successful!\", req.Name)\n\tmysql.MysqlName = app.Name\n\tif err := mysqlRepo.Create(ctx, &mysql); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &mysql, nil\n}\n\nfunc (u *MysqlService) UpdateDescription(req dto.UpdateDescription) error {\n\treturn mysqlRepo.Update(req.ID, map[string]interface{}{\"description\": req.Description})\n}\n\nfunc (u *MysqlService) DeleteCheck(id uint) ([]string, error) {\n\tvar appInUsed []string\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn appInUsed, err\n\t}\n\n\tdb, err := mysqlRepo.Get(commonRepo.WithByID(id))\n\tif err != nil {\n\t\treturn appInUsed, err\n\t}\n\n\tapps, _ := appInstallResourceRepo.GetBy(appInstallResourceRepo.WithLinkId(app.ID), appInstallResourceRepo.WithResourceId(db.ID))\n\tfor _, app := range apps {\n\t\tappInstall, _ := appInstallRepo.GetFirst(commonRepo.WithByID(app.AppInstallId))\n\t\tif appInstall.ID != 0 {\n\t\t\tappInUsed = append(appInUsed, appInstall.Name)\n\t\t}\n\t}\n\treturn appInUsed, nil\n}\n\nfunc (u *MysqlService) Delete(ctx context.Context, req dto.MysqlDBDelete) error {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil && !req.ForceDelete {\n\t\treturn err\n\t}\n\n\tdb, err := mysqlRepo.Get(commonRepo.WithByID(req.ID))\n\tif err != nil && !req.ForceDelete {\n\t\treturn err\n\t}\n\n\tif strings.HasPrefix(app.Version, \"5.6\") {\n\t\tif err := excSQL(app.ContainerName, app.Password, fmt.Sprintf(\"drop user '%s'@'%s'\", db.Username, db.Permission)); err != nil && !req.ForceDelete {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := excSQL(app.ContainerName, app.Password, fmt.Sprintf(\"drop user if exists '%s'@'%s'\", db.Username, db.Permission)); err != nil && !req.ForceDelete {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := excSQL(app.ContainerName, app.Password, fmt.Sprintf(\"drop database if exists `%s`\", db.Name)); err != nil && !req.ForceDelete {\n\t\treturn err\n\t}\n\tglobal.LOG.Info(\"execute delete database sql successful, now start to drop uploads and records\")\n\n\tuploadDir := fmt.Sprintf(\"%s/1panel/uploads/database/mysql/%s/%s\", global.CONF.System.BaseDir, app.Name, db.Name)\n\tif _, err := os.Stat(uploadDir); err == nil {\n\t\t_ = os.RemoveAll(uploadDir)\n\t}\n\tif req.DeleteBackup {\n\t\tlocalDir, err := loadLocalDir()\n\t\tif err != nil && !req.ForceDelete {\n\t\t\treturn err\n\t\t}\n\t\tbackupDir := fmt.Sprintf(\"%s/database/mysql/%s/%s\", localDir, db.MysqlName, db.Name)\n\t\tif _, err := os.Stat(backupDir); err == nil {\n\t\t\t_ = os.RemoveAll(backupDir)\n\t\t}\n\t\tglobal.LOG.Infof(\"delete database %s-%s backups successful\", app.Name, db.Name)\n\t}\n\t_ = backupRepo.DeleteRecord(ctx, commonRepo.WithByType(\"mysql\"), commonRepo.WithByName(app.Name), backupRepo.WithByDetailName(db.Name))\n\n\t_ = mysqlRepo.Delete(ctx, commonRepo.WithByID(db.ID))\n\treturn nil\n}\n\nfunc (u *MysqlService) ChangePassword(info dto.ChangeDBInfo) error {\n\tif cmd.CheckIllegal(info.Value) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\n\tvar (\n\t\tmysql model.DatabaseMysql\n\t\terr   error\n\t)\n\tif info.ID != 0 {\n\t\tmysql, err = mysqlRepo.Get(commonRepo.WithByID(info.ID))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpasswordChangeCMD := fmt.Sprintf(\"set password for '%s'@'%s' = password('%s')\", mysql.Username, mysql.Permission, info.Value)\n\tif !strings.HasPrefix(app.Version, \"5.7\") && !strings.HasPrefix(app.Version, \"5.6\") {\n\t\tpasswordChangeCMD = fmt.Sprintf(\"ALTER USER '%s'@'%s' IDENTIFIED WITH mysql_native_password BY '%s';\", mysql.Username, mysql.Permission, info.Value)\n\t}\n\tif info.ID != 0 {\n\t\tappRess, _ := appInstallResourceRepo.GetBy(appInstallResourceRepo.WithLinkId(app.ID), appInstallResourceRepo.WithResourceId(mysql.ID))\n\t\tfor _, appRes := range appRess {\n\t\t\tappInstall, err := appInstallRepo.GetFirst(commonRepo.WithByID(appRes.AppInstallId))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tappModel, err := appRepo.GetFirst(commonRepo.WithByID(appInstall.AppId))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tglobal.LOG.Infof(\"start to update mysql password used by app %s-%s\", appModel.Key, appInstall.Name)\n\t\t\tif err := updateInstallInfoInDB(appModel.Key, appInstall.Name, \"user-password\", true, info.Value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := excuteSql(app.ContainerName, app.Password, passwordChangeCMD); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tglobal.LOG.Info(\"excute password change sql successful\")\n\t\t_ = mysqlRepo.Update(mysql.ID, map[string]interface{}{\"password\": info.Value})\n\t\treturn nil\n\t}\n\n\thosts, err := excuteSqlForRows(app.ContainerName, app.Password, \"select host from mysql.user where user='root';\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, host := range hosts {\n\t\tif host == \"%\" || host == \"localhost\" {\n\t\t\tpasswordRootChangeCMD := fmt.Sprintf(\"set password for 'root'@'%s' = password('%s')\", host, info.Value)\n\t\t\tif !strings.HasPrefix(app.Version, \"5.7\") && !strings.HasPrefix(app.Version, \"5.6\") {\n\t\t\t\tpasswordRootChangeCMD = fmt.Sprintf(\"alter user 'root'@'%s' identified with mysql_native_password BY '%s';\", host, info.Value)\n\t\t\t}\n\t\t\tif err := excuteSql(app.ContainerName, app.Password, passwordRootChangeCMD); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif err := updateInstallInfoInDB(\"mysql\", \"\", \"password\", false, info.Value); err != nil {\n\t\treturn err\n\t}\n\tif err := updateInstallInfoInDB(\"phpmyadmin\", \"\", \"password\", true, info.Value); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (u *MysqlService) ChangeAccess(info dto.ChangeDBInfo) error {\n\tif cmd.CheckIllegal(info.Value) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\tvar (\n\t\tmysql model.DatabaseMysql\n\t\terr   error\n\t)\n\tif info.ID != 0 {\n\t\tmysql, err = mysqlRepo.Get(commonRepo.WithByID(info.ID))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.Value == mysql.Permission {\n\t\t\treturn nil\n\t\t}\n\t}\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif info.ID == 0 {\n\t\tmysql.Name = \"*\"\n\t\tmysql.Username = \"root\"\n\t\tmysql.Permission = \"%\"\n\t\tmysql.Password = app.Password\n\t}\n\n\tif info.Value != mysql.Permission {\n\t\tvar userlist []string\n\t\tif strings.Contains(mysql.Permission, \",\") {\n\t\t\tuserlist = strings.Split(mysql.Permission, \",\")\n\t\t} else {\n\t\t\tuserlist = append(userlist, mysql.Permission)\n\t\t}\n\t\tfor _, user := range userlist {\n\t\t\tif len(user) != 0 {\n\t\t\t\tif strings.HasPrefix(app.Version, \"5.6\") {\n\t\t\t\t\tif err := excuteSql(app.ContainerName, app.Password, fmt.Sprintf(\"drop user '%s'@'%s'\", mysql.Username, user)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif err := excuteSql(app.ContainerName, app.Password, fmt.Sprintf(\"drop user if exists '%s'@'%s'\", mysql.Username, user)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif info.ID == 0 {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif err := u.createUser(app.ContainerName, app.Password, app.Version, dto.MysqlDBCreate{\n\t\tUsername:   mysql.Username,\n\t\tName:       mysql.Name,\n\t\tPermission: info.Value,\n\t\tPassword:   mysql.Password,\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := excuteSql(app.ContainerName, app.Password, \"flush privileges\"); err != nil {\n\t\treturn err\n\t}\n\tif info.ID == 0 {\n\t\treturn nil\n\t}\n\n\t_ = mysqlRepo.Update(mysql.ID, map[string]interface{}{\"permission\": info.Value})\n\n\treturn nil\n}\n\nfunc (u *MysqlService) UpdateConfByFile(info dto.MysqlConfUpdateByFile) error {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tpath := fmt.Sprintf(\"%s/mysql/%s/conf/my.cnf\", constant.AppInstallDir, app.Name)\n\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0640)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\twrite := bufio.NewWriter(file)\n\t_, _ = write.WriteString(info.File)\n\twrite.Flush()\n\tif _, err := compose.Restart(fmt.Sprintf(\"%s/mysql/%s/docker-compose.yml\", constant.AppInstallDir, app.Name)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (u *MysqlService) UpdateVariables(updates []dto.MysqlVariablesUpdate) error {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar files []string\n\n\tpath := fmt.Sprintf(\"%s/mysql/%s/conf/my.cnf\", constant.AppInstallDir, app.Name)\n\tlineBytes, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfiles = strings.Split(string(lineBytes), \"\\n\")\n\n\tgroup := \"[mysqld]\"\n\tfor _, info := range updates {\n\t\tif !strings.HasPrefix(app.Version, \"5.7\") && !strings.HasPrefix(app.Version, \"5.6\") {\n\t\t\tif info.Param == \"query_cache_size\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif _, ok := info.Value.(float64); ok {\n\t\t\tfiles = updateMyCnf(files, group, info.Param, common.LoadSizeUnit(info.Value.(float64)))\n\t\t} else {\n\t\t\tfiles = updateMyCnf(files, group, info.Param, info.Value)\n\t\t}\n\t}\n\tfile, err := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = file.WriteString(strings.Join(files, \"\\n\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := compose.Restart(fmt.Sprintf(\"%s/mysql/%s/docker-compose.yml\", constant.AppInstallDir, app.Name)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (u *MysqlService) LoadBaseInfo() (*dto.DBBaseInfo, error) {\n\tvar data dto.DBBaseInfo\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata.ContainerName = app.ContainerName\n\tdata.Name = app.Name\n\tdata.Port = int64(app.Port)\n\n\treturn &data, nil\n}\n\nfunc (u *MysqlService) LoadRemoteAccess() (bool, error) {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\thosts, err := excuteSqlForRows(app.ContainerName, app.Password, \"select host from mysql.user where user='root';\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, host := range hosts {\n\t\tif host == \"%\" {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (u *MysqlService) LoadVariables() (*dto.MysqlVariables, error) {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvariableMap, err := excuteSqlForMaps(app.ContainerName, app.Password, \"show global variables;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar info dto.MysqlVariables\n\tarr, err := json.Marshal(variableMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_ = json.Unmarshal(arr, &info)\n\treturn &info, nil\n}\n\nfunc (u *MysqlService) LoadStatus() (*dto.MysqlStatus, error) {\n\tapp, err := appInstallRepo.LoadBaseInfo(\"mysql\", \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstatusMap, err := excuteSqlForMaps(app.ContainerName, app.Password, \"show global status;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar info dto.MysqlStatus\n\tarr, err := json.Marshal(statusMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_ = json.Unmarshal(arr, &info)\n\n\tif value, ok := statusMap[\"Run\"]; ok {\n\t\tuptime, _ := strconv.Atoi(value)\n\t\tinfo.Run = time.Unix(time.Now().Unix()-int64(uptime), 0).Format(\"2006-01-02 15:04:05\")\n\t} else {\n\t\tif value, ok := statusMap[\"Uptime\"]; ok {\n\t\t\tuptime, _ := strconv.Atoi(value)\n\t\t\tinfo.Run = time.Unix(time.Now().Unix()-int64(uptime), 0).Format(\"2006-01-02 15:04:05\")\n\t\t}\n\t}\n\n\tinfo.File = \"OFF\"\n\tinfo.Position = \"OFF\"\n\trows, err := excuteSqlForRows(app.ContainerName, app.Password, \"show master status;\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(rows) > 2 {\n\t\titemValue := strings.Split(rows[1], \"\\t\")\n\t\tif len(itemValue) > 2 {\n\t\t\tinfo.File = itemValue[0]\n\t\t\tinfo.Position = itemValue[1]\n\t\t}\n\t}\n\n\treturn &info, nil\n}\n\nfunc (u *MysqlService) createUser(container, password, version string, req dto.MysqlDBCreate) error {\n\tvar userlist []string\n\tif strings.Contains(req.Permission, \",\") {\n\t\tips := strings.Split(req.Permission, \",\")\n\t\tfor _, ip := range ips {\n\t\t\tif len(ip) != 0 {\n\t\t\t\tuserlist = append(userlist, fmt.Sprintf(\"'%s'@'%s'\", req.Username, ip))\n\t\t\t}\n\t\t}\n\t} else {\n\t\tuserlist = append(userlist, fmt.Sprintf(\"'%s'@'%s'\", req.Username, req.Permission))\n\t}\n\n\tfor _, user := range userlist {\n\t\tif err := excSQL(container, password, fmt.Sprintf(\"create user %s identified by '%s';\", user, req.Password)); err != nil {\n\t\t\tif strings.Contains(err.Error(), \"ERROR 1396\") {\n\t\t\t\thandleCreateError(container, password, req.Name, userlist, false)\n\t\t\t\treturn buserr.New(constant.ErrUserIsExist)\n\t\t\t}\n\t\t\thandleCreateError(container, password, req.Name, userlist, true)\n\t\t\treturn err\n\t\t}\n\t\tgrantStr := fmt.Sprintf(\"grant all privileges on `%s`.* to %s\", req.Name, user)\n\t\tif req.Name == \"*\" {\n\t\t\tgrantStr = fmt.Sprintf(\"grant all privileges on *.* to %s\", user)\n\t\t}\n\t\tif strings.HasPrefix(version, \"5.7\") || strings.HasPrefix(version, \"5.6\") {\n\t\t\tgrantStr = fmt.Sprintf(\"%s identified by '%s' with grant option;\", grantStr, req.Password)\n\t\t}\n\t\tif err := excSQL(container, password, grantStr); err != nil {\n\t\t\thandleCreateError(container, password, req.Name, userlist, true)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\nfunc handleCreateError(contaienr, password, dbName string, userlist []string, dropUser bool) {\n\t_ = excSQL(contaienr, password, fmt.Sprintf(\"drop database `%s`\", dbName))\n\tif dropUser {\n\t\tfor _, user := range userlist {\n\t\t\tif err := excSQL(contaienr, password, fmt.Sprintf(\"drop user if exists %s\", user)); err != nil {\n\t\t\t\tglobal.LOG.Errorf(\"drop user failed, err: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc excuteSqlForMaps(containerName, password, command string) (map[string]string, error) {\n\tcmd := exec.Command(\"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn nil, errors.New(stdStr)\n\t}\n\n\trows := strings.Split(stdStr, \"\\n\")\n\trowMap := make(map[string]string)\n\tfor _, v := range rows {\n\t\titemRow := strings.Split(v, \"\\t\")\n\t\tif len(itemRow) == 2 {\n\t\t\trowMap[itemRow[0]] = itemRow[1]\n\t\t}\n\t}\n\treturn rowMap, nil\n}\n\nfunc excuteSqlForRows(containerName, password, command string) ([]string, error) {\n\tcmd := exec.Command(\"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn nil, errors.New(stdStr)\n\t}\n\treturn strings.Split(stdStr, \"\\n\"), nil\n}\n\nfunc excuteSql(containerName, password, command string) error {\n\tcmd := exec.Command(\"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn errors.New(stdStr)\n\t}\n\treturn nil\n}\n\nfunc excSQL(containerName, password, command string) error {\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel()\n\tcmd := exec.CommandContext(ctx, \"docker\", \"exec\", containerName, \"mysql\", \"-uroot\", \"-p\"+password, \"-e\", command)\n\tstdout, err := cmd.CombinedOutput()\n\tif ctx.Err() == context.DeadlineExceeded {\n\t\treturn buserr.WithDetail(constant.ErrExecTimeOut, containerName, nil)\n\t}\n\tstdStr := strings.ReplaceAll(string(stdout), \"mysql: [Warning] Using a password on the command line interface can be insecure.\\n\", \"\")\n\tif err != nil || strings.HasPrefix(string(stdStr), \"ERROR \") {\n\t\treturn errors.New(stdStr)\n\t}\n\treturn nil\n}\n\nfunc updateMyCnf(oldFiles []string, group string, param string, value interface{}) []string {\n\tisOn := false\n\thasGroup := false\n\thasKey := false\n\tregItem, _ := regexp.Compile(`\\[*\\]`)\n\tvar newFiles []string\n\ti := 0\n\tfor _, line := range oldFiles {\n\t\ti++\n\t\tif strings.HasPrefix(line, group) {\n\t\t\tisOn = true\n\t\t\thasGroup = true\n\t\t\tnewFiles = append(newFiles, line)\n\t\t\tcontinue\n\t\t}\n\t\tif !isOn {\n\t\t\tnewFiles = append(newFiles, line)\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasPrefix(line, param+\"=\") || strings.HasPrefix(line, \"# \"+param+\"=\") {\n\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s=%v\", param, value))\n\t\t\thasKey = true\n\t\t\tcontinue\n\t\t}\n\t\tif regItem.Match([]byte(line)) || i == len(oldFiles) {\n\t\t\tisOn = false\n\t\t\tif !hasKey {\n\t\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s=%v\", param, value))\n\t\t\t}\n\t\t\tnewFiles = append(newFiles, line)\n\t\t\tcontinue\n\t\t}\n\t\tnewFiles = append(newFiles, line)\n\t}\n\tif !hasGroup {\n\t\tnewFiles = append(newFiles, group+\"\\n\")\n\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s=%v\\n\", param, value))\n\t}\n\treturn newFiles\n}\n", "package service\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/firewall\"\n\tfireClient \"github.com/1Panel-dev/1Panel/backend/utils/firewall/client\"\n\t\"github.com/jinzhu/copier\"\n)\n\nconst confPath = \"/etc/sysctl.conf\"\n\ntype FirewallService struct{}\n\ntype IFirewallService interface {\n\tLoadBaseInfo() (dto.FirewallBaseInfo, error)\n\tSearchWithPage(search dto.RuleSearch) (int64, interface{}, error)\n\tOperateFirewall(operation string) error\n\tOperatePortRule(req dto.PortRuleOperate, reload bool) error\n\tOperateAddressRule(req dto.AddrRuleOperate, reload bool) error\n\tUpdatePortRule(req dto.PortRuleUpdate) error\n\tUpdateAddrRule(req dto.AddrRuleUpdate) error\n\tBatchOperateRule(req dto.BatchRuleOperate) error\n}\n\nfunc NewIFirewallService() IFirewallService {\n\treturn &FirewallService{}\n}\n\nfunc (u *FirewallService) LoadBaseInfo() (dto.FirewallBaseInfo, error) {\n\tvar baseInfo dto.FirewallBaseInfo\n\tbaseInfo.PingStatus = u.pingStatus()\n\tbaseInfo.Status = \"not running\"\n\tbaseInfo.Version = \"-\"\n\tbaseInfo.Name = \"-\"\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\tif err.Error() == \"no such type\" {\n\t\t\treturn baseInfo, nil\n\t\t}\n\t\treturn baseInfo, err\n\t}\n\tbaseInfo.Name = client.Name()\n\tbaseInfo.Status, err = client.Status()\n\tif err != nil {\n\t\treturn baseInfo, err\n\t}\n\tif baseInfo.Status == \"not running\" {\n\t\treturn baseInfo, err\n\t}\n\tbaseInfo.Version, err = client.Version()\n\tif err != nil {\n\t\treturn baseInfo, err\n\t}\n\treturn baseInfo, nil\n}\n\nfunc (u *FirewallService) SearchWithPage(req dto.RuleSearch) (int64, interface{}, error) {\n\tvar (\n\t\tdatas     []fireClient.FireInfo\n\t\tbackDatas []fireClient.FireInfo\n\t)\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn 0, nil, err\n\t}\n\tif req.Type == \"port\" {\n\t\tports, err := client.ListPort()\n\t\tif err != nil {\n\t\t\treturn 0, nil, err\n\t\t}\n\t\tif len(req.Info) != 0 {\n\t\t\tfor _, port := range ports {\n\t\t\t\tif strings.Contains(port.Port, req.Info) {\n\t\t\t\t\tdatas = append(datas, port)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdatas = ports\n\t\t}\n\t} else {\n\t\taddrs, err := client.ListAddress()\n\t\tif err != nil {\n\t\t\treturn 0, nil, err\n\t\t}\n\t\tif len(req.Info) != 0 {\n\t\t\tfor _, addr := range addrs {\n\t\t\t\tif strings.Contains(addr.Address, req.Info) {\n\t\t\t\t\tdatas = append(datas, addr)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdatas = addrs\n\t\t}\n\t}\n\ttotal, start, end := len(datas), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\tbackDatas = make([]fireClient.FireInfo, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\tbackDatas = datas[start:end]\n\t}\n\n\tif req.Type == \"port\" {\n\t\tapps := u.loadPortByApp()\n\t\tfor i := 0; i < len(backDatas); i++ {\n\t\t\tport, _ := strconv.Atoi(backDatas[i].Port)\n\t\t\tbackDatas[i].IsUsed = common.ScanPort(port)\n\t\t\tif backDatas[i].Protocol == \"udp\" {\n\t\t\t\tbackDatas[i].IsUsed = common.ScanUDPPort(port)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, app := range apps {\n\t\t\t\tif app.HttpPort == backDatas[i].Port || app.HttpsPort == backDatas[i].Port {\n\t\t\t\t\tbackDatas[i].APPName = app.AppName\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn int64(total), backDatas, nil\n}\n\nfunc (u *FirewallService) OperateFirewall(operation string) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch operation {\n\tcase \"start\":\n\t\tif err := client.Start(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := u.addPortsBeforeStart(client); err != nil {\n\t\t\t_ = client.Stop()\n\t\t\treturn err\n\t\t}\n\t\t_, _ = cmd.Exec(\"systemctl restart docker\")\n\t\treturn nil\n\tcase \"stop\":\n\t\tif err := client.Stop(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, _ = cmd.Exec(\"systemctl restart docker\")\n\t\treturn nil\n\tcase \"disablePing\":\n\t\treturn u.updatePingStatus(\"0\")\n\tcase \"enablePing\":\n\t\treturn u.updatePingStatus(\"1\")\n\t}\n\treturn fmt.Errorf(\"not support such operation: %s\", operation)\n}\n\nfunc (u *FirewallService) OperatePortRule(req dto.PortRuleOperate, reload bool) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif client.Name() == \"ufw\" {\n\t\treq.Port = strings.ReplaceAll(req.Port, \"-\", \":\")\n\t\tif req.Operation == \"remove\" && req.Protocol == \"tcp/udp\" {\n\t\t\treq.Protocol = \"\"\n\t\t\treturn u.operatePort(client, req)\n\t\t}\n\t}\n\tif req.Protocol == \"tcp/udp\" {\n\t\tif client.Name() == \"firewalld\" && strings.Contains(req.Port, \",\") {\n\t\t\tports := strings.Split(req.Port, \",\")\n\t\t\tfor _, port := range ports {\n\t\t\t\tif len(port) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treq.Port = port\n\t\t\t\treq.Protocol = \"tcp\"\n\t\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treq.Protocol = \"udp\"\n\t\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treq.Protocol = \"tcp\"\n\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treq.Protocol = \"udp\"\n\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif strings.Contains(req.Port, \",\") {\n\t\t\tports := strings.Split(req.Port, \",\")\n\t\t\tfor _, port := range ports {\n\t\t\t\treq.Port = port\n\t\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif err := u.operatePort(client, req); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif reload {\n\t\treturn client.Reload()\n\t}\n\treturn nil\n}\n\nfunc (u *FirewallService) OperateAddressRule(req dto.AddrRuleOperate, reload bool) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar fireInfo fireClient.FireInfo\n\tif err := copier.Copy(&fireInfo, &req); err != nil {\n\t\treturn err\n\t}\n\n\taddressList := strings.Split(req.Address, \",\")\n\tfor _, addr := range addressList {\n\t\tif len(addr) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tfireInfo.Address = addr\n\t\tif err := client.RichRules(fireInfo, req.Operation); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif reload {\n\t\treturn client.Reload()\n\t}\n\treturn nil\n}\n\nfunc (u *FirewallService) UpdatePortRule(req dto.PortRuleUpdate) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperatePortRule(req.OldRule, false); err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperatePortRule(req.NewRule, false); err != nil {\n\t\treturn err\n\t}\n\treturn client.Reload()\n}\n\nfunc (u *FirewallService) UpdateAddrRule(req dto.AddrRuleUpdate) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperateAddressRule(req.OldRule, false); err != nil {\n\t\treturn err\n\t}\n\tif err := u.OperateAddressRule(req.NewRule, false); err != nil {\n\t\treturn err\n\t}\n\treturn client.Reload()\n}\n\nfunc (u *FirewallService) BatchOperateRule(req dto.BatchRuleOperate) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif req.Type == \"port\" {\n\t\tfor _, rule := range req.Rules {\n\t\t\tif err := u.OperatePortRule(rule, false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn client.Reload()\n\t}\n\tfor _, rule := range req.Rules {\n\t\titemRule := dto.AddrRuleOperate{Operation: rule.Operation, Address: rule.Address, Strategy: rule.Strategy}\n\t\tif err := u.OperateAddressRule(itemRule, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn client.Reload()\n}\n\nfunc OperateFirewallPort(oldPorts, newPorts []int) error {\n\tclient, err := firewall.NewFirewallClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, port := range newPorts {\n\t\tif err := client.Port(fireClient.FireInfo{Port: strconv.Itoa(port), Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, port := range oldPorts {\n\t\tif err := client.Port(fireClient.FireInfo{Port: strconv.Itoa(port), Protocol: \"tcp\", Strategy: \"accept\"}, \"remove\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn client.Reload()\n}\n\nfunc (u *FirewallService) operatePort(client firewall.FirewallClient, req dto.PortRuleOperate) error {\n\tvar fireInfo fireClient.FireInfo\n\tif err := copier.Copy(&fireInfo, &req); err != nil {\n\t\treturn err\n\t}\n\n\tif client.Name() == \"ufw\" {\n\t\tif len(fireInfo.Address) != 0 && fireInfo.Address != \"Anywhere\" {\n\t\t\treturn client.RichRules(fireInfo, req.Operation)\n\t\t}\n\t\treturn client.Port(fireInfo, req.Operation)\n\t}\n\n\tif len(fireInfo.Address) != 0 || fireInfo.Strategy == \"drop\" {\n\t\treturn client.RichRules(fireInfo, req.Operation)\n\t}\n\treturn client.Port(fireInfo, req.Operation)\n}\n\ntype portOfApp struct {\n\tAppName   string\n\tHttpPort  string\n\tHttpsPort string\n}\n\nfunc (u *FirewallService) loadPortByApp() []portOfApp {\n\tvar datas []portOfApp\n\tapps, err := appInstallRepo.ListBy()\n\tif err != nil {\n\t\treturn datas\n\t}\n\tfor i := 0; i < len(apps); i++ {\n\t\tdatas = append(datas, portOfApp{\n\t\t\tAppName:   apps[i].App.Key,\n\t\t\tHttpPort:  strconv.Itoa(apps[i].HttpPort),\n\t\t\tHttpsPort: strconv.Itoa(apps[i].HttpsPort),\n\t\t})\n\t}\n\tsystemPort, err := settingRepo.Get(settingRepo.WithByKey(\"ServerPort\"))\n\tif err != nil {\n\t\treturn datas\n\t}\n\tdatas = append(datas, portOfApp{AppName: \"1panel\", HttpPort: systemPort.Value})\n\n\treturn datas\n}\n\nfunc (u *FirewallService) pingStatus() string {\n\tif _, err := os.Stat(\"/etc/sysctl.conf\"); err != nil {\n\t\treturn constant.StatusNone\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\tcommand := fmt.Sprintf(\"%s cat /etc/sysctl.conf | grep net/ipv4/icmp_echo_ignore_all= \", sudo)\n\tstdout, _ := cmd.Exec(command)\n\tif stdout == \"net/ipv4/icmp_echo_ignore_all=1\\n\" {\n\t\treturn constant.StatusEnable\n\t}\n\treturn constant.StatusDisable\n}\n\nfunc (u *FirewallService) updatePingStatus(enable string) error {\n\tlineBytes, err := os.ReadFile(confPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfiles := strings.Split(string(lineBytes), \"\\n\")\n\tvar newFiles []string\n\thasLine := false\n\tfor _, line := range files {\n\t\tif strings.Contains(line, \"net/ipv4/icmp_echo_ignore_all\") || strings.HasPrefix(line, \"net/ipv4/icmp_echo_ignore_all\") {\n\t\t\tnewFiles = append(newFiles, \"net/ipv4/icmp_echo_ignore_all=\"+enable)\n\t\t\thasLine = true\n\t\t} else {\n\t\t\tnewFiles = append(newFiles, line)\n\t\t}\n\t}\n\tif !hasLine {\n\t\tnewFiles = append(newFiles, \"net/ipv4/icmp_echo_ignore_all=\"+enable)\n\t}\n\tfile, err := os.OpenFile(confPath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\t_, err = file.WriteString(strings.Join(newFiles, \"\\n\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsudo := cmd.SudoHandleCmd()\n\tcommand := fmt.Sprintf(\"%s sysctl -p\", sudo)\n\tstdout, err := cmd.Exec(command)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"update ping status failed, err: %v\", stdout)\n\t}\n\n\treturn nil\n}\n\nfunc (u *FirewallService) addPortsBeforeStart(client firewall.FirewallClient) error {\n\tserverPort, err := settingRepo.Get(settingRepo.WithByKey(\"ServerPort\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: serverPort.Value, Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: \"22\", Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: \"80\", Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tif err := client.Port(fireClient.FireInfo{Port: \"443\", Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\treturn err\n\t}\n\tapps := u.loadPortByApp()\n\tfor _, app := range apps {\n\t\tif err := client.Port(fireClient.FireInfo{Port: app.HttpPort, Protocol: \"tcp\", Strategy: \"accept\"}, \"add\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn client.Reload()\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/pkg/errors\"\n)\n\ntype ImageRepoService struct{}\n\ntype IImageRepoService interface {\n\tPage(search dto.SearchWithPage) (int64, interface{}, error)\n\tList() ([]dto.ImageRepoOption, error)\n\tLogin(req dto.OperateByID) error\n\tCreate(req dto.ImageRepoCreate) error\n\tUpdate(req dto.ImageRepoUpdate) error\n\tBatchDelete(req dto.ImageRepoDelete) error\n}\n\nfunc NewIImageRepoService() IImageRepoService {\n\treturn &ImageRepoService{}\n}\n\nfunc (u *ImageRepoService) Page(req dto.SearchWithPage) (int64, interface{}, error) {\n\ttotal, ops, err := imageRepoRepo.Page(req.Page, req.PageSize, commonRepo.WithLikeName(req.Info), commonRepo.WithOrderBy(\"created_at desc\"))\n\tvar dtoOps []dto.ImageRepoInfo\n\tfor _, op := range ops {\n\t\tvar item dto.ImageRepoInfo\n\t\tif err := copier.Copy(&item, &op); err != nil {\n\t\t\treturn 0, nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t\t}\n\t\tdtoOps = append(dtoOps, item)\n\t}\n\treturn total, dtoOps, err\n}\n\nfunc (u *ImageRepoService) Login(req dto.OperateByID) error {\n\trepo, err := imageRepoRepo.Get(commonRepo.WithByID(req.ID))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif repo.Auth {\n\t\tif err := u.CheckConn(repo.DownloadUrl, repo.Username, repo.Password); err != nil {\n\t\t\t_ = imageRepoRepo.Update(repo.ID, map[string]interface{}{\"status\": constant.StatusFailed, \"message\": err.Error()})\n\t\t\treturn err\n\t\t}\n\t}\n\t_ = imageRepoRepo.Update(repo.ID, map[string]interface{}{\"status\": constant.StatusSuccess})\n\treturn nil\n}\n\nfunc (u *ImageRepoService) List() ([]dto.ImageRepoOption, error) {\n\tops, err := imageRepoRepo.List(commonRepo.WithOrderBy(\"created_at desc\"))\n\tvar dtoOps []dto.ImageRepoOption\n\tfor _, op := range ops {\n\t\tif op.Status == constant.StatusSuccess {\n\t\t\tvar item dto.ImageRepoOption\n\t\t\tif err := copier.Copy(&item, &op); err != nil {\n\t\t\t\treturn nil, errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t\t\t}\n\t\t\tdtoOps = append(dtoOps, item)\n\t\t}\n\t}\n\treturn dtoOps, err\n}\n\nfunc (u *ImageRepoService) Create(req dto.ImageRepoCreate) error {\n\tif cmd.CheckIllegal(req.Username, req.Password, req.DownloadUrl) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\timageRepo, _ := imageRepoRepo.Get(commonRepo.WithByName(req.Name))\n\tif imageRepo.ID != 0 {\n\t\treturn constant.ErrRecordExist\n\t}\n\tif req.Protocol == \"http\" {\n\t\t_ = u.handleRegistries(req.DownloadUrl, \"\", \"create\")\n\t\tstdout, err := cmd.Exec(\"systemctl restart docker\")\n\t\tif err != nil {\n\t\t\treturn errors.New(string(stdout))\n\t\t}\n\t\tticker := time.NewTicker(3 * time.Second)\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*20)\n\t\tif err := func() error {\n\t\t\tfor range ticker.C {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\tcancel()\n\t\t\t\t\treturn errors.New(\"the docker service cannot be restarted\")\n\t\t\t\tdefault:\n\t\t\t\t\tstdout, err := cmd.Exec(\"systemctl is-active docker\")\n\t\t\t\t\tif string(stdout) == \"active\\n\" && err == nil {\n\t\t\t\t\t\tglobal.LOG.Info(\"docker restart with new conf successful!\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := copier.Copy(&imageRepo, &req); err != nil {\n\t\treturn errors.WithMessage(constant.ErrStructTransform, err.Error())\n\t}\n\n\timageRepo.Status = constant.StatusSuccess\n\tif req.Auth {\n\t\tif err := u.CheckConn(req.DownloadUrl, req.Username, req.Password); err != nil {\n\t\t\timageRepo.Status = constant.StatusFailed\n\t\t\timageRepo.Message = err.Error()\n\t\t}\n\t}\n\tif err := imageRepoRepo.Create(&imageRepo); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (u *ImageRepoService) BatchDelete(req dto.ImageRepoDelete) error {\n\tfor _, id := range req.Ids {\n\t\tif id == 1 {\n\t\t\treturn errors.New(\"The default value cannot be edit !\")\n\t\t}\n\t}\n\tif err := imageRepoRepo.Delete(commonRepo.WithIdsIn(req.Ids)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (u *ImageRepoService) Update(req dto.ImageRepoUpdate) error {\n\tif req.ID == 1 {\n\t\treturn errors.New(\"The default value cannot be deleted !\")\n\t}\n\tif cmd.CheckIllegal(req.Username, req.Password, req.DownloadUrl) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\trepo, err := imageRepoRepo.Get(commonRepo.WithByID(req.ID))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif repo.DownloadUrl != req.DownloadUrl || (!repo.Auth && req.Auth) {\n\t\t_ = u.handleRegistries(req.DownloadUrl, repo.DownloadUrl, \"update\")\n\t\tif repo.Auth {\n\t\t\t_, _ = cmd.ExecWithCheck(\"docker\", \"logout\", repo.DownloadUrl)\n\t\t}\n\t\tstdout, err := cmd.Exec(\"systemctl restart docker\")\n\t\tif err != nil {\n\t\t\treturn errors.New(string(stdout))\n\t\t}\n\t}\n\n\tupMap := make(map[string]interface{})\n\tupMap[\"download_url\"] = req.DownloadUrl\n\tupMap[\"protocol\"] = req.Protocol\n\tupMap[\"username\"] = req.Username\n\tupMap[\"password\"] = req.Password\n\tupMap[\"auth\"] = req.Auth\n\n\tupMap[\"status\"] = constant.StatusSuccess\n\tupMap[\"message\"] = \"\"\n\tif req.Auth {\n\t\tif err := u.CheckConn(req.DownloadUrl, req.Username, req.Password); err != nil {\n\t\t\tupMap[\"status\"] = constant.StatusFailed\n\t\t\tupMap[\"message\"] = err.Error()\n\t\t}\n\t}\n\treturn imageRepoRepo.Update(req.ID, upMap)\n}\n\nfunc (u *ImageRepoService) CheckConn(host, user, password string) error {\n\tstdout, err := cmd.ExecWithCheck(\"docker\", \"login\", \"-u\", user, \"-p\", password, host)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stdout: %s, stderr: %v\", stdout, err)\n\t}\n\tif strings.Contains(string(stdout), \"Login Succeeded\") {\n\t\treturn nil\n\t}\n\treturn errors.New(string(stdout))\n}\n\nfunc (u *ImageRepoService) handleRegistries(newHost, delHost, handle string) error {\n\tif _, err := os.Stat(constant.DaemonJsonPath); err != nil && os.IsNotExist(err) {\n\t\tif err = os.MkdirAll(path.Dir(constant.DaemonJsonPath), os.ModePerm); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, _ = os.Create(constant.DaemonJsonPath)\n\t}\n\n\tdaemonMap := make(map[string]interface{})\n\tfile, err := os.ReadFile(constant.DaemonJsonPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := json.Unmarshal(file, &daemonMap); err != nil {\n\t\treturn err\n\t}\n\n\tiRegistries := daemonMap[\"insecure-registries\"]\n\tregistries, _ := iRegistries.([]interface{})\n\tswitch handle {\n\tcase \"create\":\n\t\tregistries = common.RemoveRepeatElement(append(registries, newHost))\n\tcase \"update\":\n\t\tregistries = common.RemoveRepeatElement(append(registries, newHost))\n\t\tfor i, regi := range registries {\n\t\t\tif regi == delHost {\n\t\t\t\tregistries = append(registries[:i], registries[i+1:]...)\n\t\t\t}\n\t\t}\n\tcase \"delete\":\n\t\tfor i, regi := range registries {\n\t\t\tif regi == delHost {\n\t\t\t\tregistries = append(registries[:i], registries[i+1:]...)\n\t\t\t}\n\t\t}\n\t}\n\tif len(registries) == 0 {\n\t\tdelete(daemonMap, \"insecure-registries\")\n\t} else {\n\t\tdaemonMap[\"insecure-registries\"] = registries\n\t}\n\tnewJson, err := json.MarshalIndent(daemonMap, \"\", \"\\t\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.WriteFile(constant.DaemonJsonPath, newJson, 0640); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "package service\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/user\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/app/dto\"\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/global\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/common\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/files\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/qqwry\"\n)\n\nconst sshPath = \"/etc/ssh/sshd_config\"\n\ntype SSHService struct{}\n\ntype ISSHService interface {\n\tGetSSHInfo() (*dto.SSHInfo, error)\n\tOperateSSH(operation string) error\n\tUpdateByFile(value string) error\n\tUpdate(key, value string) error\n\tGenerateSSH(req dto.GenerateSSH) error\n\tLoadSSHSecret(mode string) (string, error)\n\tLoadLog(req dto.SearchSSHLog) (*dto.SSHLog, error)\n}\n\nfunc NewISSHService() ISSHService {\n\treturn &SSHService{}\n}\n\nfunc (u *SSHService) GetSSHInfo() (*dto.SSHInfo, error) {\n\tdata := dto.SSHInfo{\n\t\tStatus:                 constant.StatusEnable,\n\t\tMessage:                \"\",\n\t\tPort:                   \"22\",\n\t\tListenAddress:          \"0.0.0.0\",\n\t\tPasswordAuthentication: \"yes\",\n\t\tPubkeyAuthentication:   \"yes\",\n\t\tPermitRootLogin:        \"yes\",\n\t\tUseDNS:                 \"yes\",\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\tstdout, err := cmd.Execf(\"%s systemctl status sshd\", sudo)\n\tif err != nil {\n\t\tdata.Message = stdout\n\t\tdata.Status = constant.StatusDisable\n\t}\n\tstdLines := strings.Split(stdout, \"\\n\")\n\tfor _, stdline := range stdLines {\n\t\tif strings.Contains(stdline, \"active (running)\") {\n\t\t\tdata.Status = constant.StatusEnable\n\t\t\tbreak\n\t\t}\n\t}\n\tsshConf, err := os.ReadFile(sshPath)\n\tif err != nil {\n\t\tdata.Message = err.Error()\n\t\tdata.Status = constant.StatusDisable\n\t}\n\tlines := strings.Split(string(sshConf), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.HasPrefix(line, \"Port \") {\n\t\t\tdata.Port = strings.ReplaceAll(line, \"Port \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"ListenAddress \") {\n\t\t\tdata.ListenAddress = strings.ReplaceAll(line, \"ListenAddress \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"PasswordAuthentication \") {\n\t\t\tdata.PasswordAuthentication = strings.ReplaceAll(line, \"PasswordAuthentication \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"PubkeyAuthentication \") {\n\t\t\tdata.PubkeyAuthentication = strings.ReplaceAll(line, \"PubkeyAuthentication \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"PermitRootLogin \") {\n\t\t\tdata.PermitRootLogin = strings.ReplaceAll(line, \"PermitRootLogin \", \"\")\n\t\t}\n\t\tif strings.HasPrefix(line, \"UseDNS \") {\n\t\t\tdata.UseDNS = strings.ReplaceAll(line, \"UseDNS \", \"\")\n\t\t}\n\t}\n\treturn &data, nil\n}\n\nfunc (u *SSHService) OperateSSH(operation string) error {\n\tif operation == \"start\" || operation == \"stop\" || operation == \"restart\" {\n\t\tsudo := cmd.SudoHandleCmd()\n\t\tstdout, err := cmd.Execf(\"%s systemctl %s sshd\", sudo, operation)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s sshd failed, stdout: %s, err: %v\", operation, stdout, err)\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"not support such operation: %s\", operation)\n}\n\nfunc (u *SSHService) Update(key, value string) error {\n\tsshConf, err := os.ReadFile(sshPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlines := strings.Split(string(sshConf), \"\\n\")\n\tnewFiles := updateSSHConf(lines, key, value)\n\tif err := settingRepo.Update(key, value); err != nil {\n\t\treturn err\n\t}\n\tfile, err := os.OpenFile(sshPath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tif _, err = file.WriteString(strings.Join(newFiles, \"\\n\")); err != nil {\n\t\treturn err\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\tif key == \"Port\" {\n\t\tstdout, _ := cmd.Execf(\"%s getenforce\", sudo)\n\t\tif stdout == \"Enforcing\\n\" {\n\t\t\t_, _ = cmd.Execf(\"%s semanage port -a -t ssh_port_t -p tcp %s\", sudo, value)\n\t\t}\n\t}\n\t_, _ = cmd.Execf(\"%s systemctl restart sshd\", sudo)\n\treturn nil\n}\n\nfunc (u *SSHService) UpdateByFile(value string) error {\n\tfile, err := os.OpenFile(sshPath, os.O_WRONLY|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\tif _, err = file.WriteString(value); err != nil {\n\t\treturn err\n\t}\n\tsudo := cmd.SudoHandleCmd()\n\t_, _ = cmd.Execf(\"%s systemctl restart sshd\", sudo)\n\treturn nil\n}\n\nfunc (u *SSHService) GenerateSSH(req dto.GenerateSSH) error {\n\tif cmd.CheckIllegal(req.EncryptionMode, req.Password) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"load current user failed, err: %v\", err)\n\t}\n\tsecretFile := fmt.Sprintf(\"%s/.ssh/id_item_%s\", currentUser.HomeDir, req.EncryptionMode)\n\tsecretPubFile := fmt.Sprintf(\"%s/.ssh/id_item_%s.pub\", currentUser.HomeDir, req.EncryptionMode)\n\tauthFile := currentUser.HomeDir + \"/.ssh/authorized_keys\"\n\n\tcommand := fmt.Sprintf(\"ssh-keygen -t %s -f %s/.ssh/id_item_%s | echo y\", req.EncryptionMode, currentUser.HomeDir, req.EncryptionMode)\n\tif len(req.Password) != 0 {\n\t\tcommand = fmt.Sprintf(\"ssh-keygen -t %s -P %s -f %s/.ssh/id_item_%s | echo y\", req.EncryptionMode, req.Password, currentUser.HomeDir, req.EncryptionMode)\n\t}\n\tstdout, err := cmd.Exec(command)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"generate failed, err: %v, message: %s\", err, stdout)\n\t}\n\tdefer func() {\n\t\t_ = os.Remove(secretFile)\n\t}()\n\tdefer func() {\n\t\t_ = os.Remove(secretPubFile)\n\t}()\n\n\tif _, err := os.Stat(authFile); err != nil {\n\t\t_, _ = os.Create(authFile)\n\t}\n\tstdout1, err := cmd.Execf(\"cat %s >> %s/.ssh/authorized_keys\", secretPubFile, currentUser.HomeDir)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"generate failed, err: %v, message: %s\", err, stdout1)\n\t}\n\n\tfileOp := files.NewFileOp()\n\tif err := fileOp.Rename(secretFile, fmt.Sprintf(\"%s/.ssh/id_%s\", currentUser.HomeDir, req.EncryptionMode)); err != nil {\n\t\treturn err\n\t}\n\tif err := fileOp.Rename(secretPubFile, fmt.Sprintf(\"%s/.ssh/id_%s.pub\", currentUser.HomeDir, req.EncryptionMode)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (u *SSHService) LoadSSHSecret(mode string) (string, error) {\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"load current user failed, err: %v\", err)\n\t}\n\n\thomeDir := currentUser.HomeDir\n\tif _, err := os.Stat(fmt.Sprintf(\"%s/.ssh/id_%s\", homeDir, mode)); err != nil {\n\t\treturn \"\", nil\n\t}\n\tfile, err := os.ReadFile(fmt.Sprintf(\"%s/.ssh/id_%s\", homeDir, mode))\n\treturn string(file), err\n}\n\nfunc (u *SSHService) LoadLog(req dto.SearchSSHLog) (*dto.SSHLog, error) {\n\tvar fileList []string\n\tvar data dto.SSHLog\n\tbaseDir := \"/var/log\"\n\tif err := filepath.Walk(baseDir, func(pathItem string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() && strings.HasPrefix(info.Name(), \"secure\") || strings.HasPrefix(info.Name(), \"auth\") {\n\t\t\tif strings.HasSuffix(info.Name(), \".gz\") {\n\t\t\t\tif err := handleGunzip(pathItem); err == nil {\n\t\t\t\t\tfileList = append(fileList, strings.ReplaceAll(pathItem, \".gz\", \"\"))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfileList = append(fileList, pathItem)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\tfileList = sortFileList(fileList)\n\n\tcommand := \"\"\n\tif len(req.Info) != 0 {\n\t\tcommand = fmt.Sprintf(\" | grep '%s'\", req.Info)\n\t}\n\n\tfor i := 0; i < len(fileList); i++ {\n\t\twithAppend := len(data.Logs) < req.Page*req.PageSize\n\t\tif req.Status != constant.StatusSuccess {\n\t\t\tif strings.HasPrefix(path.Base(fileList[i]), \"secure\") {\n\t\t\t\tcommandItem := fmt.Sprintf(\"cat %s | grep -a 'Failed password for' | grep -v 'invalid' %s\", fileList[i], command)\n\t\t\t\tdataItem, itemTotal := loadFailedSecureDatas(commandItem, withAppend)\n\t\t\t\tdata.FailedCount += itemTotal\n\t\t\t\tdata.TotalCount += itemTotal\n\t\t\t\tdata.Logs = append(data.Logs, dataItem...)\n\t\t\t}\n\t\t\tif strings.HasPrefix(path.Base(fileList[i]), \"auth.log\") {\n\t\t\t\tcommandItem := fmt.Sprintf(\"cat %s | grep -a 'Connection closed by authenticating user' | grep -a 'preauth' %s\", fileList[i], command)\n\t\t\t\tdataItem, itemTotal := loadFailedAuthDatas(commandItem, withAppend)\n\t\t\t\tdata.FailedCount += itemTotal\n\t\t\t\tdata.TotalCount += itemTotal\n\t\t\t\tdata.Logs = append(data.Logs, dataItem...)\n\t\t\t}\n\t\t}\n\t\tif req.Status != constant.StatusFailed {\n\t\t\tcommandItem := fmt.Sprintf(\"cat %s | grep -a Accepted %s\", fileList[i], command)\n\t\t\tdataItem, itemTotal := loadSuccessDatas(commandItem, withAppend)\n\t\t\tdata.TotalCount += itemTotal\n\t\t\tdata.Logs = append(data.Logs, dataItem...)\n\t\t}\n\t}\n\tdata.SuccessfulCount = data.TotalCount - data.FailedCount\n\tif len(data.Logs) < 1 {\n\t\treturn nil, nil\n\t}\n\n\tvar itemDatas []dto.SSHHistory\n\ttotal, start, end := len(data.Logs), (req.Page-1)*req.PageSize, req.Page*req.PageSize\n\tif start > total {\n\t\titemDatas = make([]dto.SSHHistory, 0)\n\t} else {\n\t\tif end >= total {\n\t\t\tend = total\n\t\t}\n\t\titemDatas = data.Logs[start:end]\n\t}\n\tdata.Logs = itemDatas\n\n\ttimeNow := time.Now()\n\tnyc, _ := time.LoadLocation(common.LoadTimeZone())\n\tqqWry, err := qqwry.NewQQwry()\n\tif err != nil {\n\t\tglobal.LOG.Errorf(\"load qqwry datas failed: %s\", err)\n\t}\n\tvar itemLogs []dto.SSHHistory\n\tfor i := 0; i < len(data.Logs); i++ {\n\t\tdata.Logs[i].Area = qqWry.Find(data.Logs[i].Address).Area\n\t\tdata.Logs[i].Date, _ = time.ParseInLocation(\"2006 Jan 2 15:04:05\", fmt.Sprintf(\"%d %s\", timeNow.Year(), data.Logs[i].DateStr), nyc)\n\t\titemLogs = append(itemLogs, data.Logs[i])\n\t}\n\tdata.Logs = itemLogs\n\n\treturn &data, nil\n}\n\nfunc sortFileList(fileNames []string) []string {\n\tif len(fileNames) < 2 {\n\t\treturn fileNames\n\t}\n\tif strings.HasPrefix(path.Base(fileNames[0]), \"secure\") {\n\t\tvar itemFile []string\n\t\tsort.Slice(fileNames, func(i, j int) bool {\n\t\t\treturn fileNames[i] > fileNames[j]\n\t\t})\n\t\titemFile = append(itemFile, fileNames[len(fileNames)-1])\n\t\titemFile = append(itemFile, fileNames[:len(fileNames)-2]...)\n\t\treturn itemFile\n\t}\n\tsort.Slice(fileNames, func(i, j int) bool {\n\t\treturn fileNames[i] < fileNames[j]\n\t})\n\treturn fileNames\n}\n\nfunc updateSSHConf(oldFiles []string, param string, value interface{}) []string {\n\thasKey := false\n\tvar newFiles []string\n\tfor _, line := range oldFiles {\n\t\tif strings.HasPrefix(line, param+\" \") {\n\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s %v\", param, value))\n\t\t\thasKey = true\n\t\t\tcontinue\n\t\t}\n\t\tnewFiles = append(newFiles, line)\n\t}\n\tif !hasKey {\n\t\tnewFiles = []string{}\n\t\tfor _, line := range oldFiles {\n\t\t\tif strings.HasPrefix(line, fmt.Sprintf(\"#%s \", param)) && !hasKey {\n\t\t\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s %v\", param, value))\n\t\t\t\thasKey = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewFiles = append(newFiles, line)\n\t\t}\n\t}\n\tif !hasKey {\n\t\tnewFiles = []string{}\n\t\tnewFiles = append(newFiles, oldFiles...)\n\t\tnewFiles = append(newFiles, fmt.Sprintf(\"%s %v\", param, value))\n\t}\n\treturn newFiles\n}\n\nfunc loadSuccessDatas(command string, withAppend bool) ([]dto.SSHHistory, int) {\n\tvar (\n\t\tdatas    []dto.SSHHistory\n\t\ttotalNum int\n\t)\n\tstdout2, err := cmd.Exec(command)\n\tif err == nil {\n\t\tlines := strings.Split(string(stdout2), \"\\n\")\n\t\tif len(lines) == 0 {\n\t\t\treturn datas, 0\n\t\t}\n\t\tfor i := len(lines) - 1; i >= 0; i-- {\n\t\t\tparts := strings.Fields(lines[i])\n\t\t\tif len(parts) < 14 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotalNum++\n\t\t\tif withAppend {\n\t\t\t\thistoryItem := dto.SSHHistory{\n\t\t\t\t\tDateStr:  fmt.Sprintf(\"%s %s %s\", parts[0], parts[1], parts[2]),\n\t\t\t\t\tAuthMode: parts[6],\n\t\t\t\t\tUser:     parts[8],\n\t\t\t\t\tAddress:  parts[10],\n\t\t\t\t\tPort:     parts[12],\n\t\t\t\t\tStatus:   constant.StatusSuccess,\n\t\t\t\t}\n\t\t\t\tdatas = append(datas, historyItem)\n\t\t\t}\n\t\t}\n\t}\n\treturn datas, totalNum\n}\n\nfunc loadFailedAuthDatas(command string, withAppend bool) ([]dto.SSHHistory, int) {\n\tvar (\n\t\tdatas    []dto.SSHHistory\n\t\ttotalNum int\n\t)\n\tstdout2, err := cmd.Exec(command)\n\tif err == nil {\n\t\tlines := strings.Split(string(stdout2), \"\\n\")\n\t\tif len(lines) == 0 {\n\t\t\treturn datas, 0\n\t\t}\n\t\tfor i := len(lines) - 1; i >= 0; i-- {\n\t\t\tparts := strings.Fields(lines[i])\n\t\t\tif len(parts) < 14 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotalNum++\n\t\t\tif withAppend {\n\t\t\t\thistoryItem := dto.SSHHistory{\n\t\t\t\t\tDateStr:  fmt.Sprintf(\"%s %s %s\", parts[0], parts[1], parts[2]),\n\t\t\t\t\tAuthMode: parts[8],\n\t\t\t\t\tUser:     parts[10],\n\t\t\t\t\tAddress:  parts[11],\n\t\t\t\t\tPort:     parts[13],\n\t\t\t\t\tStatus:   constant.StatusFailed,\n\t\t\t\t}\n\t\t\t\tif strings.Contains(lines[i], \": \") {\n\t\t\t\t\thistoryItem.Message = strings.Split(lines[i], \": \")[1]\n\t\t\t\t}\n\t\t\t\tdatas = append(datas, historyItem)\n\t\t\t}\n\t\t}\n\t}\n\treturn datas, totalNum\n}\n\nfunc loadFailedSecureDatas(command string, withAppend bool) ([]dto.SSHHistory, int) {\n\tvar (\n\t\tdatas    []dto.SSHHistory\n\t\ttotalNum int\n\t)\n\tstdout2, err := cmd.Exec(command)\n\tif err == nil {\n\t\tlines := strings.Split(string(stdout2), \"\\n\")\n\t\tif len(lines) == 0 {\n\t\t\treturn datas, 0\n\t\t}\n\t\tfor i := len(lines) - 1; i >= 0; i-- {\n\t\t\tparts := strings.Fields(lines[i])\n\t\t\tif len(parts) < 14 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttotalNum++\n\t\t\tif withAppend {\n\t\t\t\thistoryItem := dto.SSHHistory{\n\t\t\t\t\tDateStr:  fmt.Sprintf(\"%s %s %s\", parts[0], parts[1], parts[2]),\n\t\t\t\t\tAuthMode: parts[6],\n\t\t\t\t\tUser:     parts[8],\n\t\t\t\t\tAddress:  parts[10],\n\t\t\t\t\tPort:     parts[12],\n\t\t\t\t\tStatus:   constant.StatusFailed,\n\t\t\t\t}\n\t\t\t\tif strings.Contains(lines[i], \": \") {\n\t\t\t\t\thistoryItem.Message = strings.Split(lines[i], \": \")[1]\n\t\t\t\t}\n\t\t\t\tdatas = append(datas, historyItem)\n\t\t\t}\n\t\t}\n\t}\n\treturn datas, totalNum\n}\n\nfunc handleGunzip(path string) error {\n\tif _, err := cmd.Execf(\"gunzip %s\", path); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "package constant\n\nimport (\n\t\"errors\"\n)\n\nconst (\n\tCodeSuccess           = 200\n\tCodeErrBadRequest     = 400\n\tCodeErrUnauthorized   = 401\n\tCodeErrUnSafety       = 402\n\tCodeErrForbidden      = 403\n\tCodeErrNotFound       = 404\n\tCodePasswordExpired   = 405\n\tCodeAuth              = 406\n\tCodeGlobalLoading     = 407\n\tCodeErrIP             = 408\n\tCodeErrDomain         = 409\n\tCodeErrInternalServer = 500\n\tCodeErrHeader         = 406\n)\n\n// internal\nvar (\n\tErrCaptchaCode     = errors.New(\"ErrCaptchaCode\")\n\tErrAuth            = errors.New(\"ErrAuth\")\n\tErrRecordExist     = errors.New(\"ErrRecordExist\")\n\tErrRecordNotFound  = errors.New(\"ErrRecordNotFound\")\n\tErrStructTransform = errors.New(\"ErrStructTransform\")\n\tErrInitialPassword = errors.New(\"ErrInitialPassword\")\n\tErrNotSupportType  = errors.New(\"ErrNotSupportType\")\n\tErrInvalidParams   = errors.New(\"ErrInvalidParams\")\n\n\tErrTokenParse = errors.New(\"ErrTokenParse\")\n)\n\n// api\nvar (\n\tErrTypeInternalServer  = \"ErrInternalServer\"\n\tErrTypeInvalidParams   = \"ErrInvalidParams\"\n\tErrTypeNotLogin        = \"ErrNotLogin\"\n\tErrTypePasswordExpired = \"ErrPasswordExpired\"\n\tErrNameIsExist         = \"ErrNameIsExist\"\n\tErrDemoEnvironment     = \"ErrDemoEnvironment\"\n\tErrCmdIllegal          = \"ErrCmdIllegal\"\n)\n\n// app\nvar (\n\tErrPortInUsed          = \"ErrPortInUsed\"\n\tErrAppLimit            = \"ErrAppLimit\"\n\tErrFileToLarge         = \"ErrFileToLarge\"\n\tErrFileCanNotRead      = \"ErrFileCanNotRead\"\n\tErrNotInstall          = \"ErrNotInstall\"\n\tErrPortInOtherApp      = \"ErrPortInOtherApp\"\n\tErrDbUserNotValid      = \"ErrDbUserNotValid\"\n\tErrUpdateBuWebsite     = \"ErrUpdateBuWebsite\"\n\tErr1PanelNetworkFailed = \"Err1PanelNetworkFailed\"\n\tErrCmdTimeout          = \"ErrCmdTimeout\"\n\tErrFileParse           = \"ErrFileParse\"\n\tErrInstallDirNotFound  = \"ErrInstallDirNotFound\"\n\tErrContainerName       = \"ErrContainerName\"\n)\n\n// website\nvar (\n\tErrDomainIsExist      = \"ErrDomainIsExist\"\n\tErrAliasIsExist       = \"ErrAliasIsExist\"\n\tErrGroupIsUsed        = \"ErrGroupIsUsed\"\n\tErrUsernameIsExist    = \"ErrUsernameIsExist\"\n\tErrUsernameIsNotExist = \"ErrUsernameIsNotExist\"\n\tErrBackupMatch        = \"ErrBackupMatch\"\n\tErrBackupExist        = \"ErrBackupExist\"\n)\n\n// ssl\nvar (\n\tErrSSLCannotDelete     = \"ErrSSLCannotDelete\"\n\tErrAccountCannotDelete = \"ErrAccountCannotDelete\"\n\tErrSSLApply            = \"ErrSSLApply\"\n\tErrEmailIsExist        = \"ErrEmailIsExist\"\n)\n\n// file\nvar (\n\tErrPathNotFound     = \"ErrPathNotFound\"\n\tErrMovePathFailed   = \"ErrMovePathFailed\"\n\tErrLinkPathNotFound = \"ErrLinkPathNotFound\"\n\tErrFileIsExit       = \"ErrFileIsExit\"\n\tErrFileUpload       = \"ErrFileUpload\"\n\tErrFileDownloadDir  = \"ErrFileDownloadDir\"\n)\n\n// mysql\nvar (\n\tErrUserIsExist     = \"ErrUserIsExist\"\n\tErrDatabaseIsExist = \"ErrDatabaseIsExist\"\n\tErrExecTimeOut     = \"ErrExecTimeOut\"\n)\n\n// redis\nvar (\n\tErrTypeOfRedis = \"ErrTypeOfRedis\"\n)\n\n// container\nvar (\n\tErrInUsed       = \"ErrInUsed\"\n\tErrObjectInUsed = \"ErrObjectInUsed\"\n\tErrPortRules    = \"ErrPortRules\"\n)\n\n// runtime\nvar (\n\tErrDirNotFound    = \"ErrDirNotFound\"\n\tErrFileNotExist   = \"ErrFileNotExist\"\n\tErrImageBuildErr  = \"ErrImageBuildErr\"\n\tErrImageExist     = \"ErrImageExist\"\n\tErrDelWithWebsite = \"ErrDelWithWebsite\"\n)\n\nvar (\n\tErrBackupInUsed = \"ErrBackupInUsed\"\n\tErrOSSConn      = \"ErrOSSConn\"\n)\n", "ErrInvalidParams: \"Request parameter error: {{ .detail }}\"\nErrTokenParse: \"Token generation error: {{ .detail }}\"\nErrInitialPassword: \"Initial password error\"\nErrInternalServer: \"Service internal error: {{ .detail }}\"\nErrRecordExist: \"Record already exists\"\nErrRecordNotFound: \"Records not found\"\nErrStructTransform: \"Type conversion failure: {{ .detail }}\"\nErrNotLogin: \"User is not Login: {{ .detail }}\"\nErrPasswordExpired: \"The current password has expired: {{ .detail }}\"\nErrNotSupportType: \"The system does not support the current type: {{ .detail }}\"\n\n#common\nErrNameIsExist: \"Name is already exist\"\nErrDemoEnvironment: \"Demo server, prohibit this operation!\"\nErrCmdTimeout: \"Command execution timed out\uff01\"\nErrCmdIllegal: \"The command contains illegal characters. Please modify and try again!\"\n\n#app\nErrPortInUsed: \"{{ .detail }} port already in use\"\nErrAppLimit: \"App exceeds install limit\"\nErrAppRequired: \"{{ .detail }} app is required\"\nErrNotInstall: \"App not installed\"\nErrPortInOtherApp: \"{{ .port }} port  already in use by  {{ .apps }}\"\nErrDbUserNotValid: \"Stock database, username and password do not match\uff01\"\nErrDockerComposeNotValid: \"docker-compose file format error!\"\nErrUpdateBuWebsite: 'The application was updated successfully, but the modification of the website configuration file failed, please check the configuration!'\nErr1PanelNetworkFailed: 'Default container network creation failed! {{ .detail }}'\nErrFileParse: 'Application docker-compose file parsing failed!'\nErrInstallDirNotFound: 'installation directory does not exist'\nAppStoreIsUpToDate: 'The app store is already up to date\uff01'\nLocalAppVersionNull: 'The {{.name}} app is not synced to version! Could not add to application list'\nLocalAppVersionErr: '{{.name}} failed to sync version {{.version}}! {{.err}}'\nErrFileNotFound: '{{.name}} file does not exist'\nErrFileParseApp: 'Failed to parse {{.name}} file {{.err}}'\nErrAppDirNull: 'version folder does not exist'\nLocalAppErr: \"App {{.name}} sync failed! {{.err}}\"\nErrContainerName: \"ContainerName is already exist\"\nErrAppSystemRestart: \"1Panel restart causes the task to terminate\"\nErrCreateHttpClient: \"Failed to create HTTP request {{.err}}\"\nErrHttpReqTimeOut: \"Request timed out {{.err}}\"\nErrHttpReqFailed: \"Request failed {{.err}}\"\nErrHttpReqNotFound: \"The file does not exist\"\nErrNoSuchHost: \"Network connection failed\"\nErrImagePullTimeOut: 'Image pull timeout'\nErrContainerNotFound: '{{ .name }} container does not exist'\nErrContainerMsg: '{{ .name }} container is abnormal, please check the log on the container page for details'\n\n#file\nErrFileCanNotRead: \"File can not read\"\nErrFileToLarge: \"file is too large\"\nErrPathNotFound: \"Path is not found\"\nErrMovePathFailed: \"The target path cannot contain the original path!\"\nErrLinkPathNotFound: \"Target path does not exist!\"\nErrFileIsExit: \"File already exists!\"\nErrFileUpload: \"Failed to upload file {{.name}}  {{.detail}}\"\nErrFileDownloadDir: \"Download folder not supported\"\n\n#website\nErrDomainIsExist: \"Domain is already exist\"\nErrAliasIsExist: \"Alias is already exist\"\nErrAppDelete: 'Other Website use this App'\nErrGroupIsUsed: 'The group is in use and cannot be deleted'\nErrBackupMatch: 'the backup file does not match the current partial data of the website: {{ .detail}}\"'\nErrBackupExist: 'the backup file corresponds to a portion of the original data that does not exist: {{ .detail}}\"'\n\n#ssl\nErrSSLCannotDelete: \"The certificate is being used by the website and cannot be removed\"\nErrAccountCannotDelete: \"The certificate associated with the account cannot be deleted\"\nErrSSLApply: \"The certificate continues to be signed successfully, but openresty reload fails, please check the configuration\uff01\"\nErrEmailIsExist: 'Email is already exist'\nErrSSLKeyNotFound: 'The private key file does not exist'\nErrSSLCertificateNotFound: 'The certificate file does not exist'\nErrSSLKeyFormat: 'Private key file verification error'\nErrSSLCertificateFormat: 'Certificate file format error, please use pem format'\n\n#mysql\nErrUserIsExist: \"The current user already exists. Please enter a new user\"\nErrDatabaseIsExist: \"The current database already exists. Please enter a new database\"\nErrExecTimeOut: \"SQL execution timed out, please check the {{ .detail }} container\"\n\n#redis\nErrTypeOfRedis: \"The recovery file type does not match the current persistence mode. Modify the file type and try again\"\n\n#container \nErrInUsed: \"{{ .detail }} is in use and cannot be deleted\"\nErrObjectInUsed: \"This object is in use and cannot be deleted\"\nErrPortRules: \"The number of ports does not match, please re-enter!\"\n\n#runtime\nErrDirNotFound: \"The build folder does not exist! Please check file integrity\uff01\"\nErrFileNotExist: \"{{ .detail }} file does not exist! Please check source file integrity\uff01\"\nErrImageBuildErr: \"Image build failed\"\nErrImageExist: \"Image is already exist\uff01\"\nErrDelWithWebsite: \"The operating environment has been associated with a website and cannot be deleted\"\n\n#setting\nErrBackupInUsed: \"The backup account is already being used in a cronjob and cannot be deleted.\"\n\nErrOSSConn: \"Unable to successfully request the latest version. Please check if the server can connect to the external network environment.\"", "ErrInvalidParams: \"\u8acb\u6c42\u53c3\u6578\u932f\u8aa4: {{ .detail }}\"\nErrTokenParse: \"Token \u7522\u751f\u932f\u8aa4: {{ .detail }}\"\nErrInitialPassword: \"\u539f\u5bc6\u78bc\u932f\u8aa4\"\nErrInternalServer: \"\u4f3a\u670d\u5668\u5167\u90e8\u932f\u8aa4: {{ .detail }}\"\nErrRecordExist: \"\u8a18\u9304\u5df2\u5b58\u5728\"\nErrRecordNotFound: \"\u8a18\u9304\u672a\u627e\u5230\"\nErrStructTransform: \"\u985e\u578b\u8f49\u63db\u5931\u6557: {{ .detail }}\"\nErrNotLogin: \"\u7528\u6236\u672a\u767b\u5165: {{ .detail }}\"\nErrPasswordExpired: \"\u7576\u524d\u5bc6\u78bc\u5df2\u904e\u671f: {{ .detail }}\"\nErrNotSupportType: \"\u7cfb\u7d71\u66ab\u4e0d\u652f\u6301\u7576\u524d\u985e\u578b: {{ .detail }}\"\n\n#common\nErrNameIsExist: \"\u540d\u7a31\u5df2\u5b58\u5728\"\nErrDemoEnvironment: \"\u6f14\u793a\u4f3a\u670d\u5668\uff0c\u7981\u6b62\u6b64\u64cd\u4f5c!\"\nErrCmdTimeout: \"\u6307\u4ee4\u57f7\u884c\u8d85\u6642\uff01\"\nErrCmdIllegal: \"\u57f7\u884c\u547d\u4ee4\u4e2d\u5b58\u5728\u4e0d\u5408\u6cd5\u5b57\u7b26\uff0c\u8acb\u4fee\u6539\u5f8c\u91cd\u8a66\uff01\"\n\n#app\nErrPortInUsed: \"{{ .detail }} \u7aef\u53e3\u5df2\u88ab\u4f54\u7528\uff01\"\nErrAppLimit: \"\u61c9\u7528\u8d85\u51fa\u5b89\u88dd\u6578\u91cf\u9650\u5236\"\nErrAppRequired: \"\u8acb\u5148\u5b89\u88dd {{ .detail }} \u61c9\u7528\"\nErrNotInstall: \"\u61c9\u7528\u672a\u5b89\u88dd\"\nErrPortInOtherApp: \"{{ .port }} \u7aef\u53e3\u5df2\u88ab {{ .apps }}\u4f54\u7528\uff01\"\nErrDbUserNotValid: \"\u5132\u5b58\u8cc7\u6599\u5eab\uff0c\u7528\u6236\u540d\u5bc6\u78bc\u4e0d\u5339\u914d\uff01\"\nErrDockerComposeNotValid: \"docker-compose \u6587\u4ef6\u683c\u5f0f\u932f\u8aa4\"\nErrUpdateBuWebsite: '\u61c9\u7528\u66f4\u65b0\u6210\u529f\uff0c\u4f46\u662f\u7db2\u7ad9\u914d\u7f6e\u6587\u4ef6\u4fee\u6539\u5931\u6557\uff0c\u8acb\u6aa2\u67e5\u914d\u7f6e\uff01'\nErr1PanelNetworkFailed: '\u9ed8\u8a8d\u5bb9\u5668\u7db2\u7d61\u5275\u5efa\u5931\u6557\uff01{{ .detail }}'\nErrFileParse: '\u61c9\u7528 docker-compose \u6587\u4ef6\u89e3\u6790\u5931\u6557!'\nErrInstallDirNotFound: '\u5b89\u88dd\u76ee\u9304\u4e0d\u5b58\u5728'\nAppStoreIsUpToDate: '\u61c9\u7528\u5546\u5e97\u5df2\u7d93\u662f\u6700\u65b0\u7248\u672c'\nLocalAppVersionNull: '{{.name}} \u61c9\u7528\u672a\u540c\u6b65\u5230\u7248\u672c\uff01\u7121\u6cd5\u6dfb\u52a0\u5230\u61c9\u7528\u5217\u8868'\nLocalAppVersionErr: '{{.name}} \u540c\u6b65\u7248\u672c {{.version}} \u5931\u6557\uff01{{.err}}'\nErrFileNotFound: '{{.name}} \u6587\u4ef6\u4e0d\u5b58\u5728'\nErrFileParseApp: '{{.name}} \u6587\u4ef6\u89e3\u6790\u5931\u6557 {{.err}}'\nErrAppDirNull: '\u7248\u672c\u8cc7\u6599\u593e\u4e0d\u5b58\u5728'\nLocalAppErr: \"\u61c9\u7528 {{.name}} \u540c\u6b65\u5931\u6557\uff01{{.err}}\"\nErrContainerName: \"\u5bb9\u5668\u540d\u7a31\u5df2\u5b58\u5728\"\nErrAppSystemRestart: \"1Panel \u91cd\u555f\u5c0e\u81f4\u4efb\u52d9\u4e2d\u65b7\"\nErrCreateHttpClient: \"\u5275\u5efaHTTP\u8acb\u6c42\u5931\u6557 {{.err}}\"\nErrHttpReqTimeOut: \"\u8acb\u6c42\u8d85\u6642 {{.err}}\"\nErrHttpReqFailed: \"\u8acb\u6c42\u5931\u6557 {{.err}}\"\nErrHttpReqNotFound: \"\u6587\u4ef6\u4e0d\u5b58\u5728\"\nErrNoSuchHost: \"\u7db2\u8def\u9023\u63a5\u5931\u6557\"\nErrImagePullTimeOut: \"\u93e1\u50cf\u62c9\u53d6\u8d85\u6642\"\nErrContainerNotFound: '{{ .name }} \u5bb9\u5668\u4e0d\u5b58\u5728'\nErrContainerMsg: '{{ .name }} \u5bb9\u5668\u7570\u5e38\uff0c\u5177\u9ad4\u8acb\u5728\u5bb9\u5668\u9801\u9762\u67e5\u770b\u65e5\u8a8c'\n\n#file\nErrFileCanNotRead: \"\u6b64\u6587\u4ef6\u4e0d\u652f\u6301\u9810\u89bd\"\nErrFileToLarge: \"\u6587\u4ef6\u8d85\u904e10M,\u7121\u6cd5\u6253\u958b\"\nErrPathNotFound: \"\u76ee\u9304\u4e0d\u5b58\u5728\"\nErrMovePathFailed: \"\u76ee\u6a19\u8def\u5f91\u4e0d\u80fd\u5305\u542b\u539f\u8def\u5f91\uff01\"\nErrLinkPathNotFound: \"\u76ee\u6a19\u8def\u5f91\u4e0d\u5b58\u5728!\"\nErrFileIsExit: \"\u6587\u4ef6\u5df2\u5b58\u5728\uff01\"\nErrFileUpload: \"{{ .name }} \u4e0a\u50b3\u6587\u4ef6\u5931\u6557 {{ .detail}}\"\nErrFileDownloadDir: \"\u4e0d\u652f\u6301\u4e0b\u8f09\u6587\u4ef6\u593e\"\n\n#website\nErrDomainIsExist: \"\u57df\u540d\u5df2\u5b58\u5728\"\nErrAliasIsExist: \"\u4ee3\u865f\u5df2\u5b58\u5728\"\nErrAppDelete: '\u5176\u4ed6\u7db2\u7ad9\u4f7f\u7528\u6b64\u61c9\u7528,\u7121\u6cd5\u522a\u9664'\nErrGroupIsUsed: '\u5206\u7d44\u6b63\u5728\u4f7f\u7528\u4e2d\uff0c\u7121\u6cd5\u522a\u9664'\nErrBackupMatch: '\u8a72\u5099\u4efd\u6587\u4ef6\u8207\u7576\u524d\u7db2\u7ad9\u90e8\u5206\u6578\u64da\u4e0d\u5339\u914d: {{ .detail}}\"'\nErrBackupExist: '\u8a72\u5099\u4efd\u6587\u4ef6\u5c0d\u61c9\u90e8\u5206\u539f\u6578\u64da\u4e0d\u5b58\u5728: {{ .detail}}\"'\n\n#ssl\nErrSSLCannotDelete: \"\u8b49\u66f8\u6b63\u5728\u88ab\u7db2\u7ad9\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\nErrAccountCannotDelete: \"\u5e33\u865f\u95dc\u806f\u8b49\u66f8\uff0c\u7121\u6cd5\u522a\u9664\"\nErrSSLApply: \"\u8b49\u66f8\u7e8c\u7c3d\u6210\u529f\uff0copenresty reload\u5931\u6557\uff0c\u8acb\u6aa2\u67e5\u914d\u7f6e\uff01\"\nErrEmailIsExist: '\u90f5\u7bb1\u5df2\u5b58\u5728'\nErrSSLKeyNotFound: '\u79c1\u9470\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLCertificateNotFound: '\u8b49\u66f8\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLKeyFormat: '\u79c1\u9470\u6587\u4ef6\u6821\u9a57\u932f\u8aa4'\nErrSSLCertificateFormat: '\u8b49\u66f8\u6587\u4ef6\u683c\u5f0f\u932f\u8aa4\uff0c\u8acb\u4f7f\u7528 pem \u683c\u5f0f'\n\n#mysql\nErrUserIsExist: \"\u7576\u524d\u7528\u6236\u5df2\u5b58\u5728\uff0c\u8acb\u91cd\u65b0\u8f38\u5165\"\nErrDatabaseIsExist: \"\u7576\u524d\u8cc7\u6599\u5eab\u5df2\u5b58\u5728\uff0c\u8acb\u91cd\u65b0\u8f38\u5165\"\nErrExecTimeOut: \"SQL \u57f7\u884c\u8d85\u6642\uff0c\u8acb\u6aa2\u67e5{{ .detail }}\u5bb9\u5668\"\n\n#redis\nErrTypeOfRedis: \"\u6062\u5fa9\u6587\u4ef6\u985e\u578b\u8207\u7576\u524d\u6301\u4e45\u5316\u65b9\u5f0f\u4e0d\u7b26\uff0c\u8acb\u4fee\u6539\u5f8c\u91cd\u8a66\"\n\n#container\nErrInUsed: \"{{ .detail }} \u6b63\u88ab\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\nErrObjectInUsed: \"\u8a72\u5c0d\u8c61\u6b63\u88ab\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\nErrPortRules: \"\u7aef\u53e3\u6578\u76ee\u4e0d\u5339\u914d\uff0c\u8acb\u91cd\u65b0\u8f38\u5165\uff01\"\n\n#runtime\nErrDirNotFound: \"build \u6587\u4ef6\u593e\u4e0d\u5b58\u5728\uff01\u8acb\u6aa2\u67e5\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrFileNotExist: \"{{ .detail }} \u6587\u4ef6\u4e0d\u5b58\u5728\uff01\u8acb\u6aa2\u67e5\u6e90\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrImageBuildErr: \"\u93e1\u50cf build \u5931\u6557\"\nErrImageExist: \"\u93e1\u50cf\u5df2\u5b58\u5728\uff01\"\nErrDelWithWebsite: \"\u904b\u884c\u74b0\u5883\u5df2\u7d93\u95dc\u806f\u7db2\u7ad9\uff0c\u7121\u6cd5\u522a\u9664\"\n\n#setting\nErrBackupInUsed: \"\u8a72\u5099\u4efd\u5e33\u865f\u5df2\u5728\u8a08\u5283\u4efb\u52d9\u4e2d\u4f7f\u7528\uff0c\u7121\u6cd5\u522a\u9664\"\n\nErrOSSConn: \"\u7121\u6cd5\u6210\u529f\u8acb\u6c42\u6700\u65b0\u7248\u672c\uff0c\u8acb\u6aa2\u67e5\u4f3a\u670d\u5668\u662f\u5426\u80fd\u5920\u9023\u63a5\u5230\u5916\u90e8\u7db2\u7d61\u74b0\u5883\u3002\"\n", "ErrInvalidParams: \"\u8bf7\u6c42\u53c2\u6570\u9519\u8bef: {{ .detail }}\"\nErrTokenParse: \"Token \u751f\u6210\u9519\u8bef: {{ .detail }}\"\nErrInitialPassword: \"\u539f\u5bc6\u7801\u9519\u8bef\"\nErrInternalServer: \"\u670d\u52a1\u5185\u90e8\u9519\u8bef: {{ .detail }}\"\nErrRecordExist: \"\u8bb0\u5f55\u5df2\u5b58\u5728\"\nErrRecordNotFound: \"\u8bb0\u5f55\u672a\u80fd\u627e\u5230\"\nErrStructTransform: \"\u7c7b\u578b\u8f6c\u6362\u5931\u8d25: {{ .detail }}\"\nErrNotLogin: \"\u7528\u6237\u672a\u767b\u5f55: {{ .detail }}\"\nErrPasswordExpired: \"\u5f53\u524d\u5bc6\u7801\u5df2\u8fc7\u671f: {{ .detail }}\"\nErrNotSupportType: \"\u7cfb\u7edf\u6682\u4e0d\u652f\u6301\u5f53\u524d\u7c7b\u578b: {{ .detail }}\"\n\n#common\nErrNameIsExist: \"\u540d\u79f0\u5df2\u5b58\u5728\"\nErrDemoEnvironment: \"\u6f14\u793a\u670d\u52a1\u5668\uff0c\u7981\u6b62\u6b64\u64cd\u4f5c!\"\nErrCmdTimeout: \"\u547d\u4ee4\u6267\u884c\u8d85\u65f6\uff01\"\nErrCmdIllegal: \"\u6267\u884c\u547d\u4ee4\u4e2d\u5b58\u5728\u4e0d\u5408\u6cd5\u5b57\u7b26\uff0c\u8bf7\u4fee\u6539\u540e\u91cd\u8bd5\uff01\"\n\n#app\nErrPortInUsed: \"{{ .detail }} \u7aef\u53e3\u5df2\u88ab\u5360\u7528\uff01\"\nErrAppLimit: \"\u5e94\u7528\u8d85\u51fa\u5b89\u88c5\u6570\u91cf\u9650\u5236\"\nErrAppRequired: \"\u8bf7\u5148\u5b89\u88c5 {{ .detail }} \u5e94\u7528\"\nErrNotInstall: \"\u5e94\u7528\u672a\u5b89\u88c5\"\nErrPortInOtherApp: \"{{ .port }} \u7aef\u53e3\u5df2\u88ab {{ .apps }}\u5360\u7528\uff01\"\nErrDbUserNotValid: \"\u5b58\u91cf\u6570\u636e\u5e93\uff0c\u7528\u6237\u540d\u5bc6\u7801\u4e0d\u5339\u914d\uff01\"\nErrDockerComposeNotValid: \"docker-compose \u6587\u4ef6\u683c\u5f0f\u9519\u8bef\"\nErrUpdateBuWebsite: '\u5e94\u7528\u66f4\u65b0\u6210\u529f\uff0c\u4f46\u662f\u7f51\u7ad9\u914d\u7f6e\u6587\u4ef6\u4fee\u6539\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u914d\u7f6e\uff01'\nErr1PanelNetworkFailed: '\u9ed8\u8ba4\u5bb9\u5668\u7f51\u7edc\u521b\u5efa\u5931\u8d25\uff01{{ .detail }}'\nErrFileParse: '\u5e94\u7528 docker-compose \u6587\u4ef6\u89e3\u6790\u5931\u8d25!'\nErrInstallDirNotFound: '\u5b89\u88c5\u76ee\u5f55\u4e0d\u5b58\u5728'\nAppStoreIsUpToDate: '\u5e94\u7528\u5546\u5e97\u5df2\u7ecf\u662f\u6700\u65b0\u7248\u672c'\nLocalAppVersionNull: '{{.name}} \u5e94\u7528\u672a\u540c\u6b65\u5230\u7248\u672c\uff01\u65e0\u6cd5\u6dfb\u52a0\u5230\u5e94\u7528\u5217\u8868'\nLocalAppVersionErr: '{{.name}} \u540c\u6b65\u7248\u672c {{.version}} \u5931\u8d25\uff01{{.err}}'\nErrFileNotFound: '{{.name}} \u6587\u4ef6\u4e0d\u5b58\u5728'\nErrFileParseApp: '{{.name}} \u6587\u4ef6\u89e3\u6790\u5931\u8d25 {{.err}}'\nErrAppDirNull: '\u7248\u672c\u6587\u4ef6\u5939\u4e0d\u5b58\u5728'\nLocalAppErr: \"\u5e94\u7528 {{.name}} \u540c\u6b65\u5931\u8d25\uff01{{.err}}\"\nErrContainerName: \"\u5bb9\u5668\u540d\u79f0\u5df2\u5b58\u5728\"\nErrAppSystemRestart: \"1Panel \u91cd\u542f\u5bfc\u81f4\u4efb\u52a1\u7ec8\u6b62\"\nErrCreateHttpClient: \"\u521b\u5efaHTTP\u8bf7\u6c42\u5931\u8d25 {{.err}}\"\nErrHttpReqTimeOut: \"\u8bf7\u6c42\u8d85\u65f6 {{.err}}\"\nErrHttpReqFailed: \"\u8bf7\u6c42\u5931\u8d25 {{.err}}\"\nErrHttpReqNotFound: \"\u6587\u4ef6\u4e0d\u5b58\u5728\"\nErrNoSuchHost: \"\u7f51\u7edc\u8fde\u63a5\u5931\u8d25\"\nErrImagePullTimeOut: '\u955c\u50cf\u62c9\u53d6\u8d85\u65f6'\nErrContainerNotFound: '{{ .name }} \u5bb9\u5668\u4e0d\u5b58\u5728'\nErrContainerMsg: '{{ .name }} \u5bb9\u5668\u5f02\u5e38\uff0c\u5177\u4f53\u8bf7\u5728\u5bb9\u5668\u9875\u9762\u67e5\u770b\u65e5\u5fd7'\n\n#file\nErrFileCanNotRead: \"\u6b64\u6587\u4ef6\u4e0d\u652f\u6301\u9884\u89c8\"\nErrFileToLarge: \"\u6587\u4ef6\u8d85\u8fc710M,\u65e0\u6cd5\u6253\u5f00\"\nErrPathNotFound: \"\u76ee\u5f55\u4e0d\u5b58\u5728\"\nErrMovePathFailed: \"\u76ee\u6807\u8def\u5f84\u4e0d\u80fd\u5305\u542b\u539f\u8def\u5f84\uff01\"\nErrLinkPathNotFound: \"\u76ee\u6807\u8def\u5f84\u4e0d\u5b58\u5728!\"\nErrFileIsExit: \"\u6587\u4ef6\u5df2\u5b58\u5728\uff01\"\nErrFileUpload: \"{{ .name }} \u4e0a\u4f20\u6587\u4ef6\u5931\u8d25 {{ .detail}}\"\nErrFileDownloadDir: \"\u4e0d\u652f\u6301\u4e0b\u8f7d\u6587\u4ef6\u5939\"\n\n#website\nErrDomainIsExist: \"\u57df\u540d\u5df2\u5b58\u5728\"\nErrAliasIsExist: \"\u4ee3\u53f7\u5df2\u5b58\u5728\"\nErrAppDelete: '\u5176\u4ed6\u7f51\u7ad9\u4f7f\u7528\u6b64\u5e94\u7528,\u65e0\u6cd5\u5220\u9664'\nErrGroupIsUsed: '\u5206\u7ec4\u6b63\u5728\u4f7f\u7528\u4e2d\uff0c\u65e0\u6cd5\u5220\u9664'\nErrBackupMatch: '\u8be5\u5907\u4efd\u6587\u4ef6\u4e0e\u5f53\u524d\u7f51\u7ad9\u90e8\u5206\u6570\u636e\u4e0d\u5339\u914d {{ .detail}}\"'\nErrBackupExist: '\u8be5\u5907\u4efd\u6587\u4ef6\u5bf9\u5e94\u90e8\u5206\u6e90\u6570\u636e\u4e0d\u5b58\u5728 {{ .detail}}\"'\n\n#ssl\nErrSSLCannotDelete: \"\u8bc1\u4e66\u6b63\u5728\u88ab\u7f51\u7ad9\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrAccountCannotDelete: \"\u8d26\u53f7\u5173\u8054\u8bc1\u4e66\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrSSLApply: \"\u8bc1\u4e66\u7eed\u7b7e\u6210\u529f\uff0copenresty reload\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u914d\u7f6e\uff01\"\nErrEmailIsExist: '\u90ae\u7bb1\u5df2\u5b58\u5728'\nErrSSLKeyNotFound: '\u79c1\u94a5\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLCertificateNotFound: '\u8bc1\u4e66\u6587\u4ef6\u4e0d\u5b58\u5728'\nErrSSLKeyFormat: '\u79c1\u94a5\u6587\u4ef6\u6821\u9a8c\u5931\u8d25'\nErrSSLCertificateFormat: '\u8bc1\u4e66\u6587\u4ef6\u683c\u5f0f\u9519\u8bef\uff0c\u8bf7\u4f7f\u7528 pem \u683c\u5f0f'\n\n#mysql\nErrUserIsExist: \"\u5f53\u524d\u7528\u6237\u5df2\u5b58\u5728\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\"\nErrDatabaseIsExist: \"\u5f53\u524d\u6570\u636e\u5e93\u5df2\u5b58\u5728\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\"\nErrExecTimeOut: \"SQL \u6267\u884c\u8d85\u65f6\uff0c\u8bf7\u68c0\u67e5{{ .detail }}\u5bb9\u5668\"\n\n#redis\nErrTypeOfRedis: \"\u6062\u590d\u6587\u4ef6\u7c7b\u578b\u4e0e\u5f53\u524d\u6301\u4e45\u5316\u65b9\u5f0f\u4e0d\u7b26\uff0c\u8bf7\u4fee\u6539\u540e\u91cd\u8bd5\"\n\n#container \nErrInUsed: \"{{ .detail }} \u6b63\u88ab\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrObjectInUsed: \"\u8be5\u5bf9\u8c61\u6b63\u88ab\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\nErrPortRules: \"\u7aef\u53e3\u6570\u76ee\u4e0d\u5339\u914d\uff0c\u8bf7\u91cd\u65b0\u8f93\u5165\uff01\"\n\n#runtime\nErrDirNotFound: \"build \u6587\u4ef6\u5939\u4e0d\u5b58\u5728\uff01\u8bf7\u68c0\u67e5\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrFileNotExist: \"{{ .detail }} \u6587\u4ef6\u4e0d\u5b58\u5728\uff01\u8bf7\u68c0\u67e5\u6e90\u6587\u4ef6\u5b8c\u6574\u6027\uff01\"\nErrImageBuildErr: \"\u955c\u50cf build \u5931\u8d25\"\nErrImageExist: \"\u955c\u50cf\u5df2\u5b58\u5728\uff01\"\nErrDelWithWebsite: \"\u8fd0\u884c\u73af\u5883\u5df2\u7ecf\u5173\u8054\u7f51\u7ad9\uff0c\u65e0\u6cd5\u5220\u9664\"\n\n#setting\nErrBackupInUsed: \"\u8be5\u5907\u4efd\u8d26\u53f7\u5df2\u5728\u8ba1\u5212\u4efb\u52a1\u4e2d\u4f7f\u7528\uff0c\u65e0\u6cd5\u5220\u9664\"\n\nErrOSSConn: \"\u65e0\u6cd5\u6210\u529f\u8bf7\u6c42\u6700\u65b0\u7248\u672c\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u5668\u662f\u5426\u80fd\u591f\u8fde\u63a5\u5230\u5916\u90e8\u7f51\u7edc\u73af\u5883\u3002\"\n", "package client\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n)\n\ntype Firewall struct{}\n\nfunc NewFirewalld() (*Firewall, error) {\n\treturn &Firewall{}, nil\n}\n\nfunc (f *Firewall) Name() string {\n\treturn \"firewalld\"\n}\n\nfunc (f *Firewall) Status() (string, error) {\n\tstdout, _ := cmd.Exec(\"firewall-cmd --state\")\n\tif stdout == \"running\\n\" {\n\t\treturn \"running\", nil\n\t}\n\treturn \"not running\", nil\n}\n\nfunc (f *Firewall) Version() (string, error) {\n\tstdout, err := cmd.Exec(\"firewall-cmd --version\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"load the firewall version failed, err: %s\", stdout)\n\t}\n\treturn strings.ReplaceAll(stdout, \"\\n \", \"\"), nil\n}\n\nfunc (f *Firewall) Start() error {\n\tstdout, err := cmd.Exec(\"systemctl start firewalld\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"enable the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) Stop() error {\n\tstdout, err := cmd.Exec(\"systemctl stop firewalld\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stop the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) Reload() error {\n\tstdout, err := cmd.Exec(\"firewall-cmd --reload\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"reload firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) ListPort() ([]FireInfo, error) {\n\tstdout, err := cmd.Exec(\"firewall-cmd --zone=public --list-ports\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tports := strings.Split(strings.ReplaceAll(stdout, \"\\n\", \"\"), \" \")\n\tvar datas []FireInfo\n\tfor _, port := range ports {\n\t\tif len(port) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvar itemPort FireInfo\n\t\tif strings.Contains(port, \"/\") {\n\t\t\titemPort.Port = strings.Split(port, \"/\")[0]\n\t\t\titemPort.Protocol = strings.Split(port, \"/\")[1]\n\t\t}\n\t\titemPort.Strategy = \"accept\"\n\t\tdatas = append(datas, itemPort)\n\t}\n\n\tstdout1, err := cmd.Exec(\"firewall-cmd --zone=public --list-rich-rules\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trules := strings.Split(stdout1, \"\\n\")\n\tfor _, rule := range rules {\n\t\tif len(rule) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\titemRule := f.loadInfo(rule)\n\t\tif len(itemRule.Port) != 0 && itemRule.Family == \"ipv4\" {\n\t\t\tdatas = append(datas, itemRule)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Firewall) ListAddress() ([]FireInfo, error) {\n\tstdout, err := cmd.Exec(\"firewall-cmd --zone=public --list-rich-rules\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar datas []FireInfo\n\trules := strings.Split(stdout, \"\\n\")\n\tfor _, rule := range rules {\n\t\tif len(rule) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\titemRule := f.loadInfo(rule)\n\t\tif len(itemRule.Port) == 0 && len(itemRule.Address) != 0 {\n\t\t\tdatas = append(datas, itemRule)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Firewall) Port(port FireInfo, operation string) error {\n\tif cmd.CheckIllegal(operation, port.Protocol, port.Port) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\n\tstdout, err := cmd.Execf(\"firewall-cmd --zone=public --%s-port=%s/%s --permanent\", operation, port.Port, port.Protocol)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) RichRules(rule FireInfo, operation string) error {\n\tif cmd.CheckIllegal(operation, rule.Address, rule.Protocol, rule.Port, rule.Strategy) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\truleStr := \"\"\n\tif strings.Contains(rule.Address, \"-\") {\n\t\tstd, err := cmd.Execf(\"firewall-cmd --permanent --new-ipset=%s --type=hash:ip\", rule.Address)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"add new ipset failed, err: %s\", std)\n\t\t}\n\t\tstd2, err := cmd.Execf(\"firewall-cmd --permanent --ipset=%s --add-entry=%s\", rule.Address, rule.Address)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"add entry to ipset failed, err: %s\", std2)\n\t\t}\n\t\tif err := f.Reload(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\truleStr = fmt.Sprintf(\"rule source ipset=%s %s\", rule.Address, rule.Strategy)\n\t} else {\n\t\truleStr = \"rule family=ipv4 \"\n\t\tif len(rule.Address) != 0 {\n\t\t\truleStr += fmt.Sprintf(\"source address=%s \", rule.Address)\n\t\t}\n\t\tif len(rule.Port) != 0 {\n\t\t\truleStr += fmt.Sprintf(\"port port=%s \", rule.Port)\n\t\t}\n\t\tif len(rule.Protocol) != 0 {\n\t\t\truleStr += fmt.Sprintf(\"protocol=%s \", rule.Protocol)\n\t\t}\n\t\truleStr += rule.Strategy\n\t}\n\tstdout, err := cmd.Execf(\"firewall-cmd --zone=public --%s-rich-rule '%s' --permanent\", operation, ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s rich rules failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) PortForward(info Forward, operation string) error {\n\truleStr := fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Target)\n\tif len(info.Address) != 0 {\n\t\truleStr = fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toaddr=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Address, info.Target)\n\t}\n\n\tstdout, err := cmd.Exec(ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port forward failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Firewall) loadInfo(line string) FireInfo {\n\tvar itemRule FireInfo\n\truleInfo := strings.Split(strings.ReplaceAll(line, \"\\\"\", \"\"), \" \")\n\tfor _, item := range ruleInfo {\n\t\tswitch {\n\t\tcase strings.Contains(item, \"family=\"):\n\t\t\titemRule.Family = strings.ReplaceAll(item, \"family=\", \"\")\n\t\tcase strings.Contains(item, \"ipset=\"):\n\t\t\titemRule.Address = strings.ReplaceAll(item, \"ipset=\", \"\")\n\t\tcase strings.Contains(item, \"address=\"):\n\t\t\titemRule.Address = strings.ReplaceAll(item, \"address=\", \"\")\n\t\tcase strings.Contains(item, \"port=\"):\n\t\t\titemRule.Port = strings.ReplaceAll(item, \"port=\", \"\")\n\t\tcase strings.Contains(item, \"protocol=\"):\n\t\t\titemRule.Protocol = strings.ReplaceAll(item, \"protocol=\", \"\")\n\t\tcase item == \"accept\" || item == \"drop\" || item == \"reject\":\n\t\t\titemRule.Strategy = item\n\t\t}\n\t}\n\treturn itemRule\n}\n", "package client\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/1Panel-dev/1Panel/backend/buserr\"\n\t\"github.com/1Panel-dev/1Panel/backend/constant\"\n\t\"github.com/1Panel-dev/1Panel/backend/utils/cmd\"\n)\n\ntype Ufw struct {\n\tCmdStr string\n}\n\nfunc NewUfw() (*Ufw, error) {\n\tvar ufw Ufw\n\tif cmd.HasNoPasswordSudo() {\n\t\tufw.CmdStr = \"sudo ufw\"\n\t} else {\n\t\tufw.CmdStr = \"ufw\"\n\t}\n\treturn &ufw, nil\n}\n\nfunc (f *Ufw) Name() string {\n\treturn \"ufw\"\n}\n\nfunc (f *Ufw) Status() (string, error) {\n\tstdout, _ := cmd.Execf(\"%s status | grep Status\", f.CmdStr)\n\tif stdout == \"Status: active\\n\" {\n\t\treturn \"running\", nil\n\t}\n\tstdout1, _ := cmd.Execf(\"%s status | grep \u72b6\u6001\", f.CmdStr)\n\tif stdout1 == \"\u72b6\u6001\uff1a \u6fc0\u6d3b\\n\" {\n\t\treturn \"running\", nil\n\t}\n\treturn \"not running\", nil\n}\n\nfunc (f *Ufw) Version() (string, error) {\n\tstdout, err := cmd.Execf(\"%s version | grep ufw\", f.CmdStr)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"load the firewall status failed, err: %s\", stdout)\n\t}\n\tinfo := strings.ReplaceAll(stdout, \"\\n\", \"\")\n\treturn strings.ReplaceAll(info, \"ufw \", \"\"), nil\n}\n\nfunc (f *Ufw) Start() error {\n\tstdout, err := cmd.Execf(\"echo y | %s enable\", f.CmdStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"enable the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) Stop() error {\n\tstdout, err := cmd.Execf(\"%s disable\", f.CmdStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stop the firewall failed, err: %s\", stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) Reload() error {\n\treturn nil\n}\n\nfunc (f *Ufw) ListPort() ([]FireInfo, error) {\n\tstdout, err := cmd.Execf(\"%s status verbose\", f.CmdStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tportInfos := strings.Split(stdout, \"\\n\")\n\tvar datas []FireInfo\n\tisStart := false\n\tfor _, line := range portInfos {\n\t\tif strings.HasPrefix(line, \"-\") {\n\t\t\tisStart = true\n\t\t\tcontinue\n\t\t}\n\t\tif !isStart {\n\t\t\tcontinue\n\t\t}\n\t\titemFire := f.loadInfo(line, \"port\")\n\t\tif len(itemFire.Port) != 0 && itemFire.Port != \"Anywhere\" && !strings.Contains(itemFire.Port, \".\") {\n\t\t\titemFire.Port = strings.ReplaceAll(itemFire.Port, \":\", \"-\")\n\t\t\tdatas = append(datas, itemFire)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Ufw) ListAddress() ([]FireInfo, error) {\n\tstdout, err := cmd.Execf(\"%s status verbose\", f.CmdStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tportInfos := strings.Split(stdout, \"\\n\")\n\tvar datas []FireInfo\n\tisStart := false\n\tfor _, line := range portInfos {\n\t\tif strings.HasPrefix(line, \"-\") {\n\t\t\tisStart = true\n\t\t\tcontinue\n\t\t}\n\t\tif !isStart {\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.Contains(line, \" IN\") {\n\t\t\tcontinue\n\t\t}\n\t\titemFire := f.loadInfo(line, \"address\")\n\t\tif strings.Contains(itemFire.Port, \".\") {\n\t\t\titemFire.Address += (\"-\" + itemFire.Port)\n\t\t\titemFire.Port = \"\"\n\t\t}\n\t\tif len(itemFire.Port) == 0 && len(itemFire.Address) != 0 {\n\t\t\tdatas = append(datas, itemFire)\n\t\t}\n\t}\n\treturn datas, nil\n}\n\nfunc (f *Ufw) Port(port FireInfo, operation string) error {\n\tswitch port.Strategy {\n\tcase \"accept\":\n\t\tport.Strategy = \"allow\"\n\tcase \"drop\":\n\t\tport.Strategy = \"deny\"\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupport strategy %s\", port.Strategy)\n\t}\n\tif cmd.CheckIllegal(port.Protocol, port.Port) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\n\tcommand := fmt.Sprintf(\"%s %s %s\", f.CmdStr, port.Strategy, port.Port)\n\tif operation == \"remove\" {\n\t\tcommand = fmt.Sprintf(\"%s delete %s %s\", f.CmdStr, port.Strategy, port.Port)\n\t}\n\tif len(port.Protocol) != 0 {\n\t\tcommand += fmt.Sprintf(\"/%s\", port.Protocol)\n\t}\n\tstdout, err := cmd.Exec(command)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) RichRules(rule FireInfo, operation string) error {\n\tswitch rule.Strategy {\n\tcase \"accept\":\n\t\trule.Strategy = \"allow\"\n\tcase \"drop\":\n\t\trule.Strategy = \"deny\"\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupport strategy %s\", rule.Strategy)\n\t}\n\n\tif cmd.CheckIllegal(operation, rule.Protocol, rule.Address, rule.Port) {\n\t\treturn buserr.New(constant.ErrCmdIllegal)\n\t}\n\n\truleStr := fmt.Sprintf(\"%s %s \", f.CmdStr, rule.Strategy)\n\tif operation == \"remove\" {\n\t\truleStr = fmt.Sprintf(\"%s delete %s \", f.CmdStr, rule.Strategy)\n\t}\n\tif len(rule.Protocol) != 0 {\n\t\truleStr += fmt.Sprintf(\"proto %s \", rule.Protocol)\n\t}\n\tif strings.Contains(rule.Address, \"-\") {\n\t\truleStr += fmt.Sprintf(\"from %s to %s \", strings.Split(rule.Address, \"-\")[0], strings.Split(rule.Address, \"-\")[1])\n\t} else {\n\t\truleStr += fmt.Sprintf(\"from %s \", rule.Address)\n\t}\n\tif len(rule.Port) != 0 {\n\t\truleStr += fmt.Sprintf(\"to any port %s \", rule.Port)\n\t}\n\n\tstdout, err := cmd.Exec(ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s rich rules failed, err: %s\", operation, stdout)\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) PortForward(info Forward, operation string) error {\n\truleStr := fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Target)\n\tif len(info.Address) != 0 {\n\t\truleStr = fmt.Sprintf(\"firewall-cmd --%s-forward-port=port=%s:proto=%s:toaddr=%s:toport=%s --permanent\", operation, info.Port, info.Protocol, info.Address, info.Target)\n\t}\n\n\tstdout, err := cmd.Exec(ruleStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s port forward failed, err: %s\", operation, stdout)\n\t}\n\tif err := f.Reload(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (f *Ufw) loadInfo(line string, fireType string) FireInfo {\n\tfields := strings.Fields(line)\n\tvar itemInfo FireInfo\n\tif len(fields) < 4 {\n\t\treturn itemInfo\n\t}\n\tif fields[1] == \"(v6)\" {\n\t\treturn itemInfo\n\t}\n\tif fields[0] == \"Anywhere\" && fireType != \"port\" {\n\t\titemInfo.Strategy = \"drop\"\n\t\tif fields[1] == \"ALLOW\" {\n\t\t\titemInfo.Strategy = \"accept\"\n\t\t}\n\t\titemInfo.Address = fields[3]\n\t\treturn itemInfo\n\t}\n\tif strings.Contains(fields[0], \"/\") {\n\t\titemInfo.Port = strings.Split(fields[0], \"/\")[0]\n\t\titemInfo.Protocol = strings.Split(fields[0], \"/\")[1]\n\t} else {\n\t\titemInfo.Port = fields[0]\n\t\titemInfo.Protocol = \"tcp/udp\"\n\t}\n\titemInfo.Family = \"ipv4\"\n\tif fields[1] == \"ALLOW\" {\n\t\titemInfo.Strategy = \"accept\"\n\t} else {\n\t\titemInfo.Strategy = \"drop\"\n\t}\n\titemInfo.Address = fields[3]\n\n\treturn itemInfo\n}\n"], "filenames": ["backend/app/service/container.go", "backend/app/service/container_compose.go", "backend/app/service/database_mysql.go", "backend/app/service/firewall.go", "backend/app/service/image_repo.go", "backend/app/service/ssh.go", "backend/constant/errs.go", "backend/i18n/lang/en.yaml", "backend/i18n/lang/zh-Hant.yaml", "backend/i18n/lang/zh.yaml", "backend/utils/firewall/client/firewalld.go", "backend/utils/firewall/client/ufw.go"], "buggy_code_start_loc": [20, 16, 19, 307, 82, 13, 44, 15, 15, 15, 6, 6], "buggy_code_end_loc": [554, 197, 255, 308, 152, 148, 111, 87, 87, 87, 124, 158], "fixing_code_start_loc": [21, 17, 20, 306, 82, 14, 45, 16, 16, 16, 7, 7], "fixing_code_end_loc": [559, 212, 268, 306, 152, 153, 110, 86, 86, 86, 134, 168], "type": "CWE-78", "message": "1Panel is an open source Linux server operation and maintenance management panel. An OS command injection vulnerability exists in 1Panel firewall functionality. A specially-crafted HTTP request can lead to arbitrary command execution. An attacker can make an authenticated HTTP request to trigger this vulnerability. 1Panel firewall functionality `/hosts/firewall/ip` endpoint read user input without validation, the attacker extends the default functionality of the application, which execute system commands. An attacker can execute arbitrary code on the target system, which can lead to a complete compromise of the system. This issue has been addressed in commit `e17b80cff49` which is included in release version `1.4.3`. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-37477", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-18T19:15:09.757", "lastModified": "2023-07-27T18:20:05.917", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "1Panel is an open source Linux server operation and maintenance management panel. An OS command injection vulnerability exists in 1Panel firewall functionality. A specially-crafted HTTP request can lead to arbitrary command execution. An attacker can make an authenticated HTTP request to trigger this vulnerability. 1Panel firewall functionality `/hosts/firewall/ip` endpoint read user input without validation, the attacker extends the default functionality of the application, which execute system commands. An attacker can execute arbitrary code on the target system, which can lead to a complete compromise of the system. This issue has been addressed in commit `e17b80cff49` which is included in release version `1.4.3`. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fit2cloud:1panel:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.3", "matchCriteriaId": "99A79710-3BD4-49D2-98B3-FCF398F40F8E"}]}]}], "references": [{"url": "https://github.com/1Panel-dev/1Panel/commit/e17b80cff4975ee343568ff526b62319f499005d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/1Panel-dev/1Panel/security/advisories/GHSA-p9xf-74xh-mhw5", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/1Panel-dev/1Panel/commit/e17b80cff4975ee343568ff526b62319f499005d"}}