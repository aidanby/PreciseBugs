{"buggy_code": ["/** @file mat4.c\n * Matlab MAT version 4 file functions\n * @ingroup MAT\n */\n/*\n * Copyright (c) 2005-2019, Christopher C. Hulbert\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <limits.h>\n#if defined(__GLIBC__)\n#include <endian.h>\n#endif\n#include \"matio_private.h\"\n#include \"mat4.h\"\n\n/** @if mat_devman\n * @brief Creates a new Matlab MAT version 4 file\n *\n * Tries to create a new Matlab MAT file with the given name.\n * @ingroup MAT\n * @param matname Name of MAT file to create\n * @return A pointer to the MAT file or NULL if it failed.  This is not a\n * simple FILE * and should not be used as one.\n * @endif\n */\nmat_t *\nMat_Create4(const char* matname)\n{\n    FILE *fp = NULL;\n    mat_t *mat = NULL;\n\n#if defined(_WIN32) && defined(_MSC_VER)\n    wchar_t* wname = utf82u(matname);\n    if ( NULL != wname ) {\n        fp = _wfopen(wname, L\"w+b\");\n        free(wname);\n    }\n#else\n    fp = fopen(matname, \"w+b\");\n#endif\n    if ( !fp )\n        return NULL;\n\n    mat = (mat_t*)malloc(sizeof(*mat));\n    if ( NULL == mat ) {\n        fclose(fp);\n        Mat_Critical(\"Couldn't allocate memory for the MAT file\");\n        return NULL;\n    }\n\n    mat->fp            = fp;\n    mat->header        = NULL;\n    mat->subsys_offset = NULL;\n    mat->filename      = strdup_printf(\"%s\",matname);\n    mat->version       = MAT_FT_MAT4;\n    mat->byteswap      = 0;\n    mat->mode          = 0;\n    mat->bof           = 0;\n    mat->next_index    = 0;\n    mat->num_datasets  = 0;\n#if defined(MAT73) && MAT73\n    mat->refs_id       = -1;\n#endif\n    mat->dir           = NULL;\n\n    Mat_Rewind(mat);\n\n    return mat;\n}\n\n/** @if mat_devman\n * @brief Writes a matlab variable to a version 4 matlab file\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarWrite4(mat_t *mat,matvar_t *matvar)\n{\n    typedef struct {\n        mat_int32_t type;\n        mat_int32_t mrows;\n        mat_int32_t ncols;\n        mat_int32_t imagf;\n        mat_int32_t namelen;\n    } Fmatrix;\n\n    mat_int32_t nelems = 1, i;\n    Fmatrix x;\n\n    if ( NULL == mat || NULL == matvar || NULL == matvar->name || matvar->rank != 2 )\n        return -1;\n\n    switch ( matvar->data_type ) {\n        case MAT_T_DOUBLE:\n            x.type = 0;\n            break;\n        case MAT_T_SINGLE:\n            x.type = 10;\n            break;\n        case MAT_T_INT32:\n            x.type = 20;\n            break;\n        case MAT_T_INT16:\n            x.type = 30;\n            break;\n        case MAT_T_UINT16:\n            x.type = 40;\n            break;\n        case MAT_T_UINT8:\n            x.type = 50;\n            break;\n        default:\n            return 2;\n    }\n\n#if defined(__GLIBC__)\n#if (__BYTE_ORDER == __LITTLE_ENDIAN)\n#elif (__BYTE_ORDER == __BIG_ENDIAN)\n    x.type += 1000;\n#else\n    return -1;\n#endif\n#elif defined(_BIG_ENDIAN) && !defined(_LITTLE_ENDIAN)\n    x.type += 1000;\n#elif defined(_LITTLE_ENDIAN) && !defined(_BIG_ENDIAN)\n#elif defined(__sparc) || defined(__sparc__) || defined(_POWER) || defined(__powerpc__) || \\\n      defined(__ppc__) || defined(__hpux) || defined(_MIPSEB) || defined(_POWER) || defined(__s390__)\n    x.type += 1000;\n#elif defined(__i386__) || defined(__alpha__) || defined(__ia64) || defined(__ia64__) || \\\n      defined(_M_IX86) || defined(_M_IA64) || defined(_M_ALPHA) || defined(__amd64) || \\\n      defined(__amd64__) || defined(_M_AMD64) || defined(__x86_64) || defined(__x86_64__) || \\\n      defined(_M_X64) || defined(__bfin__)\n#else\n    return -1;\n#endif\n\n    x.namelen = (mat_int32_t)strlen(matvar->name) + 1;\n\n    /* FIXME: SEEK_END is not Guaranteed by the C standard */\n    (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */\n\n    switch ( matvar->class_type ) {\n        case MAT_C_CHAR:\n            x.type++;\n            /* Fall through */\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n        case MAT_C_INT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_UINT8:\n            for ( i = 0; i < matvar->rank; i++ ) {\n                mat_int32_t dim;\n                dim = (mat_int32_t)matvar->dims[i];\n                nelems *= dim;\n            }\n\n            x.mrows = (mat_int32_t)matvar->dims[0];\n            x.ncols = (mat_int32_t)matvar->dims[1];\n            x.imagf = matvar->isComplex ? 1 : 0;\n            fwrite(&x, sizeof(Fmatrix), 1, (FILE*)mat->fp);\n            fwrite(matvar->name, sizeof(char), x.namelen, (FILE*)mat->fp);\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data;\n\n                complex_data = (mat_complex_split_t*)matvar->data;\n                fwrite(complex_data->Re, matvar->data_size, nelems, (FILE*)mat->fp);\n                fwrite(complex_data->Im, matvar->data_size, nelems, (FILE*)mat->fp);\n            }\n            else {\n                fwrite(matvar->data, matvar->data_size, nelems, (FILE*)mat->fp);\n            }\n            break;\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t* sparse;\n            double tmp;\n            int j;\n            size_t stride = Mat_SizeOf(matvar->data_type);\n#if !defined(EXTENDED_SPARSE)\n            if ( MAT_T_DOUBLE != matvar->data_type )\n                break;\n#endif\n\n            sparse = (mat_sparse_t*)matvar->data;\n            x.type += 2;\n            x.mrows = sparse->njc > 0 ? sparse->jc[sparse->njc - 1] + 1 : 1;\n            x.ncols = matvar->isComplex ? 4 : 3;\n            x.imagf = 0;\n\n            fwrite(&x, sizeof(Fmatrix), 1, (FILE*)mat->fp);\n            fwrite(matvar->name, sizeof(char), x.namelen, (FILE*)mat->fp);\n\n            for ( i = 0; i < sparse->njc - 1; i++ ) {\n                for ( j = sparse->jc[i];\n                      j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                    tmp = sparse->ir[j] + 1;\n                    fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n                }\n            }\n            tmp = (double)matvar->dims[0];\n            fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n            for ( i = 0; i < sparse->njc - 1; i++ ) {\n                for ( j = sparse->jc[i];\n                      j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                    tmp = i + 1;\n                    fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n                }\n            }\n            tmp = (double)matvar->dims[1];\n            fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n            tmp = 0.;\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data;\n                char* re, *im;\n\n                complex_data = (mat_complex_split_t*)sparse->data;\n                re = (char*)complex_data->Re;\n                im = (char*)complex_data->Im;\n                for ( i = 0; i < sparse->njc - 1; i++ ) {\n                    for ( j = sparse->jc[i];\n                          j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                        fwrite(re + j*stride, stride, 1, (FILE*)mat->fp);\n                    }\n                }\n                fwrite(&tmp, stride, 1, (FILE*)mat->fp);\n                for ( i = 0; i < sparse->njc - 1; i++ ) {\n                    for ( j = sparse->jc[i];\n                          j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                        fwrite(im + j*stride, stride, 1, (FILE*)mat->fp);\n                    }\n                }\n            } else {\n                char *data = (char*)sparse->data;\n                for ( i = 0; i < sparse->njc - 1; i++ ) {\n                    for ( j = sparse->jc[i];\n                          j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                        fwrite(data + j*stride, stride, 1, (FILE*)mat->fp);\n                    }\n                }\n            }\n            fwrite(&tmp, stride, 1, (FILE*)mat->fp);\n            break;\n        }\n        default:\n            break;\n    }\n\n    return 0;\n}\n\n/** @if mat_devman\n * @brief Reads the data of a version 4 MAT file variable\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer to read the data\n * @endif\n */\nvoid\nMat_VarRead4(mat_t *mat,matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return;\n    }\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n            matvar->data_size = sizeof(double);\n            err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n            if ( err ) {\n                Mat_Critical(\"Integer multiplication overflow\");\n                return;\n            }\n\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = ComplexMalloc(matvar->nbytes);\n                if ( NULL != complex_data ) {\n                    matvar->data = complex_data;\n                    ReadDoubleData(mat, (double*)complex_data->Re, matvar->data_type, nelems);\n                    ReadDoubleData(mat, (double*)complex_data->Im, matvar->data_type, nelems);\n                }\n                else {\n                    Mat_Critical(\"Couldn't allocate memory for the complex data\");\n                }\n            } else {\n                matvar->data = malloc(matvar->nbytes);\n                if ( NULL != matvar->data ) {\n                    ReadDoubleData(mat, (double*)matvar->data, matvar->data_type, nelems);\n                }\n                else {\n                    Mat_Critical(\"Couldn't allocate memory for the data\");\n                }\n            }\n            /* Update data type to match format of matvar->data */\n            matvar->data_type = MAT_T_DOUBLE;\n            break;\n        case MAT_C_CHAR:\n            matvar->data_size = 1;\n            matvar->nbytes = nelems;\n            matvar->data = malloc(matvar->nbytes);\n            if ( NULL != matvar->data ) {\n                ReadUInt8Data(mat, (mat_uint8_t*)matvar->data, matvar->data_type, nelems);\n            }\n            else {\n                Mat_Critical(\"Couldn't allocate memory for the data\");\n            }\n            matvar->data_type = MAT_T_UINT8;\n            break;\n        case MAT_C_SPARSE:\n            matvar->data_size = sizeof(mat_sparse_t);\n            matvar->data      = malloc(matvar->data_size);\n            if ( NULL != matvar->data ) {\n                double tmp;\n                int i;\n                mat_sparse_t* sparse;\n                long fpos;\n                enum matio_types data_type = MAT_T_DOUBLE;\n\n                /* matvar->dims[1] either is 3 for real or 4 for complex sparse */\n                matvar->isComplex = matvar->dims[1] == 4 ? 1 : 0;\n                sparse = (mat_sparse_t*)matvar->data;\n                sparse->nir = matvar->dims[0] - 1;\n                sparse->nzmax = sparse->nir;\n                sparse->ir = (mat_int32_t*)malloc(sparse->nir*sizeof(mat_int32_t));\n                if ( sparse->ir != NULL ) {\n                    ReadInt32Data(mat, sparse->ir, data_type, sparse->nir);\n                    for ( i = 0; i < sparse->nir; i++ )\n                        sparse->ir[i] = sparse->ir[i] - 1;\n                } else {\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Couldn't allocate memory for the sparse row array\");\n                    return;\n                }\n                ReadDoubleData(mat, &tmp, data_type, 1);\n                matvar->dims[0] = (size_t)tmp;\n\n                fpos = ftell((FILE*)mat->fp);\n                if ( fpos == -1L ) {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Couldn't determine file position\");\n                    return;\n                }\n                (void)fseek((FILE*)mat->fp,sparse->nir*Mat_SizeOf(data_type),\n                    SEEK_CUR);\n                ReadDoubleData(mat, &tmp, data_type, 1);\n                if ( tmp > INT_MAX-1 || tmp < 0 ) {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Invalid column dimension for sparse matrix\");\n                    return;\n                }\n                matvar->dims[1] = (size_t)tmp;\n                (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);\n                if ( matvar->dims[1] > INT_MAX-1 ) {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Invalid column dimension for sparse matrix\");\n                    return;\n                }\n                sparse->njc = (int)matvar->dims[1] + 1;\n                sparse->jc = (mat_int32_t*)malloc(sparse->njc*sizeof(mat_int32_t));\n                if ( sparse->jc != NULL ) {\n                    mat_int32_t *jc;\n                    jc = (mat_int32_t*)malloc(sparse->nir*sizeof(mat_int32_t));\n                    if ( jc != NULL ) {\n                        int j = 0;\n                        sparse->jc[0] = 0;\n                        ReadInt32Data(mat, jc, data_type, sparse->nir);\n                        for ( i = 1; i < sparse->njc-1; i++ ) {\n                            while ( j < sparse->nir && jc[j] <= i )\n                                j++;\n                            sparse->jc[i] = j;\n                        }\n                        free(jc);\n                        /* terminating nnz */\n                        sparse->jc[sparse->njc-1] = sparse->nir;\n                    } else {\n                        free(sparse->jc);\n                        free(sparse->ir);\n                        free(matvar->data);\n                        matvar->data = NULL;\n                        Mat_Critical(\"Couldn't allocate memory for the sparse index array\");\n                        return;\n                    }\n                } else {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Couldn't allocate memory for the sparse index array\");\n                    return;\n                }\n                ReadDoubleData(mat, &tmp, data_type, 1);\n                sparse->ndata = sparse->nir;\n                data_type = matvar->data_type;\n                if ( matvar->isComplex ) {\n                    mat_complex_split_t *complex_data =\n                        ComplexMalloc(sparse->ndata*Mat_SizeOf(data_type));\n                    if ( NULL != complex_data ) {\n                        sparse->data = complex_data;\n#if defined(EXTENDED_SPARSE)\n                        switch ( data_type ) {\n                            case MAT_T_DOUBLE:\n                                ReadDoubleData(mat, (double*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadDoubleData(mat, &tmp, data_type, 1);\n                                ReadDoubleData(mat, (double*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadDoubleData(mat, &tmp, data_type, 1);\n                                break;\n                            case MAT_T_SINGLE:\n                            {\n                                float tmp2;\n                                ReadSingleData(mat, (float*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadSingleData(mat, &tmp2, data_type, 1);\n                                ReadSingleData(mat, (float*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadSingleData(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT32:\n                            {\n                                mat_int32_t tmp2;\n                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadInt32Data(mat, &tmp2, data_type, 1);\n                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadInt32Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT16:\n                            {\n                                mat_int16_t tmp2;\n                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadInt16Data(mat, &tmp2, data_type, 1);\n                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT16:\n                            {\n                                mat_uint16_t tmp2;\n                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadUInt16Data(mat, &tmp2, data_type, 1);\n                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadUInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT8:\n                            {\n                                mat_uint8_t tmp2;\n                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadUInt8Data(mat, &tmp2, data_type, 1);\n                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadUInt8Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            default:\n                                free(complex_data->Re);\n                                free(complex_data->Im);\n                                free(complex_data);\n                                free(sparse->jc);\n                                free(sparse->ir);\n                                free(matvar->data);\n                                matvar->data = NULL;\n                                Mat_Critical(\"Mat_VarRead4: %d is not a supported data type for \"\n                                    \"extended sparse\", data_type);\n                                return;\n                        }\n#else\n                        ReadDoubleData(mat, (double*)complex_data->Re,\n                            data_type, sparse->ndata);\n                        ReadDoubleData(mat, &tmp, data_type, 1);\n                        ReadDoubleData(mat, (double*)complex_data->Im,\n                            data_type, sparse->ndata);\n                        ReadDoubleData(mat, &tmp, data_type, 1);\n#endif\n                    }\n                    else {\n                        free(sparse->jc);\n                        free(sparse->ir);\n                        free(matvar->data);\n                        matvar->data = NULL;\n                        Mat_Critical(\"Couldn't allocate memory for the complex sparse data\");\n                        return;\n                    }\n                } else {\n                    sparse->data = malloc(sparse->ndata*Mat_SizeOf(data_type));\n                    if ( sparse->data != NULL ) {\n#if defined(EXTENDED_SPARSE)\n                        switch ( data_type ) {\n                            case MAT_T_DOUBLE:\n                                ReadDoubleData(mat, (double*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadDoubleData(mat, &tmp, data_type, 1);\n                                break;\n                            case MAT_T_SINGLE:\n                            {\n                                float tmp2;\n                                ReadSingleData(mat, (float*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadSingleData(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT32:\n                            {\n                                mat_int32_t tmp2;\n                                ReadInt32Data(mat, (mat_int32_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadInt32Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT16:\n                            {\n                                mat_int16_t tmp2;\n                                ReadInt16Data(mat, (mat_int16_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT16:\n                            {\n                                mat_uint16_t tmp2;\n                                ReadUInt16Data(mat, (mat_uint16_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadUInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT8:\n                            {\n                                mat_uint8_t tmp2;\n                                ReadUInt8Data(mat, (mat_uint8_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadUInt8Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            default:\n                                free(sparse->data);\n                                free(sparse->jc);\n                                free(sparse->ir);\n                                free(matvar->data);\n                                matvar->data = NULL;\n                                Mat_Critical(\"Mat_VarRead4: %d is not a supported data type for \"\n                                    \"extended sparse\", data_type);\n                                return;\n                        }\n#else\n                        ReadDoubleData(mat, (double*)sparse->data, data_type, sparse->ndata);\n                        ReadDoubleData(mat, &tmp, data_type, 1);\n#endif\n                    } else {\n                        free(sparse->jc);\n                        free(sparse->ir);\n                        free(matvar->data);\n                        matvar->data = NULL;\n                        Mat_Critical(\"Couldn't allocate memory for the sparse data\");\n                        return;\n                    }\n                }\n                break;\n            }\n            else {\n                Mat_Critical(\"Couldn't allocate memory for the data\");\n                return;\n            }\n        default:\n            Mat_Critical(\"MAT V4 data type error\");\n            return;\n    }\n\n    return;\n}\n\n/** @if mat_devman\n * @brief Reads a slab of data from a version 4 MAT file for the @c matvar variable\n *\n * @ingroup mat_internal\n * @param mat Version 4 MAT file pointer\n * @param matvar pointer to the mat variable\n * @param data pointer to store the read data in (must be of size\n *             edge[0]*...edge[rank-1]*Mat_SizeOfClass(matvar->class_type))\n * @param start index to start reading data in each dimension\n * @param stride write data every @c stride elements in each dimension\n * @param edge number of elements to read in each dimension\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarReadData4(mat_t *mat,matvar_t *matvar,void *data,\n      int *start,int *stride,int *edge)\n{\n    int err = 0;\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n    switch( matvar->data_type ) {\n        case MAT_T_DOUBLE:\n        case MAT_T_SINGLE:\n        case MAT_T_INT32:\n        case MAT_T_INT16:\n        case MAT_T_UINT16:\n        case MAT_T_UINT8:\n            break;\n        default:\n            return 1;\n    }\n\n    if ( matvar->rank == 2 ) {\n        if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > matvar->dims[0] )\n            err = 1;\n        else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > matvar->dims[1] )\n            err = 1;\n        if ( matvar->isComplex ) {\n            mat_complex_split_t *cdata = (mat_complex_split_t*)data;\n            size_t nbytes = Mat_SizeOf(matvar->data_type);\n            err = SafeMulDims(matvar, &nbytes);\n            if ( err ) {\n                Mat_Critical(\"Integer multiplication overflow\");\n                return err;\n            }\n\n            ReadDataSlab2(mat,cdata->Re,matvar->class_type,matvar->data_type,\n                matvar->dims,start,stride,edge);\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);\n            ReadDataSlab2(mat,cdata->Im,matvar->class_type,\n                matvar->data_type,matvar->dims,start,stride,edge);\n        } else {\n            ReadDataSlab2(mat,data,matvar->class_type,matvar->data_type,\n                matvar->dims,start,stride,edge);\n        }\n    } else if ( matvar->isComplex ) {\n        mat_complex_split_t *cdata = (mat_complex_split_t*)data;\n        size_t nbytes = Mat_SizeOf(matvar->data_type);\n        err = SafeMulDims(matvar, &nbytes);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return err;\n        }\n\n        ReadDataSlabN(mat,cdata->Re,matvar->class_type,matvar->data_type,\n            matvar->rank,matvar->dims,start,stride,edge);\n        (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);\n        ReadDataSlabN(mat,cdata->Im,matvar->class_type,matvar->data_type,\n            matvar->rank,matvar->dims,start,stride,edge);\n    } else {\n        ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,\n            matvar->rank,matvar->dims,start,stride,edge);\n    }\n\n    return err;\n}\n\n/** @brief Reads a subset of a MAT variable using a 1-D indexing\n *\n * Reads data from a MAT variable using a linear (1-D) indexing mode. The\n * variable must have been read by Mat_VarReadInfo.\n * @ingroup MAT\n * @param mat MAT file to read data from\n * @param matvar MAT variable information\n * @param data pointer to store data in (must be pre-allocated)\n * @param start starting index\n * @param stride stride of data\n * @param edge number of elements to read\n * @retval 0 on success\n */\nint\nMat_VarReadDataLinear4(mat_t *mat,matvar_t *matvar,void *data,int start,\n                       int stride,int edge)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return err;\n    }\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n    matvar->data_size = Mat_SizeOf(matvar->data_type);\n\n    if ( (size_t)stride*(edge-1)+start+1 > nelems ) {\n        return 1;\n    }\n    if ( matvar->isComplex ) {\n        mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n        err = SafeMul(&nelems, nelems, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return err;\n        }\n\n        ReadDataSlab1(mat,complex_data->Re,matvar->class_type,\n                      matvar->data_type,start,stride,edge);\n        (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nelems,SEEK_SET);\n        ReadDataSlab1(mat,complex_data->Im,matvar->class_type,\n                      matvar->data_type,start,stride,edge);\n    } else {\n        ReadDataSlab1(mat,data,matvar->class_type,matvar->data_type,start,\n                      stride,edge);\n    }\n\n    return err;\n}\n\n/** @if mat_devman\n * @brief Reads the header information for the next MAT variable in a version 4 MAT file\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @return pointer to the MAT variable or NULL\n * @endif\n */\nmatvar_t *\nMat_VarReadNextInfo4(mat_t *mat)\n{\n    int       M,O,data_type,class_type;\n    mat_int32_t tmp;\n    long      nBytes;\n    size_t    readresult;\n    matvar_t *matvar = NULL;\n    union {\n        mat_uint32_t u;\n        mat_uint8_t  c[4];\n    } endian;\n\n    if ( mat == NULL || mat->fp == NULL )\n        return NULL;\n    else if ( NULL == (matvar = Mat_VarCalloc()) )\n        return NULL;\n\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n\n    endian.u = 0x01020304;\n\n    /* See if MOPT may need byteswapping */\n    if ( tmp < 0 || tmp > 4052 ) {\n        if ( Mat_int32Swap(&tmp) > 4052 ) {\n            Mat_VarFree(matvar);\n            return NULL;\n        }\n    }\n\n    M = (int)floor(tmp / 1000.0);\n    switch ( M ) {\n        case 0:\n            /* IEEE little endian */\n            mat->byteswap = endian.c[0] != 4;\n            break;\n        case 1:\n            /* IEEE big endian */\n            mat->byteswap = endian.c[0] != 1;\n            break;\n        default:\n            /* VAX, Cray, or bogus */\n            Mat_VarFree(matvar);\n            return NULL;\n    }\n\n    tmp -= M*1000;\n    O = (int)floor(tmp / 100.0);\n    /* O must be zero */\n    if ( 0 != O ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n\n    tmp -= O*100;\n    data_type = (int)floor(tmp / 10.0);\n    /* Convert the V4 data type */\n    switch ( data_type ) {\n        case 0:\n            matvar->data_type = MAT_T_DOUBLE;\n            break;\n        case 1:\n            matvar->data_type = MAT_T_SINGLE;\n            break;\n        case 2:\n            matvar->data_type = MAT_T_INT32;\n            break;\n        case 3:\n            matvar->data_type = MAT_T_INT16;\n            break;\n        case 4:\n            matvar->data_type = MAT_T_UINT16;\n            break;\n        case 5:\n            matvar->data_type = MAT_T_UINT8;\n            break;\n        default:\n            Mat_VarFree(matvar);\n            return NULL;\n    }\n\n    tmp -= data_type*10;\n    class_type = (int)floor(tmp / 1.0);\n    switch ( class_type ) {\n        case 0:\n            matvar->class_type = MAT_C_DOUBLE;\n            break;\n        case 1:\n            matvar->class_type = MAT_C_CHAR;\n            break;\n        case 2:\n            matvar->class_type = MAT_C_SPARSE;\n            break;\n        default:\n            Mat_VarFree(matvar);\n            return NULL;\n    }\n\n    matvar->rank = 2;\n    matvar->dims = (size_t*)calloc(2, sizeof(*matvar->dims));\n    if ( NULL == matvar->dims ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( mat->byteswap )\n        Mat_int32Swap(&tmp);\n    matvar->dims[0] = tmp;\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( mat->byteswap )\n        Mat_int32Swap(&tmp);\n    matvar->dims[1] = tmp;\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n\n    readresult = fread(&(matvar->isComplex),sizeof(int),1,(FILE*)mat->fp);\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    if ( matvar->isComplex && MAT_C_CHAR == matvar->class_type ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    if ( mat->byteswap )\n        Mat_int32Swap(&tmp);\n    /* Check that the length of the variable name is at least 1 */\n    if ( tmp < 1 ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    matvar->name = (char*)malloc(tmp);\n    if ( NULL == matvar->name ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(matvar->name,1,tmp,(FILE*)mat->fp);\n    if ( tmp != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n\n    matvar->internal->datapos = ftell((FILE*)mat->fp);\n    if ( matvar->internal->datapos == -1L ) {\n        Mat_VarFree(matvar);\n        Mat_Critical(\"Couldn't determine file position\");\n        return NULL;\n    }\n    {\n        int err;\n        size_t tmp2 = Mat_SizeOf(matvar->data_type);\n        if ( matvar->isComplex )\n            tmp2 *= 2;\n        err = SafeMulDims(matvar, &tmp2);\n        if ( err ) {\n            Mat_VarFree(matvar);\n            Mat_Critical(\"Integer multiplication overflow\");\n            return NULL;\n        }\n\n        nBytes = (long)tmp2;\n    }\n    (void)fseek((FILE*)mat->fp,nBytes,SEEK_CUR);\n\n    return matvar;\n}\n"], "fixing_code": ["/** @file mat4.c\n * Matlab MAT version 4 file functions\n * @ingroup MAT\n */\n/*\n * Copyright (c) 2005-2019, Christopher C. Hulbert\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <limits.h>\n#if defined(__GLIBC__)\n#include <endian.h>\n#endif\n#include \"matio_private.h\"\n#include \"mat4.h\"\n\n/** @if mat_devman\n * @brief Creates a new Matlab MAT version 4 file\n *\n * Tries to create a new Matlab MAT file with the given name.\n * @ingroup MAT\n * @param matname Name of MAT file to create\n * @return A pointer to the MAT file or NULL if it failed.  This is not a\n * simple FILE * and should not be used as one.\n * @endif\n */\nmat_t *\nMat_Create4(const char* matname)\n{\n    FILE *fp = NULL;\n    mat_t *mat = NULL;\n\n#if defined(_WIN32) && defined(_MSC_VER)\n    wchar_t* wname = utf82u(matname);\n    if ( NULL != wname ) {\n        fp = _wfopen(wname, L\"w+b\");\n        free(wname);\n    }\n#else\n    fp = fopen(matname, \"w+b\");\n#endif\n    if ( !fp )\n        return NULL;\n\n    mat = (mat_t*)malloc(sizeof(*mat));\n    if ( NULL == mat ) {\n        fclose(fp);\n        Mat_Critical(\"Couldn't allocate memory for the MAT file\");\n        return NULL;\n    }\n\n    mat->fp            = fp;\n    mat->header        = NULL;\n    mat->subsys_offset = NULL;\n    mat->filename      = strdup_printf(\"%s\",matname);\n    mat->version       = MAT_FT_MAT4;\n    mat->byteswap      = 0;\n    mat->mode          = 0;\n    mat->bof           = 0;\n    mat->next_index    = 0;\n    mat->num_datasets  = 0;\n#if defined(MAT73) && MAT73\n    mat->refs_id       = -1;\n#endif\n    mat->dir           = NULL;\n\n    Mat_Rewind(mat);\n\n    return mat;\n}\n\n/** @if mat_devman\n * @brief Writes a matlab variable to a version 4 matlab file\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar pointer to the mat variable\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarWrite4(mat_t *mat,matvar_t *matvar)\n{\n    typedef struct {\n        mat_int32_t type;\n        mat_int32_t mrows;\n        mat_int32_t ncols;\n        mat_int32_t imagf;\n        mat_int32_t namelen;\n    } Fmatrix;\n\n    mat_int32_t nelems = 1, i;\n    Fmatrix x;\n\n    if ( NULL == mat || NULL == matvar || NULL == matvar->name || matvar->rank != 2 )\n        return -1;\n\n    switch ( matvar->data_type ) {\n        case MAT_T_DOUBLE:\n            x.type = 0;\n            break;\n        case MAT_T_SINGLE:\n            x.type = 10;\n            break;\n        case MAT_T_INT32:\n            x.type = 20;\n            break;\n        case MAT_T_INT16:\n            x.type = 30;\n            break;\n        case MAT_T_UINT16:\n            x.type = 40;\n            break;\n        case MAT_T_UINT8:\n            x.type = 50;\n            break;\n        default:\n            return 2;\n    }\n\n#if defined(__GLIBC__)\n#if (__BYTE_ORDER == __LITTLE_ENDIAN)\n#elif (__BYTE_ORDER == __BIG_ENDIAN)\n    x.type += 1000;\n#else\n    return -1;\n#endif\n#elif defined(_BIG_ENDIAN) && !defined(_LITTLE_ENDIAN)\n    x.type += 1000;\n#elif defined(_LITTLE_ENDIAN) && !defined(_BIG_ENDIAN)\n#elif defined(__sparc) || defined(__sparc__) || defined(_POWER) || defined(__powerpc__) || \\\n      defined(__ppc__) || defined(__hpux) || defined(_MIPSEB) || defined(_POWER) || defined(__s390__)\n    x.type += 1000;\n#elif defined(__i386__) || defined(__alpha__) || defined(__ia64) || defined(__ia64__) || \\\n      defined(_M_IX86) || defined(_M_IA64) || defined(_M_ALPHA) || defined(__amd64) || \\\n      defined(__amd64__) || defined(_M_AMD64) || defined(__x86_64) || defined(__x86_64__) || \\\n      defined(_M_X64) || defined(__bfin__)\n#else\n    return -1;\n#endif\n\n    x.namelen = (mat_int32_t)strlen(matvar->name) + 1;\n\n    /* FIXME: SEEK_END is not Guaranteed by the C standard */\n    (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */\n\n    switch ( matvar->class_type ) {\n        case MAT_C_CHAR:\n            x.type++;\n            /* Fall through */\n        case MAT_C_DOUBLE:\n        case MAT_C_SINGLE:\n        case MAT_C_INT32:\n        case MAT_C_INT16:\n        case MAT_C_UINT16:\n        case MAT_C_UINT8:\n            for ( i = 0; i < matvar->rank; i++ ) {\n                mat_int32_t dim;\n                dim = (mat_int32_t)matvar->dims[i];\n                nelems *= dim;\n            }\n\n            x.mrows = (mat_int32_t)matvar->dims[0];\n            x.ncols = (mat_int32_t)matvar->dims[1];\n            x.imagf = matvar->isComplex ? 1 : 0;\n            fwrite(&x, sizeof(Fmatrix), 1, (FILE*)mat->fp);\n            fwrite(matvar->name, sizeof(char), x.namelen, (FILE*)mat->fp);\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data;\n\n                complex_data = (mat_complex_split_t*)matvar->data;\n                fwrite(complex_data->Re, matvar->data_size, nelems, (FILE*)mat->fp);\n                fwrite(complex_data->Im, matvar->data_size, nelems, (FILE*)mat->fp);\n            }\n            else {\n                fwrite(matvar->data, matvar->data_size, nelems, (FILE*)mat->fp);\n            }\n            break;\n        case MAT_C_SPARSE:\n        {\n            mat_sparse_t* sparse;\n            double tmp;\n            int j;\n            size_t stride = Mat_SizeOf(matvar->data_type);\n#if !defined(EXTENDED_SPARSE)\n            if ( MAT_T_DOUBLE != matvar->data_type )\n                break;\n#endif\n\n            sparse = (mat_sparse_t*)matvar->data;\n            x.type += 2;\n            x.mrows = sparse->njc > 0 ? sparse->jc[sparse->njc - 1] + 1 : 1;\n            x.ncols = matvar->isComplex ? 4 : 3;\n            x.imagf = 0;\n\n            fwrite(&x, sizeof(Fmatrix), 1, (FILE*)mat->fp);\n            fwrite(matvar->name, sizeof(char), x.namelen, (FILE*)mat->fp);\n\n            for ( i = 0; i < sparse->njc - 1; i++ ) {\n                for ( j = sparse->jc[i];\n                      j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                    tmp = sparse->ir[j] + 1;\n                    fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n                }\n            }\n            tmp = (double)matvar->dims[0];\n            fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n            for ( i = 0; i < sparse->njc - 1; i++ ) {\n                for ( j = sparse->jc[i];\n                      j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                    tmp = i + 1;\n                    fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n                }\n            }\n            tmp = (double)matvar->dims[1];\n            fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);\n            tmp = 0.;\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data;\n                char* re, *im;\n\n                complex_data = (mat_complex_split_t*)sparse->data;\n                re = (char*)complex_data->Re;\n                im = (char*)complex_data->Im;\n                for ( i = 0; i < sparse->njc - 1; i++ ) {\n                    for ( j = sparse->jc[i];\n                          j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                        fwrite(re + j*stride, stride, 1, (FILE*)mat->fp);\n                    }\n                }\n                fwrite(&tmp, stride, 1, (FILE*)mat->fp);\n                for ( i = 0; i < sparse->njc - 1; i++ ) {\n                    for ( j = sparse->jc[i];\n                          j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                        fwrite(im + j*stride, stride, 1, (FILE*)mat->fp);\n                    }\n                }\n            } else {\n                char *data = (char*)sparse->data;\n                for ( i = 0; i < sparse->njc - 1; i++ ) {\n                    for ( j = sparse->jc[i];\n                          j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {\n                        fwrite(data + j*stride, stride, 1, (FILE*)mat->fp);\n                    }\n                }\n            }\n            fwrite(&tmp, stride, 1, (FILE*)mat->fp);\n            break;\n        }\n        default:\n            break;\n    }\n\n    return 0;\n}\n\n/** @if mat_devman\n * @brief Reads the data of a version 4 MAT file variable\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @param matvar MAT variable pointer to read the data\n * @endif\n */\nvoid\nMat_VarRead4(mat_t *mat,matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return;\n    }\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n    switch ( matvar->class_type ) {\n        case MAT_C_DOUBLE:\n            matvar->data_size = sizeof(double);\n            err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);\n            if ( err ) {\n                Mat_Critical(\"Integer multiplication overflow\");\n                return;\n            }\n\n            if ( matvar->isComplex ) {\n                mat_complex_split_t *complex_data = ComplexMalloc(matvar->nbytes);\n                if ( NULL != complex_data ) {\n                    matvar->data = complex_data;\n                    ReadDoubleData(mat, (double*)complex_data->Re, matvar->data_type, nelems);\n                    ReadDoubleData(mat, (double*)complex_data->Im, matvar->data_type, nelems);\n                }\n                else {\n                    Mat_Critical(\"Couldn't allocate memory for the complex data\");\n                }\n            } else {\n                matvar->data = malloc(matvar->nbytes);\n                if ( NULL != matvar->data ) {\n                    ReadDoubleData(mat, (double*)matvar->data, matvar->data_type, nelems);\n                }\n                else {\n                    Mat_Critical(\"Couldn't allocate memory for the data\");\n                }\n            }\n            /* Update data type to match format of matvar->data */\n            matvar->data_type = MAT_T_DOUBLE;\n            break;\n        case MAT_C_CHAR:\n            matvar->data_size = 1;\n            matvar->nbytes = nelems;\n            matvar->data = malloc(matvar->nbytes);\n            if ( NULL != matvar->data ) {\n                ReadUInt8Data(mat, (mat_uint8_t*)matvar->data, matvar->data_type, nelems);\n            }\n            else {\n                Mat_Critical(\"Couldn't allocate memory for the data\");\n            }\n            matvar->data_type = MAT_T_UINT8;\n            break;\n        case MAT_C_SPARSE:\n            matvar->data_size = sizeof(mat_sparse_t);\n            matvar->data      = malloc(matvar->data_size);\n            if ( NULL != matvar->data ) {\n                double tmp;\n                int i;\n                mat_sparse_t* sparse;\n                long fpos;\n                enum matio_types data_type = MAT_T_DOUBLE;\n\n                /* matvar->dims[1] either is 3 for real or 4 for complex sparse */\n                matvar->isComplex = matvar->dims[1] == 4 ? 1 : 0;\n                sparse = (mat_sparse_t*)matvar->data;\n                sparse->nir = matvar->dims[0] - 1;\n                sparse->nzmax = sparse->nir;\n                sparse->ir = (mat_int32_t*)malloc(sparse->nir*sizeof(mat_int32_t));\n                if ( sparse->ir != NULL ) {\n                    ReadInt32Data(mat, sparse->ir, data_type, sparse->nir);\n                    for ( i = 0; i < sparse->nir; i++ )\n                        sparse->ir[i] = sparse->ir[i] - 1;\n                } else {\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Couldn't allocate memory for the sparse row array\");\n                    return;\n                }\n                ReadDoubleData(mat, &tmp, data_type, 1);\n                matvar->dims[0] = (size_t)tmp;\n\n                fpos = ftell((FILE*)mat->fp);\n                if ( fpos == -1L ) {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Couldn't determine file position\");\n                    return;\n                }\n                (void)fseek((FILE*)mat->fp,sparse->nir*Mat_SizeOf(data_type),\n                    SEEK_CUR);\n                ReadDoubleData(mat, &tmp, data_type, 1);\n                if ( tmp > INT_MAX-1 || tmp < 0 ) {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Invalid column dimension for sparse matrix\");\n                    return;\n                }\n                matvar->dims[1] = (size_t)tmp;\n                (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);\n                if ( matvar->dims[1] > INT_MAX-1 ) {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Invalid column dimension for sparse matrix\");\n                    return;\n                }\n                sparse->njc = (int)matvar->dims[1] + 1;\n                sparse->jc = (mat_int32_t*)malloc(sparse->njc*sizeof(mat_int32_t));\n                if ( sparse->jc != NULL ) {\n                    mat_int32_t *jc;\n                    jc = (mat_int32_t*)malloc(sparse->nir*sizeof(mat_int32_t));\n                    if ( jc != NULL ) {\n                        int j = 0;\n                        sparse->jc[0] = 0;\n                        ReadInt32Data(mat, jc, data_type, sparse->nir);\n                        for ( i = 1; i < sparse->njc-1; i++ ) {\n                            while ( j < sparse->nir && jc[j] <= i )\n                                j++;\n                            sparse->jc[i] = j;\n                        }\n                        free(jc);\n                        /* terminating nnz */\n                        sparse->jc[sparse->njc-1] = sparse->nir;\n                    } else {\n                        free(sparse->jc);\n                        free(sparse->ir);\n                        free(matvar->data);\n                        matvar->data = NULL;\n                        Mat_Critical(\"Couldn't allocate memory for the sparse index array\");\n                        return;\n                    }\n                } else {\n                    free(sparse->ir);\n                    free(matvar->data);\n                    matvar->data = NULL;\n                    Mat_Critical(\"Couldn't allocate memory for the sparse index array\");\n                    return;\n                }\n                ReadDoubleData(mat, &tmp, data_type, 1);\n                sparse->ndata = sparse->nir;\n                data_type = matvar->data_type;\n                if ( matvar->isComplex ) {\n                    mat_complex_split_t *complex_data =\n                        ComplexMalloc(sparse->ndata*Mat_SizeOf(data_type));\n                    if ( NULL != complex_data ) {\n                        sparse->data = complex_data;\n#if defined(EXTENDED_SPARSE)\n                        switch ( data_type ) {\n                            case MAT_T_DOUBLE:\n                                ReadDoubleData(mat, (double*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadDoubleData(mat, &tmp, data_type, 1);\n                                ReadDoubleData(mat, (double*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadDoubleData(mat, &tmp, data_type, 1);\n                                break;\n                            case MAT_T_SINGLE:\n                            {\n                                float tmp2;\n                                ReadSingleData(mat, (float*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadSingleData(mat, &tmp2, data_type, 1);\n                                ReadSingleData(mat, (float*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadSingleData(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT32:\n                            {\n                                mat_int32_t tmp2;\n                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadInt32Data(mat, &tmp2, data_type, 1);\n                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadInt32Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT16:\n                            {\n                                mat_int16_t tmp2;\n                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadInt16Data(mat, &tmp2, data_type, 1);\n                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT16:\n                            {\n                                mat_uint16_t tmp2;\n                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadUInt16Data(mat, &tmp2, data_type, 1);\n                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadUInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT8:\n                            {\n                                mat_uint8_t tmp2;\n                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Re,\n                                    data_type, sparse->ndata);\n                                ReadUInt8Data(mat, &tmp2, data_type, 1);\n                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Im,\n                                    data_type, sparse->ndata);\n                                ReadUInt8Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            default:\n                                free(complex_data->Re);\n                                free(complex_data->Im);\n                                free(complex_data);\n                                free(sparse->jc);\n                                free(sparse->ir);\n                                free(matvar->data);\n                                matvar->data = NULL;\n                                Mat_Critical(\"Mat_VarRead4: %d is not a supported data type for \"\n                                    \"extended sparse\", data_type);\n                                return;\n                        }\n#else\n                        ReadDoubleData(mat, (double*)complex_data->Re,\n                            data_type, sparse->ndata);\n                        ReadDoubleData(mat, &tmp, data_type, 1);\n                        ReadDoubleData(mat, (double*)complex_data->Im,\n                            data_type, sparse->ndata);\n                        ReadDoubleData(mat, &tmp, data_type, 1);\n#endif\n                    }\n                    else {\n                        free(sparse->jc);\n                        free(sparse->ir);\n                        free(matvar->data);\n                        matvar->data = NULL;\n                        Mat_Critical(\"Couldn't allocate memory for the complex sparse data\");\n                        return;\n                    }\n                } else {\n                    sparse->data = malloc(sparse->ndata*Mat_SizeOf(data_type));\n                    if ( sparse->data != NULL ) {\n#if defined(EXTENDED_SPARSE)\n                        switch ( data_type ) {\n                            case MAT_T_DOUBLE:\n                                ReadDoubleData(mat, (double*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadDoubleData(mat, &tmp, data_type, 1);\n                                break;\n                            case MAT_T_SINGLE:\n                            {\n                                float tmp2;\n                                ReadSingleData(mat, (float*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadSingleData(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT32:\n                            {\n                                mat_int32_t tmp2;\n                                ReadInt32Data(mat, (mat_int32_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadInt32Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_INT16:\n                            {\n                                mat_int16_t tmp2;\n                                ReadInt16Data(mat, (mat_int16_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT16:\n                            {\n                                mat_uint16_t tmp2;\n                                ReadUInt16Data(mat, (mat_uint16_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadUInt16Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            case MAT_T_UINT8:\n                            {\n                                mat_uint8_t tmp2;\n                                ReadUInt8Data(mat, (mat_uint8_t*)sparse->data,\n                                    data_type, sparse->ndata);\n                                ReadUInt8Data(mat, &tmp2, data_type, 1);\n                                break;\n                            }\n                            default:\n                                free(sparse->data);\n                                free(sparse->jc);\n                                free(sparse->ir);\n                                free(matvar->data);\n                                matvar->data = NULL;\n                                Mat_Critical(\"Mat_VarRead4: %d is not a supported data type for \"\n                                    \"extended sparse\", data_type);\n                                return;\n                        }\n#else\n                        ReadDoubleData(mat, (double*)sparse->data, data_type, sparse->ndata);\n                        ReadDoubleData(mat, &tmp, data_type, 1);\n#endif\n                    } else {\n                        free(sparse->jc);\n                        free(sparse->ir);\n                        free(matvar->data);\n                        matvar->data = NULL;\n                        Mat_Critical(\"Couldn't allocate memory for the sparse data\");\n                        return;\n                    }\n                }\n                break;\n            }\n            else {\n                Mat_Critical(\"Couldn't allocate memory for the data\");\n                return;\n            }\n        default:\n            Mat_Critical(\"MAT V4 data type error\");\n            return;\n    }\n\n    return;\n}\n\n/** @if mat_devman\n * @brief Reads a slab of data from a version 4 MAT file for the @c matvar variable\n *\n * @ingroup mat_internal\n * @param mat Version 4 MAT file pointer\n * @param matvar pointer to the mat variable\n * @param data pointer to store the read data in (must be of size\n *             edge[0]*...edge[rank-1]*Mat_SizeOfClass(matvar->class_type))\n * @param start index to start reading data in each dimension\n * @param stride write data every @c stride elements in each dimension\n * @param edge number of elements to read in each dimension\n * @retval 0 on success\n * @endif\n */\nint\nMat_VarReadData4(mat_t *mat,matvar_t *matvar,void *data,\n      int *start,int *stride,int *edge)\n{\n    int err = 0;\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n    switch( matvar->data_type ) {\n        case MAT_T_DOUBLE:\n        case MAT_T_SINGLE:\n        case MAT_T_INT32:\n        case MAT_T_INT16:\n        case MAT_T_UINT16:\n        case MAT_T_UINT8:\n            break;\n        default:\n            return 1;\n    }\n\n    if ( matvar->rank == 2 ) {\n        if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > matvar->dims[0] )\n            err = 1;\n        else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > matvar->dims[1] )\n            err = 1;\n        if ( matvar->isComplex ) {\n            mat_complex_split_t *cdata = (mat_complex_split_t*)data;\n            size_t nbytes = Mat_SizeOf(matvar->data_type);\n            err = SafeMulDims(matvar, &nbytes);\n            if ( err ) {\n                Mat_Critical(\"Integer multiplication overflow\");\n                return err;\n            }\n\n            ReadDataSlab2(mat,cdata->Re,matvar->class_type,matvar->data_type,\n                matvar->dims,start,stride,edge);\n            (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);\n            ReadDataSlab2(mat,cdata->Im,matvar->class_type,\n                matvar->data_type,matvar->dims,start,stride,edge);\n        } else {\n            ReadDataSlab2(mat,data,matvar->class_type,matvar->data_type,\n                matvar->dims,start,stride,edge);\n        }\n    } else if ( matvar->isComplex ) {\n        mat_complex_split_t *cdata = (mat_complex_split_t*)data;\n        size_t nbytes = Mat_SizeOf(matvar->data_type);\n        err = SafeMulDims(matvar, &nbytes);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return err;\n        }\n\n        ReadDataSlabN(mat,cdata->Re,matvar->class_type,matvar->data_type,\n            matvar->rank,matvar->dims,start,stride,edge);\n        (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);\n        ReadDataSlabN(mat,cdata->Im,matvar->class_type,matvar->data_type,\n            matvar->rank,matvar->dims,start,stride,edge);\n    } else {\n        ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,\n            matvar->rank,matvar->dims,start,stride,edge);\n    }\n\n    return err;\n}\n\n/** @brief Reads a subset of a MAT variable using a 1-D indexing\n *\n * Reads data from a MAT variable using a linear (1-D) indexing mode. The\n * variable must have been read by Mat_VarReadInfo.\n * @ingroup MAT\n * @param mat MAT file to read data from\n * @param matvar MAT variable information\n * @param data pointer to store data in (must be pre-allocated)\n * @param start starting index\n * @param stride stride of data\n * @param edge number of elements to read\n * @retval 0 on success\n */\nint\nMat_VarReadDataLinear4(mat_t *mat,matvar_t *matvar,void *data,int start,\n                       int stride,int edge)\n{\n    int err;\n    size_t nelems = 1;\n\n    err = SafeMulDims(matvar, &nelems);\n    if ( err ) {\n        Mat_Critical(\"Integer multiplication overflow\");\n        return err;\n    }\n\n    (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);\n\n    matvar->data_size = Mat_SizeOf(matvar->data_type);\n\n    if ( (size_t)stride*(edge-1)+start+1 > nelems ) {\n        return 1;\n    }\n    if ( matvar->isComplex ) {\n        mat_complex_split_t *complex_data = (mat_complex_split_t*)data;\n        err = SafeMul(&nelems, nelems, matvar->data_size);\n        if ( err ) {\n            Mat_Critical(\"Integer multiplication overflow\");\n            return err;\n        }\n\n        ReadDataSlab1(mat,complex_data->Re,matvar->class_type,\n                      matvar->data_type,start,stride,edge);\n        (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nelems,SEEK_SET);\n        ReadDataSlab1(mat,complex_data->Im,matvar->class_type,\n                      matvar->data_type,start,stride,edge);\n    } else {\n        ReadDataSlab1(mat,data,matvar->class_type,matvar->data_type,start,\n                      stride,edge);\n    }\n\n    return err;\n}\n\n/** @if mat_devman\n * @brief Reads the header information for the next MAT variable in a version 4 MAT file\n *\n * @ingroup mat_internal\n * @param mat MAT file pointer\n * @return pointer to the MAT variable or NULL\n * @endif\n */\nmatvar_t *\nMat_VarReadNextInfo4(mat_t *mat)\n{\n    int       M,O,data_type,class_type;\n    mat_int32_t tmp;\n    long      nBytes;\n    size_t    readresult;\n    matvar_t *matvar = NULL;\n    union {\n        mat_uint32_t u;\n        mat_uint8_t  c[4];\n    } endian;\n\n    if ( mat == NULL || mat->fp == NULL )\n        return NULL;\n    else if ( NULL == (matvar = Mat_VarCalloc()) )\n        return NULL;\n\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n\n    endian.u = 0x01020304;\n\n    /* See if MOPT may need byteswapping */\n    if ( tmp < 0 || tmp > 4052 ) {\n        if ( Mat_int32Swap(&tmp) > 4052 ) {\n            Mat_VarFree(matvar);\n            return NULL;\n        }\n    }\n\n    M = (int)floor(tmp / 1000.0);\n    switch ( M ) {\n        case 0:\n            /* IEEE little endian */\n            mat->byteswap = endian.c[0] != 4;\n            break;\n        case 1:\n            /* IEEE big endian */\n            mat->byteswap = endian.c[0] != 1;\n            break;\n        default:\n            /* VAX, Cray, or bogus */\n            Mat_VarFree(matvar);\n            return NULL;\n    }\n\n    tmp -= M*1000;\n    O = (int)floor(tmp / 100.0);\n    /* O must be zero */\n    if ( 0 != O ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n\n    tmp -= O*100;\n    data_type = (int)floor(tmp / 10.0);\n    /* Convert the V4 data type */\n    switch ( data_type ) {\n        case 0:\n            matvar->data_type = MAT_T_DOUBLE;\n            break;\n        case 1:\n            matvar->data_type = MAT_T_SINGLE;\n            break;\n        case 2:\n            matvar->data_type = MAT_T_INT32;\n            break;\n        case 3:\n            matvar->data_type = MAT_T_INT16;\n            break;\n        case 4:\n            matvar->data_type = MAT_T_UINT16;\n            break;\n        case 5:\n            matvar->data_type = MAT_T_UINT8;\n            break;\n        default:\n            Mat_VarFree(matvar);\n            return NULL;\n    }\n\n    tmp -= data_type*10;\n    class_type = (int)floor(tmp / 1.0);\n    switch ( class_type ) {\n        case 0:\n            matvar->class_type = MAT_C_DOUBLE;\n            break;\n        case 1:\n            matvar->class_type = MAT_C_CHAR;\n            break;\n        case 2:\n            matvar->class_type = MAT_C_SPARSE;\n            break;\n        default:\n            Mat_VarFree(matvar);\n            return NULL;\n    }\n\n    matvar->rank = 2;\n    matvar->dims = (size_t*)calloc(2, sizeof(*matvar->dims));\n    if ( NULL == matvar->dims ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( mat->byteswap )\n        Mat_int32Swap(&tmp);\n    matvar->dims[0] = tmp;\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( mat->byteswap )\n        Mat_int32Swap(&tmp);\n    matvar->dims[1] = tmp;\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n\n    readresult = fread(&(matvar->isComplex),sizeof(int),1,(FILE*)mat->fp);\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    if ( matvar->isComplex && MAT_C_CHAR == matvar->class_type ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);\n    if ( 1 != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    if ( mat->byteswap )\n        Mat_int32Swap(&tmp);\n    /* Check that the length of the variable name is at least 1 */\n    if ( tmp < 1 ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    matvar->name = (char*)malloc(tmp);\n    if ( NULL == matvar->name ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    }\n    readresult = fread(matvar->name,1,tmp,(FILE*)mat->fp);\n    if ( tmp != readresult ) {\n        Mat_VarFree(matvar);\n        return NULL;\n    } else {\n        matvar->name[tmp - 1] = '\\0';\n    }\n\n    matvar->internal->datapos = ftell((FILE*)mat->fp);\n    if ( matvar->internal->datapos == -1L ) {\n        Mat_VarFree(matvar);\n        Mat_Critical(\"Couldn't determine file position\");\n        return NULL;\n    }\n    {\n        int err;\n        size_t tmp2 = Mat_SizeOf(matvar->data_type);\n        if ( matvar->isComplex )\n            tmp2 *= 2;\n        err = SafeMulDims(matvar, &tmp2);\n        if ( err ) {\n            Mat_VarFree(matvar);\n            Mat_Critical(\"Integer multiplication overflow\");\n            return NULL;\n        }\n\n        nBytes = (long)tmp2;\n    }\n    (void)fseek((FILE*)mat->fp,nBytes,SEEK_CUR);\n\n    return matvar;\n}\n"], "filenames": ["src/mat4.c"], "buggy_code_start_loc": [919], "buggy_code_end_loc": [919], "fixing_code_start_loc": [920], "fixing_code_end_loc": [922], "type": "CWE-125", "message": "Mat_VarReadNextInfo4 in mat4.c in MATIO 1.5.17 omits a certain '\\0' character, leading to a heap-based buffer over-read in strdup_vprintf when uninitialized memory is accessed.", "other": {"cve": {"id": "CVE-2019-17533", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-13T02:15:12.220", "lastModified": "2023-02-28T15:55:42.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mat_VarReadNextInfo4 in mat4.c in MATIO 1.5.17 omits a certain '\\0' character, leading to a heap-based buffer over-read in strdup_vprintf when uninitialized memory is accessed."}, {"lang": "es", "value": "La funci\u00f3n Mat_VarReadNextInfo4 en el archivo mat4.c en MATIO versi\u00f3n 1.5.17, omite cierto car\u00e1cter '\\0', lo que conlleva a una lectura excesiva de b\u00fafer en la regi\u00f3n heap de la memoria en strdup_vprintf cuando se accede a la memoria no inicializada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matio_project:matio:1.5.17:*:*:*:*:*:*:*", "matchCriteriaId": "BA202CA9-93FA-4D2E-8968-0A2748AC055D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16856", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/tbeu/matio/commit/651a8e28099edb5fbb9e4e1d4d3238848f446c9a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00037.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tbeu/matio/commit/651a8e28099edb5fbb9e4e1d4d3238848f446c9a"}}