{"buggy_code": ["package quic\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils/ringbuffer\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/quicvarint\"\n)\n\ntype framer interface {\n\tHasData() bool\n\n\tQueueControlFrame(wire.Frame)\n\tAppendControlFrames([]ackhandler.Frame, protocol.ByteCount, protocol.VersionNumber) ([]ackhandler.Frame, protocol.ByteCount)\n\n\tAddActiveStream(protocol.StreamID)\n\tAppendStreamFrames([]ackhandler.StreamFrame, protocol.ByteCount, protocol.VersionNumber) ([]ackhandler.StreamFrame, protocol.ByteCount)\n\n\tHandle0RTTRejection() error\n}\n\ntype framerI struct {\n\tmutex sync.Mutex\n\n\tstreamGetter streamGetter\n\n\tactiveStreams map[protocol.StreamID]struct{}\n\tstreamQueue   ringbuffer.RingBuffer[protocol.StreamID]\n\n\tcontrolFrameMutex sync.Mutex\n\tcontrolFrames     []wire.Frame\n}\n\nvar _ framer = &framerI{}\n\nfunc newFramer(streamGetter streamGetter) framer {\n\treturn &framerI{\n\t\tstreamGetter:  streamGetter,\n\t\tactiveStreams: make(map[protocol.StreamID]struct{}),\n\t}\n}\n\nfunc (f *framerI) HasData() bool {\n\tf.mutex.Lock()\n\thasData := !f.streamQueue.Empty()\n\tf.mutex.Unlock()\n\tif hasData {\n\t\treturn true\n\t}\n\tf.controlFrameMutex.Lock()\n\thasData = len(f.controlFrames) > 0\n\tf.controlFrameMutex.Unlock()\n\treturn hasData\n}\n\nfunc (f *framerI) QueueControlFrame(frame wire.Frame) {\n\tf.controlFrameMutex.Lock()\n\tf.controlFrames = append(f.controlFrames, frame)\n\tf.controlFrameMutex.Unlock()\n}\n\nfunc (f *framerI) AppendControlFrames(frames []ackhandler.Frame, maxLen protocol.ByteCount, v protocol.VersionNumber) ([]ackhandler.Frame, protocol.ByteCount) {\n\tvar length protocol.ByteCount\n\tf.controlFrameMutex.Lock()\n\tfor len(f.controlFrames) > 0 {\n\t\tframe := f.controlFrames[len(f.controlFrames)-1]\n\t\tframeLen := frame.Length(v)\n\t\tif length+frameLen > maxLen {\n\t\t\tbreak\n\t\t}\n\t\tframes = append(frames, ackhandler.Frame{Frame: frame})\n\t\tlength += frameLen\n\t\tf.controlFrames = f.controlFrames[:len(f.controlFrames)-1]\n\t}\n\tf.controlFrameMutex.Unlock()\n\treturn frames, length\n}\n\nfunc (f *framerI) AddActiveStream(id protocol.StreamID) {\n\tf.mutex.Lock()\n\tif _, ok := f.activeStreams[id]; !ok {\n\t\tf.streamQueue.PushBack(id)\n\t\tf.activeStreams[id] = struct{}{}\n\t}\n\tf.mutex.Unlock()\n}\n\nfunc (f *framerI) AppendStreamFrames(frames []ackhandler.StreamFrame, maxLen protocol.ByteCount, v protocol.VersionNumber) ([]ackhandler.StreamFrame, protocol.ByteCount) {\n\tstartLen := len(frames)\n\tvar length protocol.ByteCount\n\tf.mutex.Lock()\n\t// pop STREAM frames, until less than MinStreamFrameSize bytes are left in the packet\n\tnumActiveStreams := f.streamQueue.Len()\n\tfor i := 0; i < numActiveStreams; i++ {\n\t\tif protocol.MinStreamFrameSize+length > maxLen {\n\t\t\tbreak\n\t\t}\n\t\tid := f.streamQueue.PopFront()\n\t\t// This should never return an error. Better check it anyway.\n\t\t// The stream will only be in the streamQueue, if it enqueued itself there.\n\t\tstr, err := f.streamGetter.GetOrOpenSendStream(id)\n\t\t// The stream can be nil if it completed after it said it had data.\n\t\tif str == nil || err != nil {\n\t\t\tdelete(f.activeStreams, id)\n\t\t\tcontinue\n\t\t}\n\t\tremainingLen := maxLen - length\n\t\t// For the last STREAM frame, we'll remove the DataLen field later.\n\t\t// Therefore, we can pretend to have more bytes available when popping\n\t\t// the STREAM frame (which will always have the DataLen set).\n\t\tremainingLen += quicvarint.Len(uint64(remainingLen))\n\t\tframe, ok, hasMoreData := str.popStreamFrame(remainingLen, v)\n\t\tif hasMoreData { // put the stream back in the queue (at the end)\n\t\t\tf.streamQueue.PushBack(id)\n\t\t} else { // no more data to send. Stream is not active\n\t\t\tdelete(f.activeStreams, id)\n\t\t}\n\t\t// The frame can be \"nil\"\n\t\t// * if the receiveStream was canceled after it said it had data\n\t\t// * the remaining size doesn't allow us to add another STREAM frame\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tframes = append(frames, frame)\n\t\tlength += frame.Frame.Length(v)\n\t}\n\tf.mutex.Unlock()\n\tif len(frames) > startLen {\n\t\tl := frames[len(frames)-1].Frame.Length(v)\n\t\t// account for the smaller size of the last STREAM frame\n\t\tframes[len(frames)-1].Frame.DataLenPresent = false\n\t\tlength += frames[len(frames)-1].Frame.Length(v) - l\n\t}\n\treturn frames, length\n}\n\nfunc (f *framerI) Handle0RTTRejection() error {\n\tf.mutex.Lock()\n\tdefer f.mutex.Unlock()\n\n\tf.controlFrameMutex.Lock()\n\tf.streamQueue.Clear()\n\tfor id := range f.activeStreams {\n\t\tdelete(f.activeStreams, id)\n\t}\n\tvar j int\n\tfor i, frame := range f.controlFrames {\n\t\tswitch frame.(type) {\n\t\tcase *wire.MaxDataFrame, *wire.MaxStreamDataFrame, *wire.MaxStreamsFrame:\n\t\t\treturn errors.New(\"didn't expect MAX_DATA / MAX_STREAM_DATA / MAX_STREAMS frame to be sent in 0-RTT\")\n\t\tcase *wire.DataBlockedFrame, *wire.StreamDataBlockedFrame, *wire.StreamsBlockedFrame:\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tf.controlFrames[j] = f.controlFrames[i]\n\t\t\tj++\n\t\t}\n\t}\n\tf.controlFrames = f.controlFrames[:j]\n\tf.controlFrameMutex.Unlock()\n\treturn nil\n}\n", "package quic\n\nimport (\n\t\"bytes\"\n\t\"math/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/golang/mock/gomock\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Framer\", func() {\n\tconst (\n\t\tid1 = protocol.StreamID(10)\n\t\tid2 = protocol.StreamID(11)\n\t)\n\n\tvar (\n\t\tframer           framer\n\t\tstream1, stream2 *MockSendStreamI\n\t\tstreamGetter     *MockStreamGetter\n\t\tversion          protocol.VersionNumber\n\t)\n\n\tBeforeEach(func() {\n\t\tstreamGetter = NewMockStreamGetter(mockCtrl)\n\t\tstream1 = NewMockSendStreamI(mockCtrl)\n\t\tstream1.EXPECT().StreamID().Return(protocol.StreamID(5)).AnyTimes()\n\t\tstream2 = NewMockSendStreamI(mockCtrl)\n\t\tstream2.EXPECT().StreamID().Return(protocol.StreamID(6)).AnyTimes()\n\t\tframer = newFramer(streamGetter)\n\t})\n\n\tContext(\"handling control frames\", func() {\n\t\tIt(\"adds control frames\", func() {\n\t\t\tmdf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tmsf := &wire.MaxStreamsFrame{MaxStreamNum: 0x1337}\n\t\t\tframer.QueueControlFrame(mdf)\n\t\t\tframer.QueueControlFrame(msf)\n\t\t\tframes, length := framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tfs := []wire.Frame{frames[0].Frame, frames[1].Frame}\n\t\t\tExpect(fs).To(ContainElement(mdf))\n\t\t\tExpect(fs).To(ContainElement(msf))\n\t\t\tExpect(length).To(Equal(mdf.Length(version) + msf.Length(version)))\n\t\t})\n\n\t\tIt(\"says if it has data\", func() {\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tframer.QueueControlFrame(f)\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tframes, _ := framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"appends to the slice given\", func() {\n\t\t\tping := &wire.PingFrame{}\n\t\t\tmdf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tframer.QueueControlFrame(mdf)\n\t\t\tframes, length := framer.AppendControlFrames([]ackhandler.Frame{{Frame: ping}}, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tExpect(frames[0].Frame).To(Equal(ping))\n\t\t\tExpect(frames[1].Frame).To(Equal(mdf))\n\t\t\tExpect(length).To(Equal(mdf.Length(version)))\n\t\t})\n\n\t\tIt(\"adds the right number of frames\", func() {\n\t\t\tmaxSize := protocol.ByteCount(1000)\n\t\t\tbf := &wire.DataBlockedFrame{MaximumData: 0x1337}\n\t\t\tbfLen := bf.Length(version)\n\t\t\tnumFrames := int(maxSize / bfLen) // max number of frames that fit into maxSize\n\t\t\tfor i := 0; i < numFrames+1; i++ {\n\t\t\t\tframer.QueueControlFrame(bf)\n\t\t\t}\n\t\t\tframes, length := framer.AppendControlFrames(nil, maxSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(numFrames))\n\t\t\tExpect(length).To(BeNumerically(\">\", maxSize-bfLen))\n\t\t\tframes, length = framer.AppendControlFrames(nil, maxSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(length).To(Equal(bfLen))\n\t\t})\n\n\t\tIt(\"drops *_BLOCKED frames when 0-RTT is rejected\", func() {\n\t\t\tping := &wire.PingFrame{}\n\t\t\tncid := &wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber: 10,\n\t\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t}\n\t\t\tframes := []wire.Frame{\n\t\t\t\t&wire.DataBlockedFrame{MaximumData: 1337},\n\t\t\t\t&wire.StreamDataBlockedFrame{StreamID: 42, MaximumStreamData: 1337},\n\t\t\t\t&wire.StreamsBlockedFrame{StreamLimit: 13},\n\t\t\t\tping,\n\t\t\t\tncid,\n\t\t\t}\n\t\t\trand.Shuffle(len(frames), func(i, j int) { frames[i], frames[j] = frames[j], frames[i] })\n\t\t\tfor _, f := range frames {\n\t\t\t\tframer.QueueControlFrame(f)\n\t\t\t}\n\t\t\tExpect(framer.Handle0RTTRejection()).To(Succeed())\n\t\t\tfs, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(2))\n\t\t\tExpect(length).To(Equal(ping.Length(version) + ncid.Length(version)))\n\t\t})\n\t})\n\n\tContext(\"popping STREAM frames\", func() {\n\t\tIt(\"returns nil when popping an empty framer\", func() {\n\t\t\tExpect(framer.AppendStreamFrames(nil, 1000, protocol.Version1)).To(BeEmpty())\n\t\t})\n\n\t\tIt(\"returns STREAM frames\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id1,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tOffset:         42,\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tfs, length := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(1))\n\t\t\tExpect(fs[0].Frame.DataLenPresent).To(BeFalse())\n\t\t\tExpect(length).To(Equal(f.Length(version)))\n\t\t})\n\n\t\tIt(\"says if it has data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil).Times(2)\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tf1 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foo\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"bar\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, true)\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"appends to a frame slice\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id1,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tf0 := ackhandler.StreamFrame{Frame: &wire.StreamFrame{StreamID: 9999}}\n\t\t\tframes := []ackhandler.StreamFrame{f0}\n\t\t\tfs, length := framer.AppendStreamFrames(frames, 1000, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(2))\n\t\t\tExpect(fs[0]).To(Equal(f0))\n\t\t\tExpect(fs[1].Frame.Data).To(Equal([]byte(\"foobar\")))\n\t\t\tExpect(fs[1].Frame.DataLenPresent).To(BeFalse())\n\t\t\tExpect(length).To(Equal(f.Length(version)))\n\t\t})\n\n\t\tIt(\"skips a stream that was reported active, but was completed shortly after\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(nil, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id2,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f))\n\t\t})\n\n\t\tIt(\"skips a stream that was reported active, but doesn't have any data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id2,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{}, false, false)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f))\n\t\t})\n\n\t\tIt(\"pops from a stream multiple times, if it has enough data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil).Times(2)\n\t\t\tf1 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobar\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobaz\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, true)\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframer.AddActiveStream(id1) // only add it once\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\t// no further calls to popStreamFrame, after popStreamFrame said there's no more data\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(BeNil())\n\t\t})\n\n\t\tIt(\"re-queues a stream at the end, if it has enough data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil).Times(2)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf11 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobar\")}\n\t\t\tf12 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobaz\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id2, Data: []byte(\"raboof\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f11}, true, true)\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f12}, true, false)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframer.AddActiveStream(id1) // only add it once\n\t\t\tframer.AddActiveStream(id2)\n\t\t\t// first a frame from stream 1\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f11))\n\t\t\t// then a frame from stream 2\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\t// then another frame from stream 1\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f12))\n\t\t})\n\n\t\tIt(\"only dequeues data from each stream once per packet\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf1 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobar\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id2, Data: []byte(\"raboof\")}\n\t\t\t// both streams have more data, and will be re-queued\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, true)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, true)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframes, length := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n\t\t\tExpect(frames[1].Frame).To(Equal(f2))\n\t\t\tExpect(length).To(Equal(f1.Length(version) + f2.Length(version)))\n\t\t})\n\n\t\tIt(\"returns multiple normal frames in the order they were reported active\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf1 := &wire.StreamFrame{Data: []byte(\"foobar\")}\n\t\t\tf2 := &wire.StreamFrame{Data: []byte(\"foobaz\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, false)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\tExpect(frames[1].Frame).To(Equal(f1))\n\t\t})\n\n\t\tIt(\"only asks a stream for data once, even if it was reported active multiple times\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{Data: []byte(\"foobar\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false) // only one call to this function\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t})\n\n\t\tIt(\"does not pop empty frames\", func() {\n\t\t\tfs, length := framer.AppendStreamFrames(nil, 500, protocol.Version1)\n\t\t\tExpect(fs).To(BeEmpty())\n\t\t\tExpect(length).To(BeZero())\n\t\t})\n\n\t\tIt(\"pops maximum size STREAM frames\", func() {\n\t\t\tfor i := protocol.MinStreamFrameSize; i < 2000; i++ {\n\t\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(func(size protocol.ByteCount, v protocol.VersionNumber) (ackhandler.StreamFrame, bool, bool) {\n\t\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\t\tStreamID:       id1,\n\t\t\t\t\t\tDataLenPresent: true,\n\t\t\t\t\t}\n\t\t\t\t\tf.Data = make([]byte, f.MaxDataLen(size, v))\n\t\t\t\t\tExpect(f.Length(version)).To(Equal(size))\n\t\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, true, false\n\t\t\t\t})\n\t\t\t\tframer.AddActiveStream(id1)\n\t\t\t\tframes, _ := framer.AppendStreamFrames(nil, i, protocol.Version1)\n\t\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\t\tf := frames[0].Frame\n\t\t\t\tExpect(f.DataLenPresent).To(BeFalse())\n\t\t\t\tExpect(f.Length(version)).To(Equal(i))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"pops multiple STREAM frames\", func() {\n\t\t\tfor i := 2 * protocol.MinStreamFrameSize; i < 2000; i++ {\n\t\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(func(size protocol.ByteCount, v protocol.VersionNumber) (ackhandler.StreamFrame, bool, bool) {\n\t\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\t\tStreamID:       id2,\n\t\t\t\t\t\tDataLenPresent: true,\n\t\t\t\t\t}\n\t\t\t\t\tf.Data = make([]byte, f.MaxDataLen(protocol.MinStreamFrameSize, v))\n\t\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, true, false\n\t\t\t\t})\n\t\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(func(size protocol.ByteCount, v protocol.VersionNumber) (ackhandler.StreamFrame, bool, bool) {\n\t\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\t\tStreamID:       id2,\n\t\t\t\t\t\tDataLenPresent: true,\n\t\t\t\t\t}\n\t\t\t\t\tf.Data = make([]byte, f.MaxDataLen(size, v))\n\t\t\t\t\tExpect(f.Length(version)).To(Equal(size))\n\t\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, true, false\n\t\t\t\t})\n\t\t\t\tframer.AddActiveStream(id1)\n\t\t\t\tframer.AddActiveStream(id2)\n\t\t\t\tframes, _ := framer.AppendStreamFrames(nil, i, protocol.Version1)\n\t\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\t\tf1 := frames[0].Frame\n\t\t\t\tf2 := frames[1].Frame\n\t\t\t\tExpect(f1.DataLenPresent).To(BeTrue())\n\t\t\t\tExpect(f2.DataLenPresent).To(BeFalse())\n\t\t\t\tExpect(f1.Length(version) + f2.Length(version)).To(Equal(i))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"pops frames that when asked for the the minimum STREAM frame size\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{Data: []byte(\"foobar\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t})\n\n\t\tIt(\"does not pop frames smaller than the minimum size\", func() {\n\t\t\t// don't expect a call to PopStreamFrame()\n\t\t\tframer.AppendStreamFrames(nil, protocol.MinStreamFrameSize-1, protocol.Version1)\n\t\t})\n\n\t\tIt(\"stops iterating when the remaining size is smaller than the minimum STREAM frame size\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\t// pop a frame such that the remaining size is one byte less than the minimum STREAM frame size\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id1,\n\t\t\t\tData:           bytes.Repeat([]byte(\"f\"), int(500-protocol.MinStreamFrameSize)),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tfs, length := framer.AppendStreamFrames(nil, 500, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(1))\n\t\t\tExpect(fs[0].Frame).To(Equal(f))\n\t\t\tExpect(length).To(Equal(f.Length(version)))\n\t\t})\n\n\t\tIt(\"drops all STREAM frames when 0-RTT is rejected\", func() {\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tExpect(framer.Handle0RTTRejection()).To(Succeed())\n\t\t\tfs, length := framer.AppendStreamFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(fs).To(BeEmpty())\n\t\t\tExpect(length).To(BeZero())\n\t\t})\n\t})\n})\n"], "fixing_code": ["package quic\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils/ringbuffer\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/quicvarint\"\n)\n\ntype framer interface {\n\tHasData() bool\n\n\tQueueControlFrame(wire.Frame)\n\tAppendControlFrames([]ackhandler.Frame, protocol.ByteCount, protocol.VersionNumber) ([]ackhandler.Frame, protocol.ByteCount)\n\n\tAddActiveStream(protocol.StreamID)\n\tAppendStreamFrames([]ackhandler.StreamFrame, protocol.ByteCount, protocol.VersionNumber) ([]ackhandler.StreamFrame, protocol.ByteCount)\n\n\tHandle0RTTRejection() error\n}\n\nconst maxPathResponses = 256\n\ntype framerI struct {\n\tmutex sync.Mutex\n\n\tstreamGetter streamGetter\n\n\tactiveStreams map[protocol.StreamID]struct{}\n\tstreamQueue   ringbuffer.RingBuffer[protocol.StreamID]\n\n\tcontrolFrameMutex sync.Mutex\n\tcontrolFrames     []wire.Frame\n\tpathResponses     []*wire.PathResponseFrame\n}\n\nvar _ framer = &framerI{}\n\nfunc newFramer(streamGetter streamGetter) framer {\n\treturn &framerI{\n\t\tstreamGetter:  streamGetter,\n\t\tactiveStreams: make(map[protocol.StreamID]struct{}),\n\t}\n}\n\nfunc (f *framerI) HasData() bool {\n\tf.mutex.Lock()\n\thasData := !f.streamQueue.Empty()\n\tf.mutex.Unlock()\n\tif hasData {\n\t\treturn true\n\t}\n\tf.controlFrameMutex.Lock()\n\tdefer f.controlFrameMutex.Unlock()\n\treturn len(f.controlFrames) > 0 || len(f.pathResponses) > 0\n}\n\nfunc (f *framerI) QueueControlFrame(frame wire.Frame) {\n\tf.controlFrameMutex.Lock()\n\tdefer f.controlFrameMutex.Unlock()\n\n\tif pr, ok := frame.(*wire.PathResponseFrame); ok {\n\t\t// Only queue up to maxPathResponses PATH_RESPONSE frames.\n\t\t// This limit should be high enough to never be hit in practice,\n\t\t// unless the peer is doing something malicious.\n\t\tif len(f.pathResponses) >= maxPathResponses {\n\t\t\treturn\n\t\t}\n\t\tf.pathResponses = append(f.pathResponses, pr)\n\t\treturn\n\t}\n\tf.controlFrames = append(f.controlFrames, frame)\n}\n\nfunc (f *framerI) AppendControlFrames(frames []ackhandler.Frame, maxLen protocol.ByteCount, v protocol.VersionNumber) ([]ackhandler.Frame, protocol.ByteCount) {\n\tf.controlFrameMutex.Lock()\n\tdefer f.controlFrameMutex.Unlock()\n\n\tvar length protocol.ByteCount\n\t// add a PATH_RESPONSE first, but only pack a single PATH_RESPONSE per packet\n\tif len(f.pathResponses) > 0 {\n\t\tframe := f.pathResponses[0]\n\t\tframeLen := frame.Length(v)\n\t\tif frameLen <= maxLen {\n\t\t\tframes = append(frames, ackhandler.Frame{Frame: frame})\n\t\t\tlength += frameLen\n\t\t\tf.pathResponses = f.pathResponses[1:]\n\t\t}\n\t}\n\n\tfor len(f.controlFrames) > 0 {\n\t\tframe := f.controlFrames[len(f.controlFrames)-1]\n\t\tframeLen := frame.Length(v)\n\t\tif length+frameLen > maxLen {\n\t\t\tbreak\n\t\t}\n\t\tframes = append(frames, ackhandler.Frame{Frame: frame})\n\t\tlength += frameLen\n\t\tf.controlFrames = f.controlFrames[:len(f.controlFrames)-1]\n\t}\n\treturn frames, length\n}\n\nfunc (f *framerI) AddActiveStream(id protocol.StreamID) {\n\tf.mutex.Lock()\n\tif _, ok := f.activeStreams[id]; !ok {\n\t\tf.streamQueue.PushBack(id)\n\t\tf.activeStreams[id] = struct{}{}\n\t}\n\tf.mutex.Unlock()\n}\n\nfunc (f *framerI) AppendStreamFrames(frames []ackhandler.StreamFrame, maxLen protocol.ByteCount, v protocol.VersionNumber) ([]ackhandler.StreamFrame, protocol.ByteCount) {\n\tstartLen := len(frames)\n\tvar length protocol.ByteCount\n\tf.mutex.Lock()\n\t// pop STREAM frames, until less than MinStreamFrameSize bytes are left in the packet\n\tnumActiveStreams := f.streamQueue.Len()\n\tfor i := 0; i < numActiveStreams; i++ {\n\t\tif protocol.MinStreamFrameSize+length > maxLen {\n\t\t\tbreak\n\t\t}\n\t\tid := f.streamQueue.PopFront()\n\t\t// This should never return an error. Better check it anyway.\n\t\t// The stream will only be in the streamQueue, if it enqueued itself there.\n\t\tstr, err := f.streamGetter.GetOrOpenSendStream(id)\n\t\t// The stream can be nil if it completed after it said it had data.\n\t\tif str == nil || err != nil {\n\t\t\tdelete(f.activeStreams, id)\n\t\t\tcontinue\n\t\t}\n\t\tremainingLen := maxLen - length\n\t\t// For the last STREAM frame, we'll remove the DataLen field later.\n\t\t// Therefore, we can pretend to have more bytes available when popping\n\t\t// the STREAM frame (which will always have the DataLen set).\n\t\tremainingLen += quicvarint.Len(uint64(remainingLen))\n\t\tframe, ok, hasMoreData := str.popStreamFrame(remainingLen, v)\n\t\tif hasMoreData { // put the stream back in the queue (at the end)\n\t\t\tf.streamQueue.PushBack(id)\n\t\t} else { // no more data to send. Stream is not active\n\t\t\tdelete(f.activeStreams, id)\n\t\t}\n\t\t// The frame can be \"nil\"\n\t\t// * if the receiveStream was canceled after it said it had data\n\t\t// * the remaining size doesn't allow us to add another STREAM frame\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tframes = append(frames, frame)\n\t\tlength += frame.Frame.Length(v)\n\t}\n\tf.mutex.Unlock()\n\tif len(frames) > startLen {\n\t\tl := frames[len(frames)-1].Frame.Length(v)\n\t\t// account for the smaller size of the last STREAM frame\n\t\tframes[len(frames)-1].Frame.DataLenPresent = false\n\t\tlength += frames[len(frames)-1].Frame.Length(v) - l\n\t}\n\treturn frames, length\n}\n\nfunc (f *framerI) Handle0RTTRejection() error {\n\tf.mutex.Lock()\n\tdefer f.mutex.Unlock()\n\n\tf.controlFrameMutex.Lock()\n\tf.streamQueue.Clear()\n\tfor id := range f.activeStreams {\n\t\tdelete(f.activeStreams, id)\n\t}\n\tvar j int\n\tfor i, frame := range f.controlFrames {\n\t\tswitch frame.(type) {\n\t\tcase *wire.MaxDataFrame, *wire.MaxStreamDataFrame, *wire.MaxStreamsFrame:\n\t\t\treturn errors.New(\"didn't expect MAX_DATA / MAX_STREAM_DATA / MAX_STREAMS frame to be sent in 0-RTT\")\n\t\tcase *wire.DataBlockedFrame, *wire.StreamDataBlockedFrame, *wire.StreamsBlockedFrame:\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tf.controlFrames[j] = f.controlFrames[i]\n\t\t\tj++\n\t\t}\n\t}\n\tf.controlFrames = f.controlFrames[:j]\n\tf.controlFrameMutex.Unlock()\n\treturn nil\n}\n", "package quic\n\nimport (\n\t\"bytes\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/golang/mock/gomock\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Framer\", func() {\n\tconst (\n\t\tid1 = protocol.StreamID(10)\n\t\tid2 = protocol.StreamID(11)\n\t)\n\n\tvar (\n\t\tframer           framer\n\t\tstream1, stream2 *MockSendStreamI\n\t\tstreamGetter     *MockStreamGetter\n\t\tversion          protocol.VersionNumber\n\t)\n\n\tBeforeEach(func() {\n\t\tstreamGetter = NewMockStreamGetter(mockCtrl)\n\t\tstream1 = NewMockSendStreamI(mockCtrl)\n\t\tstream1.EXPECT().StreamID().Return(protocol.StreamID(5)).AnyTimes()\n\t\tstream2 = NewMockSendStreamI(mockCtrl)\n\t\tstream2.EXPECT().StreamID().Return(protocol.StreamID(6)).AnyTimes()\n\t\tframer = newFramer(streamGetter)\n\t})\n\n\tContext(\"handling control frames\", func() {\n\t\tIt(\"adds control frames\", func() {\n\t\t\tmdf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tmsf := &wire.MaxStreamsFrame{MaxStreamNum: 0x1337}\n\t\t\tframer.QueueControlFrame(mdf)\n\t\t\tframer.QueueControlFrame(msf)\n\t\t\tframes, length := framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tfs := []wire.Frame{frames[0].Frame, frames[1].Frame}\n\t\t\tExpect(fs).To(ContainElement(mdf))\n\t\t\tExpect(fs).To(ContainElement(msf))\n\t\t\tExpect(length).To(Equal(mdf.Length(version) + msf.Length(version)))\n\t\t})\n\n\t\tIt(\"says if it has data\", func() {\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tframer.QueueControlFrame(f)\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tframes, _ := framer.AppendControlFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"appends to the slice given\", func() {\n\t\t\tping := &wire.PingFrame{}\n\t\t\tmdf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tframer.QueueControlFrame(mdf)\n\t\t\tframes, length := framer.AppendControlFrames([]ackhandler.Frame{{Frame: ping}}, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tExpect(frames[0].Frame).To(Equal(ping))\n\t\t\tExpect(frames[1].Frame).To(Equal(mdf))\n\t\t\tExpect(length).To(Equal(mdf.Length(version)))\n\t\t})\n\n\t\tIt(\"adds the right number of frames\", func() {\n\t\t\tmaxSize := protocol.ByteCount(1000)\n\t\t\tbf := &wire.DataBlockedFrame{MaximumData: 0x1337}\n\t\t\tbfLen := bf.Length(version)\n\t\t\tnumFrames := int(maxSize / bfLen) // max number of frames that fit into maxSize\n\t\t\tfor i := 0; i < numFrames+1; i++ {\n\t\t\t\tframer.QueueControlFrame(bf)\n\t\t\t}\n\t\t\tframes, length := framer.AppendControlFrames(nil, maxSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(numFrames))\n\t\t\tExpect(length).To(BeNumerically(\">\", maxSize-bfLen))\n\t\t\tframes, length = framer.AppendControlFrames(nil, maxSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(length).To(Equal(bfLen))\n\t\t})\n\n\t\tIt(\"drops *_BLOCKED frames when 0-RTT is rejected\", func() {\n\t\t\tping := &wire.PingFrame{}\n\t\t\tncid := &wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber: 10,\n\t\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\t}\n\t\t\tframes := []wire.Frame{\n\t\t\t\t&wire.DataBlockedFrame{MaximumData: 1337},\n\t\t\t\t&wire.StreamDataBlockedFrame{StreamID: 42, MaximumStreamData: 1337},\n\t\t\t\t&wire.StreamsBlockedFrame{StreamLimit: 13},\n\t\t\t\tping,\n\t\t\t\tncid,\n\t\t\t}\n\t\t\trand.Shuffle(len(frames), func(i, j int) { frames[i], frames[j] = frames[j], frames[i] })\n\t\t\tfor _, f := range frames {\n\t\t\t\tframer.QueueControlFrame(f)\n\t\t\t}\n\t\t\tExpect(framer.Handle0RTTRejection()).To(Succeed())\n\t\t\tfs, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(2))\n\t\t\tExpect(length).To(Equal(ping.Length(version) + ncid.Length(version)))\n\t\t})\n\t})\n\n\tContext(\"handling PATH_RESPONSE frames\", func() {\n\t\tIt(\"packs a single PATH_RESPONSE per packet\", func() {\n\t\t\tf1 := &wire.PathResponseFrame{Data: [8]byte{1, 2, 3, 4, 5, 6, 7, 8}}\n\t\t\tf2 := &wire.PathResponseFrame{Data: [8]byte{2, 3, 4, 5, 6, 7, 8, 9}}\n\t\t\tcf1 := &wire.DataBlockedFrame{MaximumData: 1337}\n\t\t\tcf2 := &wire.HandshakeDoneFrame{}\n\t\t\tframer.QueueControlFrame(f1)\n\t\t\tframer.QueueControlFrame(f2)\n\t\t\tframer.QueueControlFrame(cf1)\n\t\t\tframer.QueueControlFrame(cf2)\n\t\t\t// the first packet should contain a single PATH_RESPONSE frame, but all the other control frames\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tframes, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(3))\n\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n\t\t\tExpect([]wire.Frame{frames[1].Frame, frames[2].Frame}).To(ContainElement(cf1))\n\t\t\tExpect([]wire.Frame{frames[1].Frame, frames[2].Frame}).To(ContainElement(cf2))\n\t\t\tExpect(length).To(Equal(f1.Length(protocol.Version1) + cf1.Length(protocol.Version1) + cf2.Length(protocol.Version1)))\n\t\t\t// the second packet should contain the other PATH_RESPONSE frame\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tframes, length = framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\tExpect(length).To(Equal(f2.Length(protocol.Version1)))\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"limits the number of queued PATH_RESPONSE frames\", func() {\n\t\t\tvar pathResponses []*wire.PathResponseFrame\n\t\t\tfor i := 0; i < 2*maxPathResponses; i++ {\n\t\t\t\tvar f wire.PathResponseFrame\n\t\t\t\trand.Read(f.Data[:])\n\t\t\t\tpathResponses = append(pathResponses, &f)\n\t\t\t\tframer.QueueControlFrame(&f)\n\t\t\t}\n\t\t\tfor i := 0; i < maxPathResponses; i++ {\n\t\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\t\tframes, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\t\tExpect(frames[0].Frame).To(Equal(pathResponses[i]))\n\t\t\t\tExpect(length).To(Equal(pathResponses[i].Length(protocol.Version1)))\n\t\t\t}\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t\tframes, length := framer.AppendControlFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(frames).To(BeEmpty())\n\t\t\tExpect(length).To(BeZero())\n\t\t})\n\t})\n\n\tContext(\"popping STREAM frames\", func() {\n\t\tIt(\"returns nil when popping an empty framer\", func() {\n\t\t\tExpect(framer.AppendStreamFrames(nil, 1000, protocol.Version1)).To(BeEmpty())\n\t\t})\n\n\t\tIt(\"returns STREAM frames\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id1,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tOffset:         42,\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tfs, length := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(1))\n\t\t\tExpect(fs[0].Frame.DataLenPresent).To(BeFalse())\n\t\t\tExpect(length).To(Equal(f.Length(version)))\n\t\t})\n\n\t\tIt(\"says if it has data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil).Times(2)\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tf1 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foo\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"bar\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, true)\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n\t\t\tExpect(framer.HasData()).To(BeTrue())\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\tExpect(framer.HasData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"appends to a frame slice\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id1,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tf0 := ackhandler.StreamFrame{Frame: &wire.StreamFrame{StreamID: 9999}}\n\t\t\tframes := []ackhandler.StreamFrame{f0}\n\t\t\tfs, length := framer.AppendStreamFrames(frames, 1000, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(2))\n\t\t\tExpect(fs[0]).To(Equal(f0))\n\t\t\tExpect(fs[1].Frame.Data).To(Equal([]byte(\"foobar\")))\n\t\t\tExpect(fs[1].Frame.DataLenPresent).To(BeFalse())\n\t\t\tExpect(length).To(Equal(f.Length(version)))\n\t\t})\n\n\t\tIt(\"skips a stream that was reported active, but was completed shortly after\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(nil, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id2,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f))\n\t\t})\n\n\t\tIt(\"skips a stream that was reported active, but doesn't have any data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id2,\n\t\t\t\tData:           []byte(\"foobar\"),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{}, false, false)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f))\n\t\t})\n\n\t\tIt(\"pops from a stream multiple times, if it has enough data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil).Times(2)\n\t\t\tf1 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobar\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobaz\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, true)\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframer.AddActiveStream(id1) // only add it once\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\t// no further calls to popStreamFrame, after popStreamFrame said there's no more data\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(BeNil())\n\t\t})\n\n\t\tIt(\"re-queues a stream at the end, if it has enough data\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil).Times(2)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf11 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobar\")}\n\t\t\tf12 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobaz\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id2, Data: []byte(\"raboof\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f11}, true, true)\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f12}, true, false)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframer.AddActiveStream(id1) // only add it once\n\t\t\tframer.AddActiveStream(id2)\n\t\t\t// first a frame from stream 1\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f11))\n\t\t\t// then a frame from stream 2\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\t// then another frame from stream 1\n\t\t\tframes, _ = framer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\tExpect(frames[0].Frame).To(Equal(f12))\n\t\t})\n\n\t\tIt(\"only dequeues data from each stream once per packet\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf1 := &wire.StreamFrame{StreamID: id1, Data: []byte(\"foobar\")}\n\t\t\tf2 := &wire.StreamFrame{StreamID: id2, Data: []byte(\"raboof\")}\n\t\t\t// both streams have more data, and will be re-queued\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, true)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, true)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframes, length := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tExpect(frames[0].Frame).To(Equal(f1))\n\t\t\tExpect(frames[1].Frame).To(Equal(f2))\n\t\t\tExpect(length).To(Equal(f1.Length(version) + f2.Length(version)))\n\t\t})\n\n\t\tIt(\"returns multiple normal frames in the order they were reported active\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\tf1 := &wire.StreamFrame{Data: []byte(\"foobar\")}\n\t\t\tf2 := &wire.StreamFrame{Data: []byte(\"foobaz\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, true, false)\n\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, true, false)\n\t\t\tframer.AddActiveStream(id2)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\tExpect(frames[0].Frame).To(Equal(f2))\n\t\t\tExpect(frames[1].Frame).To(Equal(f1))\n\t\t})\n\n\t\tIt(\"only asks a stream for data once, even if it was reported active multiple times\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{Data: []byte(\"foobar\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false) // only one call to this function\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframes, _ := framer.AppendStreamFrames(nil, 1000, protocol.Version1)\n\t\t\tExpect(frames).To(HaveLen(1))\n\t\t})\n\n\t\tIt(\"does not pop empty frames\", func() {\n\t\t\tfs, length := framer.AppendStreamFrames(nil, 500, protocol.Version1)\n\t\t\tExpect(fs).To(BeEmpty())\n\t\t\tExpect(length).To(BeZero())\n\t\t})\n\n\t\tIt(\"pops maximum size STREAM frames\", func() {\n\t\t\tfor i := protocol.MinStreamFrameSize; i < 2000; i++ {\n\t\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(func(size protocol.ByteCount, v protocol.VersionNumber) (ackhandler.StreamFrame, bool, bool) {\n\t\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\t\tStreamID:       id1,\n\t\t\t\t\t\tDataLenPresent: true,\n\t\t\t\t\t}\n\t\t\t\t\tf.Data = make([]byte, f.MaxDataLen(size, v))\n\t\t\t\t\tExpect(f.Length(version)).To(Equal(size))\n\t\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, true, false\n\t\t\t\t})\n\t\t\t\tframer.AddActiveStream(id1)\n\t\t\t\tframes, _ := framer.AppendStreamFrames(nil, i, protocol.Version1)\n\t\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\t\tf := frames[0].Frame\n\t\t\t\tExpect(f.DataLenPresent).To(BeFalse())\n\t\t\t\tExpect(f.Length(version)).To(Equal(i))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"pops multiple STREAM frames\", func() {\n\t\t\tfor i := 2 * protocol.MinStreamFrameSize; i < 2000; i++ {\n\t\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id2).Return(stream2, nil)\n\t\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(func(size protocol.ByteCount, v protocol.VersionNumber) (ackhandler.StreamFrame, bool, bool) {\n\t\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\t\tStreamID:       id2,\n\t\t\t\t\t\tDataLenPresent: true,\n\t\t\t\t\t}\n\t\t\t\t\tf.Data = make([]byte, f.MaxDataLen(protocol.MinStreamFrameSize, v))\n\t\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, true, false\n\t\t\t\t})\n\t\t\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(func(size protocol.ByteCount, v protocol.VersionNumber) (ackhandler.StreamFrame, bool, bool) {\n\t\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\t\tStreamID:       id2,\n\t\t\t\t\t\tDataLenPresent: true,\n\t\t\t\t\t}\n\t\t\t\t\tf.Data = make([]byte, f.MaxDataLen(size, v))\n\t\t\t\t\tExpect(f.Length(version)).To(Equal(size))\n\t\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, true, false\n\t\t\t\t})\n\t\t\t\tframer.AddActiveStream(id1)\n\t\t\t\tframer.AddActiveStream(id2)\n\t\t\t\tframes, _ := framer.AppendStreamFrames(nil, i, protocol.Version1)\n\t\t\t\tExpect(frames).To(HaveLen(2))\n\t\t\t\tf1 := frames[0].Frame\n\t\t\t\tf2 := frames[1].Frame\n\t\t\t\tExpect(f1.DataLenPresent).To(BeTrue())\n\t\t\t\tExpect(f2.DataLenPresent).To(BeFalse())\n\t\t\t\tExpect(f1.Length(version) + f2.Length(version)).To(Equal(i))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"pops frames that when asked for the the minimum STREAM frame size\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\tf := &wire.StreamFrame{Data: []byte(\"foobar\")}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tframer.AppendStreamFrames(nil, protocol.MinStreamFrameSize, protocol.Version1)\n\t\t})\n\n\t\tIt(\"does not pop frames smaller than the minimum size\", func() {\n\t\t\t// don't expect a call to PopStreamFrame()\n\t\t\tframer.AppendStreamFrames(nil, protocol.MinStreamFrameSize-1, protocol.Version1)\n\t\t})\n\n\t\tIt(\"stops iterating when the remaining size is smaller than the minimum STREAM frame size\", func() {\n\t\t\tstreamGetter.EXPECT().GetOrOpenSendStream(id1).Return(stream1, nil)\n\t\t\t// pop a frame such that the remaining size is one byte less than the minimum STREAM frame size\n\t\t\tf := &wire.StreamFrame{\n\t\t\t\tStreamID:       id1,\n\t\t\t\tData:           bytes.Repeat([]byte(\"f\"), int(500-protocol.MinStreamFrameSize)),\n\t\t\t\tDataLenPresent: true,\n\t\t\t}\n\t\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, true, false)\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tfs, length := framer.AppendStreamFrames(nil, 500, protocol.Version1)\n\t\t\tExpect(fs).To(HaveLen(1))\n\t\t\tExpect(fs[0].Frame).To(Equal(f))\n\t\t\tExpect(length).To(Equal(f.Length(version)))\n\t\t})\n\n\t\tIt(\"drops all STREAM frames when 0-RTT is rejected\", func() {\n\t\t\tframer.AddActiveStream(id1)\n\t\t\tExpect(framer.Handle0RTTRejection()).To(Succeed())\n\t\t\tfs, length := framer.AppendStreamFrames(nil, protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(fs).To(BeEmpty())\n\t\t\tExpect(length).To(BeZero())\n\t\t})\n\t})\n})\n"], "filenames": ["framer.go", "framer_test.go"], "buggy_code_start_loc": [25, 5], "buggy_code_end_loc": [80, 110], "fixing_code_start_loc": [26, 5], "fixing_code_end_loc": [104, 161], "type": "CWE-400", "message": "quic-go is an implementation of the QUIC protocol (RFC 9000, RFC 9001, RFC 9002) in Go. An attacker can cause its peer to run out of memory sending a large number of PATH_CHALLENGE frames. The receiver is supposed to respond to each PATH_CHALLENGE frame with a PATH_RESPONSE frame. The attacker can prevent the receiver from sending out (the vast majority of) these PATH_RESPONSE frames by collapsing the peers congestion window (by selectively acknowledging received packets) and by manipulating the peer's RTT estimate. This vulnerability has been patched in versions 0.37.7, 0.38.2 and 0.39.4.", "other": {"cve": {"id": "CVE-2023-49295", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-10T22:15:50.610", "lastModified": "2024-02-21T03:15:08.410", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "quic-go is an implementation of the QUIC protocol (RFC 9000, RFC 9001, RFC 9002) in Go. An attacker can cause its peer to run out of memory sending a large number of PATH_CHALLENGE frames. The receiver is supposed to respond to each PATH_CHALLENGE frame with a PATH_RESPONSE frame. The attacker can prevent the receiver from sending out (the vast majority of) these PATH_RESPONSE frames by collapsing the peers congestion window (by selectively acknowledging received packets) and by manipulating the peer's RTT estimate. This vulnerability has been patched in versions 0.37.7, 0.38.2 and 0.39.4."}, {"lang": "es", "value": "quic-go es una implementaci\u00f3n del protocolo QUIC (RFC 9000, RFC 9001, RFC 9002) en Go. Un atacante puede hacer que su par se quede sin memoria enviando una gran cantidad de tramas PATH_CHALLENGE. Se supone que el receptor debe responder a cada trama PATH_CHALLENGE con una trama PATH_RESPONSE. El atacante puede evitar que el receptor env\u00ede (la gran mayor\u00eda de) estas tramas PATH_RESPONSE colapsando la ventana de congesti\u00f3n del par (al reconocer selectivamente los paquetes recibidos) y manipulando la estimaci\u00f3n de RTT del par. Esta vulnerabilidad ha sido parcheada en las versiones 0.37.7, 0.38.2 y 0.39.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quic-go_project:quic-go:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.37.7", "matchCriteriaId": "F0754377-65C6-4A24-8041-85F73B5630C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:quic-go_project:quic-go:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.38.0", "versionEndExcluding": "0.38.2", "matchCriteriaId": "A687FF1B-43B1-4A23-895E-F328C03FA36F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:quic-go_project:quic-go:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.39.0", "versionEndExcluding": "0.39.4", "matchCriteriaId": "BF599C83-08F6-49B5-965E-927A2004F578"}, {"vulnerable": true, "criteria": "cpe:2.3:a:quic-go_project:quic-go:0.40.0:*:*:*:*:*:*:*", "matchCriteriaId": "BFFA39B2-37BF-4F09-99CD-3665ABC16177"}]}]}], "references": [{"url": "https://github.com/quic-go/quic-go/commit/17fc98c2d81dbe685c19702dc694a9d606ac56dc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/commit/21609ddfeff93668c7625a85eb09f1541fdad965", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/commit/3a9c18bcd27a01c551ac9bf8bd2b4bded77c189a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/commit/554d543b50b917369fb1394cc5396d928166cf49", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/commit/6cc3d58935426191296171a6c0d1ee965e10534e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/commit/9aaefe19fc3dc8c8917cc87e6128bb56d9e9e6cc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/commit/a0ffa757499913f7be69aa78f573a6aee3430ae4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/commit/d7aa627ebde91cf799ada2a07443faa9b1e5abb8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/quic-go/quic-go/security/advisories/GHSA-ppxx-5m9h-6vxf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/G5RSHDTVMYAIGYVVFGKTMFHAZJMA3EVV/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZE7IOKXX5AATU2WR3V76X5Y3A44QAATG/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/quic-go/quic-go/commit/17fc98c2d81dbe685c19702dc694a9d606ac56dc"}}