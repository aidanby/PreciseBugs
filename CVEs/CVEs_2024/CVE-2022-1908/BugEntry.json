{"buggy_code": ["2022-05-02: Fix typo in macro name\n2022-04-27: Fix undefined behavior when passing null to strdup\n2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit", "/** @file parse_rawml.c\n *  @brief Functions for parsing rawml markup\n *\n * Copyright (c) 2020 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"parse_rawml.h\"\n#include \"util.h\"\n#include \"opf.h\"\n#include \"structure.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#if defined(__BIONIC__) && !defined(SIZE_MAX)\n#include <limits.h> /* for SIZE_MAX */\n#endif\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to offset in rawml raw text file\n \n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off Y value of off:y\n @return Offset in rawml buffer on success, SIZE_MAX otherwise\n */\nsize_t mobi_get_rawlink_location(const MOBIRawml *rawml, const uint32_t pos_fid, const uint32_t pos_off) {\n    if (!rawml || !rawml->frag || !rawml->frag->entries ) {\n        debug_print(\"%s\", \"Initialization failed\\n\");\n        return SIZE_MAX;\n    }\n    if (pos_fid >= rawml->frag->entries_count) {\n        debug_print(\"%s\", \"pos_fid not found\\n\");\n        return SIZE_MAX;\n    }\n    const MOBIIndexEntry *entry = &rawml->frag->entries[pos_fid];\n    const size_t insert_position = strtoul(entry->label, NULL, 10);\n    size_t file_offset = insert_position + pos_off;\n    return file_offset;\n}\n\n/**\n @brief Find first occurence of attribute to be replaced in KF7 html\n \n It searches for filepos and recindex attributes\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                /* found match */\n                if (last_border != tag_open) {\n                    /* opening char not found, not an attribute */\n                    data += needle_length;\n                    continue;\n                }\n                /* go to attribute  beginning */\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                /* now go forward */\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Find first occurence of markup attribute with given value\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @param[in] type Type of data (T_HTML or T_CSS)\n @param[in] needle String to find (len <= MOBI_ATTRNAME_MAXSIZE)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            /* found match */\n            if (last_border != tag_open) {\n                /* opening char not found, not an attribute */\n                data += needle_length;\n                continue;\n            }\n            /* go to attribute value beginning */\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            /* now go forward */\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            /* self closing tag '/>' */\n            if (*(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Find first occurence of markup attribute with given name\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @param[in] attrname String to find (len < MOBI_ATTRNAME_MAXSIZE)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_find_attrname(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const char *attrname) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    char needle[MOBI_ATTRNAME_MAXSIZE + 1];\n    snprintf(needle, MOBI_ATTRNAME_MAXSIZE + 1, \"%s=\", attrname);\n    size_t needle_length = strlen(needle);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char quote = '\"';\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length + 2 <= data_end && memcmp(data, needle, needle_length) == 0) {\n            /* found match */\n            if (last_border != tag_open) {\n                /* opening char not found, not an attribute */\n                data += needle_length;\n                continue;\n            }\n            /* go to attribute name beginning */\n            if (data > data_start) {\n                data--;\n                if (!isspace(*data) && *data != tag_open) {\n                    /* wrong name */\n                    data += needle_length;\n                    continue;\n                }\n            }\n            result->start = ++data;\n            /* now go forward */\n            data += needle_length;\n            if (*data++ != quote) {\n                /* not well formed attribute */\n                result->start = NULL;\n                continue;\n            }\n            while (data <= data_end) {\n                if (*data == quote) {\n                    result->end = ++data;\n                    return MOBI_SUCCESS;\n                }\n                data++;\n            }\n            result->start = NULL;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Find first occurence of attribute part to be replaced in KF8 html/css\n \n It searches for \"kindle:\" value in attributes\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @param[in] type Type of data (T_HTML or T_CSS)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_search_links_kf8(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type) {\n    return mobi_find_attrvalue(result, data_start, data_end, type, \"kindle:\");\n}\n\n/**\n @brief Get value and offset of the first found attribute with given name\n \n @param[in,out] value String value of the attribute, will be filled by the function, zero length if not found\n @param[in] data Data to search in\n @param[in] size Data size\n @param[in] attribute Attribute name\n @param[in] only_quoted Require the value to be quoted if true, allow no quotes (eg. filepos=00001) if false\n @return Offset from the beginning of the data, SIZE_MAX if not found\n */\nsize_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    /* FIXME: this function could be replaced by mobi_find_attrvalue()? */\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    /* FIXME: search may start inside tag, so it is a safer option */\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            /* found match */\n            size_t offset = size - length;\n            if (last_border == '>') {\n                /* We are in tag contents */\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            /* previous character should be white space or opening tag */\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            /* now go forward */\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            /* self closing tag '/>' */\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            /* return offset to the beginning of the attribute value string */\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}\n\n/**\n @brief Get offset of the given value of an \"aid\" attribute in a given part\n \n @param[in] aid String value of \"aid\" attribute\n @param[in] html MOBIPart html part\n @return Offset from the beginning of the html part data, SIZE_MAX on failure\n */\nsize_t mobi_get_aid_offset(const MOBIPart *html, const char *aid) {\n    size_t length = html->size;\n    const char *data = (char *) html->data;\n    const size_t aid_length = strlen(aid);\n    const size_t attr_length = 5; /* \"aid='\" length */\n    do {\n        if (length > (aid_length + attr_length) && memcmp(data, \"aid=\", attr_length - 1) == 0) {\n            data += attr_length;\n            length -= attr_length;\n            if (memcmp(data, aid, aid_length) == 0) {\n                if (data[aid_length] == '\\'' || data[aid_length] == '\"') {\n                    return html->size - length;\n                }\n            }\n        }\n        data++;\n    } while (--length);\n    return SIZE_MAX;\n}\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to skeleton part number and offset from the beginning of the part\n \n @param[in,out] file_number Will be set to file number value\n @param[in,out] offset Offset from the beginning of the skeleton part\n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off X value of pos:off:x\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_offset_by_posoff(uint32_t *file_number, size_t *offset, const MOBIRawml *rawml, const size_t pos_fid, const size_t pos_off) {\n    if (!rawml || !rawml->frag || !rawml->frag->entries ||\n        !rawml->skel || !rawml->skel->entries) {\n        debug_print(\"%s\", \"Initialization failed\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret;\n    if (pos_fid >= rawml->frag->entries_count) {\n        debug_print(\"Entry for pos:fid:%zu doesn't exist\\n\", pos_fid);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIIndexEntry entry = rawml->frag->entries[pos_fid];\n    *offset = strtoul(entry.label, NULL, 10);\n    uint32_t file_nr;\n    ret = mobi_get_indxentry_tagvalue(&file_nr, &entry, INDX_TAG_FRAG_FILE_NR);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (file_nr >= rawml->skel->entries_count) {\n        debug_print(\"Entry for skeleton part no %u doesn't exist\\n\", file_nr);\n        return MOBI_DATA_CORRUPT;\n        \n    }\n    const MOBIIndexEntry skel_entry = rawml->skel->entries[file_nr];\n    uint32_t skel_position;\n    ret = mobi_get_indxentry_tagvalue(&skel_position, &skel_entry, INDX_TAG_SKEL_POSITION);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    *offset -= skel_position;\n    *offset += pos_off;\n    *file_number = file_nr;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get value of the closest \"aid\" attribute following given offset in a given part\n \n @param[in,out] aid String value of \"aid\" attribute\n @param[in] html MOBIPart html part\n @param[in] offset Offset from the beginning of the part data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_aid_by_offset(char *aid, const MOBIPart *html, const size_t offset) {\n    if (!aid || !html) {\n        debug_print(\"Parameter error (aid (%p), html (%p)\\n\", (void *) aid, (void *) html);\n        return MOBI_PARAM_ERR;\n    }\n    if (offset > html->size) {\n        debug_print(\"Parameter error: offset (%zu) > part size (%zu)\\n\", offset, html->size);\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *data = html->data;\n    data += offset;\n    size_t length = html->size - offset;\n    \n    size_t off = mobi_get_attribute_value(aid, data, length, \"aid\", true);\n    if (off == SIZE_MAX) {\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get value of the closest \"id\" or \"name\" attribute following given offset in a given part\n \n @param[in,out] id String value of found attribute\n @param[in] html MOBIPart html part\n @param[in] offset Offset from the beginning of the part data\n @param[in,out] pref_attr Preferred attribute to link to (id or name)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_id_by_offset(char *id, const MOBIPart *html, const size_t offset, MOBIAttrType *pref_attr) {\n    if (!id || !html) {\n        debug_print(\"Parameter error (id (%p), html (%p)\\n\", (void *) id, (void *) html);\n        return MOBI_PARAM_ERR;\n    }\n    if (offset > html->size) {\n        debug_print(\"Parameter error: offset (%zu) > part size (%zu)\\n\", offset, html->size);\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *data = html->data;\n    data += offset;\n    size_t length = html->size - offset;\n    static const char * attributes[] = {\n        [ATTR_ID] = \"id\",\n        [ATTR_NAME] = \"name\",\n    };\n    size_t off = mobi_get_attribute_value(id, data, length, attributes[*pref_attr], true);\n    if (off == SIZE_MAX) {\n        // try optional attribute\n        const MOBIAttrType opt_attr = (*pref_attr == ATTR_ID) ? ATTR_NAME : ATTR_ID;\n        off = mobi_get_attribute_value(id, data, length, attributes[opt_attr], true);\n        if (off == SIZE_MAX) {\n            id[0] = '\\0';\n        } else {\n            // save optional attribute as preferred\n            *pref_attr = opt_attr;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to html file number and closest \"aid\" attribute following the position\n \n @param[in,out] file_number Will be set to file number value\n @param[in,out] aid String value of \"aid\" attribute\n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off Y value of off:y\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_aid_by_posoff(uint32_t *file_number, char *aid, const MOBIRawml *rawml, const size_t pos_fid, const size_t pos_off) {\n    size_t offset;\n    MOBI_RET ret = mobi_get_offset_by_posoff(file_number, &offset, rawml, pos_fid, pos_off);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPart *html = mobi_get_part_by_uid(rawml, *file_number);\n    if (html == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_get_aid_by_offset(aid, html, offset);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to html file number and closest \"id\" attribute following the position\n \n @param[in,out] file_number Will be set to file number value\n @param[in,out] id String value of \"id\" attribute\n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off Y value of off:y\n @param[in,out] pref_attr Attribute to link to\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_id_by_posoff(uint32_t *file_number, char *id, const MOBIRawml *rawml, const size_t pos_fid, const size_t pos_off, MOBIAttrType *pref_attr) {\n    size_t offset;\n    MOBI_RET ret = mobi_get_offset_by_posoff(file_number, &offset, rawml, pos_fid, pos_off);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPart *html = mobi_get_part_by_uid(rawml, *file_number);\n    if (html == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_get_id_by_offset(id, html, offset, pref_attr);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse resource records (images, fonts etc), determine their type, link to rawml\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @param[in,out] rawml Structure rawml->resources will be filled with parsed resources metadata and linked records data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_resources(const MOBIData *m, MOBIRawml *rawml) {\n    size_t first_res_seqnumber = mobi_get_first_resource_record(m);\n    if (first_res_seqnumber == MOBI_NOTSET) {\n        /* search all records */\n        first_res_seqnumber = 0;\n    }\n    const MOBIPdbRecord *curr_record = mobi_get_record_by_seqnumber(m, first_res_seqnumber);\n    if (curr_record == NULL) {\n        debug_print(\"First resource record not found at %zu, skipping resources\\n\", first_res_seqnumber);\n        return MOBI_SUCCESS;\n    }\n    size_t i = 0;\n    MOBIPart *head = NULL;\n    while (curr_record != NULL) {\n        const MOBIFiletype filetype = mobi_determine_resource_type(curr_record);\n        if (filetype == T_UNKNOWN) {\n            curr_record = curr_record->next;\n            i++;\n            continue;\n        }\n        if (filetype == T_BREAK) {\n            break;\n        }\n        \n        MOBIPart *curr_part = calloc(1, sizeof(MOBIPart));;\n        if (curr_part == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation for flow part failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        curr_part->data = curr_record->data;\n        curr_part->size = curr_record->size;\n        curr_part->uid = i++;\n        curr_part->next = NULL;\n        \n        MOBI_RET ret = MOBI_SUCCESS;\n        if (filetype == T_FONT) {\n            ret = mobi_add_font_resource(curr_part);\n            if (ret != MOBI_SUCCESS) {\n                debug_print(\"%s\\n\", \"Decoding font resource failed\");\n            }\n        } else if (filetype == T_AUDIO) {\n            ret = mobi_add_audio_resource(curr_part);\n            if (ret != MOBI_SUCCESS) {\n                debug_print(\"%s\\n\", \"Decoding audio resource failed\");\n            }\n        } else if (filetype == T_VIDEO) {\n            ret = mobi_add_video_resource(curr_part);\n            if (ret != MOBI_SUCCESS) {\n                debug_print(\"%s\\n\", \"Decoding video resource failed\");\n            }\n        } else {\n            curr_part->type = filetype;\n        }\n        \n        curr_record = curr_record->next;\n        \n        if (ret != MOBI_SUCCESS) {\n            free(curr_part);\n            curr_part = NULL;\n        } else if (head) {\n            head->next = curr_part;\n            head = curr_part;\n        } else {\n            rawml->resources = curr_part;\n            head = curr_part;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse Replica Print ebook (azw4). Extract pdf.\n @todo Parse remaining data from the file\n \n @param[in,out] pdf Memory area will be filled with extracted pdf data\n @param[in] text Raw decompressed text to be parsed\n @param[in,out] length Text length. Will be updated with pdf_length on return\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_process_replica(unsigned char *pdf, const char *text, size_t *length) {\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf = mobi_buffer_init_null((unsigned char*) text, *length);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    mobi_buffer_setpos(buf, 12);\n    size_t pdf_offset = mobi_buffer_get32(buf); /* offset 12 */\n    size_t pdf_length = mobi_buffer_get32(buf); /* 16 */\n    if (pdf_length > *length) {\n        debug_print(\"PDF size from replica header too large: %zu\", pdf_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_setpos(buf, pdf_offset);\n    mobi_buffer_getraw(pdf, buf, pdf_length);\n    ret = buf->error;\n    mobi_buffer_free_null(buf);\n    *length = pdf_length;\n    return ret;\n}\n\n/**\n @brief Parse raw text into flow parts\n \n @param[in,out] rawml Structure rawml->flow will be filled with parsed flow text parts\n @param[in] text Raw decompressed text to be parsed\n @param[in] length Text length\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_flow(MOBIRawml *rawml, const char *text, const size_t length) {\n    /* KF8 */\n    if (rawml->fdst != NULL) {\n        rawml->flow = calloc(1, sizeof(MOBIPart));\n        if (rawml->flow == NULL) {\n            debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        /* split text into fdst structure parts */\n        MOBIPart *curr = rawml->flow;\n        size_t i = 0;\n        const size_t section_count = rawml->fdst->fdst_section_count;\n        while (i < section_count) {\n            if (i > 0) {\n                curr->next = calloc(1, sizeof(MOBIPart));\n                if (curr->next == NULL) {\n                    debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                curr = curr->next;\n            }\n            const uint32_t section_start = rawml->fdst->fdst_section_starts[i];\n            const uint32_t section_end = rawml->fdst->fdst_section_ends[i];\n            const size_t section_length = section_end - section_start;\n            if (section_start + section_length > length) {\n                debug_print(\"Wrong fdst section length: %zu\\n\", section_length);\n                return MOBI_DATA_CORRUPT;\n            }\n            unsigned char *section_data = malloc(section_length);\n            if (section_data == NULL) {\n                debug_print(\"%s\", \"Memory allocation failed\\n\");\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(section_data, (text + section_start), section_length);\n            curr->uid = i;\n            curr->data = section_data;\n            curr->type = mobi_determine_flowpart_type(rawml, i);\n            curr->size = section_length;\n            curr->next = NULL;\n            i++;\n        }\n    } else {\n        /* No FDST or FDST parts count = 1 */\n        /* single flow part */\n        rawml->flow = calloc(1, sizeof(MOBIPart));\n        if (rawml->flow == NULL) {\n            debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBIPart *curr = rawml->flow;\n        size_t section_length = 0;\n        MOBIFiletype section_type = T_HTML;\n        unsigned char *section_data;\n        /* check if raw text is Print Replica */\n        if (memcmp(text, REPLICA_MAGIC, 4) == 0) {\n            debug_print(\"%s\", \"Print Replica book\\n\");\n            /* print replica */\n            unsigned char *pdf = malloc(length);\n            if (pdf == NULL) {\n                debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n                return MOBI_MALLOC_FAILED;\n            }\n            section_length = length;\n            section_type = T_PDF;\n            const MOBI_RET ret = mobi_process_replica(pdf, text, &section_length);\n            if (ret != MOBI_SUCCESS) {\n                free(pdf);\n                return ret;\n            }\n            section_data = malloc(section_length);\n            if (section_data == NULL) {\n                debug_print(\"%s\", \"Memory allocation failed\\n\");\n                free(pdf);\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(section_data, pdf, section_length);\n            free(pdf);\n        } else {\n            /* text data */\n            section_length = length;\n            section_data = malloc(section_length);\n            if (section_data == NULL) {\n                debug_print(\"%s\", \"Memory allocation failed\\n\");\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(section_data, text, section_length);\n        }\n        curr->uid = 0;\n        curr->data = section_data;\n        curr->type = section_type;\n        curr->size = section_length;\n        curr->next = NULL;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse raw html into html parts. Use index entries if present to parse file\n \n @param[in,out] rawml Structure rawml->markup will be filled with reconstructed html parts\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_parts(MOBIRawml *rawml) {\n    MOBI_RET ret;\n    if (rawml->flow == NULL) {\n        debug_print(\"%s\", \"Flow structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    /* take first part, xhtml */\n    MOBIBuffer *buf = mobi_buffer_init_null(rawml->flow->data, rawml->flow->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->markup = calloc(1, sizeof(MOBIPart));\n    if (rawml->markup == NULL) {\n        debug_print(\"%s\", \"Memory allocation for markup part failed\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPart *curr = rawml->markup;\n    /* not skeleton data, just copy whole part to markup */\n    if (rawml->skel == NULL) {\n        unsigned char *data = malloc(buf->maxlen);\n        if (data == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_MALLOC_FAILED;\n        }\n        memcpy(data, buf->data, buf->maxlen);\n        curr->uid = 0;\n        curr->size = buf->maxlen;\n        curr->data = data;\n        curr->type = rawml->flow->type;\n        curr->next = NULL;\n        mobi_buffer_free_null(buf);\n        return MOBI_SUCCESS;\n    }\n    /* parse skeleton data */\n    size_t i = 0;\n    size_t j = 0;\n    size_t curr_position = 0;\n    size_t total_fragments_count = rawml->frag->total_entries_count;\n    while (i < rawml->skel->entries_count) {\n        const MOBIIndexEntry *entry = &rawml->skel->entries[i];\n        uint32_t fragments_count;\n        ret = mobi_get_indxentry_tagvalue(&fragments_count, entry, INDX_TAG_SKEL_COUNT);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        if (fragments_count > total_fragments_count) {\n            debug_print(\"%s\", \"Wrong count of fragments\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        total_fragments_count -= fragments_count;\n        uint32_t skel_position;\n        ret = mobi_get_indxentry_tagvalue(&skel_position, entry, INDX_TAG_SKEL_POSITION);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        uint32_t skel_length;\n        ret = mobi_get_indxentry_tagvalue(&skel_length, entry, INDX_TAG_SKEL_LENGTH);\n        if (ret != MOBI_SUCCESS || skel_position + skel_length > buf->maxlen) {\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        debug_print(\"%zu\\t%s\\t%i\\t%i\\t%i\\n\", i, entry->label, fragments_count, skel_position, skel_length);\n        mobi_buffer_setpos(buf, skel_position);\n        \n        unsigned char *frag_buffer = mobi_buffer_getpointer(buf, skel_length);\n        if (frag_buffer == NULL) {\n            debug_print(\"%s\\n\", \"Fragment data beyond buffer\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        MOBIFragment *first_fragment = mobi_list_add(NULL, 0, frag_buffer, skel_length, false);\n        MOBIFragment *current_fragment = first_fragment;\n        while (fragments_count--) {\n            entry = &rawml->frag->entries[j];\n            uint32_t insert_position = (uint32_t) strtoul(entry->label, NULL, 10);\n            if (insert_position < curr_position) {\n                debug_print(\"Insert position (%u) before part start (%zu)\\n\", insert_position, curr_position);\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return MOBI_DATA_CORRUPT;\n            }\n            uint32_t file_number;\n            ret = mobi_get_indxentry_tagvalue(&file_number, entry, INDX_TAG_FRAG_FILE_NR);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            if (file_number != i) {\n                debug_print(\"%s\", \"SKEL part number and fragment sequence number don't match\\n\");\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return MOBI_DATA_CORRUPT;\n            }\n            uint32_t frag_length;\n            ret = mobi_get_indxentry_tagvalue(&frag_length, entry, INDX_TAG_FRAG_LENGTH);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n#if (MOBI_DEBUG)\n            /* FIXME: this fragment metadata is currently unused */\n            uint32_t seq_number;\n            ret = mobi_get_indxentry_tagvalue(&seq_number, entry, INDX_TAG_FRAG_SEQUENCE_NR);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            uint32_t frag_position;\n            ret = mobi_get_indxentry_tagvalue(&frag_position, entry, INDX_TAG_FRAG_POSITION);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            uint32_t cncx_offset;\n            ret = mobi_get_indxentry_tagvalue(&cncx_offset, entry, INDX_TAG_FRAG_AID_CNCX);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            const MOBIPdbRecord *cncx_record = rawml->frag->cncx_record;\n            char *aid_text = mobi_get_cncx_string(cncx_record, cncx_offset);\n            if (aid_text == NULL) {\n                mobi_buffer_free_null(buf);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_list_del_all(first_fragment);\n                return MOBI_MALLOC_FAILED;\n            }\n            debug_print(\"posfid[%zu]\\t%i\\t%i\\t%s\\t%i\\t%i\\t%i\\t%i\\n\", j, insert_position, cncx_offset, aid_text, file_number, seq_number, frag_position, frag_length);\n            free(aid_text);\n#endif\n            \n            insert_position -= curr_position;\n            if (skel_length < insert_position) {\n                debug_print(\"Insert position (%u) after part end (%u)\\n\", insert_position, skel_length);\n                // FIXME: shouldn't the fragment be ignored?\n                // For now insert it at the end.\n                insert_position = skel_length;\n            }\n            skel_length += frag_length;\n            \n            frag_buffer = mobi_buffer_getpointer(buf, frag_length);\n            if (frag_buffer == NULL) {\n                debug_print(\"%s\\n\", \"Fragment data beyond buffer\");\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return MOBI_DATA_CORRUPT;\n            }\n            current_fragment = mobi_list_insert(current_fragment, insert_position, frag_buffer, frag_length, false, insert_position);\n            j++;\n            \n        }\n        char *skel_text = malloc(skel_length);\n        if (skel_text == NULL) {\n            debug_print(\"%s\", \"Memory allocation for markup data failed\\n\");\n            mobi_buffer_free_null(buf);\n            mobi_list_del_all(first_fragment);\n            return MOBI_MALLOC_FAILED;\n        }\n        char *p = skel_text;\n        while (first_fragment) {\n            if (first_fragment->fragment) {\n                memcpy(p, first_fragment->fragment, first_fragment->size);\n                p += first_fragment->size;\n            } else {\n                debug_print(\"Skipping broken fragment in part %zu\\n\", i);\n            }\n            first_fragment = mobi_list_del(first_fragment);\n        }\n        if (i > 0) {\n            curr->next = calloc(1, sizeof(MOBIPart));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for markup part failed\\n\");\n                free(skel_text);\n                mobi_buffer_free_null(buf);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->uid = i;\n        curr->size = skel_length;\n        curr->data = (unsigned char *) skel_text;\n        curr->type = T_HTML;\n        curr->next = NULL;\n        curr_position += skel_length;\n        i++;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Scan html part and build array of filepos link target offsets\n \n @param[in,out] links MOBIArray structure for link target offsets array\n @param[in] part MOBIPart html part structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_filepos_array(MOBIArray *links, const MOBIPart *part) {\n    if (!links || !part) {\n        return MOBI_INIT_FAILED;\n    }\n    size_t offset = 0;\n    size_t size = part->size;\n    unsigned char *data = part->data;\n    while (true) {\n        char val[MOBI_ATTRVALUE_MAXSIZE + 1];\n        size -= offset;\n        data += offset;\n        offset = mobi_get_attribute_value(val, data, size, \"filepos\", false);\n        if (offset == SIZE_MAX) { break; }\n        size_t filepos = strtoul(val, NULL, 10);\n        if (filepos > UINT32_MAX || filepos == 0) {\n            debug_print(\"Filepos out of range: %zu\\n\", filepos);\n            continue;\n        }\n        MOBI_RET ret = array_insert(links, (uint32_t) filepos);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Scan ncx part and build array of filepos link target offsets.\n \n @param[in,out] links MOBIArray structure for link target offsets array\n @param[in] rawml MOBIRawml parsed records structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_ncx_filepos_array(MOBIArray *links, const MOBIRawml *rawml) {\n    if (!links || !rawml) {\n        return MOBI_PARAM_ERR;\n    }\n    MOBIPart *part = rawml->resources;\n    while (part) {\n        if (part->type == T_NCX) {\n            size_t offset = 0;\n            size_t size = part->size;\n            unsigned char *data = part->data;\n            while (true) {\n                char val[MOBI_ATTRVALUE_MAXSIZE + 1];\n                size -= offset;\n                data += offset;\n                offset = mobi_get_attribute_value(val, data, size, \"src\", false);\n                if (offset == SIZE_MAX) { break; }\n                /* part00000.html#0000000000 */\n                uint32_t filepos = 0;\n                sscanf(val + 15, \"%10u\", &filepos);\n                MOBI_RET ret = array_insert(links, filepos);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n        part = part->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace kindle:pos link with html href\n \n @param[in,out] link Memory area which will be filled with \"part00000.html#customid\", including quotation marks\n @param[in] rawml Structure rawml\n @param[in] value String kindle:pos:fid:0000:off:0000000000, without quotation marks\n @param[in,out] pref_attr Preferred attribute to link to (id or name)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_posfid_to_link(char *link, const MOBIRawml *rawml, const char *value, MOBIAttrType *pref_attr) {\n    /* \"kindle:pos:fid:0000:off:0000000000\" */\n    /* extract fid and off */\n    if (strlen(value) < (sizeof(\"kindle:pos:fid:0000:off:0000000000\") - 1)) {\n        debug_print(\"Skipping too short link: %s\\n\", value);\n        *link = '\\0';\n        return MOBI_SUCCESS;\n    }\n    value += (sizeof(\"kindle:pos:fid:\") - 1);\n    if (value[4] != ':') {\n        debug_print(\"Skipping malformed link: kindle:pos:fid:%s\\n\", value);\n        *link = '\\0';\n        return MOBI_SUCCESS;\n    }\n    char str_fid[4 + 1];\n    strncpy(str_fid, value, 4);\n    str_fid[4] = '\\0';\n    char str_off[10 + 1];\n    value += (sizeof(\"0001:off:\") - 1);\n    strncpy(str_off, value, 10);\n    str_off[10] = '\\0';\n    \n    /* get file number and id value */\n    uint32_t pos_off;\n    uint32_t pos_fid;\n    MOBI_RET ret = mobi_base32_decode(&pos_off, str_off);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_base32_decode(&pos_fid, str_fid);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    uint32_t part_id;\n    char id[MOBI_ATTRVALUE_MAXSIZE + 1];\n    ret = mobi_get_id_by_posoff(&part_id, id, rawml, pos_fid, pos_off, pref_attr);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    /* FIXME: pos_off == 0 means top of file? */\n    if (pos_off) {\n        int n = snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"part%05u.html#%s\\\"\", part_id, id);\n        if (n > MOBI_ATTRVALUE_MAXSIZE + 1) {\n            debug_print(\"Skipping truncated link: %s\\n\", link);\n            *link = '\\0';\n            return MOBI_SUCCESS;\n       }\n    } else {\n        snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"part%05u.html\\\"\", part_id);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace kindle:flow link with html href\n \n @param[in,out] link Memory area which will be filled with \"part00000.ext\", including quotation marks\n @param[in] rawml Structure rawml\n @param[in] value String kindle:flow:0000?mime=type, without quotation marks\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_flow_to_link(char *link, const MOBIRawml *rawml, const char *value) {\n    /* \"kindle:flow:0000?mime=\" */\n    *link = '\\0';\n    if (strlen(value) < (sizeof(\"kindle:flow:0000?mime=\") - 1)) {\n        debug_print(\"Skipping too short link: %s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    value += (sizeof(\"kindle:flow:\") - 1);\n    if (value[4] != '?') {\n        debug_print(\"Skipping broken link: kindle:flow:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    char str_fid[4 + 1];\n    strncpy(str_fid, value, 4);\n    str_fid[4] = '\\0';\n    \n    MOBIPart *flow = mobi_get_flow_by_fid(rawml, str_fid);\n    if (flow == NULL) {\n        debug_print(\"Skipping broken link (missing resource): kindle:flow:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    MOBIFileMeta meta = mobi_get_filemeta_by_type(flow->type);\n    char *extension = meta.extension;\n    snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"flow%05zu.%s\\\"\", flow->uid, extension);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace kindle:embed link with html href\n \n @param[in,out] link Memory area which will be filled with \"resource00000.ext\", including quotation marks\n @param[in] rawml Structure rawml\n @param[in] value String kindle:embed:0000?mime=type, with optional quotation marks\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_embed_to_link(char *link, const MOBIRawml *rawml, const char *value) {\n    /* \"kindle:embed:0000[?mime=]\" */\n    /* skip quotation marks or spaces */\n    while (*value == '\"' || *value == '\\'' || isspace(*value)) {\n        value++;\n    }\n    *link = '\\0';\n    if (strlen(value) < (sizeof(\"kindle:embed:0000\") - 1)) {\n        debug_print(\"Skipping too short link: %s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    value += (sizeof(\"kindle:embed:\") - 1);\n    char str_fid[4 + 1];\n    strncpy(str_fid, value, 4);\n    str_fid[4] = '\\0';\n    \n    /* get file number */\n    uint32_t part_id;\n    MOBI_RET ret = mobi_base32_decode(&part_id, str_fid);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"Skipping broken link (corrupt base32): kindle:embed:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    part_id--;\n    MOBIPart *resource = mobi_get_resource_by_uid(rawml, part_id);\n    if (resource == NULL) {\n        debug_print(\"Skipping broken link (missing resource): kindle:embed:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    MOBIFileMeta meta = mobi_get_filemeta_by_type(resource->type);\n    char *extension = meta.extension;\n    snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"resource%05u.%s\\\"\", part_id, extension);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace offset-links with html-links in KF8 markup\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_links_kf8(const MOBIRawml *rawml) {\n    MOBIResult result;\n    \n    typedef struct NEWData {\n        size_t part_group;\n        size_t part_uid;\n        MOBIFragment *list;\n        size_t size;\n        struct NEWData *next;\n    } NEWData;\n    \n    NEWData *partdata = NULL;\n    NEWData *curdata = NULL;\n    MOBIPart *parts[] = {\n        rawml->markup, /* html files */\n        rawml->flow->next /* css, skip first unparsed html part */\n    };\n    size_t i;\n    for (i = 0; i < 2; i++) {\n        MOBIPart *part = parts[i];\n        while (part) {\n            unsigned char *data_in = part->data;\n            result.start = part->data;\n            const unsigned char *data_end = part->data + part->size - 1;\n            MOBIFragment *first = NULL;\n            MOBIFragment *curr = NULL;\n            size_t part_size = 0;\n            MOBIAttrType pref_attr = ATTR_ID;\n            while (true) {\n                mobi_search_links_kf8(&result, result.start, data_end, part->type);\n                if (result.start == NULL) {\n                    break;\n                }\n                char *value = (char *) result.value;\n                unsigned char *data_cur = result.start;\n                char *target = NULL;\n                if (data_cur < data_in) {\n                    mobi_list_del_all(first);\n                    return MOBI_DATA_CORRUPT;\n                }\n                size_t size = (size_t) (data_cur - data_in);\n                char link[MOBI_ATTRVALUE_MAXSIZE + 1];\n                if ((target = strstr(value, \"kindle:pos:fid:\")) != NULL) {\n                    /* \"kindle:pos:fid:0001:off:0000000000\" */\n                    /* replace link with href=\"part00000.html#00\" */\n                    /* FIXME: this requires present target id or name attribute */\n                    MOBI_RET ret = mobi_posfid_to_link(link, rawml, target, &pref_attr);\n                    if (ret != MOBI_SUCCESS) {\n                        mobi_list_del_all(first);\n                        return ret;\n                    }\n                } else if ((target = strstr(value, \"kindle:flow:\")) != NULL) {\n                    /* kindle:flow:0000?mime=text/css */\n                    /* replace link with href=\"flow00000.ext\" */\n                    MOBI_RET ret = mobi_flow_to_link(link, rawml, target);\n                    if (ret != MOBI_SUCCESS) {\n                        mobi_list_del_all(first);\n                        return ret;\n                    }\n                } else if ((target = strstr(value, \"kindle:embed:\")) != NULL) {\n                    /* kindle:embed:0000?mime=image/jpg */\n                    /* kindle:embed:0000 (font resources) */\n                    /* replace link with href=\"resource00000.ext\" */\n                    MOBI_RET ret = mobi_embed_to_link(link, rawml, target);\n                    if (ret != MOBI_SUCCESS) {\n                        mobi_list_del_all(first);\n                        return ret;\n                    }\n                }\n                if (target && *link != '\\0') {\n                    /* first chunk */\n                    curr = mobi_list_add(curr, (size_t) (data_in - part->data), data_in, size, false);\n                    if (curr == NULL) {\n                        mobi_list_del_all(first);\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    if (!first) { first = curr; }\n                    part_size += curr->size;\n                    /* second chunk */\n                    /* strip quotes if is_url */\n                    curr = mobi_list_add(curr, SIZE_MAX,\n                                         (unsigned char *) strdup(link + result.is_url),\n                                         strlen(link) - 2 * result.is_url, true);\n                    if (curr == NULL) {\n                        mobi_list_del_all(first);\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    part_size += curr->size;\n                    data_in = result.end;\n                }\n            }\n            if (first && first->fragment) {\n                /* last chunk */\n                if (part->data + part->size < data_in) {\n                    mobi_list_del_all(first);\n                    return MOBI_DATA_CORRUPT;\n                }\n                size_t size = (size_t) (part->data + part->size - data_in);\n                curr = mobi_list_add(curr, (size_t) (data_in - part->data), data_in, size, false);\n                if (curr == NULL) {\n                    mobi_list_del_all(first);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                part_size += curr->size;\n                /* save */\n                if (!curdata) {\n                    curdata = calloc(1, sizeof(NEWData));\n                    partdata = curdata;\n                } else {\n                    curdata->next = calloc(1, sizeof(NEWData));\n                    curdata = curdata->next;\n                }\n                curdata->part_group = i;\n                curdata->part_uid = part->uid;\n                curdata->list = first;\n                curdata->size = part_size;\n            }\n            part = part->next;\n        }\n    }\n    /* now update parts */\n    debug_print(\"Inserting links%s\", \"\\n\");\n    for (i = 0; i < 2; i++) {\n        MOBIPart *part = parts[i];\n        while (part) {\n            if (partdata && part->uid == partdata->part_uid && i == partdata->part_group) {\n                MOBIFragment *fragdata = partdata->list;\n                unsigned char *new_data = malloc(partdata->size);\n                if (new_data == NULL) {\n                    mobi_list_del_all(fragdata);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                unsigned char *data_out = new_data;\n                while (fragdata) {\n                    memcpy(data_out, fragdata->fragment, fragdata->size);\n                    data_out += fragdata->size;\n                    fragdata = mobi_list_del(fragdata);\n                }\n                free(part->data);\n                part->data = new_data;\n                part->size = partdata->size;\n                NEWData *partused = partdata;\n                partdata = partdata->next;\n                free(partused);\n            }\n            part = part->next;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get infl index markup for given orth entry\n \n @param[in,out] outstring Reconstructed tag <idx:infl\\>\n @param[in] infl MOBIIndx structure with parsed infl index\n @param[in] orth_entry Orth index entry\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBIIndexEntry *orth_entry) {\n    const char *label = orth_entry->label;\n    uint32_t *infl_groups = NULL;\n    size_t infl_count = mobi_get_indxentry_tagarray(&infl_groups, orth_entry, INDX_TAGARR_ORTH_INFL);\n    \n    if (infl_count == 0 || !infl_groups) {\n        return MOBI_SUCCESS;\n    }    \n    const char *start_tag = \"<idx:infl>\";\n    const char *end_tag = \"</idx:infl>\";\n    const char *iform_tag = \"<idx:iform%s value=\\\"%s\\\"/>\";\n    char name_attr[INDX_INFLBUF_SIZEMAX + 1];\n    char infl_tag[INDX_INFLBUF_SIZEMAX + 1];\n    strcpy(outstring, start_tag);\n    size_t initlen = strlen(start_tag) + strlen(end_tag);\n    size_t outlen = initlen;\n    size_t label_length = strlen(label);\n    if (label_length > INDX_INFLBUF_SIZEMAX) {\n        debug_print(\"Entry label too long (%s)\\n\", label);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (infl->cncx_record == NULL) {\n        debug_print(\"%s\\n\", \"Missing cncx record\");\n        return MOBI_DATA_CORRUPT;\n    }\n    for (size_t i = 0; i < infl_count; i++) {\n        size_t offset = infl_groups[i];\n        if (offset >= infl->entries_count) {\n            debug_print(\"%s\\n\", \"Invalid entry offset\");\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t *groups;\n        size_t group_cnt = mobi_get_indxentry_tagarray(&groups, &infl->entries[offset], INDX_TAGARR_INFL_GROUPS);\n        uint32_t *parts;\n        size_t part_cnt = mobi_get_indxentry_tagarray(&parts, &infl->entries[offset], INDX_TAGARR_INFL_PARTS_V2);\n        if (group_cnt != part_cnt) {\n            return MOBI_DATA_CORRUPT;\n        }\n        for (size_t j = 0; j < part_cnt; j++) {\n            name_attr[0] = '\\0';\n            char *group_name = mobi_get_cncx_string(infl->cncx_record, groups[j]);\n            if (group_name == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            if (strlen(group_name)) {\n                snprintf(name_attr, INDX_INFLBUF_SIZEMAX, \" name=\\\"%s\\\"\", group_name);\n            }\n            free(group_name);\n            \n            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];\n            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);\n            if (parts[j] >= infl->entries_count) {\n                debug_print(\"%s\\n\", \"Invalid entry offset\");\n                return MOBI_DATA_CORRUPT;\n            }\n            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;\n            memcpy(decoded, label, label_length);\n            int decoded_length = (int) label_length;\n            MOBI_RET ret = mobi_decode_infl(decoded, &decoded_length, rule);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            if (decoded_length == 0) {\n                continue;\n            }\n            int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, name_attr, decoded);\n            if (n > INDX_INFLBUF_SIZEMAX) {\n                debug_print(\"Skipping truncated tag: %s\\n\", infl_tag);\n                continue;\n            }\n            outlen += strlen(infl_tag);\n            if (outlen > INDX_INFLTAG_SIZEMAX) {\n                debug_print(\"Inflections text in %s too long (%zu)\\n\", label, outlen);\n                return MOBI_ERROR;\n            }\n            strcat(outstring, infl_tag);\n        }\n    }\n    if (outlen == initlen) {\n        outstring[0] = '\\0';\n    } else {\n        strcat(outstring, end_tag);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get infl index markup for given orth entry\n \n This function is inflections scheme used in older mobipocket dictionaries\n \n @param[in,out] outstring Reconstructed tag <idx:infl\\>\n @param[in] infl_tree MOBITrie structure with inflection rules\n @param[in] orth_entry Orth index entry\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_infl_v1(char *outstring, MOBITrie * const infl_tree, const MOBIIndexEntry *orth_entry) {\n    const char *label = orth_entry->label;\n    const size_t label_length = strlen(label);\n    if (label_length > INDX_INFLBUF_SIZEMAX) {\n        debug_print(\"Entry label too long (%s)\\n\", label);\n        return MOBI_DATA_CORRUPT;\n    }\n    char *infl_strings[INDX_INFLSTRINGS_MAX];\n    size_t infl_count = mobi_trie_get_inflgroups(infl_strings, infl_tree, label);\n    \n    if (infl_count == 0) {\n        return MOBI_SUCCESS;\n    }\n    \n    const char *start_tag = \"<idx:infl>\";\n    const char *end_tag = \"</idx:infl>\";\n    const char *iform_tag = \"<idx:iform value=\\\"%s\\\"/>\";\n    char infl_tag[INDX_INFLBUF_SIZEMAX + 1];\n    strcpy(outstring, start_tag);\n    size_t initlen = strlen(start_tag) + strlen(end_tag);\n    size_t outlen = initlen;\n    for (size_t i = 0; i < infl_count; i++) {\n        char *decoded = infl_strings[i];\n        size_t decoded_length = strlen(decoded);\n\n        if (decoded_length == 0) {\n            free(decoded);\n            continue;\n        }\n        int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, decoded);\n        /* allocated in mobi_trie_get_inflgroups() */\n        free(decoded);\n        if (n > INDX_INFLBUF_SIZEMAX) {\n            debug_print(\"Skipping too long tag: %s\\n\", infl_tag);\n            continue;\n        }\n        outlen += strlen(infl_tag);\n        if (outlen > INDX_INFLTAG_SIZEMAX) {\n            debug_print(\"Inflections text in %s too long (%zu)\\n\", label, outlen);\n            break;\n        }\n        strcat(outstring, infl_tag);\n    }\n    if (outlen == initlen) {\n        outstring[0] = '\\0';\n    } else {\n        strcat(outstring, end_tag);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Insert orth index markup to linked list of fragments\n \n @param[in] rawml Structure rawml contains orth index data\n @param[in,out] first First element of the linked list\n @param[in,out] new_size Counter to be updated with inserted fragments size\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_orth(const MOBIRawml *rawml, MOBIFragment *first, size_t *new_size) {\n    MOBITrie *infl_trie = NULL;\n    bool is_infl_v2 = mobi_indx_has_tag(rawml->orth, INDX_TAGARR_ORTH_INFL);\n    bool is_infl_v1 = false;\n    if (is_infl_v2 == false) {\n        is_infl_v1 = mobi_indx_has_tag(rawml->infl, INDX_TAGARR_INFL_PARTS_V1);\n    }\n    debug_print(\"Reconstructing orth index %s\\n\", (is_infl_v1)?\"(infl v1)\":(is_infl_v2)?\"(infl v2)\":\"\");\n    if (is_infl_v1) {\n        size_t total = rawml->infl->entries_count;\n        size_t j = 0;\n        while (j < total) {\n            MOBI_RET ret = mobi_trie_insert_infl(&infl_trie, rawml->infl, j++);\n            if (ret != MOBI_SUCCESS || infl_trie == NULL) {\n                debug_print(\"Building trie for inflections failed%s\", \"\\n\");\n                mobi_trie_free(infl_trie);\n                is_infl_v1 = false;\n            }\n        }\n    }\n    \n    MOBIFragment *curr = first;\n    size_t i = 0;\n    const size_t count = rawml->orth->entries_count;\n    const char *start_tag1 = \"<idx:entry><idx:orth value=\\\"%s\\\">%s</idx:orth></idx:entry>\";\n    const char *start_tag2 = \"<idx:entry scriptable=\\\"yes\\\"><idx:orth value=\\\"%s\\\">%s</idx:orth>\";\n    const char *end_tag = \"</idx:entry>\";\n    const size_t start_tag1_len = strlen(start_tag1) - 4;\n    const size_t start_tag2_len = strlen(start_tag2) - 4;\n    const size_t end_tag_len = strlen(end_tag);\n    uint32_t prev_startpos = 0;\n    while (i < count) {\n        const MOBIIndexEntry *orth_entry = &rawml->orth->entries[i];\n        const char *label = orth_entry->label;\n        uint32_t entry_startpos;\n        MOBI_RET ret = mobi_get_indxentry_tagvalue(&entry_startpos, orth_entry, INDX_TAG_ORTH_POSITION);\n        if (ret != MOBI_SUCCESS) {\n            i++;\n            continue;\n        }\n        size_t entry_length = 0;\n        uint32_t entry_textlen = 0;\n        mobi_get_indxentry_tagvalue(&entry_textlen, orth_entry, INDX_TAG_ORTH_LENGTH);\n        char *start_tag;\n        if (entry_textlen == 0) {\n            entry_length += start_tag1_len + strlen(label);\n            start_tag = (char *) start_tag1;\n        } else {\n            entry_length += start_tag2_len + strlen(label);\n            start_tag = (char *) start_tag2;\n        }\n\n        char *entry_text;\n        if (rawml->infl) {\n            char *infl_tag = malloc(INDX_INFLTAG_SIZEMAX + 1);\n            if (infl_tag == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                return MOBI_MALLOC_FAILED;\n            }\n            infl_tag[0] = '\\0';\n            if (is_infl_v2) {\n                ret = mobi_reconstruct_infl(infl_tag, rawml->infl, orth_entry);\n            } else if (is_infl_v1) {\n                ret = mobi_reconstruct_infl_v1(infl_tag, infl_trie, orth_entry);\n            } else {\n                debug_print(\"Unknown inflection scheme?%s\", \"\\n\");\n            }\n            if (ret != MOBI_SUCCESS) {\n                free(infl_tag);\n                return ret;\n            }\n            entry_length += strlen(infl_tag);\n            \n            entry_text = malloc(entry_length + 1);\n            if (entry_text == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                free(infl_tag);\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(entry_text, entry_length + 1, start_tag, label, infl_tag);\n            free(infl_tag);\n        } else {\n            entry_text = malloc(entry_length + 1);\n            if (entry_text == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(entry_text, entry_length + 1, start_tag, label, \"\");\n        }\n        \n        if (entry_startpos < prev_startpos) {\n            curr = first;\n        }\n        curr = mobi_list_insert(curr, SIZE_MAX,\n                                (unsigned char *) entry_text,\n                                entry_length, true, entry_startpos);\n        prev_startpos = entry_startpos;\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            mobi_trie_free(infl_trie);\n            return MOBI_MALLOC_FAILED;\n        }\n        *new_size += curr->size;\n        if (entry_textlen > 0) {\n            /* FIXME: avoid end_tag duplication */\n            curr = mobi_list_insert(curr, SIZE_MAX,\n                                    (unsigned char *) strdup(end_tag),\n                                    end_tag_len, true, entry_startpos + entry_textlen);\n            if (curr == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                return MOBI_MALLOC_FAILED;\n            }\n            *new_size += curr->size;\n        }\n        i++;\n    }\n    mobi_trie_free(infl_trie);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace offset-links with html-links in KF7 markup.\n Also reconstruct dictionary markup if present\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_links_kf7(const MOBIRawml *rawml) {\n    MOBIResult result;\n    MOBIArray *links = array_init(25);\n    if (links == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPart *part = rawml->markup;\n    /* get array of link target offsets */\n    MOBI_RET ret = mobi_get_filepos_array(links, part);\n    if (ret != MOBI_SUCCESS) {\n        array_free(links);\n        return ret;\n    }\n    ret = mobi_get_ncx_filepos_array(links, rawml);\n    if (ret != MOBI_SUCCESS) {\n        array_free(links);\n        return ret;\n    }\n    array_sort(links, true);\n    unsigned char *data_in = part->data;\n    MOBIFragment *first = NULL;\n    MOBIFragment *curr = NULL;\n    size_t new_size = 0;\n    /* build MOBIResult list */\n    result.start = part->data;\n    const unsigned char *data_end = part->data + part->size - 1;\n    while (true) {\n        mobi_search_links_kf7(&result, result.start, data_end);\n        if (result.start == NULL) {\n            break;\n        }\n        char *attribute = (char *) result.value;\n        unsigned char *data_cur = result.start;\n        result.start = result.end;\n        char link[MOBI_ATTRVALUE_MAXSIZE + 1];\n        const char *numbers = \"0123456789\";\n        char *value = strpbrk(attribute, numbers);\n        if (value == NULL) {\n            debug_print(\"Unknown link target: %s\\n\", attribute);\n            continue;\n        }\n        size_t target;\n        switch (attribute[0]) {\n            case 'f':\n                /* filepos=0000000000 */\n                /* replace link with href=\"#0000000000\" */\n                target = strtoul(value, NULL, 10);\n                snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"href=\\\"#%010u\\\"\", (uint32_t)target);\n                break;\n            case 'h':\n            case 'l':\n                data_cur += 2;\n                /* falls through */\n            case 'r':\n                /* (hi|lo)recindex=\"00000\" */\n                /* replace link with src=\"resource00000.ext\" */\n                target = strtoul(value, NULL, 10);\n                if (target > 0) {\n                    target--;\n                }\n                MOBIFiletype filetype = mobi_get_resourcetype_by_uid(rawml, target);\n                MOBIFileMeta filemeta = mobi_get_filemeta_by_type(filetype);\n                snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"src=\\\"resource%05u.%s\\\"\", (uint32_t) target, filemeta.extension);\n                break;\n            default:\n                debug_print(\"Unknown link target: %s\\n\", attribute);\n                continue;\n        }\n        \n        /* first chunk */\n        if (data_cur < data_in) {\n            mobi_list_del_all(first);\n            array_free(links);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (data_cur - data_in);\n        size_t raw_offset = (size_t) (data_in - part->data);\n        curr = mobi_list_add(curr, raw_offset, data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (!first) { first = curr; }\n        new_size += curr->size;\n        /* second chunk */\n        curr = mobi_list_add(curr, SIZE_MAX,\n                             (unsigned char *) strdup(link),\n                             strlen(link), true);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += curr->size;\n        data_in = result.end;\n    }\n    if (first) {\n        /* last chunk */\n        if (part->data + part->size < data_in) {\n            mobi_list_del_all(first);\n            array_free(links);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (part->data + part->size - data_in);\n        size_t raw_offset = (size_t) (data_in - part->data);\n        curr = mobi_list_add(curr, raw_offset, data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += curr->size;\n    } else {\n        /* add whole part as one fragment */\n        first = mobi_list_add(first, 0, part->data, part->size, false);\n        if (first == NULL) {\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += first->size;\n    }\n    /* insert chunks from links array */\n    curr = first;\n    size_t i = 0;\n    while (i < links->size) {\n        const uint32_t offset = links->data[i];\n        char anchor[MOBI_ATTRVALUE_MAXSIZE + 1];\n        snprintf(anchor, MOBI_ATTRVALUE_MAXSIZE + 1, \"<a id=\\\"%010u\\\"></a>\", offset);\n        curr = mobi_list_insert(curr, SIZE_MAX,\n                               (unsigned char *) strdup(anchor),\n                                strlen(anchor), true, offset);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += curr->size;\n        i++;\n    }\n    array_free(links);\n    /* insert dictionary markup if present */\n    if (rawml->orth) {\n        ret = mobi_reconstruct_orth(rawml, first, &new_size);\n        if (ret != MOBI_SUCCESS) {\n            mobi_list_del_all(first);\n            return ret;\n        }\n    }\n    if (first && first->next) {\n        /* save */\n        debug_print(\"Inserting links%s\", \"\\n\");\n        unsigned char *new_data = malloc(new_size);\n        if (new_data == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        unsigned char *data_out = new_data;\n        MOBIFragment *fragdata = first;\n        while (fragdata) {\n            memcpy(data_out, fragdata->fragment, fragdata->size);\n            data_out += fragdata->size;\n            fragdata = mobi_list_del(fragdata);\n        }\n        free(part->data);\n        part->data = new_data;\n        part->size = new_size;\n    } else {\n        mobi_list_del(first);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace offset-links with html-links\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_links(const MOBIRawml *rawml) {\n    debug_print(\"Reconstructing links%s\", \"\\n\");\n    if (rawml == NULL) {\n        debug_print(\"%s\\n\", \"Rawml not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret;\n    if (mobi_is_rawml_kf8(rawml)) {\n        /* kf8 gymnastics */\n        ret = mobi_reconstruct_links_kf8(rawml);\n    } else {\n        /* kf7 format and older */\n        ret = mobi_reconstruct_links_kf7(rawml);\n    }\n    return ret;\n}\n\n/**\n @brief Call callback function for each text record\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @param[in,out] cb Callback function\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_iterate_txtparts(MOBIRawml *rawml, MOBI_RET (*cb) (MOBIPart *)) {\n    MOBIPart *parts[] = {\n        rawml->markup, /* html files */\n        rawml->flow->next /* css, skip first unparsed html part */\n    };\n    size_t i;\n    for (i = 0; i < 2; i++) {\n        MOBIPart *part = parts[i];\n        while (part) {\n            if (part->type == T_HTML || part->type == T_CSS) {\n                MOBI_RET ret = cb(part);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n            part = part->next;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert MOBIPart part data to utf8\n \n @param[in,out] part MOBIPart part\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_markup_to_utf8(MOBIPart *part) {\n    if (part == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    unsigned char *text = part->data;\n    size_t length = part->size;\n    /* extreme case in which each input character is converted\n     to 3-byte utf-8 sequence */\n    size_t out_length = 3 * length + 1;\n    char *out_text = malloc(out_length);\n    if (out_text == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBI_RET ret = mobi_cp1252_to_utf8(out_text, (const char *) text, &out_length, length);\n    free(text);\n    if (ret != MOBI_SUCCESS || out_length == 0) {\n        debug_print(\"%s\", \"conversion from cp1252 to utf8 failed\\n\");\n        free(out_text);\n        part->data = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    text = malloc(out_length);\n    if (text == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        free(out_text);\n        part->data = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    memcpy(text, out_text, out_length);\n    free(out_text);\n    part->data = text;\n    part->size = out_length;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Strip unneeded tags from html. Currently only <aid\\>\n \n @param[in,out] part MOBIPart structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_strip_mobitags(MOBIPart *part) {\n    if (part == NULL || part->data == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    if (part->type != T_HTML) {\n        return MOBI_SUCCESS;\n    }\n    MOBIResult result;\n    unsigned char *data_in = part->data;\n    result.start = part->data;\n    const unsigned char *data_end = part->data + part->size - 1;\n    MOBIFragment *first = NULL;\n    MOBIFragment *curr = NULL;\n    size_t part_size = 0;\n    while (true) {\n        mobi_find_attrname(&result, result.start, data_end, \"aid\");\n        if (result.start == NULL) {\n            break;\n        }\n        unsigned char *data_cur = result.start;\n        result.start = result.end;\n        if (data_cur < data_in) {\n            mobi_list_del_all(first);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (data_cur - data_in);\n        /* first chunk */\n        curr = mobi_list_add(curr, (size_t) (data_in - part->data ), data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (!first) { first = curr; }\n        part_size += curr->size;\n        data_in = result.end;\n    }\n    if (first) {\n        /* last chunk */\n        if (part->data + part->size < data_in) {\n            mobi_list_del_all(first);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (part->data + part->size - data_in);\n        curr = mobi_list_add(curr, (size_t) (data_in - part->data ), data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        part_size += curr->size;\n        \n        unsigned char *new_data = malloc(part_size);\n        if (new_data == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        unsigned char *data_out = new_data;\n        while (first) {\n            memcpy(data_out, first->fragment, first->size);\n            data_out += first->size;\n            first = mobi_list_del(first);\n        }\n        free(part->data);\n        part->data = new_data;\n        part->size = part_size;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse raw records into html flow parts, markup parts, resources and indices\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @param[in] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_rawml(MOBIRawml *rawml, const MOBIData *m) {\n    return mobi_parse_rawml_opt(rawml, m, true, true, true);\n}\n\n/**\n @brief Parse raw records into html flow parts, markup parts, resources and indices.\n        Individual stages of the parsing may be turned on/off.\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @param[in] m MOBIData structure\n @param[in] parse_toc bool Parse content indices if true\n @param[in] parse_dict bool Parse dictionary indices if true\n @param[in] reconstruct bool Recounstruct links, build opf, strip mobi-specific tags if true\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_rawml_opt(MOBIRawml *rawml, const MOBIData *m, bool parse_toc, bool parse_dict, bool reconstruct) {\n    \n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (rawml == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    \n    /* Get maximal size of text data */\n    const size_t maxlen = mobi_get_text_maxsize(m);\n    if (maxlen == MOBI_NOTSET) {\n        debug_print(\"%s\", \"Insane text length\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    char *text = malloc(maxlen + 1);\n    if (text == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* Extract text records, unpack, merge and copy it to text string */\n    size_t length = maxlen;\n    ret = mobi_get_rawml(m, text, &length);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"Error parsing text\\n\");\n        free(text);\n        return ret;\n    }\n    \n    if (mobi_exists_fdst(m)) {\n        /* Skip parsing if section count less or equal than 1 */\n        if (m->mh->fdst_section_count && *m->mh->fdst_section_count > 1) {\n            ret = mobi_parse_fdst(m, rawml);\n            if (ret != MOBI_SUCCESS) {\n                free(text);\n                return ret;\n            }\n        }\n    }\n    ret = mobi_reconstruct_flow(rawml, text, length);\n    free(text);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_reconstruct_resources(m, rawml);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    const size_t offset = mobi_get_kf8offset(m);\n    /* skeleton index */\n    if (mobi_exists_skel_indx(m) && mobi_exists_frag_indx(m)) {\n        const size_t indx_record_number = *m->mh->skeleton_index + offset;\n        /* to be freed in mobi_free_rawml */\n        MOBIIndx *skel_meta = mobi_init_indx();\n        ret = mobi_parse_index(m, skel_meta, indx_record_number);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        rawml->skel = skel_meta;\n    }\n    \n    /* fragment index */\n    if (mobi_exists_frag_indx(m)) {\n        MOBIIndx *frag_meta = mobi_init_indx();\n        const size_t indx_record_number = *m->mh->fragment_index + offset;\n        ret = mobi_parse_index(m, frag_meta, indx_record_number);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        rawml->frag = frag_meta;\n    }\n    \n    if (parse_toc) {\n        /* guide index */\n        if (mobi_exists_guide_indx(m)) {\n            MOBIIndx *guide_meta = mobi_init_indx();\n            const size_t indx_record_number = *m->mh->guide_index + offset;\n            ret = mobi_parse_index(m, guide_meta, indx_record_number);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            rawml->guide = guide_meta;\n        }\n        \n        /* ncx index */\n        if (mobi_exists_ncx(m)) {\n            MOBIIndx *ncx_meta = mobi_init_indx();\n            const size_t indx_record_number = *m->mh->ncx_index + offset;\n            ret = mobi_parse_index(m, ncx_meta, indx_record_number);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            rawml->ncx = ncx_meta;\n        }\n    }\n    \n    if (parse_dict && mobi_is_dictionary(m)) {\n        /* orth */\n        MOBIIndx *orth_meta = mobi_init_indx();\n        size_t indx_record_number = *m->mh->orth_index + offset;\n        ret = mobi_parse_index(m, orth_meta, indx_record_number);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        rawml->orth = orth_meta;\n        /* infl */\n        if (mobi_exists_infl(m)) {\n            MOBIIndx *infl_meta = mobi_init_indx();\n            indx_record_number = *m->mh->infl_index + offset;\n            ret = mobi_parse_index(m, infl_meta, indx_record_number);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            rawml->infl = infl_meta;\n        }\n    }\n    \n    ret = mobi_reconstruct_parts(rawml);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (reconstruct) {\n#ifdef USE_XMLWRITER\n        ret = mobi_build_opf(rawml, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n#endif\n        ret = mobi_reconstruct_links(rawml);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        if (mobi_is_kf8(m)) {\n            debug_print(\"Stripping unneeded tags%s\", \"\\n\");\n            ret = mobi_iterate_txtparts(rawml, mobi_strip_mobitags);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n        }\n\n    }\n    if (mobi_is_cp1252(m)) {\n        debug_print(\"Converting cp1252 to utf8%s\", \"\\n\");\n        ret = mobi_iterate_txtparts(rawml, mobi_markup_to_utf8);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n"], "fixing_code": ["2022-05-03: Fix boundary checking error in markup search, that could cause buffer over-read with corrupt input\n2022-05-02: Fix typo in macro name\n2022-04-27: Fix undefined behavior when passing null to strdup\n2022-04-27: Fix wrong boundary checks in inflections parser resulting in stack buffer over-read with corrupt input\n2022-04-26: Fix text formatting\n2022-04-26: Fix array boundary check when parsing inflections which could result in buffer over-read with corrupt input\n2022-04-23: Fix formatting\n2022-04-23: Fix checking boundary of deobfuscation key which could cause buffer over-read with corrupt data\n2022-04-23: Fix issue with corrupt data with empty lookup string which could lead to read beyond buffer\n2022-04-23: Fix faulty checks for array boundary which caused buffer over-read with corrupt input\n2022-04-23: Fix issue with corrupt files with tagvalues_count = 0 that caused null pointer dereference\n2022-04-23: Fix issues when mobi_buffer_getpointer returns null. With corrupt data this could lead to out-of-bounds read\n2022-04-13: Add packaging status [skip ci]\n2022-04-10: Make random generation return proper error codes\n2022-04-10: Rewrite randombytes for libmobi\n2022-04-07: Add libsodium randombytes.c\n2022-04-10: Fix \"fallthrough\" spelling\n2022-04-10: Make declaration match definition\n2022-04-10: Fix different sign comparison warning\n2022-04-10: Update Xcode project\n2022-04-10: Don't run tests if bash is missing\n2022-04-10: Looking for libxml2, first try pkg-config\n2022-04-04: Update MSVC project\n2022-04-02: Add support for GNU/kFreeBSD and GNU/Hurd\n2022-04-02: Check for inline, noreturn support in CMake\n2022-03-27: Fix format truncation warning\n2022-03-21: Version 0.10\n2022-03-21: Update Xcode project [skip ci]\n2022-03-21: Add functions for retrieving orthographic index entries\n2022-02-27: Add basic CMake support\n2022-02-26: GHA: fetch tags with checkout\n2022-02-26: Minor refactoring of file path manipulation function\n2022-02-26: Fix memory handling issues\n2022-02-26: Add coverity scan workflow\n2022-02-25: Remove obsolete changelog\n2022-02-25: Fix md5sum output on Windows\n2022-02-25: Fix inconsistent separators in path on Windows builds\n2022-02-25: GHA: fix log paths\n2022-02-25: GHA: fix workflow syntax\n2022-02-25: GHA: upload test logs on failure\n2022-02-24: Fix printf format specifier\n2022-02-24: Fix sample path in Makefile\n2022-02-24: Missing autotools in mingw workflow\n2022-02-24: Windows doesn't accept asterisk in file names\n2022-02-24: Update workflow, add badge\n2022-02-24: Add mingw workflow\n2022-02-24: Fix tests in out-of-tree build\n2022-02-24: Update man pages\n2022-02-24: Replace non-portable strptime\n2022-02-24: Make sure both validity period dates are set\n2022-02-21: Fix strptime not found on linux build\n2022-02-21: Add build github action\n2022-02-21: Update README\n2022-02-21: Minor code cleanups\n2022-02-21: Unify boolean and static usage in tools\n2022-02-21: mobimeta: fix null pointer dereference when parsing malformed option\n2022-02-18: Add  hybrid spit option to mobitool\n2022-02-18: Update documentation\n2022-02-18: Test both encrypted hybrid parts\n2022-02-18: Fix: fast decryption routine fails for non-huffman compression\n2022-02-18: Fix mobitool serial decryption\n2022-02-18: Add DRM tests\n2022-02-17: Fix build with encryption disabled\n2022-02-17: Update tests samples\n2022-02-16: Add -h option to tools, update man pages\n2022-02-16: Update Xcode settings\n2022-02-16: Restructure, cleanup encryption related code, add mobidrm tool\n2021-11-19: Improve getopt loop, fix config.h to be accessible from all tools\n2021-11-10: Update xcode project\n2021-11-10: Add functions to split hybrid files\n2021-11-10: Avoid modifying existing records, as caller may keep reference to them\n2021-11-05: Fix: tests fail if pid contains asterisk\n2021-11-05: Fix: decryption may fail for some records with standard compression\n2021-11-05: Replace test samples with self-generated smaller ones\n2021-11-05: Skip test in case of missing checksums\n2021-10-20: Version 0.9\n2021-10-24: Fix out-of-tree build\n2021-10-22: Fix mingw build, code formatting\n2021-10-14: Fix gcc format truncation warning\n2021-10-14: Include autogen.sh in distribution bundle\n2021-10-14: Create codeql-analysis.yml\n2021-10-14: Fix autoconf 2.70 warnings, clean up\n2021-10-14: Build fails with autoconf 2.70\n2021-10-11: Version 0.8\n2021-10-11: Update Xcode project\n2021-10-11: Fix warnings about changed signedness\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #38\n2021-09-18: Fix potential out-of-buffer read while parsing corrupt file, closes #35, #36\n2021-09-09: Version 0.7\n2021-09-09: fix oob write bug inside libmobi\n2021-06-07: Add reference to brew formula\n2020-09-02: Fix null pointer dereference in case of broken fragment\n2020-08-01: Update changelog\n2020-08-01: Version 0.6\n2020-07-31: Fix typo\n2020-07-31: Add Readme to dist package\n2020-07-31: Remove anchor on truncated link\n2020-07-31: Fix missing option in man page\n2020-07-30: Include test samples in dist package\n2020-07-25: Fix gcc 7+ warnings about implicit fall through and format truncation\n2020-07-24: Unique names for internal functions to avoid confilicts with static linking\n2020-06-24: Close file in error branch\n2020-06-24: Fix static compilation with miniz on gcc\n2020-06-24: Minor documentation fixes\n2020-06-23: Version 0.5\n2020-06-23: mobitool: add dump cover option\n2020-06-23: Minor documentation improvement\n2020-06-23: Fix potential buffer over-read\n2019-03-18: Fix: try also \"name\" attribute when searching for link anchor tags, closes #24\n2019-02-22: Add mobi_is_replica function\n2019-02-22: Fix potential read beyond buffer\n2019-02-22: Travis migration\n2018-08-07: Fix: missing items in recreated ncx file\n2018-06-20: Fix: printf format warning on some gcc versions\n2018-06-20: Fix: make dist broken by nonexistent header files\n2018-06-20: VERSION 0.4\n2018-06-20: Fix: buffer overflow (CVE-2018-11726)\n2018-06-20: Fix: buffer overflow (CVE-2018-11724)\n2018-06-20: Fix: read beyond buffer (CVE-2018-11725)\n2018-06-20: Fix: buffer overflow (mobitool), closes #18\n2018-06-20: Fix: read beyond buffer with corrupted KF8 Boundary record, closes #19\n2018-06-20: Fix: read beyond buffer, closes #16, #17\n2018-06-20: Updated xcode project files\n2018-04-03: Fix: ncx part was not scanned for links, fixes #12\n2018-04-02: Fix regression, potential use after free\n2018-04-02: Skip broken resources, fixes #10\n2018-03-05: Allow processing zero length text records, fixes #9\n2017-12-25: Skip broken first resource offset instead of dying\n2017-12-18: Skip broken links reconstruction instead of dying\n2017-11-27: Disable travis OS X builds, as they usually time out\n2017-11-16: Fix: increase max number of dictionary entries per record\n2017-11-14: Fix for some encrypted documents with palmdoc encoding\n2017-11-06: Fix: potential null pointer dereference\n2017-10-16: Manpage cleanup\n2017-09-27: Update README\n2017-09-26: Increase maximum length of attribute name and value, closes #5\n2017-02-26: Remove obsolete files from VS build (closes #3) [ci skip]\n2016-11-05: Mobitool: use epub extension if extracted source resource is epub\n2016-06-10: Update docs\n2016-06-10: Update test files\n2016-06-10: Fix: out of bounds read in corrupt font resource\n2016-06-10: Prevent memory leak in case of corrupt font resources\n2016-06-10: Calculate deobfuscation buffer limit from key length\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-10: Fix: USE_LIBXML2 macro was not included from config.h\n2016-06-09: Fix: memory leak in tools\n2016-06-09: Fix: potential out of bounds read\n2016-06-09: Fix: memory leak in internal xmlwriter\n2016-06-01: Update README\n2016-05-19: Feature: verify decryption key type\n2016-05-19: Cleanup converting little endian buffer to 32-bit integer\n2016-05-19: Feature: check drm expiration dates\n2016-05-18: Fix: memory leaks in encryption\n2016-05-18: Fix concurrent autotools builds\n2016-05-18: use relative path, as $(top_srcdir) fails to be substituted (?)\n2016-05-18: update vcxproj\n2016-05-18: Include headers in automake sources\n2016-05-18: Fix: automake out-of-tree miniz build\n2016-05-18: Fix: wrongly detected fdst record broke some ancient documents\n2016-05-18: Fix: improve index header parsing, some old dictionaries might not load\n2016-05-18: Fix: convert encoding of opf strings from cp1252 indices\n2016-05-18: Quiet warnings about unused values of wiped variables\n2016-05-18: Fix: potential memory leak\n2016-05-18: Fix: wrongly decoded \"&copy;\" entity\n2016-05-16: Fix: huffdic decompression fails in case of huge documents\n2016-05-14: Simplify buffer_init_null() function\n2016-05-14: Use ARRAYSIZE macro\n2016-05-14: Feature: calculate pid for decryption from device serial number\n2016-04-29: Use endian-independent byte swapping\n2016-04-29: Exclude unused miniz functions from binary\n2016-04-29: Add SHA-1 routines\n2016-04-27: Fix miniz.c formatting\n2016-04-27: Documentation\n2016-04-20: Update changelog\n2016-04-20: Fix potential null pointer dereference\n2016-04-20: Remove useless check\n2016-04-20: Fix text record size calculation\n2016-04-20: Fix buffer checking and freeing\n2016-04-19: Update docs\n2016-04-19: Update ChangeLog\n2016-04-19: Fix comparison between signed and unsigned integer\n2016-04-19: use strdup on linux/glibc\n2016-04-19: Add initial write and metadata editing support. Add mobimeta tool.\n2016-04-19: Always check whether memory allocation succeeded\n2016-04-18: Fix: guarantee array resize step is at least 1\n2016-04-13: Workaround to read some old mobipocket files\n2016-04-13: Improve pdb dates resolving\n2016-04-07: Minor documentation edit\n2016-04-07: Update changelog\n2016-04-06: Fix format warning\n2016-04-06: Update test checksums\n2016-04-06: Fix: <dc:date> \"event\" attribute needs \"opf\" namespace\n2016-04-06: Fix: id attributes in ncx file should be unique\n2016-04-06: Store full name in MOBIMobiHeader structure\n2016-04-05: Fix formatting\n2016-04-05: Fix signedness warning\n2016-04-04: Fix potential buffer overflow, closes #2\n2016-04-04: Fix potential null pointer dereference\n2016-03-23: Fix signedness warnings\n2016-03-22: Fix: _mkdir needs direct.h on MinGW\n2016-03-22: Fix tests on Windows\n2016-03-22: Fix: palmdoc decompression may fail with zero byte in input buffer\n2016-03-21: VERSION 03: internal xmlwriter, metadata handling functions, bug fixes\n2016-03-21: Feature: add helper functions for metadata extraction\n2016-03-21: Load also kf8 data when only kf7 version is requested\n2016-03-21: Fix: wrong exth header length check could discard some valid headers\n2016-03-20: Get rid of extended attributes in release archive on OS X\n2016-03-19: Mobitool: add descriptive error messages based on libmobi return codes\n2016-03-04: Add extra length check for CMET record extraction\n2016-03-04: Always check buffer allocation result\n2016-03-04: Add functions to extract conversion source and log, also add this feature to mobitool\n2016-03-04: Remove some stray printfs\n2016-03-03: Remove not used AC_FUNC_MALLOC/REALLOC macros that break cross-compilation\n2016-03-03: Fix potential illegal memory access in miniz.c\n2016-03-03: Fix potential dereference of null pointer in miniz.c\n2016-03-03: Fix for Android bionic libc bug (SIZE_MAX missing in stdint.h)\n2016-03-03: Fix mobitool compilation on MSVC++\n2016-03-03: Add EPUB creation feature to mobitool\n2016-03-02: Fix potential buffer overflow, null pointer dereference\n2016-03-02: Add travis test for no-external-dependency build\n2016-03-02: Fix missing strdup on linux\n2016-03-02: Add internal xmlwriter (as an alternative to libxml2)\n2016-03-01: Feature: decode html entities in exth header strings\n2016-02-29: Fix: potential buffer overflow\n2016-02-29: Fix: wrong pid calculation (regression introduced in 0.2)\n2016-02-26: VERSION 0.2: increased stability, lots of bugs fixed\n2016-02-26: Add Xcode project file\n2016-02-26: Preliminary support for MSVC++ compiler\n2016-02-26: Do not use variable length arrays\n2016-02-26: Refactor mobi_reconstruct_parts() to use MOBIFragment list\n2016-02-26: Fix compiler warning about sign conversion\n2016-02-26: Fix compiler warning about type conversion\n2016-02-26: Check the result of malloc/calloc\n2016-02-26: Fix inconsistent use of const between some definitions and declarations\n2016-02-24: Fix inconsistence between function declaration and definition\n2016-02-24: Fix various potential crashes in case of corrupt input (afl-fuzz)\n2016-02-24: Fix dead code warnings in miniz\n2015-11-26: Export mobi_get_first_resource_record() function\n2015-11-26: Fix: double free on corrupt cdic\n2015-11-02: Update docs\n2015-11-02: Feature: add helper functions to find resources by flow id\n2015-11-02: Feature: export MOBI_NOTSET macro\n2015-11-02: Feature: give more options to parse rawml function\n2015-10-24: Restore travis.yml\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix OSX travis build\n2015-10-24: Fix multiline inline script\n2015-10-24: Enable multi-OS feature\n2015-10-24: Fix: unique temporary name for parallel tests\n2015-10-24: Fix: decoding video resources falsely reported as failed\n2015-10-24: Fix: tests, some md5sum implementations insert double spaces\n2015-10-24: Fix for automake < 1.13\n2015-10-23: Add simple tests framework\n2015-10-23: Fix: increase max index entries per record count, as some rare samples fail\n2015-10-22: Fix: incorrectly decoded video/audio resources\n2015-10-22: Feature: add option to specify output path\n2015-10-14: Add some internal functions to public API: mobi_get_flow_by_uid, mobi_get_resource_by_uid, mobi_get_part_by_uid, mobi_get_exthrecord_by_tag\n2015-06-13: update changelog\n2015-06-13: fix: various invalid memory access\n2015-06-13: don't quit on invalid input, instead substitute with replacement character\n2015-06-12: fix typo\n2015-06-12: update changelog\n2015-06-12: fix: reconstruction failed when there were gaps between fragments\n2015-06-12: add EXTH tags\n2015-06-12: prevent return of garbage value check return value in case of failed malloc\n2015-06-12: fix invalid memory access\n2015-04-12: Fix reconstruction of \"kindle:embed\" links without mime type (regression)\n2015-04-12: Add sanity checks to link reconstruction functions, allow skipping some malformed patterns\n2015-04-12: Fix infinite loop in guide build while unknown tag was found\n2015-04-12: Increase max recursion level for huffman decompression\n2015-03-28: update docs\n2015-03-28: fix solaris studio compiler warnings\n2015-03-28: fix solaris studio compiler build\n2015-02-18: Fix \"more than one: -compatibility_version specified\" error on powerpc\n2014-11-24: improve docs\n2014-11-24: simplify public header\n2014-11-21: changelog update [ci skip]\n2014-11-21: README\n2014-11-21: fix: add sanity checks\n2014-11-21: Fix: add sanity checks\n2014-11-21: add sanity check to huffcdic indices count\n2014-11-21: fix number of leaks and other minor issues (by coverity scan)\n2014-11-20: missing notification email kills coverity scan\n2014-11-20: update travis.yml\n2014-11-20: upgrade travis.ml with covert scan\n2014-11-20: update README.md\n2014-11-20: add .travis.yml\n2014-11-20: update REAME.md\n2014-11-20: update README.md\n2014-11-20: update docs\n2014-11-20: feature: add decryption support\n2014-11-20: mkdir cleanup\n2014-11-17: documentation\n2014-11-17: strip unneeded <aid/> tags\n2014-11-16: fix: potential leak\n2014-11-16: fix: regression, some image tags were not reconstructed\n2014-11-16: fix: improve ligatures handling\n2014-11-16: override darwin linker default versioning\n2014-11-15: fix: get proper LIGT entries count from index header\n2014-11-15: feature: unpack records into new folder\n2014-11-14: make README readable on github\n2014-11-14: add README for mobitool\n2014-11-14: fix: dictionaries with large inflection rules failed\n2014-11-14: feature: support encoded ligatures in index entry labels\n2014-11-14: readme\n2014-11-14: update changelog\n2014-11-13: feature: support for older inflections scheme\n2014-11-13: bug: files with short tagx header won't open\n2014-11-13: cleanup unneeded include\n2014-11-13: use strdup on linux/glibc\n2014-11-13: debugging cleanup\n2014-11-13: reorganize source files\n2014-11-13: use strdup on linux/glibc\n2014-11-11: update changelog\n2014-11-11: update changeling\n2014-11-11: fix: documents with text record size > 4096 failed to load\n2014-11-11: add: function to decode flat index entries\n2014-11-11: debug: add functions for debugging indices\n2014-11-11: cleanup\n2014-11-11: fix: variable length value wrongly calculated when going backwards\n2014-11-08: update documentation\n2014-11-08: update changelog\n2014-11-08: add support for reconstructing inflections index entries\n2014-11-08: parsing of exth header failed in some cases\n2014-11-08: fix: some links reconstruction in kf7 failed\n2014-11-08: improve debug info\n2014-11-08: failed malloc false reports\n2014-11-03: fix problem with uncompressed documents\n2014-11-03: fix broken locales\n2014-11-03: remove obsolete includes\n2014-11-03: git log > changelog\n2014-11-03: improved buffer handling\n2014-11-03: improved OPF for dictionaries\n2014-11-03: proper rawml->orth initialization and freeing\n2014-11-03: fix subject field in opf\n2014-11-03: handle UTF-16 surrogates, make ORDT lookups locale independent\n2014-11-01: move dict reconstruction to separate function\n2014-11-01: cleanup\n2014-11-01: quiet gcc warning on printf format\n2014-11-01: reconstruction of orth dictionary entries\n2014-09-27: use mobi_list_del_all()\n2014-09-25: postpone conversion to utf8 after all source reconstructions\n2014-09-24: comment\n2014-09-24: comments\n2014-09-12: doxygen comment\n2014-09-12: data size in comment\n2014-09-05: MOBIArray data type fix\n2014-09-05: config.h fixes\n2014-06-29: merge master\n2014-04-11: initial commit", "/** @file parse_rawml.c\n *  @brief Functions for parsing rawml markup\n *\n * Copyright (c) 2020 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#define _GNU_SOURCE 1\n#ifndef __USE_BSD\n#define __USE_BSD /* for strdup on linux/glibc */\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"parse_rawml.h\"\n#include \"util.h\"\n#include \"opf.h\"\n#include \"structure.h\"\n#include \"index.h\"\n#include \"debug.h\"\n#if defined(__BIONIC__) && !defined(SIZE_MAX)\n#include <limits.h> /* for SIZE_MAX */\n#endif\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to offset in rawml raw text file\n \n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off Y value of off:y\n @return Offset in rawml buffer on success, SIZE_MAX otherwise\n */\nsize_t mobi_get_rawlink_location(const MOBIRawml *rawml, const uint32_t pos_fid, const uint32_t pos_off) {\n    if (!rawml || !rawml->frag || !rawml->frag->entries ) {\n        debug_print(\"%s\", \"Initialization failed\\n\");\n        return SIZE_MAX;\n    }\n    if (pos_fid >= rawml->frag->entries_count) {\n        debug_print(\"%s\", \"pos_fid not found\\n\");\n        return SIZE_MAX;\n    }\n    const MOBIIndexEntry *entry = &rawml->frag->entries[pos_fid];\n    const size_t insert_position = strtoul(entry->label, NULL, 10);\n    size_t file_offset = insert_position + pos_off;\n    return file_offset;\n}\n\n/**\n @brief Find first occurence of attribute to be replaced in KF7 html\n \n It searches for filepos and recindex attributes\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                /* found match */\n                if (last_border != tag_open) {\n                    /* opening char not found, not an attribute */\n                    data += needle_length;\n                    continue;\n                }\n                /* go to attribute  beginning */\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                /* now go forward */\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (data <= data_end && *(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Find first occurence of markup attribute with given value\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @param[in] type Type of data (T_HTML or T_CSS)\n @param[in] needle String to find (len <= MOBI_ATTRNAME_MAXSIZE)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            /* found match */\n            if (last_border != tag_open) {\n                /* opening char not found, not an attribute */\n                data += needle_length;\n                continue;\n            }\n            /* go to attribute value beginning */\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            /* now go forward */\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            /* self closing tag '/>' */\n            if (data <= data_end && *(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Find first occurence of markup attribute with given name\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @param[in] attrname String to find (len < MOBI_ATTRNAME_MAXSIZE)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_find_attrname(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const char *attrname) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    char needle[MOBI_ATTRNAME_MAXSIZE + 1];\n    snprintf(needle, MOBI_ATTRNAME_MAXSIZE + 1, \"%s=\", attrname);\n    size_t needle_length = strlen(needle);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char quote = '\"';\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length + 2 <= data_end && memcmp(data, needle, needle_length) == 0) {\n            /* found match */\n            if (last_border != tag_open) {\n                /* opening char not found, not an attribute */\n                data += needle_length;\n                continue;\n            }\n            /* go to attribute name beginning */\n            if (data > data_start) {\n                data--;\n                if (!isspace(*data) && *data != tag_open) {\n                    /* wrong name */\n                    data += needle_length;\n                    continue;\n                }\n            }\n            result->start = ++data;\n            /* now go forward */\n            data += needle_length;\n            if (*data++ != quote) {\n                /* not well formed attribute */\n                result->start = NULL;\n                continue;\n            }\n            while (data <= data_end) {\n                if (*data == quote) {\n                    result->end = ++data;\n                    return MOBI_SUCCESS;\n                }\n                data++;\n            }\n            result->start = NULL;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Find first occurence of attribute part to be replaced in KF8 html/css\n \n It searches for \"kindle:\" value in attributes\n \n @param[in,out] result MOBIResult structure will be filled with found data\n @param[in] data_start Beginning of the memory area to search in\n @param[in] data_end End of the memory area to search in\n @param[in] type Type of data (T_HTML or T_CSS)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_search_links_kf8(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type) {\n    return mobi_find_attrvalue(result, data_start, data_end, type, \"kindle:\");\n}\n\n/**\n @brief Get value and offset of the first found attribute with given name\n \n @param[in,out] value String value of the attribute, will be filled by the function, zero length if not found\n @param[in] data Data to search in\n @param[in] size Data size\n @param[in] attribute Attribute name\n @param[in] only_quoted Require the value to be quoted if true, allow no quotes (eg. filepos=00001) if false\n @return Offset from the beginning of the data, SIZE_MAX if not found\n */\nsize_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    /* FIXME: this function could be replaced by mobi_find_attrvalue()? */\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    /* FIXME: search may start inside tag, so it is a safer option */\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            /* found match */\n            size_t offset = size - length;\n            if (last_border == '>') {\n                /* We are in tag contents */\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            /* previous character should be white space or opening tag */\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            /* now go forward */\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            /* self closing tag '/>' */\n            if (length && *(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            /* return offset to the beginning of the attribute value string */\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}\n\n/**\n @brief Get offset of the given value of an \"aid\" attribute in a given part\n \n @param[in] aid String value of \"aid\" attribute\n @param[in] html MOBIPart html part\n @return Offset from the beginning of the html part data, SIZE_MAX on failure\n */\nsize_t mobi_get_aid_offset(const MOBIPart *html, const char *aid) {\n    size_t length = html->size;\n    const char *data = (char *) html->data;\n    const size_t aid_length = strlen(aid);\n    const size_t attr_length = 5; /* \"aid='\" length */\n    do {\n        if (length > (aid_length + attr_length) && memcmp(data, \"aid=\", attr_length - 1) == 0) {\n            data += attr_length;\n            length -= attr_length;\n            if (memcmp(data, aid, aid_length) == 0) {\n                if (data[aid_length] == '\\'' || data[aid_length] == '\"') {\n                    return html->size - length;\n                }\n            }\n        }\n        data++;\n    } while (--length);\n    return SIZE_MAX;\n}\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to skeleton part number and offset from the beginning of the part\n \n @param[in,out] file_number Will be set to file number value\n @param[in,out] offset Offset from the beginning of the skeleton part\n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off X value of pos:off:x\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_offset_by_posoff(uint32_t *file_number, size_t *offset, const MOBIRawml *rawml, const size_t pos_fid, const size_t pos_off) {\n    if (!rawml || !rawml->frag || !rawml->frag->entries ||\n        !rawml->skel || !rawml->skel->entries) {\n        debug_print(\"%s\", \"Initialization failed\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret;\n    if (pos_fid >= rawml->frag->entries_count) {\n        debug_print(\"Entry for pos:fid:%zu doesn't exist\\n\", pos_fid);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIIndexEntry entry = rawml->frag->entries[pos_fid];\n    *offset = strtoul(entry.label, NULL, 10);\n    uint32_t file_nr;\n    ret = mobi_get_indxentry_tagvalue(&file_nr, &entry, INDX_TAG_FRAG_FILE_NR);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (file_nr >= rawml->skel->entries_count) {\n        debug_print(\"Entry for skeleton part no %u doesn't exist\\n\", file_nr);\n        return MOBI_DATA_CORRUPT;\n        \n    }\n    const MOBIIndexEntry skel_entry = rawml->skel->entries[file_nr];\n    uint32_t skel_position;\n    ret = mobi_get_indxentry_tagvalue(&skel_position, &skel_entry, INDX_TAG_SKEL_POSITION);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    *offset -= skel_position;\n    *offset += pos_off;\n    *file_number = file_nr;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get value of the closest \"aid\" attribute following given offset in a given part\n \n @param[in,out] aid String value of \"aid\" attribute\n @param[in] html MOBIPart html part\n @param[in] offset Offset from the beginning of the part data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_aid_by_offset(char *aid, const MOBIPart *html, const size_t offset) {\n    if (!aid || !html) {\n        debug_print(\"Parameter error (aid (%p), html (%p)\\n\", (void *) aid, (void *) html);\n        return MOBI_PARAM_ERR;\n    }\n    if (offset > html->size) {\n        debug_print(\"Parameter error: offset (%zu) > part size (%zu)\\n\", offset, html->size);\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *data = html->data;\n    data += offset;\n    size_t length = html->size - offset;\n    \n    size_t off = mobi_get_attribute_value(aid, data, length, \"aid\", true);\n    if (off == SIZE_MAX) {\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get value of the closest \"id\" or \"name\" attribute following given offset in a given part\n \n @param[in,out] id String value of found attribute\n @param[in] html MOBIPart html part\n @param[in] offset Offset from the beginning of the part data\n @param[in,out] pref_attr Preferred attribute to link to (id or name)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_id_by_offset(char *id, const MOBIPart *html, const size_t offset, MOBIAttrType *pref_attr) {\n    if (!id || !html) {\n        debug_print(\"Parameter error (id (%p), html (%p)\\n\", (void *) id, (void *) html);\n        return MOBI_PARAM_ERR;\n    }\n    if (offset > html->size) {\n        debug_print(\"Parameter error: offset (%zu) > part size (%zu)\\n\", offset, html->size);\n        return MOBI_PARAM_ERR;\n    }\n    const unsigned char *data = html->data;\n    data += offset;\n    size_t length = html->size - offset;\n    static const char * attributes[] = {\n        [ATTR_ID] = \"id\",\n        [ATTR_NAME] = \"name\",\n    };\n    size_t off = mobi_get_attribute_value(id, data, length, attributes[*pref_attr], true);\n    if (off == SIZE_MAX) {\n        // try optional attribute\n        const MOBIAttrType opt_attr = (*pref_attr == ATTR_ID) ? ATTR_NAME : ATTR_ID;\n        off = mobi_get_attribute_value(id, data, length, attributes[opt_attr], true);\n        if (off == SIZE_MAX) {\n            id[0] = '\\0';\n        } else {\n            // save optional attribute as preferred\n            *pref_attr = opt_attr;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to html file number and closest \"aid\" attribute following the position\n \n @param[in,out] file_number Will be set to file number value\n @param[in,out] aid String value of \"aid\" attribute\n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off Y value of off:y\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_aid_by_posoff(uint32_t *file_number, char *aid, const MOBIRawml *rawml, const size_t pos_fid, const size_t pos_off) {\n    size_t offset;\n    MOBI_RET ret = mobi_get_offset_by_posoff(file_number, &offset, rawml, pos_fid, pos_off);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPart *html = mobi_get_part_by_uid(rawml, *file_number);\n    if (html == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_get_aid_by_offset(aid, html, offset);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert kindle:pos:fid:x:off:y to html file number and closest \"id\" attribute following the position\n \n @param[in,out] file_number Will be set to file number value\n @param[in,out] id String value of \"id\" attribute\n @param[in] rawml MOBIRawml parsed records structure\n @param[in] pos_fid X value of pos:fid:x\n @param[in] pos_off Y value of off:y\n @param[in,out] pref_attr Attribute to link to\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_id_by_posoff(uint32_t *file_number, char *id, const MOBIRawml *rawml, const size_t pos_fid, const size_t pos_off, MOBIAttrType *pref_attr) {\n    size_t offset;\n    MOBI_RET ret = mobi_get_offset_by_posoff(file_number, &offset, rawml, pos_fid, pos_off);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPart *html = mobi_get_part_by_uid(rawml, *file_number);\n    if (html == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_get_id_by_offset(id, html, offset, pref_attr);\n    if (ret != MOBI_SUCCESS) {\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse resource records (images, fonts etc), determine their type, link to rawml\n \n @param[in] m MOBIData structure with loaded Record(s) 0 headers\n @param[in,out] rawml Structure rawml->resources will be filled with parsed resources metadata and linked records data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_resources(const MOBIData *m, MOBIRawml *rawml) {\n    size_t first_res_seqnumber = mobi_get_first_resource_record(m);\n    if (first_res_seqnumber == MOBI_NOTSET) {\n        /* search all records */\n        first_res_seqnumber = 0;\n    }\n    const MOBIPdbRecord *curr_record = mobi_get_record_by_seqnumber(m, first_res_seqnumber);\n    if (curr_record == NULL) {\n        debug_print(\"First resource record not found at %zu, skipping resources\\n\", first_res_seqnumber);\n        return MOBI_SUCCESS;\n    }\n    size_t i = 0;\n    MOBIPart *head = NULL;\n    while (curr_record != NULL) {\n        const MOBIFiletype filetype = mobi_determine_resource_type(curr_record);\n        if (filetype == T_UNKNOWN) {\n            curr_record = curr_record->next;\n            i++;\n            continue;\n        }\n        if (filetype == T_BREAK) {\n            break;\n        }\n        \n        MOBIPart *curr_part = calloc(1, sizeof(MOBIPart));;\n        if (curr_part == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation for flow part failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        curr_part->data = curr_record->data;\n        curr_part->size = curr_record->size;\n        curr_part->uid = i++;\n        curr_part->next = NULL;\n        \n        MOBI_RET ret = MOBI_SUCCESS;\n        if (filetype == T_FONT) {\n            ret = mobi_add_font_resource(curr_part);\n            if (ret != MOBI_SUCCESS) {\n                debug_print(\"%s\\n\", \"Decoding font resource failed\");\n            }\n        } else if (filetype == T_AUDIO) {\n            ret = mobi_add_audio_resource(curr_part);\n            if (ret != MOBI_SUCCESS) {\n                debug_print(\"%s\\n\", \"Decoding audio resource failed\");\n            }\n        } else if (filetype == T_VIDEO) {\n            ret = mobi_add_video_resource(curr_part);\n            if (ret != MOBI_SUCCESS) {\n                debug_print(\"%s\\n\", \"Decoding video resource failed\");\n            }\n        } else {\n            curr_part->type = filetype;\n        }\n        \n        curr_record = curr_record->next;\n        \n        if (ret != MOBI_SUCCESS) {\n            free(curr_part);\n            curr_part = NULL;\n        } else if (head) {\n            head->next = curr_part;\n            head = curr_part;\n        } else {\n            rawml->resources = curr_part;\n            head = curr_part;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse Replica Print ebook (azw4). Extract pdf.\n @todo Parse remaining data from the file\n \n @param[in,out] pdf Memory area will be filled with extracted pdf data\n @param[in] text Raw decompressed text to be parsed\n @param[in,out] length Text length. Will be updated with pdf_length on return\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_process_replica(unsigned char *pdf, const char *text, size_t *length) {\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf = mobi_buffer_init_null((unsigned char*) text, *length);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    mobi_buffer_setpos(buf, 12);\n    size_t pdf_offset = mobi_buffer_get32(buf); /* offset 12 */\n    size_t pdf_length = mobi_buffer_get32(buf); /* 16 */\n    if (pdf_length > *length) {\n        debug_print(\"PDF size from replica header too large: %zu\", pdf_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    mobi_buffer_setpos(buf, pdf_offset);\n    mobi_buffer_getraw(pdf, buf, pdf_length);\n    ret = buf->error;\n    mobi_buffer_free_null(buf);\n    *length = pdf_length;\n    return ret;\n}\n\n/**\n @brief Parse raw text into flow parts\n \n @param[in,out] rawml Structure rawml->flow will be filled with parsed flow text parts\n @param[in] text Raw decompressed text to be parsed\n @param[in] length Text length\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_flow(MOBIRawml *rawml, const char *text, const size_t length) {\n    /* KF8 */\n    if (rawml->fdst != NULL) {\n        rawml->flow = calloc(1, sizeof(MOBIPart));\n        if (rawml->flow == NULL) {\n            debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        /* split text into fdst structure parts */\n        MOBIPart *curr = rawml->flow;\n        size_t i = 0;\n        const size_t section_count = rawml->fdst->fdst_section_count;\n        while (i < section_count) {\n            if (i > 0) {\n                curr->next = calloc(1, sizeof(MOBIPart));\n                if (curr->next == NULL) {\n                    debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                curr = curr->next;\n            }\n            const uint32_t section_start = rawml->fdst->fdst_section_starts[i];\n            const uint32_t section_end = rawml->fdst->fdst_section_ends[i];\n            const size_t section_length = section_end - section_start;\n            if (section_start + section_length > length) {\n                debug_print(\"Wrong fdst section length: %zu\\n\", section_length);\n                return MOBI_DATA_CORRUPT;\n            }\n            unsigned char *section_data = malloc(section_length);\n            if (section_data == NULL) {\n                debug_print(\"%s\", \"Memory allocation failed\\n\");\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(section_data, (text + section_start), section_length);\n            curr->uid = i;\n            curr->data = section_data;\n            curr->type = mobi_determine_flowpart_type(rawml, i);\n            curr->size = section_length;\n            curr->next = NULL;\n            i++;\n        }\n    } else {\n        /* No FDST or FDST parts count = 1 */\n        /* single flow part */\n        rawml->flow = calloc(1, sizeof(MOBIPart));\n        if (rawml->flow == NULL) {\n            debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        MOBIPart *curr = rawml->flow;\n        size_t section_length = 0;\n        MOBIFiletype section_type = T_HTML;\n        unsigned char *section_data;\n        /* check if raw text is Print Replica */\n        if (memcmp(text, REPLICA_MAGIC, 4) == 0) {\n            debug_print(\"%s\", \"Print Replica book\\n\");\n            /* print replica */\n            unsigned char *pdf = malloc(length);\n            if (pdf == NULL) {\n                debug_print(\"%s\", \"Memory allocation for flow part failed\\n\");\n                return MOBI_MALLOC_FAILED;\n            }\n            section_length = length;\n            section_type = T_PDF;\n            const MOBI_RET ret = mobi_process_replica(pdf, text, &section_length);\n            if (ret != MOBI_SUCCESS) {\n                free(pdf);\n                return ret;\n            }\n            section_data = malloc(section_length);\n            if (section_data == NULL) {\n                debug_print(\"%s\", \"Memory allocation failed\\n\");\n                free(pdf);\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(section_data, pdf, section_length);\n            free(pdf);\n        } else {\n            /* text data */\n            section_length = length;\n            section_data = malloc(section_length);\n            if (section_data == NULL) {\n                debug_print(\"%s\", \"Memory allocation failed\\n\");\n                return MOBI_MALLOC_FAILED;\n            }\n            memcpy(section_data, text, section_length);\n        }\n        curr->uid = 0;\n        curr->data = section_data;\n        curr->type = section_type;\n        curr->size = section_length;\n        curr->next = NULL;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse raw html into html parts. Use index entries if present to parse file\n \n @param[in,out] rawml Structure rawml->markup will be filled with reconstructed html parts\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_parts(MOBIRawml *rawml) {\n    MOBI_RET ret;\n    if (rawml->flow == NULL) {\n        debug_print(\"%s\", \"Flow structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    /* take first part, xhtml */\n    MOBIBuffer *buf = mobi_buffer_init_null(rawml->flow->data, rawml->flow->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->markup = calloc(1, sizeof(MOBIPart));\n    if (rawml->markup == NULL) {\n        debug_print(\"%s\", \"Memory allocation for markup part failed\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPart *curr = rawml->markup;\n    /* not skeleton data, just copy whole part to markup */\n    if (rawml->skel == NULL) {\n        unsigned char *data = malloc(buf->maxlen);\n        if (data == NULL) {\n            debug_print(\"%s\", \"Memory allocation failed\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_MALLOC_FAILED;\n        }\n        memcpy(data, buf->data, buf->maxlen);\n        curr->uid = 0;\n        curr->size = buf->maxlen;\n        curr->data = data;\n        curr->type = rawml->flow->type;\n        curr->next = NULL;\n        mobi_buffer_free_null(buf);\n        return MOBI_SUCCESS;\n    }\n    /* parse skeleton data */\n    size_t i = 0;\n    size_t j = 0;\n    size_t curr_position = 0;\n    size_t total_fragments_count = rawml->frag->total_entries_count;\n    while (i < rawml->skel->entries_count) {\n        const MOBIIndexEntry *entry = &rawml->skel->entries[i];\n        uint32_t fragments_count;\n        ret = mobi_get_indxentry_tagvalue(&fragments_count, entry, INDX_TAG_SKEL_COUNT);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        if (fragments_count > total_fragments_count) {\n            debug_print(\"%s\", \"Wrong count of fragments\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        total_fragments_count -= fragments_count;\n        uint32_t skel_position;\n        ret = mobi_get_indxentry_tagvalue(&skel_position, entry, INDX_TAG_SKEL_POSITION);\n        if (ret != MOBI_SUCCESS) {\n            mobi_buffer_free_null(buf);\n            return ret;\n        }\n        uint32_t skel_length;\n        ret = mobi_get_indxentry_tagvalue(&skel_length, entry, INDX_TAG_SKEL_LENGTH);\n        if (ret != MOBI_SUCCESS || skel_position + skel_length > buf->maxlen) {\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        debug_print(\"%zu\\t%s\\t%i\\t%i\\t%i\\n\", i, entry->label, fragments_count, skel_position, skel_length);\n        mobi_buffer_setpos(buf, skel_position);\n        \n        unsigned char *frag_buffer = mobi_buffer_getpointer(buf, skel_length);\n        if (frag_buffer == NULL) {\n            debug_print(\"%s\\n\", \"Fragment data beyond buffer\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        MOBIFragment *first_fragment = mobi_list_add(NULL, 0, frag_buffer, skel_length, false);\n        MOBIFragment *current_fragment = first_fragment;\n        while (fragments_count--) {\n            entry = &rawml->frag->entries[j];\n            uint32_t insert_position = (uint32_t) strtoul(entry->label, NULL, 10);\n            if (insert_position < curr_position) {\n                debug_print(\"Insert position (%u) before part start (%zu)\\n\", insert_position, curr_position);\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return MOBI_DATA_CORRUPT;\n            }\n            uint32_t file_number;\n            ret = mobi_get_indxentry_tagvalue(&file_number, entry, INDX_TAG_FRAG_FILE_NR);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            if (file_number != i) {\n                debug_print(\"%s\", \"SKEL part number and fragment sequence number don't match\\n\");\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return MOBI_DATA_CORRUPT;\n            }\n            uint32_t frag_length;\n            ret = mobi_get_indxentry_tagvalue(&frag_length, entry, INDX_TAG_FRAG_LENGTH);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n#if (MOBI_DEBUG)\n            /* FIXME: this fragment metadata is currently unused */\n            uint32_t seq_number;\n            ret = mobi_get_indxentry_tagvalue(&seq_number, entry, INDX_TAG_FRAG_SEQUENCE_NR);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            uint32_t frag_position;\n            ret = mobi_get_indxentry_tagvalue(&frag_position, entry, INDX_TAG_FRAG_POSITION);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            uint32_t cncx_offset;\n            ret = mobi_get_indxentry_tagvalue(&cncx_offset, entry, INDX_TAG_FRAG_AID_CNCX);\n            if (ret != MOBI_SUCCESS) {\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return ret;\n            }\n            const MOBIPdbRecord *cncx_record = rawml->frag->cncx_record;\n            char *aid_text = mobi_get_cncx_string(cncx_record, cncx_offset);\n            if (aid_text == NULL) {\n                mobi_buffer_free_null(buf);\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_list_del_all(first_fragment);\n                return MOBI_MALLOC_FAILED;\n            }\n            debug_print(\"posfid[%zu]\\t%i\\t%i\\t%s\\t%i\\t%i\\t%i\\t%i\\n\", j, insert_position, cncx_offset, aid_text, file_number, seq_number, frag_position, frag_length);\n            free(aid_text);\n#endif\n            \n            insert_position -= curr_position;\n            if (skel_length < insert_position) {\n                debug_print(\"Insert position (%u) after part end (%u)\\n\", insert_position, skel_length);\n                // FIXME: shouldn't the fragment be ignored?\n                // For now insert it at the end.\n                insert_position = skel_length;\n            }\n            skel_length += frag_length;\n            \n            frag_buffer = mobi_buffer_getpointer(buf, frag_length);\n            if (frag_buffer == NULL) {\n                debug_print(\"%s\\n\", \"Fragment data beyond buffer\");\n                mobi_buffer_free_null(buf);\n                mobi_list_del_all(first_fragment);\n                return MOBI_DATA_CORRUPT;\n            }\n            current_fragment = mobi_list_insert(current_fragment, insert_position, frag_buffer, frag_length, false, insert_position);\n            j++;\n            \n        }\n        char *skel_text = malloc(skel_length);\n        if (skel_text == NULL) {\n            debug_print(\"%s\", \"Memory allocation for markup data failed\\n\");\n            mobi_buffer_free_null(buf);\n            mobi_list_del_all(first_fragment);\n            return MOBI_MALLOC_FAILED;\n        }\n        char *p = skel_text;\n        while (first_fragment) {\n            if (first_fragment->fragment) {\n                memcpy(p, first_fragment->fragment, first_fragment->size);\n                p += first_fragment->size;\n            } else {\n                debug_print(\"Skipping broken fragment in part %zu\\n\", i);\n            }\n            first_fragment = mobi_list_del(first_fragment);\n        }\n        if (i > 0) {\n            curr->next = calloc(1, sizeof(MOBIPart));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for markup part failed\\n\");\n                free(skel_text);\n                mobi_buffer_free_null(buf);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->uid = i;\n        curr->size = skel_length;\n        curr->data = (unsigned char *) skel_text;\n        curr->type = T_HTML;\n        curr->next = NULL;\n        curr_position += skel_length;\n        i++;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Scan html part and build array of filepos link target offsets\n \n @param[in,out] links MOBIArray structure for link target offsets array\n @param[in] part MOBIPart html part structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_filepos_array(MOBIArray *links, const MOBIPart *part) {\n    if (!links || !part) {\n        return MOBI_INIT_FAILED;\n    }\n    size_t offset = 0;\n    size_t size = part->size;\n    unsigned char *data = part->data;\n    while (true) {\n        char val[MOBI_ATTRVALUE_MAXSIZE + 1];\n        size -= offset;\n        data += offset;\n        offset = mobi_get_attribute_value(val, data, size, \"filepos\", false);\n        if (offset == SIZE_MAX) { break; }\n        size_t filepos = strtoul(val, NULL, 10);\n        if (filepos > UINT32_MAX || filepos == 0) {\n            debug_print(\"Filepos out of range: %zu\\n\", filepos);\n            continue;\n        }\n        MOBI_RET ret = array_insert(links, (uint32_t) filepos);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Scan ncx part and build array of filepos link target offsets.\n \n @param[in,out] links MOBIArray structure for link target offsets array\n @param[in] rawml MOBIRawml parsed records structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_get_ncx_filepos_array(MOBIArray *links, const MOBIRawml *rawml) {\n    if (!links || !rawml) {\n        return MOBI_PARAM_ERR;\n    }\n    MOBIPart *part = rawml->resources;\n    while (part) {\n        if (part->type == T_NCX) {\n            size_t offset = 0;\n            size_t size = part->size;\n            unsigned char *data = part->data;\n            while (true) {\n                char val[MOBI_ATTRVALUE_MAXSIZE + 1];\n                size -= offset;\n                data += offset;\n                offset = mobi_get_attribute_value(val, data, size, \"src\", false);\n                if (offset == SIZE_MAX) { break; }\n                /* part00000.html#0000000000 */\n                uint32_t filepos = 0;\n                sscanf(val + 15, \"%10u\", &filepos);\n                MOBI_RET ret = array_insert(links, filepos);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n        part = part->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace kindle:pos link with html href\n \n @param[in,out] link Memory area which will be filled with \"part00000.html#customid\", including quotation marks\n @param[in] rawml Structure rawml\n @param[in] value String kindle:pos:fid:0000:off:0000000000, without quotation marks\n @param[in,out] pref_attr Preferred attribute to link to (id or name)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_posfid_to_link(char *link, const MOBIRawml *rawml, const char *value, MOBIAttrType *pref_attr) {\n    /* \"kindle:pos:fid:0000:off:0000000000\" */\n    /* extract fid and off */\n    if (strlen(value) < (sizeof(\"kindle:pos:fid:0000:off:0000000000\") - 1)) {\n        debug_print(\"Skipping too short link: %s\\n\", value);\n        *link = '\\0';\n        return MOBI_SUCCESS;\n    }\n    value += (sizeof(\"kindle:pos:fid:\") - 1);\n    if (value[4] != ':') {\n        debug_print(\"Skipping malformed link: kindle:pos:fid:%s\\n\", value);\n        *link = '\\0';\n        return MOBI_SUCCESS;\n    }\n    char str_fid[4 + 1];\n    strncpy(str_fid, value, 4);\n    str_fid[4] = '\\0';\n    char str_off[10 + 1];\n    value += (sizeof(\"0001:off:\") - 1);\n    strncpy(str_off, value, 10);\n    str_off[10] = '\\0';\n    \n    /* get file number and id value */\n    uint32_t pos_off;\n    uint32_t pos_fid;\n    MOBI_RET ret = mobi_base32_decode(&pos_off, str_off);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_base32_decode(&pos_fid, str_fid);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    uint32_t part_id;\n    char id[MOBI_ATTRVALUE_MAXSIZE + 1];\n    ret = mobi_get_id_by_posoff(&part_id, id, rawml, pos_fid, pos_off, pref_attr);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    /* FIXME: pos_off == 0 means top of file? */\n    if (pos_off) {\n        int n = snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"part%05u.html#%s\\\"\", part_id, id);\n        if (n > MOBI_ATTRVALUE_MAXSIZE + 1) {\n            debug_print(\"Skipping truncated link: %s\\n\", link);\n            *link = '\\0';\n            return MOBI_SUCCESS;\n       }\n    } else {\n        snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"part%05u.html\\\"\", part_id);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace kindle:flow link with html href\n \n @param[in,out] link Memory area which will be filled with \"part00000.ext\", including quotation marks\n @param[in] rawml Structure rawml\n @param[in] value String kindle:flow:0000?mime=type, without quotation marks\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_flow_to_link(char *link, const MOBIRawml *rawml, const char *value) {\n    /* \"kindle:flow:0000?mime=\" */\n    *link = '\\0';\n    if (strlen(value) < (sizeof(\"kindle:flow:0000?mime=\") - 1)) {\n        debug_print(\"Skipping too short link: %s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    value += (sizeof(\"kindle:flow:\") - 1);\n    if (value[4] != '?') {\n        debug_print(\"Skipping broken link: kindle:flow:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    char str_fid[4 + 1];\n    strncpy(str_fid, value, 4);\n    str_fid[4] = '\\0';\n    \n    MOBIPart *flow = mobi_get_flow_by_fid(rawml, str_fid);\n    if (flow == NULL) {\n        debug_print(\"Skipping broken link (missing resource): kindle:flow:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    MOBIFileMeta meta = mobi_get_filemeta_by_type(flow->type);\n    char *extension = meta.extension;\n    snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"flow%05zu.%s\\\"\", flow->uid, extension);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace kindle:embed link with html href\n \n @param[in,out] link Memory area which will be filled with \"resource00000.ext\", including quotation marks\n @param[in] rawml Structure rawml\n @param[in] value String kindle:embed:0000?mime=type, with optional quotation marks\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_embed_to_link(char *link, const MOBIRawml *rawml, const char *value) {\n    /* \"kindle:embed:0000[?mime=]\" */\n    /* skip quotation marks or spaces */\n    while (*value == '\"' || *value == '\\'' || isspace(*value)) {\n        value++;\n    }\n    *link = '\\0';\n    if (strlen(value) < (sizeof(\"kindle:embed:0000\") - 1)) {\n        debug_print(\"Skipping too short link: %s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    value += (sizeof(\"kindle:embed:\") - 1);\n    char str_fid[4 + 1];\n    strncpy(str_fid, value, 4);\n    str_fid[4] = '\\0';\n    \n    /* get file number */\n    uint32_t part_id;\n    MOBI_RET ret = mobi_base32_decode(&part_id, str_fid);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"Skipping broken link (corrupt base32): kindle:embed:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    part_id--;\n    MOBIPart *resource = mobi_get_resource_by_uid(rawml, part_id);\n    if (resource == NULL) {\n        debug_print(\"Skipping broken link (missing resource): kindle:embed:%s\\n\", value);\n        return MOBI_SUCCESS;\n    }\n    MOBIFileMeta meta = mobi_get_filemeta_by_type(resource->type);\n    char *extension = meta.extension;\n    snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"\\\"resource%05u.%s\\\"\", part_id, extension);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace offset-links with html-links in KF8 markup\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_links_kf8(const MOBIRawml *rawml) {\n    MOBIResult result;\n    \n    typedef struct NEWData {\n        size_t part_group;\n        size_t part_uid;\n        MOBIFragment *list;\n        size_t size;\n        struct NEWData *next;\n    } NEWData;\n    \n    NEWData *partdata = NULL;\n    NEWData *curdata = NULL;\n    MOBIPart *parts[] = {\n        rawml->markup, /* html files */\n        rawml->flow->next /* css, skip first unparsed html part */\n    };\n    size_t i;\n    for (i = 0; i < 2; i++) {\n        MOBIPart *part = parts[i];\n        while (part) {\n            unsigned char *data_in = part->data;\n            result.start = part->data;\n            const unsigned char *data_end = part->data + part->size - 1;\n            MOBIFragment *first = NULL;\n            MOBIFragment *curr = NULL;\n            size_t part_size = 0;\n            MOBIAttrType pref_attr = ATTR_ID;\n            while (true) {\n                mobi_search_links_kf8(&result, result.start, data_end, part->type);\n                if (result.start == NULL) {\n                    break;\n                }\n                char *value = (char *) result.value;\n                unsigned char *data_cur = result.start;\n                char *target = NULL;\n                if (data_cur < data_in) {\n                    mobi_list_del_all(first);\n                    return MOBI_DATA_CORRUPT;\n                }\n                size_t size = (size_t) (data_cur - data_in);\n                char link[MOBI_ATTRVALUE_MAXSIZE + 1];\n                if ((target = strstr(value, \"kindle:pos:fid:\")) != NULL) {\n                    /* \"kindle:pos:fid:0001:off:0000000000\" */\n                    /* replace link with href=\"part00000.html#00\" */\n                    /* FIXME: this requires present target id or name attribute */\n                    MOBI_RET ret = mobi_posfid_to_link(link, rawml, target, &pref_attr);\n                    if (ret != MOBI_SUCCESS) {\n                        mobi_list_del_all(first);\n                        return ret;\n                    }\n                } else if ((target = strstr(value, \"kindle:flow:\")) != NULL) {\n                    /* kindle:flow:0000?mime=text/css */\n                    /* replace link with href=\"flow00000.ext\" */\n                    MOBI_RET ret = mobi_flow_to_link(link, rawml, target);\n                    if (ret != MOBI_SUCCESS) {\n                        mobi_list_del_all(first);\n                        return ret;\n                    }\n                } else if ((target = strstr(value, \"kindle:embed:\")) != NULL) {\n                    /* kindle:embed:0000?mime=image/jpg */\n                    /* kindle:embed:0000 (font resources) */\n                    /* replace link with href=\"resource00000.ext\" */\n                    MOBI_RET ret = mobi_embed_to_link(link, rawml, target);\n                    if (ret != MOBI_SUCCESS) {\n                        mobi_list_del_all(first);\n                        return ret;\n                    }\n                }\n                if (target && *link != '\\0') {\n                    /* first chunk */\n                    curr = mobi_list_add(curr, (size_t) (data_in - part->data), data_in, size, false);\n                    if (curr == NULL) {\n                        mobi_list_del_all(first);\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    if (!first) { first = curr; }\n                    part_size += curr->size;\n                    /* second chunk */\n                    /* strip quotes if is_url */\n                    curr = mobi_list_add(curr, SIZE_MAX,\n                                         (unsigned char *) strdup(link + result.is_url),\n                                         strlen(link) - 2 * result.is_url, true);\n                    if (curr == NULL) {\n                        mobi_list_del_all(first);\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    part_size += curr->size;\n                    data_in = result.end;\n                }\n            }\n            if (first && first->fragment) {\n                /* last chunk */\n                if (part->data + part->size < data_in) {\n                    mobi_list_del_all(first);\n                    return MOBI_DATA_CORRUPT;\n                }\n                size_t size = (size_t) (part->data + part->size - data_in);\n                curr = mobi_list_add(curr, (size_t) (data_in - part->data), data_in, size, false);\n                if (curr == NULL) {\n                    mobi_list_del_all(first);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                part_size += curr->size;\n                /* save */\n                if (!curdata) {\n                    curdata = calloc(1, sizeof(NEWData));\n                    partdata = curdata;\n                } else {\n                    curdata->next = calloc(1, sizeof(NEWData));\n                    curdata = curdata->next;\n                }\n                curdata->part_group = i;\n                curdata->part_uid = part->uid;\n                curdata->list = first;\n                curdata->size = part_size;\n            }\n            part = part->next;\n        }\n    }\n    /* now update parts */\n    debug_print(\"Inserting links%s\", \"\\n\");\n    for (i = 0; i < 2; i++) {\n        MOBIPart *part = parts[i];\n        while (part) {\n            if (partdata && part->uid == partdata->part_uid && i == partdata->part_group) {\n                MOBIFragment *fragdata = partdata->list;\n                unsigned char *new_data = malloc(partdata->size);\n                if (new_data == NULL) {\n                    mobi_list_del_all(fragdata);\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                unsigned char *data_out = new_data;\n                while (fragdata) {\n                    memcpy(data_out, fragdata->fragment, fragdata->size);\n                    data_out += fragdata->size;\n                    fragdata = mobi_list_del(fragdata);\n                }\n                free(part->data);\n                part->data = new_data;\n                part->size = partdata->size;\n                NEWData *partused = partdata;\n                partdata = partdata->next;\n                free(partused);\n            }\n            part = part->next;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get infl index markup for given orth entry\n \n @param[in,out] outstring Reconstructed tag <idx:infl\\>\n @param[in] infl MOBIIndx structure with parsed infl index\n @param[in] orth_entry Orth index entry\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_infl(char *outstring, const MOBIIndx *infl, const MOBIIndexEntry *orth_entry) {\n    const char *label = orth_entry->label;\n    uint32_t *infl_groups = NULL;\n    size_t infl_count = mobi_get_indxentry_tagarray(&infl_groups, orth_entry, INDX_TAGARR_ORTH_INFL);\n    \n    if (infl_count == 0 || !infl_groups) {\n        return MOBI_SUCCESS;\n    }    \n    const char *start_tag = \"<idx:infl>\";\n    const char *end_tag = \"</idx:infl>\";\n    const char *iform_tag = \"<idx:iform%s value=\\\"%s\\\"/>\";\n    char name_attr[INDX_INFLBUF_SIZEMAX + 1];\n    char infl_tag[INDX_INFLBUF_SIZEMAX + 1];\n    strcpy(outstring, start_tag);\n    size_t initlen = strlen(start_tag) + strlen(end_tag);\n    size_t outlen = initlen;\n    size_t label_length = strlen(label);\n    if (label_length > INDX_INFLBUF_SIZEMAX) {\n        debug_print(\"Entry label too long (%s)\\n\", label);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (infl->cncx_record == NULL) {\n        debug_print(\"%s\\n\", \"Missing cncx record\");\n        return MOBI_DATA_CORRUPT;\n    }\n    for (size_t i = 0; i < infl_count; i++) {\n        size_t offset = infl_groups[i];\n        if (offset >= infl->entries_count) {\n            debug_print(\"%s\\n\", \"Invalid entry offset\");\n            return MOBI_DATA_CORRUPT;\n        }\n        uint32_t *groups;\n        size_t group_cnt = mobi_get_indxentry_tagarray(&groups, &infl->entries[offset], INDX_TAGARR_INFL_GROUPS);\n        uint32_t *parts;\n        size_t part_cnt = mobi_get_indxentry_tagarray(&parts, &infl->entries[offset], INDX_TAGARR_INFL_PARTS_V2);\n        if (group_cnt != part_cnt) {\n            return MOBI_DATA_CORRUPT;\n        }\n        for (size_t j = 0; j < part_cnt; j++) {\n            name_attr[0] = '\\0';\n            char *group_name = mobi_get_cncx_string(infl->cncx_record, groups[j]);\n            if (group_name == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            if (strlen(group_name)) {\n                snprintf(name_attr, INDX_INFLBUF_SIZEMAX, \" name=\\\"%s\\\"\", group_name);\n            }\n            free(group_name);\n            \n            unsigned char decoded[INDX_INFLBUF_SIZEMAX + 1];\n            memset(decoded, 0, INDX_INFLBUF_SIZEMAX + 1);\n            if (parts[j] >= infl->entries_count) {\n                debug_print(\"%s\\n\", \"Invalid entry offset\");\n                return MOBI_DATA_CORRUPT;\n            }\n            unsigned char *rule = (unsigned char *) infl->entries[parts[j]].label;\n            memcpy(decoded, label, label_length);\n            int decoded_length = (int) label_length;\n            MOBI_RET ret = mobi_decode_infl(decoded, &decoded_length, rule);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            if (decoded_length == 0) {\n                continue;\n            }\n            int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, name_attr, decoded);\n            if (n > INDX_INFLBUF_SIZEMAX) {\n                debug_print(\"Skipping truncated tag: %s\\n\", infl_tag);\n                continue;\n            }\n            outlen += strlen(infl_tag);\n            if (outlen > INDX_INFLTAG_SIZEMAX) {\n                debug_print(\"Inflections text in %s too long (%zu)\\n\", label, outlen);\n                return MOBI_ERROR;\n            }\n            strcat(outstring, infl_tag);\n        }\n    }\n    if (outlen == initlen) {\n        outstring[0] = '\\0';\n    } else {\n        strcat(outstring, end_tag);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Get infl index markup for given orth entry\n \n This function is inflections scheme used in older mobipocket dictionaries\n \n @param[in,out] outstring Reconstructed tag <idx:infl\\>\n @param[in] infl_tree MOBITrie structure with inflection rules\n @param[in] orth_entry Orth index entry\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_infl_v1(char *outstring, MOBITrie * const infl_tree, const MOBIIndexEntry *orth_entry) {\n    const char *label = orth_entry->label;\n    const size_t label_length = strlen(label);\n    if (label_length > INDX_INFLBUF_SIZEMAX) {\n        debug_print(\"Entry label too long (%s)\\n\", label);\n        return MOBI_DATA_CORRUPT;\n    }\n    char *infl_strings[INDX_INFLSTRINGS_MAX];\n    size_t infl_count = mobi_trie_get_inflgroups(infl_strings, infl_tree, label);\n    \n    if (infl_count == 0) {\n        return MOBI_SUCCESS;\n    }\n    \n    const char *start_tag = \"<idx:infl>\";\n    const char *end_tag = \"</idx:infl>\";\n    const char *iform_tag = \"<idx:iform value=\\\"%s\\\"/>\";\n    char infl_tag[INDX_INFLBUF_SIZEMAX + 1];\n    strcpy(outstring, start_tag);\n    size_t initlen = strlen(start_tag) + strlen(end_tag);\n    size_t outlen = initlen;\n    for (size_t i = 0; i < infl_count; i++) {\n        char *decoded = infl_strings[i];\n        size_t decoded_length = strlen(decoded);\n\n        if (decoded_length == 0) {\n            free(decoded);\n            continue;\n        }\n        int n = snprintf(infl_tag, INDX_INFLBUF_SIZEMAX, iform_tag, decoded);\n        /* allocated in mobi_trie_get_inflgroups() */\n        free(decoded);\n        if (n > INDX_INFLBUF_SIZEMAX) {\n            debug_print(\"Skipping too long tag: %s\\n\", infl_tag);\n            continue;\n        }\n        outlen += strlen(infl_tag);\n        if (outlen > INDX_INFLTAG_SIZEMAX) {\n            debug_print(\"Inflections text in %s too long (%zu)\\n\", label, outlen);\n            break;\n        }\n        strcat(outstring, infl_tag);\n    }\n    if (outlen == initlen) {\n        outstring[0] = '\\0';\n    } else {\n        strcat(outstring, end_tag);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Insert orth index markup to linked list of fragments\n \n @param[in] rawml Structure rawml contains orth index data\n @param[in,out] first First element of the linked list\n @param[in,out] new_size Counter to be updated with inserted fragments size\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_orth(const MOBIRawml *rawml, MOBIFragment *first, size_t *new_size) {\n    MOBITrie *infl_trie = NULL;\n    bool is_infl_v2 = mobi_indx_has_tag(rawml->orth, INDX_TAGARR_ORTH_INFL);\n    bool is_infl_v1 = false;\n    if (is_infl_v2 == false) {\n        is_infl_v1 = mobi_indx_has_tag(rawml->infl, INDX_TAGARR_INFL_PARTS_V1);\n    }\n    debug_print(\"Reconstructing orth index %s\\n\", (is_infl_v1)?\"(infl v1)\":(is_infl_v2)?\"(infl v2)\":\"\");\n    if (is_infl_v1) {\n        size_t total = rawml->infl->entries_count;\n        size_t j = 0;\n        while (j < total) {\n            MOBI_RET ret = mobi_trie_insert_infl(&infl_trie, rawml->infl, j++);\n            if (ret != MOBI_SUCCESS || infl_trie == NULL) {\n                debug_print(\"Building trie for inflections failed%s\", \"\\n\");\n                mobi_trie_free(infl_trie);\n                is_infl_v1 = false;\n            }\n        }\n    }\n    \n    MOBIFragment *curr = first;\n    size_t i = 0;\n    const size_t count = rawml->orth->entries_count;\n    const char *start_tag1 = \"<idx:entry><idx:orth value=\\\"%s\\\">%s</idx:orth></idx:entry>\";\n    const char *start_tag2 = \"<idx:entry scriptable=\\\"yes\\\"><idx:orth value=\\\"%s\\\">%s</idx:orth>\";\n    const char *end_tag = \"</idx:entry>\";\n    const size_t start_tag1_len = strlen(start_tag1) - 4;\n    const size_t start_tag2_len = strlen(start_tag2) - 4;\n    const size_t end_tag_len = strlen(end_tag);\n    uint32_t prev_startpos = 0;\n    while (i < count) {\n        const MOBIIndexEntry *orth_entry = &rawml->orth->entries[i];\n        const char *label = orth_entry->label;\n        uint32_t entry_startpos;\n        MOBI_RET ret = mobi_get_indxentry_tagvalue(&entry_startpos, orth_entry, INDX_TAG_ORTH_POSITION);\n        if (ret != MOBI_SUCCESS) {\n            i++;\n            continue;\n        }\n        size_t entry_length = 0;\n        uint32_t entry_textlen = 0;\n        mobi_get_indxentry_tagvalue(&entry_textlen, orth_entry, INDX_TAG_ORTH_LENGTH);\n        char *start_tag;\n        if (entry_textlen == 0) {\n            entry_length += start_tag1_len + strlen(label);\n            start_tag = (char *) start_tag1;\n        } else {\n            entry_length += start_tag2_len + strlen(label);\n            start_tag = (char *) start_tag2;\n        }\n\n        char *entry_text;\n        if (rawml->infl) {\n            char *infl_tag = malloc(INDX_INFLTAG_SIZEMAX + 1);\n            if (infl_tag == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                return MOBI_MALLOC_FAILED;\n            }\n            infl_tag[0] = '\\0';\n            if (is_infl_v2) {\n                ret = mobi_reconstruct_infl(infl_tag, rawml->infl, orth_entry);\n            } else if (is_infl_v1) {\n                ret = mobi_reconstruct_infl_v1(infl_tag, infl_trie, orth_entry);\n            } else {\n                debug_print(\"Unknown inflection scheme?%s\", \"\\n\");\n            }\n            if (ret != MOBI_SUCCESS) {\n                free(infl_tag);\n                return ret;\n            }\n            entry_length += strlen(infl_tag);\n            \n            entry_text = malloc(entry_length + 1);\n            if (entry_text == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                free(infl_tag);\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(entry_text, entry_length + 1, start_tag, label, infl_tag);\n            free(infl_tag);\n        } else {\n            entry_text = malloc(entry_length + 1);\n            if (entry_text == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                return MOBI_MALLOC_FAILED;\n            }\n            snprintf(entry_text, entry_length + 1, start_tag, label, \"\");\n        }\n        \n        if (entry_startpos < prev_startpos) {\n            curr = first;\n        }\n        curr = mobi_list_insert(curr, SIZE_MAX,\n                                (unsigned char *) entry_text,\n                                entry_length, true, entry_startpos);\n        prev_startpos = entry_startpos;\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            mobi_trie_free(infl_trie);\n            return MOBI_MALLOC_FAILED;\n        }\n        *new_size += curr->size;\n        if (entry_textlen > 0) {\n            /* FIXME: avoid end_tag duplication */\n            curr = mobi_list_insert(curr, SIZE_MAX,\n                                    (unsigned char *) strdup(end_tag),\n                                    end_tag_len, true, entry_startpos + entry_textlen);\n            if (curr == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                mobi_trie_free(infl_trie);\n                return MOBI_MALLOC_FAILED;\n            }\n            *new_size += curr->size;\n        }\n        i++;\n    }\n    mobi_trie_free(infl_trie);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace offset-links with html-links in KF7 markup.\n Also reconstruct dictionary markup if present\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_links_kf7(const MOBIRawml *rawml) {\n    MOBIResult result;\n    MOBIArray *links = array_init(25);\n    if (links == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPart *part = rawml->markup;\n    /* get array of link target offsets */\n    MOBI_RET ret = mobi_get_filepos_array(links, part);\n    if (ret != MOBI_SUCCESS) {\n        array_free(links);\n        return ret;\n    }\n    ret = mobi_get_ncx_filepos_array(links, rawml);\n    if (ret != MOBI_SUCCESS) {\n        array_free(links);\n        return ret;\n    }\n    array_sort(links, true);\n    unsigned char *data_in = part->data;\n    MOBIFragment *first = NULL;\n    MOBIFragment *curr = NULL;\n    size_t new_size = 0;\n    /* build MOBIResult list */\n    result.start = part->data;\n    const unsigned char *data_end = part->data + part->size - 1;\n    while (true) {\n        mobi_search_links_kf7(&result, result.start, data_end);\n        if (result.start == NULL) {\n            break;\n        }\n        char *attribute = (char *) result.value;\n        unsigned char *data_cur = result.start;\n        result.start = result.end;\n        char link[MOBI_ATTRVALUE_MAXSIZE + 1];\n        const char *numbers = \"0123456789\";\n        char *value = strpbrk(attribute, numbers);\n        if (value == NULL) {\n            debug_print(\"Unknown link target: %s\\n\", attribute);\n            continue;\n        }\n        size_t target;\n        switch (attribute[0]) {\n            case 'f':\n                /* filepos=0000000000 */\n                /* replace link with href=\"#0000000000\" */\n                target = strtoul(value, NULL, 10);\n                snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"href=\\\"#%010u\\\"\", (uint32_t)target);\n                break;\n            case 'h':\n            case 'l':\n                data_cur += 2;\n                /* falls through */\n            case 'r':\n                /* (hi|lo)recindex=\"00000\" */\n                /* replace link with src=\"resource00000.ext\" */\n                target = strtoul(value, NULL, 10);\n                if (target > 0) {\n                    target--;\n                }\n                MOBIFiletype filetype = mobi_get_resourcetype_by_uid(rawml, target);\n                MOBIFileMeta filemeta = mobi_get_filemeta_by_type(filetype);\n                snprintf(link, MOBI_ATTRVALUE_MAXSIZE + 1, \"src=\\\"resource%05u.%s\\\"\", (uint32_t) target, filemeta.extension);\n                break;\n            default:\n                debug_print(\"Unknown link target: %s\\n\", attribute);\n                continue;\n        }\n        \n        /* first chunk */\n        if (data_cur < data_in) {\n            mobi_list_del_all(first);\n            array_free(links);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (data_cur - data_in);\n        size_t raw_offset = (size_t) (data_in - part->data);\n        curr = mobi_list_add(curr, raw_offset, data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (!first) { first = curr; }\n        new_size += curr->size;\n        /* second chunk */\n        curr = mobi_list_add(curr, SIZE_MAX,\n                             (unsigned char *) strdup(link),\n                             strlen(link), true);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += curr->size;\n        data_in = result.end;\n    }\n    if (first) {\n        /* last chunk */\n        if (part->data + part->size < data_in) {\n            mobi_list_del_all(first);\n            array_free(links);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (part->data + part->size - data_in);\n        size_t raw_offset = (size_t) (data_in - part->data);\n        curr = mobi_list_add(curr, raw_offset, data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += curr->size;\n    } else {\n        /* add whole part as one fragment */\n        first = mobi_list_add(first, 0, part->data, part->size, false);\n        if (first == NULL) {\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += first->size;\n    }\n    /* insert chunks from links array */\n    curr = first;\n    size_t i = 0;\n    while (i < links->size) {\n        const uint32_t offset = links->data[i];\n        char anchor[MOBI_ATTRVALUE_MAXSIZE + 1];\n        snprintf(anchor, MOBI_ATTRVALUE_MAXSIZE + 1, \"<a id=\\\"%010u\\\"></a>\", offset);\n        curr = mobi_list_insert(curr, SIZE_MAX,\n                               (unsigned char *) strdup(anchor),\n                                strlen(anchor), true, offset);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            array_free(links);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        new_size += curr->size;\n        i++;\n    }\n    array_free(links);\n    /* insert dictionary markup if present */\n    if (rawml->orth) {\n        ret = mobi_reconstruct_orth(rawml, first, &new_size);\n        if (ret != MOBI_SUCCESS) {\n            mobi_list_del_all(first);\n            return ret;\n        }\n    }\n    if (first && first->next) {\n        /* save */\n        debug_print(\"Inserting links%s\", \"\\n\");\n        unsigned char *new_data = malloc(new_size);\n        if (new_data == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        unsigned char *data_out = new_data;\n        MOBIFragment *fragdata = first;\n        while (fragdata) {\n            memcpy(data_out, fragdata->fragment, fragdata->size);\n            data_out += fragdata->size;\n            fragdata = mobi_list_del(fragdata);\n        }\n        free(part->data);\n        part->data = new_data;\n        part->size = new_size;\n    } else {\n        mobi_list_del(first);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Replace offset-links with html-links\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_reconstruct_links(const MOBIRawml *rawml) {\n    debug_print(\"Reconstructing links%s\", \"\\n\");\n    if (rawml == NULL) {\n        debug_print(\"%s\\n\", \"Rawml not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBI_RET ret;\n    if (mobi_is_rawml_kf8(rawml)) {\n        /* kf8 gymnastics */\n        ret = mobi_reconstruct_links_kf8(rawml);\n    } else {\n        /* kf7 format and older */\n        ret = mobi_reconstruct_links_kf7(rawml);\n    }\n    return ret;\n}\n\n/**\n @brief Call callback function for each text record\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @param[in,out] cb Callback function\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_iterate_txtparts(MOBIRawml *rawml, MOBI_RET (*cb) (MOBIPart *)) {\n    MOBIPart *parts[] = {\n        rawml->markup, /* html files */\n        rawml->flow->next /* css, skip first unparsed html part */\n    };\n    size_t i;\n    for (i = 0; i < 2; i++) {\n        MOBIPart *part = parts[i];\n        while (part) {\n            if (part->type == T_HTML || part->type == T_CSS) {\n                MOBI_RET ret = cb(part);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n            part = part->next;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Convert MOBIPart part data to utf8\n \n @param[in,out] part MOBIPart part\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_markup_to_utf8(MOBIPart *part) {\n    if (part == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    unsigned char *text = part->data;\n    size_t length = part->size;\n    /* extreme case in which each input character is converted\n     to 3-byte utf-8 sequence */\n    size_t out_length = 3 * length + 1;\n    char *out_text = malloc(out_length);\n    if (out_text == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBI_RET ret = mobi_cp1252_to_utf8(out_text, (const char *) text, &out_length, length);\n    free(text);\n    if (ret != MOBI_SUCCESS || out_length == 0) {\n        debug_print(\"%s\", \"conversion from cp1252 to utf8 failed\\n\");\n        free(out_text);\n        part->data = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    text = malloc(out_length);\n    if (text == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        free(out_text);\n        part->data = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    memcpy(text, out_text, out_length);\n    free(out_text);\n    part->data = text;\n    part->size = out_length;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Strip unneeded tags from html. Currently only <aid\\>\n \n @param[in,out] part MOBIPart structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_strip_mobitags(MOBIPart *part) {\n    if (part == NULL || part->data == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    if (part->type != T_HTML) {\n        return MOBI_SUCCESS;\n    }\n    MOBIResult result;\n    unsigned char *data_in = part->data;\n    result.start = part->data;\n    const unsigned char *data_end = part->data + part->size - 1;\n    MOBIFragment *first = NULL;\n    MOBIFragment *curr = NULL;\n    size_t part_size = 0;\n    while (true) {\n        mobi_find_attrname(&result, result.start, data_end, \"aid\");\n        if (result.start == NULL) {\n            break;\n        }\n        unsigned char *data_cur = result.start;\n        result.start = result.end;\n        if (data_cur < data_in) {\n            mobi_list_del_all(first);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (data_cur - data_in);\n        /* first chunk */\n        curr = mobi_list_add(curr, (size_t) (data_in - part->data ), data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (!first) { first = curr; }\n        part_size += curr->size;\n        data_in = result.end;\n    }\n    if (first) {\n        /* last chunk */\n        if (part->data + part->size < data_in) {\n            mobi_list_del_all(first);\n            return MOBI_DATA_CORRUPT;\n        }\n        size_t size = (size_t) (part->data + part->size - data_in);\n        curr = mobi_list_add(curr, (size_t) (data_in - part->data ), data_in, size, false);\n        if (curr == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        part_size += curr->size;\n        \n        unsigned char *new_data = malloc(part_size);\n        if (new_data == NULL) {\n            mobi_list_del_all(first);\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        unsigned char *data_out = new_data;\n        while (first) {\n            memcpy(data_out, first->fragment, first->size);\n            data_out += first->size;\n            first = mobi_list_del(first);\n        }\n        free(part->data);\n        part->data = new_data;\n        part->size = part_size;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse raw records into html flow parts, markup parts, resources and indices\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @param[in] m MOBIData structure\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_rawml(MOBIRawml *rawml, const MOBIData *m) {\n    return mobi_parse_rawml_opt(rawml, m, true, true, true);\n}\n\n/**\n @brief Parse raw records into html flow parts, markup parts, resources and indices.\n        Individual stages of the parsing may be turned on/off.\n \n @param[in,out] rawml Structure rawml will be filled with reconstructed parts and resources\n @param[in] m MOBIData structure\n @param[in] parse_toc bool Parse content indices if true\n @param[in] parse_dict bool Parse dictionary indices if true\n @param[in] reconstruct bool Recounstruct links, build opf, strip mobi-specific tags if true\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_rawml_opt(MOBIRawml *rawml, const MOBIData *m, bool parse_toc, bool parse_dict, bool reconstruct) {\n    \n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (rawml == NULL) {\n        return MOBI_INIT_FAILED;\n    }\n    \n    /* Get maximal size of text data */\n    const size_t maxlen = mobi_get_text_maxsize(m);\n    if (maxlen == MOBI_NOTSET) {\n        debug_print(\"%s\", \"Insane text length\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    char *text = malloc(maxlen + 1);\n    if (text == NULL) {\n        debug_print(\"%s\", \"Memory allocation failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* Extract text records, unpack, merge and copy it to text string */\n    size_t length = maxlen;\n    ret = mobi_get_rawml(m, text, &length);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"Error parsing text\\n\");\n        free(text);\n        return ret;\n    }\n    \n    if (mobi_exists_fdst(m)) {\n        /* Skip parsing if section count less or equal than 1 */\n        if (m->mh->fdst_section_count && *m->mh->fdst_section_count > 1) {\n            ret = mobi_parse_fdst(m, rawml);\n            if (ret != MOBI_SUCCESS) {\n                free(text);\n                return ret;\n            }\n        }\n    }\n    ret = mobi_reconstruct_flow(rawml, text, length);\n    free(text);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_reconstruct_resources(m, rawml);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    const size_t offset = mobi_get_kf8offset(m);\n    /* skeleton index */\n    if (mobi_exists_skel_indx(m) && mobi_exists_frag_indx(m)) {\n        const size_t indx_record_number = *m->mh->skeleton_index + offset;\n        /* to be freed in mobi_free_rawml */\n        MOBIIndx *skel_meta = mobi_init_indx();\n        ret = mobi_parse_index(m, skel_meta, indx_record_number);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        rawml->skel = skel_meta;\n    }\n    \n    /* fragment index */\n    if (mobi_exists_frag_indx(m)) {\n        MOBIIndx *frag_meta = mobi_init_indx();\n        const size_t indx_record_number = *m->mh->fragment_index + offset;\n        ret = mobi_parse_index(m, frag_meta, indx_record_number);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        rawml->frag = frag_meta;\n    }\n    \n    if (parse_toc) {\n        /* guide index */\n        if (mobi_exists_guide_indx(m)) {\n            MOBIIndx *guide_meta = mobi_init_indx();\n            const size_t indx_record_number = *m->mh->guide_index + offset;\n            ret = mobi_parse_index(m, guide_meta, indx_record_number);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            rawml->guide = guide_meta;\n        }\n        \n        /* ncx index */\n        if (mobi_exists_ncx(m)) {\n            MOBIIndx *ncx_meta = mobi_init_indx();\n            const size_t indx_record_number = *m->mh->ncx_index + offset;\n            ret = mobi_parse_index(m, ncx_meta, indx_record_number);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            rawml->ncx = ncx_meta;\n        }\n    }\n    \n    if (parse_dict && mobi_is_dictionary(m)) {\n        /* orth */\n        MOBIIndx *orth_meta = mobi_init_indx();\n        size_t indx_record_number = *m->mh->orth_index + offset;\n        ret = mobi_parse_index(m, orth_meta, indx_record_number);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        rawml->orth = orth_meta;\n        /* infl */\n        if (mobi_exists_infl(m)) {\n            MOBIIndx *infl_meta = mobi_init_indx();\n            indx_record_number = *m->mh->infl_index + offset;\n            ret = mobi_parse_index(m, infl_meta, indx_record_number);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            rawml->infl = infl_meta;\n        }\n    }\n    \n    ret = mobi_reconstruct_parts(rawml);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (reconstruct) {\n#ifdef USE_XMLWRITER\n        ret = mobi_build_opf(rawml, m);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n#endif\n        ret = mobi_reconstruct_links(rawml);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n        if (mobi_is_kf8(m)) {\n            debug_print(\"Stripping unneeded tags%s\", \"\\n\");\n            ret = mobi_iterate_txtparts(rawml, mobi_strip_mobitags);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n        }\n\n    }\n    if (mobi_is_cp1252(m)) {\n        debug_print(\"Converting cp1252 to utf8%s\", \"\\n\");\n        ret = mobi_iterate_txtparts(rawml, mobi_markup_to_utf8);\n        if (ret != MOBI_SUCCESS) {\n            return ret;\n        }\n    }\n    return MOBI_SUCCESS;\n}\n"], "filenames": ["ChangeLog", "src/parse_rawml.c"], "buggy_code_start_loc": [0, 110], "buggy_code_end_loc": [0, 358], "fixing_code_start_loc": [1, 110], "fixing_code_end_loc": [2, 358], "type": "CWE-125", "message": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.", "other": {"cve": {"id": "CVE-2022-1908", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-27T09:15:08.273", "lastModified": "2022-06-03T15:14:42.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11."}, {"lang": "es", "value": "Una Lectura excesiva del Buffer en el repositorio de GitHub bfabiszewski/libmobi versiones anteriores a 0.11"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:R/S:U/C:L/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmobi_project:libmobi:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.11", "matchCriteriaId": "6FF60ACA-0257-493F-A0F1-CD257EFDAC33"}]}]}], "references": [{"url": "https://github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a7436e88-0488-4bd4-816f-2e2c803e93e8", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bfabiszewski/libmobi/commit/1e0378e6f9e4ae415cedc9eb10850888897c5dba"}}