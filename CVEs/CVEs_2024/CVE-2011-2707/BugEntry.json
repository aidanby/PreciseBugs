{"buggy_code": ["// TODO some minor issues\n/*\n * This file is subject to the terms and conditions of the GNU General Public\n * License.  See the file \"COPYING\" in the main directory of this archive\n * for more details.\n *\n * Copyright (C) 2001 - 2007  Tensilica Inc.\n *\n * Joe Taylor\t<joe@tensilica.com, joetylr@yahoo.com>\n * Chris Zankel <chris@zankel.net>\n * Scott Foehner<sfoehner@yahoo.com>,\n * Kevin Chea\n * Marc Gauthier<marc@tensilica.com> <marc@alumni.uwaterloo.ca>\n */\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/smp.h>\n#include <linux/security.h>\n#include <linux/signal.h>\n\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/system.h>\n#include <asm/uaccess.h>\n#include <asm/ptrace.h>\n#include <asm/elf.h>\n#include <asm/coprocessor.h>\n\n\nvoid user_enable_single_step(struct task_struct *child)\n{\n\tchild->ptrace |= PT_SINGLESTEP;\n}\n\nvoid user_disable_single_step(struct task_struct *child)\n{\n\tchild->ptrace &= ~PT_SINGLESTEP;\n}\n\n/*\n * Called by kernel/ptrace.c when detaching to disable single stepping.\n */\n\nvoid ptrace_disable(struct task_struct *child)\n{\n\t/* Nothing to do.. */\n}\n\nint ptrace_getregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\txtensa_gregset_t __user *gregset = uregs;\n\tunsigned long wm = regs->wmask;\n\tunsigned long wb = regs->windowbase;\n\tint live, i;\n\n\tif (!access_ok(VERIFY_WRITE, uregs, sizeof(xtensa_gregset_t)))\n\t\treturn -EIO;\n\n\t__put_user(regs->pc, &gregset->pc);\n\t__put_user(regs->ps & ~(1 << PS_EXCM_BIT), &gregset->ps);\n\t__put_user(regs->lbeg, &gregset->lbeg);\n\t__put_user(regs->lend, &gregset->lend);\n\t__put_user(regs->lcount, &gregset->lcount);\n\t__put_user(regs->windowstart, &gregset->windowstart);\n\t__put_user(regs->windowbase, &gregset->windowbase);\n\n\tlive = (wm & 2) ? 4 : (wm & 4) ? 8 : (wm & 8) ? 12 : 16;\n\n\tfor (i = 0; i < live; i++)\n\t\t__put_user(regs->areg[i],gregset->a+((wb*4+i)%XCHAL_NUM_AREGS));\n\tfor (i = XCHAL_NUM_AREGS - (wm >> 4) * 4; i < XCHAL_NUM_AREGS; i++)\n\t\t__put_user(regs->areg[i],gregset->a+((wb*4+i)%XCHAL_NUM_AREGS));\n\n\treturn 0;\n}\n\nint ptrace_setregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\txtensa_gregset_t *gregset = uregs;\n\tconst unsigned long ps_mask = PS_CALLINC_MASK | PS_OWB_MASK;\n\tunsigned long ps;\n\tunsigned long wb;\n\n\tif (!access_ok(VERIFY_WRITE, uregs, sizeof(xtensa_gregset_t)))\n\t\treturn -EIO;\n\n\t__get_user(regs->pc, &gregset->pc);\n\t__get_user(ps, &gregset->ps);\n\t__get_user(regs->lbeg, &gregset->lbeg);\n\t__get_user(regs->lend, &gregset->lend);\n\t__get_user(regs->lcount, &gregset->lcount);\n\t__get_user(regs->windowstart, &gregset->windowstart);\n\t__get_user(wb, &gregset->windowbase);\n\n\tregs->ps = (regs->ps & ~ps_mask) | (ps & ps_mask) | (1 << PS_EXCM_BIT);\n\n\tif (wb >= XCHAL_NUM_AREGS / 4)\n\t\treturn -EFAULT;\n\n\tregs->windowbase = wb;\n\n\tif (wb != 0 &&  __copy_from_user(regs->areg + XCHAL_NUM_AREGS - wb * 4,\n\t\t\t\t\t gregset->a, wb * 16))\n\t\treturn -EFAULT;\n\n\tif (__copy_from_user(regs->areg, gregset->a + wb*4, (WSBITS-wb) * 16))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n\nint ptrace_getxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\tstruct thread_info *ti = task_thread_info(child);\n\telf_xtregs_t __user *xtregs = uregs;\n\tint ret = 0;\n\n\tif (!access_ok(VERIFY_WRITE, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EIO;\n\n#if XTENSA_HAVE_COPROCESSORS\n\t/* Flush all coprocessor registers to memory. */\n\tcoprocessor_flush_all(ti);\n\tret |= __copy_to_user(&xtregs->cp0, &ti->xtregs_cp,\n\t\t\t      sizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_to_user(&xtregs->opt, &regs->xtregs_opt,\n\t\t\t      sizeof(xtregs->opt));\n\tret |= __copy_to_user(&xtregs->user,&ti->xtregs_user,\n\t\t\t      sizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}\n\nint ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\n#if XTENSA_HAVE_COPROCESSORS\n\t/* Flush all coprocessors before we overwrite them. */\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}\n\nint ptrace_peekusr(struct task_struct *child, long regno, long __user *ret)\n{\n\tstruct pt_regs *regs;\n\tunsigned long tmp;\n\n\tregs = task_pt_regs(child);\n\ttmp = 0;  /* Default return value. */\n\n\tswitch(regno) {\n\n\t\tcase REG_AR_BASE ... REG_AR_BASE + XCHAL_NUM_AREGS - 1:\n\t\t\ttmp = regs->areg[regno - REG_AR_BASE];\n\t\t\tbreak;\n\n\t\tcase REG_A_BASE ... REG_A_BASE + 15:\n\t\t\ttmp = regs->areg[regno - REG_A_BASE];\n\t\t\tbreak;\n\n\t\tcase REG_PC:\n\t\t\ttmp = regs->pc;\n\t\t\tbreak;\n\n\t\tcase REG_PS:\n\t\t\t/* Note:  PS.EXCM is not set while user task is running;\n\t\t\t * its being set in regs is for exception handling\n\t\t\t * convenience.  */\n\t\t\ttmp = (regs->ps & ~(1 << PS_EXCM_BIT));\n\t\t\tbreak;\n\n\t\tcase REG_WB:\n\t\t\tbreak;\t\t/* tmp = 0 */\n\n\t\tcase REG_WS:\n\t\t{\n\t\t\tunsigned long wb = regs->windowbase;\n\t\t\tunsigned long ws = regs->windowstart;\n\t\t\ttmp = ((ws>>wb) | (ws<<(WSBITS-wb))) & ((1<<WSBITS)-1);\n\t\t\tbreak;\n\t\t}\n\t\tcase REG_LBEG:\n\t\t\ttmp = regs->lbeg;\n\t\t\tbreak;\n\n\t\tcase REG_LEND:\n\t\t\ttmp = regs->lend;\n\t\t\tbreak;\n\n\t\tcase REG_LCOUNT:\n\t\t\ttmp = regs->lcount;\n\t\t\tbreak;\n\n\t\tcase REG_SAR:\n\t\t\ttmp = regs->sar;\n\t\t\tbreak;\n\n\t\tcase SYSCALL_NR:\n\t\t\ttmp = regs->syscall;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t}\n\treturn put_user(tmp, ret);\n}\n\nint ptrace_pokeusr(struct task_struct *child, long regno, long val)\n{\n\tstruct pt_regs *regs;\n\tregs = task_pt_regs(child);\n\n\tswitch (regno) {\n\t\tcase REG_AR_BASE ... REG_AR_BASE + XCHAL_NUM_AREGS - 1:\n\t\t\tregs->areg[regno - REG_AR_BASE] = val;\n\t\t\tbreak;\n\n\t\tcase REG_A_BASE ... REG_A_BASE + 15:\n\t\t\tregs->areg[regno - REG_A_BASE] = val;\n\t\t\tbreak;\n\n\t\tcase REG_PC:\n\t\t\tregs->pc = val;\n\t\t\tbreak;\n\n\t\tcase SYSCALL_NR:\n\t\t\tregs->syscall = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datap = (void __user *) data;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\t/* read word at location addr. */\n\tcase PTRACE_PEEKDATA:\n\t\tret = generic_ptrace_peekdata(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_PEEKUSR:\t/* read register specified by addr. */\n\t\tret = ptrace_peekusr(child, addr, datap);\n\t\tbreak;\n\n\tcase PTRACE_POKETEXT:\t/* write the word at location addr. */\n\tcase PTRACE_POKEDATA:\n\t\tret = generic_ptrace_pokedata(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_POKEUSR:\t/* write register specified by addr. */\n\t\tret = ptrace_pokeusr(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_GETREGS:\n\t\tret = ptrace_getregs(child, datap);\n\t\tbreak;\n\n\tcase PTRACE_SETREGS:\n\t\tret = ptrace_setregs(child, datap);\n\t\tbreak;\n\n\tcase PTRACE_GETXTREGS:\n\t\tret = ptrace_getxregs(child, datap);\n\t\tbreak;\n\n\tcase PTRACE_SETXTREGS:\n\t\tret = ptrace_setxregs(child, datap);\n\t\tbreak;\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nvoid do_syscall_trace(void)\n{\n\t/*\n\t * The 0x80 provides a way for the tracing parent to distinguish\n\t * between a syscall stop and SIGTRAP delivery\n\t */\n\tptrace_notify(SIGTRAP|((current->ptrace & PT_TRACESYSGOOD) ? 0x80 : 0));\n\n\t/*\n\t * this isn't the same as continuing with a signal, but it will do\n\t * for normal use.  strace only continues with a signal if the\n\t * stopping signal is not SIGTRAP.  -brl\n\t */\n\tif (current->exit_code) {\n\t\tsend_sig(current->exit_code, current, 1);\n\t\tcurrent->exit_code = 0;\n\t}\n}\n\nvoid do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tif (test_thread_flag(TIF_SYSCALL_TRACE)\n\t\t\t&& (current->ptrace & PT_PTRACED))\n\t\tdo_syscall_trace();\n\n#if 0\n\tif (unlikely(current->audit_context))\n\t\taudit_syscall_entry(current, AUDIT_ARCH_XTENSA..);\n#endif\n}\n\nvoid do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tif ((test_thread_flag(TIF_SYSCALL_TRACE))\n\t\t\t&& (current->ptrace & PT_PTRACED))\n\t\tdo_syscall_trace();\n}\n\n"], "fixing_code": ["// TODO some minor issues\n/*\n * This file is subject to the terms and conditions of the GNU General Public\n * License.  See the file \"COPYING\" in the main directory of this archive\n * for more details.\n *\n * Copyright (C) 2001 - 2007  Tensilica Inc.\n *\n * Joe Taylor\t<joe@tensilica.com, joetylr@yahoo.com>\n * Chris Zankel <chris@zankel.net>\n * Scott Foehner<sfoehner@yahoo.com>,\n * Kevin Chea\n * Marc Gauthier<marc@tensilica.com> <marc@alumni.uwaterloo.ca>\n */\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/smp.h>\n#include <linux/security.h>\n#include <linux/signal.h>\n\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/system.h>\n#include <asm/uaccess.h>\n#include <asm/ptrace.h>\n#include <asm/elf.h>\n#include <asm/coprocessor.h>\n\n\nvoid user_enable_single_step(struct task_struct *child)\n{\n\tchild->ptrace |= PT_SINGLESTEP;\n}\n\nvoid user_disable_single_step(struct task_struct *child)\n{\n\tchild->ptrace &= ~PT_SINGLESTEP;\n}\n\n/*\n * Called by kernel/ptrace.c when detaching to disable single stepping.\n */\n\nvoid ptrace_disable(struct task_struct *child)\n{\n\t/* Nothing to do.. */\n}\n\nint ptrace_getregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\txtensa_gregset_t __user *gregset = uregs;\n\tunsigned long wm = regs->wmask;\n\tunsigned long wb = regs->windowbase;\n\tint live, i;\n\n\tif (!access_ok(VERIFY_WRITE, uregs, sizeof(xtensa_gregset_t)))\n\t\treturn -EIO;\n\n\t__put_user(regs->pc, &gregset->pc);\n\t__put_user(regs->ps & ~(1 << PS_EXCM_BIT), &gregset->ps);\n\t__put_user(regs->lbeg, &gregset->lbeg);\n\t__put_user(regs->lend, &gregset->lend);\n\t__put_user(regs->lcount, &gregset->lcount);\n\t__put_user(regs->windowstart, &gregset->windowstart);\n\t__put_user(regs->windowbase, &gregset->windowbase);\n\n\tlive = (wm & 2) ? 4 : (wm & 4) ? 8 : (wm & 8) ? 12 : 16;\n\n\tfor (i = 0; i < live; i++)\n\t\t__put_user(regs->areg[i],gregset->a+((wb*4+i)%XCHAL_NUM_AREGS));\n\tfor (i = XCHAL_NUM_AREGS - (wm >> 4) * 4; i < XCHAL_NUM_AREGS; i++)\n\t\t__put_user(regs->areg[i],gregset->a+((wb*4+i)%XCHAL_NUM_AREGS));\n\n\treturn 0;\n}\n\nint ptrace_setregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\txtensa_gregset_t *gregset = uregs;\n\tconst unsigned long ps_mask = PS_CALLINC_MASK | PS_OWB_MASK;\n\tunsigned long ps;\n\tunsigned long wb;\n\n\tif (!access_ok(VERIFY_WRITE, uregs, sizeof(xtensa_gregset_t)))\n\t\treturn -EIO;\n\n\t__get_user(regs->pc, &gregset->pc);\n\t__get_user(ps, &gregset->ps);\n\t__get_user(regs->lbeg, &gregset->lbeg);\n\t__get_user(regs->lend, &gregset->lend);\n\t__get_user(regs->lcount, &gregset->lcount);\n\t__get_user(regs->windowstart, &gregset->windowstart);\n\t__get_user(wb, &gregset->windowbase);\n\n\tregs->ps = (regs->ps & ~ps_mask) | (ps & ps_mask) | (1 << PS_EXCM_BIT);\n\n\tif (wb >= XCHAL_NUM_AREGS / 4)\n\t\treturn -EFAULT;\n\n\tregs->windowbase = wb;\n\n\tif (wb != 0 &&  __copy_from_user(regs->areg + XCHAL_NUM_AREGS - wb * 4,\n\t\t\t\t\t gregset->a, wb * 16))\n\t\treturn -EFAULT;\n\n\tif (__copy_from_user(regs->areg, gregset->a + wb*4, (WSBITS-wb) * 16))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n\nint ptrace_getxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\tstruct thread_info *ti = task_thread_info(child);\n\telf_xtregs_t __user *xtregs = uregs;\n\tint ret = 0;\n\n\tif (!access_ok(VERIFY_WRITE, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EIO;\n\n#if XTENSA_HAVE_COPROCESSORS\n\t/* Flush all coprocessor registers to memory. */\n\tcoprocessor_flush_all(ti);\n\tret |= __copy_to_user(&xtregs->cp0, &ti->xtregs_cp,\n\t\t\t      sizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_to_user(&xtregs->opt, &regs->xtregs_opt,\n\t\t\t      sizeof(xtregs->opt));\n\tret |= __copy_to_user(&xtregs->user,&ti->xtregs_user,\n\t\t\t      sizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}\n\nint ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\n\tif (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EFAULT;\n\n#if XTENSA_HAVE_COPROCESSORS\n\t/* Flush all coprocessors before we overwrite them. */\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}\n\nint ptrace_peekusr(struct task_struct *child, long regno, long __user *ret)\n{\n\tstruct pt_regs *regs;\n\tunsigned long tmp;\n\n\tregs = task_pt_regs(child);\n\ttmp = 0;  /* Default return value. */\n\n\tswitch(regno) {\n\n\t\tcase REG_AR_BASE ... REG_AR_BASE + XCHAL_NUM_AREGS - 1:\n\t\t\ttmp = regs->areg[regno - REG_AR_BASE];\n\t\t\tbreak;\n\n\t\tcase REG_A_BASE ... REG_A_BASE + 15:\n\t\t\ttmp = regs->areg[regno - REG_A_BASE];\n\t\t\tbreak;\n\n\t\tcase REG_PC:\n\t\t\ttmp = regs->pc;\n\t\t\tbreak;\n\n\t\tcase REG_PS:\n\t\t\t/* Note:  PS.EXCM is not set while user task is running;\n\t\t\t * its being set in regs is for exception handling\n\t\t\t * convenience.  */\n\t\t\ttmp = (regs->ps & ~(1 << PS_EXCM_BIT));\n\t\t\tbreak;\n\n\t\tcase REG_WB:\n\t\t\tbreak;\t\t/* tmp = 0 */\n\n\t\tcase REG_WS:\n\t\t{\n\t\t\tunsigned long wb = regs->windowbase;\n\t\t\tunsigned long ws = regs->windowstart;\n\t\t\ttmp = ((ws>>wb) | (ws<<(WSBITS-wb))) & ((1<<WSBITS)-1);\n\t\t\tbreak;\n\t\t}\n\t\tcase REG_LBEG:\n\t\t\ttmp = regs->lbeg;\n\t\t\tbreak;\n\n\t\tcase REG_LEND:\n\t\t\ttmp = regs->lend;\n\t\t\tbreak;\n\n\t\tcase REG_LCOUNT:\n\t\t\ttmp = regs->lcount;\n\t\t\tbreak;\n\n\t\tcase REG_SAR:\n\t\t\ttmp = regs->sar;\n\t\t\tbreak;\n\n\t\tcase SYSCALL_NR:\n\t\t\ttmp = regs->syscall;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t}\n\treturn put_user(tmp, ret);\n}\n\nint ptrace_pokeusr(struct task_struct *child, long regno, long val)\n{\n\tstruct pt_regs *regs;\n\tregs = task_pt_regs(child);\n\n\tswitch (regno) {\n\t\tcase REG_AR_BASE ... REG_AR_BASE + XCHAL_NUM_AREGS - 1:\n\t\t\tregs->areg[regno - REG_AR_BASE] = val;\n\t\t\tbreak;\n\n\t\tcase REG_A_BASE ... REG_A_BASE + 15:\n\t\t\tregs->areg[regno - REG_A_BASE] = val;\n\t\t\tbreak;\n\n\t\tcase REG_PC:\n\t\t\tregs->pc = val;\n\t\t\tbreak;\n\n\t\tcase SYSCALL_NR:\n\t\t\tregs->syscall = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datap = (void __user *) data;\n\n\tswitch (request) {\n\tcase PTRACE_PEEKTEXT:\t/* read word at location addr. */\n\tcase PTRACE_PEEKDATA:\n\t\tret = generic_ptrace_peekdata(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_PEEKUSR:\t/* read register specified by addr. */\n\t\tret = ptrace_peekusr(child, addr, datap);\n\t\tbreak;\n\n\tcase PTRACE_POKETEXT:\t/* write the word at location addr. */\n\tcase PTRACE_POKEDATA:\n\t\tret = generic_ptrace_pokedata(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_POKEUSR:\t/* write register specified by addr. */\n\t\tret = ptrace_pokeusr(child, addr, data);\n\t\tbreak;\n\n\tcase PTRACE_GETREGS:\n\t\tret = ptrace_getregs(child, datap);\n\t\tbreak;\n\n\tcase PTRACE_SETREGS:\n\t\tret = ptrace_setregs(child, datap);\n\t\tbreak;\n\n\tcase PTRACE_GETXTREGS:\n\t\tret = ptrace_getxregs(child, datap);\n\t\tbreak;\n\n\tcase PTRACE_SETXTREGS:\n\t\tret = ptrace_setxregs(child, datap);\n\t\tbreak;\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nvoid do_syscall_trace(void)\n{\n\t/*\n\t * The 0x80 provides a way for the tracing parent to distinguish\n\t * between a syscall stop and SIGTRAP delivery\n\t */\n\tptrace_notify(SIGTRAP|((current->ptrace & PT_TRACESYSGOOD) ? 0x80 : 0));\n\n\t/*\n\t * this isn't the same as continuing with a signal, but it will do\n\t * for normal use.  strace only continues with a signal if the\n\t * stopping signal is not SIGTRAP.  -brl\n\t */\n\tif (current->exit_code) {\n\t\tsend_sig(current->exit_code, current, 1);\n\t\tcurrent->exit_code = 0;\n\t}\n}\n\nvoid do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tif (test_thread_flag(TIF_SYSCALL_TRACE)\n\t\t\t&& (current->ptrace & PT_PTRACED))\n\t\tdo_syscall_trace();\n\n#if 0\n\tif (unlikely(current->audit_context))\n\t\taudit_syscall_entry(current, AUDIT_ARCH_XTENSA..);\n#endif\n}\n\nvoid do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tif ((test_thread_flag(TIF_SYSCALL_TRACE))\n\t\t\t&& (current->ptrace & PT_PTRACED))\n\t\tdo_syscall_trace();\n}\n\n"], "filenames": ["arch/xtensa/kernel/ptrace.c"], "buggy_code_start_loc": [149], "buggy_code_end_loc": [149], "fixing_code_start_loc": [150], "fixing_code_end_loc": [153], "type": "CWE-200", "message": "The ptrace_setxregs function in arch/xtensa/kernel/ptrace.c in the Linux kernel before 3.1 does not validate user-space pointers, which allows local users to obtain sensitive information from kernel memory locations via a crafted PTRACE_SETXTREGS request.", "other": {"cve": {"id": "CVE-2011-2707", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-24T23:55:02.010", "lastModified": "2023-02-13T01:20:11.127", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ptrace_setxregs function in arch/xtensa/kernel/ptrace.c in the Linux kernel before 3.1 does not validate user-space pointers, which allows local users to obtain sensitive information from kernel memory locations via a crafted PTRACE_SETXTREGS request."}, {"lang": "es", "value": "La funci\u00f3n ptrace_setxregs en ??arch/xtensa/kernel/ptrace.c en el kernel de Linux antes de v3.1 no valida los punteros de espacio de usuario, lo que permite a usuarios locales obtener informaci\u00f3n sensible de las posiciones de memoria del kernel a trav\u00e9s de una solicitud PTRACE_SETXTREGS modificada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1", "matchCriteriaId": "156989A4-23D9-434A-B512-9C0F3583D13D"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=0d0138ebe24b94065580bd2601f8bb7eb6152f56", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/07/20/18", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56"}}