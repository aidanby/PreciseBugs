{"buggy_code": ["/* Dropbear Note: This file is based on OpenSSH 4.3p2. Avoid unnecessary \n   changes to simplify future updates */\n\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"includes.h\"\n/*RCSID(\"$OpenBSD: scp.c,v 1.130 2006/01/31 10:35:43 djm Exp $\");*/\n\n#include \"atomicio.h\"\n#include \"compat.h\"\n#include \"scpmisc.h\"\n#include \"progressmeter.h\"\n\nvoid bwlimit(int);\n\n/* Struct for addargs */\narglist args;\n\n/* Bandwidth limit */\noff_t limit_rate = 0;\n\n/* Name of current file being transferred. */\nchar *curfile;\n\n/* This is set to non-zero to enable verbose mode. */\nint verbose_mode = 0;\n\n/* This is set to zero if the progressmeter is not desired. */\nint showprogress = 1;\n\n/* This is the program to execute for the secured connection. (\"ssh\" or -S) */\nchar *ssh_program = DROPBEAR_PATH_SSH_PROGRAM;\n\n/* This is used to store the pid of ssh_program */\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#if DROPBEAR_VFORK\n\tpid = vfork();\n#else\n\tpid = fork();\n#endif\n\tif (pid == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n#if DROPBEAR_VFORK\n\t\t_exit(1);\n#else\n\t\texit(1);\n#endif\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * This function executes the given command as the specified user on the\n * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This\n * assigns the input and output file descriptors on success.\n */\n\nstatic void\narg_setup(char *host, char *remuser, char *cmd)\n{\n\treplacearg(&args, 0, \"%s\", ssh_program);\n\tif (remuser != NULL)\n\t\taddargs(&args, \"-l%s\", remuser);\n\taddargs(&args, \"%s\", host);\n\taddargs(&args, \"%s\", cmd);\n}\n\nint\ndo_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tpipe(reserved);\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\t/* uClinux needs to build the args here before vforking,\n\t   otherwise we do it later on. */\n#if DROPBEAR_VFORK\n\targ_setup(host, remuser, cmd);\n#endif\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n#if DROPBEAR_VFORK\n\tdo_cmd_pid = vfork();\n#else\n\tdo_cmd_pid = fork();\n#endif\n\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n#if !DROPBEAR_VFORK\n\t\targ_setup(host, remuser, cmd);\n#endif\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n#if DROPBEAR_VFORK\n\t\t_exit(1);\n#else\n\t\texit(1);\n#endif\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\n#if DROPBEAR_VFORK\n\t/* clean up command */\n\t/* pop cmd */\n\txfree(args.list[args.num-1]);\n\targs.list[args.num-1]=NULL;\n\targs.num--;\n\t/* pop host */\n\txfree(args.list[args.num-1]);\n\targs.list[args.num-1]=NULL;\n\targs.num--;\n\t/* pop user */\n\tif (remuser != NULL) {\n\t\txfree(args.list[args.num-1]);\n\t\targs.list[args.num-1]=NULL;\n\t\targs.num--;\n\t}\n#endif\n\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\treturn 0;\n}\n\ntypedef struct {\n\tsize_t cnt;\n\tchar *buf;\n} BUF;\n\nBUF *allocbuf(BUF *, int, int);\nvoid lostconn(int);\nvoid nospace(void);\nint okname(char *);\nvoid run_err(const char *,...);\nvoid verifydir(char *);\n\nuid_t userid;\nint errs, remin, remout;\nint pflag, iamremote, iamrecursive, targetshouldbedirectory;\n\n#define\tCMDNEEDS\t64\nchar cmd[CMDNEEDS];\t\t/* must hold \"rcp -r -p -d\\0\" */\n\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid sink(int, char *[]);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[]);\nvoid toremote(char *, int, char *[]);\nvoid usage(void);\n\n#if defined(DBMULTI_scp) || !DROPBEAR_MULTI\n#if defined(DBMULTI_scp) && DROPBEAR_MULTI\nint scp_main(int argc, char **argv)\n#else\nint\nmain(int argc, char **argv)\n#endif\n{\n\tint ch, fflag, tflag, status;\n\tdouble speed;\n\tchar *targ, *endp;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmemset(&args, '\\0', sizeof(args));\n\targs.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q1246S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&args, \"-%c%s\", ch, optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\taddargs(&args, \"-p%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tfprintf(stderr, \"Note: -B option is disabled in this version of scp\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tspeed = strtod(optarg, &endp);\n\t\t\tif (speed <= 0 || *endp != '\\0')\n\t\t\t\tusage();\n\t\t\tlimit_rate = speed * 1024;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n#ifdef PROGRESS_METER\n\t\t\taddargs(&args, \"-q\");\n\t\t\tshowprogress = 0;\n#endif\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (!isatty(STDERR_FILENO))\n\t\tshowprogress = 0;\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif ((targ = colon(argv[argc - 1])))\t/* Dest is remote host. */\n\t\ttoremote(targ, argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t\t(void) close(remin);\n\t\tif (remout != -1)\n\t\t\t(void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n#endif /* DBMULTI_scp stuff */\n\nvoid\ntoremote(char *targ, int argc, char **argv)\n{\n\tint i, len;\n\tchar *bp, *host, *src, *suser, *thost, *tuser, *arg;\n\targlist alist;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t*targ++ = 0;\n\tif (*targ == 0)\n\t\ttarg = \".\";\n\n\targ = xstrdup(argv[argc - 1]);\n\tif ((thost = strrchr(arg, '@'))) {\n\t\t/* user@host */\n\t\t*thost++ = 0;\n\t\ttuser = arg;\n\t\tif (*tuser == '\\0')\n\t\t\ttuser = NULL;\n\t} else {\n\t\tthost = arg;\n\t\ttuser = NULL;\n\t}\n\n\tif (tuser != NULL && !okname(tuser)) {\n\t\txfree(arg);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tsrc = colon(argv[i]);\n\t\tif (src) {\t/* remote to remote */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\tif (verbose_mode)\n\t\t\t\taddargs(&alist, \"-v\");\n#if 0\n\t\t\t/* Disabled since dbclient won't understand them\n\t\t\t   and scp works fine without them. */\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings yes\");\n\t\t\taddargs(&alist, \"-n\");\n#endif\n\n\t\t\t*src++ = 0;\n\t\t\tif (*src == 0)\n\t\t\t\tsrc = \".\";\n\t\t\thost = strrchr(argv[i], '@');\n\n\t\t\tif (host) {\n\t\t\t\t*host++ = 0;\n\t\t\t\thost = cleanhostname(host);\n\t\t\t\tsuser = argv[i];\n\t\t\t\tif (*suser == '\\0')\n\t\t\t\t\tcontinue; /* pretend there wasn't any @ at all */\n\t\t\t\telse if (!okname(suser))\n\t\t\t\t\tcontinue;\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t} else {\n\t\t\t\thost = cleanhostname(argv[i]);\n\t\t\t}\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\tlen = strlen(targ) + CMDNEEDS + 20;\n\t\t\t\tbp = xmalloc(len);\n\t\t\t\t(void) snprintf(bp, len, \"%s -t %s\", cmd, targ);\n\t\t\t\thost = cleanhostname(thost);\n\t\t\t\tif (do_cmd(host, tuser, bp, &remin,\n\t\t\t\t    &remout, argc) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\t(void) xfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\n}\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tint i, len;\n\tchar *bp, *host, *src, *suser;\n\targlist alist;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tif (!(src = colon(argv[i]))) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t*src++ = 0;\n\t\tif (*src == 0)\n\t\t\tsrc = \".\";\n\t\tif ((host = strrchr(argv[i], '@')) == NULL) {\n\t\t\thost = argv[i];\n\t\t\tsuser = NULL;\n\t\t} else {\n\t\t\t*host++ = 0;\n\t\t\tsuser = argv[i];\n\t\t\tif (*suser == '\\0')\n\t\t\t\tsuser = NULL;\n\t\t}\n\t\thost = cleanhostname(host);\n\t\tlen = strlen(src) + CMDNEEDS + 20;\n\t\tbp = xmalloc(len);\n\t\t(void) snprintf(bp, len, \"%s -f %s\", cmd, src);\n\t\tif (do_cmd(host, suser, bp, &remin, &remout, argc) < 0) {\n\t\t\t(void) xfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\txfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n}\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, amt, statbytes;\n\tsize_t result;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[2048];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\trun_err(\"%s: skipping, filename contains a newline\",\n\t\t\t    name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((fd = open(name, O_RDONLY, 0)) < 0)\n\t\t\tgoto syserr;\n\t\tif (fstat(fd, &stb) < 0) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\t/*\n\t\t\t * Make it compatible with possible future\n\t\t\t * versions expecting microseconds.\n\t\t\t */\n\t\t\t(void) snprintf(buf, sizeof buf, \"T%lu 0 %lu 0\\n\",\n\t\t\t    (u_long) stb.st_mtime,\n\t\t\t    (u_long) stb.st_atime);\n\t\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\t\tif (response() < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode) {\n\t\t\tfprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t}\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, 2048)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n#endif\n\t\t/* Keep writing after an error so that we stay sync'd up. */\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tresult = atomicio(read, fd, bp->buf, amt);\n\t\t\t\tif (result != amt)\n\t\t\t\t\thaderr = errno;\n\t\t\t}\n\t\t\tif (haderr)\n\t\t\t\t(void) atomicio(vwrite, remout, bp->buf, amt);\n\t\t\telse {\n\t\t\t\tresult = atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tif (result != amt)\n\t\t\t\t\thaderr = errno;\n\t\t\t\tstatbytes += result;\n\t\t\t}\n\t\t\tif (limit_rate)\n\t\t\t\tbwlimit(amt);\n\t\t}\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n#endif\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) < 0 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t}\n}\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[1100];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == 0)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\t(void) snprintf(path, sizeof(path), \"T%lu 0 %lu 0\\n\",\n\t\t    (u_long) statp->st_mtime,\n\t\t    (u_long) statp->st_atime);\n\t\t(void) atomicio(vwrite, remout, path, strlen(path));\n\t\tif (response() < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}\n\nvoid\nbwlimit(int amount)\n{\n\tstatic struct timeval bwstart, bwend;\n\tstatic int lamt = 0, thresh = 16384;\n\tuint64_t waitlen;\n\tstruct timespec ts, rm;\n\n\tif (!timerisset(&bwstart)) {\n\t\tgettimeofday(&bwstart, NULL);\n\t\treturn;\n\t}\n\n\tlamt += amount;\n\tif (lamt < thresh)\n\t\treturn;\n\n\tgettimeofday(&bwend, NULL);\n\ttimersub(&bwend, &bwstart, &bwend);\n\tif (!timerisset(&bwend))\n\t\treturn;\n\n\tlamt *= 8;\n\twaitlen = (double)1000000L * lamt / limit_rate;\n\n\tbwstart.tv_sec = waitlen / 1000000L;\n\tbwstart.tv_usec = waitlen % 1000000L;\n\n\tif (timercmp(&bwstart, &bwend, >)) {\n\t\ttimersub(&bwstart, &bwend, &bwend);\n\n\t\t/* Adjust the wait time */\n\t\tif (bwend.tv_sec) {\n\t\t\tthresh /= 2;\n\t\t\tif (thresh < 2048)\n\t\t\t\tthresh = 2048;\n\t\t} else if (bwend.tv_usec < 100) {\n\t\t\tthresh *= 2;\n\t\t\tif (thresh > 32768)\n\t\t\t\tthresh = 32768;\n\t\t}\n\n\t\tTIMEVAL_TO_TIMESPEC(&bwend, &ts);\n\t\twhile (nanosleep(&ts, &rm) == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbreak;\n\t\t\tts = rm;\n\t\t}\n\t}\n\n\tlamt = 0;\n\tgettimeofday(&bwstart, NULL);\n}\n\nvoid\nsink(int argc, char **argv)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tenum {\n\t\tYES, NO, DISPLAYED\n\t} wrerr;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, mask, mode, ofd, omode;\n\toff_t size, statbytes;\n\tint setimes, targisdir, wrerrno = 0;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048];\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\tdo { why = str; goto screwup; } while (0)\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\"ambiguous target\");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \"\", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\"unexpected <newline>\");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\"lost connection\");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfprintf(stderr, \"Sink: %s\", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0)\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    buf + 1, strlen(buf + 1));\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\treturn;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tmtime.tv_sec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.sec not delimited\");\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.usec not delimited\");\n\t\t\tatime.tv_sec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"atime.sec not delimited\");\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0')\n\t\t\t\tSCREWUP(\"atime.usec not delimited\");\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \"rcp remote:foo\\* local:bar\".\n\t\t\t * In this case, the line \"No match.\" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\"%s\", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\"expected control record\");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\"bad mode\");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"mode not delimited\");\n\n\t\tfor (size = 0; isdigit(*cp);)\n\t\t\tsize = size * 10 + (*cp++ - '0');\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"size not delimited\");\n\t\tif ((strchr(cp, '/') != NULL) || (strcmp(cp, \"..\") == 0)) {\n\t\t\trun_err(\"error: unexpected filename: %s\", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf = NULL;\n\t\t\tstatic size_t cursize = 0;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tif (namebuf)\n\t\t\t\t\txfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \"%s%s%s\", targ,\n\t\t\t    strcmp(targ, \"/\") ? \"/\" : \"\", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\"received directory without -r\");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) < 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\tif (utimes(vect[0], tv) < 0)\n\t\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t\t    vect[0], strerror(errno));\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tif (vect[0])\n\t\t\t\txfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {\nbad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, 4096)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = NO;\n\n\t\tstatbytes = 0;\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n#endif\n\t\tfor (count = i = 0; i < size; i += 4096) {\n\t\t\tamt = 4096;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio(read, remin, cp, amt);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\"%s\", j ? strerror(errno) :\n\t\t\t\t\t    \"dropped connection\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t\tstatbytes += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (limit_rate)\n\t\t\t\tbwlimit(4096);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (wrerr == NO) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\twrerr = YES;\n\t\t\t\t\t\twrerrno = errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n#endif\n\t\tif (count != 0 && wrerr == NO &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\tif (wrerr == NO && ftruncate(ofd, size) != 0) {\n\t\t\trun_err(\"%s: truncate: %s\", np, strerror(errno));\n\t\t\twrerr = DISPLAYED;\n\t\t}\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\t(void) response();\n\t\tif (setimes && wrerr == NO) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) < 0) {\n\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t    np, strerror(errno));\n\t\t\t\twrerr = DISPLAYED;\n\t\t\t}\n\t\t}\n\t\tswitch (wrerr) {\n\t\tcase YES:\n\t\t\trun_err(\"%s: %s\", np, strerror(wrerrno));\n\t\t\tbreak;\n\t\tcase NO:\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tbreak;\n\t\tcase DISPLAYED:\n\t\t\tbreak;\n\t\t}\n\t}\nscrewup:\n\trun_err(\"protocol error: %s\", why);\n\texit(1);\n}\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote)\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO, rbuf, cp - rbuf);\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-P port] [-S program]\\n\"\n\t    \"           [[user@]host1:]file1 [...] [[user@]host2:]file2\\n\");\n\texit(1);\n}\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp = NULL;\n\tva_list ap;\n\n\t++errs;\n\tif (fp == NULL && !(fp = fdopen(remout, \"w\")))\n\t\treturn;\n\t(void) fprintf(fp, \"%c\", 0x01);\n\t(void) fprintf(fp, \"scp: \");\n\tva_start(ap, fmt);\n\t(void) vfprintf(fp, fmt, ap);\n\tva_end(ap);\n\t(void) fprintf(fp, \"\\n\");\n\t(void) fflush(fp);\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit(c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = roundup(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tif (bp->buf == NULL)\n\t\tbp->buf = xmalloc(size);\n\telse\n\t\tbp->buf = xrealloc(bp->buf, size);\n\tmemset(bp->buf, 0, size);\n\tbp->cnt = size;\n\treturn (bp);\n}\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\twrite(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}\n"], "fixing_code": ["/* Dropbear Note: This file is based on OpenSSH 4.3p2. Avoid unnecessary \n   changes to simplify future updates */\n\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n */\n\n#include \"includes.h\"\n/*RCSID(\"$OpenBSD: scp.c,v 1.130 2006/01/31 10:35:43 djm Exp $\");*/\n\n#include \"atomicio.h\"\n#include \"compat.h\"\n#include \"scpmisc.h\"\n#include \"progressmeter.h\"\n\nvoid bwlimit(int);\n\n/* Struct for addargs */\narglist args;\n\n/* Bandwidth limit */\noff_t limit_rate = 0;\n\n/* Name of current file being transferred. */\nchar *curfile;\n\n/* This is set to non-zero to enable verbose mode. */\nint verbose_mode = 0;\n\n/* This is set to zero if the progressmeter is not desired. */\nint showprogress = 1;\n\n/* This is the program to execute for the secured connection. (\"ssh\" or -S) */\nchar *ssh_program = DROPBEAR_PATH_SSH_PROGRAM;\n\n/* This is used to store the pid of ssh_program */\npid_t do_cmd_pid = -1;\n\nstatic void\nkillchild(int signo)\n{\n\tif (do_cmd_pid > 1) {\n\t\tkill(do_cmd_pid, signo ? signo : SIGTERM);\n\t\twaitpid(do_cmd_pid, NULL, 0);\n\t}\n\n\tif (signo)\n\t\t_exit(1);\n\texit(1);\n}\n\nstatic int\ndo_local_cmd(arglist *a)\n{\n\tu_int i;\n\tint status;\n\tpid_t pid;\n\n\tif (a->num == 0)\n\t\tfatal(\"do_local_cmd: no arguments\");\n\n\tif (verbose_mode) {\n\t\tfprintf(stderr, \"Executing:\");\n\t\tfor (i = 0; i < a->num; i++)\n\t\t\tfprintf(stderr, \" %s\", a->list[i]);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n#if DROPBEAR_VFORK\n\tpid = vfork();\n#else\n\tpid = fork();\n#endif\n\tif (pid == -1)\n\t\tfatal(\"do_local_cmd: fork: %s\", strerror(errno));\n\n\tif (pid == 0) {\n\t\texecvp(a->list[0], a->list);\n\t\tperror(a->list[0]);\n#if DROPBEAR_VFORK\n\t\t_exit(1);\n#else\n\t\texit(1);\n#endif\n\t}\n\n\tdo_cmd_pid = pid;\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\n\twhile (waitpid(pid, &status, 0) == -1)\n\t\tif (errno != EINTR)\n\t\t\tfatal(\"do_local_cmd: waitpid: %s\", strerror(errno));\n\n\tdo_cmd_pid = -1;\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\treturn (-1);\n\n\treturn (0);\n}\n\n/*\n * This function executes the given command as the specified user on the\n * given host.  This returns < 0 if execution fails, and >= 0 otherwise. This\n * assigns the input and output file descriptors on success.\n */\n\nstatic void\narg_setup(char *host, char *remuser, char *cmd)\n{\n\treplacearg(&args, 0, \"%s\", ssh_program);\n\tif (remuser != NULL)\n\t\taddargs(&args, \"-l%s\", remuser);\n\taddargs(&args, \"%s\", host);\n\taddargs(&args, \"%s\", cmd);\n}\n\nint\ndo_cmd(char *host, char *remuser, char *cmd, int *fdin, int *fdout, int argc)\n{\n\tint pin[2], pout[2], reserved[2];\n\n\tif (verbose_mode)\n\t\tfprintf(stderr,\n\t\t    \"Executing: program %s host %s, user %s, command %s\\n\",\n\t\t    ssh_program, host,\n\t\t    remuser ? remuser : \"(unspecified)\", cmd);\n\n\t/*\n\t * Reserve two descriptors so that the real pipes won't get\n\t * descriptors 0 and 1 because that will screw up dup2 below.\n\t */\n\tpipe(reserved);\n\n\t/* Create a socket pair for communicating with ssh. */\n\tif (pipe(pin) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\tif (pipe(pout) < 0)\n\t\tfatal(\"pipe: %s\", strerror(errno));\n\n\t/* Free the reserved descriptors. */\n\tclose(reserved[0]);\n\tclose(reserved[1]);\n\n\t/* uClinux needs to build the args here before vforking,\n\t   otherwise we do it later on. */\n#if DROPBEAR_VFORK\n\targ_setup(host, remuser, cmd);\n#endif\n\n\t/* Fork a child to execute the command on the remote host using ssh. */\n#if DROPBEAR_VFORK\n\tdo_cmd_pid = vfork();\n#else\n\tdo_cmd_pid = fork();\n#endif\n\n\tif (do_cmd_pid == 0) {\n\t\t/* Child. */\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tdup2(pin[0], 0);\n\t\tdup2(pout[1], 1);\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\n#if !DROPBEAR_VFORK\n\t\targ_setup(host, remuser, cmd);\n#endif\n\n\t\texecvp(ssh_program, args.list);\n\t\tperror(ssh_program);\n#if DROPBEAR_VFORK\n\t\t_exit(1);\n#else\n\t\texit(1);\n#endif\n\t} else if (do_cmd_pid == -1) {\n\t\tfatal(\"fork: %s\", strerror(errno));\n\t}\n\n#if DROPBEAR_VFORK\n\t/* clean up command */\n\t/* pop cmd */\n\txfree(args.list[args.num-1]);\n\targs.list[args.num-1]=NULL;\n\targs.num--;\n\t/* pop host */\n\txfree(args.list[args.num-1]);\n\targs.list[args.num-1]=NULL;\n\targs.num--;\n\t/* pop user */\n\tif (remuser != NULL) {\n\t\txfree(args.list[args.num-1]);\n\t\targs.list[args.num-1]=NULL;\n\t\targs.num--;\n\t}\n#endif\n\n\t/* Parent.  Close the other side, and return the local side. */\n\tclose(pin[0]);\n\t*fdout = pin[1];\n\tclose(pout[1]);\n\t*fdin = pout[0];\n\tsignal(SIGTERM, killchild);\n\tsignal(SIGINT, killchild);\n\tsignal(SIGHUP, killchild);\n\treturn 0;\n}\n\ntypedef struct {\n\tsize_t cnt;\n\tchar *buf;\n} BUF;\n\nBUF *allocbuf(BUF *, int, int);\nvoid lostconn(int);\nvoid nospace(void);\nint okname(char *);\nvoid run_err(const char *,...);\nvoid verifydir(char *);\n\nuid_t userid;\nint errs, remin, remout;\nint pflag, iamremote, iamrecursive, targetshouldbedirectory;\n\n#define\tCMDNEEDS\t64\nchar cmd[CMDNEEDS];\t\t/* must hold \"rcp -r -p -d\\0\" */\n\nint response(void);\nvoid rsource(char *, struct stat *);\nvoid sink(int, char *[]);\nvoid source(int, char *[]);\nvoid tolocal(int, char *[]);\nvoid toremote(char *, int, char *[]);\nvoid usage(void);\n\n#if defined(DBMULTI_scp) || !DROPBEAR_MULTI\n#if defined(DBMULTI_scp) && DROPBEAR_MULTI\nint scp_main(int argc, char **argv)\n#else\nint\nmain(int argc, char **argv)\n#endif\n{\n\tint ch, fflag, tflag, status;\n\tdouble speed;\n\tchar *targ, *endp;\n\textern char *optarg;\n\textern int optind;\n\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\tmemset(&args, '\\0', sizeof(args));\n\targs.list = NULL;\n\taddargs(&args, \"%s\", ssh_program);\n\n\tfflag = tflag = 0;\n\twhile ((ch = getopt(argc, argv, \"dfl:prtvBCc:i:P:q1246S:o:F:\")) != -1)\n\t\tswitch (ch) {\n\t\t/* User-visible flags. */\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '4':\n\t\tcase '6':\n\t\tcase 'C':\n\t\t\taddargs(&args, \"-%c\", ch);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\tcase 'c':\n\t\tcase 'i':\n\t\tcase 'F':\n\t\t\taddargs(&args, \"-%c%s\", ch, optarg);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\taddargs(&args, \"-p%s\", optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tfprintf(stderr, \"Note: -B option is disabled in this version of scp\");\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tspeed = strtod(optarg, &endp);\n\t\t\tif (speed <= 0 || *endp != '\\0')\n\t\t\t\tusage();\n\t\t\tlimit_rate = speed * 1024;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpflag = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tiamrecursive = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tssh_program = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\taddargs(&args, \"-v\");\n\t\t\tverbose_mode = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n#ifdef PROGRESS_METER\n\t\t\taddargs(&args, \"-q\");\n\t\t\tshowprogress = 0;\n#endif\n\t\t\tbreak;\n\n\t\t/* Server options. */\n\t\tcase 'd':\n\t\t\ttargetshouldbedirectory = 1;\n\t\t\tbreak;\n\t\tcase 'f':\t/* \"from\" */\n\t\t\tiamremote = 1;\n\t\t\tfflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* \"to\" */\n\t\t\tiamremote = 1;\n\t\t\ttflag = 1;\n#ifdef HAVE_CYGWIN\n\t\t\tsetmode(0, O_BINARY);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (!isatty(STDERR_FILENO))\n\t\tshowprogress = 0;\n\n\tremin = STDIN_FILENO;\n\tremout = STDOUT_FILENO;\n\n\tif (fflag) {\n\t\t/* Follow \"protocol\", send data. */\n\t\t(void) response();\n\t\tsource(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (tflag) {\n\t\t/* Receive data. */\n\t\tsink(argc, argv);\n\t\texit(errs != 0);\n\t}\n\tif (argc < 2)\n\t\tusage();\n\tif (argc > 2)\n\t\ttargetshouldbedirectory = 1;\n\n\tremin = remout = -1;\n\tdo_cmd_pid = -1;\n\t/* Command to be executed on remote system using \"ssh\". */\n\t(void) snprintf(cmd, sizeof cmd, \"scp%s%s%s%s\",\n\t    verbose_mode ? \" -v\" : \"\",\n\t    iamrecursive ? \" -r\" : \"\", pflag ? \" -p\" : \"\",\n\t    targetshouldbedirectory ? \" -d\" : \"\");\n\n\t(void) signal(SIGPIPE, lostconn);\n\n\tif ((targ = colon(argv[argc - 1])))\t/* Dest is remote host. */\n\t\ttoremote(targ, argc, argv);\n\telse {\n\t\tif (targetshouldbedirectory)\n\t\t\tverifydir(argv[argc - 1]);\n\t\ttolocal(argc, argv);\t/* Dest is local host. */\n\t}\n\t/*\n\t * Finally check the exit status of the ssh process, if one was forked\n\t * and no error has occurred yet\n\t */\n\tif (do_cmd_pid != -1 && errs == 0) {\n\t\tif (remin != -1)\n\t\t\t(void) close(remin);\n\t\tif (remout != -1)\n\t\t\t(void) close(remout);\n\t\tif (waitpid(do_cmd_pid, &status, 0) == -1)\n\t\t\terrs = 1;\n\t\telse {\n\t\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0)\n\t\t\t\terrs = 1;\n\t\t}\n\t}\n\texit(errs != 0);\n}\n#endif /* DBMULTI_scp stuff */\n\nvoid\ntoremote(char *targ, int argc, char **argv)\n{\n\tint i, len;\n\tchar *bp, *host, *src, *suser, *thost, *tuser, *arg;\n\targlist alist;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\t*targ++ = 0;\n\tif (*targ == 0)\n\t\ttarg = \".\";\n\n\targ = xstrdup(argv[argc - 1]);\n\tif ((thost = strrchr(arg, '@'))) {\n\t\t/* user@host */\n\t\t*thost++ = 0;\n\t\ttuser = arg;\n\t\tif (*tuser == '\\0')\n\t\t\ttuser = NULL;\n\t} else {\n\t\tthost = arg;\n\t\ttuser = NULL;\n\t}\n\n\tif (tuser != NULL && !okname(tuser)) {\n\t\txfree(arg);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tsrc = colon(argv[i]);\n\t\tif (src) {\t/* remote to remote */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", ssh_program);\n\t\t\tif (verbose_mode)\n\t\t\t\taddargs(&alist, \"-v\");\n#if 0\n\t\t\t/* Disabled since dbclient won't understand them\n\t\t\t   and scp works fine without them. */\n\t\t\taddargs(&alist, \"-x\");\n\t\t\taddargs(&alist, \"-oClearAllForwardings yes\");\n\t\t\taddargs(&alist, \"-n\");\n#endif\n\n\t\t\t*src++ = 0;\n\t\t\tif (*src == 0)\n\t\t\t\tsrc = \".\";\n\t\t\thost = strrchr(argv[i], '@');\n\n\t\t\tif (host) {\n\t\t\t\t*host++ = 0;\n\t\t\t\thost = cleanhostname(host);\n\t\t\t\tsuser = argv[i];\n\t\t\t\tif (*suser == '\\0')\n\t\t\t\t\tcontinue; /* pretend there wasn't any @ at all */\n\t\t\t\telse if (!okname(suser))\n\t\t\t\t\tcontinue;\n\t\t\t\taddargs(&alist, \"-l\");\n\t\t\t\taddargs(&alist, \"%s\", suser);\n\t\t\t} else {\n\t\t\t\thost = cleanhostname(argv[i]);\n\t\t\t}\n\t\t\taddargs(&alist, \"%s\", host);\n\t\t\taddargs(&alist, \"%s\", cmd);\n\t\t\taddargs(&alist, \"%s\", src);\n\t\t\taddargs(&alist, \"%s%s%s:%s\",\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ);\n\t\t\tif (do_local_cmd(&alist) != 0)\n\t\t\t\terrs = 1;\n\t\t} else {\t/* local to remote */\n\t\t\tif (remin == -1) {\n\t\t\t\tlen = strlen(targ) + CMDNEEDS + 20;\n\t\t\t\tbp = xmalloc(len);\n\t\t\t\t(void) snprintf(bp, len, \"%s -t %s\", cmd, targ);\n\t\t\t\thost = cleanhostname(thost);\n\t\t\t\tif (do_cmd(host, tuser, bp, &remin,\n\t\t\t\t    &remout, argc) < 0)\n\t\t\t\t\texit(1);\n\t\t\t\tif (response() < 0)\n\t\t\t\t\texit(1);\n\t\t\t\t(void) xfree(bp);\n\t\t\t}\n\t\t\tsource(1, argv + i);\n\t\t}\n\t}\n}\n\nvoid\ntolocal(int argc, char **argv)\n{\n\tint i, len;\n\tchar *bp, *host, *src, *suser;\n\targlist alist;\n\n\tmemset(&alist, '\\0', sizeof(alist));\n\talist.list = NULL;\n\n\tfor (i = 0; i < argc - 1; i++) {\n\t\tif (!(src = colon(argv[i]))) {\t/* Local to local. */\n\t\t\tfreeargs(&alist);\n\t\t\taddargs(&alist, \"%s\", _PATH_CP);\n\t\t\tif (iamrecursive)\n\t\t\t\taddargs(&alist, \"-r\");\n\t\t\tif (pflag)\n\t\t\t\taddargs(&alist, \"-p\");\n\t\t\taddargs(&alist, \"%s\", argv[i]);\n\t\t\taddargs(&alist, \"%s\", argv[argc-1]);\n\t\t\tif (do_local_cmd(&alist))\n\t\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\t*src++ = 0;\n\t\tif (*src == 0)\n\t\t\tsrc = \".\";\n\t\tif ((host = strrchr(argv[i], '@')) == NULL) {\n\t\t\thost = argv[i];\n\t\t\tsuser = NULL;\n\t\t} else {\n\t\t\t*host++ = 0;\n\t\t\tsuser = argv[i];\n\t\t\tif (*suser == '\\0')\n\t\t\t\tsuser = NULL;\n\t\t}\n\t\thost = cleanhostname(host);\n\t\tlen = strlen(src) + CMDNEEDS + 20;\n\t\tbp = xmalloc(len);\n\t\t(void) snprintf(bp, len, \"%s -f %s\", cmd, src);\n\t\tif (do_cmd(host, suser, bp, &remin, &remout, argc) < 0) {\n\t\t\t(void) xfree(bp);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\txfree(bp);\n\t\tsink(1, argv + argc - 1);\n\t\t(void) close(remin);\n\t\tremin = remout = -1;\n\t}\n}\n\nvoid\nsource(int argc, char **argv)\n{\n\tstruct stat stb;\n\tstatic BUF buffer;\n\tBUF *bp;\n\toff_t i, amt, statbytes;\n\tsize_t result;\n\tint fd = -1, haderr, indx;\n\tchar *last, *name, buf[2048];\n\tint len;\n\n\tfor (indx = 0; indx < argc; ++indx) {\n\t\tname = argv[indx];\n\t\tstatbytes = 0;\n\t\tlen = strlen(name);\n\t\twhile (len > 1 && name[len-1] == '/')\n\t\t\tname[--len] = '\\0';\n\t\tif (strchr(name, '\\n') != NULL) {\n\t\t\trun_err(\"%s: skipping, filename contains a newline\",\n\t\t\t    name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((fd = open(name, O_RDONLY, 0)) < 0)\n\t\t\tgoto syserr;\n\t\tif (fstat(fd, &stb) < 0) {\nsyserr:\t\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\t\tgoto next;\n\t\t}\n\t\tswitch (stb.st_mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\tif (iamrecursive) {\n\t\t\t\trsource(name, &stb);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\t/* FALLTHROUGH */\n\t\tdefault:\n\t\t\trun_err(\"%s: not a regular file\", name);\n\t\t\tgoto next;\n\t\t}\n\t\tif ((last = strrchr(name, '/')) == NULL)\n\t\t\tlast = name;\n\t\telse\n\t\t\t++last;\n\t\tcurfile = last;\n\t\tif (pflag) {\n\t\t\t/*\n\t\t\t * Make it compatible with possible future\n\t\t\t * versions expecting microseconds.\n\t\t\t */\n\t\t\t(void) snprintf(buf, sizeof buf, \"T%lu 0 %lu 0\\n\",\n\t\t\t    (u_long) stb.st_mtime,\n\t\t\t    (u_long) stb.st_atime);\n\t\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\t\tif (response() < 0)\n\t\t\t\tgoto next;\n\t\t}\n#define\tFILEMODEMASK\t(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)\n\t\tsnprintf(buf, sizeof buf, \"C%04o %lld %s\\n\",\n\t\t    (u_int) (stb.st_mode & FILEMODEMASK),\n\t\t    (long long)stb.st_size, last);\n\t\tif (verbose_mode) {\n\t\t\tfprintf(stderr, \"Sending file modes: %s\", buf);\n\t\t}\n\t\t(void) atomicio(vwrite, remout, buf, strlen(buf));\n\t\tif (response() < 0)\n\t\t\tgoto next;\n\t\tif ((bp = allocbuf(&buffer, fd, 2048)) == NULL) {\nnext:\t\t\tif (fd != -1) {\n\t\t\t\t(void) close(fd);\n\t\t\t\tfd = -1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, stb.st_size, &statbytes);\n#endif\n\t\t/* Keep writing after an error so that we stay sync'd up. */\n\t\tfor (haderr = i = 0; i < stb.st_size; i += bp->cnt) {\n\t\t\tamt = bp->cnt;\n\t\t\tif (i + amt > stb.st_size)\n\t\t\t\tamt = stb.st_size - i;\n\t\t\tif (!haderr) {\n\t\t\t\tresult = atomicio(read, fd, bp->buf, amt);\n\t\t\t\tif (result != amt)\n\t\t\t\t\thaderr = errno;\n\t\t\t}\n\t\t\tif (haderr)\n\t\t\t\t(void) atomicio(vwrite, remout, bp->buf, amt);\n\t\t\telse {\n\t\t\t\tresult = atomicio(vwrite, remout, bp->buf, amt);\n\t\t\t\tif (result != amt)\n\t\t\t\t\thaderr = errno;\n\t\t\t\tstatbytes += result;\n\t\t\t}\n\t\t\tif (limit_rate)\n\t\t\t\tbwlimit(amt);\n\t\t}\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n#endif\n\n\t\tif (fd != -1) {\n\t\t\tif (close(fd) < 0 && !haderr)\n\t\t\t\thaderr = errno;\n\t\t\tfd = -1;\n\t\t}\n\t\tif (!haderr)\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\telse\n\t\t\trun_err(\"%s: %s\", name, strerror(haderr));\n\t\t(void) response();\n\t}\n}\n\nvoid\nrsource(char *name, struct stat *statp)\n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *last, *vect[1], path[1100];\n\n\tif (!(dirp = opendir(name))) {\n\t\trun_err(\"%s: %s\", name, strerror(errno));\n\t\treturn;\n\t}\n\tlast = strrchr(name, '/');\n\tif (last == 0)\n\t\tlast = name;\n\telse\n\t\tlast++;\n\tif (pflag) {\n\t\t(void) snprintf(path, sizeof(path), \"T%lu 0 %lu 0\\n\",\n\t\t    (u_long) statp->st_mtime,\n\t\t    (u_long) statp->st_atime);\n\t\t(void) atomicio(vwrite, remout, path, strlen(path));\n\t\tif (response() < 0) {\n\t\t\tclosedir(dirp);\n\t\t\treturn;\n\t\t}\n\t}\n\t(void) snprintf(path, sizeof path, \"D%04o %d %.1024s\\n\",\n\t    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);\n\tif (verbose_mode)\n\t\tfprintf(stderr, \"Entering directory: %s\", path);\n\t(void) atomicio(vwrite, remout, path, strlen(path));\n\tif (response() < 0) {\n\t\tclosedir(dirp);\n\t\treturn;\n\t}\n\twhile ((dp = readdir(dirp)) != NULL) {\n\t\tif (dp->d_ino == 0)\n\t\t\tcontinue;\n\t\tif (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {\n\t\t\trun_err(\"%s/%s: name too long\", name, dp->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\t(void) snprintf(path, sizeof path, \"%s/%s\", name, dp->d_name);\n\t\tvect[0] = path;\n\t\tsource(1, vect);\n\t}\n\t(void) closedir(dirp);\n\t(void) atomicio(vwrite, remout, \"E\\n\", 2);\n\t(void) response();\n}\n\nvoid\nbwlimit(int amount)\n{\n\tstatic struct timeval bwstart, bwend;\n\tstatic int lamt = 0, thresh = 16384;\n\tuint64_t waitlen;\n\tstruct timespec ts, rm;\n\n\tif (!timerisset(&bwstart)) {\n\t\tgettimeofday(&bwstart, NULL);\n\t\treturn;\n\t}\n\n\tlamt += amount;\n\tif (lamt < thresh)\n\t\treturn;\n\n\tgettimeofday(&bwend, NULL);\n\ttimersub(&bwend, &bwstart, &bwend);\n\tif (!timerisset(&bwend))\n\t\treturn;\n\n\tlamt *= 8;\n\twaitlen = (double)1000000L * lamt / limit_rate;\n\n\tbwstart.tv_sec = waitlen / 1000000L;\n\tbwstart.tv_usec = waitlen % 1000000L;\n\n\tif (timercmp(&bwstart, &bwend, >)) {\n\t\ttimersub(&bwstart, &bwend, &bwend);\n\n\t\t/* Adjust the wait time */\n\t\tif (bwend.tv_sec) {\n\t\t\tthresh /= 2;\n\t\t\tif (thresh < 2048)\n\t\t\t\tthresh = 2048;\n\t\t} else if (bwend.tv_usec < 100) {\n\t\t\tthresh *= 2;\n\t\t\tif (thresh > 32768)\n\t\t\t\tthresh = 32768;\n\t\t}\n\n\t\tTIMEVAL_TO_TIMESPEC(&bwend, &ts);\n\t\twhile (nanosleep(&ts, &rm) == -1) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbreak;\n\t\t\tts = rm;\n\t\t}\n\t}\n\n\tlamt = 0;\n\tgettimeofday(&bwstart, NULL);\n}\n\nvoid\nsink(int argc, char **argv)\n{\n\tstatic BUF buffer;\n\tstruct stat stb;\n\tenum {\n\t\tYES, NO, DISPLAYED\n\t} wrerr;\n\tBUF *bp;\n\toff_t i;\n\tsize_t j, count;\n\tint amt, exists, first, mask, mode, ofd, omode;\n\toff_t size, statbytes;\n\tint setimes, targisdir, wrerrno = 0;\n\tchar ch, *cp, *np, *targ, *why, *vect[1], buf[2048];\n\tstruct timeval tv[2];\n\n#define\tatime\ttv[0]\n#define\tmtime\ttv[1]\n#define\tSCREWUP(str)\tdo { why = str; goto screwup; } while (0)\n\n\tsetimes = targisdir = 0;\n\tmask = umask(0);\n\tif (!pflag)\n\t\t(void) umask(mask);\n\tif (argc != 1) {\n\t\trun_err(\"ambiguous target\");\n\t\texit(1);\n\t}\n\ttarg = *argv;\n\tif (targetshouldbedirectory)\n\t\tverifydir(targ);\n\n\t(void) atomicio(vwrite, remout, \"\", 1);\n\tif (stat(targ, &stb) == 0 && S_ISDIR(stb.st_mode))\n\t\ttargisdir = 1;\n\tfor (first = 1;; first = 0) {\n\t\tcp = buf;\n\t\tif (atomicio(read, remin, cp, 1) != 1)\n\t\t\treturn;\n\t\tif (*cp++ == '\\n')\n\t\t\tSCREWUP(\"unexpected <newline>\");\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tSCREWUP(\"lost connection\");\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &buf[sizeof(buf) - 1] && ch != '\\n');\n\t\t*cp = 0;\n\t\tif (verbose_mode)\n\t\t\tfprintf(stderr, \"Sink: %s\", buf);\n\n\t\tif (buf[0] == '\\01' || buf[0] == '\\02') {\n\t\t\tif (iamremote == 0)\n\t\t\t\t(void) atomicio(vwrite, STDERR_FILENO,\n\t\t\t\t    buf + 1, strlen(buf + 1));\n\t\t\tif (buf[0] == '\\02')\n\t\t\t\texit(1);\n\t\t\t++errs;\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[0] == 'E') {\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\treturn;\n\t\t}\n\t\tif (ch == '\\n')\n\t\t\t*--cp = 0;\n\n\t\tcp = buf;\n\t\tif (*cp == 'T') {\n\t\t\tsetimes++;\n\t\t\tcp++;\n\t\t\tmtime.tv_sec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.sec not delimited\");\n\t\t\tmtime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"mtime.usec not delimited\");\n\t\t\tatime.tv_sec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != ' ')\n\t\t\t\tSCREWUP(\"atime.sec not delimited\");\n\t\t\tatime.tv_usec = strtol(cp, &cp, 10);\n\t\t\tif (!cp || *cp++ != '\\0')\n\t\t\t\tSCREWUP(\"atime.usec not delimited\");\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (*cp != 'C' && *cp != 'D') {\n\t\t\t/*\n\t\t\t * Check for the case \"rcp remote:foo\\* local:bar\".\n\t\t\t * In this case, the line \"No match.\" can be returned\n\t\t\t * by the shell before the rcp command on the remote is\n\t\t\t * executed so the ^Aerror_message convention isn't\n\t\t\t * followed.\n\t\t\t */\n\t\t\tif (first) {\n\t\t\t\trun_err(\"%s\", cp);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tSCREWUP(\"expected control record\");\n\t\t}\n\t\tmode = 0;\n\t\tfor (++cp; cp < buf + 5; cp++) {\n\t\t\tif (*cp < '0' || *cp > '7')\n\t\t\t\tSCREWUP(\"bad mode\");\n\t\t\tmode = (mode << 3) | (*cp - '0');\n\t\t}\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"mode not delimited\");\n\n\t\tfor (size = 0; isdigit(*cp);)\n\t\t\tsize = size * 10 + (*cp++ - '0');\n\t\tif (*cp++ != ' ')\n\t\t\tSCREWUP(\"size not delimited\");\n\t\tif (*cp == '\\0' || strchr(cp, '/') != NULL ||\n\t\t    strcmp(cp, \".\") == 0 || strcmp(cp, \"..\") == 0) {\n\t\t\trun_err(\"error: unexpected filename: %s\", cp);\n\t\t\texit(1);\n\t\t}\n\t\tif (targisdir) {\n\t\t\tstatic char *namebuf = NULL;\n\t\t\tstatic size_t cursize = 0;\n\t\t\tsize_t need;\n\n\t\t\tneed = strlen(targ) + strlen(cp) + 250;\n\t\t\tif (need > cursize) {\n\t\t\t\tif (namebuf)\n\t\t\t\t\txfree(namebuf);\n\t\t\t\tnamebuf = xmalloc(need);\n\t\t\t\tcursize = need;\n\t\t\t}\n\t\t\t(void) snprintf(namebuf, need, \"%s%s%s\", targ,\n\t\t\t    strcmp(targ, \"/\") ? \"/\" : \"\", cp);\n\t\t\tnp = namebuf;\n\t\t} else\n\t\t\tnp = targ;\n\t\tcurfile = cp;\n\t\texists = stat(np, &stb) == 0;\n\t\tif (buf[0] == 'D') {\n\t\t\tint mod_flag = pflag;\n\t\t\tif (!iamrecursive)\n\t\t\t\tSCREWUP(\"received directory without -r\");\n\t\t\tif (exists) {\n\t\t\t\tif (!S_ISDIR(stb.st_mode)) {\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tif (pflag)\n\t\t\t\t\t(void) chmod(np, mode);\n\t\t\t} else {\n\t\t\t\t/* Handle copying from a read-only\n\t\t\t\t   directory */\n\t\t\t\tmod_flag = 1;\n\t\t\t\tif (mkdir(np, mode | S_IRWXU) < 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tvect[0] = xstrdup(np);\n\t\t\tsink(1, vect);\n\t\t\tif (setimes) {\n\t\t\t\tsetimes = 0;\n\t\t\t\tif (utimes(vect[0], tv) < 0)\n\t\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t\t    vect[0], strerror(errno));\n\t\t\t}\n\t\t\tif (mod_flag)\n\t\t\t\t(void) chmod(vect[0], mode);\n\t\t\tif (vect[0])\n\t\t\t\txfree(vect[0]);\n\t\t\tcontinue;\n\t\t}\n\t\tomode = mode;\n\t\tmode |= S_IWUSR;\n\t\tif ((ofd = open(np, O_WRONLY|O_CREAT, mode)) < 0) {\nbad:\t\t\trun_err(\"%s: %s\", np, strerror(errno));\n\t\t\tcontinue;\n\t\t}\n\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\tif ((bp = allocbuf(&buffer, ofd, 4096)) == NULL) {\n\t\t\t(void) close(ofd);\n\t\t\tcontinue;\n\t\t}\n\t\tcp = bp->buf;\n\t\twrerr = NO;\n\n\t\tstatbytes = 0;\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstart_progress_meter(curfile, size, &statbytes);\n#endif\n\t\tfor (count = i = 0; i < size; i += 4096) {\n\t\t\tamt = 4096;\n\t\t\tif (i + amt > size)\n\t\t\t\tamt = size - i;\n\t\t\tcount += amt;\n\t\t\tdo {\n\t\t\t\tj = atomicio(read, remin, cp, amt);\n\t\t\t\tif (j == 0) {\n\t\t\t\t\trun_err(\"%s\", j ? strerror(errno) :\n\t\t\t\t\t    \"dropped connection\");\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tamt -= j;\n\t\t\t\tcp += j;\n\t\t\t\tstatbytes += j;\n\t\t\t} while (amt > 0);\n\n\t\t\tif (limit_rate)\n\t\t\t\tbwlimit(4096);\n\n\t\t\tif (count == bp->cnt) {\n\t\t\t\t/* Keep reading so we stay sync'd up. */\n\t\t\t\tif (wrerr == NO) {\n\t\t\t\t\tif (atomicio(vwrite, ofd, bp->buf,\n\t\t\t\t\t    count) != count) {\n\t\t\t\t\t\twrerr = YES;\n\t\t\t\t\t\twrerrno = errno;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\tcp = bp->buf;\n\t\t\t}\n\t\t}\n#ifdef PROGRESS_METER\n\t\tif (showprogress)\n\t\t\tstop_progress_meter();\n#endif\n\t\tif (count != 0 && wrerr == NO &&\n\t\t    atomicio(vwrite, ofd, bp->buf, count) != count) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\tif (wrerr == NO && ftruncate(ofd, size) != 0) {\n\t\t\trun_err(\"%s: truncate: %s\", np, strerror(errno));\n\t\t\twrerr = DISPLAYED;\n\t\t}\n\t\tif (pflag) {\n\t\t\tif (exists || omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t} else {\n\t\t\tif (!exists && omode != mode)\n#ifdef HAVE_FCHMOD\n\t\t\t\tif (fchmod(ofd, omode & ~mask)) {\n#else /* HAVE_FCHMOD */\n\t\t\t\tif (chmod(np, omode & ~mask)) {\n#endif /* HAVE_FCHMOD */\n\t\t\t\t\trun_err(\"%s: set mode: %s\",\n\t\t\t\t\t    np, strerror(errno));\n\t\t\t\t\twrerr = DISPLAYED;\n\t\t\t\t}\n\t\t}\n\t\tif (close(ofd) == -1) {\n\t\t\twrerr = YES;\n\t\t\twrerrno = errno;\n\t\t}\n\t\t(void) response();\n\t\tif (setimes && wrerr == NO) {\n\t\t\tsetimes = 0;\n\t\t\tif (utimes(np, tv) < 0) {\n\t\t\t\trun_err(\"%s: set times: %s\",\n\t\t\t\t    np, strerror(errno));\n\t\t\t\twrerr = DISPLAYED;\n\t\t\t}\n\t\t}\n\t\tswitch (wrerr) {\n\t\tcase YES:\n\t\t\trun_err(\"%s: %s\", np, strerror(wrerrno));\n\t\t\tbreak;\n\t\tcase NO:\n\t\t\t(void) atomicio(vwrite, remout, \"\", 1);\n\t\t\tbreak;\n\t\tcase DISPLAYED:\n\t\t\tbreak;\n\t\t}\n\t}\nscrewup:\n\trun_err(\"protocol error: %s\", why);\n\texit(1);\n}\n\nint\nresponse(void)\n{\n\tchar ch, *cp, resp, rbuf[2048];\n\n\tif (atomicio(read, remin, &resp, sizeof(resp)) != sizeof(resp))\n\t\tlostconn(0);\n\n\tcp = rbuf;\n\tswitch (resp) {\n\tcase 0:\t\t/* ok */\n\t\treturn (0);\n\tdefault:\n\t\t*cp++ = resp;\n\t\t/* FALLTHROUGH */\n\tcase 1:\t\t/* error, followed by error msg */\n\tcase 2:\t\t/* fatal error, \"\" */\n\t\tdo {\n\t\t\tif (atomicio(read, remin, &ch, sizeof(ch)) != sizeof(ch))\n\t\t\t\tlostconn(0);\n\t\t\t*cp++ = ch;\n\t\t} while (cp < &rbuf[sizeof(rbuf) - 1] && ch != '\\n');\n\n\t\tif (!iamremote)\n\t\t\t(void) atomicio(vwrite, STDERR_FILENO, rbuf, cp - rbuf);\n\t\t++errs;\n\t\tif (resp == 1)\n\t\t\treturn (-1);\n\t\texit(1);\n\t}\n\t/* NOTREACHED */\n}\n\nvoid\nusage(void)\n{\n\t(void) fprintf(stderr,\n\t    \"usage: scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]\\n\"\n\t    \"           [-l limit] [-P port] [-S program]\\n\"\n\t    \"           [[user@]host1:]file1 [...] [[user@]host2:]file2\\n\");\n\texit(1);\n}\n\nvoid\nrun_err(const char *fmt,...)\n{\n\tstatic FILE *fp = NULL;\n\tva_list ap;\n\n\t++errs;\n\tif (fp == NULL && !(fp = fdopen(remout, \"w\")))\n\t\treturn;\n\t(void) fprintf(fp, \"%c\", 0x01);\n\t(void) fprintf(fp, \"scp: \");\n\tva_start(ap, fmt);\n\t(void) vfprintf(fp, fmt, ap);\n\tva_end(ap);\n\t(void) fprintf(fp, \"\\n\");\n\t(void) fflush(fp);\n\n\tif (!iamremote) {\n\t\tva_start(ap, fmt);\n\t\tvfprintf(stderr, fmt, ap);\n\t\tva_end(ap);\n\t\tfprintf(stderr, \"\\n\");\n\t}\n}\n\nvoid\nverifydir(char *cp)\n{\n\tstruct stat stb;\n\n\tif (!stat(cp, &stb)) {\n\t\tif (S_ISDIR(stb.st_mode))\n\t\t\treturn;\n\t\terrno = ENOTDIR;\n\t}\n\trun_err(\"%s: %s\", cp, strerror(errno));\n\tkillchild(0);\n}\n\nint\nokname(char *cp0)\n{\n\tint c;\n\tchar *cp;\n\n\tcp = cp0;\n\tdo {\n\t\tc = (int)*cp;\n\t\tif (c & 0200)\n\t\t\tgoto bad;\n\t\tif (!isalpha(c) && !isdigit(c)) {\n\t\t\tswitch (c) {\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\tcase '`':\n\t\t\tcase ' ':\n\t\t\tcase '#':\n\t\t\t\tgoto bad;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (*++cp);\n\treturn (1);\n\nbad:\tfprintf(stderr, \"%s: invalid user name\\n\", cp0);\n\treturn (0);\n}\n\nBUF *\nallocbuf(BUF *bp, int fd, int blksize)\n{\n\tsize_t size;\n#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE\n\tstruct stat stb;\n\n\tif (fstat(fd, &stb) < 0) {\n\t\trun_err(\"fstat: %s\", strerror(errno));\n\t\treturn (0);\n\t}\n\tsize = roundup(stb.st_blksize, blksize);\n\tif (size == 0)\n\t\tsize = blksize;\n#else /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tsize = blksize;\n#endif /* HAVE_STRUCT_STAT_ST_BLKSIZE */\n\tif (bp->cnt >= size)\n\t\treturn (bp);\n\tif (bp->buf == NULL)\n\t\tbp->buf = xmalloc(size);\n\telse\n\t\tbp->buf = xrealloc(bp->buf, size);\n\tmemset(bp->buf, 0, size);\n\tbp->cnt = size;\n\treturn (bp);\n}\n\nvoid\nlostconn(int signo)\n{\n\tif (!iamremote)\n\t\twrite(STDERR_FILENO, \"lost connection\\n\", 16);\n\tif (signo)\n\t\t_exit(1);\n\telse\n\t\texit(1);\n}\n"], "filenames": ["scp.c"], "buggy_code_start_loc": [938], "buggy_code_end_loc": [939], "fixing_code_start_loc": [938], "fixing_code_end_loc": [940], "type": "NVD-CWE-noinfo", "message": "scp.c in Dropbear before 2020.79 mishandles the filename of . or an empty filename, a related issue to CVE-2018-20685.", "other": {"cve": {"id": "CVE-2020-36254", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-25T09:15:13.037", "lastModified": "2021-09-17T15:34:06.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "scp.c in Dropbear before 2020.79 mishandles the filename of . or an empty filename, a related issue to CVE-2018-20685."}, {"lang": "es", "value": "El archivo scp.c en Dropbear versiones anteriores a 2020.79, maneja inapropiadamente un nombre de archivo de .&#xa0;o un nombre de archivo vac\u00edo, un problema relacionado con el CVE-2018-20685"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dropbear_ssh_project:dropbear_ssh:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020.79", "matchCriteriaId": "41663E8F-D5CD-4C2B-BFC3-DB866E785D4D"}]}]}], "references": [{"url": "https://github.com/mkj/dropbear/commit/8f8a3dff705fad774a10864a2e3dbcfa9779ceff", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mkj/dropbear/commit/8f8a3dff705fad774a10864a2e3dbcfa9779ceff"}}