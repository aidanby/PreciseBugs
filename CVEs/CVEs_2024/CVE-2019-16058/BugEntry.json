{"buggy_code": ["/*\n * libp11 PAM Login Module\n * Copyright (C) 2003 Mario Strasser <mast@gmx.net>,\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifndef PACKAGE\n#define PACKAGE \"pam_p11\"\n#endif\n\n#include <syslog.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <openssl/crypto.h>\n#include <libp11.h>\n#include <regex.h>\n\n/* openssl deprecated API emulation */\n#ifndef HAVE_EVP_MD_CTX_NEW\n#define EVP_MD_CTX_new()\tEVP_MD_CTX_create()\n#endif\n#ifndef HAVE_EVP_MD_CTX_FREE\n#define EVP_MD_CTX_free(ctx)\tEVP_MD_CTX_destroy((ctx))\n#endif\n#ifndef HAVE_EVP_MD_CTX_RESET\n#define EVP_MD_CTX_reset(ctx)\tEVP_MD_CTX_cleanup((ctx))\n#endif\n\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#include <locale.h>\n#define _(string) gettext(string)\n#ifndef LOCALEDIR\n#define LOCALEDIR \"/usr/share/locale\"\n#endif\n#else\n#define _(string) string\n#endif\n\n/* We have to make this definitions before we include the pam header files! */\n#define PAM_SM_AUTH\n#define PAM_SM_ACCOUNT\n#define PAM_SM_SESSION\n#define PAM_SM_PASSWORD\n#include <security/pam_appl.h>\n#include <security/pam_modules.h>\n#ifdef HAVE_SECURITY_PAM_EXT_H\n#include <security/pam_ext.h>\n#else\n#define pam_syslog(handle, level, msg...) syslog(level, ## msg)\n#endif\n\n#ifndef HAVE_PAM_VPROMPT\nstatic int pam_vprompt(pam_handle_t *pamh, int style, char **response,\n\t\tconst char *fmt, va_list args)\n{\n\tint r = PAM_CRED_INSUFFICIENT;\n\tconst struct pam_conv *conv;\n\tstruct pam_message msg;\n\tstruct pam_response *resp = NULL;\n\tstruct pam_message *(msgp[1]);\n\n\tchar text[128];\n\tvsnprintf(text, sizeof text, fmt, args);\n\n\tmsgp[0] = &msg;\n\tmsg.msg_style = style;\n\tmsg.msg = text;\n\n\tif (PAM_SUCCESS != pam_get_item(pamh, PAM_CONV, (const void **) &conv)\n\t\t\t|| NULL == conv || NULL == conv->conv\n\t\t\t|| conv->conv(1, (const struct pam_message **) msgp, &resp, conv->appdata_ptr)\n\t\t\t|| NULL == resp) {\n\t\tgoto err;\n\t}\n\tif (NULL != response) {\n\t\tif (resp[0].resp) {\n\t\t\t*response = strdup(resp[0].resp);\n\t\t\tif (NULL == *response) {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"strdup() failed: %s\",\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\t*response = NULL;\n\t\t}\n\t}\n\n\tr = PAM_SUCCESS;\nerr:\n\tif (resp) {\n\t\tOPENSSL_cleanse(&resp[0].resp, sizeof resp[0].resp);\n\t\tfree(&resp[0]);\n\t}\n\treturn r;\n}\n#endif\n\n#ifndef PAM_EXTERN\n#define PAM_EXTERN extern\n#endif\n\nint prompt(int flags, pam_handle_t *pamh, int style, char **response,\n\t\tconst char *fmt, ...)\n{\n\tint r;\n\n\tif (PAM_SILENT == (flags & PAM_SILENT)\n\t\t\t&& style != PAM_TEXT_INFO\n\t\t\t&& style != PAM_PROMPT_ECHO_OFF) {\n\t\t/* PAM_SILENT does not override the prompting of the user for passwords\n\t\t * etc., it only stops informative messages from being generated. We\n\t\t * use PAM_TEXT_INFO and PAM_PROMPT_ECHO_OFF exclusively for the\n\t\t * password prompt. */\n\t\tr = PAM_SUCCESS;\n\t} else {\n\t\tva_list args;\n\t\tva_start (args, fmt);\n\t\tif (!response) {\n\t\t\tchar *p = NULL;\n\t\t\tr = pam_vprompt(pamh, style, &p, fmt, args);\n\t\t\tfree(p);\n\t\t} else {\n\t\t\tr = pam_vprompt(pamh, style, response, fmt, args);\n\t\t}\n\t\tva_end(args);\n\t}\n\n\treturn r;\n}\n\nstruct module_data {\n\tPKCS11_CTX *ctx;\n\tPKCS11_SLOT *slots;\n\tunsigned int nslots;\n\tint module_loaded;\n};\n\n#ifdef TEST\nstatic struct module_data *global_module_data = NULL;\n#endif\n\nvoid module_data_cleanup(pam_handle_t *pamh, void *data, int error_status)\n{\n\tstruct module_data *module_data = data;\n\tif (module_data) {\n\t\tif (1 == module_data->module_loaded) {\n\t\t\tPKCS11_release_all_slots(module_data->ctx, module_data->slots, module_data->nslots);\n\t\t\tPKCS11_CTX_unload(module_data->ctx);\n\t\t}\n\t\tPKCS11_CTX_free(module_data->ctx);\n\t\tEVP_cleanup();\n\t\tERR_free_strings();\n\t\tfree(module_data);\n\t}\n}\n\nstatic int module_initialize(pam_handle_t * pamh,\n\t\tint flags, int argc, const char **argv,\n\t\tstruct module_data **module_data)\n{\n\tint r;\n\tstruct module_data *data = calloc(1, sizeof *data);\n\tif (NULL == data) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"calloc() failed: %s\",\n\t\t\t\tstrerror(errno));\n\t\tr = PAM_BUF_ERR;\n\t\tgoto err;\n\t}\n\n#ifdef ENABLE_NLS\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n#endif\n\n\t/* Initialize OpenSSL */\n\tOpenSSL_add_all_algorithms();\n\tERR_load_crypto_strings();\n\n\t/* Load and initialize PKCS#11 module */\n\tdata->ctx = PKCS11_CTX_new();\n\tif (0 == argc || NULL == data->ctx\n\t\t\t|| 0 != PKCS11_CTX_load(data->ctx, argv[0])) {\n\t\tpam_syslog(pamh, LOG_ALERT, \"Loading PKCS#11 engine failed: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"Error loading PKCS#11 module\"));\n\t\tr = PAM_NO_MODULE_DATA;\n\t\tgoto err;\n\t}\n\tdata->module_loaded = 1;\n\tif (0 != PKCS11_enumerate_slots(data->ctx, &data->slots, &data->nslots)) {\n\t\tpam_syslog(pamh, LOG_ALERT, \"Initializing PKCS#11 engine failed: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"Error initializing PKCS#11 module\"));\n\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\tgoto err;\n\t}\n\n#ifdef TEST\n\t/* pam_set_data() is reserved for actual modules. For testing this would\n\t * return PAM_SYSTEM_ERR, so we're saving the module data in a static\n\t * variable. */\n\tr = PAM_SUCCESS;\n\tglobal_module_data = data;\n#else\n\tr = pam_set_data(pamh, PACKAGE, data, module_data_cleanup);\n\tif (PAM_SUCCESS != r) {\n\t\tgoto err;\n\t}\n#endif\n\n\t*module_data = data;\n\tdata = NULL;\n\nerr:\n\tmodule_data_cleanup(pamh, data, r);\n\n\treturn r;\n}\n\nstatic int module_refresh(pam_handle_t *pamh,\n\t\tint flags, int argc, const char **argv,\n\t\tconst char **user, PKCS11_CTX **ctx,\n\t\tPKCS11_SLOT **slots, unsigned int *nslots,\n\t\tconst char **pin_regex)\n{\n\tint r;\n\tstruct module_data *module_data;\n\n\tif (PAM_SUCCESS != pam_get_data(pamh, PACKAGE, (void *)&module_data)\n\t\t\t|| NULL == module_data) {\n\t\tr = module_initialize(pamh, flags, argc, argv, &module_data);\n\t\tif (PAM_SUCCESS != r) {\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\t/* refresh all known slots */\n\t\tPKCS11_release_all_slots(module_data->ctx,\n\t\t\t\tmodule_data->slots, module_data->nslots);\n\t\tmodule_data->slots = NULL;\n\t\tmodule_data->nslots = 0;\n\t\tif (0 != PKCS11_enumerate_slots(module_data->ctx,\n\t\t\t\t\t&module_data->slots, &module_data->nslots)) {\n\t\t\tpam_syslog(pamh, LOG_ALERT, \"Initializing PKCS#11 engine failed: %s\\n\",\n\t\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"Error initializing PKCS#11 module\"));\n\t\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (1 < argc) {\n\t\t*pin_regex = argv[1];\n\t} else {\n#ifdef __APPLE__\n\t\t/* If multiple PAMs are allowed for macOS' login, then the captured\n\t\t * password is used for all possible modules. To not block the token's\n\t\t * PIN if the user enters his standard password, we're refusing to use\n\t\t * anything that doesn't look like a PIN. */\n\t\t*pin_regex = \"^[[:digit:]]*$\";\n#else\n\t\t*pin_regex = NULL;\n#endif\n\t}\n\n\tr = pam_get_user(pamh, user, NULL);\n\tif (PAM_SUCCESS != r) {\n\t\tpam_syslog(pamh, LOG_ERR, \"pam_get_user() failed %s\",\n\t\t\t\tpam_strerror(pamh, r));\n\t\tr = PAM_USER_UNKNOWN;\n\t\tgoto err;\n\t}\n\n\t*ctx = module_data->ctx;\n\t*nslots = module_data->nslots;\n\t*slots = module_data->slots;\n\nerr:\n\treturn r;\n}\n\nextern int match_user_opensc(EVP_PKEY *authkey, const char *login);\nextern int match_user_openssh(EVP_PKEY *authkey, const char *login);\n\nstatic int key_login(pam_handle_t *pamh, int flags, PKCS11_SLOT *slot, const char *pin_regex)\n{\n\tchar *password = NULL;\n\tint ok;\n\n\tif (0 == slot->token->loginRequired\n#ifdef HAVE_PKCS11_IS_LOGGED_IN\n\t\t\t|| (0 == PKCS11_is_logged_in(slot, 0, &ok)\n\t\t\t\t&& ok == 1)\n#endif\n\t   ) {\n\t\tok = 1;\n\t\tgoto err;\n\t}\n\tok = 0;\n\n\t/* try to get stored item */\n\tif (PAM_SUCCESS == pam_get_item(pamh, PAM_AUTHTOK, (void *)&password)\n\t\t\t&& NULL != password) {\n\t\tpassword = strdup(password);\n\t\tif (NULL == password) {\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"strdup() failed: %s\",\n\t\t\t\t\tstrerror(errno));\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tconst char *pin_info;\n\n\t\tif (slot->token->userPinFinalTry) {\n\t\t\tpin_info = _(\" (last try)\");\n\t\t} else {\n\t\t\tpin_info = \"\";\n\t\t}\n\n\t\tif (0 != slot->token->secureLogin) {\n\t\t\tprompt(flags, pamh, PAM_TEXT_INFO, NULL,\n\t\t\t\t\t_(\"Login on PIN pad with %s%s\"),\n\t\t\t\t\tslot->token->label, pin_info);\n\t\t} else {\n\t\t\t/* ask the user for the password if variable text is set */\n\t\t\tif (PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &password,\n\t\t\t\t\t\t_(\"Login with %s%s: \"),\n\t\t\t\t\t\tslot->token->label, pin_info)) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (NULL != password && NULL != pin_regex && 0 < strlen(pin_regex)) {\n\t\tregex_t regex;\n\t\tint regex_compiled = 0;\n\t\tint result = 0;\n\t\tresult = regcomp(&regex, pin_regex, REG_EXTENDED);\n\t\tif (0 == result) {\n\t\t\tregex_compiled = 1;\n\t\t\tresult = regexec(&regex, password, 0, NULL, 0);\n\t\t}\n\t\tif (result) {\n\t\t\tchar regex_error[256];\n\t\t\tregerror(result, &regex, regex_error, sizeof regex_error);\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"PIN regex didn't match: %s\",\n\t\t\t\t\tregex_error);\n\t\t\tif (1 == regex_compiled) {\n\t\t\t\tregfree(&regex);\n\t\t\t}\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Invalid PIN\"));\n\t\t\tgoto err;\n\t\t}\n\t\tregfree(&regex);\n\t}\n\n\tif (0 != PKCS11_login(slot, 0, password)) {\n\t\tif (slot->token->userPinLocked) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not verified; PIN locked\"));\n\t\t} else if (slot->token->userPinFinalTry) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not verified; one try remaining\"));\n\t\t} else {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not verified\"));\n\t\t}\n\t\tgoto err;\n\t}\n\n\tpam_set_item(pamh, PAM_AUTHTOK, password);\n\n\tok = 1;\n\nerr:\n\tif (NULL != password) {\n\t\tOPENSSL_cleanse(password, strlen(password));\n\t\tfree(password);\n\t}\n\n\treturn ok;\n}\n\nstatic int key_change_login(pam_handle_t *pamh, int flags, PKCS11_SLOT *slot, const char *pin_regex)\n{\n\tchar *old = NULL, *new = NULL, *retyped = NULL;\n\tint ok;\n\n\tif (0 == slot->token->loginRequired) {\n\t\t/* we can't change a PIN */\n\t\tok = 0;\n\t\tgoto err;\n\t}\n\tok = 0;\n\n\t/* We need a R/W public session to change the PIN via PUK or\n\t * a R/W user session to change the PIN via PIN */\n\tif (0 != PKCS11_open_session(slot, 1)\n\t\t\t|| (0 == slot->token->userPinLocked\n\t\t\t\t&& 1 != key_login(pamh, flags, slot, pin_regex))) {\n\t\tgoto err;\n\t}\n\n\t/* prompt for new PIN (and PUK if needed) */\n\tif (0 != slot->token->secureLogin) {\n\t\tif (0 != slot->token->userPinLocked) {\n\t\t\tprompt(flags, pamh, PAM_TEXT_INFO, NULL,\n\t\t\t\t\t_(\"Change PIN with PUK on PIN pad for %s\"),\n\t\t\t\t\tslot->token->label);\n\t\t} else {\n\t\t\tprompt(flags, pamh, PAM_TEXT_INFO, NULL,\n\t\t\t\t\t_(\"Change PIN on PIN pad for %s\"),\n\t\t\t\t\tslot->token->label);\n\t\t}\n\t} else {\n\t\tif (0 != slot->token->userPinLocked) {\n\t\t\tif (PAM_SUCCESS == prompt(flags, pamh,\n\t\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &old,\n\t\t\t\t\t\t_(\"PUK for %s: \"),\n\t\t\t\t\t\tslot->token->label)) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n#ifdef TEST\n\t\t\t/* In the tests we're calling pam_sm_chauthtok() directly, so\n\t\t\t * pam_get_item(PAM_AUTHTOK) will return PAM_BAD_ITEM. As\n\t\t\t * workaround, we simply enter the current PIN twice. */\n\t\t\tif (PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &old,\n\t\t\t\t\t\t_(\"Current PIN: \"))) {\n\t\t\t\tgoto err;\n\t\t\t}\n#else\n\t\t\tif (PAM_SUCCESS != pam_get_item(pamh, PAM_AUTHTOK, (void *)&old)\n\t\t\t\t\t|| NULL == old) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\told = strdup(old);\n\t\t\tif (NULL == old) {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"strdup() failed: %s\",\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\tgoto err;\n\t\t\t}\n#endif\n\t\t}\n\t\tif (PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &new,\n\t\t\t\t\t_(\"Enter new PIN: \"))\n\t\t\t\t|| PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &retyped,\n\t\t\t\t\t_(\"Retype new PIN: \"))) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (0 != strcmp(new, retyped)) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PINs don't match\"));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (0 != PKCS11_change_pin(slot, old, new)) {\n\t\tif (slot->token->userPinLocked) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not changed; PIN locked\"));\n\t\t} else if (slot->token->userPinFinalTry) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not changed; one try remaining\"));\n\t\t} else {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not changed\"));\n\t\t}\n\t\tgoto err;\n\t}\n\n\tpam_set_item(pamh, PAM_AUTHTOK, new);\n\n\tok = 1;\n\nerr:\n\tif (NULL != retyped) {\n\t\tOPENSSL_cleanse(retyped, strlen(retyped));\n\t\tfree(retyped);\n\t}\n\tif (NULL != new) {\n\t\tOPENSSL_cleanse(new, strlen(new));\n\t\tfree(new);\n\t}\n\tif (NULL != old) {\n\t\tOPENSSL_cleanse(old, strlen(old));\n\t\tfree(old);\n\t}\n\n\treturn ok;\n}\n\nstatic int key_find(pam_handle_t *pamh, int flags, const char *user,\n\t\tPKCS11_CTX *ctx, PKCS11_SLOT *slots, unsigned int nslots,\n\t\tPKCS11_SLOT **authslot, PKCS11_KEY **authkey)\n{\n\tint token_found = 0;\n\n\tif (NULL == authslot || NULL == authkey) {\n\t\treturn 0;\n\t}\n\n\t*authkey = NULL;\n\t*authslot = NULL;\n\n\t/* search all valuable slots for a key that is authorized by the user */\n\twhile (0 < nslots) {\n\t\tPKCS11_SLOT *slot = NULL;\n\t\tPKCS11_CERT *certs = NULL;\n#ifdef HAVE_PKCS11_ENUMERATE_PUBLIC_KEYS\n\t\tPKCS11_KEY *keys = NULL;\n#endif\n\t\tunsigned int count = 0;\n\n\t\tslot = PKCS11_find_token(ctx, slots, nslots);\n\t\tif (NULL == slot || NULL == slot->token) {\n\t\t\tbreak;\n\t\t}\n\t\ttoken_found = 1;\n\n\t\tif (slot->token->loginRequired && slot->token->userPinLocked) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"%s: PIN locked\",\n\t\t\t\t\tslot->token->label);\n\t\t\tcontinue;\n\t\t}\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Searching %s for keys\",\n\t\t\t\tslot->token->label);\n\n#ifdef HAVE_PKCS11_ENUMERATE_PUBLIC_KEYS\n\t\t/* First, search all available public keys to allow using tokens\n\t\t * without certificates (e.g. OpenPGP card) */\n\t\tif (0 == PKCS11_enumerate_public_keys(slot->token, &keys, &count)) {\n\t\t\twhile (0 < count && NULL != keys) {\n\t\t\t\tEVP_PKEY *pubkey = PKCS11_get_public_key(keys);\n\t\t\t\tint r = match_user_opensc(pubkey, user);\n\t\t\t\tif (1 != r) {\n\t\t\t\t\tr = match_user_openssh(pubkey, user);\n\t\t\t\t}\n\t\t\t\tif (NULL != pubkey) {\n\t\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\t\t}\n\t\t\t\tif (1 == r) {\n\t\t\t\t\t*authkey = keys;\n\t\t\t\t\t*authslot = slot;\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"Found %s\",\n\t\t\t\t\t\t\tkeys->label);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t/* Try the next possible public key */\n\t\t\t\tkeys++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* Next, search all certificates */\n\t\tif (0 == PKCS11_enumerate_certs(slot->token, &certs, &count)) {\n\t\t\twhile (0 < count && NULL != certs) {\n\t\t\t\tEVP_PKEY *pubkey = X509_get_pubkey(certs->x509);\n\t\t\t\tint r = match_user_opensc(pubkey, user);\n\t\t\t\tif (1 != r) {\n\t\t\t\t\tr = match_user_openssh(pubkey, user);\n\t\t\t\t}\n\t\t\t\tif (NULL != pubkey) {\n\t\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\t\t}\n\t\t\t\tif (1 == r) {\n\t\t\t\t\t*authkey = PKCS11_find_key(certs);\n\t\t\t\t\tif (NULL == *authkey) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t*authslot = slot;\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"Found %s\",\n\t\t\t\t\t\t\tcerts->label);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t/* Try the next possible certificate */\n\t\t\t\tcerts++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\n\t\t/* Try the next possible slot: PKCS11 slots are implemented as array,\n\t\t * so starting to look at slot++ and decrementing nslots accordingly\n\t\t * will search the rest of slots. */\n\t\tslot++;\n\t\tnslots -= (slot - slots);\n\t\tslots = slot;\n\t\tpam_syslog(pamh, LOG_DEBUG, \"No authorized key found\");\n\t}\n\n\tif (0 == token_found) {\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"No token found\"));\n\t} else {\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"No authorized keys on token\"));\n\t}\n\n\treturn 0;\n}\n\nstatic int randomize(pam_handle_t *pamh, unsigned char *r, unsigned int r_len)\n{\n\tint ok = 0;\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\tif (0 <= fd && read(fd, r, r_len) == (ssize_t)r_len) {\n\t\tok = 1;\n\t} else {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error reading from /dev/urandom: %s\",\n\t\t\t\tstrerror(errno));\n\t}\n\tif (0 <= fd) {\n\t\tclose(fd);\n\t}\n\treturn ok;\n}\n\nstatic int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\n\t/* Verify a SHA-1 hash of random data, signed by the key.\n\t *\n\t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\n\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}\n\nPAM_EXTERN int pam_sm_authenticate(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tint r;\n\tPKCS11_CTX *ctx;\n\tunsigned int nslots;\n\tPKCS11_KEY *authkey;\n\tPKCS11_SLOT *slots, *authslot;\n\tconst char *user;\n\tconst char *pin_regex;\n\n\tr = module_refresh(pamh, flags, argc, argv,\n\t\t\t&user, &ctx, &slots, &nslots, &pin_regex);\n\tif (PAM_SUCCESS != r) {\n\t\tgoto err;\n\t}\n\n\tif (1 != key_find(pamh, flags, user, ctx, slots, nslots,\n\t\t\t\t&authslot, &authkey)) {\n\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\tgoto err;\n\t}\n\tif (1 != key_login(pamh, flags, authslot, pin_regex)\n\t\t\t|| 1 != key_verify(pamh, flags, authkey)) {\n\t\tif (authslot->token->userPinLocked) {\n\t\t\tr = PAM_MAXTRIES;\n\t\t} else {\n\t\t\tr = PAM_AUTH_ERR;\n\t\t}\n\t\tgoto err;\n\t}\n\n\tr = PAM_SUCCESS;\n\nerr:\n#ifdef TEST\n\tmodule_data_cleanup(pamh, global_module_data, r);\n#endif\n\treturn r;\n}\n\nPAM_EXTERN int pam_sm_setcred(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\t/* Actually, we should return the same value as pam_sm_authenticate(). */\n\treturn PAM_SUCCESS;\n}\n\nPAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\t/* if the user has been authenticated (precondition of this call), then\n\t * everything is OK. Yes, we explicitly don't want to check CRLs, OCSP or\n\t * exparation of certificates (use pam_pkcs11 for this). */\n\treturn PAM_SUCCESS;\n}\n\nPAM_EXTERN int pam_sm_open_session(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\"Function pam_sm_open_session() is not implemented in this module\");\n\treturn PAM_SERVICE_ERR;\n}\n\nPAM_EXTERN int pam_sm_close_session(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\"Function pam_sm_close_session() is not implemented in this module\");\n\treturn PAM_SERVICE_ERR;\n}\n\nPAM_EXTERN int pam_sm_chauthtok(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tint r;\n\tPKCS11_CTX *ctx;\n\tunsigned int nslots;\n\tPKCS11_KEY *authkey;\n\tPKCS11_SLOT *slots, *authslot;\n\tconst char *user, *pin_regex;\n\n\tr = module_refresh(pamh, flags, argc, argv,\n\t\t\t&user, &ctx, &slots, &nslots, &pin_regex);\n\tif (PAM_SUCCESS != r) {\n\t\tgoto err;\n\t}\n\n\tif (flags & PAM_CHANGE_EXPIRED_AUTHTOK) {\n\t\t/* Yes, we explicitly don't want to check CRLs, OCSP or exparation of\n\t\t * certificates (use pam_pkcs11 for this). */\n\t\tr = PAM_SUCCESS;\n\t\tgoto err;\n\t}\n\n\tif (1 != key_find(pamh, flags, user, ctx, slots, nslots,\n\t\t\t\t&authslot, &authkey)) {\n\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\tgoto err;\n\t}\n\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tr = PAM_TRY_AGAIN;\n\t\tgoto err;\n\t}\n\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tif (1 != key_change_login(pamh, flags, authslot, pin_regex)) {\n\t\t\tif (authslot->token->userPinLocked) {\n\t\t\t\tr = PAM_MAXTRIES;\n\t\t\t} else {\n\t\t\t\tr = PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tr = PAM_SUCCESS;\n\nerr:\n#ifdef TEST\n\tmodule_data_cleanup(pamh, global_module_data, r);\n#endif\n\treturn r;\n}\n\n#ifdef PAM_STATIC\n/* static module data */\nstruct pam_module _pam_group_modstruct = {\n\tPACKAGE,\n\tpam_sm_authenticate,\n\tpam_sm_setcred,\n\tpam_sm_acct_mgmt,\n\tpam_sm_open_session,\n\tpam_sm_close_session,\n\tpam_sm_chauthtok\n};\n#endif\n"], "fixing_code": ["/*\n * libp11 PAM Login Module\n * Copyright (C) 2003 Mario Strasser <mast@gmx.net>,\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n */\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifndef PACKAGE\n#define PACKAGE \"pam_p11\"\n#endif\n\n#include <syslog.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <openssl/crypto.h>\n#include <libp11.h>\n#include <regex.h>\n#include <stdlib.h>\n\n/* openssl deprecated API emulation */\n#ifndef HAVE_EVP_MD_CTX_NEW\n#define EVP_MD_CTX_new()\tEVP_MD_CTX_create()\n#endif\n#ifndef HAVE_EVP_MD_CTX_FREE\n#define EVP_MD_CTX_free(ctx)\tEVP_MD_CTX_destroy((ctx))\n#endif\n#ifndef HAVE_EVP_MD_CTX_RESET\n#define EVP_MD_CTX_reset(ctx)\tEVP_MD_CTX_cleanup((ctx))\n#endif\n\n#ifdef ENABLE_NLS\n#include <libintl.h>\n#include <locale.h>\n#define _(string) gettext(string)\n#ifndef LOCALEDIR\n#define LOCALEDIR \"/usr/share/locale\"\n#endif\n#else\n#define _(string) string\n#endif\n\n/* We have to make this definitions before we include the pam header files! */\n#define PAM_SM_AUTH\n#define PAM_SM_ACCOUNT\n#define PAM_SM_SESSION\n#define PAM_SM_PASSWORD\n#include <security/pam_appl.h>\n#include <security/pam_modules.h>\n#ifdef HAVE_SECURITY_PAM_EXT_H\n#include <security/pam_ext.h>\n#else\n#define pam_syslog(handle, level, msg...) syslog(level, ## msg)\n#endif\n\n#ifndef HAVE_PAM_VPROMPT\nstatic int pam_vprompt(pam_handle_t *pamh, int style, char **response,\n\t\tconst char *fmt, va_list args)\n{\n\tint r = PAM_CRED_INSUFFICIENT;\n\tconst struct pam_conv *conv;\n\tstruct pam_message msg;\n\tstruct pam_response *resp = NULL;\n\tstruct pam_message *(msgp[1]);\n\n\tchar text[128];\n\tvsnprintf(text, sizeof text, fmt, args);\n\n\tmsgp[0] = &msg;\n\tmsg.msg_style = style;\n\tmsg.msg = text;\n\n\tif (PAM_SUCCESS != pam_get_item(pamh, PAM_CONV, (const void **) &conv)\n\t\t\t|| NULL == conv || NULL == conv->conv\n\t\t\t|| conv->conv(1, (const struct pam_message **) msgp, &resp, conv->appdata_ptr)\n\t\t\t|| NULL == resp) {\n\t\tgoto err;\n\t}\n\tif (NULL != response) {\n\t\tif (resp[0].resp) {\n\t\t\t*response = strdup(resp[0].resp);\n\t\t\tif (NULL == *response) {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"strdup() failed: %s\",\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\t*response = NULL;\n\t\t}\n\t}\n\n\tr = PAM_SUCCESS;\nerr:\n\tif (resp) {\n\t\tOPENSSL_cleanse(&resp[0].resp, sizeof resp[0].resp);\n\t\tfree(&resp[0]);\n\t}\n\treturn r;\n}\n#endif\n\n#ifndef PAM_EXTERN\n#define PAM_EXTERN extern\n#endif\n\nint prompt(int flags, pam_handle_t *pamh, int style, char **response,\n\t\tconst char *fmt, ...)\n{\n\tint r;\n\n\tif (PAM_SILENT == (flags & PAM_SILENT)\n\t\t\t&& style != PAM_TEXT_INFO\n\t\t\t&& style != PAM_PROMPT_ECHO_OFF) {\n\t\t/* PAM_SILENT does not override the prompting of the user for passwords\n\t\t * etc., it only stops informative messages from being generated. We\n\t\t * use PAM_TEXT_INFO and PAM_PROMPT_ECHO_OFF exclusively for the\n\t\t * password prompt. */\n\t\tr = PAM_SUCCESS;\n\t} else {\n\t\tva_list args;\n\t\tva_start (args, fmt);\n\t\tif (!response) {\n\t\t\tchar *p = NULL;\n\t\t\tr = pam_vprompt(pamh, style, &p, fmt, args);\n\t\t\tfree(p);\n\t\t} else {\n\t\t\tr = pam_vprompt(pamh, style, response, fmt, args);\n\t\t}\n\t\tva_end(args);\n\t}\n\n\treturn r;\n}\n\nstruct module_data {\n\tPKCS11_CTX *ctx;\n\tPKCS11_SLOT *slots;\n\tunsigned int nslots;\n\tint module_loaded;\n};\n\n#ifdef TEST\nstatic struct module_data *global_module_data = NULL;\n#endif\n\nvoid module_data_cleanup(pam_handle_t *pamh, void *data, int error_status)\n{\n\tstruct module_data *module_data = data;\n\tif (module_data) {\n\t\tif (1 == module_data->module_loaded) {\n\t\t\tPKCS11_release_all_slots(module_data->ctx, module_data->slots, module_data->nslots);\n\t\t\tPKCS11_CTX_unload(module_data->ctx);\n\t\t}\n\t\tPKCS11_CTX_free(module_data->ctx);\n\t\tEVP_cleanup();\n\t\tERR_free_strings();\n\t\tfree(module_data);\n\t}\n}\n\nstatic int module_initialize(pam_handle_t * pamh,\n\t\tint flags, int argc, const char **argv,\n\t\tstruct module_data **module_data)\n{\n\tint r;\n\tstruct module_data *data = calloc(1, sizeof *data);\n\tif (NULL == data) {\n\t\tpam_syslog(pamh, LOG_CRIT, \"calloc() failed: %s\",\n\t\t\t\tstrerror(errno));\n\t\tr = PAM_BUF_ERR;\n\t\tgoto err;\n\t}\n\n#ifdef ENABLE_NLS\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n#endif\n\n\t/* Initialize OpenSSL */\n\tOpenSSL_add_all_algorithms();\n\tERR_load_crypto_strings();\n\n\t/* Load and initialize PKCS#11 module */\n\tdata->ctx = PKCS11_CTX_new();\n\tif (0 == argc || NULL == data->ctx\n\t\t\t|| 0 != PKCS11_CTX_load(data->ctx, argv[0])) {\n\t\tpam_syslog(pamh, LOG_ALERT, \"Loading PKCS#11 engine failed: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"Error loading PKCS#11 module\"));\n\t\tr = PAM_NO_MODULE_DATA;\n\t\tgoto err;\n\t}\n\tdata->module_loaded = 1;\n\tif (0 != PKCS11_enumerate_slots(data->ctx, &data->slots, &data->nslots)) {\n\t\tpam_syslog(pamh, LOG_ALERT, \"Initializing PKCS#11 engine failed: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"Error initializing PKCS#11 module\"));\n\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\tgoto err;\n\t}\n\n#ifdef TEST\n\t/* pam_set_data() is reserved for actual modules. For testing this would\n\t * return PAM_SYSTEM_ERR, so we're saving the module data in a static\n\t * variable. */\n\tr = PAM_SUCCESS;\n\tglobal_module_data = data;\n#else\n\tr = pam_set_data(pamh, PACKAGE, data, module_data_cleanup);\n\tif (PAM_SUCCESS != r) {\n\t\tgoto err;\n\t}\n#endif\n\n\t*module_data = data;\n\tdata = NULL;\n\nerr:\n\tmodule_data_cleanup(pamh, data, r);\n\n\treturn r;\n}\n\nstatic int module_refresh(pam_handle_t *pamh,\n\t\tint flags, int argc, const char **argv,\n\t\tconst char **user, PKCS11_CTX **ctx,\n\t\tPKCS11_SLOT **slots, unsigned int *nslots,\n\t\tconst char **pin_regex)\n{\n\tint r;\n\tstruct module_data *module_data;\n\n\tif (PAM_SUCCESS != pam_get_data(pamh, PACKAGE, (void *)&module_data)\n\t\t\t|| NULL == module_data) {\n\t\tr = module_initialize(pamh, flags, argc, argv, &module_data);\n\t\tif (PAM_SUCCESS != r) {\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\t/* refresh all known slots */\n\t\tPKCS11_release_all_slots(module_data->ctx,\n\t\t\t\tmodule_data->slots, module_data->nslots);\n\t\tmodule_data->slots = NULL;\n\t\tmodule_data->nslots = 0;\n\t\tif (0 != PKCS11_enumerate_slots(module_data->ctx,\n\t\t\t\t\t&module_data->slots, &module_data->nslots)) {\n\t\t\tpam_syslog(pamh, LOG_ALERT, \"Initializing PKCS#11 engine failed: %s\\n\",\n\t\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"Error initializing PKCS#11 module\"));\n\t\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (1 < argc) {\n\t\t*pin_regex = argv[1];\n\t} else {\n#ifdef __APPLE__\n\t\t/* If multiple PAMs are allowed for macOS' login, then the captured\n\t\t * password is used for all possible modules. To not block the token's\n\t\t * PIN if the user enters his standard password, we're refusing to use\n\t\t * anything that doesn't look like a PIN. */\n\t\t*pin_regex = \"^[[:digit:]]*$\";\n#else\n\t\t*pin_regex = NULL;\n#endif\n\t}\n\n\tr = pam_get_user(pamh, user, NULL);\n\tif (PAM_SUCCESS != r) {\n\t\tpam_syslog(pamh, LOG_ERR, \"pam_get_user() failed %s\",\n\t\t\t\tpam_strerror(pamh, r));\n\t\tr = PAM_USER_UNKNOWN;\n\t\tgoto err;\n\t}\n\n\t*ctx = module_data->ctx;\n\t*nslots = module_data->nslots;\n\t*slots = module_data->slots;\n\nerr:\n\treturn r;\n}\n\nextern int match_user_opensc(EVP_PKEY *authkey, const char *login);\nextern int match_user_openssh(EVP_PKEY *authkey, const char *login);\n\nstatic int key_login(pam_handle_t *pamh, int flags, PKCS11_SLOT *slot, const char *pin_regex)\n{\n\tchar *password = NULL;\n\tint ok;\n\n\tif (0 == slot->token->loginRequired\n#ifdef HAVE_PKCS11_IS_LOGGED_IN\n\t\t\t|| (0 == PKCS11_is_logged_in(slot, 0, &ok)\n\t\t\t\t&& ok == 1)\n#endif\n\t   ) {\n\t\tok = 1;\n\t\tgoto err;\n\t}\n\tok = 0;\n\n\t/* try to get stored item */\n\tif (PAM_SUCCESS == pam_get_item(pamh, PAM_AUTHTOK, (void *)&password)\n\t\t\t&& NULL != password) {\n\t\tpassword = strdup(password);\n\t\tif (NULL == password) {\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"strdup() failed: %s\",\n\t\t\t\t\tstrerror(errno));\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tconst char *pin_info;\n\n\t\tif (slot->token->userPinFinalTry) {\n\t\t\tpin_info = _(\" (last try)\");\n\t\t} else {\n\t\t\tpin_info = \"\";\n\t\t}\n\n\t\tif (0 != slot->token->secureLogin) {\n\t\t\tprompt(flags, pamh, PAM_TEXT_INFO, NULL,\n\t\t\t\t\t_(\"Login on PIN pad with %s%s\"),\n\t\t\t\t\tslot->token->label, pin_info);\n\t\t} else {\n\t\t\t/* ask the user for the password if variable text is set */\n\t\t\tif (PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &password,\n\t\t\t\t\t\t_(\"Login with %s%s: \"),\n\t\t\t\t\t\tslot->token->label, pin_info)) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (NULL != password && NULL != pin_regex && 0 < strlen(pin_regex)) {\n\t\tregex_t regex;\n\t\tint regex_compiled = 0;\n\t\tint result = 0;\n\t\tresult = regcomp(&regex, pin_regex, REG_EXTENDED);\n\t\tif (0 == result) {\n\t\t\tregex_compiled = 1;\n\t\t\tresult = regexec(&regex, password, 0, NULL, 0);\n\t\t}\n\t\tif (result) {\n\t\t\tchar regex_error[256];\n\t\t\tregerror(result, &regex, regex_error, sizeof regex_error);\n\t\t\tpam_syslog(pamh, LOG_CRIT, \"PIN regex didn't match: %s\",\n\t\t\t\t\tregex_error);\n\t\t\tif (1 == regex_compiled) {\n\t\t\t\tregfree(&regex);\n\t\t\t}\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Invalid PIN\"));\n\t\t\tgoto err;\n\t\t}\n\t\tregfree(&regex);\n\t}\n\n\tif (0 != PKCS11_login(slot, 0, password)) {\n\t\tif (slot->token->userPinLocked) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not verified; PIN locked\"));\n\t\t} else if (slot->token->userPinFinalTry) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not verified; one try remaining\"));\n\t\t} else {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not verified\"));\n\t\t}\n\t\tgoto err;\n\t}\n\n\tpam_set_item(pamh, PAM_AUTHTOK, password);\n\n\tok = 1;\n\nerr:\n\tif (NULL != password) {\n\t\tOPENSSL_cleanse(password, strlen(password));\n\t\tfree(password);\n\t}\n\n\treturn ok;\n}\n\nstatic int key_change_login(pam_handle_t *pamh, int flags, PKCS11_SLOT *slot, const char *pin_regex)\n{\n\tchar *old = NULL, *new = NULL, *retyped = NULL;\n\tint ok;\n\n\tif (0 == slot->token->loginRequired) {\n\t\t/* we can't change a PIN */\n\t\tok = 0;\n\t\tgoto err;\n\t}\n\tok = 0;\n\n\t/* We need a R/W public session to change the PIN via PUK or\n\t * a R/W user session to change the PIN via PIN */\n\tif (0 != PKCS11_open_session(slot, 1)\n\t\t\t|| (0 == slot->token->userPinLocked\n\t\t\t\t&& 1 != key_login(pamh, flags, slot, pin_regex))) {\n\t\tgoto err;\n\t}\n\n\t/* prompt for new PIN (and PUK if needed) */\n\tif (0 != slot->token->secureLogin) {\n\t\tif (0 != slot->token->userPinLocked) {\n\t\t\tprompt(flags, pamh, PAM_TEXT_INFO, NULL,\n\t\t\t\t\t_(\"Change PIN with PUK on PIN pad for %s\"),\n\t\t\t\t\tslot->token->label);\n\t\t} else {\n\t\t\tprompt(flags, pamh, PAM_TEXT_INFO, NULL,\n\t\t\t\t\t_(\"Change PIN on PIN pad for %s\"),\n\t\t\t\t\tslot->token->label);\n\t\t}\n\t} else {\n\t\tif (0 != slot->token->userPinLocked) {\n\t\t\tif (PAM_SUCCESS == prompt(flags, pamh,\n\t\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &old,\n\t\t\t\t\t\t_(\"PUK for %s: \"),\n\t\t\t\t\t\tslot->token->label)) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n#ifdef TEST\n\t\t\t/* In the tests we're calling pam_sm_chauthtok() directly, so\n\t\t\t * pam_get_item(PAM_AUTHTOK) will return PAM_BAD_ITEM. As\n\t\t\t * workaround, we simply enter the current PIN twice. */\n\t\t\tif (PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &old,\n\t\t\t\t\t\t_(\"Current PIN: \"))) {\n\t\t\t\tgoto err;\n\t\t\t}\n#else\n\t\t\tif (PAM_SUCCESS != pam_get_item(pamh, PAM_AUTHTOK, (void *)&old)\n\t\t\t\t\t|| NULL == old) {\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\told = strdup(old);\n\t\t\tif (NULL == old) {\n\t\t\t\tpam_syslog(pamh, LOG_CRIT, \"strdup() failed: %s\",\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\tgoto err;\n\t\t\t}\n#endif\n\t\t}\n\t\tif (PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &new,\n\t\t\t\t\t_(\"Enter new PIN: \"))\n\t\t\t\t|| PAM_SUCCESS != prompt(flags, pamh,\n\t\t\t\t\tPAM_PROMPT_ECHO_OFF, &retyped,\n\t\t\t\t\t_(\"Retype new PIN: \"))) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (0 != strcmp(new, retyped)) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PINs don't match\"));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (0 != PKCS11_change_pin(slot, old, new)) {\n\t\tif (slot->token->userPinLocked) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not changed; PIN locked\"));\n\t\t} else if (slot->token->userPinFinalTry) {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not changed; one try remaining\"));\n\t\t} else {\n\t\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"PIN not changed\"));\n\t\t}\n\t\tgoto err;\n\t}\n\n\tpam_set_item(pamh, PAM_AUTHTOK, new);\n\n\tok = 1;\n\nerr:\n\tif (NULL != retyped) {\n\t\tOPENSSL_cleanse(retyped, strlen(retyped));\n\t\tfree(retyped);\n\t}\n\tif (NULL != new) {\n\t\tOPENSSL_cleanse(new, strlen(new));\n\t\tfree(new);\n\t}\n\tif (NULL != old) {\n\t\tOPENSSL_cleanse(old, strlen(old));\n\t\tfree(old);\n\t}\n\n\treturn ok;\n}\n\nstatic int key_find(pam_handle_t *pamh, int flags, const char *user,\n\t\tPKCS11_CTX *ctx, PKCS11_SLOT *slots, unsigned int nslots,\n\t\tPKCS11_SLOT **authslot, PKCS11_KEY **authkey)\n{\n\tint token_found = 0;\n\n\tif (NULL == authslot || NULL == authkey) {\n\t\treturn 0;\n\t}\n\n\t*authkey = NULL;\n\t*authslot = NULL;\n\n\t/* search all valuable slots for a key that is authorized by the user */\n\twhile (0 < nslots) {\n\t\tPKCS11_SLOT *slot = NULL;\n\t\tPKCS11_CERT *certs = NULL;\n#ifdef HAVE_PKCS11_ENUMERATE_PUBLIC_KEYS\n\t\tPKCS11_KEY *keys = NULL;\n#endif\n\t\tunsigned int count = 0;\n\n\t\tslot = PKCS11_find_token(ctx, slots, nslots);\n\t\tif (NULL == slot || NULL == slot->token) {\n\t\t\tbreak;\n\t\t}\n\t\ttoken_found = 1;\n\n\t\tif (slot->token->loginRequired && slot->token->userPinLocked) {\n\t\t\tpam_syslog(pamh, LOG_DEBUG, \"%s: PIN locked\",\n\t\t\t\t\tslot->token->label);\n\t\t\tcontinue;\n\t\t}\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Searching %s for keys\",\n\t\t\t\tslot->token->label);\n\n#ifdef HAVE_PKCS11_ENUMERATE_PUBLIC_KEYS\n\t\t/* First, search all available public keys to allow using tokens\n\t\t * without certificates (e.g. OpenPGP card) */\n\t\tif (0 == PKCS11_enumerate_public_keys(slot->token, &keys, &count)) {\n\t\t\twhile (0 < count && NULL != keys) {\n\t\t\t\tEVP_PKEY *pubkey = PKCS11_get_public_key(keys);\n\t\t\t\tint r = match_user_opensc(pubkey, user);\n\t\t\t\tif (1 != r) {\n\t\t\t\t\tr = match_user_openssh(pubkey, user);\n\t\t\t\t}\n\t\t\t\tif (NULL != pubkey) {\n\t\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\t\t}\n\t\t\t\tif (1 == r) {\n\t\t\t\t\t*authkey = keys;\n\t\t\t\t\t*authslot = slot;\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"Found %s\",\n\t\t\t\t\t\t\tkeys->label);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t/* Try the next possible public key */\n\t\t\t\tkeys++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* Next, search all certificates */\n\t\tif (0 == PKCS11_enumerate_certs(slot->token, &certs, &count)) {\n\t\t\twhile (0 < count && NULL != certs) {\n\t\t\t\tEVP_PKEY *pubkey = X509_get_pubkey(certs->x509);\n\t\t\t\tint r = match_user_opensc(pubkey, user);\n\t\t\t\tif (1 != r) {\n\t\t\t\t\tr = match_user_openssh(pubkey, user);\n\t\t\t\t}\n\t\t\t\tif (NULL != pubkey) {\n\t\t\t\t\tEVP_PKEY_free(pubkey);\n\t\t\t\t}\n\t\t\t\tif (1 == r) {\n\t\t\t\t\t*authkey = PKCS11_find_key(certs);\n\t\t\t\t\tif (NULL == *authkey) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t*authslot = slot;\n\t\t\t\t\tpam_syslog(pamh, LOG_DEBUG, \"Found %s\",\n\t\t\t\t\t\t\tcerts->label);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t/* Try the next possible certificate */\n\t\t\t\tcerts++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\n\t\t/* Try the next possible slot: PKCS11 slots are implemented as array,\n\t\t * so starting to look at slot++ and decrementing nslots accordingly\n\t\t * will search the rest of slots. */\n\t\tslot++;\n\t\tnslots -= (slot - slots);\n\t\tslots = slot;\n\t\tpam_syslog(pamh, LOG_DEBUG, \"No authorized key found\");\n\t}\n\n\tif (0 == token_found) {\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"No token found\"));\n\t} else {\n\t\tprompt(flags, pamh, PAM_ERROR_MSG , NULL, _(\"No authorized keys on token\"));\n\t}\n\n\treturn 0;\n}\n\nstatic int randomize(pam_handle_t *pamh, unsigned char *r, unsigned int r_len)\n{\n\tint ok = 0;\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\tif (0 <= fd && read(fd, r, r_len) == (ssize_t)r_len) {\n\t\tok = 1;\n\t} else {\n\t\tpam_syslog(pamh, LOG_CRIT, \"Error reading from /dev/urandom: %s\",\n\t\t\t\tstrerror(errno));\n\t}\n\tif (0 <= fd) {\n\t\tclose(fd);\n\t}\n\treturn ok;\n}\n\nstatic int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char *signature = NULL;\n\tunsigned int siglen;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\n\tif (NULL == privkey)\n\t\tgoto err;\n\tsiglen = EVP_PKEY_size(privkey);\n\tif (siglen <= 0)\n\t\tgoto err;\n\tsignature = malloc(siglen);\n\tif (NULL == signature)\n\t\tgoto err;\n\n\t/* Verify a SHA-1 hash of random data, signed by the key.\n\t *\n\t * Note that this will not work keys that aren't eligible for signing.\n\t * Unfortunately, libp11 currently has no way of checking\n\t * C_GetAttributeValue(CKA_SIGN), see\n\t * https://github.com/OpenSC/libp11/issues/219. Since we don't want to\n\t * implement try and error, we live with this limitation */\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\n\nerr:\n\tfree(signature);\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}\n\nPAM_EXTERN int pam_sm_authenticate(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tint r;\n\tPKCS11_CTX *ctx;\n\tunsigned int nslots;\n\tPKCS11_KEY *authkey;\n\tPKCS11_SLOT *slots, *authslot;\n\tconst char *user;\n\tconst char *pin_regex;\n\n\tr = module_refresh(pamh, flags, argc, argv,\n\t\t\t&user, &ctx, &slots, &nslots, &pin_regex);\n\tif (PAM_SUCCESS != r) {\n\t\tgoto err;\n\t}\n\n\tif (1 != key_find(pamh, flags, user, ctx, slots, nslots,\n\t\t\t\t&authslot, &authkey)) {\n\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\tgoto err;\n\t}\n\tif (1 != key_login(pamh, flags, authslot, pin_regex)\n\t\t\t|| 1 != key_verify(pamh, flags, authkey)) {\n\t\tif (authslot->token->userPinLocked) {\n\t\t\tr = PAM_MAXTRIES;\n\t\t} else {\n\t\t\tr = PAM_AUTH_ERR;\n\t\t}\n\t\tgoto err;\n\t}\n\n\tr = PAM_SUCCESS;\n\nerr:\n#ifdef TEST\n\tmodule_data_cleanup(pamh, global_module_data, r);\n#endif\n\treturn r;\n}\n\nPAM_EXTERN int pam_sm_setcred(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\t/* Actually, we should return the same value as pam_sm_authenticate(). */\n\treturn PAM_SUCCESS;\n}\n\nPAM_EXTERN int pam_sm_acct_mgmt(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\t/* if the user has been authenticated (precondition of this call), then\n\t * everything is OK. Yes, we explicitly don't want to check CRLs, OCSP or\n\t * exparation of certificates (use pam_pkcs11 for this). */\n\treturn PAM_SUCCESS;\n}\n\nPAM_EXTERN int pam_sm_open_session(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\"Function pam_sm_open_session() is not implemented in this module\");\n\treturn PAM_SERVICE_ERR;\n}\n\nPAM_EXTERN int pam_sm_close_session(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tpam_syslog(pamh, LOG_DEBUG,\n\t\t\t\"Function pam_sm_close_session() is not implemented in this module\");\n\treturn PAM_SERVICE_ERR;\n}\n\nPAM_EXTERN int pam_sm_chauthtok(pam_handle_t * pamh, int flags, int argc,\n\t\tconst char **argv)\n{\n\tint r;\n\tPKCS11_CTX *ctx;\n\tunsigned int nslots;\n\tPKCS11_KEY *authkey;\n\tPKCS11_SLOT *slots, *authslot;\n\tconst char *user, *pin_regex;\n\n\tr = module_refresh(pamh, flags, argc, argv,\n\t\t\t&user, &ctx, &slots, &nslots, &pin_regex);\n\tif (PAM_SUCCESS != r) {\n\t\tgoto err;\n\t}\n\n\tif (flags & PAM_CHANGE_EXPIRED_AUTHTOK) {\n\t\t/* Yes, we explicitly don't want to check CRLs, OCSP or exparation of\n\t\t * certificates (use pam_pkcs11 for this). */\n\t\tr = PAM_SUCCESS;\n\t\tgoto err;\n\t}\n\n\tif (1 != key_find(pamh, flags, user, ctx, slots, nslots,\n\t\t\t\t&authslot, &authkey)) {\n\t\tr = PAM_AUTHINFO_UNAVAIL;\n\t\tgoto err;\n\t}\n\n\tif (flags & PAM_PRELIM_CHECK) {\n\t\tr = PAM_TRY_AGAIN;\n\t\tgoto err;\n\t}\n\n\tif (flags & PAM_UPDATE_AUTHTOK) {\n\t\tif (1 != key_change_login(pamh, flags, authslot, pin_regex)) {\n\t\t\tif (authslot->token->userPinLocked) {\n\t\t\t\tr = PAM_MAXTRIES;\n\t\t\t} else {\n\t\t\t\tr = PAM_AUTH_ERR;\n\t\t\t}\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tr = PAM_SUCCESS;\n\nerr:\n#ifdef TEST\n\tmodule_data_cleanup(pamh, global_module_data, r);\n#endif\n\treturn r;\n}\n\n#ifdef PAM_STATIC\n/* static module data */\nstruct pam_module _pam_group_modstruct = {\n\tPACKAGE,\n\tpam_sm_authenticate,\n\tpam_sm_setcred,\n\tpam_sm_acct_mgmt,\n\tpam_sm_open_session,\n\tpam_sm_close_session,\n\tpam_sm_chauthtok\n};\n#endif\n"], "filenames": ["src/pam_p11.c"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [669], "fixing_code_start_loc": [34], "fixing_code_end_loc": [681], "type": "CWE-119", "message": "An issue was discovered in the pam_p11 component 0.2.0 and 0.3.0 for OpenSC. If a smart card creates a signature with a length longer than 256 bytes, this triggers a buffer overflow. This may be the case for RSA keys with 4096 bits depending on the signature scheme.", "other": {"cve": {"id": "CVE-2019-16058", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-06T18:15:15.507", "lastModified": "2019-09-12T15:15:10.983", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the pam_p11 component 0.2.0 and 0.3.0 for OpenSC. If a smart card creates a signature with a length longer than 256 bytes, this triggers a buffer overflow. This may be the case for RSA keys with 4096 bits depending on the signature scheme."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en el componente pam_p11 versiones 0.2.0 y 0.3.0 para OpenSC. Si una tarjeta inteligente crea una firma con una longitud mayor a 256 bytes, esto desencadena un desbordamiento de b\u00fafer. Este puede ser el caso de las claves RSA con 4096 bits dependiendo del esquema de firma."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "4002F529-C070-40B9-BF06-B8BE51DCC2F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "74031325-6B68-4A4C-9871-55F89B8097A3"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2019/09/12/1", "source": "cve@mitre.org"}, {"url": "https://github.com/OpenSC/pam_p11/commit/d150b60e1e14c261b113f55681419ad1dfa8a76c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSC/pam_p11/commit/d150b60e1e14c261b113f55681419ad1dfa8a76c"}}