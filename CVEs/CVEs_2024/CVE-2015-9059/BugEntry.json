{"buggy_code": ["\nVERSION=2.0a\n\n# CC = gcc\nCPPFLAGS=-DVERSION_STR=\\\"$(VERSION)\\\"\nCFLAGS = -Wall -g\n\n# LD = gcc\nLDFLAGS = -g\nLDLIBS =\n\n## Increase this to use larger input (e.g. copy-paste) buffer\nTTY_Q_SZ = 1024\nCPPFLAGS += -DTTY_Q_SZ=$(TTY_Q_SZ)\n\n## Comment this out to disable high-baudrate support\nCPPFLAGS += -DHIGH_BAUD\n\n## Normally you should NOT enable both: UUCP-style and flock(2)\n## locking.\n\n## Comment this out to disable locking with flock\nCPPFLAGS += -DUSE_FLOCK\n\n## Comment these out to disable UUCP-style lockdirs\n#UUCP_LOCK_DIR=/var/lock\n#CPPFLAGS += -DUUCP_LOCK_DIR=\\\"$(UUCP_LOCK_DIR)\\\"\n\n## Comment these out to disable \"linenoise\"-library support\nSEND_RECEIVE_HISTFILE = .picocom_send_receive\nCPPFLAGS += -DSEND_RECEIVE_HISTFILE=\\\"$(SEND_RECEIVE_HISTFILE)\\\" \\\n\t    -DLINENOISE\npicocom : linenoise-1.0/linenoise.o\nlinenoise-1.0/linenoise.o : linenoise-1.0/linenoise.c linenoise-1.0/linenoise.h\n\n\npicocom : picocom.o term.o\n#\t$(LD) $(LDFLAGS) -o $@ $+ $(LDLIBS)\n\npicocom.o : picocom.c term.h\nterm.o : term.c term.h\n\n\ndoc : picocom.8 picocom.8.html picocom.8.ps\n\nchanges :\n\tsvn log -v . > CHANGES\n\npicocom.8 : picocom.8.xml\n\txmltoman $< > $@\n\npicocom.8.html : picocom.8.xml\n\txmlmantohtml $< > $@\n\npicocom.8.ps : picocom.8\n\tgroff -mandoc -Tps $< > $@\n\nclean:\n\trm -f picocom.o term.o linenoise-1.0/linenoise.o\n\trm -f *~\n\trm -f \\#*\\#\n\ndistclean: clean\n\trm -f picocom\n\nrealclean: distclean\n\trm -f picocom.8\n\trm -f picocom.8.html\n\trm -f picocom.8.ps\n\trm -f CHANGES\n", "/* vi: set sw=4 ts=4:\n *\n * picocom.c\n *\n * simple dumb-terminal program. Helps you manually configure and test\n * stuff like modems, devices w. serial ports etc.\n *\n * by Nick Patavalis (npat@efault.net)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA \n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <assert.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <limits.h>\n#ifdef USE_FLOCK\n#include <sys/file.h>\n#endif\n#ifdef LINENOISE\n#include <dirent.h>\n#include <libgen.h>\n#endif\n\n#define _GNU_SOURCE\n#include <getopt.h>\n\n#include \"term.h\"\n#ifdef LINENOISE\n#include \"linenoise-1.0/linenoise.h\"\n#endif\n\n/**********************************************************************/\n\n/* parity modes names */\nconst char *parity_str[] = {\n\t[P_NONE] = \"none\",\n\t[P_EVEN] = \"even\",\n\t[P_ODD] = \"odd\",\n\t[P_MARK] = \"mark\",\n\t[P_SPACE] = \"space\",\n};\n\n/* flow control modes names */\nconst char *flow_str[] = {\n\t[FC_NONE] = \"none\",\n\t[FC_RTSCTS] = \"RTS/CTS\",\n\t[FC_XONXOFF] = \"xon/xoff\",\n\t[FC_OTHER] = \"other\",\n};\n\n/**********************************************************************/\n\n#define KEY_EXIT    '\\x18' /* C-x: exit picocom */\n#define KEY_QUIT    '\\x11' /* C-q: exit picocom without reseting port */\n#define KEY_PULSE   '\\x10' /* C-p: pulse DTR */\n#define KEY_TOGGLE  '\\x14' /* C-t: toggle DTR */\n#define KEY_BAUD_UP '\\x15' /* C-u: increase baudrate (up) */\n#define KEY_BAUD_DN '\\x04' /* C-d: decrase baudrate (down) */ \n#define KEY_FLOW    '\\x06' /* C-f: change flowcntrl mode */ \n#define KEY_PARITY  '\\x19' /* C-y: change parity mode */ \n#define KEY_BITS    '\\x02' /* C-b: change number of databits */ \n#define KEY_LECHO   '\\x03' /* C-c: toggle local echo */ \n#define KEY_STATUS  '\\x16' /* C-v: show program option */\n#define KEY_SEND    '\\x13' /* C-s: send file */\n#define KEY_RECEIVE '\\x12' /* C-r: receive file */\n#define KEY_BREAK   '\\x1c' /* C-\\: break */\n\n/**********************************************************************/\n\n/* implemented caracter mappings */\n#define M_CRLF   (1 << 0) /* map CR  --> LF */\n#define M_CRCRLF (1 << 1) /* map CR  --> CR + LF */\n#define M_IGNCR  (1 << 2) /* map CR  --> <nothing> */\n#define M_LFCR   (1 << 3) /* map LF  --> CR */\n#define M_LFCRLF (1 << 4) /* map LF  --> CR + LF */\n#define M_IGNLF  (1 << 5) /* map LF  --> <nothing> */\n#define M_DELBS  (1 << 6) /* map DEL --> BS */\n#define M_BSDEL  (1 << 7) /* map BS  --> DEL */\n#define M_NFLAGS 8\n\n/* default character mappings */\n#define M_I_DFL 0\n#define M_O_DFL 0\n#define M_E_DFL (M_DELBS | M_CRCRLF)\n\n/* character mapping names */\nstruct map_names_s {\n\tchar *name;\n\tint flag;\n} map_names[] = {\n\t{ \"crlf\", M_CRLF },\n\t{ \"crcrlf\", M_CRCRLF },\n\t{ \"igncr\", M_IGNCR },\n    { \"lfcr\", M_LFCR },\n\t{ \"lfcrlf\", M_LFCRLF },\n\t{ \"ignlf\", M_IGNLF },\n\t{ \"delbs\", M_DELBS },\n\t{ \"bsdel\", M_BSDEL },\n\t/* Sentinel */\n\t{ NULL, 0 } \n};\n\nint\nparse_map (char *s)\n{\n\tchar *m, *t;\n\tint f, flags, i;\n\n\tflags = 0;\n\twhile ( (t = strtok(s, \", \\t\")) ) {\n\t\tfor (i=0; (m = map_names[i].name); i++) {\n\t\t\tif ( ! strcmp(t, m) ) {\n\t\t\t\tf = map_names[i].flag;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( m ) flags |= f;\n\t\telse { flags = -1; break; }\n\t\ts = NULL;\n\t}\n\n\treturn flags;\n}\n\nvoid\nprint_map (int flags)\n{\n\tint i;\n\n\tfor (i = 0; i < M_NFLAGS; i++)\n\t\tif ( flags & (1 << i) )\n\t\t\tprintf(\"%s,\", map_names[i].name);\n\tprintf(\"\\n\");\n}\n\n/**********************************************************************/\n\nstruct {\n\tchar port[128];\n\tint baud;\n\tenum flowcntrl_e flow;\n\tenum parity_e parity;\n\tint databits;\n\tint lecho;\n\tint noinit;\n\tint noreset;\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\tint nolock;\n#endif\n\tunsigned char escape;\n\tchar send_cmd[128];\n\tchar receive_cmd[128];\n\tint imap;\n\tint omap;\n\tint emap;\n} opts = {\n\t.port = \"\",\n\t.baud = 9600,\n\t.flow = FC_NONE,\n\t.parity = P_NONE,\n\t.databits = 8,\n\t.lecho = 0,\n\t.noinit = 0,\n\t.noreset = 0,\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\t.nolock = 0,\n#endif\n\t.escape = '\\x01',\n\t.send_cmd = \"sz -vv\",\n\t.receive_cmd = \"rz -vv\",\n\t.imap = M_I_DFL,\n\t.omap = M_O_DFL,\n\t.emap = M_E_DFL\n};\n\nint sig_exit = 0;\n\n#define STO STDOUT_FILENO\n#define STI STDIN_FILENO\n\nint tty_fd;\n\n#ifndef TTY_Q_SZ\n#define TTY_Q_SZ 256\n#endif\n\nstruct tty_q {\n\tint len;\n\tunsigned char buff[TTY_Q_SZ];\n} tty_q;\n\nint tty_write_sz;\n\n#define TTY_WRITE_SZ_DIV 10\n#define TTY_WRITE_SZ_MIN 8\n\n#define set_tty_write_sz(baud)\t\t\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\t\t\t\t\\\n        tty_write_sz = (baud) / TTY_WRITE_SZ_DIV;\t\t\\\n\t    if ( tty_write_sz < TTY_WRITE_SZ_MIN )\t\t\t\\\n            tty_write_sz = TTY_WRITE_SZ_MIN;\t\t\t\\\n    } while (0)\n\n/**********************************************************************/\n\n#ifdef UUCP_LOCK_DIR\n\n/* use HDB UUCP locks  .. see\n * <http://www.faqs.org/faqs/uucp-internals> for details\n */\n\nchar lockname[_POSIX_PATH_MAX] = \"\";\n\nint\nuucp_lockname(const char *dir, const char *file)\n{\n\tchar *p, *cp;\n\tstruct stat sb;\n\n\tif ( ! dir || *dir == '\\0' || stat(dir, &sb) != 0 )\n\t\treturn -1;\n\n\t/* cut-off initial \"/dev/\" from file-name */\n\tp = strchr(file + 1, '/');\n\tp = p ? p + 1 : (char *)file;\n\t/* replace '/'s with '_'s in what remains (after making a copy) */\n\tp = cp = strdup(p);\n\tdo { if ( *p == '/' ) *p = '_'; } while(*p++);\n\t/* build lockname */\n\tsnprintf(lockname, sizeof(lockname), \"%s/LCK..%s\", dir, cp);\n\t/* destroy the copy */\n\tfree(cp);\n\n\treturn 0;\n}\n\nint\nuucp_lock(void)\n{\n\tint r, fd, pid;\n\tchar buf[16];\n\tmode_t m;\n\n\tif ( lockname[0] == '\\0' ) return 0;\n\n\tfd = open(lockname, O_RDONLY);\n\tif ( fd >= 0 ) {\n\t\tr = read(fd, buf, sizeof(buf)); \n\t\tclose(fd);\n\t\t/* if r == 4, lock file is binary (old-style) */\n\t\tpid = (r == 4) ? *(int *)buf : strtol(buf, NULL, 10);\n\t\tif ( pid > 0 \n\t\t\t && kill((pid_t)pid, 0) < 0 \n\t\t\t && errno == ESRCH ) {\n\t\t\t/* stale lock file */\n\t\t\tprintf(\"Removing stale lock: %s\\n\", lockname);\n\t\t\tsleep(1);\n\t\t\tunlink(lockname);\n\t\t} else {\n\t\t\tlockname[0] = '\\0';\n\t\t\terrno = EEXIST;\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* lock it */\n\tm = umask(022);\n\tfd = open(lockname, O_WRONLY|O_CREAT|O_EXCL, 0666);\n\tif ( fd < 0 ) { lockname[0] = '\\0'; return -1; }\n\tumask(m);\n\tsnprintf(buf, sizeof(buf), \"%04d\\n\", getpid());\n\twrite(fd, buf, strlen(buf));\n\tclose(fd);\n\n\treturn 0;\n}\n\nint\nuucp_unlock(void)\n{\n\tif ( lockname[0] ) unlink(lockname);\n\treturn 0;\n}\n\n#endif /* of UUCP_LOCK_DIR */\n\n/**********************************************************************/\n\nssize_t\nwriten_ni(int fd, const void *buff, size_t n)\n{\n\tsize_t nl; \n\tssize_t nw;\n\tconst char *p;\n\n\tp = buff;\n\tnl = n;\n\twhile (nl > 0) {\n\t\tdo {\n\t\t\tnw = write(fd, p, nl);\n\t\t} while ( nw < 0 && errno == EINTR );\n\t\tif ( nw <= 0 ) break;\n\t\tnl -= nw;\n\t\tp += nw;\n\t}\n\t\n\treturn n - nl;\n}\n\nint\nfd_printf (int fd, const char *format, ...)\n{\n\tchar buf[256];\n\tva_list args;\n\tint len;\n\t\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf), format, args);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tva_end(args);\n\t\n\treturn writen_ni(fd, buf, len);\n}\n\nvoid\nfatal (const char *format, ...)\n{\n\tchar *s, buf[256];\n\tva_list args;\n\tint len;\n\n\tterm_reset(STO);\n\tterm_reset(STI);\n\t\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf), format, args);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tva_end(args);\n\t\n\ts = \"\\r\\nFATAL: \";\n\twriten_ni(STO, s, strlen(s));\n\twriten_ni(STO, buf, len);\n\ts = \"\\r\\n\";\n\twriten_ni(STO, s, strlen(s));\n\n\t/* wait a bit for output to drain */\n\tsleep(1);\n\n#ifdef UUCP_LOCK_DIR\n\tuucp_unlock();\n#endif\n\t\n\texit(EXIT_FAILURE);\n}\n\n/**********************************************************************/\n\n#ifndef LINENOISE\n\nint cput(int fd, char c) { return write(fd, &c, 1); }\n\nint\nfd_readline (int fdi, int fdo, char *b, int bsz)\n{\n\tint r;\n\tunsigned char c;\n\tunsigned char *bp, *bpe;\n\t\n\tbp = (unsigned char *)b;\n\tbpe = (unsigned char *)b + bsz - 1;\n\n\twhile (1) {\n\t\tr = read(fdi, &c, 1);\n\t\tif ( r <= 0 ) { r = -1; goto out; }\n\n\t\tswitch (c) {\n\t\tcase '\\b':\n\t\tcase '\\x7f':\n\t\t\tif ( bp > (unsigned char *)b ) { \n\t\t\t\tbp--;\n\t\t\t\tcput(fdo, '\\b'); cput(fdo, ' '); cput(fdo, '\\b');\n\t\t\t} else {\n\t\t\t\tcput(fdo, '\\x07');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\x03': /* CTRL-c */\n\t\t\tr = -1;\n\t\t\terrno = EINTR;\n\t\t\tgoto out;\n\t\tcase '\\r':\n\t\t\t*bp = '\\0';\n\t\t\tr = bp - (unsigned char *)b; \n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tif ( bp < bpe ) { *bp++ = c; cput(fdo, c); }\n\t\t\telse { cput(fdo, '\\x07'); }\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn r;\n}\n\nchar *\nread_filename (void)\n{\n\tchar fname[_POSIX_PATH_MAX];\n\tint r;\n\n\tfd_printf(STO, \"\\r\\n*** file: \");\n\tr = fd_readline(STI, STO, fname, sizeof(fname));\n\tfd_printf(STO, \"\\r\\n\");\n\tif ( r < 0 ) \n\t\treturn NULL;\n\telse\n\t\treturn strdup(fname);\n}\n\n#else /* LINENOISE defined */\n\nvoid \nfile_completion_cb (const char *buf, linenoiseCompletions *lc) \n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *basec, *basen, *dirc, *dirn;\n\tint baselen, dirlen;\n\tchar *fullpath;\n\tstruct stat filestat;\n\n\tbasec = strdup(buf);\n\tdirc = strdup(buf);\n\tdirn = dirname(dirc);\n\tdirlen = strlen(dirn);\n\tbasen = basename(basec);\n\tbaselen = strlen(basen);\n\tdirp = opendir(dirn);\n\n\tif (dirp) {\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (strncmp(basen, dp->d_name, baselen) == 0) {\n\t\t\t\t/* add 2 extra bytes for possible / in middle & at end */\n\t\t\t\tfullpath = (char *) malloc(strlen(dp->d_name) + dirlen + 3);\n\t\t\t\tstrcpy(fullpath, dirn);\n\t\t\t\tif (fullpath[dirlen-1] != '/')\n\t\t\t\t\tstrcat(fullpath, \"/\");\n\t\t\t\tstrcat(fullpath, dp->d_name);\n\t\t\t\tif (stat(fullpath, &filestat) == 0) {\n\t\t\t\t\tif (S_ISDIR(filestat.st_mode)) {\n\t\t\t\t\t\tstrcat(fullpath, \"/\");\n\t\t\t\t\t}\n\t\t\t\t\tlinenoiseAddCompletion(lc,fullpath);\n\t\t\t\t}\n\t\t\t\tfree(fullpath);\n\t\t\t}\n\t\t}\n\n\t\tclosedir(dirp);\n\t}\n\tfree(basec);\n\tfree(dirc);\n}\n\nstatic char *send_receive_history_file_path = NULL;\n\nvoid \ninit_send_receive_history (void)\n{\n\tchar *home_directory;\n\n\thome_directory = getenv(\"HOME\");\n\tif (home_directory) {\n\t\tsend_receive_history_file_path = \n\t\t\tmalloc(strlen(home_directory) + 2 + \n\t\t\t\t   strlen(SEND_RECEIVE_HISTFILE));\n\t\tstrcpy(send_receive_history_file_path, home_directory);\n\t\tif (home_directory[strlen(home_directory)-1] != '/') {\n\t\t\tstrcat(send_receive_history_file_path, \"/\");\n\t\t}\n\t\tstrcat(send_receive_history_file_path, SEND_RECEIVE_HISTFILE);\n\t\tlinenoiseHistoryLoad(send_receive_history_file_path);\n\t}\n}\n\nvoid \ncleanup_send_receive_history (void)\n{\n\tif (send_receive_history_file_path)\n\t\tfree(send_receive_history_file_path);\n}\n\nvoid \nadd_send_receive_history (char *fname)\n{\n\tlinenoiseHistoryAdd(fname);\n\tif (send_receive_history_file_path)\n\t\tlinenoiseHistorySave(send_receive_history_file_path);\n}\n\nchar *\nread_filename (void)\n{\n\tchar *fname;\n\tlinenoiseSetCompletionCallback(file_completion_cb);\n\tprintf(\"\\r\\n\");\n\tfname = linenoise(\"*** file: \");\n\tprintf(\"\\r\\n\");\n\tlinenoiseSetCompletionCallback(NULL);\n\tif (fname != NULL)\n\t\tadd_send_receive_history(fname);\n\treturn fname;\n}\n\n#endif /* of ifndef LINENOISE */\n\n/**********************************************************************/\n\n/* maximum number of chars that can replace a single characted\n   due to mapping */\n#define M_MAXMAP 4\n\nint\ndo_map (char *b, int map, char c)\n{\n\tint n;\n\n\tswitch (c) {\n\tcase '\\x7f':\n\t\t/* DEL mapings */\n\t\tif ( map & M_DELBS ) {\n\t\t\tb[0] = '\\x08'; n = 1;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x08':\n\t\t/* BS mapings */\n\t\tif ( map & M_BSDEL ) {\n\t\t\tb[0] = '\\x7f'; n = 1;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x0d':\n\t\t/* CR mappings */\n\t\tif ( map & M_CRLF ) {\n\t\t\tb[0] = '\\x0a'; n = 1;\n\t\t} else if ( map & M_CRCRLF ) {\n\t\t\tb[0] = '\\x0d'; b[1] = '\\x0a'; n = 2;\n\t\t} else if ( map & M_IGNCR ) {\n\t\t\tn = 0;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x0a':\n\t\t/* LF mappings */\n\t\tif ( map & M_LFCR ) {\n\t\t\tb[0] = '\\x0d'; n = 1;\n\t\t} else if ( map & M_LFCRLF ) {\n\t\t\tb[0] = '\\x0d'; b[1] = '\\x0a'; n = 2;\n\t\t} else if ( map & M_IGNLF ) {\n\t\t\tn = 0;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tb[0] = c; n = 1;\n\t\tbreak;\n\t}\n\n\treturn n;\n}\n\nvoid \nmap_and_write (int fd, int map, char c)\n{\n\tchar b[M_MAXMAP];\n\tint n;\n\t\t\n\tn = do_map(b, map, c);\n\tif ( n )\n\t\tif ( writen_ni(fd, b, n) < n )\n\t\t\tfatal(\"write to stdout failed: %s\", strerror(errno));\t\t\n}\n\n/**********************************************************************/\n\nint\nbaud_up (int baud)\n{\n\treturn term_baud_up(baud);\n}\n\nint\nbaud_down (int baud)\n{\n\tint nb;\n\tnb = term_baud_down(baud);\n\tif (nb == 0)\n\t\tnb = baud;\n\treturn nb;\n}\n\nint\nflow_next (int flow)\n{\n\tswitch(flow) {\n\tcase FC_NONE:\n\t\tflow = FC_RTSCTS;\n\t\tbreak;\n\tcase FC_RTSCTS:\n\t\tflow = FC_XONXOFF;\n\t\tbreak;\n\tcase FC_XONXOFF:\n\t\tflow = FC_NONE;\n\t\tbreak;\n\tdefault:\n\t\tflow = FC_NONE;\n\t\tbreak;\n\t}\n\n\treturn flow;\n}\n\nint\nparity_next (int parity)\n{\n\tswitch(parity) {\n\tcase P_NONE:\n\t\tparity = P_EVEN;\n\t\tbreak;\n\tcase P_EVEN:\n\t\tparity = P_ODD;\n\t\tbreak;\n\tcase P_ODD:\n\t\tparity = P_NONE;\n\t\tbreak;\n\tdefault:\n\t\tparity = P_NONE;\n\t\tbreak;\n\t}\n\n\treturn parity;\n}\n\nint\nbits_next (int bits)\n{\n\tbits++;\n\tif (bits > 8) bits = 5;\n\n\treturn bits;\n}\n\nvoid\nshow_status (int dtr_up) \n{\n\tint baud, bits;\n\tenum flowcntrl_e flow;\n\tenum parity_e parity;\n\n\tterm_refresh(tty_fd);\n\n\tbaud = term_get_baudrate(tty_fd, NULL);\n\tflow = term_get_flowcntrl(tty_fd);\n\tparity = term_get_parity(tty_fd);\n\tbits = term_get_databits(tty_fd);\n\t\n\tfd_printf(STO, \"\\r\\n\");\n \n\tif ( baud != opts.baud ) {\n\t\tfd_printf(STO, \"*** baud: %d (%d)\\r\\n\", opts.baud, baud);\n\t} else { \n\t\tfd_printf(STO, \"*** baud: %d\\r\\n\", opts.baud);\n\t}\n\tif ( flow != opts.flow ) {\n\t\tfd_printf(STO, \"*** flow: %s (%s)\\r\\n\", \n\t\t\t\t  flow_str[opts.flow], flow_str[flow]);\n\t} else {\n\t\tfd_printf(STO, \"*** flow: %s\\r\\n\", flow_str[opts.flow]);\n\t}\n\tif ( parity != opts.parity ) {\n\t\tfd_printf(STO, \"*** parity: %s (%s)\\r\\n\", \n\t\t\t\t  parity_str[opts.parity], parity_str[parity]);\n\t} else {\n\t\tfd_printf(STO, \"*** parity: %s\\r\\n\", parity_str[opts.parity]);\n\t}\n\tif ( bits != opts.databits ) {\n\t\tfd_printf(STO, \"*** databits: %d (%d)\\r\\n\", opts.databits, bits);\n\t} else {\n\t\tfd_printf(STO, \"*** databits: %d\\r\\n\", opts.databits);\n\t}\n\tfd_printf(STO, \"*** dtr: %s\\r\\n\", dtr_up ? \"up\" : \"down\");\n}\n\n/**********************************************************************/\n\nvoid\nestablish_child_signal_handlers (void)\n{\n\tstruct sigaction dfl_action;\n\n\t/* Set up the structure to specify the default action. */\n\tdfl_action.sa_handler = SIG_DFL;\n\tsigemptyset (&dfl_action.sa_mask);\n\tdfl_action.sa_flags = 0;\n\t\n\tsigaction (SIGINT, &dfl_action, NULL);\n\tsigaction (SIGTERM, &dfl_action, NULL);\n}\n\n#define EXEC \"exec \"\n\nint\nrun_cmd(int fd, ...)\n{\n\tpid_t pid;\n\tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \"*** cannot fork: %s ***\\r\\n\", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \"\\r\\n*** exit status: %d ***\\r\\n\", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** killed by signal: %d ***\\r\\n\", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** abnormal termination: 0x%x ***\\r\\n\", r);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* child: external program */\n\t\tlong fl;\n\t\tchar cmd[512];\n\n\t\t/* unmanage terminal, and reset it to canonical mode */\n\t\tterm_remove(STI);\n\t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n\t\tclose(STO);\n\t\tdup2(fd, STI);\n\t\tdup2(fd, STO);\n\t\t{\n\t\t\t/* build command-line */\n\t\t\tchar *c, *ce;\n\t\t\tconst char *s;\n\t\t\tint n;\n\t\t\tva_list vls;\n\t\t\t\n\t\t\tstrcpy(cmd, EXEC);\n\t\t\tc = &cmd[sizeof(EXEC)- 1];\n\t\t\tce = cmd + sizeof(cmd) - 1;\n\t\t\tva_start(vls, fd);\n\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n\t\t\t\tn = strlen(s);\n\t\t\t\tif ( c + n + 1 >= ce ) break;\n\t\t\t\tmemcpy(c, s, n); c += n;\n\t\t\t\t*c++ = ' ';\n\t\t\t}\n\t\t\tva_end(vls);\n\t\t\t*c = '\\0';\n\t\t}\n\t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);\n\t\testablish_child_signal_handlers();\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n\t\texit(42);\n\t}\n}\n\n#undef EXEC\n\n/**********************************************************************/\n\n/* Process command key. Returns non-zero if command results in picocom\n   exit, zero otherwise. */\nint\ndo_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \"\\r\\n*** pulse DTR ***\\r\\n\");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \"*** FAILED\\r\\n\");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \"\\r\\n*** DTR: %s ***\\r\\n\", \n\t\t\t\t  dtr_up ? \"up\" : \"down\");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d (%d) ***\\r\\n\", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d ***\\r\\n\", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s (%s) ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s (%s) ***\\r\\n\",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s ***\\r\\n\", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d (%d) ***\\r\\n\",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d ***\\r\\n\", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \"\\r\\n*** local echo: %s ***\\r\\n\", \n\t\t\t\t  opts.lecho ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/**********************************************************************/\n\nvoid\nloop(void)\n{\n\tenum {\n\t\tST_COMMAND,\n\t\tST_TRANSPARENT\n\t} state;\n\tfd_set rdset, wrset;\n\tint r, n;\n\tunsigned char c;\n\n\ttty_q.len = 0;\n\tstate = ST_TRANSPARENT;\n\n\twhile ( ! sig_exit ) {\n\t\tFD_ZERO(&rdset);\n\t\tFD_ZERO(&wrset);\n\t\tFD_SET(STI, &rdset);\n\t\tFD_SET(tty_fd, &rdset);\n\t\tif ( tty_q.len ) FD_SET(tty_fd, &wrset);\n\n\t\tr = select(tty_fd + 1, &rdset, &wrset, NULL, NULL);\n\t\tif ( r < 0 )  {\n\t\t\tif ( errno == EINTR )\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tfatal(\"select failed: %d : %s\", errno, strerror(errno));\n\t\t}\n\n\t\tif ( FD_ISSET(STI, &rdset) ) {\n\n\t\t\t/* read from terminal */\n\n\t\t\tdo {\n\t\t\t\tn = read(STI, &c, 1);\n\t\t\t} while (n < 0 && errno == EINTR);\n\t\t\tif (n == 0) {\n\t\t\t\tfatal(\"stdin closed\");\n\t\t\t} else if (n < 0) {\n\t\t\t\t/* is this really necessary? better safe than sory! */\n\t\t\t\tif ( errno != EAGAIN && errno != EWOULDBLOCK ) \n\t\t\t\t\tfatal(\"read from stdin failed: %s\", strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tgoto skip_proc_STI;\n\t\t\t}\n\n\t\t\tswitch (state) {\n\t\t\tcase ST_COMMAND:\n\t\t\t\tif ( c == opts.escape ) {\n\t\t\t\t\t/* pass the escape character down */\n\t\t\t\t\tif (tty_q.len + M_MAXMAP <= TTY_Q_SZ) {\n\t\t\t\t\t\tn = do_map((char *)tty_q.buff + tty_q.len, \n\t\t\t\t\t\t\t\t   opts.omap, c);\n\t\t\t\t\t\ttty_q.len += n;\n\t\t\t\t\t\tif ( opts.lecho ) \n\t\t\t\t\t\t\tmap_and_write(STO, opts.emap, c);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfd_printf(STO, \"\\x07\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* process command key */\n\t\t\t\t\tif ( do_command(c) )\n\t\t\t\t\t\t/* picocom exit */\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstate = ST_TRANSPARENT;\n\t\t\t\tbreak;\n\t\t\tcase ST_TRANSPARENT:\n\t\t\t\tif ( c == opts.escape ) {\n\t\t\t\t\tstate = ST_COMMAND;\n\t\t\t\t} else {\n\t\t\t\t\tif (tty_q.len + M_MAXMAP <= TTY_Q_SZ) {\n\t\t\t\t\t\tn = do_map((char *)tty_q.buff + tty_q.len, \n\t\t\t\t\t\t\t\t   opts.omap, c);\n\t\t\t\t\t\ttty_q.len += n;\n\t\t\t\t\t\tif ( opts.lecho ) \n\t\t\t\t\t\t\tmap_and_write(STO, opts.emap, c);\n\t\t\t\t\t} else \n\t\t\t\t\t\tfd_printf(STO, \"\\x07\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tskip_proc_STI:\n\n\t\tif ( FD_ISSET(tty_fd, &rdset) ) {\n\n\t\t\t/* read from port */\n\n\t\t\tdo {\n\t\t\t\tn = read(tty_fd, &c, 1);\n\t\t\t} while (n < 0 && errno == EINTR);\n\t\t\tif (n == 0) {\n\t\t\t\tfatal(\"term closed\");\n\t\t\t} else if ( n < 0 ) {\n\t\t\t\tif ( errno != EAGAIN && errno != EWOULDBLOCK )\n\t\t\t\t\tfatal(\"read from term failed: %s\", strerror(errno));\n\t\t\t} else {\n\t\t\t\tmap_and_write(STO, opts.imap, c);\n\t\t\t}\n\t\t}\n\n\t\tif ( FD_ISSET(tty_fd, &wrset) ) {\n\n\t\t\t/* write to port */\n\n\t\t\tint sz;\n\t\t\tsz = (tty_q.len < tty_write_sz) ? tty_q.len : tty_write_sz;\n\t\t\tdo {\n\t\t\t\tn = write(tty_fd, tty_q.buff, sz);\n\t\t\t} while ( n < 0 && errno == EINTR );\n\t\t\tif ( n <= 0 )\n\t\t\t\tfatal(\"write to term failed: %s\", strerror(errno));\n\t\t\tmemmove(tty_q.buff, tty_q.buff + n, tty_q.len - n);\n\t\t\ttty_q.len -= n;\n\t\t}\n\t}\n}\n\n/**********************************************************************/\n\nvoid\ndeadly_handler(int signum)\n{\n\tif ( ! sig_exit ) {\n\t\tsig_exit = 1;\n\t\tkill(0, SIGTERM);\n\t}\n}\n\nvoid\nestablish_signal_handlers (void)\n{\n        struct sigaction exit_action, ign_action;\n\n        /* Set up the structure to specify the exit action. */\n        exit_action.sa_handler = deadly_handler;\n        sigemptyset (&exit_action.sa_mask);\n        exit_action.sa_flags = 0;\n\n        /* Set up the structure to specify the ignore action. */\n        ign_action.sa_handler = SIG_IGN;\n        sigemptyset (&ign_action.sa_mask);\n        ign_action.sa_flags = 0;\n\n        sigaction (SIGTERM, &exit_action, NULL);\n\n        sigaction (SIGINT, &ign_action, NULL); \n        sigaction (SIGHUP, &ign_action, NULL);\n\t\tsigaction (SIGQUIT, &ign_action, NULL);\n        sigaction (SIGALRM, &ign_action, NULL);\n        sigaction (SIGUSR1, &ign_action, NULL);\n        sigaction (SIGUSR2, &ign_action, NULL);\n        sigaction (SIGPIPE, &ign_action, NULL);\n}\n\n/**********************************************************************/\n\nvoid\nshow_usage(char *name)\n{\n\tchar *s;\n\n\ts = strrchr(name, '/');\n\ts = s ? s+1 : name;\n\n\tprintf(\"picocom v%s\\n\", VERSION_STR);\n\n\tprintf(\"\\nCompiled-in options:\\n\");\n\tprintf(\"  TTY_Q_SZ is %d\\n\", TTY_Q_SZ);\n#ifdef USE_HIGH_BAUD\n\tprintf(\"  HIGH_BAUD is enabled\\n\");\n#endif\n#ifdef USE_FLOCK\n\tprintf(\"  USE_FLOCK is enabled\\n\");\n#endif\n#ifdef UUCP_LOCK_DIR\n\tprintf(\"  UUCP_LOCK_DIR is: %s\\n\", UUCP_LOCK_DIR);\n#endif\n#ifdef LINENOISE\n\tprintf(\"  LINENOISE is enabled\\n\");\n\tprintf(\"  SEND_RECEIVE_HISTFILE is: %s\\n\", SEND_RECEIVE_HISTFILE);\n#endif\n\t\n\tprintf(\"\\nUsage is: %s [options] <tty device>\\n\", s);\n\tprintf(\"Options are:\\n\");\n\tprintf(\"  --<b>aud <baudrate>\\n\");\n\tprintf(\"  --<f>low s (=soft) | h (=hard) | n (=none)\\n\");\n\tprintf(\"  --<p>arity o (=odd) | e (=even) | n (=none)\\n\");\n\tprintf(\"  --<d>atabits 5 | 6 | 7 | 8\\n\");\n\tprintf(\"  --<e>scape <char>\\n\");\n\tprintf(\"  --e<c>ho\\n\");\n\tprintf(\"  --no<i>nit\\n\");\n\tprintf(\"  --no<r>eset\\n\");\n\tprintf(\"  --no<l>ock\\n\");\n\tprintf(\"  --<s>end-cmd <command>\\n\");\n\tprintf(\"  --recei<v>e-cmd <command>\\n\");\n\tprintf(\"  --imap <map> (input mappings)\\n\");\n\tprintf(\"  --omap <map> (output mappings)\\n\");\n\tprintf(\"  --emap <map> (local-echo mappings)\\n\");\n\tprintf(\"  --<h>elp\\n\");\n\tprintf(\"<map> is a comma-separated list of one or more of:\\n\");\n\tprintf(\"  crlf : map CR --> LF\\n\");\n\tprintf(\"  crcrlf : map CR --> CR + LF\\n\");\n\tprintf(\"  igncr : ignore CR\\n\");\n\tprintf(\"  lfcr : map LF --> CR\\n\");\n\tprintf(\"  lfcrlf : map LF --> CR + LF\\n\");\n\tprintf(\"  ignlf : ignore LF\\n\");\n\tprintf(\"  bsdel : map BS --> DEL\\n\");\n\tprintf(\"  delbs : map DEL --> BS\\n\");\n\tprintf(\"<?> indicates the equivalent short option.\\n\");\n\tprintf(\"Short options are prefixed by \\\"-\\\" instead of by \\\"--\\\".\\n\");\n}\n\n/**********************************************************************/\n\nvoid\nparse_args(int argc, char *argv[])\n{\n\tint r;\n\n\tstatic struct option longOptions[] =\n\t{\n\t\t{\"receive-cmd\", required_argument, 0, 'v'},\n\t\t{\"send-cmd\", required_argument, 0, 's'},\n        {\"imap\", required_argument, 0, 'I' },\n        {\"omap\", required_argument, 0, 'O' },\n        {\"emap\", required_argument, 0, 'E' },\n\t\t{\"escape\", required_argument, 0, 'e'},\n\t\t{\"echo\", no_argument, 0, 'c'},\n\t\t{\"noinit\", no_argument, 0, 'i'},\n\t\t{\"noreset\", no_argument, 0, 'r'},\n\t\t{\"nolock\", no_argument, 0, 'l'},\n\t\t{\"flow\", required_argument, 0, 'f'},\n\t\t{\"baud\", required_argument, 0, 'b'},\n\t\t{\"parity\", required_argument, 0, 'p'},\n\t\t{\"databits\", required_argument, 0, 'd'},\n\t\t{\"help\", no_argument, 0, 'h'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tr = 0;\n\twhile (1) {\n\t\tint optionIndex = 0;\n\t\tint c;\n\t\tint map;\n\n\t\t/* no default error messages printed. */\n\t\topterr = 0;\n\n\t\tc = getopt_long(argc, argv, \"hirlcv:s:r:e:f:b:p:d:\",\n\t\t\t\t\t\tlongOptions, &optionIndex);\n\n\t\tif (c < 0)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 's':\n\t\t\tstrncpy(opts.send_cmd, optarg, sizeof(opts.send_cmd));\n\t\t\topts.send_cmd[sizeof(opts.send_cmd) - 1] = '\\0';\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tstrncpy(opts.receive_cmd, optarg, sizeof(opts.receive_cmd));\n\t\t\topts.receive_cmd[sizeof(opts.receive_cmd) - 1] = '\\0';\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tmap = parse_map(optarg);\n\t\t\tif (map >= 0) opts.imap = map;\n\t\t\telse { fprintf(stderr, \"Invalid --imap\\n\"); r = -1; }\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tmap = parse_map(optarg);\n\t\t\tif (map >= 0) opts.omap = map;\n\t\t\telse { fprintf(stderr, \"Invalid --omap\\n\"); r = -1; }\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tmap = parse_map(optarg);\n\t\t\tif (map >= 0) opts.emap = map;\n\t\t\telse { fprintf(stderr, \"Invalid --emap\\n\"); r = -1; }\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\topts.lecho = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\topts.noinit = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\topts.noreset = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\t\t\topts.nolock = 1;\n#endif\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\topts.escape = optarg[0] & 0x1f;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase 'X':\n\t\t\tcase 'x':\n\t\t\t\topts.flow = FC_XONXOFF;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\tcase 'h':\n\t\t\t\topts.flow = FC_RTSCTS;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\tcase 'n':\n\t\t\t\topts.flow = FC_NONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Invalid --flow: %c\\n\", optarg[0]);\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topts.baud = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase 'e':\n\t\t\t\topts.parity = P_EVEN;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\topts.parity = P_ODD;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\topts.parity = P_NONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Invalid --parity: %c\\n\", optarg[0]);\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase '5':\n\t\t\t\topts.databits = 5;\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\topts.databits = 6;\n\t\t\t\tbreak;\n\t\t\tcase '7':\n\t\t\t\topts.databits = 7;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\topts.databits = 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Invalid --databits: %c\\n\", optarg[0]);\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tshow_usage(argv[0]);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase '?':\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unrecognized option(s)\\n\");\n\t\t\tr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif ( r < 0 ) {\n\t\t\tfprintf(stderr, \"Run with '--help'.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} /* while */\n\n\tif ( (argc - optind) < 1) {\n\t\tfprintf(stderr, \"No port given\\n\");\n\t\tfprintf(stderr, \"Run with '--help'.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tstrncpy(opts.port, argv[optind], sizeof(opts.port) - 1);\n\topts.port[sizeof(opts.port) - 1] = '\\0';\n\n\tprintf(\"picocom v%s\\n\", VERSION_STR);\n\tprintf(\"\\n\");\n\tprintf(\"port is        : %s\\n\", opts.port);\n\tprintf(\"flowcontrol    : %s\\n\", flow_str[opts.flow]);\n\tprintf(\"baudrate is    : %d\\n\", opts.baud);\n\tprintf(\"parity is      : %s\\n\", parity_str[opts.parity]);\n\tprintf(\"databits are   : %d\\n\", opts.databits);\n\tprintf(\"escape is      : C-%c\\n\", 'a' + opts.escape - 1);\n\tprintf(\"local echo is  : %s\\n\", opts.lecho ? \"yes\" : \"no\");\n\tprintf(\"noinit is      : %s\\n\", opts.noinit ? \"yes\" : \"no\");\n\tprintf(\"noreset is     : %s\\n\", opts.noreset ? \"yes\" : \"no\");\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\tprintf(\"nolock is      : %s\\n\", opts.nolock ? \"yes\" : \"no\");\n#endif\n\tprintf(\"send_cmd is    : %s\\n\", \n\t\t   (opts.send_cmd[0] == '\\0') ? \"disabled\" : opts.send_cmd);\n\tprintf(\"receive_cmd is : %s\\n\", \n\t\t   (opts.receive_cmd[0] == '\\0') ? \"disabled\" : opts.receive_cmd);\n\tprintf(\"imap is        : \"); print_map(opts.imap);\n\tprintf(\"omap is        : \"); print_map(opts.omap);\n\tprintf(\"emap is        : \"); print_map(opts.emap);\n\tprintf(\"\\n\");\n}\n\n/**********************************************************************/\n\n\nint\nmain(int argc, char *argv[])\n{\n\tint r;\n\n\tparse_args(argc, argv);\n\n\testablish_signal_handlers();\n\n\tr = term_lib_init();\n\tif ( r < 0 )\n\t\tfatal(\"term_init failed: %s\", term_strerror(term_errno, errno));\n\n#ifdef UUCP_LOCK_DIR\n\tif ( ! opts.nolock ) uucp_lockname(UUCP_LOCK_DIR, opts.port);\n\tif ( uucp_lock() < 0 )\n\t\tfatal(\"cannot lock %s: %s\", opts.port, strerror(errno));\n#endif\n\n\ttty_fd = open(opts.port, O_RDWR | O_NONBLOCK | O_NOCTTY);\n\tif (tty_fd < 0)\n\t\tfatal(\"cannot open %s: %s\", opts.port, strerror(errno));\n\n#ifdef USE_FLOCK\n\tif ( ! opts.nolock ) {\n\t\tr = flock(tty_fd, LOCK_EX | LOCK_NB);\n\t\tif ( r < 0 )\n\t\t\tfatal(\"cannot lock %s: %s\", opts.port, strerror(errno));\n\t}\n#endif\n\n\tif ( opts.noinit ) {\n\t\tr = term_add(tty_fd);\n\t} else {\n\t\tr = term_set(tty_fd,\n\t\t\t\t\t 1,              /* raw mode. */\n\t\t\t\t\t opts.baud,      /* baud rate. */\n\t\t\t\t\t opts.parity,    /* parity. */\n\t\t\t\t\t opts.databits,  /* data bits. */\n\t\t\t\t\t opts.flow,      /* flow control. */\n\t\t\t\t\t 1,              /* local or modem */\n\t\t\t\t\t !opts.noreset); /* hup-on-close. */\n\t}\n\tif ( r < 0 )\n\t\tfatal(\"failed to add device %s: %s\", \n\t\t\t  opts.port, term_strerror(term_errno, errno));\n\tr = term_apply(tty_fd);\n\tif ( r < 0 )\n\t\tfatal(\"failed to config device %s: %s\", \n\t\t\t  opts.port, term_strerror(term_errno, errno));\n\n\tset_tty_write_sz(term_get_baudrate(tty_fd, NULL));\n\t\n\tr = term_add(STI);\n\tif ( r < 0 )\n\t\tfatal(\"failed to add I/O device: %s\", \n\t\t\t  term_strerror(term_errno, errno));\n\tterm_set_raw(STI);\n\tr = term_apply(STI);\n\tif ( r < 0 )\n\t\tfatal(\"failed to set I/O device to raw mode: %s\",\n\t\t\t  term_strerror(term_errno, errno));\n\n#ifdef LINENOISE\n\tinit_send_receive_history();\n#endif\n\n\tfd_printf(STO, \"Terminal ready\\r\\n\");\n\tloop();\n\n#ifdef LINENOISE\n\tcleanup_send_receive_history();\n#endif\n\n\tfd_printf(STO, \"\\r\\n\");\n\tif ( opts.noreset ) {\n\t\tfd_printf(STO, \"Skipping tty reset...\\r\\n\");\n\t\tterm_erase(tty_fd);\n\t}\n\n\tif ( sig_exit )\n\t\tfd_printf(STO, \"Picocom was killed\\r\\n\");\n\telse\n\t\tfd_printf(STO, \"Thanks for using picocom\\r\\n\");\n\t/* wait a bit for output to drain */\n\tsleep(1);\n\n#ifdef UUCP_LOCK_DIR\n\tuucp_unlock();\n#endif\n\n\treturn EXIT_SUCCESS;\n}\n\n/**********************************************************************/\n\n/*\n * Local Variables:\n * mode:c\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n */\n"], "fixing_code": ["\nVERSION=2.0a\n\n# CC = gcc\nCPPFLAGS=-DVERSION_STR=\\\"$(VERSION)\\\"\nCFLAGS = -Wall -g\n\n# LD = gcc\nLDFLAGS = -g\nLDLIBS =\n\n## Increase this to use larger input (e.g. copy-paste) buffer\nTTY_Q_SZ = 1024\nCPPFLAGS += -DTTY_Q_SZ=$(TTY_Q_SZ)\n\n## Comment this out to disable high-baudrate support\nCPPFLAGS += -DHIGH_BAUD\n\n## Normally you should NOT enable both: UUCP-style and flock(2)\n## locking.\n\n## Comment this out to disable locking with flock\nCPPFLAGS += -DUSE_FLOCK\n\n## Comment these out to disable UUCP-style lockdirs\n#UUCP_LOCK_DIR=/var/lock\n#CPPFLAGS += -DUUCP_LOCK_DIR=\\\"$(UUCP_LOCK_DIR)\\\"\n\n## Comment these out to disable \"linenoise\"-library support\nSEND_RECEIVE_HISTFILE = .picocom_send_receive\nCPPFLAGS += -DSEND_RECEIVE_HISTFILE=\\\"$(SEND_RECEIVE_HISTFILE)\\\" \\\n\t    -DLINENOISE\npicocom : linenoise-1.0/linenoise.o\nlinenoise-1.0/linenoise.o : linenoise-1.0/linenoise.c linenoise-1.0/linenoise.h\n\npicocom : picocom.o term.o split.o\n#\t$(LD) $(LDFLAGS) -o $@ $+ $(LDLIBS)\n\npicocom.o : picocom.c term.h\nterm.o : term.c term.h\nsplit.o : split.c split.h\n\n\ndoc : picocom.8 picocom.8.html picocom.8.ps\n\nchanges :\n\tsvn log -v . > CHANGES\n\npicocom.8 : picocom.8.xml\n\txmltoman $< > $@\n\npicocom.8.html : picocom.8.xml\n\txmlmantohtml $< > $@\n\npicocom.8.ps : picocom.8\n\tgroff -mandoc -Tps $< > $@\n\nclean:\n\trm -f picocom.o term.o linenoise-1.0/linenoise.o\n\trm -f *~\n\trm -f \\#*\\#\n\ndistclean: clean\n\trm -f picocom\n\nrealclean: distclean\n\trm -f picocom.8\n\trm -f picocom.8.html\n\trm -f picocom.8.ps\n\trm -f CHANGES\n", "/* vi: set sw=4 ts=4:\n *\n * picocom.c\n *\n * simple dumb-terminal program. Helps you manually configure and test\n * stuff like modems, devices w. serial ports etc.\n *\n * by Nick Patavalis (npat@efault.net)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA \n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <assert.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <limits.h>\n#ifdef USE_FLOCK\n#include <sys/file.h>\n#endif\n#ifdef LINENOISE\n#include <dirent.h>\n#include <libgen.h>\n#endif\n\n#define _GNU_SOURCE\n#include <getopt.h>\n\n#include \"split.h\"\n#include \"term.h\"\n#ifdef LINENOISE\n#include \"linenoise-1.0/linenoise.h\"\n#endif\n\n/**********************************************************************/\n\n/* parity modes names */\nconst char *parity_str[] = {\n\t[P_NONE] = \"none\",\n\t[P_EVEN] = \"even\",\n\t[P_ODD] = \"odd\",\n\t[P_MARK] = \"mark\",\n\t[P_SPACE] = \"space\",\n};\n\n/* flow control modes names */\nconst char *flow_str[] = {\n\t[FC_NONE] = \"none\",\n\t[FC_RTSCTS] = \"RTS/CTS\",\n\t[FC_XONXOFF] = \"xon/xoff\",\n\t[FC_OTHER] = \"other\",\n};\n\n/**********************************************************************/\n\n#define KEY_EXIT    '\\x18' /* C-x: exit picocom */\n#define KEY_QUIT    '\\x11' /* C-q: exit picocom without reseting port */\n#define KEY_PULSE   '\\x10' /* C-p: pulse DTR */\n#define KEY_TOGGLE  '\\x14' /* C-t: toggle DTR */\n#define KEY_BAUD_UP '\\x15' /* C-u: increase baudrate (up) */\n#define KEY_BAUD_DN '\\x04' /* C-d: decrase baudrate (down) */ \n#define KEY_FLOW    '\\x06' /* C-f: change flowcntrl mode */ \n#define KEY_PARITY  '\\x19' /* C-y: change parity mode */ \n#define KEY_BITS    '\\x02' /* C-b: change number of databits */ \n#define KEY_LECHO   '\\x03' /* C-c: toggle local echo */ \n#define KEY_STATUS  '\\x16' /* C-v: show program option */\n#define KEY_SEND    '\\x13' /* C-s: send file */\n#define KEY_RECEIVE '\\x12' /* C-r: receive file */\n#define KEY_BREAK   '\\x1c' /* C-\\: break */\n\n/**********************************************************************/\n\n/* implemented caracter mappings */\n#define M_CRLF   (1 << 0) /* map CR  --> LF */\n#define M_CRCRLF (1 << 1) /* map CR  --> CR + LF */\n#define M_IGNCR  (1 << 2) /* map CR  --> <nothing> */\n#define M_LFCR   (1 << 3) /* map LF  --> CR */\n#define M_LFCRLF (1 << 4) /* map LF  --> CR + LF */\n#define M_IGNLF  (1 << 5) /* map LF  --> <nothing> */\n#define M_DELBS  (1 << 6) /* map DEL --> BS */\n#define M_BSDEL  (1 << 7) /* map BS  --> DEL */\n#define M_NFLAGS 8\n\n/* default character mappings */\n#define M_I_DFL 0\n#define M_O_DFL 0\n#define M_E_DFL (M_DELBS | M_CRCRLF)\n\n/* character mapping names */\nstruct map_names_s {\n\tchar *name;\n\tint flag;\n} map_names[] = {\n\t{ \"crlf\", M_CRLF },\n\t{ \"crcrlf\", M_CRCRLF },\n\t{ \"igncr\", M_IGNCR },\n    { \"lfcr\", M_LFCR },\n\t{ \"lfcrlf\", M_LFCRLF },\n\t{ \"ignlf\", M_IGNLF },\n\t{ \"delbs\", M_DELBS },\n\t{ \"bsdel\", M_BSDEL },\n\t/* Sentinel */\n\t{ NULL, 0 } \n};\n\nint\nparse_map (char *s)\n{\n\tchar *m, *t;\n\tint f, flags, i;\n\n\tflags = 0;\n\twhile ( (t = strtok(s, \", \\t\")) ) {\n\t\tfor (i=0; (m = map_names[i].name); i++) {\n\t\t\tif ( ! strcmp(t, m) ) {\n\t\t\t\tf = map_names[i].flag;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( m ) flags |= f;\n\t\telse { flags = -1; break; }\n\t\ts = NULL;\n\t}\n\n\treturn flags;\n}\n\nvoid\nprint_map (int flags)\n{\n\tint i;\n\n\tfor (i = 0; i < M_NFLAGS; i++)\n\t\tif ( flags & (1 << i) )\n\t\t\tprintf(\"%s,\", map_names[i].name);\n\tprintf(\"\\n\");\n}\n\n/**********************************************************************/\n\nstruct {\n\tchar port[128];\n\tint baud;\n\tenum flowcntrl_e flow;\n\tenum parity_e parity;\n\tint databits;\n\tint lecho;\n\tint noinit;\n\tint noreset;\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\tint nolock;\n#endif\n\tunsigned char escape;\n\tchar send_cmd[128];\n\tchar receive_cmd[128];\n\tint imap;\n\tint omap;\n\tint emap;\n} opts = {\n\t.port = \"\",\n\t.baud = 9600,\n\t.flow = FC_NONE,\n\t.parity = P_NONE,\n\t.databits = 8,\n\t.lecho = 0,\n\t.noinit = 0,\n\t.noreset = 0,\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\t.nolock = 0,\n#endif\n\t.escape = '\\x01',\n\t.send_cmd = \"sz -vv\",\n\t.receive_cmd = \"rz -vv\",\n\t.imap = M_I_DFL,\n\t.omap = M_O_DFL,\n\t.emap = M_E_DFL\n};\n\nint sig_exit = 0;\n\n#define STO STDOUT_FILENO\n#define STI STDIN_FILENO\n\nint tty_fd;\n\n#ifndef TTY_Q_SZ\n#define TTY_Q_SZ 256\n#endif\n\nstruct tty_q {\n\tint len;\n\tunsigned char buff[TTY_Q_SZ];\n} tty_q;\n\nint tty_write_sz;\n\n#define TTY_WRITE_SZ_DIV 10\n#define TTY_WRITE_SZ_MIN 8\n\n#define set_tty_write_sz(baud)\t\t\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\t\t\t\t\\\n        tty_write_sz = (baud) / TTY_WRITE_SZ_DIV;\t\t\\\n\t    if ( tty_write_sz < TTY_WRITE_SZ_MIN )\t\t\t\\\n            tty_write_sz = TTY_WRITE_SZ_MIN;\t\t\t\\\n    } while (0)\n\n/**********************************************************************/\n\n#ifdef UUCP_LOCK_DIR\n\n/* use HDB UUCP locks  .. see\n * <http://www.faqs.org/faqs/uucp-internals> for details\n */\n\nchar lockname[_POSIX_PATH_MAX] = \"\";\n\nint\nuucp_lockname(const char *dir, const char *file)\n{\n\tchar *p, *cp;\n\tstruct stat sb;\n\n\tif ( ! dir || *dir == '\\0' || stat(dir, &sb) != 0 )\n\t\treturn -1;\n\n\t/* cut-off initial \"/dev/\" from file-name */\n\tp = strchr(file + 1, '/');\n\tp = p ? p + 1 : (char *)file;\n\t/* replace '/'s with '_'s in what remains (after making a copy) */\n\tp = cp = strdup(p);\n\tdo { if ( *p == '/' ) *p = '_'; } while(*p++);\n\t/* build lockname */\n\tsnprintf(lockname, sizeof(lockname), \"%s/LCK..%s\", dir, cp);\n\t/* destroy the copy */\n\tfree(cp);\n\n\treturn 0;\n}\n\nint\nuucp_lock(void)\n{\n\tint r, fd, pid;\n\tchar buf[16];\n\tmode_t m;\n\n\tif ( lockname[0] == '\\0' ) return 0;\n\n\tfd = open(lockname, O_RDONLY);\n\tif ( fd >= 0 ) {\n\t\tr = read(fd, buf, sizeof(buf)); \n\t\tclose(fd);\n\t\t/* if r == 4, lock file is binary (old-style) */\n\t\tpid = (r == 4) ? *(int *)buf : strtol(buf, NULL, 10);\n\t\tif ( pid > 0 \n\t\t\t && kill((pid_t)pid, 0) < 0 \n\t\t\t && errno == ESRCH ) {\n\t\t\t/* stale lock file */\n\t\t\tprintf(\"Removing stale lock: %s\\n\", lockname);\n\t\t\tsleep(1);\n\t\t\tunlink(lockname);\n\t\t} else {\n\t\t\tlockname[0] = '\\0';\n\t\t\terrno = EEXIST;\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* lock it */\n\tm = umask(022);\n\tfd = open(lockname, O_WRONLY|O_CREAT|O_EXCL, 0666);\n\tif ( fd < 0 ) { lockname[0] = '\\0'; return -1; }\n\tumask(m);\n\tsnprintf(buf, sizeof(buf), \"%04d\\n\", getpid());\n\twrite(fd, buf, strlen(buf));\n\tclose(fd);\n\n\treturn 0;\n}\n\nint\nuucp_unlock(void)\n{\n\tif ( lockname[0] ) unlink(lockname);\n\treturn 0;\n}\n\n#endif /* of UUCP_LOCK_DIR */\n\n/**********************************************************************/\n\nssize_t\nwriten_ni(int fd, const void *buff, size_t n)\n{\n\tsize_t nl; \n\tssize_t nw;\n\tconst char *p;\n\n\tp = buff;\n\tnl = n;\n\twhile (nl > 0) {\n\t\tdo {\n\t\t\tnw = write(fd, p, nl);\n\t\t} while ( nw < 0 && errno == EINTR );\n\t\tif ( nw <= 0 ) break;\n\t\tnl -= nw;\n\t\tp += nw;\n\t}\n\t\n\treturn n - nl;\n}\n\nint\nfd_printf (int fd, const char *format, ...)\n{\n\tchar buf[256];\n\tva_list args;\n\tint len;\n\t\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf), format, args);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tva_end(args);\n\t\n\treturn writen_ni(fd, buf, len);\n}\n\nvoid\nfatal (const char *format, ...)\n{\n\tchar *s, buf[256];\n\tva_list args;\n\tint len;\n\n\tterm_reset(STO);\n\tterm_reset(STI);\n\t\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf), format, args);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tva_end(args);\n\t\n\ts = \"\\r\\nFATAL: \";\n\twriten_ni(STO, s, strlen(s));\n\twriten_ni(STO, buf, len);\n\ts = \"\\r\\n\";\n\twriten_ni(STO, s, strlen(s));\n\n\t/* wait a bit for output to drain */\n\tsleep(1);\n\n#ifdef UUCP_LOCK_DIR\n\tuucp_unlock();\n#endif\n\t\n\texit(EXIT_FAILURE);\n}\n\n/**********************************************************************/\n\n#ifndef LINENOISE\n\nint cput(int fd, char c) { return write(fd, &c, 1); }\n\nint\nfd_readline (int fdi, int fdo, char *b, int bsz)\n{\n\tint r;\n\tunsigned char c;\n\tunsigned char *bp, *bpe;\n\t\n\tbp = (unsigned char *)b;\n\tbpe = (unsigned char *)b + bsz - 1;\n\n\twhile (1) {\n\t\tr = read(fdi, &c, 1);\n\t\tif ( r <= 0 ) { r = -1; goto out; }\n\n\t\tswitch (c) {\n\t\tcase '\\b':\n\t\tcase '\\x7f':\n\t\t\tif ( bp > (unsigned char *)b ) { \n\t\t\t\tbp--;\n\t\t\t\tcput(fdo, '\\b'); cput(fdo, ' '); cput(fdo, '\\b');\n\t\t\t} else {\n\t\t\t\tcput(fdo, '\\x07');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\x03': /* CTRL-c */\n\t\t\tr = -1;\n\t\t\terrno = EINTR;\n\t\t\tgoto out;\n\t\tcase '\\r':\n\t\t\t*bp = '\\0';\n\t\t\tr = bp - (unsigned char *)b; \n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tif ( bp < bpe ) { *bp++ = c; cput(fdo, c); }\n\t\t\telse { cput(fdo, '\\x07'); }\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn r;\n}\n\nchar *\nread_filename (void)\n{\n\tchar fname[_POSIX_PATH_MAX];\n\tint r;\n\n\tfd_printf(STO, \"\\r\\n*** file: \");\n\tr = fd_readline(STI, STO, fname, sizeof(fname));\n\tfd_printf(STO, \"\\r\\n\");\n\tif ( r < 0 ) \n\t\treturn NULL;\n\telse\n\t\treturn strdup(fname);\n}\n\n#else /* LINENOISE defined */\n\nvoid \nfile_completion_cb (const char *buf, linenoiseCompletions *lc) \n{\n\tDIR *dirp;\n\tstruct dirent *dp;\n\tchar *basec, *basen, *dirc, *dirn;\n\tint baselen, dirlen;\n\tchar *fullpath;\n\tstruct stat filestat;\n\n\tbasec = strdup(buf);\n\tdirc = strdup(buf);\n\tdirn = dirname(dirc);\n\tdirlen = strlen(dirn);\n\tbasen = basename(basec);\n\tbaselen = strlen(basen);\n\tdirp = opendir(dirn);\n\n\tif (dirp) {\n\t\twhile ((dp = readdir(dirp)) != NULL) {\n\t\t\tif (strncmp(basen, dp->d_name, baselen) == 0) {\n\t\t\t\t/* add 2 extra bytes for possible / in middle & at end */\n\t\t\t\tfullpath = (char *) malloc(strlen(dp->d_name) + dirlen + 3);\n\t\t\t\tstrcpy(fullpath, dirn);\n\t\t\t\tif (fullpath[dirlen-1] != '/')\n\t\t\t\t\tstrcat(fullpath, \"/\");\n\t\t\t\tstrcat(fullpath, dp->d_name);\n\t\t\t\tif (stat(fullpath, &filestat) == 0) {\n\t\t\t\t\tif (S_ISDIR(filestat.st_mode)) {\n\t\t\t\t\t\tstrcat(fullpath, \"/\");\n\t\t\t\t\t}\n\t\t\t\t\tlinenoiseAddCompletion(lc,fullpath);\n\t\t\t\t}\n\t\t\t\tfree(fullpath);\n\t\t\t}\n\t\t}\n\n\t\tclosedir(dirp);\n\t}\n\tfree(basec);\n\tfree(dirc);\n}\n\nstatic char *send_receive_history_file_path = NULL;\n\nvoid \ninit_send_receive_history (void)\n{\n\tchar *home_directory;\n\n\thome_directory = getenv(\"HOME\");\n\tif (home_directory) {\n\t\tsend_receive_history_file_path = \n\t\t\tmalloc(strlen(home_directory) + 2 + \n\t\t\t\t   strlen(SEND_RECEIVE_HISTFILE));\n\t\tstrcpy(send_receive_history_file_path, home_directory);\n\t\tif (home_directory[strlen(home_directory)-1] != '/') {\n\t\t\tstrcat(send_receive_history_file_path, \"/\");\n\t\t}\n\t\tstrcat(send_receive_history_file_path, SEND_RECEIVE_HISTFILE);\n\t\tlinenoiseHistoryLoad(send_receive_history_file_path);\n\t}\n}\n\nvoid \ncleanup_send_receive_history (void)\n{\n\tif (send_receive_history_file_path)\n\t\tfree(send_receive_history_file_path);\n}\n\nvoid \nadd_send_receive_history (char *fname)\n{\n\tlinenoiseHistoryAdd(fname);\n\tif (send_receive_history_file_path)\n\t\tlinenoiseHistorySave(send_receive_history_file_path);\n}\n\nchar *\nread_filename (void)\n{\n\tchar *fname;\n\tlinenoiseSetCompletionCallback(file_completion_cb);\n\tprintf(\"\\r\\n\");\n\tfname = linenoise(\"*** file: \");\n\tprintf(\"\\r\\n\");\n\tlinenoiseSetCompletionCallback(NULL);\n\tif (fname != NULL)\n\t\tadd_send_receive_history(fname);\n\treturn fname;\n}\n\n#endif /* of ifndef LINENOISE */\n\n/**********************************************************************/\n\n/* maximum number of chars that can replace a single characted\n   due to mapping */\n#define M_MAXMAP 4\n\nint\ndo_map (char *b, int map, char c)\n{\n\tint n;\n\n\tswitch (c) {\n\tcase '\\x7f':\n\t\t/* DEL mapings */\n\t\tif ( map & M_DELBS ) {\n\t\t\tb[0] = '\\x08'; n = 1;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x08':\n\t\t/* BS mapings */\n\t\tif ( map & M_BSDEL ) {\n\t\t\tb[0] = '\\x7f'; n = 1;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x0d':\n\t\t/* CR mappings */\n\t\tif ( map & M_CRLF ) {\n\t\t\tb[0] = '\\x0a'; n = 1;\n\t\t} else if ( map & M_CRCRLF ) {\n\t\t\tb[0] = '\\x0d'; b[1] = '\\x0a'; n = 2;\n\t\t} else if ( map & M_IGNCR ) {\n\t\t\tn = 0;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x0a':\n\t\t/* LF mappings */\n\t\tif ( map & M_LFCR ) {\n\t\t\tb[0] = '\\x0d'; n = 1;\n\t\t} else if ( map & M_LFCRLF ) {\n\t\t\tb[0] = '\\x0d'; b[1] = '\\x0a'; n = 2;\n\t\t} else if ( map & M_IGNLF ) {\n\t\t\tn = 0;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tb[0] = c; n = 1;\n\t\tbreak;\n\t}\n\n\treturn n;\n}\n\nvoid \nmap_and_write (int fd, int map, char c)\n{\n\tchar b[M_MAXMAP];\n\tint n;\n\t\t\n\tn = do_map(b, map, c);\n\tif ( n )\n\t\tif ( writen_ni(fd, b, n) < n )\n\t\t\tfatal(\"write to stdout failed: %s\", strerror(errno));\t\t\n}\n\n/**********************************************************************/\n\nint\nbaud_up (int baud)\n{\n\treturn term_baud_up(baud);\n}\n\nint\nbaud_down (int baud)\n{\n\tint nb;\n\tnb = term_baud_down(baud);\n\tif (nb == 0)\n\t\tnb = baud;\n\treturn nb;\n}\n\nint\nflow_next (int flow)\n{\n\tswitch(flow) {\n\tcase FC_NONE:\n\t\tflow = FC_RTSCTS;\n\t\tbreak;\n\tcase FC_RTSCTS:\n\t\tflow = FC_XONXOFF;\n\t\tbreak;\n\tcase FC_XONXOFF:\n\t\tflow = FC_NONE;\n\t\tbreak;\n\tdefault:\n\t\tflow = FC_NONE;\n\t\tbreak;\n\t}\n\n\treturn flow;\n}\n\nint\nparity_next (int parity)\n{\n\tswitch(parity) {\n\tcase P_NONE:\n\t\tparity = P_EVEN;\n\t\tbreak;\n\tcase P_EVEN:\n\t\tparity = P_ODD;\n\t\tbreak;\n\tcase P_ODD:\n\t\tparity = P_NONE;\n\t\tbreak;\n\tdefault:\n\t\tparity = P_NONE;\n\t\tbreak;\n\t}\n\n\treturn parity;\n}\n\nint\nbits_next (int bits)\n{\n\tbits++;\n\tif (bits > 8) bits = 5;\n\n\treturn bits;\n}\n\nvoid\nshow_status (int dtr_up) \n{\n\tint baud, bits;\n\tenum flowcntrl_e flow;\n\tenum parity_e parity;\n\n\tterm_refresh(tty_fd);\n\n\tbaud = term_get_baudrate(tty_fd, NULL);\n\tflow = term_get_flowcntrl(tty_fd);\n\tparity = term_get_parity(tty_fd);\n\tbits = term_get_databits(tty_fd);\n\t\n\tfd_printf(STO, \"\\r\\n\");\n \n\tif ( baud != opts.baud ) {\n\t\tfd_printf(STO, \"*** baud: %d (%d)\\r\\n\", opts.baud, baud);\n\t} else { \n\t\tfd_printf(STO, \"*** baud: %d\\r\\n\", opts.baud);\n\t}\n\tif ( flow != opts.flow ) {\n\t\tfd_printf(STO, \"*** flow: %s (%s)\\r\\n\", \n\t\t\t\t  flow_str[opts.flow], flow_str[flow]);\n\t} else {\n\t\tfd_printf(STO, \"*** flow: %s\\r\\n\", flow_str[opts.flow]);\n\t}\n\tif ( parity != opts.parity ) {\n\t\tfd_printf(STO, \"*** parity: %s (%s)\\r\\n\", \n\t\t\t\t  parity_str[opts.parity], parity_str[parity]);\n\t} else {\n\t\tfd_printf(STO, \"*** parity: %s\\r\\n\", parity_str[opts.parity]);\n\t}\n\tif ( bits != opts.databits ) {\n\t\tfd_printf(STO, \"*** databits: %d (%d)\\r\\n\", opts.databits, bits);\n\t} else {\n\t\tfd_printf(STO, \"*** databits: %d\\r\\n\", opts.databits);\n\t}\n\tfd_printf(STO, \"*** dtr: %s\\r\\n\", dtr_up ? \"up\" : \"down\");\n}\n\n/**********************************************************************/\n\n#define RUNCMD_ARGS_MAX 32\n#define RUNCMD_EXEC_FAIL 126\n\nvoid\nestablish_child_signal_handlers (void)\n{\n\tstruct sigaction dfl_action;\n\n\t/* Set up the structure to specify the default action. */\n\tdfl_action.sa_handler = SIG_DFL;\n\tsigemptyset (&dfl_action.sa_mask);\n\tdfl_action.sa_flags = 0;\n\t\n\tsigaction (SIGINT, &dfl_action, NULL);\n\tsigaction (SIGTERM, &dfl_action, NULL);\n}\n\nint\nrun_cmd(int fd, const char *cmd, const char *args_extra)\n{\n\tpid_t pid;\n\tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \"*** cannot fork: %s ***\\r\\n\", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \"\\r\\n*** exit status: %d ***\\r\\n\", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** killed by signal: %d ***\\r\\n\", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** abnormal termination: 0x%x ***\\r\\n\", r);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* child: external program */\n\t\tlong fl;\n\t\tint argc;\n\t\tchar *argv[RUNCMD_ARGS_MAX + 1];\n\t\tint r;\n\t\t\t\n\t\t/* unmanage terminal, and reset it to canonical mode */\n\t\tterm_remove(STI);\n\t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n\t\tclose(STO);\n\t\tdup2(fd, STI);\n\t\tdup2(fd, STO);\n\t\t\n\t\t/* build command arguments vector */\n\t\targc = 0;\n\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);\n\t\tif ( r < 0 ) {\n\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse command\\n\");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\n\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);\n\t\tif ( r < 0 ) {\n\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse extra args\\n\");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\n\t\tif ( argc < 1 ) {\n\t\t\tfd_printf(STDERR_FILENO, \"No command given\\n\");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\t\n\t\targv[argc] = NULL;\n\t\t\t\n\t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \"$ %s %s\\n\", cmd, args_extra);\n\t\testablish_child_signal_handlers();\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecvp(argv[0], argv);\n\n\t\tfd_printf(STDERR_FILENO, \"exec: %s\\n\", strerror(errno));\n\t\texit(RUNCMD_EXEC_FAIL);\n\t}\n}\n\n/**********************************************************************/\n\n/* Process command key. Returns non-zero if command results in picocom\n   exit, zero otherwise. */\nint\ndo_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \"\\r\\n*** pulse DTR ***\\r\\n\");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \"*** FAILED\\r\\n\");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \"\\r\\n*** DTR: %s ***\\r\\n\", \n\t\t\t\t  dtr_up ? \"up\" : \"down\");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d (%d) ***\\r\\n\", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d ***\\r\\n\", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s (%s) ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s (%s) ***\\r\\n\",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s ***\\r\\n\", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d (%d) ***\\r\\n\",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d ***\\r\\n\", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \"\\r\\n*** local echo: %s ***\\r\\n\", \n\t\t\t\t  opts.lecho ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/**********************************************************************/\n\nvoid\nloop(void)\n{\n\tenum {\n\t\tST_COMMAND,\n\t\tST_TRANSPARENT\n\t} state;\n\tfd_set rdset, wrset;\n\tint r, n;\n\tunsigned char c;\n\n\ttty_q.len = 0;\n\tstate = ST_TRANSPARENT;\n\n\twhile ( ! sig_exit ) {\n\t\tFD_ZERO(&rdset);\n\t\tFD_ZERO(&wrset);\n\t\tFD_SET(STI, &rdset);\n\t\tFD_SET(tty_fd, &rdset);\n\t\tif ( tty_q.len ) FD_SET(tty_fd, &wrset);\n\n\t\tr = select(tty_fd + 1, &rdset, &wrset, NULL, NULL);\n\t\tif ( r < 0 )  {\n\t\t\tif ( errno == EINTR )\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tfatal(\"select failed: %d : %s\", errno, strerror(errno));\n\t\t}\n\n\t\tif ( FD_ISSET(STI, &rdset) ) {\n\n\t\t\t/* read from terminal */\n\n\t\t\tdo {\n\t\t\t\tn = read(STI, &c, 1);\n\t\t\t} while (n < 0 && errno == EINTR);\n\t\t\tif (n == 0) {\n\t\t\t\tfatal(\"stdin closed\");\n\t\t\t} else if (n < 0) {\n\t\t\t\t/* is this really necessary? better safe than sory! */\n\t\t\t\tif ( errno != EAGAIN && errno != EWOULDBLOCK ) \n\t\t\t\t\tfatal(\"read from stdin failed: %s\", strerror(errno));\n\t\t\t\telse\n\t\t\t\t\tgoto skip_proc_STI;\n\t\t\t}\n\n\t\t\tswitch (state) {\n\t\t\tcase ST_COMMAND:\n\t\t\t\tif ( c == opts.escape ) {\n\t\t\t\t\t/* pass the escape character down */\n\t\t\t\t\tif (tty_q.len + M_MAXMAP <= TTY_Q_SZ) {\n\t\t\t\t\t\tn = do_map((char *)tty_q.buff + tty_q.len, \n\t\t\t\t\t\t\t\t   opts.omap, c);\n\t\t\t\t\t\ttty_q.len += n;\n\t\t\t\t\t\tif ( opts.lecho ) \n\t\t\t\t\t\t\tmap_and_write(STO, opts.emap, c);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfd_printf(STO, \"\\x07\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* process command key */\n\t\t\t\t\tif ( do_command(c) )\n\t\t\t\t\t\t/* picocom exit */\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstate = ST_TRANSPARENT;\n\t\t\t\tbreak;\n\t\t\tcase ST_TRANSPARENT:\n\t\t\t\tif ( c == opts.escape ) {\n\t\t\t\t\tstate = ST_COMMAND;\n\t\t\t\t} else {\n\t\t\t\t\tif (tty_q.len + M_MAXMAP <= TTY_Q_SZ) {\n\t\t\t\t\t\tn = do_map((char *)tty_q.buff + tty_q.len, \n\t\t\t\t\t\t\t\t   opts.omap, c);\n\t\t\t\t\t\ttty_q.len += n;\n\t\t\t\t\t\tif ( opts.lecho ) \n\t\t\t\t\t\t\tmap_and_write(STO, opts.emap, c);\n\t\t\t\t\t} else \n\t\t\t\t\t\tfd_printf(STO, \"\\x07\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tskip_proc_STI:\n\n\t\tif ( FD_ISSET(tty_fd, &rdset) ) {\n\n\t\t\t/* read from port */\n\n\t\t\tdo {\n\t\t\t\tn = read(tty_fd, &c, 1);\n\t\t\t} while (n < 0 && errno == EINTR);\n\t\t\tif (n == 0) {\n\t\t\t\tfatal(\"term closed\");\n\t\t\t} else if ( n < 0 ) {\n\t\t\t\tif ( errno != EAGAIN && errno != EWOULDBLOCK )\n\t\t\t\t\tfatal(\"read from term failed: %s\", strerror(errno));\n\t\t\t} else {\n\t\t\t\tmap_and_write(STO, opts.imap, c);\n\t\t\t}\n\t\t}\n\n\t\tif ( FD_ISSET(tty_fd, &wrset) ) {\n\n\t\t\t/* write to port */\n\n\t\t\tint sz;\n\t\t\tsz = (tty_q.len < tty_write_sz) ? tty_q.len : tty_write_sz;\n\t\t\tdo {\n\t\t\t\tn = write(tty_fd, tty_q.buff, sz);\n\t\t\t} while ( n < 0 && errno == EINTR );\n\t\t\tif ( n <= 0 )\n\t\t\t\tfatal(\"write to term failed: %s\", strerror(errno));\n\t\t\tmemmove(tty_q.buff, tty_q.buff + n, tty_q.len - n);\n\t\t\ttty_q.len -= n;\n\t\t}\n\t}\n}\n\n/**********************************************************************/\n\nvoid\ndeadly_handler(int signum)\n{\n\tif ( ! sig_exit ) {\n\t\tsig_exit = 1;\n\t\tkill(0, SIGTERM);\n\t}\n}\n\nvoid\nestablish_signal_handlers (void)\n{\n        struct sigaction exit_action, ign_action;\n\n        /* Set up the structure to specify the exit action. */\n        exit_action.sa_handler = deadly_handler;\n        sigemptyset (&exit_action.sa_mask);\n        exit_action.sa_flags = 0;\n\n        /* Set up the structure to specify the ignore action. */\n        ign_action.sa_handler = SIG_IGN;\n        sigemptyset (&ign_action.sa_mask);\n        ign_action.sa_flags = 0;\n\n        sigaction (SIGTERM, &exit_action, NULL);\n\n        sigaction (SIGINT, &ign_action, NULL); \n        sigaction (SIGHUP, &ign_action, NULL);\n\t\tsigaction (SIGQUIT, &ign_action, NULL);\n        sigaction (SIGALRM, &ign_action, NULL);\n        sigaction (SIGUSR1, &ign_action, NULL);\n        sigaction (SIGUSR2, &ign_action, NULL);\n        sigaction (SIGPIPE, &ign_action, NULL);\n}\n\n/**********************************************************************/\n\nvoid\nshow_usage(char *name)\n{\n\tchar *s;\n\n\ts = strrchr(name, '/');\n\ts = s ? s+1 : name;\n\n\tprintf(\"picocom v%s\\n\", VERSION_STR);\n\n\tprintf(\"\\nCompiled-in options:\\n\");\n\tprintf(\"  TTY_Q_SZ is %d\\n\", TTY_Q_SZ);\n#ifdef USE_HIGH_BAUD\n\tprintf(\"  HIGH_BAUD is enabled\\n\");\n#endif\n#ifdef USE_FLOCK\n\tprintf(\"  USE_FLOCK is enabled\\n\");\n#endif\n#ifdef UUCP_LOCK_DIR\n\tprintf(\"  UUCP_LOCK_DIR is: %s\\n\", UUCP_LOCK_DIR);\n#endif\n#ifdef LINENOISE\n\tprintf(\"  LINENOISE is enabled\\n\");\n\tprintf(\"  SEND_RECEIVE_HISTFILE is: %s\\n\", SEND_RECEIVE_HISTFILE);\n#endif\n\t\n\tprintf(\"\\nUsage is: %s [options] <tty device>\\n\", s);\n\tprintf(\"Options are:\\n\");\n\tprintf(\"  --<b>aud <baudrate>\\n\");\n\tprintf(\"  --<f>low s (=soft) | h (=hard) | n (=none)\\n\");\n\tprintf(\"  --<p>arity o (=odd) | e (=even) | n (=none)\\n\");\n\tprintf(\"  --<d>atabits 5 | 6 | 7 | 8\\n\");\n\tprintf(\"  --<e>scape <char>\\n\");\n\tprintf(\"  --e<c>ho\\n\");\n\tprintf(\"  --no<i>nit\\n\");\n\tprintf(\"  --no<r>eset\\n\");\n\tprintf(\"  --no<l>ock\\n\");\n\tprintf(\"  --<s>end-cmd <command>\\n\");\n\tprintf(\"  --recei<v>e-cmd <command>\\n\");\n\tprintf(\"  --imap <map> (input mappings)\\n\");\n\tprintf(\"  --omap <map> (output mappings)\\n\");\n\tprintf(\"  --emap <map> (local-echo mappings)\\n\");\n\tprintf(\"  --<h>elp\\n\");\n\tprintf(\"<map> is a comma-separated list of one or more of:\\n\");\n\tprintf(\"  crlf : map CR --> LF\\n\");\n\tprintf(\"  crcrlf : map CR --> CR + LF\\n\");\n\tprintf(\"  igncr : ignore CR\\n\");\n\tprintf(\"  lfcr : map LF --> CR\\n\");\n\tprintf(\"  lfcrlf : map LF --> CR + LF\\n\");\n\tprintf(\"  ignlf : ignore LF\\n\");\n\tprintf(\"  bsdel : map BS --> DEL\\n\");\n\tprintf(\"  delbs : map DEL --> BS\\n\");\n\tprintf(\"<?> indicates the equivalent short option.\\n\");\n\tprintf(\"Short options are prefixed by \\\"-\\\" instead of by \\\"--\\\".\\n\");\n}\n\n/**********************************************************************/\n\nvoid\nparse_args(int argc, char *argv[])\n{\n\tint r;\n\n\tstatic struct option longOptions[] =\n\t{\n\t\t{\"receive-cmd\", required_argument, 0, 'v'},\n\t\t{\"send-cmd\", required_argument, 0, 's'},\n        {\"imap\", required_argument, 0, 'I' },\n        {\"omap\", required_argument, 0, 'O' },\n        {\"emap\", required_argument, 0, 'E' },\n\t\t{\"escape\", required_argument, 0, 'e'},\n\t\t{\"echo\", no_argument, 0, 'c'},\n\t\t{\"noinit\", no_argument, 0, 'i'},\n\t\t{\"noreset\", no_argument, 0, 'r'},\n\t\t{\"nolock\", no_argument, 0, 'l'},\n\t\t{\"flow\", required_argument, 0, 'f'},\n\t\t{\"baud\", required_argument, 0, 'b'},\n\t\t{\"parity\", required_argument, 0, 'p'},\n\t\t{\"databits\", required_argument, 0, 'd'},\n\t\t{\"help\", no_argument, 0, 'h'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\tr = 0;\n\twhile (1) {\n\t\tint optionIndex = 0;\n\t\tint c;\n\t\tint map;\n\n\t\t/* no default error messages printed. */\n\t\topterr = 0;\n\n\t\tc = getopt_long(argc, argv, \"hirlcv:s:r:e:f:b:p:d:\",\n\t\t\t\t\t\tlongOptions, &optionIndex);\n\n\t\tif (c < 0)\n\t\t\tbreak;\n\n\t\tswitch (c) {\n\t\tcase 's':\n\t\t\tstrncpy(opts.send_cmd, optarg, sizeof(opts.send_cmd));\n\t\t\topts.send_cmd[sizeof(opts.send_cmd) - 1] = '\\0';\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tstrncpy(opts.receive_cmd, optarg, sizeof(opts.receive_cmd));\n\t\t\topts.receive_cmd[sizeof(opts.receive_cmd) - 1] = '\\0';\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tmap = parse_map(optarg);\n\t\t\tif (map >= 0) opts.imap = map;\n\t\t\telse { fprintf(stderr, \"Invalid --imap\\n\"); r = -1; }\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tmap = parse_map(optarg);\n\t\t\tif (map >= 0) opts.omap = map;\n\t\t\telse { fprintf(stderr, \"Invalid --omap\\n\"); r = -1; }\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tmap = parse_map(optarg);\n\t\t\tif (map >= 0) opts.emap = map;\n\t\t\telse { fprintf(stderr, \"Invalid --emap\\n\"); r = -1; }\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\topts.lecho = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\topts.noinit = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\topts.noreset = 1;\n\t\t\tbreak;\n\t\tcase 'l':\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\t\t\topts.nolock = 1;\n#endif\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\topts.escape = optarg[0] & 0x1f;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase 'X':\n\t\t\tcase 'x':\n\t\t\t\topts.flow = FC_XONXOFF;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\tcase 'h':\n\t\t\t\topts.flow = FC_RTSCTS;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\tcase 'n':\n\t\t\t\topts.flow = FC_NONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Invalid --flow: %c\\n\", optarg[0]);\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topts.baud = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase 'e':\n\t\t\t\topts.parity = P_EVEN;\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\topts.parity = P_ODD;\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\topts.parity = P_NONE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Invalid --parity: %c\\n\", optarg[0]);\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tswitch (optarg[0]) {\n\t\t\tcase '5':\n\t\t\t\topts.databits = 5;\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\topts.databits = 6;\n\t\t\t\tbreak;\n\t\t\tcase '7':\n\t\t\t\topts.databits = 7;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\topts.databits = 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Invalid --databits: %c\\n\", optarg[0]);\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tshow_usage(argv[0]);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase '?':\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unrecognized option(s)\\n\");\n\t\t\tr = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif ( r < 0 ) {\n\t\t\tfprintf(stderr, \"Run with '--help'.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t} /* while */\n\n\tif ( (argc - optind) < 1) {\n\t\tfprintf(stderr, \"No port given\\n\");\n\t\tfprintf(stderr, \"Run with '--help'.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tstrncpy(opts.port, argv[optind], sizeof(opts.port) - 1);\n\topts.port[sizeof(opts.port) - 1] = '\\0';\n\n\tprintf(\"picocom v%s\\n\", VERSION_STR);\n\tprintf(\"\\n\");\n\tprintf(\"port is        : %s\\n\", opts.port);\n\tprintf(\"flowcontrol    : %s\\n\", flow_str[opts.flow]);\n\tprintf(\"baudrate is    : %d\\n\", opts.baud);\n\tprintf(\"parity is      : %s\\n\", parity_str[opts.parity]);\n\tprintf(\"databits are   : %d\\n\", opts.databits);\n\tprintf(\"escape is      : C-%c\\n\", 'a' + opts.escape - 1);\n\tprintf(\"local echo is  : %s\\n\", opts.lecho ? \"yes\" : \"no\");\n\tprintf(\"noinit is      : %s\\n\", opts.noinit ? \"yes\" : \"no\");\n\tprintf(\"noreset is     : %s\\n\", opts.noreset ? \"yes\" : \"no\");\n#if defined (UUCP_LOCK_DIR) || defined (USE_FLOCK)\n\tprintf(\"nolock is      : %s\\n\", opts.nolock ? \"yes\" : \"no\");\n#endif\n\tprintf(\"send_cmd is    : %s\\n\", \n\t\t   (opts.send_cmd[0] == '\\0') ? \"disabled\" : opts.send_cmd);\n\tprintf(\"receive_cmd is : %s\\n\", \n\t\t   (opts.receive_cmd[0] == '\\0') ? \"disabled\" : opts.receive_cmd);\n\tprintf(\"imap is        : \"); print_map(opts.imap);\n\tprintf(\"omap is        : \"); print_map(opts.omap);\n\tprintf(\"emap is        : \"); print_map(opts.emap);\n\tprintf(\"\\n\");\n}\n\n/**********************************************************************/\n\n\nint\nmain(int argc, char *argv[])\n{\n\tint r;\n\n\tparse_args(argc, argv);\n\n\testablish_signal_handlers();\n\n\tr = term_lib_init();\n\tif ( r < 0 )\n\t\tfatal(\"term_init failed: %s\", term_strerror(term_errno, errno));\n\n#ifdef UUCP_LOCK_DIR\n\tif ( ! opts.nolock ) uucp_lockname(UUCP_LOCK_DIR, opts.port);\n\tif ( uucp_lock() < 0 )\n\t\tfatal(\"cannot lock %s: %s\", opts.port, strerror(errno));\n#endif\n\n\ttty_fd = open(opts.port, O_RDWR | O_NONBLOCK | O_NOCTTY);\n\tif (tty_fd < 0)\n\t\tfatal(\"cannot open %s: %s\", opts.port, strerror(errno));\n\n#ifdef USE_FLOCK\n\tif ( ! opts.nolock ) {\n\t\tr = flock(tty_fd, LOCK_EX | LOCK_NB);\n\t\tif ( r < 0 )\n\t\t\tfatal(\"cannot lock %s: %s\", opts.port, strerror(errno));\n\t}\n#endif\n\n\tif ( opts.noinit ) {\n\t\tr = term_add(tty_fd);\n\t} else {\n\t\tr = term_set(tty_fd,\n\t\t\t\t\t 1,              /* raw mode. */\n\t\t\t\t\t opts.baud,      /* baud rate. */\n\t\t\t\t\t opts.parity,    /* parity. */\n\t\t\t\t\t opts.databits,  /* data bits. */\n\t\t\t\t\t opts.flow,      /* flow control. */\n\t\t\t\t\t 1,              /* local or modem */\n\t\t\t\t\t !opts.noreset); /* hup-on-close. */\n\t}\n\tif ( r < 0 )\n\t\tfatal(\"failed to add device %s: %s\", \n\t\t\t  opts.port, term_strerror(term_errno, errno));\n\tr = term_apply(tty_fd);\n\tif ( r < 0 )\n\t\tfatal(\"failed to config device %s: %s\", \n\t\t\t  opts.port, term_strerror(term_errno, errno));\n\n\tset_tty_write_sz(term_get_baudrate(tty_fd, NULL));\n\t\n\tr = term_add(STI);\n\tif ( r < 0 )\n\t\tfatal(\"failed to add I/O device: %s\", \n\t\t\t  term_strerror(term_errno, errno));\n\tterm_set_raw(STI);\n\tr = term_apply(STI);\n\tif ( r < 0 )\n\t\tfatal(\"failed to set I/O device to raw mode: %s\",\n\t\t\t  term_strerror(term_errno, errno));\n\n#ifdef LINENOISE\n\tinit_send_receive_history();\n#endif\n\n\tfd_printf(STO, \"Terminal ready\\r\\n\");\n\tloop();\n\n#ifdef LINENOISE\n\tcleanup_send_receive_history();\n#endif\n\n\tfd_printf(STO, \"\\r\\n\");\n\tif ( opts.noreset ) {\n\t\tfd_printf(STO, \"Skipping tty reset...\\r\\n\");\n\t\tterm_erase(tty_fd);\n\t}\n\n\tif ( sig_exit )\n\t\tfd_printf(STO, \"Picocom was killed\\r\\n\");\n\telse\n\t\tfd_printf(STO, \"Thanks for using picocom\\r\\n\");\n\t/* wait a bit for output to drain */\n\tsleep(1);\n\n#ifdef UUCP_LOCK_DIR\n\tuucp_unlock();\n#endif\n\n\treturn EXIT_SUCCESS;\n}\n\n/**********************************************************************/\n\n/*\n * Local Variables:\n * mode:c\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n */\n"], "filenames": ["Makefile", "picocom.c"], "buggy_code_start_loc": [36, 50], "buggy_code_end_loc": [41, 948], "fixing_code_start_loc": [36, 51], "fixing_code_end_loc": [42, 951], "type": "CWE-77", "message": "picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.", "other": {"cve": {"id": "CVE-2015-9059", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-28T00:29:00.187", "lastModified": "2020-06-28T17:15:10.173", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely."}, {"lang": "es", "value": "Picocom anterior a la versi\u00f3n 2.0 presenta una vulnerabilidad de inyecci\u00f3n de comandos en el comando 'enviar y recibir' porque la l\u00ednea de comandos es ejecutada por /bin/sh de forma no segura."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:picocom_project:picocom:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.8", "matchCriteriaId": "09585D7E-0ACC-4071-A883-CFEF99C32A37"}]}]}], "references": [{"url": "https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00030.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1"}}