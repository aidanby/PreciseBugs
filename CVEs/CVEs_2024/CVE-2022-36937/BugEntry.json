{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/base/ssl-socket.h\"\n#include \"hphp/runtime/base/file-util.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/base/req-ptr.h\"\n#include \"hphp/runtime/base/string-util.h\"\n#include \"hphp/runtime/server/server-stats.h\"\n\n#include <folly/String.h>\n#include <folly/portability/Sockets.h>\n#include <folly/portability/SysTime.h>\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\nbool SSLSocketData::closeImpl() {\n  if (m_ssl_active) {\n    SSL_shutdown(m_handle);\n    m_ssl_active = false;\n  }\n  if (m_handle) {\n    SSL_free(m_handle);\n    SSL_CTX_free(m_ctx);\n    m_handle = nullptr;\n    m_ctx = nullptr;\n  }\n  return SocketData::closeImpl();\n}\n\nSSLSocketData::~SSLSocketData() {\n  SSLSocketData::closeImpl();\n}\n\nMutex SSLSocket::s_mutex;\nint SSLSocket::s_ex_data_index = -1;\nint SSLSocket::GetSSLExDataIndex() {\n  if (s_ex_data_index >= 0) {\n    return s_ex_data_index;\n  }\n  Lock lock(s_mutex);\n  if (s_ex_data_index < 0) {\n    s_ex_data_index = SSL_get_ex_new_index(0, (void*)\"PHP stream index\",\n                                           nullptr, nullptr, nullptr);\n    assertx(s_ex_data_index >= 0);\n  }\n  return s_ex_data_index;\n}\n\nconst StaticString\n  s_allow_self_signed(\"allow_self_signed\"),\n  s_verify_depth(\"verify_depth\");\n\nint SSLSocket::verifyCallback(int preverify_ok, X509_STORE_CTX *ctx) {\n  int ret = preverify_ok;\n\n  /* determine the status for the current cert */\n  X509_STORE_CTX_get_current_cert(ctx);\n  int err = X509_STORE_CTX_get_error(ctx);\n  int depth = X509_STORE_CTX_get_error_depth(ctx);\n\n  /* conjure the stream & context to use */\n  SSL *ssl = (SSL*)X509_STORE_CTX_get_ex_data\n    (ctx, SSL_get_ex_data_X509_STORE_CTX_idx());\n  SSLSocket *stream =\n    (SSLSocket*)SSL_get_ex_data(ssl, SSLSocket::GetSSLExDataIndex());\n\n  /* if allow_self_signed is set, make sure that verification succeeds */\n  if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT &&\n      stream->m_context[s_allow_self_signed].toBoolean()) {\n    ret = 1;\n  }\n\n  /* check the depth */\n  Variant vdepth = stream->m_context[s_verify_depth];\n  if (vdepth.toBoolean() && depth > vdepth.toInt64()) {\n    ret = 0;\n    X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_CHAIN_TOO_LONG);\n  }\n\n  return ret;\n}\n\nconst StaticString s_passphrase(\"passphrase\");\n\nint SSLSocket::passwdCallback(char* buf, int num, int /*verify*/, void* data) {\n  /* TODO: could expand this to make a callback into PHP user-space */\n  SSLSocket *stream = (SSLSocket *)data;\n  String passphrase = stream->m_context[s_passphrase].toString();\n  if (!passphrase.empty() && passphrase.size() < num - 1) {\n    memcpy(buf, passphrase.data(), passphrase.size() + 1);\n    return passphrase.size();\n  }\n  return 0;\n}\n\nconst StaticString\n  s_verify_peer(\"verify_peer\"),\n  s_cafile(\"cafile\"),\n  s_capath(\"capath\"),\n  s_ciphers(\"ciphers\"),\n  s_local_cert(\"local_cert\");\n\nSSL *SSLSocket::createSSL(SSL_CTX *ctx) {\n  ERR_clear_error();\n\n  /* look at options in the stream and set appropriate verification flags */\n  if (m_context[s_verify_peer].toBoolean()) {\n    /* turn on verification callback */\n    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verifyCallback);\n\n    /* CA stuff */\n    String cafile = m_context[s_cafile].toString();\n    String capath = m_context[s_capath].toString();\n\n    if (!FileUtil::isValidPath(cafile)) {\n      raise_warning(\"cafile expected to be a path, string given\");\n      return nullptr;\n    } else if (!FileUtil::isValidPath(capath)) {\n      raise_warning(\"capath expected to be a path, string given\");\n      return nullptr;\n    } else if (!cafile.empty() || !capath.empty()) {\n      const char* cafileptr = cafile.empty() ? nullptr : cafile.data();\n      const char* capathptr = capath.empty() ? nullptr : capath.data();\n      if (!SSL_CTX_load_verify_locations(ctx, cafileptr, capathptr)) {\n        raise_warning(\"Unable to set verify locations `%s' `%s'\",\n                      cafile.data(), capath.data());\n        return nullptr;\n      }\n    } else if (m_data->m_client && !SSL_CTX_set_default_verify_paths(ctx)) {\n      raise_warning(\n        \"Unable to set default verify locations and no CA settings specified\");\n      return nullptr;\n    }\n\n    int64_t depth = m_context[s_verify_depth].toInt64();\n    if (depth) {\n      SSL_CTX_set_verify_depth(ctx, depth);\n    }\n  } else {\n    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, nullptr);\n  }\n\n  /* callback for the passphrase (for localcert) */\n  if (!m_context[s_passphrase].toString().empty()) {\n    SSL_CTX_set_default_passwd_cb_userdata(ctx, this);\n    SSL_CTX_set_default_passwd_cb(ctx, passwdCallback);\n  }\n\n  String cipherlist = m_context[s_ciphers].toString();\n  if (cipherlist.empty()) {\n    cipherlist = \"DEFAULT\";\n  }\n  SSL_CTX_set_cipher_list(ctx, cipherlist.data());\n\n  String certfile = m_context[s_local_cert].toString();\n  if (!FileUtil::isValidPath(certfile)) {\n    raise_warning(\"local_cert expected to be a path, string given\");\n    return nullptr;\n  } else if (!certfile.empty()) {\n    String resolved_path_buff = File::TranslatePath(certfile);\n    if (!resolved_path_buff.empty()) {\n      /* a certificate to use for authentication */\n      if (SSL_CTX_use_certificate_chain_file(ctx, resolved_path_buff.data())\n          != 1) {\n        raise_warning(\"Unable to set local cert chain file `%s'; Check \"\n                      \"that your cafile/capath settings include details of \"\n                      \"your certificate and its issuer\", certfile.data());\n        return nullptr;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff.data(),\n                                      SSL_FILETYPE_PEM) != 1) {\n        raise_warning(\"Unable to set private key file `%s'\",\n                      resolved_path_buff.data());\n        return nullptr;\n      }\n\n      SSL *tmpssl = SSL_new(ctx);\n      X509 *cert = SSL_get_certificate(tmpssl);\n      if (cert) {\n        EVP_PKEY *key = X509_get_pubkey(cert);\n        EVP_PKEY_copy_parameters(key, SSL_get_privatekey(tmpssl));\n        EVP_PKEY_free(key);\n      }\n      SSL_free(tmpssl);\n\n      if (!SSL_CTX_check_private_key(ctx)) {\n        raise_warning(\"Private key does not match certificate!\");\n      }\n    }\n  }\n\n  SSL *ssl = SSL_new(ctx);\n  if (ssl) {\n    SSL_set_ex_data(ssl, GetSSLExDataIndex(), this); /* map SSL => stream */\n  }\n  return ssl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// constructors and destructor\n\nSSLSocket::SSLSocket(bool nonblocking /* = true*/)\n: Socket(std::make_shared<SSLSocketData>(nonblocking)),\n  m_data(static_cast<SSLSocketData*>(getSocketData()))\n{}\n\nSSLSocket::SSLSocket(std::shared_ptr<SSLSocketData> data)\n: Socket(data),\n  m_data(static_cast<SSLSocketData*>(getSocketData()))\n{}\n\nStaticString s_ssl(\"ssl\");\n\nSSLSocket::SSLSocket(int sockfd, int type, const req::ptr<StreamContext>& ctx,\n                     const char *address /* = NULL */, int port /* = 0 */,\n                     bool nonblocking /* = true*/)\n: Socket(std::make_shared<SSLSocketData>(port, type, nonblocking),\n        sockfd, type, address, port),\n  m_data(static_cast<SSLSocketData*>(getSocketData()))\n{\n  if (!ctx) {\n    return;\n  }\n  this->setStreamContext(ctx);\n  this->m_context = ctx->getOptions()[s_ssl].toArray();\n}\n\nSSLSocket::~SSLSocket() { }\n\nvoid SSLSocket::sweep() {\n  File::close();\n  File::sweep();\n  m_data = nullptr;\n}\n\nbool SSLSocket::enableCrypto(CryptoMethod method) {\n  if (this->m_data->m_method != CryptoMethod::NoCrypto) {\n    raise_warning(\"SSL/TLS already set-up for this stream\");\n    return false;\n  }\n  this->m_data->m_method = method;\n  return setupCrypto() && enableCrypto();\n}\n\nbool SSLSocket::disableCrypto() {\n  if (!this->m_data->m_ssl_active) {\n    return false;\n  }\n  this->m_data->m_method = CryptoMethod::NoCrypto;\n  SSL_shutdown(this->m_data->m_handle);\n  this->m_data->m_ssl_active = false;\n  return true;\n}\n\nbool SSLSocket::onConnect() {\n  if (this->m_data->m_method == CryptoMethod::NoCrypto) {\n    return true;\n  }\n  return setupCrypto() && enableCrypto();\n}\n\nbool SSLSocket::onAccept() {\n  if (m_data->m_method == CryptoMethod::NoCrypto) {\n    return true;\n  }\n  if (getFd() >= 0 && m_data->m_enable_on_connect) {\n    switch (m_data->m_method) {\n    case CryptoMethod::ClientSSLv23:\n      m_data->m_method = CryptoMethod::ServerSSLv23;\n      break;\n    case CryptoMethod::ClientSSLv2:\n      m_data->m_method = CryptoMethod::ServerSSLv2;\n      break;\n    case CryptoMethod::ClientSSLv3:\n      m_data->m_method = CryptoMethod::ServerSSLv3;\n      break;\n    case CryptoMethod::ClientTLS:\n      m_data->m_method = CryptoMethod::ServerTLS;\n      break;\n    default:\n      assertx(false);\n    }\n\n    if (setupCrypto() && enableCrypto()) {\n      return true;\n    }\n\n    raise_warning(\"Failed to enable crypto\");\n    close();\n  }\n  return false;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nbool SSLSocket::handleError(int64_t nr_bytes, bool is_init) {\n  char esbuf[512];\n  std::string ebuf;\n  unsigned long ecode;\n\n  bool retry = true;\n  int err = SSL_get_error(m_data->m_handle, nr_bytes);\n  switch (err) {\n  case SSL_ERROR_ZERO_RETURN:\n    /* SSL terminated (but socket may still be active) */\n    retry = false;\n    break;\n  case SSL_ERROR_WANT_READ:\n  case SSL_ERROR_WANT_WRITE:\n    /* re-negotiation, or perhaps the SSL layer needs more\n     * packets: retry in next iteration */\n    errno = EAGAIN;\n    retry = (is_init || m_data->m_is_blocked);\n    break;\n  case SSL_ERROR_SYSCALL:\n    if (ERR_peek_error() == 0) {\n      if (nr_bytes == 0) {\n        if (ERR_get_error()) {\n          raise_warning(\"SSL: fatal protocol error\");\n        }\n        SSL_set_shutdown(m_data->m_handle,\n                         SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\n        setEof(true);\n        retry = false;\n      } else {\n        raise_warning(\"SSL: %s\", folly::errnoStr(errno).c_str());\n        retry = false;\n      }\n      break;\n    }\n    /* fall through */\n  default:\n    /* some other error */\n    ecode = ERR_get_error();\n    switch (ERR_GET_REASON(ecode)) {\n    case SSL_R_NO_SHARED_CIPHER:\n      raise_warning(\"SSL_R_NO_SHARED_CIPHER: no suitable shared cipher \"\n                    \"could be used.  This could be because the server is \"\n                    \"missing an SSL certificate (local_cert context \"\n                    \"option)\");\n      retry = false;\n      break;\n\n    default:\n      do {\n        // NULL is automatically added\n        ERR_error_string_n(ecode, esbuf, sizeof(esbuf));\n        if (!ebuf.empty()) {\n          ebuf += '\\n';\n        }\n        ebuf += esbuf;\n      } while ((ecode = ERR_get_error()) != 0);\n\n      raise_warning(\"SSL operation failed with code %d. %s%s\",\n                    err, !ebuf.empty() ? \"OpenSSL Error messages:\\n\" : \"\",\n                    !ebuf.empty() ? ebuf.c_str() : \"\");\n    }\n\n    retry = false;\n    errno = 0;\n  }\n\n  return retry;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nreq::ptr<SSLSocket> SSLSocket::Create(\n  int fd, int domain, const HostURL &hosturl, double timeout,\n  const req::ptr<StreamContext>& ctx,\n  bool nonblocking\n) {\n  CryptoMethod method;\n  const std::string scheme = hosturl.getScheme();\n\n  if (scheme == \"ssl\") {\n    method = CryptoMethod::ClientSSLv23;\n  } else if (scheme == \"sslv2\") {\n    method = CryptoMethod::ClientSSLv2;\n  } else if (scheme == \"sslv3\") {\n    method = CryptoMethod::ClientSSLv3;\n  } else if (scheme == \"tls\") {\n    method = CryptoMethod::ClientTLS;\n  } else if (\n    scheme == \"tcp\"\n    || (scheme.empty() && (domain == AF_INET || domain == AF_INET6))\n  ) {\n    method = CryptoMethod::NoCrypto;\n  } else {\n    return nullptr;\n  }\n\n  return Create(fd, domain, method, hosturl.getHost(), hosturl.getPort(),\n                timeout, ctx, nonblocking);\n}\n\nreq::ptr<SSLSocket> SSLSocket::Create(\n  int fd, int domain, CryptoMethod method, std::string address, int port,\n  double timeout, const req::ptr<StreamContext>& ctx,\n  bool nonblocking\n) {\n  auto sock = req::make<SSLSocket>(\n    fd, domain, ctx, address.c_str(), port, nonblocking);\n\n  sock->m_data->m_method = method;\n  sock->m_data->m_connect_timeout = timeout;\n  sock->m_data->m_enable_on_connect = true;\n\n  return sock;\n}\n\nbool SSLSocket::waitForData() {\n  if (m_data->m_ssl_active && SSL_pending(m_data->m_handle)) {\n    return true;\n  }\n\n  return Socket::waitForData();\n}\n\nint64_t SSLSocket::readImpl(char *buffer, int64_t length) {\n  int64_t nr_bytes = 0;\n  if (m_data->m_ssl_active) {\n    IOStatusHelper io(\"sslsocket::recv\", getAddress().c_str(), getPort());\n\n    bool retry = true;\n    do {\n      if (m_data->m_is_blocked) {\n        waitForData();\n        if (timedOut()) {\n          break;\n        }\n        // could get here and we only have parts of an SSL packet\n      }\n      nr_bytes = SSL_read(m_data->m_handle, buffer, length);\n      if (nr_bytes > 0) break; /* we got the data */\n      retry = handleError(nr_bytes, false);\n      setEof(!retry && errno != EAGAIN && !SSL_pending(m_data->m_handle));\n    } while (retry);\n  } else {\n    nr_bytes = Socket::readImpl(buffer, length);\n  }\n  return nr_bytes < 0 ? 0 : nr_bytes;\n}\n\nint64_t SSLSocket::writeImpl(const char *buffer, int64_t length) {\n  int didwrite;\n  if (m_data->m_ssl_active) {\n    IOStatusHelper io(\"sslsocket::send\", getAddress().c_str(), getPort());\n\n    bool retry = true;\n    do {\n      didwrite = SSL_write(m_data->m_handle, buffer, length);\n      if (didwrite > 0) break;\n      retry = handleError(didwrite, false);\n    } while (retry);\n  } else {\n    didwrite = Socket::writeImpl(buffer, length);\n  }\n  return didwrite < 0 ? 0 : didwrite;\n}\n\nbool SSLSocket::setupCrypto(SSLSocket *session /* = NULL */) {\n  if (m_data->m_handle) {\n    raise_warning(\"SSL/TLS already set-up for this stream\");\n    return false;\n  }\n\n  if (!m_context.exists(s_verify_peer)) {\n    m_context.set(s_verify_peer, true);\n  }\n\n  /* need to do slightly different things, based on client/server method,\n   * so lets remember which method was selected */\n#if OPENSSL_VERSION_NUMBER < 0x00909000L\n  SSL_METHOD *smethod;\n#else\n  const SSL_METHOD *smethod;\n#endif\n  switch (m_data->m_method) {\n  case CryptoMethod::ClientSSLv23:\n    m_data->m_client = true;\n    smethod = SSLv23_client_method();\n    break;\n  case CryptoMethod::ClientTLS:\n    m_data->m_client = true;\n    smethod = TLSv1_client_method();\n    break;\n  case CryptoMethod::ServerSSLv23:\n    m_data->m_client = false;\n    smethod = SSLv23_server_method();\n    break;\n\n#ifndef OPENSSL_NO_SSL3\n  case CryptoMethod::ClientSSLv3:\n    m_data->m_client = true;\n    smethod = SSLv3_client_method();\n    break;\n  case CryptoMethod::ServerSSLv3:\n    m_data->m_client = false;\n    smethod = SSLv3_server_method();\n    break;\n#else\n  case CryptoMethod::ClientSSLv3:\n  case CryptoMethod::ServerSSLv3:\n    raise_warning(\"OpenSSL library does not support SSL3 protocol\");\n    return false;\n#endif\n\n  /* SSLv2 protocol might be disabled in the OpenSSL library */\n#ifndef OPENSSL_NO_SSL2\n  case CryptoMethod::ClientSSLv2:\n    m_data->m_client = true;\n    smethod = SSLv2_client_method();\n    break;\n  case CryptoMethod::ServerSSLv2:\n    m_data->m_client = false;\n    smethod = SSLv2_server_method();\n    break;\n#else\n  case CryptoMethod::ClientSSLv2:\n  case CryptoMethod::ServerSSLv2:\n    raise_warning(\"OpenSSL library does not support SSL2 protocol\");\n    return false;\n  break;\n#endif\n\n  case CryptoMethod::ServerTLS:\n    m_data->m_client = false;\n    smethod = TLSv1_server_method();\n    break;\n  default:\n    return false;\n  }\n\n  SSL_CTX *ctx = SSL_CTX_new(smethod);\n  if (ctx == nullptr) {\n    raise_warning(\"failed to create an SSL context\");\n    return false;\n  }\n\n  SSL_CTX_set_options(ctx, SSL_OP_ALL);\n  m_data->m_handle = createSSL(ctx);\n  if (m_data->m_handle == nullptr) {\n    raise_warning(\"failed to create an SSL handle\");\n    SSL_CTX_free(ctx);\n    return false;\n  }\n\n  m_data->m_ctx = ctx;\n\n  if (!SSL_set_fd(m_data->m_handle, getFd())) {\n    handleError(0, true);\n  }\n  if (session) {\n    SSL_copy_session_id(m_data->m_handle, session->m_data->m_handle);\n  }\n  return true;\n}\n\nconst StaticString s_CN_match(\"CN_match\");\n\nbool SSLSocket::applyVerificationPolicy(X509 *peer) {\n  /* verification is turned off */\n  if (!m_context[s_verify_peer].toBoolean()) {\n    return true;\n  }\n\n  if (peer == nullptr) {\n    raise_warning(\"Could not get peer certificate\");\n    return false;\n  }\n\n  int err = SSL_get_verify_result(m_data->m_handle);\n  switch (err) {\n  case X509_V_OK:\n    /* fine */\n    break;\n  case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n    if (m_context[s_allow_self_signed].toBoolean()) {\n      /* allowed */\n      break;\n    }\n    /* not allowed, so fall through */\n  default:\n    raise_warning(\"Could not verify peer: code:%d %s\", err,\n                  X509_verify_cert_error_string(err));\n    return false;\n  }\n\n  /* if the cert passed the usual checks, apply our own local policies now */\n\n  /* Does the common name match ? (used primarily for https://) */\n  String cnmatch = m_context[s_CN_match].toString();\n  if (!cnmatch.empty()) {\n    X509_NAME *name = X509_get_subject_name(peer);\n    char buf[1024];\n    int name_len = X509_NAME_get_text_by_NID(name, NID_commonName, buf,\n                                             sizeof(buf));\n\n    if (name_len < 0) {\n      raise_warning(\"Unable to locate peer certificate CN\");\n      return false;\n    } else if (name_len != (int)strlen(buf)) {\n      raise_warning(\"Peer certificate CN=`%.*s' is malformed\", name_len, buf);\n      return false;\n    } else if (name_len == sizeof(buf)) {\n      raise_warning(\"Peer certificate CN=`%.*s' is too long to verify\",\n                    name_len, buf);\n      return false;\n    }\n\n    bool match = (strcmp(cnmatch.c_str(), buf) == 0);\n    if (!match && strlen(buf) > 3 && buf[0] == '*' && buf[1] == '.') {\n      /* Try wildcard */\n      if (strchr(buf+2, '.')) {\n        const char* cnmatch_str = cnmatch.c_str();\n        const char *tmp = strstr(cnmatch_str, buf+1);\n        match = tmp && strcmp(tmp, buf+2) && tmp == strchr(cnmatch_str, '.');\n      }\n    }\n\n    if (!match) {\n      /* didn't match */\n      raise_warning(\"Peer certificate CN=`%.*s' did not match expected CN=`%s'\",\n                    name_len, buf, cnmatch.c_str());\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst StaticString\n  s_capture_peer_cert(\"capture_peer_cert\"),\n  s_peer_certificate(\"peer_certificate\"),\n  s_capture_peer_cert_chain(\"capture_peer_cert_chain\"),\n  s_peer_certificate_chain(\"peer_certificate_chain\");\n\nbool SSLSocket::enableCrypto(bool activate /* = true */) {\n  if (activate && !m_data->m_ssl_active) {\n    double timeout = m_data->m_connect_timeout;\n    bool blocked = m_data->m_is_blocked;\n    if (!m_data->m_state_set) {\n      if (m_data->m_client) {\n        SSL_set_connect_state(m_data->m_handle);\n      } else {\n        SSL_set_accept_state(m_data->m_handle);\n      }\n      m_data->m_state_set = true;\n    }\n\n    if (m_data->m_client && setBlocking(false)) {\n      m_data->m_is_blocked = false;\n    }\n\n    int n;\n    bool retry = true;\n    do {\n      if (m_data->m_client) {\n        struct timeval tvs, tve;\n        struct timezone tz;\n\n        gettimeofday(&tvs, &tz);\n        n = SSL_connect(m_data->m_handle);\n        gettimeofday(&tve, &tz);\n\n        timeout -= (tve.tv_sec + (double) tve.tv_usec / 1000000) -\n          (tvs.tv_sec + (double) tvs.tv_usec / 1000000);\n        if (timeout < 0) {\n          raise_warning(\"SSL: connection timeout\");\n          return false;\n        }\n      } else {\n        n = SSL_accept(m_data->m_handle);\n      }\n\n      if (n <= 0) {\n        retry = handleError(n, true);\n      } else {\n        break;\n      }\n    } while (retry);\n\n    if (m_data->m_client &&\n        m_data->m_is_blocked != blocked &&\n        setBlocking(blocked)) {\n      m_data->m_is_blocked = blocked;\n    }\n\n    if (n == 1) {\n      X509 *peer_cert = SSL_get_peer_certificate(m_data->m_handle);\n      if (!applyVerificationPolicy(peer_cert)) {\n        SSL_shutdown(m_data->m_handle);\n      } else {\n        m_data->m_ssl_active = true;\n\n        /* allow the script to capture the peer cert\n         * and/or the certificate chain */\n        if (m_context[s_capture_peer_cert].toBoolean()) {\n          m_context.set(s_peer_certificate,\n                        Variant(req::make<Certificate>(peer_cert)));\n          peer_cert = nullptr;\n        }\n\n        if (m_context[s_capture_peer_cert_chain].toBoolean()) {\n          Array arr;\n          STACK_OF(X509) *chain = SSL_get_peer_cert_chain(m_data->m_handle);\n          if (chain) {\n            for (int i = 0; i < sk_X509_num(chain); i++) {\n              X509 *mycert = X509_dup(sk_X509_value(chain, i));\n              arr.append(Variant(req::make<Certificate>(mycert)));\n            }\n          }\n          m_context.set(s_peer_certificate_chain, arr);\n        }\n      }\n\n      if (peer_cert) {\n        X509_free(peer_cert);\n      }\n    } else  {\n      n = errno == EAGAIN ? 0 : -1;\n    }\n\n    return n >= 0;\n\n  } else if (!activate && m_data->m_ssl_active) {\n    /* deactivate - common for server/client */\n    SSL_shutdown(m_data->m_handle);\n    m_data->m_ssl_active = false;\n  }\n  return true;\n}\n\nbool SSLSocket::checkLiveness() {\n  if (getFd() == -1) {\n    return false;\n  }\n\n  pollfd p;\n  p.fd = getFd();\n  p.events = POLLIN | POLLERR | POLLHUP | POLLPRI;\n  p.revents = 0;\n  if (poll(&p, 1, 0) > 0 && p.revents > 0) {\n    char buf;\n    if (m_data->m_ssl_active) {\n      while (true) {\n        int n = SSL_peek(m_data->m_handle, &buf, sizeof(buf));\n        if (n <= 0) {\n          int err = SSL_get_error(m_data->m_handle, n);\n          if (err == SSL_ERROR_SYSCALL) {\n            return errno == EAGAIN;\n          }\n\n          if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {\n            /* re-negotiate */\n            continue;\n          }\n\n          /* any other problem is a fatal error */\n          return false;\n        }\n        /* either peek succeeded or there was an error; we\n         * have set the alive flag appropriately */\n        break;\n      }\n    } else if (0 == recv(getFd(), &buf, sizeof(buf), MSG_PEEK) &&\n               errno != EAGAIN) {\n      return false;\n    }\n  }\n  return true;\n}\n\nSSLSocket::CryptoMethod SSLSocket::getCryptoMethod() {\n  return m_data->m_method;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Certificate\n\nIMPLEMENT_RESOURCE_ALLOCATION(Certificate)\n\nBIO *Certificate::ReadData(const Variant& var, bool *file /* = NULL */) {\n  if (var.isString() || var.isObject()) {\n    String svar = var.toString();\n    if (StringUtil::IsFileUrl(svar)) {\n      String decoded = StringUtil::DecodeFileUrl(svar);\n      if (decoded.empty()) {\n        raise_warning(\"invalid file URL, %s\", svar.data());\n        return nullptr;\n      }\n      if (file) *file = true;\n      BIO *ret = BIO_new_file(decoded.data(), \"r\");\n      if (ret == nullptr) {\n        raise_warning(\"error opening the file, %s\", decoded.data());\n      }\n      return ret;\n    }\n\n    if (file) *file = false;\n    return BIO_new_mem_buf((char*)svar.data(), svar.size());\n  }\n  return nullptr;\n}\n\n\nreq::ptr<Certificate> Certificate::Get(const Variant& var) {\n  if (var.isResource()) {\n    return dyn_cast_or_null<Certificate>(var);\n  }\n  if (var.isString() || var.isObject()) {\n    bool file;\n    BIO *in = ReadData(var, &file);\n    if (in == nullptr) return nullptr;\n\n    X509 *cert;\n    /*\n    if (file) {\n      cert = PEM_read_bio_X509(in, NULL, NULL, NULL);\n    } else {\n      cert = (X509 *)PEM_ASN1_read_bio\n        ((char *(*)())d2i_X509, PEM_STRING_X509, in, NULL, NULL, NULL);\n    }\n    */\n    cert = PEM_read_bio_X509(in, nullptr, nullptr, nullptr);\n    BIO_free(in);\n    if (cert) {\n      return req::make<Certificate>(cert);\n    }\n  }\n  return nullptr;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/base/ssl-socket.h\"\n#include \"hphp/runtime/base/file-util.h\"\n#include \"hphp/runtime/base/runtime-error.h\"\n#include \"hphp/runtime/base/req-ptr.h\"\n#include \"hphp/runtime/base/string-util.h\"\n#include \"hphp/runtime/server/server-stats.h\"\n\n#include <folly/String.h>\n#include <folly/portability/Sockets.h>\n#include <folly/portability/SysTime.h>\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\nbool SSLSocketData::closeImpl() {\n  if (m_ssl_active) {\n    SSL_shutdown(m_handle);\n    m_ssl_active = false;\n  }\n  if (m_handle) {\n    SSL_free(m_handle);\n    SSL_CTX_free(m_ctx);\n    m_handle = nullptr;\n    m_ctx = nullptr;\n  }\n  return SocketData::closeImpl();\n}\n\nSSLSocketData::~SSLSocketData() {\n  SSLSocketData::closeImpl();\n}\n\nMutex SSLSocket::s_mutex;\nint SSLSocket::s_ex_data_index = -1;\nint SSLSocket::GetSSLExDataIndex() {\n  if (s_ex_data_index >= 0) {\n    return s_ex_data_index;\n  }\n  Lock lock(s_mutex);\n  if (s_ex_data_index < 0) {\n    s_ex_data_index = SSL_get_ex_new_index(0, (void*)\"PHP stream index\",\n                                           nullptr, nullptr, nullptr);\n    assertx(s_ex_data_index >= 0);\n  }\n  return s_ex_data_index;\n}\n\nconst StaticString\n  s_allow_self_signed(\"allow_self_signed\"),\n  s_verify_depth(\"verify_depth\");\n\nint SSLSocket::verifyCallback(int preverify_ok, X509_STORE_CTX *ctx) {\n  int ret = preverify_ok;\n\n  /* determine the status for the current cert */\n  X509_STORE_CTX_get_current_cert(ctx);\n  int err = X509_STORE_CTX_get_error(ctx);\n  int depth = X509_STORE_CTX_get_error_depth(ctx);\n\n  /* conjure the stream & context to use */\n  SSL *ssl = (SSL*)X509_STORE_CTX_get_ex_data\n    (ctx, SSL_get_ex_data_X509_STORE_CTX_idx());\n  SSLSocket *stream =\n    (SSLSocket*)SSL_get_ex_data(ssl, SSLSocket::GetSSLExDataIndex());\n\n  /* if allow_self_signed is set, make sure that verification succeeds */\n  if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT &&\n      stream->m_context[s_allow_self_signed].toBoolean()) {\n    ret = 1;\n  }\n\n  /* check the depth */\n  Variant vdepth = stream->m_context[s_verify_depth];\n  if (vdepth.toBoolean() && depth > vdepth.toInt64()) {\n    ret = 0;\n    X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_CHAIN_TOO_LONG);\n  }\n\n  return ret;\n}\n\nconst StaticString s_passphrase(\"passphrase\");\n\nint SSLSocket::passwdCallback(char* buf, int num, int /*verify*/, void* data) {\n  /* TODO: could expand this to make a callback into PHP user-space */\n  SSLSocket *stream = (SSLSocket *)data;\n  String passphrase = stream->m_context[s_passphrase].toString();\n  if (!passphrase.empty() && passphrase.size() < num - 1) {\n    memcpy(buf, passphrase.data(), passphrase.size() + 1);\n    return passphrase.size();\n  }\n  return 0;\n}\n\nconst StaticString\n  s_verify_peer(\"verify_peer\"),\n  s_cafile(\"cafile\"),\n  s_capath(\"capath\"),\n  s_ciphers(\"ciphers\"),\n  s_local_cert(\"local_cert\");\n\nSSL *SSLSocket::createSSL(SSL_CTX *ctx) {\n  ERR_clear_error();\n\n  /* look at options in the stream and set appropriate verification flags */\n  if (m_context[s_verify_peer].toBoolean()) {\n    /* turn on verification callback */\n    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verifyCallback);\n\n    /* CA stuff */\n    String cafile = m_context[s_cafile].toString();\n    String capath = m_context[s_capath].toString();\n\n    if (!FileUtil::isValidPath(cafile)) {\n      raise_warning(\"cafile expected to be a path, string given\");\n      return nullptr;\n    } else if (!FileUtil::isValidPath(capath)) {\n      raise_warning(\"capath expected to be a path, string given\");\n      return nullptr;\n    } else if (!cafile.empty() || !capath.empty()) {\n      const char* cafileptr = cafile.empty() ? nullptr : cafile.data();\n      const char* capathptr = capath.empty() ? nullptr : capath.data();\n      if (!SSL_CTX_load_verify_locations(ctx, cafileptr, capathptr)) {\n        raise_warning(\"Unable to set verify locations `%s' `%s'\",\n                      cafile.data(), capath.data());\n        return nullptr;\n      }\n    } else if (m_data->m_client && !SSL_CTX_set_default_verify_paths(ctx)) {\n      raise_warning(\n        \"Unable to set default verify locations and no CA settings specified\");\n      return nullptr;\n    }\n\n    int64_t depth = m_context[s_verify_depth].toInt64();\n    if (depth) {\n      SSL_CTX_set_verify_depth(ctx, depth);\n    }\n  } else {\n    SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, nullptr);\n  }\n\n  /* callback for the passphrase (for localcert) */\n  if (!m_context[s_passphrase].toString().empty()) {\n    SSL_CTX_set_default_passwd_cb_userdata(ctx, this);\n    SSL_CTX_set_default_passwd_cb(ctx, passwdCallback);\n  }\n\n  String cipherlist = m_context[s_ciphers].toString();\n  if (cipherlist.empty()) {\n    cipherlist = \"DEFAULT\";\n  }\n  SSL_CTX_set_cipher_list(ctx, cipherlist.data());\n\n  String certfile = m_context[s_local_cert].toString();\n  if (!FileUtil::isValidPath(certfile)) {\n    raise_warning(\"local_cert expected to be a path, string given\");\n    return nullptr;\n  } else if (!certfile.empty()) {\n    String resolved_path_buff = File::TranslatePath(certfile);\n    if (!resolved_path_buff.empty()) {\n      /* a certificate to use for authentication */\n      if (SSL_CTX_use_certificate_chain_file(ctx, resolved_path_buff.data())\n          != 1) {\n        raise_warning(\"Unable to set local cert chain file `%s'; Check \"\n                      \"that your cafile/capath settings include details of \"\n                      \"your certificate and its issuer\", certfile.data());\n        return nullptr;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff.data(),\n                                      SSL_FILETYPE_PEM) != 1) {\n        raise_warning(\"Unable to set private key file `%s'\",\n                      resolved_path_buff.data());\n        return nullptr;\n      }\n\n      SSL *tmpssl = SSL_new(ctx);\n      X509 *cert = SSL_get_certificate(tmpssl);\n      if (cert) {\n        EVP_PKEY *key = X509_get_pubkey(cert);\n        EVP_PKEY_copy_parameters(key, SSL_get_privatekey(tmpssl));\n        EVP_PKEY_free(key);\n      }\n      SSL_free(tmpssl);\n\n      if (!SSL_CTX_check_private_key(ctx)) {\n        raise_warning(\"Private key does not match certificate!\");\n      }\n    }\n  }\n\n  SSL *ssl = SSL_new(ctx);\n  if (ssl) {\n    SSL_set_ex_data(ssl, GetSSLExDataIndex(), this); /* map SSL => stream */\n  }\n  return ssl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// constructors and destructor\n\nSSLSocket::SSLSocket(bool nonblocking /* = true*/)\n: Socket(std::make_shared<SSLSocketData>(nonblocking)),\n  m_data(static_cast<SSLSocketData*>(getSocketData()))\n{}\n\nSSLSocket::SSLSocket(std::shared_ptr<SSLSocketData> data)\n: Socket(data),\n  m_data(static_cast<SSLSocketData*>(getSocketData()))\n{}\n\nStaticString s_ssl(\"ssl\");\n\nSSLSocket::SSLSocket(int sockfd, int type, const req::ptr<StreamContext>& ctx,\n                     const char *address /* = NULL */, int port /* = 0 */,\n                     bool nonblocking /* = true*/)\n: Socket(std::make_shared<SSLSocketData>(port, type, nonblocking),\n        sockfd, type, address, port),\n  m_data(static_cast<SSLSocketData*>(getSocketData()))\n{\n  if (!ctx) {\n    return;\n  }\n  this->setStreamContext(ctx);\n  this->m_context = ctx->getOptions()[s_ssl].toArray();\n}\n\nSSLSocket::~SSLSocket() { }\n\nvoid SSLSocket::sweep() {\n  File::close();\n  File::sweep();\n  m_data = nullptr;\n}\n\nbool SSLSocket::enableCrypto(CryptoMethod method) {\n  if (this->m_data->m_method != CryptoMethod::NoCrypto) {\n    raise_warning(\"SSL/TLS already set-up for this stream\");\n    return false;\n  }\n  this->m_data->m_method = method;\n  return setupCrypto() && enableCrypto();\n}\n\nbool SSLSocket::disableCrypto() {\n  if (!this->m_data->m_ssl_active) {\n    return false;\n  }\n  this->m_data->m_method = CryptoMethod::NoCrypto;\n  SSL_shutdown(this->m_data->m_handle);\n  this->m_data->m_ssl_active = false;\n  return true;\n}\n\nbool SSLSocket::onConnect() {\n  if (this->m_data->m_method == CryptoMethod::NoCrypto) {\n    return true;\n  }\n  return setupCrypto() && enableCrypto();\n}\n\nbool SSLSocket::onAccept() {\n  if (m_data->m_method == CryptoMethod::NoCrypto) {\n    return true;\n  }\n  if (getFd() >= 0 && m_data->m_enable_on_connect) {\n    switch (m_data->m_method) {\n    case CryptoMethod::ClientSSLv23:\n      m_data->m_method = CryptoMethod::ServerSSLv23;\n      break;\n    case CryptoMethod::ClientSSLv2:\n      m_data->m_method = CryptoMethod::ServerSSLv2;\n      break;\n    case CryptoMethod::ClientSSLv3:\n      m_data->m_method = CryptoMethod::ServerSSLv3;\n      break;\n    case CryptoMethod::ClientTLS:\n      m_data->m_method = CryptoMethod::ServerTLS;\n      break;\n    default:\n      assertx(false);\n    }\n\n    if (setupCrypto() && enableCrypto()) {\n      return true;\n    }\n\n    raise_warning(\"Failed to enable crypto\");\n    close();\n  }\n  return false;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nbool SSLSocket::handleError(int64_t nr_bytes, bool is_init) {\n  char esbuf[512];\n  std::string ebuf;\n  unsigned long ecode;\n\n  bool retry = true;\n  int err = SSL_get_error(m_data->m_handle, nr_bytes);\n  switch (err) {\n  case SSL_ERROR_ZERO_RETURN:\n    /* SSL terminated (but socket may still be active) */\n    retry = false;\n    break;\n  case SSL_ERROR_WANT_READ:\n  case SSL_ERROR_WANT_WRITE:\n    /* re-negotiation, or perhaps the SSL layer needs more\n     * packets: retry in next iteration */\n    errno = EAGAIN;\n    retry = (is_init || m_data->m_is_blocked);\n    break;\n  case SSL_ERROR_SYSCALL:\n    if (ERR_peek_error() == 0) {\n      if (nr_bytes == 0) {\n        if (ERR_get_error()) {\n          raise_warning(\"SSL: fatal protocol error\");\n        }\n        SSL_set_shutdown(m_data->m_handle,\n                         SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\n        setEof(true);\n        retry = false;\n      } else {\n        raise_warning(\"SSL: %s\", folly::errnoStr(errno).c_str());\n        retry = false;\n      }\n      break;\n    }\n    /* fall through */\n  default:\n    /* some other error */\n    ecode = ERR_get_error();\n    switch (ERR_GET_REASON(ecode)) {\n    case SSL_R_NO_SHARED_CIPHER:\n      raise_warning(\"SSL_R_NO_SHARED_CIPHER: no suitable shared cipher \"\n                    \"could be used.  This could be because the server is \"\n                    \"missing an SSL certificate (local_cert context \"\n                    \"option)\");\n      retry = false;\n      break;\n\n    default:\n      do {\n        // NULL is automatically added\n        ERR_error_string_n(ecode, esbuf, sizeof(esbuf));\n        if (!ebuf.empty()) {\n          ebuf += '\\n';\n        }\n        ebuf += esbuf;\n      } while ((ecode = ERR_get_error()) != 0);\n\n      raise_warning(\"SSL operation failed with code %d. %s%s\",\n                    err, !ebuf.empty() ? \"OpenSSL Error messages:\\n\" : \"\",\n                    !ebuf.empty() ? ebuf.c_str() : \"\");\n    }\n\n    retry = false;\n    errno = 0;\n  }\n\n  return retry;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nreq::ptr<SSLSocket> SSLSocket::Create(\n  int fd, int domain, const HostURL &hosturl, double timeout,\n  const req::ptr<StreamContext>& ctx,\n  bool nonblocking\n) {\n  CryptoMethod method;\n  const std::string scheme = hosturl.getScheme();\n\n  if (scheme == \"ssl\") {\n    method = CryptoMethod::ClientSSLv23;\n  } else if (scheme == \"sslv2\") {\n    method = CryptoMethod::ClientSSLv2;\n  } else if (scheme == \"sslv3\") {\n    method = CryptoMethod::ClientSSLv3;\n  } else if (scheme == \"tls\") {\n    method = CryptoMethod::ClientTLS;\n  } else if (\n    scheme == \"tcp\"\n    || (scheme.empty() && (domain == AF_INET || domain == AF_INET6))\n  ) {\n    method = CryptoMethod::NoCrypto;\n  } else {\n    return nullptr;\n  }\n\n  return Create(fd, domain, method, hosturl.getHost(), hosturl.getPort(),\n                timeout, ctx, nonblocking);\n}\n\nreq::ptr<SSLSocket> SSLSocket::Create(\n  int fd, int domain, CryptoMethod method, std::string address, int port,\n  double timeout, const req::ptr<StreamContext>& ctx,\n  bool nonblocking\n) {\n  auto sock = req::make<SSLSocket>(\n    fd, domain, ctx, address.c_str(), port, nonblocking);\n\n  sock->m_data->m_method = method;\n  sock->m_data->m_connect_timeout = timeout;\n  sock->m_data->m_enable_on_connect = true;\n\n  return sock;\n}\n\nbool SSLSocket::waitForData() {\n  if (m_data->m_ssl_active && SSL_pending(m_data->m_handle)) {\n    return true;\n  }\n\n  return Socket::waitForData();\n}\n\nint64_t SSLSocket::readImpl(char *buffer, int64_t length) {\n  int64_t nr_bytes = 0;\n  if (m_data->m_ssl_active) {\n    IOStatusHelper io(\"sslsocket::recv\", getAddress().c_str(), getPort());\n\n    bool retry = true;\n    do {\n      if (m_data->m_is_blocked) {\n        waitForData();\n        if (timedOut()) {\n          break;\n        }\n        // could get here and we only have parts of an SSL packet\n      }\n      nr_bytes = SSL_read(m_data->m_handle, buffer, length);\n      if (nr_bytes > 0) break; /* we got the data */\n      retry = handleError(nr_bytes, false);\n      setEof(!retry && errno != EAGAIN && !SSL_pending(m_data->m_handle));\n    } while (retry);\n  } else {\n    nr_bytes = Socket::readImpl(buffer, length);\n  }\n  return nr_bytes < 0 ? 0 : nr_bytes;\n}\n\nint64_t SSLSocket::writeImpl(const char *buffer, int64_t length) {\n  int didwrite;\n  if (m_data->m_ssl_active) {\n    IOStatusHelper io(\"sslsocket::send\", getAddress().c_str(), getPort());\n\n    bool retry = true;\n    do {\n      didwrite = SSL_write(m_data->m_handle, buffer, length);\n      if (didwrite > 0) break;\n      retry = handleError(didwrite, false);\n    } while (retry);\n  } else {\n    didwrite = Socket::writeImpl(buffer, length);\n  }\n  return didwrite < 0 ? 0 : didwrite;\n}\n\nbool SSLSocket::setupCrypto(SSLSocket *session /* = NULL */) {\n  if (m_data->m_handle) {\n    raise_warning(\"SSL/TLS already set-up for this stream\");\n    return false;\n  }\n\n  if (!m_context.exists(s_verify_peer)) {\n    m_context.set(s_verify_peer, true);\n  }\n\n  /* need to do slightly different things, based on client/server method,\n   * so lets remember which method was selected */\n#if OPENSSL_VERSION_NUMBER < 0x00909000L\n  SSL_METHOD *smethod;\n#else\n  const SSL_METHOD *smethod;\n#endif\n  switch (m_data->m_method) {\n  case CryptoMethod::ClientSSLv23:\n    m_data->m_client = true;\n    smethod = SSLv23_client_method();\n    break;\n  case CryptoMethod::ClientTLS:\n    m_data->m_client = true;\n    smethod = TLS_client_method();\n    break;\n  case CryptoMethod::ServerSSLv23:\n    m_data->m_client = false;\n    smethod = SSLv23_server_method();\n    break;\n\n#ifndef OPENSSL_NO_SSL3\n  case CryptoMethod::ClientSSLv3:\n    m_data->m_client = true;\n    smethod = SSLv3_client_method();\n    break;\n  case CryptoMethod::ServerSSLv3:\n    m_data->m_client = false;\n    smethod = SSLv3_server_method();\n    break;\n#else\n  case CryptoMethod::ClientSSLv3:\n  case CryptoMethod::ServerSSLv3:\n    raise_warning(\"OpenSSL library does not support SSL3 protocol\");\n    return false;\n#endif\n\n  /* SSLv2 protocol might be disabled in the OpenSSL library */\n#ifndef OPENSSL_NO_SSL2\n  case CryptoMethod::ClientSSLv2:\n    m_data->m_client = true;\n    smethod = SSLv2_client_method();\n    break;\n  case CryptoMethod::ServerSSLv2:\n    m_data->m_client = false;\n    smethod = SSLv2_server_method();\n    break;\n#else\n  case CryptoMethod::ClientSSLv2:\n  case CryptoMethod::ServerSSLv2:\n    raise_warning(\"OpenSSL library does not support SSL2 protocol\");\n    return false;\n  break;\n#endif\n\n  case CryptoMethod::ServerTLS:\n    m_data->m_client = false;\n    smethod = TLS_server_method();\n    break;\n  default:\n    return false;\n  }\n\n  SSL_CTX *ctx = SSL_CTX_new(smethod);\n  if (ctx == nullptr) {\n    raise_warning(\"failed to create an SSL context\");\n    return false;\n  }\n\n  SSL_CTX_set_options(ctx, SSL_OP_ALL);\n  m_data->m_handle = createSSL(ctx);\n  if (m_data->m_handle == nullptr) {\n    raise_warning(\"failed to create an SSL handle\");\n    SSL_CTX_free(ctx);\n    return false;\n  }\n\n  m_data->m_ctx = ctx;\n\n  if (!SSL_set_fd(m_data->m_handle, getFd())) {\n    handleError(0, true);\n  }\n  if (session) {\n    SSL_copy_session_id(m_data->m_handle, session->m_data->m_handle);\n  }\n  return true;\n}\n\nconst StaticString s_CN_match(\"CN_match\");\n\nbool SSLSocket::applyVerificationPolicy(X509 *peer) {\n  /* verification is turned off */\n  if (!m_context[s_verify_peer].toBoolean()) {\n    return true;\n  }\n\n  if (peer == nullptr) {\n    raise_warning(\"Could not get peer certificate\");\n    return false;\n  }\n\n  int err = SSL_get_verify_result(m_data->m_handle);\n  switch (err) {\n  case X509_V_OK:\n    /* fine */\n    break;\n  case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n    if (m_context[s_allow_self_signed].toBoolean()) {\n      /* allowed */\n      break;\n    }\n    /* not allowed, so fall through */\n  default:\n    raise_warning(\"Could not verify peer: code:%d %s\", err,\n                  X509_verify_cert_error_string(err));\n    return false;\n  }\n\n  /* if the cert passed the usual checks, apply our own local policies now */\n\n  /* Does the common name match ? (used primarily for https://) */\n  String cnmatch = m_context[s_CN_match].toString();\n  if (!cnmatch.empty()) {\n    X509_NAME *name = X509_get_subject_name(peer);\n    char buf[1024];\n    int name_len = X509_NAME_get_text_by_NID(name, NID_commonName, buf,\n                                             sizeof(buf));\n\n    if (name_len < 0) {\n      raise_warning(\"Unable to locate peer certificate CN\");\n      return false;\n    } else if (name_len != (int)strlen(buf)) {\n      raise_warning(\"Peer certificate CN=`%.*s' is malformed\", name_len, buf);\n      return false;\n    } else if (name_len == sizeof(buf)) {\n      raise_warning(\"Peer certificate CN=`%.*s' is too long to verify\",\n                    name_len, buf);\n      return false;\n    }\n\n    bool match = (strcmp(cnmatch.c_str(), buf) == 0);\n    if (!match && strlen(buf) > 3 && buf[0] == '*' && buf[1] == '.') {\n      /* Try wildcard */\n      if (strchr(buf+2, '.')) {\n        const char* cnmatch_str = cnmatch.c_str();\n        const char *tmp = strstr(cnmatch_str, buf+1);\n        match = tmp && strcmp(tmp, buf+2) && tmp == strchr(cnmatch_str, '.');\n      }\n    }\n\n    if (!match) {\n      /* didn't match */\n      raise_warning(\"Peer certificate CN=`%.*s' did not match expected CN=`%s'\",\n                    name_len, buf, cnmatch.c_str());\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst StaticString\n  s_capture_peer_cert(\"capture_peer_cert\"),\n  s_peer_certificate(\"peer_certificate\"),\n  s_capture_peer_cert_chain(\"capture_peer_cert_chain\"),\n  s_peer_certificate_chain(\"peer_certificate_chain\");\n\nbool SSLSocket::enableCrypto(bool activate /* = true */) {\n  if (activate && !m_data->m_ssl_active) {\n    double timeout = m_data->m_connect_timeout;\n    bool blocked = m_data->m_is_blocked;\n    if (!m_data->m_state_set) {\n      if (m_data->m_client) {\n        SSL_set_connect_state(m_data->m_handle);\n      } else {\n        SSL_set_accept_state(m_data->m_handle);\n      }\n      m_data->m_state_set = true;\n    }\n\n    if (m_data->m_client && setBlocking(false)) {\n      m_data->m_is_blocked = false;\n    }\n\n    int n;\n    bool retry = true;\n    do {\n      if (m_data->m_client) {\n        struct timeval tvs, tve;\n        struct timezone tz;\n\n        gettimeofday(&tvs, &tz);\n        n = SSL_connect(m_data->m_handle);\n        gettimeofday(&tve, &tz);\n\n        timeout -= (tve.tv_sec + (double) tve.tv_usec / 1000000) -\n          (tvs.tv_sec + (double) tvs.tv_usec / 1000000);\n        if (timeout < 0) {\n          raise_warning(\"SSL: connection timeout\");\n          return false;\n        }\n      } else {\n        n = SSL_accept(m_data->m_handle);\n      }\n\n      if (n <= 0) {\n        retry = handleError(n, true);\n      } else {\n        break;\n      }\n    } while (retry);\n\n    if (m_data->m_client &&\n        m_data->m_is_blocked != blocked &&\n        setBlocking(blocked)) {\n      m_data->m_is_blocked = blocked;\n    }\n\n    if (n == 1) {\n      X509 *peer_cert = SSL_get_peer_certificate(m_data->m_handle);\n      if (!applyVerificationPolicy(peer_cert)) {\n        SSL_shutdown(m_data->m_handle);\n      } else {\n        m_data->m_ssl_active = true;\n\n        /* allow the script to capture the peer cert\n         * and/or the certificate chain */\n        if (m_context[s_capture_peer_cert].toBoolean()) {\n          m_context.set(s_peer_certificate,\n                        Variant(req::make<Certificate>(peer_cert)));\n          peer_cert = nullptr;\n        }\n\n        if (m_context[s_capture_peer_cert_chain].toBoolean()) {\n          Array arr;\n          STACK_OF(X509) *chain = SSL_get_peer_cert_chain(m_data->m_handle);\n          if (chain) {\n            for (int i = 0; i < sk_X509_num(chain); i++) {\n              X509 *mycert = X509_dup(sk_X509_value(chain, i));\n              arr.append(Variant(req::make<Certificate>(mycert)));\n            }\n          }\n          m_context.set(s_peer_certificate_chain, arr);\n        }\n      }\n\n      if (peer_cert) {\n        X509_free(peer_cert);\n      }\n    } else  {\n      n = errno == EAGAIN ? 0 : -1;\n    }\n\n    return n >= 0;\n\n  } else if (!activate && m_data->m_ssl_active) {\n    /* deactivate - common for server/client */\n    SSL_shutdown(m_data->m_handle);\n    m_data->m_ssl_active = false;\n  }\n  return true;\n}\n\nbool SSLSocket::checkLiveness() {\n  if (getFd() == -1) {\n    return false;\n  }\n\n  pollfd p;\n  p.fd = getFd();\n  p.events = POLLIN | POLLERR | POLLHUP | POLLPRI;\n  p.revents = 0;\n  if (poll(&p, 1, 0) > 0 && p.revents > 0) {\n    char buf;\n    if (m_data->m_ssl_active) {\n      while (true) {\n        int n = SSL_peek(m_data->m_handle, &buf, sizeof(buf));\n        if (n <= 0) {\n          int err = SSL_get_error(m_data->m_handle, n);\n          if (err == SSL_ERROR_SYSCALL) {\n            return errno == EAGAIN;\n          }\n\n          if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {\n            /* re-negotiate */\n            continue;\n          }\n\n          /* any other problem is a fatal error */\n          return false;\n        }\n        /* either peek succeeded or there was an error; we\n         * have set the alive flag appropriately */\n        break;\n      }\n    } else if (0 == recv(getFd(), &buf, sizeof(buf), MSG_PEEK) &&\n               errno != EAGAIN) {\n      return false;\n    }\n  }\n  return true;\n}\n\nSSLSocket::CryptoMethod SSLSocket::getCryptoMethod() {\n  return m_data->m_method;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Certificate\n\nIMPLEMENT_RESOURCE_ALLOCATION(Certificate)\n\nBIO *Certificate::ReadData(const Variant& var, bool *file /* = NULL */) {\n  if (var.isString() || var.isObject()) {\n    String svar = var.toString();\n    if (StringUtil::IsFileUrl(svar)) {\n      String decoded = StringUtil::DecodeFileUrl(svar);\n      if (decoded.empty()) {\n        raise_warning(\"invalid file URL, %s\", svar.data());\n        return nullptr;\n      }\n      if (file) *file = true;\n      BIO *ret = BIO_new_file(decoded.data(), \"r\");\n      if (ret == nullptr) {\n        raise_warning(\"error opening the file, %s\", decoded.data());\n      }\n      return ret;\n    }\n\n    if (file) *file = false;\n    return BIO_new_mem_buf((char*)svar.data(), svar.size());\n  }\n  return nullptr;\n}\n\n\nreq::ptr<Certificate> Certificate::Get(const Variant& var) {\n  if (var.isResource()) {\n    return dyn_cast_or_null<Certificate>(var);\n  }\n  if (var.isString() || var.isObject()) {\n    bool file;\n    BIO *in = ReadData(var, &file);\n    if (in == nullptr) return nullptr;\n\n    X509 *cert;\n    /*\n    if (file) {\n      cert = PEM_read_bio_X509(in, NULL, NULL, NULL);\n    } else {\n      cert = (X509 *)PEM_ASN1_read_bio\n        ((char *(*)())d2i_X509, PEM_STRING_X509, in, NULL, NULL, NULL);\n    }\n    */\n    cert = PEM_read_bio_X509(in, nullptr, nullptr, nullptr);\n    BIO_free(in);\n    if (cert) {\n      return req::make<Certificate>(cert);\n    }\n  }\n  return nullptr;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n"], "filenames": ["hphp/runtime/base/ssl-socket.cpp"], "buggy_code_start_loc": [502], "buggy_code_end_loc": [546], "fixing_code_start_loc": [502], "fixing_code_end_loc": [546], "type": "NVD-CWE-noinfo", "message": "HHVM 4.172.0 and all prior versions use TLS 1.0 for secure connections when handling tls:// URLs in the stream extension. TLS1.0 has numerous published vulnerabilities and is deprecated. HHVM 4.153.4, 4.168.2, 4.169.2, 4.170.2, 4.171.1, 4.172.1, 4.173.0 replaces TLS1.0 with TLS1.3.\n\nApplications that call stream_socket_server or stream_socket_client functions with a URL starting with tls:// are affected.", "other": {"cve": {"id": "CVE-2022-36937", "sourceIdentifier": "cve-assign@fb.com", "published": "2023-05-10T19:15:08.627", "lastModified": "2023-05-18T21:21:31.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HHVM 4.172.0 and all prior versions use TLS 1.0 for secure connections when handling tls:// URLs in the stream extension. TLS1.0 has numerous published vulnerabilities and is deprecated. HHVM 4.153.4, 4.168.2, 4.169.2, 4.170.2, 4.171.1, 4.172.1, 4.173.0 replaces TLS1.0 with TLS1.3.\n\nApplications that call stream_socket_server or stream_socket_client functions with a URL starting with tls:// are affected."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1104"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.153.4", "matchCriteriaId": "91487128-B88B-4E14-B1EB-D034775108B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.154.0", "versionEndExcluding": "4.168.2", "matchCriteriaId": "AFEBC2B2-0FDF-46EB-80B0-F1E8ED6CE459"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.169.0", "versionEndExcluding": "4.169.2", "matchCriteriaId": "DB8AEBFD-04EE-419A-A080-0B123FDFEF78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.170.0", "versionEndExcluding": "4.170.2", "matchCriteriaId": "47EC3B3C-6874-4F23-A906-52B13EE7DD9F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.171.0:*:*:*:*:*:*:*", "matchCriteriaId": "BDC50CD5-5AF7-4331-810C-D489A4FF3FF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.172.0:*:*:*:*:*:*:*", "matchCriteriaId": "89209682-1753-4B6B-8AF4-E7701F493C59"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/083f5ffdee661f61512909d16f9a5b98cff3cf0b", "source": "cve-assign@fb.com", "tags": ["Patch"]}, {"url": "https://hhvm.com/blog/2023/01/20/security-update.html", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/083f5ffdee661f61512909d16f9a5b98cff3cf0b"}}