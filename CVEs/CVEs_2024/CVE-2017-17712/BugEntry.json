{"buggy_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tRAW - implementation of IP \"raw\" sockets.\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n * Fixes:\n *\t\tAlan Cox\t:\tverify_area() fixed up\n *\t\tAlan Cox\t:\tICMP error handling\n *\t\tAlan Cox\t:\tEMSGSIZE if you send too big a packet\n *\t\tAlan Cox\t: \tNow uses generic datagrams and shared\n *\t\t\t\t\tskbuff library. No more peek crashes,\n *\t\t\t\t\tno more backlogs\n *\t\tAlan Cox\t:\tChecks sk->broadcast.\n *\t\tAlan Cox\t:\tUses skb_free_datagram/skb_copy_datagram\n *\t\tAlan Cox\t:\tRaw passes ip options too\n *\t\tAlan Cox\t:\tSetsocketopt added\n *\t\tAlan Cox\t:\tFixed error return for broadcasts\n *\t\tAlan Cox\t:\tRemoved wake_up calls\n *\t\tAlan Cox\t:\tUse ttl/tos\n *\t\tAlan Cox\t:\tCleaned up old debugging\n *\t\tAlan Cox\t:\tUse new kernel side addresses\n *\tArnt Gulbrandsen\t:\tFixed MSG_DONTROUTE in raw sockets.\n *\t\tAlan Cox\t:\tBSD style RAW socket demultiplexing.\n *\t\tAlan Cox\t:\tBeginnings of mrouted support.\n *\t\tAlan Cox\t:\tAdded IP_HDRINCL option.\n *\t\tAlan Cox\t:\tSkip broadcast check if BSDism set.\n *\t\tDavid S. Miller\t:\tNew socket lookup architecture.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/current.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/sockios.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/mroute.h>\n#include <linux/netdevice.h>\n#include <linux/in_route.h>\n#include <linux/route.h>\n#include <linux/skbuff.h>\n#include <linux/igmp.h>\n#include <net/net_namespace.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <linux/ip.h>\n#include <linux/net.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/raw.h>\n#include <net/snmp.h>\n#include <net/tcp_states.h>\n#include <net/inet_common.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/rtnetlink.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/compat.h>\n#include <linux/uio.h>\n\nstruct raw_frag_vec {\n\tstruct msghdr *msg;\n\tunion {\n\t\tstruct icmphdr icmph;\n\t\tchar c[1];\n\t} hdr;\n\tint hlen;\n};\n\nstruct raw_hashinfo raw_v4_hashinfo = {\n\t.lock = __RW_LOCK_UNLOCKED(raw_v4_hashinfo.lock),\n};\nEXPORT_SYMBOL_GPL(raw_v4_hashinfo);\n\nint raw_hash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\tstruct hlist_head *head;\n\n\thead = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];\n\n\twrite_lock_bh(&h->lock);\n\tsk_add_node(sk, head);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\twrite_unlock_bh(&h->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_hash_sk);\n\nvoid raw_unhash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\n\twrite_lock_bh(&h->lock);\n\tif (sk_del_node_init(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\twrite_unlock_bh(&h->lock);\n}\nEXPORT_SYMBOL_GPL(raw_unhash_sk);\n\nstruct sock *__raw_v4_lookup(struct net *net, struct sock *sk,\n\t\t\t     unsigned short num, __be32 raddr, __be32 laddr,\n\t\t\t     int dif, int sdif)\n{\n\tsk_for_each_from(sk) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tif (net_eq(sock_net(sk), net) && inet->inet_num == num\t&&\n\t\t    !(inet->inet_daddr && inet->inet_daddr != raddr) \t&&\n\t\t    !(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif &&\n\t\t      sk->sk_bound_dev_if != sdif))\n\t\t\tgoto found; /* gotcha */\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(__raw_v4_lookup);\n\n/*\n *\t0 - deliver\n *\t1 - block\n */\nstatic int icmp_filter(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct icmphdr _hdr;\n\tconst struct icmphdr *hdr;\n\n\thdr = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn 1;\n\n\tif (hdr->type < 32) {\n\t\t__u32 data = raw_sk(sk)->filter.data;\n\n\t\treturn ((1U << hdr->type) & data) != 0;\n\t}\n\n\t/* Do not block unknown ICMP types */\n\treturn 0;\n}\n\n/* IP input processing comes here for RAW socket delivery.\n * Caller owns SKB, so we must make clones.\n *\n * RFC 1122: SHOULD pass TOS value up to the transport layer.\n * -> It does. And not only TOS, but all IP header.\n */\nstatic int raw_v4_input(struct sk_buff *skb, const struct iphdr *iph, int hash)\n{\n\tint sdif = inet_sdif(skb);\n\tstruct sock *sk;\n\tstruct hlist_head *head;\n\tint delivered = 0;\n\tstruct net *net;\n\n\tread_lock(&raw_v4_hashinfo.lock);\n\thead = &raw_v4_hashinfo.ht[hash];\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tnet = dev_net(skb->dev);\n\tsk = __raw_v4_lookup(net, __sk_head(head), iph->protocol,\n\t\t\t     iph->saddr, iph->daddr,\n\t\t\t     skb->dev->ifindex, sdif);\n\n\twhile (sk) {\n\t\tdelivered = 1;\n\t\tif ((iph->protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &&\n\t\t    ip_mc_sf_allow(sk, iph->daddr, iph->saddr,\n\t\t\t\t   skb->dev->ifindex, sdif)) {\n\t\t\tstruct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Not releasing hash table! */\n\t\t\tif (clone)\n\t\t\t\traw_rcv(sk, clone);\n\t\t}\n\t\tsk = __raw_v4_lookup(net, sk_next(sk), iph->protocol,\n\t\t\t\t     iph->saddr, iph->daddr,\n\t\t\t\t     skb->dev->ifindex, sdif);\n\t}\nout:\n\tread_unlock(&raw_v4_hashinfo.lock);\n\treturn delivered;\n}\n\nint raw_local_deliver(struct sk_buff *skb, int protocol)\n{\n\tint hash;\n\tstruct sock *raw_sk;\n\n\thash = protocol & (RAW_HTABLE_SIZE - 1);\n\traw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);\n\n\t/* If there maybe a raw socket we must check - if not we\n\t * don't care less\n\t */\n\tif (raw_sk && !raw_v4_input(skb, ip_hdr(skb), hash))\n\t\traw_sk = NULL;\n\n\treturn raw_sk != NULL;\n\n}\n\nstatic void raw_err(struct sock *sk, struct sk_buff *skb, u32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tint err = 0;\n\tint harderr = 0;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\tipv4_sk_update_pmtu(skb, sk, info);\n\telse if (type == ICMP_REDIRECT) {\n\t\tipv4_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\n\t/* Report error on raw socket, if:\n\t   1. User requested ip_recverr.\n\t   2. Socket is connected (otherwise the error indication\n\t      is useless without ip_recverr and error is hard.\n\t */\n\tif (!inet->recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase ICMP_SOURCE_QUENCH:\n\t\treturn;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tharderr = 1;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\terr = EHOSTUNREACH;\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tbreak;\n\t\terr = icmp_err_convert[code].errno;\n\t\tharderr = icmp_err_convert[code].fatal;\n\t\tif (code == ICMP_FRAG_NEEDED) {\n\t\t\tharderr = inet->pmtudisc != IP_PMTUDISC_DONT;\n\t\t\terr = EMSGSIZE;\n\t\t}\n\t}\n\n\tif (inet->recverr) {\n\t\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\t\tu8 *payload = skb->data + (iph->ihl << 2);\n\n\t\tif (inet->hdrincl)\n\t\t\tpayload = skb->data;\n\t\tip_icmp_error(sk, skb, err, 0, info, payload);\n\t}\n\n\tif (inet->recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t}\n}\n\nvoid raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)\n{\n\tint hash;\n\tstruct sock *raw_sk;\n\tconst struct iphdr *iph;\n\tstruct net *net;\n\n\thash = protocol & (RAW_HTABLE_SIZE - 1);\n\n\tread_lock(&raw_v4_hashinfo.lock);\n\traw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);\n\tif (raw_sk) {\n\t\tint dif = skb->dev->ifindex;\n\t\tint sdif = inet_sdif(skb);\n\n\t\tiph = (const struct iphdr *)skb->data;\n\t\tnet = dev_net(skb->dev);\n\n\t\twhile ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol,\n\t\t\t\t\t\tiph->daddr, iph->saddr,\n\t\t\t\t\t\tdif, sdif)) != NULL) {\n\t\t\traw_err(raw_sk, skb, info);\n\t\t\traw_sk = sk_next(raw_sk);\n\t\t\tiph = (const struct iphdr *)skb->data;\n\t\t}\n\t}\n\tread_unlock(&raw_v4_hashinfo.lock);\n}\n\nstatic int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\t/* Charge it to the socket. */\n\n\tipv4_pktinfo_prepare(sk, skb);\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn NET_RX_SUCCESS;\n}\n\nint raw_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\tnf_reset(skb);\n\n\tskb_push(skb, skb->data - skb_network_header(skb));\n\n\traw_rcv_skb(sk, skb);\n\treturn 0;\n}\n\nstatic int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,\n\t\t\t   struct msghdr *msg, size_t length,\n\t\t\t   struct rtable **rtp, unsigned int flags,\n\t\t\t   const struct sockcm_cookie *sockc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\tunsigned int iphlen;\n\tint err;\n\tstruct rtable *rt = *rtp;\n\tint hlen, tlen;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\n\t\t\t       rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (length < sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\thlen = LL_RESERVED_SPACE(rt->dst.dev);\n\ttlen = rt->dst.dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\tskb_dst_set(skb, &rt->dst);\n\t*rtp = NULL;\n\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tskb_put(skb, length);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tsock_tx_timestamp(sk, sockc->tsflags, &skb_shinfo(skb)->tx_flags);\n\n\tif (flags & MSG_CONFIRM)\n\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\tskb->transport_header = skb->network_header;\n\terr = -EFAULT;\n\tif (memcpy_from_msg(iph, msg, length))\n\t\tgoto error_free;\n\n\tiphlen = iph->ihl * 4;\n\n\t/*\n\t * We don't want to modify the ip header, but we do need to\n\t * be sure that it won't cause problems later along the network\n\t * stack.  Specifically we want to make sure that iph->ihl is a\n\t * sane value.  If ihl points beyond the length of the buffer passed\n\t * in, reject the frame as invalid\n\t */\n\terr = -EINVAL;\n\tif (iphlen > length)\n\t\tgoto error_free;\n\n\tif (iphlen >= sizeof(*iph)) {\n\t\tif (!iph->saddr)\n\t\t\tiph->saddr = fl4->saddr;\n\t\tiph->check   = 0;\n\t\tiph->tot_len = htons(length);\n\t\tif (!iph->id)\n\t\t\tip_select_ident(net, skb, NULL);\n\n\t\tiph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\n\t\tskb->transport_header += iphlen;\n\t\tif (iph->protocol == IPPROTO_ICMP &&\n\t\t    length >= iphlen + sizeof(struct icmphdr))\n\t\t\ticmp_out_count(net, ((struct icmphdr *)\n\t\t\t\tskb_transport_header(skb))->type);\n\t}\n\n\terr = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT,\n\t\t      net, sk, skb, NULL, rt->dst.dev,\n\t\t      dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err)\n\t\tgoto error;\nout:\n\treturn 0;\n\nerror_free:\n\tkfree_skb(skb);\nerror:\n\tIP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);\n\tif (err == -ENOBUFS && !inet->recverr)\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int raw_probe_proto_opt(struct raw_frag_vec *rfv, struct flowi4 *fl4)\n{\n\tint err;\n\n\tif (fl4->flowi4_proto != IPPROTO_ICMP)\n\t\treturn 0;\n\n\t/* We only need the first two bytes. */\n\trfv->hlen = 2;\n\n\terr = memcpy_from_msg(rfv->hdr.c, rfv->msg, rfv->hlen);\n\tif (err)\n\t\treturn err;\n\n\tfl4->fl4_icmp_type = rfv->hdr.icmph.type;\n\tfl4->fl4_icmp_code = rfv->hdr.icmph.code;\n\n\treturn 0;\n}\n\nstatic int raw_getfrag(void *from, char *to, int offset, int len, int odd,\n\t\t       struct sk_buff *skb)\n{\n\tstruct raw_frag_vec *rfv = from;\n\n\tif (offset < rfv->hlen) {\n\t\tint copy = min(rfv->hlen - offset, len);\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tmemcpy(to, rfv->hdr.c + offset, copy);\n\t\telse\n\t\t\tskb->csum = csum_block_add(\n\t\t\t\tskb->csum,\n\t\t\t\tcsum_partial_copy_nocheck(rfv->hdr.c + offset,\n\t\t\t\t\t\t\t  to, copy, 0),\n\t\t\t\todd);\n\n\t\todd = 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tlen -= copy;\n\n\t\tif (!len)\n\t\t\treturn 0;\n\t}\n\n\toffset -= rfv->hlen;\n\n\treturn ip_generic_getfrag(rfv->msg, to, offset, len, odd, skb);\n}\n\nstatic int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n\tint err;\n\tstruct ip_options_data opt_copy;\n\tstruct raw_frag_vec rfv;\n\n\terr = -EMSGSIZE;\n\tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.sockc.tsflags = sk->sk_tsflags;\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n\t\t */\n\t\tif (inet->hdrincl)\n\t\t\tgoto done;\n\t\tif (ipc.opt->opt.srr) {\n\t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rtconn_flags(&ipc, sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n\t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n\n\tif (!inet->hdrincl) {\n\t\trfv.msg = msg;\n\t\trfv.hlen = 0;\n\n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (inet->hdrincl)\n\t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n\t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n\n\t else {\n\t\tsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\n\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic void raw_close(struct sock *sk, long timeout)\n{\n\t/*\n\t * Raw sockets may have direct kernel references. Kill them.\n\t */\n\trtnl_lock();\n\tip_ra_control(sk, 0, NULL);\n\trtnl_unlock();\n\n\tsk_common_release(sk);\n}\n\nstatic void raw_destroy(struct sock *sk)\n{\n\tlock_sock(sk);\n\tip_flush_pending_frames(sk);\n\trelease_sock(sk);\n}\n\n/* This gets rid of all the nasties in af_inet. -DaveM */\nstatic int raw_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *addr = (struct sockaddr_in *) uaddr;\n\tu32 tb_id = RT_TABLE_LOCAL;\n\tint ret = -EINVAL;\n\tint chk_addr_ret;\n\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_in))\n\t\tgoto out;\n\n\tif (sk->sk_bound_dev_if)\n\t\ttb_id = l3mdev_fib_table_by_index(sock_net(sk),\n\t\t\t\t\t\t sk->sk_bound_dev_if) ? : tb_id;\n\n\tchk_addr_ret = inet_addr_type_table(sock_net(sk), addr->sin_addr.s_addr,\n\t\t\t\t\t    tb_id);\n\n\tret = -EADDRNOTAVAIL;\n\tif (addr->sin_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tinet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\tret = 0;\nout:\treturn ret;\n}\n\n/*\n *\tThis should be easy, if there is something there\n *\twe return it, otherwise we block.\n */\n\nstatic int raw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t       int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len, addr_len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}\n\nstatic int raw_init(struct sock *sk)\n{\n\tstruct raw_sock *rp = raw_sk(sk);\n\n\tif (inet_sk(sk)->inet_num == IPPROTO_ICMP)\n\t\tmemset(&rp->filter, 0, sizeof(rp->filter));\n\treturn 0;\n}\n\nstatic int raw_seticmpfilter(struct sock *sk, char __user *optval, int optlen)\n{\n\tif (optlen > sizeof(struct icmp_filter))\n\t\toptlen = sizeof(struct icmp_filter);\n\tif (copy_from_user(&raw_sk(sk)->filter, optval, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int raw_geticmpfilter(struct sock *sk, char __user *optval, int __user *optlen)\n{\n\tint len, ret = -EFAULT;\n\n\tif (get_user(len, optlen))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (len < 0)\n\t\tgoto out;\n\tif (len > sizeof(struct icmp_filter))\n\t\tlen = sizeof(struct icmp_filter);\n\tret = -EFAULT;\n\tif (put_user(len, optlen) ||\n\t    copy_to_user(optval, &raw_sk(sk)->filter, len))\n\t\tgoto out;\n\tret = 0;\nout:\treturn ret;\n}\n\nstatic int do_raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tif (optname == ICMP_FILTER) {\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn raw_seticmpfilter(sk, optval, optlen);\n\t}\n\treturn -ENOPROTOOPT;\n}\n\nstatic int raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn ip_setsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t char __user *optval, unsigned int optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn compat_ip_setsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int do_raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tif (optname == ICMP_FILTER) {\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn raw_geticmpfilter(sk, optval, optlen);\n\t}\n\treturn -ENOPROTOOPT;\n}\n\nstatic int raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn ip_getsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn compat_ip_getsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int raw_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\tint amount = sk_wmem_alloc_get(sk);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len;\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\tdefault:\n#ifdef CONFIG_IP_MROUTE\n\t\treturn ipmr_ioctl(sk, cmd, (void __user *)arg);\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_raw_ioctl(struct sock *sk, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\tcase SIOCINQ:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n#ifdef CONFIG_IP_MROUTE\n\t\treturn ipmr_compat_ioctl(sk, cmd, compat_ptr(arg));\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n#endif\n\nint raw_abort(struct sock *sk, int err)\n{\n\tlock_sock(sk);\n\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\n\t__udp_disconnect(sk, 0);\n\n\trelease_sock(sk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_abort);\n\nstruct proto raw_prot = {\n\t.name\t\t   = \"RAW\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = raw_close,\n\t.destroy\t   = raw_destroy,\n\t.connect\t   = ip4_datagram_connect,\n\t.disconnect\t   = __udp_disconnect,\n\t.ioctl\t\t   = raw_ioctl,\n\t.init\t\t   = raw_init,\n\t.setsockopt\t   = raw_setsockopt,\n\t.getsockopt\t   = raw_getsockopt,\n\t.sendmsg\t   = raw_sendmsg,\n\t.recvmsg\t   = raw_recvmsg,\n\t.bind\t\t   = raw_bind,\n\t.backlog_rcv\t   = raw_rcv_skb,\n\t.release_cb\t   = ip4_datagram_release_cb,\n\t.hash\t\t   = raw_hash_sk,\n\t.unhash\t\t   = raw_unhash_sk,\n\t.obj_size\t   = sizeof(struct raw_sock),\n\t.h.raw_hash\t   = &raw_v4_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_raw_setsockopt,\n\t.compat_getsockopt = compat_raw_getsockopt,\n\t.compat_ioctl\t   = compat_raw_ioctl,\n#endif\n\t.diag_destroy\t   = raw_abort,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic struct sock *raw_get_first(struct seq_file *seq)\n{\n\tstruct sock *sk;\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tfor (state->bucket = 0; state->bucket < RAW_HTABLE_SIZE;\n\t\t\t++state->bucket) {\n\t\tsk_for_each(sk, &state->h->ht[state->bucket])\n\t\t\tif (sock_net(sk) == seq_file_net(seq))\n\t\t\t\tgoto found;\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic struct sock *raw_get_next(struct seq_file *seq, struct sock *sk)\n{\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tdo {\n\t\tsk = sk_next(sk);\ntry_again:\n\t\t;\n\t} while (sk && sock_net(sk) != seq_file_net(seq));\n\n\tif (!sk && ++state->bucket < RAW_HTABLE_SIZE) {\n\t\tsk = sk_head(&state->h->ht[state->bucket]);\n\t\tgoto try_again;\n\t}\n\treturn sk;\n}\n\nstatic struct sock *raw_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct sock *sk = raw_get_first(seq);\n\n\tif (sk)\n\t\twhile (pos && (sk = raw_get_next(seq, sk)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : sk;\n}\n\nvoid *raw_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tread_lock(&state->h->lock);\n\treturn *pos ? raw_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\nEXPORT_SYMBOL_GPL(raw_seq_start);\n\nvoid *raw_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock *sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = raw_get_first(seq);\n\telse\n\t\tsk = raw_get_next(seq, v);\n\t++*pos;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(raw_seq_next);\n\nvoid raw_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tread_unlock(&state->h->lock);\n}\nEXPORT_SYMBOL_GPL(raw_seq_stop);\n\nstatic void raw_sock_seq_show(struct seq_file *seq, struct sock *sp, int i)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr,\n\t       src = inet->inet_rcv_saddr;\n\t__u16 destp = 0,\n\t      srcp  = inet->inet_num;\n\n\tseq_printf(seq, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d\\n\",\n\t\ti, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\trefcount_read(&sp->sk_refcnt), sp, atomic_read(&sp->sk_drops));\n}\n\nstatic int raw_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq, \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t\t\"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t\t\"inode ref pointer drops\\n\");\n\telse\n\t\traw_sock_seq_show(seq, v, raw_seq_private(seq)->bucket);\n\treturn 0;\n}\n\nstatic const struct seq_operations raw_seq_ops = {\n\t.start = raw_seq_start,\n\t.next  = raw_seq_next,\n\t.stop  = raw_seq_stop,\n\t.show  = raw_seq_show,\n};\n\nint raw_seq_open(struct inode *ino, struct file *file,\n\t\t struct raw_hashinfo *h, const struct seq_operations *ops)\n{\n\tint err;\n\tstruct raw_iter_state *i;\n\n\terr = seq_open_net(ino, file, ops, sizeof(struct raw_iter_state));\n\tif (err < 0)\n\t\treturn err;\n\n\ti = raw_seq_private((struct seq_file *)file->private_data);\n\ti->h = h;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_seq_open);\n\nstatic int raw_v4_seq_open(struct inode *inode, struct file *file)\n{\n\treturn raw_seq_open(inode, file, &raw_v4_hashinfo, &raw_seq_ops);\n}\n\nstatic const struct file_operations raw_seq_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = raw_v4_seq_open,\n\t.read\t = seq_read,\n\t.llseek\t = seq_lseek,\n\t.release = seq_release_net,\n};\n\nstatic __net_init int raw_init_net(struct net *net)\n{\n\tif (!proc_create(\"raw\", S_IRUGO, net->proc_net, &raw_seq_fops))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic __net_exit void raw_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"raw\", net->proc_net);\n}\n\nstatic __net_initdata struct pernet_operations raw_net_ops = {\n\t.init = raw_init_net,\n\t.exit = raw_exit_net,\n};\n\nint __init raw_proc_init(void)\n{\n\treturn register_pernet_subsys(&raw_net_ops);\n}\n\nvoid __init raw_proc_exit(void)\n{\n\tunregister_pernet_subsys(&raw_net_ops);\n}\n#endif /* CONFIG_PROC_FS */\n"], "fixing_code": ["/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tRAW - implementation of IP \"raw\" sockets.\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n * Fixes:\n *\t\tAlan Cox\t:\tverify_area() fixed up\n *\t\tAlan Cox\t:\tICMP error handling\n *\t\tAlan Cox\t:\tEMSGSIZE if you send too big a packet\n *\t\tAlan Cox\t: \tNow uses generic datagrams and shared\n *\t\t\t\t\tskbuff library. No more peek crashes,\n *\t\t\t\t\tno more backlogs\n *\t\tAlan Cox\t:\tChecks sk->broadcast.\n *\t\tAlan Cox\t:\tUses skb_free_datagram/skb_copy_datagram\n *\t\tAlan Cox\t:\tRaw passes ip options too\n *\t\tAlan Cox\t:\tSetsocketopt added\n *\t\tAlan Cox\t:\tFixed error return for broadcasts\n *\t\tAlan Cox\t:\tRemoved wake_up calls\n *\t\tAlan Cox\t:\tUse ttl/tos\n *\t\tAlan Cox\t:\tCleaned up old debugging\n *\t\tAlan Cox\t:\tUse new kernel side addresses\n *\tArnt Gulbrandsen\t:\tFixed MSG_DONTROUTE in raw sockets.\n *\t\tAlan Cox\t:\tBSD style RAW socket demultiplexing.\n *\t\tAlan Cox\t:\tBeginnings of mrouted support.\n *\t\tAlan Cox\t:\tAdded IP_HDRINCL option.\n *\t\tAlan Cox\t:\tSkip broadcast check if BSDism set.\n *\t\tDavid S. Miller\t:\tNew socket lookup architecture.\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/current.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/sockios.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/mroute.h>\n#include <linux/netdevice.h>\n#include <linux/in_route.h>\n#include <linux/route.h>\n#include <linux/skbuff.h>\n#include <linux/igmp.h>\n#include <net/net_namespace.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <linux/ip.h>\n#include <linux/net.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/raw.h>\n#include <net/snmp.h>\n#include <net/tcp_states.h>\n#include <net/inet_common.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/rtnetlink.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/compat.h>\n#include <linux/uio.h>\n\nstruct raw_frag_vec {\n\tstruct msghdr *msg;\n\tunion {\n\t\tstruct icmphdr icmph;\n\t\tchar c[1];\n\t} hdr;\n\tint hlen;\n};\n\nstruct raw_hashinfo raw_v4_hashinfo = {\n\t.lock = __RW_LOCK_UNLOCKED(raw_v4_hashinfo.lock),\n};\nEXPORT_SYMBOL_GPL(raw_v4_hashinfo);\n\nint raw_hash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\tstruct hlist_head *head;\n\n\thead = &h->ht[inet_sk(sk)->inet_num & (RAW_HTABLE_SIZE - 1)];\n\n\twrite_lock_bh(&h->lock);\n\tsk_add_node(sk, head);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\twrite_unlock_bh(&h->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_hash_sk);\n\nvoid raw_unhash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\n\twrite_lock_bh(&h->lock);\n\tif (sk_del_node_init(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\twrite_unlock_bh(&h->lock);\n}\nEXPORT_SYMBOL_GPL(raw_unhash_sk);\n\nstruct sock *__raw_v4_lookup(struct net *net, struct sock *sk,\n\t\t\t     unsigned short num, __be32 raddr, __be32 laddr,\n\t\t\t     int dif, int sdif)\n{\n\tsk_for_each_from(sk) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tif (net_eq(sock_net(sk), net) && inet->inet_num == num\t&&\n\t\t    !(inet->inet_daddr && inet->inet_daddr != raddr) \t&&\n\t\t    !(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif &&\n\t\t      sk->sk_bound_dev_if != sdif))\n\t\t\tgoto found; /* gotcha */\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(__raw_v4_lookup);\n\n/*\n *\t0 - deliver\n *\t1 - block\n */\nstatic int icmp_filter(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct icmphdr _hdr;\n\tconst struct icmphdr *hdr;\n\n\thdr = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn 1;\n\n\tif (hdr->type < 32) {\n\t\t__u32 data = raw_sk(sk)->filter.data;\n\n\t\treturn ((1U << hdr->type) & data) != 0;\n\t}\n\n\t/* Do not block unknown ICMP types */\n\treturn 0;\n}\n\n/* IP input processing comes here for RAW socket delivery.\n * Caller owns SKB, so we must make clones.\n *\n * RFC 1122: SHOULD pass TOS value up to the transport layer.\n * -> It does. And not only TOS, but all IP header.\n */\nstatic int raw_v4_input(struct sk_buff *skb, const struct iphdr *iph, int hash)\n{\n\tint sdif = inet_sdif(skb);\n\tstruct sock *sk;\n\tstruct hlist_head *head;\n\tint delivered = 0;\n\tstruct net *net;\n\n\tread_lock(&raw_v4_hashinfo.lock);\n\thead = &raw_v4_hashinfo.ht[hash];\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tnet = dev_net(skb->dev);\n\tsk = __raw_v4_lookup(net, __sk_head(head), iph->protocol,\n\t\t\t     iph->saddr, iph->daddr,\n\t\t\t     skb->dev->ifindex, sdif);\n\n\twhile (sk) {\n\t\tdelivered = 1;\n\t\tif ((iph->protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &&\n\t\t    ip_mc_sf_allow(sk, iph->daddr, iph->saddr,\n\t\t\t\t   skb->dev->ifindex, sdif)) {\n\t\t\tstruct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Not releasing hash table! */\n\t\t\tif (clone)\n\t\t\t\traw_rcv(sk, clone);\n\t\t}\n\t\tsk = __raw_v4_lookup(net, sk_next(sk), iph->protocol,\n\t\t\t\t     iph->saddr, iph->daddr,\n\t\t\t\t     skb->dev->ifindex, sdif);\n\t}\nout:\n\tread_unlock(&raw_v4_hashinfo.lock);\n\treturn delivered;\n}\n\nint raw_local_deliver(struct sk_buff *skb, int protocol)\n{\n\tint hash;\n\tstruct sock *raw_sk;\n\n\thash = protocol & (RAW_HTABLE_SIZE - 1);\n\traw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);\n\n\t/* If there maybe a raw socket we must check - if not we\n\t * don't care less\n\t */\n\tif (raw_sk && !raw_v4_input(skb, ip_hdr(skb), hash))\n\t\traw_sk = NULL;\n\n\treturn raw_sk != NULL;\n\n}\n\nstatic void raw_err(struct sock *sk, struct sk_buff *skb, u32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tint err = 0;\n\tint harderr = 0;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\tipv4_sk_update_pmtu(skb, sk, info);\n\telse if (type == ICMP_REDIRECT) {\n\t\tipv4_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\n\t/* Report error on raw socket, if:\n\t   1. User requested ip_recverr.\n\t   2. Socket is connected (otherwise the error indication\n\t      is useless without ip_recverr and error is hard.\n\t */\n\tif (!inet->recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase ICMP_SOURCE_QUENCH:\n\t\treturn;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tharderr = 1;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\terr = EHOSTUNREACH;\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tbreak;\n\t\terr = icmp_err_convert[code].errno;\n\t\tharderr = icmp_err_convert[code].fatal;\n\t\tif (code == ICMP_FRAG_NEEDED) {\n\t\t\tharderr = inet->pmtudisc != IP_PMTUDISC_DONT;\n\t\t\terr = EMSGSIZE;\n\t\t}\n\t}\n\n\tif (inet->recverr) {\n\t\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\t\tu8 *payload = skb->data + (iph->ihl << 2);\n\n\t\tif (inet->hdrincl)\n\t\t\tpayload = skb->data;\n\t\tip_icmp_error(sk, skb, err, 0, info, payload);\n\t}\n\n\tif (inet->recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t}\n}\n\nvoid raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)\n{\n\tint hash;\n\tstruct sock *raw_sk;\n\tconst struct iphdr *iph;\n\tstruct net *net;\n\n\thash = protocol & (RAW_HTABLE_SIZE - 1);\n\n\tread_lock(&raw_v4_hashinfo.lock);\n\traw_sk = sk_head(&raw_v4_hashinfo.ht[hash]);\n\tif (raw_sk) {\n\t\tint dif = skb->dev->ifindex;\n\t\tint sdif = inet_sdif(skb);\n\n\t\tiph = (const struct iphdr *)skb->data;\n\t\tnet = dev_net(skb->dev);\n\n\t\twhile ((raw_sk = __raw_v4_lookup(net, raw_sk, protocol,\n\t\t\t\t\t\tiph->daddr, iph->saddr,\n\t\t\t\t\t\tdif, sdif)) != NULL) {\n\t\t\traw_err(raw_sk, skb, info);\n\t\t\traw_sk = sk_next(raw_sk);\n\t\t\tiph = (const struct iphdr *)skb->data;\n\t\t}\n\t}\n\tread_unlock(&raw_v4_hashinfo.lock);\n}\n\nstatic int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\t/* Charge it to the socket. */\n\n\tipv4_pktinfo_prepare(sk, skb);\n\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn NET_RX_SUCCESS;\n}\n\nint raw_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\tnf_reset(skb);\n\n\tskb_push(skb, skb->data - skb_network_header(skb));\n\n\traw_rcv_skb(sk, skb);\n\treturn 0;\n}\n\nstatic int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,\n\t\t\t   struct msghdr *msg, size_t length,\n\t\t\t   struct rtable **rtp, unsigned int flags,\n\t\t\t   const struct sockcm_cookie *sockc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\tunsigned int iphlen;\n\tint err;\n\tstruct rtable *rt = *rtp;\n\tint hlen, tlen;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\n\t\t\t       rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (length < sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\thlen = LL_RESERVED_SPACE(rt->dst.dev);\n\ttlen = rt->dst.dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\tskb_dst_set(skb, &rt->dst);\n\t*rtp = NULL;\n\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tskb_put(skb, length);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tsock_tx_timestamp(sk, sockc->tsflags, &skb_shinfo(skb)->tx_flags);\n\n\tif (flags & MSG_CONFIRM)\n\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\tskb->transport_header = skb->network_header;\n\terr = -EFAULT;\n\tif (memcpy_from_msg(iph, msg, length))\n\t\tgoto error_free;\n\n\tiphlen = iph->ihl * 4;\n\n\t/*\n\t * We don't want to modify the ip header, but we do need to\n\t * be sure that it won't cause problems later along the network\n\t * stack.  Specifically we want to make sure that iph->ihl is a\n\t * sane value.  If ihl points beyond the length of the buffer passed\n\t * in, reject the frame as invalid\n\t */\n\terr = -EINVAL;\n\tif (iphlen > length)\n\t\tgoto error_free;\n\n\tif (iphlen >= sizeof(*iph)) {\n\t\tif (!iph->saddr)\n\t\t\tiph->saddr = fl4->saddr;\n\t\tiph->check   = 0;\n\t\tiph->tot_len = htons(length);\n\t\tif (!iph->id)\n\t\t\tip_select_ident(net, skb, NULL);\n\n\t\tiph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\n\t\tskb->transport_header += iphlen;\n\t\tif (iph->protocol == IPPROTO_ICMP &&\n\t\t    length >= iphlen + sizeof(struct icmphdr))\n\t\t\ticmp_out_count(net, ((struct icmphdr *)\n\t\t\t\tskb_transport_header(skb))->type);\n\t}\n\n\terr = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT,\n\t\t      net, sk, skb, NULL, rt->dst.dev,\n\t\t      dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err)\n\t\tgoto error;\nout:\n\treturn 0;\n\nerror_free:\n\tkfree_skb(skb);\nerror:\n\tIP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);\n\tif (err == -ENOBUFS && !inet->recverr)\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int raw_probe_proto_opt(struct raw_frag_vec *rfv, struct flowi4 *fl4)\n{\n\tint err;\n\n\tif (fl4->flowi4_proto != IPPROTO_ICMP)\n\t\treturn 0;\n\n\t/* We only need the first two bytes. */\n\trfv->hlen = 2;\n\n\terr = memcpy_from_msg(rfv->hdr.c, rfv->msg, rfv->hlen);\n\tif (err)\n\t\treturn err;\n\n\tfl4->fl4_icmp_type = rfv->hdr.icmph.type;\n\tfl4->fl4_icmp_code = rfv->hdr.icmph.code;\n\n\treturn 0;\n}\n\nstatic int raw_getfrag(void *from, char *to, int offset, int len, int odd,\n\t\t       struct sk_buff *skb)\n{\n\tstruct raw_frag_vec *rfv = from;\n\n\tif (offset < rfv->hlen) {\n\t\tint copy = min(rfv->hlen - offset, len);\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tmemcpy(to, rfv->hdr.c + offset, copy);\n\t\telse\n\t\t\tskb->csum = csum_block_add(\n\t\t\t\tskb->csum,\n\t\t\t\tcsum_partial_copy_nocheck(rfv->hdr.c + offset,\n\t\t\t\t\t\t\t  to, copy, 0),\n\t\t\t\todd);\n\n\t\todd = 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tlen -= copy;\n\n\t\tif (!len)\n\t\t\treturn 0;\n\t}\n\n\toffset -= rfv->hlen;\n\n\treturn ip_generic_getfrag(rfv->msg, to, offset, len, odd, skb);\n}\n\nstatic int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tu8  tos;\n\tint err;\n\tstruct ip_options_data opt_copy;\n\tstruct raw_frag_vec rfv;\n\tint hdrincl;\n\n\terr = -EMSGSIZE;\n\tif (len > 0xFFFF)\n\t\tgoto out;\n\n\t/* hdrincl should be READ_ONCE(inet->hdrincl)\n\t * but READ_ONCE() doesn't work with bit fields\n\t */\n\thdrincl = inet->hdrincl;\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t/* Mirror BSD error message */\n\t\tgoto out;               /* compatibility */\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t/* ANK: I did not forget to get protocol from port field.\n\t\t * I just do not know, who uses this weirdness.\n\t\t * IP_HDRINCL is much more convenient.\n\t\t */\n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipc.sockc.tsflags = sk->sk_tsflags;\n\tipc.addr = inet->inet_saddr;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tipc.ttl = 0;\n\tipc.tos = -1;\n\tipc.oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n\t\t/* Linux does not mangle headers on raw sockets,\n\t\t * so that IP options + IP_HDRINCL is non-sense.\n\t\t */\n\t\tif (hdrincl)\n\t\t\tgoto done;\n\t\tif (ipc.opt->opt.srr) {\n\t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rtconn_flags(&ipc, sk);\n\tif (msg->msg_flags & MSG_DONTROUTE)\n\t\ttos |= RTO_ONLINK;\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif)\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,\n\t\t\t   RT_SCOPE_UNIVERSE,\n\t\t\t   hdrincl ? IPPROTO_RAW : sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n\t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n\n\tif (!hdrincl) {\n\t\trfv.msg = msg;\n\t\trfv.hlen = 0;\n\n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (hdrincl)\n\t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n\t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n\n\t else {\n\t\tsock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);\n\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet->recverr)\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic void raw_close(struct sock *sk, long timeout)\n{\n\t/*\n\t * Raw sockets may have direct kernel references. Kill them.\n\t */\n\trtnl_lock();\n\tip_ra_control(sk, 0, NULL);\n\trtnl_unlock();\n\n\tsk_common_release(sk);\n}\n\nstatic void raw_destroy(struct sock *sk)\n{\n\tlock_sock(sk);\n\tip_flush_pending_frames(sk);\n\trelease_sock(sk);\n}\n\n/* This gets rid of all the nasties in af_inet. -DaveM */\nstatic int raw_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *addr = (struct sockaddr_in *) uaddr;\n\tu32 tb_id = RT_TABLE_LOCAL;\n\tint ret = -EINVAL;\n\tint chk_addr_ret;\n\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_in))\n\t\tgoto out;\n\n\tif (sk->sk_bound_dev_if)\n\t\ttb_id = l3mdev_fib_table_by_index(sock_net(sk),\n\t\t\t\t\t\t sk->sk_bound_dev_if) ? : tb_id;\n\n\tchk_addr_ret = inet_addr_type_table(sock_net(sk), addr->sin_addr.s_addr,\n\t\t\t\t\t    tb_id);\n\n\tret = -EADDRNOTAVAIL;\n\tif (addr->sin_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tinet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\tret = 0;\nout:\treturn ret;\n}\n\n/*\n *\tThis should be easy, if there is something there\n *\twe return it, otherwise we block.\n */\n\nstatic int raw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t       int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len, addr_len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}\n\nstatic int raw_init(struct sock *sk)\n{\n\tstruct raw_sock *rp = raw_sk(sk);\n\n\tif (inet_sk(sk)->inet_num == IPPROTO_ICMP)\n\t\tmemset(&rp->filter, 0, sizeof(rp->filter));\n\treturn 0;\n}\n\nstatic int raw_seticmpfilter(struct sock *sk, char __user *optval, int optlen)\n{\n\tif (optlen > sizeof(struct icmp_filter))\n\t\toptlen = sizeof(struct icmp_filter);\n\tif (copy_from_user(&raw_sk(sk)->filter, optval, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int raw_geticmpfilter(struct sock *sk, char __user *optval, int __user *optlen)\n{\n\tint len, ret = -EFAULT;\n\n\tif (get_user(len, optlen))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (len < 0)\n\t\tgoto out;\n\tif (len > sizeof(struct icmp_filter))\n\t\tlen = sizeof(struct icmp_filter);\n\tret = -EFAULT;\n\tif (put_user(len, optlen) ||\n\t    copy_to_user(optval, &raw_sk(sk)->filter, len))\n\t\tgoto out;\n\tret = 0;\nout:\treturn ret;\n}\n\nstatic int do_raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tif (optname == ICMP_FILTER) {\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn raw_seticmpfilter(sk, optval, optlen);\n\t}\n\treturn -ENOPROTOOPT;\n}\n\nstatic int raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn ip_setsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t char __user *optval, unsigned int optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn compat_ip_setsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int do_raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tif (optname == ICMP_FILTER) {\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn raw_geticmpfilter(sk, optval, optlen);\n\t}\n\treturn -ENOPROTOOPT;\n}\n\nstatic int raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn ip_getsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn compat_ip_getsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int raw_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\tint amount = sk_wmem_alloc_get(sk);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len;\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\tdefault:\n#ifdef CONFIG_IP_MROUTE\n\t\treturn ipmr_ioctl(sk, cmd, (void __user *)arg);\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_raw_ioctl(struct sock *sk, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\tcase SIOCINQ:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n#ifdef CONFIG_IP_MROUTE\n\t\treturn ipmr_compat_ioctl(sk, cmd, compat_ptr(arg));\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n#endif\n\nint raw_abort(struct sock *sk, int err)\n{\n\tlock_sock(sk);\n\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\n\t__udp_disconnect(sk, 0);\n\n\trelease_sock(sk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_abort);\n\nstruct proto raw_prot = {\n\t.name\t\t   = \"RAW\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = raw_close,\n\t.destroy\t   = raw_destroy,\n\t.connect\t   = ip4_datagram_connect,\n\t.disconnect\t   = __udp_disconnect,\n\t.ioctl\t\t   = raw_ioctl,\n\t.init\t\t   = raw_init,\n\t.setsockopt\t   = raw_setsockopt,\n\t.getsockopt\t   = raw_getsockopt,\n\t.sendmsg\t   = raw_sendmsg,\n\t.recvmsg\t   = raw_recvmsg,\n\t.bind\t\t   = raw_bind,\n\t.backlog_rcv\t   = raw_rcv_skb,\n\t.release_cb\t   = ip4_datagram_release_cb,\n\t.hash\t\t   = raw_hash_sk,\n\t.unhash\t\t   = raw_unhash_sk,\n\t.obj_size\t   = sizeof(struct raw_sock),\n\t.h.raw_hash\t   = &raw_v4_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_raw_setsockopt,\n\t.compat_getsockopt = compat_raw_getsockopt,\n\t.compat_ioctl\t   = compat_raw_ioctl,\n#endif\n\t.diag_destroy\t   = raw_abort,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic struct sock *raw_get_first(struct seq_file *seq)\n{\n\tstruct sock *sk;\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tfor (state->bucket = 0; state->bucket < RAW_HTABLE_SIZE;\n\t\t\t++state->bucket) {\n\t\tsk_for_each(sk, &state->h->ht[state->bucket])\n\t\t\tif (sock_net(sk) == seq_file_net(seq))\n\t\t\t\tgoto found;\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic struct sock *raw_get_next(struct seq_file *seq, struct sock *sk)\n{\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tdo {\n\t\tsk = sk_next(sk);\ntry_again:\n\t\t;\n\t} while (sk && sock_net(sk) != seq_file_net(seq));\n\n\tif (!sk && ++state->bucket < RAW_HTABLE_SIZE) {\n\t\tsk = sk_head(&state->h->ht[state->bucket]);\n\t\tgoto try_again;\n\t}\n\treturn sk;\n}\n\nstatic struct sock *raw_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct sock *sk = raw_get_first(seq);\n\n\tif (sk)\n\t\twhile (pos && (sk = raw_get_next(seq, sk)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : sk;\n}\n\nvoid *raw_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tread_lock(&state->h->lock);\n\treturn *pos ? raw_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\nEXPORT_SYMBOL_GPL(raw_seq_start);\n\nvoid *raw_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock *sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = raw_get_first(seq);\n\telse\n\t\tsk = raw_get_next(seq, v);\n\t++*pos;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(raw_seq_next);\n\nvoid raw_seq_stop(struct seq_file *seq, void *v)\n{\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tread_unlock(&state->h->lock);\n}\nEXPORT_SYMBOL_GPL(raw_seq_stop);\n\nstatic void raw_sock_seq_show(struct seq_file *seq, struct sock *sp, int i)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr,\n\t       src = inet->inet_rcv_saddr;\n\t__u16 destp = 0,\n\t      srcp  = inet->inet_num;\n\n\tseq_printf(seq, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %d\\n\",\n\t\ti, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\trefcount_read(&sp->sk_refcnt), sp, atomic_read(&sp->sk_drops));\n}\n\nstatic int raw_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq, \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t\t\"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t\t\"inode ref pointer drops\\n\");\n\telse\n\t\traw_sock_seq_show(seq, v, raw_seq_private(seq)->bucket);\n\treturn 0;\n}\n\nstatic const struct seq_operations raw_seq_ops = {\n\t.start = raw_seq_start,\n\t.next  = raw_seq_next,\n\t.stop  = raw_seq_stop,\n\t.show  = raw_seq_show,\n};\n\nint raw_seq_open(struct inode *ino, struct file *file,\n\t\t struct raw_hashinfo *h, const struct seq_operations *ops)\n{\n\tint err;\n\tstruct raw_iter_state *i;\n\n\terr = seq_open_net(ino, file, ops, sizeof(struct raw_iter_state));\n\tif (err < 0)\n\t\treturn err;\n\n\ti = raw_seq_private((struct seq_file *)file->private_data);\n\ti->h = h;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_seq_open);\n\nstatic int raw_v4_seq_open(struct inode *inode, struct file *file)\n{\n\treturn raw_seq_open(inode, file, &raw_v4_hashinfo, &raw_seq_ops);\n}\n\nstatic const struct file_operations raw_seq_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = raw_v4_seq_open,\n\t.read\t = seq_read,\n\t.llseek\t = seq_lseek,\n\t.release = seq_release_net,\n};\n\nstatic __net_init int raw_init_net(struct net *net)\n{\n\tif (!proc_create(\"raw\", S_IRUGO, net->proc_net, &raw_seq_fops))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic __net_exit void raw_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"raw\", net->proc_net);\n}\n\nstatic __net_initdata struct pernet_operations raw_net_ops = {\n\t.init = raw_init_net,\n\t.exit = raw_exit_net,\n};\n\nint __init raw_proc_init(void)\n{\n\treturn register_pernet_subsys(&raw_net_ops);\n}\n\nvoid __init raw_proc_exit(void)\n{\n\tunregister_pernet_subsys(&raw_net_ops);\n}\n#endif /* CONFIG_PROC_FS */\n"], "filenames": ["net/ipv4/raw.c"], "buggy_code_start_loc": [515], "buggy_code_end_loc": [649], "fixing_code_start_loc": [516], "fixing_code_end_loc": [654], "type": "CWE-362", "message": "The raw_sendmsg() function in net/ipv4/raw.c in the Linux kernel through 4.14.6 has a race condition in inet->hdrincl that leads to uninitialized stack pointer usage; this allows a local user to execute code and gain privileges.", "other": {"cve": {"id": "CVE-2017-17712", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-16T01:29:00.190", "lastModified": "2018-04-04T01:29:01.137", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The raw_sendmsg() function in net/ipv4/raw.c in the Linux kernel through 4.14.6 has a race condition in inet->hdrincl that leads to uninitialized stack pointer usage; this allows a local user to execute code and gain privileges."}, {"lang": "es", "value": "La funci\u00f3n raw_sendmsg() en net/ipv4/raw.c en el kernel de Linux hasta la versi\u00f3n 4.14.6 tiene una condici\u00f3n de carrera en inet->hdrincl que conduce al uso de un puntero de pila no inicializado. Esto permite que un usuario local ejecute c\u00f3digo y obtenga privilegios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.14.6", "matchCriteriaId": "199A7680-7A66-46C8-A63F-55444AF8DFF8"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8f659a03a0ba9289b9aeb9b4470e6fb263d6f483", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0502", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://source.android.com/security/bulletin/pixel/2018-04-01", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3581-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3581-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3581-3/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3582-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3582-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2017/dsa-4073", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8f659a03a0ba9289b9aeb9b4470e6fb263d6f483"}}