{"buggy_code": ["package org.bouncycastle.crypto.engines;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DataLengthException;\nimport org.bouncycastle.crypto.OutputLengthException;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.util.Pack;\n\n/**\n * an implementation of the AES (Rijndael), from FIPS-197.\n * <p>\n * For further details see: <a href=\"http://csrc.nist.gov/encryption/aes/\">http://csrc.nist.gov/encryption/aes/</a>.\n *\n * This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at\n * <a href=\"http://fp.gladman.plus.com/cryptography_technology/rijndael/\">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>\n *\n * There are three levels of tradeoff of speed vs memory\n * Because java has no preprocessor, they are written as three separate classes from which to choose\n *\n * The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption\n * and 4 for decryption.\n *\n * The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,\n * adding 12 rotate operations per round to compute the values contained in the other tables from\n * the contents of the first.\n *\n * The slowest version uses no static tables at all and computes the values in each round.\n * <p>\n * This file contains the middle performance version with 2Kbytes of static tables for round precomputation.\n *\n */\npublic class AESEngine\n    implements BlockCipher\n{\n    // The S box\n    private static final byte[] S = {\n        (byte)99, (byte)124, (byte)119, (byte)123, (byte)242, (byte)107, (byte)111, (byte)197,\n        (byte)48,   (byte)1, (byte)103,  (byte)43, (byte)254, (byte)215, (byte)171, (byte)118,\n        (byte)202, (byte)130, (byte)201, (byte)125, (byte)250,  (byte)89,  (byte)71, (byte)240,\n        (byte)173, (byte)212, (byte)162, (byte)175, (byte)156, (byte)164, (byte)114, (byte)192,\n        (byte)183, (byte)253, (byte)147,  (byte)38,  (byte)54,  (byte)63, (byte)247, (byte)204,\n        (byte)52, (byte)165, (byte)229, (byte)241, (byte)113, (byte)216,  (byte)49,  (byte)21,\n        (byte)4, (byte)199,  (byte)35, (byte)195,  (byte)24, (byte)150,   (byte)5, (byte)154,\n        (byte)7,  (byte)18, (byte)128, (byte)226, (byte)235,  (byte)39, (byte)178, (byte)117,\n        (byte)9, (byte)131,  (byte)44,  (byte)26,  (byte)27, (byte)110,  (byte)90, (byte)160,\n        (byte)82,  (byte)59, (byte)214, (byte)179,  (byte)41, (byte)227,  (byte)47, (byte)132,\n        (byte)83, (byte)209,   (byte)0, (byte)237,  (byte)32, (byte)252, (byte)177,  (byte)91,\n        (byte)106, (byte)203, (byte)190,  (byte)57,  (byte)74,  (byte)76,  (byte)88, (byte)207,\n        (byte)208, (byte)239, (byte)170, (byte)251,  (byte)67,  (byte)77,  (byte)51, (byte)133,\n        (byte)69, (byte)249,   (byte)2, (byte)127,  (byte)80,  (byte)60, (byte)159, (byte)168,\n        (byte)81, (byte)163,  (byte)64, (byte)143, (byte)146, (byte)157,  (byte)56, (byte)245,\n        (byte)188, (byte)182, (byte)218,  (byte)33,  (byte)16, (byte)255, (byte)243, (byte)210,\n        (byte)205,  (byte)12,  (byte)19, (byte)236,  (byte)95, (byte)151,  (byte)68,  (byte)23,\n        (byte)196, (byte)167, (byte)126,  (byte)61, (byte)100,  (byte)93,  (byte)25, (byte)115,\n        (byte)96, (byte)129,  (byte)79, (byte)220,  (byte)34,  (byte)42, (byte)144, (byte)136,\n        (byte)70, (byte)238, (byte)184,  (byte)20, (byte)222,  (byte)94,  (byte)11, (byte)219,\n        (byte)224,  (byte)50,  (byte)58,  (byte)10,  (byte)73,   (byte)6,  (byte)36,  (byte)92,\n        (byte)194, (byte)211, (byte)172,  (byte)98, (byte)145, (byte)149, (byte)228, (byte)121,\n        (byte)231, (byte)200,  (byte)55, (byte)109, (byte)141, (byte)213,  (byte)78, (byte)169,\n        (byte)108,  (byte)86, (byte)244, (byte)234, (byte)101, (byte)122, (byte)174,   (byte)8,\n        (byte)186, (byte)120,  (byte)37,  (byte)46,  (byte)28, (byte)166, (byte)180, (byte)198,\n        (byte)232, (byte)221, (byte)116,  (byte)31,  (byte)75, (byte)189, (byte)139, (byte)138,\n        (byte)112,  (byte)62, (byte)181, (byte)102,  (byte)72,   (byte)3, (byte)246,  (byte)14,\n        (byte)97,  (byte)53,  (byte)87, (byte)185, (byte)134, (byte)193,  (byte)29, (byte)158,\n        (byte)225, (byte)248, (byte)152,  (byte)17, (byte)105, (byte)217, (byte)142, (byte)148,\n        (byte)155,  (byte)30, (byte)135, (byte)233, (byte)206,  (byte)85,  (byte)40, (byte)223,\n        (byte)140, (byte)161, (byte)137,  (byte)13, (byte)191, (byte)230,  (byte)66, (byte)104,\n        (byte)65, (byte)153,  (byte)45,  (byte)15, (byte)176,  (byte)84, (byte)187,  (byte)22,\n    };\n\n    // The inverse S-box\n    private static final byte[] Si = {\n        (byte)82,   (byte)9, (byte)106, (byte)213,  (byte)48,  (byte)54, (byte)165,  (byte)56,\n        (byte)191,  (byte)64, (byte)163, (byte)158, (byte)129, (byte)243, (byte)215, (byte)251,\n        (byte)124, (byte)227,  (byte)57, (byte)130, (byte)155,  (byte)47, (byte)255, (byte)135,\n        (byte)52, (byte)142,  (byte)67,  (byte)68, (byte)196, (byte)222, (byte)233, (byte)203,\n        (byte)84, (byte)123, (byte)148,  (byte)50, (byte)166, (byte)194,  (byte)35,  (byte)61,\n        (byte)238,  (byte)76, (byte)149,  (byte)11,  (byte)66, (byte)250, (byte)195,  (byte)78,\n        (byte)8,  (byte)46, (byte)161, (byte)102,  (byte)40, (byte)217,  (byte)36, (byte)178,\n        (byte)118,  (byte)91, (byte)162,  (byte)73, (byte)109, (byte)139, (byte)209,  (byte)37,\n        (byte)114, (byte)248, (byte)246, (byte)100, (byte)134, (byte)104, (byte)152,  (byte)22,\n        (byte)212, (byte)164,  (byte)92, (byte)204,  (byte)93, (byte)101, (byte)182, (byte)146,\n        (byte)108, (byte)112,  (byte)72,  (byte)80, (byte)253, (byte)237, (byte)185, (byte)218,\n        (byte)94,  (byte)21,  (byte)70,  (byte)87, (byte)167, (byte)141, (byte)157, (byte)132,\n        (byte)144, (byte)216, (byte)171,   (byte)0, (byte)140, (byte)188, (byte)211,  (byte)10,\n        (byte)247, (byte)228,  (byte)88,   (byte)5, (byte)184, (byte)179,  (byte)69,   (byte)6,\n        (byte)208,  (byte)44,  (byte)30, (byte)143, (byte)202,  (byte)63,  (byte)15,   (byte)2,\n        (byte)193, (byte)175, (byte)189,   (byte)3,   (byte)1,  (byte)19, (byte)138, (byte)107,\n        (byte)58, (byte)145,  (byte)17,  (byte)65,  (byte)79, (byte)103, (byte)220, (byte)234,\n        (byte)151, (byte)242, (byte)207, (byte)206, (byte)240, (byte)180, (byte)230, (byte)115,\n        (byte)150, (byte)172, (byte)116,  (byte)34, (byte)231, (byte)173,  (byte)53, (byte)133,\n        (byte)226, (byte)249,  (byte)55, (byte)232,  (byte)28, (byte)117, (byte)223, (byte)110,\n        (byte)71, (byte)241,  (byte)26, (byte)113,  (byte)29,  (byte)41, (byte)197, (byte)137,\n        (byte)111, (byte)183,  (byte)98,  (byte)14, (byte)170,  (byte)24, (byte)190,  (byte)27,\n        (byte)252,  (byte)86,  (byte)62,  (byte)75, (byte)198, (byte)210, (byte)121,  (byte)32,\n        (byte)154, (byte)219, (byte)192, (byte)254, (byte)120, (byte)205,  (byte)90, (byte)244,\n        (byte)31, (byte)221, (byte)168,  (byte)51, (byte)136,   (byte)7, (byte)199,  (byte)49,\n        (byte)177,  (byte)18,  (byte)16,  (byte)89,  (byte)39, (byte)128, (byte)236,  (byte)95,\n        (byte)96,  (byte)81, (byte)127, (byte)169,  (byte)25, (byte)181,  (byte)74,  (byte)13,\n        (byte)45, (byte)229, (byte)122, (byte)159, (byte)147, (byte)201, (byte)156, (byte)239,\n        (byte)160, (byte)224,  (byte)59,  (byte)77, (byte)174,  (byte)42, (byte)245, (byte)176,\n        (byte)200, (byte)235, (byte)187,  (byte)60, (byte)131,  (byte)83, (byte)153,  (byte)97,\n        (byte)23,  (byte)43,   (byte)4, (byte)126, (byte)186, (byte)119, (byte)214,  (byte)38,\n        (byte)225, (byte)105,  (byte)20,  (byte)99,  (byte)85,  (byte)33,  (byte)12, (byte)125,\n        };\n\n    // vector used in calculating key schedule (powers of x in GF(256))\n    private static final int[] rcon = {\n         0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\n         0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 };\n\n    // precomputation tables of calculations for rounds\n    private static final int[] T0 =\n    {\n     0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6, 0x0df2f2ff, \n     0xbd6b6bd6, 0xb16f6fde, 0x54c5c591, 0x50303060, 0x03010102, \n     0xa96767ce, 0x7d2b2b56, 0x19fefee7, 0x62d7d7b5, 0xe6abab4d, \n     0x9a7676ec, 0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa, \n     0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb, 0xecadad41, \n     0x67d4d4b3, 0xfda2a25f, 0xeaafaf45, 0xbf9c9c23, 0xf7a4a453, \n     0x967272e4, 0x5bc0c09b, 0xc2b7b775, 0x1cfdfde1, 0xae93933d, \n     0x6a26264c, 0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83, \n     0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9, 0x937171e2, \n     0x73d8d8ab, 0x53313162, 0x3f15152a, 0x0c040408, 0x52c7c795, \n     0x65232346, 0x5ec3c39d, 0x28181830, 0xa1969637, 0x0f05050a, \n     0xb59a9a2f, 0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df, \n     0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea, 0x1b090912, \n     0x9e83831d, 0x742c2c58, 0x2e1a1a34, 0x2d1b1b36, 0xb26e6edc, \n     0xee5a5ab4, 0xfba0a05b, 0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, \n     0xceb3b37d, 0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413, \n     0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1, 0x60202040, \n     0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6, 0xbe6a6ad4, 0x46cbcb8d, \n     0xd9bebe67, 0x4b393972, 0xde4a4a94, 0xd44c4c98, 0xe85858b0, \n     0x4acfcf85, 0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed, \n     0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511, 0xcf45458a, \n     0x10f9f9e9, 0x06020204, 0x817f7ffe, 0xf05050a0, 0x443c3c78, \n     0xba9f9f25, 0xe3a8a84b, 0xf35151a2, 0xfea3a35d, 0xc0404080, \n     0x8a8f8f05, 0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1, \n     0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142, 0x30101020, \n     0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf, 0x4ccdcd81, 0x140c0c18, \n     0x35131326, 0x2fececc3, 0xe15f5fbe, 0xa2979735, 0xcc444488, \n     0x3917172e, 0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a, \n     0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6, 0xa06060c0, \n     0x98818119, 0xd14f4f9e, 0x7fdcdca3, 0x66222244, 0x7e2a2a54, \n     0xab90903b, 0x8388880b, 0xca46468c, 0x29eeeec7, 0xd3b8b86b, \n     0x3c141428, 0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad, \n     0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14, 0xdb494992, \n     0x0a06060c, 0x6c242448, 0xe45c5cb8, 0x5dc2c29f, 0x6ed3d3bd, \n     0xefacac43, 0xa66262c4, 0xa8919139, 0xa4959531, 0x37e4e4d3, \n     0x8b7979f2, 0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda, \n     0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949, 0xb46c6cd8, \n     0xfa5656ac, 0x07f4f4f3, 0x25eaeacf, 0xaf6565ca, 0x8e7a7af4, \n     0xe9aeae47, 0x18080810, 0xd5baba6f, 0x887878f0, 0x6f25254a, \n     0x722e2e5c, 0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697, \n     0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e, 0xdd4b4b96, \n     0xdcbdbd61, 0x868b8b0d, 0x858a8a0f, 0x907070e0, 0x423e3e7c, \n     0xc4b5b571, 0xaa6666cc, 0xd8484890, 0x05030306, 0x01f6f6f7, \n     0x120e0e1c, 0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969, \n     0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27, 0x38e1e1d9, \n     0x13f8f8eb, 0xb398982b, 0x33111122, 0xbb6969d2, 0x70d9d9a9, \n     0x898e8e07, 0xa7949433, 0xb69b9b2d, 0x221e1e3c, 0x92878715, \n     0x20e9e9c9, 0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5, \n     0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a, 0xdabfbf65, \n     0x31e6e6d7, 0xc6424284, 0xb86868d0, 0xc3414182, 0xb0999929, \n     0x772d2d5a, 0x110f0f1e, 0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, \n     0x3a16162c};\n\nprivate static final int[] Tinv0 =\n    {\n     0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, \n     0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, \n     0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, \n     0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, \n     0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, \n     0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, \n     0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, \n     0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, \n     0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, \n     0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, \n     0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, \n     0x2aab5566, 0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3, \n     0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, \n     0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, \n     0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, \n     0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd, \n     0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, \n     0x055dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, \n     0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, \n     0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000, \n     0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, \n     0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, \n     0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0x0fe75793, 0xd296eeb4, \n     0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, \n     0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0x0b0d090e, \n     0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, \n     0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, \n     0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, \n     0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, \n     0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, \n     0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, \n     0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, \n     0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, \n     0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0x0d927850, \n     0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, \n     0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, \n     0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x097826cd, \n     0xf418596e, 0x01b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, \n     0x08cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, \n     0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, \n     0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, \n     0xf7daec41, 0x0e50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, \n     0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, \n     0x7f516546, 0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, \n     0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, \n     0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, \n     0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, \n     0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, \n     0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, \n     0x0c25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, \n     0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, \n     0x4257b8d0};\n\n    private static int shift(int r, int shift)\n    {\n        return (r >>> shift) | (r << -shift);\n    }\n\n    /* multiply four bytes in GF(2^8) by 'x' {02} in parallel */\n\n    private static final int m1 = 0x80808080;\n    private static final int m2 = 0x7f7f7f7f;\n    private static final int m3 = 0x0000001b;\n    private static final int m4 = 0xC0C0C0C0;\n    private static final int m5 = 0x3f3f3f3f;\n\n    private static int FFmulX(int x)\n    {\n        return (((x & m2) << 1) ^ (((x & m1) >>> 7) * m3));\n    }\n\n    private static int FFmulX2(int x)\n    {\n        int t0  = (x & m5) << 2;\n        int t1  = (x & m4);\n            t1 ^= (t1 >>> 1);\n        return t0 ^ (t1 >>> 2) ^ (t1 >>> 5);\n    }\n\n    /* \n       The following defines provide alternative definitions of FFmulX that might\n       give improved performance if a fast 32-bit multiply is not available.\n       \n       private int FFmulX(int x) { int u = x & m1; u |= (u >> 1); return ((x & m2) << 1) ^ ((u >>> 3) | (u >>> 6)); } \n       private static final int  m4 = 0x1b1b1b1b;\n       private int FFmulX(int x) { int u = x & m1; return ((x & m2) << 1) ^ ((u - (u >>> 7)) & m4); } \n\n    */\n\n    private static int inv_mcol(int x)\n    {\n        int t0, t1;\n        t0  = x;\n        t1  = t0 ^ shift(t0, 8);\n        t0 ^= FFmulX(t1);\n        t1 ^= FFmulX2(t0);\n        t0 ^= t1 ^ shift(t1, 16);\n        return t0;\n    }\n\n    private static int subWord(int x)\n    {\n        return (S[x&255]&255 | ((S[(x>>8)&255]&255)<<8) | ((S[(x>>16)&255]&255)<<16) | S[(x>>24)&255]<<24);\n    }\n\n    /**\n     * Calculate the necessary round keys\n     * The number of calculations depends on key size and block size\n     * AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits\n     * This code is written assuming those are the only possible values\n     */\n    private int[][] generateWorkingKey(byte[] key, boolean forEncryption)\n    {\n        int keyLen = key.length;\n        if (keyLen < 16 || keyLen > 32 || (keyLen & 7) != 0)\n        {\n            throw new IllegalArgumentException(\"Key length not 128/192/256 bits.\");\n        }\n\n        int KC = keyLen >>> 2;\n        ROUNDS = KC + 6;  // This is not always true for the generalized Rijndael that allows larger block sizes\n        int[][] W = new int[ROUNDS+1][4];   // 4 words in a block\n\n        switch (KC)\n        {\n        case 4:\n        {\n            int t0 = Pack.littleEndianToInt(key,  0); W[0][0] = t0;\n            int t1 = Pack.littleEndianToInt(key,  4); W[0][1] = t1;\n            int t2 = Pack.littleEndianToInt(key,  8); W[0][2] = t2;\n            int t3 = Pack.littleEndianToInt(key, 12); W[0][3] = t3;\n\n            for (int i = 1; i <= 10; ++i)\n            {\n                int u = subWord(shift(t3, 8)) ^ rcon[i - 1];\n                t0 ^= u;  W[i][0] = t0;\n                t1 ^= t0; W[i][1] = t1;\n                t2 ^= t1; W[i][2] = t2;\n                t3 ^= t2; W[i][3] = t3;\n            }\n\n            break;\n        }\n        case 6:\n        {\n            int t0 = Pack.littleEndianToInt(key,  0); W[0][0] = t0;\n            int t1 = Pack.littleEndianToInt(key,  4); W[0][1] = t1;\n            int t2 = Pack.littleEndianToInt(key,  8); W[0][2] = t2;\n            int t3 = Pack.littleEndianToInt(key, 12); W[0][3] = t3;\n            int t4 = Pack.littleEndianToInt(key, 16); W[1][0] = t4;\n            int t5 = Pack.littleEndianToInt(key, 20); W[1][1] = t5;\n\n            int rcon = 1;\n            int u = subWord(shift(t5, 8)) ^ rcon; rcon <<= 1;\n            t0 ^= u;  W[1][2] = t0;\n            t1 ^= t0; W[1][3] = t1;\n            t2 ^= t1; W[2][0] = t2;\n            t3 ^= t2; W[2][1] = t3;\n            t4 ^= t3; W[2][2] = t4;\n            t5 ^= t4; W[2][3] = t5;\n\n            for (int i = 3; i < 12; i += 3)\n            {\n                u = subWord(shift(t5, 8)) ^ rcon; rcon <<= 1;\n                t0 ^= u;  W[i    ][0] = t0;\n                t1 ^= t0; W[i    ][1] = t1;\n                t2 ^= t1; W[i    ][2] = t2;\n                t3 ^= t2; W[i    ][3] = t3;\n                t4 ^= t3; W[i + 1][0] = t4;\n                t5 ^= t4; W[i + 1][1] = t5;\n                u = subWord(shift(t5, 8)) ^ rcon; rcon <<= 1;\n                t0 ^= u;  W[i + 1][2] = t0;\n                t1 ^= t0; W[i + 1][3] = t1;\n                t2 ^= t1; W[i + 2][0] = t2;\n                t3 ^= t2; W[i + 2][1] = t3;\n                t4 ^= t3; W[i + 2][2] = t4;\n                t5 ^= t4; W[i + 2][3] = t5;\n            }\n\n            u = subWord(shift(t5, 8)) ^ rcon;\n            t0 ^= u;  W[12][0] = t0;\n            t1 ^= t0; W[12][1] = t1;\n            t2 ^= t1; W[12][2] = t2;\n            t3 ^= t2; W[12][3] = t3;\n\n            break;\n        }\n        case 8:\n        {\n            int t0 = Pack.littleEndianToInt(key,  0); W[0][0] = t0;\n            int t1 = Pack.littleEndianToInt(key,  4); W[0][1] = t1;\n            int t2 = Pack.littleEndianToInt(key,  8); W[0][2] = t2;\n            int t3 = Pack.littleEndianToInt(key, 12); W[0][3] = t3;\n            int t4 = Pack.littleEndianToInt(key, 16); W[1][0] = t4;\n            int t5 = Pack.littleEndianToInt(key, 20); W[1][1] = t5;\n            int t6 = Pack.littleEndianToInt(key, 24); W[1][2] = t6;\n            int t7 = Pack.littleEndianToInt(key, 28); W[1][3] = t7;\n\n            int u, rcon = 1;\n\n            for (int i = 2; i < 14; i += 2)\n            {\n                u = subWord(shift(t7, 8)) ^ rcon; rcon <<= 1;\n                t0 ^= u;  W[i    ][0] = t0;\n                t1 ^= t0; W[i    ][1] = t1;\n                t2 ^= t1; W[i    ][2] = t2;\n                t3 ^= t2; W[i    ][3] = t3;\n                u = subWord(t3);\n                t4 ^= u;  W[i + 1][0] = t4;\n                t5 ^= t4; W[i + 1][1] = t5;\n                t6 ^= t5; W[i + 1][2] = t6;\n                t7 ^= t6; W[i + 1][3] = t7;\n            }\n\n            u = subWord(shift(t7, 8)) ^ rcon;\n            t0 ^= u;  W[14][0] = t0;\n            t1 ^= t0; W[14][1] = t1;\n            t2 ^= t1; W[14][2] = t2;\n            t3 ^= t2; W[14][3] = t3;\n\n            break;\n        }\n        default:\n        {\n            throw new IllegalStateException(\"Should never get here\");\n        }\n        }\n\n        if (!forEncryption)\n        {\n            for (int j = 1; j < ROUNDS; j++)\n            {\n                for (int i = 0; i < 4; i++)\n                {\n                    W[j][i] = inv_mcol(W[j][i]);\n                }\n            }\n        }\n\n        return W;\n    }\n\n    private int         ROUNDS;\n    private int[][]     WorkingKey = null;\n    private int         C0, C1, C2, C3;\n    private boolean     forEncryption;\n\n    private static final int BLOCK_SIZE = 16;\n\n    /**\n     * default constructor - 128 bit block size.\n     */\n    public AESEngine()\n    {\n    }\n\n    /**\n     * initialise an AES cipher.\n     *\n     * @param forEncryption whether or not we are for encryption.\n     * @param params the parameters required to set up the cipher.\n     * @exception IllegalArgumentException if the params argument is\n     * inappropriate.\n     */\n    public void init(\n        boolean           forEncryption,\n        CipherParameters  params)\n    {\n        if (params instanceof KeyParameter)\n        {\n            WorkingKey = generateWorkingKey(((KeyParameter)params).getKey(), forEncryption);\n            this.forEncryption = forEncryption;\n            return;\n        }\n\n        throw new IllegalArgumentException(\"invalid parameter passed to AES init - \" + params.getClass().getName());\n    }\n\n    public String getAlgorithmName()\n    {\n        return \"AES\";\n    }\n\n    public int getBlockSize()\n    {\n        return BLOCK_SIZE;\n    }\n\n    public int processBlock(\n        byte[] in,\n        int inOff,\n        byte[] out,\n        int outOff)\n    {\n        if (WorkingKey == null)\n        {\n            throw new IllegalStateException(\"AES engine not initialised\");\n        }\n\n        if ((inOff + (32 / 2)) > in.length)\n        {\n            throw new DataLengthException(\"input buffer too short\");\n        }\n\n        if ((outOff + (32 / 2)) > out.length)\n        {\n            throw new OutputLengthException(\"output buffer too short\");\n        }\n\n        if (forEncryption)\n        {\n            unpackBlock(in, inOff);\n            encryptBlock(WorkingKey);\n            packBlock(out, outOff);\n        }\n        else\n        {\n            unpackBlock(in, inOff);\n            decryptBlock(WorkingKey);\n            packBlock(out, outOff);\n        }\n\n        return BLOCK_SIZE;\n    }\n\n    public void reset()\n    {\n    }\n\n    private void unpackBlock(\n        byte[]      bytes,\n        int         off)\n    {\n        int     index = off;\n\n        C0 = (bytes[index++] & 0xff);\n        C0 |= (bytes[index++] & 0xff) << 8;\n        C0 |= (bytes[index++] & 0xff) << 16;\n        C0 |= bytes[index++] << 24;\n\n        C1 = (bytes[index++] & 0xff);\n        C1 |= (bytes[index++] & 0xff) << 8;\n        C1 |= (bytes[index++] & 0xff) << 16;\n        C1 |= bytes[index++] << 24;\n\n        C2 = (bytes[index++] & 0xff);\n        C2 |= (bytes[index++] & 0xff) << 8;\n        C2 |= (bytes[index++] & 0xff) << 16;\n        C2 |= bytes[index++] << 24;\n\n        C3 = (bytes[index++] & 0xff);\n        C3 |= (bytes[index++] & 0xff) << 8;\n        C3 |= (bytes[index++] & 0xff) << 16;\n        C3 |= bytes[index++] << 24;\n    }\n\n    private void packBlock(\n        byte[]      bytes,\n        int         off)\n    {\n        int     index = off;\n\n        bytes[index++] = (byte)C0;\n        bytes[index++] = (byte)(C0 >> 8);\n        bytes[index++] = (byte)(C0 >> 16);\n        bytes[index++] = (byte)(C0 >> 24);\n\n        bytes[index++] = (byte)C1;\n        bytes[index++] = (byte)(C1 >> 8);\n        bytes[index++] = (byte)(C1 >> 16);\n        bytes[index++] = (byte)(C1 >> 24);\n\n        bytes[index++] = (byte)C2;\n        bytes[index++] = (byte)(C2 >> 8);\n        bytes[index++] = (byte)(C2 >> 16);\n        bytes[index++] = (byte)(C2 >> 24);\n\n        bytes[index++] = (byte)C3;\n        bytes[index++] = (byte)(C3 >> 8);\n        bytes[index++] = (byte)(C3 >> 16);\n        bytes[index++] = (byte)(C3 >> 24);\n    }\n\n\n    private void encryptBlock(int[][] KW)\n    {\n        int t0 = this.C0 ^ KW[0][0];\n        int t1 = this.C1 ^ KW[0][1];\n        int t2 = this.C2 ^ KW[0][2];\n\n        int r = 1, r0, r1, r2, r3 = this.C3 ^ KW[0][3];\n        while (r < ROUNDS - 1)\n        {\n            r0 = T0[t0&255] ^ shift(T0[(t1>>8)&255], 24) ^ shift(T0[(t2>>16)&255], 16) ^ shift(T0[(r3>>24)&255], 8) ^ KW[r][0];\n            r1 = T0[t1&255] ^ shift(T0[(t2>>8)&255], 24) ^ shift(T0[(r3>>16)&255], 16) ^ shift(T0[(t0>>24)&255], 8) ^ KW[r][1];\n            r2 = T0[t2&255] ^ shift(T0[(r3>>8)&255], 24) ^ shift(T0[(t0>>16)&255], 16) ^ shift(T0[(t1>>24)&255], 8) ^ KW[r][2];\n            r3 = T0[r3&255] ^ shift(T0[(t0>>8)&255], 24) ^ shift(T0[(t1>>16)&255], 16) ^ shift(T0[(t2>>24)&255], 8) ^ KW[r++][3];\n            t0 = T0[r0&255] ^ shift(T0[(r1>>8)&255], 24) ^ shift(T0[(r2>>16)&255], 16) ^ shift(T0[(r3>>24)&255], 8) ^ KW[r][0];\n            t1 = T0[r1&255] ^ shift(T0[(r2>>8)&255], 24) ^ shift(T0[(r3>>16)&255], 16) ^ shift(T0[(r0>>24)&255], 8) ^ KW[r][1];\n            t2 = T0[r2&255] ^ shift(T0[(r3>>8)&255], 24) ^ shift(T0[(r0>>16)&255], 16) ^ shift(T0[(r1>>24)&255], 8) ^ KW[r][2];\n            r3 = T0[r3&255] ^ shift(T0[(r0>>8)&255], 24) ^ shift(T0[(r1>>16)&255], 16) ^ shift(T0[(r2>>24)&255], 8) ^ KW[r++][3];\n        }\n\n        r0 = T0[t0&255] ^ shift(T0[(t1>>8)&255], 24) ^ shift(T0[(t2>>16)&255], 16) ^ shift(T0[(r3>>24)&255], 8) ^ KW[r][0];\n        r1 = T0[t1&255] ^ shift(T0[(t2>>8)&255], 24) ^ shift(T0[(r3>>16)&255], 16) ^ shift(T0[(t0>>24)&255], 8) ^ KW[r][1];\n        r2 = T0[t2&255] ^ shift(T0[(r3>>8)&255], 24) ^ shift(T0[(t0>>16)&255], 16) ^ shift(T0[(t1>>24)&255], 8) ^ KW[r][2];\n        r3 = T0[r3&255] ^ shift(T0[(t0>>8)&255], 24) ^ shift(T0[(t1>>16)&255], 16) ^ shift(T0[(t2>>24)&255], 8) ^ KW[r++][3];\n\n        // the final round's table is a simple function of S so we don't use a whole other four tables for it\n\n        this.C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((S[(r2>>16)&255]&255)<<16) ^ (S[(r3>>24)&255]<<24) ^ KW[r][0];\n        this.C1 = (S[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (S[(r0>>24)&255]<<24) ^ KW[r][1];\n        this.C2 = (S[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2];\n        this.C3 = (S[r3&255]&255) ^ ((S[(r0>>8)&255]&255)<<8) ^ ((S[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3];\n    }\n\n    private void decryptBlock(int[][] KW)\n    {\n        int t0 = this.C0 ^ KW[ROUNDS][0];\n        int t1 = this.C1 ^ KW[ROUNDS][1];\n        int t2 = this.C2 ^ KW[ROUNDS][2];\n\n        int r = ROUNDS - 1, r0, r1, r2, r3 = this.C3 ^ KW[ROUNDS][3];\n        while (r > 1)\n        {\n            r0 = Tinv0[t0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(t2>>16)&255], 16) ^ shift(Tinv0[(t1>>24)&255], 8) ^ KW[r][0];\n            r1 = Tinv0[t1&255] ^ shift(Tinv0[(t0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(t2>>24)&255], 8) ^ KW[r][1];\n            r2 = Tinv0[t2&255] ^ shift(Tinv0[(t1>>8)&255], 24) ^ shift(Tinv0[(t0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];\n            r3 = Tinv0[r3&255] ^ shift(Tinv0[(t2>>8)&255], 24) ^ shift(Tinv0[(t1>>16)&255], 16) ^ shift(Tinv0[(t0>>24)&255], 8) ^ KW[r--][3];\n            t0 = Tinv0[r0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(r2>>16)&255], 16) ^ shift(Tinv0[(r1>>24)&255], 8) ^ KW[r][0];\n            t1 = Tinv0[r1&255] ^ shift(Tinv0[(r0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(r2>>24)&255], 8) ^ KW[r][1];\n            t2 = Tinv0[r2&255] ^ shift(Tinv0[(r1>>8)&255], 24) ^ shift(Tinv0[(r0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];\n            r3 = Tinv0[r3&255] ^ shift(Tinv0[(r2>>8)&255], 24) ^ shift(Tinv0[(r1>>16)&255], 16) ^ shift(Tinv0[(r0>>24)&255], 8) ^ KW[r--][3];\n        }\n\n        r0 = Tinv0[t0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(t2>>16)&255], 16) ^ shift(Tinv0[(t1>>24)&255], 8) ^ KW[r][0];\n        r1 = Tinv0[t1&255] ^ shift(Tinv0[(t0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(t2>>24)&255], 8) ^ KW[r][1];\n        r2 = Tinv0[t2&255] ^ shift(Tinv0[(t1>>8)&255], 24) ^ shift(Tinv0[(t0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];\n        r3 = Tinv0[r3&255] ^ shift(Tinv0[(t2>>8)&255], 24) ^ shift(Tinv0[(t1>>16)&255], 16) ^ shift(Tinv0[(t0>>24)&255], 8) ^ KW[r][3];\n        \n        // the final round's table is a simple function of Si so we don't use a whole other four tables for it\n\n        this.C0 = (Si[r0&255]&255) ^ ((Si[(r3>>8)&255]&255)<<8) ^ ((Si[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];\n        this.C1 = (Si[r1&255]&255) ^ ((Si[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (Si[(r2>>24)&255]<<24) ^ KW[0][1];\n        this.C2 = (Si[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (Si[(r3>>24)&255]<<24) ^ KW[0][2];\n        this.C3 = (Si[r3&255]&255) ^ ((Si[(r2>>8)&255]&255)<<8) ^ ((Si[(r1>>16)&255]&255)<<16) ^ (Si[(r0>>24)&255]<<24) ^ KW[0][3];\n    }\n}\n", "package org.bouncycastle.crypto.params;\n\nimport java.math.BigInteger;\n\npublic class DHPublicKeyParameters\n    extends DHKeyParameters\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private BigInteger      y;\n\n    public DHPublicKeyParameters(\n        BigInteger      y,\n        DHParameters    params)\n    {\n        super(false, params);\n\n        this.y = validate(y, params);\n    }   \n\n    private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            // TLS check\n            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n            {\n                throw new IllegalArgumentException(\"invalid DH public key\");\n            }\n\n            return y;         // we can't validate without Q.\n        }\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    public int hashCode()\n    {\n        return y.hashCode() ^ super.hashCode();\n    }\n\n    public boolean equals(\n        Object  obj)\n    {\n        if (!(obj instanceof DHPublicKeyParameters))\n        {\n            return false;\n        }\n\n        DHPublicKeyParameters   other = (DHPublicKeyParameters)obj;\n\n        return other.getY().equals(y) && super.equals(obj);\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\n\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\nimport javax.crypto.spec.DHPublicKeySpec;\n\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.pkcs.DHParameter;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.DHDomainParameters;\nimport org.bouncycastle.asn1.x9.DomainParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.KeyUtil;\n\npublic class BCDHPublicKey\n    implements DHPublicKey\n{\n    static final long serialVersionUID = -216691575254424324L;\n    \n    private BigInteger              y;\n\n    private transient DHParameterSpec         dhSpec;\n    private transient SubjectPublicKeyInfo    info;\n    \n    BCDHPublicKey(\n        DHPublicKeySpec spec)\n    {\n        this.y = spec.getY();\n        this.dhSpec = new DHParameterSpec(spec.getP(), spec.getG());\n    }\n\n    BCDHPublicKey(\n        DHPublicKey key)\n    {\n        this.y = key.getY();\n        this.dhSpec = key.getParams();\n    }\n\n    BCDHPublicKey(\n        DHPublicKeyParameters params)\n    {\n        this.y = params.getY();\n        this.dhSpec = new DHParameterSpec(params.getParameters().getP(), params.getParameters().getG(), params.getParameters().getL());\n    }\n\n    BCDHPublicKey(\n        BigInteger y,\n        DHParameterSpec dhSpec)\n    {\n        this.y = y;\n        this.dhSpec = dhSpec;\n    }\n\n    public BCDHPublicKey(\n        SubjectPublicKeyInfo info)\n    {\n        this.info = info;\n\n        ASN1Integer              derY;\n        try\n        {\n            derY = (ASN1Integer)info.parsePublicKey();\n        }\n        catch (IOException e)\n        {\n            throw new IllegalArgumentException(\"invalid info structure in DH public key\");\n        }\n\n        this.y = derY.getValue();\n\n        ASN1Sequence seq = ASN1Sequence.getInstance(info.getAlgorithm().getParameters());\n        ASN1ObjectIdentifier id = info.getAlgorithm().getAlgorithm();\n\n        // we need the PKCS check to handle older keys marked with the X9 oid.\n        if (id.equals(PKCSObjectIdentifiers.dhKeyAgreement) || isPKCSParam(seq))\n        {\n            DHParameter             params = DHParameter.getInstance(seq);\n\n            if (params.getL() != null)\n            {\n                this.dhSpec = new DHParameterSpec(params.getP(), params.getG(), params.getL().intValue());\n            }\n            else\n            {\n                this.dhSpec = new DHParameterSpec(params.getP(), params.getG());\n            }\n        }\n        else if (id.equals(X9ObjectIdentifiers.dhpublicnumber))\n        {\n            DomainParameters params = DomainParameters.getInstance(seq);\n\n            this.dhSpec = new DHParameterSpec(params.getP(), params.getG());\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"unknown algorithm type: \" + id);\n        }\n    }\n\n    public String getAlgorithm()\n    {\n        return \"DH\";\n    }\n\n    public String getFormat()\n    {\n        return \"X.509\";\n    }\n\n    public byte[] getEncoded()\n    {\n        if (info != null)\n        {\n            return KeyUtil.getEncodedSubjectPublicKeyInfo(info);\n        }\n\n        return KeyUtil.getEncodedSubjectPublicKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.dhKeyAgreement, new DHParameter(dhSpec.getP(), dhSpec.getG(), dhSpec.getL()).toASN1Primitive()), new ASN1Integer(y));\n    }\n\n    public DHParameterSpec getParams()\n    {\n        return dhSpec;\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    private boolean isPKCSParam(ASN1Sequence seq)\n    {\n        if (seq.size() == 2)\n        {\n            return true;\n        }\n        \n        if (seq.size() > 3)\n        {\n            return false;\n        }\n\n        ASN1Integer l = ASN1Integer.getInstance(seq.getObjectAt(2));\n        ASN1Integer p = ASN1Integer.getInstance(seq.getObjectAt(0));\n\n        if (l.getValue().compareTo(BigInteger.valueOf(p.getValue().bitLength())) > 0)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode()\n    {\n        return this.getY().hashCode() ^ this.getParams().getG().hashCode()\n                ^ this.getParams().getP().hashCode() ^ this.getParams().getL();\n    }\n\n    public boolean equals(\n        Object o)\n    {\n        if (!(o instanceof DHPublicKey))\n        {\n            return false;\n        }\n\n        DHPublicKey other = (DHPublicKey)o;\n\n        return this.getY().equals(other.getY())\n            && this.getParams().getG().equals(other.getParams().getG())\n            && this.getParams().getP().equals(other.getParams().getP())\n            && this.getParams().getL() == other.getParams().getL();\n    }\n\n    private void readObject(\n        ObjectInputStream   in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n\n        this.dhSpec = new DHParameterSpec((BigInteger)in.readObject(), (BigInteger)in.readObject(), in.readInt());\n        this.info = null;\n    }\n\n    private void writeObject(\n        ObjectOutputStream  out)\n        throws IOException\n    {\n        out.defaultWriteObject();\n\n        out.writeObject(dhSpec.getP());\n        out.writeObject(dhSpec.getG());\n        out.writeInt(dhSpec.getL());\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHPrivateKeySpec;\nimport javax.crypto.spec.DHPublicKeySpec;\n\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.BaseKeyFactorySpi;\n\npublic class KeyFactorySpi\n    extends BaseKeyFactorySpi\n{\n    public KeyFactorySpi()\n    {\n    }\n\n    protected KeySpec engineGetKeySpec(\n        Key key,\n        Class spec)\n        throws InvalidKeySpecException\n    {\n        if (spec.isAssignableFrom(DHPrivateKeySpec.class) && key instanceof DHPrivateKey)\n        {\n            DHPrivateKey k = (DHPrivateKey)key;\n\n            return new DHPrivateKeySpec(k.getX(), k.getParams().getP(), k.getParams().getG());\n        }\n        else if (spec.isAssignableFrom(DHPublicKeySpec.class) && key instanceof DHPublicKey)\n        {\n            DHPublicKey k = (DHPublicKey)key;\n\n            return new DHPublicKeySpec(k.getY(), k.getParams().getP(), k.getParams().getG());\n        }\n\n        return super.engineGetKeySpec(key, spec);\n    }\n\n    protected Key engineTranslateKey(\n        Key key)\n        throws InvalidKeyException\n    {\n        if (key instanceof DHPublicKey)\n        {\n            return new BCDHPublicKey((DHPublicKey)key);\n        }\n        else if (key instanceof DHPrivateKey)\n        {\n            return new BCDHPrivateKey((DHPrivateKey)key);\n        }\n\n        throw new InvalidKeyException(\"key type unknown\");\n    }\n\n    protected PrivateKey engineGeneratePrivate(\n        KeySpec keySpec)\n        throws InvalidKeySpecException\n    {\n        if (keySpec instanceof DHPrivateKeySpec)\n        {\n            return new BCDHPrivateKey((DHPrivateKeySpec)keySpec);\n        }\n\n        return super.engineGeneratePrivate(keySpec);\n    }\n\n    protected PublicKey engineGeneratePublic(\n        KeySpec keySpec)\n        throws InvalidKeySpecException\n    {\n        if (keySpec instanceof DHPublicKeySpec)\n        {\n            return new BCDHPublicKey((DHPublicKeySpec)keySpec);\n        }\n\n        return super.engineGeneratePublic(keySpec);\n    }\n\n    public PrivateKey generatePrivate(PrivateKeyInfo keyInfo)\n        throws IOException\n    {\n        ASN1ObjectIdentifier algOid = keyInfo.getPrivateKeyAlgorithm().getAlgorithm();\n\n        if (algOid.equals(PKCSObjectIdentifiers.dhKeyAgreement))\n        {\n            return new BCDHPrivateKey(keyInfo);\n        }\n        else if (algOid.equals(X9ObjectIdentifiers.dhpublicnumber))\n        {\n            return new BCDHPrivateKey(keyInfo);\n        }\n        else\n        {\n            throw new IOException(\"algorithm identifier \" + algOid + \" in key not recognised\");\n        }\n    }\n\n    public PublicKey generatePublic(SubjectPublicKeyInfo keyInfo)\n        throws IOException\n    {\n        ASN1ObjectIdentifier algOid = keyInfo.getAlgorithm().getAlgorithm();\n\n        if (algOid.equals(PKCSObjectIdentifiers.dhKeyAgreement))\n        {\n            return new BCDHPublicKey(keyInfo);\n        }\n        else if (algOid.equals(X9ObjectIdentifiers.dhpublicnumber))\n        {\n            return new BCDHPublicKey(keyInfo);\n        }\n        else\n        {\n            throw new IOException(\"algorithm identifier \" + algOid + \" in key not recognised\");\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ec;\n\nimport java.io.ByteArrayOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyEncoder;\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.AESFastEngine;\nimport org.bouncycastle.crypto.engines.DESedeEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.ECKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.params.ECKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.ECKeyParameters;\nimport org.bouncycastle.crypto.params.ECPublicKeyParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.crypto.parsers.ECIESPublicKeyParser;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\nimport org.bouncycastle.jcajce.provider.util.BadBlockException;\nimport org.bouncycastle.jcajce.util.BCJcaJceHelper;\nimport org.bouncycastle.jcajce.util.JcaJceHelper;\nimport org.bouncycastle.jce.interfaces.ECKey;\nimport org.bouncycastle.jce.interfaces.IESKey;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Strings;\n\n\npublic class IESCipher\n    extends CipherSpi\n{\n    private final JcaJceHelper helper = new BCJcaJceHelper();\n\n    private int ivLength;\n    private IESEngine engine;\n    private int state = -1;\n    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    private AlgorithmParameters engineParam = null;\n    private IESParameterSpec engineSpec = null;\n    private AsymmetricKeyParameter key;\n    private SecureRandom random;\n    private boolean dhaesMode = false;\n    private AsymmetricKeyParameter otherKeyParameter = null;\n\n    public IESCipher(IESEngine engine)\n    {\n        this.engine = engine;\n        this.ivLength = 0;\n    }\n\n    public IESCipher(IESEngine engine, int ivLength)\n    {\n        this.engine = engine;\n        this.ivLength = ivLength;\n    }\n\n    public int engineGetBlockSize()\n    {\n        if (engine.getCipher() != null)\n        {\n            return engine.getCipher().getBlockSize();\n        }\n        else\n        {\n            return 0;\n        }\n    }\n\n\n    public int engineGetKeySize(Key key)\n    {\n        if (key instanceof ECKey)\n        {\n            return ((ECKey)key).getParameters().getCurve().getFieldSize();\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"not an EC key\");\n        }\n    }\n\n\n    public byte[] engineGetIV()\n    {\n        if (engineSpec != null)\n        {\n            return engineSpec.getNonce();\n        }\n        return null;\n    }\n\n    public AlgorithmParameters engineGetParameters()\n    {\n        if (engineParam == null && engineSpec != null)\n        {\n            try\n            {\n                engineParam = helper.createAlgorithmParameters(\"IES\");\n                engineParam.init(engineSpec);\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.toString());\n            }\n        }\n\n        return engineParam;\n    }\n\n\n    public void engineSetMode(String mode)\n        throws NoSuchAlgorithmException\n    {\n        String modeName = Strings.toUpperCase(mode);\n\n        if (modeName.equals(\"NONE\"))\n        {\n            dhaesMode = false;\n        }\n        else if (modeName.equals(\"DHAES\"))\n        {\n            dhaesMode = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"can't support mode \" + mode);\n        }\n    }\n\n\n    public int engineGetOutputSize(int inputLen)\n    {\n        int len1, len2, len3;\n\n        if (key == null)\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        len1 = engine.getMac().getMacSize();\n\n        if (otherKeyParameter == null)\n        {\n            len2 = 2 * (((ECKeyParameters)key).getParameters().getCurve().getFieldSize() + 7) / 8;\n        }\n        else\n        {\n            len2 = 0;\n        }\n\n        if (engine.getCipher() == null)\n        {\n            len3 = inputLen;\n        }\n        else if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen);\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen - len1 - len2);\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            return buffer.size() + len1 + 1 + len2 + len3;\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            return buffer.size() - len1 - len2 + len3;\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public void engineSetPadding(String padding)\n        throws NoSuchPaddingException\n    {\n        String paddingName = Strings.toUpperCase(padding);\n\n        // TDOD: make this meaningful...\n        if (paddingName.equals(\"NOPADDING\"))\n        {\n\n        }\n        else if (paddingName.equals(\"PKCS5PADDING\") || paddingName.equals(\"PKCS7PADDING\"))\n        {\n\n        }\n        else\n        {\n            throw new NoSuchPaddingException(\"padding not available with IESCipher\");\n        }\n    }\n\n\n    // Initialisation methods\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameters params,\n        SecureRandom random)\n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        AlgorithmParameterSpec paramSpec = null;\n\n        if (params != null)\n        {\n            try\n            {\n                paramSpec = params.getParameterSpec(IESParameterSpec.class);\n            }\n            catch (Exception e)\n            {\n                throw new InvalidAlgorithmParameterException(\"cannot recognise parameters: \" + e.toString());\n            }\n        }\n\n        engineParam = params;\n        engineInit(opmode, key, paramSpec, random);\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameterSpec engineSpec,\n        SecureRandom random)\n        throws InvalidAlgorithmParameterException, InvalidKeyException\n    {\n        otherKeyParameter = null;\n\n        // Use default parameters (including cipher key size) if none are specified\n        if (engineSpec == null)\n        {\n            byte[] nonce = null;\n            if (ivLength != 0 && opmode == Cipher.ENCRYPT_MODE)\n            {\n                nonce = new byte[ivLength];\n                random.nextBytes(nonce);\n            }\n            this.engineSpec = IESUtil.guessParameterSpec(engine.getCipher(), nonce);\n        }\n        else if (engineSpec instanceof IESParameterSpec)\n        {\n            this.engineSpec = (IESParameterSpec)engineSpec;\n        }\n        else\n        {\n            throw new InvalidAlgorithmParameterException(\"must be passed IES parameters\");\n        }\n\n        byte[] nonce = this.engineSpec.getNonce();\n\n        if (ivLength != 0 && (nonce == null || nonce.length != ivLength))\n        {\n            throw new InvalidAlgorithmParameterException(\"NONCE in IES Parameters needs to be \" + ivLength + \" bytes long\");\n        }\n\n        // Parse the recipient's key\n        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE)\n        {\n            if (key instanceof PublicKey)\n            {\n                this.key = ECUtils.generatePublicKeyParameter((PublicKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.key = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.otherKeyParameter = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's public EC key for encryption\");\n            }\n        }\n        else if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE)\n        {\n            if (key instanceof PrivateKey)\n            {\n                this.key = ECUtil.generatePrivateKeyParameter((PrivateKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.otherKeyParameter = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.key = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's private EC key for decryption\");\n            }\n        }\n        else\n        {\n            throw new InvalidKeyException(\"must be passed EC key\");\n        }\n\n\n        this.random = random;\n        this.state = opmode;\n        buffer.reset();\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        SecureRandom random)\n        throws InvalidKeyException\n    {\n        try\n        {\n            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            throw new IllegalArgumentException(\"cannot handle supplied parameter spec: \" + e.getMessage());\n        }\n\n    }\n\n\n    // Update methods - buffer the input\n\n    public byte[] engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return null;\n    }\n\n\n    public int engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen,\n        byte[] output,\n        int outputOffset)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return 0;\n    }\n\n\n    // Finalisation methods\n\n    public byte[] engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (inputLen != 0)\n        {\n            buffer.write(input, inputOffset, inputLen);\n        }\n\n        final byte[] in = buffer.toByteArray();\n        buffer.reset();\n\n        // Convert parameters for use in IESEngine\n        CipherParameters params = new IESWithCipherParameters(engineSpec.getDerivationV(),\n            engineSpec.getEncodingV(),\n            engineSpec.getMacKeySize(),\n            engineSpec.getCipherKeySize());\n\n        if (engineSpec.getNonce() != null)\n        {\n            params = new ParametersWithIV(params, engineSpec.getNonce());\n        }\n\n        final ECDomainParameters ecParams = ((ECKeyParameters)key).getParameters();\n\n        final byte[] V;\n\n        if (otherKeyParameter != null)\n        {\n            try\n            {\n                if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n                {\n                    engine.init(true, otherKeyParameter, key, params);\n                }\n                else\n                {\n                    engine.init(false, key, otherKeyParameter, params);\n                }\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadBlockException(\"unable to process block\", e);\n            }\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            // Generate the ephemeral key pair\n            ECKeyPairGenerator gen = new ECKeyPairGenerator();\n            gen.init(new ECKeyGenerationParameters(ecParams, random));\n\n            final boolean usePointCompression = engineSpec.getPointCompression();\n            EphemeralKeyPairGenerator kGen = new EphemeralKeyPairGenerator(gen, new KeyEncoder()\n            {\n                public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n                {\n                    return ((ECPublicKeyParameters)keyParameter).getQ().getEncoded(usePointCompression);\n                }\n            });\n\n            // Encrypt the buffer\n            try\n            {\n                engine.init(key, params, kGen);\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (final Exception e)\n            {\n                throw new BadBlockException(\"unable to process block\", e);\n            }\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            // Decrypt the buffer\n            try\n            {\n                engine.init(key, params, new ECIESPublicKeyParser(ecParams));\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (InvalidCipherTextException e)\n            {\n                throw new BadBlockException(\"unable to process block\", e);\n            }\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public int engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLength,\n        byte[] output,\n        int outputOffset)\n        throws ShortBufferException, IllegalBlockSizeException, BadPaddingException\n    {\n\n        byte[] buf = engineDoFinal(input, inputOffset, inputLength);\n        System.arraycopy(buf, 0, output, outputOffset, buf.length);\n        return buf.length;\n    }\n\n    /**\n     * Classes that inherit from us\n     */\n\n    static public class ECIES\n        extends IESCipher\n    {\n        public ECIES()\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class ECIESwithCipher\n        extends IESCipher\n    {\n        public ECIESwithCipher(BlockCipher cipher, int ivLength)\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                            new KDF2BytesGenerator(new SHA1Digest()),\n                            new HMac(new SHA1Digest()),\n                            new PaddedBufferedBlockCipher(cipher)), ivLength);\n        }\n    }\n\n    static public class ECIESwithDESedeCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithDESedeCBC()\n        {\n            super(new CBCBlockCipher(new DESedeEngine()), 8);\n        }\n    }\n\n    static public class ECIESwithAESCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), 16);\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.util;\n\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\n\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\n\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\n\n/**\n * utility class for converting jce/jca DH objects\n * objects into their org.bouncycastle.crypto counterparts.\n */\npublic class DHUtil\n{\n    static public AsymmetricKeyParameter generatePublicKeyParameter(\n        PublicKey    key)\n        throws InvalidKeyException\n    {\n        if (key instanceof DHPublicKey)\n        {\n            DHPublicKey    k = (DHPublicKey)key;\n\n            return new DHPublicKeyParameters(k.getY(),\n                new DHParameters(k.getParams().getP(), k.getParams().getG(), null, k.getParams().getL()));\n        }\n\n        throw new InvalidKeyException(\"can't identify DH public key.\");\n    }\n\n    static public AsymmetricKeyParameter generatePrivateKeyParameter(\n        PrivateKey    key)\n        throws InvalidKeyException\n    {\n        if (key instanceof DHPrivateKey)\n        {\n            DHPrivateKey    k = (DHPrivateKey)key;\n\n            return new DHPrivateKeyParameters(k.getX(),\n                new DHParameters(k.getParams().getP(), k.getParams().getG(), null, k.getParams().getL()));\n        }\n                        \n        throw new InvalidKeyException(\"can't identify DH private key.\");\n    }\n}\n", "package org.bouncycastle.jcajce.provider.symmetric;\n\nimport java.io.IOException;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\n\nimport javax.crypto.spec.IvParameterSpec;\n\nimport org.bouncycastle.asn1.bc.BCObjectIdentifiers;\nimport org.bouncycastle.asn1.cms.CCMParameters;\nimport org.bouncycastle.asn1.cms.GCMParameters;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.crypto.CipherKeyGenerator;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DataLengthException;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.Mac;\nimport org.bouncycastle.crypto.engines.AESFastEngine;\nimport org.bouncycastle.crypto.engines.AESWrapEngine;\nimport org.bouncycastle.crypto.engines.RFC3211WrapEngine;\nimport org.bouncycastle.crypto.engines.RFC5649WrapEngine;\nimport org.bouncycastle.crypto.generators.Poly1305KeyGenerator;\nimport org.bouncycastle.crypto.macs.CMac;\nimport org.bouncycastle.crypto.macs.GMac;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.modes.CCMBlockCipher;\nimport org.bouncycastle.crypto.modes.CFBBlockCipher;\nimport org.bouncycastle.crypto.modes.GCMBlockCipher;\nimport org.bouncycastle.crypto.modes.OFBBlockCipher;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseAlgorithmParameterGenerator;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseAlgorithmParameters;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseKeyGenerator;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseMac;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseWrapCipher;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BlockCipherProvider;\nimport org.bouncycastle.jcajce.provider.symmetric.util.IvAlgorithmParameters;\nimport org.bouncycastle.jcajce.provider.symmetric.util.PBESecretKeyFactory;\nimport org.bouncycastle.jcajce.spec.AEADParameterSpec;\n\npublic final class AES\n{\n    private static final Class gcmSpecClass = lookup(\"javax.crypto.spec.GCMParameterSpec\");\n\n    private AES()\n    {\n    }\n    \n    public static class ECB\n        extends BaseBlockCipher\n    {\n        public ECB()\n        {\n            super(new BlockCipherProvider()\n            {\n                public BlockCipher get()\n                {\n                    return new AESFastEngine();\n                }\n            });\n        }\n    }\n\n    public static class CBC\n       extends BaseBlockCipher\n    {\n        public CBC()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), 128);\n        }\n    }\n\n    static public class CFB\n        extends BaseBlockCipher\n    {\n        public CFB()\n        {\n            super(new BufferedBlockCipher(new CFBBlockCipher(new AESFastEngine(), 128)), 128);\n        }\n    }\n\n    static public class OFB\n        extends BaseBlockCipher\n    {\n        public OFB()\n        {\n            super(new BufferedBlockCipher(new OFBBlockCipher(new AESFastEngine(), 128)), 128);\n        }\n    }\n\n    static public class GCM\n        extends BaseBlockCipher\n    {\n        public GCM()\n        {\n            super(new GCMBlockCipher(new AESFastEngine()));\n        }\n    }\n\n    static public class CCM\n        extends BaseBlockCipher\n    {\n        public CCM()\n        {\n            super(new CCMBlockCipher(new AESFastEngine()), false, 16);\n        }\n    }\n\n    public static class AESCMAC\n        extends BaseMac\n    {\n        public AESCMAC()\n        {\n            super(new CMac(new AESFastEngine()));\n        }\n    }\n\n    public static class AESGMAC\n        extends BaseMac\n    {\n        public AESGMAC()\n        {\n            super(new GMac(new GCMBlockCipher(new AESFastEngine())));\n        }\n    }\n\n    public static class AESCCMMAC\n        extends BaseMac\n    {\n        public AESCCMMAC()\n        {\n            super(new CCMMac());\n        }\n\n        private static class CCMMac\n            implements Mac\n        {\n            private final CCMBlockCipher ccm = new CCMBlockCipher(new AESFastEngine());\n\n            private int macLength = 8;\n\n            public void init(CipherParameters params)\n                throws IllegalArgumentException\n            {\n                ccm.init(true, params);\n\n                this.macLength = ccm.getMac().length;\n            }\n\n            public String getAlgorithmName()\n            {\n                return ccm.getAlgorithmName() + \"Mac\";\n            }\n\n            public int getMacSize()\n            {\n                return macLength;\n            }\n\n            public void update(byte in)\n                throws IllegalStateException\n            {\n                ccm.processAADByte(in);\n            }\n\n            public void update(byte[] in, int inOff, int len)\n                throws DataLengthException, IllegalStateException\n            {\n                ccm.processAADBytes(in, inOff, len);\n            }\n\n            public int doFinal(byte[] out, int outOff)\n                throws DataLengthException, IllegalStateException\n            {\n                try\n                {\n                    return ccm.doFinal(out, 0);\n                }\n                catch (InvalidCipherTextException e)\n                {\n                    throw new IllegalStateException(\"exception on doFinal()\", e);\n                }\n            }\n\n            public void reset()\n            {\n                ccm.reset();\n            }\n        }\n    }\n\n    public static class Poly1305\n        extends BaseMac\n    {\n        public Poly1305()\n        {\n            super(new org.bouncycastle.crypto.macs.Poly1305(new AESFastEngine()));\n        }\n    }\n\n    public static class Poly1305KeyGen\n        extends BaseKeyGenerator\n    {\n        public Poly1305KeyGen()\n        {\n            super(\"Poly1305-AES\", 256, new Poly1305KeyGenerator());\n        }\n    }\n\n    static public class Wrap\n        extends BaseWrapCipher\n    {\n        public Wrap()\n        {\n            super(new AESWrapEngine());\n        }\n    }\n\n    public static class RFC3211Wrap\n        extends BaseWrapCipher\n    {\n        public RFC3211Wrap()\n        {\n            super(new RFC3211WrapEngine(new AESFastEngine()), 16);\n        }\n    }\n\n    public static class RFC5649Wrap\n        extends BaseWrapCipher\n    {\n        public RFC5649Wrap()\n        {\n            super(new RFC5649WrapEngine(new AESFastEngine()));\n        }\n    }\n\n    /**\n     * PBEWithAES-CBC\n     */\n    static public class PBEWithAESCBC\n        extends BaseBlockCipher\n    {\n        public PBEWithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()));\n        }\n    }\n\n    /**\n     * PBEWithSHA1AES-CBC\n     */\n    static public class PBEWithSHA1AESCBC128\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA1AESCBC128()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 128, 16);\n        }\n    }\n\n    static public class PBEWithSHA1AESCBC192\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA1AESCBC192()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 192, 16);\n        }\n    }\n\n    static public class PBEWithSHA1AESCBC256\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA1AESCBC256()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA1, 256, 16);\n        }\n    }\n\n    /**\n     * PBEWithSHA256AES-CBC\n     */\n    static public class PBEWithSHA256AESCBC128\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA256AESCBC128()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 128, 16);\n        }\n    }\n\n    static public class PBEWithSHA256AESCBC192\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA256AESCBC192()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 192, 16);\n        }\n    }\n\n    static public class PBEWithSHA256AESCBC256\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA256AESCBC256()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), PKCS12, SHA256, 256, 16);\n        }\n    }\n\n    public static class KeyGen\n        extends BaseKeyGenerator\n    {\n        public KeyGen()\n        {\n            this(192);\n        }\n\n        public KeyGen(int keySize)\n        {\n            super(\"AES\", keySize, new CipherKeyGenerator());\n        }\n    }\n\n    public static class KeyGen128\n        extends KeyGen\n    {\n        public KeyGen128()\n        {\n            super(128);\n        }\n    }\n\n    public static class KeyGen192\n        extends KeyGen\n    {\n        public KeyGen192()\n        {\n            super(192);\n        }\n    }\n\n    public static class KeyGen256\n        extends KeyGen\n    {\n        public KeyGen256()\n        {\n            super(256);\n        }\n    }\n    \n    /**\n     * PBEWithSHA1And128BitAES-BC\n     */\n    static public class PBEWithSHAAnd128BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHAAnd128BitAESBC()\n        {\n            super(\"PBEWithSHA1And128BitAES-CBC-BC\", null, true, PKCS12, SHA1, 128, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA1And192BitAES-BC\n     */\n    static public class PBEWithSHAAnd192BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHAAnd192BitAESBC()\n        {\n            super(\"PBEWithSHA1And192BitAES-CBC-BC\", null, true, PKCS12, SHA1, 192, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA1And256BitAES-BC\n     */\n    static public class PBEWithSHAAnd256BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHAAnd256BitAESBC()\n        {\n            super(\"PBEWithSHA1And256BitAES-CBC-BC\", null, true, PKCS12, SHA1, 256, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA256And128BitAES-BC\n     */\n    static public class PBEWithSHA256And128BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHA256And128BitAESBC()\n        {\n            super(\"PBEWithSHA256And128BitAES-CBC-BC\", null, true, PKCS12, SHA256, 128, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA256And192BitAES-BC\n     */\n    static public class PBEWithSHA256And192BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHA256And192BitAESBC()\n        {\n            super(\"PBEWithSHA256And192BitAES-CBC-BC\", null, true, PKCS12, SHA256, 192, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA256And256BitAES-BC\n     */\n    static public class PBEWithSHA256And256BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHA256And256BitAESBC()\n        {\n            super(\"PBEWithSHA256And256BitAES-CBC-BC\", null, true, PKCS12, SHA256, 256, 128);\n        }\n    }\n    \n    /**\n     * PBEWithMD5And128BitAES-OpenSSL\n     */\n    static public class PBEWithMD5And128BitAESCBCOpenSSL\n        extends PBESecretKeyFactory\n    {\n        public PBEWithMD5And128BitAESCBCOpenSSL()\n        {\n            super(\"PBEWithMD5And128BitAES-CBC-OpenSSL\", null, true, OPENSSL, MD5, 128, 128);\n        }\n    }\n    \n    /**\n     * PBEWithMD5And192BitAES-OpenSSL\n     */\n    static public class PBEWithMD5And192BitAESCBCOpenSSL\n        extends PBESecretKeyFactory\n    {\n        public PBEWithMD5And192BitAESCBCOpenSSL()\n        {\n            super(\"PBEWithMD5And192BitAES-CBC-OpenSSL\", null, true, OPENSSL, MD5, 192, 128);\n        }\n    }\n    \n    /**\n     * PBEWithMD5And256BitAES-OpenSSL\n     */\n    static public class PBEWithMD5And256BitAESCBCOpenSSL\n        extends PBESecretKeyFactory\n    {\n        public PBEWithMD5And256BitAESCBCOpenSSL()\n        {\n            super(\"PBEWithMD5And256BitAES-CBC-OpenSSL\", null, true, OPENSSL, MD5, 256, 128);\n        }\n    }\n    \n    public static class AlgParamGen\n        extends BaseAlgorithmParameterGenerator\n    {\n        protected void engineInit(\n            AlgorithmParameterSpec genParamSpec,\n            SecureRandom random)\n            throws InvalidAlgorithmParameterException\n        {\n            throw new InvalidAlgorithmParameterException(\"No supported AlgorithmParameterSpec for AES parameter generation.\");\n        }\n\n        protected AlgorithmParameters engineGenerateParameters()\n        {\n            byte[]  iv = new byte[16];\n\n            if (random == null)\n            {\n                random = new SecureRandom();\n            }\n\n            random.nextBytes(iv);\n\n            AlgorithmParameters params;\n\n            try\n            {\n                params = createParametersInstance(\"AES\");\n                params.init(new IvParameterSpec(iv));\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.getMessage());\n            }\n\n            return params;\n        }\n    }\n\n    public static class AlgParamGenCCM\n        extends BaseAlgorithmParameterGenerator\n    {\n        protected void engineInit(\n            AlgorithmParameterSpec genParamSpec,\n            SecureRandom random)\n            throws InvalidAlgorithmParameterException\n        {\n            // TODO: add support for GCMParameterSpec as a template.\n            throw new InvalidAlgorithmParameterException(\"No supported AlgorithmParameterSpec for AES parameter generation.\");\n        }\n\n        protected AlgorithmParameters engineGenerateParameters()\n        {\n            byte[]  iv = new byte[12];\n\n            if (random == null)\n            {\n                random = new SecureRandom();\n            }\n\n            random.nextBytes(iv);\n\n            AlgorithmParameters params;\n\n            try\n            {\n                params = createParametersInstance(\"CCM\");\n                params.init(new CCMParameters(iv, 12).getEncoded());\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.getMessage());\n            }\n\n            return params;\n        }\n    }\n\n    public static class AlgParamGenGCM\n        extends BaseAlgorithmParameterGenerator\n    {\n        protected void engineInit(\n            AlgorithmParameterSpec genParamSpec,\n            SecureRandom random)\n            throws InvalidAlgorithmParameterException\n        {\n            // TODO: add support for GCMParameterSpec as a template.\n            throw new InvalidAlgorithmParameterException(\"No supported AlgorithmParameterSpec for AES parameter generation.\");\n        }\n\n        protected AlgorithmParameters engineGenerateParameters()\n        {\n            byte[]  nonce = new byte[12];\n\n            if (random == null)\n            {\n                random = new SecureRandom();\n            }\n\n            random.nextBytes(nonce);\n\n            AlgorithmParameters params;\n\n            try\n            {\n                params = createParametersInstance(\"GCM\");\n                params.init(new GCMParameters(nonce, 16).getEncoded());\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.getMessage());\n            }\n\n            return params;\n        }\n    }\n\n    public static class AlgParams\n        extends IvAlgorithmParameters\n    {\n        protected String engineToString()\n        {\n            return \"AES IV\";\n        }\n    }\n\n    public static class AlgParamsGCM\n        extends BaseAlgorithmParameters\n    {\n        private GCMParameters gcmParams;\n\n        protected void engineInit(AlgorithmParameterSpec paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                gcmParams = GcmSpecUtil.extractGcmParameters(paramSpec);\n            }\n            else if (paramSpec instanceof AEADParameterSpec)\n            {\n                gcmParams = new GCMParameters(((AEADParameterSpec)paramSpec).getNonce(), ((AEADParameterSpec)paramSpec).getMacSizeInBits() / 8);\n            }\n            else\n            {\n                throw new InvalidParameterSpecException(\"AlgorithmParameterSpec class not recognized: \" + paramSpec.getClass().getName());\n            }\n        }\n\n        protected void engineInit(byte[] params)\n            throws IOException\n        {\n            gcmParams = GCMParameters.getInstance(params);\n        }\n\n        protected void engineInit(byte[] params, String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            gcmParams = GCMParameters.getInstance(params);\n        }\n\n        protected byte[] engineGetEncoded()\n            throws IOException\n        {\n            return gcmParams.getEncoded();\n        }\n\n        protected byte[] engineGetEncoded(String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            return gcmParams.getEncoded();\n        }\n\n        protected String engineToString()\n        {\n            return \"GCM\";\n        }\n\n        protected AlgorithmParameterSpec localEngineGetParameterSpec(Class paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (paramSpec == AlgorithmParameterSpec.class || GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                if (GcmSpecUtil.gcmSpecExists())\n                {\n                    return GcmSpecUtil.extractGcmSpec(gcmParams.toASN1Primitive());\n                }\n                return new AEADParameterSpec(gcmParams.getNonce(), gcmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == AEADParameterSpec.class)\n            {\n                return new AEADParameterSpec(gcmParams.getNonce(), gcmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == IvParameterSpec.class)\n            {\n                return new IvParameterSpec(gcmParams.getNonce());\n            }\n\n            throw new InvalidParameterSpecException(\"AlgorithmParameterSpec not recognized: \" + paramSpec.getName());\n        }\n    }\n\n    public static class AlgParamsCCM\n        extends BaseAlgorithmParameters\n    {\n        private CCMParameters ccmParams;\n\n        protected void engineInit(AlgorithmParameterSpec paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                ccmParams = CCMParameters.getInstance(GcmSpecUtil.extractGcmParameters(paramSpec));\n            }\n            else if (paramSpec instanceof AEADParameterSpec)\n            {\n                ccmParams = new CCMParameters(((AEADParameterSpec)paramSpec).getNonce(), ((AEADParameterSpec)paramSpec).getMacSizeInBits() / 8);\n            }\n            else\n            {\n                throw new InvalidParameterSpecException(\"AlgorithmParameterSpec class not recognized: \" + paramSpec.getClass().getName());\n            }\n        }\n\n        protected void engineInit(byte[] params)\n            throws IOException\n        {\n            ccmParams = CCMParameters.getInstance(params);\n        }\n\n        protected void engineInit(byte[] params, String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            ccmParams = CCMParameters.getInstance(params);\n        }\n\n        protected byte[] engineGetEncoded()\n            throws IOException\n        {\n            return ccmParams.getEncoded();\n        }\n\n        protected byte[] engineGetEncoded(String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            return ccmParams.getEncoded();\n        }\n\n        protected String engineToString()\n        {\n            return \"CCM\";\n        }\n\n        protected AlgorithmParameterSpec localEngineGetParameterSpec(Class paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (paramSpec == AlgorithmParameterSpec.class || GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                if (GcmSpecUtil.gcmSpecExists())\n                {\n                    return GcmSpecUtil.extractGcmSpec(ccmParams.toASN1Primitive());\n                }\n                return new AEADParameterSpec(ccmParams.getNonce(), ccmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == AEADParameterSpec.class)\n            {\n                return new AEADParameterSpec(ccmParams.getNonce(), ccmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == IvParameterSpec.class)\n            {\n                return new IvParameterSpec(ccmParams.getNonce());\n            }\n\n            throw new InvalidParameterSpecException(\"AlgorithmParameterSpec not recognized: \" + paramSpec.getName());\n        }\n    }\n\n    public static class Mappings\n        extends SymmetricAlgorithmProvider\n    {\n        private static final String PREFIX = AES.class.getName();\n        \n        /**\n         * These three got introduced in some messages as a result of a typo in an\n         * early document. We don't produce anything using these OID values, but we'll\n         * read them.\n         */\n        private static final String wrongAES128 = \"2.16.840.1.101.3.4.2\";\n        private static final String wrongAES192 = \"2.16.840.1.101.3.4.22\";\n        private static final String wrongAES256 = \"2.16.840.1.101.3.4.42\";\n\n        public Mappings()\n        {\n        }\n\n        public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"AlgorithmParameters.AES\", PREFIX + \"$AlgParams\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + wrongAES128, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + wrongAES192, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + wrongAES256, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes128_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes192_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes256_CBC, \"AES\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.GCM\", PREFIX + \"$AlgParamsGCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes128_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes192_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes256_GCM, \"GCM\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.CCM\", PREFIX + \"$AlgParamsCCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes128_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes192_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes256_CCM, \"CCM\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.AES\", PREFIX + \"$AlgParamGen\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + wrongAES128, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + wrongAES192, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + wrongAES256, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes128_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes192_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes256_CBC, \"AES\");\n\n            provider.addAlgorithm(\"Cipher.AES\", PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.\" + wrongAES128, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.\" + wrongAES192, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.\" + wrongAES256, \"AES\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_ECB, PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_ECB, PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_ECB, PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_CBC, PREFIX + \"$CBC\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_CBC, PREFIX + \"$CBC\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_CBC, PREFIX + \"$CBC\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_OFB, PREFIX + \"$OFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_OFB, PREFIX + \"$OFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_OFB, PREFIX + \"$OFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_CFB, PREFIX + \"$CFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_CFB, PREFIX + \"$CFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_CFB, PREFIX + \"$CFB\");\n            provider.addAlgorithm(\"Cipher.AESWRAP\", PREFIX + \"$Wrap\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes128_wrap, \"AESWRAP\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes192_wrap, \"AESWRAP\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes256_wrap, \"AESWRAP\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.AESKW\", \"AESWRAP\");\n\n            provider.addAlgorithm(\"Cipher.AESRFC3211WRAP\", PREFIX + \"$RFC3211Wrap\");\n            provider.addAlgorithm(\"Cipher.AESRFC5649WRAP\", PREFIX + \"$RFC5649Wrap\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.CCM\", PREFIX + \"$AlgParamGenCCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes128_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes192_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes256_CCM, \"CCM\");\n\n            provider.addAlgorithm(\"Cipher.CCM\", PREFIX + \"$CCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes128_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes192_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes256_CCM, \"CCM\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.GCM\", PREFIX + \"$AlgParamGenGCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes128_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes192_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes256_GCM, \"GCM\");\n\n            provider.addAlgorithm(\"Cipher.GCM\", PREFIX + \"$GCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes128_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes192_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes256_GCM, \"GCM\");\n\n            provider.addAlgorithm(\"KeyGenerator.AES\", PREFIX + \"$KeyGen\");\n            provider.addAlgorithm(\"KeyGenerator.\" + wrongAES128, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator.\" + wrongAES192, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator.\" + wrongAES256, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_ECB, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_CBC, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_OFB, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_CFB, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_ECB, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_CBC, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_OFB, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_CFB, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_ECB, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_CBC, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_OFB, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_CFB, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator.AESWRAP\", PREFIX + \"$KeyGen\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_wrap, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_wrap, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_wrap, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_GCM, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_GCM, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_GCM, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_CCM, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_CCM, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_CCM, PREFIX + \"$KeyGen256\");\n\n            provider.addAlgorithm(\"Mac.AESCMAC\", PREFIX + \"$AESCMAC\");\n\n            provider.addAlgorithm(\"Mac.AESCCMMAC\", PREFIX + \"$AESCCMMAC\");\n            provider.addAlgorithm(\"Alg.Alias.Mac.\" + NISTObjectIdentifiers.id_aes128_CCM.getId(), \"AESCCMMAC\");\n            provider.addAlgorithm(\"Alg.Alias.Mac.\" + NISTObjectIdentifiers.id_aes192_CCM.getId(), \"AESCCMMAC\");\n            provider.addAlgorithm(\"Alg.Alias.Mac.\" + NISTObjectIdentifiers.id_aes256_CCM.getId(), \"AESCCMMAC\");\n\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc, \"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc, \"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc, \"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc, \"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc, \"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc, \"PBEWITHSHA256AND256BITAES-CBC-BC\");\n\n            provider.addAlgorithm(\"Cipher.PBEWITHSHAAND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA1AESCBC128\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHAAND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA1AESCBC192\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHAAND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA1AESCBC256\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHA256AND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256AESCBC128\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHA256AND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256AESCBC192\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHA256AND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256AESCBC256\");\n            \n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHAAND128BITAES-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHAAND192BITAES-BC\", \"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHAAND256BITAES-BC\", \"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND128BITAES-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND192BITAES-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND256BITAES-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND128BITAES-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND192BITAES-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND256BITAES-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND128BITAES-CBC-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND192BITAES-CBC-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND256BITAES-CBC-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA256AND128BITAES-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA256AND192BITAES-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA256AND256BITAES-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND128BITAES-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND192BITAES-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND256BITAES-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n\n            provider.addAlgorithm(\"Cipher.PBEWITHMD5AND128BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithAESCBC\");\n            provider.addAlgorithm(\"Cipher.PBEWITHMD5AND192BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithAESCBC\");\n            provider.addAlgorithm(\"Cipher.PBEWITHMD5AND256BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithAESCBC\");\n            \n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHMD5AND128BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithMD5And128BitAESCBCOpenSSL\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHMD5AND192BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithMD5And192BitAESCBCOpenSSL\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHMD5AND256BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithMD5And256BitAESCBCOpenSSL\");\n            \n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHAAND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHAAnd128BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHAAND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHAAnd192BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHAAND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHAAnd256BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHA256AND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256And128BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHA256AND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256And192BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHA256AND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256And256BitAESBC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND128BITAES-CBC-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND192BITAES-CBC-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND256BITAES-CBC-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND128BITAES-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND192BITAES-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND256BITAES-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc, \"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc, \"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc, \"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc, \"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc, \"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc, \"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            \n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHAAND128BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHAAND192BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHAAND256BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA256AND128BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA256AND192BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA256AND256BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA1AND128BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA1AND192BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA1AND256BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-1AND128BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-1AND192BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-1AND256BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-256AND128BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-256AND192BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-256AND256BITAES-CBC-BC\",\"PKCS12PBE\"); \n            \n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc.getId(), \"PKCS12PBE\");\n\n            addGMacAlgorithm(provider, \"AES\", PREFIX + \"$AESGMAC\", PREFIX + \"$KeyGen128\");\n            addPoly1305Algorithm(provider, \"AES\", PREFIX + \"$Poly1305\", PREFIX + \"$Poly1305KeyGen\");\n        }\n    }\n\n    private static Class lookup(String className)\n    {\n        try\n        {\n            Class def = AES.class.getClassLoader().loadClass(className);\n\n            return def;\n        }\n        catch (Exception e)\n        {\n            return null;\n        }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.KeyAgreement;\nimport javax.crypto.SecretKey;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DESKeySpec;\nimport javax.crypto.spec.DESedeKeySpec;\nimport javax.crypto.spec.DHParameterSpec;\nimport javax.crypto.spec.DHPrivateKeySpec;\nimport javax.crypto.spec.DHPublicKeySpec;\n\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jce.ECNamedCurveTable;\nimport org.bouncycastle.jce.ECPointUtil;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\npublic class DHTest\n    extends SimpleTest\n{\n    private BigInteger g512 = new BigInteger(\"153d5d6172adb43045b68ae8e1de1070b6137005686d29d3d73a7749199681ee5b212c9b96bfdcfa5b20cd5e3fd2044895d609cf9b410b7a0f12ca1cb9a428cc\", 16);\n    private BigInteger p512 = new BigInteger(\"9494fec095f3b85ee286542b3836fc81a5dd0a0349b4c239dd38744d488cf8e31db8bcb7d33b41abb9e5a33cca9144b1cef332c94bf0573bf047a3aca98cdf3b\", 16);\n\n    private BigInteger g768 = new BigInteger(\"7c240073c1316c621df461b71ebb0cdcc90a6e5527e5e126633d131f87461c4dc4afc60c2cb0f053b6758871489a69613e2a8b4c8acde23954c08c81cbd36132cfd64d69e4ed9f8e51ed6e516297206672d5c0a69135df0a5dcf010d289a9ca1\", 16);\n    private BigInteger p768 = new BigInteger(\"8c9dd223debed1b80103b8b309715be009d48860ed5ae9b9d5d8159508efd802e3ad4501a7f7e1cfec78844489148cd72da24b21eddd01aa624291c48393e277cfc529e37075eccef957f3616f962d15b44aeab4039d01b817fde9eaa12fd73f\", 16);\n\n    private BigInteger  g1024 = new BigInteger(\"1db17639cdf96bc4eabba19454f0b7e5bd4e14862889a725c96eb61048dcd676ceb303d586e30f060dbafd8a571a39c4d823982117da5cc4e0f89c77388b7a08896362429b94a18a327604eb7ff227bffbc83459ade299e57b5f77b50fb045250934938efa145511166e3197373e1b5b1e52de713eb49792bedde722c6717abf\", 16);\n    private BigInteger  p1024 = new BigInteger(\"a00e283b3c624e5b2b4d9fbc2653b5185d99499b00fd1bf244c6f0bb817b4d1c451b2958d62a0f8a38caef059fb5ecd25d75ed9af403f5b5bdab97a642902f824e3c13789fed95fa106ddfe0ff4a707c85e2eb77d49e68f2808bcea18ce128b178cd287c6bc00efa9a1ad2a673fe0dceace53166f75b81d6709d5f8af7c66bb7\", 16);\n\n    // public key with mismatched oid/parameters\n    private byte[] oldPubEnc = Base64.decode(\n        \"MIIBnzCCARQGByqGSM4+AgEwggEHAoGBAPxSrN417g43VAM9sZRf1dt6AocAf7D6\" +\n        \"WVCtqEDcBJrMzt63+g+BNJzhXVtbZ9kp9vw8L/0PHgzv0Ot/kOLX7Khn+JalOECW\" +\n        \"YlkyBhmOVbjR79TY5u2GAlvG6pqpizieQNBCEMlUuYuK1Iwseil6VoRuA13Zm7uw\" +\n        \"WO1eZmaJtY7LAoGAQaPRCFKM5rEdkMrV9FNzeSsYRs8m3DqPnnJHpuySpyO9wUcX\" +\n        \"OOJcJY5qvHbDO5SxHXu/+bMgXmVT6dXI5o0UeYqJR7fj6pR4E6T0FwG55RFr5Ok4\" +\n        \"3C4cpXmaOu176SyWuoDqGs1RDGmYQjwbZUi23DjaaTFUly9LCYXMliKrQfEDgYQA\" +\n        \"AoGAQUGCBN4TaBw1BpdBXdTvTfCU69XDB3eyU2FOBE3UWhpx9D8XJlx4f5DpA4Y6\" +\n        \"6sQMuCbhfmjEph8W7/sbMurM/awR+PSR8tTY7jeQV0OkmAYdGK2nzh0ZSifMO1oE\" +\n        \"NNhN2O62TLs67msxT28S4/S89+LMtc98mevQ2SX+JF3wEVU=\");\n\n    // bogus key with full PKCS parameter set\n    private byte[] oldFullParams = Base64.decode(\n        \"MIIBIzCCARgGByqGSM4+AgEwggELAoGBAP1/U4EddRIpUt9KnC7s5Of2EbdSPO9E\" +\n        \"AMMeP4C2USZpRV1AIlH7WT2NWPq/xfW6MPbLm1Vs14E7gB00b/JmYLdrmVClpJ+f\" +\n        \"6AR7ECLCT7up1/63xhv4O1fnxqimFQ8E+4P208UewwI1VBNaFpEy9nXzrith1yrv\" +\n        \"8iIDGZ3RSAHHAoGBAPfhoIXWmz3ey7yrXDa4V7l5lK+7+jrqgvlXTAs9B4JnUVlX\" +\n        \"jrrUWU/mcQcQgYC0SRZxI+hMKBYTt88JMozIpuE8FnqLVHyNKOCjrh4rs6Z1kW6j\" +\n        \"fwv6ITVi8ftiegEkO8yk8b6oUZCJqIPf4VrlnwaSi2ZegHtVJWQBTDv+z0kqAgFk\" +\n        \"AwUAAgIH0A==\");\n\n    private byte[] samplePubEnc = Base64.decode(\n       \"MIIBpjCCARsGCSqGSIb3DQEDATCCAQwCgYEA/X9TgR11EilS30qcLuzk5/YRt1I8\" +\n       \"70QAwx4/gLZRJmlFXUAiUftZPY1Y+r/F9bow9subVWzXgTuAHTRv8mZgt2uZUKWk\" +\n       \"n5/oBHsQIsJPu6nX/rfGG/g7V+fGqKYVDwT7g/bTxR7DAjVUE1oWkTL2dfOuK2HX\" +\n       \"Ku/yIgMZndFIAccCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdR\" +\n       \"WVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWR\" +\n       \"bqN/C/ohNWLx+2J6ASQ7zKTxvqhRkImog9/hWuWfBpKLZl6Ae1UlZAFMO/7PSSoC\" +\n       \"AgIAA4GEAAKBgEIiqxoUW6E6GChoOgcfNbVFclW91ITf5MFSUGQwt2R0RHoOhxvO\" +\n       \"lZhNs++d0VPATLAyXovjfgENT9SGCbuZttYcqqLdKTbMXBWPek+rfnAl9E4iEMED\" +\n       \"IDd83FJTKs9hQcPAm7zmp0Xm1bGF9CbUFjP5G02265z7eBmHDaT0SNlB\");\n\n    private byte[] samplePrivEnc = Base64.decode(\n       \"MIIBZgIBADCCARsGCSqGSIb3DQEDATCCAQwCgYEA/X9TgR11EilS30qcLuzk5/YR\" +\n       \"t1I870QAwx4/gLZRJmlFXUAiUftZPY1Y+r/F9bow9subVWzXgTuAHTRv8mZgt2uZ\" +\n       \"UKWkn5/oBHsQIsJPu6nX/rfGG/g7V+fGqKYVDwT7g/bTxR7DAjVUE1oWkTL2dfOu\" +\n       \"K2HXKu/yIgMZndFIAccCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0H\" +\n       \"gmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuz\" +\n       \"pnWRbqN/C/ohNWLx+2J6ASQ7zKTxvqhRkImog9/hWuWfBpKLZl6Ae1UlZAFMO/7P\" +\n       \"SSoCAgIABEICQAZYXnBHazxXUUdFP4NIf2Ipu7du0suJPZQKKff81wymi2zfCfHh\" +\n       \"uhe9gQ9xdm4GpzeNtrQ8/MzpTy+ZVrtd29Q=\");\n\n    public String getName()\n    {\n        return \"DH\";\n    }\n\n    private void testGP(\n        String      algName,\n        int         size,\n        int         privateValueSize,\n        BigInteger  g,\n        BigInteger  p)\n        throws Exception\n    {\n        DHParameterSpec             dhParams = new DHParameterSpec(p, g, privateValueSize);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algName, \"BC\");\n\n        keyGen.initialize(dhParams);\n\n        testTwoParty(algName, size, privateValueSize, keyGen);\n\n        KeyPair aKeyPair = keyGen.generateKeyPair();\n\n        //\n        // public key encoding test\n        //\n        byte[]              pubEnc = aKeyPair.getPublic().getEncoded();\n        KeyFactory          keyFac = KeyFactory.getInstance(algName, \"BC\");\n        X509EncodedKeySpec  pubX509 = new X509EncodedKeySpec(pubEnc);\n        DHPublicKey         pubKey = (DHPublicKey)keyFac.generatePublic(pubX509);\n        DHParameterSpec     spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // public key serialisation test\n        //\n        pubKey = (DHPublicKey)serializeDeserialize(aKeyPair.getPublic());\n        spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key serialisation test failed on y value\");\n        }\n\n        if (!aKeyPair.getPublic().equals(pubKey))\n        {\n            fail(\"equals test failed\");\n        }\n\n        if (aKeyPair.getPublic().hashCode() != pubKey.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n\n        //\n        // private key encoding test\n        //\n        byte[]              privEnc = aKeyPair.getPrivate().getEncoded();\n        PKCS8EncodedKeySpec privPKCS8 = new PKCS8EncodedKeySpec(privEnc);\n        DHPrivateKey        privKey = (DHPrivateKey)keyFac.generatePrivate(privPKCS8);\n\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // private key serialisation test\n        //\n        privKey = (DHPrivateKey)serializeDeserialize(aKeyPair.getPrivate());\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key serialisation test failed on X value\");\n        }\n\n        if (!aKeyPair.getPrivate().equals(privKey))\n        {\n            fail(\"equals test failed\");\n        }\n\n        if (aKeyPair.getPrivate().hashCode() != privKey.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n\n        if (!(privKey instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // three party test\n        //\n        KeyPairGenerator aPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        aPairGen.initialize(spec);\n        KeyPair aPair = aPairGen.generateKeyPair();\n\n        KeyPairGenerator bPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        bPairGen.initialize(spec);\n        KeyPair bPair = bPairGen.generateKeyPair();\n\n        KeyPairGenerator cPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        cPairGen.initialize(spec);\n        KeyPair cPair = cPairGen.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        aKeyAgree.init(aPair.getPrivate());\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        bKeyAgree.init(bPair.getPrivate());\n\n        KeyAgreement cKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        cKeyAgree.init(cPair.getPrivate());\n\n        Key ac = aKeyAgree.doPhase(cPair.getPublic(), false);\n\n        Key ba = bKeyAgree.doPhase(aPair.getPublic(), false);\n\n        Key cb = cKeyAgree.doPhase(bPair.getPublic(), false);\n\n        aKeyAgree.doPhase(cb, true);\n\n        bKeyAgree.doPhase(ac, true);\n\n        cKeyAgree.doPhase(ba, true);\n\n        BigInteger aShared = new BigInteger(aKeyAgree.generateSecret());\n        BigInteger bShared = new BigInteger(bKeyAgree.generateSecret());\n        BigInteger cShared = new BigInteger(cKeyAgree.generateSecret());\n\n        if (!aShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (a and b differ)\");\n        }\n\n        if (!cShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (c and b differ)\");\n        }\n    }\n\n    private void testTwoParty(String algName, int size, int privateValueSize, KeyPairGenerator keyGen)\n            throws Exception\n    {\n        testTwoParty(algName, size, privateValueSize, keyGen.generateKeyPair(), keyGen.generateKeyPair());\n    }\n\n    private byte[] testTwoParty(String algName, int size, int privateValueSize, KeyPair aKeyPair, KeyPair bKeyPair)\n        throws Exception\n    {\n        //\n        // a side\n        //\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n\n        checkKeySize(privateValueSize, aKeyPair);\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n\n        checkKeySize(privateValueSize, bKeyPair);\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        byte[] aSecret = aKeyAgree.generateSecret();\n        byte[] bSecret = bKeyAgree.generateSecret();\n\n        if (!Arrays.areEqual(aSecret, bSecret))\n        {\n            fail(size + \" bit 2-way test failed\");\n        }\n\n        return aSecret;\n    }\n\n    private void testExplicitWrapping(\n        int         size,\n        int         privateValueSize,\n        BigInteger  g,\n        BigInteger  p)\n        throws Exception\n    {\n        DHParameterSpec             dhParams = new DHParameterSpec(p, g, privateValueSize);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        keyGen.initialize(dhParams);\n\n        //\n        // a side\n        //\n        KeyPair aKeyPair = keyGen.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n        checkKeySize(privateValueSize, aKeyPair);\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyPair bKeyPair = keyGen.generateKeyPair();\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n        checkKeySize(privateValueSize, bKeyPair);\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        SecretKey k1 = aKeyAgree.generateSecret(PKCSObjectIdentifiers.id_alg_CMS3DESwrap.getId());\n        SecretKey k2 = bKeyAgree.generateSecret(PKCSObjectIdentifiers.id_alg_CMS3DESwrap.getId());\n        \n        // TODO Compare k1 and k2?\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    private void checkKeySize(int privateValueSize, KeyPair aKeyPair)\n    {\n        if (privateValueSize != 0)\n        {\n            DHPrivateKey key = (DHPrivateKey)aKeyPair.getPrivate();\n\n            if (key.getX().bitLength() != privateValueSize)\n            {\n                fail(\"limited key check failed for key size \" + privateValueSize);\n            }\n        }\n    }\n\n    private void testRandom(\n        int         size)\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DH\", \"BC\");\n        a.init(size, new SecureRandom());\n        AlgorithmParameters params = a.generateParameters();\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DH\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        DHParameterSpec dhP = (DHParameterSpec)params.getParameterSpec(DHParameterSpec.class);\n\n        testGP(\"DH\", size, 0, dhP.getG(), dhP.getP());\n    }\n\n    private void testDefault(\n        int         privateValueSize,\n        BigInteger  g,\n        BigInteger  p)\n        throws Exception\n    {\n        DHParameterSpec             dhParams = new DHParameterSpec(p, g, privateValueSize);\n        String                      algName = \"DH\";\n        int                         size = p.bitLength();\n\n        new BouncyCastleProvider().setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, dhParams);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algName, \"BC\");\n\n        keyGen.initialize(dhParams.getP().bitLength());\n\n        testTwoParty(\"DH\", size, privateValueSize, keyGen);\n\n        KeyPair aKeyPair = keyGen.generateKeyPair();\n\n        new BouncyCastleProvider().setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, null);\n\n        //\n        // public key encoding test\n        //\n        byte[]              pubEnc = aKeyPair.getPublic().getEncoded();\n        KeyFactory          keyFac = KeyFactory.getInstance(algName, \"BC\");\n        X509EncodedKeySpec  pubX509 = new X509EncodedKeySpec(pubEnc);\n        DHPublicKey         pubKey = (DHPublicKey)keyFac.generatePublic(pubX509);\n        DHParameterSpec     spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // public key serialisation test\n        //\n        ByteArrayOutputStream   bOut = new ByteArrayOutputStream();\n        ObjectOutputStream      oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(aKeyPair.getPublic());\n\n        ByteArrayInputStream   bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ObjectInputStream      oIn = new ObjectInputStream(bIn);\n\n        pubKey = (DHPublicKey)oIn.readObject();\n        spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key serialisation test failed on y value\");\n        }\n\n        //\n        // private key encoding test\n        //\n        byte[]              privEnc = aKeyPair.getPrivate().getEncoded();\n        PKCS8EncodedKeySpec privPKCS8 = new PKCS8EncodedKeySpec(privEnc);\n        DHPrivateKey        privKey = (DHPrivateKey)keyFac.generatePrivate(privPKCS8);\n\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // private key serialisation test\n        //\n        bOut = new ByteArrayOutputStream();\n        oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(aKeyPair.getPrivate());\n\n        bIn = new ByteArrayInputStream(bOut.toByteArray());\n        oIn = new ObjectInputStream(bIn);\n\n        privKey = (DHPrivateKey)oIn.readObject();\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key serialisation test failed on y value\");\n        }\n\n        //\n        // three party test\n        //\n        KeyPairGenerator aPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        aPairGen.initialize(spec);\n        KeyPair aPair = aPairGen.generateKeyPair();\n\n        KeyPairGenerator bPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        bPairGen.initialize(spec);\n        KeyPair bPair = bPairGen.generateKeyPair();\n\n        KeyPairGenerator cPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        cPairGen.initialize(spec);\n        KeyPair cPair = cPairGen.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        aKeyAgree.init(aPair.getPrivate());\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        bKeyAgree.init(bPair.getPrivate());\n\n        KeyAgreement cKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        cKeyAgree.init(cPair.getPrivate());\n\n        Key ac = aKeyAgree.doPhase(cPair.getPublic(), false);\n\n        Key ba = bKeyAgree.doPhase(aPair.getPublic(), false);\n\n        Key cb = cKeyAgree.doPhase(bPair.getPublic(), false);\n\n        aKeyAgree.doPhase(cb, true);\n\n        bKeyAgree.doPhase(ac, true);\n\n        cKeyAgree.doPhase(ba, true);\n\n        BigInteger aShared = new BigInteger(aKeyAgree.generateSecret());\n        BigInteger bShared = new BigInteger(bKeyAgree.generateSecret());\n        BigInteger cShared = new BigInteger(cKeyAgree.generateSecret());\n\n        if (!aShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (a and b differ)\");\n        }\n\n        if (!cShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (c and b differ)\");\n        }\n    }\n\n    private void testECDH(String algorithm, String curveName, String cipher, int keyLen)\n        throws Exception\n    {\n        ECNamedCurveParameterSpec parameterSpec = ECNamedCurveTable.getParameterSpec(curveName);\n        KeyPairGenerator g = KeyPairGenerator.getInstance(algorithm, \"BC\");\n\n        g.initialize(parameterSpec);\n\n        //\n        // a side\n        //\n        KeyPair aKeyPair = g.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyPair bKeyPair = g.generateKeyPair();\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        SecretKey k1 = aKeyAgree.generateSecret(cipher);\n        SecretKey k2 = bKeyAgree.generateSecret(cipher + \"[\" + keyLen + \"]\");  // explicit key-len\n\n        if (!k1.equals(k2))\n        {\n            fail(algorithm + \" 2-way test failed\");\n        }\n\n        if (k1.getEncoded().length != keyLen / 8)\n        {\n            fail(\"key for \" + cipher + \" the wrong size expected \" + keyLen / 8 + \" got \" + k1.getEncoded().length);\n        }\n    }\n\n    private void testECDH(String algorithm)\n        throws Exception\n    {\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(algorithm, \"BC\");\n\n        EllipticCurve curve = new EllipticCurve(\n                new ECFieldFp(new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\")), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n                curve,\n                ECPointUtil.decodePoint(curve, Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\"), // n\n                1); // h\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        //\n        // a side\n        //\n        KeyPair aKeyPair = g.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyPair bKeyPair = g.generateKeyPair();\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        BigInteger  k1 = new BigInteger(aKeyAgree.generateSecret());\n        BigInteger  k2 = new BigInteger(bKeyAgree.generateSecret());\n\n        if (!k1.equals(k2))\n        {\n            fail(algorithm + \" 2-way test failed\");\n        }\n\n        //\n        // public key encoding test\n        //\n        byte[]              pubEnc = aKeyPair.getPublic().getEncoded();\n        KeyFactory          keyFac = KeyFactory.getInstance(algorithm, \"BC\");\n        X509EncodedKeySpec  pubX509 = new X509EncodedKeySpec(pubEnc);\n        ECPublicKey         pubKey = (ECPublicKey)keyFac.generatePublic(pubX509);\n\n        if (!pubKey.getW().equals(((ECPublicKey)aKeyPair.getPublic()).getW()))\n        {\n            System.out.println(\" expected \" + pubKey.getW().getAffineX() + \" got \" + ((ECPublicKey)aKeyPair.getPublic()).getW().getAffineX());\n            System.out.println(\" expected \" + pubKey.getW().getAffineY() + \" got \" + ((ECPublicKey)aKeyPair.getPublic()).getW().getAffineY());\n            fail(algorithm + \" public key encoding (W test) failed\");\n        }\n\n        if (!pubKey.getParams().getGenerator().equals(((ECPublicKey)aKeyPair.getPublic()).getParams().getGenerator()))\n        {\n            fail(algorithm + \" public key encoding (G test) failed\");\n        }\n\n        //\n        // private key encoding test\n        //\n        byte[]              privEnc = aKeyPair.getPrivate().getEncoded();\n        PKCS8EncodedKeySpec privPKCS8 = new PKCS8EncodedKeySpec(privEnc);\n        ECPrivateKey        privKey = (ECPrivateKey)keyFac.generatePrivate(privPKCS8);\n\n        if (!privKey.getS().equals(((ECPrivateKey)aKeyPair.getPrivate()).getS()))\n        {\n            fail(algorithm + \" private key encoding (S test) failed\");\n        }\n\n        if (!privKey.getParams().getGenerator().equals(((ECPrivateKey)aKeyPair.getPrivate()).getParams().getGenerator()))\n        {\n            fail(algorithm + \" private key encoding (G test) failed\");\n        }\n    }\n\n    private void testExceptions()\n        throws Exception\n    {\n        try\n        {\n            KeyAgreement aKeyAgree = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n            aKeyAgree.generateSecret(\"DES\");\n        }\n        catch (IllegalStateException e)\n        {\n            // okay\n        }\n        catch (Exception e)\n        {\n            fail(\"Unexpected exception: \" + e, e);\n        }\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n\n        keyGen.initialize(256);\n\n        KeyPair kp = keyGen.generateKeyPair();\n        KeyAgreement agreement = KeyAgreement.getInstance(\"ECDH\", \"BC\");\n\n        agreement.init(kp.getPrivate());\n        try\n        {\n            ECPoint fakePubPoint = new ECPoint(new BigInteger(\"12345\"), new BigInteger(\"23457\"));\n            ECPublicKeySpec fakePubSpec = new ECPublicKeySpec(fakePubPoint, ((ECPublicKey)kp.getPublic()).getParams());\n            KeyFactory kf = KeyFactory.getInstance(\"EC\", \"BC\");\n            PublicKey fakePub = kf.generatePublic(fakePubSpec);\n            agreement.doPhase(fakePub, true);\n\n            fail(\"no exception on dud point\");\n        }\n        catch (java.security.spec.InvalidKeySpecException e)\n        {\n            isTrue(\"wrong message\", \"invalid KeySpec: point not on curve\".equals(e.getMessage()));\n        }\n        catch (java.security.InvalidKeyException e)\n        {\n            isTrue(\"wrong message\", \"calculation failed: Invalid point\".equals(e.getMessage()));\n        }\n    }\n\n    private void testDESAndDESede(BigInteger g, BigInteger p)\n        throws Exception\n    {\n        DHParameterSpec             dhParams = new DHParameterSpec(p, g, 256);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        keyGen.initialize(dhParams);\n\n        KeyPair kp = keyGen.generateKeyPair();\n\n        KeyAgreement keyAgreement = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n        keyAgreement.init(kp.getPrivate());\n        keyAgreement.doPhase(kp.getPublic(), true);\n\n        SecretKey key = keyAgreement.generateSecret(\"DES\");\n\n        if (key.getEncoded().length != 8)\n        {\n            fail(\"DES length wrong\");\n        }\n\n        if (!DESKeySpec.isParityAdjusted(key.getEncoded(), 0))\n        {\n            fail(\"DES parity wrong\");\n        }\n\n        key = keyAgreement.generateSecret(\"DESEDE\");\n\n        if (key.getEncoded().length != 24)\n        {\n            fail(\"DESEDE length wrong\");\n        }\n\n        if (!DESedeKeySpec.isParityAdjusted(key.getEncoded(), 0))\n        {\n            fail(\"DESEDE parity wrong\");\n        }\n\n        key = keyAgreement.generateSecret(\"Blowfish\");\n\n        if (key.getEncoded().length != 16)\n        {\n            fail(\"Blowfish length wrong\");\n        }\n    }\n\n    private void testInitialise()\n        throws Exception\n    {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        keyGen.initialize(512);\n\n        keyGen.generateKeyPair();\n\n        testTwoParty(\"DH\", 512, 0, keyGen);\n    }\n\n    private void testSmallSecret()\n        throws Exception\n    {\n        BigInteger p = new BigInteger(\"ff3b512a4cc0961fa625d6cbd9642c377ece46b8dbc3146a98e0567f944034b5e3a1406edb179a77cd2539bdb74dc819f0a74d486606e26e578ff52c5242a5ff\", 16);\n        BigInteger g = new BigInteger(\"58a66667431136e99d86de8199eb650a21afc9de3dd4ef9da6dfe89c866e928698952d95e68b418becef26f23211572eebfcbf328809bdaf02bba3d24c74f8c0\", 16);\n\n        DHPrivateKeySpec aPrivSpec = new DHPrivateKeySpec(\n            new BigInteger(\"30a6ea4e2240a42867ad98bd3adbfd5b81aba48bd930f20a595983d807566f7cba4e766951efef2c6c0c1be3823f63d66e12c2a091d5ff3bbeb1ea6e335d072d\", 16), p, g);\n        DHPublicKeySpec aPubSpec = new DHPublicKeySpec(\n                    new BigInteger(\"694dfea1bfc8897e2fcbfd88033ab34f4581892d7d5cc362dc056e3d43955accda12222bd651ca31c85f008a05dea914de68828dfd83a54a340fa84f3bbe6caf\", 16), p, g);\n\n        DHPrivateKeySpec bPrivSpec = new DHPrivateKeySpec(\n                    new BigInteger(\"775b1e7e162190700e2212dd8e4aaacf8a2af92c9c108b81d5bf9a14548f494eaa86a6c4844b9512eb3e3f2f22ffec44c795c813edfea13f075b99bbdebb34bd\", 16), p, g);\n\n        DHPublicKeySpec bPubSpec = new DHPublicKeySpec(\n                    new BigInteger(\"d8ddd4ff9246635eadbfa0bc2ef06d98a329b6e8cd2d1435d7b4921467570e697c9a9d3c172c684626a9d2b6b2fa0fc725d5b91f9a9625b717a4169bc714b064\", 16), p, g);\n\n        KeyFactory kFact = KeyFactory.getInstance(\"DH\", \"BC\");\n\n        byte[] secret = testTwoParty(\"DH\", 512, 0, new KeyPair(kFact.generatePublic(aPubSpec), kFact.generatePrivate(aPrivSpec)), new KeyPair(kFact.generatePublic(bPubSpec), kFact.generatePrivate(bPrivSpec)));\n\n        if (secret.length != ((p.bitLength() + 7) / 8))\n        {\n            fail(\"short secret wrong length\");\n        }\n\n        if (!Arrays.areEqual(Hex.decode(\"00340d3309ddc86e99e2f0be4fc212837bfb5c59336b09b9e1aeb1884b72c8b485b56723d0bf1c1d37fc89a292fc1cface9125106f1df15f55f22e4f77c5879b\"), secret))\n        {\n            fail(\"short secret mismatch\");\n        }\n    }\n\n    private void testEnc()\n        throws Exception\n    {\n        KeyFactory  kFact = KeyFactory.getInstance(\"DH\", \"BC\");\n\n        Key k = kFact.generatePrivate(new PKCS8EncodedKeySpec(samplePrivEnc));\n\n        if (!Arrays.areEqual(samplePrivEnc, k.getEncoded()))\n        {\n            fail(\"private key re-encode failed\");\n        }\n\n        k = kFact.generatePublic(new X509EncodedKeySpec(samplePubEnc));\n\n        if (!Arrays.areEqual(samplePubEnc, k.getEncoded()))\n        {\n            fail(\"public key re-encode failed\");\n        }\n\n        k = kFact.generatePublic(new X509EncodedKeySpec(oldPubEnc));\n\n        if (!Arrays.areEqual(oldPubEnc, k.getEncoded()))\n        {\n            fail(\"old public key re-encode failed\");\n        }\n\n        k = kFact.generatePublic(new X509EncodedKeySpec(oldFullParams));\n\n        if (!Arrays.areEqual(oldFullParams, k.getEncoded()))\n        {\n            fail(\"old full public key re-encode failed\");\n        }\n    }\n\n    private void testConfig()\n    {\n        ConfigurableProvider prov = new BouncyCastleProvider();\n\n        DHParameterSpec dhSpec512 = new DHParameterSpec(\n            new BigInteger(\"fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e17\", 16),\n            new BigInteger(\"678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4\", 16),\n            384);\n\n        DHParameterSpec dhSpec768 = new DHParameterSpec(\n             new BigInteger(\"e9e642599d355f37c97ffd3567120b8e25c9cd43e927b3a9670fbec5d890141922d2c3b3ad2480093799869d1e846aab49fab0ad26d2ce6a22219d470bce7d777d4a21fbe9c270b57f607002f3cef8393694cf45ee3688c11a8c56ab127a3daf\", 16),\n             new BigInteger(\"30470ad5a005fb14ce2d9dcd87e38bc7d1b1c5facbaecbe95f190aa7a31d23c4dbbcbe06174544401a5b2c020965d8c2bd2171d3668445771f74ba084d2029d83c1c158547f3a9f1a2715be23d51ae4d3e5a1f6a7064f316933a346d3f529252\", 16),\n             384);\n\n        DHParameterSpec dhSpec1024 = new DHParameterSpec(\n            new BigInteger(\"fd7f53811d75122952df4a9c2eece4e7f611b7523cef4400c31e3f80b6512669455d402251fb593d8d58fabfc5f5ba30f6cb9b556cd7813b801d346ff26660b76b9950a5a49f9fe8047b1022c24fbba9d7feb7c61bf83b57e7c6a8a6150f04fb83f6d3c51ec3023554135a169132f675f3ae2b61d72aeff22203199dd14801c7\", 16),\n            new BigInteger(\"f7e1a085d69b3ddecbbcab5c36b857b97994afbbfa3aea82f9574c0b3d0782675159578ebad4594fe67107108180b449167123e84c281613b7cf09328cc8a6e13c167a8b547c8d28e0a3ae1e2bb3a675916ea37f0bfa213562f1fb627a01243bcca4f1bea8519089a883dfe15ae59f06928b665e807b552564014c3bfecf492a\", 16),\n            512);\n\n        prov.setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, dhSpec512);\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"config mismatch\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found when none expected\");\n        }\n\n        prov.setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, new DHParameterSpec[] { dhSpec512, dhSpec768, dhSpec1024 });\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"512 config mismatch\");\n        }\n\n        if (!dhSpec768.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768)))\n        {\n            fail(\"768 config mismatch\");\n        }\n\n        if (!dhSpec1024.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(1024)))\n        {\n            fail(\"1024 config mismatch\");\n        }\n\n        prov.setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, null);\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512) != null)\n        {\n            fail(\"config found for 512 when none expected\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found for 768 when none expected\");\n        }\n\n        prov.setParameter(ConfigurableProvider.THREAD_LOCAL_DH_DEFAULT_PARAMS, dhSpec512);\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"config mismatch\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found when none expected\");\n        }\n\n        prov.setParameter(ConfigurableProvider.THREAD_LOCAL_DH_DEFAULT_PARAMS, new DHParameterSpec[] { dhSpec512, dhSpec768, dhSpec1024 });\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"512 config mismatch\");\n        }\n\n        if (!dhSpec768.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768)))\n        {\n            fail(\"768 config mismatch\");\n        }\n\n        if (!dhSpec1024.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(1024)))\n        {\n            fail(\"1024 config mismatch\");\n        }\n\n        prov.setParameter(ConfigurableProvider.THREAD_LOCAL_DH_DEFAULT_PARAMS, null);\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512) != null)\n        {\n            fail(\"config found for 512 when none expected\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found for 768 when none expected\");\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testDefault(64, g512, p512);\n\n        testEnc();\n        testGP(\"DH\", 512, 0, g512, p512);\n        testGP(\"DiffieHellman\", 768, 0, g768, p768);\n        testGP(\"DIFFIEHELLMAN\", 1024, 0, g1024, p1024);\n        testGP(\"DH\", 512, 64, g512, p512);\n        testGP(\"DiffieHellman\", 768, 128, g768, p768);\n        testGP(\"DIFFIEHELLMAN\", 1024, 256, g1024, p1024);\n        testExplicitWrapping(512, 0, g512, p512);\n        testRandom(256);\n\n        testECDH(\"ECDH\");\n        testECDH(\"ECDHC\");\n        testECDH(\"ECDH\", \"secp521r1\", \"AES\", 256);\n        testECDH(\"ECDH\", \"secp521r1\", \"DESEDE\", 192);\n        testECDH(\"ECDH\", \"secp521r1\", \"DES\", 64);\n        testECDH(\"ECDHwithSHA1KDF\", \"secp521r1\", \"AES\", 256);\n        testECDH(\"ECDHwithSHA1KDF\", \"secp521r1\", \"DESEDE\", 192);\n        testECDH(\"ECDH\", \"Curve25519\", \"AES\", 256);\n        testECDH(\"ECDH\", \"Curve25519\", \"DESEDE\", 192);\n        testECDH(\"ECDH\", \"Curve25519\", \"DES\", 64);\n        testECDH(\"ECDHwithSHA1KDF\", \"Curve25519\", \"AES\", 256);\n        testECDH(\"ECDHwithSHA1KDF\", \"Curve25519\", \"DESEDE\", 192);\n\n        testExceptions();\n        testDESAndDESede(g768, p768);\n        testInitialise();\n        testSmallSecret();\n        testConfig();\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DHTest());\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.crypto.engines;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DataLengthException;\nimport org.bouncycastle.crypto.OutputLengthException;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.Pack;\n\n/**\n * an implementation of the AES (Rijndael), from FIPS-197.\n * <p>\n * For further details see: <a href=\"http://csrc.nist.gov/encryption/aes/\">http://csrc.nist.gov/encryption/aes/</a>.\n *\n * This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at\n * <a href=\"http://fp.gladman.plus.com/cryptography_technology/rijndael/\">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>\n *\n * There are three levels of tradeoff of speed vs memory\n * Because java has no preprocessor, they are written as three separate classes from which to choose\n *\n * The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption\n * and 4 for decryption.\n *\n * The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,\n * adding 12 rotate operations per round to compute the values contained in the other tables from\n * the contents of the first.\n *\n * The slowest version uses no static tables at all and computes the values in each round.\n * <p>\n * This file contains the middle performance version with 2Kbytes of static tables for round precomputation.\n *\n */\npublic class AESEngine\n    implements BlockCipher\n{\n    // The S box\n    private static final byte[] S = {\n        (byte)99, (byte)124, (byte)119, (byte)123, (byte)242, (byte)107, (byte)111, (byte)197,\n        (byte)48,   (byte)1, (byte)103,  (byte)43, (byte)254, (byte)215, (byte)171, (byte)118,\n        (byte)202, (byte)130, (byte)201, (byte)125, (byte)250,  (byte)89,  (byte)71, (byte)240,\n        (byte)173, (byte)212, (byte)162, (byte)175, (byte)156, (byte)164, (byte)114, (byte)192,\n        (byte)183, (byte)253, (byte)147,  (byte)38,  (byte)54,  (byte)63, (byte)247, (byte)204,\n        (byte)52, (byte)165, (byte)229, (byte)241, (byte)113, (byte)216,  (byte)49,  (byte)21,\n        (byte)4, (byte)199,  (byte)35, (byte)195,  (byte)24, (byte)150,   (byte)5, (byte)154,\n        (byte)7,  (byte)18, (byte)128, (byte)226, (byte)235,  (byte)39, (byte)178, (byte)117,\n        (byte)9, (byte)131,  (byte)44,  (byte)26,  (byte)27, (byte)110,  (byte)90, (byte)160,\n        (byte)82,  (byte)59, (byte)214, (byte)179,  (byte)41, (byte)227,  (byte)47, (byte)132,\n        (byte)83, (byte)209,   (byte)0, (byte)237,  (byte)32, (byte)252, (byte)177,  (byte)91,\n        (byte)106, (byte)203, (byte)190,  (byte)57,  (byte)74,  (byte)76,  (byte)88, (byte)207,\n        (byte)208, (byte)239, (byte)170, (byte)251,  (byte)67,  (byte)77,  (byte)51, (byte)133,\n        (byte)69, (byte)249,   (byte)2, (byte)127,  (byte)80,  (byte)60, (byte)159, (byte)168,\n        (byte)81, (byte)163,  (byte)64, (byte)143, (byte)146, (byte)157,  (byte)56, (byte)245,\n        (byte)188, (byte)182, (byte)218,  (byte)33,  (byte)16, (byte)255, (byte)243, (byte)210,\n        (byte)205,  (byte)12,  (byte)19, (byte)236,  (byte)95, (byte)151,  (byte)68,  (byte)23,\n        (byte)196, (byte)167, (byte)126,  (byte)61, (byte)100,  (byte)93,  (byte)25, (byte)115,\n        (byte)96, (byte)129,  (byte)79, (byte)220,  (byte)34,  (byte)42, (byte)144, (byte)136,\n        (byte)70, (byte)238, (byte)184,  (byte)20, (byte)222,  (byte)94,  (byte)11, (byte)219,\n        (byte)224,  (byte)50,  (byte)58,  (byte)10,  (byte)73,   (byte)6,  (byte)36,  (byte)92,\n        (byte)194, (byte)211, (byte)172,  (byte)98, (byte)145, (byte)149, (byte)228, (byte)121,\n        (byte)231, (byte)200,  (byte)55, (byte)109, (byte)141, (byte)213,  (byte)78, (byte)169,\n        (byte)108,  (byte)86, (byte)244, (byte)234, (byte)101, (byte)122, (byte)174,   (byte)8,\n        (byte)186, (byte)120,  (byte)37,  (byte)46,  (byte)28, (byte)166, (byte)180, (byte)198,\n        (byte)232, (byte)221, (byte)116,  (byte)31,  (byte)75, (byte)189, (byte)139, (byte)138,\n        (byte)112,  (byte)62, (byte)181, (byte)102,  (byte)72,   (byte)3, (byte)246,  (byte)14,\n        (byte)97,  (byte)53,  (byte)87, (byte)185, (byte)134, (byte)193,  (byte)29, (byte)158,\n        (byte)225, (byte)248, (byte)152,  (byte)17, (byte)105, (byte)217, (byte)142, (byte)148,\n        (byte)155,  (byte)30, (byte)135, (byte)233, (byte)206,  (byte)85,  (byte)40, (byte)223,\n        (byte)140, (byte)161, (byte)137,  (byte)13, (byte)191, (byte)230,  (byte)66, (byte)104,\n        (byte)65, (byte)153,  (byte)45,  (byte)15, (byte)176,  (byte)84, (byte)187,  (byte)22,\n    };\n\n    // The inverse S-box\n    private static final byte[] Si = {\n        (byte)82,   (byte)9, (byte)106, (byte)213,  (byte)48,  (byte)54, (byte)165,  (byte)56,\n        (byte)191,  (byte)64, (byte)163, (byte)158, (byte)129, (byte)243, (byte)215, (byte)251,\n        (byte)124, (byte)227,  (byte)57, (byte)130, (byte)155,  (byte)47, (byte)255, (byte)135,\n        (byte)52, (byte)142,  (byte)67,  (byte)68, (byte)196, (byte)222, (byte)233, (byte)203,\n        (byte)84, (byte)123, (byte)148,  (byte)50, (byte)166, (byte)194,  (byte)35,  (byte)61,\n        (byte)238,  (byte)76, (byte)149,  (byte)11,  (byte)66, (byte)250, (byte)195,  (byte)78,\n        (byte)8,  (byte)46, (byte)161, (byte)102,  (byte)40, (byte)217,  (byte)36, (byte)178,\n        (byte)118,  (byte)91, (byte)162,  (byte)73, (byte)109, (byte)139, (byte)209,  (byte)37,\n        (byte)114, (byte)248, (byte)246, (byte)100, (byte)134, (byte)104, (byte)152,  (byte)22,\n        (byte)212, (byte)164,  (byte)92, (byte)204,  (byte)93, (byte)101, (byte)182, (byte)146,\n        (byte)108, (byte)112,  (byte)72,  (byte)80, (byte)253, (byte)237, (byte)185, (byte)218,\n        (byte)94,  (byte)21,  (byte)70,  (byte)87, (byte)167, (byte)141, (byte)157, (byte)132,\n        (byte)144, (byte)216, (byte)171,   (byte)0, (byte)140, (byte)188, (byte)211,  (byte)10,\n        (byte)247, (byte)228,  (byte)88,   (byte)5, (byte)184, (byte)179,  (byte)69,   (byte)6,\n        (byte)208,  (byte)44,  (byte)30, (byte)143, (byte)202,  (byte)63,  (byte)15,   (byte)2,\n        (byte)193, (byte)175, (byte)189,   (byte)3,   (byte)1,  (byte)19, (byte)138, (byte)107,\n        (byte)58, (byte)145,  (byte)17,  (byte)65,  (byte)79, (byte)103, (byte)220, (byte)234,\n        (byte)151, (byte)242, (byte)207, (byte)206, (byte)240, (byte)180, (byte)230, (byte)115,\n        (byte)150, (byte)172, (byte)116,  (byte)34, (byte)231, (byte)173,  (byte)53, (byte)133,\n        (byte)226, (byte)249,  (byte)55, (byte)232,  (byte)28, (byte)117, (byte)223, (byte)110,\n        (byte)71, (byte)241,  (byte)26, (byte)113,  (byte)29,  (byte)41, (byte)197, (byte)137,\n        (byte)111, (byte)183,  (byte)98,  (byte)14, (byte)170,  (byte)24, (byte)190,  (byte)27,\n        (byte)252,  (byte)86,  (byte)62,  (byte)75, (byte)198, (byte)210, (byte)121,  (byte)32,\n        (byte)154, (byte)219, (byte)192, (byte)254, (byte)120, (byte)205,  (byte)90, (byte)244,\n        (byte)31, (byte)221, (byte)168,  (byte)51, (byte)136,   (byte)7, (byte)199,  (byte)49,\n        (byte)177,  (byte)18,  (byte)16,  (byte)89,  (byte)39, (byte)128, (byte)236,  (byte)95,\n        (byte)96,  (byte)81, (byte)127, (byte)169,  (byte)25, (byte)181,  (byte)74,  (byte)13,\n        (byte)45, (byte)229, (byte)122, (byte)159, (byte)147, (byte)201, (byte)156, (byte)239,\n        (byte)160, (byte)224,  (byte)59,  (byte)77, (byte)174,  (byte)42, (byte)245, (byte)176,\n        (byte)200, (byte)235, (byte)187,  (byte)60, (byte)131,  (byte)83, (byte)153,  (byte)97,\n        (byte)23,  (byte)43,   (byte)4, (byte)126, (byte)186, (byte)119, (byte)214,  (byte)38,\n        (byte)225, (byte)105,  (byte)20,  (byte)99,  (byte)85,  (byte)33,  (byte)12, (byte)125,\n        };\n\n    // vector used in calculating key schedule (powers of x in GF(256))\n    private static final int[] rcon = {\n         0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\n         0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 };\n\n    // precomputation tables of calculations for rounds\n    private static final int[] T0 =\n    {\n     0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6, 0x0df2f2ff, \n     0xbd6b6bd6, 0xb16f6fde, 0x54c5c591, 0x50303060, 0x03010102, \n     0xa96767ce, 0x7d2b2b56, 0x19fefee7, 0x62d7d7b5, 0xe6abab4d, \n     0x9a7676ec, 0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa, \n     0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb, 0xecadad41, \n     0x67d4d4b3, 0xfda2a25f, 0xeaafaf45, 0xbf9c9c23, 0xf7a4a453, \n     0x967272e4, 0x5bc0c09b, 0xc2b7b775, 0x1cfdfde1, 0xae93933d, \n     0x6a26264c, 0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83, \n     0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9, 0x937171e2, \n     0x73d8d8ab, 0x53313162, 0x3f15152a, 0x0c040408, 0x52c7c795, \n     0x65232346, 0x5ec3c39d, 0x28181830, 0xa1969637, 0x0f05050a, \n     0xb59a9a2f, 0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df, \n     0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea, 0x1b090912, \n     0x9e83831d, 0x742c2c58, 0x2e1a1a34, 0x2d1b1b36, 0xb26e6edc, \n     0xee5a5ab4, 0xfba0a05b, 0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, \n     0xceb3b37d, 0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413, \n     0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1, 0x60202040, \n     0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6, 0xbe6a6ad4, 0x46cbcb8d, \n     0xd9bebe67, 0x4b393972, 0xde4a4a94, 0xd44c4c98, 0xe85858b0, \n     0x4acfcf85, 0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed, \n     0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511, 0xcf45458a, \n     0x10f9f9e9, 0x06020204, 0x817f7ffe, 0xf05050a0, 0x443c3c78, \n     0xba9f9f25, 0xe3a8a84b, 0xf35151a2, 0xfea3a35d, 0xc0404080, \n     0x8a8f8f05, 0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1, \n     0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142, 0x30101020, \n     0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf, 0x4ccdcd81, 0x140c0c18, \n     0x35131326, 0x2fececc3, 0xe15f5fbe, 0xa2979735, 0xcc444488, \n     0x3917172e, 0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a, \n     0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6, 0xa06060c0, \n     0x98818119, 0xd14f4f9e, 0x7fdcdca3, 0x66222244, 0x7e2a2a54, \n     0xab90903b, 0x8388880b, 0xca46468c, 0x29eeeec7, 0xd3b8b86b, \n     0x3c141428, 0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad, \n     0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14, 0xdb494992, \n     0x0a06060c, 0x6c242448, 0xe45c5cb8, 0x5dc2c29f, 0x6ed3d3bd, \n     0xefacac43, 0xa66262c4, 0xa8919139, 0xa4959531, 0x37e4e4d3, \n     0x8b7979f2, 0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda, \n     0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949, 0xb46c6cd8, \n     0xfa5656ac, 0x07f4f4f3, 0x25eaeacf, 0xaf6565ca, 0x8e7a7af4, \n     0xe9aeae47, 0x18080810, 0xd5baba6f, 0x887878f0, 0x6f25254a, \n     0x722e2e5c, 0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697, \n     0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e, 0xdd4b4b96, \n     0xdcbdbd61, 0x868b8b0d, 0x858a8a0f, 0x907070e0, 0x423e3e7c, \n     0xc4b5b571, 0xaa6666cc, 0xd8484890, 0x05030306, 0x01f6f6f7, \n     0x120e0e1c, 0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969, \n     0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27, 0x38e1e1d9, \n     0x13f8f8eb, 0xb398982b, 0x33111122, 0xbb6969d2, 0x70d9d9a9, \n     0x898e8e07, 0xa7949433, 0xb69b9b2d, 0x221e1e3c, 0x92878715, \n     0x20e9e9c9, 0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5, \n     0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a, 0xdabfbf65, \n     0x31e6e6d7, 0xc6424284, 0xb86868d0, 0xc3414182, 0xb0999929, \n     0x772d2d5a, 0x110f0f1e, 0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, \n     0x3a16162c};\n\nprivate static final int[] Tinv0 =\n    {\n     0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 0xcb6bab3b, \n     0xf1459d1f, 0xab58faac, 0x9303e34b, 0x55fa3020, 0xf66d76ad, \n     0x9176cc88, 0x254c02f5, 0xfcd7e54f, 0xd7cb2ac5, 0x80443526, \n     0x8fa362b5, 0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, \n     0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 0xe75f8f03, \n     0x959c9215, 0xeb7a6dbf, 0xda595295, 0x2d83bed4, 0xd3217458, \n     0x2969e049, 0x44c8c98e, 0x6a89c275, 0x78798ef4, 0x6b3e5899, \n     0xdd71b927, 0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, \n     0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 0xe07764b1, \n     0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 0x58684870, 0x19fd458f, \n     0x876cde94, 0xb7f87b52, 0x23d373ab, 0xe2024b72, 0x578f1fe3, \n     0x2aab5566, 0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3, \n     0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 0x2b1ccf8a, \n     0x92b479a7, 0xf0f207f3, 0xa1e2694e, 0xcdf4da65, 0xd5be0506, \n     0x1f6234d1, 0x8afea6c4, 0x9d532e34, 0xa055f3a2, 0x32e18a05, \n     0x75ebf6a4, 0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd, \n     0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 0xb58d5491, \n     0x055dc471, 0x6fd40604, 0xff155060, 0x24fb9819, 0x97e9bdd6, \n     0xcc434089, 0x779ed967, 0xbd42e8b0, 0x888b8907, 0x385b19e7, \n     0xdbeec879, 0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000, \n     0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 0xfbff0efd, \n     0x5638850f, 0x1ed5ae3d, 0x27392d36, 0x64d90f0a, 0x21a65c68, \n     0xd1545b9b, 0x3a2e3624, 0xb1670a0c, 0x0fe75793, 0xd296eeb4, \n     0x9e919b1b, 0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, \n     0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 0x0b0d090e, \n     0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 0x8519f157, 0x4c0775af, \n     0xbbdd99ee, 0xfd607fa3, 0x9f2601f7, 0xbcf5725c, 0xc53b6644, \n     0x347efb5b, 0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, \n     0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 0x7d244a85, \n     0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 0x4b2f9e1d, 0xf330b2dc, \n     0xec52860d, 0xd0e3c177, 0x6c16b32b, 0x99b970a9, 0xfa489411, \n     0x2264e947, 0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, \n     0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 0xcf81f5a6, \n     0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 0xe49d3a2c, 0x0d927850, \n     0x9bcc5f6a, 0x62467e54, 0xc2138df6, 0xe8b8d890, 0x5ef7392e, \n     0xf5afc382, 0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, \n     0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 0x097826cd, \n     0xf418596e, 0x01b79aec, 0xa89a4f83, 0x656e95e6, 0x7ee6ffaa, \n     0x08cfbc21, 0xe6e815ef, 0xd99be7ba, 0xce366f4a, 0xd4099fea, \n     0xd67cb029, 0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, \n     0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 0x4a9804f1, \n     0xf7daec41, 0x0e50cd7f, 0x2ff69117, 0x8dd64d76, 0x4db0ef43, \n     0x544daacc, 0xdf0496e4, 0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, \n     0x7f516546, 0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, \n     0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 0x8c61d79a, \n     0x7a0ca137, 0x8e14f859, 0x893c13eb, 0xee27a9ce, 0x35c961b7, \n     0xede51ce1, 0x3cb1477a, 0x59dfd29c, 0x3f73f255, 0x79ce1418, \n     0xbf37c773, 0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, \n     0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 0x72c31d16, \n     0x0c25e2bc, 0x8b493c28, 0x41950dff, 0x7101a839, 0xdeb30c08, \n     0x9ce4b4d8, 0x90c15664, 0x6184cb7b, 0x70b632d5, 0x745c6c48, \n     0x4257b8d0};\n\n    private static int shift(int r, int shift)\n    {\n        return (r >>> shift) | (r << -shift);\n    }\n\n    /* multiply four bytes in GF(2^8) by 'x' {02} in parallel */\n\n    private static final int m1 = 0x80808080;\n    private static final int m2 = 0x7f7f7f7f;\n    private static final int m3 = 0x0000001b;\n    private static final int m4 = 0xC0C0C0C0;\n    private static final int m5 = 0x3f3f3f3f;\n\n    private static int FFmulX(int x)\n    {\n        return (((x & m2) << 1) ^ (((x & m1) >>> 7) * m3));\n    }\n\n    private static int FFmulX2(int x)\n    {\n        int t0  = (x & m5) << 2;\n        int t1  = (x & m4);\n            t1 ^= (t1 >>> 1);\n        return t0 ^ (t1 >>> 2) ^ (t1 >>> 5);\n    }\n\n    /* \n       The following defines provide alternative definitions of FFmulX that might\n       give improved performance if a fast 32-bit multiply is not available.\n       \n       private int FFmulX(int x) { int u = x & m1; u |= (u >> 1); return ((x & m2) << 1) ^ ((u >>> 3) | (u >>> 6)); } \n       private static final int  m4 = 0x1b1b1b1b;\n       private int FFmulX(int x) { int u = x & m1; return ((x & m2) << 1) ^ ((u - (u >>> 7)) & m4); } \n\n    */\n\n    private static int inv_mcol(int x)\n    {\n        int t0, t1;\n        t0  = x;\n        t1  = t0 ^ shift(t0, 8);\n        t0 ^= FFmulX(t1);\n        t1 ^= FFmulX2(t0);\n        t0 ^= t1 ^ shift(t1, 16);\n        return t0;\n    }\n\n    private static int subWord(int x)\n    {\n        return (S[x&255]&255 | ((S[(x>>8)&255]&255)<<8) | ((S[(x>>16)&255]&255)<<16) | S[(x>>24)&255]<<24);\n    }\n\n    /**\n     * Calculate the necessary round keys\n     * The number of calculations depends on key size and block size\n     * AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits\n     * This code is written assuming those are the only possible values\n     */\n    private int[][] generateWorkingKey(byte[] key, boolean forEncryption)\n    {\n        int keyLen = key.length;\n        if (keyLen < 16 || keyLen > 32 || (keyLen & 7) != 0)\n        {\n            throw new IllegalArgumentException(\"Key length not 128/192/256 bits.\");\n        }\n\n        int KC = keyLen >>> 2;\n        ROUNDS = KC + 6;  // This is not always true for the generalized Rijndael that allows larger block sizes\n        int[][] W = new int[ROUNDS+1][4];   // 4 words in a block\n\n        switch (KC)\n        {\n        case 4:\n        {\n            int t0 = Pack.littleEndianToInt(key,  0); W[0][0] = t0;\n            int t1 = Pack.littleEndianToInt(key,  4); W[0][1] = t1;\n            int t2 = Pack.littleEndianToInt(key,  8); W[0][2] = t2;\n            int t3 = Pack.littleEndianToInt(key, 12); W[0][3] = t3;\n\n            for (int i = 1; i <= 10; ++i)\n            {\n                int u = subWord(shift(t3, 8)) ^ rcon[i - 1];\n                t0 ^= u;  W[i][0] = t0;\n                t1 ^= t0; W[i][1] = t1;\n                t2 ^= t1; W[i][2] = t2;\n                t3 ^= t2; W[i][3] = t3;\n            }\n\n            break;\n        }\n        case 6:\n        {\n            int t0 = Pack.littleEndianToInt(key,  0); W[0][0] = t0;\n            int t1 = Pack.littleEndianToInt(key,  4); W[0][1] = t1;\n            int t2 = Pack.littleEndianToInt(key,  8); W[0][2] = t2;\n            int t3 = Pack.littleEndianToInt(key, 12); W[0][3] = t3;\n            int t4 = Pack.littleEndianToInt(key, 16); W[1][0] = t4;\n            int t5 = Pack.littleEndianToInt(key, 20); W[1][1] = t5;\n\n            int rcon = 1;\n            int u = subWord(shift(t5, 8)) ^ rcon; rcon <<= 1;\n            t0 ^= u;  W[1][2] = t0;\n            t1 ^= t0; W[1][3] = t1;\n            t2 ^= t1; W[2][0] = t2;\n            t3 ^= t2; W[2][1] = t3;\n            t4 ^= t3; W[2][2] = t4;\n            t5 ^= t4; W[2][3] = t5;\n\n            for (int i = 3; i < 12; i += 3)\n            {\n                u = subWord(shift(t5, 8)) ^ rcon; rcon <<= 1;\n                t0 ^= u;  W[i    ][0] = t0;\n                t1 ^= t0; W[i    ][1] = t1;\n                t2 ^= t1; W[i    ][2] = t2;\n                t3 ^= t2; W[i    ][3] = t3;\n                t4 ^= t3; W[i + 1][0] = t4;\n                t5 ^= t4; W[i + 1][1] = t5;\n                u = subWord(shift(t5, 8)) ^ rcon; rcon <<= 1;\n                t0 ^= u;  W[i + 1][2] = t0;\n                t1 ^= t0; W[i + 1][3] = t1;\n                t2 ^= t1; W[i + 2][0] = t2;\n                t3 ^= t2; W[i + 2][1] = t3;\n                t4 ^= t3; W[i + 2][2] = t4;\n                t5 ^= t4; W[i + 2][3] = t5;\n            }\n\n            u = subWord(shift(t5, 8)) ^ rcon;\n            t0 ^= u;  W[12][0] = t0;\n            t1 ^= t0; W[12][1] = t1;\n            t2 ^= t1; W[12][2] = t2;\n            t3 ^= t2; W[12][3] = t3;\n\n            break;\n        }\n        case 8:\n        {\n            int t0 = Pack.littleEndianToInt(key,  0); W[0][0] = t0;\n            int t1 = Pack.littleEndianToInt(key,  4); W[0][1] = t1;\n            int t2 = Pack.littleEndianToInt(key,  8); W[0][2] = t2;\n            int t3 = Pack.littleEndianToInt(key, 12); W[0][3] = t3;\n            int t4 = Pack.littleEndianToInt(key, 16); W[1][0] = t4;\n            int t5 = Pack.littleEndianToInt(key, 20); W[1][1] = t5;\n            int t6 = Pack.littleEndianToInt(key, 24); W[1][2] = t6;\n            int t7 = Pack.littleEndianToInt(key, 28); W[1][3] = t7;\n\n            int u, rcon = 1;\n\n            for (int i = 2; i < 14; i += 2)\n            {\n                u = subWord(shift(t7, 8)) ^ rcon; rcon <<= 1;\n                t0 ^= u;  W[i    ][0] = t0;\n                t1 ^= t0; W[i    ][1] = t1;\n                t2 ^= t1; W[i    ][2] = t2;\n                t3 ^= t2; W[i    ][3] = t3;\n                u = subWord(t3);\n                t4 ^= u;  W[i + 1][0] = t4;\n                t5 ^= t4; W[i + 1][1] = t5;\n                t6 ^= t5; W[i + 1][2] = t6;\n                t7 ^= t6; W[i + 1][3] = t7;\n            }\n\n            u = subWord(shift(t7, 8)) ^ rcon;\n            t0 ^= u;  W[14][0] = t0;\n            t1 ^= t0; W[14][1] = t1;\n            t2 ^= t1; W[14][2] = t2;\n            t3 ^= t2; W[14][3] = t3;\n\n            break;\n        }\n        default:\n        {\n            throw new IllegalStateException(\"Should never get here\");\n        }\n        }\n\n        if (!forEncryption)\n        {\n            for (int j = 1; j < ROUNDS; j++)\n            {\n                for (int i = 0; i < 4; i++)\n                {\n                    W[j][i] = inv_mcol(W[j][i]);\n                }\n            }\n        }\n\n        return W;\n    }\n\n    private int         ROUNDS;\n    private int[][]     WorkingKey = null;\n    private int         C0, C1, C2, C3;\n    private boolean     forEncryption;\n\n    private byte[]      s;\n\n    private static final int BLOCK_SIZE = 16;\n\n    /**\n     * default constructor - 128 bit block size.\n     */\n    public AESEngine()\n    {\n    }\n\n    /**\n     * initialise an AES cipher.\n     *\n     * @param forEncryption whether or not we are for encryption.\n     * @param params the parameters required to set up the cipher.\n     * @exception IllegalArgumentException if the params argument is\n     * inappropriate.\n     */\n    public void init(\n        boolean           forEncryption,\n        CipherParameters  params)\n    {\n        if (params instanceof KeyParameter)\n        {\n            WorkingKey = generateWorkingKey(((KeyParameter)params).getKey(), forEncryption);\n            this.forEncryption = forEncryption;\n            if (forEncryption)\n            {\n                s = Arrays.clone(S);\n            }\n            else\n            {\n                s = Arrays.clone(Si);\n            }\n            return;\n        }\n\n        throw new IllegalArgumentException(\"invalid parameter passed to AES init - \" + params.getClass().getName());\n    }\n\n    public String getAlgorithmName()\n    {\n        return \"AES\";\n    }\n\n    public int getBlockSize()\n    {\n        return BLOCK_SIZE;\n    }\n\n    public int processBlock(\n        byte[] in,\n        int inOff,\n        byte[] out,\n        int outOff)\n    {\n        if (WorkingKey == null)\n        {\n            throw new IllegalStateException(\"AES engine not initialised\");\n        }\n\n        if ((inOff + (32 / 2)) > in.length)\n        {\n            throw new DataLengthException(\"input buffer too short\");\n        }\n\n        if ((outOff + (32 / 2)) > out.length)\n        {\n            throw new OutputLengthException(\"output buffer too short\");\n        }\n\n        if (forEncryption)\n        {\n            unpackBlock(in, inOff);\n            encryptBlock(WorkingKey);\n            packBlock(out, outOff);\n        }\n        else\n        {\n            unpackBlock(in, inOff);\n            decryptBlock(WorkingKey);\n            packBlock(out, outOff);\n        }\n\n        return BLOCK_SIZE;\n    }\n\n    public void reset()\n    {\n    }\n\n    private void unpackBlock(\n        byte[]      bytes,\n        int         off)\n    {\n        int     index = off;\n\n        C0 = (bytes[index++] & 0xff);\n        C0 |= (bytes[index++] & 0xff) << 8;\n        C0 |= (bytes[index++] & 0xff) << 16;\n        C0 |= bytes[index++] << 24;\n\n        C1 = (bytes[index++] & 0xff);\n        C1 |= (bytes[index++] & 0xff) << 8;\n        C1 |= (bytes[index++] & 0xff) << 16;\n        C1 |= bytes[index++] << 24;\n\n        C2 = (bytes[index++] & 0xff);\n        C2 |= (bytes[index++] & 0xff) << 8;\n        C2 |= (bytes[index++] & 0xff) << 16;\n        C2 |= bytes[index++] << 24;\n\n        C3 = (bytes[index++] & 0xff);\n        C3 |= (bytes[index++] & 0xff) << 8;\n        C3 |= (bytes[index++] & 0xff) << 16;\n        C3 |= bytes[index++] << 24;\n    }\n\n    private void packBlock(\n        byte[]      bytes,\n        int         off)\n    {\n        int     index = off;\n\n        bytes[index++] = (byte)C0;\n        bytes[index++] = (byte)(C0 >> 8);\n        bytes[index++] = (byte)(C0 >> 16);\n        bytes[index++] = (byte)(C0 >> 24);\n\n        bytes[index++] = (byte)C1;\n        bytes[index++] = (byte)(C1 >> 8);\n        bytes[index++] = (byte)(C1 >> 16);\n        bytes[index++] = (byte)(C1 >> 24);\n\n        bytes[index++] = (byte)C2;\n        bytes[index++] = (byte)(C2 >> 8);\n        bytes[index++] = (byte)(C2 >> 16);\n        bytes[index++] = (byte)(C2 >> 24);\n\n        bytes[index++] = (byte)C3;\n        bytes[index++] = (byte)(C3 >> 8);\n        bytes[index++] = (byte)(C3 >> 16);\n        bytes[index++] = (byte)(C3 >> 24);\n    }\n\n\n    private void encryptBlock(int[][] KW)\n    {\n        int t0 = this.C0 ^ KW[0][0];\n        int t1 = this.C1 ^ KW[0][1];\n        int t2 = this.C2 ^ KW[0][2];\n\n        int r = 1, r0, r1, r2, r3 = this.C3 ^ KW[0][3];\n        while (r < ROUNDS - 1)\n        {\n            r0 = T0[t0&255] ^ shift(T0[(t1>>8)&255], 24) ^ shift(T0[(t2>>16)&255], 16) ^ shift(T0[(r3>>24)&255], 8) ^ KW[r][0];\n            r1 = T0[t1&255] ^ shift(T0[(t2>>8)&255], 24) ^ shift(T0[(r3>>16)&255], 16) ^ shift(T0[(t0>>24)&255], 8) ^ KW[r][1];\n            r2 = T0[t2&255] ^ shift(T0[(r3>>8)&255], 24) ^ shift(T0[(t0>>16)&255], 16) ^ shift(T0[(t1>>24)&255], 8) ^ KW[r][2];\n            r3 = T0[r3&255] ^ shift(T0[(t0>>8)&255], 24) ^ shift(T0[(t1>>16)&255], 16) ^ shift(T0[(t2>>24)&255], 8) ^ KW[r++][3];\n            t0 = T0[r0&255] ^ shift(T0[(r1>>8)&255], 24) ^ shift(T0[(r2>>16)&255], 16) ^ shift(T0[(r3>>24)&255], 8) ^ KW[r][0];\n            t1 = T0[r1&255] ^ shift(T0[(r2>>8)&255], 24) ^ shift(T0[(r3>>16)&255], 16) ^ shift(T0[(r0>>24)&255], 8) ^ KW[r][1];\n            t2 = T0[r2&255] ^ shift(T0[(r3>>8)&255], 24) ^ shift(T0[(r0>>16)&255], 16) ^ shift(T0[(r1>>24)&255], 8) ^ KW[r][2];\n            r3 = T0[r3&255] ^ shift(T0[(r0>>8)&255], 24) ^ shift(T0[(r1>>16)&255], 16) ^ shift(T0[(r2>>24)&255], 8) ^ KW[r++][3];\n        }\n\n        r0 = T0[t0&255] ^ shift(T0[(t1>>8)&255], 24) ^ shift(T0[(t2>>16)&255], 16) ^ shift(T0[(r3>>24)&255], 8) ^ KW[r][0];\n        r1 = T0[t1&255] ^ shift(T0[(t2>>8)&255], 24) ^ shift(T0[(r3>>16)&255], 16) ^ shift(T0[(t0>>24)&255], 8) ^ KW[r][1];\n        r2 = T0[t2&255] ^ shift(T0[(r3>>8)&255], 24) ^ shift(T0[(t0>>16)&255], 16) ^ shift(T0[(t1>>24)&255], 8) ^ KW[r][2];\n        r3 = T0[r3&255] ^ shift(T0[(t0>>8)&255], 24) ^ shift(T0[(t1>>16)&255], 16) ^ shift(T0[(t2>>24)&255], 8) ^ KW[r++][3];\n\n        // the final round's table is a simple function of S so we don't use a whole other four tables for it\n\n        this.C0 = (S[r0&255]&255) ^ ((S[(r1>>8)&255]&255)<<8) ^ ((s[(r2>>16)&255]&255)<<16) ^ (s[(r3>>24)&255]<<24) ^ KW[r][0];\n        this.C1 = (s[r1&255]&255) ^ ((S[(r2>>8)&255]&255)<<8) ^ ((S[(r3>>16)&255]&255)<<16) ^ (s[(r0>>24)&255]<<24) ^ KW[r][1];\n        this.C2 = (s[r2&255]&255) ^ ((S[(r3>>8)&255]&255)<<8) ^ ((S[(r0>>16)&255]&255)<<16) ^ (S[(r1>>24)&255]<<24) ^ KW[r][2];\n        this.C3 = (s[r3&255]&255) ^ ((s[(r0>>8)&255]&255)<<8) ^ ((s[(r1>>16)&255]&255)<<16) ^ (S[(r2>>24)&255]<<24) ^ KW[r][3];\n    }\n\n    private void decryptBlock(int[][] KW)\n    {\n        int t0 = this.C0 ^ KW[ROUNDS][0];\n        int t1 = this.C1 ^ KW[ROUNDS][1];\n        int t2 = this.C2 ^ KW[ROUNDS][2];\n\n        int r = ROUNDS - 1, r0, r1, r2, r3 = this.C3 ^ KW[ROUNDS][3];\n        while (r > 1)\n        {\n            r0 = Tinv0[t0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(t2>>16)&255], 16) ^ shift(Tinv0[(t1>>24)&255], 8) ^ KW[r][0];\n            r1 = Tinv0[t1&255] ^ shift(Tinv0[(t0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(t2>>24)&255], 8) ^ KW[r][1];\n            r2 = Tinv0[t2&255] ^ shift(Tinv0[(t1>>8)&255], 24) ^ shift(Tinv0[(t0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];\n            r3 = Tinv0[r3&255] ^ shift(Tinv0[(t2>>8)&255], 24) ^ shift(Tinv0[(t1>>16)&255], 16) ^ shift(Tinv0[(t0>>24)&255], 8) ^ KW[r--][3];\n            t0 = Tinv0[r0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(r2>>16)&255], 16) ^ shift(Tinv0[(r1>>24)&255], 8) ^ KW[r][0];\n            t1 = Tinv0[r1&255] ^ shift(Tinv0[(r0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(r2>>24)&255], 8) ^ KW[r][1];\n            t2 = Tinv0[r2&255] ^ shift(Tinv0[(r1>>8)&255], 24) ^ shift(Tinv0[(r0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];\n            r3 = Tinv0[r3&255] ^ shift(Tinv0[(r2>>8)&255], 24) ^ shift(Tinv0[(r1>>16)&255], 16) ^ shift(Tinv0[(r0>>24)&255], 8) ^ KW[r--][3];\n        }\n\n        r0 = Tinv0[t0&255] ^ shift(Tinv0[(r3>>8)&255], 24) ^ shift(Tinv0[(t2>>16)&255], 16) ^ shift(Tinv0[(t1>>24)&255], 8) ^ KW[r][0];\n        r1 = Tinv0[t1&255] ^ shift(Tinv0[(t0>>8)&255], 24) ^ shift(Tinv0[(r3>>16)&255], 16) ^ shift(Tinv0[(t2>>24)&255], 8) ^ KW[r][1];\n        r2 = Tinv0[t2&255] ^ shift(Tinv0[(t1>>8)&255], 24) ^ shift(Tinv0[(t0>>16)&255], 16) ^ shift(Tinv0[(r3>>24)&255], 8) ^ KW[r][2];\n        r3 = Tinv0[r3&255] ^ shift(Tinv0[(t2>>8)&255], 24) ^ shift(Tinv0[(t1>>16)&255], 16) ^ shift(Tinv0[(t0>>24)&255], 8) ^ KW[r][3];\n        \n        // the final round's table is a simple function of Si so we don't use a whole other four tables for it\n\n        this.C0 = (Si[r0&255]&255) ^ ((s[(r3>>8)&255]&255)<<8) ^ ((s[(r2>>16)&255]&255)<<16) ^ (Si[(r1>>24)&255]<<24) ^ KW[0][0];\n        this.C1 = (s[r1&255]&255) ^ ((s[(r0>>8)&255]&255)<<8) ^ ((Si[(r3>>16)&255]&255)<<16) ^ (s[(r2>>24)&255]<<24) ^ KW[0][1];\n        this.C2 = (s[r2&255]&255) ^ ((Si[(r1>>8)&255]&255)<<8) ^ ((Si[(r0>>16)&255]&255)<<16) ^ (s[(r3>>24)&255]<<24) ^ KW[0][2];\n        this.C3 = (Si[r3&255]&255) ^ ((s[(r2>>8)&255]&255)<<8) ^ ((s[(r1>>16)&255]&255)<<16) ^ (s[(r0>>24)&255]<<24) ^ KW[0][3];\n    }\n}\n", "package org.bouncycastle.crypto.params;\n\nimport java.math.BigInteger;\n\npublic class DHPublicKeyParameters\n    extends DHKeyParameters\n{\n    private static final BigInteger ONE = BigInteger.valueOf(1);\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private BigInteger      y;\n\n    public DHPublicKeyParameters(\n        BigInteger      y,\n        DHParameters    params)\n    {\n        super(false, params);\n\n        this.y = validate(y, params);\n    }   \n\n    private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        // TLS check\n        if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n        {\n            throw new IllegalArgumentException(\"invalid DH public key\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            return y;         // we can't validate without Q.\n        }\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    public int hashCode()\n    {\n        return y.hashCode() ^ super.hashCode();\n    }\n\n    public boolean equals(\n        Object  obj)\n    {\n        if (!(obj instanceof DHPublicKeyParameters))\n        {\n            return false;\n        }\n\n        DHPublicKeyParameters   other = (DHPublicKeyParameters)obj;\n\n        return other.getY().equals(y) && super.equals(obj);\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\n\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHParameterSpec;\nimport javax.crypto.spec.DHPublicKeySpec;\n\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.pkcs.DHParameter;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.DomainParameters;\nimport org.bouncycastle.asn1.x9.ValidationParams;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.crypto.params.DHValidationParameters;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.KeyUtil;\n\npublic class BCDHPublicKey\n    implements DHPublicKey\n{\n    static final long serialVersionUID = -216691575254424324L;\n    \n    private BigInteger              y;\n\n    private transient DHPublicKeyParameters   dhPublicKey;\n    private transient DHParameterSpec         dhSpec;\n    private transient SubjectPublicKeyInfo    info;\n    \n    BCDHPublicKey(\n        DHPublicKeySpec spec)\n    {\n        this.y = spec.getY();\n        this.dhSpec = new DHParameterSpec(spec.getP(), spec.getG());\n        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(spec.getP(), spec.getG()));\n    }\n\n    BCDHPublicKey(\n        DHPublicKey key)\n    {\n        this.y = key.getY();\n        this.dhSpec = key.getParams();\n        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));\n    }\n\n    BCDHPublicKey(\n        DHPublicKeyParameters params)\n    {\n        this.y = params.getY();\n        this.dhSpec = new DHParameterSpec(params.getParameters().getP(), params.getParameters().getG(), params.getParameters().getL());\n        this.dhPublicKey = params;\n    }\n\n    BCDHPublicKey(\n        BigInteger y,\n        DHParameterSpec dhSpec)\n    {\n        this.y = y;\n        this.dhSpec = dhSpec;\n        this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));\n    }\n\n    public BCDHPublicKey(\n        SubjectPublicKeyInfo info)\n    {\n        this.info = info;\n\n        ASN1Integer              derY;\n        try\n        {\n            derY = (ASN1Integer)info.parsePublicKey();\n        }\n        catch (IOException e)\n        {\n            throw new IllegalArgumentException(\"invalid info structure in DH public key\");\n        }\n\n        this.y = derY.getValue();\n\n        ASN1Sequence seq = ASN1Sequence.getInstance(info.getAlgorithm().getParameters());\n        ASN1ObjectIdentifier id = info.getAlgorithm().getAlgorithm();\n\n        // we need the PKCS check to handle older keys marked with the X9 oid.\n        if (id.equals(PKCSObjectIdentifiers.dhKeyAgreement) || isPKCSParam(seq))\n        {\n            DHParameter             params = DHParameter.getInstance(seq);\n\n            if (params.getL() != null)\n            {\n                this.dhSpec = new DHParameterSpec(params.getP(), params.getG(), params.getL().intValue());\n            }\n            else\n            {\n                this.dhSpec = new DHParameterSpec(params.getP(), params.getG());\n            }\n            this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(dhSpec.getP(), dhSpec.getG()));\n        }\n        else if (id.equals(X9ObjectIdentifiers.dhpublicnumber))\n        {\n            DomainParameters params = DomainParameters.getInstance(seq);\n\n            this.dhSpec = new DHParameterSpec(params.getP(), params.getG());\n            ValidationParams validationParams = params.getValidationParams();\n            if (validationParams != null)\n            {\n                this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(params.getP(), params.getG(), params.getQ(), params.getJ(),\n                                            new DHValidationParameters(validationParams.getSeed(), validationParams.getPgenCounter().intValue())));\n            }\n            else\n            {\n                this.dhPublicKey = new DHPublicKeyParameters(y, new DHParameters(params.getP(), params.getG(), params.getQ(), params.getJ(), null));\n            }\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"unknown algorithm type: \" + id);\n        }\n    }\n\n    public String getAlgorithm()\n    {\n        return \"DH\";\n    }\n\n    public String getFormat()\n    {\n        return \"X.509\";\n    }\n\n    public byte[] getEncoded()\n    {\n        if (info != null)\n        {\n            return KeyUtil.getEncodedSubjectPublicKeyInfo(info);\n        }\n\n        return KeyUtil.getEncodedSubjectPublicKeyInfo(new AlgorithmIdentifier(PKCSObjectIdentifiers.dhKeyAgreement, new DHParameter(dhSpec.getP(), dhSpec.getG(), dhSpec.getL()).toASN1Primitive()), new ASN1Integer(y));\n    }\n\n    public DHParameterSpec getParams()\n    {\n        return dhSpec;\n    }\n\n    public BigInteger getY()\n    {\n        return y;\n    }\n\n    public DHPublicKeyParameters engineGetKeyParameters()\n    {\n        return dhPublicKey;\n    }\n\n    private boolean isPKCSParam(ASN1Sequence seq)\n    {\n        if (seq.size() == 2)\n        {\n            return true;\n        }\n        \n        if (seq.size() > 3)\n        {\n            return false;\n        }\n\n        ASN1Integer l = ASN1Integer.getInstance(seq.getObjectAt(2));\n        ASN1Integer p = ASN1Integer.getInstance(seq.getObjectAt(0));\n\n        if (l.getValue().compareTo(BigInteger.valueOf(p.getValue().bitLength())) > 0)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    public int hashCode()\n    {\n        return this.getY().hashCode() ^ this.getParams().getG().hashCode()\n                ^ this.getParams().getP().hashCode() ^ this.getParams().getL();\n    }\n\n    public boolean equals(\n        Object o)\n    {\n        if (!(o instanceof DHPublicKey))\n        {\n            return false;\n        }\n\n        DHPublicKey other = (DHPublicKey)o;\n\n        return this.getY().equals(other.getY())\n            && this.getParams().getG().equals(other.getParams().getG())\n            && this.getParams().getP().equals(other.getParams().getP())\n            && this.getParams().getL() == other.getParams().getL();\n    }\n\n    private void readObject(\n        ObjectInputStream   in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n\n        this.dhSpec = new DHParameterSpec((BigInteger)in.readObject(), (BigInteger)in.readObject(), in.readInt());\n        this.info = null;\n    }\n\n    private void writeObject(\n        ObjectOutputStream  out)\n        throws IOException\n    {\n        out.defaultWriteObject();\n\n        out.writeObject(dhSpec.getP());\n        out.writeObject(dhSpec.getG());\n        out.writeInt(dhSpec.getL());\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dh;\n\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DHPrivateKeySpec;\nimport javax.crypto.spec.DHPublicKeySpec;\n\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.BaseKeyFactorySpi;\n\npublic class KeyFactorySpi\n    extends BaseKeyFactorySpi\n{\n    public KeyFactorySpi()\n    {\n    }\n\n    protected KeySpec engineGetKeySpec(\n        Key key,\n        Class spec)\n        throws InvalidKeySpecException\n    {\n        if (spec.isAssignableFrom(DHPrivateKeySpec.class) && key instanceof DHPrivateKey)\n        {\n            DHPrivateKey k = (DHPrivateKey)key;\n\n            return new DHPrivateKeySpec(k.getX(), k.getParams().getP(), k.getParams().getG());\n        }\n        else if (spec.isAssignableFrom(DHPublicKeySpec.class) && key instanceof DHPublicKey)\n        {\n            DHPublicKey k = (DHPublicKey)key;\n\n            return new DHPublicKeySpec(k.getY(), k.getParams().getP(), k.getParams().getG());\n        }\n\n        return super.engineGetKeySpec(key, spec);\n    }\n\n    protected Key engineTranslateKey(\n        Key key)\n        throws InvalidKeyException\n    {\n        if (key instanceof DHPublicKey)\n        {\n            return new BCDHPublicKey((DHPublicKey)key);\n        }\n        else if (key instanceof DHPrivateKey)\n        {\n            return new BCDHPrivateKey((DHPrivateKey)key);\n        }\n\n        throw new InvalidKeyException(\"key type unknown\");\n    }\n\n    protected PrivateKey engineGeneratePrivate(\n        KeySpec keySpec)\n        throws InvalidKeySpecException\n    {\n        if (keySpec instanceof DHPrivateKeySpec)\n        {\n            return new BCDHPrivateKey((DHPrivateKeySpec)keySpec);\n        }\n\n        return super.engineGeneratePrivate(keySpec);\n    }\n\n    protected PublicKey engineGeneratePublic(\n        KeySpec keySpec)\n        throws InvalidKeySpecException\n    {\n        if (keySpec instanceof DHPublicKeySpec)\n        {\n            try\n            {\n                return new BCDHPublicKey((DHPublicKeySpec)keySpec);\n            }\n            catch (IllegalArgumentException e)\n            {\n                throw new InvalidKeySpecException(e.getMessage(), e);\n            }\n        }\n\n        return super.engineGeneratePublic(keySpec);\n    }\n\n    public PrivateKey generatePrivate(PrivateKeyInfo keyInfo)\n        throws IOException\n    {\n        ASN1ObjectIdentifier algOid = keyInfo.getPrivateKeyAlgorithm().getAlgorithm();\n\n        if (algOid.equals(PKCSObjectIdentifiers.dhKeyAgreement))\n        {\n            return new BCDHPrivateKey(keyInfo);\n        }\n        else if (algOid.equals(X9ObjectIdentifiers.dhpublicnumber))\n        {\n            return new BCDHPrivateKey(keyInfo);\n        }\n        else\n        {\n            throw new IOException(\"algorithm identifier \" + algOid + \" in key not recognised\");\n        }\n    }\n\n    public PublicKey generatePublic(SubjectPublicKeyInfo keyInfo)\n        throws IOException\n    {\n        ASN1ObjectIdentifier algOid = keyInfo.getAlgorithm().getAlgorithm();\n\n        if (algOid.equals(PKCSObjectIdentifiers.dhKeyAgreement))\n        {\n            return new BCDHPublicKey(keyInfo);\n        }\n        else if (algOid.equals(X9ObjectIdentifiers.dhpublicnumber))\n        {\n            return new BCDHPublicKey(keyInfo);\n        }\n        else\n        {\n            throw new IOException(\"algorithm identifier \" + algOid + \" in key not recognised\");\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ec;\n\nimport java.io.ByteArrayOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.KeyEncoder;\nimport org.bouncycastle.crypto.agreement.ECDHBasicAgreement;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.engines.AESEngine;\nimport org.bouncycastle.crypto.engines.DESedeEngine;\nimport org.bouncycastle.crypto.engines.IESEngine;\nimport org.bouncycastle.crypto.generators.ECKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.EphemeralKeyPairGenerator;\nimport org.bouncycastle.crypto.generators.KDF2BytesGenerator;\nimport org.bouncycastle.crypto.macs.HMac;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.params.ECKeyGenerationParameters;\nimport org.bouncycastle.crypto.params.ECKeyParameters;\nimport org.bouncycastle.crypto.params.ECPublicKeyParameters;\nimport org.bouncycastle.crypto.params.IESWithCipherParameters;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.bouncycastle.crypto.parsers.ECIESPublicKeyParser;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.IESUtil;\nimport org.bouncycastle.jcajce.provider.util.BadBlockException;\nimport org.bouncycastle.jcajce.util.BCJcaJceHelper;\nimport org.bouncycastle.jcajce.util.JcaJceHelper;\nimport org.bouncycastle.jce.interfaces.ECKey;\nimport org.bouncycastle.jce.interfaces.IESKey;\nimport org.bouncycastle.jce.spec.IESParameterSpec;\nimport org.bouncycastle.util.Strings;\n\n\npublic class IESCipher\n    extends CipherSpi\n{\n    private final JcaJceHelper helper = new BCJcaJceHelper();\n\n    private int ivLength;\n    private IESEngine engine;\n    private int state = -1;\n    private ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    private AlgorithmParameters engineParam = null;\n    private IESParameterSpec engineSpec = null;\n    private AsymmetricKeyParameter key;\n    private SecureRandom random;\n    private boolean dhaesMode = false;\n    private AsymmetricKeyParameter otherKeyParameter = null;\n\n    public IESCipher(IESEngine engine)\n    {\n        this.engine = engine;\n        this.ivLength = 0;\n    }\n\n    public IESCipher(IESEngine engine, int ivLength)\n    {\n        this.engine = engine;\n        this.ivLength = ivLength;\n    }\n\n    public int engineGetBlockSize()\n    {\n        if (engine.getCipher() != null)\n        {\n            return engine.getCipher().getBlockSize();\n        }\n        else\n        {\n            return 0;\n        }\n    }\n\n\n    public int engineGetKeySize(Key key)\n    {\n        if (key instanceof ECKey)\n        {\n            return ((ECKey)key).getParameters().getCurve().getFieldSize();\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"not an EC key\");\n        }\n    }\n\n\n    public byte[] engineGetIV()\n    {\n        if (engineSpec != null)\n        {\n            return engineSpec.getNonce();\n        }\n        return null;\n    }\n\n    public AlgorithmParameters engineGetParameters()\n    {\n        if (engineParam == null && engineSpec != null)\n        {\n            try\n            {\n                engineParam = helper.createAlgorithmParameters(\"IES\");\n                engineParam.init(engineSpec);\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.toString());\n            }\n        }\n\n        return engineParam;\n    }\n\n\n    public void engineSetMode(String mode)\n        throws NoSuchAlgorithmException\n    {\n        String modeName = Strings.toUpperCase(mode);\n\n        if (modeName.equals(\"NONE\"))\n        {\n            dhaesMode = false;\n        }\n        else if (modeName.equals(\"DHAES\"))\n        {\n            dhaesMode = true;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"can't support mode \" + mode);\n        }\n    }\n\n\n    public int engineGetOutputSize(int inputLen)\n    {\n        int len1, len2, len3;\n\n        if (key == null)\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        len1 = engine.getMac().getMacSize();\n\n        if (otherKeyParameter == null)\n        {\n            len2 = 2 * (((ECKeyParameters)key).getParameters().getCurve().getFieldSize() + 7) / 8;\n        }\n        else\n        {\n            len2 = 0;\n        }\n\n        if (engine.getCipher() == null)\n        {\n            len3 = inputLen;\n        }\n        else if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen);\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            len3 = engine.getCipher().getOutputSize(inputLen - len1 - len2);\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            return buffer.size() + len1 + 1 + len2 + len3;\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            return buffer.size() - len1 - len2 + len3;\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public void engineSetPadding(String padding)\n        throws NoSuchPaddingException\n    {\n        String paddingName = Strings.toUpperCase(padding);\n\n        // TDOD: make this meaningful...\n        if (paddingName.equals(\"NOPADDING\"))\n        {\n\n        }\n        else if (paddingName.equals(\"PKCS5PADDING\") || paddingName.equals(\"PKCS7PADDING\"))\n        {\n\n        }\n        else\n        {\n            throw new NoSuchPaddingException(\"padding not available with IESCipher\");\n        }\n    }\n\n\n    // Initialisation methods\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameters params,\n        SecureRandom random)\n        throws InvalidKeyException, InvalidAlgorithmParameterException\n    {\n        AlgorithmParameterSpec paramSpec = null;\n\n        if (params != null)\n        {\n            try\n            {\n                paramSpec = params.getParameterSpec(IESParameterSpec.class);\n            }\n            catch (Exception e)\n            {\n                throw new InvalidAlgorithmParameterException(\"cannot recognise parameters: \" + e.toString());\n            }\n        }\n\n        engineParam = params;\n        engineInit(opmode, key, paramSpec, random);\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        AlgorithmParameterSpec engineSpec,\n        SecureRandom random)\n        throws InvalidAlgorithmParameterException, InvalidKeyException\n    {\n        otherKeyParameter = null;\n\n        // Use default parameters (including cipher key size) if none are specified\n        if (engineSpec == null)\n        {\n            byte[] nonce = null;\n            if (ivLength != 0 && opmode == Cipher.ENCRYPT_MODE)\n            {\n                nonce = new byte[ivLength];\n                random.nextBytes(nonce);\n            }\n            this.engineSpec = IESUtil.guessParameterSpec(engine.getCipher(), nonce);\n        }\n        else if (engineSpec instanceof IESParameterSpec)\n        {\n            this.engineSpec = (IESParameterSpec)engineSpec;\n        }\n        else\n        {\n            throw new InvalidAlgorithmParameterException(\"must be passed IES parameters\");\n        }\n\n        byte[] nonce = this.engineSpec.getNonce();\n\n        if (ivLength != 0 && (nonce == null || nonce.length != ivLength))\n        {\n            throw new InvalidAlgorithmParameterException(\"NONCE in IES Parameters needs to be \" + ivLength + \" bytes long\");\n        }\n\n        // Parse the recipient's key\n        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.WRAP_MODE)\n        {\n            if (key instanceof PublicKey)\n            {\n                this.key = ECUtils.generatePublicKeyParameter((PublicKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.key = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.otherKeyParameter = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's public EC key for encryption\");\n            }\n        }\n        else if (opmode == Cipher.DECRYPT_MODE || opmode == Cipher.UNWRAP_MODE)\n        {\n            if (key instanceof PrivateKey)\n            {\n                this.key = ECUtil.generatePrivateKeyParameter((PrivateKey)key);\n            }\n            else if (key instanceof IESKey)\n            {\n                IESKey ieKey = (IESKey)key;\n\n                this.otherKeyParameter = ECUtils.generatePublicKeyParameter(ieKey.getPublic());\n                this.key = ECUtil.generatePrivateKeyParameter(ieKey.getPrivate());\n            }\n            else\n            {\n                throw new InvalidKeyException(\"must be passed recipient's private EC key for decryption\");\n            }\n        }\n        else\n        {\n            throw new InvalidKeyException(\"must be passed EC key\");\n        }\n\n\n        this.random = random;\n        this.state = opmode;\n        buffer.reset();\n\n    }\n\n\n    public void engineInit(\n        int opmode,\n        Key key,\n        SecureRandom random)\n        throws InvalidKeyException\n    {\n        try\n        {\n            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            throw new IllegalArgumentException(\"cannot handle supplied parameter spec: \" + e.getMessage());\n        }\n\n    }\n\n\n    // Update methods - buffer the input\n\n    public byte[] engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return null;\n    }\n\n\n    public int engineUpdate(\n        byte[] input,\n        int inputOffset,\n        int inputLen,\n        byte[] output,\n        int outputOffset)\n    {\n        buffer.write(input, inputOffset, inputLen);\n        return 0;\n    }\n\n\n    // Finalisation methods\n\n    public byte[] engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLen)\n        throws IllegalBlockSizeException, BadPaddingException\n    {\n        if (inputLen != 0)\n        {\n            buffer.write(input, inputOffset, inputLen);\n        }\n\n        final byte[] in = buffer.toByteArray();\n        buffer.reset();\n\n        // Convert parameters for use in IESEngine\n        CipherParameters params = new IESWithCipherParameters(engineSpec.getDerivationV(),\n            engineSpec.getEncodingV(),\n            engineSpec.getMacKeySize(),\n            engineSpec.getCipherKeySize());\n\n        if (engineSpec.getNonce() != null)\n        {\n            params = new ParametersWithIV(params, engineSpec.getNonce());\n        }\n\n        final ECDomainParameters ecParams = ((ECKeyParameters)key).getParameters();\n\n        final byte[] V;\n\n        if (otherKeyParameter != null)\n        {\n            try\n            {\n                if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n                {\n                    engine.init(true, otherKeyParameter, key, params);\n                }\n                else\n                {\n                    engine.init(false, key, otherKeyParameter, params);\n                }\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (Exception e)\n            {\n                throw new BadBlockException(\"unable to process block\", e);\n            }\n        }\n\n        if (state == Cipher.ENCRYPT_MODE || state == Cipher.WRAP_MODE)\n        {\n            // Generate the ephemeral key pair\n            ECKeyPairGenerator gen = new ECKeyPairGenerator();\n            gen.init(new ECKeyGenerationParameters(ecParams, random));\n\n            final boolean usePointCompression = engineSpec.getPointCompression();\n            EphemeralKeyPairGenerator kGen = new EphemeralKeyPairGenerator(gen, new KeyEncoder()\n            {\n                public byte[] getEncoded(AsymmetricKeyParameter keyParameter)\n                {\n                    return ((ECPublicKeyParameters)keyParameter).getQ().getEncoded(usePointCompression);\n                }\n            });\n\n            // Encrypt the buffer\n            try\n            {\n                engine.init(key, params, kGen);\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (final Exception e)\n            {\n                throw new BadBlockException(\"unable to process block\", e);\n            }\n        }\n        else if (state == Cipher.DECRYPT_MODE || state == Cipher.UNWRAP_MODE)\n        {\n            // Decrypt the buffer\n            try\n            {\n                engine.init(key, params, new ECIESPublicKeyParser(ecParams));\n\n                return engine.processBlock(in, 0, in.length);\n            }\n            catch (InvalidCipherTextException e)\n            {\n                throw new BadBlockException(\"unable to process block\", e);\n            }\n        }\n        else\n        {\n            throw new IllegalStateException(\"cipher not initialised\");\n        }\n\n    }\n\n    public int engineDoFinal(\n        byte[] input,\n        int inputOffset,\n        int inputLength,\n        byte[] output,\n        int outputOffset)\n        throws ShortBufferException, IllegalBlockSizeException, BadPaddingException\n    {\n\n        byte[] buf = engineDoFinal(input, inputOffset, inputLength);\n        System.arraycopy(buf, 0, output, outputOffset, buf.length);\n        return buf.length;\n    }\n\n    /**\n     * Classes that inherit from us\n     */\n\n    static public class ECIES\n        extends IESCipher\n    {\n        public ECIES()\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                new KDF2BytesGenerator(new SHA1Digest()),\n                new HMac(new SHA1Digest())));\n        }\n    }\n\n    static public class ECIESwithCipher\n        extends IESCipher\n    {\n        public ECIESwithCipher(BlockCipher cipher, int ivLength)\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                            new KDF2BytesGenerator(new SHA1Digest()),\n                            new HMac(new SHA1Digest()),\n                            new PaddedBufferedBlockCipher(cipher)), ivLength);\n        }\n    }\n\n    static public class ECIESwithDESedeCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithDESedeCBC()\n        {\n            super(new CBCBlockCipher(new DESedeEngine()), 8);\n        }\n    }\n\n    static public class ECIESwithAESCBC\n        extends ECIESwithCipher\n    {\n        public ECIESwithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESEngine()), 16);\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.util;\n\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\n\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\n\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.crypto.params.DHParameters;\nimport org.bouncycastle.crypto.params.DHPrivateKeyParameters;\nimport org.bouncycastle.crypto.params.DHPublicKeyParameters;\nimport org.bouncycastle.jcajce.provider.asymmetric.dh.BCDHPublicKey;\n\n/**\n * utility class for converting jce/jca DH objects\n * objects into their org.bouncycastle.crypto counterparts.\n */\npublic class DHUtil\n{\n    static public AsymmetricKeyParameter generatePublicKeyParameter(\n        PublicKey    key)\n        throws InvalidKeyException\n    {\n        if (key instanceof BCDHPublicKey)\n        {\n            return ((BCDHPublicKey)key).engineGetKeyParameters();\n        }\n        if (key instanceof DHPublicKey)\n        {\n            DHPublicKey    k = (DHPublicKey)key;\n\n            return new DHPublicKeyParameters(k.getY(),\n                new DHParameters(k.getParams().getP(), k.getParams().getG(), null, k.getParams().getL()));\n        }\n\n        throw new InvalidKeyException(\"can't identify DH public key.\");\n    }\n\n    static public AsymmetricKeyParameter generatePrivateKeyParameter(\n        PrivateKey    key)\n        throws InvalidKeyException\n    {\n        if (key instanceof DHPrivateKey)\n        {\n            DHPrivateKey    k = (DHPrivateKey)key;\n\n            return new DHPrivateKeyParameters(k.getX(),\n                new DHParameters(k.getParams().getP(), k.getParams().getG(), null, k.getParams().getL()));\n        }\n                        \n        throw new InvalidKeyException(\"can't identify DH private key.\");\n    }\n}\n", "package org.bouncycastle.jcajce.provider.symmetric;\n\nimport java.io.IOException;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\n\nimport javax.crypto.spec.IvParameterSpec;\n\nimport org.bouncycastle.asn1.bc.BCObjectIdentifiers;\nimport org.bouncycastle.asn1.cms.CCMParameters;\nimport org.bouncycastle.asn1.cms.GCMParameters;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.crypto.BlockCipher;\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.crypto.CipherKeyGenerator;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DataLengthException;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.Mac;\nimport org.bouncycastle.crypto.engines.AESEngine;\nimport org.bouncycastle.crypto.engines.AESWrapEngine;\nimport org.bouncycastle.crypto.engines.RFC3211WrapEngine;\nimport org.bouncycastle.crypto.engines.RFC5649WrapEngine;\nimport org.bouncycastle.crypto.generators.Poly1305KeyGenerator;\nimport org.bouncycastle.crypto.macs.CMac;\nimport org.bouncycastle.crypto.macs.GMac;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.modes.CCMBlockCipher;\nimport org.bouncycastle.crypto.modes.CFBBlockCipher;\nimport org.bouncycastle.crypto.modes.GCMBlockCipher;\nimport org.bouncycastle.crypto.modes.OFBBlockCipher;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseAlgorithmParameterGenerator;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseAlgorithmParameters;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseKeyGenerator;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseMac;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BaseWrapCipher;\nimport org.bouncycastle.jcajce.provider.symmetric.util.BlockCipherProvider;\nimport org.bouncycastle.jcajce.provider.symmetric.util.IvAlgorithmParameters;\nimport org.bouncycastle.jcajce.provider.symmetric.util.PBESecretKeyFactory;\nimport org.bouncycastle.jcajce.spec.AEADParameterSpec;\n\npublic final class AES\n{\n    private static final Class gcmSpecClass = lookup(\"javax.crypto.spec.GCMParameterSpec\");\n\n    private AES()\n    {\n    }\n    \n    public static class ECB\n        extends BaseBlockCipher\n    {\n        public ECB()\n        {\n            super(new BlockCipherProvider()\n            {\n                public BlockCipher get()\n                {\n                    return new AESEngine();\n                }\n            });\n        }\n    }\n\n    public static class CBC\n       extends BaseBlockCipher\n    {\n        public CBC()\n        {\n            super(new CBCBlockCipher(new AESEngine()), 128);\n        }\n    }\n\n    static public class CFB\n        extends BaseBlockCipher\n    {\n        public CFB()\n        {\n            super(new BufferedBlockCipher(new CFBBlockCipher(new AESEngine(), 128)), 128);\n        }\n    }\n\n    static public class OFB\n        extends BaseBlockCipher\n    {\n        public OFB()\n        {\n            super(new BufferedBlockCipher(new OFBBlockCipher(new AESEngine(), 128)), 128);\n        }\n    }\n\n    static public class GCM\n        extends BaseBlockCipher\n    {\n        public GCM()\n        {\n            super(new GCMBlockCipher(new AESEngine()));\n        }\n    }\n\n    static public class CCM\n        extends BaseBlockCipher\n    {\n        public CCM()\n        {\n            super(new CCMBlockCipher(new AESEngine()), false, 16);\n        }\n    }\n\n    public static class AESCMAC\n        extends BaseMac\n    {\n        public AESCMAC()\n        {\n            super(new CMac(new AESEngine()));\n        }\n    }\n\n    public static class AESGMAC\n        extends BaseMac\n    {\n        public AESGMAC()\n        {\n            super(new GMac(new GCMBlockCipher(new AESEngine())));\n        }\n    }\n\n    public static class AESCCMMAC\n        extends BaseMac\n    {\n        public AESCCMMAC()\n        {\n            super(new CCMMac());\n        }\n\n        private static class CCMMac\n            implements Mac\n        {\n            private final CCMBlockCipher ccm = new CCMBlockCipher(new AESEngine());\n\n            private int macLength = 8;\n\n            public void init(CipherParameters params)\n                throws IllegalArgumentException\n            {\n                ccm.init(true, params);\n\n                this.macLength = ccm.getMac().length;\n            }\n\n            public String getAlgorithmName()\n            {\n                return ccm.getAlgorithmName() + \"Mac\";\n            }\n\n            public int getMacSize()\n            {\n                return macLength;\n            }\n\n            public void update(byte in)\n                throws IllegalStateException\n            {\n                ccm.processAADByte(in);\n            }\n\n            public void update(byte[] in, int inOff, int len)\n                throws DataLengthException, IllegalStateException\n            {\n                ccm.processAADBytes(in, inOff, len);\n            }\n\n            public int doFinal(byte[] out, int outOff)\n                throws DataLengthException, IllegalStateException\n            {\n                try\n                {\n                    return ccm.doFinal(out, 0);\n                }\n                catch (InvalidCipherTextException e)\n                {\n                    throw new IllegalStateException(\"exception on doFinal()\", e);\n                }\n            }\n\n            public void reset()\n            {\n                ccm.reset();\n            }\n        }\n    }\n\n    public static class Poly1305\n        extends BaseMac\n    {\n        public Poly1305()\n        {\n            super(new org.bouncycastle.crypto.macs.Poly1305(new AESEngine()));\n        }\n    }\n\n    public static class Poly1305KeyGen\n        extends BaseKeyGenerator\n    {\n        public Poly1305KeyGen()\n        {\n            super(\"Poly1305-AES\", 256, new Poly1305KeyGenerator());\n        }\n    }\n\n    static public class Wrap\n        extends BaseWrapCipher\n    {\n        public Wrap()\n        {\n            super(new AESWrapEngine());\n        }\n    }\n\n    public static class RFC3211Wrap\n        extends BaseWrapCipher\n    {\n        public RFC3211Wrap()\n        {\n            super(new RFC3211WrapEngine(new AESEngine()), 16);\n        }\n    }\n\n    public static class RFC5649Wrap\n        extends BaseWrapCipher\n    {\n        public RFC5649Wrap()\n        {\n            super(new RFC5649WrapEngine(new AESEngine()));\n        }\n    }\n\n    /**\n     * PBEWithAES-CBC\n     */\n    static public class PBEWithAESCBC\n        extends BaseBlockCipher\n    {\n        public PBEWithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESEngine()));\n        }\n    }\n\n    /**\n     * PBEWithSHA1AES-CBC\n     */\n    static public class PBEWithSHA1AESCBC128\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA1AESCBC128()\n        {\n            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 128, 16);\n        }\n    }\n\n    static public class PBEWithSHA1AESCBC192\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA1AESCBC192()\n        {\n            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 192, 16);\n        }\n    }\n\n    static public class PBEWithSHA1AESCBC256\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA1AESCBC256()\n        {\n            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA1, 256, 16);\n        }\n    }\n\n    /**\n     * PBEWithSHA256AES-CBC\n     */\n    static public class PBEWithSHA256AESCBC128\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA256AESCBC128()\n        {\n            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 128, 16);\n        }\n    }\n\n    static public class PBEWithSHA256AESCBC192\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA256AESCBC192()\n        {\n            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 192, 16);\n        }\n    }\n\n    static public class PBEWithSHA256AESCBC256\n        extends BaseBlockCipher\n    {\n        public PBEWithSHA256AESCBC256()\n        {\n            super(new CBCBlockCipher(new AESEngine()), PKCS12, SHA256, 256, 16);\n        }\n    }\n\n    public static class KeyGen\n        extends BaseKeyGenerator\n    {\n        public KeyGen()\n        {\n            this(192);\n        }\n\n        public KeyGen(int keySize)\n        {\n            super(\"AES\", keySize, new CipherKeyGenerator());\n        }\n    }\n\n    public static class KeyGen128\n        extends KeyGen\n    {\n        public KeyGen128()\n        {\n            super(128);\n        }\n    }\n\n    public static class KeyGen192\n        extends KeyGen\n    {\n        public KeyGen192()\n        {\n            super(192);\n        }\n    }\n\n    public static class KeyGen256\n        extends KeyGen\n    {\n        public KeyGen256()\n        {\n            super(256);\n        }\n    }\n    \n    /**\n     * PBEWithSHA1And128BitAES-BC\n     */\n    static public class PBEWithSHAAnd128BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHAAnd128BitAESBC()\n        {\n            super(\"PBEWithSHA1And128BitAES-CBC-BC\", null, true, PKCS12, SHA1, 128, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA1And192BitAES-BC\n     */\n    static public class PBEWithSHAAnd192BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHAAnd192BitAESBC()\n        {\n            super(\"PBEWithSHA1And192BitAES-CBC-BC\", null, true, PKCS12, SHA1, 192, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA1And256BitAES-BC\n     */\n    static public class PBEWithSHAAnd256BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHAAnd256BitAESBC()\n        {\n            super(\"PBEWithSHA1And256BitAES-CBC-BC\", null, true, PKCS12, SHA1, 256, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA256And128BitAES-BC\n     */\n    static public class PBEWithSHA256And128BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHA256And128BitAESBC()\n        {\n            super(\"PBEWithSHA256And128BitAES-CBC-BC\", null, true, PKCS12, SHA256, 128, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA256And192BitAES-BC\n     */\n    static public class PBEWithSHA256And192BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHA256And192BitAESBC()\n        {\n            super(\"PBEWithSHA256And192BitAES-CBC-BC\", null, true, PKCS12, SHA256, 192, 128);\n        }\n    }\n    \n    /**\n     * PBEWithSHA256And256BitAES-BC\n     */\n    static public class PBEWithSHA256And256BitAESBC\n        extends PBESecretKeyFactory\n    {\n        public PBEWithSHA256And256BitAESBC()\n        {\n            super(\"PBEWithSHA256And256BitAES-CBC-BC\", null, true, PKCS12, SHA256, 256, 128);\n        }\n    }\n    \n    /**\n     * PBEWithMD5And128BitAES-OpenSSL\n     */\n    static public class PBEWithMD5And128BitAESCBCOpenSSL\n        extends PBESecretKeyFactory\n    {\n        public PBEWithMD5And128BitAESCBCOpenSSL()\n        {\n            super(\"PBEWithMD5And128BitAES-CBC-OpenSSL\", null, true, OPENSSL, MD5, 128, 128);\n        }\n    }\n    \n    /**\n     * PBEWithMD5And192BitAES-OpenSSL\n     */\n    static public class PBEWithMD5And192BitAESCBCOpenSSL\n        extends PBESecretKeyFactory\n    {\n        public PBEWithMD5And192BitAESCBCOpenSSL()\n        {\n            super(\"PBEWithMD5And192BitAES-CBC-OpenSSL\", null, true, OPENSSL, MD5, 192, 128);\n        }\n    }\n    \n    /**\n     * PBEWithMD5And256BitAES-OpenSSL\n     */\n    static public class PBEWithMD5And256BitAESCBCOpenSSL\n        extends PBESecretKeyFactory\n    {\n        public PBEWithMD5And256BitAESCBCOpenSSL()\n        {\n            super(\"PBEWithMD5And256BitAES-CBC-OpenSSL\", null, true, OPENSSL, MD5, 256, 128);\n        }\n    }\n    \n    public static class AlgParamGen\n        extends BaseAlgorithmParameterGenerator\n    {\n        protected void engineInit(\n            AlgorithmParameterSpec genParamSpec,\n            SecureRandom random)\n            throws InvalidAlgorithmParameterException\n        {\n            throw new InvalidAlgorithmParameterException(\"No supported AlgorithmParameterSpec for AES parameter generation.\");\n        }\n\n        protected AlgorithmParameters engineGenerateParameters()\n        {\n            byte[]  iv = new byte[16];\n\n            if (random == null)\n            {\n                random = new SecureRandom();\n            }\n\n            random.nextBytes(iv);\n\n            AlgorithmParameters params;\n\n            try\n            {\n                params = createParametersInstance(\"AES\");\n                params.init(new IvParameterSpec(iv));\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.getMessage());\n            }\n\n            return params;\n        }\n    }\n\n    public static class AlgParamGenCCM\n        extends BaseAlgorithmParameterGenerator\n    {\n        protected void engineInit(\n            AlgorithmParameterSpec genParamSpec,\n            SecureRandom random)\n            throws InvalidAlgorithmParameterException\n        {\n            // TODO: add support for GCMParameterSpec as a template.\n            throw new InvalidAlgorithmParameterException(\"No supported AlgorithmParameterSpec for AES parameter generation.\");\n        }\n\n        protected AlgorithmParameters engineGenerateParameters()\n        {\n            byte[]  iv = new byte[12];\n\n            if (random == null)\n            {\n                random = new SecureRandom();\n            }\n\n            random.nextBytes(iv);\n\n            AlgorithmParameters params;\n\n            try\n            {\n                params = createParametersInstance(\"CCM\");\n                params.init(new CCMParameters(iv, 12).getEncoded());\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.getMessage());\n            }\n\n            return params;\n        }\n    }\n\n    public static class AlgParamGenGCM\n        extends BaseAlgorithmParameterGenerator\n    {\n        protected void engineInit(\n            AlgorithmParameterSpec genParamSpec,\n            SecureRandom random)\n            throws InvalidAlgorithmParameterException\n        {\n            // TODO: add support for GCMParameterSpec as a template.\n            throw new InvalidAlgorithmParameterException(\"No supported AlgorithmParameterSpec for AES parameter generation.\");\n        }\n\n        protected AlgorithmParameters engineGenerateParameters()\n        {\n            byte[]  nonce = new byte[12];\n\n            if (random == null)\n            {\n                random = new SecureRandom();\n            }\n\n            random.nextBytes(nonce);\n\n            AlgorithmParameters params;\n\n            try\n            {\n                params = createParametersInstance(\"GCM\");\n                params.init(new GCMParameters(nonce, 16).getEncoded());\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e.getMessage());\n            }\n\n            return params;\n        }\n    }\n\n    public static class AlgParams\n        extends IvAlgorithmParameters\n    {\n        protected String engineToString()\n        {\n            return \"AES IV\";\n        }\n    }\n\n    public static class AlgParamsGCM\n        extends BaseAlgorithmParameters\n    {\n        private GCMParameters gcmParams;\n\n        protected void engineInit(AlgorithmParameterSpec paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                gcmParams = GcmSpecUtil.extractGcmParameters(paramSpec);\n            }\n            else if (paramSpec instanceof AEADParameterSpec)\n            {\n                gcmParams = new GCMParameters(((AEADParameterSpec)paramSpec).getNonce(), ((AEADParameterSpec)paramSpec).getMacSizeInBits() / 8);\n            }\n            else\n            {\n                throw new InvalidParameterSpecException(\"AlgorithmParameterSpec class not recognized: \" + paramSpec.getClass().getName());\n            }\n        }\n\n        protected void engineInit(byte[] params)\n            throws IOException\n        {\n            gcmParams = GCMParameters.getInstance(params);\n        }\n\n        protected void engineInit(byte[] params, String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            gcmParams = GCMParameters.getInstance(params);\n        }\n\n        protected byte[] engineGetEncoded()\n            throws IOException\n        {\n            return gcmParams.getEncoded();\n        }\n\n        protected byte[] engineGetEncoded(String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            return gcmParams.getEncoded();\n        }\n\n        protected String engineToString()\n        {\n            return \"GCM\";\n        }\n\n        protected AlgorithmParameterSpec localEngineGetParameterSpec(Class paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (paramSpec == AlgorithmParameterSpec.class || GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                if (GcmSpecUtil.gcmSpecExists())\n                {\n                    return GcmSpecUtil.extractGcmSpec(gcmParams.toASN1Primitive());\n                }\n                return new AEADParameterSpec(gcmParams.getNonce(), gcmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == AEADParameterSpec.class)\n            {\n                return new AEADParameterSpec(gcmParams.getNonce(), gcmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == IvParameterSpec.class)\n            {\n                return new IvParameterSpec(gcmParams.getNonce());\n            }\n\n            throw new InvalidParameterSpecException(\"AlgorithmParameterSpec not recognized: \" + paramSpec.getName());\n        }\n    }\n\n    public static class AlgParamsCCM\n        extends BaseAlgorithmParameters\n    {\n        private CCMParameters ccmParams;\n\n        protected void engineInit(AlgorithmParameterSpec paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                ccmParams = CCMParameters.getInstance(GcmSpecUtil.extractGcmParameters(paramSpec));\n            }\n            else if (paramSpec instanceof AEADParameterSpec)\n            {\n                ccmParams = new CCMParameters(((AEADParameterSpec)paramSpec).getNonce(), ((AEADParameterSpec)paramSpec).getMacSizeInBits() / 8);\n            }\n            else\n            {\n                throw new InvalidParameterSpecException(\"AlgorithmParameterSpec class not recognized: \" + paramSpec.getClass().getName());\n            }\n        }\n\n        protected void engineInit(byte[] params)\n            throws IOException\n        {\n            ccmParams = CCMParameters.getInstance(params);\n        }\n\n        protected void engineInit(byte[] params, String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            ccmParams = CCMParameters.getInstance(params);\n        }\n\n        protected byte[] engineGetEncoded()\n            throws IOException\n        {\n            return ccmParams.getEncoded();\n        }\n\n        protected byte[] engineGetEncoded(String format)\n            throws IOException\n        {\n            if (!isASN1FormatString(format))\n            {\n                throw new IOException(\"unknown format specified\");\n            }\n\n            return ccmParams.getEncoded();\n        }\n\n        protected String engineToString()\n        {\n            return \"CCM\";\n        }\n\n        protected AlgorithmParameterSpec localEngineGetParameterSpec(Class paramSpec)\n            throws InvalidParameterSpecException\n        {\n            if (paramSpec == AlgorithmParameterSpec.class || GcmSpecUtil.isGcmSpec(paramSpec))\n            {\n                if (GcmSpecUtil.gcmSpecExists())\n                {\n                    return GcmSpecUtil.extractGcmSpec(ccmParams.toASN1Primitive());\n                }\n                return new AEADParameterSpec(ccmParams.getNonce(), ccmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == AEADParameterSpec.class)\n            {\n                return new AEADParameterSpec(ccmParams.getNonce(), ccmParams.getIcvLen() * 8);\n            }\n            if (paramSpec == IvParameterSpec.class)\n            {\n                return new IvParameterSpec(ccmParams.getNonce());\n            }\n\n            throw new InvalidParameterSpecException(\"AlgorithmParameterSpec not recognized: \" + paramSpec.getName());\n        }\n    }\n\n    public static class Mappings\n        extends SymmetricAlgorithmProvider\n    {\n        private static final String PREFIX = AES.class.getName();\n        \n        /**\n         * These three got introduced in some messages as a result of a typo in an\n         * early document. We don't produce anything using these OID values, but we'll\n         * read them.\n         */\n        private static final String wrongAES128 = \"2.16.840.1.101.3.4.2\";\n        private static final String wrongAES192 = \"2.16.840.1.101.3.4.22\";\n        private static final String wrongAES256 = \"2.16.840.1.101.3.4.42\";\n\n        public Mappings()\n        {\n        }\n\n        public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"AlgorithmParameters.AES\", PREFIX + \"$AlgParams\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + wrongAES128, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + wrongAES192, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + wrongAES256, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes128_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes192_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes256_CBC, \"AES\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.GCM\", PREFIX + \"$AlgParamsGCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes128_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes192_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes256_GCM, \"GCM\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.CCM\", PREFIX + \"$AlgParamsCCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes128_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes192_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + NISTObjectIdentifiers.id_aes256_CCM, \"CCM\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.AES\", PREFIX + \"$AlgParamGen\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + wrongAES128, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + wrongAES192, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + wrongAES256, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes128_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes192_CBC, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes256_CBC, \"AES\");\n\n            provider.addAlgorithm(\"Cipher.AES\", PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.\" + wrongAES128, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.\" + wrongAES192, \"AES\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.\" + wrongAES256, \"AES\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_ECB, PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_ECB, PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_ECB, PREFIX + \"$ECB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_CBC, PREFIX + \"$CBC\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_CBC, PREFIX + \"$CBC\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_CBC, PREFIX + \"$CBC\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_OFB, PREFIX + \"$OFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_OFB, PREFIX + \"$OFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_OFB, PREFIX + \"$OFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes128_CFB, PREFIX + \"$CFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes192_CFB, PREFIX + \"$CFB\");\n            provider.addAlgorithm(\"Cipher\", NISTObjectIdentifiers.id_aes256_CFB, PREFIX + \"$CFB\");\n            provider.addAlgorithm(\"Cipher.AESWRAP\", PREFIX + \"$Wrap\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes128_wrap, \"AESWRAP\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes192_wrap, \"AESWRAP\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes256_wrap, \"AESWRAP\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.AESKW\", \"AESWRAP\");\n\n            provider.addAlgorithm(\"Cipher.AESRFC3211WRAP\", PREFIX + \"$RFC3211Wrap\");\n            provider.addAlgorithm(\"Cipher.AESRFC5649WRAP\", PREFIX + \"$RFC5649Wrap\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.CCM\", PREFIX + \"$AlgParamGenCCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes128_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes192_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes256_CCM, \"CCM\");\n\n            provider.addAlgorithm(\"Cipher.CCM\", PREFIX + \"$CCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes128_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes192_CCM, \"CCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes256_CCM, \"CCM\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.GCM\", PREFIX + \"$AlgParamGenGCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes128_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes192_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.\" + NISTObjectIdentifiers.id_aes256_GCM, \"GCM\");\n\n            provider.addAlgorithm(\"Cipher.GCM\", PREFIX + \"$GCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes128_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes192_GCM, \"GCM\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", NISTObjectIdentifiers.id_aes256_GCM, \"GCM\");\n\n            provider.addAlgorithm(\"KeyGenerator.AES\", PREFIX + \"$KeyGen\");\n            provider.addAlgorithm(\"KeyGenerator.\" + wrongAES128, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator.\" + wrongAES192, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator.\" + wrongAES256, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_ECB, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_CBC, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_OFB, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_CFB, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_ECB, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_CBC, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_OFB, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_CFB, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_ECB, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_CBC, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_OFB, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_CFB, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator.AESWRAP\", PREFIX + \"$KeyGen\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_wrap, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_wrap, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_wrap, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_GCM, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_GCM, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_GCM, PREFIX + \"$KeyGen256\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes128_CCM, PREFIX + \"$KeyGen128\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes192_CCM, PREFIX + \"$KeyGen192\");\n            provider.addAlgorithm(\"KeyGenerator\", NISTObjectIdentifiers.id_aes256_CCM, PREFIX + \"$KeyGen256\");\n\n            provider.addAlgorithm(\"Mac.AESCMAC\", PREFIX + \"$AESCMAC\");\n\n            provider.addAlgorithm(\"Mac.AESCCMMAC\", PREFIX + \"$AESCCMMAC\");\n            provider.addAlgorithm(\"Alg.Alias.Mac.\" + NISTObjectIdentifiers.id_aes128_CCM.getId(), \"AESCCMMAC\");\n            provider.addAlgorithm(\"Alg.Alias.Mac.\" + NISTObjectIdentifiers.id_aes192_CCM.getId(), \"AESCCMMAC\");\n            provider.addAlgorithm(\"Alg.Alias.Mac.\" + NISTObjectIdentifiers.id_aes256_CCM.getId(), \"AESCCMMAC\");\n\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc, \"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc, \"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc, \"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc, \"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc, \"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc, \"PBEWITHSHA256AND256BITAES-CBC-BC\");\n\n            provider.addAlgorithm(\"Cipher.PBEWITHSHAAND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA1AESCBC128\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHAAND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA1AESCBC192\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHAAND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA1AESCBC256\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHA256AND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256AESCBC128\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHA256AND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256AESCBC192\");\n            provider.addAlgorithm(\"Cipher.PBEWITHSHA256AND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256AESCBC256\");\n            \n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHAAND128BITAES-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHAAND192BITAES-BC\", \"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHAAND256BITAES-BC\", \"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND128BITAES-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND192BITAES-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA1AND256BITAES-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND128BITAES-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND192BITAES-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-1AND256BITAES-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND128BITAES-CBC-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND192BITAES-CBC-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND256BITAES-CBC-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA256AND128BITAES-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA256AND192BITAES-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA256AND256BITAES-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND128BITAES-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND192BITAES-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.Cipher.PBEWITHSHA-256AND256BITAES-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n\n            provider.addAlgorithm(\"Cipher.PBEWITHMD5AND128BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithAESCBC\");\n            provider.addAlgorithm(\"Cipher.PBEWITHMD5AND192BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithAESCBC\");\n            provider.addAlgorithm(\"Cipher.PBEWITHMD5AND256BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithAESCBC\");\n            \n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHMD5AND128BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithMD5And128BitAESCBCOpenSSL\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHMD5AND192BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithMD5And192BitAESCBCOpenSSL\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHMD5AND256BITAES-CBC-OPENSSL\", PREFIX + \"$PBEWithMD5And256BitAESCBCOpenSSL\");\n            \n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHAAND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHAAnd128BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHAAND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHAAnd192BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHAAND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHAAnd256BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHA256AND128BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256And128BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHA256AND192BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256And192BitAESBC\");\n            provider.addAlgorithm(\"SecretKeyFactory.PBEWITHSHA256AND256BITAES-CBC-BC\", PREFIX + \"$PBEWithSHA256And256BitAESBC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-1AND128BITAES-CBC-BC\",\"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-1AND192BITAES-CBC-BC\",\"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-1AND256BITAES-CBC-BC\",\"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND128BITAES-CBC-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND192BITAES-CBC-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND256BITAES-CBC-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND128BITAES-BC\",\"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND192BITAES-BC\",\"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory.PBEWITHSHA-256AND256BITAES-BC\",\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc, \"PBEWITHSHAAND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc, \"PBEWITHSHAAND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc, \"PBEWITHSHAAND256BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc, \"PBEWITHSHA256AND128BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc, \"PBEWITHSHA256AND192BITAES-CBC-BC\");\n            provider.addAlgorithm(\"Alg.Alias.SecretKeyFactory\", BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc, \"PBEWITHSHA256AND256BITAES-CBC-BC\");\n            \n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHAAND128BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHAAND192BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHAAND256BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA256AND128BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA256AND192BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA256AND256BITAES-CBC-BC\", \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA1AND128BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA1AND192BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA1AND256BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-1AND128BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-1AND192BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-1AND256BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-256AND128BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-256AND192BITAES-CBC-BC\",\"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.PBEWITHSHA-256AND256BITAES-CBC-BC\",\"PKCS12PBE\"); \n            \n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes128_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes192_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha1_pkcs12_aes256_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes128_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes192_cbc.getId(), \"PKCS12PBE\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.\" + BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc.getId(), \"PKCS12PBE\");\n\n            addGMacAlgorithm(provider, \"AES\", PREFIX + \"$AESGMAC\", PREFIX + \"$KeyGen128\");\n            addPoly1305Algorithm(provider, \"AES\", PREFIX + \"$Poly1305\", PREFIX + \"$Poly1305KeyGen\");\n        }\n    }\n\n    private static Class lookup(String className)\n    {\n        try\n        {\n            Class def = AES.class.getClassLoader().loadClass(className);\n\n            return def;\n        }\n        catch (Exception e)\n        {\n            return null;\n        }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.GeneralSecurityException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.KeyAgreement;\nimport javax.crypto.SecretKey;\nimport javax.crypto.interfaces.DHPrivateKey;\nimport javax.crypto.interfaces.DHPublicKey;\nimport javax.crypto.spec.DESKeySpec;\nimport javax.crypto.spec.DESedeKeySpec;\nimport javax.crypto.spec.DHParameterSpec;\nimport javax.crypto.spec.DHPrivateKeySpec;\nimport javax.crypto.spec.DHPublicKeySpec;\n\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.config.ConfigurableProvider;\nimport org.bouncycastle.jce.ECNamedCurveTable;\nimport org.bouncycastle.jce.ECPointUtil;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.SimpleTest;\n\npublic class DHTest\n    extends SimpleTest\n{\n    private BigInteger g512 = new BigInteger(\"153d5d6172adb43045b68ae8e1de1070b6137005686d29d3d73a7749199681ee5b212c9b96bfdcfa5b20cd5e3fd2044895d609cf9b410b7a0f12ca1cb9a428cc\", 16);\n    private BigInteger p512 = new BigInteger(\"9494fec095f3b85ee286542b3836fc81a5dd0a0349b4c239dd38744d488cf8e31db8bcb7d33b41abb9e5a33cca9144b1cef332c94bf0573bf047a3aca98cdf3b\", 16);\n\n    private BigInteger g768 = new BigInteger(\"7c240073c1316c621df461b71ebb0cdcc90a6e5527e5e126633d131f87461c4dc4afc60c2cb0f053b6758871489a69613e2a8b4c8acde23954c08c81cbd36132cfd64d69e4ed9f8e51ed6e516297206672d5c0a69135df0a5dcf010d289a9ca1\", 16);\n    private BigInteger p768 = new BigInteger(\"8c9dd223debed1b80103b8b309715be009d48860ed5ae9b9d5d8159508efd802e3ad4501a7f7e1cfec78844489148cd72da24b21eddd01aa624291c48393e277cfc529e37075eccef957f3616f962d15b44aeab4039d01b817fde9eaa12fd73f\", 16);\n\n    private BigInteger g1024 = new BigInteger(\"1db17639cdf96bc4eabba19454f0b7e5bd4e14862889a725c96eb61048dcd676ceb303d586e30f060dbafd8a571a39c4d823982117da5cc4e0f89c77388b7a08896362429b94a18a327604eb7ff227bffbc83459ade299e57b5f77b50fb045250934938efa145511166e3197373e1b5b1e52de713eb49792bedde722c6717abf\", 16);\n    private BigInteger p1024 = new BigInteger(\"a00e283b3c624e5b2b4d9fbc2653b5185d99499b00fd1bf244c6f0bb817b4d1c451b2958d62a0f8a38caef059fb5ecd25d75ed9af403f5b5bdab97a642902f824e3c13789fed95fa106ddfe0ff4a707c85e2eb77d49e68f2808bcea18ce128b178cd287c6bc00efa9a1ad2a673fe0dceace53166f75b81d6709d5f8af7c66bb7\", 16);\n\n    // public key with mismatched oid/parameters\n    private byte[] oldPubEnc = Base64.decode(\n        \"MIIBnzCCARQGByqGSM4+AgEwggEHAoGBAPxSrN417g43VAM9sZRf1dt6AocAf7D6\" +\n            \"WVCtqEDcBJrMzt63+g+BNJzhXVtbZ9kp9vw8L/0PHgzv0Ot/kOLX7Khn+JalOECW\" +\n            \"YlkyBhmOVbjR79TY5u2GAlvG6pqpizieQNBCEMlUuYuK1Iwseil6VoRuA13Zm7uw\" +\n            \"WO1eZmaJtY7LAoGAQaPRCFKM5rEdkMrV9FNzeSsYRs8m3DqPnnJHpuySpyO9wUcX\" +\n            \"OOJcJY5qvHbDO5SxHXu/+bMgXmVT6dXI5o0UeYqJR7fj6pR4E6T0FwG55RFr5Ok4\" +\n            \"3C4cpXmaOu176SyWuoDqGs1RDGmYQjwbZUi23DjaaTFUly9LCYXMliKrQfEDgYQA\" +\n            \"AoGAQUGCBN4TaBw1BpdBXdTvTfCU69XDB3eyU2FOBE3UWhpx9D8XJlx4f5DpA4Y6\" +\n            \"6sQMuCbhfmjEph8W7/sbMurM/awR+PSR8tTY7jeQV0OkmAYdGK2nzh0ZSifMO1oE\" +\n            \"NNhN2O62TLs67msxT28S4/S89+LMtc98mevQ2SX+JF3wEVU=\");\n\n    // bogus key with full PKCS parameter set\n    private byte[] oldFullParams = Base64.decode(\n        \"MIIBIzCCARgGByqGSM4+AgEwggELAoGBAP1/U4EddRIpUt9KnC7s5Of2EbdSPO9E\" +\n            \"AMMeP4C2USZpRV1AIlH7WT2NWPq/xfW6MPbLm1Vs14E7gB00b/JmYLdrmVClpJ+f\" +\n            \"6AR7ECLCT7up1/63xhv4O1fnxqimFQ8E+4P208UewwI1VBNaFpEy9nXzrith1yrv\" +\n            \"8iIDGZ3RSAHHAoGBAPfhoIXWmz3ey7yrXDa4V7l5lK+7+jrqgvlXTAs9B4JnUVlX\" +\n            \"jrrUWU/mcQcQgYC0SRZxI+hMKBYTt88JMozIpuE8FnqLVHyNKOCjrh4rs6Z1kW6j\" +\n            \"fwv6ITVi8ftiegEkO8yk8b6oUZCJqIPf4VrlnwaSi2ZegHtVJWQBTDv+z0kqAgFk\" +\n            \"AwUAAgIH0A==\");\n\n    private byte[] samplePubEnc = Base64.decode(\n        \"MIIBpjCCARsGCSqGSIb3DQEDATCCAQwCgYEA/X9TgR11EilS30qcLuzk5/YRt1I8\" +\n            \"70QAwx4/gLZRJmlFXUAiUftZPY1Y+r/F9bow9subVWzXgTuAHTRv8mZgt2uZUKWk\" +\n            \"n5/oBHsQIsJPu6nX/rfGG/g7V+fGqKYVDwT7g/bTxR7DAjVUE1oWkTL2dfOuK2HX\" +\n            \"Ku/yIgMZndFIAccCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdR\" +\n            \"WVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWR\" +\n            \"bqN/C/ohNWLx+2J6ASQ7zKTxvqhRkImog9/hWuWfBpKLZl6Ae1UlZAFMO/7PSSoC\" +\n            \"AgIAA4GEAAKBgEIiqxoUW6E6GChoOgcfNbVFclW91ITf5MFSUGQwt2R0RHoOhxvO\" +\n            \"lZhNs++d0VPATLAyXovjfgENT9SGCbuZttYcqqLdKTbMXBWPek+rfnAl9E4iEMED\" +\n            \"IDd83FJTKs9hQcPAm7zmp0Xm1bGF9CbUFjP5G02265z7eBmHDaT0SNlB\");\n\n    private byte[] samplePrivEnc = Base64.decode(\n        \"MIIBZgIBADCCARsGCSqGSIb3DQEDATCCAQwCgYEA/X9TgR11EilS30qcLuzk5/YR\" +\n            \"t1I870QAwx4/gLZRJmlFXUAiUftZPY1Y+r/F9bow9subVWzXgTuAHTRv8mZgt2uZ\" +\n            \"UKWkn5/oBHsQIsJPu6nX/rfGG/g7V+fGqKYVDwT7g/bTxR7DAjVUE1oWkTL2dfOu\" +\n            \"K2HXKu/yIgMZndFIAccCgYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0H\" +\n            \"gmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuz\" +\n            \"pnWRbqN/C/ohNWLx+2J6ASQ7zKTxvqhRkImog9/hWuWfBpKLZl6Ae1UlZAFMO/7P\" +\n            \"SSoCAgIABEICQAZYXnBHazxXUUdFP4NIf2Ipu7du0suJPZQKKff81wymi2zfCfHh\" +\n            \"uhe9gQ9xdm4GpzeNtrQ8/MzpTy+ZVrtd29Q=\");\n\n    public String getName()\n    {\n        return \"DH\";\n    }\n\n    private void testGP(\n        String algName,\n        int size,\n        int privateValueSize,\n        BigInteger g,\n        BigInteger p)\n        throws Exception\n    {\n        DHParameterSpec dhParams = new DHParameterSpec(p, g, privateValueSize);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algName, \"BC\");\n\n        keyGen.initialize(dhParams);\n\n        testTwoParty(algName, size, privateValueSize, keyGen);\n\n        KeyPair aKeyPair = keyGen.generateKeyPair();\n\n        //\n        // public key encoding test\n        //\n        byte[] pubEnc = aKeyPair.getPublic().getEncoded();\n        KeyFactory keyFac = KeyFactory.getInstance(algName, \"BC\");\n        X509EncodedKeySpec pubX509 = new X509EncodedKeySpec(pubEnc);\n        DHPublicKey pubKey = (DHPublicKey)keyFac.generatePublic(pubX509);\n        DHParameterSpec spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // public key serialisation test\n        //\n        pubKey = (DHPublicKey)serializeDeserialize(aKeyPair.getPublic());\n        spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key serialisation test failed on y value\");\n        }\n\n        if (!aKeyPair.getPublic().equals(pubKey))\n        {\n            fail(\"equals test failed\");\n        }\n\n        if (aKeyPair.getPublic().hashCode() != pubKey.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n\n        //\n        // private key encoding test\n        //\n        byte[] privEnc = aKeyPair.getPrivate().getEncoded();\n        PKCS8EncodedKeySpec privPKCS8 = new PKCS8EncodedKeySpec(privEnc);\n        DHPrivateKey privKey = (DHPrivateKey)keyFac.generatePrivate(privPKCS8);\n\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // private key serialisation test\n        //\n        privKey = (DHPrivateKey)serializeDeserialize(aKeyPair.getPrivate());\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key serialisation test failed on X value\");\n        }\n\n        if (!aKeyPair.getPrivate().equals(privKey))\n        {\n            fail(\"equals test failed\");\n        }\n\n        if (aKeyPair.getPrivate().hashCode() != privKey.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n\n        if (!(privKey instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // three party test\n        //\n        KeyPairGenerator aPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        aPairGen.initialize(spec);\n        KeyPair aPair = aPairGen.generateKeyPair();\n\n        KeyPairGenerator bPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        bPairGen.initialize(spec);\n        KeyPair bPair = bPairGen.generateKeyPair();\n\n        KeyPairGenerator cPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        cPairGen.initialize(spec);\n        KeyPair cPair = cPairGen.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        aKeyAgree.init(aPair.getPrivate());\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        bKeyAgree.init(bPair.getPrivate());\n\n        KeyAgreement cKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        cKeyAgree.init(cPair.getPrivate());\n\n        Key ac = aKeyAgree.doPhase(cPair.getPublic(), false);\n\n        Key ba = bKeyAgree.doPhase(aPair.getPublic(), false);\n\n        Key cb = cKeyAgree.doPhase(bPair.getPublic(), false);\n\n        aKeyAgree.doPhase(cb, true);\n\n        bKeyAgree.doPhase(ac, true);\n\n        cKeyAgree.doPhase(ba, true);\n\n        BigInteger aShared = new BigInteger(aKeyAgree.generateSecret());\n        BigInteger bShared = new BigInteger(bKeyAgree.generateSecret());\n        BigInteger cShared = new BigInteger(cKeyAgree.generateSecret());\n\n        if (!aShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (a and b differ)\");\n        }\n\n        if (!cShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (c and b differ)\");\n        }\n    }\n\n    private void testTwoParty(String algName, int size, int privateValueSize, KeyPairGenerator keyGen)\n        throws Exception\n    {\n        testTwoParty(algName, size, privateValueSize, keyGen.generateKeyPair(), keyGen.generateKeyPair());\n    }\n\n    private byte[] testTwoParty(String algName, int size, int privateValueSize, KeyPair aKeyPair, KeyPair bKeyPair)\n        throws Exception\n    {\n        //\n        // a side\n        //\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n\n        checkKeySize(privateValueSize, aKeyPair);\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n\n        checkKeySize(privateValueSize, bKeyPair);\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        byte[] aSecret = aKeyAgree.generateSecret();\n        byte[] bSecret = bKeyAgree.generateSecret();\n\n        if (!Arrays.areEqual(aSecret, bSecret))\n        {\n            fail(size + \" bit 2-way test failed\");\n        }\n\n        return aSecret;\n    }\n\n    private void testExplicitWrapping(\n        int size,\n        int privateValueSize,\n        BigInteger g,\n        BigInteger p)\n        throws Exception\n    {\n        DHParameterSpec dhParams = new DHParameterSpec(p, g, privateValueSize);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        keyGen.initialize(dhParams);\n\n        //\n        // a side\n        //\n        KeyPair aKeyPair = keyGen.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n        checkKeySize(privateValueSize, aKeyPair);\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyPair bKeyPair = keyGen.generateKeyPair();\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n        checkKeySize(privateValueSize, bKeyPair);\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        SecretKey k1 = aKeyAgree.generateSecret(PKCSObjectIdentifiers.id_alg_CMS3DESwrap.getId());\n        SecretKey k2 = bKeyAgree.generateSecret(PKCSObjectIdentifiers.id_alg_CMS3DESwrap.getId());\n\n        // TODO Compare k1 and k2?\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    private void checkKeySize(int privateValueSize, KeyPair aKeyPair)\n    {\n        if (privateValueSize != 0)\n        {\n            DHPrivateKey key = (DHPrivateKey)aKeyPair.getPrivate();\n\n            if (key.getX().bitLength() != privateValueSize)\n            {\n                fail(\"limited key check failed for key size \" + privateValueSize);\n            }\n        }\n    }\n\n    private void testRandom(\n        int size)\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DH\", \"BC\");\n        a.init(size, new SecureRandom());\n        AlgorithmParameters params = a.generateParameters();\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DH\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        DHParameterSpec dhP = (DHParameterSpec)params.getParameterSpec(DHParameterSpec.class);\n\n        testGP(\"DH\", size, 0, dhP.getG(), dhP.getP());\n    }\n\n    private void testDefault(\n        int privateValueSize,\n        BigInteger g,\n        BigInteger p)\n        throws Exception\n    {\n        DHParameterSpec dhParams = new DHParameterSpec(p, g, privateValueSize);\n        String algName = \"DH\";\n        int size = p.bitLength();\n\n        new BouncyCastleProvider().setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, dhParams);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(algName, \"BC\");\n\n        keyGen.initialize(dhParams.getP().bitLength());\n\n        testTwoParty(\"DH\", size, privateValueSize, keyGen);\n\n        KeyPair aKeyPair = keyGen.generateKeyPair();\n\n        new BouncyCastleProvider().setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, null);\n\n        //\n        // public key encoding test\n        //\n        byte[] pubEnc = aKeyPair.getPublic().getEncoded();\n        KeyFactory keyFac = KeyFactory.getInstance(algName, \"BC\");\n        X509EncodedKeySpec pubX509 = new X509EncodedKeySpec(pubEnc);\n        DHPublicKey pubKey = (DHPublicKey)keyFac.generatePublic(pubX509);\n        DHParameterSpec spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // public key serialisation test\n        //\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(aKeyPair.getPublic());\n\n        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ObjectInputStream oIn = new ObjectInputStream(bIn);\n\n        pubKey = (DHPublicKey)oIn.readObject();\n        spec = pubKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit public key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPublicKey)aKeyPair.getPublic()).getY().equals(pubKey.getY()))\n        {\n            fail(size + \" bit public key serialisation test failed on y value\");\n        }\n\n        //\n        // private key encoding test\n        //\n        byte[] privEnc = aKeyPair.getPrivate().getEncoded();\n        PKCS8EncodedKeySpec privPKCS8 = new PKCS8EncodedKeySpec(privEnc);\n        DHPrivateKey privKey = (DHPrivateKey)keyFac.generatePrivate(privPKCS8);\n\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key encoding/decoding test failed on y value\");\n        }\n\n        //\n        // private key serialisation test\n        //\n        bOut = new ByteArrayOutputStream();\n        oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(aKeyPair.getPrivate());\n\n        bIn = new ByteArrayInputStream(bOut.toByteArray());\n        oIn = new ObjectInputStream(bIn);\n\n        privKey = (DHPrivateKey)oIn.readObject();\n        spec = privKey.getParams();\n\n        if (!spec.getG().equals(dhParams.getG()) || !spec.getP().equals(dhParams.getP()))\n        {\n            fail(size + \" bit private key serialisation test failed on parameters\");\n        }\n\n        if (!((DHPrivateKey)aKeyPair.getPrivate()).getX().equals(privKey.getX()))\n        {\n            fail(size + \" bit private key serialisation test failed on y value\");\n        }\n\n        //\n        // three party test\n        //\n        KeyPairGenerator aPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        aPairGen.initialize(spec);\n        KeyPair aPair = aPairGen.generateKeyPair();\n\n        KeyPairGenerator bPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        bPairGen.initialize(spec);\n        KeyPair bPair = bPairGen.generateKeyPair();\n\n        KeyPairGenerator cPairGen = KeyPairGenerator.getInstance(algName, \"BC\");\n        cPairGen.initialize(spec);\n        KeyPair cPair = cPairGen.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        aKeyAgree.init(aPair.getPrivate());\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        bKeyAgree.init(bPair.getPrivate());\n\n        KeyAgreement cKeyAgree = KeyAgreement.getInstance(algName, \"BC\");\n        cKeyAgree.init(cPair.getPrivate());\n\n        Key ac = aKeyAgree.doPhase(cPair.getPublic(), false);\n\n        Key ba = bKeyAgree.doPhase(aPair.getPublic(), false);\n\n        Key cb = cKeyAgree.doPhase(bPair.getPublic(), false);\n\n        aKeyAgree.doPhase(cb, true);\n\n        bKeyAgree.doPhase(ac, true);\n\n        cKeyAgree.doPhase(ba, true);\n\n        BigInteger aShared = new BigInteger(aKeyAgree.generateSecret());\n        BigInteger bShared = new BigInteger(bKeyAgree.generateSecret());\n        BigInteger cShared = new BigInteger(cKeyAgree.generateSecret());\n\n        if (!aShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (a and b differ)\");\n        }\n\n        if (!cShared.equals(bShared))\n        {\n            fail(size + \" bit 3-way test failed (c and b differ)\");\n        }\n    }\n\n    private void testECDH(String algorithm, String curveName, String cipher, int keyLen)\n        throws Exception\n    {\n        ECNamedCurveParameterSpec parameterSpec = ECNamedCurveTable.getParameterSpec(curveName);\n        KeyPairGenerator g = KeyPairGenerator.getInstance(algorithm, \"BC\");\n\n        g.initialize(parameterSpec);\n\n        //\n        // a side\n        //\n        KeyPair aKeyPair = g.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyPair bKeyPair = g.generateKeyPair();\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        SecretKey k1 = aKeyAgree.generateSecret(cipher);\n        SecretKey k2 = bKeyAgree.generateSecret(cipher + \"[\" + keyLen + \"]\");  // explicit key-len\n\n        if (!k1.equals(k2))\n        {\n            fail(algorithm + \" 2-way test failed\");\n        }\n\n        if (k1.getEncoded().length != keyLen / 8)\n        {\n            fail(\"key for \" + cipher + \" the wrong size expected \" + keyLen / 8 + \" got \" + k1.getEncoded().length);\n        }\n    }\n\n    private void testECDH(String algorithm)\n        throws Exception\n    {\n        KeyPairGenerator g = KeyPairGenerator.getInstance(algorithm, \"BC\");\n\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldFp(new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\")), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            ECPointUtil.decodePoint(curve, Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\"), // n\n            1); // h\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        //\n        // a side\n        //\n        KeyPair aKeyPair = g.generateKeyPair();\n\n        KeyAgreement aKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        aKeyAgree.init(aKeyPair.getPrivate());\n\n        //\n        // b side\n        //\n        KeyPair bKeyPair = g.generateKeyPair();\n\n        KeyAgreement bKeyAgree = KeyAgreement.getInstance(algorithm, \"BC\");\n\n        bKeyAgree.init(bKeyPair.getPrivate());\n\n        //\n        // agreement\n        //\n        aKeyAgree.doPhase(bKeyPair.getPublic(), true);\n        bKeyAgree.doPhase(aKeyPair.getPublic(), true);\n\n        BigInteger k1 = new BigInteger(aKeyAgree.generateSecret());\n        BigInteger k2 = new BigInteger(bKeyAgree.generateSecret());\n\n        if (!k1.equals(k2))\n        {\n            fail(algorithm + \" 2-way test failed\");\n        }\n\n        //\n        // public key encoding test\n        //\n        byte[] pubEnc = aKeyPair.getPublic().getEncoded();\n        KeyFactory keyFac = KeyFactory.getInstance(algorithm, \"BC\");\n        X509EncodedKeySpec pubX509 = new X509EncodedKeySpec(pubEnc);\n        ECPublicKey pubKey = (ECPublicKey)keyFac.generatePublic(pubX509);\n\n        if (!pubKey.getW().equals(((ECPublicKey)aKeyPair.getPublic()).getW()))\n        {\n            System.out.println(\" expected \" + pubKey.getW().getAffineX() + \" got \" + ((ECPublicKey)aKeyPair.getPublic()).getW().getAffineX());\n            System.out.println(\" expected \" + pubKey.getW().getAffineY() + \" got \" + ((ECPublicKey)aKeyPair.getPublic()).getW().getAffineY());\n            fail(algorithm + \" public key encoding (W test) failed\");\n        }\n\n        if (!pubKey.getParams().getGenerator().equals(((ECPublicKey)aKeyPair.getPublic()).getParams().getGenerator()))\n        {\n            fail(algorithm + \" public key encoding (G test) failed\");\n        }\n\n        //\n        // private key encoding test\n        //\n        byte[] privEnc = aKeyPair.getPrivate().getEncoded();\n        PKCS8EncodedKeySpec privPKCS8 = new PKCS8EncodedKeySpec(privEnc);\n        ECPrivateKey privKey = (ECPrivateKey)keyFac.generatePrivate(privPKCS8);\n\n        if (!privKey.getS().equals(((ECPrivateKey)aKeyPair.getPrivate()).getS()))\n        {\n            fail(algorithm + \" private key encoding (S test) failed\");\n        }\n\n        if (!privKey.getParams().getGenerator().equals(((ECPrivateKey)aKeyPair.getPrivate()).getParams().getGenerator()))\n        {\n            fail(algorithm + \" private key encoding (G test) failed\");\n        }\n    }\n\n    private void testExceptions()\n        throws Exception\n    {\n        try\n        {\n            KeyAgreement aKeyAgree = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n            aKeyAgree.generateSecret(\"DES\");\n        }\n        catch (IllegalStateException e)\n        {\n            // okay\n        }\n        catch (Exception e)\n        {\n            fail(\"Unexpected exception: \" + e, e);\n        }\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n\n        keyGen.initialize(256);\n\n        KeyPair kp = keyGen.generateKeyPair();\n        KeyAgreement agreement = KeyAgreement.getInstance(\"ECDH\", \"BC\");\n\n        agreement.init(kp.getPrivate());\n        try\n        {\n            ECPoint fakePubPoint = new ECPoint(new BigInteger(\"12345\"), new BigInteger(\"23457\"));\n            ECPublicKeySpec fakePubSpec = new ECPublicKeySpec(fakePubPoint, ((ECPublicKey)kp.getPublic()).getParams());\n            KeyFactory kf = KeyFactory.getInstance(\"EC\", \"BC\");\n            PublicKey fakePub = kf.generatePublic(fakePubSpec);\n            agreement.doPhase(fakePub, true);\n\n            fail(\"no exception on dud point\");\n        }\n        catch (java.security.spec.InvalidKeySpecException e)\n        {\n            isTrue(\"wrong message\", \"invalid KeySpec: point not on curve\".equals(e.getMessage()));\n        }\n        catch (java.security.InvalidKeyException e)\n        {\n            isTrue(\"wrong message\", \"calculation failed: Invalid point\".equals(e.getMessage()));\n        }\n    }\n\n    private void testDESAndDESede(BigInteger g, BigInteger p)\n        throws Exception\n    {\n        DHParameterSpec dhParams = new DHParameterSpec(p, g, 256);\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        keyGen.initialize(dhParams);\n\n        KeyPair kp = keyGen.generateKeyPair();\n\n        KeyAgreement keyAgreement = KeyAgreement.getInstance(\"DH\", \"BC\");\n\n        keyAgreement.init(kp.getPrivate());\n        keyAgreement.doPhase(kp.getPublic(), true);\n\n        SecretKey key = keyAgreement.generateSecret(\"DES\");\n\n        if (key.getEncoded().length != 8)\n        {\n            fail(\"DES length wrong\");\n        }\n\n        if (!DESKeySpec.isParityAdjusted(key.getEncoded(), 0))\n        {\n            fail(\"DES parity wrong\");\n        }\n\n        key = keyAgreement.generateSecret(\"DESEDE\");\n\n        if (key.getEncoded().length != 24)\n        {\n            fail(\"DESEDE length wrong\");\n        }\n\n        if (!DESedeKeySpec.isParityAdjusted(key.getEncoded(), 0))\n        {\n            fail(\"DESEDE parity wrong\");\n        }\n\n        key = keyAgreement.generateSecret(\"Blowfish\");\n\n        if (key.getEncoded().length != 16)\n        {\n            fail(\"Blowfish length wrong\");\n        }\n    }\n\n    private void testInitialise()\n        throws Exception\n    {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n\n        keyGen.initialize(512);\n\n        keyGen.generateKeyPair();\n\n        testTwoParty(\"DH\", 512, 0, keyGen);\n    }\n\n    private void testSmallSecret()\n        throws Exception\n    {\n        BigInteger p = new BigInteger(\"ff3b512a4cc0961fa625d6cbd9642c377ece46b8dbc3146a98e0567f944034b5e3a1406edb179a77cd2539bdb74dc819f0a74d486606e26e578ff52c5242a5ff\", 16);\n        BigInteger g = new BigInteger(\"58a66667431136e99d86de8199eb650a21afc9de3dd4ef9da6dfe89c866e928698952d95e68b418becef26f23211572eebfcbf328809bdaf02bba3d24c74f8c0\", 16);\n\n        DHPrivateKeySpec aPrivSpec = new DHPrivateKeySpec(\n            new BigInteger(\"30a6ea4e2240a42867ad98bd3adbfd5b81aba48bd930f20a595983d807566f7cba4e766951efef2c6c0c1be3823f63d66e12c2a091d5ff3bbeb1ea6e335d072d\", 16), p, g);\n        DHPublicKeySpec aPubSpec = new DHPublicKeySpec(\n            new BigInteger(\"694dfea1bfc8897e2fcbfd88033ab34f4581892d7d5cc362dc056e3d43955accda12222bd651ca31c85f008a05dea914de68828dfd83a54a340fa84f3bbe6caf\", 16), p, g);\n\n        DHPrivateKeySpec bPrivSpec = new DHPrivateKeySpec(\n            new BigInteger(\"775b1e7e162190700e2212dd8e4aaacf8a2af92c9c108b81d5bf9a14548f494eaa86a6c4844b9512eb3e3f2f22ffec44c795c813edfea13f075b99bbdebb34bd\", 16), p, g);\n\n        DHPublicKeySpec bPubSpec = new DHPublicKeySpec(\n            new BigInteger(\"d8ddd4ff9246635eadbfa0bc2ef06d98a329b6e8cd2d1435d7b4921467570e697c9a9d3c172c684626a9d2b6b2fa0fc725d5b91f9a9625b717a4169bc714b064\", 16), p, g);\n\n        KeyFactory kFact = KeyFactory.getInstance(\"DH\", \"BC\");\n\n        byte[] secret = testTwoParty(\"DH\", 512, 0, new KeyPair(kFact.generatePublic(aPubSpec), kFact.generatePrivate(aPrivSpec)), new KeyPair(kFact.generatePublic(bPubSpec), kFact.generatePrivate(bPrivSpec)));\n\n        if (secret.length != ((p.bitLength() + 7) / 8))\n        {\n            fail(\"short secret wrong length\");\n        }\n\n        if (!Arrays.areEqual(Hex.decode(\"00340d3309ddc86e99e2f0be4fc212837bfb5c59336b09b9e1aeb1884b72c8b485b56723d0bf1c1d37fc89a292fc1cface9125106f1df15f55f22e4f77c5879b\"), secret))\n        {\n            fail(\"short secret mismatch\");\n        }\n    }\n\n    private void testEnc()\n        throws Exception\n    {\n        KeyFactory kFact = KeyFactory.getInstance(\"DH\", \"BC\");\n\n        Key k = kFact.generatePrivate(new PKCS8EncodedKeySpec(samplePrivEnc));\n\n        if (!Arrays.areEqual(samplePrivEnc, k.getEncoded()))\n        {\n            fail(\"private key re-encode failed\");\n        }\n\n        k = kFact.generatePublic(new X509EncodedKeySpec(samplePubEnc));\n\n        if (!Arrays.areEqual(samplePubEnc, k.getEncoded()))\n        {\n            fail(\"public key re-encode failed\");\n        }\n\n        k = kFact.generatePublic(new X509EncodedKeySpec(oldPubEnc));\n\n        if (!Arrays.areEqual(oldPubEnc, k.getEncoded()))\n        {\n            fail(\"old public key re-encode failed\");\n        }\n\n        k = kFact.generatePublic(new X509EncodedKeySpec(oldFullParams));\n\n        if (!Arrays.areEqual(oldFullParams, k.getEncoded()))\n        {\n            fail(\"old full public key re-encode failed\");\n        }\n    }\n\n    private void testConfig()\n    {\n        ConfigurableProvider prov = new BouncyCastleProvider();\n\n        DHParameterSpec dhSpec512 = new DHParameterSpec(\n            new BigInteger(\"fca682ce8e12caba26efccf7110e526db078b05edecbcd1eb4a208f3ae1617ae01f35b91a47e6df63413c5e12ed0899bcd132acd50d99151bdc43ee737592e17\", 16),\n            new BigInteger(\"678471b27a9cf44ee91a49c5147db1a9aaf244f05a434d6486931d2d14271b9e35030b71fd73da179069b32e2935630e1c2062354d0da20a6c416e50be794ca4\", 16),\n            384);\n\n        DHParameterSpec dhSpec768 = new DHParameterSpec(\n            new BigInteger(\"e9e642599d355f37c97ffd3567120b8e25c9cd43e927b3a9670fbec5d890141922d2c3b3ad2480093799869d1e846aab49fab0ad26d2ce6a22219d470bce7d777d4a21fbe9c270b57f607002f3cef8393694cf45ee3688c11a8c56ab127a3daf\", 16),\n            new BigInteger(\"30470ad5a005fb14ce2d9dcd87e38bc7d1b1c5facbaecbe95f190aa7a31d23c4dbbcbe06174544401a5b2c020965d8c2bd2171d3668445771f74ba084d2029d83c1c158547f3a9f1a2715be23d51ae4d3e5a1f6a7064f316933a346d3f529252\", 16),\n            384);\n\n        DHParameterSpec dhSpec1024 = new DHParameterSpec(\n            new BigInteger(\"fd7f53811d75122952df4a9c2eece4e7f611b7523cef4400c31e3f80b6512669455d402251fb593d8d58fabfc5f5ba30f6cb9b556cd7813b801d346ff26660b76b9950a5a49f9fe8047b1022c24fbba9d7feb7c61bf83b57e7c6a8a6150f04fb83f6d3c51ec3023554135a169132f675f3ae2b61d72aeff22203199dd14801c7\", 16),\n            new BigInteger(\"f7e1a085d69b3ddecbbcab5c36b857b97994afbbfa3aea82f9574c0b3d0782675159578ebad4594fe67107108180b449167123e84c281613b7cf09328cc8a6e13c167a8b547c8d28e0a3ae1e2bb3a675916ea37f0bfa213562f1fb627a01243bcca4f1bea8519089a883dfe15ae59f06928b665e807b552564014c3bfecf492a\", 16),\n            512);\n\n        prov.setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, dhSpec512);\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"config mismatch\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found when none expected\");\n        }\n\n        prov.setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, new DHParameterSpec[]{dhSpec512, dhSpec768, dhSpec1024});\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"512 config mismatch\");\n        }\n\n        if (!dhSpec768.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768)))\n        {\n            fail(\"768 config mismatch\");\n        }\n\n        if (!dhSpec1024.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(1024)))\n        {\n            fail(\"1024 config mismatch\");\n        }\n\n        prov.setParameter(ConfigurableProvider.DH_DEFAULT_PARAMS, null);\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512) != null)\n        {\n            fail(\"config found for 512 when none expected\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found for 768 when none expected\");\n        }\n\n        prov.setParameter(ConfigurableProvider.THREAD_LOCAL_DH_DEFAULT_PARAMS, dhSpec512);\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"config mismatch\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found when none expected\");\n        }\n\n        prov.setParameter(ConfigurableProvider.THREAD_LOCAL_DH_DEFAULT_PARAMS, new DHParameterSpec[]{dhSpec512, dhSpec768, dhSpec1024});\n\n        if (!dhSpec512.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512)))\n        {\n            fail(\"512 config mismatch\");\n        }\n\n        if (!dhSpec768.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768)))\n        {\n            fail(\"768 config mismatch\");\n        }\n\n        if (!dhSpec1024.equals(BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(1024)))\n        {\n            fail(\"1024 config mismatch\");\n        }\n\n        prov.setParameter(ConfigurableProvider.THREAD_LOCAL_DH_DEFAULT_PARAMS, null);\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(512) != null)\n        {\n            fail(\"config found for 512 when none expected\");\n        }\n\n        if (BouncyCastleProvider.CONFIGURATION.getDHDefaultParameters(768) != null)\n        {\n            fail(\"config found for 768 when none expected\");\n        }\n    }\n\n    static final String MESSAGE = \"Hello\";\n\n    static final String PROVIDER_NAME = \"BC\";\n    static final SecureRandom rand = new SecureRandom();\n\n    public void setUp()\n    {\n        // Add BouncyCastle for testing.\n        Security.insertProviderAt(new BouncyCastleProvider(), 1);\n        System.out.println(\"WARNING: Using BouncyCastleProvider\");\n    }\n\n    public DHParameterSpec ike2048()\n    {\n        final BigInteger p = new BigInteger(\n            \"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74\"\n                + \"020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f1437\"\n                + \"4fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7ed\"\n                + \"ee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf05\"\n                + \"98da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb\"\n                + \"9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3b\"\n                + \"e39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf695581718\"\n                + \"3995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\", 16);\n        final BigInteger g = new BigInteger(\"2\");\n        return new DHParameterSpec(p, g);\n    }\n\n    /**\n     * Tests whether a provider accepts invalid public keys that result in predictable shared secrets.\n     * This test is based on RFC 2785, Section 4 and NIST SP 800-56A,\n     * If an attacker can modify both public keys in an ephemeral-ephemeral key agreement scheme then\n     * it may be possible to coerce both parties into computing the same predictable shared key.\n     * <p/>\n     * Note: the test is quite whimsical. If the prime p is not a safe prime then the provider itself\n     * cannot prevent all small-subgroup attacks because of the missing parameter q in the\n     * Diffie-Hellman parameters. Implementations must add additional countermeasures such as the ones\n     * proposed in RFC 2785.\n     */\n    private void testSubgroupConfinement()\n        throws Exception\n    {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\", \"BC\");\n        DHParameterSpec params = ike2048();\n        final BigInteger p = params.getP();\n        final BigInteger g = params.getG();\n        keyGen.initialize(params);\n        PrivateKey priv = keyGen.generateKeyPair().getPrivate();\n        KeyAgreement ka = KeyAgreement.getInstance(\"DH\", \"BC\");\n        BigInteger[] weakPublicKeys = {\n            BigInteger.ZERO, BigInteger.ONE, p.subtract(BigInteger.ONE), p,\n            p.add(BigInteger.ONE), BigInteger.ONE.negate()};\n        for (final BigInteger weakKey : weakPublicKeys)\n        {\n            DHPublicKeySpec weakSpec = new DHPublicKeySpec(weakKey, p, g);\n            KeyFactory kf = KeyFactory.getInstance(\"DH\", \"BC\");\n            try\n            {\n                kf.generatePublic(weakSpec);\n                fail(\"Generated weak public key\");\n            }\n            catch (GeneralSecurityException ex)\n            {\n                isTrue(\"wrong message\", \"invalid DH public key\".equals(ex.getMessage()));\n            }\n            ka.init(priv);\n            try\n            {\n                ka.doPhase(new DHPublicKey()\n                {\n                    public BigInteger getY()\n                    {\n                        return weakKey;\n                    }\n\n                    public DHParameterSpec getParams()\n                    {\n                        return new DHParameterSpec(p, g);\n                    }\n\n                    public String getAlgorithm()\n                    {\n                        return null;\n                    }\n\n                    public String getFormat()\n                    {\n                        return null;\n                    }\n\n                    public byte[] getEncoded()\n                    {\n                        return new byte[0];\n                    }\n                }, true);\n                fail(\"Generated secrets with weak public key\");\n            }\n            catch (GeneralSecurityException ex)\n            {\n                isTrue(\"wrong message\", \"Invalid DH PublicKey\".equals(ex.getMessage()));\n            }\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testDefault(64, g512, p512);\n\n        testEnc();\n        testGP(\"DH\", 512, 0, g512, p512);\n        testGP(\"DiffieHellman\", 768, 0, g768, p768);\n        testGP(\"DIFFIEHELLMAN\", 1024, 0, g1024, p1024);\n        testGP(\"DH\", 512, 64, g512, p512);\n        testGP(\"DiffieHellman\", 768, 128, g768, p768);\n        testGP(\"DIFFIEHELLMAN\", 1024, 256, g1024, p1024);\n        testExplicitWrapping(512, 0, g512, p512);\n        testRandom(256);\n\n        testECDH(\"ECDH\");\n        testECDH(\"ECDHC\");\n        testECDH(\"ECDH\", \"secp521r1\", \"AES\", 256);\n        testECDH(\"ECDH\", \"secp521r1\", \"DESEDE\", 192);\n        testECDH(\"ECDH\", \"secp521r1\", \"DES\", 64);\n        testECDH(\"ECDHwithSHA1KDF\", \"secp521r1\", \"AES\", 256);\n        testECDH(\"ECDHwithSHA1KDF\", \"secp521r1\", \"DESEDE\", 192);\n        testECDH(\"ECDH\", \"Curve25519\", \"AES\", 256);\n        testECDH(\"ECDH\", \"Curve25519\", \"DESEDE\", 192);\n        testECDH(\"ECDH\", \"Curve25519\", \"DES\", 64);\n        testECDH(\"ECDHwithSHA1KDF\", \"Curve25519\", \"AES\", 256);\n        testECDH(\"ECDHwithSHA1KDF\", \"Curve25519\", \"DESEDE\", 192);\n\n        testExceptions();\n        testDESAndDESede(g768, p768);\n        testInitialise();\n        testSmallSecret();\n        testConfig();\n        testSubgroupConfinement();\n    }\n\n    public static void main(\n        String[] args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DHTest());\n    }\n}\n"], "filenames": ["core/src/main/java/org/bouncycastle/crypto/engines/AESEngine.java", "core/src/main/java/org/bouncycastle/crypto/params/DHPublicKeyParameters.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dh/BCDHPublicKey.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dh/KeyFactorySpi.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ec/IESCipher.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/util/DHUtil.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/symmetric/AES.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/DHTest.java"], "buggy_code_start_loc": [7, 28, 19, 85, 27, 13, 23, 9], "buggy_code_end_loc": [617, 46, 137, 86, 542, 24, 312, 1021], "fixing_code_start_loc": [8, 29, 18, 85, 27, 14, 23, 10], "fixing_code_end_loc": [628, 45, 161, 93, 542, 30, 312, 1127], "type": "CWE-310", "message": "In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate.", "other": {"cve": {"id": "CVE-2016-1000339", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-04T13:29:00.233", "lastModified": "2020-10-20T22:15:16.997", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Bouncy Castle JCE Provider version 1.55 and earlier the primary engine class used for AES was AESFastEngine. Due to the highly table driven approach used in the algorithm it turns out that if the data channel on the CPU can be monitored the lookup table accesses are sufficient to leak information on the AES key being used. There was also a leak in AESEngine although it was substantially less. AESEngine has been modified to remove any signs of leakage (testing carried out on Intel X86-64) and is now the primary AES class for the BC JCE provider from 1.56. Use of AESFastEngine is now only recommended where otherwise deemed appropriate."}, {"lang": "es", "value": "En la versi\u00f3n 1.55 y anteriores de Bouncy Castle JCE Provider, la clase de motor primaria empleada para AES era AESFastEngine. Debido al enfoque altamente enfocado a tablas empleado en el algoritmo, resulta que, si el canal de datos en la CPU puede ser monitorizado, los accesos a la tabla de b\u00fasquedas son suficientes para filtrar informaci\u00f3n sobre la clave de AES en uso. Tambi\u00e9n hab\u00eda una fuga en AESEngine, aunque significativamente menor. AESEngine se ha modificado para eliminar cualquier se\u00f1al de fuga (las pruebas se han realizado en Intel X86-64) y ahora es la principal clase de AES para el proveedor BC JCE desde la versi\u00f3n 1.56. Ahora, el uso de AESFastEngine solo se recomienda donde sea apropiado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-310"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.55", "matchCriteriaId": "946393A6-EEE2-4502-9309-81514DB5755B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2669", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2927", "source": "cve@mitre.org"}, {"url": "https://github.com/bcgit/bc-java/commit/413b42f4d770456508585c830cfcde95f9b0e93b#diff-54656f860db94b867ba7542430cd2ef0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bcgit/bc-java/commit/8a73f08931450c17c749af067b6a8185abdfd2c0#diff-494fb066bed02aeb76b6c005632943f2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20181127-0004/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3727-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/413b42f4d770456508585c830cfcde95f9b0e93b#diff-54656f860db94b867ba7542430cd2ef0"}}