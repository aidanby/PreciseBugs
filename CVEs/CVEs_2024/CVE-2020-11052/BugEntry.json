{"buggy_code": ["module Sorcery\n  # This module handles all plugin operations which are related to the Model layer in the MVC pattern.\n  # It should be included into the ORM base class.\n  # In the case of Rails this is usually ActiveRecord (actually, in that case, the plugin does this automatically).\n  #\n  # When included it defines a single method: 'authenticates_with_sorcery!'\n  # which when called adds the other capabilities to the class.\n  # This method is also the place to configure the plugin in the Model layer.\n  module Model\n    def authenticates_with_sorcery!\n      @sorcery_config = Config.new\n\n      extend ClassMethods # included here, before submodules, so they can be overriden by them.\n      include InstanceMethods\n      include TemporaryToken\n\n      include_required_submodules!\n\n      # This runs the options block set in the initializer on the model class.\n      ::Sorcery::Controller::Config.user_config.tap { |blk| blk.call(@sorcery_config) if blk }\n\n      define_base_fields\n      init_orm_hooks!\n\n      @sorcery_config.after_config << :add_config_inheritance if @sorcery_config.subclasses_inherit_config\n      @sorcery_config.after_config.each { |c| send(c) }\n    end\n\n    private\n\n    def define_base_fields\n      class_eval do\n        sorcery_config.username_attribute_names.each do |username|\n          sorcery_adapter.define_field username, String, length: 255\n        end\n        unless sorcery_config.username_attribute_names.include?(sorcery_config.email_attribute_name)\n          sorcery_adapter.define_field sorcery_config.email_attribute_name, String, length: 255\n        end\n        sorcery_adapter.define_field sorcery_config.crypted_password_attribute_name, String, length: 255\n        sorcery_adapter.define_field sorcery_config.salt_attribute_name, String, length: 255\n      end\n    end\n\n    # includes required submodules into the model class,\n    # which usually is called User.\n    def include_required_submodules!\n      class_eval do\n        @sorcery_config.submodules = ::Sorcery::Controller::Config.submodules\n        @sorcery_config.submodules.each do |mod|\n          # TODO: Is there a cleaner way to handle missing submodules?\n          # rubocop:disable Lint/HandleExceptions\n          begin\n            include Submodules.const_get(mod.to_s.split('_').map(&:capitalize).join)\n          rescue NameError\n            # don't stop on a missing submodule. Needed because some submodules are only defined\n            # in the controller side.\n          end\n          # rubocop:enable Lint/HandleExceptions\n        end\n      end\n    end\n\n    # add virtual password accessor and ORM callbacks.\n    def init_orm_hooks!\n      sorcery_adapter.define_callback :before, :validation, :encrypt_password, if: proc { |record|\n        record.send(sorcery_config.password_attribute_name).present?\n      }\n\n      sorcery_adapter.define_callback :after, :save, :clear_virtual_password, if: proc { |record|\n        record.send(sorcery_config.password_attribute_name).present?\n      }\n\n      attr_accessor sorcery_config.password_attribute_name\n    end\n\n    module ClassMethods\n      # Returns the class instance variable for configuration, when called by the class itself.\n      def sorcery_config\n        @sorcery_config\n      end\n\n      # The default authentication method.\n      # Takes a username and password,\n      # Finds the user by the username and compares the user's password to the one supplied to the method.\n      # returns the user if success, nil otherwise.\n      def authenticate(*credentials, &block)\n        raise ArgumentError, 'at least 2 arguments required' if credentials.size < 2\n\n        if credentials[0].blank?\n          return authentication_response(return_value: false, failure: :invalid_login, &block)\n        end\n\n        if @sorcery_config.downcase_username_before_authenticating\n          credentials[0].downcase!\n        end\n\n        user = sorcery_adapter.find_by_credentials(credentials)\n\n        unless user\n          return authentication_response(failure: :invalid_login, &block)\n        end\n\n        set_encryption_attributes\n\n        unless user.valid_password?(credentials[1])\n          return authentication_response(user: user, failure: :invalid_password, &block)\n        end\n\n        if user.respond_to?(:active_for_authentication?) && !user.active_for_authentication?\n          return authentication_response(user: user, failure: :inactive, &block)\n        end\n\n        @sorcery_config.before_authenticate.each do |callback|\n          success, reason = user.send(callback)\n\n          unless success\n            return authentication_response(user: user, failure: reason, &block)\n          end\n        end\n\n        authentication_response(user: user, return_value: user, &block)\n      end\n\n      # encrypt tokens using current encryption_provider.\n      def encrypt(*tokens)\n        return tokens.first if @sorcery_config.encryption_provider.nil?\n\n        set_encryption_attributes\n\n        CryptoProviders::AES256.key = @sorcery_config.encryption_key\n        @sorcery_config.encryption_provider.encrypt(*tokens)\n      end\n\n      protected\n\n      def authentication_response(options = {})\n        yield(options[:user], options[:failure]) if block_given?\n\n        options[:return_value]\n      end\n\n      def set_encryption_attributes\n        @sorcery_config.encryption_provider.stretches = @sorcery_config.stretches if @sorcery_config.encryption_provider.respond_to?(:stretches) && @sorcery_config.stretches\n        @sorcery_config.encryption_provider.join_token = @sorcery_config.salt_join_token if @sorcery_config.encryption_provider.respond_to?(:join_token) && @sorcery_config.salt_join_token\n        @sorcery_config.encryption_provider.pepper = @sorcery_config.pepper if @sorcery_config.encryption_provider.respond_to?(:pepper) && @sorcery_config.pepper\n      end\n\n      def add_config_inheritance\n        class_eval do\n          def self.inherited(subclass)\n            subclass.class_eval do\n              class << self\n                attr_accessor :sorcery_config\n              end\n            end\n            subclass.sorcery_config = sorcery_config\n            super\n          end\n        end\n      end\n    end\n\n    module InstanceMethods\n      # Returns the class instance variable for configuration, when called by an instance.\n      def sorcery_config\n        self.class.sorcery_config\n      end\n\n      # identifies whether this user is regular, i.e. we hold his credentials in our db,\n      # or that he is external, and his credentials are saved elsewhere (twitter/facebook etc.).\n      def external?\n        send(sorcery_config.crypted_password_attribute_name).nil?\n      end\n\n      # Calls the configured encryption provider to compare the supplied password with the encrypted one.\n      def valid_password?(pass)\n        crypted = send(sorcery_config.crypted_password_attribute_name)\n        return crypted == pass if sorcery_config.encryption_provider.nil?\n\n        salt = send(sorcery_config.salt_attribute_name) unless sorcery_config.salt_attribute_name.nil?\n\n        sorcery_config.encryption_provider.matches?(crypted, pass, salt)\n      end\n\n      protected\n\n      # creates new salt and saves it.\n      # encrypts password with salt and saves it.\n      def encrypt_password\n        config = sorcery_config\n        send(:\"#{config.salt_attribute_name}=\", new_salt = TemporaryToken.generate_random_token) unless config.salt_attribute_name.nil?\n        send(:\"#{config.crypted_password_attribute_name}=\", self.class.encrypt(send(config.password_attribute_name), new_salt))\n      end\n\n      def clear_virtual_password\n        config = sorcery_config\n        send(:\"#{config.password_attribute_name}=\", nil)\n\n        return unless respond_to?(:\"#{config.password_attribute_name}_confirmation=\")\n\n        send(:\"#{config.password_attribute_name}_confirmation=\", nil)\n      end\n\n      # calls the requested email method on the configured mailer\n      # supports both the ActionMailer 3 way of calling, and the plain old Ruby object way.\n      def generic_send_email(method, mailer)\n        config = sorcery_config\n        mail = config.send(mailer).send(config.send(method), self)\n        return unless mail.respond_to?(config.email_delivery_method)\n\n        mail.send(config.email_delivery_method)\n      end\n    end\n  end\nend\n"], "fixing_code": ["module Sorcery\n  # This module handles all plugin operations which are related to the Model layer in the MVC pattern.\n  # It should be included into the ORM base class.\n  # In the case of Rails this is usually ActiveRecord (actually, in that case, the plugin does this automatically).\n  #\n  # When included it defines a single method: 'authenticates_with_sorcery!'\n  # which when called adds the other capabilities to the class.\n  # This method is also the place to configure the plugin in the Model layer.\n  module Model\n    def authenticates_with_sorcery!\n      @sorcery_config = Config.new\n\n      extend ClassMethods # included here, before submodules, so they can be overriden by them.\n      include InstanceMethods\n      include TemporaryToken\n\n      include_required_submodules!\n\n      # This runs the options block set in the initializer on the model class.\n      ::Sorcery::Controller::Config.user_config.tap { |blk| blk.call(@sorcery_config) if blk }\n\n      define_base_fields\n      init_orm_hooks!\n\n      @sorcery_config.after_config << :add_config_inheritance if @sorcery_config.subclasses_inherit_config\n      @sorcery_config.after_config.each { |c| send(c) }\n    end\n\n    private\n\n    def define_base_fields\n      class_eval do\n        sorcery_config.username_attribute_names.each do |username|\n          sorcery_adapter.define_field username, String, length: 255\n        end\n        unless sorcery_config.username_attribute_names.include?(sorcery_config.email_attribute_name)\n          sorcery_adapter.define_field sorcery_config.email_attribute_name, String, length: 255\n        end\n        sorcery_adapter.define_field sorcery_config.crypted_password_attribute_name, String, length: 255\n        sorcery_adapter.define_field sorcery_config.salt_attribute_name, String, length: 255\n      end\n    end\n\n    # includes required submodules into the model class,\n    # which usually is called User.\n    def include_required_submodules!\n      class_eval do\n        @sorcery_config.submodules = ::Sorcery::Controller::Config.submodules\n        @sorcery_config.submodules.each do |mod|\n          # TODO: Is there a cleaner way to handle missing submodules?\n          # rubocop:disable Lint/HandleExceptions\n          begin\n            include Submodules.const_get(mod.to_s.split('_').map(&:capitalize).join)\n          rescue NameError\n            # don't stop on a missing submodule. Needed because some submodules are only defined\n            # in the controller side.\n          end\n          # rubocop:enable Lint/HandleExceptions\n        end\n      end\n    end\n\n    # add virtual password accessor and ORM callbacks.\n    def init_orm_hooks!\n      sorcery_adapter.define_callback :before, :validation, :encrypt_password, if: proc { |record|\n        record.send(sorcery_config.password_attribute_name).present?\n      }\n\n      sorcery_adapter.define_callback :after, :save, :clear_virtual_password, if: proc { |record|\n        record.send(sorcery_config.password_attribute_name).present?\n      }\n\n      attr_accessor sorcery_config.password_attribute_name\n    end\n\n    module ClassMethods\n      # Returns the class instance variable for configuration, when called by the class itself.\n      def sorcery_config\n        @sorcery_config\n      end\n\n      # The default authentication method.\n      # Takes a username and password,\n      # Finds the user by the username and compares the user's password to the one supplied to the method.\n      # returns the user if success, nil otherwise.\n      def authenticate(*credentials, &block)\n        raise ArgumentError, 'at least 2 arguments required' if credentials.size < 2\n\n        if credentials[0].blank?\n          return authentication_response(return_value: false, failure: :invalid_login, &block)\n        end\n\n        if @sorcery_config.downcase_username_before_authenticating\n          credentials[0].downcase!\n        end\n\n        user = sorcery_adapter.find_by_credentials(credentials)\n\n        unless user\n          return authentication_response(failure: :invalid_login, &block)\n        end\n\n        set_encryption_attributes\n\n        if user.respond_to?(:active_for_authentication?) && !user.active_for_authentication?\n          return authentication_response(user: user, failure: :inactive, &block)\n        end\n\n        @sorcery_config.before_authenticate.each do |callback|\n          success, reason = user.send(callback)\n\n          unless success\n            return authentication_response(user: user, failure: reason, &block)\n          end\n        end\n\n        unless user.valid_password?(credentials[1])\n          return authentication_response(user: user, failure: :invalid_password, &block)\n        end\n\n        authentication_response(user: user, return_value: user, &block)\n      end\n\n      # encrypt tokens using current encryption_provider.\n      def encrypt(*tokens)\n        return tokens.first if @sorcery_config.encryption_provider.nil?\n\n        set_encryption_attributes\n\n        CryptoProviders::AES256.key = @sorcery_config.encryption_key\n        @sorcery_config.encryption_provider.encrypt(*tokens)\n      end\n\n      protected\n\n      def authentication_response(options = {})\n        yield(options[:user], options[:failure]) if block_given?\n\n        options[:return_value]\n      end\n\n      def set_encryption_attributes\n        @sorcery_config.encryption_provider.stretches = @sorcery_config.stretches if @sorcery_config.encryption_provider.respond_to?(:stretches) && @sorcery_config.stretches\n        @sorcery_config.encryption_provider.join_token = @sorcery_config.salt_join_token if @sorcery_config.encryption_provider.respond_to?(:join_token) && @sorcery_config.salt_join_token\n        @sorcery_config.encryption_provider.pepper = @sorcery_config.pepper if @sorcery_config.encryption_provider.respond_to?(:pepper) && @sorcery_config.pepper\n      end\n\n      def add_config_inheritance\n        class_eval do\n          def self.inherited(subclass)\n            subclass.class_eval do\n              class << self\n                attr_accessor :sorcery_config\n              end\n            end\n            subclass.sorcery_config = sorcery_config\n            super\n          end\n        end\n      end\n    end\n\n    module InstanceMethods\n      # Returns the class instance variable for configuration, when called by an instance.\n      def sorcery_config\n        self.class.sorcery_config\n      end\n\n      # identifies whether this user is regular, i.e. we hold his credentials in our db,\n      # or that he is external, and his credentials are saved elsewhere (twitter/facebook etc.).\n      def external?\n        send(sorcery_config.crypted_password_attribute_name).nil?\n      end\n\n      # Calls the configured encryption provider to compare the supplied password with the encrypted one.\n      def valid_password?(pass)\n        crypted = send(sorcery_config.crypted_password_attribute_name)\n        return crypted == pass if sorcery_config.encryption_provider.nil?\n\n        salt = send(sorcery_config.salt_attribute_name) unless sorcery_config.salt_attribute_name.nil?\n\n        sorcery_config.encryption_provider.matches?(crypted, pass, salt)\n      end\n\n      protected\n\n      # creates new salt and saves it.\n      # encrypts password with salt and saves it.\n      def encrypt_password\n        config = sorcery_config\n        send(:\"#{config.salt_attribute_name}=\", new_salt = TemporaryToken.generate_random_token) unless config.salt_attribute_name.nil?\n        send(:\"#{config.crypted_password_attribute_name}=\", self.class.encrypt(send(config.password_attribute_name), new_salt))\n      end\n\n      def clear_virtual_password\n        config = sorcery_config\n        send(:\"#{config.password_attribute_name}=\", nil)\n\n        return unless respond_to?(:\"#{config.password_attribute_name}_confirmation=\")\n\n        send(:\"#{config.password_attribute_name}_confirmation=\", nil)\n      end\n\n      # calls the requested email method on the configured mailer\n      # supports both the ActionMailer 3 way of calling, and the plain old Ruby object way.\n      def generic_send_email(method, mailer)\n        config = sorcery_config\n        mail = config.send(mailer).send(config.send(method), self)\n        return unless mail.respond_to?(config.email_delivery_method)\n\n        mail.send(config.email_delivery_method)\n      end\n    end\n  end\nend\n"], "filenames": ["lib/sorcery/model.rb"], "buggy_code_start_loc": [105], "buggy_code_end_loc": [118], "fixing_code_start_loc": [104], "fixing_code_end_loc": [119], "type": "CWE-307", "message": "In Sorcery before 0.15.0, there is a brute force vulnerability when using password authentication via Sorcery. The brute force protection submodule will prevent a brute force attack for the defined lockout period, but once expired, protection will not be re-enabled until a user or malicious actor logs in successfully. This does not affect users that do not use the built-in brute force protection submodule, nor users that use permanent account lockout. This has been patched in 0.15.0.", "other": {"cve": {"id": "CVE-2020-11052", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-07T21:15:11.483", "lastModified": "2020-05-13T13:59:20.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Sorcery before 0.15.0, there is a brute force vulnerability when using password authentication via Sorcery. The brute force protection submodule will prevent a brute force attack for the defined lockout period, but once expired, protection will not be re-enabled until a user or malicious actor logs in successfully. This does not affect users that do not use the built-in brute force protection submodule, nor users that use permanent account lockout. This has been patched in 0.15.0."}, {"lang": "es", "value": "En Sorcery versiones anteriores a 0.15.0, se presenta una vulnerabilidad de fuerza bruta cuando se utiliza la autenticaci\u00f3n de contrase\u00f1a por medio de Sorcery. El subm\u00f3dulo de protecci\u00f3n de fuerza bruta impedir\u00e1 un ataque de fuerza bruta durante el per\u00edodo de bloqueo definido, pero una vez que expire, la protecci\u00f3n no se volver\u00e1 a habilitar hasta que un usuario o actor malicioso inicie sesi\u00f3n con \u00e9xito. Esto no afecta a los usuarios que no usan el subm\u00f3dulo de protecci\u00f3n de fuerza bruta incorporado, ni a los usuarios que utilizan el bloqueo permanente de la cuenta. Esto ha sido parcheado en la versi\u00f3n 0.15.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-307"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-307"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sorcery_project:sorcery:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "0.15.0", "matchCriteriaId": "07C2C42F-F970-4D1A-95FB-9EE238C0A190"}]}]}], "references": [{"url": "https://github.com/Sorcery/sorcery/commit/0f116d223826895a73b12492f17486e5d54ab7a7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Sorcery/sorcery/issues/231", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Sorcery/sorcery/pull/235", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Sorcery/sorcery/security/advisories/GHSA-jc8m-cxhj-668x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Sorcery/sorcery/commit/0f116d223826895a73b12492f17486e5d54ab7a7"}}