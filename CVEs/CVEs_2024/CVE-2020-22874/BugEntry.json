{"buggy_code": ["<title>Reference</title>\n<p>\n<div id=\"sectmenu\" data-opts=\"closed:false\"></div><B>JSI REFERENCE</B>: <a href=\"#System\">System</a> contains global methods\n<a name=\"Array\"></a>\n\n<hr>\n\n\n<h1>Array</h1>\n\n<font color=red>Synopsis:new Array(...):array\n\n</font><p>Provide access to array objects.\n\n\n<h2>Methods for \"Array\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Array</td><td>new Array(...):array </td><td>jsi_Array constructor.</td></tr>\n<tr><td>concat</td><td>concat(...):array </td><td>Return array with args appended.</td></tr>\n<tr><td>every</td><td>every(callback:function) </td><td>Returns true if every value in array satisfies the test.</td></tr>\n<tr><td>fill</td><td>fill(value:any, start:number=0, end:number=-1):array </td><td>Fill an array with values.</td></tr>\n<tr><td>filter</td><td>filter(callback:function, this:object=void):array </td><td>Return a filtered array.</td></tr>\n<tr><td>find</td><td>find(callback:function) </td><td>Returns the value of the first element in the array that satisfies the test.</td></tr>\n<tr><td>findIndex</td><td>findIndex(callback:function) </td><td>Returns the index of the first element in the array that satisfies the test.</td></tr>\n<tr><td>flat</td><td>flat(depth:number=1):array </td><td>Flatten an arra.</td></tr>\n<tr><td>forEach</td><td>forEach(callback:function, this:object=void):void </td><td>Invoke function with each item in object.</td></tr>\n<tr><td>includes</td><td>includes(val:any) </td><td>Returns true if array contains value.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:any, startIdx:number=0):number </td><td>Return index of first occurrance in array.</td></tr>\n<tr><td>isArray</td><td>isArray():boolean </td><td>True if val array.</td></tr>\n<tr><td>join</td><td>join(sep:string=''):string </td><td>Return elements joined by char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(val:any, start:number=0):number </td><td>Return index of last occurence in array.</td></tr>\n<tr><td>map</td><td>map(callback:function, this:object=void):array </td><td>Creates a new array with the results of calling a provided function on every element in this array.</td></tr>\n<tr><td>pop</td><td>pop() </td><td>Remove and return last element of array.</td></tr>\n<tr><td>push</td><td>push(val:any, ...):number </td><td>Push one or more elements onto array and return size.</td></tr>\n<tr><td>reduce</td><td>reduce(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reduceRight</td><td>reduceRight(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reverse</td><td>reverse():array </td><td>Reverse order of all elements in an array.</td></tr>\n<tr><td>shift</td><td>shift() </td><td>Remove first element and shift downwards.</td></tr>\n<tr><td>sizeOf</td><td>sizeOf():number </td><td>Return size of array.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number=void):array </td><td>Return sub-array.</td></tr>\n<tr><td>some</td><td>some(callback:function, this:object=void):boolean </td><td>Return true if function returns true some element.</td></tr>\n<tr><td>sort</td><td>sort(<a href='#Array.sortOptions'>options</a>:function|object=void):array </td><td>Sort an array.</td></tr>\n<tr><td>splice</td><td>splice(start:number, howmany:number=void, ...):array </td><td>Change the content of an array, adding new elements while removing old elements.</td></tr>\n<tr><td>unshift</td><td>unshift(...):number </td><td>Add new elements to start of array and return size.</td></tr>\n</table>\n\n\n<a name=\"Array.sortOptions\"></a>\n<a name=\"Array.confOptions\"></a>\n<h2>Options for \"Array.sort\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Mode to sort by. (one of: <b>default</b>, <b>desc</b>, <b>dict</b>, <b>nocase</b>)</td><td><i></i></td></tr>\n<tr><td>compare</td><td><i>FUNC</i></td><td>Function to do comparison. @function(val1,val2)</td><td><i></i></td></tr>\n<tr><td>unique</td><td><i>BOOL</i></td><td>Eliminate duplicate items.</td><td><i></i></td></tr>\n</table>\n<a name=\"Arrayend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Boolean\"></a>\n\n<hr>\n\n\n<h1>Boolean</h1>\n\n<font color=red>Synopsis:new Boolean(bool:boolean=false):boolean\n\n</font><p>A Boolean object.\n\n\n<h2>Methods for \"Boolean\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Boolean</td><td>new Boolean(bool:boolean=false):boolean </td><td>Boolean constructor.</td></tr>\n</table>\n<a name=\"Booleanend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CData\"></a>\n\n<hr>\n\n\n<h1>CData</h1>\n\n<font color=red>Synopsis:new CData(options:string&verbar;object=void, inits:object=undefined):userobj\n\n</font><p>\n<h2>Methods for \"CData\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>CData</td><td>new CData(<a href='#new CDataOptions'>options</a>:string|object=void, inits:object=undefined):userobj </td><td>Create a new struct or map/array of structs.The 2nd arg is used for function option parsing and will report errors at the callers file:line</td></tr>\n<tr><td>conf</td><td>conf(<a href='#CData.confOptions'>options</a>:object|string=void) </td><td>Configure options for c-data.</td></tr>\n<tr><td>get</td><td>get(key:string|number|object=null, field:string=void) </td><td>Get struct/map/array value.</td></tr>\n<tr><td>incr</td><td>incr(key:string|number|object|null, field:object|string, value:number=1):number </td><td>Increment a numeric field: returns the new value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info for data.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return keys for map.</td></tr>\n<tr><td>set</td><td>set(key:string|number|object|null, field:object|string, value:any=void) </td><td>Set a struct/map/array value.</td></tr>\n<tr><td>unset</td><td>unset(key:string|number|object) </td><td>Remove entry from map/array.</td></tr>\n</table>\n\n\n<a name=\"new CDataOptions\"></a>\n<a name=\"CData.confOptions\"></a>\n<h2>Options for \"new CData\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>If an array, its size in elements.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>UINT</i></td><td>Flags.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of data.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyName</td><td><i>STRKEY</i></td><td>Key struct, for key struct maps.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyType</td><td><i>STRKEY</i></td><td>Key id. (one of: <b>string</b>, <b>strkey</b>, <b>number</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>mapType</td><td><i>STRKEY</i></td><td>If a map, its type. (one of: <b>none</b>, <b>hash</b>, <b>tree</b>, <b>list</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>maxSize</td><td><i>UINT</i></td><td>Limit the array size or number of keys in a map.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name (eg. of var assigned to on create).</td><td><i>initOnly</i></td></tr>\n<tr><td>noAuto</td><td><i>BOOL</i></td><td>Disable auto-create of map keys in set/incr.</td><td><i></i></td></tr>\n<tr><td>structName</td><td><i>STRKEY</i></td><td>Struct used for storing data.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>varParam</td><td><i>STRKEY</i></td><td>Param for maps/array vars.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CDataend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CEnum\"></a>\n\n<hr>\n\n\n<h1>CEnum</h1>\n\n<font color=red>Synopsis:CEnum.method(...)\n\n</font><p>Enum commands. Note: Enum() is a shortcut for Enum.add().\n\n\n<h2>Methods for \"CEnum\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CEnum.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a new enum: value of items same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(enum:string, <a href='#CEnum.confOptions'>options</a>:object|string=void) </td><td>Configure options for enum.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(enum:string, field:string, <a href='#CEnum.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>find</td><td>find(enum:string, intValue:number):string </td><td>Find item with given value in enum.</td></tr>\n<tr><td>get</td><td>get(enum:string):object </td><td>Return enum definition.</td></tr>\n<tr><td>names</td><td>names(enum:string=void):array </td><td>Return name list of all enums, or items within one enum.</td></tr>\n<tr><td>remove</td><td>remove(enum:string) </td><td>Remove an enum.</td></tr>\n<tr><td>value</td><td>value(enum:string, item:string):number </td><td>Return value for given enum item.</td></tr>\n</table>\n\n\n<a name=\"CEnum.addOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.confOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.fieldconfOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Desciption of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Value for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Index of item in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"CEnumend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CStruct\"></a>\n\n<hr>\n\n\n<h1>CStruct</h1>\n\n<font color=red>Synopsis:CStruct.method(...)\n\n</font><p>Struct commands. Note: Struct() is a shortcut for Struct.add().\n\n\n<h2>Methods for \"CStruct\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CStruct.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a struct: field values same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(struct:string, <a href='#CStruct.confOptions'>options</a>:object|string=void) </td><td>Configure options for struct.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(struct:string, field:string, <a href='#CStruct.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>get</td><td>get(struct, options:object=void):object </td><td>Return the struct definition.</td></tr>\n<tr><td>names</td><td>names(struct:string=void):array </td><td>Return name list of all structs, or fields for one struct.</td></tr>\n<tr><td>remove</td><td>remove(name:string) </td><td>Remove a struct.</td></tr>\n<tr><td>schema</td><td>schema():string </td><td>Return database schema for struct.</td></tr>\n</table>\n\n\n<a name=\"CStruct.addOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.confOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.fieldconfOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>Size of field if an array.</td><td><i>initOnly</i></td></tr>\n<tr><td>bits</td><td><i>UINT32</i></td><td>Size of bitfield.</td><td><i>initOnly</i></td></tr>\n<tr><td>boffset</td><td><i>UINT32</i></td><td>Bit offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Index of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Field description.</td><td><i>initOnly</i></td></tr>\n<tr><td>info</td><td><i>STRKEY</i></td><td>Info for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>offset</td><td><i>UINT</i></td><td>Offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>type</td><td><i>CUSTOM</i></td><td>Type of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>init</td><td><i>CUSTOM</i></td><td>Initial value for field.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CStructend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CType\"></a>\n\n<hr>\n\n\n<h1>CType</h1>\n\n<font color=red>Synopsis:CType.method(...)\n\n</font><p>Type commands. Note: Type() is a shortcut for Type.conf().\n\n\n<h2>Methods for \"CType\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(typ:string, <a href='#CType.confOptions'>options</a>:object|string=void) </td><td>Configure options for type.</td></tr>\n<tr><td>names</td><td>names(ctype=false):array </td><td>Return type names.</td></tr>\n</table>\n\n\n<a name=\"CType.confOptions\"></a>\n<a name=\"CType.confOptions\"></a>\n<h2>Options for \"CType.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>idName</td><td><i>STRKEY</i></td><td>The id name: usually upcased cName.</td><td><i>initOnly</i></td></tr>\n<tr><td>cName</td><td><i>STRKEY</i></td><td>C type name.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of id.</td><td><i>initOnly</i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>xfmt</td><td><i>STRKEY</i></td><td>Hex printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>size</td><td><i>INT</i></td><td>Size for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n<a name=\"CTypeend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Channel\"></a>\n\n<hr>\n\n\n<h1>Channel</h1>\n\n<font color=red>Synopsis:new Channel(file:string, mode:string='r'):userobj\n\n</font><p>Commands for accessing Channel objects for file IO.\n\n\n<h2>Methods for \"Channel\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Channel</td><td>new Channel(file:string, mode:string='r'):userobj </td><td>A file input/output object. The mode string is r or w and an optional +.</td></tr>\n<tr><td>close</td><td>close():boolean </td><td>Close the file.</td></tr>\n<tr><td>eof</td><td>eof():boolean </td><td>Return true if read to end-of-file.</td></tr>\n<tr><td>filename</td><td>filename():string </td><td>Get file name.</td></tr>\n<tr><td>flush</td><td>flush():number </td><td>Flush file output.</td></tr>\n<tr><td>gets</td><td>gets():string|void </td><td>Get one line of input.</td></tr>\n<tr><td>lstat</td><td>lstat():object </td><td>Return status for file.</td></tr>\n<tr><td>mode</td><td>mode():string </td><td>Get file mode used with open.</td></tr>\n<tr><td>open</td><td>open(file:string, mode:string='r'):boolean </td><td>Open the file (after close).</td></tr>\n<tr><td>puts</td><td>puts(str):boolean </td><td>Write one line of output.</td></tr>\n<tr><td>read</td><td>read(size:number=-1):string|void </td><td>Read some or all of file.</td></tr>\n<tr><td>seek</td><td>seek(pos:number, whence:string):number </td><td>Seek to position. Return 0 if ok.</td></tr>\n<tr><td>stat</td><td>stat():object </td><td>Return status for file.</td></tr>\n<tr><td>tell</td><td>tell():number </td><td>Return current position.</td></tr>\n<tr><td>truncate</td><td>truncate(pos:number):number </td><td>Truncate file.</td></tr>\n<tr><td>write</td><td>write(data):number </td><td>Write data to file.</td></tr>\n</table>\n<a name=\"Channelend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Debugger\"></a>\n\n<hr>\n\n\n<h1>Debugger</h1>\n\n<font color=red>Synopsis:Debugger.method(...)\n\n</font><p>Debugger breakpoint management.\n\n\n<h2>Methods for \"Debugger\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(val:string|number, temp:boolean=false):number </td><td>Add a breakpoint for line, file:line or func.</td></tr>\n<tr><td>enable</td><td>enable(id:number, on:boolean):void </td><td>Enable/disable breakpoint.</td></tr>\n<tr><td>info</td><td>info(id:number=void):array|object </td><td>Return info about one breakpoint, or list of bp numbers.</td></tr>\n<tr><td>remove</td><td>remove(id:number):void </td><td>Remove breakpoint.</td></tr>\n</table>\n<a name=\"Debuggerend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Event\"></a>\n\n<hr>\n\n\n<h1>Event</h1>\n\n<font color=red>Synopsis:Event.method(...)\n\n</font><p>Event management.\n\n\n<h2>Methods for \"Event\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete an event (created with setInterval/setTimeout).</td></tr>\n<tr><td>info</td><td>info(id:number):object </td><td>Return info for the given event id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list event ids (created with setTimeout/setInterval).</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, millisecs:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, millisecs:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>update</td><td>update(<a href='#Event.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"Event.updateOptions\"></a>\n<a name=\"Event.confOptions\"></a>\n<h2>Options for \"Event.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Eventend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"File\"></a>\n\n<hr>\n\n\n<h1>File</h1>\n\n<font color=red>Synopsis:File.method(...)\n\n</font><p>Commands for accessing the filesystem.\n\n\n<h2>Methods for \"File\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>atime</td><td>atime(file:string):number </td><td>Return file Jsi_Access time.</td></tr>\n<tr><td>chdir</td><td>chdir(file:string) </td><td>Change current directory.</td></tr>\n<tr><td>chmod</td><td>chmod(file:string, mode:number) </td><td>Set file permissions.</td></tr>\n<tr><td>copy</td><td>copy(src:string, dest:string, force:boolean=false) </td><td>Copy a file to destination. Directories are not handled.\nThe third argument if given is a boolean force value which if true allows overwrite of an existing file. </td></tr>\n<tr><td>dirname</td><td>dirname(file:string):string </td><td>Return directory path.</td></tr>\n<tr><td>executable</td><td>executable(file:string):boolean </td><td>Return true if file is executable.</td></tr>\n<tr><td>exists</td><td>exists(file:string):boolean </td><td>Return true if file exists.</td></tr>\n<tr><td>extension</td><td>extension(file:string):string </td><td>Return file extension.</td></tr>\n<tr><td>glob</td><td>glob(pattern:regexp|string|null='*', <a href='#File.globOptions'>options</a>:function|object|null=void):array </td><td>Return list of files in dir with optional pattern match. With no arguments (or null) returns all files/directories in current directory.\nThe first argument can be a pattern (either a glob or regexp) of the files to return.\nWhen the second argument is a function, it is called with each path, and filter on false.\nOtherwise second argument must be a set of options.</td></tr>\n<tr><td>isdir</td><td>isdir(file:string):boolean </td><td>Return true if file is a directory.</td></tr>\n<tr><td>isfile</td><td>isfile(file:string):boolean </td><td>Return true if file is a normal file.</td></tr>\n<tr><td>isrelative</td><td>isrelative(file:string):boolean </td><td>Return true if file path is relative.</td></tr>\n<tr><td>join</td><td>join(path:string, path:string):string </td><td>Join two file realpaths, or just second if an absolute path.</td></tr>\n<tr><td>link</td><td>link(src:string, dest:string, ishard:boolean=false) </td><td>Link a file. The second argument is the destination file to be created. If a third bool argument is true, a hard link is created.</td></tr>\n<tr><td>lstat</td><td>lstat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>mkdir</td><td>mkdir(file:string,force:boolean=false) </td><td>Create a directory: force creates subdirs.</td></tr>\n<tr><td>mknod</td><td>mknod(file:string, mode:number, dev:number) </td><td>Create unix device file using mknod.</td></tr>\n<tr><td>mtime</td><td>mtime(file:string):number </td><td>Return file modified time.</td></tr>\n<tr><td>owned</td><td>owned(file:string):boolean </td><td>Return true if file is owned by user.</td></tr>\n<tr><td>pwd</td><td>pwd():string </td><td>Return current directory.</td></tr>\n<tr><td>read</td><td>read(file:string, mode:string='rb'):string </td><td>Read a file.</td></tr>\n<tr><td>readable</td><td>readable(file:string):boolean </td><td>Return true if file is readable.</td></tr>\n<tr><td>readlink</td><td>readlink(file:string):string </td><td>Read file link destination.</td></tr>\n<tr><td>realpath</td><td>realpath(file:string):string </td><td>Return absolute file name minus .., ./ etc.</td></tr>\n<tr><td>remove</td><td>remove(file:string, force:boolean=false) </td><td>Delete a file or direcotry.</td></tr>\n<tr><td>rename</td><td>rename(src:string, dest:string, force:boolean=false) </td><td>Rename a file, with possible overwrite.</td></tr>\n<tr><td>rootname</td><td>rootname(file:string):string </td><td>Return file name minus extension.</td></tr>\n<tr><td>size</td><td>size(file:string):number </td><td>Return size for file.</td></tr>\n<tr><td>stat</td><td>stat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>tail</td><td>tail(file:string):string </td><td>Return file name minus dirname.</td></tr>\n<tr><td>tempfile</td><td>tempfile(file:string) </td><td>Create a temp file.</td></tr>\n<tr><td>truncate</td><td>truncate(file:string, size:number) </td><td>Truncate file.</td></tr>\n<tr><td>type</td><td>type(file:string):string </td><td>Return type of file.</td></tr>\n<tr><td>writable</td><td>writable(file:string):boolean </td><td>Return true if file is writable.</td></tr>\n<tr><td>write</td><td>write(file:string, str:string, mode:string='wb+'):number </td><td>Write a file.</td></tr>\n</table>\n\n\n<a name=\"File.globOptions\"></a>\n<a name=\"File.confOptions\"></a>\n<h2>Options for \"File.glob\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>dir</td><td><i>STRING</i></td><td>The start directory: this path will not be prepended to results.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Maximum directory depth to recurse into.</td><td><i></i></td></tr>\n<tr><td>maxDiscard</td><td><i>INT</i></td><td>Maximum number of items to discard before giving up.</td><td><i></i></td></tr>\n<tr><td>dirFilter</td><td><i>FUNC</i></td><td>Filter function for directories, returning false to discard. @function(dir:string)</td><td><i></i></td></tr>\n<tr><td>filter</td><td><i>FUNC</i></td><td>Filter function to call with each file, returning false to discard. @function(file:string)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>The maximum number of results to return/count: -1 is unlimited (Interp.maxArrayList).</td><td><i></i></td></tr>\n<tr><td>noTypes</td><td><i>STRKEY</i></td><td>Filter files to exclude these \"types\".</td><td><i></i></td></tr>\n<tr><td>prefix</td><td><i>STRKEY</i></td><td>String prefix to prepend to each file in result list.</td><td><i></i></td></tr>\n<tr><td>recurse</td><td><i>BOOL</i></td><td>Recurse into sub-directories.</td><td><i></i></td></tr>\n<tr><td>retCount</td><td><i>BOOL</i></td><td>Return only the count of matches.</td><td><i></i></td></tr>\n<tr><td>tails</td><td><i>BOOL</i></td><td>Returned only tail of path.</td><td><i></i></td></tr>\n<tr><td>types</td><td><i>STRKEY</i></td><td>Filter files to include type: one or more of chars 'fdlpsbc' for file, directory, link, etc.</td><td><i></i></td></tr>\n</table>\n<a name=\"Fileend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Function\"></a>\n\n<hr>\n\n\n<h1>Function</h1>\n\n<font color=red>Synopsis:new Function():function\n\n</font><p>Commands for accessing functions.\n\n\n<h2>Methods for \"Function\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Function</td><td>new Function():function </td><td>Function constructor (unimplemented).</td></tr>\n<tr><td>apply</td><td>apply(thisArg:null|object|function, args:array=void) </td><td>Call function passing args array.</td></tr>\n<tr><td>bind</td><td>bind(thisArg:object|function=null,arg,...) </td><td>Return function that calls bound function prepended with thisArg+arguments.</td></tr>\n<tr><td>call</td><td>call(thisArg:null|object|function, arg1, ...) </td><td>Call function with args.</td></tr>\n</table>\n<a name=\"Functionend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Info\"></a>\n\n<hr>\n\n\n<h1>Info</h1>\n\n<font color=red>Synopsis:Info.method(...)\n\n</font><p>Commands for inspecting internal state information in JSI.\n\n\n<h2>Methods for \"Info\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argv0</td><td>argv0():string|void </td><td>Return initial start script file name.</td></tr>\n<tr><td>cmds</td><td>cmds(val:string|regexp='*', <a href='#Info.cmdsOptions'>options</a>:object=void):array|object </td><td>Return details or list of matching commands.</td></tr>\n<tr><td>completions</td><td>completions(str:string, start:number=0, end:number=void):array </td><td>Return command completions on portion of string from start to end.</td></tr>\n<tr><td>data</td><td>data(val:string|regexp|object=void):array|object </td><td>Return list of matching data (non-functions). Like info.vars(), but does not return function values.</td></tr>\n<tr><td>error</td><td>error():object </td><td>Return file and line number of error (used inside catch).</td></tr>\n<tr><td>event</td><td>event(id:number=void):array|object </td><td>List events or info for 1 event (setTimeout/setInterval). With no args, returns list of all outstanding events.  With one arg, returns infofor the given event id.</td></tr>\n<tr><td>execZip</td><td>execZip():string|void </td><td>If executing a .zip file, return file name.</td></tr>\n<tr><td>executable</td><td>executable():string </td><td>Return name of executable.</td></tr>\n<tr><td>files</td><td>files():array </td><td>Return list of all sourced files.</td></tr>\n<tr><td>funcs</td><td>funcs(string|regexp|object=void):array|object </td><td>Return details or list of matching functions.</td></tr>\n<tr><td>interp</td><td>interp(interp:userobj=void):object </td><td>Return info on given or current interp.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>keywords</td><td>keywords(isSql=false, name:string=void):boolean|array </td><td>Return/lookup reserved keyword.</td></tr>\n<tr><td>level</td><td>level(level:number=void):number|array|object </td><td>Return current level or details of a call-stack frame. With no arg, returns the number of the current stack frame level.\nOtherwise returns details on the specified level.\nThe topmost level is 1, and 0 is the current level, and a negative level translates as relative to the current level.</td></tr>\n<tr><td>locals</td><td>locals(filter:boolean=void):object </td><td>Return locals; use filter=true/false just vars/functions.</td></tr>\n<tr><td>lookup</td><td>lookup(name:string) </td><td>Given string name, lookup and return value, eg: function.</td></tr>\n<tr><td>methods</td><td>methods(val:string|regexp):array|object </td><td>Return functions and commands.</td></tr>\n<tr><td>named</td><td>named(name:string=void):array|userobj </td><td>Returns command names for builtin Objects, eg: 'File', 'Interp', sub-Object names, or the named object.</td></tr>\n<tr><td>options</td><td>options(ctype:boolean=false):array </td><td>Return Option type name, or with true the C type.</td></tr>\n<tr><td>package</td><td>package(pkgName:string):object|null </td><td>Return info about provided package if exists, else null.</td></tr>\n<tr><td>platform</td><td>platform():object </td><td>N/A. Returns general platform information for JSI.</td></tr>\n<tr><td>script</td><td>script(func:function|regexp=void):string|array|void </td><td>Get current script file name, or file containing function.</td></tr>\n<tr><td>scriptDir</td><td>scriptDir():string|void </td><td>Get directory of current script.</td></tr>\n<tr><td>vars</td><td>vars(val:string|regexp|object=void):array|object </td><td>Return details or list of matching variables. Returns all values, data or function.</td></tr>\n<tr><td>version</td><td>version(full:boolean=false):number|object </td><td>JSI version: returns object when full=true.</td></tr>\n</table>\n\n\n<a name=\"Info.cmdsOptions\"></a>\n<a name=\"Info.confOptions\"></a>\n<h2>Options for \"Info.cmds\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Return full path.</td><td><i></i></td></tr>\n<tr><td>constructor</td><td><i>BOOL</i></td><td>Do not exclude constructor.</td><td><i></i></td></tr>\n</table>\n<a name=\"Infoend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Interp\"></a>\n\n<hr>\n\n\n<h1>Interp</h1>\n\n<font color=red>Synopsis:new Interp(options:object=void):userobj\n\n</font><p>Commands for accessing interps.\n\n\n<h2>Methods for \"Interp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Interp</td><td>new Interp(<a href='#new InterpOptions'>options</a>:object=void):userobj </td><td>Create a new interp.</td></tr>\n<tr><td>alias</td><td>alias(name:string=void, func:function|null=void, args:array|null=void, async=false) </td><td>Set/get global alias bindings for command in an interp. With 0 args, returns list of all aliases in interp.\nWith 1 arg returns func for given alias name.\nWith 2 args where arg2 == null, returns args for given alias name .\nWith 3 args, create/update an alias for func and args. \nDelete an alias by creating it with null for both func and args.</td></tr>\n<tr><td>call</td><td>call(funcName:string, args:array, wait:boolean=false) </td><td>Call named function in subinterp. Invoke function in sub-interp with arguments.\nSince interps are not allowed to share objects, data is automatically cleansed by encoding/decoding to/from JSON if required.\nUnless an 'async' parameter is true call is acyncronous.\nOtherwise waits until the sub-interp is idle, to make call and return result.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Interp.confOptions'>options</a>:string|object=void) </td><td>Configure option(s).</td></tr>\n<tr><td>eval</td><td>eval(js:string, async:boolean=false) </td><td>Interpret script within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Returns internal statistics about interp.</td></tr>\n<tr><td>source</td><td>source(file:string, async:boolean=false) </td><td>Interpret file within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>uplevel</td><td>uplevel(js:string, level:number=0) </td><td>Interpret code at the given stack level. The level argument is as returned by Info.level().  Not supported with threads.</td></tr>\n<tr><td>value</td><td>value(var:string, level:number=0) </td><td>Lookup value of variable at stack level.</td></tr>\n</table>\n\n\n<a name=\"new InterpOptions\"></a>\n<a name=\"Interp.confOptions\"></a>\n<h2>Options for \"new Interp\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>args</td><td><i>ARRAY</i></td><td>The console.arguments for interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>asserts</td><td><i>BOOL</i></td><td>Enable assert.</td><td><i></i></td></tr>\n<tr><td>assertMode</td><td><i>STRKEY</i></td><td>Action upon assert failure. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>autoFiles</td><td><i>ARRAY</i></td><td>File(s) to source for loading Jsi_Auto to handle unknown commands.</td><td><i></i></td></tr>\n<tr><td>busyCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp (or noOp) to periodically call.</td><td><i></i></td></tr>\n<tr><td>busyInterval</td><td><i>INT</i></td><td>Call busyCallback command after this many op-code evals (100000).</td><td><i></i></td></tr>\n<tr><td>confFile</td><td><i>STRKEY</i></td><td>Config file of options in non-strict JSON form.</td><td><i>initOnly</i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>debugOpts</td><td><i><a href='#debugOptsOptions'>options</a></i></td><td>Options for debugging.</td><td><i></i></td></tr>\n<tr><td>interactive</td><td><i>BOOL</i></td><td>Force interactive mode. ie. ignore no_interactive flag.</td><td><i>initOnly</i></td></tr>\n<tr><td>hasOpenSSL</td><td><i>BOOL</i></td><td>Is SSL available in WebSocket.</td><td><i>initOnly</i></td></tr>\n<tr><td>historyFile</td><td><i>STRKEY</i></td><td>In interactive mode, file to use for history (~/.jsish_history).</td><td><i>initOnly</i></td></tr>\n<tr><td>isSafe</td><td><i>BOOL</i></td><td>Is this a safe interp (ie. with limited or no file access).</td><td><i>initOnly</i></td></tr>\n<tr><td>jsppChars</td><td><i>STRKEY</i></td><td>Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string.</td><td><i></i></td></tr>\n<tr><td>jsppCallback</td><td><i>FUNC</i></td><td>Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number).</td><td><i></i></td></tr>\n<tr><td>lockTimeout</td><td><i>INT</i></td><td>Thread time-out for mutex lock acquires (milliseconds).</td><td><i></i></td></tr>\n<tr><td>logOpts</td><td><i><a href='#logOptsOptions'>options</a></i></td><td>Options for log output to add file/line/time.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Depth limit of recursive function calls (1000).</td><td><i></i></td></tr>\n<tr><td>maxArrayList</td><td><i>INT</i></td><td>Maximum array convertable to list (100000).</td><td><i></i></td></tr>\n<tr><td>maxIncDepth</td><td><i>INT</i></td><td>Maximum allowed source/require nesting depth (50).</td><td><i></i></td></tr>\n<tr><td>maxInterpDepth</td><td><i>INT</i></td><td>Maximum nested subinterp create depth (10).</td><td><i></i></td></tr>\n<tr><td>maxUserObjs</td><td><i>INT</i></td><td>Maximum number of 'new' object calls, eg. File, RegExp, etc.</td><td><i></i></td></tr>\n<tr><td>maxOpCnt</td><td><i>INT</i></td><td>Execution limit for op-code evaluation.</td><td><i>initOnly</i></td></tr>\n<tr><td>memDebug</td><td><i>INT</i></td><td>Memory debugging level: 1=summary, 2=detail.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Optional text name for this interp.</td><td><i></i></td></tr>\n<tr><td>noAutoLoad</td><td><i>BOOL</i></td><td>Disable autoload.</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Interp.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noInput</td><td><i>BOOL</i></td><td>Disable use of console.input().</td><td><i></i></td></tr>\n<tr><td>noLoad</td><td><i>BOOL</i></td><td>Disable load of shared libs.</td><td><i></i></td></tr>\n<tr><td>noNetwork</td><td><i>BOOL</i></td><td>Disable new Socket/WebSocket, or load of builtin MySql.</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Make puts, log, assert, etc use stdout.</td><td><i></i></td></tr>\n<tr><td>noSubInterps</td><td><i>BOOL</i></td><td>Disallow sub-interp creation.</td><td><i></i></td></tr>\n<tr><td>onComplete</td><td><i>FUNC</i></td><td>Function to return commands completions for interactive mode.  Default uses Info.completions . @function(prefix:string, start:number, end:number)</td><td><i></i></td></tr>\n<tr><td>onEval</td><td><i>FUNC</i></td><td>Function to get control for interactive evals. @function(cmd:string)</td><td><i></i></td></tr>\n<tr><td>onExit</td><td><i>FUNC</i></td><td>Command to call in parent on exit, returns true to continue. @function()</td><td><i>initOnly</i></td></tr>\n<tr><td>pkgDirs</td><td><i>ARRAY</i></td><td>list of library directories for require() to search.</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>retValue</td><td><i>VALUE</i></td><td>Return value from last eval.</td><td><i>readOnly</i></td></tr>\n<tr><td>safeMode</td><td><i>STRKEY</i></td><td>In safe mode source() support for pwd and script-dir . (one of: <b>none</b>, <b>read</b>, <b>write</b>, <b>writeRead</b>, <b>lockdown</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>safeReadDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow reads to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeWriteDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow writes to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeExecPattern</td><td><i>STRKEY</i></td><td>In safe mode, regexp pattern allow exec of commands.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptStr</td><td><i>STRKEY</i></td><td>Interp init script string.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptFile</td><td><i>STRING</i></td><td>Interp init script file.</td><td><i></i></td></tr>\n<tr><td>stdinStr</td><td><i>STRING</i></td><td>String to use as stdin for console.input().</td><td><i></i></td></tr>\n<tr><td>stdoutStr</td><td><i>STRING</i></td><td>String to collect stdout for puts().</td><td><i></i></td></tr>\n<tr><td>strict</td><td><i>BOOL</i></td><td>Globally enable strict: same as 'use strict' in main program.</td><td><i></i></td></tr>\n<tr><td>subOpts</td><td><i><a href='#subOptsOptions'>options</a></i></td><td>Infrequently used sub-options.</td><td><i></i></td></tr>\n<tr><td>subthread</td><td><i>BOOL</i></td><td>Create a threaded Interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n<tr><td>traceOp</td><td><i>INT</i></td><td>Set debugging level for OPCODE execution.</td><td><i></i></td></tr>\n<tr><td>tracePuts</td><td><i>BOOL</i></td><td>Trace puts by making it use logOpts.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>ARRAY</i></td><td>Type-check control options. (zero or more of: <b>parse</b>, <b>run</b>, <b>all</b>, <b>error</b>, <b>strict</b>, <b>noundef</b>, <b>nowith</b>, <b>funcsig</b>)</td><td><i></i></td></tr>\n<tr><td>typeWarnMax</td><td><i>INT</i></td><td>Type checking is silently disabled after this many warnings (50).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>unitTest</td><td><i>UINT</i></td><td>Unit test control bits: 1=subst, 2=Puts with file:line prefix.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"debugOptsOptions\"></a>\n<h2>Options for \"debugOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>debugCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp for handling debugging.</td><td><i></i></td></tr>\n<tr><td>doContinue</td><td><i>BOOL</i></td><td>Continue execution until breakpoint.</td><td><i></i></td></tr>\n<tr><td>forceBreak</td><td><i>BOOL</i></td><td>Force debugger to break.</td><td><i></i></td></tr>\n<tr><td>includeOnce</td><td><i>BOOL</i></td><td>Source the file only if not already sourced.</td><td><i></i></td></tr>\n<tr><td>includeTrace</td><td><i>BOOL</i></td><td>Trace includes.</td><td><i></i></td></tr>\n<tr><td>minLevel</td><td><i>INT</i></td><td>Disable eval callback for level higher than this.</td><td><i></i></td></tr>\n<tr><td>msgCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,...</td><td><i></i></td></tr>\n<tr><td>pkgTrace</td><td><i>BOOL</i></td><td>Trace package loads.</td><td><i></i></td></tr>\n<tr><td>putsCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle puts output.</td><td><i></i></td></tr>\n<tr><td>traceCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle traceCall.</td><td><i></i></td></tr>\n<tr><td>testFmtCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to format unittest string.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"logOptsOptions\"></a>\n<h2>Options for \"logOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages.</td><td><i></i></td></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages.</td><td><i></i></td></tr>\n<tr><td>Info</td><td><i>BOOL</i></td><td>Enable LogInfo messages.</td><td><i></i></td></tr>\n<tr><td>Warn</td><td><i>BOOL</i></td><td>Enable LogWarn messages.</td><td><i></i></td></tr>\n<tr><td>Error</td><td><i>BOOL</i></td><td>Enable LogError messages.</td><td><i></i></td></tr>\n<tr><td>time</td><td><i>BOOL</i></td><td>Prefix with time.</td><td><i></i></td></tr>\n<tr><td>date</td><td><i>BOOL</i></td><td>Prefix with date.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>BOOL</i></td><td>Ouptut contains file:line.</td><td><i></i></td></tr>\n<tr><td>func</td><td><i>BOOL</i></td><td>Output function.</td><td><i></i></td></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Show full file path.</td><td><i></i></td></tr>\n<tr><td>ftail</td><td><i>BOOL</i></td><td>Show tail of file only, even in LogWarn, etc.</td><td><i></i></td></tr>\n<tr><td>before</td><td><i>BOOL</i></td><td>Output file:line before message string.</td><td><i></i></td></tr>\n<tr><td>isUTC</td><td><i>BOOL</i></td><td>Time is to be UTC.</td><td><i></i></td></tr>\n<tr><td>timeFmt</td><td><i>STRKEY</i></td><td>A format string to use with strftime.</td><td><i></i></td></tr>\n<tr><td>chan</td><td><i>USEROBJ</i></td><td>Channel to send output to.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"subOptsOptions\"></a>\n<h2>Options for \"subOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>blacklist</td><td><i>STRKEY</i></td><td>Comma separated modules to disable loading for.</td><td><i>initOnly</i></td></tr>\n<tr><td>compat</td><td><i>BOOL</i></td><td>Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser.</td><td><i></i></td></tr>\n<tr><td>dblPrec</td><td><i>INT</i></td><td>Format precision of double where 0=max, -1=max-1, ... (max-1).</td><td><i></i></td></tr>\n<tr><td>istty</td><td><i>BOOL</i></td><td>Indicates interp is in interactive mode.</td><td><i>readOnly</i></td></tr>\n<tr><td>logColNums</td><td><i>BOOL</i></td><td>Display column numbers in error messages.</td><td><i></i></td></tr>\n<tr><td>logAllowDups</td><td><i>BOOL</i></td><td>Log should not filter out duplicate messages.</td><td><i></i></td></tr>\n<tr><td>mutexUnlock</td><td><i>BOOL</i></td><td>Unlock own mutex when evaling in other interps (true).</td><td><i>initOnly</i></td></tr>\n<tr><td>noproto</td><td><i>BOOL</i></td><td>Disable support of the OOP symbols:  __proto__, prototype, constructor, etc.</td><td><i></i></td></tr>\n<tr><td>noFuncString</td><td><i>BOOL</i></td><td>Disable viewing code body for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noRegex</td><td><i>BOOL</i></td><td>Disable viewing code for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noReadline</td><td><i>BOOL</i></td><td>In interactive mode disable use of readline.</td><td><i></i></td></tr>\n<tr><td>outUndef</td><td><i>BOOL</i></td><td>In interactive mode output result values that are undefined.</td><td><i></i></td></tr>\n<tr><td>prompt</td><td><i>STRKEY</i></td><td>Prompt for interactive mode ('$ ').</td><td><i></i></td></tr>\n<tr><td>prompt2</td><td><i>STRKEY</i></td><td>Prompt for interactive mode line continue ('> ').</td><td><i></i></td></tr>\n</table>\n<a name=\"Interpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"JSON\"></a>\n\n<hr>\n\n\n<h1>JSON</h1>\n\n<font color=red>Synopsis:JSON.method(...)\n\n</font><p>Commands for handling JSON data.\n\n\n<h2>Methods for \"JSON\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>check</td><td>check(str:string, strict:boolean=true):boolean </td><td>Return true if str is JSON.</td></tr>\n<tr><td>parse</td><td>parse(str:string, strict:boolean=true) </td><td>Parse JSON and return js.</td></tr>\n<tr><td>stringify</td><td>stringify(value:any,  strict:boolean=true):string </td><td>Return JSON from a js object.</td></tr>\n</table>\n<a name=\"JSONend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Math\"></a>\n\n<hr>\n\n\n<h1>Math</h1>\n\n<font color=red>Synopsis:Math.method(...)\n\n</font><p>Commands performing math operations on numbers.\n\n\n<h2>Methods for \"Math\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>abs</td><td>abs(num:number):number </td><td>Returns the absolute value of x.</td></tr>\n<tr><td>acos</td><td>acos(num:number):number </td><td>Returns the arccosine of x, in radians.</td></tr>\n<tr><td>asin</td><td>asin(num:number):number </td><td>Returns the arcsine of x, in radians.</td></tr>\n<tr><td>atan</td><td>atan(num:number):number </td><td>Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians.</td></tr>\n<tr><td>atan2</td><td>atan2(x:number, y:number):number </td><td>Returns the arctangent of the quotient of its arguments.</td></tr>\n<tr><td>ceil</td><td>ceil(num:number):number </td><td>Returns x, rounded upwards to the nearest integer.</td></tr>\n<tr><td>cos</td><td>cos(num:number):number </td><td>Returns the cosine of x (x is in radians).</td></tr>\n<tr><td>exp</td><td>exp(num:number):number </td><td>Returns the value of Ex.</td></tr>\n<tr><td>floor</td><td>floor(num:number):number </td><td>Returns x, rounded downwards to the nearest integer.</td></tr>\n<tr><td>log</td><td>log(num:number):number </td><td>Returns the natural logarithm (base E) of x.</td></tr>\n<tr><td>max</td><td>max(x:number, y:number, ...):number </td><td>Returns the number with the highest value.</td></tr>\n<tr><td>min</td><td>min(x:number, y:number, ...):number </td><td>Returns the number with the lowest value.</td></tr>\n<tr><td>pow</td><td>pow(x:number, y:number):number </td><td>Returns the value of x to the power of y.</td></tr>\n<tr><td>random</td><td>random():number </td><td>Returns a random number between 0 and 1.</td></tr>\n<tr><td>round</td><td>round(num:number):number </td><td>Rounds x to the nearest integer.</td></tr>\n<tr><td>sin</td><td>sin(num:number):number </td><td>Returns the sine of x (x is in radians).</td></tr>\n<tr><td>sqrt</td><td>sqrt(num:number):number </td><td>Returns the square root of x.</td></tr>\n<tr><td>srand</td><td>srand(seed:number):number </td><td>Set random seed.</td></tr>\n<tr><td>tan</td><td>tan(num:number):number </td><td>Returns the tangent of an angle.</td></tr>\n</table>\n<a name=\"Mathend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"MySql\"></a>\n\n<hr>\n\n\n<h1>MySql</h1>\n\n<font color=red>Synopsis:new MySql(options:object=void):userobj\n\n</font><p>Commands for accessing mysql databases.\n\n\n<h2>Methods for \"MySql\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>MySql</td><td>new MySql(<a href='#new MySqlOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to a MySql database:.</td></tr>\n<tr><td>affectedRows</td><td>affectedRows():number </td><td>Return affected rows.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#MySql.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>errorNo</td><td>errorNo():number </td><td>Return error code returned by most recent call to mysql3_exec().</td></tr>\n<tr><td>errorState</td><td>errorState():string </td><td>Return the mysql error state str.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output.</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info about last query.</td></tr>\n<tr><td>lastQuery</td><td>lastQuery():string </td><td>Return info string about most recently executed statement.</td></tr>\n<tr><td>lastRowid</td><td>lastRowid():number </td><td>Return rowid of last insert.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>ping</td><td>ping(noError:boolean=false):number </td><td>Ping connection.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#MySql.queryOptions'>options</a>:function|string|array|object=void) </td><td>Run sql query with input and/or outputs..</td></tr>\n<tr><td>reconnect</td><td>reconnect():void </td><td>Reconnect with current settings.</td></tr>\n<tr><td>reset</td><td>reset():number </td><td>Reset connection.</td></tr>\n</table>\n\n\n<a name=\"new MySqlOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"new MySql\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>database</td><td><i>STRKEY</i></td><td>Database to use.</td><td><i>initOnly</i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>enableMulti</td><td><i>BOOL</i></td><td>Accept muiltiple semi-colon separated statements in eval().</td><td><i>initOnly</i></td></tr>\n<tr><td>errorCnt</td><td><i>INT</i></td><td>Count of errors.</td><td><i>readOnly</i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>host</td><td><i>STRING</i></td><td>IP address or host name for mysqld (default is 127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>maxStmts</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>Name for this db handle.</td><td><i></i></td></tr>\n<tr><td>numStmts</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>password</td><td><i>STRKEY</i></td><td>Database password..</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>IP port for mysqld.</td><td><i>initOnly</i></td></tr>\n<tr><td>reconnect</td><td><i>BOOL</i></td><td>Reconnect.</td><td><i></i></td></tr>\n<tr><td>sslKey</td><td><i>STRING</i></td><td>SSL key.</td><td><i></i></td></tr>\n<tr><td>sslCert</td><td><i>STRING</i></td><td>SSL Cert.</td><td><i></i></td></tr>\n<tr><td>sslCA</td><td><i>STRING</i></td><td>SSL CA.</td><td><i></i></td></tr>\n<tr><td>sslCAPath</td><td><i>STRING</i></td><td>SSL CA path.</td><td><i></i></td></tr>\n<tr><td>sslCipher</td><td><i>STRING</i></td><td>SSL Cipher.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data..</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>STRKEY</i></td><td>Database user name. Default is current user-name..</td><td><i>initOnly</i></td></tr>\n<tr><td>version</td><td><i>DOUBLE</i></td><td>Mysql version number.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"MySql.queryOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"MySql.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"MySqlend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Number\"></a>\n\n<hr>\n\n\n<h1>Number</h1>\n\n<font color=red>Synopsis:new Number(num:string=0):number\n\n</font><p>Commands for accessing number objects.\n\n\n<h2>Methods for \"Number\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Number</td><td>new Number(num:string=0):number </td><td>Number constructor.</td></tr>\n<tr><td>isFinite</td><td>isFinite():boolean </td><td>Return true if is finite.</td></tr>\n<tr><td>isInteger</td><td>isInteger():boolean </td><td>Return true if is an integer.</td></tr>\n<tr><td>isNaN</td><td>isNaN():boolean </td><td>Return true if is NaN.</td></tr>\n<tr><td>isSafeInteger</td><td>isSafeInteger():boolean </td><td>Return true if is a safe integer.</td></tr>\n<tr><td>toExponential</td><td>toExponential(num:number):string </td><td>Converts a number into an exponential notation.</td></tr>\n<tr><td>toFixed</td><td>toFixed(num:number=0):string </td><td>Formats a number with x numbers of digits after the decimal point.</td></tr>\n<tr><td>toPrecision</td><td>toPrecision(num:number):string </td><td>Formats a number to x length.</td></tr>\n<tr><td>toString</td><td>toString(radix:number=10):string </td><td>Convert to string.</td></tr>\n</table>\n<a name=\"Numberend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Object\"></a>\n\n<hr>\n\n\n<h1>Object</h1>\n\n<font color=red>Synopsis:new Object(val:object&verbar;function|null=void):object\n\n</font><p>Commands for accessing Objects.\n\n\n<h2>Methods for \"Object\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Object</td><td>new Object(val:object|function|null=void):object </td><td>Object constructor.</td></tr>\n<tr><td>create</td><td>create(proto:null|object, properties:object=void):object </td><td>Create a new object with prototype object and properties.</td></tr>\n<tr><td>getPrototypeOf</td><td>getPrototypeOf(name:object|function):function|object </td><td>Return prototype of an object.</td></tr>\n<tr><td>hasOwnProperty</td><td>hasOwnProperty(name:string):boolean </td><td>Returns a true if object has the specified property.</td></tr>\n<tr><td>is</td><td>is(value1, value2):boolean </td><td>Tests if two values are equal.</td></tr>\n<tr><td>isPrototypeOf</td><td>isPrototypeOf(name):boolean </td><td>Tests for an object in another object's prototype chain.</td></tr>\n<tr><td>keys</td><td>keys(obj:object|function=void):array </td><td>Return the keys of an object or array.</td></tr>\n<tr><td>merge</td><td>merge(obj:object|function):object </td><td>Return new object containing merged values.</td></tr>\n<tr><td>propertyIsEnumerable</td><td>propertyIsEnumerable(name):boolean </td><td>Determine if a property is enumerable.</td></tr>\n<tr><td>setPrototypeOf</td><td>setPrototypeOf(name:object, value:object) </td><td>Set prototype of an object.</td></tr>\n<tr><td>toLocaleString</td><td>toLocaleString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>toString</td><td>toString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>valueOf</td><td>valueOf() </td><td>Returns primitive value.</td></tr>\n</table>\n<a name=\"Objectend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"RegExp\"></a>\n\n<hr>\n\n\n<h1>RegExp</h1>\n\n<font color=red>Synopsis:new RegExp(val:regexp&verbar;string, flags:string):regexp\n\n</font><p>Commands for managing reqular expression objects.\n\n\n<h2>Methods for \"RegExp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>RegExp</td><td>new RegExp(val:regexp|string, flags:string):regexp </td><td>Create a regexp object.</td></tr>\n<tr><td>exec</td><td>exec(val:string):array|object|null </td><td>return matching string. Perform regexp match checking.  Returns the array of matches.With the global flag g, sets lastIndex and returns next match.</td></tr>\n<tr><td>test</td><td>test(val:string):boolean </td><td>test if a string matches.</td></tr>\n</table>\n<a name=\"RegExpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Signal\"></a>\n\n<hr>\n\n\n<h1>Signal</h1>\n\n<font color=red>Synopsis:Signal.method(...)\n\n</font><p>Commands for handling unix signals.\n\n\n<h2>Methods for \"Signal\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>alarm</td><td>alarm(secs):number </td><td>Setup alarm in seconds.</td></tr>\n<tr><td>callback</td><td>callback(func:function, sig:number|string):number </td><td>Setup callback handler for signal.</td></tr>\n<tr><td>handle</td><td>handle(sig:number|string=void, ...) </td><td>Set named signals to handle action.</td></tr>\n<tr><td>ignore</td><td>ignore(sig:number|string=void, ...) </td><td>Set named signals to ignore action.</td></tr>\n<tr><td>kill</td><td>kill(pid:number, sig:number|string='SIGTERM'):void </td><td>Send signal to process id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return names of all signals.</td></tr>\n<tr><td>reset</td><td>reset(sig:number|string=void, ...):array </td><td>Set named signals to default action.</td></tr>\n</table>\n<a name=\"Signalend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Socket\"></a>\n\n<hr>\n\n\n<h1>Socket</h1>\n\n<font color=red>Synopsis:new Socket(options:object=void):userobj\n\n</font><p>Commands for managing Socket server/client connections.\n\n\n<h2>Methods for \"Socket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Socket</td><td>new Socket(<a href='#new SocketOptions'>options</a>:object=void):userobj </td><td>Create socket server/client object.Create a socket server or client object.</td></tr>\n<tr><td>close</td><td>close():void </td><td>Close socket(s).</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Socket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number=void, <a href='#Socket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for a connection id, or return list of ids.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list of active ids on server.</td></tr>\n<tr><td>recv</td><td>recv(id:number=void):string </td><td>Recieve data.</td></tr>\n<tr><td>send</td><td>send(id:number, data:string, <a href='#Socket.sendOptions'>options</a>:object=void):void </td><td>Send a socket message to id. Send a message to a (or all if -1) connection.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this socket.</td></tr>\n</table>\n\n\n<a name=\"new SocketOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"new Socket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>Client destination address (127.0.0.0).</td><td><i>initOnly</i></td></tr>\n<tr><td>broadcast</td><td><i>BOOL</i></td><td>Enable broadcast.</td><td><i>initOnly</i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Enable client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Counter for number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createLast</td><td><i>TIME_T</i></td><td>Time of last create.</td><td><i>readOnly</i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Debugging level.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>keepalive</td><td><i>BOOL</i></td><td>Enable keepalive.</td><td><i>initOnly</i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>mcastAddMember</td><td><i>STRING</i></td><td>Multicast add membership: address/interface ('127.0.0.1/0.0.0.0').</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastInterface</td><td><i>STRING</i></td><td>Multicast interface address.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastNoLoop</td><td><i>BOOL</i></td><td>Multicast loopback disable.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastTtl</td><td><i>INT</i></td><td>Multicast TTL.</td><td><i>initOnly</i></td></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i>initOnly</i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Stop processing update events (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when connection closes. @function(s:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last connection closes. On object delete arg is null. @function(s:userobj|null)</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Socket.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when connection opens. @function(s:userobj, info:object)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call with recieved data. @function(s:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for client dest or server listen.</td><td><i>initOnly</i></td></tr>\n<tr><td>quiet</td><td><i>BOOL</i></td><td>Suppress info messages.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvTimeout</td><td><i>UINT64</i></td><td>Timeout for receive, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>sendTimeout</td><td><i>UINT64</i></td><td>Timeout for send, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcAddress</td><td><i>STRING</i></td><td>Client source address.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcPort</td><td><i>INT</i></td><td>Client source port.</td><td><i>initOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of start.</td><td><i>readOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>timeout</td><td><i>NUMBER</i></td><td>Timeout value in seconds (0.5).</td><td><i>initOnly</i></td></tr>\n<tr><td>tos</td><td><i>INT8</i></td><td>Type-Of-Service value.</td><td><i>initOnly</i></td></tr>\n<tr><td>ttl</td><td><i>INT</i></td><td>Time-To-Live value.</td><td><i>initOnly</i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>udp</td><td><i>BOOL</i></td><td>Protocol is udp.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.idconfOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.sendOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.send\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i></i></td></tr>\n</table>\n<a name=\"Socketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Sqlite\"></a>\n\n<hr>\n\n\n<h1>Sqlite</h1>\n\n<font color=red>Synopsis:new Sqlite(file:null&verbar;string=void, options:object=void):userobj\n\n</font><p>Commands for accessing sqlite databases.\n\n\n<h2>Methods for \"Sqlite\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Sqlite</td><td>new Sqlite(file:null|string=void, <a href='#new SqliteOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to the named file or :memory:.</td></tr>\n<tr><td>backup</td><td>backup(file:string, dbname:string='main'):void </td><td>Backup db to file. Open or create a database file named FILENAME.\nTransfer the content of local database DATABASE (default: 'main') into the FILENAME database.</td></tr>\n<tr><td>collate</td><td>collate(name:string, callback:function):void </td><td>Create new SQL collation command.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Sqlite.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output. Supports multiple semicolon seperated commands.\nVariable binding is NOT performed, results are discarded, and  returns sqlite3_changes()</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>filename</td><td>filename(name:string='main'):string </td><td>Return filename for named or all attached databases.</td></tr>\n<tr><td>func</td><td>func(name:string, callback:function, numArgs:number=void):void </td><td>Register a new function with database.</td></tr>\n<tr><td>import</td><td>import(table:string, file:string, <a href='#Sqlite.importOptions'>options</a>:object=void):number </td><td>Import data from file into table . Import data from a file into table. SqlOptions include the 'separator' to use, which defaults to commas for csv, or tabs otherwise.\nIf a column contains a null string, or the value of 'nullvalue', a null is inserted for the column.\nA 'conflict' is one of the sqlite conflict algorithms:    rollback, abort, fail, ignore, replace\nOn success, return the number of lines processed, not necessarily same as 'changeCnt' due to the conflict algorithm selected. </td></tr>\n<tr><td>interrupt</td><td>interrupt():void </td><td>Interrupt in progress statement.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#Sqlite.queryOptions'>options</a>:function|string|array|object=void) </td><td>Evaluate an sql query with bindings. Return values in formatted as JSON, HTML, etc. , optionally calling function with a result object</td></tr>\n<tr><td>restore</td><td>restore(file:string, dbname:string):void </td><td>Restore db from file (default db is 'main').    db.restore(FILENAME, ?,DATABASE? ) \nOpen a database file named FILENAME.  Transfer the content of FILENAME into the local database DATABASE (default: 'main').</td></tr>\n<tr><td>transaction</td><td>transaction(callback:function, type:string=void):void </td><td>Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'. Start a new transaction (if we are not already in the midst of a transaction) and execute the JS function FUNC.\nAfter FUNC completes, either commit the transaction or roll it back if FUNC throws an exception.\nOr if no new transation was started, do nothing. pass the exception on up the stack.</td></tr>\n</table>\n\n\n<a name=\"new SqliteOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"new Sqlite\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>changeCnt</td><td><i>INT</i></td><td>The number of rows modified, inserted, or deleted by last command.</td><td><i></i></td></tr>\n<tr><td>changeCntAll</td><td><i>INT</i></td><td>Total number of rows modified, inserted, or deleted since db opened.</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query/eval string to log.</td><td><i></i></td></tr>\n<tr><td>errCnt</td><td><i>INT</i></td><td>Count of errors in script callbacks.</td><td><i>readOnly</i></td></tr>\n<tr><td>errorCode</td><td><i>INT</i></td><td>Numeric error code returned by the most recent call to sqlite3_exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>noJsonConv</td><td><i>BOOL</i></td><td>Do not JSON auto-convert array and object in CHARJSON columns.</td><td><i></i></td></tr>\n<tr><td>lastInsertId</td><td><i>UINT64</i></td><td>The rowid of last insert.</td><td><i></i></td></tr>\n<tr><td>load</td><td><i>BOOL</i></td><td>Extensions can be loaded.</td><td><i></i></td></tr>\n<tr><td>mutex</td><td><i>STRKEY</i></td><td>Mutex type to use. (one of: <b>default</b>, <b>none</b>, <b>full</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>The dbname to use instead of 'main'.</td><td><i>initOnly</i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Sqlite.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCreate</td><td><i>BOOL</i></td><td>Database is must already exist (false).</td><td><i>initOnly</i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for auth. @function(db:userobj, code:string, descr1:string, decr2:string, dbname:string, trigname:string)</td><td><i></i></td></tr>\n<tr><td>onBusy</td><td><i>FUNC</i></td><td>Function to call when busy. @function(db:userobj, tries:number)</td><td><i></i></td></tr>\n<tr><td>onCommit</td><td><i>FUNC</i></td><td>Function to call on commit. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onNeedCollate</td><td><i>FUNC</i></td><td>Function to call for collation. @function(db:userobj, name:string)</td><td><i></i></td></tr>\n<tr><td>onProfile</td><td><i>FUNC</i></td><td>Function to call for profile. @function(db:userobj, sql:string, time:number)</td><td><i></i></td></tr>\n<tr><td>onProgress</td><td><i>FUNC</i></td><td>Function to call for progress: progressSteps must be >0. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onRollback</td><td><i>FUNC</i></td><td>Function to call for rollback. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onTrace</td><td><i>FUNC</i></td><td>Function to call for trace. @function(db:userobj, sql:string)</td><td><i></i></td></tr>\n<tr><td>onUpdate</td><td><i>FUNC</i></td><td>Function to call for update. @function(db:userobj, op:string, dbname:string, table:string, rowid:number)</td><td><i></i></td></tr>\n<tr><td>onWalHook</td><td><i>FUNC</i></td><td>Function to call for WAL. @function(db:userobj, dbname:string, entry:number)</td><td><i></i></td></tr>\n<tr><td>progressSteps</td><td><i>UINT</i></td><td>Number of steps between calling onProgress: 0 is disabled.</td><td><i></i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for to use with query().</td><td><i></i></td></tr>\n<tr><td>readonly</td><td><i>BOOL</i></td><td>Database opened in readonly mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>sortCnt</td><td><i>INT</i></td><td>Number of sorts in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stepCnt</td><td><i>INT</i></td><td>Number of steps in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheCnt</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheMax</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>Sqlite version info.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>vfs</td><td><i>STRING</i></td><td>VFS to use.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.importOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.import\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row contains column labels.</td><td><i></i></td></tr>\n<tr><td>csv</td><td><i>BOOL</i></td><td>Treat input values as CSV.</td><td><i></i></td></tr>\n<tr><td>conflict</td><td><i>STRKEY</i></td><td>Set conflict resolution. (one of: <b>ROLLBACK</b>, <b>ABORT</b>, <b>FAIL</b>, <b>IGNORE</b>, <b>REPLACE</b>)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of lines to load.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string; default is comma if csv, else tabs.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.queryOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"Sqliteend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"String\"></a>\n\n<hr>\n\n\n<h1>String</h1>\n\n<font color=red>Synopsis:new String(str):string\n\n</font><p>Commands for accessing string objects..\n\n\n<h2>Methods for \"String\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>String</td><td>new String(str):string </td><td>String constructor.</td></tr>\n<tr><td>charAt</td><td>charAt(index:number):string </td><td>Return char at index.</td></tr>\n<tr><td>charCodeAt</td><td>charCodeAt(index:number):number </td><td>Return char code at index.</td></tr>\n<tr><td>concat</td><td>concat(str:string, ...):string </td><td>Append one or more strings.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(...):string </td><td>Return string for char codes.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:string, start:number):number </td><td>Return index of char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(str:string, start:number):number </td><td>Return index of last char.</td></tr>\n<tr><td>map</td><td>map(strMap:array, nocase:boolean=false):string </td><td>Replaces characters in string based on the key-value pairs in strMap.</td></tr>\n<tr><td>match</td><td>match(pattern:regexp|string):array|null </td><td>Return array of matches.</td></tr>\n<tr><td>repeat</td><td>repeat(count:number):string </td><td>Return count copies of string.</td></tr>\n<tr><td>replace</td><td>replace(pattern:regexp|string, replace:string|function):string </td><td>Regex/string replacement. If the replace argument is a function, it is called with match,p1,p2,...,offset,string.  If called function is known to have 1 argument, it is called with just the match.</td></tr>\n<tr><td>search</td><td>search(pattern:regexp|string):number </td><td>Return index of first char matching pattern.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number):string </td><td>Return section of string.</td></tr>\n<tr><td>split</td><td>split(char:string|null=void):array </td><td>Split on char and return Array. When char is omitted splits on bytes.  When char==null splits on whitespace and removes empty elements.</td></tr>\n<tr><td>substr</td><td>substr(start:number, length:number):string </td><td>Return substring.</td></tr>\n<tr><td>substring</td><td>substring(start:number, end:number):string </td><td>Return substring.</td></tr>\n<tr><td>toLocaleLowerCase</td><td>toLocaleLowerCase():string </td><td>Lower case.</td></tr>\n<tr><td>toLocaleUpperCase</td><td>toLocaleUpperCase():string </td><td>Upper case.</td></tr>\n<tr><td>toLowerCase</td><td>toLowerCase():string </td><td>Return lower cased string.</td></tr>\n<tr><td>toTitle</td><td>toTitle(chars:string):string </td><td>Make first char upper case.</td></tr>\n<tr><td>toUpperCase</td><td>toUpperCase():string </td><td>Return upper cased string.</td></tr>\n<tr><td>trim</td><td>trim(chars:string):string </td><td>Trim chars.</td></tr>\n<tr><td>trimLeft</td><td>trimLeft(chars:string):string </td><td>Trim chars from left.</td></tr>\n<tr><td>trimRight</td><td>trimRight(chars:string):string </td><td>Trim chars from right.</td></tr>\n</table>\n<a name=\"Stringend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"System\"></a>\n\n<hr>\n\n\n<h1>System</h1>\n\n<font color=red>Synopsis:System.method(...)\n\n</font><p>Builtin system commands. All methods are exported as global.\n\n\n<h2>Methods for \"System\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#System.assertOptions'>options</a>:object=void):void </td><td>Throw or output msg if expr is false. Assert does nothing by default, but can be enabled with \"use assert\" or setting Interp.asserts.</td></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete event id returned from setInterval/setTimeout/info.events().</td></tr>\n<tr><td>decodeURI</td><td>decodeURI(val:string):string </td><td>Decode an HTTP URL.</td></tr>\n<tr><td>encodeURI</td><td>encodeURI(val:string):string </td><td>Encode an HTTP URL.</td></tr>\n<tr><td>exec</td><td>exec(val:string, <a href='#System.execOptions'>options</a>:string|object=void) </td><td>Execute an OS command. If the command ends with '&', set the 'bg' option to true.\nThe second argument can be a string, which is the same as setting the 'inputStr' option.\nBy default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used</td></tr>\n<tr><td>exit</td><td>exit(code:number=0):void </td><td>Exit the current interpreter.</td></tr>\n<tr><td>format</td><td>format(format:string, ...):string </td><td>Printf style formatting: adds %q and %S.</td></tr>\n<tr><td>isFinite</td><td>isFinite(val):boolean </td><td>Return true if is a finite number.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>isNaN</td><td>isNaN(val):boolean </td><td>Return true if not a number.</td></tr>\n<tr><td>load</td><td>load(shlib:string):void </td><td>Load a shared executable and invoke its _Init call.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as puts, but includes file:line.</td></tr>\n<tr><td>matchObj</td><td>matchObj(obj:object, match:string=void, partial=false, noerror=false):string|boolean </td><td>Object field names/types matching. Single arg generates string.</td></tr>\n<tr><td>noOp</td><td>noOp() </td><td>A No-Op. A zero overhead command call that is useful for debugging.</td></tr>\n<tr><td>parseFloat</td><td>parseFloat(val):number </td><td>Convert string to a double.</td></tr>\n<tr><td>parseInt</td><td>parseInt(val:any, base:number=10):number </td><td>Convert string to an integer.</td></tr>\n<tr><td>parseOpts</td><td>parseOpts(self:object|userobj, options:object, conf:object|null|undefined) </td><td>Parse options.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Formatted output to stdout.</td></tr>\n<tr><td>provide</td><td>provide(name:string|function=void, version:number|string=1.0, opts:object|function=void):void </td><td>Provide a package for use with require. Default is the file tail-rootname.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Output one or more values to stdout. Each argument is quoted.  Use Interp.logOpts to control source line and/or timestamps output.</td></tr>\n<tr><td>quote</td><td>quote(val:string):string </td><td>Return quoted string.</td></tr>\n<tr><td>require</td><td>require(name:string=void, version:number|string=1, <a href='#System.requireOptions'>options</a>:object=void):number|array|object </td><td>Load/query packages. With no arguments, returns the list of all loaded packages.\nWith one argument, loads the package (if necessary) and returns its version.\nWith two arguments, returns object containing: version, loadFile, func.\nA third argument sets options for package or module.\nNote an error is thrown if requested version is greater than actual version.</td></tr>\n<tr><td>runMain</td><td>runMain(cmd:string|null|function=void, conf:array=undefined) </td><td>If isMain invokes runModule.</td></tr>\n<tr><td>runModule</td><td>runModule(cmd:string|null|function=void, conf:array=undefined) </td><td>Invoke named module. If name is empty, uses file basename. If isMain and no args givine parses console.args.</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, ms:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, ms:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>sleep</td><td>sleep(secs:number=1.0):void </td><td>sleep for N milliseconds, minimum .001.</td></tr>\n<tr><td>source</td><td>source(val:string|array, <a href='#System.sourceOptions'>options</a>:object=void) </td><td>Load and evaluate source files: trailing '/' appends PARENTDIR.jsi.</td></tr>\n<tr><td>strftime</td><td>strftime(num:number=null, <a href='#System.strftimeOptions'>options</a>:string|object=void):string </td><td>Format numeric time (in ms) to a string. Null or no value will use current time.</td></tr>\n<tr><td>strptime</td><td>strptime(val:string=void, <a href='#System.strptimeOptions'>options</a>:string|object=void):number </td><td>Parse time from string and return ms time since 1970-01-01 in UTC, or NaN.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>unload</td><td>unload(shlib:string):void </td><td>Unload a shared executable and invoke its _Done call.</td></tr>\n<tr><td>update</td><td>update(<a href='#System.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"System.assertOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.execOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bg</td><td><i>BOOL</i></td><td>Run command in background using system() and return OS code.</td><td><i></i></td></tr>\n<tr><td>chdir</td><td><i>STRING</i></td><td>Change to directory.</td><td><i></i></td></tr>\n<tr><td>inputStr</td><td><i>STRING</i></td><td>Use string as input and return OS code.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Suppress all OS errors.</td><td><i></i></td></tr>\n<tr><td>noRedir</td><td><i>BOOL</i></td><td>Disable redirect and shell escapes in command.</td><td><i></i></td></tr>\n<tr><td>noShell</td><td><i>BOOL</i></td><td>Do not use native popen which invokes via /bin/sh.</td><td><i></i></td></tr>\n<tr><td>trim</td><td><i>BOOL</i></td><td>Trim trailing whitespace from output.</td><td><i></i></td></tr>\n<tr><td>retAll</td><td><i>BOOL</i></td><td>Return the OS return code and data as an object.</td><td><i></i></td></tr>\n<tr><td>retCode</td><td><i>BOOL</i></td><td>Return only the OS return code.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.requireOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.require\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages for module.</td><td><i></i></td></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages for module.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages for module.</td><td><i></i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.sourceOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.source\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>autoIndex</td><td><i>BOOL</i></td><td>Look for and load Jsi_Auto.jsi auto-index file.</td><td><i></i></td></tr>\n<tr><td>exists</td><td><i>BOOL</i></td><td>Source file only if exists.</td><td><i></i></td></tr>\n<tr><td>global</td><td><i>BOOL</i></td><td>File is to be sourced in global frame rather than local.</td><td><i></i></td></tr>\n<tr><td>isMain</td><td><i>BOOL</i></td><td>Coerce to true the value of Info.isMain().</td><td><i></i></td></tr>\n<tr><td>level</td><td><i>UINT</i></td><td>Frame to source file in.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Ignore errors in sourced file.</td><td><i></i></td></tr>\n<tr><td>once</td><td><i>BOOL</i></td><td>Source file only if not already sourced (Default: Interp.debugOpts.includeOnce).</td><td><i></i></td></tr>\n<tr><td>trace</td><td><i>BOOL</i></td><td>Trace include statements (Default: Interp.debugOpts.includeTrace).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strftimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strftime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strptimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strptime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.updateOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Systemend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Util\"></a>\n\n<hr>\n\n\n<h1>Util</h1>\n\n<font color=red>Synopsis:Util.method(...)\n\n</font><p>Utilities commands.\n\n\n<h2>Methods for \"Util\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argArray</td><td>argArray(arg:any|undefined):array|null </td><td>Coerces non-null to an array, if necessary.</td></tr>\n<tr><td>base64</td><td>base64(val:string, decode:boolean=false):string </td><td>Base64 encode/decode a string.</td></tr>\n<tr><td>complete</td><td>complete(val:string):boolean </td><td>Return true if string is complete command with balanced braces, etc.</td></tr>\n<tr><td>crc32</td><td>crc32(val:string, crcSeed=0):number </td><td>Calculate 32-bit CRC.</td></tr>\n<tr><td>decrypt</td><td>decrypt(val:string, key:string):string </td><td>Decrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>encrypt</td><td>encrypt(val:string, key:string):string </td><td>Encrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(code:number):string </td><td>Return char with given character code.</td></tr>\n<tr><td>getenv</td><td>getenv(name:string=void):string|object|void </td><td>Get one or all environment.</td></tr>\n<tr><td>getpid</td><td>getpid(parent:boolean=false):number </td><td>Get process/parent id.</td></tr>\n<tr><td>getuser</td><td>getuser():object </td><td>Get userid info.</td></tr>\n<tr><td>hash</td><td>hash(val:string, <a href='#Util.hashOptions'>options</a>|object=void):string </td><td>Return hash (default SHA256) of string/file.</td></tr>\n<tr><td>hexStr</td><td>hexStr(val:string, decode:boolean=false):string </td><td>Hex encode/decode a string.</td></tr>\n<tr><td>setenv</td><td>setenv(name:string, value:string=void) </td><td>Set/get an environment var.</td></tr>\n<tr><td>sqlValues</td><td>sqlValues(name:string, var:object=void) </td><td>Get object values for SQL.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>verConvert</td><td>verConvert(ver:string|number, zeroTrim:number=0):number|string|null </td><td>Convert a version to/from a string/number, or return null if not a version. For string output zeroTrim says how many trailing .0 to trim (0-2).</td></tr>\n</table>\n\n\n<a name=\"Util.hashOptions\"></a>\n<a name=\"Util.confOptions\"></a>\n<h2>Options for \"Util.hash\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Read data from file and append to str.</td><td><i></i></td></tr>\n<tr><td>hashcash</td><td><i>UINT</i></td><td>Search for a hash with this many leading zero bits by appending :nonce (Proof-Of-Work).</td><td><i></i></td></tr>\n<tr><td>noHex</td><td><i>BOOL</i></td><td>Return binary digest, without conversion to hex chars.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type of hash. (one of: <b>sha256</b>, <b>sha1</b>, <b>md5</b>, <b>sha3_224</b>, <b>sha3_384</b>, <b>sha3_512</b>, <b>sha3_256</b>)</td><td><i></i></td></tr>\n</table>\n<a name=\"Utilend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Vfs\"></a>\n\n<hr>\n\n\n<h1>Vfs</h1>\n\n<font color=red>Synopsis:Vfs.method(...)\n\n</font><p>Commands for creating in memory readonly Virtual file-systems.\n\n\n<h2>Methods for \"Vfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(mount:string, string|<a href='#Vfs.confOptions'>options</a>:object|string=void) </td><td>Configure mount.</td></tr>\n<tr><td>exec</td><td>exec(cmd:string) </td><td>Safe mode exec for VFS support cmds eg. fossil info/ls/cat.</td></tr>\n<tr><td>fileconf</td><td>fileconf(mount:string, path:string, <a href='#Vfs.fileconfOptions'>options</a>:string|object=void) </td><td>Configure file info which is same info as in fileList.</td></tr>\n<tr><td>list</td><td>list():array </td><td>Return list of all vfs mounts.</td></tr>\n<tr><td>mount</td><td>mount(type:string, file:string, param:object=void):string </td><td>Mount fossil file as given VFS type name, returning the mount point: frontend for vmount.</td></tr>\n<tr><td>type</td><td>type(type:string=void, <a href='#Vfs.typeOptions'>options</a>:object|null=void) </td><td>Set/get/delete VFS type name.</td></tr>\n<tr><td>unmount</td><td>unmount(mount:string):void </td><td>Unmount a VFS.</td></tr>\n<tr><td>vmount</td><td>vmount(<a href='#Vfs.vmountOptions'>options</a>:object=void):string </td><td>Create and mount a VFS, returning the mount point.</td></tr>\n</table>\n\n\n<a name=\"Vfs.confOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.execOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.fileconfOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.fileconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.typeOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.type\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i>required</i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.vmountOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.vmount\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n<a name=\"Vfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"WebSocket\"></a>\n\n<hr>\n\n\n<h1>WebSocket</h1>\n\n<font color=red>Synopsis:new WebSocket(options:object=void):userobj\n\n</font><p>Commands for managing WebSocket server/client connections.\n\n\n<h2>Methods for \"WebSocket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>WebSocket</td><td>new WebSocket(<a href='#new WebSocketOptions'>options</a>:object=void):userobj </td><td>Create websocket server/client object.Create a websocket server/client object.  The server serves out pages to a web browser,\nwhich can use javascript to upgrade connection to a bidirectional websocket.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#WebSocket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>file</td><td>file(name:string=void):array|void </td><td>Add file to hash, or with no args return file hash.</td></tr>\n<tr><td>handler</td><td>handler(extension:string=void, cmd:string|function=void, flags:number=0):string|array|function|void </td><td>Get/Set handler command for an extension. With no args, returns list of handlers.  With one arg, returns value for that handler.\nOtherwise, sets the handler. When cmd is a string, the call is via runModule([cmd], arg).\nIf a cmd is a function, it is called with a single arg: the file name.</td></tr>\n<tr><td>header</td><td>header(id:number, name:string=void):string|array|void </td><td>Get one or all input headers for connect id.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number, <a href='#WebSocket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for connect id.</td></tr>\n<tr><td>ids</td><td>ids(name:string=void):array </td><td>Return list of ids, or lookup one id.</td></tr>\n<tr><td>query</td><td>query(id:number, name:string=void):string|object|void </td><td>Get one or all query values for connect id.</td></tr>\n<tr><td>send</td><td>send(id:number, data:any):void </td><td>Send a websocket message to id. Send a message to one (or all connections if -1). If not already a string, msg is formatted as JSON prior to the send.</td></tr>\n<tr><td>status</td><td>status():object|void </td><td>Return libwebsocket server status.</td></tr>\n<tr><td>unalias</td><td>unalias(path:string):string|void </td><td>Return alias reverse lookup.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this websocket.</td></tr>\n<tr><td>version</td><td>version():string </td><td>Runtime library version string.</td></tr>\n</table>\n\n\n<a name=\"new WebSocketOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"new WebSocket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>In client-mode the address to connect to (127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>bufferPwr2</td><td><i>INT</i></td><td>Tune the recv/send buffer: value is a power of 2 in [0-20] (16).</td><td><i></i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Run in client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>clientHost</td><td><i>STRKEY</i></td><td>Override host name for client.</td><td><i></i></td></tr>\n<tr><td>clientOrigin</td><td><i>STRKEY</i></td><td>Override client origin (origin).</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Set debug level. Setting this to 512 will turn on max libwebsocket log levels.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>formParams</td><td><i>STRKEY</i></td><td>Comma seperated list of upload form param names ('text,send,file,upload').</td><td><i>readOnly</i></td></tr>\n<tr><td>extHandlers</td><td><i>BOOL</i></td><td>Setup builtin extension-handlers, ie: .htmli, .cssi, .jsi, .mdi.</td><td><i>initOnly</i></td></tr>\n<tr><td>extOpts</td><td><i>OBJ</i></td><td>Key/value store for extension-handlers options.</td><td><i>initOnly</i></td></tr>\n<tr><td>getRegexp</td><td><i>REGEXP</i></td><td>Call onGet() only if Url matches pattern.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser: name/value pairs.</td><td><i>initOnly</i></td></tr>\n<tr><td>jsiFnPattern</td><td><i>STRKEY</i></td><td>A glob-match pattern for files to which is appended 'window.jsiWebSocket=true;' (jsig*.js).</td><td><i>readOnly</i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>local</td><td><i>BOOL</i></td><td>Limit connections to localhost addresses on the 127 network.</td><td><i></i></td></tr>\n<tr><td>localhostName</td><td><i>STRKEY</i></td><td>Client name used by localhost connections ('localhost').</td><td><i></i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>maxDownload</td><td><i>INT</i></td><td>Max size of file download.</td><td><i></i></td></tr>\n<tr><td>maxUpload</td><td><i>INT</i></td><td>Max size of file upload will accept.</td><td><i></i></td></tr>\n<tr><td>mimeTypes</td><td><i>OBJ</i></td><td>Object providing map of file extensions to mime types. eg. {txt:'text/plain', bb:'text/bb'}.</td><td><i>initOnly</i></td></tr>\n<tr><td>modifySecs</td><td><i>UINT</i></td><td>Seconds between checking for modified files with onModify (2).</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of conf() to change options after options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCompress</td><td><i>BOOL</i></td><td>Disable per-message-deflate extension which can truncate large msgs.</td><td><i></i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Disable update event-processing (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>noWebsock</td><td><i>BOOL</i></td><td>Serve html, but disallow websocket upgrade.</td><td><i>initOnly</i></td></tr>\n<tr><td>noWarn</td><td><i>BOOL</i></td><td>Quietly ignore file related errors.</td><td><i></i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for http basic authentication. @function(ws:userobj, id:number, url:string, userpass:string)</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last websock connection closes. On object delete arg is null. @function(ws:userobj|null)</td><td><i></i></td></tr>\n<tr><td>onFilter</td><td><i>FUNC</i></td><td>Function to call on a new connection: return false to kill connection. @function(ws:userobj, id:number, url:string, ishttp:boolean)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onModify</td><td><i>FUNC</i></td><td>Function to call when a served-out-file is modified. @function(ws:userobj, file:string)</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when the websocket connection occurs. @function(ws:userobj, id:number)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>pathAliases</td><td><i>OBJ</i></td><td>Path alias lookups.</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for server to listen on (8080).</td><td><i>initOnly</i></td></tr>\n<tr><td>post</td><td><i>STRING</i></td><td>Post string to serve.</td><td><i>initOnly</i></td></tr>\n<tr><td>protocol</td><td><i>STRKEY</i></td><td>Name of protocol (ws/wss).</td><td><i></i></td></tr>\n<tr><td>realm</td><td><i>STRKEY</i></td><td>Realm for basic auth (jsish).</td><td><i></i></td></tr>\n<tr><td>recvBufMax</td><td><i>INT</i></td><td>Size limit of a websocket message.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvBufTimeout</td><td><i>INT</i></td><td>Timeout for recv of a websock msg.</td><td><i>initOnly</i></td></tr>\n<tr><td>redirMax</td><td><i>BOOL</i></td><td>Temporarily disable redirects when see more than this in 10 minutes.</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>server</td><td><i>STRKEY</i></td><td>String to send out int the header SERVER (jsiWebSocket).</td><td><i></i></td></tr>\n<tr><td>ssiExts</td><td><i>OBJ</i></td><td>Object map of file extensions to apply SSI.  eg. {myext:true, shtml:false} .</td><td><i>initOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of websocket start.</td><td><i>readOnly</i></td></tr>\n<tr><td>includeFile</td><td><i>STRKEY</i></td><td>Default file when no extension given (include.shtml).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>urlPrefix</td><td><i>STRKEY</i></td><td>Prefix in url to strip from path; for reverse proxy.</td><td><i></i></td></tr>\n<tr><td>urlRedirect</td><td><i>STRKEY</i></td><td>Redirect when no url or / is given. Must match urlPrefix, if given.</td><td><i></i></td></tr>\n<tr><td>use_ssl</td><td><i>BOOL</i></td><td>Use https (for client).</td><td><i>initOnly</i></td></tr>\n<tr><td>useridPass</td><td><i>STRKEY</i></td><td>The USERID:PASSWORD to use for basic authentication.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>WebSocket version info.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"WebSocket.idconfOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"WebSocket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>clientIP</td><td><i>STRKEY</i></td><td>Client IP Address.</td><td><i>readOnly</i></td></tr>\n<tr><td>clientName</td><td><i>STRKEY</i></td><td>Client hostname.</td><td><i>readOnly</i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser on connection: name/value pairs.</td><td><i></i></td></tr>\n<tr><td>isWebsock</td><td><i>BOOL</i></td><td>Is a websocket connection.</td><td><i></i></td></tr>\n<tr><td>key</td><td><i>STRBUF</i></td><td>String key lookup in ids command for SSI echo ${#}.</td><td><i>readOnly</i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, args:array)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistics for connection.</td><td><i>readOnly</i></td></tr>\n<tr><td>query</td><td><i>ARRAY</i></td><td>Uri arg values for connection.</td><td><i></i></td></tr>\n<tr><td>queryObj</td><td><i>OBJ</i></td><td>Uri arg values for connection as an object.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>url</td><td><i>DSTRING</i></td><td>Url for connection.</td><td><i></i></td></tr>\n<tr><td>username</td><td><i>STRING</i></td><td>The login userid for this connection.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createTime</td><td><i>TIME_T</i></td><td>Time created.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>httpCnt</td><td><i>INT</i></td><td>Number of http reqs.</td><td><i></i></td></tr>\n<tr><td>httpLast</td><td><i>TIME_T</i></td><td>Time of last http reqs.</td><td><i></i></td></tr>\n<tr><td>isBinary</td><td><i>BOOL</i></td><td>Connection recv data is binary.</td><td><i>readOnly</i></td></tr>\n<tr><td>isFinal</td><td><i>BOOL</i></td><td>Final data for current message was recieved.</td><td><i>readOnly</i></td></tr>\n<tr><td>msgQLen</td><td><i>INT</i></td><td>Number of messages in input queue.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirLast</td><td><i>TIME_T</i></td><td>Time of last redirect.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirCnt</td><td><i>INT</i></td><td>Count of redirects.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadCnt</td><td><i>INT</i></td><td>Number of uploads.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadEnd</td><td><i>TIME_T</i></td><td>Time of upload end.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadLast</td><td><i>TIME_T</i></td><td>Time of last upload input.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadStart</td><td><i>TIME_T</i></td><td>Time of upload start.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"WebSocketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Zvfs\"></a>\n\n<hr>\n\n\n<h1>Zvfs</h1>\n\n<font color=red>Synopsis:Zvfs.method(...)\n\n</font><p>Commands for mounting and accessing .zip files as a filesystem.\n\n\n<h2>Methods for \"Zvfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>append</td><td>append(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Like 'create()', but appends to an existing archive (with no dup checking).</td></tr>\n<tr><td>create</td><td>create(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Create a zip with the given files in prefix path. This command creates a zip archive and adds files to it. Files are relative the given 'path', or the current directory. If the destignation file already exist but is not an archive (eg. an executable), zip data is appended to the end of the file. If the existing file is already an archive, an error will be thrown. To truncate an existing archive, use zvfs.truncate(). Or use zvfs.append() instead. \n   zvfs.create('foo.zip',['main.js', 'bar.js'], 'src', ['a.html', 'css/a.css'], 'html');</td></tr>\n<tr><td>deflate</td><td>deflate(data:string):string </td><td>Compress string using zlib deflate.</td></tr>\n<tr><td>inflate</td><td>inflate(data:string):string </td><td>Uncompress string using zlib inflate.</td></tr>\n<tr><td>list</td><td>list(archive:string):array </td><td>List files in archive. Return contents of zip directory as an array of arrays. The first element contains the labels, ie: \n[ 'Name', 'Special', 'Offset', 'Bytes', 'BytesCompressed' ] </td></tr>\n<tr><td>mount</td><td>mount(archive:string, mountdir:string=void):string </td><td>Mount zip on mount point. Read a ZIP archive and make entries in the virutal file hash table for all files contained therein.</td></tr>\n<tr><td>names</td><td>names(mountdir:string=void):array </td><td>Return all zvfs mounted zips, or archive for specified mount. Given an mount point argument, returns the archive for it. Otherwise, returns an array of mount points</td></tr>\n<tr><td>offset</td><td>offset(archive:string):number </td><td>Return the start offset of zip data. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>stat</td><td>stat(filename:string):object </td><td>Return details on file in zvfs mount. Return details about the given file in the ZVFS.  The information consists of (1) the name of the ZIP archive that contains the file, (2) the size of the file after decompressions, (3) the compressed size of the file, and (4) the offset of the compressed data in the archive.</td></tr>\n<tr><td>truncate</td><td>truncate(archive:string, noerror:boolean=false):number </td><td>Truncate zip data from archive. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>unmount</td><td>unmount(archive:string):void </td><td>Unmount zip.</td></tr>\n</table>\n<a name=\"Zvfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"console\"></a>\n\n<hr>\n\n\n<h1>console</h1>\n\n<font color=red>Synopsis:console.method(...)\n\n</font><p>Console input and output to stderr.\n\n\n<h2>Methods for \"console\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#console.assertOptions'>options</a>:object=void):void </td><td>Same as System.assert().</td></tr>\n<tr><td>error</td><td>error(val, ...):void </td><td>Same as log.</td></tr>\n<tr><td>input</td><td>input():string|void </td><td>Read input from the console.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as System.puts, but goes to stderr and includes file:line.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Same as System.printf but goes to stderr.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Same as System.puts, but goes to stderr.</td></tr>\n<tr><td>warn</td><td>warn(val, ...):void </td><td>Same as log.</td></tr>\n</table>\n\n\n<a name=\"console.assertOptions\"></a>\n<a name=\"console.confOptions\"></a>\n<h2>Options for \"console.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n<a name=\"consoleend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<p>\n", "/* jsi.h : External API header file for Jsi. */\n#ifndef __JSI_H__\n#define __JSI_H__\n\n#define JSI_VERSION_MAJOR   3\n#define JSI_VERSION_MINOR   0\n#define JSI_VERSION_RELEASE 7\n\n#define JSI_VERSION (JSI_VERSION_MAJOR + ((Jsi_Number)JSI_VERSION_MINOR/100.0) + ((Jsi_Number)JSI_VERSION_RELEASE/10000.0))\n\n#ifndef JSI_EXTERN\n#define JSI_EXTERN extern\n#endif\n\n#ifdef offsetof\n#define Jsi_Offset(type, field) ((long) offsetof(type, field))\n#else\n#define Jsi_Offset(type, field) ((long) ((char *) &((type *) 0)->field))\n#endif\n\n#ifndef __GNUC__\n#define __attribute__(X)\n#endif\n\n#ifndef __USE_XOPEN\n#define __USE_XOPEN\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#ifdef __WIN32\n#define __USE_MINGW_ANSI_STDIO 1\n#endif\n\n#include <stdbool.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <stdio.h> \n#include <dirent.h>\n\n/* --TYPEDEFS-- */\ntypedef int64_t Jsi_Wide;\ntypedef uint64_t Jsi_UWide;\ntypedef long double ldouble;\n#ifdef JSI_USE_LONG_DOUBLE\ntypedef ldouble Jsi_Number;\n#define JSI_NUMLMOD \"L\"\n#else\ntypedef double Jsi_Number;\n#define JSI_NUMLMOD\n#endif\ntypedef double time_d;\ntypedef int64_t time_w;\ntypedef uint32_t Jsi_Sig; // Signature field\n\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long ulong;\ntypedef unsigned short ushort;\n#define JSI_NUMGFMT JSI_NUMLMOD \"g\"\n#define JSI_NUMFFMT JSI_NUMLMOD \"f\"\n#define JSI_NUMEFMT JSI_NUMLMOD \"e\"\n/* -- */\n\n\n/* --ENUMS-- */\ntypedef enum {\n    /* Jsi Return Codes. */\n    JSI_OK=0, JSI_ERROR=1, JSI_RETURN=2, JSI_BREAK=3,\n    JSI_CONTINUE=4, JSI_SIGNAL=5, JSI_EXIT=6, JSI_EVAL=7,    \n} Jsi_RC;\n\ntypedef enum {\n    JSI_MAP_NONE, JSI_MAP_HASH, JSI_MAP_TREE, JSI_MAP_LIST /*, JSI_MAP_STACK */\n} Jsi_Map_Type;\n\ntypedef enum {\n    JSI_KEYS_STRING = 0,    // A string that gets stored in hash.\n    JSI_KEYS_STRINGKEY = 1, // A pointer to strings in another hash such as Jsi_KeyLookup()\n    JSI_KEYS_ONEWORD = 2,   // A pointer.\n    JSI_KEYS_RESERVED = 3,  // Unused.\n    JSI_KEYS_STRUCT_MINSIZE = 4 // Any number >= 4 is the number of bytes in a struct/key.\n} Jsi_Key_Type;\n\ntypedef enum {\n    JSI_OT_UNDEF,       /* Undefined */\n    JSI_OT_BOOL,        /* Boolean object, use d.val */\n    JSI_OT_NUMBER,      /* Number object, use d.num */\n    JSI_OT_STRING,      /* String object, use d.str */\n    JSI_OT_OBJECT,      /* Common object */\n    JSI_OT_ARRAY,       /* NOT A REAL TYPE: is just an JSI_OT_OBJECT with array elements */\n    JSI_OT_FUNCTION,    /* Function object, use d.fobj */\n    JSI_OT_REGEXP,      /* RegExp object, use d.robj */\n    JSI_OT_ITER,        /* Iter object, use d.iobj */\n    JSI_OT_USEROBJ,     /* UserDefined object, use d.uobj */\n    JSI_OT__MAX = JSI_OT_USEROBJ\n} Jsi_otype;\n\ntypedef enum {          /* TYPE         CONSTRUCTOR JSI_VALUE-DATA  IMPLICIT-PROTOTYPE  */\n    JSI_VT_UNDEF,       /* undefined    none        none            none                */\n    JSI_VT_BOOL,        /* boolean      Boolean     d.val           none                */\n    JSI_VT_NUMBER,      /* number       Number      d.num           Number.prototype    */\n    JSI_VT_STRING,      /* string       String      d.str           String.prototype    */\n    JSI_VT_OBJECT,      /* object       Jsi_Obj     d.obj           Jsi_Obj.prototype   */\n    JSI_VT_NULL,        /* null         none        none            none                */\n    JSI_VT_VARIABLE,    /* lvalue       none        d.lval          none                */\n    JSI_VT__MAX = JSI_VT_VARIABLE\n} Jsi_vtype;\n\ntypedef enum {\n    JSI_TT_UNDEFINED= (1<<JSI_OT_UNDEF),    //  0x1\n    JSI_TT_BOOLEAN  = (1<<JSI_OT_BOOL),     //  0x2\n    JSI_TT_NUMBER   = (1<<JSI_OT_NUMBER),   //  0x4\n    JSI_TT_STRING   = (1<<JSI_OT_STRING),   //  0x8\n    JSI_TT_OBJECT   = (1<<JSI_OT_OBJECT),   //  0x10\n    JSI_TT_ARRAY    = (1<<JSI_OT_ARRAY),    //  0x20\n    JSI_TT_FUNCTION = (1<<JSI_OT_FUNCTION), //  0x40\n    JSI_TT_REGEXP   = (1<<JSI_OT_REGEXP),   //  0x80\n    JSI_TT_ITEROBJ  = (1<<JSI_OT_ITER),     //  0x100\n    JSI_TT_USEROBJ  = (1<<JSI_OT_USEROBJ),  //  0x200\n    JSI_TT_NULL     = (1<<(JSI_OT_USEROBJ+1)),//0x400\n    JSI_TT_ANY      = (1<<(JSI_OT_USEROBJ+2)),//0x800\n    JSI_TT_VOID     = (1<<(JSI_OT_USEROBJ+3)) //0x1000\n} Jsi_ttype;\n\ntypedef enum {\n    /* General flags. */\n    JSI_NONE=0, JSI_NO_ERRMSG=1, \n    JSI_CMP_NOCASE=1, JSI_CMP_CHARSET_SCAN=2,\n    JSI_CMP_EXACT=0x4,\n    JSI_EVAL_ARGV0=0x1, JSI_EVAL_GLOBAL=0x2, JSI_EVAL_NOSKIPBANG=0x4, JSI_EVAL_AUTOINDEX=0x8,\n    JSI_EVAL_RETURN         =0x10, // Return top of stack as result\n    JSI_EVAL_ONCE           =0x20, // Source files only once.\n    JSI_EVAL_ISMAIN         =0x40, // Set isMain to true.\n    JSI_EVAL_EXISTS         =0x80, // Source if exists.\n    JSI_EVAL_ERRIGNORE      =0x100,// Source ignores errors.\n\n    /* Flags for Jsi_CmdProc */\n    JSI_CALL_CONSTRUCTOR    =0x1,\n    JSI_CALL_BUILTIN        =0x2,\n    \n    JSI_CMDSPEC_ISOBJ       = 0x1,\n    JSI_CMDSPEC_PROTO       = 0x2,\n    JSI_CMDSPEC_NONTHIS     = 0x4,\n    JSI_CMDSPEC_SUBCMDS     = 0x8,      // Has sub-commands.\n    \n    JSI_CMD_HAS_ATTR        = 0x100,\n    JSI_CMD_IS_CONSTRUCTOR  = 0x200,\n    JSI_CMD_IS_OBJ          = 0x400,\n    JSI_CMD_LOG_TEST        = 0x1000,\n    JSI_CMD_LOG_DEBUG       = 0x2000,\n    JSI_CMD_LOG_TRACE       = 0x4000,\n    JSI_CMD_MASK            = 0xffff,\n    \n    JSI_OM_READONLY         = 0x01,     /* ecma read-only */\n    JSI_OM_DONTENUM         = 0x02,     /* ecma emumerable */\n    JSI_OM_DONTDEL          = 0x04,     /* ecma configurable */\n    JSI_OM_INNERSHARED      = 0x08,\n    JSI_OM_ISARRAYLIST      = 0x10,\n    JSI_OM_ISSTRKEY         = 0x20,\n    JSI_OM_UNUSED           = 0x40,\n    JSI_OM_ISSTATIC         = 0x80,\n    \n    JSI_INTACCESS_READ      = 0x0,\n    JSI_INTACCESS_WRITE     = 0x1,\n    JSI_INTACCESS_NETWORK   = 0x2,\n    JSI_INTACCESS_SETSSL    = 0x3,\n    JSI_INTACCESS_MAININTERP= 0x4,\n    JSI_INTACCESS_CREATE    = 0x5,\n    \n    JSI_LOG_BUG=0,   JSI_LOG_ERROR,   JSI_LOG_WARN,\n    JSI_LOG_INFO,    JSI_LOG_UNUSED,  JSI_LOG_PARSE,\n    JSI_LOG_TEST,    JSI_LOG_DEBUG,   JSI_LOG_TRACE,\n    JSI__LOGLAST=JSI_LOG_TRACE,\n    \n    JSI_SORT_NOCASE = 0x1, JSI_SORT_DESCEND = 0x2, JSI_SORT_DICT = 0x4,\n    \n    JSI_NAME_FUNCTIONS = 0x1, JSI_NAME_DATA = 0x2,\n    \n    JSI_TREE_ORDER_IN=0, JSI_TREE_ORDER_PRE=0x10, JSI_TREE_ORDER_POST=0x20, // Jsi_TreeSearchFirst()\n    JSI_TREE_ORDER_LEVEL=0x30, JSI_TREE_ORDER_MASK=0x30,\n    JSI_TREE_SEARCH_KEY=0x10, // Use key even if NULL\n    JSI_TREE_USERFLAG_MASK=0x7f,\n    JSI_LIST_REVERSE=0x8, // Jsi_ListSearchFirst\n    JSI_MUTEX_RECURSIVE=2,\n    \n    JSI_FS_NOCLOSE=0x1, JSI_FS_READONLY=0x2, JSI_FS_WRITEONLY=0x4, JSI_FS_APPEND=0x8,\n    JSI_FS_COMPRESS=0x100,\n    JSI_FSMODESIZE=15,\n    JSI_FILE_TYPE_FILES=0x1, JSI_FILE_TYPE_DIRS=0x2,    JSI_FILE_TYPE_MOUNT=0x4,\n    JSI_FILE_TYPE_LINK=0x8,  JSI_FILE_TYPE_PIPE=0x10,   JSI_FILE_TYPE_BLOCK=0x20,\n    JSI_FILE_TYPE_CHAR=0x40, JSI_FILE_TYPE_SOCKET=0x80, JSI_FILE_TYPE_HIDDEN=0x100,\n    \n    JSI_OUTPUT_QUOTE = 0x1,\n    JSI_OUTPUT_JSON = 0x2,\n    JSI_OUTPUT_NEWLINES = 0x4,\n    JSI_OUTPUT_STDERR = 0x8,\n    JSI_JSON_STATIC_DEFAULT =100,\n    JSI_JSON_STRICT   = 0x101, /* property names must be quoted. */\n    JSI_STUBS_STRICT  = 0x1, JSI_STUBS_SIG = 0xdeadaa00, JSI_SIG_TYPEDEF,\n    JSI_SIG_OPTS = 0xdeadab00,\n    JSI_SIG_OPTS_STRUCT, JSI_SIG_OPTS_ENUM, JSI_SIG_OPTS_VARDEF, JSI_SIG_OPTS_FIELD,\n    JSI_SIG_OPTS_USER1=0xdeadab20,\n\n    JSI_EVENT_TIMER=0, JSI_EVENT_SIGNAL=1, JSI_EVENT_ALWAYS=2,\n    JSI_ZIP_MAIN=0x1,  JSI_ZIP_INDEX=0x2,\n\n    JSI_DBI_READONLY     =0x0001, /* Db is created readonly */\n    JSI_DBI_NOCREATE     =0x0002, /* Db must already exist. */\n    JSI_DBI_NO_MUTEX     =0x0004, /* Disable mutex. */\n    JSI_DBI_FULL_MUTEX   =0x0008, /* Use full mutex. */\n    \n    JSI_MAX_NUMBER_STRING=100,\n    JSI_BUFSIZ=8192\n\n} Jsi_Enums; /* Debugging is easier with enums than #define. */\n\n/* -- */\n\n\n/* --STRUCTS-- */\n\ntypedef struct Jsi_Interp Jsi_Interp;\ntypedef struct Jsi_Obj Jsi_Obj;\ntypedef struct Jsi_Value Jsi_Value;\ntypedef struct Jsi_Func Jsi_Func;\ntypedef struct Jsi_IterObj Jsi_IterObj;\ntypedef struct Jsi_FuncObj Jsi_FuncObj;\ntypedef struct Jsi_UserObjReg Jsi_UserObjReg;\ntypedef struct Jsi_UserObj Jsi_UserObj;\ntypedef struct Jsi_HashEntry Jsi_HashEntry;\ntypedef struct Jsi_Hash Jsi_Hash;\ntypedef struct Jsi_HashSearch Jsi_HashSearch;\ntypedef struct Jsi_TreeEntry Jsi_TreeEntry;\ntypedef struct Jsi_Tree Jsi_Tree;\ntypedef struct Jsi_TreeSearch Jsi_TreeSearch;\ntypedef struct Jsi_List Jsi_List;\ntypedef struct Jsi_ListEntry Jsi_ListEntry;\ntypedef struct Jsi_ListSearch Jsi_ListSearch;\ntypedef struct Jsi_Map Jsi_Map;\ntypedef struct Jsi_MapEntry Jsi_MapEntry;\ntypedef struct Jsi_MapSearch Jsi_MapSearch;\ntypedef struct Jsi_Regex_ Jsi_Regex;\ntypedef struct Jsi_Db Jsi_Db;\ntypedef struct Jsi_DbBinds Jsi_DbBinds;\ntypedef struct Jsi_Mutex Jsi_Mutex;\ntypedef struct Jsi_ScopeStrs Jsi_ScopeStrs;\ntypedef struct Jsi_OpCodes Jsi_OpCodes;\ntypedef struct Jsi_Chan* Jsi_Channel;\ntypedef struct Jsi_CS_Ctx Jsi_CS_Ctx;\ntypedef struct Jsi_OptionSpec Jsi_OptionSpec;\n\ntypedef struct Jsi_OptionSpec Jsi_StructSpec;\ntypedef struct Jsi_OptionSpec Jsi_FieldSpec;\ntypedef struct Jsi_OptionSpec Jsi_EnumSpec;\ntypedef struct Jsi_OptionSpec Jsi_VarSpec;\n\ntypedef Jsi_RC (Jsi_InitProc)(Jsi_Interp *interp, int release); // When release>1, the main interp is exiting.\ntypedef Jsi_RC (Jsi_DeleteProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_EventHandlerProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_ValueHandlerProc)(Jsi_Interp *interp, Jsi_Value *v, struct Jsi_OptionSpec* spec, void *record);\ntypedef void (Jsi_DeleteVoidProc)(void *data);\ntypedef Jsi_RC (Jsi_csgset)(Jsi_Interp *interp, void *data, Jsi_Wide *s, Jsi_OptionSpec *spec, int idx, bool isSet);\ntypedef int (Jsi_IterProc)(Jsi_IterObj *iterObj, Jsi_Value *val, Jsi_Value *var, int index);\n\n/* -- */\n\n\n/* --INTERP-- */\n\n/* Options and flags for Jsi_InterpNew/Jsi_Main */\ntypedef struct {\n    int argc;                   // Arguments from main().\n    char **argv;                // ...\n    Jsi_InitProc* initProc;     // Initialization proc\n    uint mem_debug:2;           // Memory debug level;\n    bool no_interactive:1;      // Jsi_Main: does not default to interactive mode when no script arg given.\n    bool auto_delete:1;         // Jsi_Main: auto delete interp upon return.\n    bool no_exit:1;             // Do not exit, even on error.\n    uint reserved:11;           // Reserved for future use.\n    int exitCode:16;            // Call exit with this code.\n    Jsi_Interp* interp;         // Jsi_InterpNew sets this to let Jsi_Main use this interp.\n    void *reserved2[8];         // Reserved for future\n} Jsi_InterpOpts;\n\nJSI_EXTERN Jsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts); /*STUB = 1*/\nJSI_EXTERN void Jsi_InterpDelete( Jsi_Interp* interp); /*STUB = 2*/\nJSI_EXTERN void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr);  /*STUB = 3*/\nJSI_EXTERN Jsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags); /*STUB = 4*/\nJSI_EXTERN bool Jsi_InterpGone( Jsi_Interp* interp); /*STUB = 5*/\nJSI_EXTERN Jsi_Value* Jsi_InterpResult(Jsi_Interp *interp); /*STUB = 6*/\nJSI_EXTERN const char* Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr); /*STUB = 7*/\nJSI_EXTERN void* Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc); /*STUB = 8*/\nJSI_EXTERN void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc); /*STUB = 9*/\nJSI_EXTERN void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key); /*STUB = 10*/\nJSI_EXTERN bool Jsi_InterpSafe(Jsi_Interp *interp); /*STUB = 11*/\nJSI_EXTERN Jsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag); /*STUB = 12*/\nJSI_EXTERN Jsi_Interp* Jsi_Main(Jsi_InterpOpts *opts); /*STUB = 13*/\n/* -- */\n\n\n/* --MEMORY-- */\nJSI_EXTERN void* Jsi_Malloc(uint size); /*STUB = 14*/\nJSI_EXTERN void* Jsi_Calloc(uint n, uint size); /*STUB = 15*/\nJSI_EXTERN void* Jsi_Realloc(void *m, uint size); /*STUB = 16*/\nJSI_EXTERN void  Jsi_Free(void *m); /*STUB = 17*/\nJSI_EXTERN int Jsi_ObjIncrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 18*/\nJSI_EXTERN int Jsi_ObjDecrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 19*/\nJSI_EXTERN int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 20*/\nJSI_EXTERN int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 21*/\nJSI_EXTERN bool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 22*/\nJSI_EXTERN Jsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m); /*STUB = 23*/\n/* -- */\n\n\n/* --STRINGS-- */\nJSI_EXTERN uint Jsi_Strlen(const char *str); /*STUB = 24*/\nJSI_EXTERN uint Jsi_StrlenSet(const char *str, uint len); /*STUB = 25*/\nJSI_EXTERN int Jsi_Strcmp(const char *str1, const char *str2); /*STUB = 26*/\nJSI_EXTERN int Jsi_Strncmp(const char *str1, const char *str2, int n); /*STUB = 27*/\nJSI_EXTERN int Jsi_Strncasecmp(const char *str1, const char *str2, int n); /*STUB = 28*/\nJSI_EXTERN int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict); /*STUB = 29*/\nJSI_EXTERN char* Jsi_Strcpy(char *dst, const char *src); /*STUB = 30*/\nJSI_EXTERN char* Jsi_Strncpy(char *dst, const char *src, int len); /*STUB = 31*/\nJSI_EXTERN char* Jsi_Strdup(const char *n); /*STUB = 32*/\nJSI_EXTERN char* Jsi_StrdupLen(const char *str, int len); /*STUB = 407*/\nJSI_EXTERN char* Jsi_Strrchr(const char *str, int c); /*STUB = 33*/\nJSI_EXTERN char* Jsi_Strstr(const char *str, const char *sub); /*STUB = 34*/\nJSI_EXTERN char* Jsi_Strrstr(const char *str, const char *sub); /*STUB = 233*/ \nJSI_EXTERN char* Jsi_Strchr(const char *str, int c); /*STUB = 36*/\nJSI_EXTERN int Jsi_Strpos(const char *str, int start, const char *nid, int nocase); /*STUB = 37*/\nJSI_EXTERN int Jsi_Strrpos(const char *str, int start, const char *nid, int nocase); /*STUB = 38*/\nJSI_EXTERN bool Jsi_StrIsAlnum(const char *cp); /*STUB = 416*/\n#define Jsi_Stzcpy(buf,src) Jsi_Strncpy(buf, src, sizeof(buf))\n\n/* Dynamic strings. */\n#ifndef JSI_DSTRING_STATIC_SIZE\n#define JSI_DSTRING_STATIC_SIZE 200\n#endif\n\ntypedef struct {\n#define JSI_DSTRING_DECL_FIELDS(siz) \\\n    const char *strA; /* Allocated string, or = {\"string\"}.*/ \\\n    uint len;       /* Length of string. */ \\\n    uint spaceAvl;  /* Amount of space available or allocated. */ \\\n    uint staticSize;/* The sizeof \"Str\", or 0 if used \"= {}\" */ \\\n    char Str[siz];  /* Static string */\n    JSI_DSTRING_DECL_FIELDS(JSI_DSTRING_STATIC_SIZE)\n} Jsi_DString;\n\n/* Declares a custom Jsi_DString* variable with other than default size... */\n#define JSI_DSTRING_VAR(namPtr, siz) \\\n    struct { JSI_DSTRING_DECL_FIELDS(siz) } _STATIC_##namPtr; \\\n    Jsi_DString *namPtr = (Jsi_DString *)&_STATIC_##namPtr; \\\n    namPtr->staticSize = siz; namPtr->strA=0; \\\n    namPtr->Str[0] = 0; namPtr->spaceAvl = namPtr->len = 0\n\nJSI_EXTERN char*   Jsi_DSAppendLen(Jsi_DString *dsPtr,const char *bytes, int length);  /*STUB = 39*/\nJSI_EXTERN char*   Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)  /*STUB = 40*/  __attribute__((sentinel));\nJSI_EXTERN void    Jsi_DSFree(Jsi_DString *dsPtr);  /*STUB = 41*/\nJSI_EXTERN char*   Jsi_DSFreeDup(Jsi_DString *dsPtr);  /*STUB = 42*/\nJSI_EXTERN void    Jsi_DSInit(Jsi_DString *dsPtr);  /*STUB = 43*/\nJSI_EXTERN uint    Jsi_DSLength(Jsi_DString *dsPtr);  /*STUB = 44*/\nJSI_EXTERN char*   Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)  /*STUB = 45*/ __attribute__((format (printf,2,3)));\nJSI_EXTERN char*   Jsi_DSSet(Jsi_DString *dsPtr, const char *str);  /*STUB = 46*/\nJSI_EXTERN uint    Jsi_DSSetLength(Jsi_DString *dsPtr, uint length);  /*STUB = 47*/\nJSI_EXTERN char*   Jsi_DSValue(Jsi_DString *dsPtr);  /*STUB = 48*/\n/* -- */\n\n\n/* --FUNC/VAR/CMD-- */\ntypedef void (Jsi_DelCmdProc)(Jsi_Interp *interp, void *privData);\ntypedef Jsi_RC (Jsi_CmdProc)(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\n#define Jsi_CmdProcDecl(name,...) Jsi_RC name(Jsi_Interp *interp, Jsi_Value *args, \\\n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, ##__VA_ARGS__)\n\ntypedef struct Jsi_CmdSpec {\n    const char *name;       /* Cmd name */\n    Jsi_CmdProc *proc;      /* Command handler */\n    int minArgs;\n    int maxArgs;            /* Max args or -1 */\n    const char *argStr;     /* Argument description */\n    const char *help;       /* Short help string. */\n    uint retType;           /* Return type(s) or'ed Jsi_otype. */\n    int flags;              /* JSI_CMD_* flags. */\n    const char *info;       /* Detailed description. Use JSI_DETAIL macro. */\n    Jsi_OptionSpec *opts;   /* Options for arg, default is first. */\n    Jsi_DelCmdProc *delProc;/* Callback to handle command delete. */\n    void *reserved[4];      /* Reserved for internal use. */\n} Jsi_CmdSpec;\n\ntypedef struct {\n    bool Test;\n    bool Debug;\n    bool Trace;\n    int traceCall;\n    bool coverage;\n    bool profile;\n} Jsi_ModuleConf;\n\ntypedef struct {\n    struct Jsi_OptionSpec *spec;\n    void *data;\n    Jsi_CmdSpec *cmdSpec;\n    Jsi_Value *info;\n    void *reserved[3]; // Reserved for future use.\n    Jsi_ModuleConf modConf;\n    void *reserved2[3]; // Reserved for future use.\n} Jsi_PkgOpts;\n\ntypedef struct {\n    char *str;\n    int32_t len;\n    uint32_t flags;\n} Jsi_String;\n\nJSI_EXTERN Jsi_Value* Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData); /*STUB = 49*/\nJSI_EXTERN Jsi_Value* Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs, void *privData, int flags); /*STUB = 50*/\nJSI_EXTERN void* Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var);  /*STUB = 51*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmd, const char *json, Jsi_Value **ret); /*STUB = 52*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret); /*STUB = 53*/\nJSI_EXTERN Jsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name); /*STUB = 54*/\nJSI_EXTERN Jsi_CmdSpec* Jsi_FunctionGetSpecs(Jsi_Func *funcPtr); /*STUB = 55*/\nJSI_EXTERN bool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr); /*STUB = 56*/\nJSI_EXTERN bool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr); /*STUB = 57*/\nJSI_EXTERN void* Jsi_FunctionPrivData(Jsi_Func *funcPtr); /*STUB = 58*/\nJSI_EXTERN Jsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr); /*STUB = 59*/\nJSI_EXTERN Jsi_RC Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret); /*STUB = 60*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this); /*STUB = 61*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *tocall, const char *json, Jsi_Value **ret); /*STUB = 62*/\nJSI_EXTERN int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg); /*STUB = 63*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr); /*STUB = 64*/\nJSI_EXTERN Jsi_Value* Jsi_VarLookup(Jsi_Interp *interp, const char *varname); /*STUB = 65*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup(Jsi_Interp *interp, const char *varname); /*STUB = 66*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj); /*STUB = 67*/\nJSI_EXTERN Jsi_RC Jsi_PkgProvideEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_InitProc *initProc, Jsi_PkgOpts* popts); /*STUB = 68*/\nJSI_EXTERN Jsi_Number Jsi_PkgRequireEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_PkgOpts **poptsPtr); /*STUB = 69*/\nJSI_EXTERN Jsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr); /*STUB = 70*/\n#define Jsi_PkgRequire(i,n,v) Jsi_PkgRequireEx(i,n,v,NULL)\n#define Jsi_PkgProvide(i,n,v,p) Jsi_PkgProvideEx(i,n,v,p,NULL)\n/* -- */\n\n/* UTF-8 and Unicode */\ntypedef int32_t Jsi_UniChar;\nJSI_EXTERN uint Jsi_NumUtfBytes(char c); /*STUB = 71*/\nJSI_EXTERN uint Jsi_NumUtfChars(const char *utf, int length); /*STUB = 72*/\nJSI_EXTERN uint Jsi_UtfGetIndex(const char *utf, int index, char outbuf[5]); /*STUB = 73*/\nJSI_EXTERN const char* Jsi_UtfAtIndex(const char *utf, int index); /*STUB = 74*/\nJSI_EXTERN uint Jsi_UniCharToUtf(Jsi_UniChar uc, char *dest); /*STUB = 75*/\nJSI_EXTERN uint Jsi_UtfToUniChar(const char *utf, Jsi_UniChar *ch); /*STUB = 76*/\nJSI_EXTERN uint Jsi_UtfToUniCharCase(const char *utf, Jsi_UniChar *ch, int upper); /*STUB = 77*/\nJSI_EXTERN uint Jsi_UtfDecode(const char *str, char* oututf); /*STUB = 78*/\nJSI_EXTERN uint Jsi_UtfEncode(const char *utf, char *outstr); /*STUB = 79*/\nJSI_EXTERN char* Jsi_UtfSubstr(const char *str, int n, int len, Jsi_DString *dStr); /*STUB = 80*/\nJSI_EXTERN int Jsi_UtfIndexToOffset(const char *utf, int index); /*STUB = 81*/\n/* -- */\n\n\n/* --OBJECT-- */\nJSI_EXTERN Jsi_Obj* Jsi_ObjNew(Jsi_Interp* interp); /*STUB = 82*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewType(Jsi_Interp* interp, Jsi_otype type); /*STUB = 83*/\nJSI_EXTERN void Jsi_ObjFree(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 84*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count); /*STUB = 85*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copy); /*STUB = 86*/\n\nJSI_EXTERN bool      Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o); /*STUB = 87*/\nJSI_EXTERN void     Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len); /*STUB = 88*/\nJSI_EXTERN int      Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 89*/\nJSI_EXTERN const char* Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 90*/\nJSI_EXTERN Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj); /*STUB = 91*/\nJSI_EXTERN void     Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 92*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex); /*STUB = 93*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v); /*STUB = 94*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *nv, int flags); /*STUB = 95*/\nJSI_EXTERN void    Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj);  /*STUB = 96*/\nJSI_EXTERN Jsi_IterObj* Jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterProc); /*STUB = 412*/\nJSI_EXTERN void Jsi_IterObjFree(Jsi_IterObj *iobj); /*STUB = 413*/\nJSI_EXTERN void Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth); /*STUB = 414*/\nJSI_EXTERN int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint n); /*STUB = 35*/\n\nstruct Jsi_IterObj {\n    Jsi_Interp *interp;\n    const char **keys;\n    uint size; \n    uint count;\n    uint iter;\n    bool isArrayList;            /* If an array list do not store keys. */\n    bool isof;\n    Jsi_Obj *obj;\n    uint cur;                    /* Current array cursor. */\n    int depth;                  /* Used to create list of keys. */\n    Jsi_IterProc *iterCmd;\n};\n\n/* -- */\n\n\n/* --VALUE-- */\nJSI_EXTERN Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp); /*STUB = 97*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp); /*STUB = 98*/\nJSI_EXTERN void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v); /*STUB = 99*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp); /*STUB = 100*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval); /*STUB = 101*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n); /*STUB = 102*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, uchar *s, uint len); /*STUB = 103*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len); /*STUB = 104*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s); /*STUB = 105*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len); /*STUB = 409*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s); /*STUB = 106*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count); /*STUB = 107*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) ; /*STUB = 108*/\n#define Jsi_ValueNewBlobString(interp, s) Jsi_ValueNewBlob(interp, (uchar*)s, Jsi_Strlen(s))\n#define Jsi_ValueNewArrayObj(interp, items, count, copy) Jsi_ValueNewObj(interp, Jsi_ObjNewArray(interp, items, count, copy))\n\nJSI_EXTERN Jsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **s); /*STUB = 109*/\nJSI_EXTERN Jsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 110*/\nJSI_EXTERN Jsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n); /*STUB = 111*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n); /*STUB = 112*/\nJSI_EXTERN Jsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n); /*STUB = 113*/\nJSI_EXTERN Jsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n); /*STUB = 114*/\nJSI_EXTERN Jsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 115*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags); /*STUB = 116*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val); /*STUB = 117*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val); /*STUB = 118*/\n\nJSI_EXTERN bool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype); /*STUB = 119*/\nJSI_EXTERN bool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype); /*STUB = 120*/\nJSI_EXTERN bool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 121*/\nJSI_EXTERN bool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 122*/\nJSI_EXTERN bool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 123*/\nJSI_EXTERN bool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 124*/\nJSI_EXTERN bool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 125*/\nJSI_EXTERN bool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 126*/\nJSI_EXTERN bool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 127*/\nJSI_EXTERN bool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 128*/\nJSI_EXTERN bool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 129*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 130*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 131*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **v, Jsi_Number n); /*STUB = 132*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **v, int b); /*STUB = 133*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 134*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 135*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **v, uchar *s, int len); /*STUB = 136*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 137*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 138*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_DString *dsPtr); /*STUB = 139*/\nJSI_EXTERN bool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key); /*STUB = 140*/\n#define Jsi_ValueMakeStringDup(interp, v, s) Jsi_ValueMakeString(interp, v, Jsi_Strdup(s))\n\nJSI_EXTERN const char*  Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr); /*STUB = 141*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 142*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 143*/\nJSI_EXTERN Jsi_Number   Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt); /*STUB = 144*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 145*/\n\nJSI_EXTERN void     Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 146*/\nJSI_EXTERN const char* Jsi_ValueGetDString(Jsi_Interp* interp, Jsi_Value* v, Jsi_DString *dStr, int quote); /*STUB = 147*/\nJSI_EXTERN char*    Jsi_ValueString(Jsi_Interp* interp, Jsi_Value* v, int *lenPtr); /*STUB = 148*/\nJSI_EXTERN uchar*   Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr); /*STUB = 149*/\nJSI_EXTERN char*    Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr); /*STUB = 150*/\nJSI_EXTERN int      Jsi_ValueStrlen(Jsi_Value* v); /*STUB = 151*/\nJSI_EXTERN void     Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret);  /*STUB = 152*/\nJSI_EXTERN int      Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2); /*STUB = 153*/\nJSI_EXTERN Jsi_Obj* Jsi_ValueGetObj(Jsi_Interp* interp, Jsi_Value* v); /*STUB = 154*/\nJSI_EXTERN Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv); /*STUB = 155*/\nJSI_EXTERN const char* Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 156*/\nJSI_EXTERN int      Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int cmpFlags); /*STUB = 157*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 158*/\n\nJSI_EXTERN Jsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int sortFlags); /*STUB = 159*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 160*/\nJSI_EXTERN Jsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 161*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *arg1); /*STUB = 162*/\nJSI_EXTERN void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 163*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 164*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index); /*STUB = 165*/\nJSI_EXTERN char* Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr); /*STUB = 166*/\n#define Jsi_ValueArraySet(interp, dest, value, index) Jsi_ObjArraySet(interp, Jsi_ValueGetObj(interp, dest), value, index)\n\n#define Jsi_ValueInsertFixed(i,t,k,v) Jsi_ValueInsert(i,t,k,v,JSI_OM_READONLY | JSI_OM_DONTDEL | JSI_OM_DONTENUM)\nJSI_EXTERN Jsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags); /*STUB = 167*/\nJSI_EXTERN Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int index, Jsi_Value *val, int flags); /*STUB = 411*/\nJSI_EXTERN int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 168*/\nJSI_EXTERN Jsi_Value* Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int iskeystr); /*STUB = 169*/\nJSI_EXTERN bool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *k, int isstrkey); /*STUB = 170*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret); /*STUB = 171*/\n\nJSI_EXTERN void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ); /*STUB = 172*/\nJSI_EXTERN void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from ); /*STUB = 173*/\nJSI_EXTERN void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from); /*STUB = 174*/\nJSI_EXTERN Jsi_Value* Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val); /*STUB = 175*/\nJSI_EXTERN void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from); /*STUB = 176*/\nJSI_EXTERN bool  Jsi_ValueIsEqual(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2); /*STUB = 177*/\n/* -- */\n\n\n/* --USEROBJ-- */\ntypedef bool (Jsi_UserObjIsTrueProc)(void *data);\ntypedef bool (Jsi_UserObjIsEquProc)(void *data1, void *data2);\ntypedef Jsi_Obj* (Jsi_UserGetObjProc)(Jsi_Interp *interp, void *data);\n\ntypedef struct Jsi_UserObjReg {\n    const char *name;\n    Jsi_CmdSpec *spec;\n    Jsi_DeleteProc *freefun;\n    Jsi_UserObjIsTrueProc *istrue;\n    Jsi_UserObjIsEquProc *isequ;\n} Jsi_UserObjReg;\n\nJSI_EXTERN Jsi_Hash* Jsi_UserObjRegister    (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 178*/\nJSI_EXTERN Jsi_RC Jsi_UserObjUnregister  (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 179*/\nJSI_EXTERN int Jsi_UserObjNew    (Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data); /*STUB = 180*/\nJSI_EXTERN void* Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr); /*STUB = 181*/\nJSI_EXTERN Jsi_RC Jsi_UserObjName(Jsi_Interp *interp, Jsi_Value *v, Jsi_DString *dStr); /*STUB = 418*/ /*LAST*/\n/* -- */\n\n\n/* --UTILITY-- */\n#define JSI_NOTUSED(n) (void)n /* Eliminate annoying compiler warning. */\nJSI_EXTERN char* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz); /*STUB = 182*/\nJSI_EXTERN Jsi_Number Jsi_Version(void); /*STUB = 183*/\nJSI_EXTERN Jsi_Value* Jsi_ReturnValue(Jsi_Interp *interp); /*STUB = 184*/\nJSI_EXTERN Jsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret); /*STUB = 185*/\nJSI_EXTERN Jsi_Value* Jsi_Executable(Jsi_Interp *interp); /*STUB = 186*/\nJSI_EXTERN Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int flag); /*STUB = 187*/\nJSI_EXTERN void Jsi_RegExpFree(Jsi_Regex* re); /*STUB = 188*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatch( Jsi_Interp *interp,  Jsi_Value *pattern, const char *str, int *rc, Jsi_DString *dStr); /*STUB = 189*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret); /*STUB = 190*/\nJSI_EXTERN bool Jsi_GlobMatch(const char *pattern, const char *string, int nocase); /*STUB = 191*/\nJSI_EXTERN char* Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *path, char *newpath); /*STUB = 192*/\nJSI_EXTERN char* Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newpath); /*STUB = 193*/\nJSI_EXTERN char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr); /*STUB = 194*/\nJSI_EXTERN char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *path, Jsi_DString *dStr); /*STUB = 195*/\nJSI_EXTERN Jsi_RC Jsi_PathNormalize(Jsi_Interp *interp, Jsi_Value **pathPtr); /*STUB = 410*/\nJSI_EXTERN Jsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags); /*STUB = 196*/\nJSI_EXTERN Jsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) /*STUB = 197*/ __attribute__((format (printf,3,4)));\nJSI_EXTERN char* Jsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dStr); /*STUB = 198*/\nJSI_EXTERN Jsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags); /*STUB = 199*/\nJSI_EXTERN Jsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags); /*STUB = 200*/\nJSI_EXTERN Jsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags); /*STUB = 201*/\nJSI_EXTERN Jsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound); /*STUB = 202*/\nJSI_EXTERN int Jsi_DictionaryCompare(const char *left, const char *right); /*STUB = 203*/\nJSI_EXTERN Jsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n); /*STUB = 204*/\nJSI_EXTERN Jsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base); /*STUB = 205*/\nJSI_EXTERN Jsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *n, int base); /*STUB = 206*/\nJSI_EXTERN Jsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n); /*STUB = 207*/\nJSI_EXTERN Jsi_RC Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr); /*STUB = 208*/\nJSI_EXTERN void Jsi_SplitStr(const char *str, int *argcPtr, char ***argvPtr,  const char *splitCh, Jsi_DString *dStr); /*STUB = 209*/\nJSI_EXTERN Jsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim); /*STUB = 210*/\nJSI_EXTERN void Jsi_Preserve(Jsi_Interp* interp, void *data); /*STUB = 211*/\nJSI_EXTERN void Jsi_Release(Jsi_Interp* interp, void *data); /*STUB = 212*/\nJSI_EXTERN void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc); /*STUB = 213*/\nJSI_EXTERN void Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 214*/\nJSI_EXTERN Jsi_Value* Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton); /*STUB = 215*/\nJSI_EXTERN Jsi_RC Jsi_GetIndex( Jsi_Interp *interp, const char *str, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 216*/\nJSI_EXTERN void* Jsi_PrototypeGet(Jsi_Interp *interp, const char *key); /*STUB = 217*/\nJSI_EXTERN Jsi_RC  Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *proto); /*STUB = 218*/\nJSI_EXTERN Jsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj); /*STUB = 219*/\nJSI_EXTERN Jsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value); /*STUB = 220*/\nJSI_EXTERN void* Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this); /*STUB = 221*/\nJSI_EXTERN Jsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags); /*STUB = 222*/\nJSI_EXTERN void* Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var); /*STUB = 223*/\nJSI_EXTERN const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str); /*STUB = 224*/\nJSI_EXTERN const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str); /*STUB = 225*/\nJSI_EXTERN bool Jsi_IsReserved(Jsi_Interp *interp, const char* str, bool sql); /*STUB = 415*/\nJSI_EXTERN Jsi_RC Jsi_SqlObjBinds(Jsi_Interp* interp, Jsi_DString* zStr, const char *varName, bool addTypes, bool addDefaults, bool nullDefaults); /*STUB = 417*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number date, const char *fmt, int isUtc, Jsi_DString *dStr);  /*STUB = 226*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr, bool noMsg); /*STUB = 227*/\nJSI_EXTERN Jsi_Number Jsi_DateTime(void); /*STUB = 228*/\n#define JSI_DATE_JULIAN2UNIX(d)  (Jsi_Number)(((Jsi_Number)d - 2440587.5)*86400.0)\n#define JSI_DATE_UNIX2JULIAN(d)  (Jsi_Number)((Jsi_Number)d/86400.0+2440587.5)\n\ntypedef enum { Jsi_CHash_SHA2_256, Jsi_CHash_SHA1, Jsi_CHash_MD5, Jsi_CHash_SHA3_224, \n    Jsi_CHash_SHA3_384, Jsi_CHash_SHA3_512, Jsi_CHash_SHA3_256 } Jsi_CryptoHashType;\n\nJSI_EXTERN Jsi_RC Jsi_Encrypt(Jsi_Interp *interp, Jsi_DString *inout, const char *key, uint keyLen, bool decrypt); /*STUB = 229*/\nJSI_EXTERN Jsi_RC Jsi_CryptoHash(char *outbuf, const char *str, int len, Jsi_CryptoHashType type, uint strength, bool noHex, int *sizPtr); /*STUB = 230*/\nJSI_EXTERN Jsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *buf, bool decode); /*STUB = 231*/\nJSI_EXTERN int Jsi_HexStr(const uchar *data, int len, Jsi_DString *dStr, bool decode); /*STUB = 232*/\nJSI_EXTERN uint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len); /*STUB = 234*/\nJSI_EXTERN Jsi_RC Jsi_FileRead(Jsi_Interp *interp, Jsi_Value *name, Jsi_DString *dStr); /*STUB = 408*/\n\nJSI_EXTERN int Jsi_NumberIsInfinity(Jsi_Number a);  /*STUB = 235*/\nJSI_EXTERN bool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2);  /*STUB = 236*/\nJSI_EXTERN bool Jsi_NumberIsFinite(Jsi_Number value);  /*STUB = 237*/\nJSI_EXTERN bool Jsi_NumberIsInteger(Jsi_Number n);  /*STUB = 238*/\nJSI_EXTERN bool Jsi_NumberIsNaN(Jsi_Number a);  /*STUB = 239*/\nJSI_EXTERN bool Jsi_NumberIsNormal(Jsi_Number a);  /*STUB = 240*/\nJSI_EXTERN bool Jsi_NumberIsSubnormal(Jsi_Number a);  /*STUB = 241*/\nJSI_EXTERN bool Jsi_NumberIsWide(Jsi_Number n);  /*STUB = 242*/\nJSI_EXTERN Jsi_Number Jsi_NumberInfinity(int i);  /*STUB = 243*/\nJSI_EXTERN Jsi_Number Jsi_NumberNaN(void);  /*STUB = 244*/\nJSI_EXTERN void Jsi_NumberDtoA(Jsi_Interp *interp, Jsi_Number value, char* buf, int bsiz, int prec);  /*STUB = 245*/\nJSI_EXTERN void Jsi_NumberItoA10(Jsi_Wide value, char* buf, int bsiz);  /*STUB = 246*/\nJSI_EXTERN void Jsi_NumberUtoA10(Jsi_UWide, char* buf, int bsiz);  /*STUB = 247*/\n\n/* -- */\n\n#define JSI_WORDKEY_CAST (void*)(uintptr_t)\n\nstruct Jsi_MapOpts;\n\ntypedef Jsi_RC (Jsi_HashDeleteProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_TreeDeleteProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_MapDeleteProc)(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *data);\ntypedef Jsi_Value *(Jsi_MapFmtKeyProc)(Jsi_MapEntry* hPtr, struct Jsi_MapOpts *opts, int flags);\ntypedef Jsi_RC (Jsi_TreeWalkProc)(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data);\ntypedef int (Jsi_RBCompareProc)(Jsi_Tree *treePtr, const void *key1, const void *key2);\n\ntypedef struct Jsi_MapOpts {\n    Jsi_Map_Type mapType; // Read-only\n    Jsi_Key_Type keyType; // Read-only\n    Jsi_Interp *interp;\n    Jsi_Wide flags;\n    void *user, *user2;\n    Jsi_MapFmtKeyProc *fmtKeyProc;\n    Jsi_RBCompareProc *compareTreeProc;\n    union {\n        Jsi_RC (*freeHashProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\n        Jsi_RC (*freeTreeProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\n        Jsi_RC (*freeListProc)(Jsi_Interp *interp, Jsi_ListEntry *hPtr, void *data);\n    };\n    union {\n        Jsi_RC (*lockHashProc) (Jsi_Hash *tablePtr, int lock);\n        Jsi_RC (*lockTreeProc) (Jsi_Tree *tablePtr, int lock);\n    };\n} Jsi_MapOpts;\n\n/* --HASH-- */\ntypedef struct Jsi_HashSearch {\n    Jsi_Hash *tablePtr;\n    unsigned long nextIndex; \n    Jsi_HashEntry *nextEntryPtr;\n} Jsi_HashSearch;\n\nJSI_EXTERN Jsi_Hash* Jsi_HashNew(Jsi_Interp *interp, uint keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 248*/\nJSI_EXTERN Jsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set); /*STUB = 249*/\nJSI_EXTERN void Jsi_HashDelete(Jsi_Hash *hashPtr); /*STUB = 250*/\nJSI_EXTERN void Jsi_HashClear(Jsi_Hash *hashPtr); /*STUB = 251*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *hashPtr, const void *key, void *value); /*STUB = 252*/\nJSI_EXTERN void* Jsi_HashGet(Jsi_Hash *hashPtr, const void *key, int flags); /*STUB = 253*/\nJSI_EXTERN bool Jsi_HashUnset(Jsi_Hash *tbl, const void *key); /*STUB = 254*/\nJSI_EXTERN void* Jsi_HashKeyGet(Jsi_HashEntry *h); /*STUB = 255*/\nJSI_EXTERN Jsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *hashPtr, Jsi_Value **ret, int flags); /*STUB = 256*/\nJSI_EXTERN void* Jsi_HashValueGet(Jsi_HashEntry *h); /*STUB = 257*/\nJSI_EXTERN void Jsi_HashValueSet(Jsi_HashEntry *h, void *value); /*STUB = 258*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryFind (Jsi_Hash *hashPtr, const void *key); /*STUB = 259*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryNew (Jsi_Hash *hashPtr, const void *key, bool *isNew); /*STUB = 260*/\nJSI_EXTERN int Jsi_HashEntryDelete (Jsi_HashEntry *entryPtr); /*STUB = 261*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchFirst (Jsi_Hash *hashPtr, Jsi_HashSearch *searchPtr); /*STUB = 262*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchNext (Jsi_HashSearch *searchPtr); /*STUB = 263*/\nJSI_EXTERN uint Jsi_HashSize(Jsi_Hash *hashPtr); /*STUB = 264*/\n/* -- */\n\n\n/* --TREE-- */\n\ntypedef struct Jsi_TreeSearch {\n    Jsi_Tree *treePtr;\n    uint top, max, left, epoch; \n    int flags;\n    Jsi_TreeEntry *staticPtrs[200], *current;\n    Jsi_TreeEntry **Ptrs;\n} Jsi_TreeSearch;\n\nJSI_EXTERN Jsi_Tree* Jsi_TreeNew(Jsi_Interp *interp, uint keyType, Jsi_TreeDeleteProc *freeProc); /*STUB = 265*/\nJSI_EXTERN Jsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set); /*STUB = 266*/\nJSI_EXTERN void Jsi_TreeDelete(Jsi_Tree *treePtr); /*STUB = 267*/\nJSI_EXTERN void Jsi_TreeClear(Jsi_Tree *treePtr); /*STUB = 268*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeObjSetValue(Jsi_Obj* obj, const char *key, Jsi_Value *val, int isstrkey); /*STUB = 269*/\nJSI_EXTERN Jsi_Value*     Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey); /*STUB = 270*/\nJSI_EXTERN void* Jsi_TreeValueGet(Jsi_TreeEntry *hPtr); /*STUB = 271*/\nJSI_EXTERN void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value); /*STUB = 272*/\nJSI_EXTERN void* Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr); /*STUB = 273*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryFind(Jsi_Tree *treePtr, const void *key); /*STUB = 274*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew); /*STUB = 275*/\nJSI_EXTERN int Jsi_TreeEntryDelete(Jsi_TreeEntry *entryPtr); /*STUB = 276*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchFirst(Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey); /*STUB = 277*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr); /*STUB = 278*/\nJSI_EXTERN void Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr); /*STUB = 279*/\nJSI_EXTERN int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags); /*STUB = 280*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value); /*STUB = 281*/\nJSI_EXTERN void* Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags); /*STUB = 282*/\nJSI_EXTERN bool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key); /*STUB = 283*/\nJSI_EXTERN uint Jsi_TreeSize(Jsi_Tree *treePtr); /*STUB = 284*/ \nJSI_EXTERN Jsi_Tree* Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 285*/\nJSI_EXTERN Jsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *hashPtr, Jsi_Value **ret, int flags); /*STUB = 286*/\n/* -- */\n\n\n/* --LIST-- */\ntypedef struct Jsi_List {\n    uint sig;\n    int numEntries;\n    Jsi_ListEntry *head;\n    Jsi_ListEntry *tail;\n    Jsi_MapOpts opts;\n} Jsi_List;\n\ntypedef struct Jsi_ListEntry {\n    uint sig;\n    Jsi_Map_Type typ;    \n    struct Jsi_ListEntry *next;\n    struct Jsi_ListEntry *prev;\n    Jsi_List *list;\n    void *value;\n} Jsi_ListEntry;\n\ntypedef struct Jsi_ListSearch {\n    int flags;\n    Jsi_List *tablePtr;\n    unsigned long nextIndex; \n    Jsi_ListEntry *nextEntryPtr;\n} Jsi_ListSearch;\n\nJSI_EXTERN Jsi_List* Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc); /*STUB = 287*/\nJSI_EXTERN Jsi_RC Jsi_ListConf(Jsi_List *list, Jsi_MapOpts *opts, bool set); /*STUB = 288*/\nJSI_EXTERN void Jsi_ListDelete(Jsi_List *list); /*STUB = 289*/\nJSI_EXTERN void Jsi_ListClear(Jsi_List *list); /*STUB = 290*/\n//#define Jsi_ListSet(l, before, value) Jsi_ListPush(l, before, Jsi_ListEntryNew(l, value))\n//#define Jsi_ListGet(l, le) (le)->value \n//#define Jsi_ListKeyGet(le) (le)\n//#define Jsi_ListKeysDump(interp, list, ret, flags) JSI_ERROR\nJSI_EXTERN void* Jsi_ListValueGet(Jsi_ListEntry *list); /*STUB = 291*/\nJSI_EXTERN void Jsi_ListValueSet(Jsi_ListEntry *list, const void *value); /*STUB = 292*/\n//#define Jsi_ListEntryFind(l, le) (le)\nJSI_EXTERN Jsi_ListEntry* Jsi_ListEntryNew(Jsi_List *list, const void *value, Jsi_ListEntry *before); /*STUB = 293*/\nJSI_EXTERN int Jsi_ListEntryDelete(Jsi_ListEntry *entry); /*STUB = 294*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *search, int flags); /*STUB = 295*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *search); /*STUB = 296*/\nJSI_EXTERN uint Jsi_ListSize(Jsi_List *list); /*STUB = 297*/\n/* end of hash-compat functions. */\n\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *entry, Jsi_ListEntry *before); /*STUB = 298*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *entry); /*STUB = 299*/\n#define Jsi_ListPushFront(list,entry)   Jsi_ListPush(list, entry, list->head)\n#define Jsi_ListPushBack(list,entry)    Jsi_ListPush(list, entry, NULL)\n#define Jsi_ListPushFrontNew(list,v)    Jsi_ListEntryNew(list, v, list->head)\n#define Jsi_ListPushBackNew(list,v)     Jsi_ListEntryNew(list, v, NULL)\n#define Jsi_ListPopFront(list)          Jsi_ListPop(list, list->head)\n#define Jsi_ListPopBack(list)           Jsi_ListPop(list, list->tail)\n#define Jsi_ListEntryNext(entry)        (entry)->next \n#define Jsi_ListEntryPrev(entry)        (entry)->prev\n#define Jsi_ListGetFront(list)          (list)->head\n#define Jsi_ListGetBack(list)           (list)->tail\n\n/* -- */\n\n\n/* --STACK-- */\ntypedef struct {\n    int len;\n    int maxlen;\n    void **vector;\n} Jsi_Stack;\n\nJSI_EXTERN Jsi_Stack* Jsi_StackNew(void); /*STUB = 300*/\nJSI_EXTERN void Jsi_StackFree(Jsi_Stack *stack); /*STUB = 301*/\nJSI_EXTERN int Jsi_StackSize(Jsi_Stack *stack); /*STUB = 302*/\nJSI_EXTERN void Jsi_StackPush(Jsi_Stack *stack, void *element); /*STUB = 303*/\nJSI_EXTERN void* Jsi_StackPop(Jsi_Stack *stack); /*STUB = 304*/\nJSI_EXTERN void* Jsi_StackPeek(Jsi_Stack *stack); /*STUB = 305*/\nJSI_EXTERN void* Jsi_StackUnshift(Jsi_Stack *stack); /*STUB = 306*/\nJSI_EXTERN void* Jsi_StackHead(Jsi_Stack *stack); /*STUB = 307*/\nJSI_EXTERN void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeFunc); /*STUB = 308*/\n/* -- */\n\n/* --MAP-- */\ntypedef struct Jsi_MapSearch {\n    Jsi_Map_Type typ;\n    union {\n        Jsi_TreeSearch tree;\n        Jsi_HashSearch hash;\n        Jsi_ListSearch list;\n    } v;\n} Jsi_MapSearch;\n\nJSI_EXTERN Jsi_Map* Jsi_MapNew(Jsi_Interp *interp, Jsi_Map_Type mapType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc); /*STUB = 309*/\nJSI_EXTERN Jsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set); /*STUB = 310*/\nJSI_EXTERN void Jsi_MapDelete (Jsi_Map *mapPtr); /*STUB = 311*/\nJSI_EXTERN void Jsi_MapClear (Jsi_Map *mapPtr); /*STUB = 312*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value); /*STUB = 313*/\nJSI_EXTERN void* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags); /*STUB = 314*/\nJSI_EXTERN void* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags); /*STUB = 315*/\nJSI_EXTERN Jsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags); /*STUB = 316*/\nJSI_EXTERN void* Jsi_MapValueGet(Jsi_MapEntry *h); /*STUB = 317*/\nJSI_EXTERN void Jsi_MapValueSet(Jsi_MapEntry *h, const void *value); /*STUB = 318*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key); /*STUB = 319*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew); /*STUB = 320*/\nJSI_EXTERN int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr); /*STUB = 321*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags); /*STUB = 322*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *srchPtr); /*STUB = 323*/\nJSI_EXTERN void Jsi_MapSearchDone (Jsi_MapSearch *searchPtr);  /*STUB = 324*/\nJSI_EXTERN uint Jsi_MapSize(Jsi_Map *mapPtr); /*STUB = 325*/\n\n\n// Define typed wrappers for 5 main Map functions: Set, Get, KeyGet, EntryFind, EntryNew\n#define JSI_MAP_EXTN(Prefix, keyType, valType) \\\nJSI_EXTERN Jsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value); \\\nJSI_EXTERN valType Prefix ## _Get(Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN keyType Prefix ## _KeyGet(Jsi_MapEntry *h); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew);\n\n#define JSI_MAP_DEFN(Prefix, keyType, valType) \\\nJsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value) { return Jsi_MapSet(mapPtr, (void*)key, (void*)value); } \\\nvalType Prefix ## _Get(Jsi_Map *mapPtr, keyType key) { return (valType)Jsi_MapGet(mapPtr, (void*)key); } \\\nkeyType Prefix ## _KeyGet(Jsi_MapEntry *h) { return (keyType)Jsi_MapKeyGet(h); } \\\nJsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key) { return  Jsi_MapEntryFind(mapPtr, (void*)key); } \\\nJsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew) { return  Jsi_MapEntryNew(mapPtr, (void*)key, isNew); }\n   \n/* -- */\n\n\n/* --OPTIONS-- */\ntypedef Jsi_RC (Jsi_OptionParseProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value *value, const char *str, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value **retValue, Jsi_DString *retStr, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatStringProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_DString **retValue, void *record);\ntypedef void (Jsi_OptionFreeProc) (Jsi_Interp *interp, Jsi_OptionSpec *spec, void *ptr);\n\ntypedef Jsi_RC (Jsi_OptionBitOp)(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet);\n\ntypedef struct {\n    const char *name;\n    Jsi_OptionParseProc *parseProc;\n    Jsi_OptionFormatProc *formatProc;\n    Jsi_OptionFreeProc *freeProc;\n    const char *help;\n    const char *info;\n    void* data;\n} Jsi_OptionCustom;\n\ntypedef enum {\n    JSI_OPTION_BOOL=1,\n    JSI_OPTION_INT8,  JSI_OPTION_INT16,  JSI_OPTION_INT32,  JSI_OPTION_INT64,\n    JSI_OPTION_UINT8, JSI_OPTION_UINT16, JSI_OPTION_UINT32, JSI_OPTION_UINT64,\n    JSI_OPTION_FLOAT,\n    JSI_OPTION_DOUBLE,    // Same as NUMBER when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_LDOUBLE,   // A long double\n    JSI_OPTION_STRBUF,    // Fixed size string buffer.\n    JSI_OPTION_TIME_W,    // Jsi_Wide: milliseconds since Jan 1, 1970.\n    JSI_OPTION_TIME_D,    // double: milliseconds since Jan 1, 1970.\n    // Non-portable fields start here\n    JSI_OPTION_TIME_T,    // time_t: seconds since Jan 1, 1970. \n    JSI_OPTION_SIZE_T,\n    JSI_OPTION_SSIZE_T,\n    JSI_OPTION_INTPTR_T,  // Int big enough to store a pointer.\n    JSI_OPTION_UINTPTR_T, \n    JSI_OPTION_NUMBER,    // Same as DOUBLE when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_INT, JSI_OPTION_UINT,\n    JSI_OPTION_LONG, JSI_OPTION_ULONG, JSI_OPTION_SHORT, JSI_OPTION_USHORT,\n    JSI_OPTION_STRING, JSI_OPTION_DSTRING, JSI_OPTION_STRKEY,\n    JSI_OPTION_VALUE, JSI_OPTION_VAR, JSI_OPTION_OBJ, JSI_OPTION_ARRAY, JSI_OPTION_REGEXP,\n    JSI_OPTION_FUNC,      // Note: .data can contain string args to check\n    JSI_OPTION_USEROBJ,   // Note: .data can contain string obj name to check\n    JSI_OPTION_CUSTOM,    // Note: set .custom, .data, etc.\n    JSI_OPTION_END\n} Jsi_OptionId;\n\ntypedef const char* Jsi_Strkey;\n#ifdef __cplusplus\ntypedef void* Jsi_Strbuf;\n#else\ntypedef char Jsi_Strbuf[];\n#endif\n\ntypedef union {\n    bool           BOOL;\n    int8_t         INT8;\n    int16_t        INT16;\n    int32_t        INT32;\n    int64_t        INT64;\n    uint8_t        UINT8;\n    uint16_t       UINT16;\n    uint32_t       UINT32;\n    uint64_t       UINT64;\n    float          FLOAT;\n    double         DOUBLE;\n    ldouble        LDOUBLE;\n    Jsi_Number     NUMBER;\n    char*          STRBUF;\n    time_d         TIME_D;\n    time_w         TIME_W;\n    time_t         TIME_T;\n    size_t         SIZE_T;\n    ssize_t        SSIZE_T;\n    intptr_t       INTPTR_T;\n    uintptr_t      UINTPTR_T;\n    int            INT;\n    uint           UINT;\n    long           LONG;\n    ulong          ULONG;\n    short          SHORT;\n    ushort         USHORT;\n    Jsi_DString    DSTRING;\n    const char*    STRKEY;\n    Jsi_Value*     STRING;\n    Jsi_Value*     VALUE;\n    Jsi_Value*     VAR;\n    Jsi_Value*     OBJ;\n    Jsi_Value*     ARRAY;\n    Jsi_Value*     REGEXP;\n    Jsi_Value*     FUNC;\n    Jsi_Value*     USEROBJ;\n    void*          CUSTOM;\n    Jsi_csgset*    OPT_BITS;\n    struct Jsi_OptionSpec* OPT_CARRAY;\n} Jsi_OptionValue;\n\ntypedef union { /* Field used at compile-time by JSI_OPT() to provide type checking for the var */\n    bool           *BOOL;\n    int8_t         *INT8;\n    int16_t        *INT16;\n    int32_t        *INT32;\n    int64_t        *INT64;\n    uint8_t        *UINT8;\n    uint16_t       *UINT16;\n    uint32_t       *UINT32;\n    uint64_t       *UINT64;\n    float          *FLOAT;\n    double         *DOUBLE;\n    ldouble        *LDOUBLE;\n    Jsi_Number     *NUMBER;\n#ifdef __cplusplus\n    Jsi_Strbuf      STRBUF;\n#else\n    Jsi_Strbuf      *STRBUF;\n#endif\n    time_t         *TIME_T;\n    time_w         *TIME_W;\n    time_d         *TIME_D;\n    size_t         *SIZE_T;\n    ssize_t        *SSIZE_T;\n    intptr_t       *INTPTR_T;\n    uintptr_t      *UINTPTR_T;\n    int            *INT;\n    uint           *UINT;\n    long           *LONG;\n    ulong          *ULONG;\n    short          *SHORT;\n    ushort         *USHORT;\n    Jsi_DString    *DSTRING;\n    const char*    *STRKEY;\n    Jsi_Value*     *VALUE;\n    Jsi_Value*     *STRING;\n    Jsi_Value*     *VAR;\n    Jsi_Value*     *OBJ;\n    Jsi_Value*     *ARRAY;\n    Jsi_Value*     *REGEXP;\n    Jsi_Value*     *FUNC;\n    Jsi_Value*     *USEROBJ;\n    void           *CUSTOM;\n    Jsi_csgset     *OPT_BITS;\n    struct Jsi_OptionSpec *OPT_CARRAY;\n} Jsi_OptionInitVal;\n\ntypedef struct {\n    Jsi_Sig sig;\n    Jsi_OptionId id;\n    const char *idName, *cName;\n    int size;\n    const char *fmt, *xfmt, *sfmt, *help;\n    Jsi_OptionInitVal init;\n    Jsi_Wide flags;\n    Jsi_Wide user;\n    const char *userData;       /* User data. */ \\\n    uchar *extData;             /* Extension data. */\n    uchar *extra;\n    Jsi_HashEntry *hPtr;\n} Jsi_OptionTypedef;\n\nstruct Jsi_OptionSpec {\n    Jsi_Sig sig;                /* Signature field. */\n    Jsi_OptionId id;\n    const char *name;           /* The field name. */\n    uint offset;                /* Jsi_Offset of field. */\n    uint size;                  /* The sizeof() of field. */\n    Jsi_OptionInitVal init;     /* Initialization value */\n    const char *help;           /* A short one-line help string, without newlines. */\n    Jsi_Wide flags;             /* Lower 32 bits: the JSI_OPTS_* flags below. Upper 32 for custom/other. */\n    Jsi_OptionCustom *custom;   /* Custom handler. */\n    void *data;                 /* User data for custom options: eg. the bit for BOOLBIT. */\n    const char *info;           /* Longer command description. Use JSI_DETAIL macro to allow compile-out.*/\n    const char *tname;          /* Type name for field or external name used by the DB interface. */\n    Jsi_Wide value;             /* Value field. */\n    uint32_t bits;              /* Size of bitfield */\n    uint32_t boffset;           /* Bit offset of field (or struct) */\n    uint32_t idx;               /* Index (of field) */\n    uint32_t ssig;              /* Signature (for struct) */\n    uint32_t crc;               /* Crc (for struct) */\n    uint32_t arrSize;           /* Size of array */\n    const char *userData;       /* User data. */\n    uchar *extData;             /* Extension data. */\n    uchar *extra;               /* Extra pointer (currently unused). */\n    const Jsi_OptionTypedef *type;\n};\n\n/* JSI_OPT is a macro used for option definitions, eg:\n * \n *      typedef struct { int debug; int bool; } MyStruct;\n * \n *      Jsi_OptionSpec MyOptions[] = {\n *          JSI_OPT(BOOL,  MyStruct,  debug ),\n *          JSI_OPT(INT,   MyStruct,  max,   .help=\"Max value\"),\n *          JSI_OPT_END(   MyStruct, .help=\"My first struct\" )\n *      }\n*/\n\n#define JSI_OPT_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam)}, ##__VA_ARGS__ }\n\n#define JSI_OPT_END_(s, strct, ...) { .sig=s, .id=JSI_OPTION_END, .name=#strct, .offset=__LINE__, .size=sizeof(strct), \\\n      .init={.CUSTOM=(void*)__FILE__}, ##__VA_ARGS__}\n\n#define JSI_OPT_BITS_(s, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=0, .size=0, \\\n        .init={.OPT_BITS=&bsget}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchBitfield, .data=bdata,\\\n        .info=0, .tname=#nam, .value=0, .bits=0, .boffset=0, .idx=fidx }\n\n#define JSI_OPT_CARRAY_(s, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n        .init={.OPT_CARRAY=aropt}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchCArray, .data=0,\\\n        .info=0, .tname=tnam, .value=0, .bits=0, .boffset=0, .idx=0, .ssig=0, .crc=0, .arrSize=asiz, .extData=sinit, .extra=0 }\n\n#define JSI_OPT_CARRAY_ITEM_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=0, .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam[0])}, ##__VA_ARGS__ }\n\n#define JSI_OPT(typ, strct, nam, ...) JSI_OPT_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__) \n#define JSI_OPT_END(strct, ...) JSI_OPT_END_(JSI_SIG_OPTS, strct, ##__VA_ARGS__)\n#define JSI_OPT_BITS(strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) JSI_OPT_BITS_(JSI_SIG_OPTS, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata)\n#define JSI_OPT_CARRAY(strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) JSI_OPT_CARRAY_(JSI_SIG_OPTS, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit)\n#define JSI_OPT_CARRAY_ITEM(typ, strct, nam, ...) JSI_OPT_CARRAY_ITEM_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__)\n\n#define JSI_OPT_END_IDX(opt) ((sizeof(opt)/sizeof(opt[0]))-1)\n\n/* builtin handler for Custom. */\n#define Jsi_Opt_SwitchEnum          (Jsi_OptionCustom*)0x1 /* An Enum: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchBitset        (Jsi_OptionCustom*)0x2 /* Bits in an int: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchSuboption     (Jsi_OptionCustom*)0x3 /* Sub-structs: subspec is in .data={...} */\n#define Jsi_Opt_SwitchBitfield      (Jsi_OptionCustom*)0x4 /* Struct bitfields: used by \"jsish -c\" */\n#define Jsi_Opt_SwitchValueVerify   (Jsi_OptionCustom*)0x5 /* Callback to verify Jsi_Value* correctness in .data=func. */\n#define Jsi_Opt_SwitchCArray        (Jsi_OptionCustom*)0x6 /* C Array described in .data=type. */\n#define Jsi_Opt_SwitchNull          (Jsi_OptionCustom*)0x7 /* Set is ignored, and get returns null */\n#define Jsi_Opt_SwitchParentFunc    (Jsi_OptionCustom*)0x8 /* Name of a func in parent. Sig string is in .data*/\n\nenum {\n    /* Jsi_OptionsProcess() flags */\n    JSI_OPTS_PREFIX         =   (1<<27), /* Allow matching unique prefix of object members. */\n    JSI_OPTS_IS_UPDATE      =   (1<<28), /* This is an update/conf (do not reset the specified flags) */\n    JSI_OPTS_IGNORE_EXTRA   =   (1<<29), /* Ignore extra members not found in spec. */\n    JSI_OPTS_FORCE_STRICT   =   (1<<30), /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */\n    JSI_OPTS_VERBOSE        =   (1<<31), /* Dump verbose options */\n    JSI_OPTS_INCR           =   (1<<7),  /* Options is an increment. */\n\n    /* Jsi_OptionSpec flags. */\n    JSI_OPT_IS_SPECIFIED    =   (1<<0),   /* User set the option. */\n    JSI_OPT_INIT_ONLY       =   (1<<1),   /* Allow set only at init, disallowing update/conf. */\n    JSI_OPT_READ_ONLY       =   (1<<2),   /* Value can not be set. */\n    JSI_OPT_NO_DUPVALUE     =   (1<<3),   /* Values are not to be duped. */\n    JSI_OPT_NO_CLEAR        =   (1<<4),   /* Values are not to be cleared: watch for memory leaks */\n    JSI_OPT_REQUIRED        =   (1<<5),  /* Field must be specified (if not IS_UPDATE). */\n    JSI_OPT_PASS2           =   (1<<6),   /* Options to be processed only on pass2. */\n    JSI_OPT_DB_DIRTY        =   (1<<8),   /* Used to limit DB updates. */\n    JSI_OPT_DB_IGNORE       =   (1<<9),   /* Field is not to be used for DB. */\n    JSI_OPT_DB_ROWID        =   (1<<10),  /* Field used by DB to store rowid. */\n    JSI_OPT_CUST_NOCASE     =   (1<<11),  /* Ignore case (eg. for ENUM and BITSET). */\n    JSI_OPT_FORCE_INT       =   (1<<12),  /* Force int instead of text for enum/bitset. */\n    JSI_OPT_BITSET_ENUM     =   (1<<13),  /* Mark field as a bitset/enum map custom field. */\n    JSI_OPT_TIME_DATEONLY   =   (1<<14),  /* Time field is date only. */\n    JSI_OPT_TIME_TIMEONLY   =   (1<<15),  /* Time field is time only. */\n    JSI_OPT_IS_BITS         =   (1<<16),  /* Is a C bit-field. */\n    JSI_OPT_FMT_STRING      =   (1<<17),  /* Format value (eg. time) as string. */\n    JSI_OPT_FMT_NUMBER      =   (1<<18),  /* Format value (eg. enum) as number. */\n    JSI_OPT_FMT_HEX         =   (1<<19),  /* Format number in hex. */\n    JSI_OPT_STRICT          =   (1<<20),  /* Strict mode. */\n    JSI_OPT_LOCKSAFE        =   (1<<21),  /* Field may not be configured when isSafe. */\n    JSI_OPT_COERCE          =   (1<<22),  /* Coerce input value to required type. */\n    JSI_OPT_NO_SIG          =   (1<<23),  /* No signature. */\n    JSI_OPT_ENUM_SPEC       =   (1<<24),  /* Enum has spec rather than a list of strings. */\n    JSI_OPT_ENUM_UNSIGNED   =   (1<<25),  /* Enum value is unsigned. */\n    JSI_OPT_ENUM_EXACT      =   (1<<26),  /* Enum must be an exact match. */\n    JSI_OPTIONS_USER_FIRSTBIT  =   48,    /* First bit of user flags: the lower 48 bits are internal. */\n};\n\nJSI_EXTERN const Jsi_OptionTypedef* Jsi_OptionTypeInfo(Jsi_OptionId typ); /*STUB = 326*/\nJSI_EXTERN Jsi_OptionTypedef* Jsi_TypeLookup(Jsi_Interp* interp, const char *typ); /*STUB = 327*/\nJSI_EXTERN int Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Wide flags); /*STUB = 328*/\nJSI_EXTERN int Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags); /*STUB = 329*/\nJSI_EXTERN Jsi_RC Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Value **ret, Jsi_Wide flags); /*STUB = 330*/\nJSI_EXTERN void Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Wide flags); /*STUB = 331*/\nJSI_EXTERN Jsi_RC Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags); /*STUB = 332*/\nJSI_EXTERN Jsi_RC Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* data, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags); /*STUB = 333*/\nJSI_EXTERN Jsi_RC Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value** ret, Jsi_Wide flags); /*STUB = 334*/\nJSI_EXTERN int Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *pattern, ...) /*STUB = 335*/ __attribute__((sentinel));\nJSI_EXTERN bool Jsi_OptionsValid(Jsi_Interp *interp, Jsi_OptionSpec* spec);  /*STUB = 336*/\nJSI_EXTERN const char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema);\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags); /*STUB = 337*/\nJSI_EXTERN Jsi_Value* Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *optionName, void *data, int offset); /*STUB = 338*/\nJSI_EXTERN Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust); /*STUB = 339*/\n/* Create a duplicate of static specs.   Use this for threaded access to Jsi_OptionsChanged(). */\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs); /*STUB = 340*/\nJSI_EXTERN const Jsi_OptionSpec* Jsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs);  /*STUB = 341*/\n/* -- */\n\n\n/* --THREADS/MUTEX-- */\nJSI_EXTERN Jsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 342*/\nJSI_EXTERN void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 343*/\nJSI_EXTERN void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 344*/\nJSI_EXTERN Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags); /*STUB = 345*/\nJSI_EXTERN void* Jsi_CurrentThread(void); /*STUB = 346*/\nJSI_EXTERN void* Jsi_InterpThread(Jsi_Interp *interp); /*STUB = 347*/\n/* -- */\n\n\n/* --LOGGING-- */\n#define Jsi_LogBug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_BUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogError(fmt,...) Jsi_LogMsg(interp, JSI_LOG_ERROR, fmt, ##__VA_ARGS__)\n#define Jsi_LogParse(fmt,...) Jsi_LogMsg(interp, JSI_LOG_PARSE, fmt, ##__VA_ARGS__)\n#define Jsi_LogWarn(fmt,...) Jsi_LogMsg(interp, JSI_LOG_WARN, fmt, ##__VA_ARGS__)\n#define Jsi_LogInfo(fmt,...) Jsi_LogMsg(interp, JSI_LOG_INFO, fmt, ##__VA_ARGS__)\n#define Jsi_LogDebug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_DEBUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogTrace(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TRACE, fmt, ##__VA_ARGS__)\n#define Jsi_LogTest(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TEST, fmt, ##__VA_ARGS__)\n\nJSI_EXTERN Jsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint level, const char *format,...)  /*STUB = 348*/ __attribute__((format (printf,3,4)));\n\n\n/* --EVENTS-- */\ntypedef struct {\n    Jsi_Sig sig;\n    uint id;\n    int evType;                 /* Is signal handler. */\n    int sigNum;\n    int once;                   /* Execute once */\n    long initialms;             /* initial relative timer value */\n    long when_sec;              /* seconds */\n    long when_ms;               /* milliseconds */\n    bool busy;                  /* In event callback. */\n    uint count;                 /* Times executed */\n    Jsi_HashEntry *hPtr;\n    Jsi_Value *funcVal;         /* JS Function to call. */\n    Jsi_EventHandlerProc *handler;  /* C-function handler. */\n    void *data;\n} Jsi_Event;\n\nJSI_EXTERN Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data); /*STUB = 349*/\nJSI_EXTERN void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event); /*STUB = 350*/\nJSI_EXTERN int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents); /*STUB = 351*/\n/* -- */\n\n\n/* --JSON-- */\n#define JSI_JSON_DECLARE(p, tokens, maxsz) \\\n    Jsi_JsonParser p = {0}; \\\n    Jsi_JsonTok tokens[maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT]; \\\n    Jsi_JsonInit(&p, tokens, maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT)\n\ntypedef enum {\n    JSI_JTYPE_PRIMITIVE = 0,\n    JSI_JTYPE_OBJECT = 1,\n    JSI_JTYPE_ARRAY = 2,\n    JSI_JTYPE_STRING = 3,\n    JSI_JTYPE_INVALID=-1\n} Jsi_JsonTypeEnum;\n\ntypedef enum {\n    JSI_JSON_ERR_NOMEM = -1,\n    JSI_JSON_ERR_INVAL = -2,\n    JSI_JSON_ERR_PART = -3,\n    JSI_JSON_ERR_NONE = 0\n} Jsi_JsonErrEnum;\n\ntypedef struct {\n    Jsi_JsonTypeEnum type;\n    int start;\n    int end;\n    uint size;\n    int parent;\n} Jsi_JsonTok;\n\ntypedef struct {\n    uint pos;           /* offset in the JSON string */\n    uint toknext;       /* next token to allocate */\n    int toksuper;       /* superior token node, e.g parent object or array */\n    Jsi_JsonTok *tokens, *static_tokens;\n    uint num_tokens;\n    int no_malloc;      /* Disable parser dynamic growth tokens array. */\n    bool strict;/* Strict parsing. */\n    Jsi_Wide flags;\n    const char *errStr;\n    void *reserved[4];     /* Reserved for future */\n} Jsi_JsonParser;\n\n\nJSI_EXTERN void Jsi_JsonInit(Jsi_JsonParser *parser, Jsi_JsonTok *static_tokens, uint num_tokens); /*STUB = 352*/\nJSI_EXTERN void Jsi_JsonReset(Jsi_JsonParser *parser); /*STUB = 353*/\nJSI_EXTERN void Jsi_JsonFree(Jsi_JsonParser *parser); /*STUB = 354*/\nJSI_EXTERN Jsi_JsonErrEnum Jsi_JsonParse(Jsi_JsonParser *parser, const char *js); /*STUB = 355*/\nJSI_EXTERN Jsi_JsonTok* Jsi_JsonGetToken(Jsi_JsonParser *parser, uint index); /*STUB = 356*/\nJSI_EXTERN Jsi_JsonTypeEnum Jsi_JsonGetType(Jsi_JsonParser *parser, uint index); /*STUB = 357*/\nJSI_EXTERN int Jsi_JsonTokLen(Jsi_JsonParser *parser, uint index); /*STUB = 358*/\nJSI_EXTERN const char* Jsi_JsonGetTokstr(Jsi_JsonParser *parser, const char *js, uint index, uint *len); /*STUB = 359*/\nJSI_EXTERN const char* Jsi_JsonGetTypename(int type); /*STUB = 360*/\nJSI_EXTERN const char* Jsi_JsonGetErrname(int code); /*STUB = 361*/\nJSI_EXTERN void Jsi_JsonDump(Jsi_JsonParser *parser, const char *js); /*STUB = 362*/\n/* -- */\n\n\n/* --VFS-- */\nstruct Jsi_LoadHandle; struct Jsi_LoadHandle;\n\ntypedef struct Jsi_LoadHandle Jsi_LoadHandle;\ntypedef struct stat Jsi_StatBuf;\ntypedef struct dirent Jsi_Dirent;\n\ntypedef int (Jsi_FSStatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSAccessProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef int (Jsi_FSChmodProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef Jsi_Channel (Jsi_FSOpenProc) (Jsi_Interp *interp, Jsi_Value* path, const char* modes);\ntypedef int (Jsi_FSLstatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSCreateDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path);\ntypedef int (Jsi_FSRemoveProc) (Jsi_Interp *interp, Jsi_Value* path, int flags);\ntypedef int (Jsi_FSCopyDirectoryProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSCopyFileProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef int (Jsi_FSRemoveDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path, int recursive, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSRenameProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef Jsi_Value * (Jsi_FSListVolumesProc) (Jsi_Interp *interp);\ntypedef char* (Jsi_FSRealPathProc) (Jsi_Interp *interp, Jsi_Value* path, char *newPath);\ntypedef int (Jsi_FSLinkProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType);\ntypedef int (Jsi_FSReadlinkProc)(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size);\ntypedef int (Jsi_FSReadProc)(Jsi_Channel chan, char *buf, int size);\ntypedef int (Jsi_FSGetcProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSEofProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSTruncateProc)(Jsi_Channel chan, uint len);\ntypedef int (Jsi_FSUngetcProc)(Jsi_Channel chan, int ch);\ntypedef char *(Jsi_FSGetsProc)(Jsi_Channel chan, char *s, int size);\ntypedef int (Jsi_FSPutsProc)(Jsi_Channel chan, const char* str);\ntypedef int (Jsi_FSWriteProc)(Jsi_Channel chan, const char *buf, int size);\ntypedef int (Jsi_FSFlushProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSSeekProc)(Jsi_Channel chan, Jsi_Wide offset, int mode);\ntypedef int (Jsi_FSTellProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSCloseProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSRewindProc)(Jsi_Channel chan);\ntypedef bool (Jsi_FSPathInFilesystemProc) (Jsi_Interp *interp, Jsi_Value* path,void* *clientDataPtr);\ntypedef int (Jsi_FSScandirProc)(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,\n  int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**));\n\ntypedef struct Jsi_Filesystem {\n    const char *typeName;\n    int structureLength;    \n    int version;\n    Jsi_FSPathInFilesystemProc *pathInFilesystemProc;\n    Jsi_FSRealPathProc *realpathProc;\n    Jsi_FSStatProc *statProc;\n    Jsi_FSLstatProc *lstatProc;\n    Jsi_FSAccessProc *accessProc;\n    Jsi_FSChmodProc *chmodProc;\n    Jsi_FSOpenProc *openProc;\n    Jsi_FSScandirProc *scandirProc;\n    Jsi_FSReadProc *readProc;\n    Jsi_FSWriteProc *writeProc;\n    Jsi_FSGetsProc *getsProc;\n    Jsi_FSGetcProc *getcProc;\n    Jsi_FSUngetcProc *ungetcProc;\n    Jsi_FSPutsProc *putsProc;\n    \n    Jsi_FSFlushProc *flushProc;\n    Jsi_FSSeekProc *seekProc;\n    Jsi_FSTellProc *tellProc;\n    Jsi_FSEofProc *eofProc;\n    Jsi_FSTruncateProc *truncateProc;\n    Jsi_FSRewindProc *rewindProc;\n    Jsi_FSCloseProc *closeProc;\n    Jsi_FSLinkProc *linkProc;\n    Jsi_FSReadlinkProc *readlinkProc;\n    Jsi_FSListVolumesProc *listVolumesProc;\n    Jsi_FSCreateDirectoryProc *createDirectoryProc;\n    Jsi_FSRemoveProc *removeProc;\n    Jsi_FSRenameProc *renameProc;\n    void *reserved[10];     /* Reserved for future */\n} Jsi_Filesystem;\n\ntypedef struct Jsi_Chan {\n    FILE *fp;\n    const char *fname;  /* May be set by fs or by source */\n    Jsi_Filesystem *fsPtr;\n    int isNative;\n    int flags;\n    char modes[JSI_FSMODESIZE];\n    void *data;\n    void *reserved[4];     /* Reserved for future */\n    ssize_t resInt[2];\n} Jsi_Chan;\n\nJSI_EXTERN Jsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data); /*STUB = 363*/\nJSI_EXTERN Jsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr); /*STUB = 364*/\nJSI_EXTERN Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name); /*STUB = 365*/\nJSI_EXTERN char* Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr); /*STUB = 366*/\nJSI_EXTERN int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 367*/\nJSI_EXTERN int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 368*/\nJSI_EXTERN int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 369*/\nJSI_EXTERN int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags); /*STUB = 370*/\nJSI_EXTERN int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst); /*STUB = 371*/\nJSI_EXTERN int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 372*/\nJSI_EXTERN Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString); /*STUB = 373*/\nJSI_EXTERN int Jsi_Eof(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 374*/\nJSI_EXTERN int Jsi_Close(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 375*/\nJSI_EXTERN int Jsi_Read(Jsi_Interp *interp, Jsi_Channel chan, char *bufPtr, int toRead); /*STUB = 376*/\nJSI_EXTERN int Jsi_Write(Jsi_Interp *interp, Jsi_Channel chan, const char *bufPtr, int slen); /*STUB = 377*/\nJSI_EXTERN Jsi_Wide Jsi_Seek(Jsi_Interp *interp, Jsi_Channel chan, Jsi_Wide offset, int mode); /*STUB = 378*/\nJSI_EXTERN Jsi_Wide Jsi_Tell(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 379*/\nJSI_EXTERN int Jsi_Truncate(Jsi_Interp *interp, Jsi_Channel chan, uint len); /*STUB = 380*/\nJSI_EXTERN Jsi_Wide Jsi_Rewind(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 381*/\nJSI_EXTERN int Jsi_Flush(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 382*/\nJSI_EXTERN int Jsi_Getc(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 383*/\nJSI_EXTERN int Jsi_Printf(Jsi_Interp *interp, Jsi_Channel chan, const char *fmt, ...) /*STUB = 384*/ __attribute__((format (printf,3,4))); \nJSI_EXTERN int Jsi_Ungetc(Jsi_Interp *interp, Jsi_Channel chan, int ch); /*STUB = 385*/\nJSI_EXTERN char* Jsi_Gets(Jsi_Interp *interp, Jsi_Channel chan, char *s, int size); /*STUB = 386*/\nJSI_EXTERN int Jsi_Puts(Jsi_Interp *interp, Jsi_Channel chan, const char *str, int size); /*STUB = 387*/\n\ntypedef int (Jsi_ScandirFilter)(const Jsi_Dirent *);\ntypedef int (Jsi_ScandirCompare)(const Jsi_Dirent **, const Jsi_Dirent**);\nJSI_EXTERN int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist, Jsi_ScandirFilter *filter, Jsi_ScandirCompare *compare ); /*STUB = 388*/\nJSI_EXTERN int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName, const char *newValue); /*STUB = 389*/\nJSI_EXTERN char* Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *path, char *newname); /*STUB = 390*/\nJSI_EXTERN int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len); /*STUB = 391*/\nJSI_EXTERN Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id); /*STUB = 392*/\nJSI_EXTERN bool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 393*/\nJSI_EXTERN int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ); /*STUB = 394*/\nJSI_EXTERN int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 395*/\n\nJSI_EXTERN Jsi_RC Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr); /*STUB = 396*/\nJSI_EXTERN Jsi_RC Jsi_DllLookup(Jsi_Interp *interp, const char *module, const char *name, void **ptr); /*STUB = 404*/\nJSI_EXTERN Jsi_RC Jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName, bool noInit); /*STUB = 405*/\nJSI_EXTERN int Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir);  /*STUB = 397*/\n\n/* -- */\n\n\n\n/* --DATABASE-- */\n\nJSI_EXTERN Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags); /*STUB = 398*/\nJSI_EXTERN void* Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* db); /*STUB = 399*/\n\n/* -- */\n\n\n/* --CData-- */\n\n#define  JSI_CDATA_OPTION_CHANGED(name) \\\n        (vrPtr->spec && Jsi_OptionsChanged(interp, vrPtr->spec, #name, NULL))\n#define  JSI_CDATA_OPTION_RESET(name) \\\n        (cmdPtr->queryOpts.mode && !options->name && JSI_CDATA_OPTION_CHANGED(name))\n \ntypedef struct Jsi_CData_Static {\n    const char* name;\n    Jsi_StructSpec* structs;\n    Jsi_EnumSpec* enums;\n    Jsi_VarSpec *vars;\n    Jsi_OptionTypedef* types;\n    struct Jsi_CData_Static* nextPtr;\n} Jsi_CData_Static;\n\n/* Struct for Carray to bind Data/Option pairs to individual SQLite binding chars. */\ntypedef struct Jsi_CDataDb {\n#define JSI_DBDATA_FIELDS \\\n    Jsi_StructSpec *sf;     /* Struct fields for data. */ \\\n    void *data;             /* Data pointer for array/map */ \\\n    uint arrSize;           /* If an array, number of elements: 0 means 1. */ \\\n    char prefix;            /* Sqlite char bind prefix. One of: '@' '$' ':' '?' or 0 for any */ \\\n    Jsi_StructSpec* slKey;  /* Struct for key (for map using a struct key). */ \\\n    int (*callback)(Jsi_Interp *interp, struct Jsi_CDataDb* obPtr, void *data); /* C callback for select queries. */ \\\n    uint maxSize;           /* Limit size of array/map*/ \\\n    bool noAuto;            /* Do not auto-create map keys. */ \\\n    bool isPtrs;            /* \"data\" an array of pointers. */ \\\n    bool isPtr2;            /* \"data\" is pointer to pointers, which is updated. */ \\\n    bool isMap;             /* \"data\" is a map: use Jsi_MapConf() for details. */ \\\n    bool memClear;          /* Before query free and zero all data (eg. DStrings). */ \\\n    bool memFree;           /* Reset as per mem_clear, then free data items. Query may be empty. */ \\\n    bool dirtyOnly;         /* Sqlite dirty filter for UPDATE/INSERT/REPLACE. */ \\\n    bool noBegin;           /* Disable wrapping UPDATE in BEGIN/COMMIT. */ \\\n    bool noCache;           /* Disable Db caching statement. */ \\\n    bool noStatic;          /* Disable binding text with SQLITE_STATIC. */ \\\n    intptr_t reserved[4];   /* Internal use. */\nJSI_DBDATA_FIELDS\n} Jsi_CDataDb;\n\nJSI_EXTERN int Jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *cd, const char *query); /*STUB = 400*/\nJSI_EXTERN Jsi_CDataDb* Jsi_CDataLookup(Jsi_Interp *interp, const char *name); /*STUB = 401*/\nJSI_EXTERN Jsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics); /*STUB = 402*/\nJSI_EXTERN Jsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname); /*STUB = 403*/\nJSI_EXTERN Jsi_StructSpec* Jsi_CDataStruct(Jsi_Interp *interp, const char *name); /*STUB = 406*/\n/* -- */\n\n\n/* String */\ntypedef char STRING1[(1<<0)+1]; // Include a char for the null byte.\ntypedef char STRING2[(1<<1)+1];\ntypedef char STRING4[(1<<2)+1];\ntypedef char STRING8[(1<<3)+1];\ntypedef char STRING16[(1<<4)+1];\ntypedef char STRING32[(1<<5)+1];\ntypedef char STRING64[(1<<6)+1];\ntypedef char STRING128[(1<<7)+1];\ntypedef char STRING256[(1<<8)+1];\ntypedef char STRING512[(1<<9)+1];\ntypedef char STRING1024[(1<<10)+1];\ntypedef char STRING2048[(1<<11)+1];\ntypedef char STRING4096[(1<<12)+1];\ntypedef char STRING8192[(1<<13)+1];\ntypedef char STRING16384[(1<<14)+1];\ntypedef char STRING32768[(1<<15)+1];\ntypedef char STRING65536[(1<<16)+1];\n\n/* -- */\n\n\n#define JSI_STUBS_STRUCTSIZES (sizeof(Jsi_MapSearch)+sizeof(Jsi_TreeSearch) \\\n    +sizeof(Jsi_HashSearch)+sizeof(Jsi_Filesystem)+sizeof(Jsi_Chan)+sizeof(Jsi_Event) \\\n    +sizeof(Jsi_CDataDb)+sizeof(Jsi_Stack)+sizeof(Jsi_OptionSpec)+sizeof(Jsi_CmdSpec) \\\n    +sizeof(Jsi_UserObjReg)+sizeof(Jsi_String) + sizeof(Jsi_PkgOpts))\n\n#ifndef JSI_OMIT_STUBS\n#ifdef JSI_USE_STUBS\n#ifndef JSISTUBCALL\n#define JSISTUBCALL(ptr,func) ptr->func\n#endif\n#include \"jsiStubs.h\"\n#else\n#define JSI_EXTENSION_INI\n#define Jsi_StubsInit(i,f) JSI_OK\n#endif\n#endif\n\n\n/* Optional compile-out commands/options string information. */\n#ifdef JSI_OMIT_INFO\n#define JSI_INFO(n) NULL\n#endif\n#ifndef JSI_INFO\n#define JSI_INFO(n) n\n#endif\n\n#endif /* __JSI_H__ */\n\n\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#if JSI__MUSL==1 || defined(__FreeBSD__)\n#define NO_QSORT_R 1\n#endif\n\nstatic uint jsi_SizeOfArray(Jsi_Interp *interp, Jsi_Obj *obj) {\n    if (!obj || !obj->arr)\n        return 0;\n    return obj->arrCnt;\n}\n\nstatic Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    \n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);    \n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = jsi_SizeOfArray(interp, obj) - 1;\n\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    \n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC jsi_ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    const char *jstr = \"\";\n    int argc, curlen;\n    Jsi_DString dStr = {};\n\n    curlen = jsi_SizeOfArray(interp, _this->d.obj);\n    if (curlen == 0) {\n        goto bail;\n    }\n\n    if (Jsi_ValueGetLength(interp, args) >= 1) {\n        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);\n        if (sc != NULL)\n            jstr = Jsi_ValueToString(interp, sc, NULL);\n    }\n    \n    if (0 == (argc=jsi_SizeOfArray(interp, _this->d.obj))) {\n        goto bail;\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        const char *cp;\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);\n        if (!ov) {\n            /* TODO: are NULL args ok? */ \n            continue;\n            cp = \"\";\n        } else\n            cp = Jsi_ValueToString(interp, ov, NULL);\n        if (i && jstr[0])\n            Jsi_DSAppend(&dStr, jstr, NULL);\n        Jsi_DSAppend(&dStr, cp, NULL);\n    }\n    \n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;        \n}\n\n\nJsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2) {\n    Jsi_Value *va;\n    Jsi_Obj *obj;\n    if (arg1->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg1->d.obj)) {\n        return NULL;\n    }\n    if (arg2->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg2->d.obj)) {\n        return NULL;\n    }\n    int len1 = arg1->d.obj->arrCnt;\n    int len2 = arg2->d.obj->arrCnt;\n    Jsi_Obj *nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ObjArraySizer(interp, nobj, len1+len2);\n\n    int i, j = 0;\n    obj = arg1->d.obj;\n    for (i = 0; i<len1; i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[j] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);\n    }\n    obj = arg2->d.obj;\n    for (i = 0; i<len2; i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[j] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, len1+len2);\n    va = Jsi_ValueMakeArrayObject(interp, NULL, nobj);\n    return va;\n}\n\nJsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2) {\n    Jsi_Obj *obj;\n    if (arg1->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg1->d.obj))\n        return JSI_ERROR;\n    if (!arg2)\n        return JSI_ERROR;\n    int len1 = arg1->d.obj->arrCnt;\n    obj = arg1->d.obj;\n    Jsi_ObjArraySizer(interp, obj, len1);\n    obj->arr[len1] = arg2;\n    Jsi_IncrRefCount(interp, arg2);\n    obj->arrCnt++;\n    return JSI_OK;\n}\n\n\nJsi_Value *Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayPop, target is not object\");\n        return NULL;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (!o->isarrlist) {\n        Jsi_LogBug(\"Jsi_ValueArrayPop, target is not array\");\n        return NULL;\n    }\n    if (o->arrCnt<=0)\n        return NULL;\n    int idx = o->arrCnt-1;\n    if (!o->arr[idx])\n        return NULL;\n    Jsi_DecrRefCount(interp, o->arr[idx]);\n    Jsi_Value *ret = o->arr[idx];\n    o->arr[idx] = NULL;\n    o->arrCnt--;\n    return ret;\n}\n\n\nJsi_Value *Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayUnshift, target is not object\");\n        return NULL;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (!o->isarrlist) {\n        Jsi_LogBug(\"Jsi_ValueArrayUnshift, target is not array\");\n        return NULL;\n    }\n    if (o->arrCnt<=0)\n        return NULL;\n    if (!o->arr[0])\n        return NULL;\n    Jsi_DecrRefCount(interp, o->arr[0]);\n    Jsi_Value *ret = o->arr[0];\n    o->arr[0] = NULL;\n    o->arrCnt--;\n    return ret;\n}\n\n/* delete array[0], array[1]->array[0] */\nvoid Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    \n    int len = jsi_SizeOfArray(interp, v->d.obj);\n    if (len <= 0) return;\n    \n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    \n    Jsi_ValueReset(interp, &v0);\n    \n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}\n\nstatic Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayFlatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Number ndepth = 1;\n    Jsi_Obj *nobj;\n    Jsi_Value *depth = Jsi_ValueArrayIndex(interp, args, 0);\n    if (depth && Jsi_GetNumberFromValue(interp,depth, &ndepth) != JSI_OK)\n        return JSI_ERROR;\n    \n    if (ndepth < 0 || ndepth>1000)\n        return Jsi_LogError(\"bad depth: %d\", (int)ndepth);\n\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj );\n    if (ndepth>0)\n        return jsi_ArrayFlatSub(interp, nobj, _this, ndepth);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, argc, nsiz;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = jsi_SizeOfArray(interp, obj);\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"index too large: %d\", nsiz+1);\n        goto bail;\n    }\n\n    int i, j, m;\n    for (i = 0; i<curlen; i++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[i] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]);\n    }\n    m = i;\n    for (i = 0; i < argc; i++) {\n         va = Jsi_ValueArrayIndex(interp, args, i);\n         if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) {\n            int margc = Jsi_ValueGetLength(interp, va);\n            Jsi_Obj *mobj = va->d.obj;\n            Jsi_ObjListifyArray(interp, mobj);\n            if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            for (j = 0; j<margc; j++, m++)\n            {\n                if (!mobj->arr[j]) continue;\n                nobj->arr[m] = NULL;\n                Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]);\n            }\n        } else {\n            if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            nobj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, nobj->arr+m++, va);\n       }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, nsiz, i, maa = 0;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis;\n    Jsi_Func *fptr = NULL;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = jsi_SizeOfArray(interp, obj);    \n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrCnt;\n    if (nsiz<=0) nsiz = 1;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        Jsi_LogError(\"index too large: %d\", nsiz);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_Value *vobjs[3];\n\n    fptr = func->d.obj->d.fobj->func;\n    maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < curlen; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        nobj->arr[i] = Jsi_ValueNew1(interp);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, nobj->arr+i, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if( JSI_OK!=rc ) {\n            goto bail;\n        }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, nsiz, i, fval, n = 0, maa = 0;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis, *nrPtr = NULL;\n    Jsi_Func *fptr = NULL;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = jsi_SizeOfArray(interp, obj);    \n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrCnt;\n    if (nsiz<=0) nsiz = 1;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        Jsi_LogError(\"index too large: %d\", nsiz);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[4];\n\n    fptr = func->d.obj->d.fobj->func;\n    maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < curlen; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if( JSI_OK!=rc ) {\n            goto bail;\n        }\n        if (fval) {\n            nobj->arr[n++] = obj->arr[i];\n            Jsi_IncrRefCount(interp, obj->arr[i]);\n        }\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_ObjSetLength(interp, nobj, n);\n    return JSI_OK;\n        \nbail:\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    if (nrPtr)\n        Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayReverseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    int i, n, m;\n    Jsi_Obj *obj;\n    Jsi_Value *tval, *nthis = NULL, *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    m = obj->arrCnt/2;\n    for (i = 0, n=obj->arrCnt-1; i < m; i++, n--) {\n        tval = obj->arr[i];\n        obj->arr[i] = obj->arr[n];\n        obj->arr[n] = tval;\n    }\n    Jsi_ValueDup2(interp, ret, _this);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) \n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj;\n    uint i;\n    Jsi_Value *func, *vpargs;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_RC rc = JSI_OK;\n    \n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayFindSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_Obj *obj;\n    uint i;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *func, *vpargs, *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    int fval = 0;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if (op == 3) {\n            if (!fval) break;\n        } else if (fval)\n            break;\n    }\n    if (rc == JSI_OK) {\n        if (op == 1 && fval) // Find\n            Jsi_ValueCopy(interp, *ret, obj->arr[i]); \n        else if (op == 2 || op == 3) // Some/Every\n            Jsi_ValueMakeBool(interp, ret, fval);\n        else if (op == 4)\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)(fval?(int)i:-1));\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}\n\nstatic Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n            \n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}\n\nstatic Jsi_RC jsi_ArrayFindCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC jsi_ArraySomeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC jsi_ArrayEveryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 3);\n}\nstatic Jsi_RC jsi_ArrayFindIndexCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 4);\n}\nstatic Jsi_RC jsi_ArrayReduceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayReduceSubCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC jsi_ArrayReduceRightCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayReduceSubCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC jsi_ArrayIsArrayCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    bool b = 0;\n    Jsi_Value *sthis = _this;\n    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&\n       _this->d.obj->__proto__ == interp->Array_prototype->d.obj->__proto__ )\n        sthis = Jsi_ValueArrayIndex(interp, args, 0); \n    if (sthis && sthis->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, sthis->d.obj))\n        b = 1;\n    Jsi_ValueMakeBool(interp, ret, b);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = jsi_SizeOfArray(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayIndexSubCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC jsi_ArrayLastindexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayIndexSubCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC jsi_ArrayIncludesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayIndexSubCmd(interp, args, _this, ret, funcPtr, 3);\n}\n\nstatic Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = jsi_SizeOfArray(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = jsi_SizeOfArray(interp, obj);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; // TODO: merge with code in ArraySliceCmd.\n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = jsi_SizeOfArray(interp, obj);\n\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n      \n    if (n == 0) {\n        goto bail;\n    }\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto bail;\n\n    int i;\n    for (i = istart; i <= iend; i++)\n    {\n        if (obj->arr[i])\n            Jsi_ValueCopy(interp, obj->arr[i], value);\n        else\n            obj->arr[i] = Jsi_ValueDup(interp, value);\n    }\nbail:\n    if (_this != *ret) {\n        Jsi_ValueMove(interp, *ret, _this);\n        /*if (*ret)\n            Jsi_DecrRefCount(interp, *ret);\n        *ret = _this;\n        Jsi_IncrRefCount(interp, *ret);*/\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = jsi_SizeOfArray(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n      \n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n    \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n\ntypedef struct {\n    Jsi_Interp *interp;\n    int flags;\n    int mode;\n    bool unique;\n    Jsi_Value *compare;\n    int errCnt;\n} SortInfo;\n\nstatic const char *sortArrayStrs[] = {\"default\", \"desc\", \"dict\", \"nocase\", 0};\n\nstatic Jsi_OptionSpec jsi_ArraySortOptions[] = {\n    JSI_OPT(CUSTOM, SortInfo, mode,     .help=\"Mode to sort by\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=sortArrayStrs),\n    JSI_OPT(FUNC,   SortInfo, compare,  .help=\"Function to do comparison\", .flags=0, .custom=0, .data=(void*)\"val1,val2\"),\n    JSI_OPT(BOOL,   SortInfo, unique,   .help=\"Eliminate duplicate items\"),\n    JSI_OPT_END(SortInfo)\n};\n\n#ifdef NO_QSORT_R\n\nSortInfo *curSortInfo = NULL;\n\nstatic int SortSubCmd(const void *p1, const void *p2) {\n    SortInfo *si = curSortInfo;\n#else\n#ifdef __WIN32\nstatic int SortSubCmd(void *thunk, const void *p1, const void *p2)\n#else\nstatic int SortSubCmd(const void *p1, const void *p2, void *thunk)\n#endif\n{\n    SortInfo *si = (SortInfo *)thunk;\n#endif\n    Jsi_Interp *interp = si->interp;\n    int sortFlags = si->flags;\n\n    if (interp == NULL || interp->deleting)\n        return 0;\n    Jsi_Value *v1 = *(Jsi_Value**)p1, *v2 = *(Jsi_Value**)p2;\n    int rc = 0;\n    if (v1 != NULL && v2 != NULL) {\n        VALCHK(v1);\n        VALCHK(v2);\n        if (!si->compare)\n            rc = Jsi_ValueCmp(interp, v1, v2, sortFlags);\n        else {\n            Jsi_Value *vv[2] = {v1, v2};\n            Jsi_Value *retP = Jsi_ValueNew1(interp);\n            Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vv, 2, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            rc = Jsi_FunctionInvoke(interp, si->compare, vpargs, &retP, NULL);\n            Jsi_DecrRefCount(interp, vpargs);\n            if (rc == JSI_OK) {\n                Jsi_Number d = 0;\n                if (Jsi_ValueGetNumber(interp, retP, &d) == JSI_OK)\n                    rc = -(int)d;\n                else {\n                    if (!si->errCnt)\n                        Jsi_LogWarn(\"invalid function return\");\n                    si->errCnt++;\n                }\n            }\n            Jsi_DecrRefCount(interp, retP);\n        }\n    } else {\n        if (v1 == v2) \n            rc = 0;\n        else if (v1 == NULL)\n            rc = 1;\n        else\n            rc = -1;\n    }\n    if ((sortFlags&JSI_SORT_DESCEND))\n        return rc;\n    return -rc;\n}\n\nJsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int flags)\n{\n    if (val->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, val->d.obj)) {\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = val->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    if (obj->arrCnt <= 0) {\n        return JSI_OK;\n    }\n#ifdef __WIN32\n#define qsort_r qsort_s\n#endif\n\n    SortInfo si = {};\n    si.interp = interp;\n    si.flags = flags;\n#ifdef NO_QSORT_R\n    curSortInfo = &si;\n    qsort(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd);\n    curSortInfo = NULL;\n#else\n    qsort_r(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd, &si);\n#endif\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArraySortCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    int flags = 0, i, curlen, hasopt = 0;\n    Jsi_Value *v, *arg = NULL;\n    SortInfo si = {};\n    si.interp = interp;\n\n\n    Jsi_Obj *obj = _this->d.obj;\n    curlen = obj->arrCnt;\n\n    if (curlen <= 1) {\n        goto done;\n    }\n    \n    arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (arg) {\n        if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {\n            if (Jsi_OptionsProcess(interp, jsi_ArraySortOptions, &si, arg, 0) < 0)\n                return JSI_ERROR;\n            hasopt = 1;\n            switch (si.mode) {\n                case 1: flags |= JSI_SORT_DESCEND; break;\n                case 2: flags |= JSI_SORT_DICT; break;\n                case 3: flags |= JSI_SORT_NOCASE; break;\n            }\n        } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_FUNCTION))\n            si.compare = arg;\n        else \n            return Jsi_LogError(\"expected object or function\");\n    }\n    si.flags = flags;\n    Jsi_ObjListifyArray(interp, obj);\n#ifdef NO_QSORT_R\n    /* TODO: mutex. */\n    curSortInfo = &si;\n    qsort(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd);\n#else\n    qsort_r(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd, &si);\n#endif\n\n    if (interp->deleting) {\n#ifdef NO_QSORT_R\n        curSortInfo = NULL;\n#endif\n        return JSI_ERROR;\n    }\n    if (si.unique) {\n        int n, diff = 1, dupCnt=0;\n        for (n=0, i=1; i<(int)obj->arrCnt; i++) {\n            if (obj->arr[n] == obj->arr[i])\n                diff = 1;\n            else\n#ifdef NO_QSORT_R\n                diff = SortSubCmd(&obj->arr[n], &obj->arr[i]);\n#else\n#ifdef __WIN32\n                diff = SortSubCmd(&si, &obj->arr[n], &obj->arr[i]);\n#else\n                diff = SortSubCmd(&obj->arr[n], &obj->arr[i], &si);\n#endif\n#endif\n            if (diff) {\n                n++;\n                if (n!=i)\n                    obj->arr[n] = obj->arr[i];\n            } else {\n                dupCnt++;\n                if (obj->arr[i])\n                    Jsi_DecrRefCount(interp, obj->arr[i]);\n                obj->arr[i] = 0;\n            }\n        }\n        obj->arrCnt -= dupCnt;\n    }\n#ifdef NO_QSORT_R\n    curSortInfo = NULL;\n#endif\n    if (hasopt)\n        Jsi_OptionsFree(interp, jsi_ArraySortOptions, &si, 0);\ndone:\n    v = Jsi_ValueMakeObject(interp, NULL, obj);\n    Jsi_ValueReplace(interp, ret, v);\n    return JSI_OK;\n    \n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int newlen, argc, istart, n, rhowmany, ilen, curlen;\n    Jsi_Value *va, *start, *howmany;\n    Jsi_Obj *nobj, *obj = _this->d.obj;\n    \n    start = Jsi_ValueArrayIndex(interp, args, 0);\n    howmany = Jsi_ValueArrayIndex(interp, args, 1);\n    argc = Jsi_ValueGetLength(interp, args);\n    istart = 0;\n    ilen = (argc>=2 ? argc - 2 : 0);\n    n = jsi_SizeOfArray(interp, obj);\n    curlen = n;\n    \n    if (!start) {\n        goto bail2;\n    }\n\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_ObjSetLength(interp, nobj, 0);\n    \n    /* Determine start index. */\n    Jsi_Number nstart;\n    if (Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            istart=0;\n    }\n      \n    Jsi_Number nhow;\n    rhowmany = n-istart;\n    if (howmany && Jsi_GetNumberFromValue(interp, howmany, &nhow) == JSI_OK) {\n        rhowmany = (int)nhow;\n        if (rhowmany >= (n-istart))\n            rhowmany = n-istart;\n        if (rhowmany < 0)\n            rhowmany = (n-istart);\n        if (rhowmany<0)\n            goto bail;\n    }\n    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, curlen=0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    Jsi_ObjArraySizer(interp, nobj, rhowmany);\n\n    /* Move elements to return object. */\n    int i, j, m;\n    for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++, i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    Jsi_ObjSetLength(interp, nobj, m);\n    \n    /* Shift remaining down. */\n    for (; rhowmany && i<curlen; i++)\n    {\n        obj->arr[i-rhowmany] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    curlen -= j;\n    /* Add elements. */\n    newlen = curlen + argc - (argc>=2?2:1);\n    if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) {\n        Jsi_LogError(\"too long\");\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_ERROR;\n    }\n    if (ilen>0) {\n        for (i = curlen-1; i>=istart; i--) {\n            obj->arr[i+ilen] = obj->arr[i];\n            obj->arr[i] = NULL;\n        }\n        for (m=istart, i = 2; i<argc; m++,i++) {\n            va = Jsi_ValueArrayIndex(interp, args, i);\n            if (!va) continue;\n            obj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, obj->arr+m, va);\n        }\n    }\n    Jsi_ObjSetLength(interp, obj, newlen);\nbail:    \n    return JSI_OK;\n     \n            \nbail2:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int argc = Jsi_ValueGetLength(interp, args), iscons = Jsi_FunctionIsConstructor(funcPtr);\n    Jsi_Value *target;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    \n    if (iscons) {\n        target = _this;\n        Jsi_ValueMakeArrayObject(interp, &_this, Jsi_ObjNewArray(interp, NULL, 0, 0));\n    } else {\n        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        o->__proto__ = interp->Array_prototype;\n        Jsi_ValueMakeObject(interp, ret, o);\n        target = *ret;\n    }\n\n    if (argc == 1 && v && Jsi_ValueIsNumber(interp, v)) {\n        Jsi_Number nv;\n        Jsi_GetNumberFromValue(interp,v, &nv);\n        int len = (int)nv;\n        if (!Jsi_NumberIsInteger(v->d.num) || len < 0) \n            return Jsi_LogError(\"Invalid array length\");\n        target->d.obj->isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, target->d.obj, len) <= 0)\n            return JSI_ERROR;\n    } else {\n    \n        int i;\n        target->d.obj->isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, target->d.obj, 0) <= 0)\n                return JSI_ERROR;\n        \n        for (i = 0; i < argc; ++i) {\n            Jsi_Value *argv = Jsi_ValueArrayIndex(interp, args, i);   ;\n            Jsi_ValueInsertArray(interp, _this, i, argv, 0);\n        }\n    }\n    if (iscons)\n        Jsi_ValueDup2(interp, ret, target);\n    return JSI_OK;\n}\n            \nstatic Jsi_CmdSpec arrayCmds[] = {\n    { \"Array\",      jsi_ArrayConstructor,   0,-1, \"...\", .help=\"jsi_Array constructor\", .retType=(uint)JSI_TT_ARRAY, .flags=JSI_CMD_IS_CONSTRUCTOR },\n    { \"concat\",     jsi_ArrayConcatCmd,     0,-1, \"...\", .help=\"Return array with args appended\", .retType=(uint)JSI_TT_ARRAY },\n    { \"every\",      jsi_ArrayEveryCmd,      1, 1, \"callback:function\", .help=\"Returns true if every value in array satisfies the test\", .retType=(uint)JSI_TT_ANY },\n    { \"fill\",       jsi_ArrayFillCmd,       1, 3, \"value:any, start:number=0, end:number=-1\", .help=\"Fill an array with values\", .retType=(uint)JSI_TT_ARRAY },\n    { \"filter\",     jsi_ArrayFilterCmd,     1, 2, \"callback:function, this:object=void\", .help=\"Return a filtered array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"find\",       jsi_ArrayFindCmd,       1, 1, \"callback:function\", .help=\"Returns the value of the first element in the array that satisfies the test\", .retType=(uint)JSI_TT_ANY },\n    { \"findIndex\",  jsi_ArrayFindIndexCmd,  1, 1, \"callback:function\", .help=\"Returns the index of the first element in the array that satisfies the test\", .retType=(uint)JSI_TT_ANY },\n    { \"flat\",       jsi_ArrayFlatCmd,       0, 1, \"depth:number=1\", .help=\"Flatten an arra\", .retType=(uint)JSI_TT_ARRAY },\n    { \"forEach\",    jsi_ArrayForeachCmd,    1, 2, \"callback:function, this:object=void\", .help=\"Invoke function with each item in object\", .retType=(uint)JSI_TT_VOID },\n    { \"includes\",   jsi_ArrayIncludesCmd,   1, 1, \"val:any\", .help=\"Returns true if array contains value\", .retType=(uint)JSI_TT_ANY },\n    { \"indexOf\",    jsi_ArrayIndexOfCmd,    1, 2, \"str:any, startIdx:number=0\", .help=\"Return index of first occurrance in array\", .retType=(uint)JSI_TT_NUMBER },\n    { \"isArray\",    jsi_ArrayIsArrayCmd,    0, 0, \"\", .help=\"True if val array\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"join\",       jsi_ArrayJoinCmd,       0, 1, \"sep:string=''\", .help=\"Return elements joined by char\", .retType=(uint)JSI_TT_STRING },\n    { \"lastIndexOf\",jsi_ArrayLastindexOfCmd,1, 2, \"val:any, start:number=0\", .help=\"Return index of last occurence in array\", .retType=(uint)JSI_TT_NUMBER },\n    { \"map\",        jsi_ArrayMapCmd,        1, 2, \"callback:function, this:object=void\", .help=\"Creates a new array with the results of calling a provided function on every element in this array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"pop\",        jsi_ArrayPopCmd,        0, 0, \"\", .help=\"Remove and return last element of array\", .retType=(uint)JSI_TT_ANY },\n    { \"push\",       jsi_ArrayPushCmd,       1,-1, \"val:any, ...\", .help=\"Push one or more elements onto array and return size\", .retType=(uint)JSI_TT_NUMBER },\n    { \"reduce\",     jsi_ArrayReduceCmd,     1, 2, \"callback:function, initial:any\", .help=\"Return a reduced array\", .retType=(uint)JSI_TT_ANY },\n    { \"reduceRight\",jsi_ArrayReduceRightCmd,1, 2, \"callback:function, initial:any\", .help=\"Return a reduced array\", .retType=(uint)JSI_TT_ANY },\n    { \"shift\",      jsi_ArrayShiftCmd,      0, 0, \"\", .help=\"Remove first element and shift downwards\", .retType=(uint)JSI_TT_ANY },\n    { \"sizeOf\",     jsi_ArraySizeOfCmd,     0, 0, \"\", .help=\"Return size of array\", .retType=(uint)JSI_TT_NUMBER },\n    { \"slice\",      jsi_ArraySliceCmd,      1, 2, \"start:number, end:number=void\", .help=\"Return sub-array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"some\",       jsi_ArraySomeCmd,       1, 2, \"callback:function, this:object=void\", .help=\"Return true if function returns true some element\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"sort\",       jsi_ArraySortCmd,       0, 1, \"options:function|object=void\", .help=\"Sort an array\", .retType=(uint)JSI_TT_ARRAY, .flags=0, .info=0, .opts=jsi_ArraySortOptions },\n    { \"splice\",     jsi_ArraySpliceCmd,     1,-1, \"start:number, howmany:number=void, ...\", .help=\"Change the content of an array, adding new elements while removing old elements\", .retType=(uint)JSI_TT_ARRAY },\n    { \"reverse\",    jsi_ArrayReverseCmd,    0, 0, \"\", .help=\"Reverse order of all elements in an array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"unshift\",    jsi_ArrayUnshiftCmd,    0,-1, \"...\", .help=\"Add new elements to start of array and return size\", .retType=(uint)JSI_TT_NUMBER },\n    { NULL, 0,0,0,0, .help=\"Provide access to array objects\" }\n};\n\nJsi_RC jsi_InitArray(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    interp->Array_prototype = Jsi_CommandCreateSpecs(interp, \"Array\", arrayCmds, NULL, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\n#endif\n", "/* Jsi commands to access C-data.   http://jsish.org */\n#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#ifndef JSI_OMIT_CDATA\n#include <fcntl.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <stdint.h>\n#include <sys/time.h>\n\n#define UdcGet(udf, _this, funcPtr) \\\n   CDataObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr); \\\n    if (!udf) \\\n        return Jsi_LogError(\"CData.%s called with non-CData object\", funcPtr->cmdSpec->name);\n\nenum { jsi_CTYP_DYN_MEMORY=(1LL<<32), jsi_CTYP_STRUCT=(1LL<<33), jsi_CTYP_ENUM=(1LL<<34) };\n\ntypedef struct {\n    JSI_DBDATA_FIELDS  \n    Jsi_StructSpec *sl, *keysf;\n    Jsi_Map** mapPtr;\n    const char *help, *structName, *keyName, *varParam, *name;\n    uint flags;\n    bool isAlloc;\n    Jsi_Map_Type mapType;\n    Jsi_Key_Type keyType;\n    Jsi_Wide user;\n    Jsi_Interp *interp;\n    int objId;\n    Jsi_Obj *fobj;\n} CDataObj;\n\nstatic Jsi_StructSpec*  jsi_csStructGet(Jsi_Interp *interp, const char *name);\nstatic Jsi_StructSpec*   jsi_csFieldGet(Jsi_Interp *interp, const char *name, Jsi_StructSpec* sl);\n\nstatic Jsi_EnumSpec*    jsi_csEnumGet(Jsi_Interp *interp, const char *name);\nstatic Jsi_EnumSpec*    jsi_csEnumGetItem(Jsi_Interp *interp, const char *name, Jsi_EnumSpec* sf);\nstatic Jsi_RC     jsi_csStructInit(Jsi_StructSpec* s, uchar* data);\nstatic Jsi_RC CDataOptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *args,\n    void *rec, Jsi_Value **ret, int flags, int skipArgs);\nstatic Jsi_RC jsi_csBitGetSet(Jsi_Interp *interp, void *vrec, Jsi_Wide* valPtr, Jsi_OptionSpec *spec, int idx, bool isSet);\n\n//static Jsi_OptionSpec *jsi_csGetOptSpec(void* p) { Jsi_OptionSpec *s = (typeof(s))p; SIGASSERT(s, OPTS); return s; }\nstatic Jsi_StructSpec *jsi_csGetStructSpec(void* p) { Jsi_StructSpec *s = (typeof(s))p; SIGASSERT(s, OPTS_STRUCT); return s; }\nstatic Jsi_FieldSpec *jsi_csGetFieldSpec(void* p) { Jsi_FieldSpec *s = (typeof(s))p; SIGASSERT(s, OPTS_FIELD); return s; }\n//static Jsi_EnumSpec *jsi_csGetEnumSpec(void* p) { Jsi_EnumSpec *s = (typeof(s))p; SIGASSERT(s, OPTS_ENUM); return s; }\nstatic Jsi_OptionTypedef *jsi_csGetTypeSpec(void* p) { Jsi_OptionTypedef *s = (typeof(s))p; SIGASSERT(s, TYPEDEF); return s; }\n  \nstatic Jsi_FieldSpec*  jsi_csStructFields(Jsi_Interp *interp, const char *name) {\n    Jsi_StructSpec* sp = jsi_csStructGet(interp, name);\n    if (!sp)\n        return NULL;\n    return jsi_csGetFieldSpec(sp->extData);\n}\n\n/* Traverse hash table and match unique substring. */\nJsi_HashEntry *jsi_csfindInHash(Jsi_Interp *interp, Jsi_Hash * tbl, const char *name)\n{\n    int len;\n    Jsi_HashSearch se;\n    Jsi_HashEntry *sentry = 0, *entry = Jsi_HashEntryFind(tbl, name);\n    if (entry)\n        return entry;\n    len = Jsi_Strlen(name);\n    entry = Jsi_HashSearchFirst(tbl, &se);\n    while (entry) {\n        char *ename = (char *) Jsi_HashKeyGet(entry);\n        if (!Jsi_Strncmp(name, ename, len)) {\n            if (sentry)\n                return 0;\n            sentry = entry;\n        }\n        entry = Jsi_HashSearchNext(&se);\n    }\n    return sentry;\n}\n\n/* Traverse enum and match unique substring. */\nJsi_OptionSpec *jsi_csgetEnum(Jsi_Interp *interp, const char *name)\n{\n    Jsi_HashEntry *entry = jsi_csfindInHash(interp, interp->EnumHash, name);\n    return entry ? (Jsi_OptionSpec *) Jsi_HashValueGet(entry) : 0;\n}\n\n\n/************* INITIALIZERS  *********************************************/\n\n/* Init Type hash */\nvoid jsi_csInitType(Jsi_Interp *interp)\n{\n    if (interp->CTypeHash->numEntries) return;\n    bool isNew;\n    Jsi_HashEntry *entry;\n    const Jsi_OptionTypedef *tl;\n    if (!interp->typeInit) {\n        int i;\n        for (i = JSI_OPTION_BOOL; i!=JSI_OPTION_END; i++) {\n            tl = Jsi_OptionTypeInfo((Jsi_OptionId)i);\n            entry = Jsi_HashEntryNew(interp->TYPEHash, tl->idName, &isNew);\n            if (!isNew)\n                Jsi_LogBug(\"duplicate type: %s\", tl->idName);\n            Jsi_HashValueSet(entry, (void*)tl);\n            if (tl->cName && tl->cName[0])\n                Jsi_HashSet(interp->CTypeHash, tl->cName, (void*)tl);\n        }\n    }\n    interp->typeInit = 1;\n}\n\nstatic Jsi_RC jsi_csSetupStruct(Jsi_Interp *interp, Jsi_StructSpec *sl, Jsi_FieldSpec *sf, \n    Jsi_StructSpec* recs, int flen, Jsi_OptionTypedef** stPtr, int arrCnt) {\n    bool isNew;\n    int i, cnt = 0, boffset = 0;\n    Jsi_HashEntry *entry, *hPtr;\n    if (!(hPtr=Jsi_HashEntryNew(interp->CTypeHash, sl->name, &isNew)) || !isNew)\n        return Jsi_LogError(\"struct is c-type: %s\", sl->name);\n    entry = Jsi_HashEntryNew(interp->StructHash, sl->name, &isNew);\n    if (!isNew)\n        return Jsi_LogError(\"duplicate struct: %s\", sl->name);\n    Jsi_FieldSpec *asf = NULL, *osf = sf;\n    while (sf && sf->id != JSI_OPTION_END) {\n        if (!sf->type)\n            sf->type = Jsi_OptionTypeInfo(sf->id);\n        if (!sf->type && sf->tname)\n            sf->type = Jsi_TypeLookup(interp, sf->tname);\n        int isbitset = ((sf->flags&JSI_OPT_BITSET_ENUM)!=0);\n        if (sf->type && sf->type->extData && (sf->type->flags&(jsi_CTYP_ENUM|jsi_CTYP_STRUCT))) {\n            // A struct sub-field or a bit field mapped to an ENUM.\n            Jsi_OptionSpec *es = (typeof(es))sf->type->extData;\n            es->value++;\n            if ((sf->type->flags&jsi_CTYP_ENUM)) {\n                if (sf->bits)\n                    return Jsi_LogError(\"enum of bits unsupported: %s\", sl->name); //TODO: get working again...\n                sf->custom = (isbitset ? Jsi_Opt_SwitchBitset : Jsi_Opt_SwitchEnum);\n                sf->data = (void*)es->data;\n                sf->id = JSI_OPTION_CUSTOM;\n            }\n            else if (sf->type->flags & jsi_CTYP_STRUCT) {\n                sf->custom = Jsi_Opt_SwitchSuboption;\n                sf->data = es->extData;\n                sf->id = JSI_OPTION_CUSTOM;\n            }\n        }\n        if (recs) {\n            if (!sf->type)\n                return Jsi_LogError(\"unknown id\");\n            sf->tname = sf->type->cName;\n            sf->size = (isbitset?(int)sizeof(int):sf->type->size);\n            if (sf->arrSize)\n                sf->size *= sf->arrSize;\n            sf->idx = cnt;\n            sf->boffset = boffset;\n            if (sf->bits) {\n                if (sf->bits>=64)\n                    return Jsi_LogError(\"bits too large\");\n                boffset += sf->bits;\n                sf->id = JSI_OPTION_CUSTOM;\n                sf->custom=Jsi_Opt_SwitchBitfield;\n                sf->init.OPT_BITS=&jsi_csBitGetSet;\n            } else {\n                sf->offset = (boffset+7)/8;\n                boffset += sf->size*8;\n            }\n        } else {\n            boffset += sf->size*8;\n        }\n        sf->extData = (uchar*)sl;\n        sf++, cnt++;\n    }\n    sl->idx = cnt;\n    if (!sl->size) \n        sl->size = (boffset+7)/8;\n    if (sl->ssig)\n        Jsi_HashSet(interp->SigHash, (void*)(uintptr_t)sl->ssig, sl);\n    int extra = 0;\n    if (flen)\n        extra = sl->size + ((flen+2+arrCnt*2)*sizeof(Jsi_StructSpec));\n    Jsi_OptionTypedef *st = (typeof(st))Jsi_Calloc(1, sizeof(*st) + extra);\n    SIGINIT(st, TYPEDEF);\n    if (!recs) \n        sf = osf;\n    else {\n        st->extra = (uchar*)(st+1); // Space for struct initializer.\n        sf =  (typeof(sf))(st->extra + sl->size);\n        memcpy(sf, recs, sizeof(*sf)*(flen+1));\n        sl = sf+flen+1;\n        if (arrCnt)\n            asf = sl+1;\n        memcpy(sl, recs+flen+1, sizeof(*sl));\n        for (i=0; i<flen; i++) {\n            sf[i].extData = (uchar*)sl;\n            if (sf[i].id == 0 && sf[i].type)\n                sf[i].id = sf[i].type->id;\n            if (sf[i].arrSize) {\n                asf[0] = sf[i];\n                asf[1] = sf[flen];\n                asf->arrSize = asf->offset = 0;\n                //asf->size = asf->type->size;\n                sf[i].id = JSI_OPTION_CUSTOM;\n                sf[i].custom=Jsi_Opt_SwitchCArray;\n                sf[i].init.OPT_CARRAY = asf;\n                asf += 2;\n                //sf[i].extData = \n                 //   {.sig=JSI_SIG_OPTS_FIELD, .name=sf[i].name, \n                  //  JSI_OPT_CARRAY_ITEM_(JSI_SIG_OPTS_FIELD,'+otype+', '+name+', sf[i].name, .help=sf[i].help, .flags='+fflags+rest+'),\\n'\n                   // JSI_OPT_END_(JSI_SIG_OPTS_FIELD,'+name+', .help=\"Options for array field '+name+'.'+fname+'\")\\n  };\\n\\n';\n                   // JSI_OPT_CARRAY_(JSI_SIG_OPTS_FIELD,'+name+', '+fname+', \"'+fdescr+'\", '+fflags+', '+arnam+', '+f.asize+', \"'+type+'\", '+csinit+'),\\n';\n            }\n        }\n    }\n    st->extData = (uchar*)sl;\n    sl->extData = (uchar*)sf;\n    sl->type = st;\n    st->cName = sl->name;\n    st->idName = \"CUSTOM\";\n    st->id = JSI_OPTION_CUSTOM;\n    st->size = sl->size;\n    st->flags = jsi_CTYP_DYN_MEMORY|jsi_CTYP_STRUCT;\n    Jsi_HashValueSet(entry, sl);\n    Jsi_HashValueSet(hPtr, st);\n    st->hPtr = hPtr;\n    if (stPtr)\n        *stPtr = st;\n    return JSI_OK;\n}\n\n/* Init Struct hash */\nstatic void jsi_csInitStructTables(Jsi_Interp *interp)\n{\n    Jsi_StructSpec *sf, *sl = interp->statics->structs;\n    while (sl  && sl->name) {\n        sf = (typeof(sf))sl->data;\n        jsi_csSetupStruct(interp, sl, sf, NULL, 0, NULL, 0);\n        sl++;\n    }\n}\n\nstatic int jsi_NumWideBytes(Jsi_Wide val) {\n    if (val < 0x10000)\n        return (val < 0x100 ? 1 : 2);\n    return(val < 0x100000000L ? 4 : 8);\n}\n\nstatic Jsi_RC jsi_csSetupEnum(Jsi_Interp *interp, Jsi_EnumSpec *sl, Jsi_FieldSpec *sf, Jsi_OptionTypedef* st) {\n    bool isNew;\n    int cnt = 0;\n    if (Jsi_HashEntryFind(interp->CTypeHash, sl->name))\n        return Jsi_LogError(\"enum is c-type: %s\", sl->name);\n    Jsi_HashEntry *entry = Jsi_HashEntryNew(interp->EnumHash, sl->name, &isNew);\n    if (!isNew)\n        return Jsi_LogError(\"duplicate enum: %s\", sl->name);\n    Jsi_HashValueSet(entry, sl);\n    //Jsi_Number val = 0;\n    sl->extData = (uchar*)sf;\n    Jsi_Wide maxVal = 0, aval;\n    while (sf && sf->id != JSI_OPTION_END) {\n        sf->idx = cnt;\n        Jsi_HashSet(interp->EnumItemHash, sf->name, sf);\n        sf->extData = (uchar*)sl;\n        aval =  sf->value;\n        if (aval<0) aval = -aval;\n        if (aval>maxVal) maxVal = aval;\n        sf++, cnt++;\n    }\n    Jsi_HashSet(interp->EnumHash, sl->name, sl);\n    sl->idx = cnt;\n    if (!sl->size) \n        sl->size = cnt;\n    if (!st) {\n        st = (typeof(st))Jsi_Calloc(1, sizeof(*st));\n        SIGINIT(st, TYPEDEF);\n    }\n    st->cName = sl->name;\n    st->idName = \"CUSTOM\";\n    st->id = JSI_OPTION_CUSTOM;\n    st->size = jsi_NumWideBytes(aval);\n    st->flags = jsi_CTYP_DYN_MEMORY|jsi_CTYP_ENUM;\n    st->extData = (uchar*)sl;\n    Jsi_HashSet(interp->CTypeHash, st->cName, st);\n    return JSI_OK;\n}\n\n/* Init Enum hash */\nvoid jsi_csInitEnum(Jsi_Interp *interp)\n{\n    bool isNew;\n    Jsi_EnumSpec *sl = interp->statics->enums;\n    while (sl && sl->name && sl->id != JSI_OPTION_END) {\n        Jsi_HashEntry *entry = Jsi_HashEntryNew(interp->EnumHash, sl->name, &isNew);\n        if (!isNew)\n            Jsi_LogBug(\"duplicate enum: %s\", sl->name);\n        assert(isNew);\n        Jsi_HashValueSet(entry, sl);\n        sl++;\n    }\n}\n\n/* Find the enum name in all enums */\nJsi_OptionSpec *jsi_csInitEnumItem(Jsi_Interp *interp)\n{\n    Jsi_HashEntry *entry;\n    bool isNew;\n    Jsi_EnumSpec *sl = interp->statics->enums;\n    while (sl &&  sl->name && sl->id != JSI_OPTION_END) {\n        Jsi_OptionSpec *ei = (typeof(ei))sl->data;\n        while (ei->name  && ei->id != JSI_OPTION_END) {\n            entry = Jsi_HashEntryNew(interp->EnumItemHash, ei->name, &isNew);\n            if (!isNew)\n                Jsi_LogBug(\"duplicate enum item: %s\", ei->name);\n            Jsi_HashValueSet(entry, ei);\n            ei++;\n        }\n        sl++;\n    }\n    return 0;\n}\n\nJsi_StructSpec *Jsi_CDataStruct(Jsi_Interp *interp, const char *name) {\n    return (Jsi_StructSpec *)Jsi_HashGet(interp->StructHash, name, 0);\n}\n\n// Format struct key.\nstatic Jsi_Value *jsi_csFmtKeyCmd(Jsi_MapEntry* hPtr, Jsi_MapOpts *opts, int flags)\n{\n    void *rec = (opts->mapType==JSI_MAP_HASH ? Jsi_HashKeyGet((Jsi_HashEntry*)hPtr): Jsi_TreeKeyGet((Jsi_TreeEntry*)hPtr));\n    if (!rec) return NULL;\n    CDataObj *cd = (typeof(cd))opts->user;\n    assert(cd);\n    Jsi_Interp *interp = cd->interp;\n    if (!cd->slKey || !cd->slKey)\n        return NULL;\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->keysf, rec, NULL, &v, flags) == JSI_OK)\n        return v;\n    Jsi_DecrRefCount(interp, v);\n    return NULL;\n}\n\nstatic Jsi_RC jsi_csCDataNew(Jsi_Interp *interp, const char *name, const char *structName,\n    const char *help, const char *varParm, Jsi_VarSpec *data) {\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSPrintf(&dStr, \"var %s = new CData({name:\\\"%s\\\", structName:\\\"%s\\\"\", name, name, structName);\n    if (help)\n        Jsi_DSPrintf(&dStr, \", help:\\\"%s\\\"\", help);\n    if (varParm)\n        Jsi_DSPrintf(&dStr, \", varParam:\\\"%s\\\"\", varParm);\n    Jsi_DSPrintf(&dStr, \"});\");\n    interp->cdataNewVal = data;\n    Jsi_RC rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0);\n    interp->cdataNewVal = NULL;\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nJsi_RC jsi_csInitVarDefs(Jsi_Interp *interp)\n{\n    Jsi_VarSpec *vd = interp->statics->vars;\n    int i;\n    for (i=0; vd[i].name; i++) {\n        SIGASSERT(vd+i, OPTS_VARDEF);\n        const char *name = vd[i].name;\n        const char *structName = vd[i].info;\n        const char *help = vd[i].help;\n        const char *varParm = (const char*)vd[i].userData;\n\n        if (JSI_OK != jsi_csCDataNew(interp, name, structName, help, varParm, vd+i))\n            return JSI_ERROR;\n#if 0        \n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DSPrintf(&dStr, \"var %s = new CData({name:\\\"%s\\\", structName:\\\"%s\\\"});\", name, name, structName);\n        if (help)\n            Jsi_DSPrintf(&dStr, \", help:\\\"%s\\\"\", help);\n        /*if (vd[i].value)\n            Jsi_DSPrintf(&dStr, \", arrSize:%u\", (uint)vd[i].value);*/\n        if (varParm)\n            Jsi_DSPrintf(&dStr, \", varParam:\\\"%s\\\"\", varParm);\n        Jsi_DSPrintf(&dStr, \"});\");\n        Jsi_RC rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0);\n        Jsi_DSFree(&dStr);\n        if (rc != JSI_OK)\n            return JSI_ERROR;\n#endif\n    }\n    return JSI_OK;\n}\n\nJsi_StructSpec *jsi_csStructGet(Jsi_Interp *interp, const char *name)\n{\n    if (!name) return NULL;\n    Jsi_StructSpec *sl,*spec = Jsi_CDataStruct(interp, name);\n    if (spec) return spec;\n\n    Jsi_CData_Static *CData_Strs = interp->statics;\n    while (CData_Strs) {\n        sl = CData_Strs->structs;\n        while (sl->name) {\n            if (!Jsi_Strcmp(name, sl->name))\n                return sl;\n            sl++;\n        }\n        CData_Strs = CData_Strs->nextPtr;\n    }\n    return NULL;\n}\n\n\nJsi_EnumSpec *jsi_csGetEnum(Jsi_Interp *interp, const char *name) {\n    return (Jsi_EnumSpec *)Jsi_HashGet(interp->EnumHash, name, 0);\n}\n\n/* Traverse enum and match unique substring. */\nJsi_EnumSpec *jsi_csEnumGet(Jsi_Interp *interp, const char *name)\n{\n    Jsi_EnumSpec *sl, *spec = jsi_csGetEnum(interp, name);\n    if (spec) return spec;\n\n    Jsi_CData_Static *CData_Strs = interp->statics;\n    while (CData_Strs) {\n        sl = CData_Strs->enums;\n        while (sl->name) {\n            if (!Jsi_Strcmp(name, sl->name))\n                return sl;\n            sl++;\n        }\n        CData_Strs = CData_Strs->nextPtr;\n    }\n    return NULL;\n}\n\n/****************************************************************/\n\n/* Traverse from top looking for field in struct, match unique substrings. */\nJsi_FieldSpec *jsi_csFieldGet(Jsi_Interp *interp, const char *name, Jsi_StructSpec * sl)\n{\n    SIGASSERT(sl, OPTS_STRUCT);\n    Jsi_FieldSpec *sf, *ff = 0, *f = jsi_csGetFieldSpec(sl->extData);\n    int cnt = 0;\n    uint len = Jsi_Strlen(name);\n    sf = f;\n    SIGASSERT(sf, OPTS_FIELD);\n    while (sf->id != JSI_OPTION_END) {\n        if (!Jsi_Strncmp(name, sf->name, len)) {\n            if (!sf->name[len])\n                return sf;\n            ff = sf;\n            cnt++;\n        }\n        sf++;\n    }\n    if (cnt == 1)\n        return ff;\n    return 0;\n}\n  \n/* Traverse from top looking for item in enum, match unique substrings. */\nJsi_EnumSpec *jsi_csEnumGetItem(Jsi_Interp *interp, const char *name, Jsi_EnumSpec * el)\n{\n    SIGASSERT(el, OPTS_ENUM);\n    int cnt = 0;\n    uint len = Jsi_Strlen(name);\n    if (!el->extData)\n        return 0;\n    Jsi_FieldSpec *ff = NULL, *sf = jsi_csGetFieldSpec(el->extData);\n    while (sf->id != JSI_OPTION_END) {\n        if (!Jsi_Strncmp(name, sf->name, len)) {\n            if (!sf->name[len])\n                return sf;\n            ff = sf;\n            cnt++;\n        }\n        sf++;\n    }\n    if (cnt == 1)\n        return ff;\n    return 0;\n}\n\n/******* INIT ***************************************************/\n\n\n/* Initialize a struct to default values */\nstatic Jsi_RC jsi_csStructInit(Jsi_StructSpec * sl, uchar * data)\n{\n    /* Jsi_OptionSpec *sf; */\n    assert(sl);\n    if (!data) {\n        fprintf(stderr, \"missing data at %s:%d\", __FILE__, __LINE__);\n        return JSI_ERROR;\n    }\n    if (sl->custom)\n        memcpy(data, sl->custom, sl->size);\n    else if (sl->type && sl->type->extra)\n        memcpy(data, sl->type->extra, sl->size);\n    else\n        memset(data, 0, sl->size);\n\n    if (sl->ssig)\n        *(Jsi_Sig *) data = sl->ssig;\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataEnumNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                               Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n    \n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->EnumHash, ret, 0);\n    char *arg1 = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);\n    Jsi_EnumSpec *s, *sf;\n    if (arg1 == NULL || !(s = (Jsi_EnumSpec*)Jsi_HashGet(interp->EnumHash, arg1, 0)))\n        return Jsi_LogError(\"Unknown enum: %s\", arg1);\n    Jsi_ValueMakeArrayObject(interp, ret, NULL);\n    sf = (typeof(sf))s->extData;\n    int m = 0;\n    while (sf && sf->id != JSI_OPTION_END)\n    {\n        Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewBlobString(interp, sf->name), m++);\n        sf++;\n    }\n    return JSI_OK;\n}\n\n////// ENUM\n\nstatic Jsi_OptionSpec EnumOptions[] =\n{\n    JSI_OPT(INT64,      Jsi_EnumSpec, flags,  .help=\"Flags for enum\", jsi_IIOF),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, help,   .help=\"Description of enum\", jsi_IIOF ),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, name,   .help=\"Name of enum\", jsi_IIOF ),\n    JSI_OPT(UINT,       Jsi_EnumSpec, idx,    .help=\"Number of items in enum\", jsi_IIRO ),\n    JSI_OPT_END(Jsi_EnumSpec, .help=\"Options for CData enum\")\n};\n\nstatic Jsi_OptionSpec EnumFieldOptions[] =\n{\n    JSI_OPT(INT64,      Jsi_EnumSpec, flags,  .help=\"Flags for item\", jsi_IIOF),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, help,   .help=\"Desciption of item\", jsi_IIOF ),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, name,   .help=\"Name of item\", jsi_IIOF ),\n    JSI_OPT(INT64,      Jsi_EnumSpec, value,  .help=\"Value for item\", jsi_IIOF),\n    JSI_OPT(UINT,       Jsi_EnumSpec, idx,    .help=\"Index of item in enum\", jsi_IIRO ),\n    JSI_OPT_END(Jsi_EnumSpec, .help=\"Options for CData item\")\n};\n\nstatic Jsi_RC CDataEnumFieldConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_EnumSpec *ei, *sf;\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!(sf = jsi_csEnumGet(interp, arg1)))\n        return Jsi_LogError(\"unknown enum item: %s\", arg1);\n    ei = 0;\n    char *arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    if (!(ei = jsi_csEnumGetItem(interp, arg2, sf)))\n        return JSI_OK;\n\n    return CDataOptionsConf(interp, EnumFieldOptions, args, ei, ret, 0, 2);\n}\n\nstatic Jsi_RC CDataEnumConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_EnumSpec *sl;\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!(sl = jsi_csEnumGet(interp, arg1)))\n        return Jsi_LogError(\"unknown enum: %s\", arg1);\n    return CDataOptionsConf(interp, EnumOptions, args, sl, ret, 0, 1);\n}\n\n\nstatic Jsi_RC CDataEnumUndefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_HashEntry *entry = NULL;\n    Jsi_OptionTypedef *st = NULL;\n    if (name) {\n        entry = Jsi_HashEntryFind(interp->EnumHash, name);\n        st = Jsi_TypeLookup(interp, name);\n    }\n    if (!entry || !st)\n        return Jsi_LogError(\"Unknown enum: %s\", name);\n    Jsi_EnumSpec *sf, *sl = (typeof(sl))Jsi_HashValueGet(entry);\n    if (sl->value)\n        return Jsi_LogError(\"Enum in use\");\n    Jsi_HashEntryDelete(entry);\n    sf = (typeof(sf))sl->extData;\n    while (sf && sf->id != JSI_OPTION_END) {\n        entry = Jsi_HashEntryFind(interp->EnumItemHash, name);\n        if (entry)\n            Jsi_HashEntryDelete(entry);\n        sf++;\n    }\n    entry = Jsi_HashEntryFind(interp->CTypeHash, name);\n    if (entry)\n        Jsi_HashEntryDelete(entry);\n    else\n        Jsi_Free(st);\n    return JSI_OK;\n}\n\n/* Defines: Handles the \"CData.enum.define\" subcommand */\nstatic Jsi_RC CDataEnumDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    char **argv = NULL, *cmt, *cp;\n    Jsi_OptionTypedef *st = NULL;\n    jsi_csInitType(interp);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0),\n        *flds = Jsi_ValueArrayIndex(interp, args, 1);\n    int vlen, flen, i, argc;\n    Jsi_DString fStr = {};\n    const char **el, *vstr = Jsi_ValueString(interp, val, &vlen),\n        *fstr = Jsi_ValueString(interp, flds, &flen);\n    if (vstr) {\n        cmt = Jsi_Strstr(fstr, \"//\");\n        Jsi_DString tStr = {fstr};\n        fstr=jsi_TrimStr(Jsi_DSValue(&tStr));\n        Jsi_SplitStr(fstr, &argc, &argv, (cmt?\"\\n\":\",\"), &fStr);\n        Jsi_DSFree(&tStr);\n    } else if (!Jsi_ValueIsArray(interp,flds) || (argc=Jsi_ValueGetLength(interp, flds))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n\n    Jsi_EnumSpec *sl, *sf, recs[argc+1];\n    memset(recs, 0, sizeof(recs));\n    sl = recs+argc;\n    SIGINIT(sl, OPTS_ENUM);\n    if (vstr) {\n        sl->name = Jsi_KeyAdd(interp, vstr);\n    } else if (Jsi_OptionsProcess(interp, EnumOptions, sl, val, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(sl->name)) {\n        rc = Jsi_LogError(\"invalid enum name: %s\", sl->name);\n        goto bail;\n    }\n    if (jsi_csEnumGet(interp, sl->name)) {\n        rc = Jsi_LogError(\"enum already exists: %s\", sl->name);\n        goto bail;\n    }\n    for (i = 0; i<argc; i++) {\n        sf = recs+i;\n        SIGINIT(sf, OPTS_FIELD);\n        sf->idx = i;\n        if (i)\n            sf->value = recs[i-1].value+1;\n        if (!argv)\n            val = Jsi_ValueArrayIndex(interp, flds, i);\n        else {\n            if (cmt) {\n                cp = Jsi_Strstr(argv[i], \"//\"); \n                if (cp) {\n                    *cp = 0;\n                    cp += 2;\n                    cp = jsi_TrimStr(cp);\n                    sf->help = Jsi_KeyAdd(interp, cp);\n                }\n            }\n            cp = Jsi_Strchr(argv[i], ','); \n            if (cp) *cp = 0;\n            cp = Jsi_Strchr(argv[i], '='); \n            if (cp) {\n                *cp++ = 0;\n                cp = jsi_TrimStr(cp);\n                if (Jsi_GetWide(interp, cp, &sf->value, 0) != JSI_OK) {\n                    rc = Jsi_LogError(\"Bad value\");\n                    goto bail;\n                }\n            }\n            cp = jsi_TrimStr(argv[i]);\n            sf->name = Jsi_KeyAdd(interp, cp);\n            val = NULL;\n        }\n        if (val && Jsi_OptionsProcess(interp, EnumFieldOptions, sf, val, 0) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        if (Jsi_HashGet(interp->EnumItemHash, sf->name, 0)) {\n            rc = Jsi_LogError(\"duplicate enum item: %s\", sf->name);\n            goto bail;\n        }\n        if (!Jsi_StrIsAlnum(sf->name)) {\n            rc = Jsi_LogError(\"invalid enum item name: %s\", sf->name);\n            goto bail;\n        }\n    }\n    st = (typeof(st))Jsi_Calloc(1, sizeof(*st) + sizeof(char*)*(argc+1)+sizeof(recs));\n    SIGINIT(st, TYPEDEF);\n    sf = (typeof(sf))((uchar*)(st + 1));\n    sl = sf+argc;\n    el = (typeof(el))(sl + 1);\n    memcpy(sf, recs, sizeof(recs));\n    for (i = 0; i<argc; i++)\n        el[i] = sf[i].name;\n    sl->id = JSI_OPTION_END;\n    sl->extData = (uchar*)sf;\n    sl->data = el;\n    rc = jsi_csSetupEnum(interp, sl, sf, st);\nbail:\n    Jsi_DSFree(&fStr);\n    if (rc != JSI_OK && st)\n        Jsi_Free(st);\n    return rc;\n}\n\nstatic Jsi_RC CDataEnumValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                               Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    const char *arg1, *arg2;\n    Jsi_EnumSpec *ei, *el = 0;\n    arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    if (!(el = jsi_csEnumGet(interp, arg1))) {\n        return JSI_OK;\n    }\n    if (!(ei = jsi_csEnumGetItem(interp, arg2, el)))\n        return JSI_OK;\n    Jsi_ValueMakeNumber(interp, ret, ei->value);\n    return JSI_OK;\n}\n\n\n/* Return the enum symbol that matches the given integer value. */\nstatic Jsi_RC CDataEnumFindCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_EnumSpec *ei, *el;\n    if (!(el = jsi_csEnumGet(interp, arg1)))\n        return Jsi_LogError(\"Unknown enum: %s\", arg1);\n    Jsi_Wide wval;\n    if (Jsi_GetWideFromValue(interp, arg2, &wval) != JSI_OK)\n        return JSI_ERROR;\n\n    ei = (typeof(ei))el->extData;\n    uint i;\n    for (i=0; i<el->size; i++) {\n        if (wval == (Jsi_Wide)ei[i].value) {\n            Jsi_ValueMakeStringKey(interp, ret, ei[i].name);\n            return JSI_OK;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataEnumGetDfn(Jsi_Interp *interp, Jsi_EnumSpec * sl, Jsi_DString *dsPtr)\n{\n    \n    Jsi_EnumSpec *sf;\n    Jsi_DString eStr = {};\n\n    Jsi_DSAppend(dsPtr, \"{ name: \\\"\", sl->name, \"\\\"\", NULL);\n    if (sl->flags)\n        Jsi_DSPrintf(dsPtr, \", flags:%\" PRIx64, sl->flags);\n    if (sl->help && sl->help[0]) {\n        Jsi_DSAppend(dsPtr, \", help:\", Jsi_JSONQuote(interp, sl->help, -1, &eStr), NULL);\n        Jsi_DSFree(&eStr);\n    }\n    sf = jsi_csGetFieldSpec(sl->extData);\n    Jsi_DSAppend(dsPtr, \", fields:[\", NULL);\n    while (sf->id != JSI_OPTION_END) {\n        Jsi_DSPrintf(dsPtr, \" { name:\\\"%s\\\", value:%#\" PRIx64, sf->name, (int64_t)sf->value);\n        if (sf->help && sf->help[0]) {\n            Jsi_DSAppend(dsPtr, \", help:\", Jsi_JSONQuote(interp, sf->help, -1, &eStr), NULL);\n            Jsi_DSFree(&eStr);\n        }\n        Jsi_DSAppend(dsPtr, \"}\", NULL);\n        sf++;\n    }\n    Jsi_DSAppend(dsPtr, \"]}\", NULL);\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataEnumGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_EnumSpec *sl = jsi_csEnumGet(interp, name);\n    if (!sl)\n        return JSI_OK;\n    JSI_DSTRING_VAR(dsPtr, 400);\n    Jsi_RC rc = CDataEnumGetDfn(interp, sl, dsPtr);\n    if (JSI_OK == rc)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(dsPtr), ret, 0);\n    Jsi_DSFree(dsPtr);\n    return rc;\n}\n\nstatic Jsi_CmdSpec enumCmds[] = {\n    {\"add\",     CDataEnumDefineCmd,  2, 2, \"options:object|string, fields:array|string\", .help=\"Create a new enum: value of items same as in fieldconf\", .retType=0, .flags=0, .info=0, .opts=EnumOptions},\n    {\"conf\",    CDataEnumConfCmd,    1, 2, \"enum:string, options:object|string=void\",.help=\"Configure options for enum\", .retType=0, .flags=0, .info=0, .opts=EnumOptions},\n    {\"fieldconf\",CDataEnumFieldConfCmd,2, 3, \"enum:string, field:string, options:object|string=void\",.help=\"Configure options for fields\", .retType=0, .flags=0, .info=0, .opts=EnumFieldOptions},\n    {\"find\",    CDataEnumFindCmd,    2, 2, \"enum:string, intValue:number\", .help=\"Find item with given value in enum\", .retType=(uint)JSI_TT_STRING},\n    {\"get\",     CDataEnumGetCmd,     1, 1, \"enum:string\", .help=\"Return enum definition\", .retType=(uint)JSI_TT_OBJECT},\n    {\"names\",   CDataEnumNamesCmd,   0, 1, \"enum:string=void\", .help=\"Return name list of all enums, or items within one enum\", .retType=(uint)JSI_TT_ARRAY},\n    {\"remove\",  CDataEnumUndefineCmd,1, 1, \"enum:string\",.help=\"Remove an enum\", .retType=0, .flags=0, .info=0, .opts=0},\n    {\"value\",   CDataEnumValueCmd,   2, 2, \"enum:string, item:string\", .help=\"Return value for given enum item\", .retType=(uint)JSI_TT_NUMBER},\n    { NULL,   0,0,0,0, .help=\"Enum commands. Note: Enum() is a shortcut for Enum.add()\" }\n};\n\n/************************** STRUCT ******************************/\n\nstatic Jsi_RC CDataStructGetDfn(Jsi_Interp *interp, Jsi_StructSpec * sl, Jsi_DString *dsPtr)\n{\n    \n    Jsi_StructSpec *sf;\n    Jsi_DString eStr = {};\n    sf = jsi_csGetFieldSpec(sl->extData);\n    Jsi_DSPrintf(dsPtr, \"{ \\\"name\\\": \\\"%s\\\", \\\"size\\\":%d\", sl->name, sl->size);\n    if (sl->flags)\n        Jsi_DSPrintf(dsPtr, \", \\\"flags\\\":0x%\" PRIx64, sl->flags);\n    if (sl->help && sl->help[0]) {\n        Jsi_DSAppend(dsPtr, \", \\\"label\\\":\", Jsi_JSONQuote(interp, sl->help, -1, &eStr), NULL);\n        Jsi_DSFree(&eStr);\n    }\n    if (sl->ssig)\n        Jsi_DSPrintf(dsPtr, \", \\\"sig\\\":0x%x\", sl->ssig);\n    Jsi_DSAppend(dsPtr, \", \\\"fields\\\":[\", NULL);\n#define SSIFNV(s) (s?\"\\\"\":\"\"), (s?s:\"null\"), (s?\"\\\"\":\"\")\n    while (sf->id != JSI_OPTION_END) {\n        Jsi_DSPrintf(dsPtr, \" { \\\"name\\\":\\\"%s\\\",  \\\"id\\\":%s%s%s, \\\"size\\\":%d, \\\"bitsize\\\":%d,\"\n            \"\\\"offset\\\":%d, , \\\"bitoffs\\\":%d, \\\"isbit\\\":%d, \\\"label\\\":\",\n             sf->name, SSIFNV(sf->tname), sf->size, sf->bits,\n             sf->offset, sf->boffset, sf->flags&JSI_OPT_IS_BITS?1:0 );\n        if (sf->help && sf->help[0]) {\n            Jsi_DSAppend(dsPtr, Jsi_JSONQuote(interp, sf->help, -1, &eStr), NULL);\n            Jsi_DSFree(&eStr);\n        } else\n            Jsi_DSAppend(dsPtr,\"\\\"\\\"\", NULL);\n        Jsi_DSAppend(dsPtr, \"}\", NULL);\n        sf++;\n    }\n    Jsi_DSAppend(dsPtr, \"]}\", NULL);\n    return JSI_OK;\n}\n\n/* Return the structure definition. */\nstatic Jsi_RC CDataStructGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sl = jsi_csStructGet(interp, arg1);\n\n    if (!sl)\n        return Jsi_LogError(\"unkown struct: %s\", arg1);\n    Jsi_DString dStr = {};\n    Jsi_RC rc = CDataStructGetDfn(interp, sl, &dStr);\n    if (JSI_OK == rc)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC CDataStructNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                 Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->StructHash, ret, 0);\n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sf, *sl;\n    if (name == NULL || !(sl = Jsi_CDataStruct(interp, name)))\n        return Jsi_LogError(\"Unknown struct: %s\", name);\n    Jsi_ValueMakeArrayObject(interp, ret, NULL);\n    sf = (typeof(sf))sl->data;\n    int m = 0;\n    while (sf && sf->id != JSI_OPTION_END)\n    {\n        Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewBlobString(interp, sf->name), m++);\n        sf++;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataStructSchemaCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sf = jsi_csStructFields(interp, arg1);\n\n    if (!sf)\n        return Jsi_LogError(\"unkown struct: %s\", arg1);;\n\n    Jsi_DString dStr = {};\n    Jsi_OptionsData(interp, (Jsi_OptionSpec*)sf, &dStr, 1);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\n}\n\n/* Scanning function */\nstatic Jsi_RC jsi_csValueToFieldType(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    const Jsi_OptionTypedef *typ, **sp = (typeof(sp))(((uchar*)record) + spec->offset);\n\n    if (!inStr) {\n        if (!inValue || Jsi_ValueIsString(interp, inValue)==0)\n            return Jsi_LogError(\"expected string\");\n        inStr = Jsi_ValueString(interp, inValue, NULL);\n    }\n    typ = Jsi_TypeLookup(interp, inStr);\n    if (!typ)\n        return Jsi_LogError(\"unknown type: %s\", inStr);\n    *sp = typ;\n    return JSI_OK;\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_csFieldTypeToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    const Jsi_OptionTypedef **sp = (typeof(sp))(((uchar*)record) + spec->offset), *sptr = *sp;\n    //const char **s = (const char**)((char*)record + spec->offset);\n    if (sptr)\n        SIGASSERT(sptr, TYPEDEF);\n    if (sptr && sptr->cName)\n        Jsi_ValueMakeStringKey(interp, outValue, sptr->cName);\n    else\n        Jsi_ValueMakeNull(interp, outValue);\n    return JSI_OK;\n}\n\nJsi_OptionCustom jsi_OptSwitchFieldType = {\n    .name=\"fieldtype\", .parseProc=jsi_csValueToFieldType, .formatProc=jsi_csFieldTypeToValue, .freeProc=NULL,\n};\n\n\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToIniVal(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    uchar *data = (uchar*)record, *odata;\n    //Jsi_OptionValue iv;\n    int idx = (intptr_t)spec->data;\n    if (idx<=0 || !inValue)\n        return Jsi_LogError(\"idx/value not set\");\n    Jsi_OptionSpec *typePtr = spec-idx;\n    if (typePtr->id != JSI_OPTION_CUSTOM || typePtr->custom != &jsi_OptSwitchFieldType)\n        return Jsi_LogError(\"Bad field type\");\n    const Jsi_OptionTypedef **tsp = (typeof(tsp))(data + typePtr->offset), *tsptr = *tsp, *ssp;\n    SIGASSERT(tsptr, TYPEDEF);\n    Jsi_FieldSpec *sf = jsi_csGetFieldSpec(data);\n    Jsi_StructSpec *sl = jsi_csGetStructSpec(sf->extData);\n    ssp = sl->type;\n    SIGASSERT(ssp, TYPEDEF);\n    odata = ssp->extra;\n    if (!tsptr->sfmt) {\n        if (tsptr->flags&jsi_CTYP_STRUCT && tsptr->extra) {\n            if (!Jsi_ValueIsBoolean(interp, inValue)) Jsi_LogWarn(\"init for struct must be boolean\");\n            if (!Jsi_ValueIsTrue(interp, inValue)) return JSI_OK;\n            Jsi_StructSpec *tsl = jsi_csGetStructSpec(tsptr->extData);\n            int i, n = (sf->arrSize?sf->arrSize:1);\n            for (i=0; i<n; i++)\n                memcpy(odata+sf->offset+i*tsl->size, tsptr->extra, tsl->size);\n            return JSI_OK;\n        } else if (!(tsptr->flags&jsi_CTYP_ENUM))\n            return Jsi_LogError(\"init not supported for type: %s\", tsptr->cName);\n    }\n    return jsi_SetOption(interp, sf, \"init\", odata, inValue, flags, interp->isSafe);\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_IniValToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    uchar *data = (uchar*)record, *odata;\n    int idx = (intptr_t)spec->data;\n    if (idx<=0 || !outValue)\n        return Jsi_LogError(\"idx/value not set\");\n    Jsi_OptionSpec *typePtr = spec-idx;\n    if (typePtr->id != JSI_OPTION_CUSTOM || typePtr->custom != &jsi_OptSwitchFieldType)\n        return Jsi_LogError(\"Bad field type\");\n    const Jsi_OptionTypedef **tsp = (typeof(tsp))(data + typePtr->offset), *tsptr = *tsp, *ssp;\n    SIGASSERT(tsptr, TYPEDEF);\n    Jsi_FieldSpec *sf = jsi_csGetFieldSpec(data);\n    Jsi_StructSpec *sl = jsi_csGetStructSpec(sf->extData);\n    ssp = sl->type;\n    SIGASSERT(ssp, TYPEDEF);\n    odata = ssp->extra;\n    if (odata && tsptr->sfmt)\n        return jsi_GetOption(interp, sf, odata, \"init\", outValue, flags);\n\n    Jsi_ValueMakeNull(interp, outValue);\n    return JSI_OK;\n    \n    //Jsi_OptionSpec ospec = {.sig=JSI_SIG_OPTS, .id=tsptr->id, .name=\"init\", .offset=0, .size=sizeof(Jsi_OptionValue) };\n    //return jsi_GetOption(interp, &ospec, odata, ospec.name, outValue, flags);\n}\n\nJsi_OptionCustom jsi_OptSwitchIniVal = {\n    .name=\"inival\", .parseProc=jsi_ValueToIniVal, .formatProc=jsi_IniValToValue\n};\n\nstatic Jsi_OptionSpec StructOptions[] =\n{\n    JSI_OPT(UINT32, Jsi_StructSpec, crc,     .help=\"Crc for struct\", jsi_IIOF ),\n    JSI_OPT(INT64,  Jsi_StructSpec, flags,   .help=\"Flags for struct\", jsi_IIOF ),\n    JSI_OPT(STRKEY, Jsi_StructSpec, help,    .help=\"Struct description\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec, idx,     .help=\"Number of fields in struct\", jsi_IIRO ),\n    JSI_OPT(STRKEY, Jsi_StructSpec, name,    .help=\"Name of struct\", jsi_IIOF|JSI_OPT_REQUIRED ),\n    JSI_OPT(UINT,   Jsi_StructSpec, size,    .help=\"Size of struct in bytes\", jsi_IIRO ),\n    JSI_OPT(UINT32, Jsi_StructSpec, ssig,    .help=\"Signature for struct\", jsi_IIOF),\n    JSI_OPT(INT64,  Jsi_StructSpec, value,   .help=\"Reference count\", jsi_IIRO ),\n    JSI_OPT_END(Jsi_StructSpec, .help=\"Options for CData struct create\")\n};\n\nstatic Jsi_OptionSpec StructFieldOptions[] =\n{\n    JSI_OPT(UINT,   Jsi_StructSpec,   arrSize,.help=\"Size of field if an array\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec,   bits,   .help=\"Size of bitfield\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec,   boffset,.help=\"Bit offset of field within struct\", jsi_IIRO ),\n    JSI_OPT(INT64,  Jsi_StructSpec,   flags,  .help=\"Flags for field\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec,   idx,    .help=\"Index of field in struct\", jsi_IIRO ),\n    JSI_OPT(STRKEY, Jsi_StructSpec,   help,   .help=\"Field description\", jsi_IIOF ),\n    JSI_OPT(STRKEY, Jsi_StructSpec,   info,   .help=\"Info for field\", jsi_IIOF ),\n    JSI_OPT(STRKEY, Jsi_StructSpec,   name,   .help=\"Name of field\", jsi_IIOF|JSI_OPT_REQUIRED ),\n    JSI_OPT(UINT,   Jsi_StructSpec,   offset, .help=\"Offset of field within struct\", jsi_IIRO ),\n    JSI_OPT(UINT,   Jsi_StructSpec,   size,   .help=\"Size of field in struct\", jsi_IIRO ),\n    JSI_OPT(CUSTOM, Jsi_StructSpec,   type,   .help=\"Type of field\", jsi_IIOF|JSI_OPT_REQUIRED, .custom=&jsi_OptSwitchFieldType,  .data=NULL ),\n    JSI_OPT(CUSTOM, Jsi_StructSpec,   init,   .help=\"Initial value for field\", jsi_IIOF|JSI_OPT_PASS2, .custom=&jsi_OptSwitchIniVal, .data=(void*)1  ),\n    JSI_OPT_END(Jsi_StructSpec, .help=\"Options for CData struct field\")\n};\n\nstatic Jsi_RC CDataOptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *args,\n    void *rec, Jsi_Value **ret, int flags, int skipArgs)\n{\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *val;\n    flags |= JSI_OPTS_IS_UPDATE;\n\n    if (argc == skipArgs)\n        return Jsi_OptionsDump(interp, specs, rec, ret, flags);\n    val = Jsi_ValueArrayIndex(interp, args, skipArgs);\n    Jsi_vtype vtyp = Jsi_ValueTypeGet(val);\n    if (vtyp == JSI_VT_STRING) {\n        char *str = Jsi_ValueString(interp, val, NULL);\n        return Jsi_OptionsGet(interp, specs, rec, str, ret, flags);\n    }\n    if (vtyp != JSI_VT_OBJECT && vtyp != JSI_VT_NULL)\n        return Jsi_LogError(\"expected string, object, or null\");\n    if (Jsi_OptionsProcess(interp, specs, rec, val, JSI_OPTS_IS_UPDATE) < 0)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n\n/* Defines: Handles the \"CData.struct.conf\" subcommand */\nstatic Jsi_RC CDataStructConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sl = jsi_csStructGet(interp, arg1);\n    if (!sl)\n        return Jsi_LogError(\"unknown struct: %s\", arg1);\n    return CDataOptionsConf(interp, StructOptions, args, sl, ret, 0, 1);\n}\n\nstatic Jsi_RC CDataStructUndefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_HashEntry *entry = NULL;\n    if (name)\n        entry = Jsi_HashEntryFind(interp->StructHash, name);\n    if (!entry)\n        return Jsi_LogError(\"Unknown struct: %s\", name);\n    Jsi_StructSpec *sl = (typeof(sl))Jsi_HashValueGet(entry);\n    if (sl->value)\n        return Jsi_LogError(\"Struct in use: %d\", (int)sl->value);\n    Jsi_HashEntryDelete(entry);\n    entry = Jsi_HashEntryFind(interp->CTypeHash, name);\n    if (entry)\n        Jsi_HashEntryDelete(entry);\n    return JSI_OK;\n}\n\n/* Defines: Handles the \"CData.define\" subcommand */\nstatic Jsi_RC CDataStructDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_RC rc = JSI_OK;\n    Jsi_OptionTypedef *st = NULL;\n    jsi_csInitType(interp);\n    Jsi_Value *eval = NULL, *val = Jsi_ValueArrayIndex(interp, args, 0),\n        *flds = Jsi_ValueArrayIndex(interp, args, 1);\n    int vlen, flen, i, argc, clen = 0, arrCnt=0;\n    Jsi_DString fStr = {};\n    char **argv = NULL, *cmt, *eq, *cp, *ce, *cpval, ocp;\n    const char *vstr = Jsi_ValueString(interp, val, &vlen),\n        *fstr = Jsi_ValueString(interp, flds, &flen);\n    if (vstr) {\n        cmt = Jsi_Strstr(fstr, \"//\");\n        eq = Jsi_Strchr(fstr, '=');\n        Jsi_DString tStr = {fstr};\n        fstr=jsi_TrimStr(Jsi_DSValue(&tStr));\n        Jsi_SplitStr(fstr, &argc, &argv, (cmt?\"\\n\":\";\"), &fStr);\n        Jsi_DSFree(&tStr);\n        if (!cmt && argc>0 && !argv[argc-1][0])\n            argc--;\n        if (eq) {\n            eval = Jsi_ValueNewArray(interp, NULL, 0);\n            Jsi_IncrRefCount(interp, eval);\n        }\n    } else if (!Jsi_ValueIsArray(interp,flds) || (argc=Jsi_ValueGetLength(interp, flds))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n    if (argc>200)\n        return Jsi_LogError(\"too many fields: %d>200\", argc);\n    Jsi_StructSpec *sl, *sf, recs[argc+2];\n    memset(recs, 0, sizeof(recs));\n    sl = recs+argc+1;\n    sf = recs;\n    SIGINIT(sl, OPTS_STRUCT);\n    if (vstr) {\n        sl->name = Jsi_KeyAdd(interp, vstr);\n    } else if (Jsi_OptionsProcess(interp, StructOptions, sl, val, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(sl->name)) {\n        rc = Jsi_LogError(\"invalid struct name: %s\", sl->name);\n        goto bail;\n    }\n    if (jsi_csStructGet(interp, sl->name)) {\n        rc = Jsi_LogError(\"struct already exists: %s\", sl->name);\n        goto bail;\n    }\n    for (i = 0; i<argc; i++) {\n        Jsi_Number numVal = 0;\n        bool bVal, isbitset = 0;\n        Jsi_Value *inival = NULL;\n        sf = recs+i;\n        SIGINIT(sf, OPTS_FIELD);\n        if (!argv) {\n            val = Jsi_ValueArrayIndex(interp, flds, i);\n            if (!val || Jsi_OptionsProcess(interp, StructFieldOptions, sf, val, 0) < 0) {\n                rc = JSI_ERROR;\n                goto bail;\n            }\n            if (!Jsi_StrIsAlnum(sf->name) || !sf->type) {\n                rc = Jsi_LogError(\"invalid struct field name: %s\", sf->name);\n                goto bail;\n            }\n            if (!Jsi_ValueObjLookup(interp, val, \"init\", 0) && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n        } else {\n            if (cmt) {\n                cp = Jsi_Strstr(argv[i], \"//\"); \n                if (cp) {\n                    *cp = 0;\n                    cp += 2;\n                    cp = jsi_TrimStr(cp);\n                    sf->help = Jsi_KeyAdd(interp, cp);\n                }\n                cp = Jsi_Strchr(argv[i], ';'); \n                if (cp) *cp = 0;\n            }\n            cp = Jsi_Strchr(argv[i], '='); \n            if (cp) {\n                if (!eval)\n                    goto bail;\n                *cp++ = 0;\n                cp = jsi_TrimStr(cp);\n                int cplen = Jsi_Strlen(cp);\n                if (cplen>1 && (cp[0] == '\\'' || cp[0] == '\"') && cp[0] == cp[cplen-1]) {\n                    cpval = cp+1;\n                    cp[cplen-1] = 0;\n                    inival = Jsi_ValueNewStringDup(interp, cpval);\n                }\n                else if (Jsi_GetDouble(interp, cp, &numVal) == JSI_OK)\n                    inival = Jsi_ValueNewNumber(interp, numVal);\n                else if (Jsi_GetBool(interp, cp, &bVal) == JSI_OK)\n                    inival = Jsi_ValueNewBoolean(interp, bVal);\n                else\n                    inival = Jsi_ValueNewStringDup(interp, cp);\n            }\n            cp = argv[i];\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && !isspace(*ce)) ce++;\n            ocp = *ce;\n            if (!ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            *ce = 0;\n            sf->type = Jsi_TypeLookup(interp, cp);\n            *ce = ocp;\n            if (!sf->type) {\n                rc = Jsi_LogError(\"unknown type: %s\", argv[i]);\n                goto bail;\n            }\n            if (!inival && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n\n            cp = ce+1;\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && (isalnum(*ce) || *ce == '_')) ce++;\n            ocp = *ce;\n            *ce = 0;\n            if (!*cp) {\n                rc = Jsi_LogError(\"missing or bad struct field name\");\n                goto bail;\n            }\n            sf->name = Jsi_KeyAdd(interp, cp);\n            if (ocp) {\n                ce++;\n                clen = Jsi_Strlen(ce);\n            }\n            if (ocp == '@') {\n                isbitset = 1;\n            } else\n            if (ocp == ':') {\n                int bsiz = -1;\n                if (Jsi_GetInt(interp, ce, &bsiz,10) != JSI_OK || bsiz<=0 || bsiz>64) {\n                    rc = Jsi_LogError(\"bad bit size: %s\", ce);\n                    goto bail;\n                }\n                sf->bits = bsiz;\n            } else if (ocp == '[' && clen>1 && ce[clen-1]==']') {\n                int asiz = -1;\n                ce[clen-1] = 0;\n                if (Jsi_GetInt(interp, ce, &asiz, 10) != JSI_OK || asiz<=0) {\n                    rc = Jsi_LogError(\"bad size: %s\", cp);\n                    goto bail;\n                }\n                sf->arrSize = asiz;\n            } else if (ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            val = NULL;            \n        }\n        if (inival) {\n            Jsi_Value *sval = Jsi_ValueNewObj(interp, NULL);\n            Jsi_ValueInsert(interp, sval, \"init\", inival, 0);\n            Jsi_ValueArraySet(interp, eval, sval, i);\n        }\n        bool isEnum = (sf->type && (sf->type->flags&jsi_CTYP_ENUM));\n        if (isbitset) {\n            if (!isEnum) {\n                rc = Jsi_LogError(\"bitset type is not an enum\");\n                goto bail;\n            }\n            sf->flags |= JSI_OPT_BITSET_ENUM;\n        }\n        if (sf->arrSize) {\n            if (sf->arrSize>MAX_ARRAY_LIST) {\n                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, MAX_ARRAY_LIST);\n                goto bail;\n            }\n            if (sf->bits || isEnum) {\n                rc = Jsi_LogError(\"array of %s unsupported\", (sf->bits?\"bits\":\"enums\"));\n                goto bail;\n            }\n            arrCnt++;\n        }\n    }\n    recs[argc].id = JSI_OPTION_END;\n    rc = jsi_csSetupStruct(interp, sl, recs, recs, argc, &st, arrCnt);\n    if (rc != JSI_OK || !st) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sl = jsi_csGetStructSpec(st->extData);\n    sf = jsi_csGetFieldSpec(sl->extData);\n    if (vstr)\n        flds = eval;\n    for (i = 0; i<argc && flds; i++) {\n        val = Jsi_ValueArrayIndex(interp, flds, i);\n        if (val && Jsi_OptionsProcess(interp, StructFieldOptions, sf+i, val, JSI_OPT_PASS2) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n    }\nbail:\n    if (eval)\n        Jsi_DecrRefCount(interp, eval);\n    Jsi_DSFree(&fStr);\n    if (rc != JSI_OK && st)\n        Jsi_HashEntryDelete(st->hPtr);\n    return rc;\n}\n\n/* Defines: Handles the \"CData.struct.fieldconf\" subcommand */\nstatic Jsi_RC CDataStructFieldConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sf, *sl = jsi_csStructGet(interp, arg1);\n    if (!sl)\n        return Jsi_LogError(\"unknown struct: %s\", arg1);\n    char *arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    if (!arg2 || !(sf = jsi_csFieldGet(interp, arg2, sl)))\n        return Jsi_LogError(\"unknown field: %s\", arg2);\n    return CDataOptionsConf(interp, StructFieldOptions, args, sf, ret, 0, 2);\n}\n\nstatic Jsi_CmdSpec structCmds[] =\n{\n    {\"add\",       CDataStructDefineCmd, 2, 2, \"options:object|string, fields:array|string\", .help=\"Create a struct: field values same as in fieldconf\", .retType=0, .flags=0, .info=0, .opts=StructOptions},\n    {\"conf\",      CDataStructConfCmd,   1, 2, \"struct:string, options:object|string=void\", .help=\"Configure options for struct\", .retType=0, .flags=0, .info=0, .opts=StructOptions},\n    {\"fieldconf\", CDataStructFieldConfCmd,2,3,\"struct:string, field:string, options:object|string=void\", .help=\"Configure options for fields\", .retType=0, .flags=0, .info=0, .opts=StructFieldOptions},\n    {\"get\",       CDataStructGetCmd,    1, 2, \"struct, options:object=void\", .help=\"Return the struct definition\", .retType=(uint)JSI_TT_OBJECT},\n    {\"names\",     CDataStructNamesCmd,  0, 1, \"struct:string=void\", .help=\"Return name list of all structs, or fields for one struct\", .retType=(uint)JSI_TT_ARRAY},\n    {\"remove\",    CDataStructUndefineCmd,1, 1, \"name:string\",.help=\"Remove a struct\", .retType=0, .flags=0, .info=0, .opts=0},\n    {\"schema\",    CDataStructSchemaCmd, 1, 1, \"\", .help=\"Return database schema for struct\", .retType=(uint)JSI_TT_STRING },\n    { NULL,   0,0,0,0, .help=\"Struct commands. Note: Struct() is a shortcut for Struct.add()\" }\n};\n\n\n\nstatic Jsi_RC jsi_csGetKey(Jsi_Interp *interp, CDataObj *cd, Jsi_Value *arg, void **kPtr, size_t ksize, int anum)\n{\n    void *kBuf = *kPtr;\n    *kPtr = NULL;\n    if (!arg)\n        return Jsi_LogError(\"missing key arg\");;\n    Jsi_Number nval = 0;\n    switch (cd->keyType) {\n        case JSI_KEYS_STRING:\n        case JSI_KEYS_STRINGKEY:\n            *kPtr = (void*)Jsi_ValueString(interp, arg, NULL);\n            if (!*kPtr)\n                return Jsi_LogError(\"arg %d: expected string key\", anum);\n            break;\n        case JSI_KEYS_ONEWORD:\n            if (Jsi_ValueGetNumber(interp, arg, &nval) != JSI_OK)\n                return Jsi_LogError(\"arg %d: expected number key\", anum);\n            *kPtr = (void*)(uintptr_t)nval;\n            break;\n        default: {\n            if (!cd->slKey) {\nbadkey:\n                return Jsi_LogError(\"arg %d: expected struct key\", anum);\n            }\n            if (arg->vt == JSI_VT_OBJECT && arg->d.obj->ot == JSI_OT_OBJECT) {\n                if (cd->slKey->size>ksize || !kBuf)\n                    goto badkey;\n                memset(kBuf, 0, cd->slKey->size);\n                if (Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->keysf, kBuf, arg, NULL, 0) != JSI_OK)\n                    return JSI_ERROR;\n                *kPtr = kBuf;\n            } else\n                return Jsi_LogError(\"arg %d: expected object key\", anum);\n        }\n    }\n    return JSI_OK;\n}\n\n#define FN_dataGetN JSI_INFO(\"If given a name argument, gets data for the named field. \\\nOtherwise gets data for all fields in struct.\")\nstatic Jsi_RC CDataGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    uchar *dptr = NULL;\n    Jsi_Value *karg = Jsi_ValueArrayIndex(interp, args, 0);\n    char kbuf[BUFSIZ];\n    void *key = kbuf;\n    bool isNull = (!karg || Jsi_ValueIsNull(interp, karg));\n    if (isNull) {\n        if (cd->mapPtr || cd->arrSize>1)\n            return Jsi_LogError(\"null key used with c-array/map\");\n    } else {\n        if (!cd->mapPtr && cd->arrSize<=0)\n            return Jsi_LogError(\"must be array/map\");\n        if (JSI_OK != jsi_csGetKey(interp, cd, karg, &key, sizeof(kbuf), 1))\n        return JSI_ERROR;\n    }\n\n    dptr = (uchar*)cd->data;\n    if (isNull) {\n    } else if (cd->mapPtr) {\n        Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);\n        if (mPtr)\n            dptr = (uchar*)Jsi_MapValueGet(mPtr);\n        else\n            return Jsi_LogError(\"arg 1: key not found [%s]\", Jsi_ValueToString(interp, karg, NULL));\n    } /*else if (!cd->arrSize)\n        return Jsi_LogError(\"arg 2: expected a c-array or map\");*/\n    else {\n        uint kind = (intptr_t)key;\n        if (kind>=cd->arrSize)\n            return Jsi_LogError(\"array index out of bounds: %d not in 0,%d\", kind, cd->arrSize-1);\n\n        dptr = ((uchar*)cd->data) + cd->sl->size*kind;\n        if (cd->isPtrs)\n            dptr = ((uchar*)cd->data) + sizeof(void*)*kind;\n        else if (cd->isPtr2) {\n            dptr = (uchar*)(*(void**)dptr);\n            dptr += sizeof(void*)*kind;\n        }\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc > 2)\n        return Jsi_LogError(\"expected 0 - 2 args\");\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);\n    return Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, dptr, arg2, ret, 0);\n}\n\n#define FN_dataSet JSI_INFO(\"Sets data value for given a name argument.\")\nstatic Jsi_RC CDataSetCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    UdcGet(cd, _this, funcPtr);\n    uchar *dptr = NULL;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    char kbuf[BUFSIZ];\n    void *key = kbuf;\n    bool isNull = Jsi_ValueIsNull(interp, arg);\n    if (isNull) {\n        if (cd->mapPtr || cd->arrSize)\n            return Jsi_LogError(\"null key used with c-array/map\");\n    } else {\n        if (!cd->mapPtr && cd->arrSize<=0)\n            return Jsi_LogError(\"must be array/map\");\n        if (JSI_OK != jsi_csGetKey(interp, cd, arg, &key, sizeof(kbuf), 1))\n            return JSI_ERROR;\n    }\n\n    dptr = (uchar*)cd->data;\n    if (isNull) {\n    } else if (cd->mapPtr) {\n        Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);\n        if (mPtr)\n            dptr = (uchar*)Jsi_MapValueGet(mPtr);\n        else {\n            bool isNew;\n            if (cd->maxSize && Jsi_MapSize(*cd->mapPtr)>=cd->maxSize)\n                return Jsi_LogError(\"map would exceeded maxSize: %d\", cd->maxSize);\n            if (!cd->noAuto)\n                mPtr = Jsi_MapEntryNew(*cd->mapPtr, key, &isNew);\n            if (!mPtr)\n                return Jsi_LogError(\"arg 1: key not found [%s]\", Jsi_ValueToString(interp, arg, NULL));\n            Jsi_StructSpec *sl = cd->sl;\n            dptr = (uchar*)Jsi_Calloc(1, sl->size);\n            Jsi_MapValueSet(mPtr, dptr);\n            jsi_csStructInit(sl, dptr);\n        }\n    } else if (!cd->arrSize)\n        return Jsi_LogError(\"expected a c-array or map\");\n    else {\n        uint kind = (uintptr_t)key;\n        if (kind>=cd->arrSize)\n            return Jsi_LogError(\"array index out of bounds: %d not in 0,%d\", kind, cd->arrSize-1);\n        dptr = ((uchar*)cd->data) + cd->sl->size*kind;\n        if (cd->isPtrs)\n            dptr = ((uchar*)cd->data) + sizeof(void*)*kind;\n        else if (cd->isPtr2)\n            dptr = (uchar*)(*(void**)dptr) + sizeof(void*)*kind;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);\n    if (op == 2 && argc == 2) {\n    } else if (argc == 2) {\n        if (!Jsi_ValueIsObjType(interp, arg2, JSI_OT_OBJECT))\n            return Jsi_LogError(\"arg 3: last must be an object with 3 args\");\n        return Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, dptr, arg2, ret, 0);\n    } else if (argc != 3)\n        return Jsi_LogError(\"expected 2 or 3 args\");\n    const char *cp;\n    if (!(cp = Jsi_ValueString(interp, arg2, NULL)))\n        return Jsi_LogError(\"with 3 args, string expected for arg 2\");\n    Jsi_Value *arg3 = Jsi_ValueArrayIndex(interp, args, 2);\n    if (op == 2) {\n        if (arg3) {\n            if (!Jsi_ValueIsNumber(interp, arg3))\n                return Jsi_LogError(\"expected number\");\n        } else {\n            arg3 = Jsi_ValueNewNumber(interp, 1);\n            Jsi_IncrRefCount(interp, arg3);\n        }\n    }\n    Jsi_RC rc = Jsi_OptionsSet(interp, (Jsi_OptionSpec*)cd->sf, dptr, cp, arg3, (op==2?JSI_OPTS_INCR:0));\n    if (op==2 && argc==2)\n        Jsi_DecrRefCount(interp, arg3);\n    if (op == 2 && rc == JSI_OK) {\n        if (interp->strict && Jsi_NumberIsNaN(interp->cdataIncrVal))\n            return Jsi_LogError(\"result is NaN\");\n        Jsi_ValueMakeNumber(interp, ret, interp->cdataIncrVal);\n    }\n    return rc;\n}\n\nstatic Jsi_RC CDataSetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return CDataSetCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC CDataIncrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return CDataSetCmd_(interp, args, _this, ret, funcPtr, 2);\n}\n\nstatic Jsi_RC CDataInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    Jsi_StructSpec *sl = cd->sl;\n    Jsi_DString dStr= {};\n    const char *sptr = Jsi_DSPrintf(&dStr, \"{struct:\\\"%s\\\", label:\\\"%s\\\"}\", sl->name, cd->help?cd->help:\"\");\n    Jsi_RC rc = JSI_ERROR;\n    if (!sptr)\n        return Jsi_LogError(\"format failed\");\n    else\n        rc = Jsi_JSONParse(interp, sptr, ret, 0);\n    Jsi_DSFree(&dStr);\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_Obj *sobj;\n    Jsi_Value *svalue;\n    if (cd->sf) {\n        sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj,(Jsi_OptionSpec*) cd->sf);\n        sobj = (*ret)->d.obj;\n        Jsi_ObjInsert(interp, sobj, \"spec\", svalue, 0);\n    }\n    if (cd->slKey) {\n        sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj, (Jsi_OptionSpec*)cd->slKey);\n        sobj = (*ret)->d.obj;\n        Jsi_ObjInsert(interp, sobj, \"keySpec\", svalue, 0);\n    }    return JSI_OK;\n}\n\n\nconst char *csMapTypeStrs[] = { \"none\", \"hash\", \"tree\",  \"list\", NULL };\nconst char *csKeyTypeStrs[] = { \"string\", \"strkey\", \"number\",  NULL };\n\nstatic Jsi_OptionSpec CDataOptions[] = {\n    JSI_OPT(UINT,     CDataObj, arrSize, .help=\"If an array, its size in elements\", jsi_IIOF ),\n    JSI_OPT(UINT,     CDataObj, flags,   .help=\"Flags\", jsi_IIOF|JSI_OPT_FMT_HEX ),\n    JSI_OPT(STRKEY,   CDataObj, help,    .help=\"Description of data\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   CDataObj, keyName, .help=\"Key struct, for key struct maps\", jsi_IIOF ),\n    JSI_OPT(CUSTOM,   CDataObj, keyType, .help=\"Key id\", jsi_IIOF|JSI_OPT_COERCE, .custom=Jsi_Opt_SwitchEnum, .data=csKeyTypeStrs),\n    JSI_OPT(CUSTOM,   CDataObj, mapType, .help=\"If a map, its type\", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=csMapTypeStrs),\n    JSI_OPT(UINT,     CDataObj, maxSize, .help=\"Limit the array size or number of keys in a map\" ),\n    JSI_OPT(STRKEY,   CDataObj, name,    .help=\"Name (eg. of var assigned to on create)\", jsi_IIOF ),\n    JSI_OPT(BOOL,     CDataObj, noAuto,  .help=\"Disable auto-create of map keys in set/incr\"),\n    JSI_OPT(STRKEY,   CDataObj, structName,  .help=\"Struct used for storing data\", jsi_IIOF|JSI_OPT_REQUIRED ),\n    JSI_OPT(INT64,    CDataObj, user,    .help=\"User data\" ),\n    JSI_OPT(STRKEY,   CDataObj, varParam,.help=\"Param for maps/array vars\", jsi_IIOF ),\n    JSI_OPT_END(CDataObj, .help=\"Options for CData named\")\n};\n\n\nstatic bool jsi_csBitSetGet(int isSet, uchar *tbuf, int bits, Jsi_UWide *valPtr) {\n    union bitfield *bms = (union bitfield *)tbuf;\n    Jsi_UWide val = *valPtr;\n    union bitfield {\n        Jsi_UWide b1:1; Jsi_UWide b2:2; Jsi_UWide b3:3; Jsi_UWide b4:4; Jsi_UWide b5:5; Jsi_UWide b6:6;\n        Jsi_UWide b7:7; Jsi_UWide b8:8; Jsi_UWide b9:9; Jsi_UWide b10:10; Jsi_UWide b11:11; Jsi_UWide b12:12;\n        Jsi_UWide b13:13; Jsi_UWide b14:14; Jsi_UWide b15:15; Jsi_UWide b16:16; Jsi_UWide b17:17; \n        Jsi_UWide b18:18; Jsi_UWide b19:19; Jsi_UWide b20:20; Jsi_UWide b21:21; Jsi_UWide b22:22;\n        Jsi_UWide b23:23; Jsi_UWide b24:24; Jsi_UWide b25:25; Jsi_UWide b26:26; Jsi_UWide b27:27;\n        Jsi_UWide b28:28; Jsi_UWide b29:29; Jsi_UWide b30:30; Jsi_UWide b31:31; Jsi_UWide b32:32;\n        Jsi_UWide b33:33; Jsi_UWide b34:34; Jsi_UWide b35:35; Jsi_UWide b36:36; Jsi_UWide b37:37;\n        Jsi_UWide b38:38; Jsi_UWide b39:39; Jsi_UWide b40:40; Jsi_UWide b41:41; Jsi_UWide b42:42;\n        Jsi_UWide b43:43; Jsi_UWide b44:44; Jsi_UWide b45:45; Jsi_UWide b46:46; Jsi_UWide b47:47;\n        Jsi_UWide b48:48; Jsi_UWide b49:49; Jsi_UWide b50:50; Jsi_UWide b51:51; Jsi_UWide b52:52;\n        Jsi_UWide b53:53; Jsi_UWide b54:54; Jsi_UWide b55:55; Jsi_UWide b56:56; Jsi_UWide b57:57;\n        Jsi_UWide b58:58; Jsi_UWide b59:59; Jsi_UWide b60:60; Jsi_UWide b61:61; Jsi_UWide b62:62;\n        Jsi_UWide b63:63; Jsi_UWide b64:64;\n    };\n    if (isSet) {\n        switch (bits) {\n    #define CBSN(n) \\\n            case n: bms->b##n = val; return (bms->b##n == val)\n           CBSN(1); CBSN(2); CBSN(3); CBSN(4); CBSN(5); CBSN(6); CBSN(7); CBSN(8);\n           CBSN(9); CBSN(10); CBSN(11); CBSN(12); CBSN(13); CBSN(14); CBSN(15); CBSN(16);\n           CBSN(17); CBSN(18); CBSN(19); CBSN(20); CBSN(21); CBSN(22); CBSN(23); CBSN(24);\n           CBSN(25); CBSN(26); CBSN(27); CBSN(28); CBSN(29); CBSN(30); CBSN(31); CBSN(32);\n           CBSN(33); CBSN(34); CBSN(35); CBSN(36); CBSN(37); CBSN(38); CBSN(39); CBSN(40);\n           CBSN(41); CBSN(42); CBSN(43); CBSN(44); CBSN(45); CBSN(46); CBSN(47); CBSN(48);\n           CBSN(49); CBSN(50); CBSN(51); CBSN(52); CBSN(53); CBSN(54); CBSN(55); CBSN(56);\n           CBSN(57); CBSN(58); CBSN(59); CBSN(60); CBSN(61); CBSN(62); CBSN(63); CBSN(64);\n        }\n        assert(0);\n    }\n    switch (bits) {\n#define CBGN(n) \\\n        case n: val = bms->b##n; break\n       CBGN(1); CBGN(2); CBGN(3); CBGN(4); CBGN(5); CBGN(6); CBGN(7); CBGN(8);\n       CBGN(9); CBGN(10); CBGN(11); CBGN(12); CBGN(13); CBGN(14); CBGN(15); CBGN(16);\n       CBGN(17); CBGN(18); CBGN(19); CBGN(20); CBGN(21); CBGN(22); CBGN(23); CBGN(24);\n       CBGN(25); CBGN(26); CBGN(27); CBGN(28); CBGN(29); CBGN(30); CBGN(31); CBGN(32);\n       CBGN(33); CBGN(34); CBGN(35); CBGN(36); CBGN(37); CBGN(38); CBGN(39); CBGN(40);\n       CBGN(41); CBGN(42); CBGN(43); CBGN(44); CBGN(45); CBGN(46); CBGN(47); CBGN(48);\n       CBGN(49); CBGN(50); CBGN(51); CBGN(52); CBGN(53); CBGN(54); CBGN(55); CBGN(56);\n       CBGN(57); CBGN(58); CBGN(59); CBGN(60); CBGN(61); CBGN(62); CBGN(63); CBGN(64);\n       default: assert(0);\n    }\n    *valPtr = val;\n    return 1;\n}\n\nstatic bool jsi_csSBitSetGet(int isSet, uchar *tbuf, int bits, Jsi_Wide *valPtr) {\n    union bitfield *bms = (union bitfield *)tbuf;\n    Jsi_Wide val = *valPtr;\n    union bitfield {\n        Jsi_Wide b1:1; Jsi_Wide b2:2; Jsi_Wide b3:3; Jsi_Wide b4:4; Jsi_Wide b5:5; Jsi_Wide b6:6;\n        Jsi_Wide b7:7; Jsi_Wide b8:8; Jsi_Wide b9:9; Jsi_Wide b10:10; Jsi_Wide b11:11; Jsi_Wide b12:12;\n        Jsi_Wide b13:13; Jsi_Wide b14:14; Jsi_Wide b15:15; Jsi_Wide b16:16; Jsi_Wide b17:17; \n        Jsi_Wide b18:18; Jsi_Wide b19:19; Jsi_Wide b20:20; Jsi_Wide b21:21; Jsi_Wide b22:22;\n        Jsi_Wide b23:23; Jsi_Wide b24:24; Jsi_Wide b25:25; Jsi_Wide b26:26; Jsi_Wide b27:27;\n        Jsi_Wide b28:28; Jsi_Wide b29:29; Jsi_Wide b30:30; Jsi_Wide b31:31; Jsi_Wide b32:32;\n        Jsi_Wide b33:33; Jsi_Wide b34:34; Jsi_Wide b35:35; Jsi_Wide b36:36; Jsi_Wide b37:37;\n        Jsi_Wide b38:38; Jsi_Wide b39:39; Jsi_Wide b40:40; Jsi_Wide b41:41; Jsi_Wide b42:42;\n        Jsi_Wide b43:43; Jsi_Wide b44:44; Jsi_Wide b45:45; Jsi_Wide b46:46; Jsi_Wide b47:47;\n        Jsi_Wide b48:48; Jsi_Wide b49:49; Jsi_Wide b50:50; Jsi_Wide b51:51; Jsi_Wide b52:52;\n        Jsi_Wide b53:53; Jsi_Wide b54:54; Jsi_Wide b55:55; Jsi_Wide b56:56; Jsi_Wide b57:57;\n        Jsi_Wide b58:58; Jsi_Wide b59:59; Jsi_Wide b60:60; Jsi_Wide b61:61; Jsi_Wide b62:62;\n        Jsi_Wide b63:63; Jsi_Wide b64:64;\n    };\n    if (isSet) {\n        switch (bits) {\n           CBSN(1); CBSN(2); CBSN(3); CBSN(4); CBSN(5); CBSN(6); CBSN(7); CBSN(8);\n           CBSN(9); CBSN(10); CBSN(11); CBSN(12); CBSN(13); CBSN(14); CBSN(15); CBSN(16);\n           CBSN(17); CBSN(18); CBSN(19); CBSN(20); CBSN(21); CBSN(22); CBSN(23); CBSN(24);\n           CBSN(25); CBSN(26); CBSN(27); CBSN(28); CBSN(29); CBSN(30); CBSN(31); CBSN(32);\n           CBSN(33); CBSN(34); CBSN(35); CBSN(36); CBSN(37); CBSN(38); CBSN(39); CBSN(40);\n           CBSN(41); CBSN(42); CBSN(43); CBSN(44); CBSN(45); CBSN(46); CBSN(47); CBSN(48);\n           CBSN(49); CBSN(50); CBSN(51); CBSN(52); CBSN(53); CBSN(54); CBSN(55); CBSN(56);\n           CBSN(57); CBSN(58); CBSN(59); CBSN(60); CBSN(61); CBSN(62); CBSN(63); CBSN(64);\n        }\n        assert(0);\n    }\n    switch (bits) {\n       CBGN(1); CBGN(2); CBGN(3); CBGN(4); CBGN(5); CBGN(6); CBGN(7); CBGN(8);\n       CBGN(9); CBGN(10); CBGN(11); CBGN(12); CBGN(13); CBGN(14); CBGN(15); CBGN(16);\n       CBGN(17); CBGN(18); CBGN(19); CBGN(20); CBGN(21); CBGN(22); CBGN(23); CBGN(24);\n       CBGN(25); CBGN(26); CBGN(27); CBGN(28); CBGN(29); CBGN(30); CBGN(31); CBGN(32);\n       CBGN(33); CBGN(34); CBGN(35); CBGN(36); CBGN(37); CBGN(38); CBGN(39); CBGN(40);\n       CBGN(41); CBGN(42); CBGN(43); CBGN(44); CBGN(45); CBGN(46); CBGN(47); CBGN(48);\n       CBGN(49); CBGN(50); CBGN(51); CBGN(52); CBGN(53); CBGN(54); CBGN(55); CBGN(56);\n       CBGN(57); CBGN(58); CBGN(59); CBGN(60); CBGN(61); CBGN(62); CBGN(63); CBGN(64);\n       default: assert(0);\n    }\n    *valPtr = val;\n    return 1;\n}\n\nstatic Jsi_RC jsi_csSBitGetSet(Jsi_Interp *interp, void *vrec,  Jsi_Wide* vPtr, Jsi_OptionSpec *spec, int idx, bool isSet) {\n    Jsi_Wide *valPtr = (typeof(valPtr))vPtr;\n    int bits = spec->bits;\n    int boffs = spec->boffset;\n    if (bits<1 || bits>=64) return JSI_ERROR;\n    int ofs = (boffs/8);\n    int bo = (boffs%8); // 0 if byte-aligned\n    int Bsz = ((bits+bo+7)/8);\n    uchar *rec = (uchar*)vrec;\n#ifdef __SIZEOF_INT128__\n    typedef __int128 stvalType;\n#else\n    typedef Jsi_Wide stvalType;\n#endif\n    stvalType tbuf[2] = {};\n    uchar sbuf[20], *bptr = (uchar*)tbuf;\n    memcpy(tbuf, rec+ofs, Bsz);\n    Jsi_Wide mval = *valPtr;\n    Jsi_Wide amask = ((1LL<<(bits-1))-1LL);\n    stvalType tval = 0, kval = 0, lmask;\n    if (bo) { // If not byte aligned, get tval and shift\n        bptr = sbuf;\n        kval = tval = *(typeof(tval)*)tbuf;\n        tval >>= bo;\n        if (!isSet) {\n            mval = (Jsi_Wide)tval;\n            *(Jsi_Wide*)bptr = mval;\n        }\n    }\n        \n    if (!isSet) { // Get value.\n        if (!jsi_csSBitSetGet(0, bptr, bits, &mval))\n            return JSI_ERROR;\n        *valPtr = mval;\n        return JSI_OK;\n    }\n    \n    if (!jsi_csSBitSetGet(1, bptr, bits, &mval))\n        return JSI_ERROR;\n    if (bo) {\n        tval = (typeof(tval))mval;\n        lmask=(amask<<bo);\n        kval &= ~lmask;\n        tval <<= bo;\n        tval = (kval | tval);\n        *(typeof(tval)*)tbuf = tval;\n    }\n    memcpy(rec+ofs, tbuf, Bsz);\n\n    return JSI_OK;    \n}\n\nstatic Jsi_RC jsi_csBitGetSet(Jsi_Interp *interp, void *vrec,  Jsi_Wide* vPtr, Jsi_OptionSpec *spec, int idx, bool isSet) {\n    bool us = (spec->tname && spec->tname[0] == 'u');\n    if (!us)        \n        return jsi_csSBitGetSet(interp, vrec, vPtr, spec, idx, isSet);\n\n    if (*vPtr<0)\n        return JSI_ERROR;\n\n    Jsi_UWide *valPtr = (typeof(valPtr))vPtr;\n    int bits = spec->bits;\n    int boffs = spec->boffset;\n    if (bits<1 || bits>=64) return JSI_ERROR;\n    int ofs = (boffs/8);\n    int bo = (boffs%8); // 0 if byte-aligned\n    int Bsz = ((bits+bo+7)/8);\n    uchar *rec = (uchar*)vrec;\n#ifdef __SIZEOF_INT128__\n    typedef unsigned __int128 utvalType;\n#else\n    typedef Jsi_UWide utvalType;\n#endif\n    utvalType tbuf[2] = {};\n    uchar sbuf[20], *bptr = (uchar*)tbuf;\n    memcpy(tbuf, rec+ofs, Bsz);\n    Jsi_UWide mval;\n    Jsi_UWide amask = ((1LL<<(bits-1))-1LL);\n    utvalType tval = 0, kval = 0, lmask;\n    if (bo) { // If not byte aligned, get tval and shift\n        bptr = sbuf;\n        kval = tval = *(typeof(tval)*)tbuf;\n        tval >>= bo;\n        if (!isSet) {\n            mval = (Jsi_UWide)tval;\n            *(Jsi_UWide*)bptr = mval;\n        }\n    } else\n         mval = *valPtr;\n        \n    if (!isSet) { // Get value.\n        if (!jsi_csBitSetGet(0, bptr, bits, &mval))\n            return JSI_ERROR;\n        *valPtr = mval;\n        return JSI_OK;\n    }\n    \n    if (!jsi_csBitSetGet(1, bptr, bits, &mval))\n        return JSI_ERROR;\n    if (bo) {\n        tval = (typeof(tval))mval;\n        lmask=(amask<<bo);\n        kval &= ~lmask;\n        tval <<= bo;\n        tval = (kval | tval);\n        *(typeof(tval)*)tbuf = tval;\n    }\n    memcpy(rec+ofs, tbuf, Bsz);\n\n    return JSI_OK;    \n}\n\nstatic Jsi_RC CDataConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    return CDataOptionsConf(interp, CDataOptions, args, cd, ret, 0, 0);\n}\n \nstatic Jsi_RC CDataNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    UdcGet(cd, _this, funcPtr);\n    if (cd->mapType != JSI_MAP_NONE)\n        return Jsi_MapKeysDump(interp, *cd->mapPtr, ret, 0);\n    return Jsi_LogError(\"not a map\");;\n}\n\nstatic Jsi_RC CDataUnsetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 0);   \n    char kbuf[BUFSIZ];\n    void *key = kbuf;\n    if (!cd->mapPtr && cd->arrSize<=0)\n        return Jsi_LogError(\"can not call unset on non map/array\");\n    if (JSI_OK != jsi_csGetKey(interp, cd, arg2, &key, sizeof(kbuf), 2)) {\n        return JSI_ERROR;\n    }\n    uchar *dptr = NULL;\n    Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);\n    if (mPtr)\n        dptr = (uchar*)Jsi_MapValueGet(mPtr);\n    if (!dptr) {\n        if (cd->keyType != JSI_KEYS_ONEWORD)\n            return Jsi_LogError(\"no data in map: %s\", (char*)key);\n        else\n            return Jsi_LogError(\"no data in map: %p\", key);\n        return JSI_ERROR;\n    }\n    Jsi_Free(dptr);\n    Jsi_MapEntryDelete(mPtr);\n    return JSI_OK;\n\n}\n\n#define FN_cdataConstructor JSI_INFO(\"\\\nThe 2nd arg is used for function option parsing and will report errors at the callers file:line\")\nstatic Jsi_RC CDataConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n    \n/* Defines: Handles the \"Data\" subcommand */\nstatic Jsi_CmdSpec cdataCmds[] =\n{\n    {\"CData\",     CDataConstructor,1, 2, \"options:string|object=void, inits:object=undefined\",.help=\"Create a new struct or map/array of structs\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=FN_cdataConstructor, .opts=CDataOptions},\n    {\"conf\",      CDataConfCmd,    0, 1, \"options:object|string=void\",.help=\"Configure options for c-data\", .retType=0, .flags=0, .info=0, .opts=CDataOptions},\n    {\"get\"   ,    CDataGetCmd,     0, 2, \"key:string|number|object=null, field:string=void\", .help=\"Get struct/map/array value\", .retType=(uint)JSI_TT_ANY},\n    {\"incr\",      CDataIncrCmd,    2, 3, \"key:string|number|object|null, field:object|string, value:number=1\", .help=\"Increment a numeric field: returns the new value\", .retType=(uint)JSI_TT_NUMBER},\n    {\"info\",      CDataInfoCmd,    0, 0, \"\", .help=\"Return info for data\", .retType=(uint)JSI_TT_OBJECT},\n    {\"names\",     CDataNamesCmd,   0, 0, \"\", .help=\"Return keys for map\", .retType=(uint)JSI_TT_ARRAY },\n    {\"set\",       CDataSetCmd,     2, 3, \"key:string|number|object|null, field:object|string, value:any=void\", .help=\"Set a struct/map/array value\", .retType=(uint)JSI_TT_ANY},\n    {\"unset\",     CDataUnsetCmd,   1, 1, \"key:string|number|object\", .help=\"Remove entry from map/array\", .retType=(uint)JSI_TT_ANY},\n    {NULL}\n};\n\n\nstatic Jsi_OptionSpec TypeOptions[] = {\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, idName,  .help=\"The id name: usually upcased cName\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, cName,   .help=\"C type name\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, help,    .help=\"Description of id\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, fmt,     .help=\"Printf format for id\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, xfmt,    .help=\"Hex printf format for id\", jsi_IIOF ),\n    JSI_OPT(INT64,    Jsi_OptionTypedef, flags,   .help=\"Flags for id\", jsi_IIOF ),\n    JSI_OPT(INT,      Jsi_OptionTypedef, size,    .help=\"Size for id\", jsi_IIOF ),\n    JSI_OPT(INT64,    Jsi_OptionTypedef, user,    .help=\"User data\" ),\n    JSI_OPT_END(Jsi_OptionTypedef, .help=\"Options for CData id\")\n};\n\nstatic Jsi_RC CDataTypeConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_OptionTypedef *nd = NULL;\n    jsi_csInitType(interp);\n    if (arg1)\n        nd = (typeof(nd))Jsi_TypeLookup(interp, arg1);\n    if (!nd)\n        return Jsi_LogError(\"Unknown type: %s\", arg1);\n    return CDataOptionsConf(interp, TypeOptions, args, nd, ret, 0, 1);\n}\n\nstatic Jsi_RC CDataTypeNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    jsi_csInitType(interp);\n    int argc = Jsi_ValueGetLength(interp, args);\n    return Jsi_HashKeysDump(interp, (argc?interp->CTypeHash:interp->TYPEHash), ret, 0);\n}\n\n/* Defines: Handles the \"Type\" subcommand */\nstatic Jsi_CmdSpec typeCmds[] =\n{\n    {\"conf\",      CDataTypeConfCmd,    1, 2, \"typ:string, options:object|string=void\",.help=\"Configure options for type\", .retType=0, .flags=0, .info=0, .opts=TypeOptions},\n    {\"names\",     CDataTypeNamesCmd,   0, 1, \"ctype=false\", .help=\"Return type names\", .retType=(uint)JSI_TT_ARRAY},\n    { NULL,   0,0,0,0, .help=\"Type commands. Note: Type() is a shortcut for Type.conf()\" }\n};\n\nstatic Jsi_RC jsi_csTypeFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_OptionTypedef *type = jsi_csGetTypeSpec(ptr);\n    if (type->extData && (type->flags&(jsi_CTYP_ENUM|jsi_CTYP_STRUCT)))\n        ((Jsi_OptionSpec*)(type->extData))->value--;\n    if (type->flags&jsi_CTYP_DYN_MEMORY)\n        Jsi_Free(ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_csMapFree(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_Free(ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_csObjFree(Jsi_Interp *interp, void *data)\n{\n    CDataObj *cd = (CDataObj *)data;\n    cd->sl->value--;\n    if (cd->slKey)\n        cd->slKey->value--;\n    if (cd->isAlloc) {\n        if (cd->mapPtr && *cd->mapPtr) {\n            Jsi_MapDelete(*cd->mapPtr);\n            *cd->mapPtr = NULL;\n        }\n        else if (cd->data) Jsi_Free(cd->data);\n    }\n    Jsi_Free(cd);\n    return JSI_OK;\n}\n\nstatic bool jsi_csObjIsTrue(void *data)\n{\n    CDataObj *fo = (CDataObj *)data;\n    if (!fo->fobj) return JSI_OK;\n    else return 1;\n}\n\nstatic bool jsi_csObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\nstatic Jsi_UserObjReg cdataobject = {\n    \"CData\",\n    cdataCmds,\n    jsi_csObjFree,\n    jsi_csObjIsTrue,\n    jsi_csObjEqual\n};\n\nstatic Jsi_RC jsi_csNewCData(Jsi_Interp *interp, CDataObj *cd, int flags) {\n\n    Jsi_StructSpec *slKey = NULL, *keySpec = NULL, *sf = cd->sf, *sl = cd->sl;\n    \n    if (!sf)\n        cd->sf = sf = jsi_csStructFields(interp, cd->structName);\n    if (!sl)\n        sl = cd->sl = Jsi_CDataStruct(interp, cd->structName);\n    if (!sf)\n        return Jsi_LogError(\"missing struct/fields: %s\", cd->structName);\n    \n    if (cd->keyName) {\n        slKey = keySpec = Jsi_CDataStruct(interp, cd->keyName);\n        if (slKey == NULL)\n            return Jsi_LogError(\"unknown key struct: %s\", cd->keyName);\n    }\n\n    const char *vparm = cd->varParam;\n    if (vparm && vparm[0]) {\n        char parm[200] = {}, *parms=parm, *ep;\n        int plen = Jsi_Strlen(vparm);\n        if (plen>=2 && vparm[0] == '[' && vparm[plen-1]==']') {\n            snprintf(parm, sizeof(parm), \"%.*s\", plen-2, vparm+1);\n            int sz = 0;\n            if (parm[0] && isdigit(parm[0])) {\n                sz=strtoul(parm, &ep, 0);\n                if (*ep || sz<=0)\n                    return Jsi_LogError(\"bad array size: %s\", vparm);\n                cd->arrSize = sz;\n            } else {\n                Jsi_EnumSpec *ei = (typeof(ei))Jsi_HashGet(interp->EnumItemHash, parm, 0);\n                if (!ei || (sz=ei->value)<=0)\n                    return Jsi_LogError(\"bad array enum: %s\", vparm);\n            }\n            \n        } else if (plen>=2 && vparm[0] == '{' && vparm[plen-1]=='}') {\n            snprintf(parm, sizeof(parm), \"%.*s\", plen-2, vparm+1);\n            cd->mapType = JSI_MAP_TREE;\n            if (parms[0]) {\n                const char *ktn = NULL;\n                if (*parms == '#') {\n                     cd->mapType = JSI_MAP_HASH;\n                     parms++;\n                }\n                if (*parms == '0') {\n                    cd->keyType = JSI_KEYS_ONEWORD;\n                    if (parms[1])\n                        return Jsi_LogError(\"Trailing junk: %s\", vparm);\n                } else if (parms[0] == '@') {\n                    slKey = Jsi_CDataStruct(interp, ktn=(parms+1));\n                    if (!slKey)\n                        return Jsi_LogError(\"unknown key struct: %s\", ktn);\n                    cd->keyName = slKey->name;\n                } else if (parms[0])\n                        return Jsi_LogError(\"Trailing junk: %s\", vparm);\n            }\n\n        } else\n            return Jsi_LogError(\"expected either {} or []: %s\", vparm);\n    \n    }\n    cd->sl->value++;\n \n    if (cd->keyName) {\n        cd->slKey = Jsi_CDataStruct(interp, cd->keyName);\n        if (!cd->slKey)\n            return Jsi_LogError(\"unknown key struct: %s\", cd->keyName);\n        cd->keysf = jsi_csStructFields(interp, cd->keyName);\n        cd->keyType = (Jsi_Key_Type)slKey->size;\n        cd->slKey->value++;\n    }\n    \n    if (cd->arrSize<=0 && cd->mapType != JSI_MAP_NONE) {\n        if (interp->cdataNewVal && interp->cdataNewVal->data)\n            cd->mapPtr = (Jsi_Map**)(interp->cdataNewVal->data);\n        else\n            cd->mapPtr = (Jsi_Map**)&cd->data;\n        cd->isAlloc = 1;\n        *cd->mapPtr = Jsi_MapNew(interp, cd->mapType, cd->keyType, jsi_csMapFree);\n        if (cd->slKey) {\n            Jsi_MapOpts mo;\n            Jsi_MapConf(*cd->mapPtr, &mo, 0);\n            mo.fmtKeyProc = jsi_csFmtKeyCmd;\n            mo.user = (void*)cd;\n            Jsi_MapConf(*cd->mapPtr, &mo, 1);\n        }\n    } else {\n        uint i, sz = (cd->arrSize<=0 ? 1 : cd->arrSize);\n        cd->keyType = JSI_KEYS_ONEWORD;\n        if (interp->cdataNewVal && interp->cdataNewVal->data)\n            cd->data = interp->cdataNewVal->data;\n        else {\n            cd->isAlloc = 1;\n            cd->data = (typeof(cd->data))Jsi_Calloc(sz, cd->sl->size);\n        }\n        for (i=0; i<sz; i++)\n            jsi_csStructInit(sl, (((uchar*)cd->data) + i*cd->sl->size));\n    }\n\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *that = _this;\n    Jsi_Obj *nobj;\n    \n    if (!Jsi_FunctionIsConstructor(funcPtr)) {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"CData\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        that = *ret;\n    }\n\n    CDataObj *cd = (typeof(cd))Jsi_Calloc(1,sizeof(*cd));\n    cd->interp = interp;\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_vtype vtyp = Jsi_ValueTypeGet(val);\n    int vlen, isNew = 0;\n    const char *vstr = Jsi_ValueString(interp, val, &vlen);\n    Jsi_DString dStr = {};\n    Jsi_Value *ival = Jsi_ValueArrayIndex(interp, args, 1);\n    if (ival && Jsi_ValueIsUndef(interp, ival))\n        ival = NULL;\n    else if (ival && !Jsi_ValueIsObjType(interp, ival, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 2: expected object or undef\");\n    if (vstr && vlen) {\n        char ech = 0;\n        const char *nstr = vstr, *cp = vstr;\n        while (*cp && (isalnum(*cp) || *cp=='_')) cp++;\n        if (*cp) {\n            int slen = cp-vstr;\n            Jsi_DString sStr = {};\n            nstr = Jsi_DSAppendLen(&dStr, vstr, slen);\n            if (*cp == '[')\n                ech = ']';\n            else if (*cp == '{')\n                ech = '}';\n            if (!ech || vstr[vlen-1] != ech) {\n                Jsi_LogError(\"malformed var form is not: STRUCT, STRUCT{...}, STRUCT[...]\");\n                goto errout;\n            }\n            //cp++;\n            cd->varParam = Jsi_KeyAdd(interp, Jsi_DSAppendLen(&sStr, cp, vlen-slen));\n        }\n        cd->structName = Jsi_KeyAdd(interp, nstr);\n        val = NULL;\n    } else if (vtyp != JSI_VT_OBJECT) {\n        Jsi_LogError(\"expected string, object\");\n        goto errout;\n    }\n    if (val && Jsi_OptionsProcess(interp, CDataOptions, cd, val, 0) < 0)\n        goto errout;\n\n    if (ival && (cd->mapPtr || cd->arrSize)) {\n        Jsi_LogError(\"init can not be used with c-array/map\");\n        goto errout;\n     }\n  \n    if (JSI_OK != jsi_csNewCData(interp, cd, JSI_OPT_NO_SIG))\n        goto errout;\n\n    if (ival) {\n        interp->callerErr = 1;\n        Jsi_RC rc = Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, cd->data, ival, ret, 0);\n        interp->callerErr = 0;\n        if (rc != JSI_OK) {\n            isNew = 1;\n            goto errout;\n        }\n    }\n        \n    nobj = (Jsi_Obj*)Jsi_ValueGetObj(interp, that);\n    cd->objId = Jsi_UserObjNew(interp, &cdataobject, nobj, cd);\n    if (cd->objId<0) {\n        goto errout;\n    }\n    cd->fobj = nobj;\n    return JSI_OK;\n    \nerrout:\n    Jsi_DSFree(&dStr);\n    Jsi_OptionsFree(interp, CDataOptions, cd, 0);\n    if (isNew)\n       jsi_csObjFree(interp, cd);\n    else\n        Jsi_Free(cd);\n    return JSI_ERROR;\n\n}\n\n// Globals\n\nstatic Jsi_RC jsi_DoneCData(Jsi_Interp *interp)\n{\n    if (!interp->SigHash) return JSI_OK;\n    Jsi_HashDelete(interp->SigHash);\n    Jsi_HashDelete(interp->StructHash);\n    Jsi_HashDelete(interp->EnumHash);\n    Jsi_HashDelete(interp->EnumItemHash);\n    Jsi_HashDelete(interp->TYPEHash);\n    Jsi_HashDelete(interp->CTypeHash);\n    return JSI_OK;\n}\n\nJsi_RC jsi_InitCData(Jsi_Interp *interp, int release)\n{\n    if (release) return jsi_DoneCData(interp);\n#if JSI_USE_STUBS\n    if (Jsi_StubsInit(interp, 0) != JSI_OK)\n        return JSI_ERROR;\n#endif\n\n    Jsi_Hash *fsys = Jsi_UserObjRegister(interp, &cdataobject);\n    if (!fsys)\n        return Jsi_LogBug(\"Can not init cdata\");\n\n    interp->SigHash      = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n    interp->StructHash   = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->EnumHash     = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->EnumItemHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->CTypeHash    = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_csTypeFree);\n    interp->TYPEHash     = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n\n    Jsi_CommandCreateSpecs(interp, cdataobject.name,  cdataCmds,  fsys, JSI_CMDSPEC_ISOBJ);\n    Jsi_CommandCreateSpecs(interp, \"CEnum\",  enumCmds,   NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"CStruct\",structCmds, NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"CType\",  typeCmds,   NULL, 0);\n\n    if (Jsi_PkgProvide(interp, cdataobject.name, 1, jsi_InitCData) != JSI_OK)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n/* Initialize a struct to default values */\nJsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname)\n{\n    Jsi_StructSpec * sl = jsi_csStructGet(interp, sname);\n    if (!sl)\n        return Jsi_LogError(\"unknown struct: %s\", sname);\n    return jsi_csStructInit(sl, data);\n}\n\nJsi_CDataDb *Jsi_CDataLookup(Jsi_Interp *interp, const char *name) {\n    CDataObj *cd = (typeof(cd))Jsi_UserObjDataFromVar(interp, name);\n    if (!cd)\n        return NULL;\n    return (Jsi_CDataDb*)cd;\n}\n\nJsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics)\n{\n    Jsi_RC rc = JSI_OK;\n    if (statics) {\n        if (interp->statics)\n            statics->nextPtr = interp->statics;\n        interp->statics = statics;\n        jsi_csInitType(interp);\n        jsi_csInitStructTables(interp);\n        jsi_csInitEnum(interp);\n        jsi_csInitEnumItem(interp);\n        rc = jsi_csInitVarDefs(interp);\n    }\n    return rc;\n}\n\n/* Traverse types and match unique substring. */\nJsi_OptionTypedef *Jsi_TypeLookup(Jsi_Interp *interp, const char *name)\n{\n    int isup = 1;\n    const char *cp = name;\n    while (*cp && isup) {\n        if (*cp != '_' && !isdigit(*cp) && !isupper(*cp)) { isup=0; break; }\n        cp++;\n    }\n    Jsi_OptionTypedef *ptr = (typeof(ptr))Jsi_HashGet((isup?interp->TYPEHash:interp->CTypeHash), name, 0);\n    if (ptr)\n        SIGASSERT(ptr, TYPEDEF);\n    return ptr;\n}\n\n#else // JSI_OMIT_CDATA\n\nJsi_CDataDb *Jsi_CDataLookup(Jsi_Interp *interp, const char *name) { return NULL; }\nJsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics) { return JSI_ERROR; }\nJsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname) { return JSI_ERROR; }\nJsi_OptionTypedef *Jsi_TypeLookup(Jsi_Interp *interp, const char *name) { return NULL; }\n\n#endif // JSI_OMIT_CDATA\n#endif // JSI_LITE_ONLY\n", "#ifndef __JSIINT_H__\n#define __JSIINT_H__\n\n#ifdef JSI_CONFIG_H_FILE\n#include JSI_CONFIG_H_FILE\n#endif\n\n#if JSI__ALL\n#define JSI__SQLITE 1\n#define JSI__WEBSOCKET 1\n#define JSI__READLINE 1\n#endif\n// Define the defaults\n#ifndef JSI__EVENT\n#define JSI__EVENT 1\n#endif\n#ifndef JSI__DEBUG\n#define JSI__DEBUG 1\n#endif\n#ifndef JSI__LOAD\n#define JSI__LOAD 1\n#endif\n#ifndef JSI__SIGNAL\n#define JSI__SIGNAL 1\n#endif\n#ifndef JSI__FILESYS\n#define JSI__FILESYS 1\n#endif\n#ifndef JSI__ZVFS\n#define JSI__ZVFS 1\n#endif\n#ifndef JSI__STUBS\n#define JSI__STUBS 1\n#endif\n#ifndef JSI__THREADS\n#define JSI__THREADS 1\n#endif\n#ifndef JSI__INFO\n#define JSI__INFO 1\n#endif\n#ifndef JSI__CDATA\n#define JSI__CDATA 1\n#endif\n#ifndef JSI__SOCKET\n#ifndef __WIN32 \n#define JSI__SOCKET 1\n#endif\n#endif\n#ifndef JSI__MATH\n#define JSI__MATH 1\n#endif\n#ifndef JSI__UTF8\n#define JSI__UTF8 1\n#endif\n#ifndef JSI__MINIZ\n#define JSI__MINIZ 1\n#endif\n\n#if (JSI__STUBS!=1)\n#ifndef JSI_OMIT_STUBS\n#define JSI_OMIT_STUBS\n#endif\n#endif\n#if (JSI__THREADS!=1)\n#define JSI_OMIT_THREADS\n#endif\n#if (JSI__SIGNAL!=1)\n#define JSI_OMIT_SIGNAL\n#endif\n\n#if defined(JSI__MD5) && JSI__MD5==0\n#define JSI_OMIT_MD5 1\n#endif\n#if defined(JSI__SHA1) && JSI__SHA1==0\n#define JSI_OMIT_SHA1 1\n#endif\n#if defined(JSI__SHA256) && JSI__SHA256==0\n#define JSI_OMIT_SHA256 1\n#endif\n#if defined(JSI__ENCRYPT) && JSI__ENCRYPT==0\n#define JSI_OMIT_ENCRYPT 1\n#endif\n#if defined(JSI__BASE64) && JSI__BASE64==0\n#define JSI_OMIT_BASE64 1\n#endif\n#if defined(JSI__LOAD) && JSI__LOAD==0\n#define JSI_OMIT_LOAD 1\n#endif\n#if defined(JSI__EVENT) && JSI__EVENT==0\n#define JSI_OMIT_EVENT 1\n#endif\n#if defined(JSI__DEBUG) && JSI__DEBUG==0\n#define JSI_OMIT_DEBUG 1\n#endif\n#if defined(JSI__CDATA) && JSI__CDATA==0\n#define JSI_OMIT_CDATA 1\n#endif\n#if defined(JSI__MATH) && JSI__MATH==0\n#define JSI_OMIT_MATH 1\n#endif\n\n//#define JSI__MEMDEBUG 1\n#if JSI__MEMDEBUG\n#define JSI_MEM_DEBUG\n#define Assert(n) assert(n)\n#else\n#define Assert(n)\n#endif\n#ifndef JSI_OMIT_SIGNATURES\n#define JSI_HAS_SIG\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#define __USE_GNU\n#endif\n#define VAL_REFCNT\n#define VAL_REFCNT2\n\n#ifndef JSI_ZVFS_DIR\n#define JSI_ZVFS_DIR \"/zvfs\"\n#endif\n#ifndef JSI_VFS_DIR\n#define JSI_VFS_DIR \"/vfs\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <assert.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <float.h>\n\n#ifdef __WIN32 /* TODO: support windows signal??? */\n#define JSI__MINIZ 1\n#define JSI_OMIT_SIGNAL\n#endif\n\n#if (JSI_VERSION_MAJOR>=10)\n#define JSI_VERFMT_LEN \"6\"\n#else\n#define JSI_VERFMT_LEN \"5\"\n#endif\n\n#ifndef JSI_AMALGAMATION\n\n#if JSI__REGEX\n#include \"regex/regex.h\"\n#else\n#include <regex.h>\n#endif\n#ifdef __WIN32\n#include \"win/compat.h\"\n//#include \"win/regex.h\"\n//#include \"regex/regex.h\"\n#else\n#define JSI__REGCOMP\n#include <sys/time.h>\n#endif\n#endif\n\n#include <time.h>\n\n#ifndef JSI_IS64BIT\n#ifdef __GNUC__\n#ifdef __X86_64__\n#define JSI_IS64BIT 1\n#endif\n#else /* GCC */\n#if _WIN64 || __amd64__\n#define JSI_IS64BIT 1\n#endif\n#endif /* GCC */\n#endif /* JSI_IS64BIT */\n\n#ifndef JSI_IS64BIT\n#define JSI_IS64BIT 0\n#endif\n\n#define JSMN_FREE(p) Jsi_Free(p)\n#define JSMN_MALLOC(l) Jsi_Malloc(l)\n#define JSMN_REALLOC(p,l) Jsi_Realloc(p,l)\n\n#ifndef NDEBUG\n#define SIGASSERTDO(s, ret) assert(s);\n#else\n#define SIGASSERTDO(s, ret) if (!(s)) return ret\n#endif\n#define SIGASSERTRET(s,n,ret) SIGASSERTDO((s) && (s)->sig == (uint)JSI_SIG_##n, ret);\n\n#define JSI_HAS_SIG /* Signatures to help with debugging */\n#ifdef JSI_HAS_SIG\n#ifndef SIGASSERT\n#define SIGASSERTV(s,n) SIGASSERTRET(s, n, /*void*/);\n#define SIGASSERT(s,n) SIGASSERTRET(s, n, JSI_OK);\n#define SIGASSERTMASK(s,n,m) assert((s) && ((s)->sig&(~(m))) == (uint)JSI_SIG_##n);\n#endif\n#define SIGINIT(s,n) (s)->sig = JSI_SIG_##n;\n#define __VALSIG__ .sig=JSI_SIG_VALUE,\n#else\n#define SIGASSERTV(s,n)\n#define SIGASSERT(s,n)\n#define SIGASSERTMASK(s,n,m)\n#define SIGINIT(s,n)\n#define __VALSIG__\n#endif\n\n#ifndef JSI_HAS___PROTO__\n#define JSI_HAS___PROTO__ 1  // Enable setting and getting prototypes. 1=set/get funcs, 2=__proto__ assign.\n#endif\n\n#ifdef NDEBUG\n#define JSI_NOWARN(v) v=v\n#else\n#define JSI_NOWARN(v)\n#endif\n\n#ifdef __FreeBSD__\n#define _JSICASTINT(s) (int)(s)\n#else\n#define _JSICASTINT(s) (s)\n#endif\n\n#ifndef __DBL_DECIMAL_DIG__\n#define __DBL_DECIMAL_DIG__ 17\n#endif\n\n#if 0\n#ifndef uint\ntypedef unsigned int uint;\n#endif\n#ifndef uchar\ntypedef unsigned char uchar;\n#endif\n#endif\n\n#ifndef JSI_AMALGAMATION\n#include \"jsi.h\"\n#else\n//#define JSI_OMIT_STUBS\n#endif\n\n#define ALLOC_MOD_SIZE 16      /* Increase allocs by increments of 16. */\n#define MAX_ARRAY_LIST 100000  /* Default Max size of an array convertable to list form */\n#define MAX_LOOP_COUNT 10000000 /* Limit infinite loops */\n#define JSI_MAX_ALLOC_BUF  100000000 /* Limit for dynamic memory allocation hunk */\n#define JSI_MAX_SCOPE (JSI_BUFSIZ/2)\ntypedef enum {\n    JSI_SIG_ITEROBJ=0xdeadbaa0, JSI_SIG_FUNCOBJ, JSI_SIG_SCOPE, JSI_SIG_VALUE,\n    JSI_SIG_OBJ, JSI_SIG_USERDATA, JSI_SIG_INTERP, JSI_SIG_PARSER,\n    JSI_SIG_FILEOBJ, JSI_SIG_INTERPOBJ, JSI_SIG_FUNC, JSI_SIG_CMDSPECITEM, JSI_SIG_HASH,\n    JSI_SIG_HASHENTRY, JSI_SIG_TREE, JSI_SIG_TREEENTRY, JSI_SIG_LIST, JSI_SIG_LISTENTRY,\n    JSI_SIG_USER_REG, JSI_SIG_EVENT, JSI_SIG_MAP, JSI_SIG_REGEXP,\n    JSI_SIG_ARGTYPE, JSI_SIG_FORINVAR, JSI_SIG_CASELIST, JSI_SIG_CASESTAT,\n    JSI_SIG_FASTVAR, JSI_SIG_INTERPSTREVENT, JSI_SIG_ALIASCMD, JSI_SIG_SOCKET, JSI_SIG_SOCKETPSS,\n    JSI_SIG_NAMEDATA\n} jsi_Sig;\n\n#define Jsi_LogType(fmt,...) Jsi_LogMsg(interp, (interp->typeCheck.strict || interp->typeCheck.error)?JSI_LOG_ERROR:JSI_LOG_WARN, fmt, ##__VA_ARGS__)\n\nstruct jsi_OpCode;\n\n#if  JSI__MEMDEBUG\nextern void jsi_VALCHK(Jsi_Value *v);\nextern void jsi_OBJCHK(Jsi_Obj *o);\n#define VALCHK(val) jsi_VALCHK(val)\n#define OBJCHK(val) jsi_OBJCHK(val)\n#else\n#define VALCHK(val)\n#define OBJCHK(val)\n#endif\n\nenum {  jsi_callTraceFuncs = 1, jsi_callTraceCmds = 2, jsi_callTraceNew = 4,\n        jsi_callTraceReturn = 8, jsi_callTraceArgs = 16, \n        jsi_callTraceNoTrunc = 32,  jsi_callTraceNoParent = 64,\n        jsi_callTraceFullPath = 128, jsi_callTraceBefore = 256\n};\n\n/* Scope chain */\ntypedef struct jsi_ScopeChain_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Value **chains;  /* values(objects) */\n    int chains_cnt;         /* count */\n} jsi_ScopeChain;\n\n/* Function obj */\n/* a Jsi_FuncObj is a raw function with own scope chain */\nstruct Jsi_FuncObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Func *func;\n    jsi_ScopeChain *scope;\n    Jsi_Value *bindArgs;\n    Jsi_Value *bindFunc;\n};\n\n/* Jsi_IterObj, use only in for-in statement */\ntypedef struct UserObjReg_ { /* Per interp userobj registration. */\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_UserObjReg *reg;\n    Jsi_Hash* hashPtr;\n    int idx;\n} UserObjReg;\n\n/* User defined object */\ntypedef struct Jsi_UserObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Hash *id;\n    void *data;\n    const char *prefix;\n    Jsi_UserObjReg *reg;\n    struct UserObjReg_ *ureg;\n    uintptr_t idx;\n    Jsi_HashEntry* hPtr;\n} Jsi_UserObj;\n\ntypedef struct {\n    int valueCnt;\n    int objCnt;\n    int valueAllocCnt;\n    int objAllocCnt;\n#ifdef JSI_MEM_DEBUG\n    Jsi_Hash *valueDebugTbl;\n    Jsi_Hash *objDebugTbl;\n    uint memDebugCallIdx;\n#endif\n} Jsi_InterpDebug;\n\n\n/* stack change */\n/* 0  nothing change */\n/* +1 push */\n/* -1 pop */\ntypedef enum {      /* SC   type of data    comment                             */\n    OP_NOP,         /* 0 */\n    OP_PUSHNUM,     /* +1   *double         number                              */\n    OP_PUSHSTR,     /* +1   *char           string                              */\n    OP_PUSHVSTR,    /* +1   Jsi_String*     string                              */\n    OP_PUSHVAR,     /* +1   *FastVar        variable name                       */\n    OP_PUSHUND,     /* +1   -               undefined                           */\n    OP_PUSHNULL,    /* +1   -               null                                */\n    OP_PUSHBOO,     /* +1   int             bool                                */\n    OP_PUSHFUN,     /* +1   *Jsi_Func           function                            */\n    OP_PUSHREG,     /* +1   *regex_t        regex                               */\n    OP_PUSHARG,     /* +1   -               push arguments(cur scope)           */\n    OP_PUSHTHS,     /* +1   -               push this                           */\n    OP_PUSHTOP,     /* +1   -               duplicate top                       */\n    OP_PUSHTOP2,    /* +2   -               duplicate toq and top               */\n    OP_UNREF,       /* 0    -               make top be right value             */\n    OP_POP,         /* -n   int             pop n elements                      */\n    OP_LOCAL,       /* 0    *char        add a var to current scope          */\n    OP_NEG,         /* 0    -               make top = - top                    */\n    OP_POS,         /* 0    -               make top = + top, (conv to number)  */\n    OP_NOT,         /* 0    -               reserve top                         */\n    OP_BNOT,        /* 0    -               bitwise not                         */\n    OP_ADD,         /* -1   -               all math opr pop 2 elem from stack, */\n    OP_SUB,         /* -1   -                calc and push back in to the stack */\n    OP_MUL,         /* -1   -                                                   */\n    OP_DIV,         /* -1   -                                                   */\n    OP_MOD,         /* -1   -                                                   */\n    OP_LESS,        /* -1   -               logical opr, same as math opr       */\n    OP_GREATER,     /* -1   -                                                   */\n    OP_LESSEQU,     /* -1   -                                                   */\n    OP_GREATEREQU,  /* -1   -                                                   */\n    OP_EQUAL,       /* -1   -                                                   */\n    OP_NOTEQUAL,    /* -1   -                                                   */\n    OP_STRICTEQU,   /* -1   -                                                   */\n    OP_STRICTNEQ,   /* -1   -                                                   */\n    OP_BAND,        /* -1   -               bitwise and                         */\n    OP_BOR,         /* -1   -               bitwise or                          */\n    OP_BXOR,        /* -1   -               bitwise xor                         */\n    OP_SHF,         /* -1   int(right)      signed shift left or shift right    */\n    OP_INSTANCEOF,  /* -1 */\n    OP_ASSIGN,      /* -n   int             if n = 1, assign to lval,           */\n                    /*                      n = 2, assign to object member      */\n    OP_SUBSCRIPT,   /* -1   -               do subscript TOQ[TOP]               */\n    OP_INC,         /* 0    int             data indicate prefix/postfix inc/dec                */\n    OP_TYPEOF,      /* 0    obj                                                                 */\n    OP_IN,          /* 0    obj                                                                 */\n    OP_DEC,         /* 0    int                                                                 */\n    OP_KEY,         /* +1   -               push an iter object that contain all key in top     */\n    OP_NEXT,        /* -1   -               assign next key to top, make top be res of this opr */\n    OP_JTRUE,       /* -1   int             jmp to offset if top is true,                       */\n    OP_JFALSE,      /* -1   int             jmp to offset if top is false,                      */\n    OP_JTRUE_NP,    /* 0    int             jtrue no pop version                                */\n    OP_JFALSE_NP,   /* 0    int             jfalse no pop version                               */\n    OP_JMP,         /* 0    int             jmp to offset                                       */\n    OP_JMPPOP,      /* -n   *jsi_JmpPopInfo     jmp to offset with pop n                            */\n    OP_FCALL,       /* -n+1 int             call func with n args, pop then, make ret to be top */\n    OP_NEWFCALL,    /* -n+1 int             same as fcall, call as a constructor                */\n    OP_RET,         /* -n   int             n = 0|1, return with arg                            */\n    OP_DELETE,      /* -n   int             n = 1, delete var, n = 2, delete object member      */\n    OP_CHTHIS,      /* 0,   -               make toq as new 'this'                              */\n    OP_OBJECT,      /* -n*2+1   int         create object from stack, and push back in          */\n    OP_ARRAY,       /* -n+1 int             create array object from stack, and push back in    */\n    OP_EVAL,        /* -n+1 int             eval can not be assign to other var                 */\n    OP_STRY,        /* 0    *jsi_TryInfo        push try statment poses Jsi_LogWarn to trylist             */\n    OP_ETRY,        /* 0    -               end of try block, jmp to finally                    */\n    OP_SCATCH,      /* 0    *char        create new scope, assign to current excption        */\n    OP_ECATCH,      /* 0    -               jmp to finally                                      */\n    OP_SFINAL,      /* 0    -               restore scope chain create by Scatch                */\n    OP_EFINAL,      /* 0    -               end of finally, any unfinish code in catch, do it   */\n    OP_THROW,       /* 0    -               make top be last exception, pop trylist till catched*/\n    OP_WITH,        /* -1   -               make top be top of scopechain, add to trylist       */\n    OP_EWITH,       /* 0    -               pop trylist                                         */\n    OP_RESERVED,    /* 0    jsi_ReservedInfo*   reserved, be replaced by iterstat by jmp/jmppop     */\n    OP_DEBUG,       /* 0    -               DEBUG OPCODE, output top                            */\n    OP_LASTOP       /* 0    -               END OF OPCODE                                       */\n} jsi_Eopcode;\n\ntypedef enum { jsi_Oplf_none=0, jsi_Oplf_assert=1, jsi_Oplf_debug=2, jsi_Oplf_trace=3, jsi_Oplf_test=4 } jsi_OpLogFlags;\n\ntypedef struct jsi_OpCode {\n    jsi_Eopcode op;\n    void *data;\n    unsigned int Line:16;\n    unsigned int Lofs:8;\n    unsigned char alloc:1;\n    unsigned char nodebug:1;\n    unsigned char hit:1;\n    unsigned char isof:1;\n    unsigned char local:1;\n    jsi_OpLogFlags logflag:3;\n    const char *fname;\n} jsi_OpCode;\n\n\ntypedef struct Jsi_OpCodes {\n    jsi_OpCode *codes;\n    int code_len;\n    int code_size;          // Used by malloc.\n    \n    int expr_counter;           /* context related expr count */\n    int lvalue_flag;            /* left value count/flag */\n    const char *lvalue_name; /* left value name */\n    int line;  // Used in Lemon\n#ifdef JSI_MEM_DEBUG\n    Jsi_HashEntry *hPtr;\n    int id;\n#endif\n} Jsi_OpCodes;\n\n\ntypedef struct jsi_TryInfo {\n    int trylen;\n    int catchlen;\n    int finallen;\n} jsi_TryInfo;\n\ntypedef struct jsi_ReservedInfo {\n    int type;\n    const char *label;\n    int topop;\n} jsi_ReservedInfo;\n\ntypedef struct jsi_JmpPopInfo {\n    int off;\n    int topop;\n} jsi_JmpPopInfo;\n\n#define RES_CONTINUE    1\n#define RES_BREAK       2\ntypedef struct YYLTYPE jsi_Pline;\n\n//void jsi_codes_print(Jsi_OpCodes *ops);\nvoid jsi_code_decode(Jsi_Interp *interp, jsi_OpCode *op, int currentip, char *buf, int bsiz);\nconst char* jsi_opcode_string(uint opCode);\n\n#ifdef JSI_MEM_DEBUG\ntypedef struct \n{\n    const char *fname;\n    int line;\n    const char *func;\n    const char *label;\n    const char *label2;\n    const char *label3;\n    uint Idx;\n    uint flags;\n    struct jsi_OpCode *ip;\n    int ipLine;\n    jsi_Eopcode ipOp;\n    const char* ipFname;\n    Jsi_HashEntry *hPtr;\n    Jsi_Interp *interp;\n} jsi_ValueDebug;\n#endif\n\nstruct Jsi_Obj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int refcnt;                 /* reference count */\n    Jsi_otype ot:8;             /* object type */\n    uint isarrlist:1;           /* Array type. */\n    uint isstrkey:1;            /* Key string registered in interp->strKeyTbl (do not free) */\n    uint isJSONstr:1;\n    uint clearProto:1;          /* Prototype changed, clean it up at exit. */\n    uint isNoOp:1;\n    uint isBlob:1;\n    uint unused2:16;\n    union {                     /* switched on by value of \"ot\" */\n        int val;\n        Jsi_Number num;\n        Jsi_String s;\n        Jsi_Regex *robj;\n        Jsi_FuncObj *fobj;\n        Jsi_IterObj *iobj;\n        Jsi_UserObj *uobj;\n    } d;\n    uint arrMaxSize;                 /* Max allocated space for array. */\n    uint arrCnt;                     /* Count of actually set keys. */\n    Jsi_Value **arr;   /* Array values. */  \n    Jsi_Tree *tree;                 /* Tree storage (should be union with array). */\n    Jsi_Value *__proto__;           /* TODO: memory leaks when this is changed */\n    struct Jsi_Obj *constructor;\n    struct Jsi_Obj *next, *prev;    /* GC list for containers (array and object). */\n    int gc_refs;\n#ifdef JSI_MEM_DEBUG\n    jsi_ValueDebug VD;\n#endif\n};\n\n/*#pragma pack(1)*/\n\n\nstruct Jsi_Value {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int32_t refCnt;\n    Jsi_vtype vt:8;             /* value type */\n    union {\n        uint flag:8;\n        struct vflagbit {\n            uint readonly:1;\n            uint dontenum:1;  /* Dont enumerate. */\n            uint dontdel:1;\n            uint innershared:1; /* All above used only for objkeys. */\n            uint isarrlist:1;\n            uint isstrkey:1;    /* Key string registered in interp->strKeyTbl (do not free) */\n            uint local:1;       // Used to detect a function creating a global var.\n            uint lookupfailed:1;// Indicates failed lookup, string is stored in lookupFail below.\n        } bits;\n    } f;\n    union {                     /* see above */\n        int val;\n        Jsi_Number num;\n        Jsi_String s;\n        Jsi_Obj *obj;\n        struct Jsi_Value *lval;\n        const char *lookupFail;\n    } d;\n    struct Jsi_Value *next, *prev;\n#ifdef JSI_MEM_DEBUG\n    jsi_ValueDebug VD;\n#endif\n};\n\n#ifndef JSI_SMALL_HASH_TABLE\n#define JSI_SMALL_HASH_TABLE 0x10\n#endif\n\ntypedef uintptr_t jsi_Hash;\n\ntypedef union jsi_HashKey {\n    char string[sizeof(jsi_Hash)];  // STRING, STRUCT\n    void *oneWordValue;             // ONEWORD, STRINGKEY\n} jsi_HashKey;\n\ntypedef struct Jsi_HashEntry {\n    jsi_Sig sig;\n    int typ; // JSI_MAP_HASH\n    struct Jsi_HashEntry *nextPtr;\n    Jsi_Hash *tablePtr;\n    jsi_Hash hval;\n    void* clientData;\n    jsi_HashKey key;\n} Jsi_HashEntry;\n\n\ntypedef struct Jsi_Hash {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int typ; // JSI_MAP_HASH\n    Jsi_HashEntry **buckets;\n    Jsi_HashEntry *staticBuckets[JSI_SMALL_HASH_TABLE];\n    int numBuckets;\n    int numEntries;\n    int rebuildSize;\n    jsi_Hash mask;\n    unsigned int downShift;\n    int keyType;\n    Jsi_HashEntry *(*createProc) (Jsi_Hash *tablePtr, const void *key, bool *newPtr);\n    Jsi_HashEntry *(*findProc) (Jsi_Hash *tablePtr, const void *key);\n    Jsi_MapOpts opts;\n} Jsi_Hash;\n\nstruct Jsi_Tree {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int typ; // JSI_MAP_TREE\n    //Jsi_Interp *interp;\n    Jsi_TreeEntry *root;\n    uint numEntries, keyType, epoch;\n    struct {\n        uint \n            inserting:1, destroyed:1,\n            nonredblack:1,  /* Disable red/black handling on insert/delete. */\n            internstr:1,    /* STRINGPTR keys are stored in strHash */\n            valuesonly:1,   /* Values must be of type JSI_VALUE */\n            unused:28;\n    } flags;\n    Jsi_Hash* strHash;  /* String hash table to use if INTERNSTR; setup on first Create if not defined. */\n    Jsi_TreeEntry* (*createProc)(Jsi_Tree *treePtr, const void *key, bool *newPtr);\n    Jsi_MapOpts opts;\n};\n\ntypedef struct Jsi_TreeEntry {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int typ; // JSI_MAP_TREE\n    Jsi_Tree *treePtr;\n    struct Jsi_TreeEntry* left;\n    struct Jsi_TreeEntry* right;\n    struct Jsi_TreeEntry* parent;\n    union { /* FLAGS: bottom 16 bits for JSI, upper 16 bits for users. First 7 map to JSI_OM_ above. */\n        struct { \n            unsigned int readonly:1, dontenum:1, dontdel:1, innershared:1, isarrlist:1, isstrkey:1, unused:1,\n                color:1,\n                reserve:8,\n                user0:8,\n                user1:1, user2:1, user3:1, user4:1, user5:1, user6:1, user7:1, user8:1;\n        } bits;\n        int flags;\n    } f;\n    void* value;\n    jsi_HashKey key;\n} Jsi_TreeEntry;\n\ntypedef struct Jsi_Map {  // Wrapped Tree/Hash/List.\n    uint sig;\n    Jsi_Map_Type typ;\n    union {\n        Jsi_Hash *hash;\n        Jsi_Tree *tree;\n        Jsi_List *list;\n    } v;\n} Jsi_Map;\n\ntypedef struct jsi_ArgValue_ {\n    char *name;\n    uint type;  // or'ed Jsi_otype\n    Jsi_Value *defValue;\n} jsi_ArgValue;\n\ntypedef struct Jsi_ScopeStrs {\n    jsi_ArgValue *args;\n    int count;\n    int _size;  // Used in allocation only.\n    int varargs;\n    int typeCnt;\n    int firstDef;\n    int argCnt;\n    int retType;\n} Jsi_ScopeStrs;\n\n// Eval stack-frame.\ntypedef struct jsi_Frame {\n    int level;\n    const char *fileName;\n    const char *funcName;\n    const char *dirName;\n    int line;\n    jsi_OpCode *ip;\n    int Sp;\n    int tryDepth;\n    int withDepth;\n    jsi_ScopeChain* ingsc;\n    Jsi_Value *incsc;\n    Jsi_Value *inthis;\n    Jsi_OpCodes *opcodes;\n    struct jsi_Pstate *ps;\n    int logflag;\n    Jsi_Func *evalFuncPtr;\n    struct jsi_Frame *parent, *child;\n    Jsi_Value *arguments; // Set when arguments are accessed.\n} jsi_Frame;\n\n/* Program/parse state(context) */\ntypedef struct jsi_Pstate {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int err_count;              /* Jsi_LogError count after parse */\n    int eval_flag;              /* 1 if currently executing in an eval function */\n    int funcDefs;               /* Count of functions defined. 0 means we can delete this cache (eventually). */\n    Jsi_OpCodes *opcodes;       /* Execution codes. */\n    struct jsi_Lexer *lexer;        /* seq provider */\n\n    int _context_id;            /* used in FastVar-locating */\n    Jsi_Value *last_exception;\n    Jsi_Interp *interp;\n    Jsi_HashEntry *hPtr;\n    Jsi_Hash *argsTbl;\n    Jsi_Hash *fastVarTbl;\n    Jsi_Hash *strTbl;\n    int argType;                // Used during parsing to aggregate type.\n    Jsi_ScopeStrs *args;        // Last push.\n} jsi_Pstate;\n\n\nJsi_ScopeStrs *jsi_ScopeStrsNew(void);\nvoid jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType);\nvoid jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss);\nconst char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i);\n\nvoid jsi_PstatePush(jsi_Pstate *ps);\nvoid jsi_PstatePop(jsi_Pstate *ps);\nvoid jsi_PstateAddVar(jsi_Pstate *ps, jsi_Pline *line, const char *str);\nJsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps);\n\nvoid jsi_PstateFree(jsi_Pstate *ps);\njsi_Pstate *jsi_PstateNew(Jsi_Interp *interp);\nvoid jsi_PstateClear(jsi_Pstate *ps);\nconst char * jsi_PstateGetFilename(jsi_Pstate *ps);\nint jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang);\nint jsi_PstateSetString(jsi_Pstate *ps, const char *str);\n\nextern int yyparse(jsi_Pstate *ps);\n\n#ifndef JSI_AMALGAMATION\n#include \"parser.h\"\n#endif\n\ntypedef struct jsi_ForinVar {\n    jsi_Sig sig;\n    const char *varname;\n    Jsi_OpCodes *local;\n    Jsi_OpCodes *lval;\n} jsi_ForinVar;\n\n\ntypedef struct jsi_CaseExprStat {\n    jsi_Sig sig;\n    Jsi_OpCodes *expr;\n    Jsi_OpCodes *stat;\n    int isdefault;\n} jsi_CaseExprStat;\n\n\ntypedef struct jsi_CaseList {\n    jsi_Sig sig;\n    jsi_CaseExprStat *es;\n    int off;\n    struct jsi_CaseList *tail;\n    struct jsi_CaseList *next;\n} jsi_CaseList;\n\n\ntypedef enum {\n    LT_NONE,\n    LT_FILE,            /* read from file */\n    LT_STRING           /* read from a string */\n} Jsi_Lexer_Type;\n\n/* jsi_Lexer, where input seq provided */\ntypedef struct jsi_Lexer {\n    Jsi_Lexer_Type ltype;\n    union {\n        Jsi_Channel fp;           /* LT_FILE, where to read */\n        char *str;          /* LT_STRING */\n    } d;\n    int last_token;         /* last token returned */\n    int ungot, unch[100];\n    int cur;                /* LT_STRING, current char */\n    int cur_line;           /* current line no. */\n    int cur_char;           /* current column no. */\n    int inStr;\n    jsi_Pstate *pstate;\n} jsi_Lexer;\n\nint yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Pstate *pstate);\nvoid yyerror(YYLTYPE *yylloc, jsi_Pstate *ps, const char *msg);\n\ntypedef struct {\n    jsi_Sig sig;\n    int context_id:31;\n    unsigned int local:1;\n    jsi_Pstate *ps;\n    char *varname;\n    struct Jsi_Value *lval;\n} jsi_FastVar;\n\ntypedef enum { FC_NORMAL, FC_BUILDIN } Jsi_Func_Type;\nstruct jsi_PkgInfo;\n\n/* raw function data, with script function or system Jsi_CmdProc */\nstruct Jsi_Func {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Func_Type type;                         /* type */\n    struct Jsi_OpCodes *opcodes;    /* FC_NORMAL, codes of this function */\n    Jsi_CmdProc *callback;            /* FC_BUILDIN, callback */\n\n    Jsi_ScopeStrs *argnames;                 /* FC_NORMAL, argument names */\n    Jsi_ScopeStrs *localnames;               /* FC_NORMAL, local var names */\n    union {\n        uint flags;\n        struct {\n            uint res:8, hasattr:1, isobj:1 , iscons:1, res2:4;\n        } bits;\n    } f;\n    union {\n        uint i;\n        struct {\n            uint addargs:1 , iscons:1, isdiscard:1, res:5;\n        } bits;\n    } callflags;\n    int refCnt;\n    void *privData;                 /* context data given in create. */\n    Jsi_CmdSpec *cmdSpec;\n    const char *name, *parentName;  /* Name for non-anonymous function. */\n    Jsi_CmdSpec *parentSpec;\n    uint retType;  /* Type name: or of Jsi_otype*/\n    int callCnt;\n    const char *script, *scriptFile;  /* Script created in. */\n    jsi_Pline bodyline; /* Body line info. */\n    const char *bodyStr; // Non-builtin func script body.\n    int endPos, startPos;\n    Jsi_HashEntry *hPtr;\n    double subTime, allTime;\n    Jsi_FuncObj *fobj;\n    struct jsi_PkgInfo *pkg;\n    bool isArrow;\n};\n\ntypedef struct {\n    char *origFile; /* Short file name. */\n    char *fileName; /* Fully qualified name. */\n    char *dirName;  /* Directory name. */\n    const char *str; /* File data. */\n    int useCnt;\n} jsi_FileInfo;\n\nenum {\n    STACK_INIT_SIZE=1024, STACK_INCR_SIZE=1024, STACK_MIN_PAD=100,\n    JSI_MAX_EVAL_DEPTH=200, /* default max nesting depth for eval */\n    JSI_MAX_INCLUDE_DEPTH=50,  JSI_MAX_SUBINTERP_DEPTH=10,\n    JSI_IS_UTF=1,\n    JSI_UTF_CHECKED=2\n    /*,JSI_ON_STACK=0x80*/\n};\n\ntypedef struct InterpStrEvent_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int rc, isExec, tryDepth, errLine;\n    const char *errFile;\n//    Jsi_Value *objData;\n    Jsi_DString func;\n    Jsi_DString data;\n    struct InterpStrEvent_ *next;\n    void *acdata;\n    Jsi_Value *acfunc;\n    void *mutex;\n} InterpStrEvent;\n\ntypedef void (*jsiCallTraceProc)(Jsi_Interp *interp, const char *funcName, const char *file, \n    int line, Jsi_CmdSpec* spec, Jsi_Value* _this, Jsi_Value* args, Jsi_Value *ret);\n\ntypedef struct {\n    const char *file;\n    const char *func;\n    int line;\n    int id;\n    int hits;\n    bool enabled;\n    bool temp;\n} jsi_BreakPoint;\n\ntypedef struct jsi_PkgInfo {\n    Jsi_Number version, lastReq;\n    const char *loadFile;  // Full path of file name loaded.\n    Jsi_InitProc *initProc; // For C-extensions.\n    bool needInit;  // If a C-extension and _Init func needs calling in this interp.\n    Jsi_Value *info;\n    Jsi_PkgOpts popts;\n} jsi_PkgInfo;\n\ntypedef struct {\n    bool isDebugger; // Set to 1 if we are the debugger, debugging a sub-interp.\n    bool noFilter;\n    bool doContinue;\n    bool forceBreak;\n    bool bpLast; // Last break was a breakpoint.\n    bool includeOnce;\n    bool includeTrace;\n    int bpOpCnt;\n    int minLevel;\n    Jsi_Value *putsCallback;\n    Jsi_Value *msgCallback;\n    Jsi_Value *traceCallback;\n    Jsi_Value *debugCallback;\n    Jsi_Value *testFmtCallback;\n    int lastLine;\n    int lastLevel;\n    const char *lastFile;\n    bool pkgTrace;\n    int breakIdx;\n    Jsi_RC (*hook)(struct Jsi_Interp* interp, const char *curFile, int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *msg);\n} Jsi_DebugInterp;\n\ntypedef union jsi_numUnion {\n    bool       BOOL;\n    int            INT;\n    uint           UINT;\n    int8_t         INT8;\n    uint8_t        UINT8;\n    int16_t        INT16;\n    uint16_t       UINT16;\n    int32_t        INT32;\n    uint32_t       UINT32;\n    int64_t        INT64;\n    uint64_t       UINT64;\n    Jsi_Number     DOUBLE;\n    time_t         TIME_T;\n    time_w         TIME_W;\n    time_d         TIME_D;\n} jsi_numUnion;\n\ntypedef struct {\n    uint parse:1;\n    uint run:1;\n    uint all:1;     \n    uint error:1;\n    uint strict:1;\n    uint noundef:1;\n    uint nowith:1;\n    uint funcsig:1;\n    uint unused:24;\n} Jsi_TypeCheck;\n\ntypedef enum {\n    jsi_AssertModeThrow,\n    jsi_AssertModeLog,\n    jsi_AssertModePuts\n} jsi_AssertMode;\n\ntypedef struct {\n    uint isSpecified:1; /* User set the option. */\n    uint initOnly:1;    /* Allow set only at init, disallowing update/conf. */\n    uint readOnly:1;    /* Value can not be set. */\n    uint noDupValue:1;  /* Values are not to be duped. */\n    uint noClear:1;     /* Values are not to be cleared: watch for memory leaks */\n    uint dbDirty:1;     /* Used to limit DB updates. */\n    uint dbIgnore:1;    /* Field is not to be used for DB. */\n    uint dbRowid:1 ;    /* Field used by DB to store rowid. */\n    uint custNoCase:1;  /* Ignore case (eg. for ENUM and BITSET). */\n    uint forceInt:1;    /* Force int instead of text for enum/bitset. */\n    uint bitsetBool:1;  /* Treat bitset custom field as bool instead of an int. */\n    uint timeDateOnly:1;/* Time field is date only. */\n    uint timeTimeOnly:1;/* Time field is time only. */\n    uint isBits:1;      /* Is a C bit-field. */\n    uint fmtString:1;   /* Format value (eg. time) as string. */\n    uint fmtNumber:1;   /* Format value (eg. enum) as number. */\n    uint fmtHext:1;     /* Format number in hex. */\n    uint strict:1;      /* Strict mode. */\n    uint fieldSetup:1;  /* Field has been setup. */\n    uint coerce:1;      /* Coerce input value to required type. */\n    uint noSig:1;       /* No signature. */\n    uint enumSpec:1;    /* Enum has spec rather than a list of strings. */\n    uint enumUnsigned:1;/* Enum value is unsigned. */\n    uint enumExact:1;   /* Enum must be an exact match. */\n    uint required:1;    /* Field must be specified (if not IS_UPDATE). */\n    uint prefix:1;      /* Allow matching unique prefix of object members. */\n    uint isUpdate:1;    /* This is an update/conf (do not reset the specified flags) */\n    uint ignoreExtra:1; /* Ignore extra members not found in spec. */\n    uint forceStrict:1; /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */\n    uint verbose:1;     /* Dump verbose options */\n    uint userBits:32;\n} jsi_OptionFlags;\n\ntypedef struct {\n    bool file;    // Ouput file:line information: default is at end.\n    bool full;    // Show full file path.\n    bool ftail;   // Show tail of file only, even in LogWarn, etc.\n    bool func;    // Ouput function at end.\n    bool Debug;\n    bool Trace;\n    bool Test;\n    bool Info;\n    bool Warn;\n    bool Error;\n    bool time;    // Prefix with time\n    bool date;    // Prefix with date\n    bool before;  // Print file:line before message instead of at end.\n    bool isUTC;\n    const char* timeFmt;\n    Jsi_Value *chan;\n} jsi_LogOptions;\n\ntypedef struct {\n    bool istty;\n    bool noRegex;\n    bool noReadline;\n    bool noproto;\n    bool outUndef;\n    bool logAllowDups;\n    bool logColNums;\n    bool privKeys;\n    bool compat;\n    bool mutexUnlock;\n    bool noFuncString;\n    int dblPrec;\n    const char *blacklist;\n    const char *prompt, *prompt2;\n} jsi_SubOptions;\n\nextern Jsi_OptionSpec jsi_InterpLogOptions[];\n\ntypedef enum {\n        jsi_TL_TRY,\n        jsi_TL_WITH,\n} jsi_try_op_type;                            /* type of try */\n\ntypedef enum { jsi_LOP_NOOP, jsi_LOP_THROW, jsi_LOP_JMP } jsi_last_try_op_t; \n\ntypedef struct jsi_TryList {\n    jsi_try_op_type type;\n    union {\n        struct {                    /* try data */\n            jsi_OpCode *tstart;         /* try start ip */\n            jsi_OpCode *tend;           /* try end ip */\n            jsi_OpCode *cstart;         /* ...*/\n            jsi_OpCode *cend;\n            jsi_OpCode *fstart;\n            jsi_OpCode *fend;\n            int tsp;\n            jsi_last_try_op_t last_op;              /* what to do after finally block */\n                                    /* depend on last jmp code in catch block */\n            union {\n                jsi_OpCode *tojmp;\n            } ld;                   /* jmp out of catch (target)*/\n        } td;\n        struct {                    /* with data */\n            jsi_OpCode *wstart;         /* with start */\n            jsi_OpCode *wend;           /* with end */\n        } wd;\n    } d;\n    \n    jsi_ScopeChain *scope_save;         /* saved scope (used in catch block/with block)*/\n    Jsi_Value *curscope_save;           /* saved current scope */\n    struct jsi_TryList *next;\n    bool inCatch;\n    bool inFinal;\n} jsi_TryList;\n\ntypedef enum {\n    jsi_safe_None,\n    jsi_safe_Read,\n    jsi_safe_Write,\n    jsi_safe_WriteRead,\n    jsi_safe_Lockdown\n} jsi_safe_mode;\n\nstruct Jsi_Interp {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    bool isSafe, startSafe;\n    jsi_safe_mode safeMode;\n    int iskips;\n    Jsi_Value *safeReadDirs;\n    Jsi_Value *safeWriteDirs;\n    const char *safeExecPattern;\n    Jsi_DebugInterp debugOpts;\n    struct jsi_TryList *tryList;\n    bool deleting;\n    bool destroying;\n    uint EventHdlId;\n    uint autoLoaded;\n    int exited;\n    int exitCode;\n    int interrupted;\n    int refCount;\n    int traceCall;\n    int traceOp;\n    int memDebug;\n    int coverAll, coverHit;\n    bool coverage;\n    bool profile;\n    int profileCnt;\n    bool asserts;\n    bool noNetwork;\n    bool noInput;\n    jsi_AssertMode assertMode;\n    uint unitTest;\n    const char *jsppChars;\n    Jsi_Value *jsppCallback;\n    bool noConfig;\n    bool noLoad;\n    bool noAutoLoad;\n    bool noStderr;\n    bool noSubInterps;\n    bool tracePuts;\n    bool isMain;\n    bool hasCallee;\n    bool subthread;\n    bool strict;\n    bool protoInit;\n    bool hasOpenSSL;\n    bool isHelp;\n    bool callerErr;\n    bool interactive;\n    jsi_SubOptions subOpts;\n    bool isInteractive;\n    const char *confArgs;\n    Jsi_Value *stdinStr;\n    Jsi_Value *stdoutStr;\n    Jsi_TypeCheck typeCheck;\n    jsi_LogOptions logOpts;\n    int typeWarnMax;\n    int typeMismatchCnt;\n    Jsi_InterpOpts opts;\n    Jsi_Value *inopts;\n    int evalFlags;\n    Jsi_InterpDebug dbStatic;\n    Jsi_InterpDebug *dbPtr;\n    jsiCallTraceProc traceHook;\n    int opCnt;  /* Count of instructions eval'ed */\n    int maxOpCnt;\n    int maxUserObjs;\n    int userObjCnt;\n    int funcCnt;\n    int level;  /* Nesting level of eval/func calls. */\n    int maxDepth;/* Max allowed eval recursion. */\n    int callDepth;\n    int maxIncDepth;\n    int includeDepth;\n    int includeCnt;\n    int maxInterpDepth;\n    int interpDepth;\n    int pkgReqDepth;\n    int didReturn;\n    uint codeCacheHit;\n    uint funcCallCnt;\n    uint cmdCallCnt;\n    uintptr_t eventIdx;\n#ifdef JSI_MEM_DEBUG\n    uint valueDebugIdx;\n    Jsi_Hash *codesTbl;\n#endif\n    jsi_ScopeChain *gsc;\n    Jsi_Value *csc;\n    struct Jsi_Interp *parent, *topInterp, *mainInterp;\n    Jsi_Value *onComplete;\n    Jsi_Value *onEval;\n    Jsi_Value *onExit;\n    Jsi_Value *execZip;\n    void (*logHook)(char *buf, va_list va);\n    const char *name;\n    Jsi_Value *pkgDirs;\n    bool selfZvfs;\n    int inParse;\n    Jsi_Value *retValue;       /* Return value from eval */\n    jsi_Pstate *ps, *parsePs;\n    Jsi_Value *argv0;\n    Jsi_Value *args;\n    Jsi_Value *console;\n    Jsi_Value *scriptFile;  /* Start script returned by info.argv0(). */\n    const char *scriptStr;\n    const char *curFile;\n    const char *curFunction;\n    const char *homeDir;\n    const char *historyFile;\n    char *curDir;\n    int maxStack;\n    double timesStart;\n\n    Jsi_Map *strKeyTbl;  /* Global strings table. */\n    Jsi_Map *cmdSpecTbl; /* Jsi_CmdSpecs registered. */\n    Jsi_Hash *onDeleteTbl;  /* Cleanup funcs to call on interp delete. */\n    Jsi_Hash *assocTbl;\n    Jsi_Hash *codeTbl; /* Scripts compiled table. */\n    Jsi_Hash *eventTbl;\n    Jsi_Hash *genValueTbl;\n    Jsi_Hash *genObjTbl;\n    Jsi_Hash *funcObjTbl;\n    Jsi_Hash *funcsTbl;\n    Jsi_Hash *bindTbl;\n    Jsi_Hash *fileTbl;    // The \"source\"ed files.\n    Jsi_Hash *lexkeyTbl;\n    Jsi_Hash *protoTbl;\n    Jsi_Hash *regexpTbl;    \n    Jsi_Hash *thisTbl;\n    Jsi_Hash *userdataTbl;\n    Jsi_Hash *varTbl;\n    Jsi_Hash *preserveTbl;\n    Jsi_Hash *loadTbl;\n    Jsi_Hash *staticFuncsTbl; // For debugOpts.typeProto\n    Jsi_Hash *breakpointHash;\n    Jsi_Hash *packageHash;\n    Jsi_Hash *aliasHash;\n    Jsi_Hash* vfsMountHash;\n    Jsi_Hash* vfsDefHash;\n#ifdef VAL_REFCNT\n    Jsi_Value **Stack;\n    Jsi_Value **Obj_this;\n#else\n    Jsi_Value *Stack;\n    Jsi_Value *Obj_this;\n#endif\n            \n    Jsi_Value *Object_prototype;\n    Jsi_Value *Function_prototype_prototype;\n    Jsi_Value *Function_prototype;\n    Jsi_Value *String_prototype;\n    Jsi_Value *Number_prototype;\n    Jsi_Value *Boolean_prototype;\n    Jsi_Value *Array_prototype;\n    Jsi_Value *RegExp_prototype;\n    Jsi_Value *Date_prototype;\n    \n    Jsi_Value *NaNValue;\n    Jsi_Value *InfValue;\n    Jsi_Value *NullValue;\n    Jsi_Value *nullFuncArg; /* Efficient call of no-arg func */\n    Jsi_Value *nullFuncRet;\n    Jsi_Value *autoFiles;\n    Jsi_Obj* cleanObjs[4];\n    Jsi_Obj* allObjs;\n    Jsi_Value* allValues, *udata;\n\n    Jsi_Value *busyCallback;\n    const char *confFile;\n    int busyInterval;\n    int isInCallback;\n    int cleanup;\n    int objId;\n    Jsi_Value *Top_object;\n    Jsi_ScopeStrs *scopes[JSI_MAX_SCOPE];\n    int cur_scope;\n    int maxArrayList;\n    int delRBCnt;\n    Jsi_Func *activeFunc;  // Currently active function call.\n    Jsi_Func *prevActiveFunc;  // Prev active function call.\n    jsi_OpCode *curIp;  /* Used for debug Log msgs. */\n    \n    char *lastPushStr;  // Used by error handling and Jsi_LogMsg.   TODO: cleanup/rationalize.\n    Jsi_Value* lastParseOpt;\n    Jsi_Value* lastSubscriptFail;\n    const char* lastSubscriptFailStr;\n    int logErrorCnt;\n    Jsi_OptionSpec *parseMsgSpec;\n\n\n    Jsi_Wide sigmask;\n    char errMsgBuf[JSI_BUFSIZ];  /* Error message space for when in try. */\n    int errLine;\n    int errCol;\n    const char *errFile;\n    Jsi_Mutex* Mutex;\n    Jsi_Mutex* QMutex; /* For threads queues */\n    void* threadId;\n    int threadCnt;\n    int threadShrCnt;\n    int lockTimeout; /* in milliseconds. */\n    uint lockRefCnt;\n    int psEpoch;\n    int mountCnt;\n    Jsi_DString interpEvalQ;\n    InterpStrEvent *interpStrEvents;\n\n    bool typeInit;\n    Jsi_Number cdataIncrVal;\n    Jsi_CData_Static *statics;\n    Jsi_VarSpec *cdataNewVal;\n    Jsi_Hash *StructHash;\n    Jsi_Hash *SigHash;\n    Jsi_Hash *EnumHash;\n    Jsi_Hash *EnumItemHash;\n    Jsi_Hash *CTypeHash;\n    Jsi_Hash *TYPEHash;\n\n    uint threadErrCnt;  /* Count of bad thread event return codes. */\n    uint threadEvalCnt;\n    uint threadMsgCnt;\n    void *sleepData;\n    jsi_PkgInfo *pkgRequiring, *pkgProviding;\n    jsi_Pline *parseLine;\n    jsi_Frame *framePtr;\n    struct jsi_DbVfs **dbVfsPtrPtr;\n    double subTime, startTime, funcSelfTime, cmdSelfTime;\n};\n\n\nenum { JSI_REG_GLOB=0x1, JSI_REG_NEWLINE=0x2, JSI_REG_DOT_NEWLINE=0x4, JSI_REG_STATIC=0x100 };\n\nstruct Jsi_Regex_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    regex_t reg;\n    int eflags;\n    int flags;\n    char *pattern;\n    int lastIndex;\n};\n\n\n/* Entries in interp->cmdSpecTbl. */\ntypedef struct Jsi_CmdSpecItem_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    const char *name;  /* Parent cmd. */\n    Jsi_CmdSpec *spec;\n    Jsi_Value *proto;\n    int flags;\n    void *privData;\n    Jsi_MapEntry *hPtr;\n    struct Jsi_CmdSpecItem_ *next; /* TODO: support user-added sub-commands. */\n    const char *help;\n    const char *info;\n    int isCons;\n} Jsi_CmdSpecItem;\n\n//extern Jsi_OptionTypedef jsi_OptTypeInfo[];\nextern const char* jsi_OptionTypeStr(Jsi_OptionId typ, bool cname);\nextern const Jsi_OptionTypedef* Jsi_OptionsStr2Type(const char *str, bool cname);\n\n/* SCOPE */\n//typedef struct jsi_ScopeChain jsi_ScopeChain;\n\nextern jsi_ScopeChain* jsi_ScopeChainNew(Jsi_Interp *interp, int cnt); /*STUB = 176*/\nextern Jsi_Value* jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key); /*STUB = 177*/\nextern jsi_ScopeChain* jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next); /*STUB = 178*/\nextern void jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc); /*STUB = 179*/\n\nextern void jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr);\n\nJsi_RC jsi_InitFilesys(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitLexer(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitLoad(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitCmds(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitInterp(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitFileCmds(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitString(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitValue(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitNumber(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitArray(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitBoolean(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitMath(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitProto(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitRegexp(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitJSON(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitSqlite(Jsi_Interp *interp, int release);\nJsi_RC Jsi_initSqlite(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitMySql(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitTree(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitWebSocket(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitSocket(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitSignal(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitOptions(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitZvfs(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitCData(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitVfs(Jsi_Interp *interp, int release);\nJsi_RC jsi_execCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr, Jsi_DString *cStr, int *code);\n\nvoid jsi_SignalClear(Jsi_Interp *interp, int sigNum);\nbool jsi_SignalIsSet(Jsi_Interp *interp, int sigNum);\n/* excute opcodes\n * 1. ps, program execution context\n * 2. opcodes, codes to be executed\n * 3. scope, current scopechain, not include current scope\n * 4. currentScope, current scope\n * 5. _this, where 'this' indicated\n * 6. vret, return value\n */\nextern Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n        jsi_ScopeChain *scope, Jsi_Value *currentScope,\n        Jsi_Value *_this,\n        Jsi_Value **vret);\n        \ntypedef Jsi_RC (*Jsi_Constructor)(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, int flags, void *privData);\nextern Jsi_RC jsi_SharedArgs(Jsi_Interp *interp, Jsi_Value *args, Jsi_Func *func, int alloc);\nextern void jsi_SetCallee(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *tocall);\nextern Jsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_NoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n    \nenum {StrKeyAny = 0, StrKeyFunc = 0x1, StrKeyCmd = 0x2, StrKeyVar = 0x2};\n\n//char* jsi_KeyLookup(Jsi_Interp *interp, const char *str);\nextern char* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey);\nextern void jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who);\nextern Jsi_Value *jsi_GlobalContext(Jsi_Interp *interp);\nextern void jsi_AddEventHandler(Jsi_Interp *interp);\nextern Jsi_RC jsi_SetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue, Jsi_Wide flags, bool isSafe);\nextern Jsi_RC jsi_GetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, void* record, const char *option, Jsi_Value **valuePtr, Jsi_Wide flags);\nextern const char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp);\nextern const char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val);\nextern const char *jsi_TypeName(Jsi_Interp *interp, Jsi_ttype otyp);\nextern Jsi_RC jsi_ObjectToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_HasOwnPropertyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_Value* jsi_ValueMakeBlobDup(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len);\n\nextern const char *jsi_GetHomeDir(Jsi_Interp *interp);\nextern Jsi_RC jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret);\nextern void jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec);\nextern Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops, jsi_Pline *line, const char *name, int isArrow);\nextern Jsi_Func *jsi_FuncNew(Jsi_Interp *interp);\nextern void jsi_FreeOpcodes(Jsi_OpCodes *ops);\nextern void jsi_DelAssocData(Jsi_Interp *interp, void *data);\n\nextern void jsi_UserObjFree (Jsi_Interp *interp, Jsi_UserObj *uobj);\nextern bool jsi_UserObjIsTrue (Jsi_Interp *interp, Jsi_UserObj *uobj);\nextern Jsi_RC jsi_UserObjDump   (Jsi_Interp *interp, const char *argStr, Jsi_Obj *obj);\nextern Jsi_RC jsi_UserObjDelete (Jsi_Interp *interp, void *data);\nextern void jsi_UserObjToName(Jsi_Interp *interp, Jsi_UserObj *uobj, Jsi_DString *dStr);\nextern Jsi_Obj *jsi_UserObjFromName(Jsi_Interp *interp, const char *name);\n\nextern Jsi_RC Zvfs_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret);\nextern Jsi_Value* jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex);\nextern void jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey);\nextern void jsi_ValueSubscriptLen(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val);\nextern Jsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret);\nextern Jsi_Value* jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value *value, int flag);\nextern void jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof);\nextern Jsi_Value* jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key);\nextern Jsi_Value* jsi_ProtoObjValueNew1(Jsi_Interp *interp, const char *name);\nextern Jsi_Value* jsi_ProtoValueNew(Jsi_Interp *interp, const char *name, const char *parent);\nextern Jsi_Value* jsi_ObjValueNew(Jsi_Interp *interp);\nextern Jsi_Value* Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v);\nextern int jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v);\nextern Jsi_RC jsi_FreeOneLoadHandle(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *handle);\nextern Jsi_Value* jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name, Jsi_Value** toVal, Jsi_CmdSpec *cspec);\nextern Jsi_Value* jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData);\nextern bool jsi_FuncArgCheck(Jsi_Interp *interp, Jsi_Func *f, const char *argStr);\nextern bool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent);\nextern Jsi_RC jsi_FileStatCmd(Jsi_Interp *interp, Jsi_Value *fnam, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int islstat);\nextern Jsi_RC jsi_LoadLoadCmd(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_LoadUnloadCmd(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\nextern void jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr);\nextern Jsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);\nextern Jsi_RC jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, const char *str, int flags, int level);\nextern Jsi_RC jsi_FuncArgsToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags);\nextern Jsi_Value *jsi_LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret);\nextern Jsi_RC jsi_SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, bool restricted);\n\nextern Jsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func);\nextern void jsi_FuncObjFree(Jsi_FuncObj *fobj);\nextern Jsi_RC jsi_ArglistFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);\nextern void jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func);\nextern void jsi_ToHexStr(const uchar *indata, int dlen, char *out);\nextern bool jsi_StrIsBalanced(char *str);\n\n#ifndef _JSI_MEMCLEAR\n#ifndef JSI_MEM_DEBUG\n#define _JSI_MEMCLEAR(ptr)\n#else\n#define _JSI_MEMCLEAR(ptr) memset(ptr, 0, sizeof(*ptr)) /* To aid debugging memory.*/\n#endif\n#endif\n\n#define MAX_SUBREGEX    256\n#define JSI__LONG_LONG\n#define UCHAR(s) (unsigned char)(s)\nextern char* jsi_SubstrDup(const char *a, int alen, int start, int len, int *olen);\nextern int jsi_typeGet(Jsi_Interp *interp , const char *tname);\nextern const char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr);\nextern Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ, Jsi_Value *arg, const char *p1, const char *p2, int index, Jsi_Func *func, bool isdefault);\nextern void jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, bool isNew, const char *name, const char *namePre, Jsi_OpCodes *argCodes);\nextern Jsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes, bool isParse);\nextern Jsi_RC jsi_FunctionSubCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Value *tocall, int discard);\nextern Jsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a);\nextern Jsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue, jsi_Pline *lPtr, bool prepend);\nextern Jsi_ScopeStrs* jsi_ParseArgStr(Jsi_Interp *interp, const char *argStr);\nextern Jsi_Value* jsi_AccessFile(Jsi_Interp *interp, const char *name, int mode);\nextern double jsi_GetTimestamp(void);\nextern const char *jsi_GetCurFile(Jsi_Interp *interp);\nextern void jsi_TypeMismatch(Jsi_Interp* interp);\nextern void jsi_SortDString(Jsi_Interp *interp, Jsi_DString *dStr, const char *sep);\nextern const char* jsi_GetDirective(Jsi_Interp *interp, Jsi_OpCodes *ops, const char *str);\nextern Jsi_Value* jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData, int flags, Jsi_CmdSpec *cspec);\nextern int jsi_GetDefaultType(const char *cp);\nextern Jsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str);\nextern Jsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc);\nextern Jsi_RC jsi_CDataDataSetCmdSub(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, int flags);\nextern Jsi_RC jsi_AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_Number jsi_VersionNormalize(Jsi_Number ver, char *obuf, size_t osiz);\nextern const char* jsi_FuncGetCode(Jsi_Interp *interp, Jsi_Func *func, int *lenPtr);\nextern Jsi_RC jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret, int *ofs, bool match);\nextern int jsi_AllObjOp(Jsi_Interp *interp, Jsi_Obj* obj, int op);\n//extern void jsi_AllValueOp(Jsi_Interp *interp, Jsi_Value* obj, int op);\nextern Jsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret); //TODO: EXPORT\nextern void jsi_SysPutsCmdPrefix(Jsi_Interp *interp, jsi_LogOptions *popts,Jsi_DString *dStr, int* quote, const char **fnPtr);\n\nextern char jsi_toHexChar(char code);\nextern char jsi_fromHexChar(char ch);\nextern bool Jsi_StrIsAlnum(const char *cp);\nextern char *jsi_TrimStr(char *str);\nextern bool jsi_ModBlacklisted(Jsi_Interp *interp, const char *mod);\nextern bool jsi_FuncIsNoop(Jsi_Interp* interp, Jsi_Value *func);\n\ntypedef enum {\n    _JSI_CDATA_INFO=0,\n    _JSI_CDATA_GET=1,\n    _JSI_CDATA_SET=2,\n    _JSI_CDATA_SIZE=3,\n    _JSI_CDATA_SCHEMA=4,\n    _JSI_CDATA_STRUCT=6\n} jsi_cdatasub;\n\n//extern Jsi_RC jsi_cdataMapsubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n//    Jsi_Value **ret, Jsi_Func *funcPtr, jsi_cdatasub sub);\n\n#define jsi_ValueString(pv) (pv->vt == JSI_VT_STRING ? &pv->d.s : \\\n  ((pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING) ? &pv->d.obj->d.s : NULL))\n                 \n#define jsi_PrefixMatch(str, cstr) (!Jsi_Strncmp(str, cstr, sizeof(cstr)-1))\n\n#ifdef JSI_MEM_DEBUG\n#define jsi_ValueDebugUpdate(interp, v, tbl, file, line, func) jsi_ValueDebugUpdate_(interp, &v->VD, v, interp->dbPtr->tbl, file, line, func)\n#define jsi_ValueDebugLabel(v,l1,l2) jsi_ValueDebugLabel_(&v->VD,l1,l2)\n\n#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueDup(interp,v) jsi_ValueDup(interp, v,__FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n\nextern Jsi_Value *jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func);\nextern Jsi_Value *jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func);\nextern Jsi_Value *jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func);\nextern Jsi_Obj *jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func);\nextern void jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2);\nextern void jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func);\nextern void jsi_DebugValue(Jsi_Value* v, const char *reason, uint idx, Jsi_Interp *interp);\nextern void jsi_DebugObj(Jsi_Obj* o, const char *reason, uint idx, Jsi_Interp *interp);\n\n#define jsi_DebugValueCallIdx() ++interp->dbPtr->memDebugCallIdx\n#define VALINIT { __VALSIG__ .refCnt=1, .vt=JSI_VT_UNDEF, .f={.flag=JSI_OM_ISSTATIC}, .d={}, .next=NULL, .prev=NULL, .VD={.fname=__FILE__, .line=__LINE__,.func=__PRETTY_FUNCTION__}  }\n#else\n#define VALINIT { __VALSIG__ .refCnt=1, .vt=JSI_VT_UNDEF, .f={.flag=JSI_OM_ISSTATIC}  }\n#define jsi_ValueDebugUpdate(interp, vd, v, tbl, file, line, func)\n#define jsi_ValueDebugLabel(v,l1,l2)\n#define jsi_DebugValue(v,r,i,t)\n#define jsi_DebugObj(o,r,i,t)\n#define jsi_DebugValueCallIdx() 0\n#define jsi_ValueDebugLabel_(v,l1,l2)\n#endif\n\n#define DECL_VALINIT(n) Jsi_Value n = VALINIT\n\nvoid jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *func, jsi_OpCode *iPtr, \n    Jsi_Value *_this, Jsi_Value* args, Jsi_Value *ret, int tc);\n\n\n#if JSI__SANITIZE\n#define Jsi_Malloc(sz) malloc(sz)\n#define Jsi_Calloc(nm, sz) calloc(nm,sz)\n#define Jsi_Realloc(ptr, sz) realloc(ptr,sz)\n#define Jsi_Free(ptr) free(ptr)\n#endif\n\nstruct Jsi_Stubs;\nextern struct Jsi_Stubs *jsiStubsTblPtr;\nextern const char *jsi_AssertModeStrs[];\nextern const char *jsi_callTraceStrs[];\nextern Jsi_CmdSpec cDataArrayCmds[];\n\n// Global Jsi internal state.\ntypedef struct {\n    Jsi_Interp *mainInterp;\n    Jsi_Interp *delInterp;\n    Jsi_Hash *interpsTbl;\n    bool isInit;\n    char *execName;\n    Jsi_Value *execValue;\n    Jsi_Chan stdChans[3];\n    Jsi_Filesystem *cwdFsPtr;\n    Jsi_DString pwdStr;\n    char *pwd;\n    int tolowerZvfs;\n    struct {\n        Jsi_Hash* fileHash;\n        Jsi_Hash *archiveHash;\n        int isInit;\n        Jsi_Interp *interp;\n    } zvfslocal;\n} jsi_IntData;\n\nextern jsi_IntData jsiIntData;\n\n#define jsi_Stdin jsiIntData.stdChans\n#define jsi_Stdout (jsiIntData.stdChans+1)\n#define jsi_Stderr (jsiIntData.stdChans+2)\n\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n\n#endif /* __JSIINT_H__ */\n", "#ifndef JSI_LITE_ONLY\n#define __JSIINT_C__\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <assert.h>\n\n#ifdef __WIN32\n#include <windows.h>\n#include <shlwapi.h>\n#ifndef JSI_OMIT_THREADS\n#include <process.h>\n#endif\n#else\n#ifndef JSI_OMIT_THREADS\n#include <pthread.h>\n#endif\n#endif\n\n#if (JSI_VERSION_MINOR<0 || JSI_VERSION_MINOR>99 || JSI_VERSION_RELEASE<0 || JSI_VERSION_RELEASE>99)\n#error \"VERSION MINOR/RELEASE not between 0-99 inclusive\"\n#endif\n\nstatic Jsi_OptionSpec InterpDebugOptions[] = {\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, debugCallback,  .help=\"Command in parent interp for handling debugging\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"file:string, line:number, level:number, func:string, opstr:string, bpId:number, emsg:string\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, doContinue,     .help=\"Continue execution until breakpoint\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, forceBreak,     .help=\"Force debugger to break\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeOnce,    .help=\"Source the file only if not already sourced\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeTrace,   .help=\"Trace includes\" ),\n    JSI_OPT(INT,   Jsi_DebugInterp, minLevel,       .help=\"Disable eval callback for level higher than this\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, msgCallback,    .help=\"Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,..\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, type:string, file:string, line:number, col:number\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, pkgTrace,       .help=\"Trace package loads\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, putsCallback,   .help=\"Comand in parent interp to handle puts output\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, isStderr:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, traceCallback,  .help=\"Comand in parent interp to handle traceCall\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, args:string, ret:string, file:string, line:number, col:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, testFmtCallback,.help=\"Comand in parent interp to format unittest string\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, line:number\" ),\n    JSI_OPT_END(Jsi_DebugInterp, .help=\"Interp options for debugging\")\n};\n\nJsi_OptionSpec jsi_InterpLogOptions[] = {\n    JSI_OPT(BOOL,   jsi_LogOptions, Test,    .help=\"Enable LogTest messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Debug,   .help=\"Enable LogDebug messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Trace,   .help=\"Enable LogTrace messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Info,    .help=\"Enable LogInfo messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Warn,    .help=\"Enable LogWarn messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Error,   .help=\"Enable LogError messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, time,    .help=\"Prefix with time\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, date,    .help=\"Prefix with date\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, file,    .help=\"Ouptut contains file:line\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, func,    .help=\"Output function\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, full,    .help=\"Show full file path\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, ftail,   .help=\"Show tail of file only, even in LogWarn, etc\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, before,  .help=\"Output file:line before message string\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, isUTC,   .help=\"Time is to be UTC\" ),\n    JSI_OPT(STRKEY, jsi_LogOptions, timeFmt, .help=\"A format string to use with strftime\" ),\n    JSI_OPT(USEROBJ,jsi_LogOptions, chan,    .help=\"Channel to send output to\", .flags=0, .custom=0, .data=(void*)\"Channel\" ),\n    JSI_OPT_END(jsi_LogOptions, .help=\"Interp options for logging\")\n};\nstatic Jsi_OptionSpec InterpSubOptions[] = {\n    JSI_OPT(STRKEY,jsi_SubOptions, blacklist,   .help=\"Comma separated modules to disable loading for\", jsi_IIOF ),\n    JSI_OPT(BOOL,  jsi_SubOptions, compat,      .help=\"Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser\" ),\n    JSI_OPT(INT,   jsi_SubOptions, dblPrec,     .help=\"Format precision of double where 0=max, -1=max-1, ... (max-1)\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, istty,       .help=\"Indicates interp is in interactive mode\", jsi_IIRO),\n    JSI_OPT(BOOL,  jsi_SubOptions, logColNums,  .help=\"Display column numbers in error messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, logAllowDups,.help=\"Log should not filter out duplicate messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, mutexUnlock, .help=\"Unlock own mutex when evaling in other interps (true)\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noproto,     .help=\"Disable support of the OOP symbols:  __proto__, prototype, constructor, etc\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, noFuncString,.help=\"Disable viewing code body for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noRegex,     .help=\"Disable viewing code for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noReadline,  .help=\"In interactive mode disable use of readline\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, outUndef,    .help=\"In interactive mode output result values that are undefined\"),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt,      .help=\"Prompt for interactive mode ('$ ')\" ),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt2,     .help=\"Prompt for interactive mode line continue ('> ')\" ),\n    JSI_OPT_END(jsi_SubOptions, .help=\"Lesser sub-feature options\")\n};\n\nstatic const char *jsi_SafeModeStrs[] = { \"none\", \"read\", \"write\", \"writeRead\", \"lockdown\", NULL };\nstatic const char *jsi_TypeChkStrs[] = { \"parse\", \"run\", \"all\", \"error\", \"strict\", \"noundef\", \"nowith\", \"funcsig\", NULL };\nconst char *jsi_callTraceStrs[] = { \"funcs\", \"cmds\", \"new\", \"return\", \"args\", \"notrunc\", \"noparent\", \"full\", \"before\", NULL};\nconst char *jsi_AssertModeStrs[] = { \"throw\", \"log\", \"puts\", NULL};\n\nstatic Jsi_OptionSpec InterpOptions[] = {\n    JSI_OPT(ARRAY, Jsi_Interp, args,        .help=\"The console.arguments for interp\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, asserts,     .help=\"Enable assert\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, assertMode,  .help=\"Action upon assert failure\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, autoFiles,   .help=\"File(s) to source for loading Jsi_Auto to handle unknown commands\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, busyCallback,.help=\"Command in parent interp (or noOp) to periodically call\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"interpName:string, opCnt:number\"),\n    JSI_OPT(INT   ,Jsi_Interp, busyInterval,.help=\"Call busyCallback command after this many op-code evals (100000)\"),\n    JSI_OPT(STRKEY,Jsi_Interp, confFile,    .help=\"Config file of options in non-strict JSON form\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, coverage,    .help=\"On exit generate detailed code coverage for function calls (with profile)\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, debugOpts,   .help=\"Options for debugging\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpDebugOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, interactive, .help=\"Force interactive mode. ie. ignore no_interactive flag\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, hasOpenSSL,  .help=\"Is SSL available in WebSocket\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, historyFile, .help=\"In interactive mode, file to use for history (~/.jsish_history)\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, isSafe,      .help=\"Is this a safe interp (ie. with limited or no file access)\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, jsppChars,   .help=\"Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string\"),\n    JSI_OPT(FUNC,  Jsi_Interp, jsppCallback,.help=\"Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number)\"),\n    JSI_OPT(INT,   Jsi_Interp, lockTimeout, .help=\"Thread time-out for mutex lock acquires (milliseconds)\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, logOpts,     .help=\"Options for log output to add file/line/time\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=jsi_InterpLogOptions),\n    JSI_OPT(INT,   Jsi_Interp, maxDepth,    .help=\"Depth limit of recursive function calls (1000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxArrayList,.help=\"Maximum array convertable to list (100000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxIncDepth, .help=\"Maximum allowed source/require nesting depth (50)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxInterpDepth,.help=\"Maximum nested subinterp create depth (10)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxUserObjs, .help=\"Maximum number of 'new' object calls, eg. File, RegExp, etc\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, maxOpCnt,    .help=\"Execution limit for op-code evaluation\", jsi_IIOF|JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, memDebug,    .help=\"Memory debugging level: 1=summary, 2=detail\", .flags=JSI_OPT_NO_CLEAR),\n    JSI_OPT(STRKEY,Jsi_Interp, name,        .help=\"Optional text name for this interp\"),\n    JSI_OPT(BOOL,  Jsi_Interp, noAutoLoad,  .help=\"Disable autoload\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(BOOL,  Jsi_Interp, noConfig,    .help=\"Disable use of Interp.conf to change options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, noInput,     .help=\"Disable use of console.input()\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noLoad,      .help=\"Disable load of shared libs\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, noNetwork,   .help=\"Disable new Socket/WebSocket, or load of builtin MySql\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noStderr,    .help=\"Make puts, log, assert, etc use stdout\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noSubInterps,.help=\"Disallow sub-interp creation\"),\n    JSI_OPT(FUNC,  Jsi_Interp, onComplete,  .help=\"Function to return commands completions for interactive mode.  Default uses Info.completions \", .flags=0, .custom=0, .data=(void*)\"prefix:string, start:number, end:number\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onEval,      .help=\"Function to get control for interactive evals\", .flags=0, .custom=0, .data=(void*)\"cmd:string\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onExit,      .help=\"Command to call in parent on exit, returns true to continue\", jsi_IIOF , .custom=0, .data=(void*)\"\"),\n    JSI_OPT(ARRAY, Jsi_Interp, pkgDirs,     .help=\"list of library directories for require() to search\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, profile,     .help=\"On exit generate profile of function calls\"),\n    JSI_OPT(VALUE, Jsi_Interp, retValue,    .help=\"Return value from last eval\", jsi_IIRO),\n    JSI_OPT(CUSTOM,Jsi_Interp, safeMode,    .help=\"In safe mode source() support for pwd and script-dir \", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=jsi_SafeModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, safeReadDirs,.help=\"In safe mode, files/dirs to allow reads to\", jsi_IIOF),\n    JSI_OPT(ARRAY, Jsi_Interp, safeWriteDirs,.help=\"In safe mode, files/dirs to allow writes to\", jsi_IIOF),\n    JSI_OPT(STRKEY, Jsi_Interp,safeExecPattern,.help=\"In safe mode, regexp pattern allow exec of commands\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, scriptStr,   .help=\"Interp init script string\", jsi_IIOF),\n    JSI_OPT(STRING,Jsi_Interp, scriptFile,  .help=\"Interp init script file\"),\n    JSI_OPT(STRING,Jsi_Interp, stdinStr,    .help=\"String to use as stdin for console.input()\"),\n    JSI_OPT(STRING,Jsi_Interp, stdoutStr,   .help=\"String to collect stdout for puts()\"),\n    JSI_OPT(BOOL,  Jsi_Interp, strict,      .help=\"Globally enable strict: same as 'use strict' in main program\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, subOpts,     .help=\"Infrequently used sub-options\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpSubOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, subthread,   .help=\"Create a threaded Interp\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(CUSTOM,Jsi_Interp, traceCall,   .help=\"Trace commands\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=jsi_callTraceStrs),\n    JSI_OPT(INT,   Jsi_Interp, traceOp,     .help=\"Set debugging level for OPCODE execution\"),\n    JSI_OPT(BOOL,  Jsi_Interp, tracePuts,   .help=\"Trace puts by making it use logOpts\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, typeCheck,   .help=\"Type-check control options\", .flags=0, .custom=Jsi_Opt_SwitchBitset, .data=jsi_TypeChkStrs),\n    JSI_OPT(INT,   Jsi_Interp, typeWarnMax, .help=\"Type checking is silently disabled after this many warnings (50)\" ),\n    JSI_OPT(OBJ,   Jsi_Interp, udata,       .help=\"User data\"),\n    JSI_OPT(UINT,  Jsi_Interp, unitTest,    .help=\"Unit test control bits: 1=subst, 2=Puts with file:line prefix\" ),\n    JSI_OPT_END(Jsi_Interp, .help=\"Options for the Jsi interpreter\")\n};\n\n/* Object for each interp created. */\ntypedef struct InterpObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *subinterp;\n    Jsi_Interp *parent;\n    //char *interpname;\n    char *mode;\n    Jsi_Obj *fobj;\n    int objId;\n    int deleting;\n} InterpObj;\n\n/* Global state of interps. */\n\ntypedef struct {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int refCount;\n    const char *cmdName;\n    Jsi_Value *args;\n    Jsi_Value *func;\n    Jsi_Value *cmdVal;\n    InterpObj *intobj;\n    Jsi_Interp *dinterp; // Dest interp.\n    Jsi_Interp *subinterp;\n} AliasCmd;\n\n\nstatic void interpObjErase(InterpObj *fo);\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data);\nstatic bool interpObjIsTrue(void *data);\nstatic bool interpObjEqual(void *data1, void *data2);\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp);\n\n/* Call a command with JSON args.  Returned string by using Jsi_ValueGetDString(..., flags). */\nJsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags)\n{\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_CommandInvokeJSON(interp, cmd, jsonArgs, &nrPtr);\n    Jsi_DSInit(dStr);\n    Jsi_ValueGetDString(interp, nrPtr, dStr, flags /*JSI_OUTPUT_JSON*/);\n    Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    return rc;\n}\n\n/* Call a function with JSON args.  Return a primative. */\nJsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *func, const char *json, Jsi_Value **ret)\n{\n    if (!Jsi_ValueIsFunction(interp, func))\n        return JSI_ERROR;\n    Jsi_Value *aPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_JSONParse(interp, json, &aPtr, 0);\n    if (rc == JSI_OK)\n        rc = Jsi_FunctionInvoke(interp, func, aPtr, ret, NULL);\n    Jsi_DecrRefCount(interp, aPtr);\n    return rc;\n}\n/* Lookup cmd from cmdstr and invoke with JSON args. */\n/*\n *   Jsi_CommandInvokeJSON(interp, \"info.cmds\", \"[\\\"*\\\",true]\", ret);\n */\nJsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmdstr, const char *json, Jsi_Value **ret)\n{\n    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);\n    if (func)\n        return Jsi_FunctionInvokeJSON(interp, func, json, ret);\n    return Jsi_LogError(\"can not find cmd: %s\", cmdstr);\n}\n\n/* Clean-copying of value between interps: uses JSON parse if needed. */\nJsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret)\n{\n    Jsi_RC rc = JSI_OK;\n    const char *cp;\n    int len, iskey;\n    Jsi_Obj *obj;\n    switch (val->vt) {\n        case JSI_VT_UNDEF: Jsi_ValueMakeUndef(interp, ret); return rc;\n        case JSI_VT_NULL: Jsi_ValueMakeNull(tointerp, ret); return rc;\n        case JSI_VT_BOOL: Jsi_ValueMakeBool(tointerp, ret, val->d.val); return rc;\n        case JSI_VT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, val->d.num); return rc;\n        case JSI_VT_STRING:\n            iskey = val->f.bits.isstrkey;\n            cp = val->d.s.str;\n            len = val->d.s.len;\nmakestr:\n            if (iskey) {\n                Jsi_ValueMakeStringKey(interp, ret, cp);\n                return rc;\n            }\n            jsi_ValueMakeBlobDup(tointerp, ret, (uchar*)cp, len);\n            return rc;\n        case JSI_VT_OBJECT:\n            obj = val->d.obj;\n            switch (obj->ot) {\n                case JSI_OT_BOOL: Jsi_ValueMakeBool(tointerp, ret, obj->d.val); return rc;\n                case JSI_OT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, obj->d.num); return rc;\n                case JSI_OT_STRING:\n                    cp = obj->d.s.str;\n                    len = obj->d.s.len;\n                    iskey = obj->isstrkey;\n                    goto makestr;\n                default: break;\n            }\n            break;\n        default:\n            break;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    cp = Jsi_ValueGetDString(interp, val, &dStr, JSI_OUTPUT_JSON);\n    if (Jsi_JSONParse(tointerp, cp, ret, 0) != JSI_OK) {\n        Jsi_DSFree(&dStr);\n        return Jsi_LogWarn(\"bad JSON parse in subinterp\");\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n/* Invoke command in target interp. */\nJsi_RC jsi_AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    AliasCmd *ac = (AliasCmd *)funcPtr->cmdSpec->reserved[2];\n    Jsi_Interp *dinterp = ac->dinterp;\n    Jsi_Value *nargs = NULL;\n    int inc=0, argc = Jsi_ValueGetLength(interp, args);\n    if (!ac) {\n        Jsi_LogBug(\"BAD ALIAS INVOKE OF DELETED\");\n        return JSI_ERROR;\n    }\n    SIGASSERT(ac,ALIASCMD);\n    bool isthrd = (interp != dinterp && interp->threadId != dinterp->threadId);\n    Jsi_Value *nrPtr = Jsi_ValueNew1(dinterp);\n\n     if (argc == 0 && ac->args)\n        nargs = ac->args;\n     else if (argc) {\n        if (dinterp == interp)\n            Jsi_ValueCopy(interp, nrPtr, args);\n        else if (Jsi_CleanValue(interp, dinterp, args, &nrPtr) != JSI_OK)\n            return JSI_ERROR;\n        if (ac->args && Jsi_ValueGetLength(dinterp, ac->args)) {\n            nargs = Jsi_ValueArrayConcat(dinterp, ac->args, nrPtr);\n            Jsi_IncrRefCount(dinterp, nargs);\n            inc=1;\n        } else {\n            nargs = nrPtr;\n        }\n    }\n\n    if (isthrd) {\n        /* Post to thread event in sub-interps queue. */\n        if (Jsi_MutexLock(interp, dinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n\n       /* Is an async call. */\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        // TODO: is s->data inited?\n        Jsi_DSInit(&s->data);\n        Jsi_ValueGetDString(interp, nargs, &s->data, JSI_OUTPUT_JSON);\n        if (inc)\n            Jsi_DecrRefCount(dinterp, nargs);\n        Jsi_DecrRefCount(dinterp, nrPtr);\n        s->acfunc = ac->func;\n        Jsi_IncrRefCount(dinterp, ac->func);\n        se = dinterp->interpStrEvents;\n        if (!se)\n            dinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, dinterp->QMutex);\n        return JSI_OK;\n    }\n\n    if (dinterp != interp) {\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, dinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n    }\n    ac->refCount++;\n    Jsi_Value *srPtr, **srpPtr = ret;\n    if (dinterp != interp) {\n        srPtr = Jsi_ValueNew1(dinterp);\n        srpPtr = &srPtr;\n    }\n    Jsi_RC rc = Jsi_FunctionInvoke(dinterp, ac->func, nargs, srpPtr, NULL);\n    ac->refCount--;\n    if (inc)\n        Jsi_DecrRefCount(dinterp, nargs);\n    Jsi_DecrRefCount(dinterp, nrPtr);\n    if (dinterp != interp) {\n        Jsi_MutexUnlock(interp, dinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            return JSI_ERROR;\n        }\n    }\n    if (dinterp != interp) {\n        Jsi_CleanValue(dinterp, interp, *srpPtr, ret);\n        Jsi_DecrRefCount(dinterp, srPtr);\n        if (rc != JSI_OK && dinterp->errMsgBuf[0] && interp != dinterp) {\n            Jsi_Strcpy(interp->errMsgBuf, dinterp->errMsgBuf);\n            interp->errLine = dinterp->errLine;\n            interp->errFile = dinterp->errFile;\n            dinterp->errMsgBuf[0] = 0;\n        }\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_AliasFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data) {\n    /* TODO: deal with other copies of func may be floating around (refCount). */\n    AliasCmd *ac = (AliasCmd *)data;\n    if (!ac) return JSI_ERROR;\n    SIGASSERT(ac,ALIASCMD);\n    if (ac->func)\n        Jsi_DecrRefCount(ac->dinterp, ac->func);\n    if (ac->args)\n        Jsi_DecrRefCount(ac->dinterp, ac->args);\n    if (!ac->cmdVal)\n        return JSI_OK;\n    Jsi_Func *fobj = ac->cmdVal->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = NULL;\n    fobj->cmdSpec->proc = NULL;\n    if (ac->intobj && ac->intobj->subinterp) {\n        Jsi_CommandDelete(ac->intobj->subinterp, ac->cmdName);\n        //if (Jsi_Strchr(ac->cmdName, '.'))\n        //    Jsi_LogBug(\"alias free with X.Y dot name leaks memory: %s\", ac->cmdName);\n    } else\n        Jsi_DecrRefCount(ac->subinterp, ac->cmdVal);\n    _JSI_MEMCLEAR(ac);\n    Jsi_Free(ac);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_AliasCreateCmd(Jsi_Interp* interp, const char* key, AliasCmd* ac) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    key = Jsi_KeyAdd(interp, key);\n    Jsi_Value *cmd = jsi_CommandCreate(interp, key, jsi_AliasInvoke, NULL, 0, 0);\n    if (!cmd)\n        return Jsi_LogBug(\"command create failure\");\n    ac->cmdVal = cmd;\n    Jsi_Func *fobj = cmd->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = ac;\n    cmd->d.obj->isNoOp = (ac->func->d.obj->d.fobj->func->callback == jsi_NoOpCmd);\n    return JSI_OK;\n}\n\n#define FN_intalias JSI_INFO(\"With 0 args, returns list of all aliases in interp.\\n\\\nWith 1 arg returns func for given alias name.\\n\\\nWith 2 args where arg2 == null, returns args for given alias name .\\n\\\nWith 3 args, create/update an alias for func and args. \\n\\\nDelete an alias by creating it with null for both func and args.\")\nstatic Jsi_RC InterpAliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = (udf ? udf->subinterp : interp );\n    Jsi_Hash *aliases = sinterp->aliasHash;\n    if (!aliases)\n        return Jsi_LogError(\"Sub-interp gone\");\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, aliases, ret, 0);\n    Jsi_HashEntry *hPtr;\n    char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!key)\n        return Jsi_LogError(\"expected string\");\n    AliasCmd* ac;\n    if (argc == 1) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->func);\n        return JSI_OK;\n    }\n    Jsi_Value *afunc = Jsi_ValueArrayIndex(interp, args, 1);\n    if (argc == 2) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!Jsi_ValueIsNull(interp, afunc))\n            return Jsi_LogError(\"arg 2: expected null to query args\");\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->args); //TODO: JSON??\n        return JSI_OK;\n    }\n    \n    if (argc < 3)\n        return JSI_ERROR;\n    bool isthrd = (interp->threadId != sinterp->threadId);\n    //if (isthrd)\n        //return Jsi_LogError(\"alias not supported with threads\");\n    bool isNew;\n    Jsi_Value *aargs = Jsi_ValueArrayIndex(interp, args, 2);\n    if (Jsi_ValueIsNull(interp, afunc) && Jsi_ValueIsNull(interp, aargs)) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (hPtr == NULL)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        if (0 && ac->cmdVal)\n            Jsi_DecrRefCount(interp, ac->cmdVal);\n        jsi_AliasFree(interp, NULL, ac);\n        Jsi_HashValueSet(hPtr, NULL);\n        Jsi_HashEntryDelete(hPtr);\n        return JSI_OK;\n    }\n    hPtr = Jsi_HashEntryNew(aliases, (void*)key, &isNew);\n    if (!hPtr)\n        return Jsi_LogError(\"create failed: %s\", key);\n    if (!Jsi_ValueIsFunction(interp, afunc))\n        return Jsi_LogError(\"arg 2: expected function\");\n    if (Jsi_ValueIsNull(interp, aargs) == 0 && Jsi_ValueIsArray(interp, aargs) == 0)\n        return Jsi_LogError(\"arg 3: expected array or null\");\n    if (!isNew) {\n        jsi_AliasFree(interp, NULL, Jsi_HashValueGet(hPtr));\n    }\n    ac = (AliasCmd*)Jsi_Calloc(1, sizeof(AliasCmd));\n    SIGINIT(ac, ALIASCMD);\n    ac->cmdName = (const char*)Jsi_HashKeyGet(hPtr);\n    ac->func = afunc;\n    Jsi_IncrRefCount(interp, afunc);\n    if (!Jsi_ValueIsNull(interp, aargs)) {\n        ac->args = aargs;\n        Jsi_IncrRefCount(interp, aargs);\n    }\n    ac->intobj = udf;\n    ac->dinterp = interp;\n    ac->subinterp = sinterp;\n    Jsi_HashValueSet(hPtr, ac);\n    if (!isthrd)\n        return jsi_AliasCreateCmd(sinterp, key, ac);\n\n    Jsi_Value *vasync = Jsi_ValueArrayIndex(interp, args, 3);\n    bool async = 0;\n    if (vasync && Jsi_GetBoolFromValue(interp, vasync, &async))\n        return JSI_ERROR;\n        \n    if (!async) {\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_RC rc = jsi_AliasCreateCmd(sinterp, key, ac);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    s->acdata = ac;\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, ac->cmdName, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCodeTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_Pstate *ps = (jsi_Pstate *)ptr;\n    if (!ps) return JSI_OK;\n    ps->hPtr = NULL;\n    jsi_PstateFree(ps);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeOnDeleteTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_DeleteProc *proc = (Jsi_DeleteProc *)ptr;\n    proc(interp, NULL);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeAssocTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_DelAssocData(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeEventTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Event *event = (Jsi_Event *)ptr;\n    SIGASSERT(event,EVENT);\n    if (!ptr) return JSI_OK;\n    Jsi_HashValueSet(event->hPtr, NULL);\n    event->hPtr = NULL;\n    Jsi_EventFree(interp, event);\n    return JSI_OK;\n}\nJsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Free(ptr);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC packageHashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_PkgInfo *p = (jsi_PkgInfo*)ptr;\n    if (p->popts.info) Jsi_DecrRefCount(interp, p->popts.info);\n    Jsi_Free(p);\n    return JSI_OK;\n}\n\nstatic Jsi_RC regExpFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_RegExpFree((Jsi_Regex*)ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCmdSpecTbl(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_CmdSpecDelete(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeGenObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *obj = (Jsi_Obj *)ptr;\n    SIGASSERT(obj,OBJ);\n    if (!obj) return JSI_OK;\n    Jsi_ObjDecrRefCount(interp, obj);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC freeFuncsTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Func *func = (Jsi_Func *)ptr;\n    if (!func) return JSI_OK;\n    SIGASSERT(func,FUNC);\n    func->hPtr = NULL;\n    jsi_FuncFree(interp, func);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeFuncObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj) {\n        if (v->d.fobj->scope) {\n            jsi_ScopeChain *scope = v->d.fobj->scope;\n            v->d.fobj->scope = NULL;\n            jsi_ScopeChainFree(interp, scope);\n        }\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeBindObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj && v->d.fobj->scope) {\n        v->d.fobj->scope = NULL;\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\n/* TODO: incr ref before add then just decr till done. */\nstatic Jsi_RC freeValueTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Value *val = (Jsi_Value *)ptr;\n    if (!val) return JSI_OK;\n    SIGASSERT(val,VALUE);\n    //printf(\"GEN: %p\\n\", val);\n   /* if (val->refCnt>1)\n        Jsi_DecrRefCount(interp, val);*/\n    Jsi_DecrRefCount(interp, val);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeUserdataTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (ptr)\n        jsi_UserObjDelete(interp, ptr);\n    return JSI_OK;\n}\n\nvoid Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v) {\n    if (!v)\n        v = interp->args;\n    if (v==NULL || v->vt != JSI_VT_OBJECT || v->d.obj->arr == NULL || v->d.obj->arrCnt <= 0)\n        return;\n    Jsi_Obj *obj = v->d.obj;\n    int n = v->d.obj->arrCnt;\n    n--;\n    v = obj->arr[0];\n    if (v)\n        Jsi_DecrRefCount(interp, v);\n    if (n>0)\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n    obj->arr[n] = NULL;\n    Jsi_ObjSetLength(interp, obj, n);\n}\n\nJsi_Value *Jsi_Executable(Jsi_Interp *interp)\n{\n    return jsiIntData.execValue;\n}\n\nstatic Jsi_RC KeyLocker(Jsi_Hash* tbl, int lock)\n{\n    if (!lock)\n        Jsi_MutexUnlock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    else\n        return Jsi_MutexLock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    return JSI_OK;\n}\n\n#ifdef JSI_USE_MANY_STRKEY\nstatic Jsi_RC KeyLockerTree(Jsi_Tree* tree, int lock) { return KeyLocker((Jsi_Hash*)tree, lock); }\n#endif\n\nstatic int jsi_deleted = 0, jsi_exitCode = 0; // TODO: move to jsiIntData\nstatic Jsi_Value *jsi_vf = NULL;\n\nstatic Jsi_RC jsi_InterpDelete(Jsi_Interp *interp, void *ptr) {\n    if (jsi_vf)\n        Jsi_DecrRefCount(interp, jsi_vf);\n    jsi_vf = NULL;\n    jsi_exitCode = interp->exitCode;\n    jsi_deleted = 1;\n    return JSI_OK;\n}\n\nJsi_Interp* Jsi_Main(Jsi_InterpOpts *opts)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_Interp* interp = NULL;\n    int argc = 0, first = 1;\n    char **argv = NULL;\n    if (opts) {\n        interp = opts->interp;\n        argc = opts->argc;\n        argv = opts->argv;\n    }\n    if (!interp)\n        interp = Jsi_InterpNew(opts);\n    if (!interp)\n        return NULL;\n    Jsi_InterpOnDelete(interp, &jsi_InterpDelete, (void*)&jsi_InterpDelete);\n    argc -= interp->iskips;\n    argv += interp->iskips;\n\n#ifndef NO_JAZ\n    /* Mount zip at end of executable */\n    Jsi_Value *v = Jsi_Executable(interp);\n    const char *exeFile = (v?Jsi_ValueString(interp, v, NULL):NULL);\n    int jsFound = 0;\n    if (v && (argc != 2 || Jsi_Strcmp(argv[1], \"--nozvfs\"))) {\n        rc = Jsi_EvalZip(interp, exeFile, JSI_ZVFS_DIR, &jsFound);\n        if (rc == JSI_OK) {\n            interp->selfZvfs = 1;\n            if (!jsFound) {\n#if (JSI__FILESYS && JSI__ZVFS)\n                fprintf(stderr, \"warning: no main.jsi or autoload.jsi\\n\");\n#endif\n            }\n            if (jsi_deleted)\n                return jsi_DoExit(interp, jsi_exitCode);\n            else if (rc != 0) {\n                fprintf(stderr, \"Error\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        }\n    }\n#endif\n    const char *ext = NULL, *ai1, *iext = (argc<=1?NULL:Jsi_Strrchr(argv[1], '.'));\n    if (interp->selfZvfs && iext && Jsi_Strcmp(iext,\".fossil\")==0) {\n        rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n        goto done;\n    }\n    Jsi_ShiftArgs(interp, NULL);\n    if (argc <= 1) {\n        if (interp->opts.no_interactive && !interp->interactive)\n            return interp;\n        rc = Jsi_Interactive(interp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n        goto done;\n    }\n    ai1 = argv[1];\n    if ((!Jsi_Strcmp(ai1, \"-help\") || !Jsi_Strcmp(ai1, \"-h\")) && argc<=3) {\n        if (argc>2) {\n            if (Jsi_PkgRequire(interp, \"Help\", 0)>=0) {\n                char tbuf[BUFSIZ];\n                snprintf(tbuf, sizeof(tbuf), \"return runModule('Help', '%s'.trim().split(null));\", argv[2]);\n                Jsi_RC rc = Jsi_EvalString(interp, tbuf, 0);\n                const char *hstr = Jsi_ValueToString(interp, interp->retValue, NULL);\n                if (rc == JSI_OK)\n                    puts(hstr);\n                return jsi_DoExit(interp, 1);\n            }\n        }\n        dohelp:\n        puts(\"USAGE:\\n  jsish [PREFIX-OPTS] [COMMAND-OPTS|FILE] ...\\n\"\n          \"\\nPREFIX-OPTS:\\n\"\n          \"  --C FILE\\tOption file of config options.\\n\"\n          \"  --F\\t\\tTrace all function calls and returns.\\n\"\n          \"  --I OPT:VAL\\tInterp option: equivalent to Interp.conf({OPT:VAL}).\\n\"\n          \"  --L PATH\\tSet safeMode to \\\"lockdown\\\" using PATH for safe(Read/Write)Dirs.\\n\"\n          \"  --T OPT\\tTypecheck option: equivalent to \\\"use OPT\\\".\\n\"\n          \"  --U\\t\\tDisplay unittest output, minus pass/fail compare.\\n\"\n          \"  --V\\t\\tSame as --U, but adds file and line number to output.\\n\"\n          \"\\nCOMMAND-OPTS:\\n\"\n          \"  -a\\t\\tArchive: mount an archive (zip, sqlar or fossil repo) and run module.\\n\"\n          \"  -c\\t\\tCData: generate .c or JSON output from a .jsc description.\\n\"\n          \"  -d\\t\\tDebug: console script debugger.\\n\"\n          \"  -e CODE ...\\tEvaluate javascript CODE.\\n\"\n          \"  -g\\t\\tGendeep: generate html output from markdeep source.\\n\"\n          \"  -h ?CMD?\\tHelp: show help for jsish or its commands.\\n\"\n          \"  -m\\t\\tModule: utility create/manage/invoke a Module.\\n\"\n          \"  -s\\t\\tSafe: runs script in safe sub-interp.\\n\"\n          \"  -u\\t\\tUnitTest: test script file(s) or directories .js/.jsi files.\\n\"\n          \"  -w\\t\\tWget: web client to download file from url.\\n\"\n          \"  -v\\t\\tVersion: show version detail: add an arg to show only X.Y.Z\\n\"\n          \"  -z\\t\\tZip: append/manage zip files at end of executable.\\n\"\n          \"  -D\\t\\tDebugUI: web-gui script debugger.\\n\"\n          \"  -J\\t\\tJSpp: preprocess javascript for web.\\n\"\n          \"  -S\\t\\tSqliteUI: web-gui for sqlite database file.\\n\"\n          \"  -W\\t\\tWebsrv: web server to serve out content.\\n\"\n          \"\\nInterp options may also be set via the confFile.'\\n\"\n           );\n        return jsi_DoExit(interp, 1);\n    }\n    if (!Jsi_Strcmp(ai1, \"-version\"))\n        ai1 = \"-v\";\n    if (ai1[0] == '-') {\n        switch (ai1[1]) {\n            case 'a':\n                rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'c':\n                rc = Jsi_EvalString(interp, \"runModule('Cdata');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'd':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('Debug');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'D':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('DebugUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'e':\n                if (argc < 3)\n                    rc = Jsi_LogError(\"missing argument\");\n                else {\n                    rc = Jsi_EvalString(interp, argv[2], JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n                    if (rc == JSI_OK && argc>3) {\n                        first += 2;\n                        Jsi_ShiftArgs(interp, NULL);\n                        Jsi_ShiftArgs(interp, NULL);\n                        goto dofile;\n                    }\n                }\n                break;\n            case 'g':\n                rc = Jsi_EvalString(interp, \"runModule('GenDeep');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'h':\n                goto dohelp;\n            case 'J':\n                rc = Jsi_EvalString(interp, \"runModule('Jspp');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'm':\n                if (argc <= 2 || argv[2][0] == '-')\n                    rc = Jsi_EvalString(interp, \"runModule('Module');\", JSI_EVAL_ISMAIN);\n                else {\n                    Jsi_DString dStr = {}, eStr = {};\n                    const char *cps, *cpe;\n                    cps = Jsi_Strrchr(argv[2], '/');\n                    if (cps) cps++; else cps = argv[2];\n                    cpe = Jsi_Strrchr(cps, '.');\n                    int len = (cpe?cpe-cps:(int)Jsi_Strlen(cps));\n                    if (cpe)\n                        Jsi_DSPrintf(&dStr, \"source(\\\"%s\\\");\", argv[2]);\n                    else\n                        Jsi_DSPrintf(&dStr, \"require(\\\"%s\\\");\", argv[2]);\n                    Jsi_DSPrintf(&dStr, \"puts(runModule(\\\"%.*s\\\",console.args.slice(1)));\", len, cps);\n                    rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_NOSKIPBANG);\n                    Jsi_DSFree(&dStr);\n                    Jsi_DSFree(&eStr);\n                }\n                break;\n            case 's':\n                rc = Jsi_EvalString(interp, \"runModule('Safe');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'S':\n                rc = Jsi_EvalString(interp, \"runModule('SqliteUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'u':\n                rc = Jsi_EvalString(interp, \"exit(runModule('UnitTest'));\", JSI_EVAL_ISMAIN);\n                break;\n            case 'v': {\n                char str[200] = \"\\n\";\n                    \n                Jsi_Value* fval = Jsi_ValueNewStringKey(interp, \"/zvfs/lib/sourceid.txt\");\n                if (!Jsi_Access(interp, fval, R_OK)) {\n                    Jsi_Channel chan = Jsi_Open(interp, fval, \"r\");\n                    if (chan)\n                        Jsi_Read(interp, chan, str, sizeof(str));\n                }\n                if (argc>2)\n                    printf(\"%u.%u.%u\\n\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);\n                else \n                    printf(\"%u.%u.%u %.\" JSI_VERFMT_LEN JSI_NUMGFMT \" %s\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE, Jsi_Version(), str);\n                return jsi_DoExit(interp, 1);\n            }\n            case 'w':\n                rc = Jsi_EvalString(interp, \"runModule('Wget');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'W':\n                rc = Jsi_EvalString(interp, \"runModule('Websrv');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'z':\n                rc = Jsi_EvalString(interp, \"runModule('Zip');\", JSI_EVAL_ISMAIN);\n                break;\n            default:\n                puts(\"usage: jsish [  --C FILE | --I OPT:VAL | --L PATH | --T OPT | --U | --V | --F ] | -e STRING |\\n\\t\"\n                \"| -a | -c | -d | -D | -h | -m | -s | -S | -u | -v | -w | -W | -z | FILE ...\\nUse -help for long help.\");\n                return jsi_DoExit(interp, 1);\n        }\n    } else {\ndofile:\n        ext = Jsi_Strrchr(argv[first], '.');\n\n        /* Support running \"main.jsi\" from a zip file. */\n        if (ext && (Jsi_Strcmp(ext,\".zip\")==0 ||Jsi_Strcmp(ext,\".jsz\")==0 ) ) {\n            rc = Jsi_EvalZip(interp, argv[first], NULL, &jsFound);\n            if (rc<0) {\n                fprintf(stderr, \"zip mount failed\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n            if (!(jsFound&JSI_ZIP_MAIN)) {\n                fprintf(stderr, \"main.jsi not found\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        } else if (ext && !Jsi_Strcmp(ext,\".jsc\")) {\n            Jsi_DString dStr = {};\n            Jsi_DSPrintf(&dStr, \"console.args.unshift('%s'); runModule('CData');\", argv[first]);\n            rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n            Jsi_DSFree(&dStr);\n\n        } else {\n            if (argc>1) {\n                jsi_vf = Jsi_ValueNewStringKey(interp, argv[first]);\n                Jsi_IncrRefCount(interp, jsi_vf);\n            }\n            rc = Jsi_EvalFile(interp, jsi_vf, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX|JSI_EVAL_ISMAIN);\n            if (jsi_vf) {\n                Jsi_DecrRefCount(interp, jsi_vf);\n                jsi_vf = NULL;\n            }\n\n        }\n    }\n    if (jsi_deleted) //TODO: rationalize jsi_deleted, jsi_exitCode, etc\n        return jsi_DoExit(rc==JSI_EXIT?NULL:interp, jsi_exitCode);\n    if (rc == JSI_OK) {\n        /* Skip output from an ending semicolon which evaluates to undefined */\n        Jsi_Value *ret = Jsi_ReturnValue(interp);\n        if (!Jsi_ValueIsType(interp, ret, JSI_VT_UNDEF)) {\n            Jsi_DString dStr = {};\n            fputs(Jsi_ValueGetDString(interp, ret, &dStr, 0), stdout);\n            Jsi_DSFree(&dStr);\n            fputs(\"\\n\", stdout);\n        }\n    } else {\n        if (!interp->parent && !interp->isHelp)\n            fprintf(stderr, \"ERROR: %s\\n\", interp->errMsgBuf);\n        return jsi_DoExit(interp, 1);\n    }\n\ndone:\n    if (rc == JSI_EXIT) {\n        if (opts)\n            opts->exitCode = jsi_exitCode;\n        return NULL;\n    }\n    if (jsi_deleted == 0 && interp->opts.auto_delete) {\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    return interp;\n}\n\nbool jsi_ModBlacklisted(Jsi_Interp *interp, const char *mod) {\n    if (!interp->subOpts.blacklist) return false;\n    const char *blstr =Jsi_Strstr(interp->subOpts.blacklist, mod);\n    if (!blstr) return false;\n    if ((blstr==interp->subOpts.blacklist || !isalnum(blstr[-1])) && !isalnum(blstr[Jsi_Strlen(mod)]))\n        return false;\n    return true;\n}\n\n// Get control during script evaluation to support debugging.\nstatic Jsi_RC jsi_InterpDebugHook(struct Jsi_Interp* interp, const char *curFile,\n    int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *emsg)\n{\n    // TODO: when code is run in debugger, parser.y should attribute op for case stmt to skip str compares, etc.\n    int isfun=0;\n    if (interp->isInCallback || curLine<=0)\n        return JSI_OK;\n    if (op && op->nodebug)\n        return JSI_OK;\n    int isbp = 0, bpId = 0, cont = interp->debugOpts.doContinue,\n        stop = (interp->debugOpts.noFilter || interp->debugOpts.forceBreak);\n    if (!curFunc)\n        curFunc = \"\";\n\n    if (interp->parent && interp->parent->sigmask) {\n        interp->parent->sigmask = 0;\n        opCode = \"SIGINT\";\n\n    } else if (Jsi_Strcmp(opCode, \"DEBUG\") || !interp->parent) {\n\n        // Avoid overhead of multiple ops on same line of code.\n        int sameLine = (interp->debugOpts.lastLine == curLine && interp->debugOpts.lastLevel == curLevel\n            && interp->debugOpts.lastFile == curFile);\n\n        if (sameLine && stop==0 && (interp->debugOpts.bpLast==0\n            || (interp->debugOpts.bpOpCnt+10) >= interp->opCnt)) //TODO: need better way to detect bp dups.\n            goto done;\n\n        if (!interp->debugOpts.debugCallback || !interp->parent) {\n            fprintf(stderr, \"FILE %s:%d (%d) %s %s\\n\", curFile, curLine, curLevel, curFunc, opCode);\n            return JSI_OK;\n        }\n\n        // Check for breakpoints.\n        if (interp->breakpointHash) {\n            Jsi_HashEntry *hPtr;\n            Jsi_HashSearch search;\n            for (hPtr = Jsi_HashSearchFirst(interp->breakpointHash, &search);\n                hPtr != NULL && stop == 0; hPtr = Jsi_HashSearchNext(&search)) {\n                jsi_BreakPoint* bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n                if (bptr == NULL || bptr->enabled == 0) continue;\n                if (bptr->func)\n                    stop = (!Jsi_Strcmp(bptr->func, curFunc));\n                else\n                    stop = (bptr->line == curLine && !Jsi_Strcmp(bptr->file, curFile));\n                if (stop) {\n                    isbp = 1;\n                    bpId = bptr->id;\n                    bptr->hits++;\n                    if (bptr->temp)\n                        bptr->enabled = 0;\n                }\n            }\n        }\n\n        if (stop == 0) { // No breakpoint.\n            if (cont  // Cmd is \"continue\"\n                // Handle \"next\" by skipping calls into functions.\n                || (interp->debugOpts.minLevel>0 && curLevel>interp->debugOpts.minLevel)\n                || (isfun=(Jsi_Strcmp(opCode, \"PUSHVAR\")==0 && op[1].op == OP_PUSHFUN)))\n            {\n                if (isfun) {\n                    interp->debugOpts.lastLine = curLine;\n                    interp->debugOpts.lastLevel = curLevel;\n                    interp->debugOpts.lastFile = curFile;\n                }\ndone:\n                return JSI_OK;\n            }\n        }\n    }\n    interp->debugOpts.bpLast = isbp;\n    interp->debugOpts.bpOpCnt = interp->opCnt;\n    interp->debugOpts.lastLine = curLine;\n    interp->debugOpts.lastLevel = curLevel;\n    interp->debugOpts.lastFile = curFile;\n    interp->debugOpts.forceBreak = 0;\n\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    if (emsg && Jsi_Strchr(emsg,'\\\"'))\n        emsg = 0;\n    Jsi_DSPrintf(&dStr, \"[\\\"%s\\\", %d, %d, \\\"%s\\\", \\\"%s\\\", %d, \\\"%s\\\"]\", curFile?curFile:\"\", curLine, curLevel, curFunc, opCode, bpId, emsg?emsg:\"\");\n    interp->isInCallback = 1;\n    Jsi_RC rc = JSI_ERROR;\n    if (interp->debugOpts.debugCallback)\n        rc = Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.debugCallback, Jsi_DSValue(&dStr), &interp->retValue);\n    interp->isInCallback = 0;\n    if (interp->parent->exited == 0 && rc != JSI_OK)\n        Jsi_LogError(\"debugger failure\");\n    return rc;\n}\n\nJsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str) {\n    uint *iptr = (uint*)&interp->typeCheck;\n    const char *wcp = str, *wcn = wcp;\n    while (wcn && wcp) {\n        int isnot = 0;\n        if (*wcp == '!') { isnot = 1; wcp++; }\n        wcn = Jsi_Strchr(wcp, ',');\n        int ti, wlen = (wcn?(wcn-wcp):(int)Jsi_Strlen(wcp));\n#define _JSIPARSETYPES(nam, field) \\\n        if (wlen == (sizeof(#nam)-1) && !Jsi_Strncmp(#nam, wcp, (sizeof(#nam)-1))) { \\\n            interp->field = (1-isnot); \\\n            wcp = (wcn?wcn+1:NULL); \\\n            continue; \\\n        }\n        _JSIPARSETYPES(Debug, logOpts.Debug)\n        _JSIPARSETYPES(Trace, logOpts.Trace)\n        _JSIPARSETYPES(Test,  logOpts.Test)\n        _JSIPARSETYPES(Info, logOpts.Info)\n        _JSIPARSETYPES(Warn, logOpts.Warn)\n        _JSIPARSETYPES(Error,  logOpts.Error)\n        _JSIPARSETYPES(full,  logOpts.full)\n        _JSIPARSETYPES(before,  logOpts.before)\n        _JSIPARSETYPES(time,  logOpts.time)\n        _JSIPARSETYPES(date,  logOpts.date)\n        _JSIPARSETYPES(asserts, asserts)\n        _JSIPARSETYPES(assert, asserts)\n        _JSIPARSETYPES(noproto, subOpts.noproto)\n\n        const char **tstrs = jsi_TypeChkStrs;\n        for (ti=0; tstrs[ti]; ti++) {\n            wlen = Jsi_Strlen(tstrs[ti]);\n            if (!Jsi_Strncmp(tstrs[ti], wcp, wlen) && (!tstrs[ti][wlen] || tstrs[ti][wlen] == ',')) break;\n        }\n        if (tstrs[ti]) {\n            if (isnot)\n                *iptr &= ~(1<<ti);\n            else {\n                *iptr |= (1<<ti);\n                if (!Jsi_Strcmp(tstrs[ti], \"all\"))\n                    interp->typeCheck.parse = interp->typeCheck.run = 1;\n                if (!Jsi_Strcmp(tstrs[ti], \"strict\")) {\n                    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n                    if (interp->framePtr->level<=0 || interp->isMain)\n                        interp->strict = 1;\n                }\n            }\n        } else {\n            Jsi_DString wStr = {};\n            int i;\n            tstrs = jsi_TypeChkStrs;\n            for (i=0; tstrs[i]; i++) Jsi_DSAppend(&wStr, i?\", \":\"\", tstrs[i], NULL);\n            Jsi_LogWarn(\"unknown typeCheck warn option(s) \\\"%s\\\" not in: Debug, Trace, Test, Info, Warn, Error, assert, %s, noproto, full, before, time, date\", str, Jsi_DSValue(&wStr));\n            Jsi_DSFree(&wStr);\n        }\n        wcp = (wcn?wcn+1:NULL);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_Interp* jsi_InterpNew(Jsi_Interp *parent, Jsi_Value *opts, Jsi_InterpOpts *iopts)\n{\n    Jsi_Interp* interp;\n    if (parent && parent->noSubInterps) {\n        interp = parent;\n        Jsi_LogError(\"subinterps disallowed\");\n        return NULL;\n    }\n    if (opts && parent && (Jsi_ValueIsObjType(parent, opts, JSI_OT_OBJECT)==0 ||\n        Jsi_TreeSize(opts->d.obj->tree)<=0))\n        opts = NULL;\n    interp = (Jsi_Interp *)Jsi_Calloc(1,sizeof(*interp) + sizeof(jsi_Frame));\n    interp->framePtr = (jsi_Frame*)(((uchar*)interp)+sizeof(*interp));\n    if (!parent)\n        interp->maxInterpDepth = JSI_MAX_SUBINTERP_DEPTH;\n    else {\n        interp->maxInterpDepth = parent->maxInterpDepth;\n        interp->interpDepth = parent->interpDepth+1;\n        if (interp->interpDepth > interp->maxInterpDepth) {\n            Jsi_Free(interp);\n            interp = parent;\n            Jsi_LogError(\"exceeded max subinterp depth\");\n            return NULL;\n        }\n    }\n    interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n    interp->maxIncDepth = JSI_MAX_INCLUDE_DEPTH;\n    interp->typeWarnMax = 50;\n    interp->subOpts.dblPrec = __DBL_DECIMAL_DIG__-1;\n    interp->subOpts.prompt = \"$ \";\n    interp->subOpts.prompt2 = \"> \";\n\n    int iocnt;\n    if (iopts) {\n        iopts->interp = interp;\n        interp->opts = *iopts;\n    }\n    interp->logOpts.file = 1;\n    interp->logOpts.func = 1;\n    interp->logOpts.Info = 1;\n    interp->logOpts.Warn = 1;\n    interp->logOpts.Error = 1;\n    int argc = interp->opts.argc;\n    char **argv = interp->opts.argv;\n    char *argv0 = (argv?argv[0]:NULL);\n    interp->parent = parent;\n    interp->topInterp = (parent == NULL ? interp: parent->topInterp);\n    if (jsiIntData.mainInterp == NULL)\n        jsiIntData.mainInterp = interp->topInterp;\n    interp->mainInterp = jsiIntData.mainInterp; // The first interps handles exit.\n    interp->memDebug = interp->opts.mem_debug;\n    if (parent) {\n        interp->dbPtr = parent->dbPtr;\n    } else {\n        interp->dbPtr = &interp->dbStatic;\n    }\n#ifdef JSI_MEM_DEBUG\n    if (!interp->dbPtr->valueDebugTbl) {\n        interp->dbPtr->valueDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n        interp->dbPtr->objDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n    }\n#endif\n    if (parent) {\n        if (parent->pkgDirs)\n            interp->pkgDirs = Jsi_ValueDupJSON(interp, parent->pkgDirs);\n    } else {\n#ifdef JSI_PKG_DIRS\n        interp->pkgDirs = Jsi_StringSplit(interp, JSI_PKG_DIRS, \",\");\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n#endif\n    }\n#ifdef JSI_USE_COMPAT\n    interp->compat = JSI_USE_COMPAT;\n#endif\n#ifndef JSI_CONF_ARGS\n#define JSI_CONF_ARGS \"\"\n#endif\n    interp->confArgs = JSI_CONF_ARGS;\n    for (iocnt = 1; (iocnt+1)<argc; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--T\") == 0 || Jsi_Strcmp(aio, \"--C\") == 0 || Jsi_Strcmp(aio, \"--L\") == 0) {\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--F\") == 0 || Jsi_Strcmp(aio, \"--U\") == 0 || Jsi_Strcmp(aio, \"--V\") == 0) {\n            iocnt--;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\")) {\n            const char *aio2 = argv[iocnt+1];\n            if (!Jsi_Strncmp(\"memDebug:\", aio2, sizeof(\"memDebug\")))\n                interp->memDebug=strtol(aio2+sizeof(\"memDebug\"), NULL, 0);\n            else if (!Jsi_Strncmp(\"compat\", aio2, sizeof(\"compat\")))\n                interp->subOpts.compat=strtol(aio2+sizeof(\"compat\"), NULL, 0);\n            continue;\n        }\n        break;\n    }\n    SIGINIT(interp,INTERP);\n    interp->NullValue = Jsi_ValueNewNull(interp);\n    Jsi_IncrRefCount(interp, interp->NullValue);\n#ifdef __WIN32\n    Jsi_DString cwdStr;\n    Jsi_DSInit(&cwdStr);\n    interp->curDir = Jsi_Strdup(Jsi_GetCwd(interp, &cwdStr));\n    Jsi_DSFree(&cwdStr);\n#else\n    char buf[JSI_BUFSIZ];\n    interp->curDir = getcwd(buf, sizeof(buf));\n    interp->curDir = Jsi_Strdup(interp->curDir?interp->curDir:\".\");\n#endif\n    interp->onDeleteTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeOnDeleteTbl);\n    interp->assocTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeAssocTbl);\n    interp->cmdSpecTbl = Jsi_MapNew(interp, JSI_MAP_TREE, JSI_KEYS_STRING, freeCmdSpecTbl);\n    interp->eventTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeEventTbl);\n    interp->fileTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    interp->funcObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncObjTbl);\n    interp->funcsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncsTbl);\n    interp->bindTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeBindObjTbl);\n    interp->protoTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL/*freeValueTbl*/);\n    interp->regexpTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, regExpFree);\n    interp->preserveTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_HashFree);\n    interp->loadTbl = (parent?parent->loadTbl:Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_FreeOneLoadHandle));\n    interp->packageHash = Jsi_HashNew(interp, JSI_KEYS_STRING, packageHashFree);\n    interp->aliasHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_AliasFree);\n\n    interp->lockTimeout = -1;\n#ifdef JSI_LOCK_TIMEOUT\n    interp->lockTimeout JSI_LOCK_TIMEOUT;\n#endif\n#ifndef JSI_DO_UNLOCK\n#define JSI_DO_UNLOCK 1\n#endif\n    interp->subOpts.mutexUnlock = JSI_DO_UNLOCK;\n    Jsi_Map_Type mapType = JSI_MAP_HASH;\n#ifdef JSI_USE_MANY_STRKEY\n    mapType = JSI_MAP_TREE;\n#endif\n\n    if (interp == jsiIntData.mainInterp || interp->threadId != jsiIntData.mainInterp->threadId) {\n        interp->strKeyTbl = Jsi_MapNew(interp,  mapType, JSI_KEYS_STRING, NULL);\n        interp->subOpts.privKeys = 1;\n    }\n    // Handle interp options: -T value and -Ixxx value\n    for (iocnt = 1; (iocnt+1)<argc && !interp->parent; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--F\") == 0) {\n            interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--U\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--V\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 5;\n            interp->tracePuts = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--C\") == 0) {\n            if (interp->confFile)\n               Jsi_LogWarn(\"overriding confFile: %s\", interp->confFile);\n            interp->confFile = argv[iocnt+1];\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--L\") == 0) {\n            struct stat sb;\n            const char* path = argv[iocnt+1]; //TODO: convert to Jsi_Value first?\n            if (!path || stat(path, &sb)\n                || !((S_ISREG(sb.st_mode) && !access(path, W_OK)) || (S_ISDIR(sb.st_mode) && !access(path, X_OK)))) {\n                Jsi_LogError(\"Lockdown path must exist and be a writable file or executable dir: %s\", path);\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->isSafe = true;\n            interp->safeMode = jsi_safe_Lockdown;\n            if (interp->safeWriteDirs) {\n                Jsi_LogWarn(\"Overriding safeWriteDirs\");\n                Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            }\n            const char *vda[2] = {};\n            char npath[PATH_MAX];\n            vda[0] = Jsi_FileRealpathStr(interp, path, npath);\n            interp->safeWriteDirs = Jsi_ValueNewArray(interp, vda, 1);\n            Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n            if (!interp->safeReadDirs) {\n                interp->safeReadDirs = interp->safeWriteDirs;\n                Jsi_IncrRefCount(interp, interp->safeReadDirs);\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--T\") == 0) {\n            if (jsi_ParseTypeCheckStr(interp, argv[iocnt+1]) != JSI_OK) {\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\"))  {\n            bool bv = 1;\n            char *aio2 = argv[iocnt+1], *aioc = Jsi_Strchr(aio2, ':'),\n                argNamS[50], *argNam = aio2;\n            const char *argVal;\n            if (!Jsi_Strcmp(\"traceCall\", aio2))\n                interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            else {\n                if (aioc) {\n                    argNam = argNamS;\n                    argVal = aioc+1;\n                    snprintf(argNamS, sizeof(argNamS), \"%.*s\", (int)(aioc-aio2), aio2);\n                }\n                \n                DECL_VALINIT(argV);\n                Jsi_Value *argValue = &argV;\n                Jsi_Number dv;\n                if (!aioc || Jsi_GetBool(interp, argVal, &bv) == JSI_OK) {\n                    Jsi_ValueMakeBool(interp, &argValue, bv);\n                } else if (!Jsi_Strcmp(\"null\", argVal)) {\n                    Jsi_ValueMakeNull(interp, &argValue);\n                } else if (Jsi_GetDouble(interp, argVal, &dv) == JSI_OK) {\n                    Jsi_ValueMakeNumber(interp, &argValue, dv);\n                } else {\n                    Jsi_ValueMakeStringKey(interp, &argValue, argVal);\n                }\n                if (JSI_OK != Jsi_OptionsSet(interp, InterpOptions, interp, argNam, argValue, 0)) {\n                    Jsi_InterpDelete(interp);\n                    return NULL;\n                }\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        break;\n    }\n    if (!interp->strKeyTbl)\n        interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n    if (opts) {\n        interp->inopts = opts = Jsi_ValueDupJSON(interp, opts);\n        if (Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0) {\n            Jsi_DecrRefCount(interp, opts);\n            interp->inopts = NULL;\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n    }\n    if (interp == jsiIntData.mainInterp) {\n        interp->subthread = 0;\n    } else {\n        if (opts) {\n            if (interp->subOpts.privKeys && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl) {\n                //Jsi_HashDelete(interp->strKeyTbl);\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                interp->strKeyTbl = Jsi_MapNew(interp, mapType, JSI_KEYS_STRING, NULL);\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            } else if (interp->subOpts.privKeys == 0 && interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl) {\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                Jsi_MapDelete(interp->strKeyTbl);\n                interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            }\n        }\n        if (parent && parent->isSafe) {\n            interp->isSafe = 1;\n            interp->safeMode = parent->safeMode;\n        }\n        if (interp->subthread && interp->isSafe) {\n            interp->subthread = 0;\n            Jsi_LogError(\"threading disallowed in safe mode\");\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n        if (interp->subthread)\n            jsiIntData.mainInterp->threadCnt++;\n        if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n            jsiIntData.mainInterp->threadShrCnt++;\n        if (jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n            jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = KeyLockerTree;\n#else\n            jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = KeyLocker;\n#endif\n    }\n    if (parent && parent->isSafe) {\n        interp->isSafe = 1;\n        interp->safeMode = parent->safeMode;\n        interp->maxOpCnt = parent->maxOpCnt;\n        if (interp->safeWriteDirs || interp->safeReadDirs || interp->safeExecPattern) {\n            Jsi_LogWarn(\"ignoring safe* options in safe sub-sub-interp\");\n            if (interp->safeWriteDirs) Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            if (interp->safeReadDirs) Jsi_DecrRefCount(interp, interp->safeReadDirs);\n            interp->safeWriteDirs = interp->safeReadDirs = NULL;\n            interp->safeExecPattern = NULL;\n        }\n    }\n\n    jsi_InterpConfFiles(interp);\n    if (!interp->udata) {\n        interp->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, interp->udata);\n    }\n    if (interp->subthread && !interp->scriptStr && !interp->scriptFile) {\n        Jsi_LogError(\"subthread interp must be specify either scriptFile or scriptStr\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n#ifndef JSI_MEM_DEBUG\n    static int warnNoDebug = 0;\n    if (interp->memDebug && warnNoDebug == 0) {\n        Jsi_LogWarn(\"ignoring memDebug as jsi was compiled without memory debugging\");\n        warnNoDebug = 1;\n    }\n#endif\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->parent && interp->subthread==0 && interp->threadId != interp->parent->threadId) {\n        interp->threadId = interp->parent->threadId;\n#ifndef JSI_MEM_DEBUG\n        Jsi_LogWarn(\"non-threaded sub-interp created by different thread than parent\");\n#endif\n    }\n    if (interp->safeMode != jsi_safe_None)\n        interp->isSafe = interp->startSafe = 1;\n    if (!interp->parent) {\n        if (interp->isSafe)\n            interp->startSafe = 1;\n        if (interp->debugOpts.msgCallback)\n            Jsi_LogWarn(\"ignoring msgCallback\");\n        if (interp->debugOpts.putsCallback)\n            Jsi_LogWarn(\"ignoring putsCallback\");\n        if (interp->busyCallback)\n            Jsi_LogWarn(\"ignoring busyCallback\");\n        if (interp->debugOpts.traceCallback)\n            Jsi_LogWarn(\"ignoring traceCallback\");\n    } else if (interp->busyCallback && interp->threadId != interp->parent->threadId) {\n        Jsi_LogWarn(\"disabling busyCallback due to threads\");\n        interp->busyCallback = NULL;\n    }\n    if (interp == jsiIntData.mainInterp)\n        interp->lexkeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    else\n        interp->lexkeyTbl = jsiIntData.mainInterp->lexkeyTbl;\n    interp->thisTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeValueTbl);\n    interp->userdataTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeUserdataTbl);\n    interp->varTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->codeTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCodeTbl);\n    interp->genValueTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD,freeValueTbl);\n    interp->genObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeGenObjTbl);\n#ifdef JSI_MEM_DEBUG\n    interp->codesTbl = (interp == jsiIntData.mainInterp ? Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL) : jsiIntData.mainInterp->codesTbl);\n#endif\n    if (interp->typeCheck.all|interp->typeCheck.parse|interp->typeCheck.funcsig)\n        interp->staticFuncsTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->maxArrayList = MAX_ARRAY_LIST;\n    if (!jsiIntData.isInit) {\n        jsiIntData.isInit = 1;\n        jsi_InitValue(interp, 0);\n        jsiIntData.interpsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);\n    }\n\n    /* current scope, also global */\n    interp->csc = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeObject(interp, &interp->csc, Jsi_ObjNew(interp));\n    interp->framePtr->incsc = interp->csc;\n\n#define JSIDOINIT(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n#define JSIDOINIT2(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (Jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n\n    JSIDOINIT(Proto);\n\n    if (interp->pkgDirs) // Fix-up because above, array was not yet initialized.\n        interp->pkgDirs->d.obj->__proto__ = interp->Array_prototype;\n\n    Jsi_Value *modObj = Jsi_ValueNewObj(interp, Jsi_ObjNewType(interp, JSI_OT_OBJECT));\n    Jsi_ValueInsert(interp, interp->csc, \"Jsi_Auto\", modObj, JSI_OM_DONTDEL);\n\n    /* initial scope chain, nothing */\n    interp->framePtr->ingsc = interp->gsc = jsi_ScopeChainNew(interp, 0);\n\n    interp->ps = jsi_PstateNew(interp); /* Default parser. */\n    if (interp->unitTest&2) {\n        interp->logOpts.before = 1;\n        interp->logOpts.full = 1;\n        interp->tracePuts = 1;\n        interp->noStderr = 1;\n    }\n    if (interp->args && argc) {\n        Jsi_LogBug(\"args may not be specified both as options and parameter\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    if (interp->maxDepth>JSI_MAX_EVAL_DEPTH)\n        interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n\n    // Create the args array.\n    if (argc >= 0 && !interp->args) {\n        Jsi_Value *iargs = Jsi_ValueNew1(interp);\n        iargs->f.bits.dontdel = 1;\n        iargs->f.bits.readonly = 1;\n        Jsi_Obj *iobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, &iargs, iobj);\n        int i = 1, ii = (iocnt>1 ? iocnt : 1);\n        int msiz = (argc?argc-iocnt:0);\n        Jsi_ObjArraySizer(interp, iobj, msiz);\n        iobj->arrMaxSize = msiz;\n        iocnt--;\n        iobj->arrCnt = argc-iocnt;\n        for (i = 1; ii < argc; ++ii, i++) {\n            iobj->arr[i-1] = Jsi_ValueNewStringKey(interp, argv[ii]);\n            Jsi_IncrRefCount(interp, iobj->arr[i-1]);\n            jsi_ValueDebugLabel(iobj->arr[i-1], \"InterpCreate\", \"args\");\n        }\n        Jsi_ObjSetLength(interp, iobj, msiz);\n        interp->args = iargs;\n    } else if (interp->parent && interp->args) {\n        // Avoid strings from sneeking in with options from parent...\n        Jsi_Value *nar = Jsi_ValueDupJSON(interp, interp->args);\n        Jsi_DecrRefCount(interp, interp->args);\n        interp->args = nar;\n    }\n    JSIDOINIT(Options);\n    JSIDOINIT(Cmds);\n    JSIDOINIT(Interp);\n    JSIDOINIT(JSON);\n\n    interp->retValue = Jsi_ValueNew1(interp);\n    interp->Mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n    if (1 || interp->subthread) {\n        interp->QMutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_DSInit(&interp->interpEvalQ);\n    }\n    JSIDOINIT(Lexer);\n    if (interp != jsiIntData.mainInterp && !parent)\n        Jsi_HashSet(jsiIntData.interpsTbl, interp, NULL);\n\n    if (!interp->isSafe) {\n        JSIDOINIT(Load);\n#if JSI__SIGNAL==1\n        JSIDOINIT(Signal);\n#endif\n    }\n    if (interp->isSafe == 0 || interp->startSafe || interp->safeWriteDirs!=NULL || interp->safeReadDirs!=NULL) {\n#if JSI__FILESYS==1\n        JSIDOINIT(FileCmds);\n        JSIDOINIT(Filesys);\n#endif\n    }\n#if JSI__SQLITE==1\n    JSIDOINIT2(Sqlite);\n#else\n    Jsi_initSqlite(interp, 0);\n#endif\n#if JSI__MYSQL==1\n    if (!interp->noNetwork) {\n        JSIDOINIT2(MySql);\n    }\n#endif\n#if JSI__SOCKET==1\n    JSIDOINIT2(Socket);\n#endif\n#if JSI__WEBSOCKET==1\n    JSIDOINIT2(WebSocket);\n#endif\n\n#if JSI__CDATA==1\n    JSIDOINIT(CData);\n#endif\n\n#ifdef JSI_USER_EXTENSION\n    extern int JSI_USER_EXTENSION(Jsi_Interp *interp, int release);\n    if (JSI_USER_EXTENSION (interp, 0) != JSI_OK) {\n        fprintf(stderr, \"extension load failed\");\n        return jsi_DoExit(interp, 1);\n    }\n#endif\n    Jsi_PkgProvide(interp, \"Jsi\", JSI_VERSION, NULL);\n    if (argc > 0) {\n        char *ss = argv0;\n        char epath[PATH_MAX] = \"\"; // Path of executable\n#ifdef __WIN32\n\n        if (GetModuleFileName(NULL, epath, sizeof(epath))>0)\n            ss = epath;\n#else\n#ifndef PROC_SELF_DIR\n#define PROC_SELF_DIR \"/proc/self/exe\"\n#endif\n        if (ss && *ss != '/' && readlink(PROC_SELF_DIR, epath, sizeof(epath)) && epath[0])\n            ss = epath;\n#endif\n        Jsi_Value *src = Jsi_ValueNewStringDup(interp, ss);\n        Jsi_IncrRefCount(interp, src);\n        jsiIntData.execName = Jsi_Realpath(interp, src, NULL);\n        Jsi_DecrRefCount(interp, src);\n        if (!jsiIntData.execName) jsiIntData.execName = Jsi_Strdup(\"\");\n        jsiIntData.execValue = Jsi_ValueNewString(interp, jsiIntData.execName, -1);\n        Jsi_IncrRefCount(interp, jsiIntData.execValue);\n        Jsi_HashSet(interp->genValueTbl, jsiIntData.execValue, jsiIntData.execValue);\n    }\n\n    //interp->nocacheOpCodes = 1;\n    if (interp->debugOpts.debugCallback && !interp->debugOpts.hook) {\n        interp->debugOpts.hook = jsi_InterpDebugHook;\n    }\n    interp->startTime = jsi_GetTimestamp();\n#ifdef JSI_INTERP_EXTENSION_CODE // For extending interp from jsi.c\n    JSI_INTERP_EXTENSION_CODE\n#endif\n    if (interp->opts.initProc && (*interp->opts.initProc)(interp, 0) != JSI_OK)\n        Jsi_LogBug(\"Init failure in initProc\");\n\n    return interp;\n}\n\nJsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts)\n{\n    return jsi_InterpNew(NULL, NULL, opts);\n}\n\nbool Jsi_InterpGone( Jsi_Interp* interp)\n{\n    return (interp == NULL || interp->deleting || interp->destroying || interp->exited);\n}\n\nstatic void DeleteAllInterps() { /* Delete toplevel interps. */\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    if (!jsiIntData.interpsTbl)\n        return;\n    for (hPtr = Jsi_HashSearchFirst(jsiIntData.interpsTbl, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {\n        Jsi_Interp *interp = (Jsi_Interp *)Jsi_HashKeyGet(hPtr);\n        Jsi_HashEntryDelete(hPtr);\n        interp->destroying = 1;\n        Jsi_InterpDelete(interp);\n    }\n    Jsi_HashDelete(jsiIntData.interpsTbl);\n    jsiIntData.interpsTbl = NULL;\n    jsiIntData.isInit = 0;\n}\n\n#ifdef JSI_MEM_DEBUG\n\ntypedef enum { MDB_INOBJ=1, MDB_VISITED=2 } jsi_MDB;\n\nvoid jsiFlagDebugValues(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    Jsi_Value *v;\n    int oflags;\n    if (obj->ot != JSI_OT_OBJECT && obj->ot != JSI_OT_ARRAY)\n        return;\n    if (obj->tree) {\n        Jsi_TreeEntry *hPtr;\n        Jsi_TreeSearch srch;\n        for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr;\n            hPtr=Jsi_TreeSearchNext(&srch)) {\n            v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n    if (obj->arr) {\n        uint i;\n        for (i=0; i<obj->arrCnt; i++) {\n            v = obj->arr[i];\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n}\n\nvoid jsi_DebugDumpValues(Jsi_Interp *interp)\n{\n    if (jsiIntData.mainInterp != interp) return;\n    int vdLev = interp->memDebug;\n    int have = (interp->dbPtr->valueDebugTbl->numEntries || interp->dbPtr->objDebugTbl->numEntries);\n    if ((have && vdLev>0) || vdLev>=3) {\n        // First traverse all Object trees/arrays and mark all values contained therein.\n        Jsi_HashSearch search;\n        Jsi_HashEntry *hPtr;\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp!=NULL && vp->sig == JSI_SIG_OBJ) {\n                jsiFlagDebugValues(interp, vp);\n            }\n        }\n        if (interp->dbPtr->valueDebugTbl->numEntries != interp->dbPtr->valueCnt)\n            fprintf(stderr, \"\\n\\nValues table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->valueDebugTbl->numEntries, interp->dbPtr->valueCnt);\n        // Dump unfreed values and objs.\n        int refSum=0, refsum=0;\n        int bcnt[4] = {};\n        if (vdLev>1 && interp->dbPtr->valueDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED VALUES \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->valueDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Value *vp = (Jsi_Value *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_VALUE) {\n                bcnt[0]++;\n                if (vdLev>1)\n                    fprintf(stderr, \"BAD VALUE: %p\\n\", vp);\n            } else {\n                bcnt[1]++;\n                refSum += vp->refCnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->vt==JSI_VT_OBJECT)\n                        snprintf(ebuf, sizeof(ebuf), \" {obj=%p, otype=%s}\", vp->d.obj, Jsi_ObjTypeStr(interp, vp->d.obj));\n                    else if (vp->vt==JSI_VT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \" {num=%s}\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->vt==JSI_VT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \" {bool=%s}\", vp->d.val?\"true\":\"false\");\n                    else if (vp->vt==JSI_VT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \" {string=\\\"%.40s%s\\\"}\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    const char *pfx = \"\";\n                    if (!(vp->VD.flags&MDB_INOBJ))\n                        pfx = \"!\"; // Value is not contained in an object.\n                    fprintf(stderr, \"[%s*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s()%s\\n\", pfx,\n                        vp, vp->refCnt, Jsi_ValueTypeStr(interp, vp), vp->VD.Idx,\n                        (vp->VD.label?vp->VD.label:\"\"), (vp->VD.label2?\":\":\"\"),\n                        (vp->VD.label2?vp->VD.label2:\"\"), vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line, vp->VD.func, ebuf);\n                }\n            }\n        }\n        if (interp->dbPtr->objDebugTbl->numEntries != interp->dbPtr->objCnt)\n            fprintf(stderr, \"\\n\\nObject table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->objDebugTbl->numEntries, interp->dbPtr->objCnt);\n        if (vdLev>1 && interp->dbPtr->objDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED OBJECTS \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_OBJ) {\n                bcnt[2]++;\n                fprintf(stderr, \"BAD OBJ: %p\\n\", vp);\n            } else {\n                bcnt[3]++;\n                refsum += vp->refcnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->ot==JSI_OT_OBJECT) {\n                        if (vp->isarrlist)\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d, array#%d\", (vp->tree?vp->tree->numEntries:0), vp->arrCnt);\n                        else\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d\", (vp->tree?vp->tree->numEntries:0));\n                    } else if (vp->ot==JSI_OT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \"num=%s\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->ot==JSI_OT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \"bool=%s\", vp->d.val?\"true\":\"false\");\n                    else if (vp->ot==JSI_OT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \"string=\\\"%.40s%s\\\"\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    fprintf(stderr, \"[*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s() {%s}\\n\",\n                        vp, vp->refcnt, Jsi_ObjTypeStr(interp, vp), vp->VD.Idx, vp->VD.label?vp->VD.label:\"\",\n                        vp->VD.label2?\":\":\"\",vp->VD.label2?vp->VD.label2:\"\", vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line,\n                        vp->VD.func, ebuf);\n                }\n            }\n        }\n        fprintf(stderr, \"\\nVALUES: bad=%d,unfreed=%d,allocs=%d,refsum=%d  | OBJECTS: bad=%d,unfreed=%d,allocs=%d,refsum=%d  interp=%p\\n\",\n            bcnt[0], bcnt[1], interp->dbPtr->valueAllocCnt, refSum, bcnt[2], bcnt[3], interp->dbPtr->objAllocCnt, refsum, interp);\n\n        if (interp->codesTbl)\n            for (hPtr = Jsi_HashSearchFirst(interp->codesTbl, &search);\n                hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                Jsi_OpCodes *vp = (Jsi_OpCodes *)Jsi_HashKeyGet(hPtr);\n                fprintf(stderr, \"unfreed opcodes: %d\\n\", vp->id);\n            }\n    }\n    Jsi_HashDelete(interp->dbPtr->valueDebugTbl);\n    Jsi_HashDelete(interp->dbPtr->objDebugTbl);\n    Jsi_HashDelete(interp->codesTbl);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    if (isMainInt && vdLev>3)\n        _exit(1); // Avoid sanitize output.\n}\n#endif\n\nstatic Jsi_RC jsiInterpDelete(Jsi_Interp* interp, void *unused)\n{\n    SIGASSERT(interp,INTERP);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    int mainFlag = (isMainInt ? 2 : 1);\n    if (isMainInt)\n        DeleteAllInterps();\n    if (interp->opts.initProc)\n        (*interp->opts.initProc)(interp, mainFlag);\n    jsiIntData.delInterp = interp;\n    if (interp->gsc) jsi_ScopeChainFree(interp, interp->gsc);\n    if (interp->csc) Jsi_DecrRefCount(interp, interp->csc);\n    if (interp->ps) jsi_PstateFree(interp->ps);\n    int i;\n    for (i=0; i<interp->maxStack; i++) {\n        if (interp->Stack[i]) Jsi_DecrRefCount(interp, interp->Stack[i]);\n        if (interp->Obj_this[i]) Jsi_DecrRefCount(interp, interp->Obj_this[i]);\n    }\n    if (interp->Stack) {\n        Jsi_Free(interp->Stack);\n        Jsi_Free(interp->Obj_this);\n    }\n\n    if (interp->argv0)\n        Jsi_DecrRefCount(interp, interp->argv0);\n    if (interp->console)\n        Jsi_DecrRefCount(interp, interp->console);\n    if (interp->lastSubscriptFail)\n        Jsi_DecrRefCount(interp, interp->lastSubscriptFail);\n    if (interp->nullFuncRet)\n        Jsi_DecrRefCount(interp, interp->nullFuncRet);\n    Jsi_HashDelete(interp->codeTbl);\n    Jsi_MapDelete(interp->cmdSpecTbl);\n    Jsi_HashDelete(interp->fileTbl);\n    Jsi_HashDelete(interp->funcObjTbl);\n    Jsi_HashDelete(interp->funcsTbl);\n    if (interp->profileCnt) { // TODO: resolve some values from dbPtr, others not.\n        double endTime = jsi_GetTimestamp();\n        double coverage = (int)(100.0*interp->coverHit/interp->coverAll);\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DSPrintf(&dStr, \"PROFILE: TOTAL: time=%.6f, func=%.6f, cmd=%.6f, #funcs=%d, #cmds=%d, cover=%2.1f%%, #values=%d, #objs=%d %s%s\\n\",\n            endTime-interp->startTime, interp->funcSelfTime, interp->cmdSelfTime, interp->funcCallCnt, interp->cmdCallCnt,\n            coverage, interp->dbPtr->valueAllocCnt,  interp->dbPtr->objAllocCnt,\n            interp->parent?\" ::\":\"\", (interp->parent&&interp->name?interp->name:\"\"));\n        Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&dStr), -1);\n        Jsi_DSFree(&dStr);\n    }\n    if (isMainInt)\n        Jsi_HashDelete(interp->lexkeyTbl);\n    Jsi_HashDelete(interp->protoTbl);\n    if (interp->subthread)\n        jsiIntData.mainInterp->threadCnt--;\n    if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n        jsiIntData.mainInterp->threadShrCnt--;\n    if (!jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n        jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = NULL;\n#else\n        jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = NULL;\n#endif\n    //Jsi_ValueMakeUndef(interp, &interp->ret);\n    Jsi_HashDelete(interp->thisTbl);\n    Jsi_HashDelete(interp->varTbl);\n    Jsi_HashDelete(interp->genValueTbl);\n    Jsi_HashDelete(interp->genObjTbl);\n    Jsi_HashDelete(interp->aliasHash);\n    if (interp->staticFuncsTbl)\n        Jsi_HashDelete(interp->staticFuncsTbl);\n    if (interp->breakpointHash)\n        Jsi_HashDelete(interp->breakpointHash);\n    if (interp->preserveTbl->numEntries!=0)\n        Jsi_LogBug(\"Preserves unbalanced\");\n    Jsi_HashDelete(interp->preserveTbl);\n    if (interp->curDir)\n        Jsi_Free(interp->curDir);\n    if (isMainInt) {\n        jsi_InitFilesys(interp, mainFlag);\n    }\n#ifndef JSI_OMIT_VFS\n    jsi_InitVfs(interp, 1);\n#endif\n#ifndef JSI_OMIT_CDATA\n        jsi_InitCData(interp, mainFlag);\n#endif\n#if JSI__MYSQL==1\n        Jsi_InitMySql(interp, mainFlag);\n#endif\n    while (interp->interpStrEvents) {\n        InterpStrEvent *se = interp->interpStrEvents;\n        interp->interpStrEvents = se->next;\n        if (se->acfunc)\n            Jsi_DecrRefCount(interp, se->acfunc);\n        if (se->acdata)\n            Jsi_Free(se->acdata);\n        Jsi_Free(se);\n    }\n\n    if (interp->Mutex)\n        Jsi_MutexDelete(interp, interp->Mutex);\n    if (interp->QMutex) {\n        Jsi_MutexDelete(interp, interp->QMutex);\n        Jsi_DSFree(&interp->interpEvalQ);\n    }\n    if (interp->nullFuncArg)\n        Jsi_DecrRefCount(interp, interp->nullFuncArg);\n    if (interp->NullValue)\n        Jsi_DecrRefCount(interp, interp->NullValue);\n    if (interp->Function_prototype_prototype) {\n        if (interp->Function_prototype_prototype->refCnt>1)\n            Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n        Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n    }\n    if (interp->Object_prototype) {\n        Jsi_DecrRefCount(interp, interp->Object_prototype);\n    }\n    Jsi_HashDelete(interp->regexpTbl);\n    Jsi_OptionsFree(interp, InterpOptions, interp, 0);\n    Jsi_HashDelete(interp->userdataTbl);\n    Jsi_HashDelete(interp->eventTbl);\n    if (interp->inopts)\n        Jsi_DecrRefCount(interp, interp->inopts);\n    if (interp->safeWriteDirs)\n        Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n    if (interp->safeReadDirs)\n        Jsi_DecrRefCount(interp, interp->safeReadDirs);\n    if (interp->pkgDirs)\n        Jsi_DecrRefCount(interp, interp->pkgDirs);\n    for (i=0; interp->cleanObjs[i]; i++) {\n        interp->cleanObjs[i]->tree->opts.freeHashProc = 0;\n        Jsi_ObjFree(interp, interp->cleanObjs[i]);\n    }\n    Jsi_HashDelete(interp->bindTbl);\n    for (i = 0; i <= interp->cur_scope; i++)\n        jsi_ScopeStrsFree(interp, interp->scopes[i]);\n#if JSI__ZVFS==1\n    Jsi_InitZvfs(interp, mainFlag);\n#endif\n    if (!interp->parent)\n        Jsi_HashDelete(interp->loadTbl);\n    if (interp->packageHash)\n        Jsi_HashDelete(interp->packageHash);\n    Jsi_HashDelete(interp->assocTbl);\n    interp->cleanup = 1;\n    jsi_AllObjOp(interp, NULL, -1);\n#ifdef JSI_MEM_DEBUG\n    jsi_DebugDumpValues(interp);\n#endif\n    if (isMainInt || interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl)\n        Jsi_MapDelete(interp->strKeyTbl);\n\n    if (isMainInt)\n        jsiIntData.mainInterp = NULL;\n    _JSI_MEMCLEAR(interp);\n    jsiIntData.delInterp = NULL;\n    Jsi_Free(interp);\n    return JSI_OK;\n}\n\nvoid Jsi_InterpDelete(Jsi_Interp* interp)\n{\n    if (interp->deleting || interp->level > 0 || !interp->onDeleteTbl)\n        return;\n    interp->deleting = 1;\n    Jsi_HashDelete(interp->onDeleteTbl);\n    interp->onDeleteTbl = NULL;\n    Jsi_EventuallyFree(interp, interp, jsiInterpDelete);\n}\n\ntypedef struct {\n    void *data;\n    Jsi_Interp *interp;\n    int refCnt;\n    Jsi_DeleteProc* proc;\n} PreserveData;\n\nvoid Jsi_Preserve(Jsi_Interp* interp, void *data) {\n    bool isNew;\n    PreserveData *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->preserveTbl, data, &isNew);\n    assert(hPtr);\n    if (!isNew) {\n        ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n        if (ptr) {\n            assert(interp == ptr->interp);\n            ptr->refCnt++;\n        }\n    } else {\n        ptr = (PreserveData*)Jsi_Calloc(1,sizeof(*ptr));\n        Jsi_HashValueSet(hPtr, ptr);\n        ptr->interp = interp;\n        ptr->data = data;\n        ptr->refCnt = 1;\n    }\n}\n\nvoid Jsi_Release(Jsi_Interp* interp, void *data) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) return;\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    if (!ptr) return;\n    assert(ptr->interp == interp);\n    if (--ptr->refCnt > 0) return;\n    if (ptr->proc)\n        (*ptr->proc)(interp, data);\n    Jsi_Free(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) {\n        (*proc)(interp, data);\n        return;\n    }\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    assert(ptr && ptr->interp == interp);\n    JSI_NOWARN(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr)\n{\n    if (freeProc)\n        Jsi_HashSet(interp->onDeleteTbl, ptr, (void*)freeProc);\n    else {\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->onDeleteTbl, ptr);\n        if (hPtr)\n            Jsi_HashEntryDelete(hPtr);\n    }\n}\n\nstatic void interpObjErase(InterpObj *fo)\n{\n    SIGASSERTV(fo,INTERPOBJ);\n    if (fo->subinterp) {\n        Jsi_Interp *interp = fo->subinterp;\n        fo->subinterp = NULL;\n        Jsi_InterpDelete(interp);\n        /*fclose(fo->fp);\n        Jsi_Free(fo->interpname);\n        Jsi_Free(fo->mode);*/\n    }\n    fo->subinterp = NULL;\n}\n\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (fo->deleting) return JSI_OK;\n    fo->deleting = 1;\n    interpObjErase(fo);\n    Jsi_Free(fo);\n    return JSI_OK;\n}\n\nstatic bool interpObjIsTrue(void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (!fo->subinterp) return 0;\n    else return 1;\n}\n\nstatic bool interpObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\n/* TODO: possibly support async func-callback.  Also for call/send. */\nstatic Jsi_RC InterpEvalCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int flags)\n{\n    int isFile = flags&2;\n    int isUplevel = flags&1;\n    int lev = 0;\n    bool async = 0;\n    Jsi_RC rc = JSI_OK;\n    int isthrd;\n    Jsi_Interp *sinterp = interp;\n    Jsi_ValueMakeUndef(interp, ret);\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (udf)\n        sinterp = udf->subinterp;\n    if (Jsi_InterpGone(interp) || Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!isUplevel) {\n        if (nw && Jsi_GetBoolFromValue(interp, nw, &async))\n            return JSI_ERROR;\n    } else {\n        if (isthrd)\n            return Jsi_LogError(\"can not use uplevel() with threaded interp\");\n        Jsi_Number nlev = sinterp->framePtr->level;\n        if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev)!=JSI_OK)\n            return Jsi_LogError(\"expected number\");\n        lev = (int)nlev;\n        if (lev <= 0)\n            lev = f->level+lev;\n        if (lev <= 0 || lev > f->level)\n            return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    }\n\n    char *cp = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (cp==NULL || *cp == 0)\n        return JSI_OK;\n    if (async && isthrd) {\n        /* Post to thread event in sub-interps queue. TODO: could just use event like below... */\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_DSAppend(&sinterp->interpEvalQ, Jsi_Strlen(Jsi_DSValue(&sinterp->interpEvalQ))?\";\":\"\", cp, NULL);\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        return JSI_OK;\n    }\n    if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n    if (!isthrd) {\n        int ostrict = sinterp->strict;\n        sinterp->strict = 0;\n        sinterp->level++;\n        if (interp->framePtr->tryDepth)\n            sinterp->framePtr->tryDepth++;\n        if (isFile) {\n            int sflags = 0;\n            if (!sinterp->includeCnt) {\n                sflags = JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX;\n                sinterp->isMain = 1;\n            }\n            if (sinterp->debugOpts.debugCallback && !sinterp->includeCnt)  // TODO: safe debugging can't use \"source\"\n                // TODO: we do this in debugger, even though it is illegal for interps to share objects.\n                sinterp->autoFiles = Jsi_ValueDup(sinterp, interp->autoFiles);\n            sinterp->includeCnt++;\n            rc = Jsi_EvalFile(sinterp, Jsi_ValueArrayIndex(interp, args, 0), sflags);\n        } else if (isUplevel == 0 || lev <= 1)\n            rc = (Jsi_EvalString(sinterp, cp, 0) == 0 ? JSI_OK : JSI_ERROR);\n        else {\n            rc = (jsi_evalStrFile(sinterp, NULL, cp, 0, lev) == 0 ? JSI_OK : JSI_ERROR);\n        }\n        sinterp->strict = ostrict;\n        if (interp->framePtr->tryDepth) {\n            sinterp->framePtr->tryDepth--;\n            if (rc != JSI_OK && interp != sinterp) {\n                Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n                interp->errLine = sinterp->errLine;\n                interp->errFile = sinterp->errFile;\n                sinterp->errMsgBuf[0] = 0;\n            }\n        }\n        sinterp->level--;\n    } else {\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        SIGINIT(s,INTERPSTREVENT);\n        s->isExec = 1;\n        s->tryDepth = interp->framePtr->tryDepth;\n        Jsi_DSInit(&s->data);\n        Jsi_DSAppend(&s->data, cp, NULL);\n        Jsi_DSInit(&s->func);\n        //s->mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_MutexLock(s->mutex);\n        se = sinterp->interpStrEvents;\n        if (!se)\n            sinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        while (s->isExec)      /* Wait until done. TODO: timeout??? */\n            Jsi_Sleep(interp, 1);\n        rc = (s->rc == 0 ? JSI_OK : JSI_ERROR);\n        if (rc != JSI_OK)\n            Jsi_LogError(\"eval failed: %s\", Jsi_DSValue(&s->data));\n        Jsi_DSFree(&s->func);\n        Jsi_DSFree(&s->data);\n        Jsi_Free(s);\n    }\n\n    if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n        return JSI_ERROR;\n    }\n\n    if (Jsi_InterpGone(sinterp))\n    {\n        /* TODO: perhaps exit() be able to delete. */\n        //Jsi_InterpDelete(sinterp);\n        return JSI_OK;\n    }\n    /*if (rc != JSI_OK && !async)\n        return rc;*/\n    if (sinterp->retValue->vt != JSI_VT_UNDEF) {\n        if (sinterp == interp)\n            Jsi_ValueCopy(interp, *ret, sinterp->retValue);\n        else\n            Jsi_CleanValue(sinterp, interp, sinterp->retValue, ret);\n    }\n    return rc;\n}\n\nJsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc)\n{\n    if (rc<0 || rc>127) rc = 127;\n    if (!interp || !interp->opts.no_exit) {\n        if (rc) {\n            Jsi_Flush(interp, jsi_Stdout);\n            Jsi_Flush(interp, jsi_Stderr);\n        }\n        exit(rc);\n    }\n    fprintf(stderr, \"ignoring attempted exit: may cause a crash\\n\");\n    if (interp) interp->deleting = 1;\n    return NULL;\n}\n\n#define FN_interpeval JSI_INFO(\"\\\nWhen the 'async' option is used on a threaded interp, the script is queued as an Event.\")\n\nstatic Jsi_RC InterpEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 0);\n}\n\n\n#define FN_interpuplevel JSI_INFO(\"\\\nThe level argument is as returned by Info.level().  Not supported with threads.\")\nstatic Jsi_RC InterpUplevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC InterpSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 2);\n}\n\nstatic Jsi_RC InterpValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n        return Jsi_LogError(\"Sub-interp gone\");\n        sinterp = udf->subinterp;\n        if (interp->threadId != udf->subinterp->threadId)\n            return Jsi_LogError(\"value not supported with threads\");\n    }\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Number nlev = sinterp->framePtr->level;\n    if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev))\n        return JSI_ERROR;\n    int lev = (int)nlev;\n    if (lev <= 0)\n        lev = f->level+lev;\n    if (lev <= 0 || lev > f->level)\n        return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    while (f->level != lev  && f->parent)\n        f = f->parent;\n\n    const char* arg = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *val = NULL;\n    if (arg) {\n        if (f == sinterp->framePtr)\n            val = Jsi_NameLookup(sinterp, arg);\n        else {\n            jsi_Frame *of = sinterp->framePtr;\n            sinterp->framePtr = f;\n            val = Jsi_NameLookup(sinterp, arg);\n            sinterp->framePtr = of;\n        }\n    }\n    if (!val)\n        return Jsi_LogError(\"unknown var: %s\", arg);\n    if (sinterp == interp) {\n        Jsi_ValueCopy(interp, *ret, val);\n        return JSI_OK;\n    }\n    Jsi_CleanValue(sinterp, interp, val, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InterpInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *subinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n            return Jsi_LogError(\"Sub-interp gone\");\n        subinterp = udf->subinterp;\n    }\n    return jsi_InterpInfo(subinterp, args, _this, ret, funcPtr);\n}\n\nJsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Interp *sinterp = interp;\n    Jsi_DString dStr = {}, cStr = {};\n    char tbuf[1024];\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    tbuf[0] = 0;\n    if (v) {\n        InterpObj *udf = NULL;\n        if (v && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_USEROBJ)\n            udf = (InterpObj *)v->d.obj->d.uobj->data;\n        if (udf && udf->subinterp) {\n            SIGASSERT(udf, INTERPOBJ);\n            sinterp = udf->subinterp;\n        } else\n            return Jsi_LogError(\"unknown interp\");\n    }\n    if (sinterp->subthread)\n        snprintf(tbuf, sizeof(tbuf), \", thread:{errorCnt:%u, evalCnt:%u, msgCnt:%u }\",\n            sinterp->threadErrCnt, sinterp->threadEvalCnt, sinterp->threadMsgCnt );\n    const char *funcstr = sinterp->framePtr->funcName;\n    if (!funcstr)\n        funcstr = \"\";\n    int curLine = (sinterp->curIp?sinterp->curIp->Line:0);\n    Jsi_DSPrintf(&dStr, \"{curLevel:%d, curLine:%d, curFile:\\\"%s\\\", curFunc:\\\"%s\\\", hasExited:%d, \"\n        \"opCnt:%d, isSafe:%s, depth:%d, codeCacheHits: %d, typeMismatchCnt:%d, \"\n        \"funcCallCnt:%d, cmdCallCnt:%d, includeCnt:%d, includeDepth:%d, pkgReqDepth:%d, \"\n        \"cwd:\\\"%s\\\", lockTimeout: %d, name, \\\"%s\\\" %s%s};\",\n        sinterp->level, curLine, jsi_GetCurFile(sinterp), funcstr?funcstr:\"\",\n        sinterp->exited, sinterp->opCnt, sinterp->isSafe?\"true\":\"false\",\n        sinterp->interpDepth, sinterp->codeCacheHit, sinterp->typeMismatchCnt,\n        sinterp->funcCallCnt, sinterp->cmdCallCnt, sinterp->includeCnt, sinterp->includeDepth, sinterp->pkgReqDepth,\n        (sinterp->curDir?sinterp->curDir:Jsi_GetCwd(sinterp,&cStr)),\n        sinterp->lockTimeout, sinterp->name?sinterp->name:\"\", tbuf[0]?\",\":\"\", tbuf);\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    if (rc != JSI_OK)\n        puts(Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&cStr);\n    return rc;\n}\n\nstatic Jsi_RC SubInterpEvalCallback(Jsi_Interp *interp, void* data)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {};\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n    char *cp = Jsi_DSValue(&interp->interpEvalQ);\n    if (*cp) {\n        Jsi_DSAppend(&dStr, cp, NULL);\n        Jsi_DSSetLength(&interp->interpEvalQ, 0);\n        interp->threadEvalCnt++;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0) != JSI_OK)\n            rc = JSI_ERROR;\n        Jsi_DSSetLength(&dStr, 0);\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n    }\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    Jsi_DSFree(&dStr);\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Process subevents. */\n    InterpStrEvent *oldse, *se = interp->interpStrEvents;\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    while (se) {\n        oldse = se;\n        int isExec = se->isExec;\n        if (se->acdata) {\n            jsi_AliasCreateCmd(interp, Jsi_DSValue(&se->func), se->acdata);\n        }\n        else if (se->acfunc) {\n            if (JSI_OK != Jsi_FunctionInvokeJSON(interp, se->acfunc, Jsi_DSValue(&se->data), NULL))\n                rc = JSI_ERROR;\n            Jsi_DecrRefCount(interp, se->acfunc);\n        }\n        else if (isExec) {\n            if (se->tryDepth)\n                interp->framePtr->tryDepth++;\n            se->rc = Jsi_EvalString(interp, Jsi_DSValue(&se->data), 0);\n            Jsi_DSSetLength(&se->data, 0);\n            if (se->rc != JSI_OK && se->tryDepth) {\n                Jsi_DSAppend(&se->data, interp->errMsgBuf, NULL);\n                se->errLine = interp->errLine;\n                se->errFile = interp->errFile;\n            } else {\n                Jsi_ValueGetDString(interp, interp->retValue, &se->data, JSI_OUTPUT_JSON);\n            }\n            if (se->tryDepth)\n                interp->framePtr->tryDepth--;\n\n        /* Otherwise, async calls. */\n        /*} else if (se->objData) {\n            if (JSI_OK != Jsi_CommandInvoke(interp, Jsi_DSValue(&se->func), se->objData, NULL))\n                rc = JSI_ERROR;*/\n        } else {\n            const char *scp = Jsi_DSValue(&se->data);\n            if (JSI_OK != Jsi_CommandInvokeJSON(interp, Jsi_DSValue(&se->func), scp, NULL))\n                rc = JSI_ERROR;\n        }\n        if (!isExec) {\n            Jsi_DSFree(&se->func);\n            Jsi_DSFree(&se->data);\n        }\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        interp->interpStrEvents = se->next;\n        if (!isExec) Jsi_Free(se);\n        se = interp->interpStrEvents;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (isExec)\n            oldse->isExec = 0;\n    }\n\n    return rc;\n}\n\n\nstatic Jsi_RC ThreadEvalCallback(Jsi_Interp *interp, void* data) {\n    Jsi_RC rc;\n\n    if ((rc=SubInterpEvalCallback(interp, data)) != JSI_OK)\n        interp->threadErrCnt++;\n    return rc;\n}\n\n/* Create an event handler in interp to handle call/eval/send asyncronously via 'Sys.update()'. */\nvoid jsi_AddEventHandler(Jsi_Interp *interp)\n{\n    Jsi_Event *ev;\n    while (!interp->EventHdlId) { /* Find an empty event slot. */\n        bool isNew;\n        uintptr_t id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));\n        SIGINIT(ev,EVENT);\n        ev->id = id;\n        ev->handler = ThreadEvalCallback;\n        ev->hPtr = hPtr;\n        ev->evType = JSI_EVENT_ALWAYS;\n        Jsi_HashValueSet(hPtr, ev);\n        interp->EventHdlId = id;\n    }\n}\n\n#define FN_call JSI_INFO(\"\\\nInvoke function in sub-interp with arguments.\\n\\\nSince interps are not allowed to share objects, \\\ndata is automatically cleansed by encoding/decoding to/from JSON if required.\\n\\\nUnless an 'async' parameter is true call is acyncronous.\\n\\\nOtherwise waits until the sub-interp is idle, \\\nto make call and return result.\")\n\nstatic Jsi_RC InterpCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    int isthrd;\n    Jsi_Interp *sinterp;\n    if (udf)\n        sinterp = udf->subinterp;\n    else\n        return Jsi_LogError(\"Apply Interp.call in a non-subinterp\");\n    if (Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n\n    Jsi_Value *func = NULL;\n    char *fname = NULL;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    fname = Jsi_ValueString(interp, func, NULL);\n    if (!fname)\n        return Jsi_LogError(\"function name must be a string\");\n    if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *namLU = Jsi_NameLookup(sinterp, fname);\n    Jsi_MutexUnlock(interp, sinterp->Mutex);\n    if (namLU == NULL)\n        return Jsi_LogError(\"unknown function: %s\", fname);\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    char *cp = Jsi_ValueString(interp, arg, NULL);\n\n    if (cp == NULL && !Jsi_ValueIsArray(interp, arg))\n        return Jsi_LogError(\"expected string or array\");\n\n    Jsi_Value *vwait = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_RC rc = JSI_OK;\n    bool wait = 0;\n    if (vwait && Jsi_GetBoolFromValue(interp, vwait, &wait))\n        return JSI_ERROR;\n\n    if (wait) {\n        Jsi_DString dStr = {};\n        if (cp == NULL)\n            cp = (char*)Jsi_ValueGetDString(interp, arg, &dStr, JSI_OUTPUT_JSON);\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n        Jsi_Value *srPtr = Jsi_ValueNew1(sinterp);\n        /* TODO: call from this interp may not be safe if threaded.\n         * Could instead use async code below then wait for unlock on se->mutex. */\n        rc = Jsi_CommandInvokeJSON(sinterp, fname, cp, &srPtr);\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_CleanValue(sinterp, interp, srPtr, ret);\n        //Jsi_ValueCopy(interp, *ret, srPtr);\n        Jsi_DecrRefCount(sinterp, srPtr);\n        Jsi_DSFree(&dStr);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            Jsi_LogBug(\"mutex re-get failed\");\n            return JSI_ERROR;\n        }\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    Jsi_DSInit(&s->data);\n    if (!cp) {\n        Jsi_ValueGetDString(interp, arg, &s->data, JSI_OUTPUT_JSON);\n    } else {\n        Jsi_DSSetLength(&s->data, 0);\n        Jsi_DSAppend(&s->data, cp, NULL);\n    }\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, fname, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    if (!isthrd) {\n        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)\n            sinterp->threadErrCnt++;\n    }\n    return JSI_OK;\n}\n\nJsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)\n{\n#if JSI__ZVFS==1\n    return Zvfs_Mount(interp, archive, mount, ret);\n#else\n    return JSI_ERROR;\n#endif\n}\n\n/* Looks in dir for autoload.jsi or lib/autoload.jsi to add to autoFiles list. */\nint Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir) {\n    Jsi_DString dStr = {};\n    Jsi_StatBuf stat;\n    int i, cnt = 0;\n    for (i=0; i<2; i++) {\n        Jsi_DSAppend(&dStr, dir, (i==0?\"/lib\":\"\"),\"/autoload.jsi\", NULL);\n        Jsi_Value *v = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));\n        if (Jsi_Stat(interp, v, &stat) != 0)\n            Jsi_ValueFree(interp, v);\n        else {\n            if (!interp->autoFiles) {\n                interp->autoFiles = Jsi_ValueNewArray(interp, 0, 0);\n                Jsi_IncrRefCount(interp, interp->autoFiles);\n            }\n            Jsi_ObjArrayAdd(interp, interp->autoFiles->d.obj, v);\n            cnt++;\n            interp->autoLoaded = 0;\n        }\n        Jsi_DSSetLength(&dStr, 0);\n    }\n    Jsi_DSFree(&dStr);\n    return cnt;\n}\n\nJsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound)\n{\n#if JSI__ZVFS==1\n    Jsi_StatBuf stat;\n    Jsi_Value *vinit, *linit, *vmnt = NULL;\n    Jsi_Value *vexe = Jsi_ValueNewStringKey(interp, exeFile);\n    Jsi_Value *ret = NULL;\n    Jsi_RC rc;\n    const char *omntDir = mntDir;\n    int pass = 0;\n    Jsi_IncrRefCount(interp, vexe);\n    Jsi_HashSet(interp->genValueTbl, vexe, vexe);\n    if (jsFound)\n        *jsFound = 0;\n    if (!mntDir)\n        ret = Jsi_ValueNew(interp);\n    else {\n        vmnt = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, vmnt);\n        Jsi_HashSet(interp->genValueTbl, vmnt, vmnt);\n    }\n    bool osafe = interp->isSafe;\n    if (interp->startSafe)\n        interp->isSafe = 0;\n    rc =Jsi_Mount(interp, vexe, vmnt, &ret);\n    interp->isSafe = osafe;\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_DString dStr, bStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&bStr);\n    if (!mntDir) {\n        mntDir = Jsi_KeyAdd(interp, Jsi_ValueString(interp, ret, NULL));\n        Jsi_DecrRefCount(interp, ret);\n    }\ndochk:\n    Jsi_DSAppend(&dStr, mntDir, \"/main.jsi\", NULL);\n    if (interp->pkgDirs)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, Jsi_ValueNewStringKey(interp, mntDir));\n    else {\n        interp->pkgDirs = Jsi_ValueNewArray(interp, &mntDir, 1);\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n    }\n    vinit = Jsi_ValueNewStringKey(interp,  Jsi_DSValue(&dStr));\n    Jsi_IncrRefCount(interp, vinit);\n    Jsi_HashSet(interp->genValueTbl, vinit, vinit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSAppend(&dStr, mntDir, \"/lib\", NULL);\n    const char *str = Jsi_DSValue(&dStr);\n    linit = Jsi_ValueNewStringKey(interp, str);\n    Jsi_IncrRefCount(interp, linit);\n    if (Jsi_Stat(interp, linit, &stat) == 0)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, linit);\n    Jsi_DecrRefCount(interp, linit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&bStr);\n    if (Jsi_Stat(interp, vinit, &stat) == 0) {\n        if (jsFound)\n            *jsFound |= JSI_ZIP_MAIN;\n        interp->execZip = vexe;\n        return Jsi_EvalFile(interp, vinit, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX);\n    }\n    if (Jsi_AddAutoFiles(interp, mntDir) && omntDir)\n        *jsFound = JSI_ZIP_INDEX;\n    if (!pass++) {\n        str = Jsi_Strrchr(exeFile, '/');\n        if (str) str++;\n        else str = exeFile;\n        char *bn = Jsi_DSAppend(&bStr, mntDir, \"/\", str, NULL);\n        bn = Jsi_Strrchr(bn, '.');\n        if (bn) *bn = 0;\n        mntDir = Jsi_DSValue(&bStr);\n        linit = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, linit);\n        int bsi = Jsi_Stat(interp, linit, &stat);\n        Jsi_DecrRefCount(interp, linit);\n        if (bsi == 0)\n            goto dochk;\n        Jsi_DSFree(&bStr);\n    }\n#endif\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_THREADS\n\n#ifdef __WIN32\n#define JSITHREADRET void\n#else\n#define JSITHREADRET void*\n#endif\n\nstatic JSITHREADRET NewInterpThread(void* iPtr)\n{\n    int rc = JSI_OK;\n    InterpObj *udf = (InterpObj *)iPtr;\n    Jsi_Interp *interp = udf->subinterp;\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->scriptStr)\n        rc = Jsi_EvalString(interp, interp->scriptStr, 0);\n    else if (interp->scriptFile) {\n        if (!interp->debugOpts.debugCallback) // Debug will use Interp.source() instead.\n            Jsi_EvalFile(interp, interp->scriptFile, 0);\n    } else {\n        Jsi_LogBug(\"no eval\");\n    }\n    if (rc != JSI_OK) {\n        Jsi_LogError(\"eval failure\");\n        interp->threadErrCnt++;\n        if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n            return NULL;\n        Jsi_MutexUnlock(interp, interp->Mutex);\n    }\n    interpObjErase(udf);\n#ifndef __WIN32\n    /* TODO: should we wait/notify parent??? */\n    pthread_detach(pthread_self());\n    return NULL;\n#endif\n}\n#endif\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_CmdSpec interpCmds[] = {\n    { \"Interp\", InterpConstructor,0,  1, \"options:object=void\", .help=\"Create a new interp\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=InterpOptions},\n    { \"alias\",  InterpAliasCmd,   0,  4, \"name:string=void, func:function|null=void, args:array|null=void, async=false\",.help=\"Set/get global alias bindings for command in an interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_intalias },\n    { \"call\",   InterpCallCmd,    2,  3, \"funcName:string, args:array, wait:boolean=false\", .help=\"Call named function in subinterp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_call },\n    { \"conf\",   InterpConfCmd,    0,  1, \"options:string|object=void\",.help=\"Configure option(s)\" , .retType=(uint)JSI_TT_ANY,.flags=0,.info=0,.opts=InterpOptions},\n    { \"eval\",   InterpEvalCmd,    1,  2, \"js:string, async:boolean=false\", .help=\"Interpret script within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"info\",   InterpInfoCmd,    0,  0, \"\", .help=\"Returns internal statistics about interp\", .retType=(uint)JSI_TT_OBJECT },\n    { \"source\", InterpSourceCmd,  1,  2, \"file:string, async:boolean=false\", .help=\"Interpret file within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"uplevel\",InterpUplevelCmd, 2,  2, \"js:string, level:number=0\", .help=\"Interpret code at the given stack level\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpuplevel },\n    { \"value\",  InterpValueCmd,   1,  2, \"var:string, level:number=0\", .help=\"Lookup value of variable at stack level\", .retType=(uint)JSI_TT_ANY },\n    { NULL,     0,0,0,0, .help=\"Commands for accessing interps\" }\n};\n\nstatic Jsi_UserObjReg interpobject = {\n    \"Interp\",\n    interpCmds,\n    interpObjFree,\n    interpObjIsTrue,\n    interpObjEqual\n};\n\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *fobj;\n    Jsi_Value *toacc;\n    InterpObj *cmdPtr = (InterpObj *)Jsi_Calloc(1,sizeof(*cmdPtr));\n    int rc = JSI_OK;\n    SIGINIT(cmdPtr,INTERPOBJ);\n    cmdPtr->parent = interp;\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n\n    if (!(cmdPtr->subinterp = jsi_InterpNew(interp, arg, NULL))) {\n        Jsi_Free(cmdPtr);\n        return JSI_ERROR;\n    }\n    Jsi_Interp *sinterp = cmdPtr->subinterp;\n    sinterp->opts.no_exit = interp->opts.no_exit;\n    toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"Interp\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &interpobject, fobj, cmdPtr))<0)\n        goto bail;\n    sinterp->objId = cmdPtr->objId;\n    cmdPtr->fobj = fobj;\n#ifndef JSI_OMIT_THREADS\n    if (sinterp->subthread) {\n#ifdef __WIN32\n        if (!_beginthread( NewInterpThread, 0, cmdPtr )) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#else\n        pthread_t nthread;\n        if (pthread_create(&nthread, NULL, NewInterpThread, cmdPtr) != 0) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#endif //__WIN32\n#else\n    if (0) {\n#endif //JSI_OMIT_THREADS\n    } else {\n        //sinterp->framePtr->tryDepth++;\n        if (sinterp->scriptStr != 0) {\n            if (sinterp->scriptFile && !interp->curFile)\n                sinterp->curFile = Jsi_ValueString(sinterp, sinterp->scriptFile, NULL);\n            rc = Jsi_EvalString(sinterp, sinterp->scriptStr, JSI_EVAL_ISMAIN);\n        } else if (sinterp->scriptFile && !sinterp->debugOpts.debugCallback) {\n            int len;\n            if (Jsi_ValueString(interp, sinterp->scriptFile, &len) && len==0)\n                Jsi_Interactive(sinterp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n            else\n                rc = Jsi_EvalFile(sinterp, sinterp->scriptFile, JSI_EVAL_ISMAIN);\n        }\n        //sinterp->framePtr->tryDepth--;\n        if (rc == JSI_EXIT)\n            return JSI_OK;\n        if (rc != JSI_OK) {\n            /*Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n            interp->errLine = sinterp->errLine;\n            interp->errFile = sinterp->errFile;\n            sinterp->errMsgBuf[0] = 0;*/\n            goto bail;\n        }\n    }\n    return JSI_OK;\n\nbail:\n    interpObjErase(cmdPtr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return JSI_ERROR;\n}\n\nstatic Jsi_RC Jsi_DoneInterp(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &interpobject);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_InterpConfFile(Jsi_Interp *interp, const char *fname, bool etc)\n{\n    Jsi_RC rc;\n    Jsi_DString dStr = {};\n    Jsi_Value *opts = NULL, *fn = Jsi_ValueNewStringConst(interp, fname, -1);\n    Jsi_IncrRefCount(interp, fn);\n    bool isSafe = interp->isSafe;\n    if (etc)\n        interp->isSafe = 0;\n    rc = Jsi_FileRead(interp, fn, &dStr);\n    if (rc != JSI_OK)\n        goto done;\n    opts = Jsi_ValueNew1(interp);\n    if (rc == JSI_OK)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), &opts, 0);\n    if (rc == JSI_OK\n        && Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0)\n        rc = JSI_ERROR;\ndone:\n    if (etc && isSafe)\n        interp->isSafe = 1;\n    if (opts)\n        Jsi_DecrRefCount(interp, opts);\n    Jsi_DecrRefCount(interp, fn);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp)\n{\n    Jsi_RC rc = JSI_OK;\n#ifndef JSI__CONFFILE\n#define JSI__CONFFILE \"/etc/jsish.conf\"\n#endif\n    const char *fn = JSI__CONFFILE;\n    if (!fn || !fn[0])\n        return JSI_OK;\n    if (interp->confFile)\n        rc = jsi_InterpConfFile(interp, interp->confFile, 0);\n    if (rc == JSI_OK && access(fn, R_OK)==0)\n        rc = jsi_InterpConfFile(interp, fn, 1);\n    if (rc != JSI_OK)\n        Jsi_LogWarn(\"parse failure: %s\", fn);\n    if (interp->jsppChars && Jsi_Strlen(interp->jsppChars)!=2) {\n        Jsi_LogWarn(\"jsppChars ignored: length not 2: %s\", interp->jsppChars);\n        interp->jsppChars = NULL;\n    }\n    return rc;\n}\n\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_RC rc;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Interp *sinterp = interp;\n    if (!udf || udf->subinterp == interp) {\n        if (interp->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n            return Jsi_LogError(\"Interp conf() is disabled for set\");\n        rc = Jsi_OptionsConf(interp, InterpOptions, interp, opts, ret, 0);\n    } else {\n        sinterp = udf->subinterp;\n        Jsi_Value *popts = opts;\n        if (opts && opts->vt != JSI_VT_NULL && !Jsi_ValueString(interp, opts, NULL) && opts->vt == JSI_VT_OBJECT) {\n            popts = Jsi_ValueNew1(sinterp);\n            Jsi_CleanValue(interp, sinterp, opts, &popts);\n        }\n        rc = Jsi_OptionsConf(sinterp, InterpOptions, sinterp, popts, ret, 0);\n        if (popts && popts != opts)\n            Jsi_DecrRefCount(sinterp, popts);\n        Jsi_CleanValue(sinterp, interp, *ret, ret);\n    }\n    return rc;\n}\n\nJsi_Value *Jsi_ReturnValue(Jsi_Interp *interp) {\n    return interp->retValue;\n}\n\nJsi_RC jsi_InitInterp(Jsi_Interp *interp, int release)\n{\n    if (release) return Jsi_DoneInterp(interp);\n    Jsi_Hash *isys;\n    if (!(isys = Jsi_UserObjRegister(interp, &interpobject)))\n        Jsi_LogBug(\"Can not init interp\");\n\n    Jsi_CommandCreateSpecs(interp, interpobject.name, interpCmds, isys, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\nbool Jsi_InterpSafe(Jsi_Interp *interp)\n{\n    return interp->isSafe;\n}\n\nJsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag)\n{\n    switch (aflag) {\n        case JSI_INTACCESS_NETWORK:\n            return (interp->noNetwork?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_MAININTERP:\n            return (interp->parent?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_SETSSL:\n            interp->hasOpenSSL = 1;\n            return JSI_OK;\n        case JSI_INTACCESS_CREATE:\n            return (interp->isSafe && interp->safeMode==jsi_safe_Lockdown?JSI_ERROR: JSI_OK);\n        case JSI_INTACCESS_WRITE:\n        case JSI_INTACCESS_READ:\n            break;\n        default:\n            return JSI_ERROR;\n    }\n    if (!resource)\n        return JSI_ERROR;\n    Jsi_Value *v, *dirs = ((aflag==JSI_INTACCESS_WRITE) ? interp->safeWriteDirs : interp->safeReadDirs);\n    if (!interp->isSafe)\n        return JSI_OK;\n    if (!dirs)\n        return JSI_ERROR;\n    char pbuf[PATH_MAX];\n    int i, m, argc = Jsi_ValueGetLength(interp, dirs);\n    char *str, *dstr = Jsi_Realpath(interp, resource, pbuf);\n    if (!dstr)\n        return JSI_ERROR;\n    for (i=0; i<argc; i++) {\n        v = Jsi_ValueArrayIndex(interp, dirs, i);\n        if (!v) continue;\n        str = Jsi_ValueString(interp, v, &m);\n        if (!str || m<=0) continue;\n        if (!Jsi_Strcmp(str, dstr)) // Exact match.\n            return JSI_OK;\n        if (Jsi_Strncmp(str, dstr, m))\n            continue;\n        if (m>1 && str[m-1]=='/')\n            return JSI_OK;\n        if (dstr[m] == '/')\n            return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\nJsi_Value *Jsi_InterpResult(Jsi_Interp *interp)\n{\n    return interp->retValue;\n}\n\nconst char *Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr)\n{\n    if (errFilePtr)\n        *errFilePtr = interp->errFile;\n    if (errLinePtr)\n        *errLinePtr = interp->errLine;\n    return interp->errMsgBuf;\n}\n\n#ifdef __WIN32\nvoid bzero(void *s, size_t n) {\n    memset(s, 0, n);\n}\n#endif\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n/******************* TREE ACCESS **********************/\n\nJsi_Value *Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey) {\n    Jsi_Tree *treePtr = obj->tree;\n    \n    if (!isstrkey) {\n        Jsi_MapEntry *hPtr = Jsi_MapEntryFind(treePtr->opts.interp->strKeyTbl, key);\n        if (!hPtr)\n            return NULL;\n        key = (const char*)Jsi_MapKeyGet(hPtr, 0);\n    }\n    Jsi_Value *v = (Jsi_Value*)Jsi_TreeGet(treePtr, (void*)key, 0);\n    return v;\n}\n\nJsi_TreeEntry *Jsi_TreeObjSetValue(Jsi_Obj *obj, const char *key, Jsi_Value *val, int isstrkey) {\n    Jsi_Tree *treePtr = obj->tree;\n    bool isNew;\n    Jsi_TreeEntry *hPtr;\n    Jsi_Interp *interp = treePtr->opts.interp;\n    if (!isstrkey) {\n        const char *okey = key;\n        Jsi_MapEntry *hePtr = Jsi_MapEntryNew(interp->strKeyTbl, key, &isNew);\n        key = (const char*)Jsi_MapKeyGet(hePtr, 0);\n        if (!key) {\n            Jsi_MapEntry *hePtr = Jsi_MapEntryNew(interp->strKeyTbl, okey, &isNew);\n            key = (const char*)Jsi_MapKeyGet(hePtr, 0);\n        }\n    }\n    //return Jsi_TreeSet(treePtr, key, val);\n    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);\n    if (!hPtr)\n        return NULL;\n    if (val)\n        SIGASSERT(val,VALUE);\n    if (!isNew)\n        Jsi_ValueReplace(interp, (Jsi_Value**)&(hPtr->value), val);\n    else {\n        hPtr->value = val;\n        if (val)\n            Jsi_IncrRefCount(interp, val);\n    }\n//    Jsi_Value *oldVal;  /* FYI: This let kitty.breed() work in tests/proto2.js */\n//    Assert(val->refCnt>0);\n//    if (!isNew) {\n//        oldVal = Jsi_TreeValueGet(hPtr);\n//        if (oldVal) {\n//            Jsi_ValueReset(interp, &oldVal);\n//            Jsi_ValueCopy(interp, oldVal, val);\n//        }\n//    }\n//    else\n//        hPtr->value = val;\n\n    return hPtr;\n}\n\n/*****************************************/\n\nbool Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o)  {\n    return ((o)->ot == JSI_OT_OBJECT && o->isarrlist);\n}\n\nstatic Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n       // obj->arrCnt++;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC ObjListifyArrayCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    if (hPtr->f.bits.isarrlist) {\n        Jsi_TreeEntryDelete(hPtr);\n        tree->opts.interp->delRBCnt++;\n        return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    if (!obj->isarrlist) {\n        Jsi_LogBug(\"Can not listify a non-array\");\n        return;\n    }\n    if (obj->arr) return;\n    Jsi_TreeWalk(obj->tree, ObjListifyCallback, obj, 0);\n\n    do {\n        interp->delRBCnt = 0;\n        Jsi_TreeWalk(obj->tree, ObjListifyArrayCallback, obj, 0);\n    } while (interp->delRBCnt);\n}\n\nvoid Jsi_IterObjFree(Jsi_IterObj *iobj)\n{\n    if (!iobj->isArrayList) {\n        uint i;\n        for (i = 0; i < iobj->count; i++) {\n            if (iobj->keys[i]) {\n                /*Jsi_TreeDecrRef(iobj->keys[i]); TODO: ??? */\n            }\n        }\n        Jsi_Free(iobj->keys);\n    }\n    Jsi_Free(iobj);\n}\n\nJsi_IterObj *Jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterCmd)\n{\n    Jsi_IterObj *o = (Jsi_IterObj*)Jsi_Calloc(1,sizeof(Jsi_IterObj));\n    o->interp = interp;\n    o->iterCmd = iterCmd;\n    return o;\n}\n\nstatic Jsi_RC DeleteTreeValue(Jsi_Interp *interp, Jsi_TreeEntry *ti, void *p) {\n    /* Cleanup tree value. */\n    SIGASSERT(ti,TREEENTRY);\n    Jsi_Value *v = (Jsi_Value*)p;\n    SIGASSERT(v,VALUE);\n    Jsi_DecrRefCount(interp, v);\n    ti->value = NULL;\n    return JSI_OK;\n}\n\nint jsi_AllObjOp(Jsi_Interp *interp, Jsi_Obj* obj, int op) {\n    if (op==2) {\n        Jsi_Obj* o = interp->allObjs;\n        while (o) {\n            if (o==obj) return 1;\n            o = o->next;\n        }\n        return 0;\n    }\n    if (op==1) {\n        //printf(\"ADD: %p : %p : %d\\n\", interp, obj, obj->VD.Idx);\n        assert(interp->allObjs!=obj);\n        obj->next = interp->allObjs;\n        if (interp->allObjs)\n            interp->allObjs->prev = obj;\n        interp->allObjs = obj;\n        return 0;\n    }\n    if (op==0) {\n        //printf(\"DEL: %p : %p\\n\", interp, obj);\n        if (!obj || !interp->allObjs) return 0;\n        if (obj == interp->allObjs)\n            interp->allObjs = obj->next;\n        if (obj->next)\n            obj->next->prev = obj->prev;\n        if (obj->prev)  \n            obj->prev->next = obj->next; \n        return 0;\n    }\n    if (op == -1) {\n        // TODO: fix cleanup for recursive bug, eg: x=[]; x.push(x);\n        // Perhaps use python approach??: http://www.arctrix.com/nas/python/gc/\n        while (0 && interp->allObjs) {\n            printf(\"NEED CLEANUP: %p\\n\", interp->allObjs);\n            Jsi_ObjDecrRefCount(interp, interp->allObjs);\n        }\n        return 0;\n    }\n#if JSI__MEMDEBUG\n    assert(0);\n    abort();\n#endif\n    return 0;\n}\n\nJsi_Obj *jsi_ObjNew_(Jsi_Interp *interp)\n{\n    Jsi_Obj *obj = (Jsi_Obj*)Jsi_Calloc(1,sizeof(*obj));\n    SIGINIT(obj,OBJ);\n    jsi_DebugObj(obj,\"New\", jsi_DebugValueCallIdx(), interp);\n    obj->ot = JSI_OT_OBJECT;\n    obj->tree = Jsi_TreeNew(interp, JSI_KEYS_STRINGKEY, NULL);\n    obj->tree->opts.freeTreeProc = DeleteTreeValue;\n    obj->tree->flags.valuesonly = 1;\n    obj->__proto__ = interp->Object_prototype;\n    interp->dbPtr->objCnt++;\n    interp->dbPtr->objAllocCnt++;\n   return obj;\n}\n\n#ifndef JSI_MEM_DEBUG\nJsi_Obj * Jsi_ObjNew(Jsi_Interp *interp) {\n    Jsi_Obj *obj = jsi_ObjNew_(interp);\n    jsi_AllObjOp(interp, obj, 1);\n    return obj;\n}\n#else\nJsi_Obj * jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Obj *obj = jsi_ObjNew_(interp);\n    jsi_ValueDebugUpdate(interp, obj, objDebugTbl, fname, line, func);\n    jsi_AllObjOp(interp, obj, 1);\n    return obj;\n}\n\n#ifndef JSI_OMIT_STUBS\n#undef Jsi_ObjNew\nJsi_Obj *Jsi_ObjNew(Jsi_Interp *interp) {\n    Jsi_Obj* obj = jsi_ObjNew_(interp);\n#ifdef JSI_MEM_DEBUG\n    jsi_ValueDebugUpdate(interp, obj, objDebugTbl, NULL, 0, NULL);\n#endif\n    jsi_AllObjOp(interp, obj, 1);\n    return obj;\n}\n#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#endif\n\n#endif\n\nJsi_Obj *Jsi_ObjNewType(Jsi_Interp *interp, Jsi_otype otype)\n{\n    Jsi_Obj *obj = Jsi_ObjNew(interp);\n    obj->ot = (otype==JSI_OT_ARRAY?JSI_OT_OBJECT:otype);\n    switch (otype) {\n        case JSI_OT_BOOL:   obj->__proto__ = interp->Boolean_prototype; break;\n        case JSI_OT_NUMBER: obj->__proto__ = interp->Number_prototype; break;\n        case JSI_OT_STRING: obj->__proto__ = interp->String_prototype; break;\n        case JSI_OT_FUNCTION:obj->__proto__ = interp->Function_prototype; break;\n        case JSI_OT_REGEXP: obj->__proto__ = interp->RegExp_prototype; break;\n        case JSI_OT_OBJECT: obj->__proto__ = interp->Object_prototype; break;\n        case JSI_OT_ARRAY:  obj->__proto__ = interp->Array_prototype;\n            obj->isarrlist = 1;\n            break;\n        default: assert(0); break;\n    }\n    if (interp->protoInit)\n        assert(obj->__proto__);\n    return obj;\n}\n\nvoid Jsi_ObjFree(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    interp->dbPtr->objCnt--;\n    //assert(obj->refcnt == 0);\n    jsi_AllObjOp(interp, obj, 0);\n#ifdef JSI_MEM_DEBUG\n    if (interp != obj->VD.interp)\n        printf(\"interp mismatch of objFree: %p!=%p : %p\\n\", interp, obj->VD.interp, obj);\n    jsi_DebugObj(obj,\"Free\", jsi_DebugValueCallIdx(), interp);\n    if (obj->VD.hPtr && !interp->cleanup) {\n        Jsi_HashEntryDelete(obj->VD.hPtr);\n        obj->VD.hPtr = NULL;\n    }\n#endif\n    /* printf(\"Free obj: %x\\n\", (int)obj); */\n    switch (obj->ot) {\n        case JSI_OT_STRING:\n            if (!obj->isstrkey)\n                Jsi_Free(obj->d.s.str);\n            obj->d.s.str = 0;\n            obj->isstrkey = 0;\n            break;\n        case JSI_OT_FUNCTION:\n            jsi_FuncObjFree(obj->d.fobj);\n            break;\n        case JSI_OT_ITER:\n            Jsi_IterObjFree(obj->d.iobj);\n            break;\n        case JSI_OT_USEROBJ:\n            jsi_UserObjFree(interp, obj->d.uobj);\n        case JSI_OT_ARRAY:\n        case JSI_OT_OBJECT:\n            break;\n        case JSI_OT_REGEXP:\n            if ((obj->d.robj->eflags&JSI_REG_STATIC)==0) {\n                regfree(&obj->d.robj->reg);\n                Jsi_Free(obj->d.robj);\n            }\n            break;\n        default:\n            break;\n    }\n    if (obj->tree)\n        Jsi_TreeDelete(obj->tree);\n    if (obj->arr) {\n        int i = -1;\n        while (++i < (int)obj->arrCnt)\n            if (obj->arr[i])\n                Jsi_DecrRefCount(interp, obj->arr[i]);\n        Jsi_Free(obj->arr);\n        obj->arr = NULL;\n    }\n    obj->tree = NULL;\n    if (obj->clearProto)\n        Jsi_DecrRefCount(interp, obj->__proto__);\n#ifdef JSI_MEM_DEBUG\n    memset(obj, 0, (sizeof(*obj)-sizeof(obj->VD)));\n#endif\n    Jsi_Free(obj);\n}\n\n\n/**************************** ARRAY ******************************/\n\nJsi_Value *jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key) {\n    if (!obj->arr || !key || !isdigit(*key))\n        return NULL;\n    char *ep = NULL;\n    int n = (int)strtol(key, &ep, 0);\n    if (n<0 || n >= (int)obj->arrCnt)\n        return NULL;\n    Jsi_Value *v = obj->arr[n];\n    return v;\n}\n\nJsi_RC Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v)\n{\n    if (o->isarrlist == 0)\n        return JSI_ERROR;\n    if (!o->arr)\n        Jsi_ObjListifyArray(interp, o);\n    int len = o->arrCnt;\n    if (Jsi_ObjArraySizer(interp, o, len+1) <= 0)\n        return JSI_ERROR;\n    o->arr[len] = v;\n    if (v)\n        Jsi_IncrRefCount(interp, v);\n    assert(o->arrCnt<=o->arrMaxSize);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex)\n{\n    int m, n = arrayindex;\n    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)\n        return JSI_ERROR;\n    if (obj->arr[n] == value)\n        return JSI_OK;\n    if (obj->arr[n])\n        Jsi_DecrRefCount(interp, obj->arr[n]);\n    Assert(obj->arrCnt<=obj->arrMaxSize);\n    obj->arr[n] = value;\n    if (value)\n        Jsi_IncrRefCount(interp, value);\n    m = Jsi_ObjGetLength(interp, obj);\n    if ((n+1) > m)\n       Jsi_ObjSetLength(interp, obj, n+1);\n    return JSI_OK;\n}\n\n// Copying version of above.\nJsi_Value *jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int n)\n{\n    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)\n        return NULL;\n    if (obj->arr[n])\n    {\n        Jsi_ValueCopy(interp, obj->arr[n], value);\n        return obj->arr[n];\n    }\n    Assert(obj->arrCnt<=obj->arrMaxSize);\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    int m;\n    Jsi_ValueCopy(interp,v, value);\n    obj->arr[n] = v;\n    m = Jsi_ObjGetLength(interp, obj);\n    if ((n+1) > m)\n       Jsi_ObjSetLength(interp, obj, n+1);\n    return v;\n}\n\nint Jsi_ObjIncrRefCount(Jsi_Interp *interp, Jsi_Obj *obj) {\n    jsi_DebugObj(obj,\"Incr\", jsi_DebugValueCallIdx(), interp);\n    SIGASSERT(obj,OBJ);\n    Assert(obj->refcnt>=0);\n    return ++obj->refcnt;\n}\n\nint Jsi_ObjDecrRefCount(Jsi_Interp *interp, Jsi_Obj *obj)  {\n   // if (interp->cleanup && !jsi_AllObjOp(interp, obj, 2))\n   //    return 0;\n    SIGASSERT(obj,OBJ);\n    if (obj->refcnt<=0) {\n#ifdef JSI_MEM_DEBUG\n        fprintf(stderr, \"Obj decr with ref %d: VD.Idx=%d\\n\", obj->refcnt, obj->VD.Idx);\n#endif\n        return -2;\n    }\n    jsi_DebugObj(obj,\"Decr\", jsi_DebugValueCallIdx(), interp);\n    int nref;\n    if ((nref = --obj->refcnt) <= 0) {\n        obj->refcnt = -1;\n        Jsi_ObjFree(interp, obj);\n    }\n    return nref;\n}\n\n\nint Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}\n\nJsi_Obj *Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copyflag)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (count>=0) {\n        int i;\n        if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {\n            Jsi_ObjFree(interp, obj);\n            return NULL;\n        }\n        for (i = 0; i < count; ++i) {\n            if (!items[i]) continue;\n            if (!copyflag) {\n                obj->arr[i] = items[i];\n                Jsi_IncrRefCount(interp, items[i]);\n            } else {\n                obj->arr[i] = Jsi_ValueNew1(interp);\n                Jsi_ValueCopy(interp, obj->arr[i], items[i]);\n            }\n        }\n    }\n    obj->arrCnt = count;\n    assert(obj->arrCnt<=obj->arrMaxSize);\n    return obj;\n}\n\n/****** END ARRAY ************/\n\nstatic Jsi_TreeEntry* ObjInsertFromValue(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *keyVal, Jsi_Value *nv)\n{\n    const char *key = NULL;\n    int flags = 0;\n    Jsi_DString dStr = {};\n    if (keyVal->vt == JSI_VT_STRING) {\n        flags = (keyVal->f.bits.isstrkey ? JSI_OM_ISSTRKEY : 0);\n        key = keyVal->d.s.str;\n    } else if (keyVal->vt == JSI_VT_OBJECT && keyVal->d.obj->ot == JSI_OT_STRING) {\n        Jsi_Obj *o = keyVal->d.obj;\n        flags = (o->isstrkey ? JSI_OM_ISSTRKEY : 0);\n        key = o->d.s.str;\n    }\n    if (key == NULL)\n        key = Jsi_ValueGetDString(interp, keyVal, &dStr, 0);\n    return Jsi_ObjInsert(interp, obj, key, nv, flags);\n}\n\nJsi_Obj *Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    if (count%2) return obj;\n    int i;\n    for (i = 0; i < count; i += 2) {\n        if (!items[i] || !items[i+1]) continue;\n        Jsi_Value *v = Jsi_ValueDup(interp, items[i+1]);\n        ObjInsertFromValue(interp, obj, items[i], v);\n        Jsi_DecrRefCount(interp, v);\n    }\n    return obj;\n}\n\nvoid Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    if (obj->isarrlist) {\n        assert(len<=obj->arrMaxSize);\n        obj->arrCnt = len;\n        return;\n    }\n    Jsi_Value *r = Jsi_TreeObjGetValue(obj,\"length\", 0);\n    if (!r) {\n        Jsi_Value *n = Jsi_ValueMakeNumber(interp, NULL, len);\n        Jsi_ObjInsert(interp, obj, \"length\", n, JSI_OM_DONTDEL | JSI_OM_DONTENUM | JSI_OM_READONLY);\n    } else {\n        Jsi_ValueReset(interp, &r);\n        Jsi_ValueMakeNumber(interp, &r, len);\n    }\n}\n\nint Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    if (obj->tree && obj->tree->numEntries) {\n        Jsi_Value *r = Jsi_TreeObjGetValue(obj, \"length\", 0);\n        Jsi_Number nr;\n        if (r && Jsi_GetNumberFromValue(interp,r, &nr) == JSI_OK) {\n            if (Jsi_NumberIsInteger(nr))\n                return nr;\n        }\n    }\n    if (obj->arr)\n        return obj->arrCnt;\n\n    return 0;\n}\n\nJsi_Value *jsi_ObjValueNew(Jsi_Interp *interp)\n{\n    return Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNew(interp));\n}\n\n\n/* Set result string into obj. */\nvoid Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj) {\n    int len = Jsi_DSLength(dsPtr);\n    if (obj->ot == JSI_OT_STRING && obj->d.s.str && !obj->isstrkey)\n        Jsi_Free(obj->d.s.str);\n    if (!(obj->d.s.str = (char*)dsPtr->strA)) {\n        obj->d.s.str = (char*)Jsi_Malloc(len+1);\n        memcpy(obj->d.s.str, dsPtr->Str, len+1);\n    }\n    obj->d.s.len = len;\n    obj->isBlob = 1;\n    dsPtr->strA = NULL;\n    dsPtr->Str[0] = 0;\n    dsPtr->len = 0;\n    dsPtr->spaceAvl = dsPtr->staticSize;\n}\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define bits_set(who, mask)     ((who) |= (mask))\n#define bits_unset(who, mask)   ((who) &= (~(mask)))\n#define bits_get(who, mask)     ((who) & (mask))\n\n#if  JSI__MEMDEBUG\nvoid jsi_VALCHK(Jsi_Value *val) {\n    SIGASSERTV(val,VALUE);\n    assert(val->vt <= JSI_VT__MAX);\n    if (val->vt == JSI_VT_OBJECT)\n        OBJCHK(val->d.obj);\n}\n\nvoid jsi_OBJCHK(Jsi_Obj *obj) {\n    SIGASSERTV(obj,OBJ);\n    assert(obj->ot <= JSI_OT__MAX);\n}\n#endif\n\n/*********************************************/\n\nbool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    return (v->refCnt > 1);\n}\n\nint Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    assert(v->refCnt>=0);\n    jsi_DebugValue(v,\"Incr\", jsi_DebugValueCallIdx(), interp);\n    return ++(v->refCnt);\n}\n\nint Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v) {\n    SIGASSERT(v,VALUE);\n    if (v->refCnt<=0) {\n#ifdef JSI_MEM_DEBUG\n        fprintf(stderr, \"Value decr with ref %d: VD.Idx=%d\\n\", v->refCnt, v->VD.Idx);\n#endif\n        return -2;\n    }\n    int ref;\n    jsi_DebugValue(v,\"Decr\", jsi_DebugValueCallIdx(), interp);\n    if ((ref = --(v->refCnt)) <= 0) {\n        v->refCnt = -1;\n        Jsi_ValueFree(interp, v);\n    }\n    return ref;\n}\n\nstatic Jsi_Value *ValueNew(Jsi_Interp *interp)\n{\n    interp->dbPtr->valueCnt++;\n    interp->dbPtr->valueAllocCnt++;\n    Jsi_Value *v = (Jsi_Value *)Jsi_Calloc(1,sizeof(*v));\n    SIGINIT(v,VALUE)\n    v->vt = JSI_VT_UNDEF;\n    jsi_DebugValue(v,\"New\", jsi_DebugValueCallIdx(), interp);\n    return v;\n}\n\nstatic Jsi_Value *ValueNew1(Jsi_Interp *interp)\n{\n    Jsi_Value *v = ValueNew(interp);\n    Jsi_IncrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *ValueDup(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Value *r = ValueNew1(interp);\n    Jsi_ValueCopy(interp,r, v);\n#ifdef JSI_MEM_DEBUG\n    r->VD.label2 = \"ValueDup\";\n#endif\n    return r;\n}\n#ifndef JSI_MEM_DEBUG\nJsi_Value* Jsi_ValueNew(Jsi_Interp *interp) {\n    return ValueNew(interp);\n}\nJsi_Value* Jsi_ValueNew1(Jsi_Interp *interp) {\n    return ValueNew1(interp);\n}\nJsi_Value *Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v) {\n    return ValueDup(interp, v);\n}\n#else\nstatic uint jsi_memDebugBreakIdx = 0;  // Debug memory by setting this, and adding BP on following func.\nvoid jsi_memDebugBreak() {\n}\n\n// Debugging functions: set breakpoint with \"cond B v == 0xNNN\"\nvoid jsi_DebugValue(Jsi_Value* v, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == v->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\nvoid jsi_DebugObj(Jsi_Obj* o, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == o->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\n\n\nvoid jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func)\n{\n    vd->fname = fname;\n    vd->line = line;\n    vd->func = func;\n    if (!vd->Idx)\n        vd->Idx = interp->dbPtr->memDebugCallIdx;\n    vd->hPtr = Jsi_HashSet(tbl, v, 0);\n    vd->ip = interp->curIp;\n    if (vd->ip) {\n        vd->ipLine = vd->ip->Line;\n        vd->ipOp = vd->ip->op;\n        vd->ipFname = vd->ip->fname;\n    }\n    vd->interp = interp;\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == vd->Idx)\n        jsi_memDebugBreak();\n}\n\nvoid jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2)\n{\n    if (l1)\n        vd->label = l1;\n    if (l2)\n        vd->label2 = l2;\n}\n\n\nJsi_Value * jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\nJsi_Value * jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew1(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\nJsi_Value * jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueDup(interp, ov);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\n#ifndef JSI_OMIT_STUBS\n#undef Jsi_ValueNew\n#undef Jsi_ValueNew1\nJsi_Value *Jsi_ValueNew(Jsi_Interp *interp) { return ValueNew(interp); }\nJsi_Value *Jsi_ValueNew1(Jsi_Interp *interp) { return ValueNew1(interp); }\n#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#endif\n\n#endif\n\nJsi_Hash *strDebug = NULL;\n\nstatic void ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    SIGASSERTV(v,VALUE);\n    //printf(\"FREE: %d\\n\", interp->valueCnt);\n    switch (v->vt) {\n        case JSI_VT_OBJECT:\n            Jsi_ObjDecrRefCount(interp, v->d.obj);\n            break;\n        case JSI_VT_VARIABLE:\n            assert(v->d.lval != v);\n            Jsi_DecrRefCount(interp, v->d.lval);\n            break;\n        case JSI_VT_STRING:\n            if (v->d.s.str && !v->f.bits.isstrkey) {\n                Jsi_Free(v->d.s.str);\n                /*Jsi_HashEntry *hPtr;\n                if ((hPtr = Jsi_HashEntryFind(strDebug, v->d.s.str)))\n                    Jsi_HashEntryDelete(hPtr);*/\n            }\n            break;\n        default:\n            break;\n    }\n    v->vt = JSI_VT_UNDEF;\n}\n\nvoid Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    interp->dbPtr->valueCnt--;\n    jsi_DebugValue(v, \"Free\", jsi_DebugValueCallIdx(), interp);\n    ValueFree(interp, v);\n#ifdef JSI_MEM_DEBUG\n    //if (v->VD.interp != interp)  //TODO: InterpAliasCmd leaking Values.\n     //   fprintf(stderr, \"cross interp delete: %p\\n\", v);\n    if (v->VD.hPtr && !interp->cleanup) {\n        if (!Jsi_HashEntryDelete(v->VD.hPtr))\n            fprintf(stderr, \"Value not in hash\\n\");\n    }\n    memset(v, 0, (sizeof(*v)-sizeof(v->VD)));\n#endif\n    Jsi_Free(v);\n}\n\n/* Reset a value back to undefined, releasing string/obj if necessary. */\nvoid Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = *vPtr;\n    SIGASSERTV(v,VALUE);\n    Assert(v->vt <= JSI_VT__MAX);\n    jsi_DebugValue(v, \"Reset\", jsi_DebugValueCallIdx(), interp);\n    Assert(v->refCnt>=0);\n    v->f.bits.lookupfailed = 0; // TODO: rework lookup-fail mechanism.\n    if (v->vt == JSI_VT_UNDEF)\n        return;\n    ValueFree(interp, v);\n    v->f.flag = 0;\n}\n\n// Assign value ptrs (to=from). Decr old to, and Incr from ref count.\nvoid Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )  {\n    VALCHK(from);\n    if( *to == from) return;\n    if (*to)\n        Jsi_DecrRefCount(interp, *to);\n    *to = from;\n    if (from)\n        Jsi_IncrRefCount(interp, from);\n}\n\n\nstatic void jsi_ValueCopyMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from, int isCopy )  {\n    if (!from) {\n        Jsi_ValueMakeUndef(interp, &to);\n        return;\n    }\n    VALCHK(from);\n    if( to == from) return;\n    int ocnt = to->refCnt;\n    Jsi_Value *ovt = NULL;\n    assert(ocnt>0);\n    int toVt = to->vt;\n    if (toVt == JSI_VT_VARIABLE) {\n        ovt = to->d.lval;\n        Jsi_IncrRefCount(interp, ovt);\n    }\n    Jsi_ValueMakeUndef(interp, &to);\n#ifdef JSI_MEM_DEBUG\n    memcpy(to, from, sizeof(*to)-sizeof(to->VD));\n    to->VD.label3 = from->VD.func;\n#else\n    *to = *from;\n#endif\n    if (isCopy) {\n        if (to->refCnt) {\n            switch (to->vt) {\n                case JSI_VT_STRING:\n                    if (!to->f.bits.isstrkey) {\n                        to->d.s.str = Jsi_StrdupLen(to->d.s.str, to->d.s.len);\n                    }\n                    break;\n                case JSI_VT_OBJECT:\n                    Jsi_ObjIncrRefCount(interp,to->d.obj);\n                    break;\n                case JSI_VT_VARIABLE:\n                    Jsi_IncrRefCount(interp,to->d.lval);\n                    break;\n                default:\n                    break;\n            }\n        }\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n    } else {\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n        ocnt = from->refCnt;\n#ifdef JSI_MEM_DEBUG\n        memset(from, 0, sizeof(*to)-sizeof(to->VD));\n#else\n        memset(from, 0, sizeof(*to));\n#endif\n        SIGINIT(from, VALUE);\n        from->refCnt = ocnt;\n    }\n}\n\nvoid Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from )  {\n    return jsi_ValueCopyMove(interp, to, from, 0);\n}\n\nvoid Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ) {\n    return jsi_ValueCopyMove(interp, to, from, 1);\n}\n\nvoid Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )\n{\n    if (!*to)\n        *to = Jsi_ValueNew1(interp);\n#ifdef JSI_MEM_DEBUG\n    (*to)->VD.label3 = \"ValueDup2\";\n#endif\n    Jsi_ValueCopy(interp, *to, from);\n    (*to)->f.bits.readonly = 0;\n}\n\nJsi_Value *Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val)\n{\n    Jsi_DString pStr;\n    Jsi_DSInit(&pStr);\n    Jsi_ValueGetDString(interp, val, &pStr, JSI_OUTPUT_JSON);\n    Jsi_Value *valPtr = NULL;\n    if (Jsi_JSONParse(interp, Jsi_DSValue(&pStr), &valPtr, 0) != JSI_OK)\n        Jsi_LogBug(\"bad json parse\");\n    Jsi_DSFree(&pStr);\n    return valPtr;\n}\n\n#if 0\nvoid jsi_AllValueOp(Jsi_Interp *interp, Jsi_Value* val, int op) {\n    if (op==1) {\n        //printf(\"ADD: %p : %p : %d\\n\", interp, val, val->VD.Idx);\n        assert(interp->allValues!=val);\n        val->next = interp->allValues;\n        if (interp->allValues)\n            interp->allValues->prev = val;\n        interp->allValues = val;\n        return;\n    }\n    if (op==0) {\n        //printf(\"DEL: %p : %p\\n\", interp, val);\n        if (!val || !interp->allValues) return;\n        if (val == interp->allValues)\n            interp->allValues = val->next;\n        if (val->next)\n            val->next->prev = val->prev;\n        if (val->prev)  \n            val->prev->next = val->next; \n        return;\n    }\n    if (op == -1) {\n        while (interp->allValues) {\n            printf(\"NEED CLEANUP: %p\\n\", interp->allValues);\n            Jsi_ValueFree(interp, interp->allValues);\n        }\n        return;\n    }\n#if JSI__MEMDEBUG\n    assert(0);\n    abort();\n#endif\n}\n#endif\n\nJsi_Value *Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    Jsi_Obj *obj;\n    Jsi_Value *v = NULL;\n    if (interp->subOpts.noproto && key) {\n        if (key[0] == 'p' && Jsi_Strcmp(key, \"prototype\")==0) {\n            Jsi_LogError(\"inheritance is disabled in interp\");\n            return NULL;\n        }\n    }\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return NULL;\n    }\n    obj = target->d.obj;\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (*key == '_' && Jsi_Strcmp(key, \"__proto__\")==0 && interp->noproto==0)\n        return obj->__proto__;\n#endif\n\n    if (*key == 't' && Jsi_Strcmp(key, \"this\")==0)\n        return interp->framePtr->inthis;\n    if (obj->arr)\n        v = jsi_ObjArrayLookup(interp, obj, key);\n    if (!v)\n        v= Jsi_TreeObjGetValue(obj, key, isstrkey);\n    return v;  /* TODO: redo with copy */\n}\n\nJsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}\n\n/**************************************************/\n\nJsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_BOOL)\n        *val = pv->d.val;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL)\n        *val = pv->d.obj->d.val;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\n\nbool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v)  {\n    return (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT && v->d.obj->isarrlist);\n}\n\nbool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_BOOL || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL));\n}\n\nbool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NULL);\n}\n\nbool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_UNDEF);\n}\n\nJsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_NUMBER)\n        *val = pv->d.num;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER)\n        *val = pv->d.obj->d.num;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\nbool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NUMBER || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER));\n}\n\nbool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key)\n{\n    if (key->vt == JSI_VT_STRING && key->f.bits.isstrkey)\n        return 1;\n    if (key->vt == JSI_VT_OBJECT && key->d.obj->ot == JSI_OT_STRING && key->d.obj->isstrkey)\n        return 1;\n    return 0;\n}\n\nbool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_STRING || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING));\n}\n\nbool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *v)\n{\n    int rc = (v!=NULL && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION);\n    if (!rc) return rc;\n    if (interp == v->d.obj->d.fobj->interp)\n        return 1;\n    fprintf(stderr, \"OOPS: function in wrong interp %s: %s\\n\", \n        interp->parent?\"(string came in from parent interp?)\":\"\",\n        v->d.obj->d.fobj->func->name);\n    return 0;\n}\n\nbool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype) {\n    if (!pv) return 0;\n    return pv->vt == vtype;\n}\n\nJsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv) { return pv->vt; }\n\n\nbool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype)\n{\n    if (v == NULL || v->vt != JSI_VT_OBJECT)\n        return 0;\n    if (otype != JSI_OT_ARRAY)\n        return (v->d.obj->ot == otype);\n    if (v->d.obj->ot != JSI_OT_OBJECT || !v->d.obj->isarrlist)\n        return 0;\n    return 1;\n}\n\nchar* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz)\n{\n     if (Jsi_NumberIsInteger(d)) {\n        Jsi_NumberItoA10((Jsi_Wide)d, buf, bsiz);\n    } else if (Jsi_NumberIsNormal(d)) {\n        Jsi_NumberDtoA(interp, d, buf, bsiz, 0);\n    } else if (Jsi_NumberIsNaN(d)) {\n        Jsi_Strcpy(buf, \"NaN\");\n    } else {\n        int s = Jsi_NumberIsInfinity(d);\n        if (s > 0) Jsi_Strcpy(buf,  \"Infinity\");\n        else if (s < 0) Jsi_Strcpy(buf, \"-Infinity\");\n        else {\n            buf[0] = 0;\n        }\n    }\n    return buf;\n}\n\n/* Return the string value.  Coerce value to a string type. */\nconst char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[JSI_MAX_NUMBER_STRING*2];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:\n            ntxt = \"null\";\n            break;\n        case JSI_VT_NUMBER: {\n            d = v->d.num;\nfmtnum:\n            if (Jsi_NumberIsInteger(d)) {\n                Jsi_NumberItoA10((Jsi_Wide)d, unibuf, sizeof(unibuf));\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNormal(d)) {\n                Jsi_NumberDtoA(interp, d, unibuf, sizeof(unibuf), 0);\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNaN(v->d.num)) {\n                ntxt = \"NaN\";\n            } else {\n                int s = Jsi_NumberIsInfinity(d);\n                if (s > 0) ntxt = \"Infinity\";\n                else if (s < 0) ntxt = \"-Infinity\";\n                else Jsi_LogBug(\"Ieee function got problem\");\n            }\n            break;\n        }\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_STRING:\n                    ntxt = obj->d.s.str;\n                    goto done;\n                case JSI_OT_BOOL:\n                    ntxt = obj->d.val ? \"true\":\"false\";\n                    break;\n                case JSI_OT_NUMBER:\n                    d = obj->d.num;\n                    goto fmtnum;\n                    break;\n                default:\n                    ntxt = \"[object Object]\";\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to string\", v->vt);\n            break;\n    }\n    Jsi_ValueReset(interp, &v);\n    if (!kflag) {\n        Jsi_ValueMakeStringDup(interp, &v, ntxt);\n        return Jsi_ValueString(interp, v, lenPtr);\n    }\n    \n    key = jsi_KeyFind(interp, ntxt, 0, &isKey);\n    if (key)\n        Jsi_ValueMakeStringKey(interp, &v, key);\n    else\n        Jsi_ValueMakeString(interp, &v, ntxt);\n    ntxt = v->d.s.str;\n    \ndone:\n    if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);\n    return ntxt;\n}\n\nJsi_Number Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt)\n{\n    char *endPtr = NULL, *sptr;\n    Jsi_Number a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = (Jsi_Number)(v->d.val ? 1.0: 0);\n            break;\n        case JSI_VT_NULL:\n            a = 0;\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (Jsi_Number)(obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    break;\n                case JSI_OT_STRING:\n                    sptr = obj->d.s.str;\n                    goto donum;\n                    break;\n                default:\n                    a = 0;\n                break;\n            }\n            break;\n        }\n        case JSI_VT_UNDEF:\n            a = Jsi_NumberNaN();\n            break;\n        case JSI_VT_NUMBER:\n            a = v->d.num;\n            break;\n        case JSI_VT_STRING:\n            sptr = v->d.s.str;\ndonum:\n            if (!isInt) {\n                a = strtod(sptr, &endPtr);\n                if (endPtr && *endPtr) {\n                    a = interp->NaNValue->d.num;\n                }\n            } else {\n                a = (Jsi_Number)strtol(sptr, &endPtr, 0);\n                if (!isdigit(*sptr))\n                    a = interp->NaNValue->d.num;\n            }\n            break;\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            break;\n    }\n    if (isInt && Jsi_NumberIsNormal(a))\n        a = (Jsi_Number)((int64_t)(a));\n    return a;\n}\n\nJsi_RC Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_NUMBER) return JSI_OK;\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0);\n    Jsi_ValueReset(interp, &v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    bool a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = v->d.val;\n            break;\n        case JSI_VT_NULL:\n            break;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_NUMBER:\n            a = (v->d.num ? 1: 0);\n            break;\n        case JSI_VT_STRING:     /* TODO: NaN, and accept true/false string? */\n            a = atoi(v->d.s.str);\n            a = (a ? 1 : 0);\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    a = (a ? 1 : 0);\n                    break;\n                case JSI_OT_STRING:\n                    a = atoi(obj->d.s.str);\n                    a = (a ? 1 : 0);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            return JSI_ERROR;\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeBool(interp, &v, a);\n    return rc;\n}\n\nint jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 1);\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return (int)a;\n}\n\nJsi_RC Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    if (v->vt == JSI_VT_OBJECT) return rc;\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:\n            if (interp->strict) {\n                Jsi_LogError(\"converting a undefined/null value to object\");\n                rc = JSI_ERROR;\n            }\n            o->d.num = 0;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        case JSI_VT_BOOL: {\n            o->d.val = v->d.val;\n            o->ot = JSI_OT_BOOL;\n            o->__proto__ = interp->Boolean_prototype;\n            break;\n        }\n        case JSI_VT_NUMBER: {\n            o->d.num = v->d.num;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        }\n        case JSI_VT_STRING: {\n            o->d.s = v->d.s;\n            if (!v->f.bits.isstrkey)\n                o->d.s.str = (char*)Jsi_KeyAdd(interp, v->d.s.str);\n            o->isstrkey = 1;\n            o->ot = JSI_OT_STRING;\n            o->__proto__ = interp->String_prototype;\n            break;\n        }\n        default:\n            Jsi_LogBug(\"toobject, not suppose to reach here\");\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return rc;\n}\n\n/* also toBoolean here, in ecma */\nbool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v)\n{\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:   return 0;\n        case JSI_VT_BOOL:   return v->d.val ? 1:0;\n        case JSI_VT_NUMBER: \n            if (v->d.num == 0.0 || Jsi_NumberIsNaN(v->d.num)) return 0;\n            return 1;\n        case JSI_VT_STRING: return (Jsi_ValueStrlen(v)!=0);\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *o = v->d.obj;\n            if (o->ot == JSI_OT_STRING)\n                return (Jsi_ValueStrlen(v)!=0);\n            if (o->ot == JSI_OT_NUMBER)\n                return (o->d.num != 0);\n            if (o->ot == JSI_OT_BOOL)\n                return (o->d.val != 0);\n            if (o->ot == JSI_OT_USEROBJ && o->d.uobj->interp == interp) {\n                return jsi_UserObjIsTrue(interp, o->d.uobj);\n            }\n            return 1;\n        }\n        default: Jsi_LogBug(\"TOP is type incorrect: %d\", v->vt);\n    }\n    return 0;\n}\n\nbool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_BOOL)  return v->d.val ? 0:1;\n    return 0;\n}\n\nbool Jsi_ValueIsEqual(Jsi_Interp* interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    int eq = 0;\n    if (v1->vt == JSI_VT_OBJECT && v2->vt == JSI_VT_OBJECT && v1->d.obj == v2->d.obj)\n        eq = 1;\n    else if (Jsi_ValueIsNull(interp, v1) && Jsi_ValueIsNull(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsUndef(interp, v1) && Jsi_ValueIsUndef(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsBoolean(interp, v1) && Jsi_ValueIsBoolean(interp, v2)) {\n        bool b1, b2;\n        eq = (Jsi_GetBoolFromValue(interp, v1, &b1) == JSI_OK\n            && Jsi_GetBoolFromValue(interp, v2, &b2) == JSI_OK\n            && b1 == b2);\n    } else if (Jsi_ValueIsNumber(interp, v1) && Jsi_ValueIsNumber(interp, v2)) {\n        Jsi_Number n1, n2;\n        eq = (Jsi_GetNumberFromValue(interp, v1, &n1) == JSI_OK\n            && Jsi_GetNumberFromValue(interp, v2, &n2) == JSI_OK\n            && n1 == n2);\n    } else if (Jsi_ValueIsString(interp, v1) && Jsi_ValueIsString(interp, v2)) {\n        const char *s1, *s2;\n        int l1, l2;\n        eq = (((s1=Jsi_ValueString(interp, v1, &l1)) && ((s2=Jsi_ValueString(interp, v2, &l2)))\n            && l1 == l2 && Jsi_Strcmp(s1, s2)==0));\n    }\n    return eq;\n}\n\nvoid jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr)\n{\n    Jsi_Value *v = *vPtr;\n    if (v->vt != JSI_VT_OBJECT)\n        return;\n    DECL_VALINIT(res);\n    Jsi_Value *rPtr = &res;\n    Jsi_Obj *obj = v->d.obj;\n    //rPtr = v;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp,&rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp,&rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            if (obj->isstrkey) {\n                res.d.s = obj->d.s;\n                res.f.bits.isstrkey = 1;\n                obj->d.s.str = NULL;\n            } else {\n                if (obj->refcnt==1) {\n                    Jsi_ValueMakeString(interp, &rPtr, obj->d.s.str);\n                    res.d.s = obj->d.s;\n                    obj->d.s.str = NULL;\n                } else if (obj->d.s.len >= 0) \n                {\n                    Assert(obj->refcnt>=1);\n                    obj->refcnt--;\n                    int bytes = obj->d.s.len;\n                    jsi_ValueMakeBlobDup(interp, &rPtr, (uchar*)obj->d.s.str, bytes);\n                } else\n                    Jsi_ValueMakeStringDup(interp, &rPtr, obj->d.s.str);\n            }\n            break;\n        case JSI_OT_FUNCTION: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            Jsi_FuncObjToString(interp, obj->d.fobj->func, &dStr, 3);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        case JSI_OT_USEROBJ: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            jsi_UserObjToName(interp, obj->d.uobj, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        default:\n            Jsi_ValueMakeStringKey(interp,&rPtr, \"[object Object]\");\n            break;\n    }\n    Jsi_ValueReset(interp, vPtr);\n    res.refCnt = v->refCnt;\n#ifdef JSI_MEM_DEBUG\n    memcpy(v, &res, sizeof(res)-sizeof(res.VD));\n#else\n    *v = res;\n#endif\n}\n\nstatic void jsi_ValueToPrimitiveRes(Jsi_Interp *interp, Jsi_Value *v, Jsi_Value *rPtr)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n#ifdef JSI_MEM_DEBUG\n    memcpy(rPtr, v, sizeof(*v)-sizeof(v->VD));\n#else\n    *rPtr = *v; //TODO: usde only by ValueCompare, so refCnt doesn't matter?\n#endif\n        return;\n    }\n    Jsi_Obj *obj = v->d.obj;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp, &rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp, &rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            rPtr->vt = JSI_VT_STRING;\n            rPtr->d.s = obj->d.s;\n            rPtr->f.bits.isstrkey = 1;\n            break;\n        default:\n            break;\n    }\n}\n\nint Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int flags)\n{\n    DECL_VALINIT(res1);\n    DECL_VALINIT(res2);\n    int r = 1;\n    int nocase = (flags&JSI_SORT_NOCASE), dict = ((flags & JSI_SORT_DICT));\n    if (v1 == v2)\n        return 1;\n    if (v1->vt != v2->vt) {\n        jsi_ValueToPrimitiveRes(interp, v1, &res1);\n        jsi_ValueToPrimitiveRes(interp, v2, &res2);\n        v1 = &res1;\n        v2 = &res2;\n    }\n    if (v1->vt != v2->vt) {\n        if ((flags&JSI_CMP_EXACT))\n            return 1;\n        if ((v1->vt == JSI_VT_UNDEF || v1->vt == JSI_VT_NULL) && \n            (v2->vt == JSI_VT_UNDEF || v2->vt == JSI_VT_NULL)) {\n            r = 0;\n        } else {\n            Jsi_Number n1, n2;\n            n1 = Jsi_ValueToNumberInt(interp, v1, 0);\n            n2 = Jsi_ValueToNumberInt(interp, v2, 0);\n            r = (n2 - n1);\n        }\n    } else {\n        switch (v1->vt) {\n            case JSI_VT_NUMBER:\n                if (v2->d.num == v1->d.num) return 0;\n                r = (v2->d.num < v1->d.num ? -1 : 1);\n                break;\n            case JSI_VT_BOOL:\n                r = (v2->d.val - v1->d.val);\n                break;\n            case JSI_VT_STRING:\n                r = (Jsi_StrcmpDict(v2->d.s.str, v1->d.s.str, nocase, dict));\n                break;\n            case JSI_VT_OBJECT:\n                /* TODO: refer to objects joined to each other */\n                if (v2->vt != JSI_VT_OBJECT)\n                    r = 1;\n                else if (v1->d.obj->ot == JSI_OT_STRING && v2->d.obj->ot == JSI_OT_STRING)\n                    r = (Jsi_StrcmpDict(v2->d.obj->d.s.str, v1->d.obj->d.s.str, nocase, dict));\n                else\n                    r = (v2->d.obj - v1->d.obj);\n                break;\n            case JSI_VT_UNDEF:\n            case JSI_VT_NULL:\n                r = 0;\n                break;\n            default:\n                Jsi_LogBug(\"Unexpected value type\");\n        }\n    }\n    return r;\n}\n\n/**\n * @brief Split a string.\n * @param interp \n * @param str - input string to split\n * @param split - to split on\n * @returns an array of string values\n * \n * \n */\nJsi_Value *Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton)\n{\n    char **argv; int argc;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_SplitStr(str, &argc, &argv, spliton, &dStr);\n    Jsi_Value *nret = Jsi_ValueNewArray(interp, NULL, 0);\n    Jsi_Obj *obj = nret->d.obj;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, argv[i]), i);\n    }\n    Jsi_ObjSetLength(interp, obj, argc);\n    Jsi_ValueMakeArrayObject(interp, &nret, obj);\n    Jsi_DSFree(&dStr);\n    return nret;\n}\n\nvoid jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey)\n{\n    Jsi_TreeEntry *hPtr;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return;\n    }\n    hPtr = Jsi_ObjInsert(interp, target->d.obj, key, value, (isstrkey?JSI_OM_ISSTRKEY:0));\n    if (!hPtr)\n        return;\n    hPtr->f.flags |= (flags&JSI_TREE_USERFLAG_MASK);\n}\n\nJsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    /* TODO: array[\"1\"] also extern the length of array */\n    \n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        //obj->clearProto = 1;\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *jsi_ValueLookupBase(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    if (!target)\n        return NULL;\n    if (target->vt != JSI_VT_OBJECT) {\n        Jsi_LogError(\"subscript operand is not object\");\n        return NULL;\n    }\n    const char *keyStr = Jsi_ValueToString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    bool isStrKey = (key->vt == JSI_VT_STRING && key->f.bits.isstrkey);\n    Jsi_Value *v = Jsi_ValueObjLookup(interp, target, (char*)keyStr, isStrKey);\n    if (v)\n        return v;\n    if (target->d.obj->__proto__)\n        return jsi_ValueLookupBase(interp, target->d.obj->__proto__, key, ret);\n    return NULL;\n}\n\n\nJsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    int len;\n    Jsi_ValueReset(interp, ret);\n    Jsi_Value *v = jsi_ValueLookupBase(interp, target, key, ret);\n    if (v)\n        return v;\n    const char *keyStr = Jsi_ValueString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    // Special cases such as \"length\", \"constructor\", etc...\n    if (Jsi_Strcmp(keyStr,\"length\")==0) {\n        if (Jsi_ValueIsString(interp, target)) {\n            len = Jsi_ValueStrlen(target);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->isarrlist) {\n            len = target->d.obj->arrCnt;\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n            Jsi_Func *fo = target->d.obj->d.fobj->func;\n            if (fo->type == FC_NORMAL)\n                len = fo->argnames->count;\n            else\n                len = fo->cmdSpec->maxArgs, len = (len>=0?len:fo->cmdSpec->minArgs);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->tree) {\n            len = target->d.obj->tree->numEntries;\n        } else {\n            return NULL;\n        }\n        (*ret)->vt = JSI_VT_NUMBER;\n        (*ret)->d.num = (Jsi_Number)len;\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && (interp->subOpts.noproto==0 && Jsi_Strcmp(keyStr,\"constructor\")==0)) {\n        const char *cp;\n        Jsi_Obj *o = target->d.obj->constructor;\n        if (o) {\n            if (o->ot == JSI_OT_FUNCTION) {\n                Jsi_Value *proto = Jsi_TreeObjGetValue(o, \"prototype\", 0);\n                if (proto && proto->vt == JSI_VT_OBJECT && proto->d.obj->constructor) {\n                    o = proto->d.obj->constructor;\n                }\n            }\n        } else {\n            switch(target->d.obj->ot) {\n                case JSI_OT_NUMBER:\n                    cp = \"Number\";\n                    break;\n                case JSI_OT_BOOL:\n                    cp = \"Boolean\";\n                    break;\n                case JSI_OT_STRING:\n                    cp = \"String\";\n                    break;\n                case JSI_OT_REGEXP:\n                    cp = \"RegExp\";\n                    break;\n                case JSI_OT_OBJECT:\n                    if (target->d.obj->isarrlist) {\n                        cp = \"Array\";\n                        break;\n                    }\n                    cp = \"Object\";\n                    break;\n                default:\n                    Jsi_ValueMakeUndef(interp, ret);\n                    return *ret;\n            }\n            v = Jsi_ValueObjLookup(interp, interp->csc, cp, 0);\n            if (v==NULL || v->vt != JSI_VT_OBJECT)\n                return NULL;\n            o = target->d.obj->constructor = v->d.obj;\n        }\n        Jsi_ValueMakeObject(interp, ret, o);\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n        /* Looking up something like \"String.substr\" */\n        Jsi_Func* func = target->d.obj->d.fobj->func;\n        if (func->type == FC_BUILDIN) {\n            if (func->f.bits.iscons && func->name) {\n                Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, (char*)func->name, 0);\n                if (!v) {\n                } else {\n                    bool ooo = interp->subOpts.noproto;\n                    interp->subOpts.noproto = 0;\n                    v = Jsi_ValueObjLookup(interp, v, \"prototype\", 0);\n                    interp->subOpts.noproto = ooo;\n                    \n                    if (v && ((v = Jsi_ValueObjLookup(interp, v, (char*)keyStr, 0)))) {\n                        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && Jsi_Strcmp(func->name,\"Interp\")) {\n                            Jsi_Func* sfunc = v->d.obj->d.fobj->func;\n                            /* Handle \"Math.pow(2,3)\", \"String.fromCharCode(0x21)\", ... */\n                            sfunc->callflags.bits.addargs = 1;\n                        }\n                        return v;\n                    }\n                }\n            }\n            if (Jsi_ValueIsString(interp, key)) {\n                char *kstr = Jsi_ValueString(interp, key, NULL);\n                if (!Jsi_Strcmp(kstr,\"call\") || !Jsi_Strcmp(kstr,\"apply\") || !Jsi_Strcmp(kstr,\"bind\")) {\n                    char fbuf[JSI_MAX_NUMBER_STRING];\n                    snprintf(fbuf, sizeof(fbuf), \"Function.%s\", kstr);\n                    Jsi_Value *vv = Jsi_NameLookup(interp, fbuf);\n                    if (vv)\n                        return vv;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nbool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    SIGASSERT(interp,INTERP);\n    //SIGASSERT(target,VALUE);\n    if (Jsi_TreeObjGetValue(target->d.obj, key, isstrkey))\n        return 1;\n    if (target->d.obj->__proto__ == NULL || target->d.obj->__proto__ == target)\n        return 0;\n    return Jsi_ValueKeyPresent(interp, target->d.obj->__proto__, key, isstrkey);\n}\n\nvoid jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof)\n{\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_Obj *to = target->d.obj;\n    \n    if (target->vt != JSI_VT_UNDEF && target->vt != JSI_VT_NULL) {\n\n        if (target->vt == JSI_VT_OBJECT && to->arr) {\n            io->isArrayList = 1;\n            io->count = to->arrCnt;\n        } else {\n            if (isof &&interp->strict)\n                Jsi_LogWarn(\"non-array in 'for...of'\");\n            Jsi_IterGetKeys(interp, target, io, 0);\n        }\n    }\n    io->obj = to;\n    io->isof = isof;\n    Jsi_Obj *r = Jsi_ObjNew(interp);\n    r->ot = JSI_OT_ITER;\n    r->d.iobj = io;\n    Jsi_ValueMakeObject(interp, &ret, r);\n}\n\nJsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret)\n{\n    uint i, n = 0;\n    Jsi_IterObj *io;\n    if (target->vt != JSI_VT_OBJECT)\n        return JSI_ERROR;\n    Jsi_Obj *to = target->d.obj;\n    Jsi_Obj *r = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, &ret, r);\n    if (to->arr) {\n        for (i=0; i<to->arrCnt; i++)\n            if (to->arr[i]) n++;\n        if (Jsi_ObjArraySizer(interp, r, n) <= 0) {\n            Jsi_LogError(\"too long\");\n            Jsi_ValueMakeUndef(interp, &ret);\n            return JSI_ERROR;\n        }\n        for (i=0, n=0; i<to->arrCnt; i++) {\n            if (to->arr[i]) {\n                r->arr[n] = Jsi_ValueNewNumber(interp, (Jsi_Number)i);\n                Jsi_IncrRefCount(interp, r->arr[n]);\n                n++;\n            }\n        }\n        r->arrCnt = n;\n        return JSI_OK;\n    }\n    io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, target, io, 0);\n    if (Jsi_ObjArraySizer(interp, r, io->count) <= 0) {\n        Jsi_LogError(\"too long\");\n        Jsi_ValueMakeUndef(interp, &ret);\n        return JSI_ERROR;\n    }\n    for (i=0; i<io->count; i++) {\n        r->arr[i] = (io->keys[i] ? Jsi_ValueNewStringKey(interp, io->keys[i]) : NULL);\n        Jsi_IncrRefCount(interp, r->arr[i]);\n    }\n    io->count = 0;\n    r->arrCnt = i;\n    Jsi_IterObjFree(io);\n    return JSI_OK;\n}\n\njsi_ScopeChain *jsi_ScopeChainNew(Jsi_Interp *interp, int cnt)\n{\n    jsi_ScopeChain *r = (jsi_ScopeChain *)Jsi_Calloc(1, sizeof(*r));\n    r->interp = interp;\n    SIGINIT(r,SCOPE);\n    r->chains = (Jsi_Value **)Jsi_Calloc(cnt, sizeof(r->chains[0]));\n    r->chains_cnt = cnt;\n    return r;\n}\n\nJsi_Value *jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key)\n{\n    int i;\n    Jsi_Value *ret;\n    for (i = sc->chains_cnt - 1; i >= 0; --i) {\n        if ((ret = Jsi_ValueObjLookup(sc->interp, sc->chains[i], key, 0))) {\n            return ret;\n        }\n    }\n    return NULL;\n}\n\njsi_ScopeChain *jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next)\n{\n    if (!sc) {\n        jsi_ScopeChain *nr = jsi_ScopeChainNew(interp, 1);\n        nr->chains[0] = next;\n        Jsi_IncrRefCount(interp, next);\n        nr->chains_cnt = 1;\n        return nr;\n    }\n    jsi_ScopeChain *r = jsi_ScopeChainNew(interp, sc->chains_cnt + 1);\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        r->chains[i] = sc->chains[i];\n        Jsi_IncrRefCount(interp, sc->chains[i]);\n    }\n    r->chains[i] =  next;\n    Jsi_IncrRefCount(interp, next);\n    r->chains_cnt = i + 1;\n    return r;\n}\n\nvoid jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc)\n{\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        Jsi_DecrRefCount(interp, sc->chains[i]);\n    }\n    Jsi_Free(sc->chains);\n    _JSI_MEMCLEAR(sc);\n    Jsi_Free(sc);\n}\n\nint Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v) {\n    if (Jsi_ValueIsArray(interp, v))\n        return v->d.obj->arrCnt;\n    Jsi_LogWarn(\"expected array\");\n    return 0;\n}\n\nchar *Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, index);\n    if (!arg)\n        return NULL;\n    char *res = Jsi_ValueString(interp, arg, lenPtr);\n    if (res)\n        return res;\n    res = (char*)Jsi_ValueToString(interp, arg, NULL);\n    if (res && lenPtr)\n        *lenPtr = Jsi_Strlen(res);\n    return res;\n}\n\nJsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags)\n{\n    if (target == NULL)\n        target = interp->csc;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    target->f.flag |= flags;\n    if (Jsi_ObjInsert(interp, target->d.obj, key, val, flags))\n        return JSI_OK;\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    \n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}\n\n/* OBJ INTERFACE TO BTREE */\n\nstatic void IterObjInsertKey(Jsi_IterObj *io, const char *key)\n{\n    assert(!io->isArrayList);\n    if (io->depth) {\n        uint i;\n        for (i=0; i<io->count; i++) {\n            if (!Jsi_Strcmp(key, io->keys[i]))\n                return;\n        }\n    }\n\n    if (io->count >= io->size) {\n        io->size += 10;\n        io->keys = (const char**)Jsi_Realloc(io->keys, io->size * sizeof(io->keys[0]));\n    }\n    io->keys[io->count] = key;\n    io->count++;\n}\nstatic void IterObjInsert(Jsi_IterObj *io, Jsi_TreeEntry *hPtr)\n{\n    IterObjInsertKey(io, (const char*)Jsi_TreeKeyGet(hPtr));\n}\n\nJsi_TreeEntry * Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *val, int flags)\n{\n    Jsi_TreeEntry *hPtr;\n    SIGASSERT(val, VALUE);\n    /*if (val)\n        Jsi_IncrRefCount(interp, val);*/\n    hPtr = Jsi_TreeObjSetValue(obj, key, val, (flags&JSI_OM_ISSTRKEY));\n    if ((flags&JSI_OM_DONTDEL))\n        val->f.bits.dontdel = hPtr->f.bits.dontdel = 1;\n    if ((flags&JSI_OM_READONLY))\n        val->f.bits.readonly =hPtr->f.bits.readonly = 1;\n    if ((flags&JSI_OM_DONTENUM))\n        val->f.bits.dontenum =hPtr->f.bits.dontenum = 1;\n    return hPtr;\n}\n\nstatic Jsi_RC IterGetKeysCallback(Jsi_Tree* tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_IterObj *io = (Jsi_IterObj *)data;\n    if (!hPtr->f.bits.dontenum) {\n        IterObjInsert(io, hPtr);\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth)\n{\n    if (!target) return;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"operand is not a object\");\n        return;\n    }\n    Jsi_Obj *to = target->d.obj;\n    Jsi_CmdSpec *cs = NULL;\n    if (to->ot == JSI_OT_USEROBJ) {\n        Jsi_UserObj *uobj = to->d.uobj;\n        cs = uobj->reg->spec;\n    } else if (to->ot == JSI_OT_FUNCTION) {\n        Jsi_FuncObj *fobj = to->d.fobj;\n        if (fobj->func->type == FC_BUILDIN)\n            cs = fobj->func->cmdSpec;\n    }\n    if (cs) {\n        while (cs->name) {\n            IterObjInsertKey(iterobj, cs->name);\n            cs++;\n        }\n        return;\n    }\n    iterobj->depth = depth;\n    Jsi_TreeWalk(target->d.obj->tree, IterGetKeysCallback, iterobj, 0);\n    if (target->d.obj->__proto__ && target != target->d.obj->__proto__)\n        Jsi_IterGetKeys(interp, target->d.obj->__proto__, iterobj, depth+1);\n    iterobj->depth = depth;\n}\n\nJsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_DString *dsPtr)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    Jsi_Obj *obj;\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        assert(v->vt <= JSI_VT__MAX);\n        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING\n            && v->d.obj->refcnt == 1\n        ) {\n            Jsi_ObjFromDS(dsPtr, v->d.obj);\n            return v;\n        }\n        Jsi_ValueReset(interp, &v);\n    }\n    obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ObjFromDS(dsPtr, obj);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (v && v->vt == JSI_VT_OBJECT && o == v->d.obj)\n        return v;\n    if (v)\n        Jsi_ValueReset(interp, vPtr);\n    else\n        v = Jsi_ValueNew(interp);\n    //Jsi_IncrRefCount(interp, v);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n       if (v->vt == JSI_VT_OBJECT && o == v->d.obj) {\n            if (!o->isarrlist) {\n                if (o->tree)\n                    Jsi_TreeDelete( o->tree);\n                o->tree = NULL;\n                o->__proto__ = interp->Array_prototype;\n                o->isarrlist = 1;\n            }\n            return v;\n        }\n        Jsi_ValueReset(interp, vPtr);\n    }\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    o->ot = JSI_OT_OBJECT;\n    o->__proto__ = interp->Array_prototype;\n    o->isarrlist = 1;\n    Jsi_ObjArraySizer(interp, o, 0);\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Number n) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **vPtr, int b) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = b;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = len;\n    obj->isBlob = 1;\n    return v;\n}\nJsi_Value* jsi_ValueMakeBlobDup(Jsi_Interp *interp, Jsi_Value **ret, unsigned char *s, int len) {\n    if (len<0) len = Jsi_Strlen((char*)s);\n    uchar *dp = (uchar*)Jsi_Malloc(len+1);\n    memcpy(dp, s, len);\n    dp[len] = 0;\n    return Jsi_ValueMakeBlob(interp, ret, dp, len);\n}\n\n\nJsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    return Jsi_ValueMakeBlob(interp, vPtr, (unsigned char *)s, Jsi_Strlen(s));\n}\n\nJsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        if (v->vt == JSI_VT_UNDEF) return v;\n        Jsi_ValueReset(interp, vPtr);\n    }\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len) {\n    assert(s);\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s) {\n    return Jsi_ValueNewString(interp, Jsi_Strdup(s), -1);\n}\n\nJsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\n\nJsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)s;\n    v->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, unsigned char *s, uint len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, o);\n    o->d.s.str = (char*)Jsi_Malloc(len+1);\n    memcpy(o->d.s.str, (char*)s, len);\n    o->d.s.str[len] = 0;\n    o->d.s.len = len;\n    o->isBlob = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = bval;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value *Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    int i = 0;\n    if (count<0) {\n        count = 0;\n        while (items[count])\n            count++;\n    }\n    if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {\n        Jsi_ObjFree(interp, obj);\n        return NULL;\n    }\n    for (i = 0; i < count; ++i) {\n        obj->arr[i] = Jsi_ValueNewStringDup(interp, items[i]);\n        Jsi_IncrRefCount(interp, obj->arr[i]);\n    }\n    obj->arrCnt = count;\n    assert(obj->arrCnt<=obj->arrMaxSize);\n    return Jsi_ValueMakeArrayObject(interp, NULL, obj);\n}\n\nJsi_Obj *Jsi_ValueGetObj(Jsi_Interp *interp, Jsi_Value* v)\n{\n    if (v->vt == JSI_VT_OBJECT) {\n        return v->d.obj;\n    }\n    return NULL;\n}\n\nint Jsi_ValueStrlen(Jsi_Value* v) {\n    //if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING && v->d.obj->isBlob)\n    //    return v->d.obj->d.s.len;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s == 0 || s->str == 0)\n        return 0;\n#if JSI__UTF8\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#else\n    if (s->len>=0) return s->len;\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#endif\n}\n\nchar *Jsi_ValueString(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    if (!v) return NULL;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s) {\n        if (lenPtr)\n            *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n        return s->str;\n    }\n    if (lenPtr)\n        *lenPtr = 0;\n    return NULL;\n}\n\nunsigned char *Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    return (unsigned char*)Jsi_ValueString(interp, v, lenPtr);\n}\n\nchar* Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr)\n{\n    if (!pv)\n        return NULL;\n    Jsi_String *s = jsi_ValueString(pv);\n    if (!s)\n        return NULL;\n    if (lenPtr)\n        *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n    return s->str;\n}\n\nint Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    Jsi_Value *proto, *sproto;\n    if (v1->vt != JSI_VT_OBJECT || v2->vt != JSI_VT_OBJECT  || v2->d.obj->ot != JSI_OT_FUNCTION)\n        return 0;\n    proto = Jsi_ValueObjLookup(interp, v2, \"prototype\", 0);\n    if (!proto)\n        return 0;\n    sproto = v1->d.obj->__proto__ ;\n    while (sproto) {\n        if (sproto == proto)\n            return 1;\n        if (sproto->vt != JSI_VT_OBJECT)\n            return 0;\n        sproto = sproto->d.obj->__proto__;\n    }\n    return 0;\n}\n\n\nJsi_RC jsi_InitValue(Jsi_Interp *interp, int release)\n{\n    return JSI_OK;\n}\n\nvoid  Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret)\n{\n    char *cp = NULL;\n    int len = Jsi_DSLength(dsPtr);\n    if (len && !(cp=(char*)dsPtr->strA)) \n        cp = Jsi_StrdupLen(dsPtr->Str, len);\n    dsPtr->strA = NULL;\n    dsPtr->Str[0] = 0;\n    dsPtr->len = 0;\n    dsPtr->spaceAvl = dsPtr->staticSize;\n    if (!cp)\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    else\n        Jsi_ValueMakeBlob(interp, ret, (uchar*)cp, len);\n}\n\n#endif\n", "//JSI Command Prototypes: version 3.0.6\nthrow(\"NOT EXECUTABLE: USE FILE IN GEANY EDITOR FOR CMD LINE COMPLETION + GOTO TAG\");\n\nvar Array = function(cmd,args) {};\nArray.prototype.concat = function(...):array {};\nArray.prototype.every = function(callback:function):any {};\nArray.prototype.fill = function(value:any, start:number=0, end:number=-1):array {};\nArray.prototype.filter = function(callback:function, this:object=void):array {};\nArray.prototype.find = function(callback:function):any {};\nArray.prototype.findIndex = function(callback:function):any {};\nArray.prototype.flat = function(depth:number=1):array {};\nArray.prototype.forEach = function(callback:function, this:object=void):void {};\nArray.prototype.includes = function(val:any):any {};\nArray.prototype.indexOf = function(str:any, startIdx:number=0):number {};\nArray.prototype.isArray = function():boolean {};\nArray.prototype.join = function(sep:string=''):string {};\nArray.prototype.lastIndexOf = function(val:any, start:number=0):number {};\nArray.prototype.map = function(callback:function, this:object=void):array {};\nArray.prototype.pop = function():any {};\nArray.prototype.push = function(val:any, ...):number {};\nArray.prototype.reduce = function(callback:function, initial:any):any {};\nArray.prototype.reduceRight = function(callback:function, initial:any):any {};\nArray.prototype.reverse = function():array {};\nArray.prototype.shift = function():any {};\nArray.prototype.sizeOf = function():number {};\nArray.prototype.slice = function(start:number, end:number=void):array {};\nArray.prototype.some = function(callback:function, this:object=void):boolean {};\nArray.prototype.sort = function(options:function|object=void):array {};\nArray.prototype.splice = function(start:number, howmany:number=void, ...):array {};\nArray.prototype.unshift = function(...):number {};\nvar Boolean = function(cmd,args) {};\nvar CData = function(cmd,args) {};\nCData.prototype.conf = function(options:object|string=void):any {};\nCData.prototype.get = function(key:string|number|object=null, field:string=void):any {};\nCData.prototype.incr = function(key:string|number|object|null, field:object|string, value:number=1):number {};\nCData.prototype.info = function():object {};\nCData.prototype.names = function():array {};\nCData.prototype.set = function(key:string|number|object|null, field:object|string, value:any=void):any {};\nCData.prototype.unset = function(key:string|number|object):any {};\nvar CEnum = function(cmd,args) {};\nCEnum.prototype.add = function(options:object|string, fields:array|string):any {};\nCEnum.prototype.conf = function(enum:string, options:object|string=void):any {};\nCEnum.prototype.fieldconf = function(enum:string, field:string, options:object|string=void):any {};\nCEnum.prototype.find = function(enum:string, intValue:number):string {};\nCEnum.prototype.get = function(enum:string):object {};\nCEnum.prototype.names = function(enum:string=void):array {};\nCEnum.prototype.remove = function(enum:string):any {};\nCEnum.prototype.value = function(enum:string, item:string):number {};\nvar CStruct = function(cmd,args) {};\nCStruct.prototype.add = function(options:object|string, fields:array|string):any {};\nCStruct.prototype.conf = function(struct:string, options:object|string=void):any {};\nCStruct.prototype.fieldconf = function(struct:string, field:string, options:object|string=void):any {};\nCStruct.prototype.get = function(struct, options:object=void):object {};\nCStruct.prototype.names = function(struct:string=void):array {};\nCStruct.prototype.remove = function(name:string):any {};\nCStruct.prototype.schema = function():string {};\nvar CType = function(cmd,args) {};\nCType.prototype.conf = function(typ:string, options:object|string=void):any {};\nCType.prototype.names = function(ctype=false):array {};\nvar Channel = function(cmd,args) {};\nChannel.prototype.close = function():boolean {};\nChannel.prototype.eof = function():boolean {};\nChannel.prototype.filename = function():string {};\nChannel.prototype.flush = function():number {};\nChannel.prototype.gets = function():string|void {};\nChannel.prototype.lstat = function():object {};\nChannel.prototype.mode = function():string {};\nChannel.prototype.open = function(file:string, mode:string='r'):boolean {};\nChannel.prototype.puts = function(str):boolean {};\nChannel.prototype.read = function(size:number=-1):string|void {};\nChannel.prototype.seek = function(pos:number, whence:string):number {};\nChannel.prototype.stat = function():object {};\nChannel.prototype.tell = function():number {};\nChannel.prototype.truncate = function(pos:number):number {};\nChannel.prototype.write = function(data):number {};\nvar Debugger = function(cmd,args) {};\nDebugger.prototype.add = function(val:string|number, temp:boolean=false):number {};\nDebugger.prototype.enable = function(id:number, on:boolean):void {};\nDebugger.prototype.info = function(id:number=void):array|object {};\nDebugger.prototype.remove = function(id:number):void {};\nvar Event = function(cmd,args) {};\nEvent.prototype.clearInterval = function(id:number):void {};\nEvent.prototype.info = function(id:number):object {};\nEvent.prototype.names = function():array {};\nEvent.prototype.setInterval = function(callback:function, millisecs:number):number {};\nEvent.prototype.setTimeout = function(callback:function, millisecs:number):number {};\nEvent.prototype.update = function(options:number|object=void):number {};\nvar File = function(cmd,args) {};\nFile.prototype.atime = function(file:string):number {};\nFile.prototype.chdir = function(file:string):any {};\nFile.prototype.chmod = function(file:string, mode:number):any {};\nFile.prototype.copy = function(src:string, dest:string, force:boolean=false):any {};\nFile.prototype.dirname = function(file:string):string {};\nFile.prototype.executable = function(file:string):boolean {};\nFile.prototype.exists = function(file:string):boolean {};\nFile.prototype.extension = function(file:string):string {};\nFile.prototype.glob = function(pattern:regexp|string|null='*', options:function|object|null=void):array {};\nFile.prototype.isdir = function(file:string):boolean {};\nFile.prototype.isfile = function(file:string):boolean {};\nFile.prototype.isrelative = function(file:string):boolean {};\nFile.prototype.join = function(path:string, path:string):string {};\nFile.prototype.link = function(src:string, dest:string, ishard:boolean=false):any {};\nFile.prototype.lstat = function(file:string):object {};\nFile.prototype.mkdir = function(file:string,force:boolean=false):any {};\nFile.prototype.mknod = function(file:string, mode:number, dev:number):any {};\nFile.prototype.mtime = function(file:string):number {};\nFile.prototype.owned = function(file:string):boolean {};\nFile.prototype.pwd = function():string {};\nFile.prototype.read = function(file:string, mode:string='rb'):string {};\nFile.prototype.readable = function(file:string):boolean {};\nFile.prototype.readlink = function(file:string):string {};\nFile.prototype.realpath = function(file:string):string {};\nFile.prototype.remove = function(file:string, force:boolean=false):any {};\nFile.prototype.rename = function(src:string, dest:string, force:boolean=false):any {};\nFile.prototype.rootname = function(file:string):string {};\nFile.prototype.size = function(file:string):number {};\nFile.prototype.stat = function(file:string):object {};\nFile.prototype.tail = function(file:string):string {};\nFile.prototype.tempfile = function(file:string):any {};\nFile.prototype.truncate = function(file:string, size:number):any {};\nFile.prototype.type = function(file:string):string {};\nFile.prototype.writable = function(file:string):boolean {};\nFile.prototype.write = function(file:string, str:string, mode:string='wb+'):number {};\nvar Function = function(cmd,args) {};\nFunction.prototype.apply = function(thisArg:null|object|function, args:array=void):any {};\nFunction.prototype.bind = function(thisArg:object|function=null,arg,...):any {};\nFunction.prototype.call = function(thisArg:null|object|function, arg1, ...):any {};\nvar Info = function(cmd,args) {};\nInfo.prototype.argv0 = function():string|void {};\nInfo.prototype.cmds = function(val:string|regexp='*', options:object=void):array|object {};\nInfo.prototype.completions = function(str:string, start:number=0, end:number=void):array {};\nInfo.prototype.data = function(val:string|regexp|object=void):array|object {};\nInfo.prototype.error = function():object {};\nInfo.prototype.event = function(id:number=void):array|object {};\nInfo.prototype.execZip = function():string|void {};\nInfo.prototype.executable = function():string {};\nInfo.prototype.files = function():array {};\nInfo.prototype.funcs = function(string|regexp|object=void):array|object {};\nInfo.prototype.interp = function(interp:userobj=void):object {};\nInfo.prototype.isMain = function():boolean {};\nInfo.prototype.keywords = function(isSql=false, name:string=void):boolean|array {};\nInfo.prototype.level = function(level:number=void):number|array|object {};\nInfo.prototype.locals = function(filter:boolean=void):object {};\nInfo.prototype.lookup = function(name:string):any {};\nInfo.prototype.methods = function(val:string|regexp):array|object {};\nInfo.prototype.named = function(name:string=void):array|userobj {};\nInfo.prototype.options = function(ctype:boolean=false):array {};\nInfo.prototype.package = function(pkgName:string):object|null {};\nInfo.prototype.platform = function():object {};\nInfo.prototype.script = function(func:function|regexp=void):string|array|void {};\nInfo.prototype.scriptDir = function():string|void {};\nInfo.prototype.vars = function(val:string|regexp|object=void):array|object {};\nInfo.prototype.version = function(full:boolean=false):number|object {};\nvar Interp = function(cmd,args) {};\nInterp.prototype.alias = function(name:string=void, func:function|null=void, args:array|null=void, async=false):any {};\nInterp.prototype.call = function(funcName:string, args:array, wait:boolean=false):any {};\nInterp.prototype.conf = function(options:string|object=void):any {};\nInterp.prototype.eval = function(js:string, async:boolean=false):any {};\nInterp.prototype.info = function():object {};\nInterp.prototype.source = function(file:string, async:boolean=false):any {};\nInterp.prototype.uplevel = function(js:string, level:number=0):any {};\nInterp.prototype.value = function(var:string, level:number=0):any {};\nvar JSON = function(cmd,args) {};\nJSON.prototype.check = function(str:string, strict:boolean=true):boolean {};\nJSON.prototype.parse = function(str:string, strict:boolean=true):any {};\nJSON.prototype.stringify = function(value:any,  strict:boolean=true):string {};\nvar Math = function(cmd,args) {};\nMath.prototype.abs = function(num:number):number {};\nMath.prototype.acos = function(num:number):number {};\nMath.prototype.asin = function(num:number):number {};\nMath.prototype.atan = function(num:number):number {};\nMath.prototype.atan2 = function(x:number, y:number):number {};\nMath.prototype.ceil = function(num:number):number {};\nMath.prototype.cos = function(num:number):number {};\nMath.prototype.exp = function(num:number):number {};\nMath.prototype.floor = function(num:number):number {};\nMath.prototype.log = function(num:number):number {};\nMath.prototype.max = function(x:number, y:number, ...):number {};\nMath.prototype.min = function(x:number, y:number, ...):number {};\nMath.prototype.pow = function(x:number, y:number):number {};\nMath.prototype.random = function():number {};\nMath.prototype.round = function(num:number):number {};\nMath.prototype.sin = function(num:number):number {};\nMath.prototype.sqrt = function(num:number):number {};\nMath.prototype.srand = function(seed:number):number {};\nMath.prototype.tan = function(num:number):number {};\nvar MySql = function(cmd,args) {};\nMySql.prototype.affectedRows = function():number {};\nMySql.prototype.complete = function(sql:string):boolean {};\nMySql.prototype.conf = function(options:string|object=void):any {};\nMySql.prototype.errorNo = function():number {};\nMySql.prototype.errorState = function():string {};\nMySql.prototype.eval = function(sql:string):number {};\nMySql.prototype.exists = function(sql:string):boolean {};\nMySql.prototype.info = function():object {};\nMySql.prototype.lastQuery = function():string {};\nMySql.prototype.lastRowid = function():number {};\nMySql.prototype.onecolumn = function(sql:string):any {};\nMySql.prototype.ping = function(noError:boolean=false):number {};\nMySql.prototype.query = function(sql:string, options:function|string|array|object=void):any {};\nMySql.prototype.reconnect = function():void {};\nMySql.prototype.reset = function():number {};\nvar Number = function(cmd,args) {};\nNumber.prototype.isFinite = function():boolean {};\nNumber.prototype.isInteger = function():boolean {};\nNumber.prototype.isNaN = function():boolean {};\nNumber.prototype.isSafeInteger = function():boolean {};\nNumber.prototype.toExponential = function(num:number):string {};\nNumber.prototype.toFixed = function(num:number=0):string {};\nNumber.prototype.toPrecision = function(num:number):string {};\nNumber.prototype.toString = function(radix:number=10):string {};\nvar Object = function(cmd,args) {};\nObject.prototype.create = function(proto:null|object, properties:object=void):object {};\nObject.prototype.getPrototypeOf = function(name:object|function):function|object {};\nObject.prototype.hasOwnProperty = function(name:string):boolean {};\nObject.prototype.is = function(value1, value2):boolean {};\nObject.prototype.isPrototypeOf = function(name):boolean {};\nObject.prototype.keys = function(obj:object|function=void):array {};\nObject.prototype.merge = function(obj:object|function):object {};\nObject.prototype.propertyIsEnumerable = function(name):boolean {};\nObject.prototype.setPrototypeOf = function(name:object, value:object):any {};\nObject.prototype.toLocaleString = function(quote:boolean=false):string {};\nObject.prototype.toString = function(quote:boolean=false):string {};\nObject.prototype.valueOf = function():any {};\nvar RegExp = function(cmd,args) {};\nRegExp.prototype.exec = function(val:string):array|object|null {};\nRegExp.prototype.test = function(val:string):boolean {};\nvar Signal = function(cmd,args) {};\nSignal.prototype.alarm = function(secs):number {};\nSignal.prototype.callback = function(func:function, sig:number|string):number {};\nSignal.prototype.handle = function(sig:number|string=void, ...):any {};\nSignal.prototype.ignore = function(sig:number|string=void, ...):any {};\nSignal.prototype.kill = function(pid:number, sig:number|string='SIGTERM'):void {};\nSignal.prototype.names = function():array {};\nSignal.prototype.reset = function(sig:number|string=void, ...):array {};\nvar Socket = function(cmd,args) {};\nSocket.prototype.close = function():void {};\nSocket.prototype.conf = function(options:string|object=void):any {};\nSocket.prototype.idconf = function(id:number=void, options:string|object=void):any {};\nSocket.prototype.names = function():array {};\nSocket.prototype.recv = function(id:number=void):string {};\nSocket.prototype.send = function(id:number, data:string, options:object=void):void {};\nSocket.prototype.update = function():void {};\nvar Sqlite = function(cmd,args) {};\nSqlite.prototype.backup = function(file:string, dbname:string='main'):void {};\nSqlite.prototype.collate = function(name:string, callback:function):void {};\nSqlite.prototype.complete = function(sql:string):boolean {};\nSqlite.prototype.conf = function(options:string|object=void):any {};\nSqlite.prototype.eval = function(sql:string):number {};\nSqlite.prototype.exists = function(sql:string):boolean {};\nSqlite.prototype.filename = function(name:string='main'):string {};\nSqlite.prototype.func = function(name:string, callback:function, numArgs:number=void):void {};\nSqlite.prototype.import = function(table:string, file:string, options:object=void):number {};\nSqlite.prototype.interrupt = function():void {};\nSqlite.prototype.onecolumn = function(sql:string):any {};\nSqlite.prototype.query = function(sql:string, options:function|string|array|object=void):any {};\nSqlite.prototype.restore = function(file:string, dbname:string):void {};\nSqlite.prototype.transaction = function(callback:function, type:string=void):void {};\nvar String = function(cmd,args) {};\nString.prototype.charAt = function(index:number):string {};\nString.prototype.charCodeAt = function(index:number):number {};\nString.prototype.concat = function(str:string, ...):string {};\nString.prototype.fromCharCode = function(...):string {};\nString.prototype.indexOf = function(str:string, start:number):number {};\nString.prototype.lastIndexOf = function(str:string, start:number):number {};\nString.prototype.map = function(strMap:array, nocase:boolean=false):string {};\nString.prototype.match = function(pattern:regexp|string):array|null {};\nString.prototype.repeat = function(count:number):string {};\nString.prototype.replace = function(pattern:regexp|string, replace:string|function):string {};\nString.prototype.search = function(pattern:regexp|string):number {};\nString.prototype.slice = function(start:number, end:number):string {};\nString.prototype.split = function(char:string|null=void):array {};\nString.prototype.substr = function(start:number, length:number):string {};\nString.prototype.substring = function(start:number, end:number):string {};\nString.prototype.toLocaleLowerCase = function():string {};\nString.prototype.toLocaleUpperCase = function():string {};\nString.prototype.toLowerCase = function():string {};\nString.prototype.toTitle = function(chars:string):string {};\nString.prototype.toUpperCase = function():string {};\nString.prototype.trim = function(chars:string):string {};\nString.prototype.trimLeft = function(chars:string):string {};\nString.prototype.trimRight = function(chars:string):string {};\nvar System = function(cmd,args) {};\nSystem.prototype.assert = function(expr:boolean|number|function, msg:string=void, options:object=void):void {};\nSystem.prototype.clearInterval = function(id:number):void {};\nSystem.prototype.decodeURI = function(val:string):string {};\nSystem.prototype.encodeURI = function(val:string):string {};\nSystem.prototype.exec = function(val:string, options:string|object=void):any {};\nSystem.prototype.exit = function(code:number=0):void {};\nSystem.prototype.format = function(format:string, ...):string {};\nSystem.prototype.isFinite = function(val):boolean {};\nSystem.prototype.isMain = function():boolean {};\nSystem.prototype.isNaN = function(val):boolean {};\nSystem.prototype.load = function(shlib:string):void {};\nSystem.prototype.log = function(val, ...):void {};\nSystem.prototype.matchObj = function(obj:object, match:string=void, partial=false, noerror=false):string|boolean {};\nSystem.prototype.noOp = function():any {};\nSystem.prototype.parseFloat = function(val):number {};\nSystem.prototype.parseInt = function(val:any, base:number=10):number {};\nSystem.prototype.parseOpts = function(self:object|userobj, options:object, conf:object|null|undefined):any {};\nSystem.prototype.printf = function(format:string, ...):void {};\nSystem.prototype.provide = function(name:string|function=void, version:number|string=1.0, opts:object|function=void):void {};\nSystem.prototype.puts = function(val, ...):void {};\nSystem.prototype.quote = function(val:string):string {};\nSystem.prototype.require = function(name:string=void, version:number|string=1, options:object=void):number|array|object {};\nSystem.prototype.runMain = function(cmd:string|null|function=void, conf:array=undefined):any {};\nSystem.prototype.runModule = function(cmd:string|null|function=void, conf:array=undefined):any {};\nSystem.prototype.setInterval = function(callback:function, ms:number):number {};\nSystem.prototype.setTimeout = function(callback:function, ms:number):number {};\nSystem.prototype.sleep = function(secs:number=1.0):void {};\nSystem.prototype.source = function(val:string|array, options:object=void):any {};\nSystem.prototype.strftime = function(num:number=null, options:string|object=void):string {};\nSystem.prototype.strptime = function(val:string=void, options:string|object=void):number {};\nSystem.prototype.times = function(callback:function|boolean, count:number=1):number {};\nSystem.prototype.unload = function(shlib:string):void {};\nSystem.prototype.update = function(options:number|object=void):number {};\nvar Util = function(cmd,args) {};\nUtil.prototype.argArray = function(arg:any|undefined):array|null {};\nUtil.prototype.base64 = function(val:string, decode:boolean=false):string {};\nUtil.prototype.complete = function(val:string):boolean {};\nUtil.prototype.crc32 = function(val:string, crcSeed=0):number {};\nUtil.prototype.decrypt = function(val:string, key:string):string {};\nUtil.prototype.encrypt = function(val:string, key:string):string {};\nUtil.prototype.fromCharCode = function(code:number):string {};\nUtil.prototype.getenv = function(name:string=void):string|object|void {};\nUtil.prototype.getpid = function(parent:boolean=false):number {};\nUtil.prototype.getuser = function():object {};\nUtil.prototype.hash = function(val:string, options|object=void):string {};\nUtil.prototype.hexStr = function(val:string, decode:boolean=false):string {};\nUtil.prototype.setenv = function(name:string, value:string=void):any {};\nUtil.prototype.sqlValues = function(name:string, var:object=void):any {};\nUtil.prototype.times = function(callback:function|boolean, count:number=1):number {};\nUtil.prototype.verConvert = function(ver:string|number, zeroTrim:number=0):number|string|null {};\nvar Vfs = function(cmd,args) {};\nVfs.prototype.conf = function(mount:string, string|options:object|string=void):any {};\nVfs.prototype.exec = function(cmd:string):any {};\nVfs.prototype.fileconf = function(mount:string, path:string, options:string|object=void):any {};\nVfs.prototype.list = function():array {};\nVfs.prototype.mount = function(type:string, file:string, param:object=void):string {};\nVfs.prototype.type = function(type:string=void, options:object|null=void):any {};\nVfs.prototype.unmount = function(mount:string):void {};\nVfs.prototype.vmount = function(options:object=void):string {};\nvar WebSocket = function(cmd,args) {};\nWebSocket.prototype.conf = function(options:string|object=void):any {};\nWebSocket.prototype.file = function(name:string=void):array|void {};\nWebSocket.prototype.handler = function(extension:string=void, cmd:string|function=void, flags:number=0):string|array|function|void {};\nWebSocket.prototype.header = function(id:number, name:string=void):string|array|void {};\nWebSocket.prototype.idconf = function(id:number, options:string|object=void):any {};\nWebSocket.prototype.ids = function(name:string=void):array {};\nWebSocket.prototype.query = function(id:number, name:string=void):string|object|void {};\nWebSocket.prototype.send = function(id:number, data:any):void {};\nWebSocket.prototype.status = function():object|void {};\nWebSocket.prototype.unalias = function(path:string):string|void {};\nWebSocket.prototype.update = function():void {};\nWebSocket.prototype.version = function():string {};\nvar Zvfs = function(cmd,args) {};\nZvfs.prototype.append = function(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void {};\nZvfs.prototype.create = function(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void {};\nZvfs.prototype.deflate = function(data:string):string {};\nZvfs.prototype.inflate = function(data:string):string {};\nZvfs.prototype.list = function(archive:string):array {};\nZvfs.prototype.mount = function(archive:string, mountdir:string=void):string {};\nZvfs.prototype.names = function(mountdir:string=void):array {};\nZvfs.prototype.offset = function(archive:string):number {};\nZvfs.prototype.stat = function(filename:string):object {};\nZvfs.prototype.truncate = function(archive:string, noerror:boolean=false):number {};\nZvfs.prototype.unmount = function(archive:string):void {};\nvar assert = function(expr:boolean|number|function, msg:string=void, options:object=void):void {};\nvar clearInterval = function(id:number):void {};\nvar console = function(cmd,args) {};\nconsole.prototype.assert = function(expr:boolean|number|function, msg:string=void, options:object=void):void {};\nconsole.prototype.error = function(val, ...):void {};\nconsole.prototype.input = function():string|void {};\nconsole.prototype.log = function(val, ...):void {};\nconsole.prototype.printf = function(format:string, ...):void {};\nconsole.prototype.puts = function(val, ...):void {};\nconsole.prototype.warn = function(val, ...):void {};\nvar decodeURI = function(val:string):string {};\nvar encodeURI = function(val:string):string {};\nvar exec = function(val:string, options:string|object=void):any {};\nvar exit = function(code:number=0):void {};\nvar format = function(format:string, ...):string {};\nvar isFinite = function(val):boolean {};\nvar isMain = function():boolean {};\nvar isNaN = function(val):boolean {};\nvar load = function(shlib:string):void {};\nvar log = function(val, ...):void {};\nvar matchObj = function(obj:object, match:string=void, partial=false, noerror=false):string|boolean {};\nvar noOp = function():any {};\nvar parseFloat = function(val):number {};\nvar parseInt = function(val:any, base:number=10):number {};\nvar parseOpts = function(self:object|userobj, options:object, conf:object|null|undefined):any {};\nvar printf = function(format:string, ...):void {};\nvar provide = function(name:string|function=void, version:number|string=1.0, opts:object|function=void):void {};\nvar puts = function(val, ...):void {};\nvar quote = function(val:string):string {};\nvar require = function(name:string=void, version:number|string=1, options:object=void):number|array|object {};\nvar runMain = function(cmd:string|null|function=void, conf:array=undefined):any {};\nvar runModule = function(cmd:string|null|function=void, conf:array=undefined):any {};\nvar setInterval = function(callback:function, ms:number):number {};\nvar setTimeout = function(callback:function, ms:number):number {};\nvar sleep = function(secs:number=1.0):void {};\nvar source = function(val:string|array, options:object=void):any {};\nvar strftime = function(num:number=null, options:string|object=void):string {};\nvar strptime = function(val:string=void, options:string|object=void):number {};\nvar times = function(callback:function|boolean, count:number=1):number {};\nvar unload = function(shlib:string):void {};\nvar update = function(options:number|object=void):number {};\n\n", "<title>Reference</title>\n<p>\n<div id=\"sectmenu\" data-opts=\"closed:false\"></div><B>JSI REFERENCE</B>: <a href=\"#System\">System</a> contains global methods\n(Related: [./functions.wiki|Functions], [./language.wiki|Syntax]).\n<p>\n<a name=\"TOC\"></a>\n<a href='#Array'>Array</a>\n<a href='#Boolean'>Boolean</a>\n<a href='#CData'>CData</a>\n<a href='#CEnum'>CEnum</a>\n<a href='#CStruct'>CStruct</a>\n<a href='#CType'>CType</a>\n<a href='#Channel'>Channel</a>\n<a href='#Debugger'>Debugger</a>\n<a href='#Event'>Event</a>\n<a href='#File'>File</a>\n<a href='#Function'>Function</a>\n<a href='#Info'>Info</a>\n<a href='#Interp'>Interp</a>\n<a href='#JSON'>JSON</a>\n<a href='#Math'>Math</a>\n<a href='#MySql'>MySql</a>\n<a href='#Number'>Number</a>\n<a href='#Object'>Object</a>\n<a href='#RegExp'>RegExp</a>\n<a href='#Signal'>Signal</a>\n<a href='#Socket'>Socket</a>\n<a href='#Sqlite'>Sqlite</a>\n<a href='#String'>String</a>\n<a href='#System'>System</a>\n<a href='#Util'>Util</a>\n<a href='#Vfs'>Vfs</a>\n<a href='#WebSocket'>WebSocket</a>\n<a href='#Zvfs'>Zvfs</a>\n<a href='#console'>console</a>\n<nowiki>\n<a name=\"Array\"></a>\n\n<hr>\n\n\n<h1>Array</h1>\n\n<font color=red>Synopsis:new Array(...):array\n\n</font><p>Provide access to array objects.\n\n\n<h2>Methods for \"Array\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Array</td><td>new Array(...):array </td><td>jsi_Array constructor.</td></tr>\n<tr><td>concat</td><td>concat(...):array </td><td>Return array with args appended.</td></tr>\n<tr><td>every</td><td>every(callback:function) </td><td>Returns true if every value in array satisfies the test.</td></tr>\n<tr><td>fill</td><td>fill(value:any, start:number=0, end:number=-1):array </td><td>Fill an array with values.</td></tr>\n<tr><td>filter</td><td>filter(callback:function, this:object=void):array </td><td>Return a filtered array.</td></tr>\n<tr><td>find</td><td>find(callback:function) </td><td>Returns the value of the first element in the array that satisfies the test.</td></tr>\n<tr><td>findIndex</td><td>findIndex(callback:function) </td><td>Returns the index of the first element in the array that satisfies the test.</td></tr>\n<tr><td>flat</td><td>flat(depth:number=1):array </td><td>Flatten an arra.</td></tr>\n<tr><td>forEach</td><td>forEach(callback:function, this:object=void):void </td><td>Invoke function with each item in object.</td></tr>\n<tr><td>includes</td><td>includes(val:any) </td><td>Returns true if array contains value.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:any, startIdx:number=0):number </td><td>Return index of first occurrance in array.</td></tr>\n<tr><td>isArray</td><td>isArray():boolean </td><td>True if val array.</td></tr>\n<tr><td>join</td><td>join(sep:string=''):string </td><td>Return elements joined by char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(val:any, start:number=0):number </td><td>Return index of last occurence in array.</td></tr>\n<tr><td>map</td><td>map(callback:function, this:object=void):array </td><td>Creates a new array with the results of calling a provided function on every element in this array.</td></tr>\n<tr><td>pop</td><td>pop() </td><td>Remove and return last element of array.</td></tr>\n<tr><td>push</td><td>push(val:any, ...):number </td><td>Push one or more elements onto array and return size.</td></tr>\n<tr><td>reduce</td><td>reduce(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reduceRight</td><td>reduceRight(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reverse</td><td>reverse():array </td><td>Reverse order of all elements in an array.</td></tr>\n<tr><td>shift</td><td>shift() </td><td>Remove first element and shift downwards.</td></tr>\n<tr><td>sizeOf</td><td>sizeOf():number </td><td>Return size of array.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number=void):array </td><td>Return sub-array.</td></tr>\n<tr><td>some</td><td>some(callback:function, this:object=void):boolean </td><td>Return true if function returns true some element.</td></tr>\n<tr><td>sort</td><td>sort(<a href='#Array.sortOptions'>options</a>:function|object=void):array </td><td>Sort an array.</td></tr>\n<tr><td>splice</td><td>splice(start:number, howmany:number=void, ...):array </td><td>Change the content of an array, adding new elements while removing old elements.</td></tr>\n<tr><td>unshift</td><td>unshift(...):number </td><td>Add new elements to start of array and return size.</td></tr>\n</table>\n\n\n<a name=\"Array.sortOptions\"></a>\n<a name=\"Array.confOptions\"></a>\n<h2>Options for \"Array.sort\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Mode to sort by. (one of: <b>default</b>, <b>desc</b>, <b>dict</b>, <b>nocase</b>)</td><td><i></i></td></tr>\n<tr><td>compare</td><td><i>FUNC</i></td><td>Function to do comparison. @function(val1,val2)</td><td><i></i></td></tr>\n<tr><td>unique</td><td><i>BOOL</i></td><td>Eliminate duplicate items.</td><td><i></i></td></tr>\n</table>\n<a name=\"Arrayend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Boolean\"></a>\n\n<hr>\n\n\n<h1>Boolean</h1>\n\n<font color=red>Synopsis:new Boolean(bool:boolean=false):boolean\n\n</font><p>A Boolean object.\n\n\n<h2>Methods for \"Boolean\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Boolean</td><td>new Boolean(bool:boolean=false):boolean </td><td>Boolean constructor.</td></tr>\n</table>\n<a name=\"Booleanend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CData\"></a>\n\n<hr>\n\n\n<h1>CData</h1>\n\n<font color=red>Synopsis:new CData(options:string&verbar;object=void, inits:object=undefined):userobj\n\n</font><p>\n<h2>Methods for \"CData\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>CData</td><td>new CData(<a href='#new CDataOptions'>options</a>:string|object=void, inits:object=undefined):userobj </td><td>Create a new struct or map/array of structs.The 2nd arg is used for function option parsing and will report errors at the callers file:line</td></tr>\n<tr><td>conf</td><td>conf(<a href='#CData.confOptions'>options</a>:object|string=void) </td><td>Configure options for c-data.</td></tr>\n<tr><td>get</td><td>get(key:string|number|object=null, field:string=void) </td><td>Get struct/map/array value.</td></tr>\n<tr><td>incr</td><td>incr(key:string|number|object|null, field:object|string, value:number=1):number </td><td>Increment a numeric field: returns the new value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info for data.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return keys for map.</td></tr>\n<tr><td>set</td><td>set(key:string|number|object|null, field:object|string, value:any=void) </td><td>Set a struct/map/array value.</td></tr>\n<tr><td>unset</td><td>unset(key:string|number|object) </td><td>Remove entry from map/array.</td></tr>\n</table>\n\n\n<a name=\"new CDataOptions\"></a>\n<a name=\"CData.confOptions\"></a>\n<h2>Options for \"new CData\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>If an array, its size in elements.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>UINT</i></td><td>Flags.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of data.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyName</td><td><i>STRKEY</i></td><td>Key struct, for key struct maps.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyType</td><td><i>STRKEY</i></td><td>Key id. (one of: <b>string</b>, <b>strkey</b>, <b>number</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>mapType</td><td><i>STRKEY</i></td><td>If a map, its type. (one of: <b>none</b>, <b>hash</b>, <b>tree</b>, <b>list</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>maxSize</td><td><i>UINT</i></td><td>Limit the array size or number of keys in a map.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name (eg. of var assigned to on create).</td><td><i>initOnly</i></td></tr>\n<tr><td>noAuto</td><td><i>BOOL</i></td><td>Disable auto-create of map keys in set/incr.</td><td><i></i></td></tr>\n<tr><td>structName</td><td><i>STRKEY</i></td><td>Struct used for storing data.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>varParam</td><td><i>STRKEY</i></td><td>Param for maps/array vars.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CDataend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CEnum\"></a>\n\n<hr>\n\n\n<h1>CEnum</h1>\n\n<font color=red>Synopsis:CEnum.method(...)\n\n</font><p>Enum commands. Note: Enum() is a shortcut for Enum.add().\n\n\n<h2>Methods for \"CEnum\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CEnum.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a new enum: value of items same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(enum:string, <a href='#CEnum.confOptions'>options</a>:object|string=void) </td><td>Configure options for enum.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(enum:string, field:string, <a href='#CEnum.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>find</td><td>find(enum:string, intValue:number):string </td><td>Find item with given value in enum.</td></tr>\n<tr><td>get</td><td>get(enum:string):object </td><td>Return enum definition.</td></tr>\n<tr><td>names</td><td>names(enum:string=void):array </td><td>Return name list of all enums, or items within one enum.</td></tr>\n<tr><td>remove</td><td>remove(enum:string) </td><td>Remove an enum.</td></tr>\n<tr><td>value</td><td>value(enum:string, item:string):number </td><td>Return value for given enum item.</td></tr>\n</table>\n\n\n<a name=\"CEnum.addOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.confOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.fieldconfOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Desciption of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Value for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Index of item in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"CEnumend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CStruct\"></a>\n\n<hr>\n\n\n<h1>CStruct</h1>\n\n<font color=red>Synopsis:CStruct.method(...)\n\n</font><p>Struct commands. Note: Struct() is a shortcut for Struct.add().\n\n\n<h2>Methods for \"CStruct\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CStruct.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a struct: field values same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(struct:string, <a href='#CStruct.confOptions'>options</a>:object|string=void) </td><td>Configure options for struct.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(struct:string, field:string, <a href='#CStruct.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>get</td><td>get(struct, options:object=void):object </td><td>Return the struct definition.</td></tr>\n<tr><td>names</td><td>names(struct:string=void):array </td><td>Return name list of all structs, or fields for one struct.</td></tr>\n<tr><td>remove</td><td>remove(name:string) </td><td>Remove a struct.</td></tr>\n<tr><td>schema</td><td>schema():string </td><td>Return database schema for struct.</td></tr>\n</table>\n\n\n<a name=\"CStruct.addOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.confOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.fieldconfOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>Size of field if an array.</td><td><i>initOnly</i></td></tr>\n<tr><td>bits</td><td><i>UINT32</i></td><td>Size of bitfield.</td><td><i>initOnly</i></td></tr>\n<tr><td>boffset</td><td><i>UINT32</i></td><td>Bit offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Index of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Field description.</td><td><i>initOnly</i></td></tr>\n<tr><td>info</td><td><i>STRKEY</i></td><td>Info for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>offset</td><td><i>UINT</i></td><td>Offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>type</td><td><i>CUSTOM</i></td><td>Type of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>init</td><td><i>CUSTOM</i></td><td>Initial value for field.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CStructend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CType\"></a>\n\n<hr>\n\n\n<h1>CType</h1>\n\n<font color=red>Synopsis:CType.method(...)\n\n</font><p>Type commands. Note: Type() is a shortcut for Type.conf().\n\n\n<h2>Methods for \"CType\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(typ:string, <a href='#CType.confOptions'>options</a>:object|string=void) </td><td>Configure options for type.</td></tr>\n<tr><td>names</td><td>names(ctype=false):array </td><td>Return type names.</td></tr>\n</table>\n\n\n<a name=\"CType.confOptions\"></a>\n<a name=\"CType.confOptions\"></a>\n<h2>Options for \"CType.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>idName</td><td><i>STRKEY</i></td><td>The id name: usually upcased cName.</td><td><i>initOnly</i></td></tr>\n<tr><td>cName</td><td><i>STRKEY</i></td><td>C type name.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of id.</td><td><i>initOnly</i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>xfmt</td><td><i>STRKEY</i></td><td>Hex printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>size</td><td><i>INT</i></td><td>Size for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n<a name=\"CTypeend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Channel\"></a>\n\n<hr>\n\n\n<h1>Channel</h1>\n\n<font color=red>Synopsis:new Channel(file:string, mode:string='r'):userobj\n\n</font><p>Commands for accessing Channel objects for file IO.\n\n\n<h2>Methods for \"Channel\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Channel</td><td>new Channel(file:string, mode:string='r'):userobj </td><td>A file input/output object. The mode string is r or w and an optional +.</td></tr>\n<tr><td>close</td><td>close():boolean </td><td>Close the file.</td></tr>\n<tr><td>eof</td><td>eof():boolean </td><td>Return true if read to end-of-file.</td></tr>\n<tr><td>filename</td><td>filename():string </td><td>Get file name.</td></tr>\n<tr><td>flush</td><td>flush():number </td><td>Flush file output.</td></tr>\n<tr><td>gets</td><td>gets():string|void </td><td>Get one line of input.</td></tr>\n<tr><td>lstat</td><td>lstat():object </td><td>Return status for file.</td></tr>\n<tr><td>mode</td><td>mode():string </td><td>Get file mode used with open.</td></tr>\n<tr><td>open</td><td>open(file:string, mode:string='r'):boolean </td><td>Open the file (after close).</td></tr>\n<tr><td>puts</td><td>puts(str):boolean </td><td>Write one line of output.</td></tr>\n<tr><td>read</td><td>read(size:number=-1):string|void </td><td>Read some or all of file.</td></tr>\n<tr><td>seek</td><td>seek(pos:number, whence:string):number </td><td>Seek to position. Return 0 if ok.</td></tr>\n<tr><td>stat</td><td>stat():object </td><td>Return status for file.</td></tr>\n<tr><td>tell</td><td>tell():number </td><td>Return current position.</td></tr>\n<tr><td>truncate</td><td>truncate(pos:number):number </td><td>Truncate file.</td></tr>\n<tr><td>write</td><td>write(data):number </td><td>Write data to file.</td></tr>\n</table>\n<a name=\"Channelend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Debugger\"></a>\n\n<hr>\n\n\n<h1>Debugger</h1>\n\n<font color=red>Synopsis:Debugger.method(...)\n\n</font><p>Debugger breakpoint management.\n\n\n<h2>Methods for \"Debugger\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(val:string|number, temp:boolean=false):number </td><td>Add a breakpoint for line, file:line or func.</td></tr>\n<tr><td>enable</td><td>enable(id:number, on:boolean):void </td><td>Enable/disable breakpoint.</td></tr>\n<tr><td>info</td><td>info(id:number=void):array|object </td><td>Return info about one breakpoint, or list of bp numbers.</td></tr>\n<tr><td>remove</td><td>remove(id:number):void </td><td>Remove breakpoint.</td></tr>\n</table>\n<a name=\"Debuggerend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Event\"></a>\n\n<hr>\n\n\n<h1>Event</h1>\n\n<font color=red>Synopsis:Event.method(...)\n\n</font><p>Event management.\n\n\n<h2>Methods for \"Event\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete an event (created with setInterval/setTimeout).</td></tr>\n<tr><td>info</td><td>info(id:number):object </td><td>Return info for the given event id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list event ids (created with setTimeout/setInterval).</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, millisecs:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, millisecs:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>update</td><td>update(<a href='#Event.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"Event.updateOptions\"></a>\n<a name=\"Event.confOptions\"></a>\n<h2>Options for \"Event.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Eventend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"File\"></a>\n\n<hr>\n\n\n<h1>File</h1>\n\n<font color=red>Synopsis:File.method(...)\n\n</font><p>Commands for accessing the filesystem.\n\n\n<h2>Methods for \"File\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>atime</td><td>atime(file:string):number </td><td>Return file Jsi_Access time.</td></tr>\n<tr><td>chdir</td><td>chdir(file:string) </td><td>Change current directory.</td></tr>\n<tr><td>chmod</td><td>chmod(file:string, mode:number) </td><td>Set file permissions.</td></tr>\n<tr><td>copy</td><td>copy(src:string, dest:string, force:boolean=false) </td><td>Copy a file to destination. Directories are not handled.\nThe third argument if given is a boolean force value which if true allows overwrite of an existing file. </td></tr>\n<tr><td>dirname</td><td>dirname(file:string):string </td><td>Return directory path.</td></tr>\n<tr><td>executable</td><td>executable(file:string):boolean </td><td>Return true if file is executable.</td></tr>\n<tr><td>exists</td><td>exists(file:string):boolean </td><td>Return true if file exists.</td></tr>\n<tr><td>extension</td><td>extension(file:string):string </td><td>Return file extension.</td></tr>\n<tr><td>glob</td><td>glob(pattern:regexp|string|null='*', <a href='#File.globOptions'>options</a>:function|object|null=void):array </td><td>Return list of files in dir with optional pattern match. With no arguments (or null) returns all files/directories in current directory.\nThe first argument can be a pattern (either a glob or regexp) of the files to return.\nWhen the second argument is a function, it is called with each path, and filter on false.\nOtherwise second argument must be a set of options.</td></tr>\n<tr><td>isdir</td><td>isdir(file:string):boolean </td><td>Return true if file is a directory.</td></tr>\n<tr><td>isfile</td><td>isfile(file:string):boolean </td><td>Return true if file is a normal file.</td></tr>\n<tr><td>isrelative</td><td>isrelative(file:string):boolean </td><td>Return true if file path is relative.</td></tr>\n<tr><td>join</td><td>join(path:string, path:string):string </td><td>Join two file realpaths, or just second if an absolute path.</td></tr>\n<tr><td>link</td><td>link(src:string, dest:string, ishard:boolean=false) </td><td>Link a file. The second argument is the destination file to be created. If a third bool argument is true, a hard link is created.</td></tr>\n<tr><td>lstat</td><td>lstat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>mkdir</td><td>mkdir(file:string,force:boolean=false) </td><td>Create a directory: force creates subdirs.</td></tr>\n<tr><td>mknod</td><td>mknod(file:string, mode:number, dev:number) </td><td>Create unix device file using mknod.</td></tr>\n<tr><td>mtime</td><td>mtime(file:string):number </td><td>Return file modified time.</td></tr>\n<tr><td>owned</td><td>owned(file:string):boolean </td><td>Return true if file is owned by user.</td></tr>\n<tr><td>pwd</td><td>pwd():string </td><td>Return current directory.</td></tr>\n<tr><td>read</td><td>read(file:string, mode:string='rb'):string </td><td>Read a file.</td></tr>\n<tr><td>readable</td><td>readable(file:string):boolean </td><td>Return true if file is readable.</td></tr>\n<tr><td>readlink</td><td>readlink(file:string):string </td><td>Read file link destination.</td></tr>\n<tr><td>realpath</td><td>realpath(file:string):string </td><td>Return absolute file name minus .., ./ etc.</td></tr>\n<tr><td>remove</td><td>remove(file:string, force:boolean=false) </td><td>Delete a file or direcotry.</td></tr>\n<tr><td>rename</td><td>rename(src:string, dest:string, force:boolean=false) </td><td>Rename a file, with possible overwrite.</td></tr>\n<tr><td>rootname</td><td>rootname(file:string):string </td><td>Return file name minus extension.</td></tr>\n<tr><td>size</td><td>size(file:string):number </td><td>Return size for file.</td></tr>\n<tr><td>stat</td><td>stat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>tail</td><td>tail(file:string):string </td><td>Return file name minus dirname.</td></tr>\n<tr><td>tempfile</td><td>tempfile(file:string) </td><td>Create a temp file.</td></tr>\n<tr><td>truncate</td><td>truncate(file:string, size:number) </td><td>Truncate file.</td></tr>\n<tr><td>type</td><td>type(file:string):string </td><td>Return type of file.</td></tr>\n<tr><td>writable</td><td>writable(file:string):boolean </td><td>Return true if file is writable.</td></tr>\n<tr><td>write</td><td>write(file:string, str:string, mode:string='wb+'):number </td><td>Write a file.</td></tr>\n</table>\n\n\n<a name=\"File.globOptions\"></a>\n<a name=\"File.confOptions\"></a>\n<h2>Options for \"File.glob\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>dir</td><td><i>STRING</i></td><td>The start directory: this path will not be prepended to results.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Maximum directory depth to recurse into.</td><td><i></i></td></tr>\n<tr><td>maxDiscard</td><td><i>INT</i></td><td>Maximum number of items to discard before giving up.</td><td><i></i></td></tr>\n<tr><td>dirFilter</td><td><i>FUNC</i></td><td>Filter function for directories, returning false to discard. @function(dir:string)</td><td><i></i></td></tr>\n<tr><td>filter</td><td><i>FUNC</i></td><td>Filter function to call with each file, returning false to discard. @function(file:string)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>The maximum number of results to return/count: -1 is unlimited (Interp.maxArrayList).</td><td><i></i></td></tr>\n<tr><td>noTypes</td><td><i>STRKEY</i></td><td>Filter files to exclude these \"types\".</td><td><i></i></td></tr>\n<tr><td>prefix</td><td><i>STRKEY</i></td><td>String prefix to prepend to each file in result list.</td><td><i></i></td></tr>\n<tr><td>recurse</td><td><i>BOOL</i></td><td>Recurse into sub-directories.</td><td><i></i></td></tr>\n<tr><td>retCount</td><td><i>BOOL</i></td><td>Return only the count of matches.</td><td><i></i></td></tr>\n<tr><td>tails</td><td><i>BOOL</i></td><td>Returned only tail of path.</td><td><i></i></td></tr>\n<tr><td>types</td><td><i>STRKEY</i></td><td>Filter files to include type: one or more of chars 'fdlpsbc' for file, directory, link, etc.</td><td><i></i></td></tr>\n</table>\n<a name=\"Fileend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Function\"></a>\n\n<hr>\n\n\n<h1>Function</h1>\n\n<font color=red>Synopsis:new Function():function\n\n</font><p>Commands for accessing functions.\n\n\n<h2>Methods for \"Function\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Function</td><td>new Function():function </td><td>Function constructor (unimplemented).</td></tr>\n<tr><td>apply</td><td>apply(thisArg:null|object|function, args:array=void) </td><td>Call function passing args array.</td></tr>\n<tr><td>bind</td><td>bind(thisArg:object|function=null,arg,...) </td><td>Return function that calls bound function prepended with thisArg+arguments.</td></tr>\n<tr><td>call</td><td>call(thisArg:null|object|function, arg1, ...) </td><td>Call function with args.</td></tr>\n</table>\n<a name=\"Functionend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Info\"></a>\n\n<hr>\n\n\n<h1>Info</h1>\n\n<font color=red>Synopsis:Info.method(...)\n\n</font><p>Commands for inspecting internal state information in JSI.\n\n\n<h2>Methods for \"Info\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argv0</td><td>argv0():string|void </td><td>Return initial start script file name.</td></tr>\n<tr><td>cmds</td><td>cmds(val:string|regexp='*', <a href='#Info.cmdsOptions'>options</a>:object=void):array|object </td><td>Return details or list of matching commands.</td></tr>\n<tr><td>completions</td><td>completions(str:string, start:number=0, end:number=void):array </td><td>Return command completions on portion of string from start to end.</td></tr>\n<tr><td>data</td><td>data(val:string|regexp|object=void):array|object </td><td>Return list of matching data (non-functions). Like info.vars(), but does not return function values.</td></tr>\n<tr><td>error</td><td>error():object </td><td>Return file and line number of error (used inside catch).</td></tr>\n<tr><td>event</td><td>event(id:number=void):array|object </td><td>List events or info for 1 event (setTimeout/setInterval). With no args, returns list of all outstanding events.  With one arg, returns infofor the given event id.</td></tr>\n<tr><td>execZip</td><td>execZip():string|void </td><td>If executing a .zip file, return file name.</td></tr>\n<tr><td>executable</td><td>executable():string </td><td>Return name of executable.</td></tr>\n<tr><td>files</td><td>files():array </td><td>Return list of all sourced files.</td></tr>\n<tr><td>funcs</td><td>funcs(string|regexp|object=void):array|object </td><td>Return details or list of matching functions.</td></tr>\n<tr><td>interp</td><td>interp(interp:userobj=void):object </td><td>Return info on given or current interp.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>keywords</td><td>keywords(isSql=false, name:string=void):boolean|array </td><td>Return/lookup reserved keyword.</td></tr>\n<tr><td>level</td><td>level(level:number=void):number|array|object </td><td>Return current level or details of a call-stack frame. With no arg, returns the number of the current stack frame level.\nOtherwise returns details on the specified level.\nThe topmost level is 1, and 0 is the current level, and a negative level translates as relative to the current level.</td></tr>\n<tr><td>locals</td><td>locals(filter:boolean=void):object </td><td>Return locals; use filter=true/false just vars/functions.</td></tr>\n<tr><td>lookup</td><td>lookup(name:string) </td><td>Given string name, lookup and return value, eg: function.</td></tr>\n<tr><td>methods</td><td>methods(val:string|regexp):array|object </td><td>Return functions and commands.</td></tr>\n<tr><td>named</td><td>named(name:string=void):array|userobj </td><td>Returns command names for builtin Objects, eg: 'File', 'Interp', sub-Object names, or the named object.</td></tr>\n<tr><td>options</td><td>options(ctype:boolean=false):array </td><td>Return Option type name, or with true the C type.</td></tr>\n<tr><td>package</td><td>package(pkgName:string):object|null </td><td>Return info about provided package if exists, else null.</td></tr>\n<tr><td>platform</td><td>platform():object </td><td>N/A. Returns general platform information for JSI.</td></tr>\n<tr><td>script</td><td>script(func:function|regexp=void):string|array|void </td><td>Get current script file name, or file containing function.</td></tr>\n<tr><td>scriptDir</td><td>scriptDir():string|void </td><td>Get directory of current script.</td></tr>\n<tr><td>vars</td><td>vars(val:string|regexp|object=void):array|object </td><td>Return details or list of matching variables. Returns all values, data or function.</td></tr>\n<tr><td>version</td><td>version(full:boolean=false):number|object </td><td>JSI version: returns object when full=true.</td></tr>\n</table>\n\n\n<a name=\"Info.cmdsOptions\"></a>\n<a name=\"Info.confOptions\"></a>\n<h2>Options for \"Info.cmds\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Return full path.</td><td><i></i></td></tr>\n<tr><td>constructor</td><td><i>BOOL</i></td><td>Do not exclude constructor.</td><td><i></i></td></tr>\n</table>\n<a name=\"Infoend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Interp\"></a>\n\n<hr>\n\n\n<h1>Interp</h1>\n\n<font color=red>Synopsis:new Interp(options:object=void):userobj\n\n</font><p>Commands for accessing interps.\n\n\n<h2>Methods for \"Interp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Interp</td><td>new Interp(<a href='#new InterpOptions'>options</a>:object=void):userobj </td><td>Create a new interp.</td></tr>\n<tr><td>alias</td><td>alias(name:string=void, func:function|null=void, args:array|null=void, async=false) </td><td>Set/get global alias bindings for command in an interp. With 0 args, returns list of all aliases in interp.\nWith 1 arg returns func for given alias name.\nWith 2 args where arg2 == null, returns args for given alias name .\nWith 3 args, create/update an alias for func and args. \nDelete an alias by creating it with null for both func and args.</td></tr>\n<tr><td>call</td><td>call(funcName:string, args:array, wait:boolean=false) </td><td>Call named function in subinterp. Invoke function in sub-interp with arguments.\nSince interps are not allowed to share objects, data is automatically cleansed by encoding/decoding to/from JSON if required.\nUnless an 'async' parameter is true call is acyncronous.\nOtherwise waits until the sub-interp is idle, to make call and return result.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Interp.confOptions'>options</a>:string|object=void) </td><td>Configure option(s).</td></tr>\n<tr><td>eval</td><td>eval(js:string, async:boolean=false) </td><td>Interpret script within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Returns internal statistics about interp.</td></tr>\n<tr><td>source</td><td>source(file:string, async:boolean=false) </td><td>Interpret file within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>uplevel</td><td>uplevel(js:string, level:number=0) </td><td>Interpret code at the given stack level. The level argument is as returned by Info.level().  Not supported with threads.</td></tr>\n<tr><td>value</td><td>value(var:string, level:number=0) </td><td>Lookup value of variable at stack level.</td></tr>\n</table>\n\n\n<a name=\"new InterpOptions\"></a>\n<a name=\"Interp.confOptions\"></a>\n<h2>Options for \"new Interp\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>args</td><td><i>ARRAY</i></td><td>The console.arguments for interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>asserts</td><td><i>BOOL</i></td><td>Enable assert.</td><td><i></i></td></tr>\n<tr><td>assertMode</td><td><i>STRKEY</i></td><td>Action upon assert failure. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>autoFiles</td><td><i>ARRAY</i></td><td>File(s) to source for loading Jsi_Auto to handle unknown commands.</td><td><i></i></td></tr>\n<tr><td>busyCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp (or noOp) to periodically call.</td><td><i></i></td></tr>\n<tr><td>busyInterval</td><td><i>INT</i></td><td>Call busyCallback command after this many op-code evals (100000).</td><td><i></i></td></tr>\n<tr><td>confFile</td><td><i>STRKEY</i></td><td>Config file of options in non-strict JSON form.</td><td><i>initOnly</i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>debugOpts</td><td><i><a href='#debugOptsOptions'>options</a></i></td><td>Options for debugging.</td><td><i></i></td></tr>\n<tr><td>interactive</td><td><i>BOOL</i></td><td>Force interactive mode. ie. ignore no_interactive flag.</td><td><i>initOnly</i></td></tr>\n<tr><td>hasOpenSSL</td><td><i>BOOL</i></td><td>Is SSL available in WebSocket.</td><td><i>initOnly</i></td></tr>\n<tr><td>historyFile</td><td><i>STRKEY</i></td><td>In interactive mode, file to use for history (~/.jsish_history).</td><td><i>initOnly</i></td></tr>\n<tr><td>isSafe</td><td><i>BOOL</i></td><td>Is this a safe interp (ie. with limited or no file access).</td><td><i>initOnly</i></td></tr>\n<tr><td>jsppChars</td><td><i>STRKEY</i></td><td>Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string.</td><td><i></i></td></tr>\n<tr><td>jsppCallback</td><td><i>FUNC</i></td><td>Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number).</td><td><i></i></td></tr>\n<tr><td>lockTimeout</td><td><i>INT</i></td><td>Thread time-out for mutex lock acquires (milliseconds).</td><td><i></i></td></tr>\n<tr><td>logOpts</td><td><i><a href='#logOptsOptions'>options</a></i></td><td>Options for log output to add file/line/time.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Depth limit of recursive function calls (1000).</td><td><i></i></td></tr>\n<tr><td>maxArrayList</td><td><i>INT</i></td><td>Maximum array convertable to list (100000).</td><td><i></i></td></tr>\n<tr><td>maxIncDepth</td><td><i>INT</i></td><td>Maximum allowed source/require nesting depth (50).</td><td><i></i></td></tr>\n<tr><td>maxInterpDepth</td><td><i>INT</i></td><td>Maximum nested subinterp create depth (10).</td><td><i></i></td></tr>\n<tr><td>maxUserObjs</td><td><i>INT</i></td><td>Maximum number of 'new' object calls, eg. File, RegExp, etc.</td><td><i></i></td></tr>\n<tr><td>maxOpCnt</td><td><i>INT</i></td><td>Execution limit for op-code evaluation.</td><td><i>initOnly</i></td></tr>\n<tr><td>memDebug</td><td><i>INT</i></td><td>Memory debugging level: 1=summary, 2=detail.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Optional text name for this interp.</td><td><i></i></td></tr>\n<tr><td>noAutoLoad</td><td><i>BOOL</i></td><td>Disable autoload.</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Interp.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noInput</td><td><i>BOOL</i></td><td>Disable use of console.input().</td><td><i></i></td></tr>\n<tr><td>noLoad</td><td><i>BOOL</i></td><td>Disable load of shared libs.</td><td><i></i></td></tr>\n<tr><td>noNetwork</td><td><i>BOOL</i></td><td>Disable new Socket/WebSocket, or load of builtin MySql.</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Make puts, log, assert, etc use stdout.</td><td><i></i></td></tr>\n<tr><td>noSubInterps</td><td><i>BOOL</i></td><td>Disallow sub-interp creation.</td><td><i></i></td></tr>\n<tr><td>onComplete</td><td><i>FUNC</i></td><td>Function to return commands completions for interactive mode.  Default uses Info.completions . @function(prefix:string, start:number, end:number)</td><td><i></i></td></tr>\n<tr><td>onEval</td><td><i>FUNC</i></td><td>Function to get control for interactive evals. @function(cmd:string)</td><td><i></i></td></tr>\n<tr><td>onExit</td><td><i>FUNC</i></td><td>Command to call in parent on exit, returns true to continue. @function()</td><td><i>initOnly</i></td></tr>\n<tr><td>pkgDirs</td><td><i>ARRAY</i></td><td>list of library directories for require() to search.</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>retValue</td><td><i>VALUE</i></td><td>Return value from last eval.</td><td><i>readOnly</i></td></tr>\n<tr><td>safeMode</td><td><i>STRKEY</i></td><td>In safe mode source() support for pwd and script-dir . (one of: <b>none</b>, <b>read</b>, <b>write</b>, <b>writeRead</b>, <b>lockdown</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>safeReadDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow reads to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeWriteDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow writes to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeExecPattern</td><td><i>STRKEY</i></td><td>In safe mode, regexp pattern allow exec of commands.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptStr</td><td><i>STRKEY</i></td><td>Interp init script string.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptFile</td><td><i>STRING</i></td><td>Interp init script file.</td><td><i></i></td></tr>\n<tr><td>stdinStr</td><td><i>STRING</i></td><td>String to use as stdin for console.input().</td><td><i></i></td></tr>\n<tr><td>stdoutStr</td><td><i>STRING</i></td><td>String to collect stdout for puts().</td><td><i></i></td></tr>\n<tr><td>strict</td><td><i>BOOL</i></td><td>Globally enable strict: same as 'use strict' in main program.</td><td><i></i></td></tr>\n<tr><td>subOpts</td><td><i><a href='#subOptsOptions'>options</a></i></td><td>Infrequently used sub-options.</td><td><i></i></td></tr>\n<tr><td>subthread</td><td><i>BOOL</i></td><td>Create a threaded Interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n<tr><td>traceOp</td><td><i>INT</i></td><td>Set debugging level for OPCODE execution.</td><td><i></i></td></tr>\n<tr><td>tracePuts</td><td><i>BOOL</i></td><td>Trace puts by making it use logOpts.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>ARRAY</i></td><td>Type-check control options. (zero or more of: <b>parse</b>, <b>run</b>, <b>all</b>, <b>error</b>, <b>strict</b>, <b>noundef</b>, <b>nowith</b>, <b>funcsig</b>)</td><td><i></i></td></tr>\n<tr><td>typeWarnMax</td><td><i>INT</i></td><td>Type checking is silently disabled after this many warnings (50).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>unitTest</td><td><i>UINT</i></td><td>Unit test control bits: 1=subst, 2=Puts with file:line prefix.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"debugOptsOptions\"></a>\n<h2>Options for \"debugOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>debugCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp for handling debugging.</td><td><i></i></td></tr>\n<tr><td>doContinue</td><td><i>BOOL</i></td><td>Continue execution until breakpoint.</td><td><i></i></td></tr>\n<tr><td>forceBreak</td><td><i>BOOL</i></td><td>Force debugger to break.</td><td><i></i></td></tr>\n<tr><td>includeOnce</td><td><i>BOOL</i></td><td>Source the file only if not already sourced.</td><td><i></i></td></tr>\n<tr><td>includeTrace</td><td><i>BOOL</i></td><td>Trace includes.</td><td><i></i></td></tr>\n<tr><td>minLevel</td><td><i>INT</i></td><td>Disable eval callback for level higher than this.</td><td><i></i></td></tr>\n<tr><td>msgCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,...</td><td><i></i></td></tr>\n<tr><td>pkgTrace</td><td><i>BOOL</i></td><td>Trace package loads.</td><td><i></i></td></tr>\n<tr><td>putsCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle puts output.</td><td><i></i></td></tr>\n<tr><td>traceCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle traceCall.</td><td><i></i></td></tr>\n<tr><td>testFmtCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to format unittest string.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"logOptsOptions\"></a>\n<h2>Options for \"logOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages.</td><td><i></i></td></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages.</td><td><i></i></td></tr>\n<tr><td>Info</td><td><i>BOOL</i></td><td>Enable LogInfo messages.</td><td><i></i></td></tr>\n<tr><td>Warn</td><td><i>BOOL</i></td><td>Enable LogWarn messages.</td><td><i></i></td></tr>\n<tr><td>Error</td><td><i>BOOL</i></td><td>Enable LogError messages.</td><td><i></i></td></tr>\n<tr><td>time</td><td><i>BOOL</i></td><td>Prefix with time.</td><td><i></i></td></tr>\n<tr><td>date</td><td><i>BOOL</i></td><td>Prefix with date.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>BOOL</i></td><td>Ouptut contains file:line.</td><td><i></i></td></tr>\n<tr><td>func</td><td><i>BOOL</i></td><td>Output function.</td><td><i></i></td></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Show full file path.</td><td><i></i></td></tr>\n<tr><td>ftail</td><td><i>BOOL</i></td><td>Show tail of file only, even in LogWarn, etc.</td><td><i></i></td></tr>\n<tr><td>before</td><td><i>BOOL</i></td><td>Output file:line before message string.</td><td><i></i></td></tr>\n<tr><td>isUTC</td><td><i>BOOL</i></td><td>Time is to be UTC.</td><td><i></i></td></tr>\n<tr><td>timeFmt</td><td><i>STRKEY</i></td><td>A format string to use with strftime.</td><td><i></i></td></tr>\n<tr><td>chan</td><td><i>USEROBJ</i></td><td>Channel to send output to.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"subOptsOptions\"></a>\n<h2>Options for \"subOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>blacklist</td><td><i>STRKEY</i></td><td>Comma separated modules to disable loading for.</td><td><i>initOnly</i></td></tr>\n<tr><td>compat</td><td><i>BOOL</i></td><td>Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser.</td><td><i></i></td></tr>\n<tr><td>dblPrec</td><td><i>INT</i></td><td>Format precision of double where 0=max, -1=max-1, ... (max-1).</td><td><i></i></td></tr>\n<tr><td>istty</td><td><i>BOOL</i></td><td>Indicates interp is in interactive mode.</td><td><i>readOnly</i></td></tr>\n<tr><td>logColNums</td><td><i>BOOL</i></td><td>Display column numbers in error messages.</td><td><i></i></td></tr>\n<tr><td>logAllowDups</td><td><i>BOOL</i></td><td>Log should not filter out duplicate messages.</td><td><i></i></td></tr>\n<tr><td>mutexUnlock</td><td><i>BOOL</i></td><td>Unlock own mutex when evaling in other interps (true).</td><td><i>initOnly</i></td></tr>\n<tr><td>noproto</td><td><i>BOOL</i></td><td>Disable support of the OOP symbols:  __proto__, prototype, constructor, etc.</td><td><i></i></td></tr>\n<tr><td>noFuncString</td><td><i>BOOL</i></td><td>Disable viewing code body for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noRegex</td><td><i>BOOL</i></td><td>Disable viewing code for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noReadline</td><td><i>BOOL</i></td><td>In interactive mode disable use of readline.</td><td><i></i></td></tr>\n<tr><td>outUndef</td><td><i>BOOL</i></td><td>In interactive mode output result values that are undefined.</td><td><i></i></td></tr>\n<tr><td>prompt</td><td><i>STRKEY</i></td><td>Prompt for interactive mode ('$ ').</td><td><i></i></td></tr>\n<tr><td>prompt2</td><td><i>STRKEY</i></td><td>Prompt for interactive mode line continue ('> ').</td><td><i></i></td></tr>\n</table>\n<a name=\"Interpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"JSON\"></a>\n\n<hr>\n\n\n<h1>JSON</h1>\n\n<font color=red>Synopsis:JSON.method(...)\n\n</font><p>Commands for handling JSON data.\n\n\n<h2>Methods for \"JSON\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>check</td><td>check(str:string, strict:boolean=true):boolean </td><td>Return true if str is JSON.</td></tr>\n<tr><td>parse</td><td>parse(str:string, strict:boolean=true) </td><td>Parse JSON and return js.</td></tr>\n<tr><td>stringify</td><td>stringify(value:any,  strict:boolean=true):string </td><td>Return JSON from a js object.</td></tr>\n</table>\n<a name=\"JSONend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Math\"></a>\n\n<hr>\n\n\n<h1>Math</h1>\n\n<font color=red>Synopsis:Math.method(...)\n\n</font><p>Commands performing math operations on numbers.\n\n\n<h2>Methods for \"Math\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>abs</td><td>abs(num:number):number </td><td>Returns the absolute value of x.</td></tr>\n<tr><td>acos</td><td>acos(num:number):number </td><td>Returns the arccosine of x, in radians.</td></tr>\n<tr><td>asin</td><td>asin(num:number):number </td><td>Returns the arcsine of x, in radians.</td></tr>\n<tr><td>atan</td><td>atan(num:number):number </td><td>Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians.</td></tr>\n<tr><td>atan2</td><td>atan2(x:number, y:number):number </td><td>Returns the arctangent of the quotient of its arguments.</td></tr>\n<tr><td>ceil</td><td>ceil(num:number):number </td><td>Returns x, rounded upwards to the nearest integer.</td></tr>\n<tr><td>cos</td><td>cos(num:number):number </td><td>Returns the cosine of x (x is in radians).</td></tr>\n<tr><td>exp</td><td>exp(num:number):number </td><td>Returns the value of Ex.</td></tr>\n<tr><td>floor</td><td>floor(num:number):number </td><td>Returns x, rounded downwards to the nearest integer.</td></tr>\n<tr><td>log</td><td>log(num:number):number </td><td>Returns the natural logarithm (base E) of x.</td></tr>\n<tr><td>max</td><td>max(x:number, y:number, ...):number </td><td>Returns the number with the highest value.</td></tr>\n<tr><td>min</td><td>min(x:number, y:number, ...):number </td><td>Returns the number with the lowest value.</td></tr>\n<tr><td>pow</td><td>pow(x:number, y:number):number </td><td>Returns the value of x to the power of y.</td></tr>\n<tr><td>random</td><td>random():number </td><td>Returns a random number between 0 and 1.</td></tr>\n<tr><td>round</td><td>round(num:number):number </td><td>Rounds x to the nearest integer.</td></tr>\n<tr><td>sin</td><td>sin(num:number):number </td><td>Returns the sine of x (x is in radians).</td></tr>\n<tr><td>sqrt</td><td>sqrt(num:number):number </td><td>Returns the square root of x.</td></tr>\n<tr><td>srand</td><td>srand(seed:number):number </td><td>Set random seed.</td></tr>\n<tr><td>tan</td><td>tan(num:number):number </td><td>Returns the tangent of an angle.</td></tr>\n</table>\n<a name=\"Mathend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"MySql\"></a>\n\n<hr>\n\n\n<h1>MySql</h1>\n\n<font color=red>Synopsis:new MySql(options:object=void):userobj\n\n</font><p>Commands for accessing mysql databases.\n\n\n<h2>Methods for \"MySql\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>MySql</td><td>new MySql(<a href='#new MySqlOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to a MySql database:.</td></tr>\n<tr><td>affectedRows</td><td>affectedRows():number </td><td>Return affected rows.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#MySql.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>errorNo</td><td>errorNo():number </td><td>Return error code returned by most recent call to mysql3_exec().</td></tr>\n<tr><td>errorState</td><td>errorState():string </td><td>Return the mysql error state str.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output.</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info about last query.</td></tr>\n<tr><td>lastQuery</td><td>lastQuery():string </td><td>Return info string about most recently executed statement.</td></tr>\n<tr><td>lastRowid</td><td>lastRowid():number </td><td>Return rowid of last insert.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>ping</td><td>ping(noError:boolean=false):number </td><td>Ping connection.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#MySql.queryOptions'>options</a>:function|string|array|object=void) </td><td>Run sql query with input and/or outputs..</td></tr>\n<tr><td>reconnect</td><td>reconnect():void </td><td>Reconnect with current settings.</td></tr>\n<tr><td>reset</td><td>reset():number </td><td>Reset connection.</td></tr>\n</table>\n\n\n<a name=\"new MySqlOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"new MySql\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>database</td><td><i>STRKEY</i></td><td>Database to use.</td><td><i>initOnly</i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>enableMulti</td><td><i>BOOL</i></td><td>Accept muiltiple semi-colon separated statements in eval().</td><td><i>initOnly</i></td></tr>\n<tr><td>errorCnt</td><td><i>INT</i></td><td>Count of errors.</td><td><i>readOnly</i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>host</td><td><i>STRING</i></td><td>IP address or host name for mysqld (default is 127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>maxStmts</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>Name for this db handle.</td><td><i></i></td></tr>\n<tr><td>numStmts</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>password</td><td><i>STRKEY</i></td><td>Database password..</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>IP port for mysqld.</td><td><i>initOnly</i></td></tr>\n<tr><td>reconnect</td><td><i>BOOL</i></td><td>Reconnect.</td><td><i></i></td></tr>\n<tr><td>sslKey</td><td><i>STRING</i></td><td>SSL key.</td><td><i></i></td></tr>\n<tr><td>sslCert</td><td><i>STRING</i></td><td>SSL Cert.</td><td><i></i></td></tr>\n<tr><td>sslCA</td><td><i>STRING</i></td><td>SSL CA.</td><td><i></i></td></tr>\n<tr><td>sslCAPath</td><td><i>STRING</i></td><td>SSL CA path.</td><td><i></i></td></tr>\n<tr><td>sslCipher</td><td><i>STRING</i></td><td>SSL Cipher.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data..</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>STRKEY</i></td><td>Database user name. Default is current user-name..</td><td><i>initOnly</i></td></tr>\n<tr><td>version</td><td><i>DOUBLE</i></td><td>Mysql version number.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"MySql.queryOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"MySql.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"MySqlend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Number\"></a>\n\n<hr>\n\n\n<h1>Number</h1>\n\n<font color=red>Synopsis:new Number(num:string=0):number\n\n</font><p>Commands for accessing number objects.\n\n\n<h2>Methods for \"Number\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Number</td><td>new Number(num:string=0):number </td><td>Number constructor.</td></tr>\n<tr><td>isFinite</td><td>isFinite():boolean </td><td>Return true if is finite.</td></tr>\n<tr><td>isInteger</td><td>isInteger():boolean </td><td>Return true if is an integer.</td></tr>\n<tr><td>isNaN</td><td>isNaN():boolean </td><td>Return true if is NaN.</td></tr>\n<tr><td>isSafeInteger</td><td>isSafeInteger():boolean </td><td>Return true if is a safe integer.</td></tr>\n<tr><td>toExponential</td><td>toExponential(num:number):string </td><td>Converts a number into an exponential notation.</td></tr>\n<tr><td>toFixed</td><td>toFixed(num:number=0):string </td><td>Formats a number with x numbers of digits after the decimal point.</td></tr>\n<tr><td>toPrecision</td><td>toPrecision(num:number):string </td><td>Formats a number to x length.</td></tr>\n<tr><td>toString</td><td>toString(radix:number=10):string </td><td>Convert to string.</td></tr>\n</table>\n<a name=\"Numberend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Object\"></a>\n\n<hr>\n\n\n<h1>Object</h1>\n\n<font color=red>Synopsis:new Object(val:object&verbar;function|null=void):object\n\n</font><p>Commands for accessing Objects.\n\n\n<h2>Methods for \"Object\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Object</td><td>new Object(val:object|function|null=void):object </td><td>Object constructor.</td></tr>\n<tr><td>create</td><td>create(proto:null|object, properties:object=void):object </td><td>Create a new object with prototype object and properties.</td></tr>\n<tr><td>getPrototypeOf</td><td>getPrototypeOf(name:object|function):function|object </td><td>Return prototype of an object.</td></tr>\n<tr><td>hasOwnProperty</td><td>hasOwnProperty(name:string):boolean </td><td>Returns a true if object has the specified property.</td></tr>\n<tr><td>is</td><td>is(value1, value2):boolean </td><td>Tests if two values are equal.</td></tr>\n<tr><td>isPrototypeOf</td><td>isPrototypeOf(name):boolean </td><td>Tests for an object in another object's prototype chain.</td></tr>\n<tr><td>keys</td><td>keys(obj:object|function=void):array </td><td>Return the keys of an object or array.</td></tr>\n<tr><td>merge</td><td>merge(obj:object|function):object </td><td>Return new object containing merged values.</td></tr>\n<tr><td>propertyIsEnumerable</td><td>propertyIsEnumerable(name):boolean </td><td>Determine if a property is enumerable.</td></tr>\n<tr><td>setPrototypeOf</td><td>setPrototypeOf(name:object, value:object) </td><td>Set prototype of an object.</td></tr>\n<tr><td>toLocaleString</td><td>toLocaleString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>toString</td><td>toString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>valueOf</td><td>valueOf() </td><td>Returns primitive value.</td></tr>\n</table>\n<a name=\"Objectend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"RegExp\"></a>\n\n<hr>\n\n\n<h1>RegExp</h1>\n\n<font color=red>Synopsis:new RegExp(val:regexp&verbar;string, flags:string):regexp\n\n</font><p>Commands for managing reqular expression objects.\n\n\n<h2>Methods for \"RegExp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>RegExp</td><td>new RegExp(val:regexp|string, flags:string):regexp </td><td>Create a regexp object.</td></tr>\n<tr><td>exec</td><td>exec(val:string):array|object|null </td><td>return matching string. Perform regexp match checking.  Returns the array of matches.With the global flag g, sets lastIndex and returns next match.</td></tr>\n<tr><td>test</td><td>test(val:string):boolean </td><td>test if a string matches.</td></tr>\n</table>\n<a name=\"RegExpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Signal\"></a>\n\n<hr>\n\n\n<h1>Signal</h1>\n\n<font color=red>Synopsis:Signal.method(...)\n\n</font><p>Commands for handling unix signals.\n\n\n<h2>Methods for \"Signal\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>alarm</td><td>alarm(secs):number </td><td>Setup alarm in seconds.</td></tr>\n<tr><td>callback</td><td>callback(func:function, sig:number|string):number </td><td>Setup callback handler for signal.</td></tr>\n<tr><td>handle</td><td>handle(sig:number|string=void, ...) </td><td>Set named signals to handle action.</td></tr>\n<tr><td>ignore</td><td>ignore(sig:number|string=void, ...) </td><td>Set named signals to ignore action.</td></tr>\n<tr><td>kill</td><td>kill(pid:number, sig:number|string='SIGTERM'):void </td><td>Send signal to process id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return names of all signals.</td></tr>\n<tr><td>reset</td><td>reset(sig:number|string=void, ...):array </td><td>Set named signals to default action.</td></tr>\n</table>\n<a name=\"Signalend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Socket\"></a>\n\n<hr>\n\n\n<h1>Socket</h1>\n\n<font color=red>Synopsis:new Socket(options:object=void):userobj\n\n</font><p>Commands for managing Socket server/client connections.\n\n\n<h2>Methods for \"Socket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Socket</td><td>new Socket(<a href='#new SocketOptions'>options</a>:object=void):userobj </td><td>Create socket server/client object.Create a socket server or client object.</td></tr>\n<tr><td>close</td><td>close():void </td><td>Close socket(s).</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Socket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number=void, <a href='#Socket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for a connection id, or return list of ids.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list of active ids on server.</td></tr>\n<tr><td>recv</td><td>recv(id:number=void):string </td><td>Recieve data.</td></tr>\n<tr><td>send</td><td>send(id:number, data:string, <a href='#Socket.sendOptions'>options</a>:object=void):void </td><td>Send a socket message to id. Send a message to a (or all if -1) connection.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this socket.</td></tr>\n</table>\n\n\n<a name=\"new SocketOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"new Socket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>Client destination address (127.0.0.0).</td><td><i>initOnly</i></td></tr>\n<tr><td>broadcast</td><td><i>BOOL</i></td><td>Enable broadcast.</td><td><i>initOnly</i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Enable client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Counter for number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createLast</td><td><i>TIME_T</i></td><td>Time of last create.</td><td><i>readOnly</i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Debugging level.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>keepalive</td><td><i>BOOL</i></td><td>Enable keepalive.</td><td><i>initOnly</i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>mcastAddMember</td><td><i>STRING</i></td><td>Multicast add membership: address/interface ('127.0.0.1/0.0.0.0').</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastInterface</td><td><i>STRING</i></td><td>Multicast interface address.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastNoLoop</td><td><i>BOOL</i></td><td>Multicast loopback disable.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastTtl</td><td><i>INT</i></td><td>Multicast TTL.</td><td><i>initOnly</i></td></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i>initOnly</i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Stop processing update events (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when connection closes. @function(s:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last connection closes. On object delete arg is null. @function(s:userobj|null)</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Socket.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when connection opens. @function(s:userobj, info:object)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call with recieved data. @function(s:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for client dest or server listen.</td><td><i>initOnly</i></td></tr>\n<tr><td>quiet</td><td><i>BOOL</i></td><td>Suppress info messages.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvTimeout</td><td><i>UINT64</i></td><td>Timeout for receive, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>sendTimeout</td><td><i>UINT64</i></td><td>Timeout for send, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcAddress</td><td><i>STRING</i></td><td>Client source address.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcPort</td><td><i>INT</i></td><td>Client source port.</td><td><i>initOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of start.</td><td><i>readOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>timeout</td><td><i>NUMBER</i></td><td>Timeout value in seconds (0.5).</td><td><i>initOnly</i></td></tr>\n<tr><td>tos</td><td><i>INT8</i></td><td>Type-Of-Service value.</td><td><i>initOnly</i></td></tr>\n<tr><td>ttl</td><td><i>INT</i></td><td>Time-To-Live value.</td><td><i>initOnly</i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>udp</td><td><i>BOOL</i></td><td>Protocol is udp.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.idconfOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.sendOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.send\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i></i></td></tr>\n</table>\n<a name=\"Socketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Sqlite\"></a>\n\n<hr>\n\n\n<h1>Sqlite</h1>\n\n<font color=red>Synopsis:new Sqlite(file:null&verbar;string=void, options:object=void):userobj\n\n</font><p>Commands for accessing sqlite databases.\n\n\n<h2>Methods for \"Sqlite\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Sqlite</td><td>new Sqlite(file:null|string=void, <a href='#new SqliteOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to the named file or :memory:.</td></tr>\n<tr><td>backup</td><td>backup(file:string, dbname:string='main'):void </td><td>Backup db to file. Open or create a database file named FILENAME.\nTransfer the content of local database DATABASE (default: 'main') into the FILENAME database.</td></tr>\n<tr><td>collate</td><td>collate(name:string, callback:function):void </td><td>Create new SQL collation command.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Sqlite.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output. Supports multiple semicolon seperated commands.\nVariable binding is NOT performed, results are discarded, and  returns sqlite3_changes()</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>filename</td><td>filename(name:string='main'):string </td><td>Return filename for named or all attached databases.</td></tr>\n<tr><td>func</td><td>func(name:string, callback:function, numArgs:number=void):void </td><td>Register a new function with database.</td></tr>\n<tr><td>import</td><td>import(table:string, file:string, <a href='#Sqlite.importOptions'>options</a>:object=void):number </td><td>Import data from file into table . Import data from a file into table. SqlOptions include the 'separator' to use, which defaults to commas for csv, or tabs otherwise.\nIf a column contains a null string, or the value of 'nullvalue', a null is inserted for the column.\nA 'conflict' is one of the sqlite conflict algorithms:    rollback, abort, fail, ignore, replace\nOn success, return the number of lines processed, not necessarily same as 'changeCnt' due to the conflict algorithm selected. </td></tr>\n<tr><td>interrupt</td><td>interrupt():void </td><td>Interrupt in progress statement.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#Sqlite.queryOptions'>options</a>:function|string|array|object=void) </td><td>Evaluate an sql query with bindings. Return values in formatted as JSON, HTML, etc. , optionally calling function with a result object</td></tr>\n<tr><td>restore</td><td>restore(file:string, dbname:string):void </td><td>Restore db from file (default db is 'main').    db.restore(FILENAME, ?,DATABASE? ) \nOpen a database file named FILENAME.  Transfer the content of FILENAME into the local database DATABASE (default: 'main').</td></tr>\n<tr><td>transaction</td><td>transaction(callback:function, type:string=void):void </td><td>Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'. Start a new transaction (if we are not already in the midst of a transaction) and execute the JS function FUNC.\nAfter FUNC completes, either commit the transaction or roll it back if FUNC throws an exception.\nOr if no new transation was started, do nothing. pass the exception on up the stack.</td></tr>\n</table>\n\n\n<a name=\"new SqliteOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"new Sqlite\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>changeCnt</td><td><i>INT</i></td><td>The number of rows modified, inserted, or deleted by last command.</td><td><i></i></td></tr>\n<tr><td>changeCntAll</td><td><i>INT</i></td><td>Total number of rows modified, inserted, or deleted since db opened.</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query/eval string to log.</td><td><i></i></td></tr>\n<tr><td>errCnt</td><td><i>INT</i></td><td>Count of errors in script callbacks.</td><td><i>readOnly</i></td></tr>\n<tr><td>errorCode</td><td><i>INT</i></td><td>Numeric error code returned by the most recent call to sqlite3_exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>noJsonConv</td><td><i>BOOL</i></td><td>Do not JSON auto-convert array and object in CHARJSON columns.</td><td><i></i></td></tr>\n<tr><td>lastInsertId</td><td><i>UINT64</i></td><td>The rowid of last insert.</td><td><i></i></td></tr>\n<tr><td>load</td><td><i>BOOL</i></td><td>Extensions can be loaded.</td><td><i></i></td></tr>\n<tr><td>mutex</td><td><i>STRKEY</i></td><td>Mutex type to use. (one of: <b>default</b>, <b>none</b>, <b>full</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>The dbname to use instead of 'main'.</td><td><i>initOnly</i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Sqlite.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCreate</td><td><i>BOOL</i></td><td>Database is must already exist (false).</td><td><i>initOnly</i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for auth. @function(db:userobj, code:string, descr1:string, decr2:string, dbname:string, trigname:string)</td><td><i></i></td></tr>\n<tr><td>onBusy</td><td><i>FUNC</i></td><td>Function to call when busy. @function(db:userobj, tries:number)</td><td><i></i></td></tr>\n<tr><td>onCommit</td><td><i>FUNC</i></td><td>Function to call on commit. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onNeedCollate</td><td><i>FUNC</i></td><td>Function to call for collation. @function(db:userobj, name:string)</td><td><i></i></td></tr>\n<tr><td>onProfile</td><td><i>FUNC</i></td><td>Function to call for profile. @function(db:userobj, sql:string, time:number)</td><td><i></i></td></tr>\n<tr><td>onProgress</td><td><i>FUNC</i></td><td>Function to call for progress: progressSteps must be >0. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onRollback</td><td><i>FUNC</i></td><td>Function to call for rollback. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onTrace</td><td><i>FUNC</i></td><td>Function to call for trace. @function(db:userobj, sql:string)</td><td><i></i></td></tr>\n<tr><td>onUpdate</td><td><i>FUNC</i></td><td>Function to call for update. @function(db:userobj, op:string, dbname:string, table:string, rowid:number)</td><td><i></i></td></tr>\n<tr><td>onWalHook</td><td><i>FUNC</i></td><td>Function to call for WAL. @function(db:userobj, dbname:string, entry:number)</td><td><i></i></td></tr>\n<tr><td>progressSteps</td><td><i>UINT</i></td><td>Number of steps between calling onProgress: 0 is disabled.</td><td><i></i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for to use with query().</td><td><i></i></td></tr>\n<tr><td>readonly</td><td><i>BOOL</i></td><td>Database opened in readonly mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>sortCnt</td><td><i>INT</i></td><td>Number of sorts in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stepCnt</td><td><i>INT</i></td><td>Number of steps in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheCnt</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheMax</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>Sqlite version info.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>vfs</td><td><i>STRING</i></td><td>VFS to use.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.importOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.import\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row contains column labels.</td><td><i></i></td></tr>\n<tr><td>csv</td><td><i>BOOL</i></td><td>Treat input values as CSV.</td><td><i></i></td></tr>\n<tr><td>conflict</td><td><i>STRKEY</i></td><td>Set conflict resolution. (one of: <b>ROLLBACK</b>, <b>ABORT</b>, <b>FAIL</b>, <b>IGNORE</b>, <b>REPLACE</b>)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of lines to load.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string; default is comma if csv, else tabs.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.queryOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"Sqliteend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"String\"></a>\n\n<hr>\n\n\n<h1>String</h1>\n\n<font color=red>Synopsis:new String(str):string\n\n</font><p>Commands for accessing string objects..\n\n\n<h2>Methods for \"String\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>String</td><td>new String(str):string </td><td>String constructor.</td></tr>\n<tr><td>charAt</td><td>charAt(index:number):string </td><td>Return char at index.</td></tr>\n<tr><td>charCodeAt</td><td>charCodeAt(index:number):number </td><td>Return char code at index.</td></tr>\n<tr><td>concat</td><td>concat(str:string, ...):string </td><td>Append one or more strings.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(...):string </td><td>Return string for char codes.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:string, start:number):number </td><td>Return index of char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(str:string, start:number):number </td><td>Return index of last char.</td></tr>\n<tr><td>map</td><td>map(strMap:array, nocase:boolean=false):string </td><td>Replaces characters in string based on the key-value pairs in strMap.</td></tr>\n<tr><td>match</td><td>match(pattern:regexp|string):array|null </td><td>Return array of matches.</td></tr>\n<tr><td>repeat</td><td>repeat(count:number):string </td><td>Return count copies of string.</td></tr>\n<tr><td>replace</td><td>replace(pattern:regexp|string, replace:string|function):string </td><td>Regex/string replacement. If the replace argument is a function, it is called with match,p1,p2,...,offset,string.  If called function is known to have 1 argument, it is called with just the match.</td></tr>\n<tr><td>search</td><td>search(pattern:regexp|string):number </td><td>Return index of first char matching pattern.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number):string </td><td>Return section of string.</td></tr>\n<tr><td>split</td><td>split(char:string|null=void):array </td><td>Split on char and return Array. When char is omitted splits on bytes.  When char==null splits on whitespace and removes empty elements.</td></tr>\n<tr><td>substr</td><td>substr(start:number, length:number):string </td><td>Return substring.</td></tr>\n<tr><td>substring</td><td>substring(start:number, end:number):string </td><td>Return substring.</td></tr>\n<tr><td>toLocaleLowerCase</td><td>toLocaleLowerCase():string </td><td>Lower case.</td></tr>\n<tr><td>toLocaleUpperCase</td><td>toLocaleUpperCase():string </td><td>Upper case.</td></tr>\n<tr><td>toLowerCase</td><td>toLowerCase():string </td><td>Return lower cased string.</td></tr>\n<tr><td>toTitle</td><td>toTitle(chars:string):string </td><td>Make first char upper case.</td></tr>\n<tr><td>toUpperCase</td><td>toUpperCase():string </td><td>Return upper cased string.</td></tr>\n<tr><td>trim</td><td>trim(chars:string):string </td><td>Trim chars.</td></tr>\n<tr><td>trimLeft</td><td>trimLeft(chars:string):string </td><td>Trim chars from left.</td></tr>\n<tr><td>trimRight</td><td>trimRight(chars:string):string </td><td>Trim chars from right.</td></tr>\n</table>\n<a name=\"Stringend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"System\"></a>\n\n<hr>\n\n\n<h1>System</h1>\n\n<font color=red>Synopsis:System.method(...)\n\n</font><p>Builtin system commands. All methods are exported as global.\n\n\n<h2>Methods for \"System\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#System.assertOptions'>options</a>:object=void):void </td><td>Throw or output msg if expr is false. Assert does nothing by default, but can be enabled with \"use assert\" or setting Interp.asserts.</td></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete event id returned from setInterval/setTimeout/info.events().</td></tr>\n<tr><td>decodeURI</td><td>decodeURI(val:string):string </td><td>Decode an HTTP URL.</td></tr>\n<tr><td>encodeURI</td><td>encodeURI(val:string):string </td><td>Encode an HTTP URL.</td></tr>\n<tr><td>exec</td><td>exec(val:string, <a href='#System.execOptions'>options</a>:string|object=void) </td><td>Execute an OS command. If the command ends with '&', set the 'bg' option to true.\nThe second argument can be a string, which is the same as setting the 'inputStr' option.\nBy default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used</td></tr>\n<tr><td>exit</td><td>exit(code:number=0):void </td><td>Exit the current interpreter.</td></tr>\n<tr><td>format</td><td>format(format:string, ...):string </td><td>Printf style formatting: adds %q and %S.</td></tr>\n<tr><td>isFinite</td><td>isFinite(val):boolean </td><td>Return true if is a finite number.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>isNaN</td><td>isNaN(val):boolean </td><td>Return true if not a number.</td></tr>\n<tr><td>load</td><td>load(shlib:string):void </td><td>Load a shared executable and invoke its _Init call.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as puts, but includes file:line.</td></tr>\n<tr><td>matchObj</td><td>matchObj(obj:object, match:string=void, partial=false, noerror=false):string|boolean </td><td>Object field names/types matching. Single arg generates string.</td></tr>\n<tr><td>noOp</td><td>noOp() </td><td>A No-Op. A zero overhead command call that is useful for debugging.</td></tr>\n<tr><td>parseFloat</td><td>parseFloat(val):number </td><td>Convert string to a double.</td></tr>\n<tr><td>parseInt</td><td>parseInt(val:any, base:number=10):number </td><td>Convert string to an integer.</td></tr>\n<tr><td>parseOpts</td><td>parseOpts(self:object|userobj, options:object, conf:object|null|undefined) </td><td>Parse options.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Formatted output to stdout.</td></tr>\n<tr><td>provide</td><td>provide(name:string|function=void, version:number|string=1.0, opts:object|function=void):void </td><td>Provide a package for use with require. Default is the file tail-rootname.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Output one or more values to stdout. Each argument is quoted.  Use Interp.logOpts to control source line and/or timestamps output.</td></tr>\n<tr><td>quote</td><td>quote(val:string):string </td><td>Return quoted string.</td></tr>\n<tr><td>require</td><td>require(name:string=void, version:number|string=1, <a href='#System.requireOptions'>options</a>:object=void):number|array|object </td><td>Load/query packages. With no arguments, returns the list of all loaded packages.\nWith one argument, loads the package (if necessary) and returns its version.\nWith two arguments, returns object containing: version, loadFile, func.\nA third argument sets options for package or module.\nNote an error is thrown if requested version is greater than actual version.</td></tr>\n<tr><td>runMain</td><td>runMain(cmd:string|null|function=void, conf:array=undefined) </td><td>If isMain invokes runModule.</td></tr>\n<tr><td>runModule</td><td>runModule(cmd:string|null|function=void, conf:array=undefined) </td><td>Invoke named module. If name is empty, uses file basename. If isMain and no args givine parses console.args.</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, ms:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, ms:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>sleep</td><td>sleep(secs:number=1.0):void </td><td>sleep for N milliseconds, minimum .001.</td></tr>\n<tr><td>source</td><td>source(val:string|array, <a href='#System.sourceOptions'>options</a>:object=void) </td><td>Load and evaluate source files: trailing '/' appends PARENTDIR.jsi.</td></tr>\n<tr><td>strftime</td><td>strftime(num:number=null, <a href='#System.strftimeOptions'>options</a>:string|object=void):string </td><td>Format numeric time (in ms) to a string. Null or no value will use current time.</td></tr>\n<tr><td>strptime</td><td>strptime(val:string=void, <a href='#System.strptimeOptions'>options</a>:string|object=void):number </td><td>Parse time from string and return ms time since 1970-01-01 in UTC, or NaN.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>unload</td><td>unload(shlib:string):void </td><td>Unload a shared executable and invoke its _Done call.</td></tr>\n<tr><td>update</td><td>update(<a href='#System.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"System.assertOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.execOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bg</td><td><i>BOOL</i></td><td>Run command in background using system() and return OS code.</td><td><i></i></td></tr>\n<tr><td>chdir</td><td><i>STRING</i></td><td>Change to directory.</td><td><i></i></td></tr>\n<tr><td>inputStr</td><td><i>STRING</i></td><td>Use string as input and return OS code.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Suppress all OS errors.</td><td><i></i></td></tr>\n<tr><td>noRedir</td><td><i>BOOL</i></td><td>Disable redirect and shell escapes in command.</td><td><i></i></td></tr>\n<tr><td>noShell</td><td><i>BOOL</i></td><td>Do not use native popen which invokes via /bin/sh.</td><td><i></i></td></tr>\n<tr><td>trim</td><td><i>BOOL</i></td><td>Trim trailing whitespace from output.</td><td><i></i></td></tr>\n<tr><td>retAll</td><td><i>BOOL</i></td><td>Return the OS return code and data as an object.</td><td><i></i></td></tr>\n<tr><td>retCode</td><td><i>BOOL</i></td><td>Return only the OS return code.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.requireOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.require\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages for module.</td><td><i></i></td></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages for module.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages for module.</td><td><i></i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.sourceOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.source\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>autoIndex</td><td><i>BOOL</i></td><td>Look for and load Jsi_Auto.jsi auto-index file.</td><td><i></i></td></tr>\n<tr><td>exists</td><td><i>BOOL</i></td><td>Source file only if exists.</td><td><i></i></td></tr>\n<tr><td>global</td><td><i>BOOL</i></td><td>File is to be sourced in global frame rather than local.</td><td><i></i></td></tr>\n<tr><td>isMain</td><td><i>BOOL</i></td><td>Coerce to true the value of Info.isMain().</td><td><i></i></td></tr>\n<tr><td>level</td><td><i>UINT</i></td><td>Frame to source file in.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Ignore errors in sourced file.</td><td><i></i></td></tr>\n<tr><td>once</td><td><i>BOOL</i></td><td>Source file only if not already sourced (Default: Interp.debugOpts.includeOnce).</td><td><i></i></td></tr>\n<tr><td>trace</td><td><i>BOOL</i></td><td>Trace include statements (Default: Interp.debugOpts.includeTrace).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strftimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strftime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strptimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strptime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.updateOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Systemend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Util\"></a>\n\n<hr>\n\n\n<h1>Util</h1>\n\n<font color=red>Synopsis:Util.method(...)\n\n</font><p>Utilities commands.\n\n\n<h2>Methods for \"Util\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argArray</td><td>argArray(arg:any|undefined):array|null </td><td>Coerces non-null to an array, if necessary.</td></tr>\n<tr><td>base64</td><td>base64(val:string, decode:boolean=false):string </td><td>Base64 encode/decode a string.</td></tr>\n<tr><td>complete</td><td>complete(val:string):boolean </td><td>Return true if string is complete command with balanced braces, etc.</td></tr>\n<tr><td>crc32</td><td>crc32(val:string, crcSeed=0):number </td><td>Calculate 32-bit CRC.</td></tr>\n<tr><td>decrypt</td><td>decrypt(val:string, key:string):string </td><td>Decrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>encrypt</td><td>encrypt(val:string, key:string):string </td><td>Encrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(code:number):string </td><td>Return char with given character code.</td></tr>\n<tr><td>getenv</td><td>getenv(name:string=void):string|object|void </td><td>Get one or all environment.</td></tr>\n<tr><td>getpid</td><td>getpid(parent:boolean=false):number </td><td>Get process/parent id.</td></tr>\n<tr><td>getuser</td><td>getuser():object </td><td>Get userid info.</td></tr>\n<tr><td>hash</td><td>hash(val:string, <a href='#Util.hashOptions'>options</a>|object=void):string </td><td>Return hash (default SHA256) of string/file.</td></tr>\n<tr><td>hexStr</td><td>hexStr(val:string, decode:boolean=false):string </td><td>Hex encode/decode a string.</td></tr>\n<tr><td>setenv</td><td>setenv(name:string, value:string=void) </td><td>Set/get an environment var.</td></tr>\n<tr><td>sqlValues</td><td>sqlValues(name:string, var:object=void) </td><td>Get object values for SQL.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>verConvert</td><td>verConvert(ver:string|number, zeroTrim:number=0):number|string|null </td><td>Convert a version to/from a string/number, or return null if not a version. For string output zeroTrim says how many trailing .0 to trim (0-2).</td></tr>\n</table>\n\n\n<a name=\"Util.hashOptions\"></a>\n<a name=\"Util.confOptions\"></a>\n<h2>Options for \"Util.hash\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Read data from file and append to str.</td><td><i></i></td></tr>\n<tr><td>hashcash</td><td><i>UINT</i></td><td>Search for a hash with this many leading zero bits by appending :nonce (Proof-Of-Work).</td><td><i></i></td></tr>\n<tr><td>noHex</td><td><i>BOOL</i></td><td>Return binary digest, without conversion to hex chars.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type of hash. (one of: <b>sha256</b>, <b>sha1</b>, <b>md5</b>, <b>sha3_224</b>, <b>sha3_384</b>, <b>sha3_512</b>, <b>sha3_256</b>)</td><td><i></i></td></tr>\n</table>\n<a name=\"Utilend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Vfs\"></a>\n\n<hr>\n\n\n<h1>Vfs</h1>\n\n<font color=red>Synopsis:Vfs.method(...)\n\n</font><p>Commands for creating in memory readonly Virtual file-systems.\n\n\n<h2>Methods for \"Vfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(mount:string, string|<a href='#Vfs.confOptions'>options</a>:object|string=void) </td><td>Configure mount.</td></tr>\n<tr><td>exec</td><td>exec(cmd:string) </td><td>Safe mode exec for VFS support cmds eg. fossil info/ls/cat.</td></tr>\n<tr><td>fileconf</td><td>fileconf(mount:string, path:string, <a href='#Vfs.fileconfOptions'>options</a>:string|object=void) </td><td>Configure file info which is same info as in fileList.</td></tr>\n<tr><td>list</td><td>list():array </td><td>Return list of all vfs mounts.</td></tr>\n<tr><td>mount</td><td>mount(type:string, file:string, param:object=void):string </td><td>Mount fossil file as given VFS type name, returning the mount point: frontend for vmount.</td></tr>\n<tr><td>type</td><td>type(type:string=void, <a href='#Vfs.typeOptions'>options</a>:object|null=void) </td><td>Set/get/delete VFS type name.</td></tr>\n<tr><td>unmount</td><td>unmount(mount:string):void </td><td>Unmount a VFS.</td></tr>\n<tr><td>vmount</td><td>vmount(<a href='#Vfs.vmountOptions'>options</a>:object=void):string </td><td>Create and mount a VFS, returning the mount point.</td></tr>\n</table>\n\n\n<a name=\"Vfs.confOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.execOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.fileconfOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.fileconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.typeOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.type\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i>required</i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.vmountOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.vmount\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n<a name=\"Vfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"WebSocket\"></a>\n\n<hr>\n\n\n<h1>WebSocket</h1>\n\n<font color=red>Synopsis:new WebSocket(options:object=void):userobj\n\n</font><p>Commands for managing WebSocket server/client connections.\n\n\n<h2>Methods for \"WebSocket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>WebSocket</td><td>new WebSocket(<a href='#new WebSocketOptions'>options</a>:object=void):userobj </td><td>Create websocket server/client object.Create a websocket server/client object.  The server serves out pages to a web browser,\nwhich can use javascript to upgrade connection to a bidirectional websocket.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#WebSocket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>file</td><td>file(name:string=void):array|void </td><td>Add file to hash, or with no args return file hash.</td></tr>\n<tr><td>handler</td><td>handler(extension:string=void, cmd:string|function=void, flags:number=0):string|array|function|void </td><td>Get/Set handler command for an extension. With no args, returns list of handlers.  With one arg, returns value for that handler.\nOtherwise, sets the handler. When cmd is a string, the call is via runModule([cmd], arg).\nIf a cmd is a function, it is called with a single arg: the file name.</td></tr>\n<tr><td>header</td><td>header(id:number, name:string=void):string|array|void </td><td>Get one or all input headers for connect id.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number, <a href='#WebSocket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for connect id.</td></tr>\n<tr><td>ids</td><td>ids(name:string=void):array </td><td>Return list of ids, or lookup one id.</td></tr>\n<tr><td>query</td><td>query(id:number, name:string=void):string|object|void </td><td>Get one or all query values for connect id.</td></tr>\n<tr><td>send</td><td>send(id:number, data:any):void </td><td>Send a websocket message to id. Send a message to one (or all connections if -1). If not already a string, msg is formatted as JSON prior to the send.</td></tr>\n<tr><td>status</td><td>status():object|void </td><td>Return libwebsocket server status.</td></tr>\n<tr><td>unalias</td><td>unalias(path:string):string|void </td><td>Return alias reverse lookup.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this websocket.</td></tr>\n<tr><td>version</td><td>version():string </td><td>Runtime library version string.</td></tr>\n</table>\n\n\n<a name=\"new WebSocketOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"new WebSocket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>In client-mode the address to connect to (127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>bufferPwr2</td><td><i>INT</i></td><td>Tune the recv/send buffer: value is a power of 2 in [0-20] (16).</td><td><i></i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Run in client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>clientHost</td><td><i>STRKEY</i></td><td>Override host name for client.</td><td><i></i></td></tr>\n<tr><td>clientOrigin</td><td><i>STRKEY</i></td><td>Override client origin (origin).</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Set debug level. Setting this to 512 will turn on max libwebsocket log levels.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>formParams</td><td><i>STRKEY</i></td><td>Comma seperated list of upload form param names ('text,send,file,upload').</td><td><i>readOnly</i></td></tr>\n<tr><td>extHandlers</td><td><i>BOOL</i></td><td>Setup builtin extension-handlers, ie: .htmli, .cssi, .jsi, .mdi.</td><td><i>initOnly</i></td></tr>\n<tr><td>extOpts</td><td><i>OBJ</i></td><td>Key/value store for extension-handlers options.</td><td><i>initOnly</i></td></tr>\n<tr><td>getRegexp</td><td><i>REGEXP</i></td><td>Call onGet() only if Url matches pattern.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser: name/value pairs.</td><td><i>initOnly</i></td></tr>\n<tr><td>jsiFnPattern</td><td><i>STRKEY</i></td><td>A glob-match pattern for files to which is appended 'window.jsiWebSocket=true;' (jsig*.js).</td><td><i>readOnly</i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>local</td><td><i>BOOL</i></td><td>Limit connections to localhost addresses on the 127 network.</td><td><i></i></td></tr>\n<tr><td>localhostName</td><td><i>STRKEY</i></td><td>Client name used by localhost connections ('localhost').</td><td><i></i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>maxDownload</td><td><i>INT</i></td><td>Max size of file download.</td><td><i></i></td></tr>\n<tr><td>maxUpload</td><td><i>INT</i></td><td>Max size of file upload will accept.</td><td><i></i></td></tr>\n<tr><td>mimeTypes</td><td><i>OBJ</i></td><td>Object providing map of file extensions to mime types. eg. {txt:'text/plain', bb:'text/bb'}.</td><td><i>initOnly</i></td></tr>\n<tr><td>modifySecs</td><td><i>UINT</i></td><td>Seconds between checking for modified files with onModify (2).</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of conf() to change options after options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCompress</td><td><i>BOOL</i></td><td>Disable per-message-deflate extension which can truncate large msgs.</td><td><i></i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Disable update event-processing (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>noWebsock</td><td><i>BOOL</i></td><td>Serve html, but disallow websocket upgrade.</td><td><i>initOnly</i></td></tr>\n<tr><td>noWarn</td><td><i>BOOL</i></td><td>Quietly ignore file related errors.</td><td><i></i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for http basic authentication. @function(ws:userobj, id:number, url:string, userpass:string)</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last websock connection closes. On object delete arg is null. @function(ws:userobj|null)</td><td><i></i></td></tr>\n<tr><td>onFilter</td><td><i>FUNC</i></td><td>Function to call on a new connection: return false to kill connection. @function(ws:userobj, id:number, url:string, ishttp:boolean)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onModify</td><td><i>FUNC</i></td><td>Function to call when a served-out-file is modified. @function(ws:userobj, file:string)</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when the websocket connection occurs. @function(ws:userobj, id:number)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>pathAliases</td><td><i>OBJ</i></td><td>Path alias lookups.</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for server to listen on (8080).</td><td><i>initOnly</i></td></tr>\n<tr><td>post</td><td><i>STRING</i></td><td>Post string to serve.</td><td><i>initOnly</i></td></tr>\n<tr><td>protocol</td><td><i>STRKEY</i></td><td>Name of protocol (ws/wss).</td><td><i></i></td></tr>\n<tr><td>realm</td><td><i>STRKEY</i></td><td>Realm for basic auth (jsish).</td><td><i></i></td></tr>\n<tr><td>recvBufMax</td><td><i>INT</i></td><td>Size limit of a websocket message.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvBufTimeout</td><td><i>INT</i></td><td>Timeout for recv of a websock msg.</td><td><i>initOnly</i></td></tr>\n<tr><td>redirMax</td><td><i>BOOL</i></td><td>Temporarily disable redirects when see more than this in 10 minutes.</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>server</td><td><i>STRKEY</i></td><td>String to send out int the header SERVER (jsiWebSocket).</td><td><i></i></td></tr>\n<tr><td>ssiExts</td><td><i>OBJ</i></td><td>Object map of file extensions to apply SSI.  eg. {myext:true, shtml:false} .</td><td><i>initOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of websocket start.</td><td><i>readOnly</i></td></tr>\n<tr><td>includeFile</td><td><i>STRKEY</i></td><td>Default file when no extension given (include.shtml).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>urlPrefix</td><td><i>STRKEY</i></td><td>Prefix in url to strip from path; for reverse proxy.</td><td><i></i></td></tr>\n<tr><td>urlRedirect</td><td><i>STRKEY</i></td><td>Redirect when no url or / is given. Must match urlPrefix, if given.</td><td><i></i></td></tr>\n<tr><td>use_ssl</td><td><i>BOOL</i></td><td>Use https (for client).</td><td><i>initOnly</i></td></tr>\n<tr><td>useridPass</td><td><i>STRKEY</i></td><td>The USERID:PASSWORD to use for basic authentication.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>WebSocket version info.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"WebSocket.idconfOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"WebSocket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>clientIP</td><td><i>STRKEY</i></td><td>Client IP Address.</td><td><i>readOnly</i></td></tr>\n<tr><td>clientName</td><td><i>STRKEY</i></td><td>Client hostname.</td><td><i>readOnly</i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser on connection: name/value pairs.</td><td><i></i></td></tr>\n<tr><td>isWebsock</td><td><i>BOOL</i></td><td>Is a websocket connection.</td><td><i></i></td></tr>\n<tr><td>key</td><td><i>STRBUF</i></td><td>String key lookup in ids command for SSI echo ${#}.</td><td><i>readOnly</i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, args:array)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistics for connection.</td><td><i>readOnly</i></td></tr>\n<tr><td>query</td><td><i>ARRAY</i></td><td>Uri arg values for connection.</td><td><i></i></td></tr>\n<tr><td>queryObj</td><td><i>OBJ</i></td><td>Uri arg values for connection as an object.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>url</td><td><i>DSTRING</i></td><td>Url for connection.</td><td><i></i></td></tr>\n<tr><td>username</td><td><i>STRING</i></td><td>The login userid for this connection.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createTime</td><td><i>TIME_T</i></td><td>Time created.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>httpCnt</td><td><i>INT</i></td><td>Number of http reqs.</td><td><i></i></td></tr>\n<tr><td>httpLast</td><td><i>TIME_T</i></td><td>Time of last http reqs.</td><td><i></i></td></tr>\n<tr><td>isBinary</td><td><i>BOOL</i></td><td>Connection recv data is binary.</td><td><i>readOnly</i></td></tr>\n<tr><td>isFinal</td><td><i>BOOL</i></td><td>Final data for current message was recieved.</td><td><i>readOnly</i></td></tr>\n<tr><td>msgQLen</td><td><i>INT</i></td><td>Number of messages in input queue.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirLast</td><td><i>TIME_T</i></td><td>Time of last redirect.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirCnt</td><td><i>INT</i></td><td>Count of redirects.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadCnt</td><td><i>INT</i></td><td>Number of uploads.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadEnd</td><td><i>TIME_T</i></td><td>Time of upload end.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadLast</td><td><i>TIME_T</i></td><td>Time of last upload input.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadStart</td><td><i>TIME_T</i></td><td>Time of upload start.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"WebSocketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Zvfs\"></a>\n\n<hr>\n\n\n<h1>Zvfs</h1>\n\n<font color=red>Synopsis:Zvfs.method(...)\n\n</font><p>Commands for mounting and accessing .zip files as a filesystem.\n\n\n<h2>Methods for \"Zvfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>append</td><td>append(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Like 'create()', but appends to an existing archive (with no dup checking).</td></tr>\n<tr><td>create</td><td>create(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Create a zip with the given files in prefix path. This command creates a zip archive and adds files to it. Files are relative the given 'path', or the current directory. If the destignation file already exist but is not an archive (eg. an executable), zip data is appended to the end of the file. If the existing file is already an archive, an error will be thrown. To truncate an existing archive, use zvfs.truncate(). Or use zvfs.append() instead. \n   zvfs.create('foo.zip',['main.js', 'bar.js'], 'src', ['a.html', 'css/a.css'], 'html');</td></tr>\n<tr><td>deflate</td><td>deflate(data:string):string </td><td>Compress string using zlib deflate.</td></tr>\n<tr><td>inflate</td><td>inflate(data:string):string </td><td>Uncompress string using zlib inflate.</td></tr>\n<tr><td>list</td><td>list(archive:string):array </td><td>List files in archive. Return contents of zip directory as an array of arrays. The first element contains the labels, ie: \n[ 'Name', 'Special', 'Offset', 'Bytes', 'BytesCompressed' ] </td></tr>\n<tr><td>mount</td><td>mount(archive:string, mountdir:string=void):string </td><td>Mount zip on mount point. Read a ZIP archive and make entries in the virutal file hash table for all files contained therein.</td></tr>\n<tr><td>names</td><td>names(mountdir:string=void):array </td><td>Return all zvfs mounted zips, or archive for specified mount. Given an mount point argument, returns the archive for it. Otherwise, returns an array of mount points</td></tr>\n<tr><td>offset</td><td>offset(archive:string):number </td><td>Return the start offset of zip data. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>stat</td><td>stat(filename:string):object </td><td>Return details on file in zvfs mount. Return details about the given file in the ZVFS.  The information consists of (1) the name of the ZIP archive that contains the file, (2) the size of the file after decompressions, (3) the compressed size of the file, and (4) the offset of the compressed data in the archive.</td></tr>\n<tr><td>truncate</td><td>truncate(archive:string, noerror:boolean=false):number </td><td>Truncate zip data from archive. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>unmount</td><td>unmount(archive:string):void </td><td>Unmount zip.</td></tr>\n</table>\n<a name=\"Zvfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"console\"></a>\n\n<hr>\n\n\n<h1>console</h1>\n\n<font color=red>Synopsis:console.method(...)\n\n</font><p>Console input and output to stderr.\n\n\n<h2>Methods for \"console\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#console.assertOptions'>options</a>:object=void):void </td><td>Same as System.assert().</td></tr>\n<tr><td>error</td><td>error(val, ...):void </td><td>Same as log.</td></tr>\n<tr><td>input</td><td>input():string|void </td><td>Read input from the console.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as System.puts, but goes to stderr and includes file:line.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Same as System.printf but goes to stderr.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Same as System.puts, but goes to stderr.</td></tr>\n<tr><td>warn</td><td>warn(val, ...):void </td><td>Same as log.</td></tr>\n</table>\n\n\n<a name=\"console.assertOptions\"></a>\n<a name=\"console.confOptions\"></a>\n<h2>Options for \"console.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n<a name=\"consoleend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n</nowiki><p>\n"], "fixing_code": ["<title>Reference</title>\n<p>\n<div id=\"sectmenu\" data-opts=\"closed:false\"></div><B>JSI REFERENCE</B>: <a href=\"#System\">System</a> contains global methods\n<a name=\"Array\"></a>\n\n<hr>\n\n\n<h1>Array</h1>\n\n<font color=red>Synopsis:new Array(...):array\n\n</font><p>Provide access to array objects.\n\n\n<h2>Methods for \"Array\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Array</td><td>new Array(...):array </td><td>jsi_Array constructor.</td></tr>\n<tr><td>concat</td><td>concat(...):array </td><td>Return array with args appended.</td></tr>\n<tr><td>every</td><td>every(callback:function) </td><td>Returns true if every value in array satisfies the test.</td></tr>\n<tr><td>fill</td><td>fill(value:any, start:number=0, end:number=-1):array </td><td>Fill an array with values.</td></tr>\n<tr><td>filter</td><td>filter(callback:function, this:object=void):array </td><td>Return a filtered array.</td></tr>\n<tr><td>find</td><td>find(callback:function) </td><td>Returns the value of the first element in the array that satisfies the test.</td></tr>\n<tr><td>findIndex</td><td>findIndex(callback:function) </td><td>Returns the index of the first element in the array that satisfies the test.</td></tr>\n<tr><td>flat</td><td>flat(depth:number=1):array </td><td>Flatten an arra.</td></tr>\n<tr><td>forEach</td><td>forEach(callback:function, this:object=void):void </td><td>Invoke function with each item in object.</td></tr>\n<tr><td>includes</td><td>includes(val:any) </td><td>Returns true if array contains value.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:any, startIdx:number=0):number </td><td>Return index of first occurrance in array.</td></tr>\n<tr><td>isArray</td><td>isArray():boolean </td><td>True if val array.</td></tr>\n<tr><td>join</td><td>join(sep:string=''):string </td><td>Return elements joined by char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(val:any, start:number=0):number </td><td>Return index of last occurence in array.</td></tr>\n<tr><td>map</td><td>map(callback:function, this:object=void):array </td><td>Creates a new array with the results of calling a provided function on every element in this array.</td></tr>\n<tr><td>pop</td><td>pop() </td><td>Remove and return last element of array.</td></tr>\n<tr><td>push</td><td>push(val:any, ...):number </td><td>Push one or more elements onto array and return size.</td></tr>\n<tr><td>reduce</td><td>reduce(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reduceRight</td><td>reduceRight(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reverse</td><td>reverse():array </td><td>Reverse order of all elements in an array.</td></tr>\n<tr><td>shift</td><td>shift() </td><td>Remove first element and shift downwards.</td></tr>\n<tr><td>sizeOf</td><td>sizeOf():number </td><td>Return size of array.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number=void):array </td><td>Return sub-array.</td></tr>\n<tr><td>some</td><td>some(callback:function, this:object=void):boolean </td><td>Return true if function returns true some element.</td></tr>\n<tr><td>sort</td><td>sort(<a href='#Array.sortOptions'>options</a>:function|object=void):array </td><td>Sort an array.</td></tr>\n<tr><td>splice</td><td>splice(start:number, howmany:number=void, ...):array </td><td>Change the content of an array, adding new elements while removing old elements.</td></tr>\n<tr><td>unshift</td><td>unshift(...):number </td><td>Add new elements to start of array and return size.</td></tr>\n</table>\n\n\n<a name=\"Array.sortOptions\"></a>\n<a name=\"Array.confOptions\"></a>\n<h2>Options for \"Array.sort\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Mode to sort by. (one of: <b>default</b>, <b>desc</b>, <b>dict</b>, <b>nocase</b>)</td><td><i></i></td></tr>\n<tr><td>compare</td><td><i>FUNC</i></td><td>Function to do comparison. @function(val1,val2)</td><td><i></i></td></tr>\n<tr><td>unique</td><td><i>BOOL</i></td><td>Eliminate duplicate items.</td><td><i></i></td></tr>\n</table>\n<a name=\"Arrayend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Boolean\"></a>\n\n<hr>\n\n\n<h1>Boolean</h1>\n\n<font color=red>Synopsis:new Boolean(bool:boolean=false):boolean\n\n</font><p>A Boolean object.\n\n\n<h2>Methods for \"Boolean\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Boolean</td><td>new Boolean(bool:boolean=false):boolean </td><td>Boolean constructor.</td></tr>\n</table>\n<a name=\"Booleanend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CData\"></a>\n\n<hr>\n\n\n<h1>CData</h1>\n\n<font color=red>Synopsis:new CData(options:string&verbar;object=void, inits:object=undefined):userobj\n\n</font><p>\n<h2>Methods for \"CData\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>CData</td><td>new CData(<a href='#new CDataOptions'>options</a>:string|object=void, inits:object=undefined):userobj </td><td>Create a new struct or map/array of structs.The 2nd arg is used for function option parsing and will report errors at the callers file:line</td></tr>\n<tr><td>conf</td><td>conf(<a href='#CData.confOptions'>options</a>:object|string=void) </td><td>Configure options for c-data.</td></tr>\n<tr><td>get</td><td>get(key:string|number|object=null, field:string=void) </td><td>Get struct/map/array value.</td></tr>\n<tr><td>incr</td><td>incr(key:string|number|object|null, field:object|string, value:number=1):number </td><td>Increment a numeric field: returns the new value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info for data.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return keys for map.</td></tr>\n<tr><td>set</td><td>set(key:string|number|object|null, field:object|string, value:any=void) </td><td>Set a struct/map/array value.</td></tr>\n<tr><td>unset</td><td>unset(key:string|number|object) </td><td>Remove entry from map/array.</td></tr>\n</table>\n\n\n<a name=\"new CDataOptions\"></a>\n<a name=\"CData.confOptions\"></a>\n<h2>Options for \"new CData\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>If an array, its size in elements.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>UINT</i></td><td>Flags.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of data.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyName</td><td><i>STRKEY</i></td><td>Key struct, for key struct maps.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyType</td><td><i>STRKEY</i></td><td>Key id. (one of: <b>string</b>, <b>strkey</b>, <b>number</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>mapType</td><td><i>STRKEY</i></td><td>If a map, its type. (one of: <b>none</b>, <b>hash</b>, <b>tree</b>, <b>list</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>maxSize</td><td><i>UINT</i></td><td>Limit the array size or number of keys in a map.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name (eg. of var assigned to on create).</td><td><i>initOnly</i></td></tr>\n<tr><td>noAuto</td><td><i>BOOL</i></td><td>Disable auto-create of map keys in set/incr.</td><td><i></i></td></tr>\n<tr><td>structName</td><td><i>STRKEY</i></td><td>Struct used for storing data.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>varParam</td><td><i>STRKEY</i></td><td>Param for maps/array vars.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CDataend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CEnum\"></a>\n\n<hr>\n\n\n<h1>CEnum</h1>\n\n<font color=red>Synopsis:CEnum.method(...)\n\n</font><p>Enum commands. Note: Enum() is a shortcut for Enum.add().\n\n\n<h2>Methods for \"CEnum\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CEnum.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a new enum: value of items same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(enum:string, <a href='#CEnum.confOptions'>options</a>:object|string=void) </td><td>Configure options for enum.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(enum:string, field:string, <a href='#CEnum.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>find</td><td>find(enum:string, intValue:number):string </td><td>Find item with given value in enum.</td></tr>\n<tr><td>get</td><td>get(enum:string):object </td><td>Return enum definition.</td></tr>\n<tr><td>names</td><td>names(enum:string=void):array </td><td>Return name list of all enums, or items within one enum.</td></tr>\n<tr><td>remove</td><td>remove(enum:string) </td><td>Remove an enum.</td></tr>\n<tr><td>value</td><td>value(enum:string, item:string):number </td><td>Return value for given enum item.</td></tr>\n</table>\n\n\n<a name=\"CEnum.addOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.confOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.fieldconfOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Desciption of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Value for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Index of item in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"CEnumend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CStruct\"></a>\n\n<hr>\n\n\n<h1>CStruct</h1>\n\n<font color=red>Synopsis:CStruct.method(...)\n\n</font><p>Struct commands. Note: Struct() is a shortcut for Struct.add().\n\n\n<h2>Methods for \"CStruct\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CStruct.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a struct: field values same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(struct:string, <a href='#CStruct.confOptions'>options</a>:object|string=void) </td><td>Configure options for struct.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(struct:string, field:string, <a href='#CStruct.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>get</td><td>get(struct, options:object=void):object </td><td>Return the struct definition.</td></tr>\n<tr><td>names</td><td>names(struct:string=void):array </td><td>Return name list of all structs, or fields for one struct.</td></tr>\n<tr><td>remove</td><td>remove(name:string) </td><td>Remove a struct.</td></tr>\n<tr><td>schema</td><td>schema():string </td><td>Return database schema for struct.</td></tr>\n</table>\n\n\n<a name=\"CStruct.addOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.confOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.fieldconfOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>Size of field if an array.</td><td><i>initOnly</i></td></tr>\n<tr><td>bits</td><td><i>UINT32</i></td><td>Size of bitfield.</td><td><i>initOnly</i></td></tr>\n<tr><td>boffset</td><td><i>UINT32</i></td><td>Bit offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Index of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Field description.</td><td><i>initOnly</i></td></tr>\n<tr><td>info</td><td><i>STRKEY</i></td><td>Info for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>offset</td><td><i>UINT</i></td><td>Offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>type</td><td><i>CUSTOM</i></td><td>Type of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>init</td><td><i>CUSTOM</i></td><td>Initial value for field.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CStructend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CType\"></a>\n\n<hr>\n\n\n<h1>CType</h1>\n\n<font color=red>Synopsis:CType.method(...)\n\n</font><p>Type commands. Note: Type() is a shortcut for Type.conf().\n\n\n<h2>Methods for \"CType\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(typ:string, <a href='#CType.confOptions'>options</a>:object|string=void) </td><td>Configure options for type.</td></tr>\n<tr><td>names</td><td>names(ctype=false):array </td><td>Return type names.</td></tr>\n</table>\n\n\n<a name=\"CType.confOptions\"></a>\n<a name=\"CType.confOptions\"></a>\n<h2>Options for \"CType.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>idName</td><td><i>STRKEY</i></td><td>The id name: usually upcased cName.</td><td><i>initOnly</i></td></tr>\n<tr><td>cName</td><td><i>STRKEY</i></td><td>C type name.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of id.</td><td><i>initOnly</i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>xfmt</td><td><i>STRKEY</i></td><td>Hex printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>size</td><td><i>INT</i></td><td>Size for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n<a name=\"CTypeend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Channel\"></a>\n\n<hr>\n\n\n<h1>Channel</h1>\n\n<font color=red>Synopsis:new Channel(file:string, mode:string='r'):userobj\n\n</font><p>Commands for accessing Channel objects for file IO.\n\n\n<h2>Methods for \"Channel\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Channel</td><td>new Channel(file:string, mode:string='r'):userobj </td><td>A file input/output object. The mode string is r or w and an optional +.</td></tr>\n<tr><td>close</td><td>close():boolean </td><td>Close the file.</td></tr>\n<tr><td>eof</td><td>eof():boolean </td><td>Return true if read to end-of-file.</td></tr>\n<tr><td>filename</td><td>filename():string </td><td>Get file name.</td></tr>\n<tr><td>flush</td><td>flush():number </td><td>Flush file output.</td></tr>\n<tr><td>gets</td><td>gets():string|void </td><td>Get one line of input.</td></tr>\n<tr><td>lstat</td><td>lstat():object </td><td>Return status for file.</td></tr>\n<tr><td>mode</td><td>mode():string </td><td>Get file mode used with open.</td></tr>\n<tr><td>open</td><td>open(file:string, mode:string='r'):boolean </td><td>Open the file (after close).</td></tr>\n<tr><td>puts</td><td>puts(str):boolean </td><td>Write one line of output.</td></tr>\n<tr><td>read</td><td>read(size:number=-1):string|void </td><td>Read some or all of file.</td></tr>\n<tr><td>seek</td><td>seek(pos:number, whence:string):number </td><td>Seek to position. Return 0 if ok.</td></tr>\n<tr><td>stat</td><td>stat():object </td><td>Return status for file.</td></tr>\n<tr><td>tell</td><td>tell():number </td><td>Return current position.</td></tr>\n<tr><td>truncate</td><td>truncate(pos:number):number </td><td>Truncate file.</td></tr>\n<tr><td>write</td><td>write(data):number </td><td>Write data to file.</td></tr>\n</table>\n<a name=\"Channelend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Debugger\"></a>\n\n<hr>\n\n\n<h1>Debugger</h1>\n\n<font color=red>Synopsis:Debugger.method(...)\n\n</font><p>Debugger breakpoint management.\n\n\n<h2>Methods for \"Debugger\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(val:string|number, temp:boolean=false):number </td><td>Add a breakpoint for line, file:line or func.</td></tr>\n<tr><td>enable</td><td>enable(id:number, on:boolean):void </td><td>Enable/disable breakpoint.</td></tr>\n<tr><td>info</td><td>info(id:number=void):array|object </td><td>Return info about one breakpoint, or list of bp numbers.</td></tr>\n<tr><td>remove</td><td>remove(id:number):void </td><td>Remove breakpoint.</td></tr>\n</table>\n<a name=\"Debuggerend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Event\"></a>\n\n<hr>\n\n\n<h1>Event</h1>\n\n<font color=red>Synopsis:Event.method(...)\n\n</font><p>Event management.\n\n\n<h2>Methods for \"Event\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete an event (created with setInterval/setTimeout).</td></tr>\n<tr><td>info</td><td>info(id:number):object </td><td>Return info for the given event id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list event ids (created with setTimeout/setInterval).</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, millisecs:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, millisecs:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>update</td><td>update(<a href='#Event.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"Event.updateOptions\"></a>\n<a name=\"Event.confOptions\"></a>\n<h2>Options for \"Event.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Eventend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"File\"></a>\n\n<hr>\n\n\n<h1>File</h1>\n\n<font color=red>Synopsis:File.method(...)\n\n</font><p>Commands for accessing the filesystem.\n\n\n<h2>Methods for \"File\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>atime</td><td>atime(file:string):number </td><td>Return file Jsi_Access time.</td></tr>\n<tr><td>chdir</td><td>chdir(file:string) </td><td>Change current directory.</td></tr>\n<tr><td>chmod</td><td>chmod(file:string, mode:number) </td><td>Set file permissions.</td></tr>\n<tr><td>copy</td><td>copy(src:string, dest:string, force:boolean=false) </td><td>Copy a file to destination. Directories are not handled.\nThe third argument if given is a boolean force value which if true allows overwrite of an existing file. </td></tr>\n<tr><td>dirname</td><td>dirname(file:string):string </td><td>Return directory path.</td></tr>\n<tr><td>executable</td><td>executable(file:string):boolean </td><td>Return true if file is executable.</td></tr>\n<tr><td>exists</td><td>exists(file:string):boolean </td><td>Return true if file exists.</td></tr>\n<tr><td>extension</td><td>extension(file:string):string </td><td>Return file extension.</td></tr>\n<tr><td>glob</td><td>glob(pattern:regexp|string|null='*', <a href='#File.globOptions'>options</a>:function|object|null=void):array </td><td>Return list of files in dir with optional pattern match. With no arguments (or null) returns all files/directories in current directory.\nThe first argument can be a pattern (either a glob or regexp) of the files to return.\nWhen the second argument is a function, it is called with each path, and filter on false.\nOtherwise second argument must be a set of options.</td></tr>\n<tr><td>isdir</td><td>isdir(file:string):boolean </td><td>Return true if file is a directory.</td></tr>\n<tr><td>isfile</td><td>isfile(file:string):boolean </td><td>Return true if file is a normal file.</td></tr>\n<tr><td>isrelative</td><td>isrelative(file:string):boolean </td><td>Return true if file path is relative.</td></tr>\n<tr><td>join</td><td>join(path:string, path:string):string </td><td>Join two file realpaths, or just second if an absolute path.</td></tr>\n<tr><td>link</td><td>link(src:string, dest:string, ishard:boolean=false) </td><td>Link a file. The second argument is the destination file to be created. If a third bool argument is true, a hard link is created.</td></tr>\n<tr><td>lstat</td><td>lstat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>mkdir</td><td>mkdir(file:string,force:boolean=false) </td><td>Create a directory: force creates subdirs.</td></tr>\n<tr><td>mknod</td><td>mknod(file:string, mode:number, dev:number) </td><td>Create unix device file using mknod.</td></tr>\n<tr><td>mtime</td><td>mtime(file:string):number </td><td>Return file modified time.</td></tr>\n<tr><td>owned</td><td>owned(file:string):boolean </td><td>Return true if file is owned by user.</td></tr>\n<tr><td>pwd</td><td>pwd():string </td><td>Return current directory.</td></tr>\n<tr><td>read</td><td>read(file:string, mode:string='rb'):string </td><td>Read a file.</td></tr>\n<tr><td>readable</td><td>readable(file:string):boolean </td><td>Return true if file is readable.</td></tr>\n<tr><td>readlink</td><td>readlink(file:string):string </td><td>Read file link destination.</td></tr>\n<tr><td>realpath</td><td>realpath(file:string):string </td><td>Return absolute file name minus .., ./ etc.</td></tr>\n<tr><td>remove</td><td>remove(file:string, force:boolean=false) </td><td>Delete a file or direcotry.</td></tr>\n<tr><td>rename</td><td>rename(src:string, dest:string, force:boolean=false) </td><td>Rename a file, with possible overwrite.</td></tr>\n<tr><td>rootname</td><td>rootname(file:string):string </td><td>Return file name minus extension.</td></tr>\n<tr><td>size</td><td>size(file:string):number </td><td>Return size for file.</td></tr>\n<tr><td>stat</td><td>stat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>tail</td><td>tail(file:string):string </td><td>Return file name minus dirname.</td></tr>\n<tr><td>tempfile</td><td>tempfile(file:string) </td><td>Create a temp file.</td></tr>\n<tr><td>truncate</td><td>truncate(file:string, size:number) </td><td>Truncate file.</td></tr>\n<tr><td>type</td><td>type(file:string):string </td><td>Return type of file.</td></tr>\n<tr><td>writable</td><td>writable(file:string):boolean </td><td>Return true if file is writable.</td></tr>\n<tr><td>write</td><td>write(file:string, str:string, mode:string='wb+'):number </td><td>Write a file.</td></tr>\n</table>\n\n\n<a name=\"File.globOptions\"></a>\n<a name=\"File.confOptions\"></a>\n<h2>Options for \"File.glob\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>dir</td><td><i>STRING</i></td><td>The start directory: this path will not be prepended to results.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Maximum directory depth to recurse into.</td><td><i></i></td></tr>\n<tr><td>maxDiscard</td><td><i>INT</i></td><td>Maximum number of items to discard before giving up.</td><td><i></i></td></tr>\n<tr><td>dirFilter</td><td><i>FUNC</i></td><td>Filter function for directories, returning false to discard. @function(dir:string)</td><td><i></i></td></tr>\n<tr><td>filter</td><td><i>FUNC</i></td><td>Filter function to call with each file, returning false to discard. @function(file:string)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>The maximum number of results to return/count: -1 is unlimited (Interp.maxArrayList).</td><td><i></i></td></tr>\n<tr><td>noTypes</td><td><i>STRKEY</i></td><td>Filter files to exclude these \"types\".</td><td><i></i></td></tr>\n<tr><td>prefix</td><td><i>STRKEY</i></td><td>String prefix to prepend to each file in result list.</td><td><i></i></td></tr>\n<tr><td>recurse</td><td><i>BOOL</i></td><td>Recurse into sub-directories.</td><td><i></i></td></tr>\n<tr><td>retCount</td><td><i>BOOL</i></td><td>Return only the count of matches.</td><td><i></i></td></tr>\n<tr><td>tails</td><td><i>BOOL</i></td><td>Returned only tail of path.</td><td><i></i></td></tr>\n<tr><td>types</td><td><i>STRKEY</i></td><td>Filter files to include type: one or more of chars 'fdlpsbc' for file, directory, link, etc.</td><td><i></i></td></tr>\n</table>\n<a name=\"Fileend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Function\"></a>\n\n<hr>\n\n\n<h1>Function</h1>\n\n<font color=red>Synopsis:new Function():function\n\n</font><p>Commands for accessing functions.\n\n\n<h2>Methods for \"Function\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Function</td><td>new Function():function </td><td>Function constructor (unimplemented).</td></tr>\n<tr><td>apply</td><td>apply(thisArg:null|object|function, args:array=void) </td><td>Call function passing args array.</td></tr>\n<tr><td>bind</td><td>bind(thisArg:object|function=null,arg,...) </td><td>Return function that calls bound function prepended with thisArg+arguments.</td></tr>\n<tr><td>call</td><td>call(thisArg:null|object|function, arg1, ...) </td><td>Call function with args.</td></tr>\n</table>\n<a name=\"Functionend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Info\"></a>\n\n<hr>\n\n\n<h1>Info</h1>\n\n<font color=red>Synopsis:Info.method(...)\n\n</font><p>Commands for inspecting internal state information in JSI.\n\n\n<h2>Methods for \"Info\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argv0</td><td>argv0():string|void </td><td>Return initial start script file name.</td></tr>\n<tr><td>cmds</td><td>cmds(val:string|regexp='*', <a href='#Info.cmdsOptions'>options</a>:object=void):array|object </td><td>Return details or list of matching commands.</td></tr>\n<tr><td>completions</td><td>completions(str:string, start:number=0, end:number=void):array </td><td>Return command completions on portion of string from start to end.</td></tr>\n<tr><td>data</td><td>data(val:string|regexp|object=void):array|object </td><td>Return list of matching data (non-functions). Like info.vars(), but does not return function values.</td></tr>\n<tr><td>error</td><td>error():object </td><td>Return file and line number of error (used inside catch).</td></tr>\n<tr><td>event</td><td>event(id:number=void):array|object </td><td>List events or info for 1 event (setTimeout/setInterval). With no args, returns list of all outstanding events.  With one arg, returns infofor the given event id.</td></tr>\n<tr><td>execZip</td><td>execZip():string|void </td><td>If executing a .zip file, return file name.</td></tr>\n<tr><td>executable</td><td>executable():string </td><td>Return name of executable.</td></tr>\n<tr><td>files</td><td>files():array </td><td>Return list of all sourced files.</td></tr>\n<tr><td>funcs</td><td>funcs(string|regexp|object=void):array|object </td><td>Return details or list of matching functions.</td></tr>\n<tr><td>interp</td><td>interp(interp:userobj=void):object </td><td>Return info on given or current interp.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>keywords</td><td>keywords(isSql=false, name:string=void):boolean|array </td><td>Return/lookup reserved keyword.</td></tr>\n<tr><td>level</td><td>level(level:number=void):number|array|object </td><td>Return current level or details of a call-stack frame. With no arg, returns the number of the current stack frame level.\nOtherwise returns details on the specified level.\nThe topmost level is 1, and 0 is the current level, and a negative level translates as relative to the current level.</td></tr>\n<tr><td>locals</td><td>locals(filter:boolean=void):object </td><td>Return locals; use filter=true/false just vars/functions.</td></tr>\n<tr><td>lookup</td><td>lookup(name:string) </td><td>Given string name, lookup and return value, eg: function.</td></tr>\n<tr><td>methods</td><td>methods(val:string|regexp):array|object </td><td>Return functions and commands.</td></tr>\n<tr><td>named</td><td>named(name:string=void):array|userobj </td><td>Returns command names for builtin Objects, eg: 'File', 'Interp', sub-Object names, or the named object.</td></tr>\n<tr><td>options</td><td>options(ctype:boolean=false):array </td><td>Return Option type name, or with true the C type.</td></tr>\n<tr><td>package</td><td>package(pkgName:string):object|null </td><td>Return info about provided package if exists, else null.</td></tr>\n<tr><td>platform</td><td>platform():object </td><td>N/A. Returns general platform information for JSI.</td></tr>\n<tr><td>script</td><td>script(func:function|regexp=void):string|array|void </td><td>Get current script file name, or file containing function.</td></tr>\n<tr><td>scriptDir</td><td>scriptDir():string|void </td><td>Get directory of current script.</td></tr>\n<tr><td>vars</td><td>vars(val:string|regexp|object=void):array|object </td><td>Return details or list of matching variables. Returns all values, data or function.</td></tr>\n<tr><td>version</td><td>version(full:boolean=false):number|object </td><td>JSI version: returns object when full=true.</td></tr>\n</table>\n\n\n<a name=\"Info.cmdsOptions\"></a>\n<a name=\"Info.confOptions\"></a>\n<h2>Options for \"Info.cmds\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Return full path.</td><td><i></i></td></tr>\n<tr><td>constructor</td><td><i>BOOL</i></td><td>Do not exclude constructor.</td><td><i></i></td></tr>\n</table>\n<a name=\"Infoend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Interp\"></a>\n\n<hr>\n\n\n<h1>Interp</h1>\n\n<font color=red>Synopsis:new Interp(options:object=void):userobj\n\n</font><p>Commands for accessing interps.\n\n\n<h2>Methods for \"Interp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Interp</td><td>new Interp(<a href='#new InterpOptions'>options</a>:object=void):userobj </td><td>Create a new interp.</td></tr>\n<tr><td>alias</td><td>alias(name:string=void, func:function|null=void, args:array|null=void, async=false) </td><td>Set/get global alias bindings for command in an interp. With 0 args, returns list of all aliases in interp.\nWith 1 arg returns func for given alias name.\nWith 2 args where arg2 == null, returns args for given alias name .\nWith 3 args, create/update an alias for func and args. \nDelete an alias by creating it with null for both func and args.</td></tr>\n<tr><td>call</td><td>call(funcName:string, args:array, wait:boolean=false) </td><td>Call named function in subinterp. Invoke function in sub-interp with arguments.\nSince interps are not allowed to share objects, data is automatically cleansed by encoding/decoding to/from JSON if required.\nUnless an 'async' parameter is true call is acyncronous.\nOtherwise waits until the sub-interp is idle, to make call and return result.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Interp.confOptions'>options</a>:string|object=void) </td><td>Configure option(s).</td></tr>\n<tr><td>eval</td><td>eval(js:string, async:boolean=false) </td><td>Interpret script within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Returns internal statistics about interp.</td></tr>\n<tr><td>source</td><td>source(file:string, async:boolean=false) </td><td>Interpret file within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>uplevel</td><td>uplevel(js:string, level:number=0) </td><td>Interpret code at the given stack level. The level argument is as returned by Info.level().  Not supported with threads.</td></tr>\n<tr><td>value</td><td>value(var:string, level:number=0) </td><td>Lookup value of variable at stack level.</td></tr>\n</table>\n\n\n<a name=\"new InterpOptions\"></a>\n<a name=\"Interp.confOptions\"></a>\n<h2>Options for \"new Interp\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>args</td><td><i>ARRAY</i></td><td>The console.arguments for interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>asserts</td><td><i>BOOL</i></td><td>Enable assert.</td><td><i></i></td></tr>\n<tr><td>assertMode</td><td><i>STRKEY</i></td><td>Action upon assert failure. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>autoFiles</td><td><i>ARRAY</i></td><td>File(s) to source for loading Jsi_Auto to handle unknown commands.</td><td><i></i></td></tr>\n<tr><td>busyCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp (or noOp) to periodically call.</td><td><i></i></td></tr>\n<tr><td>busyInterval</td><td><i>INT</i></td><td>Call busyCallback command after this many op-code evals (100000).</td><td><i></i></td></tr>\n<tr><td>confFile</td><td><i>STRKEY</i></td><td>Config file of options in non-strict JSON form.</td><td><i>initOnly</i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>debugOpts</td><td><i><a href='#debugOptsOptions'>options</a></i></td><td>Options for debugging.</td><td><i></i></td></tr>\n<tr><td>interactive</td><td><i>BOOL</i></td><td>Force interactive mode. ie. ignore no_interactive flag.</td><td><i>initOnly</i></td></tr>\n<tr><td>hasOpenSSL</td><td><i>BOOL</i></td><td>Is SSL available in WebSocket.</td><td><i>initOnly</i></td></tr>\n<tr><td>historyFile</td><td><i>STRKEY</i></td><td>In interactive mode, file to use for history (~/.jsish_history).</td><td><i>initOnly</i></td></tr>\n<tr><td>isSafe</td><td><i>BOOL</i></td><td>Is this a safe interp (ie. with limited or no file access).</td><td><i>initOnly</i></td></tr>\n<tr><td>jsppChars</td><td><i>STRKEY</i></td><td>Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string.</td><td><i></i></td></tr>\n<tr><td>jsppCallback</td><td><i>FUNC</i></td><td>Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number).</td><td><i></i></td></tr>\n<tr><td>lockTimeout</td><td><i>INT</i></td><td>Thread time-out for mutex lock acquires (milliseconds).</td><td><i></i></td></tr>\n<tr><td>logOpts</td><td><i><a href='#logOptsOptions'>options</a></i></td><td>Options for log output to add file/line/time.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Depth limit of recursive function calls (1000).</td><td><i></i></td></tr>\n<tr><td>maxArrayList</td><td><i>UINT</i></td><td>Maximum array convertable to list (100000).</td><td><i></i></td></tr>\n<tr><td>maxIncDepth</td><td><i>INT</i></td><td>Maximum allowed source/require nesting depth (50).</td><td><i></i></td></tr>\n<tr><td>maxInterpDepth</td><td><i>INT</i></td><td>Maximum nested subinterp create depth (10).</td><td><i></i></td></tr>\n<tr><td>maxUserObjs</td><td><i>INT</i></td><td>Maximum number of 'new' object calls, eg. File, RegExp, etc.</td><td><i></i></td></tr>\n<tr><td>maxOpCnt</td><td><i>INT</i></td><td>Execution limit for op-code evaluation.</td><td><i>initOnly</i></td></tr>\n<tr><td>memDebug</td><td><i>INT</i></td><td>Memory debugging level: 1=summary, 2=detail.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Optional text name for this interp.</td><td><i></i></td></tr>\n<tr><td>noAutoLoad</td><td><i>BOOL</i></td><td>Disable autoload.</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Interp.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noInput</td><td><i>BOOL</i></td><td>Disable use of console.input().</td><td><i></i></td></tr>\n<tr><td>noLoad</td><td><i>BOOL</i></td><td>Disable load of shared libs.</td><td><i></i></td></tr>\n<tr><td>noNetwork</td><td><i>BOOL</i></td><td>Disable new Socket/WebSocket, or load of builtin MySql.</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Make puts, log, assert, etc use stdout.</td><td><i></i></td></tr>\n<tr><td>noSubInterps</td><td><i>BOOL</i></td><td>Disallow sub-interp creation.</td><td><i></i></td></tr>\n<tr><td>onComplete</td><td><i>FUNC</i></td><td>Function to return commands completions for interactive mode.  Default uses Info.completions . @function(prefix:string, start:number, end:number)</td><td><i></i></td></tr>\n<tr><td>onEval</td><td><i>FUNC</i></td><td>Function to get control for interactive evals. @function(cmd:string)</td><td><i></i></td></tr>\n<tr><td>onExit</td><td><i>FUNC</i></td><td>Command to call in parent on exit, returns true to continue. @function()</td><td><i>initOnly</i></td></tr>\n<tr><td>pkgDirs</td><td><i>ARRAY</i></td><td>list of library directories for require() to search.</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>retValue</td><td><i>VALUE</i></td><td>Return value from last eval.</td><td><i>readOnly</i></td></tr>\n<tr><td>safeMode</td><td><i>STRKEY</i></td><td>In safe mode source() support for pwd and script-dir . (one of: <b>none</b>, <b>read</b>, <b>write</b>, <b>writeRead</b>, <b>lockdown</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>safeReadDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow reads to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeWriteDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow writes to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeExecPattern</td><td><i>STRKEY</i></td><td>In safe mode, regexp pattern allow exec of commands.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptStr</td><td><i>STRKEY</i></td><td>Interp init script string.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptFile</td><td><i>STRING</i></td><td>Interp init script file.</td><td><i></i></td></tr>\n<tr><td>stdinStr</td><td><i>STRING</i></td><td>String to use as stdin for console.input().</td><td><i></i></td></tr>\n<tr><td>stdoutStr</td><td><i>STRING</i></td><td>String to collect stdout for puts().</td><td><i></i></td></tr>\n<tr><td>strict</td><td><i>BOOL</i></td><td>Globally enable strict: same as 'use strict' in main program.</td><td><i></i></td></tr>\n<tr><td>subOpts</td><td><i><a href='#subOptsOptions'>options</a></i></td><td>Infrequently used sub-options.</td><td><i></i></td></tr>\n<tr><td>subthread</td><td><i>BOOL</i></td><td>Create a threaded Interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n<tr><td>traceOp</td><td><i>INT</i></td><td>Set debugging level for OPCODE execution.</td><td><i></i></td></tr>\n<tr><td>tracePuts</td><td><i>BOOL</i></td><td>Trace puts by making it use logOpts.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>ARRAY</i></td><td>Type-check control options. (zero or more of: <b>parse</b>, <b>run</b>, <b>all</b>, <b>error</b>, <b>strict</b>, <b>noundef</b>, <b>nowith</b>, <b>funcsig</b>)</td><td><i></i></td></tr>\n<tr><td>typeWarnMax</td><td><i>INT</i></td><td>Type checking is silently disabled after this many warnings (50).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>unitTest</td><td><i>UINT</i></td><td>Unit test control bits: 1=subst, 2=Puts with file:line prefix.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"debugOptsOptions\"></a>\n<h2>Options for \"debugOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>debugCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp for handling debugging.</td><td><i></i></td></tr>\n<tr><td>doContinue</td><td><i>BOOL</i></td><td>Continue execution until breakpoint.</td><td><i></i></td></tr>\n<tr><td>forceBreak</td><td><i>BOOL</i></td><td>Force debugger to break.</td><td><i></i></td></tr>\n<tr><td>includeOnce</td><td><i>BOOL</i></td><td>Source the file only if not already sourced.</td><td><i></i></td></tr>\n<tr><td>includeTrace</td><td><i>BOOL</i></td><td>Trace includes.</td><td><i></i></td></tr>\n<tr><td>minLevel</td><td><i>INT</i></td><td>Disable eval callback for level higher than this.</td><td><i></i></td></tr>\n<tr><td>msgCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,...</td><td><i></i></td></tr>\n<tr><td>pkgTrace</td><td><i>BOOL</i></td><td>Trace package loads.</td><td><i></i></td></tr>\n<tr><td>putsCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle puts output.</td><td><i></i></td></tr>\n<tr><td>traceCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle traceCall.</td><td><i></i></td></tr>\n<tr><td>testFmtCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to format unittest string.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"logOptsOptions\"></a>\n<h2>Options for \"logOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages.</td><td><i></i></td></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages.</td><td><i></i></td></tr>\n<tr><td>Info</td><td><i>BOOL</i></td><td>Enable LogInfo messages.</td><td><i></i></td></tr>\n<tr><td>Warn</td><td><i>BOOL</i></td><td>Enable LogWarn messages.</td><td><i></i></td></tr>\n<tr><td>Error</td><td><i>BOOL</i></td><td>Enable LogError messages.</td><td><i></i></td></tr>\n<tr><td>time</td><td><i>BOOL</i></td><td>Prefix with time.</td><td><i></i></td></tr>\n<tr><td>date</td><td><i>BOOL</i></td><td>Prefix with date.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>BOOL</i></td><td>Ouptut contains file:line.</td><td><i></i></td></tr>\n<tr><td>func</td><td><i>BOOL</i></td><td>Output function.</td><td><i></i></td></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Show full file path.</td><td><i></i></td></tr>\n<tr><td>ftail</td><td><i>BOOL</i></td><td>Show tail of file only, even in LogWarn, etc.</td><td><i></i></td></tr>\n<tr><td>before</td><td><i>BOOL</i></td><td>Output file:line before message string.</td><td><i></i></td></tr>\n<tr><td>isUTC</td><td><i>BOOL</i></td><td>Time is to be UTC.</td><td><i></i></td></tr>\n<tr><td>timeFmt</td><td><i>STRKEY</i></td><td>A format string to use with strftime.</td><td><i></i></td></tr>\n<tr><td>chan</td><td><i>USEROBJ</i></td><td>Channel to send output to.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"subOptsOptions\"></a>\n<h2>Options for \"subOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>blacklist</td><td><i>STRKEY</i></td><td>Comma separated modules to disable loading for.</td><td><i>initOnly</i></td></tr>\n<tr><td>compat</td><td><i>BOOL</i></td><td>Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser.</td><td><i></i></td></tr>\n<tr><td>dblPrec</td><td><i>INT</i></td><td>Format precision of double where 0=max, -1=max-1, ... (max-1).</td><td><i></i></td></tr>\n<tr><td>istty</td><td><i>BOOL</i></td><td>Indicates interp is in interactive mode.</td><td><i>readOnly</i></td></tr>\n<tr><td>logColNums</td><td><i>BOOL</i></td><td>Display column numbers in error messages.</td><td><i></i></td></tr>\n<tr><td>logAllowDups</td><td><i>BOOL</i></td><td>Log should not filter out duplicate messages.</td><td><i></i></td></tr>\n<tr><td>mutexUnlock</td><td><i>BOOL</i></td><td>Unlock own mutex when evaling in other interps (true).</td><td><i>initOnly</i></td></tr>\n<tr><td>noproto</td><td><i>BOOL</i></td><td>Disable support of the OOP symbols:  __proto__, prototype, constructor, etc.</td><td><i></i></td></tr>\n<tr><td>noFuncString</td><td><i>BOOL</i></td><td>Disable viewing code body for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noRegex</td><td><i>BOOL</i></td><td>Disable viewing code for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noReadline</td><td><i>BOOL</i></td><td>In interactive mode disable use of readline.</td><td><i></i></td></tr>\n<tr><td>outUndef</td><td><i>BOOL</i></td><td>In interactive mode output result values that are undefined.</td><td><i></i></td></tr>\n<tr><td>prompt</td><td><i>STRKEY</i></td><td>Prompt for interactive mode ('$ ').</td><td><i></i></td></tr>\n<tr><td>prompt2</td><td><i>STRKEY</i></td><td>Prompt for interactive mode line continue ('> ').</td><td><i></i></td></tr>\n</table>\n<a name=\"Interpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"JSON\"></a>\n\n<hr>\n\n\n<h1>JSON</h1>\n\n<font color=red>Synopsis:JSON.method(...)\n\n</font><p>Commands for handling JSON data.\n\n\n<h2>Methods for \"JSON\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>check</td><td>check(str:string, strict:boolean=true):boolean </td><td>Return true if str is JSON.</td></tr>\n<tr><td>parse</td><td>parse(str:string, strict:boolean=true) </td><td>Parse JSON and return js.</td></tr>\n<tr><td>stringify</td><td>stringify(value:any,  strict:boolean=true):string </td><td>Return JSON from a js object.</td></tr>\n</table>\n<a name=\"JSONend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Math\"></a>\n\n<hr>\n\n\n<h1>Math</h1>\n\n<font color=red>Synopsis:Math.method(...)\n\n</font><p>Commands performing math operations on numbers.\n\n\n<h2>Methods for \"Math\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>abs</td><td>abs(num:number):number </td><td>Returns the absolute value of x.</td></tr>\n<tr><td>acos</td><td>acos(num:number):number </td><td>Returns the arccosine of x, in radians.</td></tr>\n<tr><td>asin</td><td>asin(num:number):number </td><td>Returns the arcsine of x, in radians.</td></tr>\n<tr><td>atan</td><td>atan(num:number):number </td><td>Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians.</td></tr>\n<tr><td>atan2</td><td>atan2(x:number, y:number):number </td><td>Returns the arctangent of the quotient of its arguments.</td></tr>\n<tr><td>ceil</td><td>ceil(num:number):number </td><td>Returns x, rounded upwards to the nearest integer.</td></tr>\n<tr><td>cos</td><td>cos(num:number):number </td><td>Returns the cosine of x (x is in radians).</td></tr>\n<tr><td>exp</td><td>exp(num:number):number </td><td>Returns the value of Ex.</td></tr>\n<tr><td>floor</td><td>floor(num:number):number </td><td>Returns x, rounded downwards to the nearest integer.</td></tr>\n<tr><td>log</td><td>log(num:number):number </td><td>Returns the natural logarithm (base E) of x.</td></tr>\n<tr><td>max</td><td>max(x:number, y:number, ...):number </td><td>Returns the number with the highest value.</td></tr>\n<tr><td>min</td><td>min(x:number, y:number, ...):number </td><td>Returns the number with the lowest value.</td></tr>\n<tr><td>pow</td><td>pow(x:number, y:number):number </td><td>Returns the value of x to the power of y.</td></tr>\n<tr><td>random</td><td>random():number </td><td>Returns a random number between 0 and 1.</td></tr>\n<tr><td>round</td><td>round(num:number):number </td><td>Rounds x to the nearest integer.</td></tr>\n<tr><td>sin</td><td>sin(num:number):number </td><td>Returns the sine of x (x is in radians).</td></tr>\n<tr><td>sqrt</td><td>sqrt(num:number):number </td><td>Returns the square root of x.</td></tr>\n<tr><td>srand</td><td>srand(seed:number):number </td><td>Set random seed.</td></tr>\n<tr><td>tan</td><td>tan(num:number):number </td><td>Returns the tangent of an angle.</td></tr>\n</table>\n<a name=\"Mathend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"MySql\"></a>\n\n<hr>\n\n\n<h1>MySql</h1>\n\n<font color=red>Synopsis:new MySql(options:object=void):userobj\n\n</font><p>Commands for accessing mysql databases.\n\n\n<h2>Methods for \"MySql\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>MySql</td><td>new MySql(<a href='#new MySqlOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to a MySql database:.</td></tr>\n<tr><td>affectedRows</td><td>affectedRows():number </td><td>Return affected rows.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#MySql.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>errorNo</td><td>errorNo():number </td><td>Return error code returned by most recent call to mysql3_exec().</td></tr>\n<tr><td>errorState</td><td>errorState():string </td><td>Return the mysql error state str.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output.</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info about last query.</td></tr>\n<tr><td>lastQuery</td><td>lastQuery():string </td><td>Return info string about most recently executed statement.</td></tr>\n<tr><td>lastRowid</td><td>lastRowid():number </td><td>Return rowid of last insert.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>ping</td><td>ping(noError:boolean=false):number </td><td>Ping connection.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#MySql.queryOptions'>options</a>:function|string|array|object=void) </td><td>Run sql query with input and/or outputs..</td></tr>\n<tr><td>reconnect</td><td>reconnect():void </td><td>Reconnect with current settings.</td></tr>\n<tr><td>reset</td><td>reset():number </td><td>Reset connection.</td></tr>\n</table>\n\n\n<a name=\"new MySqlOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"new MySql\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>database</td><td><i>STRKEY</i></td><td>Database to use.</td><td><i>initOnly</i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>enableMulti</td><td><i>BOOL</i></td><td>Accept muiltiple semi-colon separated statements in eval().</td><td><i>initOnly</i></td></tr>\n<tr><td>errorCnt</td><td><i>INT</i></td><td>Count of errors.</td><td><i>readOnly</i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>host</td><td><i>STRING</i></td><td>IP address or host name for mysqld (default is 127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>maxStmts</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>Name for this db handle.</td><td><i></i></td></tr>\n<tr><td>numStmts</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>password</td><td><i>STRKEY</i></td><td>Database password..</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>IP port for mysqld.</td><td><i>initOnly</i></td></tr>\n<tr><td>reconnect</td><td><i>BOOL</i></td><td>Reconnect.</td><td><i></i></td></tr>\n<tr><td>sslKey</td><td><i>STRING</i></td><td>SSL key.</td><td><i></i></td></tr>\n<tr><td>sslCert</td><td><i>STRING</i></td><td>SSL Cert.</td><td><i></i></td></tr>\n<tr><td>sslCA</td><td><i>STRING</i></td><td>SSL CA.</td><td><i></i></td></tr>\n<tr><td>sslCAPath</td><td><i>STRING</i></td><td>SSL CA path.</td><td><i></i></td></tr>\n<tr><td>sslCipher</td><td><i>STRING</i></td><td>SSL Cipher.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data..</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>STRKEY</i></td><td>Database user name. Default is current user-name..</td><td><i>initOnly</i></td></tr>\n<tr><td>version</td><td><i>DOUBLE</i></td><td>Mysql version number.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"MySql.queryOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"MySql.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"MySqlend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Number\"></a>\n\n<hr>\n\n\n<h1>Number</h1>\n\n<font color=red>Synopsis:new Number(num:string=0):number\n\n</font><p>Commands for accessing number objects.\n\n\n<h2>Methods for \"Number\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Number</td><td>new Number(num:string=0):number </td><td>Number constructor.</td></tr>\n<tr><td>isFinite</td><td>isFinite():boolean </td><td>Return true if is finite.</td></tr>\n<tr><td>isInteger</td><td>isInteger():boolean </td><td>Return true if is an integer.</td></tr>\n<tr><td>isNaN</td><td>isNaN():boolean </td><td>Return true if is NaN.</td></tr>\n<tr><td>isSafeInteger</td><td>isSafeInteger():boolean </td><td>Return true if is a safe integer.</td></tr>\n<tr><td>toExponential</td><td>toExponential(num:number):string </td><td>Converts a number into an exponential notation.</td></tr>\n<tr><td>toFixed</td><td>toFixed(num:number=0):string </td><td>Formats a number with x numbers of digits after the decimal point.</td></tr>\n<tr><td>toPrecision</td><td>toPrecision(num:number):string </td><td>Formats a number to x length.</td></tr>\n<tr><td>toString</td><td>toString(radix:number=10):string </td><td>Convert to string.</td></tr>\n</table>\n<a name=\"Numberend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Object\"></a>\n\n<hr>\n\n\n<h1>Object</h1>\n\n<font color=red>Synopsis:new Object(val:object&verbar;function|null=void):object\n\n</font><p>Commands for accessing Objects.\n\n\n<h2>Methods for \"Object\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Object</td><td>new Object(val:object|function|null=void):object </td><td>Object constructor.</td></tr>\n<tr><td>create</td><td>create(proto:null|object, properties:object=void):object </td><td>Create a new object with prototype object and properties.</td></tr>\n<tr><td>getPrototypeOf</td><td>getPrototypeOf(name:object|function):function|object </td><td>Return prototype of an object.</td></tr>\n<tr><td>hasOwnProperty</td><td>hasOwnProperty(name:string):boolean </td><td>Returns a true if object has the specified property.</td></tr>\n<tr><td>is</td><td>is(value1, value2):boolean </td><td>Tests if two values are equal.</td></tr>\n<tr><td>isPrototypeOf</td><td>isPrototypeOf(name):boolean </td><td>Tests for an object in another object's prototype chain.</td></tr>\n<tr><td>keys</td><td>keys(obj:object|function=void):array </td><td>Return the keys of an object or array.</td></tr>\n<tr><td>merge</td><td>merge(obj:object|function):object </td><td>Return new object containing merged values.</td></tr>\n<tr><td>propertyIsEnumerable</td><td>propertyIsEnumerable(name):boolean </td><td>Determine if a property is enumerable.</td></tr>\n<tr><td>setPrototypeOf</td><td>setPrototypeOf(name:object, value:object) </td><td>Set prototype of an object.</td></tr>\n<tr><td>toLocaleString</td><td>toLocaleString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>toString</td><td>toString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>valueOf</td><td>valueOf() </td><td>Returns primitive value.</td></tr>\n</table>\n<a name=\"Objectend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"RegExp\"></a>\n\n<hr>\n\n\n<h1>RegExp</h1>\n\n<font color=red>Synopsis:new RegExp(val:regexp&verbar;string, flags:string):regexp\n\n</font><p>Commands for managing reqular expression objects.\n\n\n<h2>Methods for \"RegExp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>RegExp</td><td>new RegExp(val:regexp|string, flags:string):regexp </td><td>Create a regexp object.</td></tr>\n<tr><td>exec</td><td>exec(val:string):array|object|null </td><td>return matching string. Perform regexp match checking.  Returns the array of matches.With the global flag g, sets lastIndex and returns next match.</td></tr>\n<tr><td>test</td><td>test(val:string):boolean </td><td>test if a string matches.</td></tr>\n</table>\n<a name=\"RegExpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Signal\"></a>\n\n<hr>\n\n\n<h1>Signal</h1>\n\n<font color=red>Synopsis:Signal.method(...)\n\n</font><p>Commands for handling unix signals.\n\n\n<h2>Methods for \"Signal\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>alarm</td><td>alarm(secs):number </td><td>Setup alarm in seconds.</td></tr>\n<tr><td>callback</td><td>callback(func:function, sig:number|string):number </td><td>Setup callback handler for signal.</td></tr>\n<tr><td>handle</td><td>handle(sig:number|string=void, ...) </td><td>Set named signals to handle action.</td></tr>\n<tr><td>ignore</td><td>ignore(sig:number|string=void, ...) </td><td>Set named signals to ignore action.</td></tr>\n<tr><td>kill</td><td>kill(pid:number, sig:number|string='SIGTERM'):void </td><td>Send signal to process id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return names of all signals.</td></tr>\n<tr><td>reset</td><td>reset(sig:number|string=void, ...):array </td><td>Set named signals to default action.</td></tr>\n</table>\n<a name=\"Signalend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Socket\"></a>\n\n<hr>\n\n\n<h1>Socket</h1>\n\n<font color=red>Synopsis:new Socket(options:object=void):userobj\n\n</font><p>Commands for managing Socket server/client connections.\n\n\n<h2>Methods for \"Socket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Socket</td><td>new Socket(<a href='#new SocketOptions'>options</a>:object=void):userobj </td><td>Create socket server/client object.Create a socket server or client object.</td></tr>\n<tr><td>close</td><td>close():void </td><td>Close socket(s).</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Socket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number=void, <a href='#Socket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for a connection id, or return list of ids.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list of active ids on server.</td></tr>\n<tr><td>recv</td><td>recv(id:number=void):string </td><td>Recieve data.</td></tr>\n<tr><td>send</td><td>send(id:number, data:string, <a href='#Socket.sendOptions'>options</a>:object=void):void </td><td>Send a socket message to id. Send a message to a (or all if -1) connection.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this socket.</td></tr>\n</table>\n\n\n<a name=\"new SocketOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"new Socket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>Client destination address (127.0.0.0).</td><td><i>initOnly</i></td></tr>\n<tr><td>broadcast</td><td><i>BOOL</i></td><td>Enable broadcast.</td><td><i>initOnly</i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Enable client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Counter for number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createLast</td><td><i>TIME_T</i></td><td>Time of last create.</td><td><i>readOnly</i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Debugging level.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>keepalive</td><td><i>BOOL</i></td><td>Enable keepalive.</td><td><i>initOnly</i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>mcastAddMember</td><td><i>STRING</i></td><td>Multicast add membership: address/interface ('127.0.0.1/0.0.0.0').</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastInterface</td><td><i>STRING</i></td><td>Multicast interface address.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastNoLoop</td><td><i>BOOL</i></td><td>Multicast loopback disable.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastTtl</td><td><i>INT</i></td><td>Multicast TTL.</td><td><i>initOnly</i></td></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i>initOnly</i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Stop processing update events (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when connection closes. @function(s:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last connection closes. On object delete arg is null. @function(s:userobj|null)</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Socket.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when connection opens. @function(s:userobj, info:object)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call with recieved data. @function(s:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for client dest or server listen.</td><td><i>initOnly</i></td></tr>\n<tr><td>quiet</td><td><i>BOOL</i></td><td>Suppress info messages.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvTimeout</td><td><i>UINT64</i></td><td>Timeout for receive, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>sendTimeout</td><td><i>UINT64</i></td><td>Timeout for send, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcAddress</td><td><i>STRING</i></td><td>Client source address.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcPort</td><td><i>INT</i></td><td>Client source port.</td><td><i>initOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of start.</td><td><i>readOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>timeout</td><td><i>NUMBER</i></td><td>Timeout value in seconds (0.5).</td><td><i>initOnly</i></td></tr>\n<tr><td>tos</td><td><i>INT8</i></td><td>Type-Of-Service value.</td><td><i>initOnly</i></td></tr>\n<tr><td>ttl</td><td><i>INT</i></td><td>Time-To-Live value.</td><td><i>initOnly</i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>udp</td><td><i>BOOL</i></td><td>Protocol is udp.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.idconfOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.sendOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.send\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i></i></td></tr>\n</table>\n<a name=\"Socketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Sqlite\"></a>\n\n<hr>\n\n\n<h1>Sqlite</h1>\n\n<font color=red>Synopsis:new Sqlite(file:null&verbar;string=void, options:object=void):userobj\n\n</font><p>Commands for accessing sqlite databases.\n\n\n<h2>Methods for \"Sqlite\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Sqlite</td><td>new Sqlite(file:null|string=void, <a href='#new SqliteOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to the named file or :memory:.</td></tr>\n<tr><td>backup</td><td>backup(file:string, dbname:string='main'):void </td><td>Backup db to file. Open or create a database file named FILENAME.\nTransfer the content of local database DATABASE (default: 'main') into the FILENAME database.</td></tr>\n<tr><td>collate</td><td>collate(name:string, callback:function):void </td><td>Create new SQL collation command.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Sqlite.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output. Supports multiple semicolon seperated commands.\nVariable binding is NOT performed, results are discarded, and  returns sqlite3_changes()</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>filename</td><td>filename(name:string='main'):string </td><td>Return filename for named or all attached databases.</td></tr>\n<tr><td>func</td><td>func(name:string, callback:function, numArgs:number=void):void </td><td>Register a new function with database.</td></tr>\n<tr><td>import</td><td>import(table:string, file:string, <a href='#Sqlite.importOptions'>options</a>:object=void):number </td><td>Import data from file into table . Import data from a file into table. SqlOptions include the 'separator' to use, which defaults to commas for csv, or tabs otherwise.\nIf a column contains a null string, or the value of 'nullvalue', a null is inserted for the column.\nA 'conflict' is one of the sqlite conflict algorithms:    rollback, abort, fail, ignore, replace\nOn success, return the number of lines processed, not necessarily same as 'changeCnt' due to the conflict algorithm selected. </td></tr>\n<tr><td>interrupt</td><td>interrupt():void </td><td>Interrupt in progress statement.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#Sqlite.queryOptions'>options</a>:function|string|array|object=void) </td><td>Evaluate an sql query with bindings. Return values in formatted as JSON, HTML, etc. , optionally calling function with a result object</td></tr>\n<tr><td>restore</td><td>restore(file:string, dbname:string):void </td><td>Restore db from file (default db is 'main').    db.restore(FILENAME, ?,DATABASE? ) \nOpen a database file named FILENAME.  Transfer the content of FILENAME into the local database DATABASE (default: 'main').</td></tr>\n<tr><td>transaction</td><td>transaction(callback:function, type:string=void):void </td><td>Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'. Start a new transaction (if we are not already in the midst of a transaction) and execute the JS function FUNC.\nAfter FUNC completes, either commit the transaction or roll it back if FUNC throws an exception.\nOr if no new transation was started, do nothing. pass the exception on up the stack.</td></tr>\n</table>\n\n\n<a name=\"new SqliteOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"new Sqlite\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>changeCnt</td><td><i>INT</i></td><td>The number of rows modified, inserted, or deleted by last command.</td><td><i></i></td></tr>\n<tr><td>changeCntAll</td><td><i>INT</i></td><td>Total number of rows modified, inserted, or deleted since db opened.</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query/eval string to log.</td><td><i></i></td></tr>\n<tr><td>errCnt</td><td><i>INT</i></td><td>Count of errors in script callbacks.</td><td><i>readOnly</i></td></tr>\n<tr><td>errorCode</td><td><i>INT</i></td><td>Numeric error code returned by the most recent call to sqlite3_exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>noJsonConv</td><td><i>BOOL</i></td><td>Do not JSON auto-convert array and object in CHARJSON columns.</td><td><i></i></td></tr>\n<tr><td>lastInsertId</td><td><i>UINT64</i></td><td>The rowid of last insert.</td><td><i></i></td></tr>\n<tr><td>load</td><td><i>BOOL</i></td><td>Extensions can be loaded.</td><td><i></i></td></tr>\n<tr><td>mutex</td><td><i>STRKEY</i></td><td>Mutex type to use. (one of: <b>default</b>, <b>none</b>, <b>full</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>The dbname to use instead of 'main'.</td><td><i>initOnly</i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Sqlite.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCreate</td><td><i>BOOL</i></td><td>Database is must already exist (false).</td><td><i>initOnly</i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for auth. @function(db:userobj, code:string, descr1:string, decr2:string, dbname:string, trigname:string)</td><td><i></i></td></tr>\n<tr><td>onBusy</td><td><i>FUNC</i></td><td>Function to call when busy. @function(db:userobj, tries:number)</td><td><i></i></td></tr>\n<tr><td>onCommit</td><td><i>FUNC</i></td><td>Function to call on commit. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onNeedCollate</td><td><i>FUNC</i></td><td>Function to call for collation. @function(db:userobj, name:string)</td><td><i></i></td></tr>\n<tr><td>onProfile</td><td><i>FUNC</i></td><td>Function to call for profile. @function(db:userobj, sql:string, time:number)</td><td><i></i></td></tr>\n<tr><td>onProgress</td><td><i>FUNC</i></td><td>Function to call for progress: progressSteps must be >0. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onRollback</td><td><i>FUNC</i></td><td>Function to call for rollback. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onTrace</td><td><i>FUNC</i></td><td>Function to call for trace. @function(db:userobj, sql:string)</td><td><i></i></td></tr>\n<tr><td>onUpdate</td><td><i>FUNC</i></td><td>Function to call for update. @function(db:userobj, op:string, dbname:string, table:string, rowid:number)</td><td><i></i></td></tr>\n<tr><td>onWalHook</td><td><i>FUNC</i></td><td>Function to call for WAL. @function(db:userobj, dbname:string, entry:number)</td><td><i></i></td></tr>\n<tr><td>progressSteps</td><td><i>UINT</i></td><td>Number of steps between calling onProgress: 0 is disabled.</td><td><i></i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for to use with query().</td><td><i></i></td></tr>\n<tr><td>readonly</td><td><i>BOOL</i></td><td>Database opened in readonly mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>sortCnt</td><td><i>INT</i></td><td>Number of sorts in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stepCnt</td><td><i>INT</i></td><td>Number of steps in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheCnt</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheMax</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>Sqlite version info.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>vfs</td><td><i>STRING</i></td><td>VFS to use.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.importOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.import\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row contains column labels.</td><td><i></i></td></tr>\n<tr><td>csv</td><td><i>BOOL</i></td><td>Treat input values as CSV.</td><td><i></i></td></tr>\n<tr><td>conflict</td><td><i>STRKEY</i></td><td>Set conflict resolution. (one of: <b>ROLLBACK</b>, <b>ABORT</b>, <b>FAIL</b>, <b>IGNORE</b>, <b>REPLACE</b>)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of lines to load.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string; default is comma if csv, else tabs.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.queryOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"Sqliteend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"String\"></a>\n\n<hr>\n\n\n<h1>String</h1>\n\n<font color=red>Synopsis:new String(str):string\n\n</font><p>Commands for accessing string objects..\n\n\n<h2>Methods for \"String\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>String</td><td>new String(str):string </td><td>String constructor.</td></tr>\n<tr><td>charAt</td><td>charAt(index:number):string </td><td>Return char at index.</td></tr>\n<tr><td>charCodeAt</td><td>charCodeAt(index:number):number </td><td>Return char code at index.</td></tr>\n<tr><td>concat</td><td>concat(str:string, ...):string </td><td>Append one or more strings.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(...):string </td><td>Return string for char codes.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:string, start:number):number </td><td>Return index of char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(str:string, start:number):number </td><td>Return index of last char.</td></tr>\n<tr><td>map</td><td>map(strMap:array, nocase:boolean=false):string </td><td>Replaces characters in string based on the key-value pairs in strMap.</td></tr>\n<tr><td>match</td><td>match(pattern:regexp|string):array|null </td><td>Return array of matches.</td></tr>\n<tr><td>repeat</td><td>repeat(count:number):string </td><td>Return count copies of string.</td></tr>\n<tr><td>replace</td><td>replace(pattern:regexp|string, replace:string|function):string </td><td>Regex/string replacement. If the replace argument is a function, it is called with match,p1,p2,...,offset,string.  If called function is known to have 1 argument, it is called with just the match.</td></tr>\n<tr><td>search</td><td>search(pattern:regexp|string):number </td><td>Return index of first char matching pattern.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number):string </td><td>Return section of string.</td></tr>\n<tr><td>split</td><td>split(char:string|null=void):array </td><td>Split on char and return Array. When char is omitted splits on bytes.  When char==null splits on whitespace and removes empty elements.</td></tr>\n<tr><td>substr</td><td>substr(start:number, length:number):string </td><td>Return substring.</td></tr>\n<tr><td>substring</td><td>substring(start:number, end:number):string </td><td>Return substring.</td></tr>\n<tr><td>toLocaleLowerCase</td><td>toLocaleLowerCase():string </td><td>Lower case.</td></tr>\n<tr><td>toLocaleUpperCase</td><td>toLocaleUpperCase():string </td><td>Upper case.</td></tr>\n<tr><td>toLowerCase</td><td>toLowerCase():string </td><td>Return lower cased string.</td></tr>\n<tr><td>toTitle</td><td>toTitle(chars:string):string </td><td>Make first char upper case.</td></tr>\n<tr><td>toUpperCase</td><td>toUpperCase():string </td><td>Return upper cased string.</td></tr>\n<tr><td>trim</td><td>trim(chars:string):string </td><td>Trim chars.</td></tr>\n<tr><td>trimLeft</td><td>trimLeft(chars:string):string </td><td>Trim chars from left.</td></tr>\n<tr><td>trimRight</td><td>trimRight(chars:string):string </td><td>Trim chars from right.</td></tr>\n</table>\n<a name=\"Stringend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"System\"></a>\n\n<hr>\n\n\n<h1>System</h1>\n\n<font color=red>Synopsis:System.method(...)\n\n</font><p>Builtin system commands. All methods are exported as global.\n\n\n<h2>Methods for \"System\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#System.assertOptions'>options</a>:object=void):void </td><td>Throw or output msg if expr is false. Assert does nothing by default, but can be enabled with \"use assert\" or setting Interp.asserts.</td></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete event id returned from setInterval/setTimeout/info.events().</td></tr>\n<tr><td>decodeURI</td><td>decodeURI(val:string):string </td><td>Decode an HTTP URL.</td></tr>\n<tr><td>encodeURI</td><td>encodeURI(val:string):string </td><td>Encode an HTTP URL.</td></tr>\n<tr><td>exec</td><td>exec(val:string, <a href='#System.execOptions'>options</a>:string|object=void) </td><td>Execute an OS command. If the command ends with '&', set the 'bg' option to true.\nThe second argument can be a string, which is the same as setting the 'inputStr' option.\nBy default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used</td></tr>\n<tr><td>exit</td><td>exit(code:number=0):void </td><td>Exit the current interpreter.</td></tr>\n<tr><td>format</td><td>format(format:string, ...):string </td><td>Printf style formatting: adds %q and %S.</td></tr>\n<tr><td>isFinite</td><td>isFinite(val):boolean </td><td>Return true if is a finite number.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>isNaN</td><td>isNaN(val):boolean </td><td>Return true if not a number.</td></tr>\n<tr><td>load</td><td>load(shlib:string):void </td><td>Load a shared executable and invoke its _Init call.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as puts, but includes file:line.</td></tr>\n<tr><td>matchObj</td><td>matchObj(obj:object, match:string=void, partial=false, noerror=false):string|boolean </td><td>Object field names/types matching. Single arg generates string.</td></tr>\n<tr><td>noOp</td><td>noOp() </td><td>A No-Op. A zero overhead command call that is useful for debugging.</td></tr>\n<tr><td>parseFloat</td><td>parseFloat(val):number </td><td>Convert string to a double.</td></tr>\n<tr><td>parseInt</td><td>parseInt(val:any, base:number=10):number </td><td>Convert string to an integer.</td></tr>\n<tr><td>parseOpts</td><td>parseOpts(self:object|userobj, options:object, conf:object|null|undefined) </td><td>Parse options.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Formatted output to stdout.</td></tr>\n<tr><td>provide</td><td>provide(name:string|function=void, version:number|string=1.0, opts:object|function=void):void </td><td>Provide a package for use with require. Default is the file tail-rootname.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Output one or more values to stdout. Each argument is quoted.  Use Interp.logOpts to control source line and/or timestamps output.</td></tr>\n<tr><td>quote</td><td>quote(val:string):string </td><td>Return quoted string.</td></tr>\n<tr><td>require</td><td>require(name:string=void, version:number|string=1, <a href='#System.requireOptions'>options</a>:object=void):number|array|object </td><td>Load/query packages. With no arguments, returns the list of all loaded packages.\nWith one argument, loads the package (if necessary) and returns its version.\nWith two arguments, returns object containing: version, loadFile, func.\nA third argument sets options for package or module.\nNote an error is thrown if requested version is greater than actual version.</td></tr>\n<tr><td>runMain</td><td>runMain(cmd:string|null|function=void, conf:array=undefined) </td><td>If isMain invokes runModule.</td></tr>\n<tr><td>runModule</td><td>runModule(cmd:string|null|function=void, conf:array=undefined) </td><td>Invoke named module. If name is empty, uses file basename. If isMain and no args givine parses console.args.</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, ms:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, ms:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>sleep</td><td>sleep(secs:number=1.0):void </td><td>sleep for N milliseconds, minimum .001.</td></tr>\n<tr><td>source</td><td>source(val:string|array, <a href='#System.sourceOptions'>options</a>:object=void) </td><td>Load and evaluate source files: trailing '/' appends PARENTDIR.jsi.</td></tr>\n<tr><td>strftime</td><td>strftime(num:number=null, <a href='#System.strftimeOptions'>options</a>:string|object=void):string </td><td>Format numeric time (in ms) to a string. Null or no value will use current time.</td></tr>\n<tr><td>strptime</td><td>strptime(val:string=void, <a href='#System.strptimeOptions'>options</a>:string|object=void):number </td><td>Parse time from string and return ms time since 1970-01-01 in UTC, or NaN.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>unload</td><td>unload(shlib:string):void </td><td>Unload a shared executable and invoke its _Done call.</td></tr>\n<tr><td>update</td><td>update(<a href='#System.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"System.assertOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.execOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bg</td><td><i>BOOL</i></td><td>Run command in background using system() and return OS code.</td><td><i></i></td></tr>\n<tr><td>chdir</td><td><i>STRING</i></td><td>Change to directory.</td><td><i></i></td></tr>\n<tr><td>inputStr</td><td><i>STRING</i></td><td>Use string as input and return OS code.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Suppress all OS errors.</td><td><i></i></td></tr>\n<tr><td>noRedir</td><td><i>BOOL</i></td><td>Disable redirect and shell escapes in command.</td><td><i></i></td></tr>\n<tr><td>noShell</td><td><i>BOOL</i></td><td>Do not use native popen which invokes via /bin/sh.</td><td><i></i></td></tr>\n<tr><td>trim</td><td><i>BOOL</i></td><td>Trim trailing whitespace from output.</td><td><i></i></td></tr>\n<tr><td>retAll</td><td><i>BOOL</i></td><td>Return the OS return code and data as an object.</td><td><i></i></td></tr>\n<tr><td>retCode</td><td><i>BOOL</i></td><td>Return only the OS return code.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.requireOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.require\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages for module.</td><td><i></i></td></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages for module.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages for module.</td><td><i></i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.sourceOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.source\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>autoIndex</td><td><i>BOOL</i></td><td>Look for and load Jsi_Auto.jsi auto-index file.</td><td><i></i></td></tr>\n<tr><td>exists</td><td><i>BOOL</i></td><td>Source file only if exists.</td><td><i></i></td></tr>\n<tr><td>global</td><td><i>BOOL</i></td><td>File is to be sourced in global frame rather than local.</td><td><i></i></td></tr>\n<tr><td>isMain</td><td><i>BOOL</i></td><td>Coerce to true the value of Info.isMain().</td><td><i></i></td></tr>\n<tr><td>level</td><td><i>UINT</i></td><td>Frame to source file in.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Ignore errors in sourced file.</td><td><i></i></td></tr>\n<tr><td>once</td><td><i>BOOL</i></td><td>Source file only if not already sourced (Default: Interp.debugOpts.includeOnce).</td><td><i></i></td></tr>\n<tr><td>trace</td><td><i>BOOL</i></td><td>Trace include statements (Default: Interp.debugOpts.includeTrace).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strftimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strftime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strptimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strptime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.updateOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Systemend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Util\"></a>\n\n<hr>\n\n\n<h1>Util</h1>\n\n<font color=red>Synopsis:Util.method(...)\n\n</font><p>Utilities commands.\n\n\n<h2>Methods for \"Util\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argArray</td><td>argArray(arg:any|undefined):array|null </td><td>Coerces non-null to an array, if necessary.</td></tr>\n<tr><td>base64</td><td>base64(val:string, decode:boolean=false):string </td><td>Base64 encode/decode a string.</td></tr>\n<tr><td>complete</td><td>complete(val:string):boolean </td><td>Return true if string is complete command with balanced braces, etc.</td></tr>\n<tr><td>crc32</td><td>crc32(val:string, crcSeed=0):number </td><td>Calculate 32-bit CRC.</td></tr>\n<tr><td>decrypt</td><td>decrypt(val:string, key:string):string </td><td>Decrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>encrypt</td><td>encrypt(val:string, key:string):string </td><td>Encrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(code:number):string </td><td>Return char with given character code.</td></tr>\n<tr><td>getenv</td><td>getenv(name:string=void):string|object|void </td><td>Get one or all environment.</td></tr>\n<tr><td>getpid</td><td>getpid(parent:boolean=false):number </td><td>Get process/parent id.</td></tr>\n<tr><td>getuser</td><td>getuser():object </td><td>Get userid info.</td></tr>\n<tr><td>hash</td><td>hash(val:string, <a href='#Util.hashOptions'>options</a>|object=void):string </td><td>Return hash (default SHA256) of string/file.</td></tr>\n<tr><td>hexStr</td><td>hexStr(val:string, decode:boolean=false):string </td><td>Hex encode/decode a string.</td></tr>\n<tr><td>setenv</td><td>setenv(name:string, value:string=void) </td><td>Set/get an environment var.</td></tr>\n<tr><td>sqlValues</td><td>sqlValues(name:string, var:object=void) </td><td>Get object values for SQL.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>verConvert</td><td>verConvert(ver:string|number, zeroTrim:number=0):number|string|null </td><td>Convert a version to/from a string/number, or return null if not a version. For string output zeroTrim says how many trailing .0 to trim (0-2).</td></tr>\n</table>\n\n\n<a name=\"Util.hashOptions\"></a>\n<a name=\"Util.confOptions\"></a>\n<h2>Options for \"Util.hash\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Read data from file and append to str.</td><td><i></i></td></tr>\n<tr><td>hashcash</td><td><i>UINT</i></td><td>Search for a hash with this many leading zero bits by appending :nonce (Proof-Of-Work).</td><td><i></i></td></tr>\n<tr><td>noHex</td><td><i>BOOL</i></td><td>Return binary digest, without conversion to hex chars.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type of hash. (one of: <b>sha256</b>, <b>sha1</b>, <b>md5</b>, <b>sha3_224</b>, <b>sha3_384</b>, <b>sha3_512</b>, <b>sha3_256</b>)</td><td><i></i></td></tr>\n</table>\n<a name=\"Utilend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Vfs\"></a>\n\n<hr>\n\n\n<h1>Vfs</h1>\n\n<font color=red>Synopsis:Vfs.method(...)\n\n</font><p>Commands for creating in memory readonly Virtual file-systems.\n\n\n<h2>Methods for \"Vfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(mount:string, string|<a href='#Vfs.confOptions'>options</a>:object|string=void) </td><td>Configure mount.</td></tr>\n<tr><td>exec</td><td>exec(cmd:string) </td><td>Safe mode exec for VFS support cmds eg. fossil info/ls/cat.</td></tr>\n<tr><td>fileconf</td><td>fileconf(mount:string, path:string, <a href='#Vfs.fileconfOptions'>options</a>:string|object=void) </td><td>Configure file info which is same info as in fileList.</td></tr>\n<tr><td>list</td><td>list():array </td><td>Return list of all vfs mounts.</td></tr>\n<tr><td>mount</td><td>mount(type:string, file:string, param:object=void):string </td><td>Mount fossil file as given VFS type name, returning the mount point: frontend for vmount.</td></tr>\n<tr><td>type</td><td>type(type:string=void, <a href='#Vfs.typeOptions'>options</a>:object|null=void) </td><td>Set/get/delete VFS type name.</td></tr>\n<tr><td>unmount</td><td>unmount(mount:string):void </td><td>Unmount a VFS.</td></tr>\n<tr><td>vmount</td><td>vmount(<a href='#Vfs.vmountOptions'>options</a>:object=void):string </td><td>Create and mount a VFS, returning the mount point.</td></tr>\n</table>\n\n\n<a name=\"Vfs.confOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.execOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.fileconfOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.fileconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.typeOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.type\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i>required</i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.vmountOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.vmount\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n<a name=\"Vfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"WebSocket\"></a>\n\n<hr>\n\n\n<h1>WebSocket</h1>\n\n<font color=red>Synopsis:new WebSocket(options:object=void):userobj\n\n</font><p>Commands for managing WebSocket server/client connections.\n\n\n<h2>Methods for \"WebSocket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>WebSocket</td><td>new WebSocket(<a href='#new WebSocketOptions'>options</a>:object=void):userobj </td><td>Create websocket server/client object.Create a websocket server/client object.  The server serves out pages to a web browser,\nwhich can use javascript to upgrade connection to a bidirectional websocket.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#WebSocket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>file</td><td>file(name:string=void):array|void </td><td>Add file to hash, or with no args return file hash.</td></tr>\n<tr><td>handler</td><td>handler(extension:string=void, cmd:string|function=void, flags:number=0):string|array|function|void </td><td>Get/Set handler command for an extension. With no args, returns list of handlers.  With one arg, returns value for that handler.\nOtherwise, sets the handler. When cmd is a string, the call is via runModule([cmd], arg).\nIf a cmd is a function, it is called with a single arg: the file name.</td></tr>\n<tr><td>header</td><td>header(id:number, name:string=void):string|array|void </td><td>Get one or all input headers for connect id.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number, <a href='#WebSocket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for connect id.</td></tr>\n<tr><td>ids</td><td>ids(name:string=void):array </td><td>Return list of ids, or lookup one id.</td></tr>\n<tr><td>query</td><td>query(id:number, name:string=void):string|object|void </td><td>Get one or all query values for connect id.</td></tr>\n<tr><td>send</td><td>send(id:number, data:any):void </td><td>Send a websocket message to id. Send a message to one (or all connections if -1). If not already a string, msg is formatted as JSON prior to the send.</td></tr>\n<tr><td>status</td><td>status():object|void </td><td>Return libwebsocket server status.</td></tr>\n<tr><td>unalias</td><td>unalias(path:string):string|void </td><td>Return alias reverse lookup.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this websocket.</td></tr>\n<tr><td>version</td><td>version():string </td><td>Runtime library version string.</td></tr>\n</table>\n\n\n<a name=\"new WebSocketOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"new WebSocket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>In client-mode the address to connect to (127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>bufferPwr2</td><td><i>INT</i></td><td>Tune the recv/send buffer: value is a power of 2 in [0-20] (16).</td><td><i></i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Run in client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>clientHost</td><td><i>STRKEY</i></td><td>Override host name for client.</td><td><i></i></td></tr>\n<tr><td>clientOrigin</td><td><i>STRKEY</i></td><td>Override client origin (origin).</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Set debug level. Setting this to 512 will turn on max libwebsocket log levels.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>formParams</td><td><i>STRKEY</i></td><td>Comma seperated list of upload form param names ('text,send,file,upload').</td><td><i>readOnly</i></td></tr>\n<tr><td>extHandlers</td><td><i>BOOL</i></td><td>Setup builtin extension-handlers, ie: .htmli, .cssi, .jsi, .mdi.</td><td><i>initOnly</i></td></tr>\n<tr><td>extOpts</td><td><i>OBJ</i></td><td>Key/value store for extension-handlers options.</td><td><i>initOnly</i></td></tr>\n<tr><td>getRegexp</td><td><i>REGEXP</i></td><td>Call onGet() only if Url matches pattern.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser: name/value pairs.</td><td><i>initOnly</i></td></tr>\n<tr><td>jsiFnPattern</td><td><i>STRKEY</i></td><td>A glob-match pattern for files to which is appended 'window.jsiWebSocket=true;' (jsig*.js).</td><td><i>readOnly</i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>local</td><td><i>BOOL</i></td><td>Limit connections to localhost addresses on the 127 network.</td><td><i></i></td></tr>\n<tr><td>localhostName</td><td><i>STRKEY</i></td><td>Client name used by localhost connections ('localhost').</td><td><i></i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>maxDownload</td><td><i>INT</i></td><td>Max size of file download.</td><td><i></i></td></tr>\n<tr><td>maxUpload</td><td><i>INT</i></td><td>Max size of file upload will accept.</td><td><i></i></td></tr>\n<tr><td>mimeTypes</td><td><i>OBJ</i></td><td>Object providing map of file extensions to mime types. eg. {txt:'text/plain', bb:'text/bb'}.</td><td><i>initOnly</i></td></tr>\n<tr><td>modifySecs</td><td><i>UINT</i></td><td>Seconds between checking for modified files with onModify (2).</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of conf() to change options after options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCompress</td><td><i>BOOL</i></td><td>Disable per-message-deflate extension which can truncate large msgs.</td><td><i></i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Disable update event-processing (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>noWebsock</td><td><i>BOOL</i></td><td>Serve html, but disallow websocket upgrade.</td><td><i>initOnly</i></td></tr>\n<tr><td>noWarn</td><td><i>BOOL</i></td><td>Quietly ignore file related errors.</td><td><i></i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for http basic authentication. @function(ws:userobj, id:number, url:string, userpass:string)</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last websock connection closes. On object delete arg is null. @function(ws:userobj|null)</td><td><i></i></td></tr>\n<tr><td>onFilter</td><td><i>FUNC</i></td><td>Function to call on a new connection: return false to kill connection. @function(ws:userobj, id:number, url:string, ishttp:boolean)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onModify</td><td><i>FUNC</i></td><td>Function to call when a served-out-file is modified. @function(ws:userobj, file:string)</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when the websocket connection occurs. @function(ws:userobj, id:number)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>pathAliases</td><td><i>OBJ</i></td><td>Path alias lookups.</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for server to listen on (8080).</td><td><i>initOnly</i></td></tr>\n<tr><td>post</td><td><i>STRING</i></td><td>Post string to serve.</td><td><i>initOnly</i></td></tr>\n<tr><td>protocol</td><td><i>STRKEY</i></td><td>Name of protocol (ws/wss).</td><td><i></i></td></tr>\n<tr><td>realm</td><td><i>STRKEY</i></td><td>Realm for basic auth (jsish).</td><td><i></i></td></tr>\n<tr><td>recvBufMax</td><td><i>INT</i></td><td>Size limit of a websocket message.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvBufTimeout</td><td><i>INT</i></td><td>Timeout for recv of a websock msg.</td><td><i>initOnly</i></td></tr>\n<tr><td>redirMax</td><td><i>BOOL</i></td><td>Temporarily disable redirects when see more than this in 10 minutes.</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>server</td><td><i>STRKEY</i></td><td>String to send out int the header SERVER (jsiWebSocket).</td><td><i></i></td></tr>\n<tr><td>ssiExts</td><td><i>OBJ</i></td><td>Object map of file extensions to apply SSI.  eg. {myext:true, shtml:false} .</td><td><i>initOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of websocket start.</td><td><i>readOnly</i></td></tr>\n<tr><td>includeFile</td><td><i>STRKEY</i></td><td>Default file when no extension given (include.shtml).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>urlPrefix</td><td><i>STRKEY</i></td><td>Prefix in url to strip from path; for reverse proxy.</td><td><i></i></td></tr>\n<tr><td>urlRedirect</td><td><i>STRKEY</i></td><td>Redirect when no url or / is given. Must match urlPrefix, if given.</td><td><i></i></td></tr>\n<tr><td>use_ssl</td><td><i>BOOL</i></td><td>Use https (for client).</td><td><i>initOnly</i></td></tr>\n<tr><td>useridPass</td><td><i>STRKEY</i></td><td>The USERID:PASSWORD to use for basic authentication.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>WebSocket version info.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"WebSocket.idconfOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"WebSocket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>clientIP</td><td><i>STRKEY</i></td><td>Client IP Address.</td><td><i>readOnly</i></td></tr>\n<tr><td>clientName</td><td><i>STRKEY</i></td><td>Client hostname.</td><td><i>readOnly</i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser on connection: name/value pairs.</td><td><i></i></td></tr>\n<tr><td>isWebsock</td><td><i>BOOL</i></td><td>Is a websocket connection.</td><td><i></i></td></tr>\n<tr><td>key</td><td><i>STRBUF</i></td><td>String key lookup in ids command for SSI echo ${#}.</td><td><i>readOnly</i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, args:array)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistics for connection.</td><td><i>readOnly</i></td></tr>\n<tr><td>query</td><td><i>ARRAY</i></td><td>Uri arg values for connection.</td><td><i></i></td></tr>\n<tr><td>queryObj</td><td><i>OBJ</i></td><td>Uri arg values for connection as an object.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>url</td><td><i>DSTRING</i></td><td>Url for connection.</td><td><i></i></td></tr>\n<tr><td>username</td><td><i>STRING</i></td><td>The login userid for this connection.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createTime</td><td><i>TIME_T</i></td><td>Time created.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>httpCnt</td><td><i>INT</i></td><td>Number of http reqs.</td><td><i></i></td></tr>\n<tr><td>httpLast</td><td><i>TIME_T</i></td><td>Time of last http reqs.</td><td><i></i></td></tr>\n<tr><td>isBinary</td><td><i>BOOL</i></td><td>Connection recv data is binary.</td><td><i>readOnly</i></td></tr>\n<tr><td>isFinal</td><td><i>BOOL</i></td><td>Final data for current message was recieved.</td><td><i>readOnly</i></td></tr>\n<tr><td>msgQLen</td><td><i>INT</i></td><td>Number of messages in input queue.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirLast</td><td><i>TIME_T</i></td><td>Time of last redirect.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirCnt</td><td><i>INT</i></td><td>Count of redirects.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadCnt</td><td><i>INT</i></td><td>Number of uploads.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadEnd</td><td><i>TIME_T</i></td><td>Time of upload end.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadLast</td><td><i>TIME_T</i></td><td>Time of last upload input.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadStart</td><td><i>TIME_T</i></td><td>Time of upload start.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"WebSocketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Zvfs\"></a>\n\n<hr>\n\n\n<h1>Zvfs</h1>\n\n<font color=red>Synopsis:Zvfs.method(...)\n\n</font><p>Commands for mounting and accessing .zip files as a filesystem.\n\n\n<h2>Methods for \"Zvfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>append</td><td>append(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Like 'create()', but appends to an existing archive (with no dup checking).</td></tr>\n<tr><td>create</td><td>create(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Create a zip with the given files in prefix path. This command creates a zip archive and adds files to it. Files are relative the given 'path', or the current directory. If the destignation file already exist but is not an archive (eg. an executable), zip data is appended to the end of the file. If the existing file is already an archive, an error will be thrown. To truncate an existing archive, use zvfs.truncate(). Or use zvfs.append() instead. \n   zvfs.create('foo.zip',['main.js', 'bar.js'], 'src', ['a.html', 'css/a.css'], 'html');</td></tr>\n<tr><td>deflate</td><td>deflate(data:string):string </td><td>Compress string using zlib deflate.</td></tr>\n<tr><td>inflate</td><td>inflate(data:string):string </td><td>Uncompress string using zlib inflate.</td></tr>\n<tr><td>list</td><td>list(archive:string):array </td><td>List files in archive. Return contents of zip directory as an array of arrays. The first element contains the labels, ie: \n[ 'Name', 'Special', 'Offset', 'Bytes', 'BytesCompressed' ] </td></tr>\n<tr><td>mount</td><td>mount(archive:string, mountdir:string=void):string </td><td>Mount zip on mount point. Read a ZIP archive and make entries in the virutal file hash table for all files contained therein.</td></tr>\n<tr><td>names</td><td>names(mountdir:string=void):array </td><td>Return all zvfs mounted zips, or archive for specified mount. Given an mount point argument, returns the archive for it. Otherwise, returns an array of mount points</td></tr>\n<tr><td>offset</td><td>offset(archive:string):number </td><td>Return the start offset of zip data. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>stat</td><td>stat(filename:string):object </td><td>Return details on file in zvfs mount. Return details about the given file in the ZVFS.  The information consists of (1) the name of the ZIP archive that contains the file, (2) the size of the file after decompressions, (3) the compressed size of the file, and (4) the offset of the compressed data in the archive.</td></tr>\n<tr><td>truncate</td><td>truncate(archive:string, noerror:boolean=false):number </td><td>Truncate zip data from archive. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>unmount</td><td>unmount(archive:string):void </td><td>Unmount zip.</td></tr>\n</table>\n<a name=\"Zvfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"console\"></a>\n\n<hr>\n\n\n<h1>console</h1>\n\n<font color=red>Synopsis:console.method(...)\n\n</font><p>Console input and output to stderr.\n\n\n<h2>Methods for \"console\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#console.assertOptions'>options</a>:object=void):void </td><td>Same as System.assert().</td></tr>\n<tr><td>error</td><td>error(val, ...):void </td><td>Same as log.</td></tr>\n<tr><td>input</td><td>input():string|void </td><td>Read input from the console.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as System.puts, but goes to stderr and includes file:line.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Same as System.printf but goes to stderr.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Same as System.puts, but goes to stderr.</td></tr>\n<tr><td>warn</td><td>warn(val, ...):void </td><td>Same as log.</td></tr>\n</table>\n\n\n<a name=\"console.assertOptions\"></a>\n<a name=\"console.confOptions\"></a>\n<h2>Options for \"console.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n<a name=\"consoleend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<p>\n", "/* jsi.h : External API header file for Jsi. */\n#ifndef __JSI_H__\n#define __JSI_H__\n\n#define JSI_VERSION_MAJOR   3\n#define JSI_VERSION_MINOR   0\n#define JSI_VERSION_RELEASE 8\n\n#define JSI_VERSION (JSI_VERSION_MAJOR + ((Jsi_Number)JSI_VERSION_MINOR/100.0) + ((Jsi_Number)JSI_VERSION_RELEASE/10000.0))\n\n#ifndef JSI_EXTERN\n#define JSI_EXTERN extern\n#endif\n\n#ifdef offsetof\n#define Jsi_Offset(type, field) ((long) offsetof(type, field))\n#else\n#define Jsi_Offset(type, field) ((long) ((char *) &((type *) 0)->field))\n#endif\n\n#ifndef __GNUC__\n#define __attribute__(X)\n#endif\n\n#ifndef __USE_XOPEN\n#define __USE_XOPEN\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#ifdef __WIN32\n#define __USE_MINGW_ANSI_STDIO 1\n#endif\n\n#include <stdbool.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <stdio.h> \n#include <dirent.h>\n\n/* --TYPEDEFS-- */\ntypedef int64_t Jsi_Wide;\ntypedef uint64_t Jsi_UWide;\ntypedef long double ldouble;\n#ifdef JSI_USE_LONG_DOUBLE\ntypedef ldouble Jsi_Number;\n#define JSI_NUMLMOD \"L\"\n#else\ntypedef double Jsi_Number;\n#define JSI_NUMLMOD\n#endif\ntypedef double time_d;\ntypedef int64_t time_w;\ntypedef uint32_t Jsi_Sig; // Signature field\n\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long ulong;\ntypedef unsigned short ushort;\n#define JSI_NUMGFMT JSI_NUMLMOD \"g\"\n#define JSI_NUMFFMT JSI_NUMLMOD \"f\"\n#define JSI_NUMEFMT JSI_NUMLMOD \"e\"\n/* -- */\n\n\n/* --ENUMS-- */\ntypedef enum {\n    /* Jsi Return Codes. */\n    JSI_OK=0, JSI_ERROR=1, JSI_RETURN=2, JSI_BREAK=3,\n    JSI_CONTINUE=4, JSI_SIGNAL=5, JSI_EXIT=6, JSI_EVAL=7,    \n} Jsi_RC;\n\ntypedef enum {\n    JSI_MAP_NONE, JSI_MAP_HASH, JSI_MAP_TREE, JSI_MAP_LIST /*, JSI_MAP_STACK */\n} Jsi_Map_Type;\n\ntypedef enum {\n    JSI_KEYS_STRING = 0,    // A string that gets stored in hash.\n    JSI_KEYS_STRINGKEY = 1, // A pointer to strings in another hash such as Jsi_KeyLookup()\n    JSI_KEYS_ONEWORD = 2,   // A pointer.\n    JSI_KEYS_RESERVED = 3,  // Unused.\n    JSI_KEYS_STRUCT_MINSIZE = 4 // Any number >= 4 is the number of bytes in a struct/key.\n} Jsi_Key_Type;\n\ntypedef enum {\n    JSI_OT_UNDEF,       /* Undefined */\n    JSI_OT_BOOL,        /* Boolean object, use d.val */\n    JSI_OT_NUMBER,      /* Number object, use d.num */\n    JSI_OT_STRING,      /* String object, use d.str */\n    JSI_OT_OBJECT,      /* Common object */\n    JSI_OT_ARRAY,       /* NOT A REAL TYPE: is just an JSI_OT_OBJECT with array elements */\n    JSI_OT_FUNCTION,    /* Function object, use d.fobj */\n    JSI_OT_REGEXP,      /* RegExp object, use d.robj */\n    JSI_OT_ITER,        /* Iter object, use d.iobj */\n    JSI_OT_USEROBJ,     /* UserDefined object, use d.uobj */\n    JSI_OT__MAX = JSI_OT_USEROBJ\n} Jsi_otype;\n\ntypedef enum {          /* TYPE         CONSTRUCTOR JSI_VALUE-DATA  IMPLICIT-PROTOTYPE  */\n    JSI_VT_UNDEF,       /* undefined    none        none            none                */\n    JSI_VT_BOOL,        /* boolean      Boolean     d.val           none                */\n    JSI_VT_NUMBER,      /* number       Number      d.num           Number.prototype    */\n    JSI_VT_STRING,      /* string       String      d.str           String.prototype    */\n    JSI_VT_OBJECT,      /* object       Jsi_Obj     d.obj           Jsi_Obj.prototype   */\n    JSI_VT_NULL,        /* null         none        none            none                */\n    JSI_VT_VARIABLE,    /* lvalue       none        d.lval          none                */\n    JSI_VT__MAX = JSI_VT_VARIABLE\n} Jsi_vtype;\n\ntypedef enum {\n    JSI_TT_UNDEFINED= (1<<JSI_OT_UNDEF),    //  0x1\n    JSI_TT_BOOLEAN  = (1<<JSI_OT_BOOL),     //  0x2\n    JSI_TT_NUMBER   = (1<<JSI_OT_NUMBER),   //  0x4\n    JSI_TT_STRING   = (1<<JSI_OT_STRING),   //  0x8\n    JSI_TT_OBJECT   = (1<<JSI_OT_OBJECT),   //  0x10\n    JSI_TT_ARRAY    = (1<<JSI_OT_ARRAY),    //  0x20\n    JSI_TT_FUNCTION = (1<<JSI_OT_FUNCTION), //  0x40\n    JSI_TT_REGEXP   = (1<<JSI_OT_REGEXP),   //  0x80\n    JSI_TT_ITEROBJ  = (1<<JSI_OT_ITER),     //  0x100\n    JSI_TT_USEROBJ  = (1<<JSI_OT_USEROBJ),  //  0x200\n    JSI_TT_NULL     = (1<<(JSI_OT_USEROBJ+1)),//0x400\n    JSI_TT_ANY      = (1<<(JSI_OT_USEROBJ+2)),//0x800\n    JSI_TT_VOID     = (1<<(JSI_OT_USEROBJ+3)) //0x1000\n} Jsi_ttype;\n\ntypedef enum {\n    /* General flags. */\n    JSI_NONE=0, JSI_NO_ERRMSG=1, \n    JSI_CMP_NOCASE=1, JSI_CMP_CHARSET_SCAN=2,\n    JSI_CMP_EXACT=0x4,\n    JSI_EVAL_ARGV0=0x1, JSI_EVAL_GLOBAL=0x2, JSI_EVAL_NOSKIPBANG=0x4, JSI_EVAL_AUTOINDEX=0x8,\n    JSI_EVAL_RETURN         =0x10, // Return top of stack as result\n    JSI_EVAL_ONCE           =0x20, // Source files only once.\n    JSI_EVAL_ISMAIN         =0x40, // Set isMain to true.\n    JSI_EVAL_EXISTS         =0x80, // Source if exists.\n    JSI_EVAL_ERRIGNORE      =0x100,// Source ignores errors.\n\n    /* Flags for Jsi_CmdProc */\n    JSI_CALL_CONSTRUCTOR    =0x1,\n    JSI_CALL_BUILTIN        =0x2,\n    \n    JSI_CMDSPEC_ISOBJ       = 0x1,\n    JSI_CMDSPEC_PROTO       = 0x2,\n    JSI_CMDSPEC_NONTHIS     = 0x4,\n    JSI_CMDSPEC_SUBCMDS     = 0x8,      // Has sub-commands.\n    \n    JSI_CMD_HAS_ATTR        = 0x100,\n    JSI_CMD_IS_CONSTRUCTOR  = 0x200,\n    JSI_CMD_IS_OBJ          = 0x400,\n    JSI_CMD_LOG_TEST        = 0x1000,\n    JSI_CMD_LOG_DEBUG       = 0x2000,\n    JSI_CMD_LOG_TRACE       = 0x4000,\n    JSI_CMD_MASK            = 0xffff,\n    \n    JSI_OM_READONLY         = 0x01,     /* ecma read-only */\n    JSI_OM_DONTENUM         = 0x02,     /* ecma emumerable */\n    JSI_OM_DONTDEL          = 0x04,     /* ecma configurable */\n    JSI_OM_INNERSHARED      = 0x08,\n    JSI_OM_ISARRAYLIST      = 0x10,\n    JSI_OM_ISSTRKEY         = 0x20,\n    JSI_OM_UNUSED           = 0x40,\n    JSI_OM_ISSTATIC         = 0x80,\n    \n    JSI_INTACCESS_READ      = 0x0,\n    JSI_INTACCESS_WRITE     = 0x1,\n    JSI_INTACCESS_NETWORK   = 0x2,\n    JSI_INTACCESS_SETSSL    = 0x3,\n    JSI_INTACCESS_MAININTERP= 0x4,\n    JSI_INTACCESS_CREATE    = 0x5,\n    \n    JSI_LOG_BUG=0,   JSI_LOG_ERROR,   JSI_LOG_WARN,\n    JSI_LOG_INFO,    JSI_LOG_UNUSED,  JSI_LOG_PARSE,\n    JSI_LOG_TEST,    JSI_LOG_DEBUG,   JSI_LOG_TRACE,\n    JSI__LOGLAST=JSI_LOG_TRACE,\n    \n    JSI_SORT_NOCASE = 0x1, JSI_SORT_DESCEND = 0x2, JSI_SORT_DICT = 0x4,\n    \n    JSI_NAME_FUNCTIONS = 0x1, JSI_NAME_DATA = 0x2,\n    \n    JSI_TREE_ORDER_IN=0, JSI_TREE_ORDER_PRE=0x10, JSI_TREE_ORDER_POST=0x20, // Jsi_TreeSearchFirst()\n    JSI_TREE_ORDER_LEVEL=0x30, JSI_TREE_ORDER_MASK=0x30,\n    JSI_TREE_SEARCH_KEY=0x10, // Use key even if NULL\n    JSI_TREE_USERFLAG_MASK=0x7f,\n    JSI_LIST_REVERSE=0x8, // Jsi_ListSearchFirst\n    JSI_MUTEX_RECURSIVE=2,\n    \n    JSI_FS_NOCLOSE=0x1, JSI_FS_READONLY=0x2, JSI_FS_WRITEONLY=0x4, JSI_FS_APPEND=0x8,\n    JSI_FS_COMPRESS=0x100,\n    JSI_FSMODESIZE=15,\n    JSI_FILE_TYPE_FILES=0x1, JSI_FILE_TYPE_DIRS=0x2,    JSI_FILE_TYPE_MOUNT=0x4,\n    JSI_FILE_TYPE_LINK=0x8,  JSI_FILE_TYPE_PIPE=0x10,   JSI_FILE_TYPE_BLOCK=0x20,\n    JSI_FILE_TYPE_CHAR=0x40, JSI_FILE_TYPE_SOCKET=0x80, JSI_FILE_TYPE_HIDDEN=0x100,\n    \n    JSI_OUTPUT_QUOTE = 0x1,\n    JSI_OUTPUT_JSON = 0x2,\n    JSI_OUTPUT_NEWLINES = 0x4,\n    JSI_OUTPUT_STDERR = 0x8,\n    JSI_JSON_STATIC_DEFAULT =100,\n    JSI_JSON_STRICT   = 0x101, /* property names must be quoted. */\n    JSI_STUBS_STRICT  = 0x1, JSI_STUBS_SIG = 0xdeadaa00, JSI_SIG_TYPEDEF,\n    JSI_SIG_OPTS = 0xdeadab00,\n    JSI_SIG_OPTS_STRUCT, JSI_SIG_OPTS_ENUM, JSI_SIG_OPTS_VARDEF, JSI_SIG_OPTS_FIELD,\n    JSI_SIG_OPTS_USER1=0xdeadab20,\n\n    JSI_EVENT_TIMER=0, JSI_EVENT_SIGNAL=1, JSI_EVENT_ALWAYS=2,\n    JSI_ZIP_MAIN=0x1,  JSI_ZIP_INDEX=0x2,\n\n    JSI_DBI_READONLY     =0x0001, /* Db is created readonly */\n    JSI_DBI_NOCREATE     =0x0002, /* Db must already exist. */\n    JSI_DBI_NO_MUTEX     =0x0004, /* Disable mutex. */\n    JSI_DBI_FULL_MUTEX   =0x0008, /* Use full mutex. */\n    \n    JSI_MAX_NUMBER_STRING=100,\n    JSI_BUFSIZ=8192\n\n} Jsi_Enums; /* Debugging is easier with enums than #define. */\n\n/* -- */\n\n\n/* --STRUCTS-- */\n\ntypedef struct Jsi_Interp Jsi_Interp;\ntypedef struct Jsi_Obj Jsi_Obj;\ntypedef struct Jsi_Value Jsi_Value;\ntypedef struct Jsi_Func Jsi_Func;\ntypedef struct Jsi_IterObj Jsi_IterObj;\ntypedef struct Jsi_FuncObj Jsi_FuncObj;\ntypedef struct Jsi_UserObjReg Jsi_UserObjReg;\ntypedef struct Jsi_UserObj Jsi_UserObj;\ntypedef struct Jsi_HashEntry Jsi_HashEntry;\ntypedef struct Jsi_Hash Jsi_Hash;\ntypedef struct Jsi_HashSearch Jsi_HashSearch;\ntypedef struct Jsi_TreeEntry Jsi_TreeEntry;\ntypedef struct Jsi_Tree Jsi_Tree;\ntypedef struct Jsi_TreeSearch Jsi_TreeSearch;\ntypedef struct Jsi_List Jsi_List;\ntypedef struct Jsi_ListEntry Jsi_ListEntry;\ntypedef struct Jsi_ListSearch Jsi_ListSearch;\ntypedef struct Jsi_Map Jsi_Map;\ntypedef struct Jsi_MapEntry Jsi_MapEntry;\ntypedef struct Jsi_MapSearch Jsi_MapSearch;\ntypedef struct Jsi_Regex_ Jsi_Regex;\ntypedef struct Jsi_Db Jsi_Db;\ntypedef struct Jsi_DbBinds Jsi_DbBinds;\ntypedef struct Jsi_Mutex Jsi_Mutex;\ntypedef struct Jsi_ScopeStrs Jsi_ScopeStrs;\ntypedef struct Jsi_OpCodes Jsi_OpCodes;\ntypedef struct Jsi_Chan* Jsi_Channel;\ntypedef struct Jsi_CS_Ctx Jsi_CS_Ctx;\ntypedef struct Jsi_OptionSpec Jsi_OptionSpec;\n\ntypedef struct Jsi_OptionSpec Jsi_StructSpec;\ntypedef struct Jsi_OptionSpec Jsi_FieldSpec;\ntypedef struct Jsi_OptionSpec Jsi_EnumSpec;\ntypedef struct Jsi_OptionSpec Jsi_VarSpec;\n\ntypedef Jsi_RC (Jsi_InitProc)(Jsi_Interp *interp, int release); // When release>1, the main interp is exiting.\ntypedef Jsi_RC (Jsi_DeleteProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_EventHandlerProc)(Jsi_Interp *interp, void *data);\ntypedef Jsi_RC (Jsi_ValueHandlerProc)(Jsi_Interp *interp, Jsi_Value *v, struct Jsi_OptionSpec* spec, void *record);\ntypedef void (Jsi_DeleteVoidProc)(void *data);\ntypedef Jsi_RC (Jsi_csgset)(Jsi_Interp *interp, void *data, Jsi_Wide *s, Jsi_OptionSpec *spec, int idx, bool isSet);\ntypedef int (Jsi_IterProc)(Jsi_IterObj *iterObj, Jsi_Value *val, Jsi_Value *var, int index);\n\n/* -- */\n\n\n/* --INTERP-- */\n\n/* Options and flags for Jsi_InterpNew/Jsi_Main */\ntypedef struct {\n    int argc;                   // Arguments from main().\n    char **argv;                // ...\n    Jsi_InitProc* initProc;     // Initialization proc\n    uint mem_debug:2;           // Memory debug level;\n    bool no_interactive:1;      // Jsi_Main: does not default to interactive mode when no script arg given.\n    bool auto_delete:1;         // Jsi_Main: auto delete interp upon return.\n    bool no_exit:1;             // Do not exit, even on error.\n    uint reserved:11;           // Reserved for future use.\n    int exitCode:16;            // Call exit with this code.\n    Jsi_Interp* interp;         // Jsi_InterpNew sets this to let Jsi_Main use this interp.\n    void *reserved2[8];         // Reserved for future\n} Jsi_InterpOpts;\n\nJSI_EXTERN Jsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts); /*STUB = 1*/\nJSI_EXTERN void Jsi_InterpDelete( Jsi_Interp* interp); /*STUB = 2*/\nJSI_EXTERN void Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr);  /*STUB = 3*/\nJSI_EXTERN Jsi_RC Jsi_Interactive(Jsi_Interp* interp, int flags); /*STUB = 4*/\nJSI_EXTERN bool Jsi_InterpGone( Jsi_Interp* interp); /*STUB = 5*/\nJSI_EXTERN Jsi_Value* Jsi_InterpResult(Jsi_Interp *interp); /*STUB = 6*/\nJSI_EXTERN const char* Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr); /*STUB = 7*/\nJSI_EXTERN void* Jsi_InterpGetData(Jsi_Interp *interp, const char *key, Jsi_DeleteProc **proc); /*STUB = 8*/\nJSI_EXTERN void Jsi_InterpSetData(Jsi_Interp *interp, const char *key, void *data, Jsi_DeleteProc *proc); /*STUB = 9*/\nJSI_EXTERN void Jsi_InterpFreeData(Jsi_Interp *interp, const char *key); /*STUB = 10*/\nJSI_EXTERN bool Jsi_InterpSafe(Jsi_Interp *interp); /*STUB = 11*/\nJSI_EXTERN Jsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag); /*STUB = 12*/\nJSI_EXTERN Jsi_Interp* Jsi_Main(Jsi_InterpOpts *opts); /*STUB = 13*/\n/* -- */\n\n\n/* --MEMORY-- */\nJSI_EXTERN void* Jsi_Malloc(uint size); /*STUB = 14*/\nJSI_EXTERN void* Jsi_Calloc(uint n, uint size); /*STUB = 15*/\nJSI_EXTERN void* Jsi_Realloc(void *m, uint size); /*STUB = 16*/\nJSI_EXTERN void  Jsi_Free(void *m); /*STUB = 17*/\nJSI_EXTERN int Jsi_ObjIncrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 18*/\nJSI_EXTERN int Jsi_ObjDecrRefCount(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 19*/\nJSI_EXTERN int Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 20*/\nJSI_EXTERN int Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 21*/\nJSI_EXTERN bool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v); /*STUB = 22*/\nJSI_EXTERN Jsi_RC Jsi_DeleteData(Jsi_Interp* interp, void *m); /*STUB = 23*/\n/* -- */\n\n\n/* --STRINGS-- */\nJSI_EXTERN uint Jsi_Strlen(const char *str); /*STUB = 24*/\nJSI_EXTERN uint Jsi_StrlenSet(const char *str, uint len); /*STUB = 25*/\nJSI_EXTERN int Jsi_Strcmp(const char *str1, const char *str2); /*STUB = 26*/\nJSI_EXTERN int Jsi_Strncmp(const char *str1, const char *str2, int n); /*STUB = 27*/\nJSI_EXTERN int Jsi_Strncasecmp(const char *str1, const char *str2, int n); /*STUB = 28*/\nJSI_EXTERN int Jsi_StrcmpDict(const char *str1, const char *str2, int nocase, int dict); /*STUB = 29*/\nJSI_EXTERN char* Jsi_Strcpy(char *dst, const char *src); /*STUB = 30*/\nJSI_EXTERN char* Jsi_Strncpy(char *dst, const char *src, int len); /*STUB = 31*/\nJSI_EXTERN char* Jsi_Strdup(const char *n); /*STUB = 32*/\nJSI_EXTERN char* Jsi_StrdupLen(const char *str, int len); /*STUB = 407*/\nJSI_EXTERN char* Jsi_Strrchr(const char *str, int c); /*STUB = 33*/\nJSI_EXTERN char* Jsi_Strstr(const char *str, const char *sub); /*STUB = 34*/\nJSI_EXTERN char* Jsi_Strrstr(const char *str, const char *sub); /*STUB = 233*/ \nJSI_EXTERN char* Jsi_Strchr(const char *str, int c); /*STUB = 36*/\nJSI_EXTERN int Jsi_Strpos(const char *str, int start, const char *nid, int nocase); /*STUB = 37*/\nJSI_EXTERN int Jsi_Strrpos(const char *str, int start, const char *nid, int nocase); /*STUB = 38*/\nJSI_EXTERN bool Jsi_StrIsAlnum(const char *cp); /*STUB = 416*/\n#define Jsi_Stzcpy(buf,src) Jsi_Strncpy(buf, src, sizeof(buf))\n\n/* Dynamic strings. */\n#ifndef JSI_DSTRING_STATIC_SIZE\n#define JSI_DSTRING_STATIC_SIZE 200\n#endif\n\ntypedef struct {\n#define JSI_DSTRING_DECL_FIELDS(siz) \\\n    const char *strA; /* Allocated string, or = {\"string\"}.*/ \\\n    uint len;       /* Length of string. */ \\\n    uint spaceAvl;  /* Amount of space available or allocated. */ \\\n    uint staticSize;/* The sizeof \"Str\", or 0 if used \"= {}\" */ \\\n    char Str[siz];  /* Static string */\n    JSI_DSTRING_DECL_FIELDS(JSI_DSTRING_STATIC_SIZE)\n} Jsi_DString;\n\n/* Declares a custom Jsi_DString* variable with other than default size... */\n#define JSI_DSTRING_VAR(namPtr, siz) \\\n    struct { JSI_DSTRING_DECL_FIELDS(siz) } _STATIC_##namPtr; \\\n    Jsi_DString *namPtr = (Jsi_DString *)&_STATIC_##namPtr; \\\n    namPtr->staticSize = siz; namPtr->strA=0; \\\n    namPtr->Str[0] = 0; namPtr->spaceAvl = namPtr->len = 0\n\nJSI_EXTERN char*   Jsi_DSAppendLen(Jsi_DString *dsPtr,const char *bytes, int length);  /*STUB = 39*/\nJSI_EXTERN char*   Jsi_DSAppend(Jsi_DString *dsPtr, const char *str, ...)  /*STUB = 40*/  __attribute__((sentinel));\nJSI_EXTERN void    Jsi_DSFree(Jsi_DString *dsPtr);  /*STUB = 41*/\nJSI_EXTERN char*   Jsi_DSFreeDup(Jsi_DString *dsPtr);  /*STUB = 42*/\nJSI_EXTERN void    Jsi_DSInit(Jsi_DString *dsPtr);  /*STUB = 43*/\nJSI_EXTERN uint    Jsi_DSLength(Jsi_DString *dsPtr);  /*STUB = 44*/\nJSI_EXTERN char*   Jsi_DSPrintf(Jsi_DString *dsPtr, const char *fmt, ...)  /*STUB = 45*/ __attribute__((format (printf,2,3)));\nJSI_EXTERN char*   Jsi_DSSet(Jsi_DString *dsPtr, const char *str);  /*STUB = 46*/\nJSI_EXTERN uint    Jsi_DSSetLength(Jsi_DString *dsPtr, uint length);  /*STUB = 47*/\nJSI_EXTERN char*   Jsi_DSValue(Jsi_DString *dsPtr);  /*STUB = 48*/\n/* -- */\n\n\n/* --FUNC/VAR/CMD-- */\ntypedef void (Jsi_DelCmdProc)(Jsi_Interp *interp, void *privData);\ntypedef Jsi_RC (Jsi_CmdProc)(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\n#define Jsi_CmdProcDecl(name,...) Jsi_RC name(Jsi_Interp *interp, Jsi_Value *args, \\\n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, ##__VA_ARGS__)\n\ntypedef struct Jsi_CmdSpec {\n    const char *name;       /* Cmd name */\n    Jsi_CmdProc *proc;      /* Command handler */\n    int minArgs;\n    int maxArgs;            /* Max args or -1 */\n    const char *argStr;     /* Argument description */\n    const char *help;       /* Short help string. */\n    uint retType;           /* Return type(s) or'ed Jsi_otype. */\n    int flags;              /* JSI_CMD_* flags. */\n    const char *info;       /* Detailed description. Use JSI_DETAIL macro. */\n    Jsi_OptionSpec *opts;   /* Options for arg, default is first. */\n    Jsi_DelCmdProc *delProc;/* Callback to handle command delete. */\n    void *reserved[4];      /* Reserved for internal use. */\n} Jsi_CmdSpec;\n\ntypedef struct {\n    bool Test;\n    bool Debug;\n    bool Trace;\n    int traceCall;\n    bool coverage;\n    bool profile;\n} Jsi_ModuleConf;\n\ntypedef struct {\n    struct Jsi_OptionSpec *spec;\n    void *data;\n    Jsi_CmdSpec *cmdSpec;\n    Jsi_Value *info;\n    void *reserved[3]; // Reserved for future use.\n    Jsi_ModuleConf modConf;\n    void *reserved2[3]; // Reserved for future use.\n} Jsi_PkgOpts;\n\ntypedef struct {\n    char *str;\n    int32_t len;\n    uint32_t flags;\n} Jsi_String;\n\nJSI_EXTERN Jsi_Value* Jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData); /*STUB = 49*/\nJSI_EXTERN Jsi_Value* Jsi_CommandCreateSpecs(Jsi_Interp *interp, const char *name, Jsi_CmdSpec *cmdSpecs, void *privData, int flags); /*STUB = 50*/\nJSI_EXTERN void* Jsi_CommandNewObj(Jsi_Interp *interp, const char *name, const char *arg1, const char *opts, const char *var);  /*STUB = 51*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmd, const char *json, Jsi_Value **ret); /*STUB = 52*/\nJSI_EXTERN Jsi_RC Jsi_CommandInvoke(Jsi_Interp *interp, const char *cmdstr, Jsi_Value *args, Jsi_Value **ret); /*STUB = 53*/\nJSI_EXTERN Jsi_RC Jsi_CommandDelete(Jsi_Interp *interp, const char *name); /*STUB = 54*/\nJSI_EXTERN Jsi_CmdSpec* Jsi_FunctionGetSpecs(Jsi_Func *funcPtr); /*STUB = 55*/\nJSI_EXTERN bool Jsi_FunctionIsConstructor(Jsi_Func *funcPtr); /*STUB = 56*/\nJSI_EXTERN bool Jsi_FunctionReturnIgnored(Jsi_Interp *interp, Jsi_Func *funcPtr); /*STUB = 57*/\nJSI_EXTERN void* Jsi_FunctionPrivData(Jsi_Func *funcPtr); /*STUB = 58*/\nJSI_EXTERN Jsi_RC Jsi_FunctionArguments(Jsi_Interp *interp, Jsi_Value *func, int *argcPtr); /*STUB = 59*/\nJSI_EXTERN Jsi_RC Jsi_FunctionApply(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret); /*STUB = 60*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *tocall, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this); /*STUB = 61*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *tocall, const char *json, Jsi_Value **ret); /*STUB = 62*/\nJSI_EXTERN int Jsi_FunctionInvokeBool(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg); /*STUB = 63*/\nJSI_EXTERN Jsi_RC Jsi_FunctionInvokeString(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *arg, Jsi_DString *dStr); /*STUB = 64*/\nJSI_EXTERN Jsi_Value* Jsi_VarLookup(Jsi_Interp *interp, const char *varname); /*STUB = 65*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup(Jsi_Interp *interp, const char *varname); /*STUB = 66*/\nJSI_EXTERN Jsi_Value* Jsi_NameLookup2(Jsi_Interp *interp, const char *name, const char *inObj); /*STUB = 67*/\nJSI_EXTERN Jsi_RC Jsi_PkgProvideEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_InitProc *initProc, Jsi_PkgOpts* popts); /*STUB = 68*/\nJSI_EXTERN Jsi_Number Jsi_PkgRequireEx(Jsi_Interp *interp, const char *name, Jsi_Number version, Jsi_PkgOpts **poptsPtr); /*STUB = 69*/\nJSI_EXTERN Jsi_Number Jsi_PkgVersion(Jsi_Interp *interp, const char *name, const char **filePtr); /*STUB = 70*/\n#define Jsi_PkgRequire(i,n,v) Jsi_PkgRequireEx(i,n,v,NULL)\n#define Jsi_PkgProvide(i,n,v,p) Jsi_PkgProvideEx(i,n,v,p,NULL)\n/* -- */\n\n/* UTF-8 and Unicode */\ntypedef int32_t Jsi_UniChar;\nJSI_EXTERN uint Jsi_NumUtfBytes(char c); /*STUB = 71*/\nJSI_EXTERN uint Jsi_NumUtfChars(const char *utf, int length); /*STUB = 72*/\nJSI_EXTERN uint Jsi_UtfGetIndex(const char *utf, int index, char outbuf[5]); /*STUB = 73*/\nJSI_EXTERN const char* Jsi_UtfAtIndex(const char *utf, int index); /*STUB = 74*/\nJSI_EXTERN uint Jsi_UniCharToUtf(Jsi_UniChar uc, char *dest); /*STUB = 75*/\nJSI_EXTERN uint Jsi_UtfToUniChar(const char *utf, Jsi_UniChar *ch); /*STUB = 76*/\nJSI_EXTERN uint Jsi_UtfToUniCharCase(const char *utf, Jsi_UniChar *ch, int upper); /*STUB = 77*/\nJSI_EXTERN uint Jsi_UtfDecode(const char *str, char* oututf); /*STUB = 78*/\nJSI_EXTERN uint Jsi_UtfEncode(const char *utf, char *outstr); /*STUB = 79*/\nJSI_EXTERN char* Jsi_UtfSubstr(const char *str, int n, int len, Jsi_DString *dStr); /*STUB = 80*/\nJSI_EXTERN int Jsi_UtfIndexToOffset(const char *utf, int index); /*STUB = 81*/\n/* -- */\n\n\n/* --OBJECT-- */\nJSI_EXTERN Jsi_Obj* Jsi_ObjNew(Jsi_Interp* interp); /*STUB = 82*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewType(Jsi_Interp* interp, Jsi_otype type); /*STUB = 83*/\nJSI_EXTERN void Jsi_ObjFree(Jsi_Interp* interp, Jsi_Obj *obj); /*STUB = 84*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count); /*STUB = 85*/\nJSI_EXTERN Jsi_Obj* Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copy); /*STUB = 86*/\n\nJSI_EXTERN bool      Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o); /*STUB = 87*/\nJSI_EXTERN void     Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len); /*STUB = 88*/\nJSI_EXTERN int      Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 89*/\nJSI_EXTERN const char* Jsi_ObjTypeStr(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 90*/\nJSI_EXTERN Jsi_otype Jsi_ObjTypeGet(Jsi_Obj *obj); /*STUB = 91*/\nJSI_EXTERN void     Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj); /*STUB = 92*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex); /*STUB = 93*/\nJSI_EXTERN Jsi_RC      Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v); /*STUB = 94*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *nv, int flags); /*STUB = 95*/\nJSI_EXTERN void    Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj);  /*STUB = 96*/\nJSI_EXTERN Jsi_IterObj* Jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterProc); /*STUB = 412*/\nJSI_EXTERN void Jsi_IterObjFree(Jsi_IterObj *iobj); /*STUB = 413*/\nJSI_EXTERN void Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth); /*STUB = 414*/\nJSI_EXTERN int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint n); /*STUB = 35*/\n\nstruct Jsi_IterObj {\n    Jsi_Interp *interp;\n    const char **keys;\n    uint size; \n    uint count;\n    uint iter;\n    bool isArrayList;            /* If an array list do not store keys. */\n    bool isof;\n    Jsi_Obj *obj;\n    uint cur;                    /* Current array cursor. */\n    int depth;                  /* Used to create list of keys. */\n    Jsi_IterProc *iterCmd;\n};\n\n/* -- */\n\n\n/* --VALUE-- */\nJSI_EXTERN Jsi_Value* Jsi_ValueNew(Jsi_Interp *interp); /*STUB = 97*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNew1(Jsi_Interp *interp); /*STUB = 98*/\nJSI_EXTERN void Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v); /*STUB = 99*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp); /*STUB = 100*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval); /*STUB = 101*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n); /*STUB = 102*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, uchar *s, uint len); /*STUB = 103*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len); /*STUB = 104*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s); /*STUB = 105*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len); /*STUB = 409*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s); /*STUB = 106*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count); /*STUB = 107*/\nJSI_EXTERN Jsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) ; /*STUB = 108*/\n#define Jsi_ValueNewBlobString(interp, s) Jsi_ValueNewBlob(interp, (uchar*)s, Jsi_Strlen(s))\n#define Jsi_ValueNewArrayObj(interp, items, count, copy) Jsi_ValueNewObj(interp, Jsi_ObjNewArray(interp, items, count, copy))\n\nJSI_EXTERN Jsi_RC Jsi_GetStringFromValue(Jsi_Interp* interp, Jsi_Value *value, const char **s); /*STUB = 109*/\nJSI_EXTERN Jsi_RC Jsi_GetNumberFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 110*/\nJSI_EXTERN Jsi_RC Jsi_GetBoolFromValue(Jsi_Interp* interp, Jsi_Value *value, bool *n); /*STUB = 111*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValue(Jsi_Interp* interp, Jsi_Value *value, int *n); /*STUB = 112*/\nJSI_EXTERN Jsi_RC Jsi_GetLongFromValue(Jsi_Interp* interp, Jsi_Value *value, long *n); /*STUB = 113*/\nJSI_EXTERN Jsi_RC Jsi_GetWideFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Wide *n); /*STUB = 114*/\nJSI_EXTERN Jsi_RC Jsi_GetDoubleFromValue(Jsi_Interp* interp, Jsi_Value *value, Jsi_Number *n); /*STUB = 115*/\nJSI_EXTERN Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags); /*STUB = 116*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val); /*STUB = 117*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val); /*STUB = 118*/\n\nJSI_EXTERN bool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype); /*STUB = 119*/\nJSI_EXTERN bool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype); /*STUB = 120*/\nJSI_EXTERN bool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 121*/\nJSI_EXTERN bool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 122*/\nJSI_EXTERN bool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 123*/\nJSI_EXTERN bool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 124*/\nJSI_EXTERN bool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 125*/\nJSI_EXTERN bool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 126*/\nJSI_EXTERN bool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 127*/\nJSI_EXTERN bool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 128*/\nJSI_EXTERN bool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv); /*STUB = 129*/\n\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 130*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_Obj *o); /*STUB = 131*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **v, Jsi_Number n); /*STUB = 132*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **v, int b); /*STUB = 133*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 134*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **v, const char *s); /*STUB = 135*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **v, uchar *s, int len); /*STUB = 136*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 137*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 138*/\nJSI_EXTERN Jsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **v, Jsi_DString *dsPtr); /*STUB = 139*/\nJSI_EXTERN bool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key); /*STUB = 140*/\n#define Jsi_ValueMakeStringDup(interp, v, s) Jsi_ValueMakeString(interp, v, Jsi_Strdup(s))\n\nJSI_EXTERN const char*  Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr); /*STUB = 141*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 142*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 143*/\nJSI_EXTERN Jsi_Number   Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt); /*STUB = 144*/\nJSI_EXTERN Jsi_RC       Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 145*/\n\nJSI_EXTERN void     Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **v); /*STUB = 146*/\nJSI_EXTERN const char* Jsi_ValueGetDString(Jsi_Interp* interp, Jsi_Value* v, Jsi_DString *dStr, int quote); /*STUB = 147*/\nJSI_EXTERN char*    Jsi_ValueString(Jsi_Interp* interp, Jsi_Value* v, int *lenPtr); /*STUB = 148*/\nJSI_EXTERN uchar*   Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr); /*STUB = 149*/\nJSI_EXTERN char*    Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr); /*STUB = 150*/\nJSI_EXTERN int      Jsi_ValueStrlen(Jsi_Value* v); /*STUB = 151*/\nJSI_EXTERN void     Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret);  /*STUB = 152*/\nJSI_EXTERN int      Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2); /*STUB = 153*/\nJSI_EXTERN Jsi_Obj* Jsi_ValueGetObj(Jsi_Interp* interp, Jsi_Value* v); /*STUB = 154*/\nJSI_EXTERN Jsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv); /*STUB = 155*/\nJSI_EXTERN const char* Jsi_ValueTypeStr(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 156*/\nJSI_EXTERN int      Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int cmpFlags); /*STUB = 157*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetIndex( Jsi_Interp *interp, Jsi_Value *valPtr, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 158*/\n\nJSI_EXTERN Jsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int sortFlags); /*STUB = 159*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 160*/\nJSI_EXTERN Jsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2); /*STUB = 161*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *arg1); /*STUB = 162*/\nJSI_EXTERN void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 163*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 164*/\nJSI_EXTERN Jsi_Value* Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index); /*STUB = 165*/\nJSI_EXTERN char* Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr); /*STUB = 166*/\n#define Jsi_ValueArraySet(interp, dest, value, index) Jsi_ObjArraySet(interp, Jsi_ValueGetObj(interp, dest), value, index)\n\n#define Jsi_ValueInsertFixed(i,t,k,v) Jsi_ValueInsert(i,t,k,v,JSI_OM_READONLY | JSI_OM_DONTDEL | JSI_OM_DONTENUM)\nJSI_EXTERN Jsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags); /*STUB = 167*/\nJSI_EXTERN Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int index, Jsi_Value *val, int flags); /*STUB = 411*/\nJSI_EXTERN int Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 168*/\nJSI_EXTERN Jsi_Value* Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int iskeystr); /*STUB = 169*/\nJSI_EXTERN bool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *k, int isstrkey); /*STUB = 170*/\nJSI_EXTERN Jsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret); /*STUB = 171*/\n\nJSI_EXTERN void Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ); /*STUB = 172*/\nJSI_EXTERN void Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from ); /*STUB = 173*/\nJSI_EXTERN void Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from); /*STUB = 174*/\nJSI_EXTERN Jsi_Value* Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val); /*STUB = 175*/\nJSI_EXTERN void Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from); /*STUB = 176*/\nJSI_EXTERN bool  Jsi_ValueIsEqual(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2); /*STUB = 177*/\n/* -- */\n\n\n/* --USEROBJ-- */\ntypedef bool (Jsi_UserObjIsTrueProc)(void *data);\ntypedef bool (Jsi_UserObjIsEquProc)(void *data1, void *data2);\ntypedef Jsi_Obj* (Jsi_UserGetObjProc)(Jsi_Interp *interp, void *data);\n\ntypedef struct Jsi_UserObjReg {\n    const char *name;\n    Jsi_CmdSpec *spec;\n    Jsi_DeleteProc *freefun;\n    Jsi_UserObjIsTrueProc *istrue;\n    Jsi_UserObjIsEquProc *isequ;\n} Jsi_UserObjReg;\n\nJSI_EXTERN Jsi_Hash* Jsi_UserObjRegister    (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 178*/\nJSI_EXTERN Jsi_RC Jsi_UserObjUnregister  (Jsi_Interp *interp, Jsi_UserObjReg *reg); /*STUB = 179*/\nJSI_EXTERN int Jsi_UserObjNew    (Jsi_Interp *interp, Jsi_UserObjReg* reg, Jsi_Obj *obj, void *data); /*STUB = 180*/\nJSI_EXTERN void* Jsi_UserObjGetData(Jsi_Interp *interp, Jsi_Value* value, Jsi_Func *funcPtr); /*STUB = 181*/\nJSI_EXTERN Jsi_RC Jsi_UserObjName(Jsi_Interp *interp, Jsi_Value *v, Jsi_DString *dStr); /*STUB = 418*/ /*LAST*/\n/* -- */\n\n\n/* --UTILITY-- */\n#define JSI_NOTUSED(n) (void)n /* Eliminate annoying compiler warning. */\nJSI_EXTERN char* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz); /*STUB = 182*/\nJSI_EXTERN Jsi_Number Jsi_Version(void); /*STUB = 183*/\nJSI_EXTERN Jsi_Value* Jsi_ReturnValue(Jsi_Interp *interp); /*STUB = 184*/\nJSI_EXTERN Jsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret); /*STUB = 185*/\nJSI_EXTERN Jsi_Value* Jsi_Executable(Jsi_Interp *interp); /*STUB = 186*/\nJSI_EXTERN Jsi_Regex* Jsi_RegExpNew(Jsi_Interp *interp, const char *regtxt, int flag); /*STUB = 187*/\nJSI_EXTERN void Jsi_RegExpFree(Jsi_Regex* re); /*STUB = 188*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatch( Jsi_Interp *interp,  Jsi_Value *pattern, const char *str, int *rc, Jsi_DString *dStr); /*STUB = 189*/\nJSI_EXTERN Jsi_RC Jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret); /*STUB = 190*/\nJSI_EXTERN bool Jsi_GlobMatch(const char *pattern, const char *string, int nocase); /*STUB = 191*/\nJSI_EXTERN char* Jsi_FileRealpath(Jsi_Interp *interp, Jsi_Value *path, char *newpath); /*STUB = 192*/\nJSI_EXTERN char* Jsi_FileRealpathStr(Jsi_Interp *interp, const char *path, char *newpath); /*STUB = 193*/\nJSI_EXTERN char* Jsi_NormalPath(Jsi_Interp *interp, const char *path, Jsi_DString *dStr); /*STUB = 194*/\nJSI_EXTERN char* Jsi_ValueNormalPath(Jsi_Interp *interp, Jsi_Value *path, Jsi_DString *dStr); /*STUB = 195*/\nJSI_EXTERN Jsi_RC Jsi_PathNormalize(Jsi_Interp *interp, Jsi_Value **pathPtr); /*STUB = 410*/\nJSI_EXTERN Jsi_RC Jsi_JSONParse(Jsi_Interp *interp, const char *js, Jsi_Value **ret, int flags); /*STUB = 196*/\nJSI_EXTERN Jsi_RC Jsi_JSONParseFmt(Jsi_Interp *interp, Jsi_Value **ret, const char *fmt, ...) /*STUB = 197*/ __attribute__((format (printf,3,4)));\nJSI_EXTERN char* Jsi_JSONQuote(Jsi_Interp *interp, const char *str, int len, Jsi_DString *dStr); /*STUB = 198*/\nJSI_EXTERN Jsi_RC Jsi_EvalString(Jsi_Interp* interp, const char *str, int flags); /*STUB = 199*/\nJSI_EXTERN Jsi_RC Jsi_EvalFile(Jsi_Interp* interp, Jsi_Value *fname, int flags); /*STUB = 200*/\nJSI_EXTERN Jsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags); /*STUB = 201*/\nJSI_EXTERN Jsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound); /*STUB = 202*/\nJSI_EXTERN int Jsi_DictionaryCompare(const char *left, const char *right); /*STUB = 203*/\nJSI_EXTERN Jsi_RC Jsi_GetBool(Jsi_Interp* interp, const char *string, bool *n); /*STUB = 204*/\nJSI_EXTERN Jsi_RC Jsi_GetInt(Jsi_Interp* interp, const char *string, int *n, int base); /*STUB = 205*/\nJSI_EXTERN Jsi_RC Jsi_GetWide(Jsi_Interp* interp, const char *string, Jsi_Wide *n, int base); /*STUB = 206*/\nJSI_EXTERN Jsi_RC Jsi_GetDouble(Jsi_Interp* interp, const char *string, Jsi_Number *n); /*STUB = 207*/\nJSI_EXTERN Jsi_RC Jsi_FormatString(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr); /*STUB = 208*/\nJSI_EXTERN void Jsi_SplitStr(const char *str, int *argcPtr, char ***argvPtr,  const char *splitCh, Jsi_DString *dStr); /*STUB = 209*/\nJSI_EXTERN Jsi_RC Jsi_Sleep(Jsi_Interp *interp, Jsi_Number dtim); /*STUB = 210*/\nJSI_EXTERN void Jsi_Preserve(Jsi_Interp* interp, void *data); /*STUB = 211*/\nJSI_EXTERN void Jsi_Release(Jsi_Interp* interp, void *data); /*STUB = 212*/\nJSI_EXTERN void Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc); /*STUB = 213*/\nJSI_EXTERN void Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 214*/\nJSI_EXTERN Jsi_Value* Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton); /*STUB = 215*/\nJSI_EXTERN Jsi_RC Jsi_GetIndex( Jsi_Interp *interp, const char *str, const char **tablePtr, const char *msg, int flags, int *indexPtr); /*STUB = 216*/\nJSI_EXTERN void* Jsi_PrototypeGet(Jsi_Interp *interp, const char *key); /*STUB = 217*/\nJSI_EXTERN Jsi_RC  Jsi_PrototypeDefine(Jsi_Interp *interp, const char *key, Jsi_Value *proto); /*STUB = 218*/\nJSI_EXTERN Jsi_RC Jsi_PrototypeObjSet(Jsi_Interp *interp, const char *key, Jsi_Obj *obj); /*STUB = 219*/\nJSI_EXTERN Jsi_RC Jsi_ThisDataSet(Jsi_Interp *interp, Jsi_Value *_this, void *value); /*STUB = 220*/\nJSI_EXTERN void* Jsi_ThisDataGet(Jsi_Interp *interp, Jsi_Value *_this); /*STUB = 221*/\nJSI_EXTERN Jsi_RC Jsi_FuncObjToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags); /*STUB = 222*/\nJSI_EXTERN void* Jsi_UserObjDataFromVar(Jsi_Interp *interp, const char *var); /*STUB = 223*/\nJSI_EXTERN const char* Jsi_KeyAdd(Jsi_Interp *interp, const char *str); /*STUB = 224*/\nJSI_EXTERN const char* Jsi_KeyLookup(Jsi_Interp *interp, const char *str); /*STUB = 225*/\nJSI_EXTERN bool Jsi_IsReserved(Jsi_Interp *interp, const char* str, bool sql); /*STUB = 415*/\nJSI_EXTERN Jsi_RC Jsi_SqlObjBinds(Jsi_Interp* interp, Jsi_DString* zStr, const char *varName, bool addTypes, bool addDefaults, bool nullDefaults); /*STUB = 417*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeFormat(Jsi_Interp *interp, Jsi_Number date, const char *fmt, int isUtc, Jsi_DString *dStr);  /*STUB = 226*/\nJSI_EXTERN Jsi_RC Jsi_DatetimeParse(Jsi_Interp *interp, const char *str, const char *fmt, int isUtc, Jsi_Number *datePtr, bool noMsg); /*STUB = 227*/\nJSI_EXTERN Jsi_Number Jsi_DateTime(void); /*STUB = 228*/\n#define JSI_DATE_JULIAN2UNIX(d)  (Jsi_Number)(((Jsi_Number)d - 2440587.5)*86400.0)\n#define JSI_DATE_UNIX2JULIAN(d)  (Jsi_Number)((Jsi_Number)d/86400.0+2440587.5)\n\ntypedef enum { Jsi_CHash_SHA2_256, Jsi_CHash_SHA1, Jsi_CHash_MD5, Jsi_CHash_SHA3_224, \n    Jsi_CHash_SHA3_384, Jsi_CHash_SHA3_512, Jsi_CHash_SHA3_256 } Jsi_CryptoHashType;\n\nJSI_EXTERN Jsi_RC Jsi_Encrypt(Jsi_Interp *interp, Jsi_DString *inout, const char *key, uint keyLen, bool decrypt); /*STUB = 229*/\nJSI_EXTERN Jsi_RC Jsi_CryptoHash(char *outbuf, const char *str, int len, Jsi_CryptoHashType type, uint strength, bool noHex, int *sizPtr); /*STUB = 230*/\nJSI_EXTERN Jsi_RC Jsi_Base64(const char *str, int len, Jsi_DString *buf, bool decode); /*STUB = 231*/\nJSI_EXTERN int Jsi_HexStr(const uchar *data, int len, Jsi_DString *dStr, bool decode); /*STUB = 232*/\nJSI_EXTERN uint32_t Jsi_Crc32(uint32_t crc, const void *ptr, size_t buf_len); /*STUB = 234*/\nJSI_EXTERN Jsi_RC Jsi_FileRead(Jsi_Interp *interp, Jsi_Value *name, Jsi_DString *dStr); /*STUB = 408*/\n\nJSI_EXTERN int Jsi_NumberIsInfinity(Jsi_Number a);  /*STUB = 235*/\nJSI_EXTERN bool Jsi_NumberIsEqual(Jsi_Number n1, Jsi_Number n2);  /*STUB = 236*/\nJSI_EXTERN bool Jsi_NumberIsFinite(Jsi_Number value);  /*STUB = 237*/\nJSI_EXTERN bool Jsi_NumberIsInteger(Jsi_Number n);  /*STUB = 238*/\nJSI_EXTERN bool Jsi_NumberIsNaN(Jsi_Number a);  /*STUB = 239*/\nJSI_EXTERN bool Jsi_NumberIsNormal(Jsi_Number a);  /*STUB = 240*/\nJSI_EXTERN bool Jsi_NumberIsSubnormal(Jsi_Number a);  /*STUB = 241*/\nJSI_EXTERN bool Jsi_NumberIsWide(Jsi_Number n);  /*STUB = 242*/\nJSI_EXTERN Jsi_Number Jsi_NumberInfinity(int i);  /*STUB = 243*/\nJSI_EXTERN Jsi_Number Jsi_NumberNaN(void);  /*STUB = 244*/\nJSI_EXTERN void Jsi_NumberDtoA(Jsi_Interp *interp, Jsi_Number value, char* buf, int bsiz, int prec);  /*STUB = 245*/\nJSI_EXTERN void Jsi_NumberItoA10(Jsi_Wide value, char* buf, int bsiz);  /*STUB = 246*/\nJSI_EXTERN void Jsi_NumberUtoA10(Jsi_UWide, char* buf, int bsiz);  /*STUB = 247*/\n\n/* -- */\n\n#define JSI_WORDKEY_CAST (void*)(uintptr_t)\n\nstruct Jsi_MapOpts;\n\ntypedef Jsi_RC (Jsi_HashDeleteProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_TreeDeleteProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\ntypedef Jsi_RC (Jsi_MapDeleteProc)(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *data);\ntypedef Jsi_Value *(Jsi_MapFmtKeyProc)(Jsi_MapEntry* hPtr, struct Jsi_MapOpts *opts, int flags);\ntypedef Jsi_RC (Jsi_TreeWalkProc)(Jsi_Tree* treePtr, Jsi_TreeEntry* hPtr, void *data);\ntypedef int (Jsi_RBCompareProc)(Jsi_Tree *treePtr, const void *key1, const void *key2);\n\ntypedef struct Jsi_MapOpts {\n    Jsi_Map_Type mapType; // Read-only\n    Jsi_Key_Type keyType; // Read-only\n    Jsi_Interp *interp;\n    Jsi_Wide flags;\n    void *user, *user2;\n    Jsi_MapFmtKeyProc *fmtKeyProc;\n    Jsi_RBCompareProc *compareTreeProc;\n    union {\n        Jsi_RC (*freeHashProc)(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data);\n        Jsi_RC (*freeTreeProc)(Jsi_Interp *interp, Jsi_TreeEntry *hPtr, void *data);\n        Jsi_RC (*freeListProc)(Jsi_Interp *interp, Jsi_ListEntry *hPtr, void *data);\n    };\n    union {\n        Jsi_RC (*lockHashProc) (Jsi_Hash *tablePtr, int lock);\n        Jsi_RC (*lockTreeProc) (Jsi_Tree *tablePtr, int lock);\n    };\n} Jsi_MapOpts;\n\n/* --HASH-- */\ntypedef struct Jsi_HashSearch {\n    Jsi_Hash *tablePtr;\n    unsigned long nextIndex; \n    Jsi_HashEntry *nextEntryPtr;\n} Jsi_HashSearch;\n\nJSI_EXTERN Jsi_Hash* Jsi_HashNew(Jsi_Interp *interp, uint keyType, Jsi_HashDeleteProc *freeProc); /*STUB = 248*/\nJSI_EXTERN Jsi_RC Jsi_HashConf(Jsi_Hash *hashPtr, Jsi_MapOpts *opts, bool set); /*STUB = 249*/\nJSI_EXTERN void Jsi_HashDelete(Jsi_Hash *hashPtr); /*STUB = 250*/\nJSI_EXTERN void Jsi_HashClear(Jsi_Hash *hashPtr); /*STUB = 251*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSet(Jsi_Hash *hashPtr, const void *key, void *value); /*STUB = 252*/\nJSI_EXTERN void* Jsi_HashGet(Jsi_Hash *hashPtr, const void *key, int flags); /*STUB = 253*/\nJSI_EXTERN bool Jsi_HashUnset(Jsi_Hash *tbl, const void *key); /*STUB = 254*/\nJSI_EXTERN void* Jsi_HashKeyGet(Jsi_HashEntry *h); /*STUB = 255*/\nJSI_EXTERN Jsi_RC Jsi_HashKeysDump(Jsi_Interp *interp, Jsi_Hash *hashPtr, Jsi_Value **ret, int flags); /*STUB = 256*/\nJSI_EXTERN void* Jsi_HashValueGet(Jsi_HashEntry *h); /*STUB = 257*/\nJSI_EXTERN void Jsi_HashValueSet(Jsi_HashEntry *h, void *value); /*STUB = 258*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryFind (Jsi_Hash *hashPtr, const void *key); /*STUB = 259*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashEntryNew (Jsi_Hash *hashPtr, const void *key, bool *isNew); /*STUB = 260*/\nJSI_EXTERN int Jsi_HashEntryDelete (Jsi_HashEntry *entryPtr); /*STUB = 261*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchFirst (Jsi_Hash *hashPtr, Jsi_HashSearch *searchPtr); /*STUB = 262*/\nJSI_EXTERN Jsi_HashEntry* Jsi_HashSearchNext (Jsi_HashSearch *searchPtr); /*STUB = 263*/\nJSI_EXTERN uint Jsi_HashSize(Jsi_Hash *hashPtr); /*STUB = 264*/\n/* -- */\n\n\n/* --TREE-- */\n\ntypedef struct Jsi_TreeSearch {\n    Jsi_Tree *treePtr;\n    uint top, max, left, epoch; \n    int flags;\n    Jsi_TreeEntry *staticPtrs[200], *current;\n    Jsi_TreeEntry **Ptrs;\n} Jsi_TreeSearch;\n\nJSI_EXTERN Jsi_Tree* Jsi_TreeNew(Jsi_Interp *interp, uint keyType, Jsi_TreeDeleteProc *freeProc); /*STUB = 265*/\nJSI_EXTERN Jsi_RC Jsi_TreeConf(Jsi_Tree *treePtr, Jsi_MapOpts *opts, bool set); /*STUB = 266*/\nJSI_EXTERN void Jsi_TreeDelete(Jsi_Tree *treePtr); /*STUB = 267*/\nJSI_EXTERN void Jsi_TreeClear(Jsi_Tree *treePtr); /*STUB = 268*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeObjSetValue(Jsi_Obj* obj, const char *key, Jsi_Value *val, int isstrkey); /*STUB = 269*/\nJSI_EXTERN Jsi_Value*     Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey); /*STUB = 270*/\nJSI_EXTERN void* Jsi_TreeValueGet(Jsi_TreeEntry *hPtr); /*STUB = 271*/\nJSI_EXTERN void Jsi_TreeValueSet(Jsi_TreeEntry *hPtr, void *value); /*STUB = 272*/\nJSI_EXTERN void* Jsi_TreeKeyGet(Jsi_TreeEntry *hPtr); /*STUB = 273*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryFind(Jsi_Tree *treePtr, const void *key); /*STUB = 274*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeEntryNew(Jsi_Tree *treePtr, const void *key, bool *isNew); /*STUB = 275*/\nJSI_EXTERN int Jsi_TreeEntryDelete(Jsi_TreeEntry *entryPtr); /*STUB = 276*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchFirst(Jsi_Tree *treePtr, Jsi_TreeSearch *searchPtr, int flags, const void *startKey); /*STUB = 277*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSearchNext(Jsi_TreeSearch *searchPtr); /*STUB = 278*/\nJSI_EXTERN void Jsi_TreeSearchDone(Jsi_TreeSearch *searchPtr); /*STUB = 279*/\nJSI_EXTERN int Jsi_TreeWalk(Jsi_Tree* treePtr, Jsi_TreeWalkProc* callback, void *data, int flags); /*STUB = 280*/\nJSI_EXTERN Jsi_TreeEntry* Jsi_TreeSet(Jsi_Tree *treePtr, const void *key, void *value); /*STUB = 281*/\nJSI_EXTERN void* Jsi_TreeGet(Jsi_Tree *treePtr, void *key, int flags); /*STUB = 282*/\nJSI_EXTERN bool Jsi_TreeUnset(Jsi_Tree *treePtr, void *key); /*STUB = 283*/\nJSI_EXTERN uint Jsi_TreeSize(Jsi_Tree *treePtr); /*STUB = 284*/ \nJSI_EXTERN Jsi_Tree* Jsi_TreeFromValue(Jsi_Interp *interp, Jsi_Value *v); /*STUB = 285*/\nJSI_EXTERN Jsi_RC Jsi_TreeKeysDump(Jsi_Interp *interp, Jsi_Tree *hashPtr, Jsi_Value **ret, int flags); /*STUB = 286*/\n/* -- */\n\n\n/* --LIST-- */\ntypedef struct Jsi_List {\n    uint sig;\n    int numEntries;\n    Jsi_ListEntry *head;\n    Jsi_ListEntry *tail;\n    Jsi_MapOpts opts;\n} Jsi_List;\n\ntypedef struct Jsi_ListEntry {\n    uint sig;\n    Jsi_Map_Type typ;    \n    struct Jsi_ListEntry *next;\n    struct Jsi_ListEntry *prev;\n    Jsi_List *list;\n    void *value;\n} Jsi_ListEntry;\n\ntypedef struct Jsi_ListSearch {\n    int flags;\n    Jsi_List *tablePtr;\n    unsigned long nextIndex; \n    Jsi_ListEntry *nextEntryPtr;\n} Jsi_ListSearch;\n\nJSI_EXTERN Jsi_List* Jsi_ListNew(Jsi_Interp *interp, Jsi_Wide flags, Jsi_HashDeleteProc *freeProc); /*STUB = 287*/\nJSI_EXTERN Jsi_RC Jsi_ListConf(Jsi_List *list, Jsi_MapOpts *opts, bool set); /*STUB = 288*/\nJSI_EXTERN void Jsi_ListDelete(Jsi_List *list); /*STUB = 289*/\nJSI_EXTERN void Jsi_ListClear(Jsi_List *list); /*STUB = 290*/\n//#define Jsi_ListSet(l, before, value) Jsi_ListPush(l, before, Jsi_ListEntryNew(l, value))\n//#define Jsi_ListGet(l, le) (le)->value \n//#define Jsi_ListKeyGet(le) (le)\n//#define Jsi_ListKeysDump(interp, list, ret, flags) JSI_ERROR\nJSI_EXTERN void* Jsi_ListValueGet(Jsi_ListEntry *list); /*STUB = 291*/\nJSI_EXTERN void Jsi_ListValueSet(Jsi_ListEntry *list, const void *value); /*STUB = 292*/\n//#define Jsi_ListEntryFind(l, le) (le)\nJSI_EXTERN Jsi_ListEntry* Jsi_ListEntryNew(Jsi_List *list, const void *value, Jsi_ListEntry *before); /*STUB = 293*/\nJSI_EXTERN int Jsi_ListEntryDelete(Jsi_ListEntry *entry); /*STUB = 294*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchFirst (Jsi_List *list, Jsi_ListSearch *search, int flags); /*STUB = 295*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListSearchNext (Jsi_ListSearch *search); /*STUB = 296*/\nJSI_EXTERN uint Jsi_ListSize(Jsi_List *list); /*STUB = 297*/\n/* end of hash-compat functions. */\n\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPush(Jsi_List *list, Jsi_ListEntry *entry, Jsi_ListEntry *before); /*STUB = 298*/\nJSI_EXTERN Jsi_ListEntry* Jsi_ListPop(Jsi_List *list, Jsi_ListEntry *entry); /*STUB = 299*/\n#define Jsi_ListPushFront(list,entry)   Jsi_ListPush(list, entry, list->head)\n#define Jsi_ListPushBack(list,entry)    Jsi_ListPush(list, entry, NULL)\n#define Jsi_ListPushFrontNew(list,v)    Jsi_ListEntryNew(list, v, list->head)\n#define Jsi_ListPushBackNew(list,v)     Jsi_ListEntryNew(list, v, NULL)\n#define Jsi_ListPopFront(list)          Jsi_ListPop(list, list->head)\n#define Jsi_ListPopBack(list)           Jsi_ListPop(list, list->tail)\n#define Jsi_ListEntryNext(entry)        (entry)->next \n#define Jsi_ListEntryPrev(entry)        (entry)->prev\n#define Jsi_ListGetFront(list)          (list)->head\n#define Jsi_ListGetBack(list)           (list)->tail\n\n/* -- */\n\n\n/* --STACK-- */\ntypedef struct {\n    int len;\n    int maxlen;\n    void **vector;\n} Jsi_Stack;\n\nJSI_EXTERN Jsi_Stack* Jsi_StackNew(void); /*STUB = 300*/\nJSI_EXTERN void Jsi_StackFree(Jsi_Stack *stack); /*STUB = 301*/\nJSI_EXTERN int Jsi_StackSize(Jsi_Stack *stack); /*STUB = 302*/\nJSI_EXTERN void Jsi_StackPush(Jsi_Stack *stack, void *element); /*STUB = 303*/\nJSI_EXTERN void* Jsi_StackPop(Jsi_Stack *stack); /*STUB = 304*/\nJSI_EXTERN void* Jsi_StackPeek(Jsi_Stack *stack); /*STUB = 305*/\nJSI_EXTERN void* Jsi_StackUnshift(Jsi_Stack *stack); /*STUB = 306*/\nJSI_EXTERN void* Jsi_StackHead(Jsi_Stack *stack); /*STUB = 307*/\nJSI_EXTERN void Jsi_StackFreeElements(Jsi_Interp *interp, Jsi_Stack *stack, Jsi_DeleteProc *freeFunc); /*STUB = 308*/\n/* -- */\n\n/* --MAP-- */\ntypedef struct Jsi_MapSearch {\n    Jsi_Map_Type typ;\n    union {\n        Jsi_TreeSearch tree;\n        Jsi_HashSearch hash;\n        Jsi_ListSearch list;\n    } v;\n} Jsi_MapSearch;\n\nJSI_EXTERN Jsi_Map* Jsi_MapNew(Jsi_Interp *interp, Jsi_Map_Type mapType, Jsi_Key_Type keyType, Jsi_MapDeleteProc *freeProc); /*STUB = 309*/\nJSI_EXTERN Jsi_RC Jsi_MapConf(Jsi_Map *mapPtr, Jsi_MapOpts *opts, bool set); /*STUB = 310*/\nJSI_EXTERN void Jsi_MapDelete (Jsi_Map *mapPtr); /*STUB = 311*/\nJSI_EXTERN void Jsi_MapClear (Jsi_Map *mapPtr); /*STUB = 312*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSet(Jsi_Map *mapPtr, const void *key, const void *value); /*STUB = 313*/\nJSI_EXTERN void* Jsi_MapGet(Jsi_Map *mapPtr, const void *key, int flags); /*STUB = 314*/\nJSI_EXTERN void* Jsi_MapKeyGet(Jsi_MapEntry *h, int flags); /*STUB = 315*/\nJSI_EXTERN Jsi_RC Jsi_MapKeysDump(Jsi_Interp *interp, Jsi_Map *mapPtr, Jsi_Value **ret, int flags); /*STUB = 316*/\nJSI_EXTERN void* Jsi_MapValueGet(Jsi_MapEntry *h); /*STUB = 317*/\nJSI_EXTERN void Jsi_MapValueSet(Jsi_MapEntry *h, const void *value); /*STUB = 318*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryFind (Jsi_Map *mapPtr, const void *key); /*STUB = 319*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapEntryNew (Jsi_Map *mapPtr, const void *key, bool *isNew); /*STUB = 320*/\nJSI_EXTERN int Jsi_MapEntryDelete (Jsi_MapEntry *entryPtr); /*STUB = 321*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchFirst (Jsi_Map *mapPtr, Jsi_MapSearch *searchPtr, int flags); /*STUB = 322*/\nJSI_EXTERN Jsi_MapEntry* Jsi_MapSearchNext (Jsi_MapSearch *srchPtr); /*STUB = 323*/\nJSI_EXTERN void Jsi_MapSearchDone (Jsi_MapSearch *searchPtr);  /*STUB = 324*/\nJSI_EXTERN uint Jsi_MapSize(Jsi_Map *mapPtr); /*STUB = 325*/\n\n\n// Define typed wrappers for 5 main Map functions: Set, Get, KeyGet, EntryFind, EntryNew\n#define JSI_MAP_EXTN(Prefix, keyType, valType) \\\nJSI_EXTERN Jsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value); \\\nJSI_EXTERN valType Prefix ## _Get(Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN keyType Prefix ## _KeyGet(Jsi_MapEntry *h); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key); \\\nJSI_EXTERN Jsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew);\n\n#define JSI_MAP_DEFN(Prefix, keyType, valType) \\\nJsi_MapEntry *Prefix ## _Set(Jsi_Map *mapPtr, keyType key, valType value) { return Jsi_MapSet(mapPtr, (void*)key, (void*)value); } \\\nvalType Prefix ## _Get(Jsi_Map *mapPtr, keyType key) { return (valType)Jsi_MapGet(mapPtr, (void*)key); } \\\nkeyType Prefix ## _KeyGet(Jsi_MapEntry *h) { return (keyType)Jsi_MapKeyGet(h); } \\\nJsi_MapEntry* Prefix ## _EntryFind (Jsi_Map *mapPtr, keyType key) { return  Jsi_MapEntryFind(mapPtr, (void*)key); } \\\nJsi_MapEntry* Prefix ## _EntryNew (Jsi_Map *mapPtr, keyType key, int *isNew) { return  Jsi_MapEntryNew(mapPtr, (void*)key, isNew); }\n   \n/* -- */\n\n\n/* --OPTIONS-- */\ntypedef Jsi_RC (Jsi_OptionParseProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value *value, const char *str, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_Value **retValue, Jsi_DString *retStr, void *record, Jsi_Wide flags);\ntypedef Jsi_RC (Jsi_OptionFormatStringProc) (\n    Jsi_Interp *interp, Jsi_OptionSpec *spec, Jsi_DString **retValue, void *record);\ntypedef void (Jsi_OptionFreeProc) (Jsi_Interp *interp, Jsi_OptionSpec *spec, void *ptr);\n\ntypedef Jsi_RC (Jsi_OptionBitOp)(Jsi_Interp *interp, Jsi_OptionSpec *spec, void *data, Jsi_Wide *s, int isSet);\n\ntypedef struct {\n    const char *name;\n    Jsi_OptionParseProc *parseProc;\n    Jsi_OptionFormatProc *formatProc;\n    Jsi_OptionFreeProc *freeProc;\n    const char *help;\n    const char *info;\n    void* data;\n} Jsi_OptionCustom;\n\ntypedef enum {\n    JSI_OPTION_BOOL=1,\n    JSI_OPTION_INT8,  JSI_OPTION_INT16,  JSI_OPTION_INT32,  JSI_OPTION_INT64,\n    JSI_OPTION_UINT8, JSI_OPTION_UINT16, JSI_OPTION_UINT32, JSI_OPTION_UINT64,\n    JSI_OPTION_FLOAT,\n    JSI_OPTION_DOUBLE,    // Same as NUMBER when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_LDOUBLE,   // A long double\n    JSI_OPTION_STRBUF,    // Fixed size string buffer.\n    JSI_OPTION_TIME_W,    // Jsi_Wide: milliseconds since Jan 1, 1970.\n    JSI_OPTION_TIME_D,    // double: milliseconds since Jan 1, 1970.\n    // Non-portable fields start here\n    JSI_OPTION_TIME_T,    // time_t: seconds since Jan 1, 1970. \n    JSI_OPTION_SIZE_T,\n    JSI_OPTION_SSIZE_T,\n    JSI_OPTION_INTPTR_T,  // Int big enough to store a pointer.\n    JSI_OPTION_UINTPTR_T, \n    JSI_OPTION_NUMBER,    // Same as DOUBLE when !JSI_USE_LONG_DOUBLE.\n    JSI_OPTION_INT, JSI_OPTION_UINT,\n    JSI_OPTION_LONG, JSI_OPTION_ULONG, JSI_OPTION_SHORT, JSI_OPTION_USHORT,\n    JSI_OPTION_STRING, JSI_OPTION_DSTRING, JSI_OPTION_STRKEY,\n    JSI_OPTION_VALUE, JSI_OPTION_VAR, JSI_OPTION_OBJ, JSI_OPTION_ARRAY, JSI_OPTION_REGEXP,\n    JSI_OPTION_FUNC,      // Note: .data can contain string args to check\n    JSI_OPTION_USEROBJ,   // Note: .data can contain string obj name to check\n    JSI_OPTION_CUSTOM,    // Note: set .custom, .data, etc.\n    JSI_OPTION_END\n} Jsi_OptionId;\n\ntypedef const char* Jsi_Strkey;\n#ifdef __cplusplus\ntypedef void* Jsi_Strbuf;\n#else\ntypedef char Jsi_Strbuf[];\n#endif\n\ntypedef union {\n    bool           BOOL;\n    int8_t         INT8;\n    int16_t        INT16;\n    int32_t        INT32;\n    int64_t        INT64;\n    uint8_t        UINT8;\n    uint16_t       UINT16;\n    uint32_t       UINT32;\n    uint64_t       UINT64;\n    float          FLOAT;\n    double         DOUBLE;\n    ldouble        LDOUBLE;\n    Jsi_Number     NUMBER;\n    char*          STRBUF;\n    time_d         TIME_D;\n    time_w         TIME_W;\n    time_t         TIME_T;\n    size_t         SIZE_T;\n    ssize_t        SSIZE_T;\n    intptr_t       INTPTR_T;\n    uintptr_t      UINTPTR_T;\n    int            INT;\n    uint           UINT;\n    long           LONG;\n    ulong          ULONG;\n    short          SHORT;\n    ushort         USHORT;\n    Jsi_DString    DSTRING;\n    const char*    STRKEY;\n    Jsi_Value*     STRING;\n    Jsi_Value*     VALUE;\n    Jsi_Value*     VAR;\n    Jsi_Value*     OBJ;\n    Jsi_Value*     ARRAY;\n    Jsi_Value*     REGEXP;\n    Jsi_Value*     FUNC;\n    Jsi_Value*     USEROBJ;\n    void*          CUSTOM;\n    Jsi_csgset*    OPT_BITS;\n    struct Jsi_OptionSpec* OPT_CARRAY;\n} Jsi_OptionValue;\n\ntypedef union { /* Field used at compile-time by JSI_OPT() to provide type checking for the var */\n    bool           *BOOL;\n    int8_t         *INT8;\n    int16_t        *INT16;\n    int32_t        *INT32;\n    int64_t        *INT64;\n    uint8_t        *UINT8;\n    uint16_t       *UINT16;\n    uint32_t       *UINT32;\n    uint64_t       *UINT64;\n    float          *FLOAT;\n    double         *DOUBLE;\n    ldouble        *LDOUBLE;\n    Jsi_Number     *NUMBER;\n#ifdef __cplusplus\n    Jsi_Strbuf      STRBUF;\n#else\n    Jsi_Strbuf      *STRBUF;\n#endif\n    time_t         *TIME_T;\n    time_w         *TIME_W;\n    time_d         *TIME_D;\n    size_t         *SIZE_T;\n    ssize_t        *SSIZE_T;\n    intptr_t       *INTPTR_T;\n    uintptr_t      *UINTPTR_T;\n    int            *INT;\n    uint           *UINT;\n    long           *LONG;\n    ulong          *ULONG;\n    short          *SHORT;\n    ushort         *USHORT;\n    Jsi_DString    *DSTRING;\n    const char*    *STRKEY;\n    Jsi_Value*     *VALUE;\n    Jsi_Value*     *STRING;\n    Jsi_Value*     *VAR;\n    Jsi_Value*     *OBJ;\n    Jsi_Value*     *ARRAY;\n    Jsi_Value*     *REGEXP;\n    Jsi_Value*     *FUNC;\n    Jsi_Value*     *USEROBJ;\n    void           *CUSTOM;\n    Jsi_csgset     *OPT_BITS;\n    struct Jsi_OptionSpec *OPT_CARRAY;\n} Jsi_OptionInitVal;\n\ntypedef struct {\n    Jsi_Sig sig;\n    Jsi_OptionId id;\n    const char *idName, *cName;\n    int size;\n    const char *fmt, *xfmt, *sfmt, *help;\n    Jsi_OptionInitVal init;\n    Jsi_Wide flags;\n    Jsi_Wide user;\n    const char *userData;       /* User data. */ \\\n    uchar *extData;             /* Extension data. */\n    uchar *extra;\n    Jsi_HashEntry *hPtr;\n} Jsi_OptionTypedef;\n\nstruct Jsi_OptionSpec {\n    Jsi_Sig sig;                /* Signature field. */\n    Jsi_OptionId id;\n    const char *name;           /* The field name. */\n    uint offset;                /* Jsi_Offset of field. */\n    uint size;                  /* The sizeof() of field. */\n    Jsi_OptionInitVal init;     /* Initialization value */\n    const char *help;           /* A short one-line help string, without newlines. */\n    Jsi_Wide flags;             /* Lower 32 bits: the JSI_OPTS_* flags below. Upper 32 for custom/other. */\n    Jsi_OptionCustom *custom;   /* Custom handler. */\n    void *data;                 /* User data for custom options: eg. the bit for BOOLBIT. */\n    const char *info;           /* Longer command description. Use JSI_DETAIL macro to allow compile-out.*/\n    const char *tname;          /* Type name for field or external name used by the DB interface. */\n    Jsi_Wide value;             /* Value field. */\n    uint32_t bits;              /* Size of bitfield */\n    uint32_t boffset;           /* Bit offset of field (or struct) */\n    uint32_t idx;               /* Index (of field) */\n    uint32_t ssig;              /* Signature (for struct) */\n    uint32_t crc;               /* Crc (for struct) */\n    uint32_t arrSize;           /* Size of array */\n    const char *userData;       /* User data. */\n    uchar *extData;             /* Extension data. */\n    uchar *extra;               /* Extra pointer (currently unused). */\n    const Jsi_OptionTypedef *type;\n};\n\n/* JSI_OPT is a macro used for option definitions, eg:\n * \n *      typedef struct { int debug; int bool; } MyStruct;\n * \n *      Jsi_OptionSpec MyOptions[] = {\n *          JSI_OPT(BOOL,  MyStruct,  debug ),\n *          JSI_OPT(INT,   MyStruct,  max,   .help=\"Max value\"),\n *          JSI_OPT_END(   MyStruct, .help=\"My first struct\" )\n *      }\n*/\n\n#define JSI_OPT_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam)}, ##__VA_ARGS__ }\n\n#define JSI_OPT_END_(s, strct, ...) { .sig=s, .id=JSI_OPTION_END, .name=#strct, .offset=__LINE__, .size=sizeof(strct), \\\n      .init={.CUSTOM=(void*)__FILE__}, ##__VA_ARGS__}\n\n#define JSI_OPT_BITS_(s, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=0, .size=0, \\\n        .init={.OPT_BITS=&bsget}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchBitfield, .data=bdata,\\\n        .info=0, .tname=#nam, .value=0, .bits=0, .boffset=0, .idx=fidx }\n\n#define JSI_OPT_CARRAY_(s, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) \\\n    { .sig=s, .id=JSI_OPTION_CUSTOM, .name=#nam, .offset=Jsi_Offset(strct, nam), .size=sizeof(((strct *) 0)->nam), \\\n        .init={.OPT_CARRAY=aropt}, .help=hlp, .flags=flgs, .custom=Jsi_Opt_SwitchCArray, .data=0,\\\n        .info=0, .tname=tnam, .value=0, .bits=0, .boffset=0, .idx=0, .ssig=0, .crc=0, .arrSize=asiz, .extData=sinit, .extra=0 }\n\n#define JSI_OPT_CARRAY_ITEM_(s, typ, strct, nam, ...) \\\n    { .sig=s, .id=JSI_OPTION_##typ, .name=#nam, .offset=0, .size=sizeof(((strct *) 0)->nam), \\\n      .init={.typ=(&((strct *) 0)->nam[0])}, ##__VA_ARGS__ }\n\n#define JSI_OPT(typ, strct, nam, ...) JSI_OPT_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__) \n#define JSI_OPT_END(strct, ...) JSI_OPT_END_(JSI_SIG_OPTS, strct, ##__VA_ARGS__)\n#define JSI_OPT_BITS(strct, nam, hlp, flgs, bsget, fidx, tnam, bdata) JSI_OPT_BITS_(JSI_SIG_OPTS, strct, nam, hlp, flgs, bsget, fidx, tnam, bdata)\n#define JSI_OPT_CARRAY(strct, nam, hlp, flgs, aropt, asiz, tnam, sinit) JSI_OPT_CARRAY_(JSI_SIG_OPTS, strct, nam, hlp, flgs, aropt, asiz, tnam, sinit)\n#define JSI_OPT_CARRAY_ITEM(typ, strct, nam, ...) JSI_OPT_CARRAY_ITEM_(JSI_SIG_OPTS, typ, strct, nam, ##__VA_ARGS__)\n\n#define JSI_OPT_END_IDX(opt) ((sizeof(opt)/sizeof(opt[0]))-1)\n\n/* builtin handler for Custom. */\n#define Jsi_Opt_SwitchEnum          (Jsi_OptionCustom*)0x1 /* An Enum: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchBitset        (Jsi_OptionCustom*)0x2 /* Bits in an int: choices are in .data=stringlist */\n#define Jsi_Opt_SwitchSuboption     (Jsi_OptionCustom*)0x3 /* Sub-structs: subspec is in .data={...} */\n#define Jsi_Opt_SwitchBitfield      (Jsi_OptionCustom*)0x4 /* Struct bitfields: used by \"jsish -c\" */\n#define Jsi_Opt_SwitchValueVerify   (Jsi_OptionCustom*)0x5 /* Callback to verify Jsi_Value* correctness in .data=func. */\n#define Jsi_Opt_SwitchCArray        (Jsi_OptionCustom*)0x6 /* C Array described in .data=type. */\n#define Jsi_Opt_SwitchNull          (Jsi_OptionCustom*)0x7 /* Set is ignored, and get returns null */\n#define Jsi_Opt_SwitchParentFunc    (Jsi_OptionCustom*)0x8 /* Name of a func in parent. Sig string is in .data*/\n\nenum {\n    /* Jsi_OptionsProcess() flags */\n    JSI_OPTS_PREFIX         =   (1<<27), /* Allow matching unique prefix of object members. */\n    JSI_OPTS_IS_UPDATE      =   (1<<28), /* This is an update/conf (do not reset the specified flags) */\n    JSI_OPTS_IGNORE_EXTRA   =   (1<<29), /* Ignore extra members not found in spec. */\n    JSI_OPTS_FORCE_STRICT   =   (1<<30), /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */\n    JSI_OPTS_VERBOSE        =   (1<<31), /* Dump verbose options */\n    JSI_OPTS_INCR           =   (1<<7),  /* Options is an increment. */\n\n    /* Jsi_OptionSpec flags. */\n    JSI_OPT_IS_SPECIFIED    =   (1<<0),   /* User set the option. */\n    JSI_OPT_INIT_ONLY       =   (1<<1),   /* Allow set only at init, disallowing update/conf. */\n    JSI_OPT_READ_ONLY       =   (1<<2),   /* Value can not be set. */\n    JSI_OPT_NO_DUPVALUE     =   (1<<3),   /* Values are not to be duped. */\n    JSI_OPT_NO_CLEAR        =   (1<<4),   /* Values are not to be cleared: watch for memory leaks */\n    JSI_OPT_REQUIRED        =   (1<<5),  /* Field must be specified (if not IS_UPDATE). */\n    JSI_OPT_PASS2           =   (1<<6),   /* Options to be processed only on pass2. */\n    JSI_OPT_DB_DIRTY        =   (1<<8),   /* Used to limit DB updates. */\n    JSI_OPT_DB_IGNORE       =   (1<<9),   /* Field is not to be used for DB. */\n    JSI_OPT_DB_ROWID        =   (1<<10),  /* Field used by DB to store rowid. */\n    JSI_OPT_CUST_NOCASE     =   (1<<11),  /* Ignore case (eg. for ENUM and BITSET). */\n    JSI_OPT_FORCE_INT       =   (1<<12),  /* Force int instead of text for enum/bitset. */\n    JSI_OPT_BITSET_ENUM     =   (1<<13),  /* Mark field as a bitset/enum map custom field. */\n    JSI_OPT_TIME_DATEONLY   =   (1<<14),  /* Time field is date only. */\n    JSI_OPT_TIME_TIMEONLY   =   (1<<15),  /* Time field is time only. */\n    JSI_OPT_IS_BITS         =   (1<<16),  /* Is a C bit-field. */\n    JSI_OPT_FMT_STRING      =   (1<<17),  /* Format value (eg. time) as string. */\n    JSI_OPT_FMT_NUMBER      =   (1<<18),  /* Format value (eg. enum) as number. */\n    JSI_OPT_FMT_HEX         =   (1<<19),  /* Format number in hex. */\n    JSI_OPT_STRICT          =   (1<<20),  /* Strict mode. */\n    JSI_OPT_LOCKSAFE        =   (1<<21),  /* Field may not be configured when isSafe. */\n    JSI_OPT_COERCE          =   (1<<22),  /* Coerce input value to required type. */\n    JSI_OPT_NO_SIG          =   (1<<23),  /* No signature. */\n    JSI_OPT_ENUM_SPEC       =   (1<<24),  /* Enum has spec rather than a list of strings. */\n    JSI_OPT_ENUM_UNSIGNED   =   (1<<25),  /* Enum value is unsigned. */\n    JSI_OPT_ENUM_EXACT      =   (1<<26),  /* Enum must be an exact match. */\n    JSI_OPTIONS_USER_FIRSTBIT  =   48,    /* First bit of user flags: the lower 48 bits are internal. */\n};\n\nJSI_EXTERN const Jsi_OptionTypedef* Jsi_OptionTypeInfo(Jsi_OptionId typ); /*STUB = 326*/\nJSI_EXTERN Jsi_OptionTypedef* Jsi_TypeLookup(Jsi_Interp* interp, const char *typ); /*STUB = 327*/\nJSI_EXTERN int Jsi_OptionsProcess(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Wide flags); /*STUB = 328*/\nJSI_EXTERN int Jsi_OptionsProcessJSON(Jsi_Interp *interp, Jsi_OptionSpec *opts, void *data, const char *json, Jsi_Wide flags); /*STUB = 329*/\nJSI_EXTERN Jsi_RC Jsi_OptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value *value, Jsi_Value **ret, Jsi_Wide flags); /*STUB = 330*/\nJSI_EXTERN void Jsi_OptionsFree(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Wide flags); /*STUB = 331*/\nJSI_EXTERN Jsi_RC Jsi_OptionsGet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, const char *option, Jsi_Value** valuePtr, Jsi_Wide flags); /*STUB = 332*/\nJSI_EXTERN Jsi_RC Jsi_OptionsSet(Jsi_Interp *interp, Jsi_OptionSpec *specs, void* data, const char *option, Jsi_Value *valuePtr, Jsi_Wide flags); /*STUB = 333*/\nJSI_EXTERN Jsi_RC Jsi_OptionsDump(Jsi_Interp *interp, Jsi_OptionSpec *specs, void *data, Jsi_Value** ret, Jsi_Wide flags); /*STUB = 334*/\nJSI_EXTERN int Jsi_OptionsChanged(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *pattern, ...) /*STUB = 335*/ __attribute__((sentinel));\nJSI_EXTERN bool Jsi_OptionsValid(Jsi_Interp *interp, Jsi_OptionSpec* spec);  /*STUB = 336*/\nJSI_EXTERN const char* Jsi_OptionsData(Jsi_Interp *interp, Jsi_OptionSpec *specs, Jsi_DString *dStr, bool schema);\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsFind(Jsi_Interp *interp, Jsi_OptionSpec *specs, const char *name, Jsi_Wide flags); /*STUB = 337*/\nJSI_EXTERN Jsi_Value* Jsi_OptionsCustomPrint(void* clientData, Jsi_Interp *interp, const char *optionName, void *data, int offset); /*STUB = 338*/\nJSI_EXTERN Jsi_OptionCustom* Jsi_OptionCustomBuiltin(Jsi_OptionCustom* cust); /*STUB = 339*/\n/* Create a duplicate of static specs.   Use this for threaded access to Jsi_OptionsChanged(). */\nJSI_EXTERN Jsi_OptionSpec* Jsi_OptionsDup(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs); /*STUB = 340*/\nJSI_EXTERN const Jsi_OptionSpec* Jsi_OptionSpecsCached(Jsi_Interp *interp, const Jsi_OptionSpec *staticSpecs);  /*STUB = 341*/\n/* -- */\n\n\n/* --THREADS/MUTEX-- */\nJSI_EXTERN Jsi_RC Jsi_MutexLock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 342*/\nJSI_EXTERN void Jsi_MutexUnlock(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 343*/\nJSI_EXTERN void Jsi_MutexDelete(Jsi_Interp *interp, Jsi_Mutex *mtx); /*STUB = 344*/\nJSI_EXTERN Jsi_Mutex* Jsi_MutexNew(Jsi_Interp *interp, int timeout, int flags); /*STUB = 345*/\nJSI_EXTERN void* Jsi_CurrentThread(void); /*STUB = 346*/\nJSI_EXTERN void* Jsi_InterpThread(Jsi_Interp *interp); /*STUB = 347*/\n/* -- */\n\n\n/* --LOGGING-- */\n#define Jsi_LogBug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_BUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogError(fmt,...) Jsi_LogMsg(interp, JSI_LOG_ERROR, fmt, ##__VA_ARGS__)\n#define Jsi_LogParse(fmt,...) Jsi_LogMsg(interp, JSI_LOG_PARSE, fmt, ##__VA_ARGS__)\n#define Jsi_LogWarn(fmt,...) Jsi_LogMsg(interp, JSI_LOG_WARN, fmt, ##__VA_ARGS__)\n#define Jsi_LogInfo(fmt,...) Jsi_LogMsg(interp, JSI_LOG_INFO, fmt, ##__VA_ARGS__)\n#define Jsi_LogDebug(fmt,...) Jsi_LogMsg(interp, JSI_LOG_DEBUG, fmt, ##__VA_ARGS__)\n#define Jsi_LogTrace(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TRACE, fmt, ##__VA_ARGS__)\n#define Jsi_LogTest(fmt,...) Jsi_LogMsg(interp, JSI_LOG_TEST, fmt, ##__VA_ARGS__)\n\nJSI_EXTERN Jsi_RC Jsi_LogMsg(Jsi_Interp *interp, uint level, const char *format,...)  /*STUB = 348*/ __attribute__((format (printf,3,4)));\n\n\n/* --EVENTS-- */\ntypedef struct {\n    Jsi_Sig sig;\n    uint id;\n    int evType;                 /* Is signal handler. */\n    int sigNum;\n    int once;                   /* Execute once */\n    long initialms;             /* initial relative timer value */\n    long when_sec;              /* seconds */\n    long when_ms;               /* milliseconds */\n    bool busy;                  /* In event callback. */\n    uint count;                 /* Times executed */\n    Jsi_HashEntry *hPtr;\n    Jsi_Value *funcVal;         /* JS Function to call. */\n    Jsi_EventHandlerProc *handler;  /* C-function handler. */\n    void *data;\n} Jsi_Event;\n\nJSI_EXTERN Jsi_Event* Jsi_EventNew(Jsi_Interp *interp, Jsi_EventHandlerProc *callback, void* data); /*STUB = 349*/\nJSI_EXTERN void Jsi_EventFree(Jsi_Interp *interp, Jsi_Event* event); /*STUB = 350*/\nJSI_EXTERN int Jsi_EventProcess(Jsi_Interp *interp, int maxEvents); /*STUB = 351*/\n/* -- */\n\n\n/* --JSON-- */\n#define JSI_JSON_DECLARE(p, tokens, maxsz) \\\n    Jsi_JsonParser p = {0}; \\\n    Jsi_JsonTok tokens[maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT]; \\\n    Jsi_JsonInit(&p, tokens, maxsz>0?maxsz:JSI_JSON_STATIC_DEFAULT)\n\ntypedef enum {\n    JSI_JTYPE_PRIMITIVE = 0,\n    JSI_JTYPE_OBJECT = 1,\n    JSI_JTYPE_ARRAY = 2,\n    JSI_JTYPE_STRING = 3,\n    JSI_JTYPE_INVALID=-1\n} Jsi_JsonTypeEnum;\n\ntypedef enum {\n    JSI_JSON_ERR_NOMEM = -1,\n    JSI_JSON_ERR_INVAL = -2,\n    JSI_JSON_ERR_PART = -3,\n    JSI_JSON_ERR_NONE = 0\n} Jsi_JsonErrEnum;\n\ntypedef struct {\n    Jsi_JsonTypeEnum type;\n    int start;\n    int end;\n    uint size;\n    int parent;\n} Jsi_JsonTok;\n\ntypedef struct {\n    uint pos;           /* offset in the JSON string */\n    uint toknext;       /* next token to allocate */\n    int toksuper;       /* superior token node, e.g parent object or array */\n    Jsi_JsonTok *tokens, *static_tokens;\n    uint num_tokens;\n    int no_malloc;      /* Disable parser dynamic growth tokens array. */\n    bool strict;/* Strict parsing. */\n    Jsi_Wide flags;\n    const char *errStr;\n    void *reserved[4];     /* Reserved for future */\n} Jsi_JsonParser;\n\n\nJSI_EXTERN void Jsi_JsonInit(Jsi_JsonParser *parser, Jsi_JsonTok *static_tokens, uint num_tokens); /*STUB = 352*/\nJSI_EXTERN void Jsi_JsonReset(Jsi_JsonParser *parser); /*STUB = 353*/\nJSI_EXTERN void Jsi_JsonFree(Jsi_JsonParser *parser); /*STUB = 354*/\nJSI_EXTERN Jsi_JsonErrEnum Jsi_JsonParse(Jsi_JsonParser *parser, const char *js); /*STUB = 355*/\nJSI_EXTERN Jsi_JsonTok* Jsi_JsonGetToken(Jsi_JsonParser *parser, uint index); /*STUB = 356*/\nJSI_EXTERN Jsi_JsonTypeEnum Jsi_JsonGetType(Jsi_JsonParser *parser, uint index); /*STUB = 357*/\nJSI_EXTERN int Jsi_JsonTokLen(Jsi_JsonParser *parser, uint index); /*STUB = 358*/\nJSI_EXTERN const char* Jsi_JsonGetTokstr(Jsi_JsonParser *parser, const char *js, uint index, uint *len); /*STUB = 359*/\nJSI_EXTERN const char* Jsi_JsonGetTypename(int type); /*STUB = 360*/\nJSI_EXTERN const char* Jsi_JsonGetErrname(int code); /*STUB = 361*/\nJSI_EXTERN void Jsi_JsonDump(Jsi_JsonParser *parser, const char *js); /*STUB = 362*/\n/* -- */\n\n\n/* --VFS-- */\nstruct Jsi_LoadHandle; struct Jsi_LoadHandle;\n\ntypedef struct Jsi_LoadHandle Jsi_LoadHandle;\ntypedef struct stat Jsi_StatBuf;\ntypedef struct dirent Jsi_Dirent;\n\ntypedef int (Jsi_FSStatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSAccessProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef int (Jsi_FSChmodProc) (Jsi_Interp *interp, Jsi_Value* path, int mode);\ntypedef Jsi_Channel (Jsi_FSOpenProc) (Jsi_Interp *interp, Jsi_Value* path, const char* modes);\ntypedef int (Jsi_FSLstatProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf);\ntypedef int (Jsi_FSCreateDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path);\ntypedef int (Jsi_FSRemoveProc) (Jsi_Interp *interp, Jsi_Value* path, int flags);\ntypedef int (Jsi_FSCopyDirectoryProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSCopyFileProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef int (Jsi_FSRemoveDirectoryProc) (Jsi_Interp *interp, Jsi_Value* path, int recursive, Jsi_Value **errorPtr);\ntypedef int (Jsi_FSRenameProc) (Jsi_Interp *interp, Jsi_Value *srcPathPtr, Jsi_Value *destPathPtr);\ntypedef Jsi_Value * (Jsi_FSListVolumesProc) (Jsi_Interp *interp);\ntypedef char* (Jsi_FSRealPathProc) (Jsi_Interp *interp, Jsi_Value* path, char *newPath);\ntypedef int (Jsi_FSLinkProc) (Jsi_Interp *interp, Jsi_Value* path, Jsi_Value *toPath, int linkType);\ntypedef int (Jsi_FSReadlinkProc)(Jsi_Interp *interp, Jsi_Value *path, char *buf, int size);\ntypedef int (Jsi_FSReadProc)(Jsi_Channel chan, char *buf, int size);\ntypedef int (Jsi_FSGetcProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSEofProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSTruncateProc)(Jsi_Channel chan, uint len);\ntypedef int (Jsi_FSUngetcProc)(Jsi_Channel chan, int ch);\ntypedef char *(Jsi_FSGetsProc)(Jsi_Channel chan, char *s, int size);\ntypedef int (Jsi_FSPutsProc)(Jsi_Channel chan, const char* str);\ntypedef int (Jsi_FSWriteProc)(Jsi_Channel chan, const char *buf, int size);\ntypedef int (Jsi_FSFlushProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSSeekProc)(Jsi_Channel chan, Jsi_Wide offset, int mode);\ntypedef int (Jsi_FSTellProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSCloseProc)(Jsi_Channel chan);\ntypedef int (Jsi_FSRewindProc)(Jsi_Channel chan);\ntypedef bool (Jsi_FSPathInFilesystemProc) (Jsi_Interp *interp, Jsi_Value* path,void* *clientDataPtr);\ntypedef int (Jsi_FSScandirProc)(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist,\n  int (*filter)(const Jsi_Dirent *), int (*compar)(const Jsi_Dirent **, const Jsi_Dirent**));\n\ntypedef struct Jsi_Filesystem {\n    const char *typeName;\n    int structureLength;    \n    int version;\n    Jsi_FSPathInFilesystemProc *pathInFilesystemProc;\n    Jsi_FSRealPathProc *realpathProc;\n    Jsi_FSStatProc *statProc;\n    Jsi_FSLstatProc *lstatProc;\n    Jsi_FSAccessProc *accessProc;\n    Jsi_FSChmodProc *chmodProc;\n    Jsi_FSOpenProc *openProc;\n    Jsi_FSScandirProc *scandirProc;\n    Jsi_FSReadProc *readProc;\n    Jsi_FSWriteProc *writeProc;\n    Jsi_FSGetsProc *getsProc;\n    Jsi_FSGetcProc *getcProc;\n    Jsi_FSUngetcProc *ungetcProc;\n    Jsi_FSPutsProc *putsProc;\n    \n    Jsi_FSFlushProc *flushProc;\n    Jsi_FSSeekProc *seekProc;\n    Jsi_FSTellProc *tellProc;\n    Jsi_FSEofProc *eofProc;\n    Jsi_FSTruncateProc *truncateProc;\n    Jsi_FSRewindProc *rewindProc;\n    Jsi_FSCloseProc *closeProc;\n    Jsi_FSLinkProc *linkProc;\n    Jsi_FSReadlinkProc *readlinkProc;\n    Jsi_FSListVolumesProc *listVolumesProc;\n    Jsi_FSCreateDirectoryProc *createDirectoryProc;\n    Jsi_FSRemoveProc *removeProc;\n    Jsi_FSRenameProc *renameProc;\n    void *reserved[10];     /* Reserved for future */\n} Jsi_Filesystem;\n\ntypedef struct Jsi_Chan {\n    FILE *fp;\n    const char *fname;  /* May be set by fs or by source */\n    Jsi_Filesystem *fsPtr;\n    int isNative;\n    int flags;\n    char modes[JSI_FSMODESIZE];\n    void *data;\n    void *reserved[4];     /* Reserved for future */\n    ssize_t resInt[2];\n} Jsi_Chan;\n\nJSI_EXTERN Jsi_RC Jsi_FSRegister(Jsi_Filesystem *fsPtr, void *data); /*STUB = 363*/\nJSI_EXTERN Jsi_RC Jsi_FSUnregister(Jsi_Filesystem *fsPtr); /*STUB = 364*/\nJSI_EXTERN Jsi_Channel Jsi_FSNameToChannel(Jsi_Interp *interp, const char *name); /*STUB = 365*/\nJSI_EXTERN char* Jsi_GetCwd(Jsi_Interp *interp, Jsi_DString *cwdPtr); /*STUB = 366*/\nJSI_EXTERN int Jsi_Lstat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 367*/\nJSI_EXTERN int Jsi_Stat(Jsi_Interp *interp, Jsi_Value* path, Jsi_StatBuf *buf); /*STUB = 368*/\nJSI_EXTERN int Jsi_Access(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 369*/\nJSI_EXTERN int Jsi_Remove(Jsi_Interp *interp, Jsi_Value* path, int flags); /*STUB = 370*/\nJSI_EXTERN int Jsi_Rename(Jsi_Interp *interp, Jsi_Value *src, Jsi_Value *dst); /*STUB = 371*/\nJSI_EXTERN int Jsi_Chdir(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 372*/\nJSI_EXTERN Jsi_Channel Jsi_Open(Jsi_Interp *interp, Jsi_Value *file, const char *modeString); /*STUB = 373*/\nJSI_EXTERN int Jsi_Eof(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 374*/\nJSI_EXTERN int Jsi_Close(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 375*/\nJSI_EXTERN int Jsi_Read(Jsi_Interp *interp, Jsi_Channel chan, char *bufPtr, int toRead); /*STUB = 376*/\nJSI_EXTERN int Jsi_Write(Jsi_Interp *interp, Jsi_Channel chan, const char *bufPtr, int slen); /*STUB = 377*/\nJSI_EXTERN Jsi_Wide Jsi_Seek(Jsi_Interp *interp, Jsi_Channel chan, Jsi_Wide offset, int mode); /*STUB = 378*/\nJSI_EXTERN Jsi_Wide Jsi_Tell(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 379*/\nJSI_EXTERN int Jsi_Truncate(Jsi_Interp *interp, Jsi_Channel chan, uint len); /*STUB = 380*/\nJSI_EXTERN Jsi_Wide Jsi_Rewind(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 381*/\nJSI_EXTERN int Jsi_Flush(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 382*/\nJSI_EXTERN int Jsi_Getc(Jsi_Interp *interp, Jsi_Channel chan); /*STUB = 383*/\nJSI_EXTERN int Jsi_Printf(Jsi_Interp *interp, Jsi_Channel chan, const char *fmt, ...) /*STUB = 384*/ __attribute__((format (printf,3,4))); \nJSI_EXTERN int Jsi_Ungetc(Jsi_Interp *interp, Jsi_Channel chan, int ch); /*STUB = 385*/\nJSI_EXTERN char* Jsi_Gets(Jsi_Interp *interp, Jsi_Channel chan, char *s, int size); /*STUB = 386*/\nJSI_EXTERN int Jsi_Puts(Jsi_Interp *interp, Jsi_Channel chan, const char *str, int size); /*STUB = 387*/\n\ntypedef int (Jsi_ScandirFilter)(const Jsi_Dirent *);\ntypedef int (Jsi_ScandirCompare)(const Jsi_Dirent **, const Jsi_Dirent**);\nJSI_EXTERN int Jsi_Scandir(Jsi_Interp *interp, Jsi_Value *path, Jsi_Dirent ***namelist, Jsi_ScandirFilter *filter, Jsi_ScandirCompare *compare ); /*STUB = 388*/\nJSI_EXTERN int Jsi_SetChannelOption(Jsi_Interp *interp, Jsi_Channel chan, const char *optionName, const char *newValue); /*STUB = 389*/\nJSI_EXTERN char* Jsi_Realpath(Jsi_Interp *interp, Jsi_Value *path, char *newname); /*STUB = 390*/\nJSI_EXTERN int Jsi_Readlink(Jsi_Interp *interp, Jsi_Value* path, char *ret, int len); /*STUB = 391*/\nJSI_EXTERN Jsi_Channel Jsi_GetStdChannel(Jsi_Interp *interp, int id); /*STUB = 392*/\nJSI_EXTERN bool Jsi_FSNative(Jsi_Interp *interp, Jsi_Value* path); /*STUB = 393*/\nJSI_EXTERN int Jsi_Link(Jsi_Interp *interp, Jsi_Value* src, Jsi_Value *dest, int typ); /*STUB = 394*/\nJSI_EXTERN int Jsi_Chmod(Jsi_Interp *interp, Jsi_Value* path, int mode); /*STUB = 395*/\n\nJSI_EXTERN Jsi_RC Jsi_StubLookup(Jsi_Interp *interp, const char *name, void **ptr); /*STUB = 396*/\nJSI_EXTERN Jsi_RC Jsi_DllLookup(Jsi_Interp *interp, const char *module, const char *name, void **ptr); /*STUB = 404*/\nJSI_EXTERN Jsi_RC Jsi_LoadLibrary(Jsi_Interp *interp, const char *pathName, bool noInit); /*STUB = 405*/\nJSI_EXTERN int Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir);  /*STUB = 397*/\n\n/* -- */\n\n\n\n/* --DATABASE-- */\n\nJSI_EXTERN Jsi_Db* Jsi_DbNew(const char *zFile, int inFlags); /*STUB = 398*/\nJSI_EXTERN void* Jsi_DbHandle(Jsi_Interp *interp, Jsi_Db* db); /*STUB = 399*/\n\n/* -- */\n\n\n/* --CData-- */\n\n#define  JSI_CDATA_OPTION_CHANGED(name) \\\n        (vrPtr->spec && Jsi_OptionsChanged(interp, vrPtr->spec, #name, NULL))\n#define  JSI_CDATA_OPTION_RESET(name) \\\n        (cmdPtr->queryOpts.mode && !options->name && JSI_CDATA_OPTION_CHANGED(name))\n \ntypedef struct Jsi_CData_Static {\n    const char* name;\n    Jsi_StructSpec* structs;\n    Jsi_EnumSpec* enums;\n    Jsi_VarSpec *vars;\n    Jsi_OptionTypedef* types;\n    struct Jsi_CData_Static* nextPtr;\n} Jsi_CData_Static;\n\n/* Struct for Carray to bind Data/Option pairs to individual SQLite binding chars. */\ntypedef struct Jsi_CDataDb {\n#define JSI_DBDATA_FIELDS \\\n    Jsi_StructSpec *sf;     /* Struct fields for data. */ \\\n    void *data;             /* Data pointer for array/map */ \\\n    uint arrSize;           /* If an array, number of elements: 0 means 1. */ \\\n    char prefix;            /* Sqlite char bind prefix. One of: '@' '$' ':' '?' or 0 for any */ \\\n    Jsi_StructSpec* slKey;  /* Struct for key (for map using a struct key). */ \\\n    int (*callback)(Jsi_Interp *interp, struct Jsi_CDataDb* obPtr, void *data); /* C callback for select queries. */ \\\n    uint maxSize;           /* Limit size of array/map*/ \\\n    bool noAuto;            /* Do not auto-create map keys. */ \\\n    bool isPtrs;            /* \"data\" an array of pointers. */ \\\n    bool isPtr2;            /* \"data\" is pointer to pointers, which is updated. */ \\\n    bool isMap;             /* \"data\" is a map: use Jsi_MapConf() for details. */ \\\n    bool memClear;          /* Before query free and zero all data (eg. DStrings). */ \\\n    bool memFree;           /* Reset as per mem_clear, then free data items. Query may be empty. */ \\\n    bool dirtyOnly;         /* Sqlite dirty filter for UPDATE/INSERT/REPLACE. */ \\\n    bool noBegin;           /* Disable wrapping UPDATE in BEGIN/COMMIT. */ \\\n    bool noCache;           /* Disable Db caching statement. */ \\\n    bool noStatic;          /* Disable binding text with SQLITE_STATIC. */ \\\n    intptr_t reserved[4];   /* Internal use. */\nJSI_DBDATA_FIELDS\n} Jsi_CDataDb;\n\nJSI_EXTERN int Jsi_DbQuery(Jsi_Db *jdb, Jsi_CDataDb *cd, const char *query); /*STUB = 400*/\nJSI_EXTERN Jsi_CDataDb* Jsi_CDataLookup(Jsi_Interp *interp, const char *name); /*STUB = 401*/\nJSI_EXTERN Jsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics); /*STUB = 402*/\nJSI_EXTERN Jsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname); /*STUB = 403*/\nJSI_EXTERN Jsi_StructSpec* Jsi_CDataStruct(Jsi_Interp *interp, const char *name); /*STUB = 406*/\n/* -- */\n\n\n/* String */\ntypedef char STRING1[(1<<0)+1]; // Include a char for the null byte.\ntypedef char STRING2[(1<<1)+1];\ntypedef char STRING4[(1<<2)+1];\ntypedef char STRING8[(1<<3)+1];\ntypedef char STRING16[(1<<4)+1];\ntypedef char STRING32[(1<<5)+1];\ntypedef char STRING64[(1<<6)+1];\ntypedef char STRING128[(1<<7)+1];\ntypedef char STRING256[(1<<8)+1];\ntypedef char STRING512[(1<<9)+1];\ntypedef char STRING1024[(1<<10)+1];\ntypedef char STRING2048[(1<<11)+1];\ntypedef char STRING4096[(1<<12)+1];\ntypedef char STRING8192[(1<<13)+1];\ntypedef char STRING16384[(1<<14)+1];\ntypedef char STRING32768[(1<<15)+1];\ntypedef char STRING65536[(1<<16)+1];\n\n/* -- */\n\n\n#define JSI_STUBS_STRUCTSIZES (sizeof(Jsi_MapSearch)+sizeof(Jsi_TreeSearch) \\\n    +sizeof(Jsi_HashSearch)+sizeof(Jsi_Filesystem)+sizeof(Jsi_Chan)+sizeof(Jsi_Event) \\\n    +sizeof(Jsi_CDataDb)+sizeof(Jsi_Stack)+sizeof(Jsi_OptionSpec)+sizeof(Jsi_CmdSpec) \\\n    +sizeof(Jsi_UserObjReg)+sizeof(Jsi_String) + sizeof(Jsi_PkgOpts))\n\n#ifndef JSI_OMIT_STUBS\n#ifdef JSI_USE_STUBS\n#ifndef JSISTUBCALL\n#define JSISTUBCALL(ptr,func) ptr->func\n#endif\n#include \"jsiStubs.h\"\n#else\n#define JSI_EXTENSION_INI\n#define Jsi_StubsInit(i,f) JSI_OK\n#endif\n#endif\n\n\n/* Optional compile-out commands/options string information. */\n#ifdef JSI_OMIT_INFO\n#define JSI_INFO(n) NULL\n#endif\n#ifndef JSI_INFO\n#define JSI_INFO(n) n\n#endif\n\n#endif /* __JSI_H__ */\n\n\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#if JSI__MUSL==1 || defined(__FreeBSD__)\n#define NO_QSORT_R 1\n#endif\n\nstatic uint jsi_SizeOfArray(Jsi_Interp *interp, Jsi_Obj *obj) {\n    if (!obj || !obj->arr)\n        return 0;\n    return obj->arrCnt;\n}\n\nstatic Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    \n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);    \n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = jsi_SizeOfArray(interp, obj) - 1;\n\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    \n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC jsi_ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    const char *jstr = \"\";\n    int argc, curlen;\n    Jsi_DString dStr = {};\n\n    curlen = jsi_SizeOfArray(interp, _this->d.obj);\n    if (curlen == 0) {\n        goto bail;\n    }\n\n    if (Jsi_ValueGetLength(interp, args) >= 1) {\n        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);\n        if (sc != NULL)\n            jstr = Jsi_ValueToString(interp, sc, NULL);\n    }\n    \n    if (0 == (argc=jsi_SizeOfArray(interp, _this->d.obj))) {\n        goto bail;\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        const char *cp;\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);\n        if (!ov) {\n            /* TODO: are NULL args ok? */ \n            continue;\n            cp = \"\";\n        } else\n            cp = Jsi_ValueToString(interp, ov, NULL);\n        if (i && jstr[0])\n            Jsi_DSAppend(&dStr, jstr, NULL);\n        Jsi_DSAppend(&dStr, cp, NULL);\n    }\n    \n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;        \n}\n\n\nJsi_Value* Jsi_ValueArrayConcat(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2) {\n    Jsi_Value *va;\n    Jsi_Obj *obj;\n    if (arg1->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg1->d.obj)) {\n        return NULL;\n    }\n    if (arg2->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg2->d.obj)) {\n        return NULL;\n    }\n    int len1 = arg1->d.obj->arrCnt;\n    int len2 = arg2->d.obj->arrCnt;\n    Jsi_Obj *nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ObjArraySizer(interp, nobj, len1+len2);\n\n    int i, j = 0;\n    obj = arg1->d.obj;\n    for (i = 0; i<len1; i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[j] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);\n    }\n    obj = arg2->d.obj;\n    for (i = 0; i<len2; i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[j] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+j, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, len1+len2);\n    va = Jsi_ValueMakeArrayObject(interp, NULL, nobj);\n    return va;\n}\n\nJsi_RC Jsi_ValueArrayPush(Jsi_Interp *interp, Jsi_Value *arg1, Jsi_Value *arg2) {\n    Jsi_Obj *obj;\n    if (arg1->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, arg1->d.obj))\n        return JSI_ERROR;\n    if (!arg2)\n        return JSI_ERROR;\n    int len1 = arg1->d.obj->arrCnt;\n    obj = arg1->d.obj;\n    Jsi_ObjArraySizer(interp, obj, len1);\n    obj->arr[len1] = arg2;\n    Jsi_IncrRefCount(interp, arg2);\n    obj->arrCnt++;\n    return JSI_OK;\n}\n\n\nJsi_Value *Jsi_ValueArrayPop(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayPop, target is not object\");\n        return NULL;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (!o->isarrlist) {\n        Jsi_LogBug(\"Jsi_ValueArrayPop, target is not array\");\n        return NULL;\n    }\n    if (o->arrCnt<=0)\n        return NULL;\n    int idx = o->arrCnt-1;\n    if (!o->arr[idx])\n        return NULL;\n    Jsi_DecrRefCount(interp, o->arr[idx]);\n    Jsi_Value *ret = o->arr[idx];\n    o->arr[idx] = NULL;\n    o->arrCnt--;\n    return ret;\n}\n\n\nJsi_Value *Jsi_ValueArrayUnshift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayUnshift, target is not object\");\n        return NULL;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (!o->isarrlist) {\n        Jsi_LogBug(\"Jsi_ValueArrayUnshift, target is not array\");\n        return NULL;\n    }\n    if (o->arrCnt<=0)\n        return NULL;\n    if (!o->arr[0])\n        return NULL;\n    Jsi_DecrRefCount(interp, o->arr[0]);\n    Jsi_Value *ret = o->arr[0];\n    o->arr[0] = NULL;\n    o->arrCnt--;\n    return ret;\n}\n\n/* delete array[0], array[1]->array[0] */\nvoid Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    \n    int len = jsi_SizeOfArray(interp, v->d.obj);\n    if (len <= 0) return;\n    \n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    \n    Jsi_ValueReset(interp, &v0);\n    \n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}\n\nstatic Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayFlatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Number ndepth = 1;\n    Jsi_Obj *nobj;\n    Jsi_Value *depth = Jsi_ValueArrayIndex(interp, args, 0);\n    if (depth && Jsi_GetNumberFromValue(interp,depth, &ndepth) != JSI_OK)\n        return JSI_ERROR;\n    \n    if (ndepth < 0 || ndepth>1000)\n        return Jsi_LogError(\"bad depth: %d\", (int)ndepth);\n\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj );\n    if (ndepth>0)\n        return jsi_ArrayFlatSub(interp, nobj, _this, ndepth);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, argc, nsiz;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = jsi_SizeOfArray(interp, obj);\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"index too large: %d\", nsiz+1);\n        goto bail;\n    }\n\n    int i, j, m;\n    for (i = 0; i<curlen; i++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[i] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]);\n    }\n    m = i;\n    for (i = 0; i < argc; i++) {\n         va = Jsi_ValueArrayIndex(interp, args, i);\n         if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) {\n            int margc = Jsi_ValueGetLength(interp, va);\n            Jsi_Obj *mobj = va->d.obj;\n            Jsi_ObjListifyArray(interp, mobj);\n            if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            for (j = 0; j<margc; j++, m++)\n            {\n                if (!mobj->arr[j]) continue;\n                nobj->arr[m] = NULL;\n                Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]);\n            }\n        } else {\n            if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) {\n                rc = JSI_ERROR;\n                Jsi_LogError(\"index too large: %d\", curlen);\n                goto bail;\n            }\n            nobj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, nobj->arr+m++, va);\n       }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayMapCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, nsiz, i, maa = 0;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis;\n    Jsi_Func *fptr = NULL;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = jsi_SizeOfArray(interp, obj);    \n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrCnt;\n    if (nsiz<=0) nsiz = 1;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        Jsi_LogError(\"index too large: %d\", nsiz);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_Value *vobjs[3];\n\n    fptr = func->d.obj->d.fobj->func;\n    maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < curlen; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        nobj->arr[i] = Jsi_ValueNew1(interp);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, nobj->arr+i, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if( JSI_OK!=rc ) {\n            goto bail;\n        }\n    }\n    Jsi_ObjSetLength(interp, nobj, curlen);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return JSI_OK;\n        \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, nsiz, i, fval, n = 0, maa = 0;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *func, *vpargs, *nthis = NULL, *sthis, *nrPtr = NULL;\n    Jsi_Func *fptr = NULL;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = jsi_SizeOfArray(interp, obj);    \n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrCnt;\n    if (nsiz<=0) nsiz = 1;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        Jsi_LogError(\"index too large: %d\", nsiz);\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[4];\n\n    fptr = func->d.obj->d.fobj->func;\n    maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < curlen; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if( JSI_OK!=rc ) {\n            goto bail;\n        }\n        if (fval) {\n            nobj->arr[n++] = obj->arr[i];\n            Jsi_IncrRefCount(interp, obj->arr[i]);\n        }\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_ObjSetLength(interp, nobj, n);\n    return JSI_OK;\n        \nbail:\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    if (nrPtr)\n        Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayReverseCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    int i, n, m;\n    Jsi_Obj *obj;\n    Jsi_Value *tval, *nthis = NULL, *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    m = obj->arrCnt/2;\n    for (i = 0, n=obj->arrCnt-1; i < m; i++, n--) {\n        tval = obj->arr[i];\n        obj->arr[i] = obj->arr[n];\n        obj->arr[n] = tval;\n    }\n    Jsi_ValueDup2(interp, ret, _this);\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) \n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj;\n    uint i;\n    Jsi_Value *func, *vpargs;\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_RC rc = JSI_OK;\n    \n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}\n\nstatic Jsi_RC jsi_ArrayFindSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_Obj *obj;\n    uint i;\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *func, *vpargs, *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    int fval = 0;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        fval = Jsi_ValueIsTrue(interp, nrPtr);\n        Jsi_ValueMakeUndef(interp, &nrPtr);\n        if (op == 3) {\n            if (!fval) break;\n        } else if (fval)\n            break;\n    }\n    if (rc == JSI_OK) {\n        if (op == 1 && fval) // Find\n            Jsi_ValueCopy(interp, *ret, obj->arr[i]); \n        else if (op == 2 || op == 3) // Some/Every\n            Jsi_ValueMakeBool(interp, ret, fval);\n        else if (op == 4)\n            Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)(fval?(int)i:-1));\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}\n\nstatic Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n            \n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n\n}\n\nstatic Jsi_RC jsi_ArrayFindCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC jsi_ArraySomeCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC jsi_ArrayEveryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 3);\n}\nstatic Jsi_RC jsi_ArrayFindIndexCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayFindSubCmd(interp, args, _this, ret, funcPtr, 4);\n}\nstatic Jsi_RC jsi_ArrayReduceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayReduceSubCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC jsi_ArrayReduceRightCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayReduceSubCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC jsi_ArrayIsArrayCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    bool b = 0;\n    Jsi_Value *sthis = _this;\n    if (_this->vt == JSI_VT_OBJECT && _this->d.obj->ot == JSI_OT_FUNCTION &&\n       _this->d.obj->__proto__ == interp->Array_prototype->d.obj->__proto__ )\n        sthis = Jsi_ValueArrayIndex(interp, args, 0); \n    if (sthis && sthis->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, sthis->d.obj))\n        b = 1;\n    Jsi_ValueMakeBool(interp, ret, b);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = jsi_SizeOfArray(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayIndexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayIndexSubCmd(interp, args, _this, ret, funcPtr, 1);\n}\nstatic Jsi_RC jsi_ArrayLastindexOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayIndexSubCmd(interp, args, _this, ret, funcPtr, 2);\n}\nstatic Jsi_RC jsi_ArrayIncludesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return jsi_ArrayIndexSubCmd(interp, args, _this, ret, funcPtr, 3);\n}\n\nstatic Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = jsi_SizeOfArray(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = jsi_SizeOfArray(interp, obj);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; // TODO: merge with code in ArraySliceCmd.\n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = jsi_SizeOfArray(interp, obj);\n\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n      \n    if (n == 0) {\n        goto bail;\n    }\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto bail;\n\n    int i;\n    for (i = istart; i <= iend; i++)\n    {\n        if (obj->arr[i])\n            Jsi_ValueCopy(interp, obj->arr[i], value);\n        else\n            obj->arr[i] = Jsi_ValueDup(interp, value);\n    }\nbail:\n    if (_this != *ret) {\n        Jsi_ValueMove(interp, *ret, _this);\n        /*if (*ret)\n            Jsi_DecrRefCount(interp, *ret);\n        *ret = _this;\n        Jsi_IncrRefCount(interp, *ret);*/\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = jsi_SizeOfArray(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n      \n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\n    \nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}\n\ntypedef struct {\n    Jsi_Interp *interp;\n    int flags;\n    int mode;\n    bool unique;\n    Jsi_Value *compare;\n    int errCnt;\n} SortInfo;\n\nstatic const char *sortArrayStrs[] = {\"default\", \"desc\", \"dict\", \"nocase\", 0};\n\nstatic Jsi_OptionSpec jsi_ArraySortOptions[] = {\n    JSI_OPT(CUSTOM, SortInfo, mode,     .help=\"Mode to sort by\", .flags=0, .custom=Jsi_Opt_SwitchEnum,  .data=sortArrayStrs),\n    JSI_OPT(FUNC,   SortInfo, compare,  .help=\"Function to do comparison\", .flags=0, .custom=0, .data=(void*)\"val1,val2\"),\n    JSI_OPT(BOOL,   SortInfo, unique,   .help=\"Eliminate duplicate items\"),\n    JSI_OPT_END(SortInfo)\n};\n\n#ifdef NO_QSORT_R\n\nSortInfo *curSortInfo = NULL;\n\nstatic int SortSubCmd(const void *p1, const void *p2) {\n    SortInfo *si = curSortInfo;\n#else\n#ifdef __WIN32\nstatic int SortSubCmd(void *thunk, const void *p1, const void *p2)\n#else\nstatic int SortSubCmd(const void *p1, const void *p2, void *thunk)\n#endif\n{\n    SortInfo *si = (SortInfo *)thunk;\n#endif\n    Jsi_Interp *interp = si->interp;\n    int sortFlags = si->flags;\n\n    if (interp == NULL || interp->deleting)\n        return 0;\n    Jsi_Value *v1 = *(Jsi_Value**)p1, *v2 = *(Jsi_Value**)p2;\n    int rc = 0;\n    if (v1 != NULL && v2 != NULL) {\n        VALCHK(v1);\n        VALCHK(v2);\n        if (!si->compare)\n            rc = Jsi_ValueCmp(interp, v1, v2, sortFlags);\n        else {\n            Jsi_Value *vv[2] = {v1, v2};\n            Jsi_Value *retP = Jsi_ValueNew1(interp);\n            Jsi_Value *vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vv, 2, 0));\n            Jsi_IncrRefCount(interp, vpargs);\n            rc = Jsi_FunctionInvoke(interp, si->compare, vpargs, &retP, NULL);\n            Jsi_DecrRefCount(interp, vpargs);\n            if (rc == JSI_OK) {\n                Jsi_Number d = 0;\n                if (Jsi_ValueGetNumber(interp, retP, &d) == JSI_OK)\n                    rc = -(int)d;\n                else {\n                    if (!si->errCnt)\n                        Jsi_LogWarn(\"invalid function return\");\n                    si->errCnt++;\n                }\n            }\n            Jsi_DecrRefCount(interp, retP);\n        }\n    } else {\n        if (v1 == v2) \n            rc = 0;\n        else if (v1 == NULL)\n            rc = 1;\n        else\n            rc = -1;\n    }\n    if ((sortFlags&JSI_SORT_DESCEND))\n        return rc;\n    return -rc;\n}\n\nJsi_RC Jsi_ValueArraySort(Jsi_Interp *interp, Jsi_Value *val, int flags)\n{\n    if (val->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, val->d.obj)) {\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = val->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    if (obj->arrCnt <= 0) {\n        return JSI_OK;\n    }\n#ifdef __WIN32\n#define qsort_r qsort_s\n#endif\n\n    SortInfo si = {};\n    si.interp = interp;\n    si.flags = flags;\n#ifdef NO_QSORT_R\n    curSortInfo = &si;\n    qsort(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd);\n    curSortInfo = NULL;\n#else\n    qsort_r(obj->arr, obj->arrCnt, sizeof(Jsi_Value*), SortSubCmd, &si);\n#endif\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArraySortCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    int flags = 0, i, curlen, hasopt = 0;\n    Jsi_Value *v, *arg = NULL;\n    SortInfo si = {};\n    si.interp = interp;\n\n\n    Jsi_Obj *obj = _this->d.obj;\n    curlen = obj->arrCnt;\n\n    if (curlen <= 1) {\n        goto done;\n    }\n    \n    arg = Jsi_ValueArrayIndex(interp, args, 0);\n    if (arg) {\n        if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) {\n            if (Jsi_OptionsProcess(interp, jsi_ArraySortOptions, &si, arg, 0) < 0)\n                return JSI_ERROR;\n            hasopt = 1;\n            switch (si.mode) {\n                case 1: flags |= JSI_SORT_DESCEND; break;\n                case 2: flags |= JSI_SORT_DICT; break;\n                case 3: flags |= JSI_SORT_NOCASE; break;\n            }\n        } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_FUNCTION))\n            si.compare = arg;\n        else \n            return Jsi_LogError(\"expected object or function\");\n    }\n    si.flags = flags;\n    Jsi_ObjListifyArray(interp, obj);\n#ifdef NO_QSORT_R\n    /* TODO: mutex. */\n    curSortInfo = &si;\n    qsort(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd);\n#else\n    qsort_r(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd, &si);\n#endif\n\n    if (interp->deleting) {\n#ifdef NO_QSORT_R\n        curSortInfo = NULL;\n#endif\n        return JSI_ERROR;\n    }\n    if (si.unique) {\n        int n, diff = 1, dupCnt=0;\n        for (n=0, i=1; i<(int)obj->arrCnt; i++) {\n            if (obj->arr[n] == obj->arr[i])\n                diff = 1;\n            else\n#ifdef NO_QSORT_R\n                diff = SortSubCmd(&obj->arr[n], &obj->arr[i]);\n#else\n#ifdef __WIN32\n                diff = SortSubCmd(&si, &obj->arr[n], &obj->arr[i]);\n#else\n                diff = SortSubCmd(&obj->arr[n], &obj->arr[i], &si);\n#endif\n#endif\n            if (diff) {\n                n++;\n                if (n!=i)\n                    obj->arr[n] = obj->arr[i];\n            } else {\n                dupCnt++;\n                if (obj->arr[i])\n                    Jsi_DecrRefCount(interp, obj->arr[i]);\n                obj->arr[i] = 0;\n            }\n        }\n        obj->arrCnt -= dupCnt;\n    }\n#ifdef NO_QSORT_R\n    curSortInfo = NULL;\n#endif\n    if (hasopt)\n        Jsi_OptionsFree(interp, jsi_ArraySortOptions, &si, 0);\ndone:\n    v = Jsi_ValueMakeObject(interp, NULL, obj);\n    Jsi_ValueReplace(interp, ret, v);\n    return JSI_OK;\n    \n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int newlen, argc, istart, n, rhowmany, ilen, curlen;\n    Jsi_Value *va, *start, *howmany;\n    Jsi_Obj *nobj, *obj = _this->d.obj;\n    \n    start = Jsi_ValueArrayIndex(interp, args, 0);\n    howmany = Jsi_ValueArrayIndex(interp, args, 1);\n    argc = Jsi_ValueGetLength(interp, args);\n    istart = 0;\n    ilen = (argc>=2 ? argc - 2 : 0);\n    n = jsi_SizeOfArray(interp, obj);\n    curlen = n;\n    \n    if (!start) {\n        goto bail2;\n    }\n\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    Jsi_ObjSetLength(interp, nobj, 0);\n    \n    /* Determine start index. */\n    Jsi_Number nstart;\n    if (Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            istart=0;\n    }\n      \n    Jsi_Number nhow;\n    rhowmany = n-istart;\n    if (howmany && Jsi_GetNumberFromValue(interp, howmany, &nhow) == JSI_OK) {\n        rhowmany = (int)nhow;\n        if (rhowmany >= (n-istart))\n            rhowmany = n-istart;\n        if (rhowmany < 0)\n            rhowmany = (n-istart);\n        if (rhowmany<0)\n            goto bail;\n    }\n    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, curlen=0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    Jsi_ObjArraySizer(interp, nobj, rhowmany);\n\n    /* Move elements to return object. */\n    int i, j, m;\n    for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++, i++, j++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    Jsi_ObjSetLength(interp, nobj, m);\n    \n    /* Shift remaining down. */\n    for (; rhowmany && i<curlen; i++)\n    {\n        obj->arr[i-rhowmany] = obj->arr[i];\n        obj->arr[i] = NULL;\n    }\n    curlen -= j;\n    /* Add elements. */\n    newlen = curlen + argc - (argc>=2?2:1);\n    if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) {\n        Jsi_LogError(\"too long\");\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_ERROR;\n    }\n    if (ilen>0) {\n        for (i = curlen-1; i>=istart; i--) {\n            obj->arr[i+ilen] = obj->arr[i];\n            obj->arr[i] = NULL;\n        }\n        for (m=istart, i = 2; i<argc; m++,i++) {\n            va = Jsi_ValueArrayIndex(interp, args, i);\n            if (!va) continue;\n            obj->arr[m] = NULL;\n            Jsi_ValueDup2(interp, obj->arr+m, va);\n        }\n    }\n    Jsi_ObjSetLength(interp, obj, newlen);\nbail:    \n    return JSI_OK;\n     \n            \nbail2:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_ArrayConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int argc = Jsi_ValueGetLength(interp, args), iscons = Jsi_FunctionIsConstructor(funcPtr);\n    Jsi_Value *target;\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    \n    if (iscons) {\n        target = _this;\n        Jsi_ValueMakeArrayObject(interp, &_this, Jsi_ObjNewArray(interp, NULL, 0, 0));\n    } else {\n        Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        o->__proto__ = interp->Array_prototype;\n        Jsi_ValueMakeObject(interp, ret, o);\n        target = *ret;\n    }\n\n    if (argc == 1 && v && Jsi_ValueIsNumber(interp, v)) {\n        Jsi_Number nv;\n        Jsi_GetNumberFromValue(interp,v, &nv);\n        int len = (int)nv;\n        if (!Jsi_NumberIsInteger(v->d.num) || len < 0) \n            return Jsi_LogError(\"Invalid array length\");\n        target->d.obj->isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, target->d.obj, len) <= 0)\n            return JSI_ERROR;\n    } else {\n    \n        int i;\n        target->d.obj->isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, target->d.obj, 0) <= 0)\n                return JSI_ERROR;\n        \n        for (i = 0; i < argc; ++i) {\n            Jsi_Value *argv = Jsi_ValueArrayIndex(interp, args, i);   ;\n            Jsi_ValueInsertArray(interp, _this, i, argv, 0);\n        }\n    }\n    if (iscons)\n        Jsi_ValueDup2(interp, ret, target);\n    return JSI_OK;\n}\n            \nstatic Jsi_CmdSpec arrayCmds[] = {\n    { \"Array\",      jsi_ArrayConstructor,   0,-1, \"...\", .help=\"jsi_Array constructor\", .retType=(uint)JSI_TT_ARRAY, .flags=JSI_CMD_IS_CONSTRUCTOR },\n    { \"concat\",     jsi_ArrayConcatCmd,     0,-1, \"...\", .help=\"Return array with args appended\", .retType=(uint)JSI_TT_ARRAY },\n    { \"every\",      jsi_ArrayEveryCmd,      1, 1, \"callback:function\", .help=\"Returns true if every value in array satisfies the test\", .retType=(uint)JSI_TT_ANY },\n    { \"fill\",       jsi_ArrayFillCmd,       1, 3, \"value:any, start:number=0, end:number=-1\", .help=\"Fill an array with values\", .retType=(uint)JSI_TT_ARRAY },\n    { \"filter\",     jsi_ArrayFilterCmd,     1, 2, \"callback:function, this:object=void\", .help=\"Return a filtered array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"find\",       jsi_ArrayFindCmd,       1, 1, \"callback:function\", .help=\"Returns the value of the first element in the array that satisfies the test\", .retType=(uint)JSI_TT_ANY },\n    { \"findIndex\",  jsi_ArrayFindIndexCmd,  1, 1, \"callback:function\", .help=\"Returns the index of the first element in the array that satisfies the test\", .retType=(uint)JSI_TT_ANY },\n    { \"flat\",       jsi_ArrayFlatCmd,       0, 1, \"depth:number=1\", .help=\"Flatten an arra\", .retType=(uint)JSI_TT_ARRAY },\n    { \"forEach\",    jsi_ArrayForeachCmd,    1, 2, \"callback:function, this:object=void\", .help=\"Invoke function with each item in object\", .retType=(uint)JSI_TT_VOID },\n    { \"includes\",   jsi_ArrayIncludesCmd,   1, 1, \"val:any\", .help=\"Returns true if array contains value\", .retType=(uint)JSI_TT_ANY },\n    { \"indexOf\",    jsi_ArrayIndexOfCmd,    1, 2, \"str:any, startIdx:number=0\", .help=\"Return index of first occurrance in array\", .retType=(uint)JSI_TT_NUMBER },\n    { \"isArray\",    jsi_ArrayIsArrayCmd,    0, 0, \"\", .help=\"True if val array\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"join\",       jsi_ArrayJoinCmd,       0, 1, \"sep:string=''\", .help=\"Return elements joined by char\", .retType=(uint)JSI_TT_STRING },\n    { \"lastIndexOf\",jsi_ArrayLastindexOfCmd,1, 2, \"val:any, start:number=0\", .help=\"Return index of last occurence in array\", .retType=(uint)JSI_TT_NUMBER },\n    { \"map\",        jsi_ArrayMapCmd,        1, 2, \"callback:function, this:object=void\", .help=\"Creates a new array with the results of calling a provided function on every element in this array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"pop\",        jsi_ArrayPopCmd,        0, 0, \"\", .help=\"Remove and return last element of array\", .retType=(uint)JSI_TT_ANY },\n    { \"push\",       jsi_ArrayPushCmd,       1,-1, \"val:any, ...\", .help=\"Push one or more elements onto array and return size\", .retType=(uint)JSI_TT_NUMBER },\n    { \"reduce\",     jsi_ArrayReduceCmd,     1, 2, \"callback:function, initial:any\", .help=\"Return a reduced array\", .retType=(uint)JSI_TT_ANY },\n    { \"reduceRight\",jsi_ArrayReduceRightCmd,1, 2, \"callback:function, initial:any\", .help=\"Return a reduced array\", .retType=(uint)JSI_TT_ANY },\n    { \"shift\",      jsi_ArrayShiftCmd,      0, 0, \"\", .help=\"Remove first element and shift downwards\", .retType=(uint)JSI_TT_ANY },\n    { \"sizeOf\",     jsi_ArraySizeOfCmd,     0, 0, \"\", .help=\"Return size of array\", .retType=(uint)JSI_TT_NUMBER },\n    { \"slice\",      jsi_ArraySliceCmd,      1, 2, \"start:number, end:number=void\", .help=\"Return sub-array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"some\",       jsi_ArraySomeCmd,       1, 2, \"callback:function, this:object=void\", .help=\"Return true if function returns true some element\", .retType=(uint)JSI_TT_BOOLEAN },\n    { \"sort\",       jsi_ArraySortCmd,       0, 1, \"options:function|object=void\", .help=\"Sort an array\", .retType=(uint)JSI_TT_ARRAY, .flags=0, .info=0, .opts=jsi_ArraySortOptions },\n    { \"splice\",     jsi_ArraySpliceCmd,     1,-1, \"start:number, howmany:number=void, ...\", .help=\"Change the content of an array, adding new elements while removing old elements\", .retType=(uint)JSI_TT_ARRAY },\n    { \"reverse\",    jsi_ArrayReverseCmd,    0, 0, \"\", .help=\"Reverse order of all elements in an array\", .retType=(uint)JSI_TT_ARRAY },\n    { \"unshift\",    jsi_ArrayUnshiftCmd,    0,-1, \"...\", .help=\"Add new elements to start of array and return size\", .retType=(uint)JSI_TT_NUMBER },\n    { NULL, 0,0,0,0, .help=\"Provide access to array objects\" }\n};\n\nJsi_RC jsi_InitArray(Jsi_Interp *interp, int release)\n{\n    if (release) return JSI_OK;\n    interp->Array_prototype = Jsi_CommandCreateSpecs(interp, \"Array\", arrayCmds, NULL, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\n#endif\n", "/* Jsi commands to access C-data.   http://jsish.org */\n#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#ifndef JSI_OMIT_CDATA\n#include <fcntl.h>\n#include <limits.h>\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <time.h>\n#include <ctype.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <stdint.h>\n#include <sys/time.h>\n\n#define UdcGet(udf, _this, funcPtr) \\\n   CDataObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr); \\\n    if (!udf) \\\n        return Jsi_LogError(\"CData.%s called with non-CData object\", funcPtr->cmdSpec->name);\n\nenum { jsi_CTYP_DYN_MEMORY=(1LL<<32), jsi_CTYP_STRUCT=(1LL<<33), jsi_CTYP_ENUM=(1LL<<34) };\n\ntypedef struct {\n    JSI_DBDATA_FIELDS  \n    Jsi_StructSpec *sl, *keysf;\n    Jsi_Map** mapPtr;\n    const char *help, *structName, *keyName, *varParam, *name;\n    uint flags;\n    bool isAlloc;\n    Jsi_Map_Type mapType;\n    Jsi_Key_Type keyType;\n    Jsi_Wide user;\n    Jsi_Interp *interp;\n    int objId;\n    Jsi_Obj *fobj;\n} CDataObj;\n\nstatic Jsi_StructSpec*  jsi_csStructGet(Jsi_Interp *interp, const char *name);\nstatic Jsi_StructSpec*   jsi_csFieldGet(Jsi_Interp *interp, const char *name, Jsi_StructSpec* sl);\n\nstatic Jsi_EnumSpec*    jsi_csEnumGet(Jsi_Interp *interp, const char *name);\nstatic Jsi_EnumSpec*    jsi_csEnumGetItem(Jsi_Interp *interp, const char *name, Jsi_EnumSpec* sf);\nstatic Jsi_RC     jsi_csStructInit(Jsi_StructSpec* s, uchar* data);\nstatic Jsi_RC CDataOptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *args,\n    void *rec, Jsi_Value **ret, int flags, int skipArgs);\nstatic Jsi_RC jsi_csBitGetSet(Jsi_Interp *interp, void *vrec, Jsi_Wide* valPtr, Jsi_OptionSpec *spec, int idx, bool isSet);\n\n//static Jsi_OptionSpec *jsi_csGetOptSpec(void* p) { Jsi_OptionSpec *s = (typeof(s))p; SIGASSERT(s, OPTS); return s; }\nstatic Jsi_StructSpec *jsi_csGetStructSpec(void* p) { Jsi_StructSpec *s = (typeof(s))p; SIGASSERT(s, OPTS_STRUCT); return s; }\nstatic Jsi_FieldSpec *jsi_csGetFieldSpec(void* p) { Jsi_FieldSpec *s = (typeof(s))p; SIGASSERT(s, OPTS_FIELD); return s; }\n//static Jsi_EnumSpec *jsi_csGetEnumSpec(void* p) { Jsi_EnumSpec *s = (typeof(s))p; SIGASSERT(s, OPTS_ENUM); return s; }\nstatic Jsi_OptionTypedef *jsi_csGetTypeSpec(void* p) { Jsi_OptionTypedef *s = (typeof(s))p; SIGASSERT(s, TYPEDEF); return s; }\n  \nstatic Jsi_FieldSpec*  jsi_csStructFields(Jsi_Interp *interp, const char *name) {\n    Jsi_StructSpec* sp = jsi_csStructGet(interp, name);\n    if (!sp)\n        return NULL;\n    return jsi_csGetFieldSpec(sp->extData);\n}\n\n/* Traverse hash table and match unique substring. */\nJsi_HashEntry *jsi_csfindInHash(Jsi_Interp *interp, Jsi_Hash * tbl, const char *name)\n{\n    int len;\n    Jsi_HashSearch se;\n    Jsi_HashEntry *sentry = 0, *entry = Jsi_HashEntryFind(tbl, name);\n    if (entry)\n        return entry;\n    len = Jsi_Strlen(name);\n    entry = Jsi_HashSearchFirst(tbl, &se);\n    while (entry) {\n        char *ename = (char *) Jsi_HashKeyGet(entry);\n        if (!Jsi_Strncmp(name, ename, len)) {\n            if (sentry)\n                return 0;\n            sentry = entry;\n        }\n        entry = Jsi_HashSearchNext(&se);\n    }\n    return sentry;\n}\n\n/* Traverse enum and match unique substring. */\nJsi_OptionSpec *jsi_csgetEnum(Jsi_Interp *interp, const char *name)\n{\n    Jsi_HashEntry *entry = jsi_csfindInHash(interp, interp->EnumHash, name);\n    return entry ? (Jsi_OptionSpec *) Jsi_HashValueGet(entry) : 0;\n}\n\n\n/************* INITIALIZERS  *********************************************/\n\n/* Init Type hash */\nvoid jsi_csInitType(Jsi_Interp *interp)\n{\n    if (interp->CTypeHash->numEntries) return;\n    bool isNew;\n    Jsi_HashEntry *entry;\n    const Jsi_OptionTypedef *tl;\n    if (!interp->typeInit) {\n        int i;\n        for (i = JSI_OPTION_BOOL; i!=JSI_OPTION_END; i++) {\n            tl = Jsi_OptionTypeInfo((Jsi_OptionId)i);\n            entry = Jsi_HashEntryNew(interp->TYPEHash, tl->idName, &isNew);\n            if (!isNew)\n                Jsi_LogBug(\"duplicate type: %s\", tl->idName);\n            Jsi_HashValueSet(entry, (void*)tl);\n            if (tl->cName && tl->cName[0])\n                Jsi_HashSet(interp->CTypeHash, tl->cName, (void*)tl);\n        }\n    }\n    interp->typeInit = 1;\n}\n\nstatic Jsi_RC jsi_csSetupStruct(Jsi_Interp *interp, Jsi_StructSpec *sl, Jsi_FieldSpec *sf, \n    Jsi_StructSpec* recs, int flen, Jsi_OptionTypedef** stPtr, int arrCnt) {\n    bool isNew;\n    int i, cnt = 0, boffset = 0;\n    Jsi_HashEntry *entry, *hPtr;\n    if (!(hPtr=Jsi_HashEntryNew(interp->CTypeHash, sl->name, &isNew)) || !isNew)\n        return Jsi_LogError(\"struct is c-type: %s\", sl->name);\n    entry = Jsi_HashEntryNew(interp->StructHash, sl->name, &isNew);\n    if (!isNew)\n        return Jsi_LogError(\"duplicate struct: %s\", sl->name);\n    Jsi_FieldSpec *asf = NULL, *osf = sf;\n    while (sf && sf->id != JSI_OPTION_END) {\n        if (!sf->type)\n            sf->type = Jsi_OptionTypeInfo(sf->id);\n        if (!sf->type && sf->tname)\n            sf->type = Jsi_TypeLookup(interp, sf->tname);\n        int isbitset = ((sf->flags&JSI_OPT_BITSET_ENUM)!=0);\n        if (sf->type && sf->type->extData && (sf->type->flags&(jsi_CTYP_ENUM|jsi_CTYP_STRUCT))) {\n            // A struct sub-field or a bit field mapped to an ENUM.\n            Jsi_OptionSpec *es = (typeof(es))sf->type->extData;\n            es->value++;\n            if ((sf->type->flags&jsi_CTYP_ENUM)) {\n                if (sf->bits)\n                    return Jsi_LogError(\"enum of bits unsupported: %s\", sl->name); //TODO: get working again...\n                sf->custom = (isbitset ? Jsi_Opt_SwitchBitset : Jsi_Opt_SwitchEnum);\n                sf->data = (void*)es->data;\n                sf->id = JSI_OPTION_CUSTOM;\n            }\n            else if (sf->type->flags & jsi_CTYP_STRUCT) {\n                sf->custom = Jsi_Opt_SwitchSuboption;\n                sf->data = es->extData;\n                sf->id = JSI_OPTION_CUSTOM;\n            }\n        }\n        if (recs) {\n            if (!sf->type)\n                return Jsi_LogError(\"unknown id\");\n            sf->tname = sf->type->cName;\n            sf->size = (isbitset?(int)sizeof(int):sf->type->size);\n            if (sf->arrSize)\n                sf->size *= sf->arrSize;\n            sf->idx = cnt;\n            sf->boffset = boffset;\n            if (sf->bits) {\n                if (sf->bits>=64)\n                    return Jsi_LogError(\"bits too large\");\n                boffset += sf->bits;\n                sf->id = JSI_OPTION_CUSTOM;\n                sf->custom=Jsi_Opt_SwitchBitfield;\n                sf->init.OPT_BITS=&jsi_csBitGetSet;\n            } else {\n                sf->offset = (boffset+7)/8;\n                boffset += sf->size*8;\n            }\n        } else {\n            boffset += sf->size*8;\n        }\n        sf->extData = (uchar*)sl;\n        sf++, cnt++;\n    }\n    sl->idx = cnt;\n    if (!sl->size) \n        sl->size = (boffset+7)/8;\n    if (sl->ssig)\n        Jsi_HashSet(interp->SigHash, (void*)(uintptr_t)sl->ssig, sl);\n    int extra = 0;\n    if (flen)\n        extra = sl->size + ((flen+2+arrCnt*2)*sizeof(Jsi_StructSpec));\n    Jsi_OptionTypedef *st = (typeof(st))Jsi_Calloc(1, sizeof(*st) + extra);\n    SIGINIT(st, TYPEDEF);\n    if (!recs) \n        sf = osf;\n    else {\n        st->extra = (uchar*)(st+1); // Space for struct initializer.\n        sf =  (typeof(sf))(st->extra + sl->size);\n        memcpy(sf, recs, sizeof(*sf)*(flen+1));\n        sl = sf+flen+1;\n        if (arrCnt)\n            asf = sl+1;\n        memcpy(sl, recs+flen+1, sizeof(*sl));\n        for (i=0; i<flen; i++) {\n            sf[i].extData = (uchar*)sl;\n            if (sf[i].id == 0 && sf[i].type)\n                sf[i].id = sf[i].type->id;\n            if (sf[i].arrSize) {\n                asf[0] = sf[i];\n                asf[1] = sf[flen];\n                asf->arrSize = asf->offset = 0;\n                //asf->size = asf->type->size;\n                sf[i].id = JSI_OPTION_CUSTOM;\n                sf[i].custom=Jsi_Opt_SwitchCArray;\n                sf[i].init.OPT_CARRAY = asf;\n                asf += 2;\n                //sf[i].extData = \n                 //   {.sig=JSI_SIG_OPTS_FIELD, .name=sf[i].name, \n                  //  JSI_OPT_CARRAY_ITEM_(JSI_SIG_OPTS_FIELD,'+otype+', '+name+', sf[i].name, .help=sf[i].help, .flags='+fflags+rest+'),\\n'\n                   // JSI_OPT_END_(JSI_SIG_OPTS_FIELD,'+name+', .help=\"Options for array field '+name+'.'+fname+'\")\\n  };\\n\\n';\n                   // JSI_OPT_CARRAY_(JSI_SIG_OPTS_FIELD,'+name+', '+fname+', \"'+fdescr+'\", '+fflags+', '+arnam+', '+f.asize+', \"'+type+'\", '+csinit+'),\\n';\n            }\n        }\n    }\n    st->extData = (uchar*)sl;\n    sl->extData = (uchar*)sf;\n    sl->type = st;\n    st->cName = sl->name;\n    st->idName = \"CUSTOM\";\n    st->id = JSI_OPTION_CUSTOM;\n    st->size = sl->size;\n    st->flags = jsi_CTYP_DYN_MEMORY|jsi_CTYP_STRUCT;\n    Jsi_HashValueSet(entry, sl);\n    Jsi_HashValueSet(hPtr, st);\n    st->hPtr = hPtr;\n    if (stPtr)\n        *stPtr = st;\n    return JSI_OK;\n}\n\n/* Init Struct hash */\nstatic void jsi_csInitStructTables(Jsi_Interp *interp)\n{\n    Jsi_StructSpec *sf, *sl = interp->statics->structs;\n    while (sl  && sl->name) {\n        sf = (typeof(sf))sl->data;\n        jsi_csSetupStruct(interp, sl, sf, NULL, 0, NULL, 0);\n        sl++;\n    }\n}\n\nstatic int jsi_NumWideBytes(Jsi_Wide val) {\n    if (val < 0x10000)\n        return (val < 0x100 ? 1 : 2);\n    return(val < 0x100000000L ? 4 : 8);\n}\n\nstatic Jsi_RC jsi_csSetupEnum(Jsi_Interp *interp, Jsi_EnumSpec *sl, Jsi_FieldSpec *sf, Jsi_OptionTypedef* st) {\n    bool isNew;\n    int cnt = 0;\n    if (Jsi_HashEntryFind(interp->CTypeHash, sl->name))\n        return Jsi_LogError(\"enum is c-type: %s\", sl->name);\n    Jsi_HashEntry *entry = Jsi_HashEntryNew(interp->EnumHash, sl->name, &isNew);\n    if (!isNew)\n        return Jsi_LogError(\"duplicate enum: %s\", sl->name);\n    Jsi_HashValueSet(entry, sl);\n    //Jsi_Number val = 0;\n    sl->extData = (uchar*)sf;\n    Jsi_Wide maxVal = 0, aval;\n    while (sf && sf->id != JSI_OPTION_END) {\n        sf->idx = cnt;\n        Jsi_HashSet(interp->EnumItemHash, sf->name, sf);\n        sf->extData = (uchar*)sl;\n        aval =  sf->value;\n        if (aval<0) aval = -aval;\n        if (aval>maxVal) maxVal = aval;\n        sf++, cnt++;\n    }\n    Jsi_HashSet(interp->EnumHash, sl->name, sl);\n    sl->idx = cnt;\n    if (!sl->size) \n        sl->size = cnt;\n    if (!st) {\n        st = (typeof(st))Jsi_Calloc(1, sizeof(*st));\n        SIGINIT(st, TYPEDEF);\n    }\n    st->cName = sl->name;\n    st->idName = \"CUSTOM\";\n    st->id = JSI_OPTION_CUSTOM;\n    st->size = jsi_NumWideBytes(aval);\n    st->flags = jsi_CTYP_DYN_MEMORY|jsi_CTYP_ENUM;\n    st->extData = (uchar*)sl;\n    Jsi_HashSet(interp->CTypeHash, st->cName, st);\n    return JSI_OK;\n}\n\n/* Init Enum hash */\nvoid jsi_csInitEnum(Jsi_Interp *interp)\n{\n    bool isNew;\n    Jsi_EnumSpec *sl = interp->statics->enums;\n    while (sl && sl->name && sl->id != JSI_OPTION_END) {\n        Jsi_HashEntry *entry = Jsi_HashEntryNew(interp->EnumHash, sl->name, &isNew);\n        if (!isNew)\n            Jsi_LogBug(\"duplicate enum: %s\", sl->name);\n        assert(isNew);\n        Jsi_HashValueSet(entry, sl);\n        sl++;\n    }\n}\n\n/* Find the enum name in all enums */\nJsi_OptionSpec *jsi_csInitEnumItem(Jsi_Interp *interp)\n{\n    Jsi_HashEntry *entry;\n    bool isNew;\n    Jsi_EnumSpec *sl = interp->statics->enums;\n    while (sl &&  sl->name && sl->id != JSI_OPTION_END) {\n        Jsi_OptionSpec *ei = (typeof(ei))sl->data;\n        while (ei->name  && ei->id != JSI_OPTION_END) {\n            entry = Jsi_HashEntryNew(interp->EnumItemHash, ei->name, &isNew);\n            if (!isNew)\n                Jsi_LogBug(\"duplicate enum item: %s\", ei->name);\n            Jsi_HashValueSet(entry, ei);\n            ei++;\n        }\n        sl++;\n    }\n    return 0;\n}\n\nJsi_StructSpec *Jsi_CDataStruct(Jsi_Interp *interp, const char *name) {\n    return (Jsi_StructSpec *)Jsi_HashGet(interp->StructHash, name, 0);\n}\n\n// Format struct key.\nstatic Jsi_Value *jsi_csFmtKeyCmd(Jsi_MapEntry* hPtr, Jsi_MapOpts *opts, int flags)\n{\n    void *rec = (opts->mapType==JSI_MAP_HASH ? Jsi_HashKeyGet((Jsi_HashEntry*)hPtr): Jsi_TreeKeyGet((Jsi_TreeEntry*)hPtr));\n    if (!rec) return NULL;\n    CDataObj *cd = (typeof(cd))opts->user;\n    assert(cd);\n    Jsi_Interp *interp = cd->interp;\n    if (!cd->slKey || !cd->slKey)\n        return NULL;\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->keysf, rec, NULL, &v, flags) == JSI_OK)\n        return v;\n    Jsi_DecrRefCount(interp, v);\n    return NULL;\n}\n\nstatic Jsi_RC jsi_csCDataNew(Jsi_Interp *interp, const char *name, const char *structName,\n    const char *help, const char *varParm, Jsi_VarSpec *data) {\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSPrintf(&dStr, \"var %s = new CData({name:\\\"%s\\\", structName:\\\"%s\\\"\", name, name, structName);\n    if (help)\n        Jsi_DSPrintf(&dStr, \", help:\\\"%s\\\"\", help);\n    if (varParm)\n        Jsi_DSPrintf(&dStr, \", varParam:\\\"%s\\\"\", varParm);\n    Jsi_DSPrintf(&dStr, \"});\");\n    interp->cdataNewVal = data;\n    Jsi_RC rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0);\n    interp->cdataNewVal = NULL;\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nJsi_RC jsi_csInitVarDefs(Jsi_Interp *interp)\n{\n    Jsi_VarSpec *vd = interp->statics->vars;\n    int i;\n    for (i=0; vd[i].name; i++) {\n        SIGASSERT(vd+i, OPTS_VARDEF);\n        const char *name = vd[i].name;\n        const char *structName = vd[i].info;\n        const char *help = vd[i].help;\n        const char *varParm = (const char*)vd[i].userData;\n\n        if (JSI_OK != jsi_csCDataNew(interp, name, structName, help, varParm, vd+i))\n            return JSI_ERROR;\n#if 0        \n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DSPrintf(&dStr, \"var %s = new CData({name:\\\"%s\\\", structName:\\\"%s\\\"});\", name, name, structName);\n        if (help)\n            Jsi_DSPrintf(&dStr, \", help:\\\"%s\\\"\", help);\n        /*if (vd[i].value)\n            Jsi_DSPrintf(&dStr, \", arrSize:%u\", (uint)vd[i].value);*/\n        if (varParm)\n            Jsi_DSPrintf(&dStr, \", varParam:\\\"%s\\\"\", varParm);\n        Jsi_DSPrintf(&dStr, \"});\");\n        Jsi_RC rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0);\n        Jsi_DSFree(&dStr);\n        if (rc != JSI_OK)\n            return JSI_ERROR;\n#endif\n    }\n    return JSI_OK;\n}\n\nJsi_StructSpec *jsi_csStructGet(Jsi_Interp *interp, const char *name)\n{\n    if (!name) return NULL;\n    Jsi_StructSpec *sl,*spec = Jsi_CDataStruct(interp, name);\n    if (spec) return spec;\n\n    Jsi_CData_Static *CData_Strs = interp->statics;\n    while (CData_Strs) {\n        sl = CData_Strs->structs;\n        while (sl->name) {\n            if (!Jsi_Strcmp(name, sl->name))\n                return sl;\n            sl++;\n        }\n        CData_Strs = CData_Strs->nextPtr;\n    }\n    return NULL;\n}\n\n\nJsi_EnumSpec *jsi_csGetEnum(Jsi_Interp *interp, const char *name) {\n    return (Jsi_EnumSpec *)Jsi_HashGet(interp->EnumHash, name, 0);\n}\n\n/* Traverse enum and match unique substring. */\nJsi_EnumSpec *jsi_csEnumGet(Jsi_Interp *interp, const char *name)\n{\n    Jsi_EnumSpec *sl, *spec = jsi_csGetEnum(interp, name);\n    if (spec) return spec;\n\n    Jsi_CData_Static *CData_Strs = interp->statics;\n    while (CData_Strs) {\n        sl = CData_Strs->enums;\n        while (sl->name) {\n            if (!Jsi_Strcmp(name, sl->name))\n                return sl;\n            sl++;\n        }\n        CData_Strs = CData_Strs->nextPtr;\n    }\n    return NULL;\n}\n\n/****************************************************************/\n\n/* Traverse from top looking for field in struct, match unique substrings. */\nJsi_FieldSpec *jsi_csFieldGet(Jsi_Interp *interp, const char *name, Jsi_StructSpec * sl)\n{\n    SIGASSERT(sl, OPTS_STRUCT);\n    Jsi_FieldSpec *sf, *ff = 0, *f = jsi_csGetFieldSpec(sl->extData);\n    int cnt = 0;\n    uint len = Jsi_Strlen(name);\n    sf = f;\n    SIGASSERT(sf, OPTS_FIELD);\n    while (sf->id != JSI_OPTION_END) {\n        if (!Jsi_Strncmp(name, sf->name, len)) {\n            if (!sf->name[len])\n                return sf;\n            ff = sf;\n            cnt++;\n        }\n        sf++;\n    }\n    if (cnt == 1)\n        return ff;\n    return 0;\n}\n  \n/* Traverse from top looking for item in enum, match unique substrings. */\nJsi_EnumSpec *jsi_csEnumGetItem(Jsi_Interp *interp, const char *name, Jsi_EnumSpec * el)\n{\n    SIGASSERT(el, OPTS_ENUM);\n    int cnt = 0;\n    uint len = Jsi_Strlen(name);\n    if (!el->extData)\n        return 0;\n    Jsi_FieldSpec *ff = NULL, *sf = jsi_csGetFieldSpec(el->extData);\n    while (sf->id != JSI_OPTION_END) {\n        if (!Jsi_Strncmp(name, sf->name, len)) {\n            if (!sf->name[len])\n                return sf;\n            ff = sf;\n            cnt++;\n        }\n        sf++;\n    }\n    if (cnt == 1)\n        return ff;\n    return 0;\n}\n\n/******* INIT ***************************************************/\n\n\n/* Initialize a struct to default values */\nstatic Jsi_RC jsi_csStructInit(Jsi_StructSpec * sl, uchar * data)\n{\n    /* Jsi_OptionSpec *sf; */\n    assert(sl);\n    if (!data) {\n        fprintf(stderr, \"missing data at %s:%d\", __FILE__, __LINE__);\n        return JSI_ERROR;\n    }\n    if (sl->custom)\n        memcpy(data, sl->custom, sl->size);\n    else if (sl->type && sl->type->extra)\n        memcpy(data, sl->type->extra, sl->size);\n    else\n        memset(data, 0, sl->size);\n\n    if (sl->ssig)\n        *(Jsi_Sig *) data = sl->ssig;\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataEnumNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                               Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n    \n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->EnumHash, ret, 0);\n    char *arg1 = Jsi_ValueString(interp, Jsi_ValueArrayIndex(interp, args, 0), NULL);\n    Jsi_EnumSpec *s, *sf;\n    if (arg1 == NULL || !(s = (Jsi_EnumSpec*)Jsi_HashGet(interp->EnumHash, arg1, 0)))\n        return Jsi_LogError(\"Unknown enum: %s\", arg1);\n    Jsi_ValueMakeArrayObject(interp, ret, NULL);\n    sf = (typeof(sf))s->extData;\n    int m = 0;\n    while (sf && sf->id != JSI_OPTION_END)\n    {\n        Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewBlobString(interp, sf->name), m++);\n        sf++;\n    }\n    return JSI_OK;\n}\n\n////// ENUM\n\nstatic Jsi_OptionSpec EnumOptions[] =\n{\n    JSI_OPT(INT64,      Jsi_EnumSpec, flags,  .help=\"Flags for enum\", jsi_IIOF),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, help,   .help=\"Description of enum\", jsi_IIOF ),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, name,   .help=\"Name of enum\", jsi_IIOF ),\n    JSI_OPT(UINT,       Jsi_EnumSpec, idx,    .help=\"Number of items in enum\", jsi_IIRO ),\n    JSI_OPT_END(Jsi_EnumSpec, .help=\"Options for CData enum\")\n};\n\nstatic Jsi_OptionSpec EnumFieldOptions[] =\n{\n    JSI_OPT(INT64,      Jsi_EnumSpec, flags,  .help=\"Flags for item\", jsi_IIOF),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, help,   .help=\"Desciption of item\", jsi_IIOF ),\n    JSI_OPT(STRKEY,     Jsi_EnumSpec, name,   .help=\"Name of item\", jsi_IIOF ),\n    JSI_OPT(INT64,      Jsi_EnumSpec, value,  .help=\"Value for item\", jsi_IIOF),\n    JSI_OPT(UINT,       Jsi_EnumSpec, idx,    .help=\"Index of item in enum\", jsi_IIRO ),\n    JSI_OPT_END(Jsi_EnumSpec, .help=\"Options for CData item\")\n};\n\nstatic Jsi_RC CDataEnumFieldConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_EnumSpec *ei, *sf;\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!(sf = jsi_csEnumGet(interp, arg1)))\n        return Jsi_LogError(\"unknown enum item: %s\", arg1);\n    ei = 0;\n    char *arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    if (!(ei = jsi_csEnumGetItem(interp, arg2, sf)))\n        return JSI_OK;\n\n    return CDataOptionsConf(interp, EnumFieldOptions, args, ei, ret, 0, 2);\n}\n\nstatic Jsi_RC CDataEnumConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_EnumSpec *sl;\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!(sl = jsi_csEnumGet(interp, arg1)))\n        return Jsi_LogError(\"unknown enum: %s\", arg1);\n    return CDataOptionsConf(interp, EnumOptions, args, sl, ret, 0, 1);\n}\n\n\nstatic Jsi_RC CDataEnumUndefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_HashEntry *entry = NULL;\n    Jsi_OptionTypedef *st = NULL;\n    if (name) {\n        entry = Jsi_HashEntryFind(interp->EnumHash, name);\n        st = Jsi_TypeLookup(interp, name);\n    }\n    if (!entry || !st)\n        return Jsi_LogError(\"Unknown enum: %s\", name);\n    Jsi_EnumSpec *sf, *sl = (typeof(sl))Jsi_HashValueGet(entry);\n    if (sl->value)\n        return Jsi_LogError(\"Enum in use\");\n    Jsi_HashEntryDelete(entry);\n    sf = (typeof(sf))sl->extData;\n    while (sf && sf->id != JSI_OPTION_END) {\n        entry = Jsi_HashEntryFind(interp->EnumItemHash, name);\n        if (entry)\n            Jsi_HashEntryDelete(entry);\n        sf++;\n    }\n    entry = Jsi_HashEntryFind(interp->CTypeHash, name);\n    if (entry)\n        Jsi_HashEntryDelete(entry);\n    else\n        Jsi_Free(st);\n    return JSI_OK;\n}\n\n/* Defines: Handles the \"CData.enum.define\" subcommand */\nstatic Jsi_RC CDataEnumDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    char **argv = NULL, *cmt, *cp;\n    Jsi_OptionTypedef *st = NULL;\n    jsi_csInitType(interp);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0),\n        *flds = Jsi_ValueArrayIndex(interp, args, 1);\n    int vlen, flen, i, argc;\n    Jsi_DString fStr = {};\n    const char **el, *vstr = Jsi_ValueString(interp, val, &vlen),\n        *fstr = Jsi_ValueString(interp, flds, &flen);\n    if (vstr) {\n        cmt = Jsi_Strstr(fstr, \"//\");\n        Jsi_DString tStr = {fstr};\n        fstr=jsi_TrimStr(Jsi_DSValue(&tStr));\n        Jsi_SplitStr(fstr, &argc, &argv, (cmt?\"\\n\":\",\"), &fStr);\n        Jsi_DSFree(&tStr);\n    } else if (!Jsi_ValueIsArray(interp,flds) || (argc=Jsi_ValueGetLength(interp, flds))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n\n    Jsi_EnumSpec *sl, *sf, recs[argc+1];\n    memset(recs, 0, sizeof(recs));\n    sl = recs+argc;\n    SIGINIT(sl, OPTS_ENUM);\n    if (vstr) {\n        sl->name = Jsi_KeyAdd(interp, vstr);\n    } else if (Jsi_OptionsProcess(interp, EnumOptions, sl, val, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(sl->name)) {\n        rc = Jsi_LogError(\"invalid enum name: %s\", sl->name);\n        goto bail;\n    }\n    if (jsi_csEnumGet(interp, sl->name)) {\n        rc = Jsi_LogError(\"enum already exists: %s\", sl->name);\n        goto bail;\n    }\n    for (i = 0; i<argc; i++) {\n        sf = recs+i;\n        SIGINIT(sf, OPTS_FIELD);\n        sf->idx = i;\n        if (i)\n            sf->value = recs[i-1].value+1;\n        if (!argv)\n            val = Jsi_ValueArrayIndex(interp, flds, i);\n        else {\n            if (cmt) {\n                cp = Jsi_Strstr(argv[i], \"//\"); \n                if (cp) {\n                    *cp = 0;\n                    cp += 2;\n                    cp = jsi_TrimStr(cp);\n                    sf->help = Jsi_KeyAdd(interp, cp);\n                }\n            }\n            cp = Jsi_Strchr(argv[i], ','); \n            if (cp) *cp = 0;\n            cp = Jsi_Strchr(argv[i], '='); \n            if (cp) {\n                *cp++ = 0;\n                cp = jsi_TrimStr(cp);\n                if (Jsi_GetWide(interp, cp, &sf->value, 0) != JSI_OK) {\n                    rc = Jsi_LogError(\"Bad value\");\n                    goto bail;\n                }\n            }\n            cp = jsi_TrimStr(argv[i]);\n            sf->name = Jsi_KeyAdd(interp, cp);\n            val = NULL;\n        }\n        if (val && Jsi_OptionsProcess(interp, EnumFieldOptions, sf, val, 0) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n        if (Jsi_HashGet(interp->EnumItemHash, sf->name, 0)) {\n            rc = Jsi_LogError(\"duplicate enum item: %s\", sf->name);\n            goto bail;\n        }\n        if (!Jsi_StrIsAlnum(sf->name)) {\n            rc = Jsi_LogError(\"invalid enum item name: %s\", sf->name);\n            goto bail;\n        }\n    }\n    st = (typeof(st))Jsi_Calloc(1, sizeof(*st) + sizeof(char*)*(argc+1)+sizeof(recs));\n    SIGINIT(st, TYPEDEF);\n    sf = (typeof(sf))((uchar*)(st + 1));\n    sl = sf+argc;\n    el = (typeof(el))(sl + 1);\n    memcpy(sf, recs, sizeof(recs));\n    for (i = 0; i<argc; i++)\n        el[i] = sf[i].name;\n    sl->id = JSI_OPTION_END;\n    sl->extData = (uchar*)sf;\n    sl->data = el;\n    rc = jsi_csSetupEnum(interp, sl, sf, st);\nbail:\n    Jsi_DSFree(&fStr);\n    if (rc != JSI_OK && st)\n        Jsi_Free(st);\n    return rc;\n}\n\nstatic Jsi_RC CDataEnumValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                               Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    const char *arg1, *arg2;\n    Jsi_EnumSpec *ei, *el = 0;\n    arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    if (!(el = jsi_csEnumGet(interp, arg1))) {\n        return JSI_OK;\n    }\n    if (!(ei = jsi_csEnumGetItem(interp, arg2, el)))\n        return JSI_OK;\n    Jsi_ValueMakeNumber(interp, ret, ei->value);\n    return JSI_OK;\n}\n\n\n/* Return the enum symbol that matches the given integer value. */\nstatic Jsi_RC CDataEnumFindCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_EnumSpec *ei, *el;\n    if (!(el = jsi_csEnumGet(interp, arg1)))\n        return Jsi_LogError(\"Unknown enum: %s\", arg1);\n    Jsi_Wide wval;\n    if (Jsi_GetWideFromValue(interp, arg2, &wval) != JSI_OK)\n        return JSI_ERROR;\n\n    ei = (typeof(ei))el->extData;\n    uint i;\n    for (i=0; i<el->size; i++) {\n        if (wval == (Jsi_Wide)ei[i].value) {\n            Jsi_ValueMakeStringKey(interp, ret, ei[i].name);\n            return JSI_OK;\n        }\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataEnumGetDfn(Jsi_Interp *interp, Jsi_EnumSpec * sl, Jsi_DString *dsPtr)\n{\n    \n    Jsi_EnumSpec *sf;\n    Jsi_DString eStr = {};\n\n    Jsi_DSAppend(dsPtr, \"{ name: \\\"\", sl->name, \"\\\"\", NULL);\n    if (sl->flags)\n        Jsi_DSPrintf(dsPtr, \", flags:%\" PRIx64, sl->flags);\n    if (sl->help && sl->help[0]) {\n        Jsi_DSAppend(dsPtr, \", help:\", Jsi_JSONQuote(interp, sl->help, -1, &eStr), NULL);\n        Jsi_DSFree(&eStr);\n    }\n    sf = jsi_csGetFieldSpec(sl->extData);\n    Jsi_DSAppend(dsPtr, \", fields:[\", NULL);\n    while (sf->id != JSI_OPTION_END) {\n        Jsi_DSPrintf(dsPtr, \" { name:\\\"%s\\\", value:%#\" PRIx64, sf->name, (int64_t)sf->value);\n        if (sf->help && sf->help[0]) {\n            Jsi_DSAppend(dsPtr, \", help:\", Jsi_JSONQuote(interp, sf->help, -1, &eStr), NULL);\n            Jsi_DSFree(&eStr);\n        }\n        Jsi_DSAppend(dsPtr, \"}\", NULL);\n        sf++;\n    }\n    Jsi_DSAppend(dsPtr, \"]}\", NULL);\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataEnumGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_EnumSpec *sl = jsi_csEnumGet(interp, name);\n    if (!sl)\n        return JSI_OK;\n    JSI_DSTRING_VAR(dsPtr, 400);\n    Jsi_RC rc = CDataEnumGetDfn(interp, sl, dsPtr);\n    if (JSI_OK == rc)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(dsPtr), ret, 0);\n    Jsi_DSFree(dsPtr);\n    return rc;\n}\n\nstatic Jsi_CmdSpec enumCmds[] = {\n    {\"add\",     CDataEnumDefineCmd,  2, 2, \"options:object|string, fields:array|string\", .help=\"Create a new enum: value of items same as in fieldconf\", .retType=0, .flags=0, .info=0, .opts=EnumOptions},\n    {\"conf\",    CDataEnumConfCmd,    1, 2, \"enum:string, options:object|string=void\",.help=\"Configure options for enum\", .retType=0, .flags=0, .info=0, .opts=EnumOptions},\n    {\"fieldconf\",CDataEnumFieldConfCmd,2, 3, \"enum:string, field:string, options:object|string=void\",.help=\"Configure options for fields\", .retType=0, .flags=0, .info=0, .opts=EnumFieldOptions},\n    {\"find\",    CDataEnumFindCmd,    2, 2, \"enum:string, intValue:number\", .help=\"Find item with given value in enum\", .retType=(uint)JSI_TT_STRING},\n    {\"get\",     CDataEnumGetCmd,     1, 1, \"enum:string\", .help=\"Return enum definition\", .retType=(uint)JSI_TT_OBJECT},\n    {\"names\",   CDataEnumNamesCmd,   0, 1, \"enum:string=void\", .help=\"Return name list of all enums, or items within one enum\", .retType=(uint)JSI_TT_ARRAY},\n    {\"remove\",  CDataEnumUndefineCmd,1, 1, \"enum:string\",.help=\"Remove an enum\", .retType=0, .flags=0, .info=0, .opts=0},\n    {\"value\",   CDataEnumValueCmd,   2, 2, \"enum:string, item:string\", .help=\"Return value for given enum item\", .retType=(uint)JSI_TT_NUMBER},\n    { NULL,   0,0,0,0, .help=\"Enum commands. Note: Enum() is a shortcut for Enum.add()\" }\n};\n\n/************************** STRUCT ******************************/\n\nstatic Jsi_RC CDataStructGetDfn(Jsi_Interp *interp, Jsi_StructSpec * sl, Jsi_DString *dsPtr)\n{\n    \n    Jsi_StructSpec *sf;\n    Jsi_DString eStr = {};\n    sf = jsi_csGetFieldSpec(sl->extData);\n    Jsi_DSPrintf(dsPtr, \"{ \\\"name\\\": \\\"%s\\\", \\\"size\\\":%d\", sl->name, sl->size);\n    if (sl->flags)\n        Jsi_DSPrintf(dsPtr, \", \\\"flags\\\":0x%\" PRIx64, sl->flags);\n    if (sl->help && sl->help[0]) {\n        Jsi_DSAppend(dsPtr, \", \\\"label\\\":\", Jsi_JSONQuote(interp, sl->help, -1, &eStr), NULL);\n        Jsi_DSFree(&eStr);\n    }\n    if (sl->ssig)\n        Jsi_DSPrintf(dsPtr, \", \\\"sig\\\":0x%x\", sl->ssig);\n    Jsi_DSAppend(dsPtr, \", \\\"fields\\\":[\", NULL);\n#define SSIFNV(s) (s?\"\\\"\":\"\"), (s?s:\"null\"), (s?\"\\\"\":\"\")\n    while (sf->id != JSI_OPTION_END) {\n        Jsi_DSPrintf(dsPtr, \" { \\\"name\\\":\\\"%s\\\",  \\\"id\\\":%s%s%s, \\\"size\\\":%d, \\\"bitsize\\\":%d,\"\n            \"\\\"offset\\\":%d, , \\\"bitoffs\\\":%d, \\\"isbit\\\":%d, \\\"label\\\":\",\n             sf->name, SSIFNV(sf->tname), sf->size, sf->bits,\n             sf->offset, sf->boffset, sf->flags&JSI_OPT_IS_BITS?1:0 );\n        if (sf->help && sf->help[0]) {\n            Jsi_DSAppend(dsPtr, Jsi_JSONQuote(interp, sf->help, -1, &eStr), NULL);\n            Jsi_DSFree(&eStr);\n        } else\n            Jsi_DSAppend(dsPtr,\"\\\"\\\"\", NULL);\n        Jsi_DSAppend(dsPtr, \"}\", NULL);\n        sf++;\n    }\n    Jsi_DSAppend(dsPtr, \"]}\", NULL);\n    return JSI_OK;\n}\n\n/* Return the structure definition. */\nstatic Jsi_RC CDataStructGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sl = jsi_csStructGet(interp, arg1);\n\n    if (!sl)\n        return Jsi_LogError(\"unkown struct: %s\", arg1);\n    Jsi_DString dStr = {};\n    Jsi_RC rc = CDataStructGetDfn(interp, sl, &dStr);\n    if (JSI_OK == rc)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC CDataStructNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                 Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->StructHash, ret, 0);\n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sf, *sl;\n    if (name == NULL || !(sl = Jsi_CDataStruct(interp, name)))\n        return Jsi_LogError(\"Unknown struct: %s\", name);\n    Jsi_ValueMakeArrayObject(interp, ret, NULL);\n    sf = (typeof(sf))sl->data;\n    int m = 0;\n    while (sf && sf->id != JSI_OPTION_END)\n    {\n        Jsi_ValueArraySet(interp, *ret, Jsi_ValueNewBlobString(interp, sf->name), m++);\n        sf++;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataStructSchemaCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sf = jsi_csStructFields(interp, arg1);\n\n    if (!sf)\n        return Jsi_LogError(\"unkown struct: %s\", arg1);;\n\n    Jsi_DString dStr = {};\n    Jsi_OptionsData(interp, (Jsi_OptionSpec*)sf, &dStr, 1);\n    Jsi_ValueFromDS(interp, &dStr, ret);\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\n}\n\n/* Scanning function */\nstatic Jsi_RC jsi_csValueToFieldType(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    const Jsi_OptionTypedef *typ, **sp = (typeof(sp))(((uchar*)record) + spec->offset);\n\n    if (!inStr) {\n        if (!inValue || Jsi_ValueIsString(interp, inValue)==0)\n            return Jsi_LogError(\"expected string\");\n        inStr = Jsi_ValueString(interp, inValue, NULL);\n    }\n    typ = Jsi_TypeLookup(interp, inStr);\n    if (!typ)\n        return Jsi_LogError(\"unknown type: %s\", inStr);\n    *sp = typ;\n    return JSI_OK;\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_csFieldTypeToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    const Jsi_OptionTypedef **sp = (typeof(sp))(((uchar*)record) + spec->offset), *sptr = *sp;\n    //const char **s = (const char**)((char*)record + spec->offset);\n    if (sptr)\n        SIGASSERT(sptr, TYPEDEF);\n    if (sptr && sptr->cName)\n        Jsi_ValueMakeStringKey(interp, outValue, sptr->cName);\n    else\n        Jsi_ValueMakeNull(interp, outValue);\n    return JSI_OK;\n}\n\nJsi_OptionCustom jsi_OptSwitchFieldType = {\n    .name=\"fieldtype\", .parseProc=jsi_csValueToFieldType, .formatProc=jsi_csFieldTypeToValue, .freeProc=NULL,\n};\n\n\n/* Scanning function */\nstatic Jsi_RC jsi_ValueToIniVal(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value *inValue, const char *inStr, void *record, Jsi_Wide flags)\n{\n    if (inStr)\n        return JSI_ERROR;\n    uchar *data = (uchar*)record, *odata;\n    //Jsi_OptionValue iv;\n    int idx = (intptr_t)spec->data;\n    if (idx<=0 || !inValue)\n        return Jsi_LogError(\"idx/value not set\");\n    Jsi_OptionSpec *typePtr = spec-idx;\n    if (typePtr->id != JSI_OPTION_CUSTOM || typePtr->custom != &jsi_OptSwitchFieldType)\n        return Jsi_LogError(\"Bad field type\");\n    const Jsi_OptionTypedef **tsp = (typeof(tsp))(data + typePtr->offset), *tsptr = *tsp, *ssp;\n    SIGASSERT(tsptr, TYPEDEF);\n    Jsi_FieldSpec *sf = jsi_csGetFieldSpec(data);\n    Jsi_StructSpec *sl = jsi_csGetStructSpec(sf->extData);\n    ssp = sl->type;\n    SIGASSERT(ssp, TYPEDEF);\n    odata = ssp->extra;\n    if (!tsptr->sfmt) {\n        if (tsptr->flags&jsi_CTYP_STRUCT && tsptr->extra) {\n            if (!Jsi_ValueIsBoolean(interp, inValue)) Jsi_LogWarn(\"init for struct must be boolean\");\n            if (!Jsi_ValueIsTrue(interp, inValue)) return JSI_OK;\n            Jsi_StructSpec *tsl = jsi_csGetStructSpec(tsptr->extData);\n            int i, n = (sf->arrSize?sf->arrSize:1);\n            for (i=0; i<n; i++)\n                memcpy(odata+sf->offset+i*tsl->size, tsptr->extra, tsl->size);\n            return JSI_OK;\n        } else if (!(tsptr->flags&jsi_CTYP_ENUM))\n            return Jsi_LogError(\"init not supported for type: %s\", tsptr->cName);\n    }\n    return jsi_SetOption(interp, sf, \"init\", odata, inValue, flags, interp->isSafe);\n}\n\n/* Printing function. */\nstatic Jsi_RC jsi_IniValToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue, Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    if (outStr)\n        return JSI_ERROR;\n    uchar *data = (uchar*)record, *odata;\n    int idx = (intptr_t)spec->data;\n    if (idx<=0 || !outValue)\n        return Jsi_LogError(\"idx/value not set\");\n    Jsi_OptionSpec *typePtr = spec-idx;\n    if (typePtr->id != JSI_OPTION_CUSTOM || typePtr->custom != &jsi_OptSwitchFieldType)\n        return Jsi_LogError(\"Bad field type\");\n    const Jsi_OptionTypedef **tsp = (typeof(tsp))(data + typePtr->offset), *tsptr = *tsp, *ssp;\n    SIGASSERT(tsptr, TYPEDEF);\n    Jsi_FieldSpec *sf = jsi_csGetFieldSpec(data);\n    Jsi_StructSpec *sl = jsi_csGetStructSpec(sf->extData);\n    ssp = sl->type;\n    SIGASSERT(ssp, TYPEDEF);\n    odata = ssp->extra;\n    if (odata && tsptr->sfmt)\n        return jsi_GetOption(interp, sf, odata, \"init\", outValue, flags);\n\n    Jsi_ValueMakeNull(interp, outValue);\n    return JSI_OK;\n    \n    //Jsi_OptionSpec ospec = {.sig=JSI_SIG_OPTS, .id=tsptr->id, .name=\"init\", .offset=0, .size=sizeof(Jsi_OptionValue) };\n    //return jsi_GetOption(interp, &ospec, odata, ospec.name, outValue, flags);\n}\n\nJsi_OptionCustom jsi_OptSwitchIniVal = {\n    .name=\"inival\", .parseProc=jsi_ValueToIniVal, .formatProc=jsi_IniValToValue\n};\n\nstatic Jsi_OptionSpec StructOptions[] =\n{\n    JSI_OPT(UINT32, Jsi_StructSpec, crc,     .help=\"Crc for struct\", jsi_IIOF ),\n    JSI_OPT(INT64,  Jsi_StructSpec, flags,   .help=\"Flags for struct\", jsi_IIOF ),\n    JSI_OPT(STRKEY, Jsi_StructSpec, help,    .help=\"Struct description\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec, idx,     .help=\"Number of fields in struct\", jsi_IIRO ),\n    JSI_OPT(STRKEY, Jsi_StructSpec, name,    .help=\"Name of struct\", jsi_IIOF|JSI_OPT_REQUIRED ),\n    JSI_OPT(UINT,   Jsi_StructSpec, size,    .help=\"Size of struct in bytes\", jsi_IIRO ),\n    JSI_OPT(UINT32, Jsi_StructSpec, ssig,    .help=\"Signature for struct\", jsi_IIOF),\n    JSI_OPT(INT64,  Jsi_StructSpec, value,   .help=\"Reference count\", jsi_IIRO ),\n    JSI_OPT_END(Jsi_StructSpec, .help=\"Options for CData struct create\")\n};\n\nstatic Jsi_OptionSpec StructFieldOptions[] =\n{\n    JSI_OPT(UINT,   Jsi_StructSpec,   arrSize,.help=\"Size of field if an array\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec,   bits,   .help=\"Size of bitfield\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec,   boffset,.help=\"Bit offset of field within struct\", jsi_IIRO ),\n    JSI_OPT(INT64,  Jsi_StructSpec,   flags,  .help=\"Flags for field\", jsi_IIOF ),\n    JSI_OPT(UINT32, Jsi_StructSpec,   idx,    .help=\"Index of field in struct\", jsi_IIRO ),\n    JSI_OPT(STRKEY, Jsi_StructSpec,   help,   .help=\"Field description\", jsi_IIOF ),\n    JSI_OPT(STRKEY, Jsi_StructSpec,   info,   .help=\"Info for field\", jsi_IIOF ),\n    JSI_OPT(STRKEY, Jsi_StructSpec,   name,   .help=\"Name of field\", jsi_IIOF|JSI_OPT_REQUIRED ),\n    JSI_OPT(UINT,   Jsi_StructSpec,   offset, .help=\"Offset of field within struct\", jsi_IIRO ),\n    JSI_OPT(UINT,   Jsi_StructSpec,   size,   .help=\"Size of field in struct\", jsi_IIRO ),\n    JSI_OPT(CUSTOM, Jsi_StructSpec,   type,   .help=\"Type of field\", jsi_IIOF|JSI_OPT_REQUIRED, .custom=&jsi_OptSwitchFieldType,  .data=NULL ),\n    JSI_OPT(CUSTOM, Jsi_StructSpec,   init,   .help=\"Initial value for field\", jsi_IIOF|JSI_OPT_PASS2, .custom=&jsi_OptSwitchIniVal, .data=(void*)1  ),\n    JSI_OPT_END(Jsi_StructSpec, .help=\"Options for CData struct field\")\n};\n\nstatic Jsi_RC CDataOptionsConf(Jsi_Interp *interp, Jsi_OptionSpec *specs,  Jsi_Value *args,\n    void *rec, Jsi_Value **ret, int flags, int skipArgs)\n{\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *val;\n    flags |= JSI_OPTS_IS_UPDATE;\n\n    if (argc == skipArgs)\n        return Jsi_OptionsDump(interp, specs, rec, ret, flags);\n    val = Jsi_ValueArrayIndex(interp, args, skipArgs);\n    Jsi_vtype vtyp = Jsi_ValueTypeGet(val);\n    if (vtyp == JSI_VT_STRING) {\n        char *str = Jsi_ValueString(interp, val, NULL);\n        return Jsi_OptionsGet(interp, specs, rec, str, ret, flags);\n    }\n    if (vtyp != JSI_VT_OBJECT && vtyp != JSI_VT_NULL)\n        return Jsi_LogError(\"expected string, object, or null\");\n    if (Jsi_OptionsProcess(interp, specs, rec, val, JSI_OPTS_IS_UPDATE) < 0)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n\n/* Defines: Handles the \"CData.struct.conf\" subcommand */\nstatic Jsi_RC CDataStructConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sl = jsi_csStructGet(interp, arg1);\n    if (!sl)\n        return Jsi_LogError(\"unknown struct: %s\", arg1);\n    return CDataOptionsConf(interp, StructOptions, args, sl, ret, 0, 1);\n}\n\nstatic Jsi_RC CDataStructUndefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *name = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_HashEntry *entry = NULL;\n    if (name)\n        entry = Jsi_HashEntryFind(interp->StructHash, name);\n    if (!entry)\n        return Jsi_LogError(\"Unknown struct: %s\", name);\n    Jsi_StructSpec *sl = (typeof(sl))Jsi_HashValueGet(entry);\n    if (sl->value)\n        return Jsi_LogError(\"Struct in use: %d\", (int)sl->value);\n    Jsi_HashEntryDelete(entry);\n    entry = Jsi_HashEntryFind(interp->CTypeHash, name);\n    if (entry)\n        Jsi_HashEntryDelete(entry);\n    return JSI_OK;\n}\n\n/* Defines: Handles the \"CData.define\" subcommand */\nstatic Jsi_RC CDataStructDefineCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    Jsi_RC rc = JSI_OK;\n    Jsi_OptionTypedef *st = NULL;\n    jsi_csInitType(interp);\n    Jsi_Value *eval = NULL, *val = Jsi_ValueArrayIndex(interp, args, 0),\n        *flds = Jsi_ValueArrayIndex(interp, args, 1);\n    int vlen, flen, i, argc, clen = 0, arrCnt=0;\n    Jsi_DString fStr = {};\n    char **argv = NULL, *cmt, *eq, *cp, *ce, *cpval, ocp;\n    const char *vstr = Jsi_ValueString(interp, val, &vlen),\n        *fstr = Jsi_ValueString(interp, flds, &flen);\n    if (vstr) {\n        cmt = Jsi_Strstr(fstr, \"//\");\n        eq = Jsi_Strchr(fstr, '=');\n        Jsi_DString tStr = {fstr};\n        fstr=jsi_TrimStr(Jsi_DSValue(&tStr));\n        Jsi_SplitStr(fstr, &argc, &argv, (cmt?\"\\n\":\";\"), &fStr);\n        Jsi_DSFree(&tStr);\n        if (!cmt && argc>0 && !argv[argc-1][0])\n            argc--;\n        if (eq) {\n            eval = Jsi_ValueNewArray(interp, NULL, 0);\n            Jsi_IncrRefCount(interp, eval);\n        }\n    } else if (!Jsi_ValueIsArray(interp,flds) || (argc=Jsi_ValueGetLength(interp, flds))<1)\n        return Jsi_LogError(\"arg 2 must be string or non-empty array\");\n    if (argc>200)\n        return Jsi_LogError(\"too many fields: %d>200\", argc);\n    Jsi_StructSpec *sl, *sf, recs[argc+2];\n    memset(recs, 0, sizeof(recs));\n    sl = recs+argc+1;\n    sf = recs;\n    SIGINIT(sl, OPTS_STRUCT);\n    if (vstr) {\n        sl->name = Jsi_KeyAdd(interp, vstr);\n    } else if (Jsi_OptionsProcess(interp, StructOptions, sl, val, 0) < 0) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    if (!Jsi_StrIsAlnum(sl->name)) {\n        rc = Jsi_LogError(\"invalid struct name: %s\", sl->name);\n        goto bail;\n    }\n    if (jsi_csStructGet(interp, sl->name)) {\n        rc = Jsi_LogError(\"struct already exists: %s\", sl->name);\n        goto bail;\n    }\n    for (i = 0; i<argc; i++) {\n        Jsi_Number numVal = 0;\n        bool bVal, isbitset = 0;\n        Jsi_Value *inival = NULL;\n        sf = recs+i;\n        SIGINIT(sf, OPTS_FIELD);\n        if (!argv) {\n            val = Jsi_ValueArrayIndex(interp, flds, i);\n            if (!val || Jsi_OptionsProcess(interp, StructFieldOptions, sf, val, 0) < 0) {\n                rc = JSI_ERROR;\n                goto bail;\n            }\n            if (!Jsi_StrIsAlnum(sf->name) || !sf->type) {\n                rc = Jsi_LogError(\"invalid struct field name: %s\", sf->name);\n                goto bail;\n            }\n            if (!Jsi_ValueObjLookup(interp, val, \"init\", 0) && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n        } else {\n            if (cmt) {\n                cp = Jsi_Strstr(argv[i], \"//\"); \n                if (cp) {\n                    *cp = 0;\n                    cp += 2;\n                    cp = jsi_TrimStr(cp);\n                    sf->help = Jsi_KeyAdd(interp, cp);\n                }\n                cp = Jsi_Strchr(argv[i], ';'); \n                if (cp) *cp = 0;\n            }\n            cp = Jsi_Strchr(argv[i], '='); \n            if (cp) {\n                if (!eval)\n                    goto bail;\n                *cp++ = 0;\n                cp = jsi_TrimStr(cp);\n                int cplen = Jsi_Strlen(cp);\n                if (cplen>1 && (cp[0] == '\\'' || cp[0] == '\"') && cp[0] == cp[cplen-1]) {\n                    cpval = cp+1;\n                    cp[cplen-1] = 0;\n                    inival = Jsi_ValueNewStringDup(interp, cpval);\n                }\n                else if (Jsi_GetDouble(interp, cp, &numVal) == JSI_OK)\n                    inival = Jsi_ValueNewNumber(interp, numVal);\n                else if (Jsi_GetBool(interp, cp, &bVal) == JSI_OK)\n                    inival = Jsi_ValueNewBoolean(interp, bVal);\n                else\n                    inival = Jsi_ValueNewStringDup(interp, cp);\n            }\n            cp = argv[i];\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && !isspace(*ce)) ce++;\n            ocp = *ce;\n            if (!ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            *ce = 0;\n            sf->type = Jsi_TypeLookup(interp, cp);\n            *ce = ocp;\n            if (!sf->type) {\n                rc = Jsi_LogError(\"unknown type: %s\", argv[i]);\n                goto bail;\n            }\n            if (!inival && (sf->type->flags&jsi_CTYP_STRUCT))\n                inival = Jsi_ValueNewBoolean(interp, true);\n\n            cp = ce+1;\n            while (*cp && isspace(*cp)) cp++;\n            ce = cp;\n            while (*ce && (isalnum(*ce) || *ce == '_')) ce++;\n            ocp = *ce;\n            *ce = 0;\n            if (!*cp) {\n                rc = Jsi_LogError(\"missing or bad struct field name\");\n                goto bail;\n            }\n            sf->name = Jsi_KeyAdd(interp, cp);\n            if (ocp) {\n                ce++;\n                clen = Jsi_Strlen(ce);\n            }\n            if (ocp == '@') {\n                isbitset = 1;\n            } else\n            if (ocp == ':') {\n                int bsiz = -1;\n                if (Jsi_GetInt(interp, ce, &bsiz,10) != JSI_OK || bsiz<=0 || bsiz>64) {\n                    rc = Jsi_LogError(\"bad bit size: %s\", ce);\n                    goto bail;\n                }\n                sf->bits = bsiz;\n            } else if (ocp == '[' && clen>1 && ce[clen-1]==']') {\n                int asiz = -1;\n                ce[clen-1] = 0;\n                if (Jsi_GetInt(interp, ce, &asiz, 10) != JSI_OK || asiz<=0) {\n                    rc = Jsi_LogError(\"bad size: %s\", cp);\n                    goto bail;\n                }\n                sf->arrSize = asiz;\n            } else if (ocp) {\n                rc = Jsi_LogError(\"bad field: %s\", cp);\n                goto bail;\n            }\n            val = NULL;            \n        }\n        if (inival) {\n            Jsi_Value *sval = Jsi_ValueNewObj(interp, NULL);\n            Jsi_ValueInsert(interp, sval, \"init\", inival, 0);\n            Jsi_ValueArraySet(interp, eval, sval, i);\n        }\n        bool isEnum = (sf->type && (sf->type->flags&jsi_CTYP_ENUM));\n        if (isbitset) {\n            if (!isEnum) {\n                rc = Jsi_LogError(\"bitset type is not an enum\");\n                goto bail;\n            }\n            sf->flags |= JSI_OPT_BITSET_ENUM;\n        }\n        if (sf->arrSize) {\n            if (sf->arrSize>interp->maxArrayList) {\n                rc = Jsi_LogError(\"array size too big: %d >= %d\", sf->arrSize, interp->maxArrayList);\n                goto bail;\n            }\n            if (sf->bits || isEnum) {\n                rc = Jsi_LogError(\"array of %s unsupported\", (sf->bits?\"bits\":\"enums\"));\n                goto bail;\n            }\n            arrCnt++;\n        }\n    }\n    recs[argc].id = JSI_OPTION_END;\n    rc = jsi_csSetupStruct(interp, sl, recs, recs, argc, &st, arrCnt);\n    if (rc != JSI_OK || !st) {\n        rc = JSI_ERROR;\n        goto bail;\n    }\n    sl = jsi_csGetStructSpec(st->extData);\n    sf = jsi_csGetFieldSpec(sl->extData);\n    if (vstr)\n        flds = eval;\n    for (i = 0; i<argc && flds; i++) {\n        val = Jsi_ValueArrayIndex(interp, flds, i);\n        if (val && Jsi_OptionsProcess(interp, StructFieldOptions, sf+i, val, JSI_OPT_PASS2) < 0) {\n            rc = JSI_ERROR;\n            goto bail;\n        }\n    }\nbail:\n    if (eval)\n        Jsi_DecrRefCount(interp, eval);\n    Jsi_DSFree(&fStr);\n    if (rc != JSI_OK && st)\n        Jsi_HashEntryDelete(st->hPtr);\n    return rc;\n}\n\n/* Defines: Handles the \"CData.struct.fieldconf\" subcommand */\nstatic Jsi_RC CDataStructFieldConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                                Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_StructSpec *sf, *sl = jsi_csStructGet(interp, arg1);\n    if (!sl)\n        return Jsi_LogError(\"unknown struct: %s\", arg1);\n    char *arg2 = Jsi_ValueArrayIndexToStr(interp, args, 1, NULL);\n    if (!arg2 || !(sf = jsi_csFieldGet(interp, arg2, sl)))\n        return Jsi_LogError(\"unknown field: %s\", arg2);\n    return CDataOptionsConf(interp, StructFieldOptions, args, sf, ret, 0, 2);\n}\n\nstatic Jsi_CmdSpec structCmds[] =\n{\n    {\"add\",       CDataStructDefineCmd, 2, 2, \"options:object|string, fields:array|string\", .help=\"Create a struct: field values same as in fieldconf\", .retType=0, .flags=0, .info=0, .opts=StructOptions},\n    {\"conf\",      CDataStructConfCmd,   1, 2, \"struct:string, options:object|string=void\", .help=\"Configure options for struct\", .retType=0, .flags=0, .info=0, .opts=StructOptions},\n    {\"fieldconf\", CDataStructFieldConfCmd,2,3,\"struct:string, field:string, options:object|string=void\", .help=\"Configure options for fields\", .retType=0, .flags=0, .info=0, .opts=StructFieldOptions},\n    {\"get\",       CDataStructGetCmd,    1, 2, \"struct, options:object=void\", .help=\"Return the struct definition\", .retType=(uint)JSI_TT_OBJECT},\n    {\"names\",     CDataStructNamesCmd,  0, 1, \"struct:string=void\", .help=\"Return name list of all structs, or fields for one struct\", .retType=(uint)JSI_TT_ARRAY},\n    {\"remove\",    CDataStructUndefineCmd,1, 1, \"name:string\",.help=\"Remove a struct\", .retType=0, .flags=0, .info=0, .opts=0},\n    {\"schema\",    CDataStructSchemaCmd, 1, 1, \"\", .help=\"Return database schema for struct\", .retType=(uint)JSI_TT_STRING },\n    { NULL,   0,0,0,0, .help=\"Struct commands. Note: Struct() is a shortcut for Struct.add()\" }\n};\n\n\n\nstatic Jsi_RC jsi_csGetKey(Jsi_Interp *interp, CDataObj *cd, Jsi_Value *arg, void **kPtr, size_t ksize, int anum)\n{\n    void *kBuf = *kPtr;\n    *kPtr = NULL;\n    if (!arg)\n        return Jsi_LogError(\"missing key arg\");;\n    Jsi_Number nval = 0;\n    switch (cd->keyType) {\n        case JSI_KEYS_STRING:\n        case JSI_KEYS_STRINGKEY:\n            *kPtr = (void*)Jsi_ValueString(interp, arg, NULL);\n            if (!*kPtr)\n                return Jsi_LogError(\"arg %d: expected string key\", anum);\n            break;\n        case JSI_KEYS_ONEWORD:\n            if (Jsi_ValueGetNumber(interp, arg, &nval) != JSI_OK)\n                return Jsi_LogError(\"arg %d: expected number key\", anum);\n            *kPtr = (void*)(uintptr_t)nval;\n            break;\n        default: {\n            if (!cd->slKey) {\nbadkey:\n                return Jsi_LogError(\"arg %d: expected struct key\", anum);\n            }\n            if (arg->vt == JSI_VT_OBJECT && arg->d.obj->ot == JSI_OT_OBJECT) {\n                if (cd->slKey->size>ksize || !kBuf)\n                    goto badkey;\n                memset(kBuf, 0, cd->slKey->size);\n                if (Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->keysf, kBuf, arg, NULL, 0) != JSI_OK)\n                    return JSI_ERROR;\n                *kPtr = kBuf;\n            } else\n                return Jsi_LogError(\"arg %d: expected object key\", anum);\n        }\n    }\n    return JSI_OK;\n}\n\n#define FN_dataGetN JSI_INFO(\"If given a name argument, gets data for the named field. \\\nOtherwise gets data for all fields in struct.\")\nstatic Jsi_RC CDataGetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    uchar *dptr = NULL;\n    Jsi_Value *karg = Jsi_ValueArrayIndex(interp, args, 0);\n    char kbuf[BUFSIZ];\n    void *key = kbuf;\n    bool isNull = (!karg || Jsi_ValueIsNull(interp, karg));\n    if (isNull) {\n        if (cd->mapPtr || cd->arrSize>1)\n            return Jsi_LogError(\"null key used with c-array/map\");\n    } else {\n        if (!cd->mapPtr && cd->arrSize<=0)\n            return Jsi_LogError(\"must be array/map\");\n        if (JSI_OK != jsi_csGetKey(interp, cd, karg, &key, sizeof(kbuf), 1))\n        return JSI_ERROR;\n    }\n\n    dptr = (uchar*)cd->data;\n    if (isNull) {\n    } else if (cd->mapPtr) {\n        Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);\n        if (mPtr)\n            dptr = (uchar*)Jsi_MapValueGet(mPtr);\n        else\n            return Jsi_LogError(\"arg 1: key not found [%s]\", Jsi_ValueToString(interp, karg, NULL));\n    } /*else if (!cd->arrSize)\n        return Jsi_LogError(\"arg 2: expected a c-array or map\");*/\n    else {\n        uint kind = (intptr_t)key;\n        if (kind>=cd->arrSize)\n            return Jsi_LogError(\"array index out of bounds: %d not in 0,%d\", kind, cd->arrSize-1);\n\n        dptr = ((uchar*)cd->data) + cd->sl->size*kind;\n        if (cd->isPtrs)\n            dptr = ((uchar*)cd->data) + sizeof(void*)*kind;\n        else if (cd->isPtr2) {\n            dptr = (uchar*)(*(void**)dptr);\n            dptr += sizeof(void*)*kind;\n        }\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc > 2)\n        return Jsi_LogError(\"expected 0 - 2 args\");\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);\n    return Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, dptr, arg2, ret, 0);\n}\n\n#define FN_dataSet JSI_INFO(\"Sets data value for given a name argument.\")\nstatic Jsi_RC CDataSetCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    UdcGet(cd, _this, funcPtr);\n    uchar *dptr = NULL;\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n    char kbuf[BUFSIZ];\n    void *key = kbuf;\n    bool isNull = Jsi_ValueIsNull(interp, arg);\n    if (isNull) {\n        if (cd->mapPtr || cd->arrSize)\n            return Jsi_LogError(\"null key used with c-array/map\");\n    } else {\n        if (!cd->mapPtr && cd->arrSize<=0)\n            return Jsi_LogError(\"must be array/map\");\n        if (JSI_OK != jsi_csGetKey(interp, cd, arg, &key, sizeof(kbuf), 1))\n            return JSI_ERROR;\n    }\n\n    dptr = (uchar*)cd->data;\n    if (isNull) {\n    } else if (cd->mapPtr) {\n        Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);\n        if (mPtr)\n            dptr = (uchar*)Jsi_MapValueGet(mPtr);\n        else {\n            bool isNew;\n            if (cd->maxSize && Jsi_MapSize(*cd->mapPtr)>=cd->maxSize)\n                return Jsi_LogError(\"map would exceeded maxSize: %d\", cd->maxSize);\n            if (!cd->noAuto)\n                mPtr = Jsi_MapEntryNew(*cd->mapPtr, key, &isNew);\n            if (!mPtr)\n                return Jsi_LogError(\"arg 1: key not found [%s]\", Jsi_ValueToString(interp, arg, NULL));\n            Jsi_StructSpec *sl = cd->sl;\n            dptr = (uchar*)Jsi_Calloc(1, sl->size);\n            Jsi_MapValueSet(mPtr, dptr);\n            jsi_csStructInit(sl, dptr);\n        }\n    } else if (!cd->arrSize)\n        return Jsi_LogError(\"expected a c-array or map\");\n    else {\n        uint kind = (uintptr_t)key;\n        if (kind>=cd->arrSize)\n            return Jsi_LogError(\"array index out of bounds: %d not in 0,%d\", kind, cd->arrSize-1);\n        dptr = ((uchar*)cd->data) + cd->sl->size*kind;\n        if (cd->isPtrs)\n            dptr = ((uchar*)cd->data) + sizeof(void*)*kind;\n        else if (cd->isPtr2)\n            dptr = (uchar*)(*(void**)dptr) + sizeof(void*)*kind;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 1);\n    if (op == 2 && argc == 2) {\n    } else if (argc == 2) {\n        if (!Jsi_ValueIsObjType(interp, arg2, JSI_OT_OBJECT))\n            return Jsi_LogError(\"arg 3: last must be an object with 3 args\");\n        return Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, dptr, arg2, ret, 0);\n    } else if (argc != 3)\n        return Jsi_LogError(\"expected 2 or 3 args\");\n    const char *cp;\n    if (!(cp = Jsi_ValueString(interp, arg2, NULL)))\n        return Jsi_LogError(\"with 3 args, string expected for arg 2\");\n    Jsi_Value *arg3 = Jsi_ValueArrayIndex(interp, args, 2);\n    if (op == 2) {\n        if (arg3) {\n            if (!Jsi_ValueIsNumber(interp, arg3))\n                return Jsi_LogError(\"expected number\");\n        } else {\n            arg3 = Jsi_ValueNewNumber(interp, 1);\n            Jsi_IncrRefCount(interp, arg3);\n        }\n    }\n    Jsi_RC rc = Jsi_OptionsSet(interp, (Jsi_OptionSpec*)cd->sf, dptr, cp, arg3, (op==2?JSI_OPTS_INCR:0));\n    if (op==2 && argc==2)\n        Jsi_DecrRefCount(interp, arg3);\n    if (op == 2 && rc == JSI_OK) {\n        if (interp->strict && Jsi_NumberIsNaN(interp->cdataIncrVal))\n            return Jsi_LogError(\"result is NaN\");\n        Jsi_ValueMakeNumber(interp, ret, interp->cdataIncrVal);\n    }\n    return rc;\n}\n\nstatic Jsi_RC CDataSetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return CDataSetCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC CDataIncrCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                             Jsi_Value **ret, Jsi_Func *funcPtr) {\n    return CDataSetCmd_(interp, args, _this, ret, funcPtr, 2);\n}\n\nstatic Jsi_RC CDataInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    Jsi_StructSpec *sl = cd->sl;\n    Jsi_DString dStr= {};\n    const char *sptr = Jsi_DSPrintf(&dStr, \"{struct:\\\"%s\\\", label:\\\"%s\\\"}\", sl->name, cd->help?cd->help:\"\");\n    Jsi_RC rc = JSI_ERROR;\n    if (!sptr)\n        return Jsi_LogError(\"format failed\");\n    else\n        rc = Jsi_JSONParse(interp, sptr, ret, 0);\n    Jsi_DSFree(&dStr);\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_Obj *sobj;\n    Jsi_Value *svalue;\n    if (cd->sf) {\n        sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj,(Jsi_OptionSpec*) cd->sf);\n        sobj = (*ret)->d.obj;\n        Jsi_ObjInsert(interp, sobj, \"spec\", svalue, 0);\n    }\n    if (cd->slKey) {\n        sobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n        svalue = Jsi_ValueMakeObject(interp, NULL, sobj);\n        jsi_DumpOptionSpecs(interp, sobj, (Jsi_OptionSpec*)cd->slKey);\n        sobj = (*ret)->d.obj;\n        Jsi_ObjInsert(interp, sobj, \"keySpec\", svalue, 0);\n    }    return JSI_OK;\n}\n\n\nconst char *csMapTypeStrs[] = { \"none\", \"hash\", \"tree\",  \"list\", NULL };\nconst char *csKeyTypeStrs[] = { \"string\", \"strkey\", \"number\",  NULL };\n\nstatic Jsi_OptionSpec CDataOptions[] = {\n    JSI_OPT(UINT,     CDataObj, arrSize, .help=\"If an array, its size in elements\", jsi_IIOF ),\n    JSI_OPT(UINT,     CDataObj, flags,   .help=\"Flags\", jsi_IIOF|JSI_OPT_FMT_HEX ),\n    JSI_OPT(STRKEY,   CDataObj, help,    .help=\"Description of data\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   CDataObj, keyName, .help=\"Key struct, for key struct maps\", jsi_IIOF ),\n    JSI_OPT(CUSTOM,   CDataObj, keyType, .help=\"Key id\", jsi_IIOF|JSI_OPT_COERCE, .custom=Jsi_Opt_SwitchEnum, .data=csKeyTypeStrs),\n    JSI_OPT(CUSTOM,   CDataObj, mapType, .help=\"If a map, its type\", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=csMapTypeStrs),\n    JSI_OPT(UINT,     CDataObj, maxSize, .help=\"Limit the array size or number of keys in a map\" ),\n    JSI_OPT(STRKEY,   CDataObj, name,    .help=\"Name (eg. of var assigned to on create)\", jsi_IIOF ),\n    JSI_OPT(BOOL,     CDataObj, noAuto,  .help=\"Disable auto-create of map keys in set/incr\"),\n    JSI_OPT(STRKEY,   CDataObj, structName,  .help=\"Struct used for storing data\", jsi_IIOF|JSI_OPT_REQUIRED ),\n    JSI_OPT(INT64,    CDataObj, user,    .help=\"User data\" ),\n    JSI_OPT(STRKEY,   CDataObj, varParam,.help=\"Param for maps/array vars\", jsi_IIOF ),\n    JSI_OPT_END(CDataObj, .help=\"Options for CData named\")\n};\n\n\nstatic bool jsi_csBitSetGet(int isSet, uchar *tbuf, int bits, Jsi_UWide *valPtr) {\n    union bitfield *bms = (union bitfield *)tbuf;\n    Jsi_UWide val = *valPtr;\n    union bitfield {\n        Jsi_UWide b1:1; Jsi_UWide b2:2; Jsi_UWide b3:3; Jsi_UWide b4:4; Jsi_UWide b5:5; Jsi_UWide b6:6;\n        Jsi_UWide b7:7; Jsi_UWide b8:8; Jsi_UWide b9:9; Jsi_UWide b10:10; Jsi_UWide b11:11; Jsi_UWide b12:12;\n        Jsi_UWide b13:13; Jsi_UWide b14:14; Jsi_UWide b15:15; Jsi_UWide b16:16; Jsi_UWide b17:17; \n        Jsi_UWide b18:18; Jsi_UWide b19:19; Jsi_UWide b20:20; Jsi_UWide b21:21; Jsi_UWide b22:22;\n        Jsi_UWide b23:23; Jsi_UWide b24:24; Jsi_UWide b25:25; Jsi_UWide b26:26; Jsi_UWide b27:27;\n        Jsi_UWide b28:28; Jsi_UWide b29:29; Jsi_UWide b30:30; Jsi_UWide b31:31; Jsi_UWide b32:32;\n        Jsi_UWide b33:33; Jsi_UWide b34:34; Jsi_UWide b35:35; Jsi_UWide b36:36; Jsi_UWide b37:37;\n        Jsi_UWide b38:38; Jsi_UWide b39:39; Jsi_UWide b40:40; Jsi_UWide b41:41; Jsi_UWide b42:42;\n        Jsi_UWide b43:43; Jsi_UWide b44:44; Jsi_UWide b45:45; Jsi_UWide b46:46; Jsi_UWide b47:47;\n        Jsi_UWide b48:48; Jsi_UWide b49:49; Jsi_UWide b50:50; Jsi_UWide b51:51; Jsi_UWide b52:52;\n        Jsi_UWide b53:53; Jsi_UWide b54:54; Jsi_UWide b55:55; Jsi_UWide b56:56; Jsi_UWide b57:57;\n        Jsi_UWide b58:58; Jsi_UWide b59:59; Jsi_UWide b60:60; Jsi_UWide b61:61; Jsi_UWide b62:62;\n        Jsi_UWide b63:63; Jsi_UWide b64:64;\n    };\n    if (isSet) {\n        switch (bits) {\n    #define CBSN(n) \\\n            case n: bms->b##n = val; return (bms->b##n == val)\n           CBSN(1); CBSN(2); CBSN(3); CBSN(4); CBSN(5); CBSN(6); CBSN(7); CBSN(8);\n           CBSN(9); CBSN(10); CBSN(11); CBSN(12); CBSN(13); CBSN(14); CBSN(15); CBSN(16);\n           CBSN(17); CBSN(18); CBSN(19); CBSN(20); CBSN(21); CBSN(22); CBSN(23); CBSN(24);\n           CBSN(25); CBSN(26); CBSN(27); CBSN(28); CBSN(29); CBSN(30); CBSN(31); CBSN(32);\n           CBSN(33); CBSN(34); CBSN(35); CBSN(36); CBSN(37); CBSN(38); CBSN(39); CBSN(40);\n           CBSN(41); CBSN(42); CBSN(43); CBSN(44); CBSN(45); CBSN(46); CBSN(47); CBSN(48);\n           CBSN(49); CBSN(50); CBSN(51); CBSN(52); CBSN(53); CBSN(54); CBSN(55); CBSN(56);\n           CBSN(57); CBSN(58); CBSN(59); CBSN(60); CBSN(61); CBSN(62); CBSN(63); CBSN(64);\n        }\n        assert(0);\n    }\n    switch (bits) {\n#define CBGN(n) \\\n        case n: val = bms->b##n; break\n       CBGN(1); CBGN(2); CBGN(3); CBGN(4); CBGN(5); CBGN(6); CBGN(7); CBGN(8);\n       CBGN(9); CBGN(10); CBGN(11); CBGN(12); CBGN(13); CBGN(14); CBGN(15); CBGN(16);\n       CBGN(17); CBGN(18); CBGN(19); CBGN(20); CBGN(21); CBGN(22); CBGN(23); CBGN(24);\n       CBGN(25); CBGN(26); CBGN(27); CBGN(28); CBGN(29); CBGN(30); CBGN(31); CBGN(32);\n       CBGN(33); CBGN(34); CBGN(35); CBGN(36); CBGN(37); CBGN(38); CBGN(39); CBGN(40);\n       CBGN(41); CBGN(42); CBGN(43); CBGN(44); CBGN(45); CBGN(46); CBGN(47); CBGN(48);\n       CBGN(49); CBGN(50); CBGN(51); CBGN(52); CBGN(53); CBGN(54); CBGN(55); CBGN(56);\n       CBGN(57); CBGN(58); CBGN(59); CBGN(60); CBGN(61); CBGN(62); CBGN(63); CBGN(64);\n       default: assert(0);\n    }\n    *valPtr = val;\n    return 1;\n}\n\nstatic bool jsi_csSBitSetGet(int isSet, uchar *tbuf, int bits, Jsi_Wide *valPtr) {\n    union bitfield *bms = (union bitfield *)tbuf;\n    Jsi_Wide val = *valPtr;\n    union bitfield {\n        Jsi_Wide b1:1; Jsi_Wide b2:2; Jsi_Wide b3:3; Jsi_Wide b4:4; Jsi_Wide b5:5; Jsi_Wide b6:6;\n        Jsi_Wide b7:7; Jsi_Wide b8:8; Jsi_Wide b9:9; Jsi_Wide b10:10; Jsi_Wide b11:11; Jsi_Wide b12:12;\n        Jsi_Wide b13:13; Jsi_Wide b14:14; Jsi_Wide b15:15; Jsi_Wide b16:16; Jsi_Wide b17:17; \n        Jsi_Wide b18:18; Jsi_Wide b19:19; Jsi_Wide b20:20; Jsi_Wide b21:21; Jsi_Wide b22:22;\n        Jsi_Wide b23:23; Jsi_Wide b24:24; Jsi_Wide b25:25; Jsi_Wide b26:26; Jsi_Wide b27:27;\n        Jsi_Wide b28:28; Jsi_Wide b29:29; Jsi_Wide b30:30; Jsi_Wide b31:31; Jsi_Wide b32:32;\n        Jsi_Wide b33:33; Jsi_Wide b34:34; Jsi_Wide b35:35; Jsi_Wide b36:36; Jsi_Wide b37:37;\n        Jsi_Wide b38:38; Jsi_Wide b39:39; Jsi_Wide b40:40; Jsi_Wide b41:41; Jsi_Wide b42:42;\n        Jsi_Wide b43:43; Jsi_Wide b44:44; Jsi_Wide b45:45; Jsi_Wide b46:46; Jsi_Wide b47:47;\n        Jsi_Wide b48:48; Jsi_Wide b49:49; Jsi_Wide b50:50; Jsi_Wide b51:51; Jsi_Wide b52:52;\n        Jsi_Wide b53:53; Jsi_Wide b54:54; Jsi_Wide b55:55; Jsi_Wide b56:56; Jsi_Wide b57:57;\n        Jsi_Wide b58:58; Jsi_Wide b59:59; Jsi_Wide b60:60; Jsi_Wide b61:61; Jsi_Wide b62:62;\n        Jsi_Wide b63:63; Jsi_Wide b64:64;\n    };\n    if (isSet) {\n        switch (bits) {\n           CBSN(1); CBSN(2); CBSN(3); CBSN(4); CBSN(5); CBSN(6); CBSN(7); CBSN(8);\n           CBSN(9); CBSN(10); CBSN(11); CBSN(12); CBSN(13); CBSN(14); CBSN(15); CBSN(16);\n           CBSN(17); CBSN(18); CBSN(19); CBSN(20); CBSN(21); CBSN(22); CBSN(23); CBSN(24);\n           CBSN(25); CBSN(26); CBSN(27); CBSN(28); CBSN(29); CBSN(30); CBSN(31); CBSN(32);\n           CBSN(33); CBSN(34); CBSN(35); CBSN(36); CBSN(37); CBSN(38); CBSN(39); CBSN(40);\n           CBSN(41); CBSN(42); CBSN(43); CBSN(44); CBSN(45); CBSN(46); CBSN(47); CBSN(48);\n           CBSN(49); CBSN(50); CBSN(51); CBSN(52); CBSN(53); CBSN(54); CBSN(55); CBSN(56);\n           CBSN(57); CBSN(58); CBSN(59); CBSN(60); CBSN(61); CBSN(62); CBSN(63); CBSN(64);\n        }\n        assert(0);\n    }\n    switch (bits) {\n       CBGN(1); CBGN(2); CBGN(3); CBGN(4); CBGN(5); CBGN(6); CBGN(7); CBGN(8);\n       CBGN(9); CBGN(10); CBGN(11); CBGN(12); CBGN(13); CBGN(14); CBGN(15); CBGN(16);\n       CBGN(17); CBGN(18); CBGN(19); CBGN(20); CBGN(21); CBGN(22); CBGN(23); CBGN(24);\n       CBGN(25); CBGN(26); CBGN(27); CBGN(28); CBGN(29); CBGN(30); CBGN(31); CBGN(32);\n       CBGN(33); CBGN(34); CBGN(35); CBGN(36); CBGN(37); CBGN(38); CBGN(39); CBGN(40);\n       CBGN(41); CBGN(42); CBGN(43); CBGN(44); CBGN(45); CBGN(46); CBGN(47); CBGN(48);\n       CBGN(49); CBGN(50); CBGN(51); CBGN(52); CBGN(53); CBGN(54); CBGN(55); CBGN(56);\n       CBGN(57); CBGN(58); CBGN(59); CBGN(60); CBGN(61); CBGN(62); CBGN(63); CBGN(64);\n       default: assert(0);\n    }\n    *valPtr = val;\n    return 1;\n}\n\nstatic Jsi_RC jsi_csSBitGetSet(Jsi_Interp *interp, void *vrec,  Jsi_Wide* vPtr, Jsi_OptionSpec *spec, int idx, bool isSet) {\n    Jsi_Wide *valPtr = (typeof(valPtr))vPtr;\n    int bits = spec->bits;\n    int boffs = spec->boffset;\n    if (bits<1 || bits>=64) return JSI_ERROR;\n    int ofs = (boffs/8);\n    int bo = (boffs%8); // 0 if byte-aligned\n    int Bsz = ((bits+bo+7)/8);\n    uchar *rec = (uchar*)vrec;\n#ifdef __SIZEOF_INT128__\n    typedef __int128 stvalType;\n#else\n    typedef Jsi_Wide stvalType;\n#endif\n    stvalType tbuf[2] = {};\n    uchar sbuf[20], *bptr = (uchar*)tbuf;\n    memcpy(tbuf, rec+ofs, Bsz);\n    Jsi_Wide mval = *valPtr;\n    Jsi_Wide amask = ((1LL<<(bits-1))-1LL);\n    stvalType tval = 0, kval = 0, lmask;\n    if (bo) { // If not byte aligned, get tval and shift\n        bptr = sbuf;\n        kval = tval = *(typeof(tval)*)tbuf;\n        tval >>= bo;\n        if (!isSet) {\n            mval = (Jsi_Wide)tval;\n            *(Jsi_Wide*)bptr = mval;\n        }\n    }\n        \n    if (!isSet) { // Get value.\n        if (!jsi_csSBitSetGet(0, bptr, bits, &mval))\n            return JSI_ERROR;\n        *valPtr = mval;\n        return JSI_OK;\n    }\n    \n    if (!jsi_csSBitSetGet(1, bptr, bits, &mval))\n        return JSI_ERROR;\n    if (bo) {\n        tval = (typeof(tval))mval;\n        lmask=(amask<<bo);\n        kval &= ~lmask;\n        tval <<= bo;\n        tval = (kval | tval);\n        *(typeof(tval)*)tbuf = tval;\n    }\n    memcpy(rec+ofs, tbuf, Bsz);\n\n    return JSI_OK;    \n}\n\nstatic Jsi_RC jsi_csBitGetSet(Jsi_Interp *interp, void *vrec,  Jsi_Wide* vPtr, Jsi_OptionSpec *spec, int idx, bool isSet) {\n    bool us = (spec->tname && spec->tname[0] == 'u');\n    if (!us)        \n        return jsi_csSBitGetSet(interp, vrec, vPtr, spec, idx, isSet);\n\n    if (*vPtr<0)\n        return JSI_ERROR;\n\n    Jsi_UWide *valPtr = (typeof(valPtr))vPtr;\n    int bits = spec->bits;\n    int boffs = spec->boffset;\n    if (bits<1 || bits>=64) return JSI_ERROR;\n    int ofs = (boffs/8);\n    int bo = (boffs%8); // 0 if byte-aligned\n    int Bsz = ((bits+bo+7)/8);\n    uchar *rec = (uchar*)vrec;\n#ifdef __SIZEOF_INT128__\n    typedef unsigned __int128 utvalType;\n#else\n    typedef Jsi_UWide utvalType;\n#endif\n    utvalType tbuf[2] = {};\n    uchar sbuf[20], *bptr = (uchar*)tbuf;\n    memcpy(tbuf, rec+ofs, Bsz);\n    Jsi_UWide mval;\n    Jsi_UWide amask = ((1LL<<(bits-1))-1LL);\n    utvalType tval = 0, kval = 0, lmask;\n    if (bo) { // If not byte aligned, get tval and shift\n        bptr = sbuf;\n        kval = tval = *(typeof(tval)*)tbuf;\n        tval >>= bo;\n        if (!isSet) {\n            mval = (Jsi_UWide)tval;\n            *(Jsi_UWide*)bptr = mval;\n        }\n    } else\n         mval = *valPtr;\n        \n    if (!isSet) { // Get value.\n        if (!jsi_csBitSetGet(0, bptr, bits, &mval))\n            return JSI_ERROR;\n        *valPtr = mval;\n        return JSI_OK;\n    }\n    \n    if (!jsi_csBitSetGet(1, bptr, bits, &mval))\n        return JSI_ERROR;\n    if (bo) {\n        tval = (typeof(tval))mval;\n        lmask=(amask<<bo);\n        kval &= ~lmask;\n        tval <<= bo;\n        tval = (kval | tval);\n        *(typeof(tval)*)tbuf = tval;\n    }\n    memcpy(rec+ofs, tbuf, Bsz);\n\n    return JSI_OK;    \n}\n\nstatic Jsi_RC CDataConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    return CDataOptionsConf(interp, CDataOptions, args, cd, ret, 0, 0);\n}\n \nstatic Jsi_RC CDataNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr) {\n    UdcGet(cd, _this, funcPtr);\n    if (cd->mapType != JSI_MAP_NONE)\n        return Jsi_MapKeysDump(interp, *cd->mapPtr, ret, 0);\n    return Jsi_LogError(\"not a map\");;\n}\n\nstatic Jsi_RC CDataUnsetCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    UdcGet(cd, _this, funcPtr);\n    Jsi_Value *arg2 = Jsi_ValueArrayIndex(interp, args, 0);   \n    char kbuf[BUFSIZ];\n    void *key = kbuf;\n    if (!cd->mapPtr && cd->arrSize<=0)\n        return Jsi_LogError(\"can not call unset on non map/array\");\n    if (JSI_OK != jsi_csGetKey(interp, cd, arg2, &key, sizeof(kbuf), 2)) {\n        return JSI_ERROR;\n    }\n    uchar *dptr = NULL;\n    Jsi_MapEntry *mPtr = Jsi_MapEntryFind(*cd->mapPtr, key);\n    if (mPtr)\n        dptr = (uchar*)Jsi_MapValueGet(mPtr);\n    if (!dptr) {\n        if (cd->keyType != JSI_KEYS_ONEWORD)\n            return Jsi_LogError(\"no data in map: %s\", (char*)key);\n        else\n            return Jsi_LogError(\"no data in map: %p\", key);\n        return JSI_ERROR;\n    }\n    Jsi_Free(dptr);\n    Jsi_MapEntryDelete(mPtr);\n    return JSI_OK;\n\n}\n\n#define FN_cdataConstructor JSI_INFO(\"\\\nThe 2nd arg is used for function option parsing and will report errors at the callers file:line\")\nstatic Jsi_RC CDataConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n    \n/* Defines: Handles the \"Data\" subcommand */\nstatic Jsi_CmdSpec cdataCmds[] =\n{\n    {\"CData\",     CDataConstructor,1, 2, \"options:string|object=void, inits:object=undefined\",.help=\"Create a new struct or map/array of structs\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=FN_cdataConstructor, .opts=CDataOptions},\n    {\"conf\",      CDataConfCmd,    0, 1, \"options:object|string=void\",.help=\"Configure options for c-data\", .retType=0, .flags=0, .info=0, .opts=CDataOptions},\n    {\"get\"   ,    CDataGetCmd,     0, 2, \"key:string|number|object=null, field:string=void\", .help=\"Get struct/map/array value\", .retType=(uint)JSI_TT_ANY},\n    {\"incr\",      CDataIncrCmd,    2, 3, \"key:string|number|object|null, field:object|string, value:number=1\", .help=\"Increment a numeric field: returns the new value\", .retType=(uint)JSI_TT_NUMBER},\n    {\"info\",      CDataInfoCmd,    0, 0, \"\", .help=\"Return info for data\", .retType=(uint)JSI_TT_OBJECT},\n    {\"names\",     CDataNamesCmd,   0, 0, \"\", .help=\"Return keys for map\", .retType=(uint)JSI_TT_ARRAY },\n    {\"set\",       CDataSetCmd,     2, 3, \"key:string|number|object|null, field:object|string, value:any=void\", .help=\"Set a struct/map/array value\", .retType=(uint)JSI_TT_ANY},\n    {\"unset\",     CDataUnsetCmd,   1, 1, \"key:string|number|object\", .help=\"Remove entry from map/array\", .retType=(uint)JSI_TT_ANY},\n    {NULL}\n};\n\n\nstatic Jsi_OptionSpec TypeOptions[] = {\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, idName,  .help=\"The id name: usually upcased cName\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, cName,   .help=\"C type name\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, help,    .help=\"Description of id\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, fmt,     .help=\"Printf format for id\", jsi_IIOF ),\n    JSI_OPT(STRKEY,   Jsi_OptionTypedef, xfmt,    .help=\"Hex printf format for id\", jsi_IIOF ),\n    JSI_OPT(INT64,    Jsi_OptionTypedef, flags,   .help=\"Flags for id\", jsi_IIOF ),\n    JSI_OPT(INT,      Jsi_OptionTypedef, size,    .help=\"Size for id\", jsi_IIOF ),\n    JSI_OPT(INT64,    Jsi_OptionTypedef, user,    .help=\"User data\" ),\n    JSI_OPT_END(Jsi_OptionTypedef, .help=\"Options for CData id\")\n};\n\nstatic Jsi_RC CDataTypeConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    char *arg1 = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_OptionTypedef *nd = NULL;\n    jsi_csInitType(interp);\n    if (arg1)\n        nd = (typeof(nd))Jsi_TypeLookup(interp, arg1);\n    if (!nd)\n        return Jsi_LogError(\"Unknown type: %s\", arg1);\n    return CDataOptionsConf(interp, TypeOptions, args, nd, ret, 0, 1);\n}\n\nstatic Jsi_RC CDataTypeNamesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n                              Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    \n    jsi_csInitType(interp);\n    int argc = Jsi_ValueGetLength(interp, args);\n    return Jsi_HashKeysDump(interp, (argc?interp->CTypeHash:interp->TYPEHash), ret, 0);\n}\n\n/* Defines: Handles the \"Type\" subcommand */\nstatic Jsi_CmdSpec typeCmds[] =\n{\n    {\"conf\",      CDataTypeConfCmd,    1, 2, \"typ:string, options:object|string=void\",.help=\"Configure options for type\", .retType=0, .flags=0, .info=0, .opts=TypeOptions},\n    {\"names\",     CDataTypeNamesCmd,   0, 1, \"ctype=false\", .help=\"Return type names\", .retType=(uint)JSI_TT_ARRAY},\n    { NULL,   0,0,0,0, .help=\"Type commands. Note: Type() is a shortcut for Type.conf()\" }\n};\n\nstatic Jsi_RC jsi_csTypeFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_OptionTypedef *type = jsi_csGetTypeSpec(ptr);\n    if (type->extData && (type->flags&(jsi_CTYP_ENUM|jsi_CTYP_STRUCT)))\n        ((Jsi_OptionSpec*)(type->extData))->value--;\n    if (type->flags&jsi_CTYP_DYN_MEMORY)\n        Jsi_Free(ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_csMapFree(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_Free(ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_csObjFree(Jsi_Interp *interp, void *data)\n{\n    CDataObj *cd = (CDataObj *)data;\n    cd->sl->value--;\n    if (cd->slKey)\n        cd->slKey->value--;\n    if (cd->isAlloc) {\n        if (cd->mapPtr && *cd->mapPtr) {\n            Jsi_MapDelete(*cd->mapPtr);\n            *cd->mapPtr = NULL;\n        }\n        else if (cd->data) Jsi_Free(cd->data);\n    }\n    Jsi_Free(cd);\n    return JSI_OK;\n}\n\nstatic bool jsi_csObjIsTrue(void *data)\n{\n    CDataObj *fo = (CDataObj *)data;\n    if (!fo->fobj) return JSI_OK;\n    else return 1;\n}\n\nstatic bool jsi_csObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\nstatic Jsi_UserObjReg cdataobject = {\n    \"CData\",\n    cdataCmds,\n    jsi_csObjFree,\n    jsi_csObjIsTrue,\n    jsi_csObjEqual\n};\n\nstatic Jsi_RC jsi_csNewCData(Jsi_Interp *interp, CDataObj *cd, int flags) {\n\n    Jsi_StructSpec *slKey = NULL, *keySpec = NULL, *sf = cd->sf, *sl = cd->sl;\n    \n    if (!sf)\n        cd->sf = sf = jsi_csStructFields(interp, cd->structName);\n    if (!sl)\n        sl = cd->sl = Jsi_CDataStruct(interp, cd->structName);\n    if (!sf)\n        return Jsi_LogError(\"missing struct/fields: %s\", cd->structName);\n    \n    if (cd->keyName) {\n        slKey = keySpec = Jsi_CDataStruct(interp, cd->keyName);\n        if (slKey == NULL)\n            return Jsi_LogError(\"unknown key struct: %s\", cd->keyName);\n    }\n\n    const char *vparm = cd->varParam;\n    if (vparm && vparm[0]) {\n        char parm[200] = {}, *parms=parm, *ep;\n        int plen = Jsi_Strlen(vparm);\n        if (plen>=2 && vparm[0] == '[' && vparm[plen-1]==']') {\n            snprintf(parm, sizeof(parm), \"%.*s\", plen-2, vparm+1);\n            int sz = 0;\n            if (parm[0] && isdigit(parm[0])) {\n                sz=strtoul(parm, &ep, 0);\n                if (*ep || sz<=0)\n                    return Jsi_LogError(\"bad array size: %s\", vparm);\n                cd->arrSize = sz;\n            } else {\n                Jsi_EnumSpec *ei = (typeof(ei))Jsi_HashGet(interp->EnumItemHash, parm, 0);\n                if (!ei || (sz=ei->value)<=0)\n                    return Jsi_LogError(\"bad array enum: %s\", vparm);\n            }\n            \n        } else if (plen>=2 && vparm[0] == '{' && vparm[plen-1]=='}') {\n            snprintf(parm, sizeof(parm), \"%.*s\", plen-2, vparm+1);\n            cd->mapType = JSI_MAP_TREE;\n            if (parms[0]) {\n                const char *ktn = NULL;\n                if (*parms == '#') {\n                     cd->mapType = JSI_MAP_HASH;\n                     parms++;\n                }\n                if (*parms == '0') {\n                    cd->keyType = JSI_KEYS_ONEWORD;\n                    if (parms[1])\n                        return Jsi_LogError(\"Trailing junk: %s\", vparm);\n                } else if (parms[0] == '@') {\n                    slKey = Jsi_CDataStruct(interp, ktn=(parms+1));\n                    if (!slKey)\n                        return Jsi_LogError(\"unknown key struct: %s\", ktn);\n                    cd->keyName = slKey->name;\n                } else if (parms[0])\n                        return Jsi_LogError(\"Trailing junk: %s\", vparm);\n            }\n\n        } else\n            return Jsi_LogError(\"expected either {} or []: %s\", vparm);\n    \n    }\n    cd->sl->value++;\n \n    if (cd->keyName) {\n        cd->slKey = Jsi_CDataStruct(interp, cd->keyName);\n        if (!cd->slKey)\n            return Jsi_LogError(\"unknown key struct: %s\", cd->keyName);\n        cd->keysf = jsi_csStructFields(interp, cd->keyName);\n        cd->keyType = (Jsi_Key_Type)slKey->size;\n        cd->slKey->value++;\n    }\n    \n    if (cd->arrSize<=0 && cd->mapType != JSI_MAP_NONE) {\n        if (interp->cdataNewVal && interp->cdataNewVal->data)\n            cd->mapPtr = (Jsi_Map**)(interp->cdataNewVal->data);\n        else\n            cd->mapPtr = (Jsi_Map**)&cd->data;\n        cd->isAlloc = 1;\n        *cd->mapPtr = Jsi_MapNew(interp, cd->mapType, cd->keyType, jsi_csMapFree);\n        if (cd->slKey) {\n            Jsi_MapOpts mo;\n            Jsi_MapConf(*cd->mapPtr, &mo, 0);\n            mo.fmtKeyProc = jsi_csFmtKeyCmd;\n            mo.user = (void*)cd;\n            Jsi_MapConf(*cd->mapPtr, &mo, 1);\n        }\n    } else {\n        uint i, sz = (cd->arrSize<=0 ? 1 : cd->arrSize);\n        cd->keyType = JSI_KEYS_ONEWORD;\n        if (interp->cdataNewVal && interp->cdataNewVal->data)\n            cd->data = interp->cdataNewVal->data;\n        else {\n            cd->isAlloc = 1;\n            cd->data = (typeof(cd->data))Jsi_Calloc(sz, cd->sl->size);\n        }\n        for (i=0; i<sz; i++)\n            jsi_csStructInit(sl, (((uchar*)cd->data) + i*cd->sl->size));\n    }\n\n    return JSI_OK;\n}\n\nstatic Jsi_RC CDataConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *that = _this;\n    Jsi_Obj *nobj;\n    \n    if (!Jsi_FunctionIsConstructor(funcPtr)) {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"CData\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        that = *ret;\n    }\n\n    CDataObj *cd = (typeof(cd))Jsi_Calloc(1,sizeof(*cd));\n    cd->interp = interp;\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_vtype vtyp = Jsi_ValueTypeGet(val);\n    int vlen, isNew = 0;\n    const char *vstr = Jsi_ValueString(interp, val, &vlen);\n    Jsi_DString dStr = {};\n    Jsi_Value *ival = Jsi_ValueArrayIndex(interp, args, 1);\n    if (ival && Jsi_ValueIsUndef(interp, ival))\n        ival = NULL;\n    else if (ival && !Jsi_ValueIsObjType(interp, ival, JSI_OT_OBJECT))\n        return Jsi_LogError(\"arg 2: expected object or undef\");\n    if (vstr && vlen) {\n        char ech = 0;\n        const char *nstr = vstr, *cp = vstr;\n        while (*cp && (isalnum(*cp) || *cp=='_')) cp++;\n        if (*cp) {\n            int slen = cp-vstr;\n            Jsi_DString sStr = {};\n            nstr = Jsi_DSAppendLen(&dStr, vstr, slen);\n            if (*cp == '[')\n                ech = ']';\n            else if (*cp == '{')\n                ech = '}';\n            if (!ech || vstr[vlen-1] != ech) {\n                Jsi_LogError(\"malformed var form is not: STRUCT, STRUCT{...}, STRUCT[...]\");\n                goto errout;\n            }\n            //cp++;\n            cd->varParam = Jsi_KeyAdd(interp, Jsi_DSAppendLen(&sStr, cp, vlen-slen));\n        }\n        cd->structName = Jsi_KeyAdd(interp, nstr);\n        val = NULL;\n    } else if (vtyp != JSI_VT_OBJECT) {\n        Jsi_LogError(\"expected string, object\");\n        goto errout;\n    }\n    if (val && Jsi_OptionsProcess(interp, CDataOptions, cd, val, 0) < 0)\n        goto errout;\n\n    if (ival && (cd->mapPtr || cd->arrSize)) {\n        Jsi_LogError(\"init can not be used with c-array/map\");\n        goto errout;\n     }\n  \n    if (JSI_OK != jsi_csNewCData(interp, cd, JSI_OPT_NO_SIG))\n        goto errout;\n\n    if (ival) {\n        interp->callerErr = 1;\n        Jsi_RC rc = Jsi_OptionsConf(interp, (Jsi_OptionSpec*)cd->sf, cd->data, ival, ret, 0);\n        interp->callerErr = 0;\n        if (rc != JSI_OK) {\n            isNew = 1;\n            goto errout;\n        }\n    }\n        \n    nobj = (Jsi_Obj*)Jsi_ValueGetObj(interp, that);\n    cd->objId = Jsi_UserObjNew(interp, &cdataobject, nobj, cd);\n    if (cd->objId<0) {\n        goto errout;\n    }\n    cd->fobj = nobj;\n    return JSI_OK;\n    \nerrout:\n    Jsi_DSFree(&dStr);\n    Jsi_OptionsFree(interp, CDataOptions, cd, 0);\n    if (isNew)\n       jsi_csObjFree(interp, cd);\n    else\n        Jsi_Free(cd);\n    return JSI_ERROR;\n\n}\n\n// Globals\n\nstatic Jsi_RC jsi_DoneCData(Jsi_Interp *interp)\n{\n    if (!interp->SigHash) return JSI_OK;\n    Jsi_HashDelete(interp->SigHash);\n    Jsi_HashDelete(interp->StructHash);\n    Jsi_HashDelete(interp->EnumHash);\n    Jsi_HashDelete(interp->EnumItemHash);\n    Jsi_HashDelete(interp->TYPEHash);\n    Jsi_HashDelete(interp->CTypeHash);\n    return JSI_OK;\n}\n\nJsi_RC jsi_InitCData(Jsi_Interp *interp, int release)\n{\n    if (release) return jsi_DoneCData(interp);\n#if JSI_USE_STUBS\n    if (Jsi_StubsInit(interp, 0) != JSI_OK)\n        return JSI_ERROR;\n#endif\n\n    Jsi_Hash *fsys = Jsi_UserObjRegister(interp, &cdataobject);\n    if (!fsys)\n        return Jsi_LogBug(\"Can not init cdata\");\n\n    interp->SigHash      = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n    interp->StructHash   = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->EnumHash     = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->EnumItemHash = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->CTypeHash    = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_csTypeFree);\n    interp->TYPEHash     = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n\n    Jsi_CommandCreateSpecs(interp, cdataobject.name,  cdataCmds,  fsys, JSI_CMDSPEC_ISOBJ);\n    Jsi_CommandCreateSpecs(interp, \"CEnum\",  enumCmds,   NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"CStruct\",structCmds, NULL, 0);\n    Jsi_CommandCreateSpecs(interp, \"CType\",  typeCmds,   NULL, 0);\n\n    if (Jsi_PkgProvide(interp, cdataobject.name, 1, jsi_InitCData) != JSI_OK)\n        return JSI_ERROR;\n    return JSI_OK;\n}\n\n/* Initialize a struct to default values */\nJsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname)\n{\n    Jsi_StructSpec * sl = jsi_csStructGet(interp, sname);\n    if (!sl)\n        return Jsi_LogError(\"unknown struct: %s\", sname);\n    return jsi_csStructInit(sl, data);\n}\n\nJsi_CDataDb *Jsi_CDataLookup(Jsi_Interp *interp, const char *name) {\n    CDataObj *cd = (typeof(cd))Jsi_UserObjDataFromVar(interp, name);\n    if (!cd)\n        return NULL;\n    return (Jsi_CDataDb*)cd;\n}\n\nJsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics)\n{\n    Jsi_RC rc = JSI_OK;\n    if (statics) {\n        if (interp->statics)\n            statics->nextPtr = interp->statics;\n        interp->statics = statics;\n        jsi_csInitType(interp);\n        jsi_csInitStructTables(interp);\n        jsi_csInitEnum(interp);\n        jsi_csInitEnumItem(interp);\n        rc = jsi_csInitVarDefs(interp);\n    }\n    return rc;\n}\n\n/* Traverse types and match unique substring. */\nJsi_OptionTypedef *Jsi_TypeLookup(Jsi_Interp *interp, const char *name)\n{\n    int isup = 1;\n    const char *cp = name;\n    while (*cp && isup) {\n        if (*cp != '_' && !isdigit(*cp) && !isupper(*cp)) { isup=0; break; }\n        cp++;\n    }\n    Jsi_OptionTypedef *ptr = (typeof(ptr))Jsi_HashGet((isup?interp->TYPEHash:interp->CTypeHash), name, 0);\n    if (ptr)\n        SIGASSERT(ptr, TYPEDEF);\n    return ptr;\n}\n\n#else // JSI_OMIT_CDATA\n\nJsi_CDataDb *Jsi_CDataLookup(Jsi_Interp *interp, const char *name) { return NULL; }\nJsi_RC Jsi_CDataRegister(Jsi_Interp *interp, Jsi_CData_Static *statics) { return JSI_ERROR; }\nJsi_RC Jsi_CDataStructInit(Jsi_Interp *interp, uchar* data, const char *sname) { return JSI_ERROR; }\nJsi_OptionTypedef *Jsi_TypeLookup(Jsi_Interp *interp, const char *name) { return NULL; }\n\n#endif // JSI_OMIT_CDATA\n#endif // JSI_LITE_ONLY\n", "#ifndef __JSIINT_H__\n#define __JSIINT_H__\n\n#ifdef JSI_CONFIG_H_FILE\n#include JSI_CONFIG_H_FILE\n#endif\n\n#if JSI__ALL\n#define JSI__SQLITE 1\n#define JSI__WEBSOCKET 1\n#define JSI__READLINE 1\n#endif\n// Define the defaults\n#ifndef JSI__EVENT\n#define JSI__EVENT 1\n#endif\n#ifndef JSI__DEBUG\n#define JSI__DEBUG 1\n#endif\n#ifndef JSI__LOAD\n#define JSI__LOAD 1\n#endif\n#ifndef JSI__SIGNAL\n#define JSI__SIGNAL 1\n#endif\n#ifndef JSI__FILESYS\n#define JSI__FILESYS 1\n#endif\n#ifndef JSI__ZVFS\n#define JSI__ZVFS 1\n#endif\n#ifndef JSI__STUBS\n#define JSI__STUBS 1\n#endif\n#ifndef JSI__THREADS\n#define JSI__THREADS 1\n#endif\n#ifndef JSI__INFO\n#define JSI__INFO 1\n#endif\n#ifndef JSI__CDATA\n#define JSI__CDATA 1\n#endif\n#ifndef JSI__SOCKET\n#ifndef __WIN32 \n#define JSI__SOCKET 1\n#endif\n#endif\n#ifndef JSI__MATH\n#define JSI__MATH 1\n#endif\n#ifndef JSI__UTF8\n#define JSI__UTF8 1\n#endif\n#ifndef JSI__MINIZ\n#define JSI__MINIZ 1\n#endif\n\n#if (JSI__STUBS!=1)\n#ifndef JSI_OMIT_STUBS\n#define JSI_OMIT_STUBS\n#endif\n#endif\n#if (JSI__THREADS!=1)\n#define JSI_OMIT_THREADS\n#endif\n#if (JSI__SIGNAL!=1)\n#define JSI_OMIT_SIGNAL\n#endif\n\n#if defined(JSI__MD5) && JSI__MD5==0\n#define JSI_OMIT_MD5 1\n#endif\n#if defined(JSI__SHA1) && JSI__SHA1==0\n#define JSI_OMIT_SHA1 1\n#endif\n#if defined(JSI__SHA256) && JSI__SHA256==0\n#define JSI_OMIT_SHA256 1\n#endif\n#if defined(JSI__ENCRYPT) && JSI__ENCRYPT==0\n#define JSI_OMIT_ENCRYPT 1\n#endif\n#if defined(JSI__BASE64) && JSI__BASE64==0\n#define JSI_OMIT_BASE64 1\n#endif\n#if defined(JSI__LOAD) && JSI__LOAD==0\n#define JSI_OMIT_LOAD 1\n#endif\n#if defined(JSI__EVENT) && JSI__EVENT==0\n#define JSI_OMIT_EVENT 1\n#endif\n#if defined(JSI__DEBUG) && JSI__DEBUG==0\n#define JSI_OMIT_DEBUG 1\n#endif\n#if defined(JSI__CDATA) && JSI__CDATA==0\n#define JSI_OMIT_CDATA 1\n#endif\n#if defined(JSI__MATH) && JSI__MATH==0\n#define JSI_OMIT_MATH 1\n#endif\n\n//#define JSI__MEMDEBUG 1\n#if JSI__MEMDEBUG\n#define JSI_MEM_DEBUG\n#define Assert(n) assert(n)\n#else\n#define Assert(n)\n#endif\n#ifndef JSI_OMIT_SIGNATURES\n#define JSI_HAS_SIG\n#endif\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#define __USE_GNU\n#endif\n#define VAL_REFCNT\n#define VAL_REFCNT2\n\n#ifndef JSI_ZVFS_DIR\n#define JSI_ZVFS_DIR \"/zvfs\"\n#endif\n#ifndef JSI_VFS_DIR\n#define JSI_VFS_DIR \"/vfs\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <assert.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <float.h>\n\n#ifdef __WIN32 /* TODO: support windows signal??? */\n#define JSI__MINIZ 1\n#define JSI_OMIT_SIGNAL\n#endif\n\n#if (JSI_VERSION_MAJOR>=10)\n#define JSI_VERFMT_LEN \"6\"\n#else\n#define JSI_VERFMT_LEN \"5\"\n#endif\n\n#ifndef JSI_AMALGAMATION\n\n#if JSI__REGEX\n#include \"regex/regex.h\"\n#else\n#include <regex.h>\n#endif\n#ifdef __WIN32\n#include \"win/compat.h\"\n//#include \"win/regex.h\"\n//#include \"regex/regex.h\"\n#else\n#define JSI__REGCOMP\n#include <sys/time.h>\n#endif\n#endif\n\n#include <time.h>\n\n#ifndef JSI_IS64BIT\n#ifdef __GNUC__\n#ifdef __X86_64__\n#define JSI_IS64BIT 1\n#endif\n#else /* GCC */\n#if _WIN64 || __amd64__\n#define JSI_IS64BIT 1\n#endif\n#endif /* GCC */\n#endif /* JSI_IS64BIT */\n\n#ifndef JSI_IS64BIT\n#define JSI_IS64BIT 0\n#endif\n\n#define JSMN_FREE(p) Jsi_Free(p)\n#define JSMN_MALLOC(l) Jsi_Malloc(l)\n#define JSMN_REALLOC(p,l) Jsi_Realloc(p,l)\n\n#ifndef NDEBUG\n#define SIGASSERTDO(s, ret) assert(s);\n#else\n#define SIGASSERTDO(s, ret) if (!(s)) return ret\n#endif\n#define SIGASSERTRET(s,n,ret) SIGASSERTDO((s) && (s)->sig == (uint)JSI_SIG_##n, ret);\n\n#define JSI_HAS_SIG /* Signatures to help with debugging */\n#ifdef JSI_HAS_SIG\n#ifndef SIGASSERT\n#define SIGASSERTV(s,n) SIGASSERTRET(s, n, /*void*/);\n#define SIGASSERT(s,n) SIGASSERTRET(s, n, JSI_OK);\n#define SIGASSERTMASK(s,n,m) assert((s) && ((s)->sig&(~(m))) == (uint)JSI_SIG_##n);\n#endif\n#define SIGINIT(s,n) (s)->sig = JSI_SIG_##n;\n#define __VALSIG__ .sig=JSI_SIG_VALUE,\n#else\n#define SIGASSERTV(s,n)\n#define SIGASSERT(s,n)\n#define SIGASSERTMASK(s,n,m)\n#define SIGINIT(s,n)\n#define __VALSIG__\n#endif\n\n#ifndef JSI_HAS___PROTO__\n#define JSI_HAS___PROTO__ 1  // Enable setting and getting prototypes. 1=set/get funcs, 2=__proto__ assign.\n#endif\n\n#ifdef NDEBUG\n#define JSI_NOWARN(v) v=v\n#else\n#define JSI_NOWARN(v)\n#endif\n\n#ifdef __FreeBSD__\n#define _JSICASTINT(s) (int)(s)\n#else\n#define _JSICASTINT(s) (s)\n#endif\n\n#ifndef __DBL_DECIMAL_DIG__\n#define __DBL_DECIMAL_DIG__ 17\n#endif\n\n#if 0\n#ifndef uint\ntypedef unsigned int uint;\n#endif\n#ifndef uchar\ntypedef unsigned char uchar;\n#endif\n#endif\n\n#ifndef JSI_AMALGAMATION\n#include \"jsi.h\"\n#else\n//#define JSI_OMIT_STUBS\n#endif\n\n#define ALLOC_MOD_SIZE 16      /* Increase allocs by increments of 16. */\n#define MAX_ARRAY_LIST 100000  /* Default Max size of an array convertable to list form */\n#define MAX_LOOP_COUNT 10000000 /* Limit infinite loops */\n#define JSI_MAX_ALLOC_BUF  100000000 /* Limit for dynamic memory allocation hunk */\n#define JSI_MAX_SCOPE (JSI_BUFSIZ/2)\ntypedef enum {\n    JSI_SIG_ITEROBJ=0xdeadbaa0, JSI_SIG_FUNCOBJ, JSI_SIG_SCOPE, JSI_SIG_VALUE,\n    JSI_SIG_OBJ, JSI_SIG_USERDATA, JSI_SIG_INTERP, JSI_SIG_PARSER,\n    JSI_SIG_FILEOBJ, JSI_SIG_INTERPOBJ, JSI_SIG_FUNC, JSI_SIG_CMDSPECITEM, JSI_SIG_HASH,\n    JSI_SIG_HASHENTRY, JSI_SIG_TREE, JSI_SIG_TREEENTRY, JSI_SIG_LIST, JSI_SIG_LISTENTRY,\n    JSI_SIG_USER_REG, JSI_SIG_EVENT, JSI_SIG_MAP, JSI_SIG_REGEXP,\n    JSI_SIG_ARGTYPE, JSI_SIG_FORINVAR, JSI_SIG_CASELIST, JSI_SIG_CASESTAT,\n    JSI_SIG_FASTVAR, JSI_SIG_INTERPSTREVENT, JSI_SIG_ALIASCMD, JSI_SIG_SOCKET, JSI_SIG_SOCKETPSS,\n    JSI_SIG_NAMEDATA\n} jsi_Sig;\n\n#define Jsi_LogType(fmt,...) Jsi_LogMsg(interp, (interp->typeCheck.strict || interp->typeCheck.error)?JSI_LOG_ERROR:JSI_LOG_WARN, fmt, ##__VA_ARGS__)\n\nstruct jsi_OpCode;\n\n#if  JSI__MEMDEBUG\nextern void jsi_VALCHK(Jsi_Value *v);\nextern void jsi_OBJCHK(Jsi_Obj *o);\n#define VALCHK(val) jsi_VALCHK(val)\n#define OBJCHK(val) jsi_OBJCHK(val)\n#else\n#define VALCHK(val)\n#define OBJCHK(val)\n#endif\n\nenum {  jsi_callTraceFuncs = 1, jsi_callTraceCmds = 2, jsi_callTraceNew = 4,\n        jsi_callTraceReturn = 8, jsi_callTraceArgs = 16, \n        jsi_callTraceNoTrunc = 32,  jsi_callTraceNoParent = 64,\n        jsi_callTraceFullPath = 128, jsi_callTraceBefore = 256\n};\n\n/* Scope chain */\ntypedef struct jsi_ScopeChain_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Value **chains;  /* values(objects) */\n    int chains_cnt;         /* count */\n} jsi_ScopeChain;\n\n/* Function obj */\n/* a Jsi_FuncObj is a raw function with own scope chain */\nstruct Jsi_FuncObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Func *func;\n    jsi_ScopeChain *scope;\n    Jsi_Value *bindArgs;\n    Jsi_Value *bindFunc;\n};\n\n/* Jsi_IterObj, use only in for-in statement */\ntypedef struct UserObjReg_ { /* Per interp userobj registration. */\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_UserObjReg *reg;\n    Jsi_Hash* hashPtr;\n    int idx;\n} UserObjReg;\n\n/* User defined object */\ntypedef struct Jsi_UserObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *interp;\n    Jsi_Hash *id;\n    void *data;\n    const char *prefix;\n    Jsi_UserObjReg *reg;\n    struct UserObjReg_ *ureg;\n    uintptr_t idx;\n    Jsi_HashEntry* hPtr;\n} Jsi_UserObj;\n\ntypedef struct {\n    int valueCnt;\n    int objCnt;\n    int valueAllocCnt;\n    int objAllocCnt;\n#ifdef JSI_MEM_DEBUG\n    Jsi_Hash *valueDebugTbl;\n    Jsi_Hash *objDebugTbl;\n    uint memDebugCallIdx;\n#endif\n} Jsi_InterpDebug;\n\n\n/* stack change */\n/* 0  nothing change */\n/* +1 push */\n/* -1 pop */\ntypedef enum {      /* SC   type of data    comment                             */\n    OP_NOP,         /* 0 */\n    OP_PUSHNUM,     /* +1   *double         number                              */\n    OP_PUSHSTR,     /* +1   *char           string                              */\n    OP_PUSHVSTR,    /* +1   Jsi_String*     string                              */\n    OP_PUSHVAR,     /* +1   *FastVar        variable name                       */\n    OP_PUSHUND,     /* +1   -               undefined                           */\n    OP_PUSHNULL,    /* +1   -               null                                */\n    OP_PUSHBOO,     /* +1   int             bool                                */\n    OP_PUSHFUN,     /* +1   *Jsi_Func           function                            */\n    OP_PUSHREG,     /* +1   *regex_t        regex                               */\n    OP_PUSHARG,     /* +1   -               push arguments(cur scope)           */\n    OP_PUSHTHS,     /* +1   -               push this                           */\n    OP_PUSHTOP,     /* +1   -               duplicate top                       */\n    OP_PUSHTOP2,    /* +2   -               duplicate toq and top               */\n    OP_UNREF,       /* 0    -               make top be right value             */\n    OP_POP,         /* -n   int             pop n elements                      */\n    OP_LOCAL,       /* 0    *char        add a var to current scope          */\n    OP_NEG,         /* 0    -               make top = - top                    */\n    OP_POS,         /* 0    -               make top = + top, (conv to number)  */\n    OP_NOT,         /* 0    -               reserve top                         */\n    OP_BNOT,        /* 0    -               bitwise not                         */\n    OP_ADD,         /* -1   -               all math opr pop 2 elem from stack, */\n    OP_SUB,         /* -1   -                calc and push back in to the stack */\n    OP_MUL,         /* -1   -                                                   */\n    OP_DIV,         /* -1   -                                                   */\n    OP_MOD,         /* -1   -                                                   */\n    OP_LESS,        /* -1   -               logical opr, same as math opr       */\n    OP_GREATER,     /* -1   -                                                   */\n    OP_LESSEQU,     /* -1   -                                                   */\n    OP_GREATEREQU,  /* -1   -                                                   */\n    OP_EQUAL,       /* -1   -                                                   */\n    OP_NOTEQUAL,    /* -1   -                                                   */\n    OP_STRICTEQU,   /* -1   -                                                   */\n    OP_STRICTNEQ,   /* -1   -                                                   */\n    OP_BAND,        /* -1   -               bitwise and                         */\n    OP_BOR,         /* -1   -               bitwise or                          */\n    OP_BXOR,        /* -1   -               bitwise xor                         */\n    OP_SHF,         /* -1   int(right)      signed shift left or shift right    */\n    OP_INSTANCEOF,  /* -1 */\n    OP_ASSIGN,      /* -n   int             if n = 1, assign to lval,           */\n                    /*                      n = 2, assign to object member      */\n    OP_SUBSCRIPT,   /* -1   -               do subscript TOQ[TOP]               */\n    OP_INC,         /* 0    int             data indicate prefix/postfix inc/dec                */\n    OP_TYPEOF,      /* 0    obj                                                                 */\n    OP_IN,          /* 0    obj                                                                 */\n    OP_DEC,         /* 0    int                                                                 */\n    OP_KEY,         /* +1   -               push an iter object that contain all key in top     */\n    OP_NEXT,        /* -1   -               assign next key to top, make top be res of this opr */\n    OP_JTRUE,       /* -1   int             jmp to offset if top is true,                       */\n    OP_JFALSE,      /* -1   int             jmp to offset if top is false,                      */\n    OP_JTRUE_NP,    /* 0    int             jtrue no pop version                                */\n    OP_JFALSE_NP,   /* 0    int             jfalse no pop version                               */\n    OP_JMP,         /* 0    int             jmp to offset                                       */\n    OP_JMPPOP,      /* -n   *jsi_JmpPopInfo     jmp to offset with pop n                            */\n    OP_FCALL,       /* -n+1 int             call func with n args, pop then, make ret to be top */\n    OP_NEWFCALL,    /* -n+1 int             same as fcall, call as a constructor                */\n    OP_RET,         /* -n   int             n = 0|1, return with arg                            */\n    OP_DELETE,      /* -n   int             n = 1, delete var, n = 2, delete object member      */\n    OP_CHTHIS,      /* 0,   -               make toq as new 'this'                              */\n    OP_OBJECT,      /* -n*2+1   int         create object from stack, and push back in          */\n    OP_ARRAY,       /* -n+1 int             create array object from stack, and push back in    */\n    OP_EVAL,        /* -n+1 int             eval can not be assign to other var                 */\n    OP_STRY,        /* 0    *jsi_TryInfo        push try statment poses Jsi_LogWarn to trylist             */\n    OP_ETRY,        /* 0    -               end of try block, jmp to finally                    */\n    OP_SCATCH,      /* 0    *char        create new scope, assign to current excption        */\n    OP_ECATCH,      /* 0    -               jmp to finally                                      */\n    OP_SFINAL,      /* 0    -               restore scope chain create by Scatch                */\n    OP_EFINAL,      /* 0    -               end of finally, any unfinish code in catch, do it   */\n    OP_THROW,       /* 0    -               make top be last exception, pop trylist till catched*/\n    OP_WITH,        /* -1   -               make top be top of scopechain, add to trylist       */\n    OP_EWITH,       /* 0    -               pop trylist                                         */\n    OP_RESERVED,    /* 0    jsi_ReservedInfo*   reserved, be replaced by iterstat by jmp/jmppop     */\n    OP_DEBUG,       /* 0    -               DEBUG OPCODE, output top                            */\n    OP_LASTOP       /* 0    -               END OF OPCODE                                       */\n} jsi_Eopcode;\n\ntypedef enum { jsi_Oplf_none=0, jsi_Oplf_assert=1, jsi_Oplf_debug=2, jsi_Oplf_trace=3, jsi_Oplf_test=4 } jsi_OpLogFlags;\n\ntypedef struct jsi_OpCode {\n    jsi_Eopcode op;\n    void *data;\n    unsigned int Line:16;\n    unsigned int Lofs:8;\n    unsigned char alloc:1;\n    unsigned char nodebug:1;\n    unsigned char hit:1;\n    unsigned char isof:1;\n    unsigned char local:1;\n    jsi_OpLogFlags logflag:3;\n    const char *fname;\n} jsi_OpCode;\n\n\ntypedef struct Jsi_OpCodes {\n    jsi_OpCode *codes;\n    int code_len;\n    int code_size;          // Used by malloc.\n    \n    int expr_counter;           /* context related expr count */\n    int lvalue_flag;            /* left value count/flag */\n    const char *lvalue_name; /* left value name */\n    int line;  // Used in Lemon\n#ifdef JSI_MEM_DEBUG\n    Jsi_HashEntry *hPtr;\n    int id;\n#endif\n} Jsi_OpCodes;\n\n\ntypedef struct jsi_TryInfo {\n    int trylen;\n    int catchlen;\n    int finallen;\n} jsi_TryInfo;\n\ntypedef struct jsi_ReservedInfo {\n    int type;\n    const char *label;\n    int topop;\n} jsi_ReservedInfo;\n\ntypedef struct jsi_JmpPopInfo {\n    int off;\n    int topop;\n} jsi_JmpPopInfo;\n\n#define RES_CONTINUE    1\n#define RES_BREAK       2\ntypedef struct YYLTYPE jsi_Pline;\n\n//void jsi_codes_print(Jsi_OpCodes *ops);\nvoid jsi_code_decode(Jsi_Interp *interp, jsi_OpCode *op, int currentip, char *buf, int bsiz);\nconst char* jsi_opcode_string(uint opCode);\n\n#ifdef JSI_MEM_DEBUG\ntypedef struct \n{\n    const char *fname;\n    int line;\n    const char *func;\n    const char *label;\n    const char *label2;\n    const char *label3;\n    uint Idx;\n    uint flags;\n    struct jsi_OpCode *ip;\n    int ipLine;\n    jsi_Eopcode ipOp;\n    const char* ipFname;\n    Jsi_HashEntry *hPtr;\n    Jsi_Interp *interp;\n} jsi_ValueDebug;\n#endif\n\nstruct Jsi_Obj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int refcnt;                 /* reference count */\n    Jsi_otype ot:8;             /* object type */\n    uint isarrlist:1;           /* Array type. */\n    uint isstrkey:1;            /* Key string registered in interp->strKeyTbl (do not free) */\n    uint isJSONstr:1;\n    uint clearProto:1;          /* Prototype changed, clean it up at exit. */\n    uint isNoOp:1;\n    uint isBlob:1;\n    uint unused2:16;\n    union {                     /* switched on by value of \"ot\" */\n        int val;\n        Jsi_Number num;\n        Jsi_String s;\n        Jsi_Regex *robj;\n        Jsi_FuncObj *fobj;\n        Jsi_IterObj *iobj;\n        Jsi_UserObj *uobj;\n    } d;\n    uint arrMaxSize;                 /* Max allocated space for array. */\n    uint arrCnt;                     /* Count of actually set keys. */\n    Jsi_Value **arr;   /* Array values. */  \n    Jsi_Tree *tree;                 /* Tree storage (should be union with array). */\n    Jsi_Value *__proto__;           /* TODO: memory leaks when this is changed */\n    struct Jsi_Obj *constructor;\n    struct Jsi_Obj *next, *prev;    /* GC list for containers (array and object). */\n    int gc_refs;\n#ifdef JSI_MEM_DEBUG\n    jsi_ValueDebug VD;\n#endif\n};\n\n/*#pragma pack(1)*/\n\n\nstruct Jsi_Value {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int32_t refCnt;\n    Jsi_vtype vt:8;             /* value type */\n    union {\n        uint flag:8;\n        struct vflagbit {\n            uint readonly:1;\n            uint dontenum:1;  /* Dont enumerate. */\n            uint dontdel:1;\n            uint innershared:1; /* All above used only for objkeys. */\n            uint isarrlist:1;\n            uint isstrkey:1;    /* Key string registered in interp->strKeyTbl (do not free) */\n            uint local:1;       // Used to detect a function creating a global var.\n            uint lookupfailed:1;// Indicates failed lookup, string is stored in lookupFail below.\n        } bits;\n    } f;\n    union {                     /* see above */\n        int val;\n        Jsi_Number num;\n        Jsi_String s;\n        Jsi_Obj *obj;\n        struct Jsi_Value *lval;\n        const char *lookupFail;\n    } d;\n    struct Jsi_Value *next, *prev;\n#ifdef JSI_MEM_DEBUG\n    jsi_ValueDebug VD;\n#endif\n};\n\n#ifndef JSI_SMALL_HASH_TABLE\n#define JSI_SMALL_HASH_TABLE 0x10\n#endif\n\ntypedef uintptr_t jsi_Hash;\n\ntypedef union jsi_HashKey {\n    char string[sizeof(jsi_Hash)];  // STRING, STRUCT\n    void *oneWordValue;             // ONEWORD, STRINGKEY\n} jsi_HashKey;\n\ntypedef struct Jsi_HashEntry {\n    jsi_Sig sig;\n    int typ; // JSI_MAP_HASH\n    struct Jsi_HashEntry *nextPtr;\n    Jsi_Hash *tablePtr;\n    jsi_Hash hval;\n    void* clientData;\n    jsi_HashKey key;\n} Jsi_HashEntry;\n\n\ntypedef struct Jsi_Hash {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int typ; // JSI_MAP_HASH\n    Jsi_HashEntry **buckets;\n    Jsi_HashEntry *staticBuckets[JSI_SMALL_HASH_TABLE];\n    int numBuckets;\n    int numEntries;\n    int rebuildSize;\n    jsi_Hash mask;\n    unsigned int downShift;\n    int keyType;\n    Jsi_HashEntry *(*createProc) (Jsi_Hash *tablePtr, const void *key, bool *newPtr);\n    Jsi_HashEntry *(*findProc) (Jsi_Hash *tablePtr, const void *key);\n    Jsi_MapOpts opts;\n} Jsi_Hash;\n\nstruct Jsi_Tree {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int typ; // JSI_MAP_TREE\n    //Jsi_Interp *interp;\n    Jsi_TreeEntry *root;\n    uint numEntries, keyType, epoch;\n    struct {\n        uint \n            inserting:1, destroyed:1,\n            nonredblack:1,  /* Disable red/black handling on insert/delete. */\n            internstr:1,    /* STRINGPTR keys are stored in strHash */\n            valuesonly:1,   /* Values must be of type JSI_VALUE */\n            unused:28;\n    } flags;\n    Jsi_Hash* strHash;  /* String hash table to use if INTERNSTR; setup on first Create if not defined. */\n    Jsi_TreeEntry* (*createProc)(Jsi_Tree *treePtr, const void *key, bool *newPtr);\n    Jsi_MapOpts opts;\n};\n\ntypedef struct Jsi_TreeEntry {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int typ; // JSI_MAP_TREE\n    Jsi_Tree *treePtr;\n    struct Jsi_TreeEntry* left;\n    struct Jsi_TreeEntry* right;\n    struct Jsi_TreeEntry* parent;\n    union { /* FLAGS: bottom 16 bits for JSI, upper 16 bits for users. First 7 map to JSI_OM_ above. */\n        struct { \n            unsigned int readonly:1, dontenum:1, dontdel:1, innershared:1, isarrlist:1, isstrkey:1, unused:1,\n                color:1,\n                reserve:8,\n                user0:8,\n                user1:1, user2:1, user3:1, user4:1, user5:1, user6:1, user7:1, user8:1;\n        } bits;\n        int flags;\n    } f;\n    void* value;\n    jsi_HashKey key;\n} Jsi_TreeEntry;\n\ntypedef struct Jsi_Map {  // Wrapped Tree/Hash/List.\n    uint sig;\n    Jsi_Map_Type typ;\n    union {\n        Jsi_Hash *hash;\n        Jsi_Tree *tree;\n        Jsi_List *list;\n    } v;\n} Jsi_Map;\n\ntypedef struct jsi_ArgValue_ {\n    char *name;\n    uint type;  // or'ed Jsi_otype\n    Jsi_Value *defValue;\n} jsi_ArgValue;\n\ntypedef struct Jsi_ScopeStrs {\n    jsi_ArgValue *args;\n    int count;\n    int _size;  // Used in allocation only.\n    int varargs;\n    int typeCnt;\n    int firstDef;\n    int argCnt;\n    int retType;\n} Jsi_ScopeStrs;\n\n// Eval stack-frame.\ntypedef struct jsi_Frame {\n    int level;\n    const char *fileName;\n    const char *funcName;\n    const char *dirName;\n    int line;\n    jsi_OpCode *ip;\n    int Sp;\n    int tryDepth;\n    int withDepth;\n    jsi_ScopeChain* ingsc;\n    Jsi_Value *incsc;\n    Jsi_Value *inthis;\n    Jsi_OpCodes *opcodes;\n    struct jsi_Pstate *ps;\n    int logflag;\n    Jsi_Func *evalFuncPtr;\n    struct jsi_Frame *parent, *child;\n    Jsi_Value *arguments; // Set when arguments are accessed.\n} jsi_Frame;\n\n/* Program/parse state(context) */\ntypedef struct jsi_Pstate {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int err_count;              /* Jsi_LogError count after parse */\n    int eval_flag;              /* 1 if currently executing in an eval function */\n    int funcDefs;               /* Count of functions defined. 0 means we can delete this cache (eventually). */\n    Jsi_OpCodes *opcodes;       /* Execution codes. */\n    struct jsi_Lexer *lexer;        /* seq provider */\n\n    int _context_id;            /* used in FastVar-locating */\n    Jsi_Value *last_exception;\n    Jsi_Interp *interp;\n    Jsi_HashEntry *hPtr;\n    Jsi_Hash *argsTbl;\n    Jsi_Hash *fastVarTbl;\n    Jsi_Hash *strTbl;\n    int argType;                // Used during parsing to aggregate type.\n    Jsi_ScopeStrs *args;        // Last push.\n} jsi_Pstate;\n\n\nJsi_ScopeStrs *jsi_ScopeStrsNew(void);\nvoid jsi_ScopeStrsPush(Jsi_Interp *interp, Jsi_ScopeStrs *ss, const char *string, int argType);\nvoid jsi_ScopeStrsFree(Jsi_Interp *interp, Jsi_ScopeStrs *ss);\nconst char *jsi_ScopeStrsGet(Jsi_ScopeStrs *ss, int i);\n\nvoid jsi_PstatePush(jsi_Pstate *ps);\nvoid jsi_PstatePop(jsi_Pstate *ps);\nvoid jsi_PstateAddVar(jsi_Pstate *ps, jsi_Pline *line, const char *str);\nJsi_ScopeStrs *jsi_ScopeGetVarlist(jsi_Pstate *ps);\n\nvoid jsi_PstateFree(jsi_Pstate *ps);\njsi_Pstate *jsi_PstateNew(Jsi_Interp *interp);\nvoid jsi_PstateClear(jsi_Pstate *ps);\nconst char * jsi_PstateGetFilename(jsi_Pstate *ps);\nint jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang);\nint jsi_PstateSetString(jsi_Pstate *ps, const char *str);\n\nextern int yyparse(jsi_Pstate *ps);\n\n#ifndef JSI_AMALGAMATION\n#include \"parser.h\"\n#endif\n\ntypedef struct jsi_ForinVar {\n    jsi_Sig sig;\n    const char *varname;\n    Jsi_OpCodes *local;\n    Jsi_OpCodes *lval;\n} jsi_ForinVar;\n\n\ntypedef struct jsi_CaseExprStat {\n    jsi_Sig sig;\n    Jsi_OpCodes *expr;\n    Jsi_OpCodes *stat;\n    int isdefault;\n} jsi_CaseExprStat;\n\n\ntypedef struct jsi_CaseList {\n    jsi_Sig sig;\n    jsi_CaseExprStat *es;\n    int off;\n    struct jsi_CaseList *tail;\n    struct jsi_CaseList *next;\n} jsi_CaseList;\n\n\ntypedef enum {\n    LT_NONE,\n    LT_FILE,            /* read from file */\n    LT_STRING           /* read from a string */\n} Jsi_Lexer_Type;\n\n/* jsi_Lexer, where input seq provided */\ntypedef struct jsi_Lexer {\n    Jsi_Lexer_Type ltype;\n    union {\n        Jsi_Channel fp;           /* LT_FILE, where to read */\n        char *str;          /* LT_STRING */\n    } d;\n    int last_token;         /* last token returned */\n    int ungot, unch[100];\n    int cur;                /* LT_STRING, current char */\n    int cur_line;           /* current line no. */\n    int cur_char;           /* current column no. */\n    int inStr;\n    jsi_Pstate *pstate;\n} jsi_Lexer;\n\nint yylex (YYSTYPE *yylvalp, YYLTYPE *yyllocp, jsi_Pstate *pstate);\nvoid yyerror(YYLTYPE *yylloc, jsi_Pstate *ps, const char *msg);\n\ntypedef struct {\n    jsi_Sig sig;\n    int context_id:31;\n    unsigned int local:1;\n    jsi_Pstate *ps;\n    char *varname;\n    struct Jsi_Value *lval;\n} jsi_FastVar;\n\ntypedef enum { FC_NORMAL, FC_BUILDIN } Jsi_Func_Type;\nstruct jsi_PkgInfo;\n\n/* raw function data, with script function or system Jsi_CmdProc */\nstruct Jsi_Func {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Func_Type type;                         /* type */\n    struct Jsi_OpCodes *opcodes;    /* FC_NORMAL, codes of this function */\n    Jsi_CmdProc *callback;            /* FC_BUILDIN, callback */\n\n    Jsi_ScopeStrs *argnames;                 /* FC_NORMAL, argument names */\n    Jsi_ScopeStrs *localnames;               /* FC_NORMAL, local var names */\n    union {\n        uint flags;\n        struct {\n            uint res:8, hasattr:1, isobj:1 , iscons:1, res2:4;\n        } bits;\n    } f;\n    union {\n        uint i;\n        struct {\n            uint addargs:1 , iscons:1, isdiscard:1, res:5;\n        } bits;\n    } callflags;\n    int refCnt;\n    void *privData;                 /* context data given in create. */\n    Jsi_CmdSpec *cmdSpec;\n    const char *name, *parentName;  /* Name for non-anonymous function. */\n    Jsi_CmdSpec *parentSpec;\n    uint retType;  /* Type name: or of Jsi_otype*/\n    int callCnt;\n    const char *script, *scriptFile;  /* Script created in. */\n    jsi_Pline bodyline; /* Body line info. */\n    const char *bodyStr; // Non-builtin func script body.\n    int endPos, startPos;\n    Jsi_HashEntry *hPtr;\n    double subTime, allTime;\n    Jsi_FuncObj *fobj;\n    struct jsi_PkgInfo *pkg;\n    bool isArrow;\n};\n\ntypedef struct {\n    char *origFile; /* Short file name. */\n    char *fileName; /* Fully qualified name. */\n    char *dirName;  /* Directory name. */\n    const char *str; /* File data. */\n    int useCnt;\n} jsi_FileInfo;\n\nenum {\n    STACK_INIT_SIZE=1024, STACK_INCR_SIZE=1024, STACK_MIN_PAD=100,\n    JSI_MAX_EVAL_DEPTH=200, /* default max nesting depth for eval */\n    JSI_MAX_INCLUDE_DEPTH=50,  JSI_MAX_SUBINTERP_DEPTH=10,\n    JSI_IS_UTF=1,\n    JSI_UTF_CHECKED=2\n    /*,JSI_ON_STACK=0x80*/\n};\n\ntypedef struct InterpStrEvent_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int rc, isExec, tryDepth, errLine;\n    const char *errFile;\n//    Jsi_Value *objData;\n    Jsi_DString func;\n    Jsi_DString data;\n    struct InterpStrEvent_ *next;\n    void *acdata;\n    Jsi_Value *acfunc;\n    void *mutex;\n} InterpStrEvent;\n\ntypedef void (*jsiCallTraceProc)(Jsi_Interp *interp, const char *funcName, const char *file, \n    int line, Jsi_CmdSpec* spec, Jsi_Value* _this, Jsi_Value* args, Jsi_Value *ret);\n\ntypedef struct {\n    const char *file;\n    const char *func;\n    int line;\n    int id;\n    int hits;\n    bool enabled;\n    bool temp;\n} jsi_BreakPoint;\n\ntypedef struct jsi_PkgInfo {\n    Jsi_Number version, lastReq;\n    const char *loadFile;  // Full path of file name loaded.\n    Jsi_InitProc *initProc; // For C-extensions.\n    bool needInit;  // If a C-extension and _Init func needs calling in this interp.\n    Jsi_Value *info;\n    Jsi_PkgOpts popts;\n} jsi_PkgInfo;\n\ntypedef struct {\n    bool isDebugger; // Set to 1 if we are the debugger, debugging a sub-interp.\n    bool noFilter;\n    bool doContinue;\n    bool forceBreak;\n    bool bpLast; // Last break was a breakpoint.\n    bool includeOnce;\n    bool includeTrace;\n    int bpOpCnt;\n    int minLevel;\n    Jsi_Value *putsCallback;\n    Jsi_Value *msgCallback;\n    Jsi_Value *traceCallback;\n    Jsi_Value *debugCallback;\n    Jsi_Value *testFmtCallback;\n    int lastLine;\n    int lastLevel;\n    const char *lastFile;\n    bool pkgTrace;\n    int breakIdx;\n    Jsi_RC (*hook)(struct Jsi_Interp* interp, const char *curFile, int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *msg);\n} Jsi_DebugInterp;\n\ntypedef union jsi_numUnion {\n    bool       BOOL;\n    int            INT;\n    uint           UINT;\n    int8_t         INT8;\n    uint8_t        UINT8;\n    int16_t        INT16;\n    uint16_t       UINT16;\n    int32_t        INT32;\n    uint32_t       UINT32;\n    int64_t        INT64;\n    uint64_t       UINT64;\n    Jsi_Number     DOUBLE;\n    time_t         TIME_T;\n    time_w         TIME_W;\n    time_d         TIME_D;\n} jsi_numUnion;\n\ntypedef struct {\n    uint parse:1;\n    uint run:1;\n    uint all:1;     \n    uint error:1;\n    uint strict:1;\n    uint noundef:1;\n    uint nowith:1;\n    uint funcsig:1;\n    uint unused:24;\n} Jsi_TypeCheck;\n\ntypedef enum {\n    jsi_AssertModeThrow,\n    jsi_AssertModeLog,\n    jsi_AssertModePuts\n} jsi_AssertMode;\n\ntypedef struct {\n    uint isSpecified:1; /* User set the option. */\n    uint initOnly:1;    /* Allow set only at init, disallowing update/conf. */\n    uint readOnly:1;    /* Value can not be set. */\n    uint noDupValue:1;  /* Values are not to be duped. */\n    uint noClear:1;     /* Values are not to be cleared: watch for memory leaks */\n    uint dbDirty:1;     /* Used to limit DB updates. */\n    uint dbIgnore:1;    /* Field is not to be used for DB. */\n    uint dbRowid:1 ;    /* Field used by DB to store rowid. */\n    uint custNoCase:1;  /* Ignore case (eg. for ENUM and BITSET). */\n    uint forceInt:1;    /* Force int instead of text for enum/bitset. */\n    uint bitsetBool:1;  /* Treat bitset custom field as bool instead of an int. */\n    uint timeDateOnly:1;/* Time field is date only. */\n    uint timeTimeOnly:1;/* Time field is time only. */\n    uint isBits:1;      /* Is a C bit-field. */\n    uint fmtString:1;   /* Format value (eg. time) as string. */\n    uint fmtNumber:1;   /* Format value (eg. enum) as number. */\n    uint fmtHext:1;     /* Format number in hex. */\n    uint strict:1;      /* Strict mode. */\n    uint fieldSetup:1;  /* Field has been setup. */\n    uint coerce:1;      /* Coerce input value to required type. */\n    uint noSig:1;       /* No signature. */\n    uint enumSpec:1;    /* Enum has spec rather than a list of strings. */\n    uint enumUnsigned:1;/* Enum value is unsigned. */\n    uint enumExact:1;   /* Enum must be an exact match. */\n    uint required:1;    /* Field must be specified (if not IS_UPDATE). */\n    uint prefix:1;      /* Allow matching unique prefix of object members. */\n    uint isUpdate:1;    /* This is an update/conf (do not reset the specified flags) */\n    uint ignoreExtra:1; /* Ignore extra members not found in spec. */\n    uint forceStrict:1; /* Override Interp->compat to disable JSI_OPTS_IGNORE_EXTRA. */\n    uint verbose:1;     /* Dump verbose options */\n    uint userBits:32;\n} jsi_OptionFlags;\n\ntypedef struct {\n    bool file;    // Ouput file:line information: default is at end.\n    bool full;    // Show full file path.\n    bool ftail;   // Show tail of file only, even in LogWarn, etc.\n    bool func;    // Ouput function at end.\n    bool Debug;\n    bool Trace;\n    bool Test;\n    bool Info;\n    bool Warn;\n    bool Error;\n    bool time;    // Prefix with time\n    bool date;    // Prefix with date\n    bool before;  // Print file:line before message instead of at end.\n    bool isUTC;\n    const char* timeFmt;\n    Jsi_Value *chan;\n} jsi_LogOptions;\n\ntypedef struct {\n    bool istty;\n    bool noRegex;\n    bool noReadline;\n    bool noproto;\n    bool outUndef;\n    bool logAllowDups;\n    bool logColNums;\n    bool privKeys;\n    bool compat;\n    bool mutexUnlock;\n    bool noFuncString;\n    int dblPrec;\n    const char *blacklist;\n    const char *prompt, *prompt2;\n} jsi_SubOptions;\n\nextern Jsi_OptionSpec jsi_InterpLogOptions[];\n\ntypedef enum {\n        jsi_TL_TRY,\n        jsi_TL_WITH,\n} jsi_try_op_type;                            /* type of try */\n\ntypedef enum { jsi_LOP_NOOP, jsi_LOP_THROW, jsi_LOP_JMP } jsi_last_try_op_t; \n\ntypedef struct jsi_TryList {\n    jsi_try_op_type type;\n    union {\n        struct {                    /* try data */\n            jsi_OpCode *tstart;         /* try start ip */\n            jsi_OpCode *tend;           /* try end ip */\n            jsi_OpCode *cstart;         /* ...*/\n            jsi_OpCode *cend;\n            jsi_OpCode *fstart;\n            jsi_OpCode *fend;\n            int tsp;\n            jsi_last_try_op_t last_op;              /* what to do after finally block */\n                                    /* depend on last jmp code in catch block */\n            union {\n                jsi_OpCode *tojmp;\n            } ld;                   /* jmp out of catch (target)*/\n        } td;\n        struct {                    /* with data */\n            jsi_OpCode *wstart;         /* with start */\n            jsi_OpCode *wend;           /* with end */\n        } wd;\n    } d;\n    \n    jsi_ScopeChain *scope_save;         /* saved scope (used in catch block/with block)*/\n    Jsi_Value *curscope_save;           /* saved current scope */\n    struct jsi_TryList *next;\n    bool inCatch;\n    bool inFinal;\n} jsi_TryList;\n\ntypedef enum {\n    jsi_safe_None,\n    jsi_safe_Read,\n    jsi_safe_Write,\n    jsi_safe_WriteRead,\n    jsi_safe_Lockdown\n} jsi_safe_mode;\n\nstruct Jsi_Interp {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    bool isSafe, startSafe;\n    jsi_safe_mode safeMode;\n    int iskips;\n    Jsi_Value *safeReadDirs;\n    Jsi_Value *safeWriteDirs;\n    const char *safeExecPattern;\n    Jsi_DebugInterp debugOpts;\n    struct jsi_TryList *tryList;\n    bool deleting;\n    bool destroying;\n    uint EventHdlId;\n    uint autoLoaded;\n    int exited;\n    int exitCode;\n    int interrupted;\n    int refCount;\n    int traceCall;\n    int traceOp;\n    int memDebug;\n    int coverAll, coverHit;\n    bool coverage;\n    bool profile;\n    int profileCnt;\n    bool asserts;\n    bool noNetwork;\n    bool noInput;\n    jsi_AssertMode assertMode;\n    uint unitTest;\n    const char *jsppChars;\n    Jsi_Value *jsppCallback;\n    bool noConfig;\n    bool noLoad;\n    bool noAutoLoad;\n    bool noStderr;\n    bool noSubInterps;\n    bool tracePuts;\n    bool isMain;\n    bool hasCallee;\n    bool subthread;\n    bool strict;\n    bool protoInit;\n    bool hasOpenSSL;\n    bool isHelp;\n    bool callerErr;\n    bool interactive;\n    jsi_SubOptions subOpts;\n    bool isInteractive;\n    const char *confArgs;\n    Jsi_Value *stdinStr;\n    Jsi_Value *stdoutStr;\n    Jsi_TypeCheck typeCheck;\n    jsi_LogOptions logOpts;\n    int typeWarnMax;\n    int typeMismatchCnt;\n    Jsi_InterpOpts opts;\n    Jsi_Value *inopts;\n    int evalFlags;\n    Jsi_InterpDebug dbStatic;\n    Jsi_InterpDebug *dbPtr;\n    jsiCallTraceProc traceHook;\n    int opCnt;  /* Count of instructions eval'ed */\n    int maxOpCnt;\n    int maxUserObjs;\n    int userObjCnt;\n    int funcCnt;\n    int level;  /* Nesting level of eval/func calls. */\n    int maxDepth;/* Max allowed eval recursion. */\n    int callDepth;\n    int maxIncDepth;\n    int includeDepth;\n    int includeCnt;\n    int maxInterpDepth;\n    int interpDepth;\n    int pkgReqDepth;\n    int didReturn;\n    uint codeCacheHit;\n    uint funcCallCnt;\n    uint cmdCallCnt;\n    uintptr_t eventIdx;\n#ifdef JSI_MEM_DEBUG\n    uint valueDebugIdx;\n    Jsi_Hash *codesTbl;\n#endif\n    jsi_ScopeChain *gsc;\n    Jsi_Value *csc;\n    struct Jsi_Interp *parent, *topInterp, *mainInterp;\n    Jsi_Value *onComplete;\n    Jsi_Value *onEval;\n    Jsi_Value *onExit;\n    Jsi_Value *execZip;\n    void (*logHook)(char *buf, va_list va);\n    const char *name;\n    Jsi_Value *pkgDirs;\n    bool selfZvfs;\n    int inParse;\n    Jsi_Value *retValue;       /* Return value from eval */\n    jsi_Pstate *ps, *parsePs;\n    Jsi_Value *argv0;\n    Jsi_Value *args;\n    Jsi_Value *console;\n    Jsi_Value *scriptFile;  /* Start script returned by info.argv0(). */\n    const char *scriptStr;\n    const char *curFile;\n    const char *curFunction;\n    const char *homeDir;\n    const char *historyFile;\n    char *curDir;\n    int maxStack;\n    double timesStart;\n\n    Jsi_Map *strKeyTbl;  /* Global strings table. */\n    Jsi_Map *cmdSpecTbl; /* Jsi_CmdSpecs registered. */\n    Jsi_Hash *onDeleteTbl;  /* Cleanup funcs to call on interp delete. */\n    Jsi_Hash *assocTbl;\n    Jsi_Hash *codeTbl; /* Scripts compiled table. */\n    Jsi_Hash *eventTbl;\n    Jsi_Hash *genValueTbl;\n    Jsi_Hash *genObjTbl;\n    Jsi_Hash *funcObjTbl;\n    Jsi_Hash *funcsTbl;\n    Jsi_Hash *bindTbl;\n    Jsi_Hash *fileTbl;    // The \"source\"ed files.\n    Jsi_Hash *lexkeyTbl;\n    Jsi_Hash *protoTbl;\n    Jsi_Hash *regexpTbl;    \n    Jsi_Hash *thisTbl;\n    Jsi_Hash *userdataTbl;\n    Jsi_Hash *varTbl;\n    Jsi_Hash *preserveTbl;\n    Jsi_Hash *loadTbl;\n    Jsi_Hash *staticFuncsTbl; // For debugOpts.typeProto\n    Jsi_Hash *breakpointHash;\n    Jsi_Hash *packageHash;\n    Jsi_Hash *aliasHash;\n    Jsi_Hash* vfsMountHash;\n    Jsi_Hash* vfsDefHash;\n#ifdef VAL_REFCNT\n    Jsi_Value **Stack;\n    Jsi_Value **Obj_this;\n#else\n    Jsi_Value *Stack;\n    Jsi_Value *Obj_this;\n#endif\n            \n    Jsi_Value *Object_prototype;\n    Jsi_Value *Function_prototype_prototype;\n    Jsi_Value *Function_prototype;\n    Jsi_Value *String_prototype;\n    Jsi_Value *Number_prototype;\n    Jsi_Value *Boolean_prototype;\n    Jsi_Value *Array_prototype;\n    Jsi_Value *RegExp_prototype;\n    Jsi_Value *Date_prototype;\n    \n    Jsi_Value *NaNValue;\n    Jsi_Value *InfValue;\n    Jsi_Value *NullValue;\n    Jsi_Value *nullFuncArg; /* Efficient call of no-arg func */\n    Jsi_Value *nullFuncRet;\n    Jsi_Value *autoFiles;\n    Jsi_Obj* cleanObjs[4];\n    Jsi_Obj* allObjs;\n    Jsi_Value* allValues, *udata;\n\n    Jsi_Value *busyCallback;\n    const char *confFile;\n    int busyInterval;\n    int isInCallback;\n    int cleanup;\n    int objId;\n    Jsi_Value *Top_object;\n    Jsi_ScopeStrs *scopes[JSI_MAX_SCOPE];\n    int cur_scope;\n    uint maxArrayList;\n    int delRBCnt;\n    Jsi_Func *activeFunc;  // Currently active function call.\n    Jsi_Func *prevActiveFunc;  // Prev active function call.\n    jsi_OpCode *curIp;  /* Used for debug Log msgs. */\n    \n    char *lastPushStr;  // Used by error handling and Jsi_LogMsg.   TODO: cleanup/rationalize.\n    Jsi_Value* lastParseOpt;\n    Jsi_Value* lastSubscriptFail;\n    const char* lastSubscriptFailStr;\n    int logErrorCnt;\n    Jsi_OptionSpec *parseMsgSpec;\n\n\n    Jsi_Wide sigmask;\n    char errMsgBuf[JSI_BUFSIZ];  /* Error message space for when in try. */\n    int errLine;\n    int errCol;\n    const char *errFile;\n    Jsi_Mutex* Mutex;\n    Jsi_Mutex* QMutex; /* For threads queues */\n    void* threadId;\n    int threadCnt;\n    int threadShrCnt;\n    int lockTimeout; /* in milliseconds. */\n    uint lockRefCnt;\n    int psEpoch;\n    int mountCnt;\n    Jsi_DString interpEvalQ;\n    InterpStrEvent *interpStrEvents;\n\n    bool typeInit;\n    Jsi_Number cdataIncrVal;\n    Jsi_CData_Static *statics;\n    Jsi_VarSpec *cdataNewVal;\n    Jsi_Hash *StructHash;\n    Jsi_Hash *SigHash;\n    Jsi_Hash *EnumHash;\n    Jsi_Hash *EnumItemHash;\n    Jsi_Hash *CTypeHash;\n    Jsi_Hash *TYPEHash;\n\n    uint threadErrCnt;  /* Count of bad thread event return codes. */\n    uint threadEvalCnt;\n    uint threadMsgCnt;\n    void *sleepData;\n    jsi_PkgInfo *pkgRequiring, *pkgProviding;\n    jsi_Pline *parseLine;\n    jsi_Frame *framePtr;\n    struct jsi_DbVfs **dbVfsPtrPtr;\n    double subTime, startTime, funcSelfTime, cmdSelfTime;\n};\n\n\nenum { JSI_REG_GLOB=0x1, JSI_REG_NEWLINE=0x2, JSI_REG_DOT_NEWLINE=0x4, JSI_REG_STATIC=0x100 };\n\nstruct Jsi_Regex_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    regex_t reg;\n    int eflags;\n    int flags;\n    char *pattern;\n    int lastIndex;\n};\n\n\n/* Entries in interp->cmdSpecTbl. */\ntypedef struct Jsi_CmdSpecItem_ {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    const char *name;  /* Parent cmd. */\n    Jsi_CmdSpec *spec;\n    Jsi_Value *proto;\n    int flags;\n    void *privData;\n    Jsi_MapEntry *hPtr;\n    struct Jsi_CmdSpecItem_ *next; /* TODO: support user-added sub-commands. */\n    const char *help;\n    const char *info;\n    int isCons;\n} Jsi_CmdSpecItem;\n\n//extern Jsi_OptionTypedef jsi_OptTypeInfo[];\nextern const char* jsi_OptionTypeStr(Jsi_OptionId typ, bool cname);\nextern const Jsi_OptionTypedef* Jsi_OptionsStr2Type(const char *str, bool cname);\n\n/* SCOPE */\n//typedef struct jsi_ScopeChain jsi_ScopeChain;\n\nextern jsi_ScopeChain* jsi_ScopeChainNew(Jsi_Interp *interp, int cnt); /*STUB = 176*/\nextern Jsi_Value* jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key); /*STUB = 177*/\nextern jsi_ScopeChain* jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next); /*STUB = 178*/\nextern void jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc); /*STUB = 179*/\n\nextern void jsi_CmdSpecDelete(Jsi_Interp *interp, void *ptr);\n\nJsi_RC jsi_InitFilesys(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitLexer(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitLoad(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitCmds(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitInterp(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitFileCmds(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitString(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitValue(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitNumber(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitArray(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitBoolean(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitMath(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitProto(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitRegexp(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitJSON(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitSqlite(Jsi_Interp *interp, int release);\nJsi_RC Jsi_initSqlite(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitMySql(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitTree(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitWebSocket(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitSocket(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitSignal(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitOptions(Jsi_Interp *interp, int release);\nJsi_RC Jsi_InitZvfs(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitCData(Jsi_Interp *interp, int release);\nJsi_RC jsi_InitVfs(Jsi_Interp *interp, int release);\nJsi_RC jsi_execCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_DString *dStr, Jsi_DString *cStr, int *code);\n\nvoid jsi_SignalClear(Jsi_Interp *interp, int sigNum);\nbool jsi_SignalIsSet(Jsi_Interp *interp, int sigNum);\n/* excute opcodes\n * 1. ps, program execution context\n * 2. opcodes, codes to be executed\n * 3. scope, current scopechain, not include current scope\n * 4. currentScope, current scope\n * 5. _this, where 'this' indicated\n * 6. vret, return value\n */\nextern Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n        jsi_ScopeChain *scope, Jsi_Value *currentScope,\n        Jsi_Value *_this,\n        Jsi_Value **vret);\n        \ntypedef Jsi_RC (*Jsi_Constructor)(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, int flags, void *privData);\nextern Jsi_RC jsi_SharedArgs(Jsi_Interp *interp, Jsi_Value *args, Jsi_Func *func, int alloc);\nextern void jsi_SetCallee(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *tocall);\nextern Jsi_RC jsi_AssertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_NoOpCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n    \nenum {StrKeyAny = 0, StrKeyFunc = 0x1, StrKeyCmd = 0x2, StrKeyVar = 0x2};\n\n//char* jsi_KeyLookup(Jsi_Interp *interp, const char *str);\nextern char* jsi_KeyFind(Jsi_Interp *interp, const char *str, int nocreate, int *isKey);\nextern void jsi_InitLocalVar(Jsi_Interp *interp, Jsi_Value *arguments, Jsi_Func *who);\nextern Jsi_Value *jsi_GlobalContext(Jsi_Interp *interp);\nextern void jsi_AddEventHandler(Jsi_Interp *interp);\nextern Jsi_RC jsi_SetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, const char *string /*UNUSED*/, void* rec, Jsi_Value *argValue, Jsi_Wide flags, bool isSafe);\nextern Jsi_RC jsi_GetOption(Jsi_Interp *interp, Jsi_OptionSpec *specPtr, void* record, const char *option, Jsi_Value **valuePtr, Jsi_Wide flags);\nextern const char *jsi_ObjectTypeName(Jsi_Interp *interp, Jsi_otype otyp);\nextern const char *jsi_ValueTypeName(Jsi_Interp *interp, Jsi_Value *val);\nextern const char *jsi_TypeName(Jsi_Interp *interp, Jsi_ttype otyp);\nextern Jsi_RC jsi_ObjectToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_HasOwnPropertyCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_Value* jsi_ValueMakeBlobDup(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len);\n\nextern const char *jsi_GetHomeDir(Jsi_Interp *interp);\nextern Jsi_RC jsi_RegExpValueNew(Jsi_Interp *interp, const char *regtxt, Jsi_Value *ret);\nextern void jsi_DumpOptionSpecs(Jsi_Interp *interp, Jsi_Obj *nobj, Jsi_OptionSpec* spec);\nextern Jsi_Func *jsi_FuncMake(jsi_Pstate *pstate, Jsi_ScopeStrs *args, Jsi_OpCodes *ops, jsi_Pline *line, const char *name, int isArrow);\nextern Jsi_Func *jsi_FuncNew(Jsi_Interp *interp);\nextern void jsi_FreeOpcodes(Jsi_OpCodes *ops);\nextern void jsi_DelAssocData(Jsi_Interp *interp, void *data);\n\nextern void jsi_UserObjFree (Jsi_Interp *interp, Jsi_UserObj *uobj);\nextern bool jsi_UserObjIsTrue (Jsi_Interp *interp, Jsi_UserObj *uobj);\nextern Jsi_RC jsi_UserObjDump   (Jsi_Interp *interp, const char *argStr, Jsi_Obj *obj);\nextern Jsi_RC jsi_UserObjDelete (Jsi_Interp *interp, void *data);\nextern void jsi_UserObjToName(Jsi_Interp *interp, Jsi_UserObj *uobj, Jsi_DString *dStr);\nextern Jsi_Obj *jsi_UserObjFromName(Jsi_Interp *interp, const char *name);\n\nextern Jsi_RC Zvfs_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret);\nextern Jsi_Value* jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex);\nextern void jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey);\nextern void jsi_ValueSubscriptLen(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret, int right_val);\nextern Jsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret);\nextern Jsi_Value* jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value *value, int flag);\nextern void jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof);\nextern Jsi_Value* jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key);\nextern Jsi_Value* jsi_ProtoObjValueNew1(Jsi_Interp *interp, const char *name);\nextern Jsi_Value* jsi_ProtoValueNew(Jsi_Interp *interp, const char *name, const char *parent);\nextern Jsi_Value* jsi_ObjValueNew(Jsi_Interp *interp);\nextern Jsi_Value* Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v);\nextern int jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v);\nextern Jsi_RC jsi_FreeOneLoadHandle(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *handle);\nextern Jsi_Value* jsi_MakeFuncValue(Jsi_Interp *interp, Jsi_CmdProc *callback, const char *name, Jsi_Value** toVal, Jsi_CmdSpec *cspec);\nextern Jsi_Value* jsi_MakeFuncValueSpec(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, void *privData);\nextern bool jsi_FuncArgCheck(Jsi_Interp *interp, Jsi_Func *f, const char *argStr);\nextern bool jsi_CommandArgCheck(Jsi_Interp *interp, Jsi_CmdSpec *cmdSpec, Jsi_Func *f, const char *parent);\nextern Jsi_RC jsi_FileStatCmd(Jsi_Interp *interp, Jsi_Value *fnam, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int islstat);\nextern Jsi_RC jsi_LoadLoadCmd(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_RC jsi_LoadUnloadCmd(Jsi_Interp *interp, Jsi_Value *args, \n    Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\nextern void jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr);\nextern Jsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);\nextern Jsi_RC jsi_evalStrFile(Jsi_Interp* interp, Jsi_Value *path, const char *str, int flags, int level);\nextern Jsi_RC jsi_FuncArgsToString(Jsi_Interp *interp, Jsi_Func *f, Jsi_DString *dStr, int flags);\nextern Jsi_Value *jsi_LoadFunction(Jsi_Interp *interp, const char *str, Jsi_Value *tret);\nextern Jsi_RC jsi_SysExecCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, bool restricted);\n\nextern Jsi_FuncObj *jsi_FuncObjNew(Jsi_Interp *interp, Jsi_Func *func);\nextern void jsi_FuncObjFree(Jsi_FuncObj *fobj);\nextern Jsi_RC jsi_ArglistFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr);\nextern void jsi_FuncFree(Jsi_Interp *interp, Jsi_Func *func);\nextern void jsi_ToHexStr(const uchar *indata, int dlen, char *out);\nextern bool jsi_StrIsBalanced(char *str);\n\n#ifndef _JSI_MEMCLEAR\n#ifndef JSI_MEM_DEBUG\n#define _JSI_MEMCLEAR(ptr)\n#else\n#define _JSI_MEMCLEAR(ptr) memset(ptr, 0, sizeof(*ptr)) /* To aid debugging memory.*/\n#endif\n#endif\n\n#define MAX_SUBREGEX    256\n#define JSI__LONG_LONG\n#define UCHAR(s) (unsigned char)(s)\nextern char* jsi_SubstrDup(const char *a, int alen, int start, int len, int *olen);\nextern int jsi_typeGet(Jsi_Interp *interp , const char *tname);\nextern const char *jsi_typeName(Jsi_Interp *interp, int typ, Jsi_DString *dStr);\nextern Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ, Jsi_Value *arg, const char *p1, const char *p2, int index, Jsi_Func *func, bool isdefault);\nextern void jsi_FuncCallCheck(jsi_Pstate *p, jsi_Pline *line, int argc, bool isNew, const char *name, const char *namePre, Jsi_OpCodes *argCodes);\nextern Jsi_RC jsi_RunFuncCallCheck(Jsi_Interp *interp, Jsi_Func *func, int argc, const char *name, jsi_Pline *line, Jsi_OpCodes *argCodes, bool isParse);\nextern Jsi_RC jsi_FunctionSubCall(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Value *tocall, int discard);\nextern Jsi_ScopeStrs *jsi_ArgsOptAdd(jsi_Pstate *pstate, Jsi_ScopeStrs *a);\nextern Jsi_ScopeStrs *jsi_argInsert(jsi_Pstate *pstate, Jsi_ScopeStrs *a, const char *name, Jsi_Value *defValue, jsi_Pline *lPtr, bool prepend);\nextern Jsi_ScopeStrs* jsi_ParseArgStr(Jsi_Interp *interp, const char *argStr);\nextern Jsi_Value* jsi_AccessFile(Jsi_Interp *interp, const char *name, int mode);\nextern double jsi_GetTimestamp(void);\nextern const char *jsi_GetCurFile(Jsi_Interp *interp);\nextern void jsi_TypeMismatch(Jsi_Interp* interp);\nextern void jsi_SortDString(Jsi_Interp *interp, Jsi_DString *dStr, const char *sep);\nextern const char* jsi_GetDirective(Jsi_Interp *interp, Jsi_OpCodes *ops, const char *str);\nextern Jsi_Value* jsi_CommandCreate(Jsi_Interp *interp, const char *name, Jsi_CmdProc *cmdProc, void *privData, int flags, Jsi_CmdSpec *cspec);\nextern int jsi_GetDefaultType(const char *cp);\nextern Jsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str);\nextern Jsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc);\nextern Jsi_RC jsi_CDataDataSetCmdSub(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, int flags);\nextern Jsi_RC jsi_AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr);\nextern Jsi_Number jsi_VersionNormalize(Jsi_Number ver, char *obuf, size_t osiz);\nextern const char* jsi_FuncGetCode(Jsi_Interp *interp, Jsi_Func *func, int *lenPtr);\nextern Jsi_RC jsi_RegExpMatches(Jsi_Interp *interp, Jsi_Value *pattern, const char *str, int slen, Jsi_Value *ret, int *ofs, bool match);\nextern int jsi_AllObjOp(Jsi_Interp *interp, Jsi_Obj* obj, int op);\n//extern void jsi_AllValueOp(Jsi_Interp *interp, Jsi_Value* obj, int op);\nextern Jsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret); //TODO: EXPORT\nextern void jsi_SysPutsCmdPrefix(Jsi_Interp *interp, jsi_LogOptions *popts,Jsi_DString *dStr, int* quote, const char **fnPtr);\n\nextern char jsi_toHexChar(char code);\nextern char jsi_fromHexChar(char ch);\nextern bool Jsi_StrIsAlnum(const char *cp);\nextern char *jsi_TrimStr(char *str);\nextern bool jsi_ModBlacklisted(Jsi_Interp *interp, const char *mod);\nextern bool jsi_FuncIsNoop(Jsi_Interp* interp, Jsi_Value *func);\n\ntypedef enum {\n    _JSI_CDATA_INFO=0,\n    _JSI_CDATA_GET=1,\n    _JSI_CDATA_SET=2,\n    _JSI_CDATA_SIZE=3,\n    _JSI_CDATA_SCHEMA=4,\n    _JSI_CDATA_STRUCT=6\n} jsi_cdatasub;\n\n//extern Jsi_RC jsi_cdataMapsubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n//    Jsi_Value **ret, Jsi_Func *funcPtr, jsi_cdatasub sub);\n\n#define jsi_ValueString(pv) (pv->vt == JSI_VT_STRING ? &pv->d.s : \\\n  ((pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING) ? &pv->d.obj->d.s : NULL))\n                 \n#define jsi_PrefixMatch(str, cstr) (!Jsi_Strncmp(str, cstr, sizeof(cstr)-1))\n\n#ifdef JSI_MEM_DEBUG\n#define jsi_ValueDebugUpdate(interp, v, tbl, file, line, func) jsi_ValueDebugUpdate_(interp, &v->VD, v, interp->dbPtr->tbl, file, line, func)\n#define jsi_ValueDebugLabel(v,l1,l2) jsi_ValueDebugLabel_(&v->VD,l1,l2)\n\n#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueDup(interp,v) jsi_ValueDup(interp, v,__FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n\nextern Jsi_Value *jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func);\nextern Jsi_Value *jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func);\nextern Jsi_Value *jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func);\nextern Jsi_Obj *jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func);\nextern void jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2);\nextern void jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func);\nextern void jsi_DebugValue(Jsi_Value* v, const char *reason, uint idx, Jsi_Interp *interp);\nextern void jsi_DebugObj(Jsi_Obj* o, const char *reason, uint idx, Jsi_Interp *interp);\n\n#define jsi_DebugValueCallIdx() ++interp->dbPtr->memDebugCallIdx\n#define VALINIT { __VALSIG__ .refCnt=1, .vt=JSI_VT_UNDEF, .f={.flag=JSI_OM_ISSTATIC}, .d={}, .next=NULL, .prev=NULL, .VD={.fname=__FILE__, .line=__LINE__,.func=__PRETTY_FUNCTION__}  }\n#else\n#define VALINIT { __VALSIG__ .refCnt=1, .vt=JSI_VT_UNDEF, .f={.flag=JSI_OM_ISSTATIC}  }\n#define jsi_ValueDebugUpdate(interp, vd, v, tbl, file, line, func)\n#define jsi_ValueDebugLabel(v,l1,l2)\n#define jsi_DebugValue(v,r,i,t)\n#define jsi_DebugObj(o,r,i,t)\n#define jsi_DebugValueCallIdx() 0\n#define jsi_ValueDebugLabel_(v,l1,l2)\n#endif\n\n#define DECL_VALINIT(n) Jsi_Value n = VALINIT\n\nvoid jsi_TraceFuncCall(Jsi_Interp *interp, Jsi_Func *func, jsi_OpCode *iPtr, \n    Jsi_Value *_this, Jsi_Value* args, Jsi_Value *ret, int tc);\n\n\n#if JSI__SANITIZE\n#define Jsi_Malloc(sz) malloc(sz)\n#define Jsi_Calloc(nm, sz) calloc(nm,sz)\n#define Jsi_Realloc(ptr, sz) realloc(ptr,sz)\n#define Jsi_Free(ptr) free(ptr)\n#endif\n\nstruct Jsi_Stubs;\nextern struct Jsi_Stubs *jsiStubsTblPtr;\nextern const char *jsi_AssertModeStrs[];\nextern const char *jsi_callTraceStrs[];\nextern Jsi_CmdSpec cDataArrayCmds[];\n\n// Global Jsi internal state.\ntypedef struct {\n    Jsi_Interp *mainInterp;\n    Jsi_Interp *delInterp;\n    Jsi_Hash *interpsTbl;\n    bool isInit;\n    char *execName;\n    Jsi_Value *execValue;\n    Jsi_Chan stdChans[3];\n    Jsi_Filesystem *cwdFsPtr;\n    Jsi_DString pwdStr;\n    char *pwd;\n    int tolowerZvfs;\n    struct {\n        Jsi_Hash* fileHash;\n        Jsi_Hash *archiveHash;\n        int isInit;\n        Jsi_Interp *interp;\n    } zvfslocal;\n} jsi_IntData;\n\nextern jsi_IntData jsiIntData;\n\n#define jsi_Stdin jsiIntData.stdChans\n#define jsi_Stdout (jsiIntData.stdChans+1)\n#define jsi_Stderr (jsiIntData.stdChans+2)\n\n#define jsi_IIOF .flags=JSI_OPT_INIT_ONLY\n#define jsi_IIRO .flags=JSI_OPT_READ_ONLY\n\n#endif /* __JSIINT_H__ */\n", "#ifndef JSI_LITE_ONLY\n#define __JSIINT_C__\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <assert.h>\n\n#ifdef __WIN32\n#include <windows.h>\n#include <shlwapi.h>\n#ifndef JSI_OMIT_THREADS\n#include <process.h>\n#endif\n#else\n#ifndef JSI_OMIT_THREADS\n#include <pthread.h>\n#endif\n#endif\n\n#if (JSI_VERSION_MINOR<0 || JSI_VERSION_MINOR>99 || JSI_VERSION_RELEASE<0 || JSI_VERSION_RELEASE>99)\n#error \"VERSION MINOR/RELEASE not between 0-99 inclusive\"\n#endif\n\nstatic Jsi_OptionSpec InterpDebugOptions[] = {\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, debugCallback,  .help=\"Command in parent interp for handling debugging\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"file:string, line:number, level:number, func:string, opstr:string, bpId:number, emsg:string\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, doContinue,     .help=\"Continue execution until breakpoint\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, forceBreak,     .help=\"Force debugger to break\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeOnce,    .help=\"Source the file only if not already sourced\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, includeTrace,   .help=\"Trace includes\" ),\n    JSI_OPT(INT,   Jsi_DebugInterp, minLevel,       .help=\"Disable eval callback for level higher than this\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, msgCallback,    .help=\"Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,..\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, type:string, file:string, line:number, col:number\" ),\n    JSI_OPT(BOOL,  Jsi_DebugInterp, pkgTrace,       .help=\"Trace package loads\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, putsCallback,   .help=\"Comand in parent interp to handle puts output\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"msg:string, isStderr:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, traceCallback,  .help=\"Comand in parent interp to handle traceCall\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, args:string, ret:string, file:string, line:number, col:number\" ),\n    JSI_OPT(CUSTOM,Jsi_DebugInterp, testFmtCallback,.help=\"Comand in parent interp to format unittest string\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"cmd:string, line:number\" ),\n    JSI_OPT_END(Jsi_DebugInterp, .help=\"Interp options for debugging\")\n};\n\nJsi_OptionSpec jsi_InterpLogOptions[] = {\n    JSI_OPT(BOOL,   jsi_LogOptions, Test,    .help=\"Enable LogTest messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Debug,   .help=\"Enable LogDebug messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Trace,   .help=\"Enable LogTrace messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Info,    .help=\"Enable LogInfo messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Warn,    .help=\"Enable LogWarn messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, Error,   .help=\"Enable LogError messages\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, time,    .help=\"Prefix with time\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, date,    .help=\"Prefix with date\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, file,    .help=\"Ouptut contains file:line\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, func,    .help=\"Output function\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, full,    .help=\"Show full file path\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, ftail,   .help=\"Show tail of file only, even in LogWarn, etc\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, before,  .help=\"Output file:line before message string\" ),\n    JSI_OPT(BOOL,   jsi_LogOptions, isUTC,   .help=\"Time is to be UTC\" ),\n    JSI_OPT(STRKEY, jsi_LogOptions, timeFmt, .help=\"A format string to use with strftime\" ),\n    JSI_OPT(USEROBJ,jsi_LogOptions, chan,    .help=\"Channel to send output to\", .flags=0, .custom=0, .data=(void*)\"Channel\" ),\n    JSI_OPT_END(jsi_LogOptions, .help=\"Interp options for logging\")\n};\nstatic Jsi_OptionSpec InterpSubOptions[] = {\n    JSI_OPT(STRKEY,jsi_SubOptions, blacklist,   .help=\"Comma separated modules to disable loading for\", jsi_IIOF ),\n    JSI_OPT(BOOL,  jsi_SubOptions, compat,      .help=\"Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser\" ),\n    JSI_OPT(INT,   jsi_SubOptions, dblPrec,     .help=\"Format precision of double where 0=max, -1=max-1, ... (max-1)\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, istty,       .help=\"Indicates interp is in interactive mode\", jsi_IIRO),\n    JSI_OPT(BOOL,  jsi_SubOptions, logColNums,  .help=\"Display column numbers in error messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, logAllowDups,.help=\"Log should not filter out duplicate messages\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, mutexUnlock, .help=\"Unlock own mutex when evaling in other interps (true)\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noproto,     .help=\"Disable support of the OOP symbols:  __proto__, prototype, constructor, etc\"),\n    JSI_OPT(BOOL,  jsi_SubOptions, noFuncString,.help=\"Disable viewing code body for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noRegex,     .help=\"Disable viewing code for functions\", jsi_IIOF),\n    JSI_OPT(BOOL,  jsi_SubOptions, noReadline,  .help=\"In interactive mode disable use of readline\" ),\n    JSI_OPT(BOOL,  jsi_SubOptions, outUndef,    .help=\"In interactive mode output result values that are undefined\"),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt,      .help=\"Prompt for interactive mode ('$ ')\" ),\n    JSI_OPT(STRKEY,jsi_SubOptions, prompt2,     .help=\"Prompt for interactive mode line continue ('> ')\" ),\n    JSI_OPT_END(jsi_SubOptions, .help=\"Lesser sub-feature options\")\n};\n\nstatic const char *jsi_SafeModeStrs[] = { \"none\", \"read\", \"write\", \"writeRead\", \"lockdown\", NULL };\nstatic const char *jsi_TypeChkStrs[] = { \"parse\", \"run\", \"all\", \"error\", \"strict\", \"noundef\", \"nowith\", \"funcsig\", NULL };\nconst char *jsi_callTraceStrs[] = { \"funcs\", \"cmds\", \"new\", \"return\", \"args\", \"notrunc\", \"noparent\", \"full\", \"before\", NULL};\nconst char *jsi_AssertModeStrs[] = { \"throw\", \"log\", \"puts\", NULL};\n\nstatic Jsi_OptionSpec InterpOptions[] = {\n    JSI_OPT(ARRAY, Jsi_Interp, args,        .help=\"The console.arguments for interp\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, asserts,     .help=\"Enable assert\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, assertMode,  .help=\"Action upon assert failure\", .flags=0, .custom=Jsi_Opt_SwitchEnum, .data=jsi_AssertModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, autoFiles,   .help=\"File(s) to source for loading Jsi_Auto to handle unknown commands\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, busyCallback,.help=\"Command in parent interp (or noOp) to periodically call\", .flags=0, .custom=Jsi_Opt_SwitchParentFunc, .data=(void*)\"interpName:string, opCnt:number\"),\n    JSI_OPT(INT   ,Jsi_Interp, busyInterval,.help=\"Call busyCallback command after this many op-code evals (100000)\"),\n    JSI_OPT(STRKEY,Jsi_Interp, confFile,    .help=\"Config file of options in non-strict JSON form\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, coverage,    .help=\"On exit generate detailed code coverage for function calls (with profile)\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, debugOpts,   .help=\"Options for debugging\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpDebugOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, interactive, .help=\"Force interactive mode. ie. ignore no_interactive flag\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, hasOpenSSL,  .help=\"Is SSL available in WebSocket\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, historyFile, .help=\"In interactive mode, file to use for history (~/.jsish_history)\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, isSafe,      .help=\"Is this a safe interp (ie. with limited or no file access)\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, jsppChars,   .help=\"Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string\"),\n    JSI_OPT(FUNC,  Jsi_Interp, jsppCallback,.help=\"Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number)\"),\n    JSI_OPT(INT,   Jsi_Interp, lockTimeout, .help=\"Thread time-out for mutex lock acquires (milliseconds)\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, logOpts,     .help=\"Options for log output to add file/line/time\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=jsi_InterpLogOptions),\n    JSI_OPT(INT,   Jsi_Interp, maxDepth,    .help=\"Depth limit of recursive function calls (1000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(UINT,  Jsi_Interp, maxArrayList,.help=\"Maximum array convertable to list (100000)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxIncDepth, .help=\"Maximum allowed source/require nesting depth (50)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxInterpDepth,.help=\"Maximum nested subinterp create depth (10)\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(INT,   Jsi_Interp, maxUserObjs, .help=\"Maximum number of 'new' object calls, eg. File, RegExp, etc\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, maxOpCnt,    .help=\"Execution limit for op-code evaluation\", jsi_IIOF|JSI_OPT_LOCKSAFE ),\n    JSI_OPT(INT,   Jsi_Interp, memDebug,    .help=\"Memory debugging level: 1=summary, 2=detail\", .flags=JSI_OPT_NO_CLEAR),\n    JSI_OPT(STRKEY,Jsi_Interp, name,        .help=\"Optional text name for this interp\"),\n    JSI_OPT(BOOL,  Jsi_Interp, noAutoLoad,  .help=\"Disable autoload\", .flags=JSI_OPT_LOCKSAFE ),\n    JSI_OPT(BOOL,  Jsi_Interp, noConfig,    .help=\"Disable use of Interp.conf to change options after create\", jsi_IIOF),\n    JSI_OPT(BOOL,  Jsi_Interp, noInput,     .help=\"Disable use of console.input()\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noLoad,      .help=\"Disable load of shared libs\", .flags=JSI_OPT_LOCKSAFE),\n    JSI_OPT(BOOL,  Jsi_Interp, noNetwork,   .help=\"Disable new Socket/WebSocket, or load of builtin MySql\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noStderr,    .help=\"Make puts, log, assert, etc use stdout\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, noSubInterps,.help=\"Disallow sub-interp creation\"),\n    JSI_OPT(FUNC,  Jsi_Interp, onComplete,  .help=\"Function to return commands completions for interactive mode.  Default uses Info.completions \", .flags=0, .custom=0, .data=(void*)\"prefix:string, start:number, end:number\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onEval,      .help=\"Function to get control for interactive evals\", .flags=0, .custom=0, .data=(void*)\"cmd:string\" ),\n    JSI_OPT(FUNC,  Jsi_Interp, onExit,      .help=\"Command to call in parent on exit, returns true to continue\", jsi_IIOF , .custom=0, .data=(void*)\"\"),\n    JSI_OPT(ARRAY, Jsi_Interp, pkgDirs,     .help=\"list of library directories for require() to search\" ),\n    JSI_OPT(BOOL,  Jsi_Interp, profile,     .help=\"On exit generate profile of function calls\"),\n    JSI_OPT(VALUE, Jsi_Interp, retValue,    .help=\"Return value from last eval\", jsi_IIRO),\n    JSI_OPT(CUSTOM,Jsi_Interp, safeMode,    .help=\"In safe mode source() support for pwd and script-dir \", jsi_IIOF, .custom=Jsi_Opt_SwitchEnum, .data=jsi_SafeModeStrs ),\n    JSI_OPT(ARRAY, Jsi_Interp, safeReadDirs,.help=\"In safe mode, files/dirs to allow reads to\", jsi_IIOF),\n    JSI_OPT(ARRAY, Jsi_Interp, safeWriteDirs,.help=\"In safe mode, files/dirs to allow writes to\", jsi_IIOF),\n    JSI_OPT(STRKEY, Jsi_Interp,safeExecPattern,.help=\"In safe mode, regexp pattern allow exec of commands\", jsi_IIOF),\n    JSI_OPT(STRKEY,Jsi_Interp, scriptStr,   .help=\"Interp init script string\", jsi_IIOF),\n    JSI_OPT(STRING,Jsi_Interp, scriptFile,  .help=\"Interp init script file\"),\n    JSI_OPT(STRING,Jsi_Interp, stdinStr,    .help=\"String to use as stdin for console.input()\"),\n    JSI_OPT(STRING,Jsi_Interp, stdoutStr,   .help=\"String to collect stdout for puts()\"),\n    JSI_OPT(BOOL,  Jsi_Interp, strict,      .help=\"Globally enable strict: same as 'use strict' in main program\"),\n    JSI_OPT(CUSTOM,Jsi_Interp, subOpts,     .help=\"Infrequently used sub-options\", .flags=0, .custom=Jsi_Opt_SwitchSuboption, .data=InterpSubOptions),\n    JSI_OPT(BOOL,  Jsi_Interp, subthread,   .help=\"Create a threaded Interp\", jsi_IIOF|JSI_OPT_LOCKSAFE),\n    JSI_OPT(CUSTOM,Jsi_Interp, traceCall,   .help=\"Trace commands\", .flags=0,  .custom=Jsi_Opt_SwitchBitset,  .data=jsi_callTraceStrs),\n    JSI_OPT(INT,   Jsi_Interp, traceOp,     .help=\"Set debugging level for OPCODE execution\"),\n    JSI_OPT(BOOL,  Jsi_Interp, tracePuts,   .help=\"Trace puts by making it use logOpts\" ),\n    JSI_OPT(CUSTOM,Jsi_Interp, typeCheck,   .help=\"Type-check control options\", .flags=0, .custom=Jsi_Opt_SwitchBitset, .data=jsi_TypeChkStrs),\n    JSI_OPT(INT,   Jsi_Interp, typeWarnMax, .help=\"Type checking is silently disabled after this many warnings (50)\" ),\n    JSI_OPT(OBJ,   Jsi_Interp, udata,       .help=\"User data\"),\n    JSI_OPT(UINT,  Jsi_Interp, unitTest,    .help=\"Unit test control bits: 1=subst, 2=Puts with file:line prefix\" ),\n    JSI_OPT_END(Jsi_Interp, .help=\"Options for the Jsi interpreter\")\n};\n\n/* Object for each interp created. */\ntypedef struct InterpObj {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    Jsi_Interp *subinterp;\n    Jsi_Interp *parent;\n    //char *interpname;\n    char *mode;\n    Jsi_Obj *fobj;\n    int objId;\n    int deleting;\n} InterpObj;\n\n/* Global state of interps. */\n\ntypedef struct {\n#ifdef JSI_HAS_SIG\n    jsi_Sig sig;\n#endif\n    int refCount;\n    const char *cmdName;\n    Jsi_Value *args;\n    Jsi_Value *func;\n    Jsi_Value *cmdVal;\n    InterpObj *intobj;\n    Jsi_Interp *dinterp; // Dest interp.\n    Jsi_Interp *subinterp;\n} AliasCmd;\n\n\nstatic void interpObjErase(InterpObj *fo);\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data);\nstatic bool interpObjIsTrue(void *data);\nstatic bool interpObjEqual(void *data1, void *data2);\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp);\n\n/* Call a command with JSON args.  Returned string by using Jsi_ValueGetDString(..., flags). */\nJsi_RC Jsi_EvalCmdJSON(Jsi_Interp *interp, const char *cmd, const char *jsonArgs, Jsi_DString *dStr, int flags)\n{\n    if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_CommandInvokeJSON(interp, cmd, jsonArgs, &nrPtr);\n    Jsi_DSInit(dStr);\n    Jsi_ValueGetDString(interp, nrPtr, dStr, flags /*JSI_OUTPUT_JSON*/);\n    Jsi_DecrRefCount(interp, nrPtr);\n    Jsi_MutexUnlock(interp, interp->Mutex);\n    return rc;\n}\n\n/* Call a function with JSON args.  Return a primative. */\nJsi_RC Jsi_FunctionInvokeJSON(Jsi_Interp *interp, Jsi_Value *func, const char *json, Jsi_Value **ret)\n{\n    if (!Jsi_ValueIsFunction(interp, func))\n        return JSI_ERROR;\n    Jsi_Value *aPtr = Jsi_ValueNew1(interp);\n    Jsi_RC rc = Jsi_JSONParse(interp, json, &aPtr, 0);\n    if (rc == JSI_OK)\n        rc = Jsi_FunctionInvoke(interp, func, aPtr, ret, NULL);\n    Jsi_DecrRefCount(interp, aPtr);\n    return rc;\n}\n/* Lookup cmd from cmdstr and invoke with JSON args. */\n/*\n *   Jsi_CommandInvokeJSON(interp, \"info.cmds\", \"[\\\"*\\\",true]\", ret);\n */\nJsi_RC Jsi_CommandInvokeJSON(Jsi_Interp *interp, const char *cmdstr, const char *json, Jsi_Value **ret)\n{\n    Jsi_Value *func = Jsi_NameLookup(interp, cmdstr);\n    if (func)\n        return Jsi_FunctionInvokeJSON(interp, func, json, ret);\n    return Jsi_LogError(\"can not find cmd: %s\", cmdstr);\n}\n\n/* Clean-copying of value between interps: uses JSON parse if needed. */\nJsi_RC Jsi_CleanValue(Jsi_Interp *interp, Jsi_Interp *tointerp, Jsi_Value *val, Jsi_Value **ret)\n{\n    Jsi_RC rc = JSI_OK;\n    const char *cp;\n    int len, iskey;\n    Jsi_Obj *obj;\n    switch (val->vt) {\n        case JSI_VT_UNDEF: Jsi_ValueMakeUndef(interp, ret); return rc;\n        case JSI_VT_NULL: Jsi_ValueMakeNull(tointerp, ret); return rc;\n        case JSI_VT_BOOL: Jsi_ValueMakeBool(tointerp, ret, val->d.val); return rc;\n        case JSI_VT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, val->d.num); return rc;\n        case JSI_VT_STRING:\n            iskey = val->f.bits.isstrkey;\n            cp = val->d.s.str;\n            len = val->d.s.len;\nmakestr:\n            if (iskey) {\n                Jsi_ValueMakeStringKey(interp, ret, cp);\n                return rc;\n            }\n            jsi_ValueMakeBlobDup(tointerp, ret, (uchar*)cp, len);\n            return rc;\n        case JSI_VT_OBJECT:\n            obj = val->d.obj;\n            switch (obj->ot) {\n                case JSI_OT_BOOL: Jsi_ValueMakeBool(tointerp, ret, obj->d.val); return rc;\n                case JSI_OT_NUMBER: Jsi_ValueMakeNumber(tointerp, ret, obj->d.num); return rc;\n                case JSI_OT_STRING:\n                    cp = obj->d.s.str;\n                    len = obj->d.s.len;\n                    iskey = obj->isstrkey;\n                    goto makestr;\n                default: break;\n            }\n            break;\n        default:\n            break;\n    }\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    cp = Jsi_ValueGetDString(interp, val, &dStr, JSI_OUTPUT_JSON);\n    if (Jsi_JSONParse(tointerp, cp, ret, 0) != JSI_OK) {\n        Jsi_DSFree(&dStr);\n        return Jsi_LogWarn(\"bad JSON parse in subinterp\");\n    }\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\n/* Invoke command in target interp. */\nJsi_RC jsi_AliasInvoke(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    AliasCmd *ac = (AliasCmd *)funcPtr->cmdSpec->reserved[2];\n    Jsi_Interp *dinterp = ac->dinterp;\n    Jsi_Value *nargs = NULL;\n    int inc=0, argc = Jsi_ValueGetLength(interp, args);\n    if (!ac) {\n        Jsi_LogBug(\"BAD ALIAS INVOKE OF DELETED\");\n        return JSI_ERROR;\n    }\n    SIGASSERT(ac,ALIASCMD);\n    bool isthrd = (interp != dinterp && interp->threadId != dinterp->threadId);\n    Jsi_Value *nrPtr = Jsi_ValueNew1(dinterp);\n\n     if (argc == 0 && ac->args)\n        nargs = ac->args;\n     else if (argc) {\n        if (dinterp == interp)\n            Jsi_ValueCopy(interp, nrPtr, args);\n        else if (Jsi_CleanValue(interp, dinterp, args, &nrPtr) != JSI_OK)\n            return JSI_ERROR;\n        if (ac->args && Jsi_ValueGetLength(dinterp, ac->args)) {\n            nargs = Jsi_ValueArrayConcat(dinterp, ac->args, nrPtr);\n            Jsi_IncrRefCount(dinterp, nargs);\n            inc=1;\n        } else {\n            nargs = nrPtr;\n        }\n    }\n\n    if (isthrd) {\n        /* Post to thread event in sub-interps queue. */\n        if (Jsi_MutexLock(interp, dinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n\n       /* Is an async call. */\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        // TODO: is s->data inited?\n        Jsi_DSInit(&s->data);\n        Jsi_ValueGetDString(interp, nargs, &s->data, JSI_OUTPUT_JSON);\n        if (inc)\n            Jsi_DecrRefCount(dinterp, nargs);\n        Jsi_DecrRefCount(dinterp, nrPtr);\n        s->acfunc = ac->func;\n        Jsi_IncrRefCount(dinterp, ac->func);\n        se = dinterp->interpStrEvents;\n        if (!se)\n            dinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, dinterp->QMutex);\n        return JSI_OK;\n    }\n\n    if (dinterp != interp) {\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, dinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n    }\n    ac->refCount++;\n    Jsi_Value *srPtr, **srpPtr = ret;\n    if (dinterp != interp) {\n        srPtr = Jsi_ValueNew1(dinterp);\n        srpPtr = &srPtr;\n    }\n    Jsi_RC rc = Jsi_FunctionInvoke(dinterp, ac->func, nargs, srpPtr, NULL);\n    ac->refCount--;\n    if (inc)\n        Jsi_DecrRefCount(dinterp, nargs);\n    Jsi_DecrRefCount(dinterp, nrPtr);\n    if (dinterp != interp) {\n        Jsi_MutexUnlock(interp, dinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            return JSI_ERROR;\n        }\n    }\n    if (dinterp != interp) {\n        Jsi_CleanValue(dinterp, interp, *srpPtr, ret);\n        Jsi_DecrRefCount(dinterp, srPtr);\n        if (rc != JSI_OK && dinterp->errMsgBuf[0] && interp != dinterp) {\n            Jsi_Strcpy(interp->errMsgBuf, dinterp->errMsgBuf);\n            interp->errLine = dinterp->errLine;\n            interp->errFile = dinterp->errFile;\n            dinterp->errMsgBuf[0] = 0;\n        }\n    }\n    return rc;\n}\n\n\nstatic Jsi_RC jsi_AliasFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *data) {\n    /* TODO: deal with other copies of func may be floating around (refCount). */\n    AliasCmd *ac = (AliasCmd *)data;\n    if (!ac) return JSI_ERROR;\n    SIGASSERT(ac,ALIASCMD);\n    if (ac->func)\n        Jsi_DecrRefCount(ac->dinterp, ac->func);\n    if (ac->args)\n        Jsi_DecrRefCount(ac->dinterp, ac->args);\n    if (!ac->cmdVal)\n        return JSI_OK;\n    Jsi_Func *fobj = ac->cmdVal->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = NULL;\n    fobj->cmdSpec->proc = NULL;\n    if (ac->intobj && ac->intobj->subinterp) {\n        Jsi_CommandDelete(ac->intobj->subinterp, ac->cmdName);\n        //if (Jsi_Strchr(ac->cmdName, '.'))\n        //    Jsi_LogBug(\"alias free with X.Y dot name leaks memory: %s\", ac->cmdName);\n    } else\n        Jsi_DecrRefCount(ac->subinterp, ac->cmdVal);\n    _JSI_MEMCLEAR(ac);\n    Jsi_Free(ac);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_AliasCreateCmd(Jsi_Interp* interp, const char* key, AliasCmd* ac) {\n    if (Jsi_InterpGone(interp))\n        return JSI_ERROR;\n    key = Jsi_KeyAdd(interp, key);\n    Jsi_Value *cmd = jsi_CommandCreate(interp, key, jsi_AliasInvoke, NULL, 0, 0);\n    if (!cmd)\n        return Jsi_LogBug(\"command create failure\");\n    ac->cmdVal = cmd;\n    Jsi_Func *fobj = cmd->d.obj->d.fobj->func;\n    fobj->cmdSpec->reserved[2] = ac;\n    cmd->d.obj->isNoOp = (ac->func->d.obj->d.fobj->func->callback == jsi_NoOpCmd);\n    return JSI_OK;\n}\n\n#define FN_intalias JSI_INFO(\"With 0 args, returns list of all aliases in interp.\\n\\\nWith 1 arg returns func for given alias name.\\n\\\nWith 2 args where arg2 == null, returns args for given alias name .\\n\\\nWith 3 args, create/update an alias for func and args. \\n\\\nDelete an alias by creating it with null for both func and args.\")\nstatic Jsi_RC InterpAliasCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = (udf ? udf->subinterp : interp );\n    Jsi_Hash *aliases = sinterp->aliasHash;\n    if (!aliases)\n        return Jsi_LogError(\"Sub-interp gone\");\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, aliases, ret, 0);\n    Jsi_HashEntry *hPtr;\n    char *key = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (!key)\n        return Jsi_LogError(\"expected string\");\n    AliasCmd* ac;\n    if (argc == 1) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->func);\n        return JSI_OK;\n    }\n    Jsi_Value *afunc = Jsi_ValueArrayIndex(interp, args, 1);\n    if (argc == 2) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (!hPtr)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!Jsi_ValueIsNull(interp, afunc))\n            return Jsi_LogError(\"arg 2: expected null to query args\");\n        if (!ac) return JSI_ERROR;\n        SIGASSERT(ac,ALIASCMD);\n        Jsi_ValueDup2(interp, ret, ac->args); //TODO: JSON??\n        return JSI_OK;\n    }\n    \n    if (argc < 3)\n        return JSI_ERROR;\n    bool isthrd = (interp->threadId != sinterp->threadId);\n    //if (isthrd)\n        //return Jsi_LogError(\"alias not supported with threads\");\n    bool isNew;\n    Jsi_Value *aargs = Jsi_ValueArrayIndex(interp, args, 2);\n    if (Jsi_ValueIsNull(interp, afunc) && Jsi_ValueIsNull(interp, aargs)) {\n        hPtr = Jsi_HashEntryFind(aliases, (void*)key);\n        if (hPtr == NULL)\n            return JSI_OK;\n        ac = (AliasCmd*)Jsi_HashValueGet(hPtr);\n        if (!ac) return JSI_ERROR;\n        if (0 && ac->cmdVal)\n            Jsi_DecrRefCount(interp, ac->cmdVal);\n        jsi_AliasFree(interp, NULL, ac);\n        Jsi_HashValueSet(hPtr, NULL);\n        Jsi_HashEntryDelete(hPtr);\n        return JSI_OK;\n    }\n    hPtr = Jsi_HashEntryNew(aliases, (void*)key, &isNew);\n    if (!hPtr)\n        return Jsi_LogError(\"create failed: %s\", key);\n    if (!Jsi_ValueIsFunction(interp, afunc))\n        return Jsi_LogError(\"arg 2: expected function\");\n    if (Jsi_ValueIsNull(interp, aargs) == 0 && Jsi_ValueIsArray(interp, aargs) == 0)\n        return Jsi_LogError(\"arg 3: expected array or null\");\n    if (!isNew) {\n        jsi_AliasFree(interp, NULL, Jsi_HashValueGet(hPtr));\n    }\n    ac = (AliasCmd*)Jsi_Calloc(1, sizeof(AliasCmd));\n    SIGINIT(ac, ALIASCMD);\n    ac->cmdName = (const char*)Jsi_HashKeyGet(hPtr);\n    ac->func = afunc;\n    Jsi_IncrRefCount(interp, afunc);\n    if (!Jsi_ValueIsNull(interp, aargs)) {\n        ac->args = aargs;\n        Jsi_IncrRefCount(interp, aargs);\n    }\n    ac->intobj = udf;\n    ac->dinterp = interp;\n    ac->subinterp = sinterp;\n    Jsi_HashValueSet(hPtr, ac);\n    if (!isthrd)\n        return jsi_AliasCreateCmd(sinterp, key, ac);\n\n    Jsi_Value *vasync = Jsi_ValueArrayIndex(interp, args, 3);\n    bool async = 0;\n    if (vasync && Jsi_GetBoolFromValue(interp, vasync, &async))\n        return JSI_ERROR;\n        \n    if (!async) {\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_RC rc = jsi_AliasCreateCmd(sinterp, key, ac);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    s->acdata = ac;\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, ac->cmdName, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCodeTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_Pstate *ps = (jsi_Pstate *)ptr;\n    if (!ps) return JSI_OK;\n    ps->hPtr = NULL;\n    jsi_PstateFree(ps);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeOnDeleteTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    Jsi_DeleteProc *proc = (Jsi_DeleteProc *)ptr;\n    proc(interp, NULL);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeAssocTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_DelAssocData(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeEventTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Event *event = (Jsi_Event *)ptr;\n    SIGASSERT(event,EVENT);\n    if (!ptr) return JSI_OK;\n    Jsi_HashValueSet(event->hPtr, NULL);\n    event->hPtr = NULL;\n    Jsi_EventFree(interp, event);\n    return JSI_OK;\n}\nJsi_RC jsi_HashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Free(ptr);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC packageHashFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    jsi_PkgInfo *p = (jsi_PkgInfo*)ptr;\n    if (p->popts.info) Jsi_DecrRefCount(interp, p->popts.info);\n    Jsi_Free(p);\n    return JSI_OK;\n}\n\nstatic Jsi_RC regExpFree(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_RegExpFree((Jsi_Regex*)ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeCmdSpecTbl(Jsi_Interp *interp, Jsi_MapEntry *hPtr, void *ptr) {\n    if (!ptr) return JSI_OK;\n    jsi_CmdSpecDelete(interp, ptr);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeGenObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *obj = (Jsi_Obj *)ptr;\n    SIGASSERT(obj,OBJ);\n    if (!obj) return JSI_OK;\n    Jsi_ObjDecrRefCount(interp, obj);\n    return JSI_OK;\n}\n\n\nstatic Jsi_RC freeFuncsTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Func *func = (Jsi_Func *)ptr;\n    if (!func) return JSI_OK;\n    SIGASSERT(func,FUNC);\n    func->hPtr = NULL;\n    jsi_FuncFree(interp, func);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeFuncObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj) {\n        if (v->d.fobj->scope) {\n            jsi_ScopeChain *scope = v->d.fobj->scope;\n            v->d.fobj->scope = NULL;\n            jsi_ScopeChainFree(interp, scope);\n        }\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeBindObjTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Obj *v = (Jsi_Obj *)ptr;\n    if (!v) return JSI_OK;\n    SIGASSERT(v,OBJ);\n    if (v->ot != JSI_OT_FUNCTION)\n        fprintf(stderr, \"invalid func obj\\n\");\n    else if (v->d.fobj && v->d.fobj->scope) {\n        v->d.fobj->scope = NULL;\n    }\n    Jsi_ObjDecrRefCount(interp, v);\n    return JSI_OK;\n}\n\n/* TODO: incr ref before add then just decr till done. */\nstatic Jsi_RC freeValueTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    Jsi_Value *val = (Jsi_Value *)ptr;\n    if (!val) return JSI_OK;\n    SIGASSERT(val,VALUE);\n    //printf(\"GEN: %p\\n\", val);\n   /* if (val->refCnt>1)\n        Jsi_DecrRefCount(interp, val);*/\n    Jsi_DecrRefCount(interp, val);\n    return JSI_OK;\n}\n\nstatic Jsi_RC freeUserdataTbl(Jsi_Interp *interp, Jsi_HashEntry *hPtr, void *ptr) {\n    if (ptr)\n        jsi_UserObjDelete(interp, ptr);\n    return JSI_OK;\n}\n\nvoid Jsi_ShiftArgs(Jsi_Interp *interp, Jsi_Value *v) {\n    if (!v)\n        v = interp->args;\n    if (v==NULL || v->vt != JSI_VT_OBJECT || v->d.obj->arr == NULL || v->d.obj->arrCnt <= 0)\n        return;\n    Jsi_Obj *obj = v->d.obj;\n    int n = v->d.obj->arrCnt;\n    n--;\n    v = obj->arr[0];\n    if (v)\n        Jsi_DecrRefCount(interp, v);\n    if (n>0)\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n    obj->arr[n] = NULL;\n    Jsi_ObjSetLength(interp, obj, n);\n}\n\nJsi_Value *Jsi_Executable(Jsi_Interp *interp)\n{\n    return jsiIntData.execValue;\n}\n\nstatic Jsi_RC KeyLocker(Jsi_Hash* tbl, int lock)\n{\n    if (!lock)\n        Jsi_MutexUnlock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    else\n        return Jsi_MutexLock(jsiIntData.mainInterp, jsiIntData.mainInterp->Mutex);\n    return JSI_OK;\n}\n\n#ifdef JSI_USE_MANY_STRKEY\nstatic Jsi_RC KeyLockerTree(Jsi_Tree* tree, int lock) { return KeyLocker((Jsi_Hash*)tree, lock); }\n#endif\n\nstatic int jsi_deleted = 0, jsi_exitCode = 0; // TODO: move to jsiIntData\nstatic Jsi_Value *jsi_vf = NULL;\n\nstatic Jsi_RC jsi_InterpDelete(Jsi_Interp *interp, void *ptr) {\n    if (jsi_vf)\n        Jsi_DecrRefCount(interp, jsi_vf);\n    jsi_vf = NULL;\n    jsi_exitCode = interp->exitCode;\n    jsi_deleted = 1;\n    return JSI_OK;\n}\n\nJsi_Interp* Jsi_Main(Jsi_InterpOpts *opts)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_Interp* interp = NULL;\n    int argc = 0, first = 1;\n    char **argv = NULL;\n    if (opts) {\n        interp = opts->interp;\n        argc = opts->argc;\n        argv = opts->argv;\n    }\n    if (!interp)\n        interp = Jsi_InterpNew(opts);\n    if (!interp)\n        return NULL;\n    Jsi_InterpOnDelete(interp, &jsi_InterpDelete, (void*)&jsi_InterpDelete);\n    argc -= interp->iskips;\n    argv += interp->iskips;\n\n#ifndef NO_JAZ\n    /* Mount zip at end of executable */\n    Jsi_Value *v = Jsi_Executable(interp);\n    const char *exeFile = (v?Jsi_ValueString(interp, v, NULL):NULL);\n    int jsFound = 0;\n    if (v && (argc != 2 || Jsi_Strcmp(argv[1], \"--nozvfs\"))) {\n        rc = Jsi_EvalZip(interp, exeFile, JSI_ZVFS_DIR, &jsFound);\n        if (rc == JSI_OK) {\n            interp->selfZvfs = 1;\n            if (!jsFound) {\n#if (JSI__FILESYS && JSI__ZVFS)\n                fprintf(stderr, \"warning: no main.jsi or autoload.jsi\\n\");\n#endif\n            }\n            if (jsi_deleted)\n                return jsi_DoExit(interp, jsi_exitCode);\n            else if (rc != 0) {\n                fprintf(stderr, \"Error\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        }\n    }\n#endif\n    const char *ext = NULL, *ai1, *iext = (argc<=1?NULL:Jsi_Strrchr(argv[1], '.'));\n    if (interp->selfZvfs && iext && Jsi_Strcmp(iext,\".fossil\")==0) {\n        rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n        goto done;\n    }\n    Jsi_ShiftArgs(interp, NULL);\n    if (argc <= 1) {\n        if (interp->opts.no_interactive && !interp->interactive)\n            return interp;\n        rc = Jsi_Interactive(interp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n        goto done;\n    }\n    ai1 = argv[1];\n    if ((!Jsi_Strcmp(ai1, \"-help\") || !Jsi_Strcmp(ai1, \"-h\")) && argc<=3) {\n        if (argc>2) {\n            if (Jsi_PkgRequire(interp, \"Help\", 0)>=0) {\n                char tbuf[BUFSIZ];\n                snprintf(tbuf, sizeof(tbuf), \"return runModule('Help', '%s'.trim().split(null));\", argv[2]);\n                Jsi_RC rc = Jsi_EvalString(interp, tbuf, 0);\n                const char *hstr = Jsi_ValueToString(interp, interp->retValue, NULL);\n                if (rc == JSI_OK)\n                    puts(hstr);\n                return jsi_DoExit(interp, 1);\n            }\n        }\n        dohelp:\n        puts(\"USAGE:\\n  jsish [PREFIX-OPTS] [COMMAND-OPTS|FILE] ...\\n\"\n          \"\\nPREFIX-OPTS:\\n\"\n          \"  --C FILE\\tOption file of config options.\\n\"\n          \"  --F\\t\\tTrace all function calls and returns.\\n\"\n          \"  --I OPT:VAL\\tInterp option: equivalent to Interp.conf({OPT:VAL}).\\n\"\n          \"  --L PATH\\tSet safeMode to \\\"lockdown\\\" using PATH for safe(Read/Write)Dirs.\\n\"\n          \"  --T OPT\\tTypecheck option: equivalent to \\\"use OPT\\\".\\n\"\n          \"  --U\\t\\tDisplay unittest output, minus pass/fail compare.\\n\"\n          \"  --V\\t\\tSame as --U, but adds file and line number to output.\\n\"\n          \"\\nCOMMAND-OPTS:\\n\"\n          \"  -a\\t\\tArchive: mount an archive (zip, sqlar or fossil repo) and run module.\\n\"\n          \"  -c\\t\\tCData: generate .c or JSON output from a .jsc description.\\n\"\n          \"  -d\\t\\tDebug: console script debugger.\\n\"\n          \"  -e CODE ...\\tEvaluate javascript CODE.\\n\"\n          \"  -g\\t\\tGendeep: generate html output from markdeep source.\\n\"\n          \"  -h ?CMD?\\tHelp: show help for jsish or its commands.\\n\"\n          \"  -m\\t\\tModule: utility create/manage/invoke a Module.\\n\"\n          \"  -s\\t\\tSafe: runs script in safe sub-interp.\\n\"\n          \"  -u\\t\\tUnitTest: test script file(s) or directories .js/.jsi files.\\n\"\n          \"  -w\\t\\tWget: web client to download file from url.\\n\"\n          \"  -v\\t\\tVersion: show version detail: add an arg to show only X.Y.Z\\n\"\n          \"  -z\\t\\tZip: append/manage zip files at end of executable.\\n\"\n          \"  -D\\t\\tDebugUI: web-gui script debugger.\\n\"\n          \"  -J\\t\\tJSpp: preprocess javascript for web.\\n\"\n          \"  -S\\t\\tSqliteUI: web-gui for sqlite database file.\\n\"\n          \"  -W\\t\\tWebsrv: web server to serve out content.\\n\"\n          \"\\nInterp options may also be set via the confFile.'\\n\"\n           );\n        return jsi_DoExit(interp, 1);\n    }\n    if (!Jsi_Strcmp(ai1, \"-version\"))\n        ai1 = \"-v\";\n    if (ai1[0] == '-') {\n        switch (ai1[1]) {\n            case 'a':\n                rc = Jsi_EvalString(interp, \"runModule('Archive');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'c':\n                rc = Jsi_EvalString(interp, \"runModule('Cdata');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'd':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('Debug');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'D':\n                interp->debugOpts.isDebugger = 1;\n                rc = Jsi_EvalString(interp, \"runModule('DebugUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'e':\n                if (argc < 3)\n                    rc = Jsi_LogError(\"missing argument\");\n                else {\n                    rc = Jsi_EvalString(interp, argv[2], JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n                    if (rc == JSI_OK && argc>3) {\n                        first += 2;\n                        Jsi_ShiftArgs(interp, NULL);\n                        Jsi_ShiftArgs(interp, NULL);\n                        goto dofile;\n                    }\n                }\n                break;\n            case 'g':\n                rc = Jsi_EvalString(interp, \"runModule('GenDeep');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'h':\n                goto dohelp;\n            case 'J':\n                rc = Jsi_EvalString(interp, \"runModule('Jspp');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'm':\n                if (argc <= 2 || argv[2][0] == '-')\n                    rc = Jsi_EvalString(interp, \"runModule('Module');\", JSI_EVAL_ISMAIN);\n                else {\n                    Jsi_DString dStr = {}, eStr = {};\n                    const char *cps, *cpe;\n                    cps = Jsi_Strrchr(argv[2], '/');\n                    if (cps) cps++; else cps = argv[2];\n                    cpe = Jsi_Strrchr(cps, '.');\n                    int len = (cpe?cpe-cps:(int)Jsi_Strlen(cps));\n                    if (cpe)\n                        Jsi_DSPrintf(&dStr, \"source(\\\"%s\\\");\", argv[2]);\n                    else\n                        Jsi_DSPrintf(&dStr, \"require(\\\"%s\\\");\", argv[2]);\n                    Jsi_DSPrintf(&dStr, \"puts(runModule(\\\"%.*s\\\",console.args.slice(1)));\", len, cps);\n                    rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_NOSKIPBANG);\n                    Jsi_DSFree(&dStr);\n                    Jsi_DSFree(&eStr);\n                }\n                break;\n            case 's':\n                rc = Jsi_EvalString(interp, \"runModule('Safe');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'S':\n                rc = Jsi_EvalString(interp, \"runModule('SqliteUI');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'u':\n                rc = Jsi_EvalString(interp, \"exit(runModule('UnitTest'));\", JSI_EVAL_ISMAIN);\n                break;\n            case 'v': {\n                char str[200] = \"\\n\";\n                    \n                Jsi_Value* fval = Jsi_ValueNewStringKey(interp, \"/zvfs/lib/sourceid.txt\");\n                if (!Jsi_Access(interp, fval, R_OK)) {\n                    Jsi_Channel chan = Jsi_Open(interp, fval, \"r\");\n                    if (chan)\n                        Jsi_Read(interp, chan, str, sizeof(str));\n                }\n                if (argc>2)\n                    printf(\"%u.%u.%u\\n\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE);\n                else \n                    printf(\"%u.%u.%u %.\" JSI_VERFMT_LEN JSI_NUMGFMT \" %s\", JSI_VERSION_MAJOR, JSI_VERSION_MINOR, JSI_VERSION_RELEASE, Jsi_Version(), str);\n                return jsi_DoExit(interp, 1);\n            }\n            case 'w':\n                rc = Jsi_EvalString(interp, \"runModule('Wget');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'W':\n                rc = Jsi_EvalString(interp, \"runModule('Websrv');\", JSI_EVAL_ISMAIN);\n                break;\n            case 'z':\n                rc = Jsi_EvalString(interp, \"runModule('Zip');\", JSI_EVAL_ISMAIN);\n                break;\n            default:\n                puts(\"usage: jsish [  --C FILE | --I OPT:VAL | --L PATH | --T OPT | --U | --V | --F ] | -e STRING |\\n\\t\"\n                \"| -a | -c | -d | -D | -h | -m | -s | -S | -u | -v | -w | -W | -z | FILE ...\\nUse -help for long help.\");\n                return jsi_DoExit(interp, 1);\n        }\n    } else {\ndofile:\n        ext = Jsi_Strrchr(argv[first], '.');\n\n        /* Support running \"main.jsi\" from a zip file. */\n        if (ext && (Jsi_Strcmp(ext,\".zip\")==0 ||Jsi_Strcmp(ext,\".jsz\")==0 ) ) {\n            rc = Jsi_EvalZip(interp, argv[first], NULL, &jsFound);\n            if (rc<0) {\n                fprintf(stderr, \"zip mount failed\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n            if (!(jsFound&JSI_ZIP_MAIN)) {\n                fprintf(stderr, \"main.jsi not found\\n\");\n                return jsi_DoExit(interp, 1);\n            }\n        } else if (ext && !Jsi_Strcmp(ext,\".jsc\")) {\n            Jsi_DString dStr = {};\n            Jsi_DSPrintf(&dStr, \"console.args.unshift('%s'); runModule('CData');\", argv[first]);\n            rc = Jsi_EvalString(interp, Jsi_DSValue(&dStr), JSI_EVAL_ISMAIN|JSI_EVAL_NOSKIPBANG);\n            Jsi_DSFree(&dStr);\n\n        } else {\n            if (argc>1) {\n                jsi_vf = Jsi_ValueNewStringKey(interp, argv[first]);\n                Jsi_IncrRefCount(interp, jsi_vf);\n            }\n            rc = Jsi_EvalFile(interp, jsi_vf, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX|JSI_EVAL_ISMAIN);\n            if (jsi_vf) {\n                Jsi_DecrRefCount(interp, jsi_vf);\n                jsi_vf = NULL;\n            }\n\n        }\n    }\n    if (jsi_deleted) //TODO: rationalize jsi_deleted, jsi_exitCode, etc\n        return jsi_DoExit(rc==JSI_EXIT?NULL:interp, jsi_exitCode);\n    if (rc == JSI_OK) {\n        /* Skip output from an ending semicolon which evaluates to undefined */\n        Jsi_Value *ret = Jsi_ReturnValue(interp);\n        if (!Jsi_ValueIsType(interp, ret, JSI_VT_UNDEF)) {\n            Jsi_DString dStr = {};\n            fputs(Jsi_ValueGetDString(interp, ret, &dStr, 0), stdout);\n            Jsi_DSFree(&dStr);\n            fputs(\"\\n\", stdout);\n        }\n    } else {\n        if (!interp->parent && !interp->isHelp)\n            fprintf(stderr, \"ERROR: %s\\n\", interp->errMsgBuf);\n        return jsi_DoExit(interp, 1);\n    }\n\ndone:\n    if (rc == JSI_EXIT) {\n        if (opts)\n            opts->exitCode = jsi_exitCode;\n        return NULL;\n    }\n    if (jsi_deleted == 0 && interp->opts.auto_delete) {\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    return interp;\n}\n\nbool jsi_ModBlacklisted(Jsi_Interp *interp, const char *mod) {\n    if (!interp->subOpts.blacklist) return false;\n    const char *blstr =Jsi_Strstr(interp->subOpts.blacklist, mod);\n    if (!blstr) return false;\n    if ((blstr==interp->subOpts.blacklist || !isalnum(blstr[-1])) && !isalnum(blstr[Jsi_Strlen(mod)]))\n        return false;\n    return true;\n}\n\n// Get control during script evaluation to support debugging.\nstatic Jsi_RC jsi_InterpDebugHook(struct Jsi_Interp* interp, const char *curFile,\n    int curLine, int curLevel, const char *curFunc, const char *opCode, jsi_OpCode *op, const char *emsg)\n{\n    // TODO: when code is run in debugger, parser.y should attribute op for case stmt to skip str compares, etc.\n    int isfun=0;\n    if (interp->isInCallback || curLine<=0)\n        return JSI_OK;\n    if (op && op->nodebug)\n        return JSI_OK;\n    int isbp = 0, bpId = 0, cont = interp->debugOpts.doContinue,\n        stop = (interp->debugOpts.noFilter || interp->debugOpts.forceBreak);\n    if (!curFunc)\n        curFunc = \"\";\n\n    if (interp->parent && interp->parent->sigmask) {\n        interp->parent->sigmask = 0;\n        opCode = \"SIGINT\";\n\n    } else if (Jsi_Strcmp(opCode, \"DEBUG\") || !interp->parent) {\n\n        // Avoid overhead of multiple ops on same line of code.\n        int sameLine = (interp->debugOpts.lastLine == curLine && interp->debugOpts.lastLevel == curLevel\n            && interp->debugOpts.lastFile == curFile);\n\n        if (sameLine && stop==0 && (interp->debugOpts.bpLast==0\n            || (interp->debugOpts.bpOpCnt+10) >= interp->opCnt)) //TODO: need better way to detect bp dups.\n            goto done;\n\n        if (!interp->debugOpts.debugCallback || !interp->parent) {\n            fprintf(stderr, \"FILE %s:%d (%d) %s %s\\n\", curFile, curLine, curLevel, curFunc, opCode);\n            return JSI_OK;\n        }\n\n        // Check for breakpoints.\n        if (interp->breakpointHash) {\n            Jsi_HashEntry *hPtr;\n            Jsi_HashSearch search;\n            for (hPtr = Jsi_HashSearchFirst(interp->breakpointHash, &search);\n                hPtr != NULL && stop == 0; hPtr = Jsi_HashSearchNext(&search)) {\n                jsi_BreakPoint* bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n                if (bptr == NULL || bptr->enabled == 0) continue;\n                if (bptr->func)\n                    stop = (!Jsi_Strcmp(bptr->func, curFunc));\n                else\n                    stop = (bptr->line == curLine && !Jsi_Strcmp(bptr->file, curFile));\n                if (stop) {\n                    isbp = 1;\n                    bpId = bptr->id;\n                    bptr->hits++;\n                    if (bptr->temp)\n                        bptr->enabled = 0;\n                }\n            }\n        }\n\n        if (stop == 0) { // No breakpoint.\n            if (cont  // Cmd is \"continue\"\n                // Handle \"next\" by skipping calls into functions.\n                || (interp->debugOpts.minLevel>0 && curLevel>interp->debugOpts.minLevel)\n                || (isfun=(Jsi_Strcmp(opCode, \"PUSHVAR\")==0 && op[1].op == OP_PUSHFUN)))\n            {\n                if (isfun) {\n                    interp->debugOpts.lastLine = curLine;\n                    interp->debugOpts.lastLevel = curLevel;\n                    interp->debugOpts.lastFile = curFile;\n                }\ndone:\n                return JSI_OK;\n            }\n        }\n    }\n    interp->debugOpts.bpLast = isbp;\n    interp->debugOpts.bpOpCnt = interp->opCnt;\n    interp->debugOpts.lastLine = curLine;\n    interp->debugOpts.lastLevel = curLevel;\n    interp->debugOpts.lastFile = curFile;\n    interp->debugOpts.forceBreak = 0;\n\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    if (emsg && Jsi_Strchr(emsg,'\\\"'))\n        emsg = 0;\n    Jsi_DSPrintf(&dStr, \"[\\\"%s\\\", %d, %d, \\\"%s\\\", \\\"%s\\\", %d, \\\"%s\\\"]\", curFile?curFile:\"\", curLine, curLevel, curFunc, opCode, bpId, emsg?emsg:\"\");\n    interp->isInCallback = 1;\n    Jsi_RC rc = JSI_ERROR;\n    if (interp->debugOpts.debugCallback)\n        rc = Jsi_FunctionInvokeJSON(interp->parent, interp->debugOpts.debugCallback, Jsi_DSValue(&dStr), &interp->retValue);\n    interp->isInCallback = 0;\n    if (interp->parent->exited == 0 && rc != JSI_OK)\n        Jsi_LogError(\"debugger failure\");\n    return rc;\n}\n\nJsi_RC jsi_ParseTypeCheckStr(Jsi_Interp *interp, const char *str) {\n    uint *iptr = (uint*)&interp->typeCheck;\n    const char *wcp = str, *wcn = wcp;\n    while (wcn && wcp) {\n        int isnot = 0;\n        if (*wcp == '!') { isnot = 1; wcp++; }\n        wcn = Jsi_Strchr(wcp, ',');\n        int ti, wlen = (wcn?(wcn-wcp):(int)Jsi_Strlen(wcp));\n#define _JSIPARSETYPES(nam, field) \\\n        if (wlen == (sizeof(#nam)-1) && !Jsi_Strncmp(#nam, wcp, (sizeof(#nam)-1))) { \\\n            interp->field = (1-isnot); \\\n            wcp = (wcn?wcn+1:NULL); \\\n            continue; \\\n        }\n        _JSIPARSETYPES(Debug, logOpts.Debug)\n        _JSIPARSETYPES(Trace, logOpts.Trace)\n        _JSIPARSETYPES(Test,  logOpts.Test)\n        _JSIPARSETYPES(Info, logOpts.Info)\n        _JSIPARSETYPES(Warn, logOpts.Warn)\n        _JSIPARSETYPES(Error,  logOpts.Error)\n        _JSIPARSETYPES(full,  logOpts.full)\n        _JSIPARSETYPES(before,  logOpts.before)\n        _JSIPARSETYPES(time,  logOpts.time)\n        _JSIPARSETYPES(date,  logOpts.date)\n        _JSIPARSETYPES(asserts, asserts)\n        _JSIPARSETYPES(assert, asserts)\n        _JSIPARSETYPES(noproto, subOpts.noproto)\n\n        const char **tstrs = jsi_TypeChkStrs;\n        for (ti=0; tstrs[ti]; ti++) {\n            wlen = Jsi_Strlen(tstrs[ti]);\n            if (!Jsi_Strncmp(tstrs[ti], wcp, wlen) && (!tstrs[ti][wlen] || tstrs[ti][wlen] == ',')) break;\n        }\n        if (tstrs[ti]) {\n            if (isnot)\n                *iptr &= ~(1<<ti);\n            else {\n                *iptr |= (1<<ti);\n                if (!Jsi_Strcmp(tstrs[ti], \"all\"))\n                    interp->typeCheck.parse = interp->typeCheck.run = 1;\n                if (!Jsi_Strcmp(tstrs[ti], \"strict\")) {\n                    interp->typeCheck.parse = interp->typeCheck.run = interp->typeCheck.all = 1;\n                    if (interp->framePtr->level<=0 || interp->isMain)\n                        interp->strict = 1;\n                }\n            }\n        } else {\n            Jsi_DString wStr = {};\n            int i;\n            tstrs = jsi_TypeChkStrs;\n            for (i=0; tstrs[i]; i++) Jsi_DSAppend(&wStr, i?\", \":\"\", tstrs[i], NULL);\n            Jsi_LogWarn(\"unknown typeCheck warn option(s) \\\"%s\\\" not in: Debug, Trace, Test, Info, Warn, Error, assert, %s, noproto, full, before, time, date\", str, Jsi_DSValue(&wStr));\n            Jsi_DSFree(&wStr);\n        }\n        wcp = (wcn?wcn+1:NULL);\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_Interp* jsi_InterpNew(Jsi_Interp *parent, Jsi_Value *opts, Jsi_InterpOpts *iopts)\n{\n    Jsi_Interp* interp;\n    if (parent && parent->noSubInterps) {\n        interp = parent;\n        Jsi_LogError(\"subinterps disallowed\");\n        return NULL;\n    }\n    if (opts && parent && (Jsi_ValueIsObjType(parent, opts, JSI_OT_OBJECT)==0 ||\n        Jsi_TreeSize(opts->d.obj->tree)<=0))\n        opts = NULL;\n    interp = (Jsi_Interp *)Jsi_Calloc(1,sizeof(*interp) + sizeof(jsi_Frame));\n    interp->framePtr = (jsi_Frame*)(((uchar*)interp)+sizeof(*interp));\n    if (!parent)\n        interp->maxInterpDepth = JSI_MAX_SUBINTERP_DEPTH;\n    else {\n        interp->maxInterpDepth = parent->maxInterpDepth;\n        interp->interpDepth = parent->interpDepth+1;\n        if (interp->interpDepth > interp->maxInterpDepth) {\n            Jsi_Free(interp);\n            interp = parent;\n            Jsi_LogError(\"exceeded max subinterp depth\");\n            return NULL;\n        }\n    }\n    interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n    interp->maxIncDepth = JSI_MAX_INCLUDE_DEPTH;\n    interp->maxArrayList = MAX_ARRAY_LIST;\n    interp->typeWarnMax = 50;\n    interp->subOpts.dblPrec = __DBL_DECIMAL_DIG__-1;\n    interp->subOpts.prompt = \"$ \";\n    interp->subOpts.prompt2 = \"> \";\n\n    int iocnt;\n    if (iopts) {\n        iopts->interp = interp;\n        interp->opts = *iopts;\n    }\n    interp->logOpts.file = 1;\n    interp->logOpts.func = 1;\n    interp->logOpts.Info = 1;\n    interp->logOpts.Warn = 1;\n    interp->logOpts.Error = 1;\n    int argc = interp->opts.argc;\n    char **argv = interp->opts.argv;\n    char *argv0 = (argv?argv[0]:NULL);\n    interp->parent = parent;\n    interp->topInterp = (parent == NULL ? interp: parent->topInterp);\n    if (jsiIntData.mainInterp == NULL)\n        jsiIntData.mainInterp = interp->topInterp;\n    interp->mainInterp = jsiIntData.mainInterp; // The first interps handles exit.\n    interp->memDebug = interp->opts.mem_debug;\n    if (parent) {\n        interp->dbPtr = parent->dbPtr;\n    } else {\n        interp->dbPtr = &interp->dbStatic;\n    }\n#ifdef JSI_MEM_DEBUG\n    if (!interp->dbPtr->valueDebugTbl) {\n        interp->dbPtr->valueDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n        interp->dbPtr->objDebugTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL);\n    }\n#endif\n    if (parent) {\n        if (parent->pkgDirs)\n            interp->pkgDirs = Jsi_ValueDupJSON(interp, parent->pkgDirs);\n    } else {\n#ifdef JSI_PKG_DIRS\n        interp->pkgDirs = Jsi_StringSplit(interp, JSI_PKG_DIRS, \",\");\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n#endif\n    }\n#ifdef JSI_USE_COMPAT\n    interp->compat = JSI_USE_COMPAT;\n#endif\n#ifndef JSI_CONF_ARGS\n#define JSI_CONF_ARGS \"\"\n#endif\n    interp->confArgs = JSI_CONF_ARGS;\n    for (iocnt = 1; (iocnt+1)<argc; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--T\") == 0 || Jsi_Strcmp(aio, \"--C\") == 0 || Jsi_Strcmp(aio, \"--L\") == 0) {\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--F\") == 0 || Jsi_Strcmp(aio, \"--U\") == 0 || Jsi_Strcmp(aio, \"--V\") == 0) {\n            iocnt--;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\")) {\n            const char *aio2 = argv[iocnt+1];\n            if (!Jsi_Strncmp(\"memDebug:\", aio2, sizeof(\"memDebug\")))\n                interp->memDebug=strtol(aio2+sizeof(\"memDebug\"), NULL, 0);\n            else if (!Jsi_Strncmp(\"compat\", aio2, sizeof(\"compat\")))\n                interp->subOpts.compat=strtol(aio2+sizeof(\"compat\"), NULL, 0);\n            continue;\n        }\n        break;\n    }\n    SIGINIT(interp,INTERP);\n    interp->NullValue = Jsi_ValueNewNull(interp);\n    Jsi_IncrRefCount(interp, interp->NullValue);\n#ifdef __WIN32\n    Jsi_DString cwdStr;\n    Jsi_DSInit(&cwdStr);\n    interp->curDir = Jsi_Strdup(Jsi_GetCwd(interp, &cwdStr));\n    Jsi_DSFree(&cwdStr);\n#else\n    char buf[JSI_BUFSIZ];\n    interp->curDir = getcwd(buf, sizeof(buf));\n    interp->curDir = Jsi_Strdup(interp->curDir?interp->curDir:\".\");\n#endif\n    interp->onDeleteTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeOnDeleteTbl);\n    interp->assocTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeAssocTbl);\n    interp->cmdSpecTbl = Jsi_MapNew(interp, JSI_MAP_TREE, JSI_KEYS_STRING, freeCmdSpecTbl);\n    interp->eventTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeEventTbl);\n    interp->fileTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    interp->funcObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncObjTbl);\n    interp->funcsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeFuncsTbl);\n    interp->bindTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeBindObjTbl);\n    interp->protoTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL/*freeValueTbl*/);\n    interp->regexpTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, regExpFree);\n    interp->preserveTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, jsi_HashFree);\n    interp->loadTbl = (parent?parent->loadTbl:Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_FreeOneLoadHandle));\n    interp->packageHash = Jsi_HashNew(interp, JSI_KEYS_STRING, packageHashFree);\n    interp->aliasHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_AliasFree);\n\n    interp->lockTimeout = -1;\n#ifdef JSI_LOCK_TIMEOUT\n    interp->lockTimeout JSI_LOCK_TIMEOUT;\n#endif\n#ifndef JSI_DO_UNLOCK\n#define JSI_DO_UNLOCK 1\n#endif\n    interp->subOpts.mutexUnlock = JSI_DO_UNLOCK;\n    Jsi_Map_Type mapType = JSI_MAP_HASH;\n#ifdef JSI_USE_MANY_STRKEY\n    mapType = JSI_MAP_TREE;\n#endif\n\n    if (interp == jsiIntData.mainInterp || interp->threadId != jsiIntData.mainInterp->threadId) {\n        interp->strKeyTbl = Jsi_MapNew(interp,  mapType, JSI_KEYS_STRING, NULL);\n        interp->subOpts.privKeys = 1;\n    }\n    // Handle interp options: -T value and -Ixxx value\n    for (iocnt = 1; (iocnt+1)<argc && !interp->parent; iocnt+=2)\n    {\n        const char *aio = argv[iocnt];\n        if (Jsi_Strcmp(aio, \"--F\") == 0) {\n            interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--U\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--V\") == 0) {\n            interp->asserts = 1;\n            interp->unitTest = 5;\n            interp->tracePuts = 1;\n            iocnt--;\n            interp->iskips++;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--C\") == 0) {\n            if (interp->confFile)\n               Jsi_LogWarn(\"overriding confFile: %s\", interp->confFile);\n            interp->confFile = argv[iocnt+1];\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--L\") == 0) {\n            struct stat sb;\n            const char* path = argv[iocnt+1]; //TODO: convert to Jsi_Value first?\n            if (!path || stat(path, &sb)\n                || !((S_ISREG(sb.st_mode) && !access(path, W_OK)) || (S_ISDIR(sb.st_mode) && !access(path, X_OK)))) {\n                Jsi_LogError(\"Lockdown path must exist and be a writable file or executable dir: %s\", path);\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->isSafe = true;\n            interp->safeMode = jsi_safe_Lockdown;\n            if (interp->safeWriteDirs) {\n                Jsi_LogWarn(\"Overriding safeWriteDirs\");\n                Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            }\n            const char *vda[2] = {};\n            char npath[PATH_MAX];\n            vda[0] = Jsi_FileRealpathStr(interp, path, npath);\n            interp->safeWriteDirs = Jsi_ValueNewArray(interp, vda, 1);\n            Jsi_IncrRefCount(interp, interp->safeWriteDirs);\n            if (!interp->safeReadDirs) {\n                interp->safeReadDirs = interp->safeWriteDirs;\n                Jsi_IncrRefCount(interp, interp->safeReadDirs);\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (Jsi_Strcmp(aio, \"--T\") == 0) {\n            if (jsi_ParseTypeCheckStr(interp, argv[iocnt+1]) != JSI_OK) {\n                Jsi_InterpDelete(interp);\n                return NULL;\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        if (!Jsi_Strcmp(aio, \"--I\"))  {\n            bool bv = 1;\n            char *aio2 = argv[iocnt+1], *aioc = Jsi_Strchr(aio2, ':'),\n                argNamS[50], *argNam = aio2;\n            const char *argVal;\n            if (!Jsi_Strcmp(\"traceCall\", aio2))\n                interp->traceCall |= (jsi_callTraceFuncs |jsi_callTraceArgs |jsi_callTraceReturn | jsi_callTraceBefore | jsi_callTraceFullPath);\n            else {\n                if (aioc) {\n                    argNam = argNamS;\n                    argVal = aioc+1;\n                    snprintf(argNamS, sizeof(argNamS), \"%.*s\", (int)(aioc-aio2), aio2);\n                }\n                \n                DECL_VALINIT(argV);\n                Jsi_Value *argValue = &argV;\n                Jsi_Number dv;\n                if (!aioc || Jsi_GetBool(interp, argVal, &bv) == JSI_OK) {\n                    Jsi_ValueMakeBool(interp, &argValue, bv);\n                } else if (!Jsi_Strcmp(\"null\", argVal)) {\n                    Jsi_ValueMakeNull(interp, &argValue);\n                } else if (Jsi_GetDouble(interp, argVal, &dv) == JSI_OK) {\n                    Jsi_ValueMakeNumber(interp, &argValue, dv);\n                } else {\n                    Jsi_ValueMakeStringKey(interp, &argValue, argVal);\n                }\n                if (JSI_OK != Jsi_OptionsSet(interp, InterpOptions, interp, argNam, argValue, 0)) {\n                    Jsi_InterpDelete(interp);\n                    return NULL;\n                }\n            }\n            interp->iskips+=2;\n            continue;\n        }\n        break;\n    }\n    if (!interp->strKeyTbl)\n        interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n    if (opts) {\n        interp->inopts = opts = Jsi_ValueDupJSON(interp, opts);\n        if (Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0) {\n            Jsi_DecrRefCount(interp, opts);\n            interp->inopts = NULL;\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n    }\n    if (interp == jsiIntData.mainInterp) {\n        interp->subthread = 0;\n    } else {\n        if (opts) {\n            if (interp->subOpts.privKeys && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl) {\n                //Jsi_HashDelete(interp->strKeyTbl);\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                interp->strKeyTbl = Jsi_MapNew(interp, mapType, JSI_KEYS_STRING, NULL);\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            } else if (interp->subOpts.privKeys == 0 && interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl) {\n                Jsi_OptionsFree(interp, InterpOptions, interp, 0); /* Reparse options to populate new key table. */\n                Jsi_MapDelete(interp->strKeyTbl);\n                interp->strKeyTbl = jsiIntData.mainInterp->strKeyTbl;\n                if (opts->vt != JSI_VT_NULL) Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0);\n            }\n        }\n        if (parent && parent->isSafe) {\n            interp->isSafe = 1;\n            interp->safeMode = parent->safeMode;\n        }\n        if (interp->subthread && interp->isSafe) {\n            interp->subthread = 0;\n            Jsi_LogError(\"threading disallowed in safe mode\");\n            Jsi_InterpDelete(interp);\n            return NULL;\n        }\n        if (interp->subthread)\n            jsiIntData.mainInterp->threadCnt++;\n        if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n            jsiIntData.mainInterp->threadShrCnt++;\n        if (jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n            jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = KeyLockerTree;\n#else\n            jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = KeyLocker;\n#endif\n    }\n    if (parent && parent->isSafe) {\n        interp->isSafe = 1;\n        interp->safeMode = parent->safeMode;\n        interp->maxOpCnt = parent->maxOpCnt;\n        if (interp->safeWriteDirs || interp->safeReadDirs || interp->safeExecPattern) {\n            Jsi_LogWarn(\"ignoring safe* options in safe sub-sub-interp\");\n            if (interp->safeWriteDirs) Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n            if (interp->safeReadDirs) Jsi_DecrRefCount(interp, interp->safeReadDirs);\n            interp->safeWriteDirs = interp->safeReadDirs = NULL;\n            interp->safeExecPattern = NULL;\n        }\n    }\n\n    jsi_InterpConfFiles(interp);\n    if (!interp->udata) {\n        interp->udata = Jsi_ValueNewObj(interp, NULL);\n        Jsi_IncrRefCount(interp, interp->udata);\n    }\n    if (interp->subthread && !interp->scriptStr && !interp->scriptFile) {\n        Jsi_LogError(\"subthread interp must be specify either scriptFile or scriptStr\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n#ifndef JSI_MEM_DEBUG\n    static int warnNoDebug = 0;\n    if (interp->memDebug && warnNoDebug == 0) {\n        Jsi_LogWarn(\"ignoring memDebug as jsi was compiled without memory debugging\");\n        warnNoDebug = 1;\n    }\n#endif\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->parent && interp->subthread==0 && interp->threadId != interp->parent->threadId) {\n        interp->threadId = interp->parent->threadId;\n#ifndef JSI_MEM_DEBUG\n        Jsi_LogWarn(\"non-threaded sub-interp created by different thread than parent\");\n#endif\n    }\n    if (interp->safeMode != jsi_safe_None)\n        interp->isSafe = interp->startSafe = 1;\n    if (!interp->parent) {\n        if (interp->isSafe)\n            interp->startSafe = 1;\n        if (interp->debugOpts.msgCallback)\n            Jsi_LogWarn(\"ignoring msgCallback\");\n        if (interp->debugOpts.putsCallback)\n            Jsi_LogWarn(\"ignoring putsCallback\");\n        if (interp->busyCallback)\n            Jsi_LogWarn(\"ignoring busyCallback\");\n        if (interp->debugOpts.traceCallback)\n            Jsi_LogWarn(\"ignoring traceCallback\");\n    } else if (interp->busyCallback && interp->threadId != interp->parent->threadId) {\n        Jsi_LogWarn(\"disabling busyCallback due to threads\");\n        interp->busyCallback = NULL;\n    }\n    if (interp == jsiIntData.mainInterp)\n        interp->lexkeyTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    else\n        interp->lexkeyTbl = jsiIntData.mainInterp->lexkeyTbl;\n    interp->thisTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeValueTbl);\n    interp->userdataTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeUserdataTbl);\n    interp->varTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    interp->codeTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, freeCodeTbl);\n    interp->genValueTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD,freeValueTbl);\n    interp->genObjTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, freeGenObjTbl);\n#ifdef JSI_MEM_DEBUG\n    interp->codesTbl = (interp == jsiIntData.mainInterp ? Jsi_HashNew(interp, JSI_KEYS_ONEWORD, NULL) : jsiIntData.mainInterp->codesTbl);\n#endif\n    if (interp->typeCheck.all|interp->typeCheck.parse|interp->typeCheck.funcsig)\n        interp->staticFuncsTbl = Jsi_HashNew(interp, JSI_KEYS_STRING, NULL);\n    if (!jsiIntData.isInit) {\n        jsiIntData.isInit = 1;\n        jsi_InitValue(interp, 0);\n        jsiIntData.interpsTbl = Jsi_HashNew(interp, JSI_KEYS_ONEWORD, 0);\n    }\n\n    /* current scope, also global */\n    interp->csc = Jsi_ValueNew1(interp);\n    Jsi_ValueMakeObject(interp, &interp->csc, Jsi_ObjNew(interp));\n    interp->framePtr->incsc = interp->csc;\n\n#define JSIDOINIT(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n#define JSIDOINIT2(nam) if (!jsi_ModBlacklisted(interp,#nam)) { if (Jsi_Init##nam(interp, 0) != JSI_OK) { Jsi_LogBug(\"Init failure in %s\", #nam); } }\n\n    JSIDOINIT(Proto);\n\n    if (interp->pkgDirs) // Fix-up because above, array was not yet initialized.\n        interp->pkgDirs->d.obj->__proto__ = interp->Array_prototype;\n\n    Jsi_Value *modObj = Jsi_ValueNewObj(interp, Jsi_ObjNewType(interp, JSI_OT_OBJECT));\n    Jsi_ValueInsert(interp, interp->csc, \"Jsi_Auto\", modObj, JSI_OM_DONTDEL);\n\n    /* initial scope chain, nothing */\n    interp->framePtr->ingsc = interp->gsc = jsi_ScopeChainNew(interp, 0);\n\n    interp->ps = jsi_PstateNew(interp); /* Default parser. */\n    if (interp->unitTest&2) {\n        interp->logOpts.before = 1;\n        interp->logOpts.full = 1;\n        interp->tracePuts = 1;\n        interp->noStderr = 1;\n    }\n    if (interp->args && argc) {\n        Jsi_LogBug(\"args may not be specified both as options and parameter\");\n        Jsi_InterpDelete(interp);\n        return NULL;\n    }\n    if (interp->maxDepth>JSI_MAX_EVAL_DEPTH)\n        interp->maxDepth = JSI_MAX_EVAL_DEPTH;\n\n    // Create the args array.\n    if (argc >= 0 && !interp->args) {\n        Jsi_Value *iargs = Jsi_ValueNew1(interp);\n        iargs->f.bits.dontdel = 1;\n        iargs->f.bits.readonly = 1;\n        Jsi_Obj *iobj = Jsi_ObjNew(interp);\n        Jsi_ValueMakeArrayObject(interp, &iargs, iobj);\n        int i = 1, ii = (iocnt>1 ? iocnt : 1);\n        int msiz = (argc?argc-iocnt:0);\n        Jsi_ObjArraySizer(interp, iobj, msiz);\n        iobj->arrMaxSize = msiz;\n        iocnt--;\n        iobj->arrCnt = argc-iocnt;\n        for (i = 1; ii < argc; ++ii, i++) {\n            iobj->arr[i-1] = Jsi_ValueNewStringKey(interp, argv[ii]);\n            Jsi_IncrRefCount(interp, iobj->arr[i-1]);\n            jsi_ValueDebugLabel(iobj->arr[i-1], \"InterpCreate\", \"args\");\n        }\n        Jsi_ObjSetLength(interp, iobj, msiz);\n        interp->args = iargs;\n    } else if (interp->parent && interp->args) {\n        // Avoid strings from sneeking in with options from parent...\n        Jsi_Value *nar = Jsi_ValueDupJSON(interp, interp->args);\n        Jsi_DecrRefCount(interp, interp->args);\n        interp->args = nar;\n    }\n    JSIDOINIT(Options);\n    JSIDOINIT(Cmds);\n    JSIDOINIT(Interp);\n    JSIDOINIT(JSON);\n\n    interp->retValue = Jsi_ValueNew1(interp);\n    interp->Mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n    if (1 || interp->subthread) {\n        interp->QMutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_DSInit(&interp->interpEvalQ);\n    }\n    JSIDOINIT(Lexer);\n    if (interp != jsiIntData.mainInterp && !parent)\n        Jsi_HashSet(jsiIntData.interpsTbl, interp, NULL);\n\n    if (!interp->isSafe) {\n        JSIDOINIT(Load);\n#if JSI__SIGNAL==1\n        JSIDOINIT(Signal);\n#endif\n    }\n    if (interp->isSafe == 0 || interp->startSafe || interp->safeWriteDirs!=NULL || interp->safeReadDirs!=NULL) {\n#if JSI__FILESYS==1\n        JSIDOINIT(FileCmds);\n        JSIDOINIT(Filesys);\n#endif\n    }\n#if JSI__SQLITE==1\n    JSIDOINIT2(Sqlite);\n#else\n    Jsi_initSqlite(interp, 0);\n#endif\n#if JSI__MYSQL==1\n    if (!interp->noNetwork) {\n        JSIDOINIT2(MySql);\n    }\n#endif\n#if JSI__SOCKET==1\n    JSIDOINIT2(Socket);\n#endif\n#if JSI__WEBSOCKET==1\n    JSIDOINIT2(WebSocket);\n#endif\n\n#if JSI__CDATA==1\n    JSIDOINIT(CData);\n#endif\n\n#ifdef JSI_USER_EXTENSION\n    extern int JSI_USER_EXTENSION(Jsi_Interp *interp, int release);\n    if (JSI_USER_EXTENSION (interp, 0) != JSI_OK) {\n        fprintf(stderr, \"extension load failed\");\n        return jsi_DoExit(interp, 1);\n    }\n#endif\n    Jsi_PkgProvide(interp, \"Jsi\", JSI_VERSION, NULL);\n    if (argc > 0) {\n        char *ss = argv0;\n        char epath[PATH_MAX] = \"\"; // Path of executable\n#ifdef __WIN32\n\n        if (GetModuleFileName(NULL, epath, sizeof(epath))>0)\n            ss = epath;\n#else\n#ifndef PROC_SELF_DIR\n#define PROC_SELF_DIR \"/proc/self/exe\"\n#endif\n        if (ss && *ss != '/' && readlink(PROC_SELF_DIR, epath, sizeof(epath)) && epath[0])\n            ss = epath;\n#endif\n        Jsi_Value *src = Jsi_ValueNewStringDup(interp, ss);\n        Jsi_IncrRefCount(interp, src);\n        jsiIntData.execName = Jsi_Realpath(interp, src, NULL);\n        Jsi_DecrRefCount(interp, src);\n        if (!jsiIntData.execName) jsiIntData.execName = Jsi_Strdup(\"\");\n        jsiIntData.execValue = Jsi_ValueNewString(interp, jsiIntData.execName, -1);\n        Jsi_IncrRefCount(interp, jsiIntData.execValue);\n        Jsi_HashSet(interp->genValueTbl, jsiIntData.execValue, jsiIntData.execValue);\n    }\n\n    //interp->nocacheOpCodes = 1;\n    if (interp->debugOpts.debugCallback && !interp->debugOpts.hook) {\n        interp->debugOpts.hook = jsi_InterpDebugHook;\n    }\n    interp->startTime = jsi_GetTimestamp();\n#ifdef JSI_INTERP_EXTENSION_CODE // For extending interp from jsi.c\n    JSI_INTERP_EXTENSION_CODE\n#endif\n    if (interp->opts.initProc && (*interp->opts.initProc)(interp, 0) != JSI_OK)\n        Jsi_LogBug(\"Init failure in initProc\");\n\n    return interp;\n}\n\nJsi_Interp* Jsi_InterpNew(Jsi_InterpOpts *opts)\n{\n    return jsi_InterpNew(NULL, NULL, opts);\n}\n\nbool Jsi_InterpGone( Jsi_Interp* interp)\n{\n    return (interp == NULL || interp->deleting || interp->destroying || interp->exited);\n}\n\nstatic void DeleteAllInterps() { /* Delete toplevel interps. */\n    Jsi_HashEntry *hPtr;\n    Jsi_HashSearch search;\n    if (!jsiIntData.interpsTbl)\n        return;\n    for (hPtr = Jsi_HashSearchFirst(jsiIntData.interpsTbl, &search); hPtr; hPtr = Jsi_HashSearchNext(&search)) {\n        Jsi_Interp *interp = (Jsi_Interp *)Jsi_HashKeyGet(hPtr);\n        Jsi_HashEntryDelete(hPtr);\n        interp->destroying = 1;\n        Jsi_InterpDelete(interp);\n    }\n    Jsi_HashDelete(jsiIntData.interpsTbl);\n    jsiIntData.interpsTbl = NULL;\n    jsiIntData.isInit = 0;\n}\n\n#ifdef JSI_MEM_DEBUG\n\ntypedef enum { MDB_INOBJ=1, MDB_VISITED=2 } jsi_MDB;\n\nvoid jsiFlagDebugValues(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    Jsi_Value *v;\n    int oflags;\n    if (obj->ot != JSI_OT_OBJECT && obj->ot != JSI_OT_ARRAY)\n        return;\n    if (obj->tree) {\n        Jsi_TreeEntry *hPtr;\n        Jsi_TreeSearch srch;\n        for (hPtr=Jsi_TreeSearchFirst(obj->tree, &srch,  JSI_TREE_ORDER_IN, NULL); hPtr;\n            hPtr=Jsi_TreeSearchNext(&srch)) {\n            v = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n    if (obj->arr) {\n        uint i;\n        for (i=0; i<obj->arrCnt; i++) {\n            v = obj->arr[i];\n            if (v == NULL || v->sig != JSI_SIG_VALUE) continue;\n            oflags = v->VD.flags;\n            v->VD.flags |= (MDB_VISITED|MDB_INOBJ);\n            if (oflags&MDB_VISITED || v->vt != JSI_VT_OBJECT)\n                continue;\n            jsiFlagDebugValues(interp, v->d.obj);\n        }\n    }\n}\n\nvoid jsi_DebugDumpValues(Jsi_Interp *interp)\n{\n    if (jsiIntData.mainInterp != interp) return;\n    int vdLev = interp->memDebug;\n    int have = (interp->dbPtr->valueDebugTbl->numEntries || interp->dbPtr->objDebugTbl->numEntries);\n    if ((have && vdLev>0) || vdLev>=3) {\n        // First traverse all Object trees/arrays and mark all values contained therein.\n        Jsi_HashSearch search;\n        Jsi_HashEntry *hPtr;\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp!=NULL && vp->sig == JSI_SIG_OBJ) {\n                jsiFlagDebugValues(interp, vp);\n            }\n        }\n        if (interp->dbPtr->valueDebugTbl->numEntries != interp->dbPtr->valueCnt)\n            fprintf(stderr, \"\\n\\nValues table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->valueDebugTbl->numEntries, interp->dbPtr->valueCnt);\n        // Dump unfreed values and objs.\n        int refSum=0, refsum=0;\n        int bcnt[4] = {};\n        if (vdLev>1 && interp->dbPtr->valueDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED VALUES \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->valueDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Value *vp = (Jsi_Value *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_VALUE) {\n                bcnt[0]++;\n                if (vdLev>1)\n                    fprintf(stderr, \"BAD VALUE: %p\\n\", vp);\n            } else {\n                bcnt[1]++;\n                refSum += vp->refCnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->vt==JSI_VT_OBJECT)\n                        snprintf(ebuf, sizeof(ebuf), \" {obj=%p, otype=%s}\", vp->d.obj, Jsi_ObjTypeStr(interp, vp->d.obj));\n                    else if (vp->vt==JSI_VT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \" {num=%s}\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->vt==JSI_VT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \" {bool=%s}\", vp->d.val?\"true\":\"false\");\n                    else if (vp->vt==JSI_VT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \" {string=\\\"%.40s%s\\\"}\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    const char *pfx = \"\";\n                    if (!(vp->VD.flags&MDB_INOBJ))\n                        pfx = \"!\"; // Value is not contained in an object.\n                    fprintf(stderr, \"[%s*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s()%s\\n\", pfx,\n                        vp, vp->refCnt, Jsi_ValueTypeStr(interp, vp), vp->VD.Idx,\n                        (vp->VD.label?vp->VD.label:\"\"), (vp->VD.label2?\":\":\"\"),\n                        (vp->VD.label2?vp->VD.label2:\"\"), vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line, vp->VD.func, ebuf);\n                }\n            }\n        }\n        if (interp->dbPtr->objDebugTbl->numEntries != interp->dbPtr->objCnt)\n            fprintf(stderr, \"\\n\\nObject table/alloc mismatch: table=%d, alloc=%d\\n\",\n                interp->dbPtr->objDebugTbl->numEntries, interp->dbPtr->objCnt);\n        if (vdLev>1 && interp->dbPtr->objDebugTbl->numEntries)\n            fprintf(stderr, \"\\n\\nUNFREED OBJECTS \\\"[*ptr,#refCnt,type,idx:label,label2]: @file:line in func() ...\\\"\\n\");\n        for (hPtr = Jsi_HashSearchFirst(interp->dbPtr->objDebugTbl, &search);\n            hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n            Jsi_Obj *vp = (Jsi_Obj *)Jsi_HashKeyGet(hPtr);\n            if (vp==NULL || vp->sig != JSI_SIG_OBJ) {\n                bcnt[2]++;\n                fprintf(stderr, \"BAD OBJ: %p\\n\", vp);\n            } else {\n                bcnt[3]++;\n                refsum += vp->refcnt;\n                if (vdLev>1) {\n                    char ebuf[JSI_BUFSIZ], ebuf2[JSI_MAX_NUMBER_STRING];\n                    ebuf[0] = 0;\n                    if (vp->ot==JSI_OT_OBJECT) {\n                        if (vp->isarrlist)\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d, array#%d\", (vp->tree?vp->tree->numEntries:0), vp->arrCnt);\n                        else\n                            snprintf(ebuf, sizeof(ebuf), \"tree#%d\", (vp->tree?vp->tree->numEntries:0));\n                    } else if (vp->ot==JSI_OT_NUMBER)\n                        snprintf(ebuf, sizeof(ebuf), \"num=%s\", Jsi_NumberToString(interp, vp->d.num, ebuf2, sizeof(ebuf2)));\n                    else if (vp->ot==JSI_OT_BOOL)\n                        snprintf(ebuf, sizeof(ebuf), \"bool=%s\", vp->d.val?\"true\":\"false\");\n                    else if (vp->ot==JSI_OT_STRING) {\n                        const char *sbuf = ((vp->d.s.str && Jsi_Strlen(vp->d.s.str)>40)?\"...\":\"\");\n                        snprintf(ebuf, sizeof(ebuf), \"string=\\\"%.40s%s\\\"\", (vp->d.s.str?vp->d.s.str:\"\"), sbuf);\n                    }\n                    fprintf(stderr, \"[*%p,#%d,%s,%d:%s%s%s]:%s @%s:%d in %s() {%s}\\n\",\n                        vp, vp->refcnt, Jsi_ObjTypeStr(interp, vp), vp->VD.Idx, vp->VD.label?vp->VD.label:\"\",\n                        vp->VD.label2?\":\":\"\",vp->VD.label2?vp->VD.label2:\"\", vp->VD.interp==jsiIntData.mainInterp?\"\":\"!\",\n                        vp->VD.fname, vp->VD.line,\n                        vp->VD.func, ebuf);\n                }\n            }\n        }\n        fprintf(stderr, \"\\nVALUES: bad=%d,unfreed=%d,allocs=%d,refsum=%d  | OBJECTS: bad=%d,unfreed=%d,allocs=%d,refsum=%d  interp=%p\\n\",\n            bcnt[0], bcnt[1], interp->dbPtr->valueAllocCnt, refSum, bcnt[2], bcnt[3], interp->dbPtr->objAllocCnt, refsum, interp);\n\n        if (interp->codesTbl)\n            for (hPtr = Jsi_HashSearchFirst(interp->codesTbl, &search);\n                hPtr != NULL; hPtr = Jsi_HashSearchNext(&search)) {\n                Jsi_OpCodes *vp = (Jsi_OpCodes *)Jsi_HashKeyGet(hPtr);\n                fprintf(stderr, \"unfreed opcodes: %d\\n\", vp->id);\n            }\n    }\n    Jsi_HashDelete(interp->dbPtr->valueDebugTbl);\n    Jsi_HashDelete(interp->dbPtr->objDebugTbl);\n    Jsi_HashDelete(interp->codesTbl);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    if (isMainInt && vdLev>3)\n        _exit(1); // Avoid sanitize output.\n}\n#endif\n\nstatic Jsi_RC jsiInterpDelete(Jsi_Interp* interp, void *unused)\n{\n    SIGASSERT(interp,INTERP);\n    bool isMainInt = (interp == jsiIntData.mainInterp);\n    int mainFlag = (isMainInt ? 2 : 1);\n    if (isMainInt)\n        DeleteAllInterps();\n    if (interp->opts.initProc)\n        (*interp->opts.initProc)(interp, mainFlag);\n    jsiIntData.delInterp = interp;\n    if (interp->gsc) jsi_ScopeChainFree(interp, interp->gsc);\n    if (interp->csc) Jsi_DecrRefCount(interp, interp->csc);\n    if (interp->ps) jsi_PstateFree(interp->ps);\n    int i;\n    for (i=0; i<interp->maxStack; i++) {\n        if (interp->Stack[i]) Jsi_DecrRefCount(interp, interp->Stack[i]);\n        if (interp->Obj_this[i]) Jsi_DecrRefCount(interp, interp->Obj_this[i]);\n    }\n    if (interp->Stack) {\n        Jsi_Free(interp->Stack);\n        Jsi_Free(interp->Obj_this);\n    }\n\n    if (interp->argv0)\n        Jsi_DecrRefCount(interp, interp->argv0);\n    if (interp->console)\n        Jsi_DecrRefCount(interp, interp->console);\n    if (interp->lastSubscriptFail)\n        Jsi_DecrRefCount(interp, interp->lastSubscriptFail);\n    if (interp->nullFuncRet)\n        Jsi_DecrRefCount(interp, interp->nullFuncRet);\n    Jsi_HashDelete(interp->codeTbl);\n    Jsi_MapDelete(interp->cmdSpecTbl);\n    Jsi_HashDelete(interp->fileTbl);\n    Jsi_HashDelete(interp->funcObjTbl);\n    Jsi_HashDelete(interp->funcsTbl);\n    if (interp->profileCnt) { // TODO: resolve some values from dbPtr, others not.\n        double endTime = jsi_GetTimestamp();\n        double coverage = (int)(100.0*interp->coverHit/interp->coverAll);\n        Jsi_DString dStr;\n        Jsi_DSInit(&dStr);\n        Jsi_DSPrintf(&dStr, \"PROFILE: TOTAL: time=%.6f, func=%.6f, cmd=%.6f, #funcs=%d, #cmds=%d, cover=%2.1f%%, #values=%d, #objs=%d %s%s\\n\",\n            endTime-interp->startTime, interp->funcSelfTime, interp->cmdSelfTime, interp->funcCallCnt, interp->cmdCallCnt,\n            coverage, interp->dbPtr->valueAllocCnt,  interp->dbPtr->objAllocCnt,\n            interp->parent?\" ::\":\"\", (interp->parent&&interp->name?interp->name:\"\"));\n        Jsi_Puts(interp, jsi_Stderr, Jsi_DSValue(&dStr), -1);\n        Jsi_DSFree(&dStr);\n    }\n    if (isMainInt)\n        Jsi_HashDelete(interp->lexkeyTbl);\n    Jsi_HashDelete(interp->protoTbl);\n    if (interp->subthread)\n        jsiIntData.mainInterp->threadCnt--;\n    if (interp->subthread && interp->strKeyTbl == jsiIntData.mainInterp->strKeyTbl)\n        jsiIntData.mainInterp->threadShrCnt--;\n    if (!jsiIntData.mainInterp->threadShrCnt)\n#ifdef JSI_USE_MANY_STRKEY\n        jsiIntData.mainInterp->strKeyTbl->v.tree->opts.lockTreeProc = NULL;\n#else\n        jsiIntData.mainInterp->strKeyTbl->v.hash->opts.lockHashProc = NULL;\n#endif\n    //Jsi_ValueMakeUndef(interp, &interp->ret);\n    Jsi_HashDelete(interp->thisTbl);\n    Jsi_HashDelete(interp->varTbl);\n    Jsi_HashDelete(interp->genValueTbl);\n    Jsi_HashDelete(interp->genObjTbl);\n    Jsi_HashDelete(interp->aliasHash);\n    if (interp->staticFuncsTbl)\n        Jsi_HashDelete(interp->staticFuncsTbl);\n    if (interp->breakpointHash)\n        Jsi_HashDelete(interp->breakpointHash);\n    if (interp->preserveTbl->numEntries!=0)\n        Jsi_LogBug(\"Preserves unbalanced\");\n    Jsi_HashDelete(interp->preserveTbl);\n    if (interp->curDir)\n        Jsi_Free(interp->curDir);\n    if (isMainInt) {\n        jsi_InitFilesys(interp, mainFlag);\n    }\n#ifndef JSI_OMIT_VFS\n    jsi_InitVfs(interp, 1);\n#endif\n#ifndef JSI_OMIT_CDATA\n        jsi_InitCData(interp, mainFlag);\n#endif\n#if JSI__MYSQL==1\n        Jsi_InitMySql(interp, mainFlag);\n#endif\n    while (interp->interpStrEvents) {\n        InterpStrEvent *se = interp->interpStrEvents;\n        interp->interpStrEvents = se->next;\n        if (se->acfunc)\n            Jsi_DecrRefCount(interp, se->acfunc);\n        if (se->acdata)\n            Jsi_Free(se->acdata);\n        Jsi_Free(se);\n    }\n\n    if (interp->Mutex)\n        Jsi_MutexDelete(interp, interp->Mutex);\n    if (interp->QMutex) {\n        Jsi_MutexDelete(interp, interp->QMutex);\n        Jsi_DSFree(&interp->interpEvalQ);\n    }\n    if (interp->nullFuncArg)\n        Jsi_DecrRefCount(interp, interp->nullFuncArg);\n    if (interp->NullValue)\n        Jsi_DecrRefCount(interp, interp->NullValue);\n    if (interp->Function_prototype_prototype) {\n        if (interp->Function_prototype_prototype->refCnt>1)\n            Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n        Jsi_DecrRefCount(interp, interp->Function_prototype_prototype);\n    }\n    if (interp->Object_prototype) {\n        Jsi_DecrRefCount(interp, interp->Object_prototype);\n    }\n    Jsi_HashDelete(interp->regexpTbl);\n    Jsi_OptionsFree(interp, InterpOptions, interp, 0);\n    Jsi_HashDelete(interp->userdataTbl);\n    Jsi_HashDelete(interp->eventTbl);\n    if (interp->inopts)\n        Jsi_DecrRefCount(interp, interp->inopts);\n    if (interp->safeWriteDirs)\n        Jsi_DecrRefCount(interp, interp->safeWriteDirs);\n    if (interp->safeReadDirs)\n        Jsi_DecrRefCount(interp, interp->safeReadDirs);\n    if (interp->pkgDirs)\n        Jsi_DecrRefCount(interp, interp->pkgDirs);\n    for (i=0; interp->cleanObjs[i]; i++) {\n        interp->cleanObjs[i]->tree->opts.freeHashProc = 0;\n        Jsi_ObjFree(interp, interp->cleanObjs[i]);\n    }\n    Jsi_HashDelete(interp->bindTbl);\n    for (i = 0; i <= interp->cur_scope; i++)\n        jsi_ScopeStrsFree(interp, interp->scopes[i]);\n#if JSI__ZVFS==1\n    Jsi_InitZvfs(interp, mainFlag);\n#endif\n    if (!interp->parent)\n        Jsi_HashDelete(interp->loadTbl);\n    if (interp->packageHash)\n        Jsi_HashDelete(interp->packageHash);\n    Jsi_HashDelete(interp->assocTbl);\n    interp->cleanup = 1;\n    jsi_AllObjOp(interp, NULL, -1);\n#ifdef JSI_MEM_DEBUG\n    jsi_DebugDumpValues(interp);\n#endif\n    if (isMainInt || interp->strKeyTbl != jsiIntData.mainInterp->strKeyTbl)\n        Jsi_MapDelete(interp->strKeyTbl);\n\n    if (isMainInt)\n        jsiIntData.mainInterp = NULL;\n    _JSI_MEMCLEAR(interp);\n    jsiIntData.delInterp = NULL;\n    Jsi_Free(interp);\n    return JSI_OK;\n}\n\nvoid Jsi_InterpDelete(Jsi_Interp* interp)\n{\n    if (interp->deleting || interp->level > 0 || !interp->onDeleteTbl)\n        return;\n    interp->deleting = 1;\n    Jsi_HashDelete(interp->onDeleteTbl);\n    interp->onDeleteTbl = NULL;\n    Jsi_EventuallyFree(interp, interp, jsiInterpDelete);\n}\n\ntypedef struct {\n    void *data;\n    Jsi_Interp *interp;\n    int refCnt;\n    Jsi_DeleteProc* proc;\n} PreserveData;\n\nvoid Jsi_Preserve(Jsi_Interp* interp, void *data) {\n    bool isNew;\n    PreserveData *ptr;\n    Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->preserveTbl, data, &isNew);\n    assert(hPtr);\n    if (!isNew) {\n        ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n        if (ptr) {\n            assert(interp == ptr->interp);\n            ptr->refCnt++;\n        }\n    } else {\n        ptr = (PreserveData*)Jsi_Calloc(1,sizeof(*ptr));\n        Jsi_HashValueSet(hPtr, ptr);\n        ptr->interp = interp;\n        ptr->data = data;\n        ptr->refCnt = 1;\n    }\n}\n\nvoid Jsi_Release(Jsi_Interp* interp, void *data) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) return;\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    if (!ptr) return;\n    assert(ptr->interp == interp);\n    if (--ptr->refCnt > 0) return;\n    if (ptr->proc)\n        (*ptr->proc)(interp, data);\n    Jsi_Free(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_EventuallyFree(Jsi_Interp* interp, void *data, Jsi_DeleteProc* proc) {\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->preserveTbl, data);\n    if (!hPtr) {\n        (*proc)(interp, data);\n        return;\n    }\n    PreserveData *ptr = (PreserveData*)Jsi_HashValueGet(hPtr);\n    assert(ptr && ptr->interp == interp);\n    JSI_NOWARN(ptr);\n    Jsi_HashEntryDelete(hPtr);\n}\n\nvoid Jsi_InterpOnDelete(Jsi_Interp *interp, Jsi_DeleteProc *freeProc, void *ptr)\n{\n    if (freeProc)\n        Jsi_HashSet(interp->onDeleteTbl, ptr, (void*)freeProc);\n    else {\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->onDeleteTbl, ptr);\n        if (hPtr)\n            Jsi_HashEntryDelete(hPtr);\n    }\n}\n\nstatic void interpObjErase(InterpObj *fo)\n{\n    SIGASSERTV(fo,INTERPOBJ);\n    if (fo->subinterp) {\n        Jsi_Interp *interp = fo->subinterp;\n        fo->subinterp = NULL;\n        Jsi_InterpDelete(interp);\n        /*fclose(fo->fp);\n        Jsi_Free(fo->interpname);\n        Jsi_Free(fo->mode);*/\n    }\n    fo->subinterp = NULL;\n}\n\nstatic Jsi_RC interpObjFree(Jsi_Interp *interp, void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (fo->deleting) return JSI_OK;\n    fo->deleting = 1;\n    interpObjErase(fo);\n    Jsi_Free(fo);\n    return JSI_OK;\n}\n\nstatic bool interpObjIsTrue(void *data)\n{\n    InterpObj *fo = (InterpObj *)data;\n    SIGASSERT(fo,INTERPOBJ);\n    if (!fo->subinterp) return 0;\n    else return 1;\n}\n\nstatic bool interpObjEqual(void *data1, void *data2)\n{\n    return (data1 == data2);\n}\n\n/* TODO: possibly support async func-callback.  Also for call/send. */\nstatic Jsi_RC InterpEvalCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int flags)\n{\n    int isFile = flags&2;\n    int isUplevel = flags&1;\n    int lev = 0;\n    bool async = 0;\n    Jsi_RC rc = JSI_OK;\n    int isthrd;\n    Jsi_Interp *sinterp = interp;\n    Jsi_ValueMakeUndef(interp, ret);\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    if (udf)\n        sinterp = udf->subinterp;\n    if (Jsi_InterpGone(interp) || Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!isUplevel) {\n        if (nw && Jsi_GetBoolFromValue(interp, nw, &async))\n            return JSI_ERROR;\n    } else {\n        if (isthrd)\n            return Jsi_LogError(\"can not use uplevel() with threaded interp\");\n        Jsi_Number nlev = sinterp->framePtr->level;\n        if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev)!=JSI_OK)\n            return Jsi_LogError(\"expected number\");\n        lev = (int)nlev;\n        if (lev <= 0)\n            lev = f->level+lev;\n        if (lev <= 0 || lev > f->level)\n            return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    }\n\n    char *cp = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    if (cp==NULL || *cp == 0)\n        return JSI_OK;\n    if (async && isthrd) {\n        /* Post to thread event in sub-interps queue. TODO: could just use event like below... */\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        Jsi_DSAppend(&sinterp->interpEvalQ, Jsi_Strlen(Jsi_DSValue(&sinterp->interpEvalQ))?\";\":\"\", cp, NULL);\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        return JSI_OK;\n    }\n    if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n    if (!isthrd) {\n        int ostrict = sinterp->strict;\n        sinterp->strict = 0;\n        sinterp->level++;\n        if (interp->framePtr->tryDepth)\n            sinterp->framePtr->tryDepth++;\n        if (isFile) {\n            int sflags = 0;\n            if (!sinterp->includeCnt) {\n                sflags = JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX;\n                sinterp->isMain = 1;\n            }\n            if (sinterp->debugOpts.debugCallback && !sinterp->includeCnt)  // TODO: safe debugging can't use \"source\"\n                // TODO: we do this in debugger, even though it is illegal for interps to share objects.\n                sinterp->autoFiles = Jsi_ValueDup(sinterp, interp->autoFiles);\n            sinterp->includeCnt++;\n            rc = Jsi_EvalFile(sinterp, Jsi_ValueArrayIndex(interp, args, 0), sflags);\n        } else if (isUplevel == 0 || lev <= 1)\n            rc = (Jsi_EvalString(sinterp, cp, 0) == 0 ? JSI_OK : JSI_ERROR);\n        else {\n            rc = (jsi_evalStrFile(sinterp, NULL, cp, 0, lev) == 0 ? JSI_OK : JSI_ERROR);\n        }\n        sinterp->strict = ostrict;\n        if (interp->framePtr->tryDepth) {\n            sinterp->framePtr->tryDepth--;\n            if (rc != JSI_OK && interp != sinterp) {\n                Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n                interp->errLine = sinterp->errLine;\n                interp->errFile = sinterp->errFile;\n                sinterp->errMsgBuf[0] = 0;\n            }\n        }\n        sinterp->level--;\n    } else {\n        if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n        SIGINIT(s,INTERPSTREVENT);\n        s->isExec = 1;\n        s->tryDepth = interp->framePtr->tryDepth;\n        Jsi_DSInit(&s->data);\n        Jsi_DSAppend(&s->data, cp, NULL);\n        Jsi_DSInit(&s->func);\n        //s->mutex = Jsi_MutexNew(interp, -1, JSI_MUTEX_RECURSIVE);\n        //Jsi_MutexLock(s->mutex);\n        se = sinterp->interpStrEvents;\n        if (!se)\n            sinterp->interpStrEvents = s;\n        else {\n            while (se->next)\n                se = se->next;\n            se->next = s;\n        }\n\n        Jsi_MutexUnlock(interp, sinterp->QMutex);\n        while (s->isExec)      /* Wait until done. TODO: timeout??? */\n            Jsi_Sleep(interp, 1);\n        rc = (s->rc == 0 ? JSI_OK : JSI_ERROR);\n        if (rc != JSI_OK)\n            Jsi_LogError(\"eval failed: %s\", Jsi_DSValue(&s->data));\n        Jsi_DSFree(&s->func);\n        Jsi_DSFree(&s->data);\n        Jsi_Free(s);\n    }\n\n    if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n        return JSI_ERROR;\n    }\n\n    if (Jsi_InterpGone(sinterp))\n    {\n        /* TODO: perhaps exit() be able to delete. */\n        //Jsi_InterpDelete(sinterp);\n        return JSI_OK;\n    }\n    /*if (rc != JSI_OK && !async)\n        return rc;*/\n    if (sinterp->retValue->vt != JSI_VT_UNDEF) {\n        if (sinterp == interp)\n            Jsi_ValueCopy(interp, *ret, sinterp->retValue);\n        else\n            Jsi_CleanValue(sinterp, interp, sinterp->retValue, ret);\n    }\n    return rc;\n}\n\nJsi_Interp *jsi_DoExit(Jsi_Interp *interp, int rc)\n{\n    if (rc<0 || rc>127) rc = 127;\n    if (!interp || !interp->opts.no_exit) {\n        if (rc) {\n            Jsi_Flush(interp, jsi_Stdout);\n            Jsi_Flush(interp, jsi_Stderr);\n        }\n        exit(rc);\n    }\n    fprintf(stderr, \"ignoring attempted exit: may cause a crash\\n\");\n    if (interp) interp->deleting = 1;\n    return NULL;\n}\n\n#define FN_interpeval JSI_INFO(\"\\\nWhen the 'async' option is used on a threaded interp, the script is queued as an Event.\")\n\nstatic Jsi_RC InterpEvalCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 0);\n}\n\n\n#define FN_interpuplevel JSI_INFO(\"\\\nThe level argument is as returned by Info.level().  Not supported with threads.\")\nstatic Jsi_RC InterpUplevelCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 1);\n}\n\nstatic Jsi_RC InterpSourceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    return InterpEvalCmd_(interp, args, _this, ret, funcPtr, 2);\n}\n\nstatic Jsi_RC InterpValueCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *sinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n        return Jsi_LogError(\"Sub-interp gone\");\n        sinterp = udf->subinterp;\n        if (interp->threadId != udf->subinterp->threadId)\n            return Jsi_LogError(\"value not supported with threads\");\n    }\n    Jsi_Value *nw = Jsi_ValueArrayIndex(interp, args, 1);\n    jsi_Frame *f = sinterp->framePtr;\n    Jsi_Number nlev = sinterp->framePtr->level;\n    if (nw && Jsi_GetNumberFromValue(interp, nw, &nlev))\n        return JSI_ERROR;\n    int lev = (int)nlev;\n    if (lev <= 0)\n        lev = f->level+lev;\n    if (lev <= 0 || lev > f->level)\n        return Jsi_LogError(\"level %d not between 1 and %d\", (int)nlev, f->level);\n    while (f->level != lev  && f->parent)\n        f = f->parent;\n\n    const char* arg = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n    Jsi_Value *val = NULL;\n    if (arg) {\n        if (f == sinterp->framePtr)\n            val = Jsi_NameLookup(sinterp, arg);\n        else {\n            jsi_Frame *of = sinterp->framePtr;\n            sinterp->framePtr = f;\n            val = Jsi_NameLookup(sinterp, arg);\n            sinterp->framePtr = of;\n        }\n    }\n    if (!val)\n        return Jsi_LogError(\"unknown var: %s\", arg);\n    if (sinterp == interp) {\n        Jsi_ValueCopy(interp, *ret, val);\n        return JSI_OK;\n    }\n    Jsi_CleanValue(sinterp, interp, val, ret);\n    return JSI_OK;\n}\n\nstatic Jsi_RC InterpInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_Interp *subinterp = interp;\n    if (udf) {\n        if (!udf->subinterp)\n            return Jsi_LogError(\"Sub-interp gone\");\n        subinterp = udf->subinterp;\n    }\n    return jsi_InterpInfo(subinterp, args, _this, ret, funcPtr);\n}\n\nJsi_RC jsi_InterpInfo(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Interp *sinterp = interp;\n    Jsi_DString dStr = {}, cStr = {};\n    char tbuf[1024];\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    tbuf[0] = 0;\n    if (v) {\n        InterpObj *udf = NULL;\n        if (v && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_USEROBJ)\n            udf = (InterpObj *)v->d.obj->d.uobj->data;\n        if (udf && udf->subinterp) {\n            SIGASSERT(udf, INTERPOBJ);\n            sinterp = udf->subinterp;\n        } else\n            return Jsi_LogError(\"unknown interp\");\n    }\n    if (sinterp->subthread)\n        snprintf(tbuf, sizeof(tbuf), \", thread:{errorCnt:%u, evalCnt:%u, msgCnt:%u }\",\n            sinterp->threadErrCnt, sinterp->threadEvalCnt, sinterp->threadMsgCnt );\n    const char *funcstr = sinterp->framePtr->funcName;\n    if (!funcstr)\n        funcstr = \"\";\n    int curLine = (sinterp->curIp?sinterp->curIp->Line:0);\n    Jsi_DSPrintf(&dStr, \"{curLevel:%d, curLine:%d, curFile:\\\"%s\\\", curFunc:\\\"%s\\\", hasExited:%d, \"\n        \"opCnt:%d, isSafe:%s, depth:%d, codeCacheHits: %d, typeMismatchCnt:%d, \"\n        \"funcCallCnt:%d, cmdCallCnt:%d, includeCnt:%d, includeDepth:%d, pkgReqDepth:%d, \"\n        \"cwd:\\\"%s\\\", lockTimeout: %d, name, \\\"%s\\\" %s%s};\",\n        sinterp->level, curLine, jsi_GetCurFile(sinterp), funcstr?funcstr:\"\",\n        sinterp->exited, sinterp->opCnt, sinterp->isSafe?\"true\":\"false\",\n        sinterp->interpDepth, sinterp->codeCacheHit, sinterp->typeMismatchCnt,\n        sinterp->funcCallCnt, sinterp->cmdCallCnt, sinterp->includeCnt, sinterp->includeDepth, sinterp->pkgReqDepth,\n        (sinterp->curDir?sinterp->curDir:Jsi_GetCwd(sinterp,&cStr)),\n        sinterp->lockTimeout, sinterp->name?sinterp->name:\"\", tbuf[0]?\",\":\"\", tbuf);\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    if (rc != JSI_OK)\n        puts(Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&cStr);\n    return rc;\n}\n\nstatic Jsi_RC SubInterpEvalCallback(Jsi_Interp *interp, void* data)\n{\n    Jsi_RC rc = JSI_OK;\n    Jsi_DString dStr = {};\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n    char *cp = Jsi_DSValue(&interp->interpEvalQ);\n    if (*cp) {\n        Jsi_DSAppend(&dStr, cp, NULL);\n        Jsi_DSSetLength(&interp->interpEvalQ, 0);\n        interp->threadEvalCnt++;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (Jsi_EvalString(interp, Jsi_DSValue(&dStr), 0) != JSI_OK)\n            rc = JSI_ERROR;\n        Jsi_DSSetLength(&dStr, 0);\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n    }\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    Jsi_DSFree(&dStr);\n    if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Process subevents. */\n    InterpStrEvent *oldse, *se = interp->interpStrEvents;\n    Jsi_MutexUnlock(interp, interp->QMutex);\n    while (se) {\n        oldse = se;\n        int isExec = se->isExec;\n        if (se->acdata) {\n            jsi_AliasCreateCmd(interp, Jsi_DSValue(&se->func), se->acdata);\n        }\n        else if (se->acfunc) {\n            if (JSI_OK != Jsi_FunctionInvokeJSON(interp, se->acfunc, Jsi_DSValue(&se->data), NULL))\n                rc = JSI_ERROR;\n            Jsi_DecrRefCount(interp, se->acfunc);\n        }\n        else if (isExec) {\n            if (se->tryDepth)\n                interp->framePtr->tryDepth++;\n            se->rc = Jsi_EvalString(interp, Jsi_DSValue(&se->data), 0);\n            Jsi_DSSetLength(&se->data, 0);\n            if (se->rc != JSI_OK && se->tryDepth) {\n                Jsi_DSAppend(&se->data, interp->errMsgBuf, NULL);\n                se->errLine = interp->errLine;\n                se->errFile = interp->errFile;\n            } else {\n                Jsi_ValueGetDString(interp, interp->retValue, &se->data, JSI_OUTPUT_JSON);\n            }\n            if (se->tryDepth)\n                interp->framePtr->tryDepth--;\n\n        /* Otherwise, async calls. */\n        /*} else if (se->objData) {\n            if (JSI_OK != Jsi_CommandInvoke(interp, Jsi_DSValue(&se->func), se->objData, NULL))\n                rc = JSI_ERROR;*/\n        } else {\n            const char *scp = Jsi_DSValue(&se->data);\n            if (JSI_OK != Jsi_CommandInvokeJSON(interp, Jsi_DSValue(&se->func), scp, NULL))\n                rc = JSI_ERROR;\n        }\n        if (!isExec) {\n            Jsi_DSFree(&se->func);\n            Jsi_DSFree(&se->data);\n        }\n        if (Jsi_MutexLock(interp, interp->QMutex) != JSI_OK)\n            return JSI_ERROR;\n        interp->interpStrEvents = se->next;\n        if (!isExec) Jsi_Free(se);\n        se = interp->interpStrEvents;\n        Jsi_MutexUnlock(interp, interp->QMutex);\n        if (isExec)\n            oldse->isExec = 0;\n    }\n\n    return rc;\n}\n\n\nstatic Jsi_RC ThreadEvalCallback(Jsi_Interp *interp, void* data) {\n    Jsi_RC rc;\n\n    if ((rc=SubInterpEvalCallback(interp, data)) != JSI_OK)\n        interp->threadErrCnt++;\n    return rc;\n}\n\n/* Create an event handler in interp to handle call/eval/send asyncronously via 'Sys.update()'. */\nvoid jsi_AddEventHandler(Jsi_Interp *interp)\n{\n    Jsi_Event *ev;\n    while (!interp->EventHdlId) { /* Find an empty event slot. */\n        bool isNew;\n        uintptr_t id = ++interp->eventIdx;\n        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);\n        if (!isNew)\n            continue;\n        ev = (Jsi_Event*)Jsi_Calloc(1, sizeof(*ev));\n        SIGINIT(ev,EVENT);\n        ev->id = id;\n        ev->handler = ThreadEvalCallback;\n        ev->hPtr = hPtr;\n        ev->evType = JSI_EVENT_ALWAYS;\n        Jsi_HashValueSet(hPtr, ev);\n        interp->EventHdlId = id;\n    }\n}\n\n#define FN_call JSI_INFO(\"\\\nInvoke function in sub-interp with arguments.\\n\\\nSince interps are not allowed to share objects, \\\ndata is automatically cleansed by encoding/decoding to/from JSON if required.\\n\\\nUnless an 'async' parameter is true call is acyncronous.\\n\\\nOtherwise waits until the sub-interp is idle, \\\nto make call and return result.\")\n\nstatic Jsi_RC InterpCallCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (InterpObj *)Jsi_UserObjGetData(interp, _this, funcPtr);\n    int isthrd;\n    Jsi_Interp *sinterp;\n    if (udf)\n        sinterp = udf->subinterp;\n    else\n        return Jsi_LogError(\"Apply Interp.call in a non-subinterp\");\n    if (Jsi_InterpGone(sinterp))\n        return Jsi_LogError(\"Sub-interp gone\");\n    isthrd = (interp->threadId != sinterp->threadId);\n\n    Jsi_Value *func = NULL;\n    char *fname = NULL;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    fname = Jsi_ValueString(interp, func, NULL);\n    if (!fname)\n        return Jsi_LogError(\"function name must be a string\");\n    if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK)\n        return JSI_ERROR;\n    Jsi_Value *namLU = Jsi_NameLookup(sinterp, fname);\n    Jsi_MutexUnlock(interp, sinterp->Mutex);\n    if (namLU == NULL)\n        return Jsi_LogError(\"unknown function: %s\", fname);\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1);\n    char *cp = Jsi_ValueString(interp, arg, NULL);\n\n    if (cp == NULL && !Jsi_ValueIsArray(interp, arg))\n        return Jsi_LogError(\"expected string or array\");\n\n    Jsi_Value *vwait = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_RC rc = JSI_OK;\n    bool wait = 0;\n    if (vwait && Jsi_GetBoolFromValue(interp, vwait, &wait))\n        return JSI_ERROR;\n\n    if (wait) {\n        Jsi_DString dStr = {};\n        if (cp == NULL)\n            cp = (char*)Jsi_ValueGetDString(interp, arg, &dStr, JSI_OUTPUT_JSON);\n        if (interp->subOpts.mutexUnlock) Jsi_MutexUnlock(interp, interp->Mutex);\n        if (Jsi_MutexLock(interp, sinterp->Mutex) != JSI_OK) {\n            if (interp->subOpts.mutexUnlock) Jsi_MutexLock(interp, interp->Mutex);\n            return JSI_ERROR;\n        }\n        Jsi_Value *srPtr = Jsi_ValueNew1(sinterp);\n        /* TODO: call from this interp may not be safe if threaded.\n         * Could instead use async code below then wait for unlock on se->mutex. */\n        rc = Jsi_CommandInvokeJSON(sinterp, fname, cp, &srPtr);\n        Jsi_DSSetLength(&dStr, 0);\n        Jsi_CleanValue(sinterp, interp, srPtr, ret);\n        //Jsi_ValueCopy(interp, *ret, srPtr);\n        Jsi_DecrRefCount(sinterp, srPtr);\n        Jsi_DSFree(&dStr);\n        Jsi_MutexUnlock(interp, sinterp->Mutex);\n        if (interp->subOpts.mutexUnlock && Jsi_MutexLock(interp, interp->Mutex) != JSI_OK) {\n            Jsi_LogBug(\"mutex re-get failed\");\n            return JSI_ERROR;\n        }\n        return rc;\n    }\n\n    /* Post to thread event in sub-interps queue. */\n    if (Jsi_MutexLock(interp, sinterp->QMutex) != JSI_OK)\n        return JSI_ERROR;\n\n    /* Is an async call. */\n    InterpStrEvent *se, *s = (InterpStrEvent *)Jsi_Calloc(1, sizeof(*s));\n    // TODO: is s->data inited?\n    Jsi_DSInit(&s->data);\n    if (!cp) {\n        Jsi_ValueGetDString(interp, arg, &s->data, JSI_OUTPUT_JSON);\n    } else {\n        Jsi_DSSetLength(&s->data, 0);\n        Jsi_DSAppend(&s->data, cp, NULL);\n    }\n    Jsi_DSInit(&s->func);\n    Jsi_DSAppend(&s->func, fname, NULL);\n    se = sinterp->interpStrEvents;\n    if (!se)\n        sinterp->interpStrEvents = s;\n    else {\n        while (se->next)\n            se = se->next;\n        se->next = s;\n    }\n\n    Jsi_MutexUnlock(interp, sinterp->QMutex);\n    if (!isthrd) {\n        if (SubInterpEvalCallback(sinterp, NULL) != JSI_OK)\n            sinterp->threadErrCnt++;\n    }\n    return JSI_OK;\n}\n\nJsi_RC Jsi_Mount( Jsi_Interp *interp, Jsi_Value *archive, Jsi_Value *mount, Jsi_Value **ret)\n{\n#if JSI__ZVFS==1\n    return Zvfs_Mount(interp, archive, mount, ret);\n#else\n    return JSI_ERROR;\n#endif\n}\n\n/* Looks in dir for autoload.jsi or lib/autoload.jsi to add to autoFiles list. */\nint Jsi_AddAutoFiles(Jsi_Interp *interp, const char *dir) {\n    Jsi_DString dStr = {};\n    Jsi_StatBuf stat;\n    int i, cnt = 0;\n    for (i=0; i<2; i++) {\n        Jsi_DSAppend(&dStr, dir, (i==0?\"/lib\":\"\"),\"/autoload.jsi\", NULL);\n        Jsi_Value *v = Jsi_ValueNewStringKey(interp, Jsi_DSValue(&dStr));\n        if (Jsi_Stat(interp, v, &stat) != 0)\n            Jsi_ValueFree(interp, v);\n        else {\n            if (!interp->autoFiles) {\n                interp->autoFiles = Jsi_ValueNewArray(interp, 0, 0);\n                Jsi_IncrRefCount(interp, interp->autoFiles);\n            }\n            Jsi_ObjArrayAdd(interp, interp->autoFiles->d.obj, v);\n            cnt++;\n            interp->autoLoaded = 0;\n        }\n        Jsi_DSSetLength(&dStr, 0);\n    }\n    Jsi_DSFree(&dStr);\n    return cnt;\n}\n\nJsi_RC Jsi_EvalZip(Jsi_Interp *interp, const char *exeFile, const char *mntDir, int *jsFound)\n{\n#if JSI__ZVFS==1\n    Jsi_StatBuf stat;\n    Jsi_Value *vinit, *linit, *vmnt = NULL;\n    Jsi_Value *vexe = Jsi_ValueNewStringKey(interp, exeFile);\n    Jsi_Value *ret = NULL;\n    Jsi_RC rc;\n    const char *omntDir = mntDir;\n    int pass = 0;\n    Jsi_IncrRefCount(interp, vexe);\n    Jsi_HashSet(interp->genValueTbl, vexe, vexe);\n    if (jsFound)\n        *jsFound = 0;\n    if (!mntDir)\n        ret = Jsi_ValueNew(interp);\n    else {\n        vmnt = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, vmnt);\n        Jsi_HashSet(interp->genValueTbl, vmnt, vmnt);\n    }\n    bool osafe = interp->isSafe;\n    if (interp->startSafe)\n        interp->isSafe = 0;\n    rc =Jsi_Mount(interp, vexe, vmnt, &ret);\n    interp->isSafe = osafe;\n    if (rc != JSI_OK)\n        return rc;\n    Jsi_DString dStr, bStr;\n    Jsi_DSInit(&dStr);\n    Jsi_DSInit(&bStr);\n    if (!mntDir) {\n        mntDir = Jsi_KeyAdd(interp, Jsi_ValueString(interp, ret, NULL));\n        Jsi_DecrRefCount(interp, ret);\n    }\ndochk:\n    Jsi_DSAppend(&dStr, mntDir, \"/main.jsi\", NULL);\n    if (interp->pkgDirs)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, Jsi_ValueNewStringKey(interp, mntDir));\n    else {\n        interp->pkgDirs = Jsi_ValueNewArray(interp, &mntDir, 1);\n        Jsi_IncrRefCount(interp, interp->pkgDirs);\n    }\n    vinit = Jsi_ValueNewStringKey(interp,  Jsi_DSValue(&dStr));\n    Jsi_IncrRefCount(interp, vinit);\n    Jsi_HashSet(interp->genValueTbl, vinit, vinit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSAppend(&dStr, mntDir, \"/lib\", NULL);\n    const char *str = Jsi_DSValue(&dStr);\n    linit = Jsi_ValueNewStringKey(interp, str);\n    Jsi_IncrRefCount(interp, linit);\n    if (Jsi_Stat(interp, linit, &stat) == 0)\n        Jsi_ValueArrayPush(interp, interp->pkgDirs, linit);\n    Jsi_DecrRefCount(interp, linit);\n    Jsi_DSFree(&dStr);\n    Jsi_DSFree(&bStr);\n    if (Jsi_Stat(interp, vinit, &stat) == 0) {\n        if (jsFound)\n            *jsFound |= JSI_ZIP_MAIN;\n        interp->execZip = vexe;\n        return Jsi_EvalFile(interp, vinit, JSI_EVAL_ARGV0|JSI_EVAL_AUTOINDEX);\n    }\n    if (Jsi_AddAutoFiles(interp, mntDir) && omntDir)\n        *jsFound = JSI_ZIP_INDEX;\n    if (!pass++) {\n        str = Jsi_Strrchr(exeFile, '/');\n        if (str) str++;\n        else str = exeFile;\n        char *bn = Jsi_DSAppend(&bStr, mntDir, \"/\", str, NULL);\n        bn = Jsi_Strrchr(bn, '.');\n        if (bn) *bn = 0;\n        mntDir = Jsi_DSValue(&bStr);\n        linit = Jsi_ValueNewStringKey(interp, mntDir);\n        Jsi_IncrRefCount(interp, linit);\n        int bsi = Jsi_Stat(interp, linit, &stat);\n        Jsi_DecrRefCount(interp, linit);\n        if (bsi == 0)\n            goto dochk;\n        Jsi_DSFree(&bStr);\n    }\n#endif\n    return JSI_OK;\n}\n\n#ifndef JSI_OMIT_THREADS\n\n#ifdef __WIN32\n#define JSITHREADRET void\n#else\n#define JSITHREADRET void*\n#endif\n\nstatic JSITHREADRET NewInterpThread(void* iPtr)\n{\n    int rc = JSI_OK;\n    InterpObj *udf = (InterpObj *)iPtr;\n    Jsi_Interp *interp = udf->subinterp;\n    interp->threadId = Jsi_CurrentThread();\n    if (interp->scriptStr)\n        rc = Jsi_EvalString(interp, interp->scriptStr, 0);\n    else if (interp->scriptFile) {\n        if (!interp->debugOpts.debugCallback) // Debug will use Interp.source() instead.\n            Jsi_EvalFile(interp, interp->scriptFile, 0);\n    } else {\n        Jsi_LogBug(\"no eval\");\n    }\n    if (rc != JSI_OK) {\n        Jsi_LogError(\"eval failure\");\n        interp->threadErrCnt++;\n        if (Jsi_MutexLock(interp, interp->Mutex) != JSI_OK)\n            return NULL;\n        Jsi_MutexUnlock(interp, interp->Mutex);\n    }\n    interpObjErase(udf);\n#ifndef __WIN32\n    /* TODO: should we wait/notify parent??? */\n    pthread_detach(pthread_self());\n    return NULL;\n#endif\n}\n#endif\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr);\n\nstatic Jsi_CmdSpec interpCmds[] = {\n    { \"Interp\", InterpConstructor,0,  1, \"options:object=void\", .help=\"Create a new interp\", .retType=(uint)JSI_TT_USEROBJ, .flags=JSI_CMD_IS_CONSTRUCTOR, .info=0, .opts=InterpOptions},\n    { \"alias\",  InterpAliasCmd,   0,  4, \"name:string=void, func:function|null=void, args:array|null=void, async=false\",.help=\"Set/get global alias bindings for command in an interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_intalias },\n    { \"call\",   InterpCallCmd,    2,  3, \"funcName:string, args:array, wait:boolean=false\", .help=\"Call named function in subinterp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_call },\n    { \"conf\",   InterpConfCmd,    0,  1, \"options:string|object=void\",.help=\"Configure option(s)\" , .retType=(uint)JSI_TT_ANY,.flags=0,.info=0,.opts=InterpOptions},\n    { \"eval\",   InterpEvalCmd,    1,  2, \"js:string, async:boolean=false\", .help=\"Interpret script within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"info\",   InterpInfoCmd,    0,  0, \"\", .help=\"Returns internal statistics about interp\", .retType=(uint)JSI_TT_OBJECT },\n    { \"source\", InterpSourceCmd,  1,  2, \"file:string, async:boolean=false\", .help=\"Interpret file within sub-interp\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpeval },\n    { \"uplevel\",InterpUplevelCmd, 2,  2, \"js:string, level:number=0\", .help=\"Interpret code at the given stack level\", .retType=(uint)JSI_TT_ANY, .flags=0, .info=FN_interpuplevel },\n    { \"value\",  InterpValueCmd,   1,  2, \"var:string, level:number=0\", .help=\"Lookup value of variable at stack level\", .retType=(uint)JSI_TT_ANY },\n    { NULL,     0,0,0,0, .help=\"Commands for accessing interps\" }\n};\n\nstatic Jsi_UserObjReg interpobject = {\n    \"Interp\",\n    interpCmds,\n    interpObjFree,\n    interpObjIsTrue,\n    interpObjEqual\n};\n\n\nstatic Jsi_RC InterpConstructor(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *fobj;\n    Jsi_Value *toacc;\n    InterpObj *cmdPtr = (InterpObj *)Jsi_Calloc(1,sizeof(*cmdPtr));\n    int rc = JSI_OK;\n    SIGINIT(cmdPtr,INTERPOBJ);\n    cmdPtr->parent = interp;\n\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);\n\n    if (!(cmdPtr->subinterp = jsi_InterpNew(interp, arg, NULL))) {\n        Jsi_Free(cmdPtr);\n        return JSI_ERROR;\n    }\n    Jsi_Interp *sinterp = cmdPtr->subinterp;\n    sinterp->opts.no_exit = interp->opts.no_exit;\n    toacc = NULL;\n    if (Jsi_FunctionIsConstructor(funcPtr)) {\n        toacc = _this;\n    } else {\n        Jsi_Obj *o = Jsi_ObjNew(interp);\n        Jsi_PrototypeObjSet(interp, \"Interp\", o);\n        Jsi_ValueMakeObject(interp, ret, o);\n        toacc = *ret;\n    }\n\n    fobj = Jsi_ValueGetObj(interp, toacc);\n    if ((cmdPtr->objId = Jsi_UserObjNew(interp, &interpobject, fobj, cmdPtr))<0)\n        goto bail;\n    sinterp->objId = cmdPtr->objId;\n    cmdPtr->fobj = fobj;\n#ifndef JSI_OMIT_THREADS\n    if (sinterp->subthread) {\n#ifdef __WIN32\n        if (!_beginthread( NewInterpThread, 0, cmdPtr )) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#else\n        pthread_t nthread;\n        if (pthread_create(&nthread, NULL, NewInterpThread, cmdPtr) != 0) {\n            Jsi_LogError(\"thread create failed\");\n            goto bail;\n        }\n#endif //__WIN32\n#else\n    if (0) {\n#endif //JSI_OMIT_THREADS\n    } else {\n        //sinterp->framePtr->tryDepth++;\n        if (sinterp->scriptStr != 0) {\n            if (sinterp->scriptFile && !interp->curFile)\n                sinterp->curFile = Jsi_ValueString(sinterp, sinterp->scriptFile, NULL);\n            rc = Jsi_EvalString(sinterp, sinterp->scriptStr, JSI_EVAL_ISMAIN);\n        } else if (sinterp->scriptFile && !sinterp->debugOpts.debugCallback) {\n            int len;\n            if (Jsi_ValueString(interp, sinterp->scriptFile, &len) && len==0)\n                Jsi_Interactive(sinterp, JSI_OUTPUT_QUOTE|JSI_OUTPUT_NEWLINES);\n            else\n                rc = Jsi_EvalFile(sinterp, sinterp->scriptFile, JSI_EVAL_ISMAIN);\n        }\n        //sinterp->framePtr->tryDepth--;\n        if (rc == JSI_EXIT)\n            return JSI_OK;\n        if (rc != JSI_OK) {\n            /*Jsi_Strcpy(interp->errMsgBuf, sinterp->errMsgBuf);\n            interp->errLine = sinterp->errLine;\n            interp->errFile = sinterp->errFile;\n            sinterp->errMsgBuf[0] = 0;*/\n            goto bail;\n        }\n    }\n    return JSI_OK;\n\nbail:\n    interpObjErase(cmdPtr);\n    Jsi_ValueMakeUndef(interp, ret);\n    return JSI_ERROR;\n}\n\nstatic Jsi_RC Jsi_DoneInterp(Jsi_Interp *interp)\n{\n    Jsi_UserObjUnregister(interp, &interpobject);\n    return JSI_OK;\n}\n\nstatic Jsi_RC jsi_InterpConfFile(Jsi_Interp *interp, const char *fname, bool etc)\n{\n    Jsi_RC rc;\n    Jsi_DString dStr = {};\n    Jsi_Value *opts = NULL, *fn = Jsi_ValueNewStringConst(interp, fname, -1);\n    Jsi_IncrRefCount(interp, fn);\n    bool isSafe = interp->isSafe;\n    if (etc)\n        interp->isSafe = 0;\n    rc = Jsi_FileRead(interp, fn, &dStr);\n    if (rc != JSI_OK)\n        goto done;\n    opts = Jsi_ValueNew1(interp);\n    if (rc == JSI_OK)\n        rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), &opts, 0);\n    if (rc == JSI_OK\n        && Jsi_OptionsProcess(interp, InterpOptions, interp, opts, 0) < 0)\n        rc = JSI_ERROR;\ndone:\n    if (etc && isSafe)\n        interp->isSafe = 1;\n    if (opts)\n        Jsi_DecrRefCount(interp, opts);\n    Jsi_DecrRefCount(interp, fn);\n    Jsi_DSFree(&dStr);\n    return rc;\n}\n\nstatic Jsi_RC jsi_InterpConfFiles(Jsi_Interp *interp)\n{\n    Jsi_RC rc = JSI_OK;\n#ifndef JSI__CONFFILE\n#define JSI__CONFFILE \"/etc/jsish.conf\"\n#endif\n    const char *fn = JSI__CONFFILE;\n    if (!fn || !fn[0])\n        return JSI_OK;\n    if (interp->confFile)\n        rc = jsi_InterpConfFile(interp, interp->confFile, 0);\n    if (rc == JSI_OK && access(fn, R_OK)==0)\n        rc = jsi_InterpConfFile(interp, fn, 1);\n    if (rc != JSI_OK)\n        Jsi_LogWarn(\"parse failure: %s\", fn);\n    if (interp->jsppChars && Jsi_Strlen(interp->jsppChars)!=2) {\n        Jsi_LogWarn(\"jsppChars ignored: length not 2: %s\", interp->jsppChars);\n        interp->jsppChars = NULL;\n    }\n    return rc;\n}\n\nstatic Jsi_RC InterpConfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    InterpObj *udf = (typeof(udf))Jsi_UserObjGetData(interp, _this, funcPtr);\n    Jsi_RC rc;\n    Jsi_Value *opts = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Interp *sinterp = interp;\n    if (!udf || udf->subinterp == interp) {\n        if (interp->noConfig && opts && !Jsi_ValueIsString(interp, opts))\n            return Jsi_LogError(\"Interp conf() is disabled for set\");\n        rc = Jsi_OptionsConf(interp, InterpOptions, interp, opts, ret, 0);\n    } else {\n        sinterp = udf->subinterp;\n        Jsi_Value *popts = opts;\n        if (opts && opts->vt != JSI_VT_NULL && !Jsi_ValueString(interp, opts, NULL) && opts->vt == JSI_VT_OBJECT) {\n            popts = Jsi_ValueNew1(sinterp);\n            Jsi_CleanValue(interp, sinterp, opts, &popts);\n        }\n        rc = Jsi_OptionsConf(sinterp, InterpOptions, sinterp, popts, ret, 0);\n        if (popts && popts != opts)\n            Jsi_DecrRefCount(sinterp, popts);\n        Jsi_CleanValue(sinterp, interp, *ret, ret);\n    }\n    return rc;\n}\n\nJsi_Value *Jsi_ReturnValue(Jsi_Interp *interp) {\n    return interp->retValue;\n}\n\nJsi_RC jsi_InitInterp(Jsi_Interp *interp, int release)\n{\n    if (release) return Jsi_DoneInterp(interp);\n    Jsi_Hash *isys;\n    if (!(isys = Jsi_UserObjRegister(interp, &interpobject)))\n        Jsi_LogBug(\"Can not init interp\");\n\n    Jsi_CommandCreateSpecs(interp, interpobject.name, interpCmds, isys, JSI_CMDSPEC_ISOBJ);\n    return JSI_OK;\n}\n\nbool Jsi_InterpSafe(Jsi_Interp *interp)\n{\n    return interp->isSafe;\n}\n\nJsi_RC Jsi_InterpAccess(Jsi_Interp *interp, Jsi_Value* resource, int aflag)\n{\n    switch (aflag) {\n        case JSI_INTACCESS_NETWORK:\n            return (interp->noNetwork?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_MAININTERP:\n            return (interp->parent?JSI_ERROR:JSI_OK);\n        case JSI_INTACCESS_SETSSL:\n            interp->hasOpenSSL = 1;\n            return JSI_OK;\n        case JSI_INTACCESS_CREATE:\n            return (interp->isSafe && interp->safeMode==jsi_safe_Lockdown?JSI_ERROR: JSI_OK);\n        case JSI_INTACCESS_WRITE:\n        case JSI_INTACCESS_READ:\n            break;\n        default:\n            return JSI_ERROR;\n    }\n    if (!resource)\n        return JSI_ERROR;\n    Jsi_Value *v, *dirs = ((aflag==JSI_INTACCESS_WRITE) ? interp->safeWriteDirs : interp->safeReadDirs);\n    if (!interp->isSafe)\n        return JSI_OK;\n    if (!dirs)\n        return JSI_ERROR;\n    char pbuf[PATH_MAX];\n    int i, m, argc = Jsi_ValueGetLength(interp, dirs);\n    char *str, *dstr = Jsi_Realpath(interp, resource, pbuf);\n    if (!dstr)\n        return JSI_ERROR;\n    for (i=0; i<argc; i++) {\n        v = Jsi_ValueArrayIndex(interp, dirs, i);\n        if (!v) continue;\n        str = Jsi_ValueString(interp, v, &m);\n        if (!str || m<=0) continue;\n        if (!Jsi_Strcmp(str, dstr)) // Exact match.\n            return JSI_OK;\n        if (Jsi_Strncmp(str, dstr, m))\n            continue;\n        if (m>1 && str[m-1]=='/')\n            return JSI_OK;\n        if (dstr[m] == '/')\n            return JSI_OK;\n    }\n    return JSI_ERROR;\n}\n\nJsi_Value *Jsi_InterpResult(Jsi_Interp *interp)\n{\n    return interp->retValue;\n}\n\nconst char *Jsi_InterpLastError(Jsi_Interp *interp, const char **errFilePtr, int *errLinePtr)\n{\n    if (errFilePtr)\n        *errFilePtr = interp->errFile;\n    if (errLinePtr)\n        *errLinePtr = interp->errLine;\n    return interp->errMsgBuf;\n}\n\n#ifdef __WIN32\nvoid bzero(void *s, size_t n) {\n    memset(s, 0, n);\n}\n#endif\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n/******************* TREE ACCESS **********************/\n\nJsi_Value *Jsi_TreeObjGetValue(Jsi_Obj* obj, const char *key, int isstrkey) {\n    Jsi_Tree *treePtr = obj->tree;\n    \n    if (!isstrkey) {\n        Jsi_MapEntry *hPtr = Jsi_MapEntryFind(treePtr->opts.interp->strKeyTbl, key);\n        if (!hPtr)\n            return NULL;\n        key = (const char*)Jsi_MapKeyGet(hPtr, 0);\n    }\n    Jsi_Value *v = (Jsi_Value*)Jsi_TreeGet(treePtr, (void*)key, 0);\n    return v;\n}\n\nJsi_TreeEntry *Jsi_TreeObjSetValue(Jsi_Obj *obj, const char *key, Jsi_Value *val, int isstrkey) {\n    Jsi_Tree *treePtr = obj->tree;\n    bool isNew;\n    Jsi_TreeEntry *hPtr;\n    Jsi_Interp *interp = treePtr->opts.interp;\n    if (!isstrkey) {\n        const char *okey = key;\n        Jsi_MapEntry *hePtr = Jsi_MapEntryNew(interp->strKeyTbl, key, &isNew);\n        key = (const char*)Jsi_MapKeyGet(hePtr, 0);\n        if (!key) {\n            Jsi_MapEntry *hePtr = Jsi_MapEntryNew(interp->strKeyTbl, okey, &isNew);\n            key = (const char*)Jsi_MapKeyGet(hePtr, 0);\n        }\n    }\n    //return Jsi_TreeSet(treePtr, key, val);\n    hPtr = Jsi_TreeEntryNew(treePtr, key, &isNew);\n    if (!hPtr)\n        return NULL;\n    if (val)\n        SIGASSERT(val,VALUE);\n    if (!isNew)\n        Jsi_ValueReplace(interp, (Jsi_Value**)&(hPtr->value), val);\n    else {\n        hPtr->value = val;\n        if (val)\n            Jsi_IncrRefCount(interp, val);\n    }\n//    Jsi_Value *oldVal;  /* FYI: This let kitty.breed() work in tests/proto2.js */\n//    Assert(val->refCnt>0);\n//    if (!isNew) {\n//        oldVal = Jsi_TreeValueGet(hPtr);\n//        if (oldVal) {\n//            Jsi_ValueReset(interp, &oldVal);\n//            Jsi_ValueCopy(interp, oldVal, val);\n//        }\n//    }\n//    else\n//        hPtr->value = val;\n\n    return hPtr;\n}\n\n/*****************************************/\n\nbool Jsi_ObjIsArray(Jsi_Interp *interp, Jsi_Obj *o)  {\n    return ((o)->ot == JSI_OT_OBJECT && o->isarrlist);\n}\n\nstatic Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || (uint)n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n       // obj->arrCnt++;\n    }\n    return JSI_OK;\n}\n\nstatic Jsi_RC ObjListifyArrayCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    if (hPtr->f.bits.isarrlist) {\n        Jsi_TreeEntryDelete(hPtr);\n        tree->opts.interp->delRBCnt++;\n        return JSI_ERROR;\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_ObjListifyArray(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    if (!obj->isarrlist) {\n        Jsi_LogBug(\"Can not listify a non-array\");\n        return;\n    }\n    if (obj->arr) return;\n    Jsi_TreeWalk(obj->tree, ObjListifyCallback, obj, 0);\n\n    do {\n        interp->delRBCnt = 0;\n        Jsi_TreeWalk(obj->tree, ObjListifyArrayCallback, obj, 0);\n    } while (interp->delRBCnt);\n}\n\nvoid Jsi_IterObjFree(Jsi_IterObj *iobj)\n{\n    if (!iobj->isArrayList) {\n        uint i;\n        for (i = 0; i < iobj->count; i++) {\n            if (iobj->keys[i]) {\n                /*Jsi_TreeDecrRef(iobj->keys[i]); TODO: ??? */\n            }\n        }\n        Jsi_Free(iobj->keys);\n    }\n    Jsi_Free(iobj);\n}\n\nJsi_IterObj *Jsi_IterObjNew(Jsi_Interp *interp, Jsi_IterProc *iterCmd)\n{\n    Jsi_IterObj *o = (Jsi_IterObj*)Jsi_Calloc(1,sizeof(Jsi_IterObj));\n    o->interp = interp;\n    o->iterCmd = iterCmd;\n    return o;\n}\n\nstatic Jsi_RC DeleteTreeValue(Jsi_Interp *interp, Jsi_TreeEntry *ti, void *p) {\n    /* Cleanup tree value. */\n    SIGASSERT(ti,TREEENTRY);\n    Jsi_Value *v = (Jsi_Value*)p;\n    SIGASSERT(v,VALUE);\n    Jsi_DecrRefCount(interp, v);\n    ti->value = NULL;\n    return JSI_OK;\n}\n\nint jsi_AllObjOp(Jsi_Interp *interp, Jsi_Obj* obj, int op) {\n    if (op==2) {\n        Jsi_Obj* o = interp->allObjs;\n        while (o) {\n            if (o==obj) return 1;\n            o = o->next;\n        }\n        return 0;\n    }\n    if (op==1) {\n        //printf(\"ADD: %p : %p : %d\\n\", interp, obj, obj->VD.Idx);\n        assert(interp->allObjs!=obj);\n        obj->next = interp->allObjs;\n        if (interp->allObjs)\n            interp->allObjs->prev = obj;\n        interp->allObjs = obj;\n        return 0;\n    }\n    if (op==0) {\n        //printf(\"DEL: %p : %p\\n\", interp, obj);\n        if (!obj || !interp->allObjs) return 0;\n        if (obj == interp->allObjs)\n            interp->allObjs = obj->next;\n        if (obj->next)\n            obj->next->prev = obj->prev;\n        if (obj->prev)  \n            obj->prev->next = obj->next; \n        return 0;\n    }\n    if (op == -1) {\n        // TODO: fix cleanup for recursive bug, eg: x=[]; x.push(x);\n        // Perhaps use python approach??: http://www.arctrix.com/nas/python/gc/\n        while (0 && interp->allObjs) {\n            printf(\"NEED CLEANUP: %p\\n\", interp->allObjs);\n            Jsi_ObjDecrRefCount(interp, interp->allObjs);\n        }\n        return 0;\n    }\n#if JSI__MEMDEBUG\n    assert(0);\n    abort();\n#endif\n    return 0;\n}\n\nJsi_Obj *jsi_ObjNew_(Jsi_Interp *interp)\n{\n    Jsi_Obj *obj = (Jsi_Obj*)Jsi_Calloc(1,sizeof(*obj));\n    SIGINIT(obj,OBJ);\n    jsi_DebugObj(obj,\"New\", jsi_DebugValueCallIdx(), interp);\n    obj->ot = JSI_OT_OBJECT;\n    obj->tree = Jsi_TreeNew(interp, JSI_KEYS_STRINGKEY, NULL);\n    obj->tree->opts.freeTreeProc = DeleteTreeValue;\n    obj->tree->flags.valuesonly = 1;\n    obj->__proto__ = interp->Object_prototype;\n    interp->dbPtr->objCnt++;\n    interp->dbPtr->objAllocCnt++;\n   return obj;\n}\n\n#ifndef JSI_MEM_DEBUG\nJsi_Obj * Jsi_ObjNew(Jsi_Interp *interp) {\n    Jsi_Obj *obj = jsi_ObjNew_(interp);\n    jsi_AllObjOp(interp, obj, 1);\n    return obj;\n}\n#else\nJsi_Obj * jsi_ObjNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Obj *obj = jsi_ObjNew_(interp);\n    jsi_ValueDebugUpdate(interp, obj, objDebugTbl, fname, line, func);\n    jsi_AllObjOp(interp, obj, 1);\n    return obj;\n}\n\n#ifndef JSI_OMIT_STUBS\n#undef Jsi_ObjNew\nJsi_Obj *Jsi_ObjNew(Jsi_Interp *interp) {\n    Jsi_Obj* obj = jsi_ObjNew_(interp);\n#ifdef JSI_MEM_DEBUG\n    jsi_ValueDebugUpdate(interp, obj, objDebugTbl, NULL, 0, NULL);\n#endif\n    jsi_AllObjOp(interp, obj, 1);\n    return obj;\n}\n#define Jsi_ObjNew(interp) jsi_ObjNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#endif\n\n#endif\n\nJsi_Obj *Jsi_ObjNewType(Jsi_Interp *interp, Jsi_otype otype)\n{\n    Jsi_Obj *obj = Jsi_ObjNew(interp);\n    obj->ot = (otype==JSI_OT_ARRAY?JSI_OT_OBJECT:otype);\n    switch (otype) {\n        case JSI_OT_BOOL:   obj->__proto__ = interp->Boolean_prototype; break;\n        case JSI_OT_NUMBER: obj->__proto__ = interp->Number_prototype; break;\n        case JSI_OT_STRING: obj->__proto__ = interp->String_prototype; break;\n        case JSI_OT_FUNCTION:obj->__proto__ = interp->Function_prototype; break;\n        case JSI_OT_REGEXP: obj->__proto__ = interp->RegExp_prototype; break;\n        case JSI_OT_OBJECT: obj->__proto__ = interp->Object_prototype; break;\n        case JSI_OT_ARRAY:  obj->__proto__ = interp->Array_prototype;\n            obj->isarrlist = 1;\n            break;\n        default: assert(0); break;\n    }\n    if (interp->protoInit)\n        assert(obj->__proto__);\n    return obj;\n}\n\nvoid Jsi_ObjFree(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    interp->dbPtr->objCnt--;\n    //assert(obj->refcnt == 0);\n    jsi_AllObjOp(interp, obj, 0);\n#ifdef JSI_MEM_DEBUG\n    if (interp != obj->VD.interp)\n        printf(\"interp mismatch of objFree: %p!=%p : %p\\n\", interp, obj->VD.interp, obj);\n    jsi_DebugObj(obj,\"Free\", jsi_DebugValueCallIdx(), interp);\n    if (obj->VD.hPtr && !interp->cleanup) {\n        Jsi_HashEntryDelete(obj->VD.hPtr);\n        obj->VD.hPtr = NULL;\n    }\n#endif\n    /* printf(\"Free obj: %x\\n\", (int)obj); */\n    switch (obj->ot) {\n        case JSI_OT_STRING:\n            if (!obj->isstrkey)\n                Jsi_Free(obj->d.s.str);\n            obj->d.s.str = 0;\n            obj->isstrkey = 0;\n            break;\n        case JSI_OT_FUNCTION:\n            jsi_FuncObjFree(obj->d.fobj);\n            break;\n        case JSI_OT_ITER:\n            Jsi_IterObjFree(obj->d.iobj);\n            break;\n        case JSI_OT_USEROBJ:\n            jsi_UserObjFree(interp, obj->d.uobj);\n        case JSI_OT_ARRAY:\n        case JSI_OT_OBJECT:\n            break;\n        case JSI_OT_REGEXP:\n            if ((obj->d.robj->eflags&JSI_REG_STATIC)==0) {\n                regfree(&obj->d.robj->reg);\n                Jsi_Free(obj->d.robj);\n            }\n            break;\n        default:\n            break;\n    }\n    if (obj->tree)\n        Jsi_TreeDelete(obj->tree);\n    if (obj->arr) {\n        int i = -1;\n        while (++i < (int)obj->arrCnt)\n            if (obj->arr[i])\n                Jsi_DecrRefCount(interp, obj->arr[i]);\n        Jsi_Free(obj->arr);\n        obj->arr = NULL;\n    }\n    obj->tree = NULL;\n    if (obj->clearProto)\n        Jsi_DecrRefCount(interp, obj->__proto__);\n#ifdef JSI_MEM_DEBUG\n    memset(obj, 0, (sizeof(*obj)-sizeof(obj->VD)));\n#endif\n    Jsi_Free(obj);\n}\n\n\n/**************************** ARRAY ******************************/\n\nJsi_Value *jsi_ObjArrayLookup(Jsi_Interp *interp, Jsi_Obj *obj, const char *key) {\n    if (!obj->arr || !key || !isdigit(*key))\n        return NULL;\n    char *ep = NULL;\n    int n = (int)strtol(key, &ep, 0);\n    if (n<0 || n >= (int)obj->arrCnt)\n        return NULL;\n    Jsi_Value *v = obj->arr[n];\n    return v;\n}\n\nJsi_RC Jsi_ObjArrayAdd(Jsi_Interp *interp, Jsi_Obj *o, Jsi_Value *v)\n{\n    if (o->isarrlist == 0)\n        return JSI_ERROR;\n    if (!o->arr)\n        Jsi_ObjListifyArray(interp, o);\n    int len = o->arrCnt;\n    if (Jsi_ObjArraySizer(interp, o, len+1) <= 0)\n        return JSI_ERROR;\n    o->arr[len] = v;\n    if (v)\n        Jsi_IncrRefCount(interp, v);\n    assert(o->arrCnt<=o->arrMaxSize);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_ObjArraySet(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int arrayindex)\n{\n    int m, n = arrayindex;\n    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)\n        return JSI_ERROR;\n    if (obj->arr[n] == value)\n        return JSI_OK;\n    if (obj->arr[n])\n        Jsi_DecrRefCount(interp, obj->arr[n]);\n    Assert(obj->arrCnt<=obj->arrMaxSize);\n    obj->arr[n] = value;\n    if (value)\n        Jsi_IncrRefCount(interp, value);\n    m = Jsi_ObjGetLength(interp, obj);\n    if ((n+1) > m)\n       Jsi_ObjSetLength(interp, obj, n+1);\n    return JSI_OK;\n}\n\n// Copying version of above.\nJsi_Value *jsi_ObjArraySetDup(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *value, int n)\n{\n    if (Jsi_ObjArraySizer(interp, obj, n) <= 0)\n        return NULL;\n    if (obj->arr[n])\n    {\n        Jsi_ValueCopy(interp, obj->arr[n], value);\n        return obj->arr[n];\n    }\n    Assert(obj->arrCnt<=obj->arrMaxSize);\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    int m;\n    Jsi_ValueCopy(interp,v, value);\n    obj->arr[n] = v;\n    m = Jsi_ObjGetLength(interp, obj);\n    if ((n+1) > m)\n       Jsi_ObjSetLength(interp, obj, n+1);\n    return v;\n}\n\nint Jsi_ObjIncrRefCount(Jsi_Interp *interp, Jsi_Obj *obj) {\n    jsi_DebugObj(obj,\"Incr\", jsi_DebugValueCallIdx(), interp);\n    SIGASSERT(obj,OBJ);\n    Assert(obj->refcnt>=0);\n    return ++obj->refcnt;\n}\n\nint Jsi_ObjDecrRefCount(Jsi_Interp *interp, Jsi_Obj *obj)  {\n   // if (interp->cleanup && !jsi_AllObjOp(interp, obj, 2))\n   //    return 0;\n    SIGASSERT(obj,OBJ);\n    if (obj->refcnt<=0) {\n#ifdef JSI_MEM_DEBUG\n        fprintf(stderr, \"Obj decr with ref %d: VD.Idx=%d\\n\", obj->refcnt, obj->VD.Idx);\n#endif\n        return -2;\n    }\n    jsi_DebugObj(obj,\"Decr\", jsi_DebugValueCallIdx(), interp);\n    int nref;\n    if ((nref = --obj->refcnt) <= 0) {\n        obj->refcnt = -1;\n        Jsi_ObjFree(interp, obj);\n    }\n    return nref;\n}\n\n\nint Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    uint nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (len >= interp->maxArrayList || nsiz > interp->maxArrayList) {\n        Jsi_LogError(\"array size too big: %u >= %u\", len, interp->maxArrayList);\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}\n\nJsi_Obj *Jsi_ObjNewArray(Jsi_Interp *interp, Jsi_Value **items, int count, int copyflag)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (count>=0) {\n        int i;\n        if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {\n            Jsi_ObjFree(interp, obj);\n            return NULL;\n        }\n        for (i = 0; i < count; ++i) {\n            if (!items[i]) continue;\n            if (!copyflag) {\n                obj->arr[i] = items[i];\n                Jsi_IncrRefCount(interp, items[i]);\n            } else {\n                obj->arr[i] = Jsi_ValueNew1(interp);\n                Jsi_ValueCopy(interp, obj->arr[i], items[i]);\n            }\n        }\n    }\n    obj->arrCnt = count;\n    assert(obj->arrCnt<=obj->arrMaxSize);\n    return obj;\n}\n\n/****** END ARRAY ************/\n\nstatic Jsi_TreeEntry* ObjInsertFromValue(Jsi_Interp *interp, Jsi_Obj *obj, Jsi_Value *keyVal, Jsi_Value *nv)\n{\n    const char *key = NULL;\n    int flags = 0;\n    Jsi_DString dStr = {};\n    if (keyVal->vt == JSI_VT_STRING) {\n        flags = (keyVal->f.bits.isstrkey ? JSI_OM_ISSTRKEY : 0);\n        key = keyVal->d.s.str;\n    } else if (keyVal->vt == JSI_VT_OBJECT && keyVal->d.obj->ot == JSI_OT_STRING) {\n        Jsi_Obj *o = keyVal->d.obj;\n        flags = (o->isstrkey ? JSI_OM_ISSTRKEY : 0);\n        key = o->d.s.str;\n    }\n    if (key == NULL)\n        key = Jsi_ValueGetDString(interp, keyVal, &dStr, 0);\n    return Jsi_ObjInsert(interp, obj, key, nv, flags);\n}\n\nJsi_Obj *Jsi_ObjNewObj(Jsi_Interp *interp, Jsi_Value **items, int count)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    if (count%2) return obj;\n    int i;\n    for (i = 0; i < count; i += 2) {\n        if (!items[i] || !items[i+1]) continue;\n        Jsi_Value *v = Jsi_ValueDup(interp, items[i+1]);\n        ObjInsertFromValue(interp, obj, items[i], v);\n        Jsi_DecrRefCount(interp, v);\n    }\n    return obj;\n}\n\nvoid Jsi_ObjSetLength(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    if (obj->isarrlist) {\n        assert(len<=obj->arrMaxSize);\n        obj->arrCnt = len;\n        return;\n    }\n    Jsi_Value *r = Jsi_TreeObjGetValue(obj,\"length\", 0);\n    if (!r) {\n        Jsi_Value *n = Jsi_ValueMakeNumber(interp, NULL, len);\n        Jsi_ObjInsert(interp, obj, \"length\", n, JSI_OM_DONTDEL | JSI_OM_DONTENUM | JSI_OM_READONLY);\n    } else {\n        Jsi_ValueReset(interp, &r);\n        Jsi_ValueMakeNumber(interp, &r, len);\n    }\n}\n\nint Jsi_ObjGetLength(Jsi_Interp *interp, Jsi_Obj *obj)\n{\n    if (obj->tree && obj->tree->numEntries) {\n        Jsi_Value *r = Jsi_TreeObjGetValue(obj, \"length\", 0);\n        Jsi_Number nr;\n        if (r && Jsi_GetNumberFromValue(interp,r, &nr) == JSI_OK) {\n            if (Jsi_NumberIsInteger(nr))\n                return nr;\n        }\n    }\n    if (obj->arr)\n        return obj->arrCnt;\n\n    return 0;\n}\n\nJsi_Value *jsi_ObjValueNew(Jsi_Interp *interp)\n{\n    return Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNew(interp));\n}\n\n\n/* Set result string into obj. */\nvoid Jsi_ObjFromDS(Jsi_DString *dsPtr, Jsi_Obj *obj) {\n    int len = Jsi_DSLength(dsPtr);\n    if (obj->ot == JSI_OT_STRING && obj->d.s.str && !obj->isstrkey)\n        Jsi_Free(obj->d.s.str);\n    if (!(obj->d.s.str = (char*)dsPtr->strA)) {\n        obj->d.s.str = (char*)Jsi_Malloc(len+1);\n        memcpy(obj->d.s.str, dsPtr->Str, len+1);\n    }\n    obj->d.s.len = len;\n    obj->isBlob = 1;\n    dsPtr->strA = NULL;\n    dsPtr->Str[0] = 0;\n    dsPtr->len = 0;\n    dsPtr->spaceAvl = dsPtr->staticSize;\n}\n#endif\n", "#ifndef JSI_LITE_ONLY\n#ifndef JSI_AMALGAMATION\n#include \"jsiInt.h\"\n#endif\n\n#define bits_set(who, mask)     ((who) |= (mask))\n#define bits_unset(who, mask)   ((who) &= (~(mask)))\n#define bits_get(who, mask)     ((who) & (mask))\n\n#if  JSI__MEMDEBUG\nvoid jsi_VALCHK(Jsi_Value *val) {\n    SIGASSERTV(val,VALUE);\n    assert(val->vt <= JSI_VT__MAX);\n    if (val->vt == JSI_VT_OBJECT)\n        OBJCHK(val->d.obj);\n}\n\nvoid jsi_OBJCHK(Jsi_Obj *obj) {\n    SIGASSERTV(obj,OBJ);\n    assert(obj->ot <= JSI_OT__MAX);\n}\n#endif\n\n/*********************************************/\n\nbool Jsi_IsShared(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    return (v->refCnt > 1);\n}\n\nint Jsi_IncrRefCount(Jsi_Interp* interp, Jsi_Value *v)\n{\n    SIGASSERT(v,VALUE);\n    assert(v->refCnt>=0);\n    jsi_DebugValue(v,\"Incr\", jsi_DebugValueCallIdx(), interp);\n    return ++(v->refCnt);\n}\n\nint Jsi_DecrRefCount(Jsi_Interp* interp, Jsi_Value *v) {\n    SIGASSERT(v,VALUE);\n    if (v->refCnt<=0) {\n#ifdef JSI_MEM_DEBUG\n        fprintf(stderr, \"Value decr with ref %d: VD.Idx=%d\\n\", v->refCnt, v->VD.Idx);\n#endif\n        return -2;\n    }\n    int ref;\n    jsi_DebugValue(v,\"Decr\", jsi_DebugValueCallIdx(), interp);\n    if ((ref = --(v->refCnt)) <= 0) {\n        v->refCnt = -1;\n        Jsi_ValueFree(interp, v);\n    }\n    return ref;\n}\n\nstatic Jsi_Value *ValueNew(Jsi_Interp *interp)\n{\n    interp->dbPtr->valueCnt++;\n    interp->dbPtr->valueAllocCnt++;\n    Jsi_Value *v = (Jsi_Value *)Jsi_Calloc(1,sizeof(*v));\n    SIGINIT(v,VALUE)\n    v->vt = JSI_VT_UNDEF;\n    jsi_DebugValue(v,\"New\", jsi_DebugValueCallIdx(), interp);\n    return v;\n}\n\nstatic Jsi_Value *ValueNew1(Jsi_Interp *interp)\n{\n    Jsi_Value *v = ValueNew(interp);\n    Jsi_IncrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *ValueDup(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Value *r = ValueNew1(interp);\n    Jsi_ValueCopy(interp,r, v);\n#ifdef JSI_MEM_DEBUG\n    r->VD.label2 = \"ValueDup\";\n#endif\n    return r;\n}\n#ifndef JSI_MEM_DEBUG\nJsi_Value* Jsi_ValueNew(Jsi_Interp *interp) {\n    return ValueNew(interp);\n}\nJsi_Value* Jsi_ValueNew1(Jsi_Interp *interp) {\n    return ValueNew1(interp);\n}\nJsi_Value *Jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *v) {\n    return ValueDup(interp, v);\n}\n#else\nstatic uint jsi_memDebugBreakIdx = 0;  // Debug memory by setting this, and adding BP on following func.\nvoid jsi_memDebugBreak() {\n}\n\n// Debugging functions: set breakpoint with \"cond B v == 0xNNN\"\nvoid jsi_DebugValue(Jsi_Value* v, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == v->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\nvoid jsi_DebugObj(Jsi_Obj* o, const char *reason, uint cidx, Jsi_Interp *interp)\n{\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == o->VD.Idx)\n        jsi_memDebugBreak();\n    return;\n}\n\n\nvoid jsi_ValueDebugUpdate_(Jsi_Interp *interp, jsi_ValueDebug *vd, void *v, Jsi_Hash* tbl, const char *fname, int line, const char *func)\n{\n    vd->fname = fname;\n    vd->line = line;\n    vd->func = func;\n    if (!vd->Idx)\n        vd->Idx = interp->dbPtr->memDebugCallIdx;\n    vd->hPtr = Jsi_HashSet(tbl, v, 0);\n    vd->ip = interp->curIp;\n    if (vd->ip) {\n        vd->ipLine = vd->ip->Line;\n        vd->ipOp = vd->ip->op;\n        vd->ipFname = vd->ip->fname;\n    }\n    vd->interp = interp;\n    if (jsi_memDebugBreakIdx && jsi_memDebugBreakIdx == vd->Idx)\n        jsi_memDebugBreak();\n}\n\nvoid jsi_ValueDebugLabel_(jsi_ValueDebug *vd, const char *l1, const char *l2)\n{\n    if (l1)\n        vd->label = l1;\n    if (l2)\n        vd->label2 = l2;\n}\n\n\nJsi_Value * jsi_ValueNew(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\nJsi_Value * jsi_ValueNew1(Jsi_Interp *interp, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueNew1(interp);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\nJsi_Value * jsi_ValueDup(Jsi_Interp *interp, Jsi_Value *ov, const char *fname, int line, const char *func) {\n    Jsi_Value *v = ValueDup(interp, ov);\n    jsi_ValueDebugUpdate(interp, v, valueDebugTbl, fname, line, func);\n    return v;\n}\n\n#ifndef JSI_OMIT_STUBS\n#undef Jsi_ValueNew\n#undef Jsi_ValueNew1\nJsi_Value *Jsi_ValueNew(Jsi_Interp *interp) { return ValueNew(interp); }\nJsi_Value *Jsi_ValueNew1(Jsi_Interp *interp) { return ValueNew1(interp); }\n#define Jsi_ValueNew(interp) jsi_ValueNew(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#define Jsi_ValueNew1(interp) jsi_ValueNew1(interp, __FILE__, __LINE__,__PRETTY_FUNCTION__)\n#endif\n\n#endif\n\nJsi_Hash *strDebug = NULL;\n\nstatic void ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    SIGASSERTV(v,VALUE);\n    //printf(\"FREE: %d\\n\", interp->valueCnt);\n    switch (v->vt) {\n        case JSI_VT_OBJECT:\n            Jsi_ObjDecrRefCount(interp, v->d.obj);\n            break;\n        case JSI_VT_VARIABLE:\n            assert(v->d.lval != v);\n            Jsi_DecrRefCount(interp, v->d.lval);\n            break;\n        case JSI_VT_STRING:\n            if (v->d.s.str && !v->f.bits.isstrkey) {\n                Jsi_Free(v->d.s.str);\n                /*Jsi_HashEntry *hPtr;\n                if ((hPtr = Jsi_HashEntryFind(strDebug, v->d.s.str)))\n                    Jsi_HashEntryDelete(hPtr);*/\n            }\n            break;\n        default:\n            break;\n    }\n    v->vt = JSI_VT_UNDEF;\n}\n\nvoid Jsi_ValueFree(Jsi_Interp *interp, Jsi_Value* v)\n{\n    interp->dbPtr->valueCnt--;\n    jsi_DebugValue(v, \"Free\", jsi_DebugValueCallIdx(), interp);\n    ValueFree(interp, v);\n#ifdef JSI_MEM_DEBUG\n    //if (v->VD.interp != interp)  //TODO: InterpAliasCmd leaking Values.\n     //   fprintf(stderr, \"cross interp delete: %p\\n\", v);\n    if (v->VD.hPtr && !interp->cleanup) {\n        if (!Jsi_HashEntryDelete(v->VD.hPtr))\n            fprintf(stderr, \"Value not in hash\\n\");\n    }\n    memset(v, 0, (sizeof(*v)-sizeof(v->VD)));\n#endif\n    Jsi_Free(v);\n}\n\n/* Reset a value back to undefined, releasing string/obj if necessary. */\nvoid Jsi_ValueReset(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = *vPtr;\n    SIGASSERTV(v,VALUE);\n    Assert(v->vt <= JSI_VT__MAX);\n    jsi_DebugValue(v, \"Reset\", jsi_DebugValueCallIdx(), interp);\n    Assert(v->refCnt>=0);\n    v->f.bits.lookupfailed = 0; // TODO: rework lookup-fail mechanism.\n    if (v->vt == JSI_VT_UNDEF)\n        return;\n    ValueFree(interp, v);\n    v->f.flag = 0;\n}\n\n// Assign value ptrs (to=from). Decr old to, and Incr from ref count.\nvoid Jsi_ValueReplace(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )  {\n    VALCHK(from);\n    if( *to == from) return;\n    if (*to)\n        Jsi_DecrRefCount(interp, *to);\n    *to = from;\n    if (from)\n        Jsi_IncrRefCount(interp, from);\n}\n\n\nstatic void jsi_ValueCopyMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from, int isCopy )  {\n    if (!from) {\n        Jsi_ValueMakeUndef(interp, &to);\n        return;\n    }\n    VALCHK(from);\n    if( to == from) return;\n    int ocnt = to->refCnt;\n    Jsi_Value *ovt = NULL;\n    assert(ocnt>0);\n    int toVt = to->vt;\n    if (toVt == JSI_VT_VARIABLE) {\n        ovt = to->d.lval;\n        Jsi_IncrRefCount(interp, ovt);\n    }\n    Jsi_ValueMakeUndef(interp, &to);\n#ifdef JSI_MEM_DEBUG\n    memcpy(to, from, sizeof(*to)-sizeof(to->VD));\n    to->VD.label3 = from->VD.func;\n#else\n    *to = *from;\n#endif\n    if (isCopy) {\n        if (to->refCnt) {\n            switch (to->vt) {\n                case JSI_VT_STRING:\n                    if (!to->f.bits.isstrkey) {\n                        to->d.s.str = Jsi_StrdupLen(to->d.s.str, to->d.s.len);\n                    }\n                    break;\n                case JSI_VT_OBJECT:\n                    Jsi_ObjIncrRefCount(interp,to->d.obj);\n                    break;\n                case JSI_VT_VARIABLE:\n                    Jsi_IncrRefCount(interp,to->d.lval);\n                    break;\n                default:\n                    break;\n            }\n        }\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n    } else {\n        to->refCnt = ocnt;\n        if (ovt)\n            Jsi_DecrRefCount(interp, ovt);\n        ocnt = from->refCnt;\n#ifdef JSI_MEM_DEBUG\n        memset(from, 0, sizeof(*to)-sizeof(to->VD));\n#else\n        memset(from, 0, sizeof(*to));\n#endif\n        SIGINIT(from, VALUE);\n        from->refCnt = ocnt;\n    }\n}\n\nvoid Jsi_ValueMove(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from )  {\n    return jsi_ValueCopyMove(interp, to, from, 0);\n}\n\nvoid Jsi_ValueCopy(Jsi_Interp *interp, Jsi_Value *to, Jsi_Value *from ) {\n    return jsi_ValueCopyMove(interp, to, from, 1);\n}\n\nvoid Jsi_ValueDup2(Jsi_Interp *interp, Jsi_Value **to, Jsi_Value *from )\n{\n    if (!*to)\n        *to = Jsi_ValueNew1(interp);\n#ifdef JSI_MEM_DEBUG\n    (*to)->VD.label3 = \"ValueDup2\";\n#endif\n    Jsi_ValueCopy(interp, *to, from);\n    (*to)->f.bits.readonly = 0;\n}\n\nJsi_Value *Jsi_ValueDupJSON(Jsi_Interp *interp, Jsi_Value *val)\n{\n    Jsi_DString pStr;\n    Jsi_DSInit(&pStr);\n    Jsi_ValueGetDString(interp, val, &pStr, JSI_OUTPUT_JSON);\n    Jsi_Value *valPtr = NULL;\n    if (Jsi_JSONParse(interp, Jsi_DSValue(&pStr), &valPtr, 0) != JSI_OK)\n        Jsi_LogBug(\"bad json parse\");\n    Jsi_DSFree(&pStr);\n    return valPtr;\n}\n\n#if 0\nvoid jsi_AllValueOp(Jsi_Interp *interp, Jsi_Value* val, int op) {\n    if (op==1) {\n        //printf(\"ADD: %p : %p : %d\\n\", interp, val, val->VD.Idx);\n        assert(interp->allValues!=val);\n        val->next = interp->allValues;\n        if (interp->allValues)\n            interp->allValues->prev = val;\n        interp->allValues = val;\n        return;\n    }\n    if (op==0) {\n        //printf(\"DEL: %p : %p\\n\", interp, val);\n        if (!val || !interp->allValues) return;\n        if (val == interp->allValues)\n            interp->allValues = val->next;\n        if (val->next)\n            val->next->prev = val->prev;\n        if (val->prev)  \n            val->prev->next = val->next; \n        return;\n    }\n    if (op == -1) {\n        while (interp->allValues) {\n            printf(\"NEED CLEANUP: %p\\n\", interp->allValues);\n            Jsi_ValueFree(interp, interp->allValues);\n        }\n        return;\n    }\n#if JSI__MEMDEBUG\n    assert(0);\n    abort();\n#endif\n}\n#endif\n\nJsi_Value *Jsi_ValueObjLookup(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    Jsi_Obj *obj;\n    Jsi_Value *v = NULL;\n    if (interp->subOpts.noproto && key) {\n        if (key[0] == 'p' && Jsi_Strcmp(key, \"prototype\")==0) {\n            Jsi_LogError(\"inheritance is disabled in interp\");\n            return NULL;\n        }\n    }\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return NULL;\n    }\n    obj = target->d.obj;\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (*key == '_' && Jsi_Strcmp(key, \"__proto__\")==0 && interp->noproto==0)\n        return obj->__proto__;\n#endif\n\n    if (*key == 't' && Jsi_Strcmp(key, \"this\")==0)\n        return interp->framePtr->inthis;\n    if (obj->arr)\n        v = jsi_ObjArrayLookup(interp, obj, key);\n    if (!v)\n        v= Jsi_TreeObjGetValue(obj, key, isstrkey);\n    return v;  /* TODO: redo with copy */\n}\n\nJsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}\n\n/**************************************************/\n\nJsi_RC Jsi_ValueGetBoolean(Jsi_Interp *interp, Jsi_Value *pv, bool *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_BOOL)\n        *val = pv->d.val;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL)\n        *val = pv->d.obj->d.val;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\n\nbool Jsi_ValueIsArray(Jsi_Interp *interp, Jsi_Value *v)  {\n    return (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_OBJECT && v->d.obj->isarrlist);\n}\n\nbool Jsi_ValueIsBoolean(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_BOOL || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_BOOL));\n}\n\nbool Jsi_ValueIsNull(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NULL);\n}\n\nbool Jsi_ValueIsUndef(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_UNDEF);\n}\n\nJsi_RC Jsi_ValueGetNumber(Jsi_Interp *interp, Jsi_Value *pv, Jsi_Number *val)\n{\n    if (!pv) return JSI_ERROR;\n    if (pv->vt == JSI_VT_NUMBER)\n        *val = pv->d.num;\n    else if (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER)\n        *val = pv->d.obj->d.num;\n    else \n        return JSI_ERROR;\n    return JSI_OK;\n}\nbool Jsi_ValueIsNumber(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_NUMBER || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_NUMBER));\n}\n\nbool Jsi_ValueIsStringKey(Jsi_Interp* interp, Jsi_Value *key)\n{\n    if (key->vt == JSI_VT_STRING && key->f.bits.isstrkey)\n        return 1;\n    if (key->vt == JSI_VT_OBJECT && key->d.obj->ot == JSI_OT_STRING && key->d.obj->isstrkey)\n        return 1;\n    return 0;\n}\n\nbool Jsi_ValueIsString(Jsi_Interp *interp, Jsi_Value *pv)\n{\n    return (pv->vt == JSI_VT_STRING || (pv->vt == JSI_VT_OBJECT && pv->d.obj->ot == JSI_OT_STRING));\n}\n\nbool Jsi_ValueIsFunction(Jsi_Interp *interp, Jsi_Value *v)\n{\n    int rc = (v!=NULL && v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION);\n    if (!rc) return rc;\n    if (interp == v->d.obj->d.fobj->interp)\n        return 1;\n    fprintf(stderr, \"OOPS: function in wrong interp %s: %s\\n\", \n        interp->parent?\"(string came in from parent interp?)\":\"\",\n        v->d.obj->d.fobj->func->name);\n    return 0;\n}\n\nbool Jsi_ValueIsType(Jsi_Interp *interp, Jsi_Value *pv, Jsi_vtype vtype) {\n    if (!pv) return 0;\n    return pv->vt == vtype;\n}\n\nJsi_vtype Jsi_ValueTypeGet(Jsi_Value *pv) { return pv->vt; }\n\n\nbool Jsi_ValueIsObjType(Jsi_Interp *interp, Jsi_Value *v, Jsi_otype otype)\n{\n    if (v == NULL || v->vt != JSI_VT_OBJECT)\n        return 0;\n    if (otype != JSI_OT_ARRAY)\n        return (v->d.obj->ot == otype);\n    if (v->d.obj->ot != JSI_OT_OBJECT || !v->d.obj->isarrlist)\n        return 0;\n    return 1;\n}\n\nchar* Jsi_NumberToString(Jsi_Interp *interp, Jsi_Number d, char *buf, int bsiz)\n{\n     if (Jsi_NumberIsInteger(d)) {\n        Jsi_NumberItoA10((Jsi_Wide)d, buf, bsiz);\n    } else if (Jsi_NumberIsNormal(d)) {\n        Jsi_NumberDtoA(interp, d, buf, bsiz, 0);\n    } else if (Jsi_NumberIsNaN(d)) {\n        Jsi_Strcpy(buf, \"NaN\");\n    } else {\n        int s = Jsi_NumberIsInfinity(d);\n        if (s > 0) Jsi_Strcpy(buf,  \"Infinity\");\n        else if (s < 0) Jsi_Strcpy(buf, \"-Infinity\");\n        else {\n            buf[0] = 0;\n        }\n    }\n    return buf;\n}\n\n/* Return the string value.  Coerce value to a string type. */\nconst char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[JSI_MAX_NUMBER_STRING*2];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:\n            ntxt = \"null\";\n            break;\n        case JSI_VT_NUMBER: {\n            d = v->d.num;\nfmtnum:\n            if (Jsi_NumberIsInteger(d)) {\n                Jsi_NumberItoA10((Jsi_Wide)d, unibuf, sizeof(unibuf));\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNormal(d)) {\n                Jsi_NumberDtoA(interp, d, unibuf, sizeof(unibuf), 0);\n                kflag = 0;\n                ntxt = unibuf;\n            } else if (Jsi_NumberIsNaN(v->d.num)) {\n                ntxt = \"NaN\";\n            } else {\n                int s = Jsi_NumberIsInfinity(d);\n                if (s > 0) ntxt = \"Infinity\";\n                else if (s < 0) ntxt = \"-Infinity\";\n                else Jsi_LogBug(\"Ieee function got problem\");\n            }\n            break;\n        }\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_STRING:\n                    ntxt = obj->d.s.str;\n                    goto done;\n                case JSI_OT_BOOL:\n                    ntxt = obj->d.val ? \"true\":\"false\";\n                    break;\n                case JSI_OT_NUMBER:\n                    d = obj->d.num;\n                    goto fmtnum;\n                    break;\n                default:\n                    ntxt = \"[object Object]\";\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to string\", v->vt);\n            break;\n    }\n    Jsi_ValueReset(interp, &v);\n    if (!kflag) {\n        Jsi_ValueMakeStringDup(interp, &v, ntxt);\n        return Jsi_ValueString(interp, v, lenPtr);\n    }\n    \n    key = jsi_KeyFind(interp, ntxt, 0, &isKey);\n    if (key)\n        Jsi_ValueMakeStringKey(interp, &v, key);\n    else\n        Jsi_ValueMakeString(interp, &v, ntxt);\n    ntxt = v->d.s.str;\n    \ndone:\n    if (lenPtr) *lenPtr = Jsi_Strlen(ntxt);\n    return ntxt;\n}\n\nJsi_Number Jsi_ValueToNumberInt(Jsi_Interp *interp, Jsi_Value *v, int isInt)\n{\n    char *endPtr = NULL, *sptr;\n    Jsi_Number a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = (Jsi_Number)(v->d.val ? 1.0: 0);\n            break;\n        case JSI_VT_NULL:\n            a = 0;\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (Jsi_Number)(obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    break;\n                case JSI_OT_STRING:\n                    sptr = obj->d.s.str;\n                    goto donum;\n                    break;\n                default:\n                    a = 0;\n                break;\n            }\n            break;\n        }\n        case JSI_VT_UNDEF:\n            a = Jsi_NumberNaN();\n            break;\n        case JSI_VT_NUMBER:\n            a = v->d.num;\n            break;\n        case JSI_VT_STRING:\n            sptr = v->d.s.str;\ndonum:\n            if (!isInt) {\n                a = strtod(sptr, &endPtr);\n                if (endPtr && *endPtr) {\n                    a = interp->NaNValue->d.num;\n                }\n            } else {\n                a = (Jsi_Number)strtol(sptr, &endPtr, 0);\n                if (!isdigit(*sptr))\n                    a = interp->NaNValue->d.num;\n            }\n            break;\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            break;\n    }\n    if (isInt && Jsi_NumberIsNormal(a))\n        a = (Jsi_Number)((int64_t)(a));\n    return a;\n}\n\nJsi_RC Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_NUMBER) return JSI_OK;\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0);\n    Jsi_ValueReset(interp, &v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return JSI_OK;\n}\n\nJsi_RC Jsi_ValueToBool(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    bool a = 0;\n    switch(v->vt) {\n        case JSI_VT_BOOL:\n            a = v->d.val;\n            break;\n        case JSI_VT_NULL:\n            break;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_NUMBER:\n            a = (v->d.num ? 1: 0);\n            break;\n        case JSI_VT_STRING:     /* TODO: NaN, and accept true/false string? */\n            a = atoi(v->d.s.str);\n            a = (a ? 1 : 0);\n            break;\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *obj = v->d.obj;\n            switch(obj->ot) {\n                case JSI_OT_BOOL:\n                    a = (obj->d.val ? 1.0: 0);\n                    break;\n                case JSI_OT_NUMBER:\n                    a = obj->d.num;\n                    a = (a ? 1 : 0);\n                    break;\n                case JSI_OT_STRING:\n                    a = atoi(obj->d.s.str);\n                    a = (a ? 1 : 0);\n                    break;\n                default:\n                    break;\n            }\n            break;\n        }\n        default:\n            Jsi_LogBug(\"Convert a unknown type: 0x%x to number\", v->vt);\n            return JSI_ERROR;\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeBool(interp, &v, a);\n    return rc;\n}\n\nint jsi_ValueToOInt32(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 1);\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeNumber(interp, &v, a);\n    return (int)a;\n}\n\nJsi_RC Jsi_ValueToObject(Jsi_Interp *interp, Jsi_Value *v)\n{\n    Jsi_RC rc = JSI_OK;\n    if (v->vt == JSI_VT_OBJECT) return rc;\n    Jsi_Obj *o = Jsi_ObjNew(interp);\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:\n            if (interp->strict) {\n                Jsi_LogError(\"converting a undefined/null value to object\");\n                rc = JSI_ERROR;\n            }\n            o->d.num = 0;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        case JSI_VT_BOOL: {\n            o->d.val = v->d.val;\n            o->ot = JSI_OT_BOOL;\n            o->__proto__ = interp->Boolean_prototype;\n            break;\n        }\n        case JSI_VT_NUMBER: {\n            o->d.num = v->d.num;\n            o->ot = JSI_OT_NUMBER;\n            o->__proto__ = interp->Number_prototype;\n            break;\n        }\n        case JSI_VT_STRING: {\n            o->d.s = v->d.s;\n            if (!v->f.bits.isstrkey)\n                o->d.s.str = (char*)Jsi_KeyAdd(interp, v->d.s.str);\n            o->isstrkey = 1;\n            o->ot = JSI_OT_STRING;\n            o->__proto__ = interp->String_prototype;\n            break;\n        }\n        default:\n            Jsi_LogBug(\"toobject, not suppose to reach here\");\n    }\n    Jsi_ValueReset(interp,&v);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return rc;\n}\n\n/* also toBoolean here, in ecma */\nbool Jsi_ValueIsTrue(Jsi_Interp *interp, Jsi_Value *v)\n{\n    switch(v->vt) {\n        case JSI_VT_UNDEF:\n        case JSI_VT_NULL:   return 0;\n        case JSI_VT_BOOL:   return v->d.val ? 1:0;\n        case JSI_VT_NUMBER: \n            if (v->d.num == 0.0 || Jsi_NumberIsNaN(v->d.num)) return 0;\n            return 1;\n        case JSI_VT_STRING: return (Jsi_ValueStrlen(v)!=0);\n        case JSI_VT_OBJECT: {\n            Jsi_Obj *o = v->d.obj;\n            if (o->ot == JSI_OT_STRING)\n                return (Jsi_ValueStrlen(v)!=0);\n            if (o->ot == JSI_OT_NUMBER)\n                return (o->d.num != 0);\n            if (o->ot == JSI_OT_BOOL)\n                return (o->d.val != 0);\n            if (o->ot == JSI_OT_USEROBJ && o->d.uobj->interp == interp) {\n                return jsi_UserObjIsTrue(interp, o->d.uobj);\n            }\n            return 1;\n        }\n        default: Jsi_LogBug(\"TOP is type incorrect: %d\", v->vt);\n    }\n    return 0;\n}\n\nbool Jsi_ValueIsFalse(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt == JSI_VT_BOOL)  return v->d.val ? 0:1;\n    return 0;\n}\n\nbool Jsi_ValueIsEqual(Jsi_Interp* interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    int eq = 0;\n    if (v1->vt == JSI_VT_OBJECT && v2->vt == JSI_VT_OBJECT && v1->d.obj == v2->d.obj)\n        eq = 1;\n    else if (Jsi_ValueIsNull(interp, v1) && Jsi_ValueIsNull(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsUndef(interp, v1) && Jsi_ValueIsUndef(interp, v2))\n        eq = 1;\n    else if (Jsi_ValueIsBoolean(interp, v1) && Jsi_ValueIsBoolean(interp, v2)) {\n        bool b1, b2;\n        eq = (Jsi_GetBoolFromValue(interp, v1, &b1) == JSI_OK\n            && Jsi_GetBoolFromValue(interp, v2, &b2) == JSI_OK\n            && b1 == b2);\n    } else if (Jsi_ValueIsNumber(interp, v1) && Jsi_ValueIsNumber(interp, v2)) {\n        Jsi_Number n1, n2;\n        eq = (Jsi_GetNumberFromValue(interp, v1, &n1) == JSI_OK\n            && Jsi_GetNumberFromValue(interp, v2, &n2) == JSI_OK\n            && n1 == n2);\n    } else if (Jsi_ValueIsString(interp, v1) && Jsi_ValueIsString(interp, v2)) {\n        const char *s1, *s2;\n        int l1, l2;\n        eq = (((s1=Jsi_ValueString(interp, v1, &l1)) && ((s2=Jsi_ValueString(interp, v2, &l2)))\n            && l1 == l2 && Jsi_Strcmp(s1, s2)==0));\n    }\n    return eq;\n}\n\nvoid jsi_ValueToPrimitive(Jsi_Interp *interp, Jsi_Value **vPtr)\n{\n    Jsi_Value *v = *vPtr;\n    if (v->vt != JSI_VT_OBJECT)\n        return;\n    DECL_VALINIT(res);\n    Jsi_Value *rPtr = &res;\n    Jsi_Obj *obj = v->d.obj;\n    //rPtr = v;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp,&rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp,&rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            if (obj->isstrkey) {\n                res.d.s = obj->d.s;\n                res.f.bits.isstrkey = 1;\n                obj->d.s.str = NULL;\n            } else {\n                if (obj->refcnt==1) {\n                    Jsi_ValueMakeString(interp, &rPtr, obj->d.s.str);\n                    res.d.s = obj->d.s;\n                    obj->d.s.str = NULL;\n                } else if (obj->d.s.len >= 0) \n                {\n                    Assert(obj->refcnt>=1);\n                    obj->refcnt--;\n                    int bytes = obj->d.s.len;\n                    jsi_ValueMakeBlobDup(interp, &rPtr, (uchar*)obj->d.s.str, bytes);\n                } else\n                    Jsi_ValueMakeStringDup(interp, &rPtr, obj->d.s.str);\n            }\n            break;\n        case JSI_OT_FUNCTION: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            Jsi_FuncObjToString(interp, obj->d.fobj->func, &dStr, 3);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        case JSI_OT_USEROBJ: {\n            Jsi_DString dStr;\n            Jsi_DSInit(&dStr);\n            jsi_UserObjToName(interp, obj->d.uobj, &dStr);\n            Jsi_ValueFromDS(interp, &dStr, &rPtr);\n            break;\n        }\n        default:\n            Jsi_ValueMakeStringKey(interp,&rPtr, \"[object Object]\");\n            break;\n    }\n    Jsi_ValueReset(interp, vPtr);\n    res.refCnt = v->refCnt;\n#ifdef JSI_MEM_DEBUG\n    memcpy(v, &res, sizeof(res)-sizeof(res.VD));\n#else\n    *v = res;\n#endif\n}\n\nstatic void jsi_ValueToPrimitiveRes(Jsi_Interp *interp, Jsi_Value *v, Jsi_Value *rPtr)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n#ifdef JSI_MEM_DEBUG\n    memcpy(rPtr, v, sizeof(*v)-sizeof(v->VD));\n#else\n    *rPtr = *v; //TODO: usde only by ValueCompare, so refCnt doesn't matter?\n#endif\n        return;\n    }\n    Jsi_Obj *obj = v->d.obj;\n    switch(obj->ot) {\n        case JSI_OT_BOOL:\n            Jsi_ValueMakeBool(interp, &rPtr, obj->d.val);\n            break;\n        case JSI_OT_NUMBER:\n            Jsi_ValueMakeNumber(interp, &rPtr, obj->d.num);\n            break;\n        case JSI_OT_STRING:\n            rPtr->vt = JSI_VT_STRING;\n            rPtr->d.s = obj->d.s;\n            rPtr->f.bits.isstrkey = 1;\n            break;\n        default:\n            break;\n    }\n}\n\nint Jsi_ValueCmp(Jsi_Interp *interp, Jsi_Value *v1, Jsi_Value* v2, int flags)\n{\n    DECL_VALINIT(res1);\n    DECL_VALINIT(res2);\n    int r = 1;\n    int nocase = (flags&JSI_SORT_NOCASE), dict = ((flags & JSI_SORT_DICT));\n    if (v1 == v2)\n        return 1;\n    if (v1->vt != v2->vt) {\n        jsi_ValueToPrimitiveRes(interp, v1, &res1);\n        jsi_ValueToPrimitiveRes(interp, v2, &res2);\n        v1 = &res1;\n        v2 = &res2;\n    }\n    if (v1->vt != v2->vt) {\n        if ((flags&JSI_CMP_EXACT))\n            return 1;\n        if ((v1->vt == JSI_VT_UNDEF || v1->vt == JSI_VT_NULL) && \n            (v2->vt == JSI_VT_UNDEF || v2->vt == JSI_VT_NULL)) {\n            r = 0;\n        } else {\n            Jsi_Number n1, n2;\n            n1 = Jsi_ValueToNumberInt(interp, v1, 0);\n            n2 = Jsi_ValueToNumberInt(interp, v2, 0);\n            r = (n2 - n1);\n        }\n    } else {\n        switch (v1->vt) {\n            case JSI_VT_NUMBER:\n                if (v2->d.num == v1->d.num) return 0;\n                r = (v2->d.num < v1->d.num ? -1 : 1);\n                break;\n            case JSI_VT_BOOL:\n                r = (v2->d.val - v1->d.val);\n                break;\n            case JSI_VT_STRING:\n                r = (Jsi_StrcmpDict(v2->d.s.str, v1->d.s.str, nocase, dict));\n                break;\n            case JSI_VT_OBJECT:\n                /* TODO: refer to objects joined to each other */\n                if (v2->vt != JSI_VT_OBJECT)\n                    r = 1;\n                else if (v1->d.obj->ot == JSI_OT_STRING && v2->d.obj->ot == JSI_OT_STRING)\n                    r = (Jsi_StrcmpDict(v2->d.obj->d.s.str, v1->d.obj->d.s.str, nocase, dict));\n                else\n                    r = (v2->d.obj - v1->d.obj);\n                break;\n            case JSI_VT_UNDEF:\n            case JSI_VT_NULL:\n                r = 0;\n                break;\n            default:\n                Jsi_LogBug(\"Unexpected value type\");\n        }\n    }\n    return r;\n}\n\n/**\n * @brief Split a string.\n * @param interp \n * @param str - input string to split\n * @param split - to split on\n * @returns an array of string values\n * \n * \n */\nJsi_Value *Jsi_StringSplit(Jsi_Interp *interp, const char *str, const char *spliton)\n{\n    char **argv; int argc;\n    Jsi_DString dStr;\n    Jsi_DSInit(&dStr);\n    Jsi_SplitStr(str, &argc, &argv, spliton, &dStr);\n    Jsi_Value *nret = Jsi_ValueNewArray(interp, NULL, 0);\n    Jsi_Obj *obj = nret->d.obj;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_ObjArraySet(interp, obj, Jsi_ValueNewStringDup(interp, argv[i]), i);\n    }\n    Jsi_ObjSetLength(interp, obj, argc);\n    Jsi_ValueMakeArrayObject(interp, &nret, obj);\n    Jsi_DSFree(&dStr);\n    return nret;\n}\n\nvoid jsi_ValueObjSet(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *value, int flags, int isstrkey)\n{\n    Jsi_TreeEntry *hPtr;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object: %d\", target->vt);\n        return;\n    }\n    hPtr = Jsi_ObjInsert(interp, target->d.obj, key, value, (isstrkey?JSI_OM_ISSTRKEY:0));\n    if (!hPtr)\n        return;\n    hPtr->f.flags |= (flags&JSI_TREE_USERFLAG_MASK);\n}\n\nJsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    /* TODO: array[\"1\"] also extern the length of array */\n    \n    if (arrayindex >= 0 && (uint)arrayindex < interp->maxArrayList &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n    \n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        //obj->clearProto = 1;\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}\n\nstatic Jsi_Value *jsi_ValueLookupBase(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    if (!target)\n        return NULL;\n    if (target->vt != JSI_VT_OBJECT) {\n        Jsi_LogError(\"subscript operand is not object\");\n        return NULL;\n    }\n    const char *keyStr = Jsi_ValueToString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    bool isStrKey = (key->vt == JSI_VT_STRING && key->f.bits.isstrkey);\n    Jsi_Value *v = Jsi_ValueObjLookup(interp, target, (char*)keyStr, isStrKey);\n    if (v)\n        return v;\n    if (target->d.obj->__proto__)\n        return jsi_ValueLookupBase(interp, target->d.obj->__proto__, key, ret);\n    return NULL;\n}\n\n\nJsi_Value* jsi_ValueSubscript(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *key, Jsi_Value **ret)\n{\n    int len;\n    Jsi_ValueReset(interp, ret);\n    Jsi_Value *v = jsi_ValueLookupBase(interp, target, key, ret);\n    if (v)\n        return v;\n    const char *keyStr = Jsi_ValueString(interp, key, NULL);\n    if (!keyStr)\n        return NULL;\n    // Special cases such as \"length\", \"constructor\", etc...\n    if (Jsi_Strcmp(keyStr,\"length\")==0) {\n        if (Jsi_ValueIsString(interp, target)) {\n            len = Jsi_ValueStrlen(target);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->isarrlist) {\n            len = target->d.obj->arrCnt;\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n            Jsi_Func *fo = target->d.obj->d.fobj->func;\n            if (fo->type == FC_NORMAL)\n                len = fo->argnames->count;\n            else\n                len = fo->cmdSpec->maxArgs, len = (len>=0?len:fo->cmdSpec->minArgs);\n        } else if (target->vt == JSI_VT_OBJECT && target->d.obj->tree) {\n            len = target->d.obj->tree->numEntries;\n        } else {\n            return NULL;\n        }\n        (*ret)->vt = JSI_VT_NUMBER;\n        (*ret)->d.num = (Jsi_Number)len;\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && (interp->subOpts.noproto==0 && Jsi_Strcmp(keyStr,\"constructor\")==0)) {\n        const char *cp;\n        Jsi_Obj *o = target->d.obj->constructor;\n        if (o) {\n            if (o->ot == JSI_OT_FUNCTION) {\n                Jsi_Value *proto = Jsi_TreeObjGetValue(o, \"prototype\", 0);\n                if (proto && proto->vt == JSI_VT_OBJECT && proto->d.obj->constructor) {\n                    o = proto->d.obj->constructor;\n                }\n            }\n        } else {\n            switch(target->d.obj->ot) {\n                case JSI_OT_NUMBER:\n                    cp = \"Number\";\n                    break;\n                case JSI_OT_BOOL:\n                    cp = \"Boolean\";\n                    break;\n                case JSI_OT_STRING:\n                    cp = \"String\";\n                    break;\n                case JSI_OT_REGEXP:\n                    cp = \"RegExp\";\n                    break;\n                case JSI_OT_OBJECT:\n                    if (target->d.obj->isarrlist) {\n                        cp = \"Array\";\n                        break;\n                    }\n                    cp = \"Object\";\n                    break;\n                default:\n                    Jsi_ValueMakeUndef(interp, ret);\n                    return *ret;\n            }\n            v = Jsi_ValueObjLookup(interp, interp->csc, cp, 0);\n            if (v==NULL || v->vt != JSI_VT_OBJECT)\n                return NULL;\n            o = target->d.obj->constructor = v->d.obj;\n        }\n        Jsi_ValueMakeObject(interp, ret, o);\n        return *ret;\n    }\n\n    if (target->vt == JSI_VT_OBJECT && target->d.obj->ot == JSI_OT_FUNCTION) {\n        /* Looking up something like \"String.substr\" */\n        Jsi_Func* func = target->d.obj->d.fobj->func;\n        if (func->type == FC_BUILDIN) {\n            if (func->f.bits.iscons && func->name) {\n                Jsi_Value *v = Jsi_ValueObjLookup(interp, interp->csc, (char*)func->name, 0);\n                if (!v) {\n                } else {\n                    bool ooo = interp->subOpts.noproto;\n                    interp->subOpts.noproto = 0;\n                    v = Jsi_ValueObjLookup(interp, v, \"prototype\", 0);\n                    interp->subOpts.noproto = ooo;\n                    \n                    if (v && ((v = Jsi_ValueObjLookup(interp, v, (char*)keyStr, 0)))) {\n                        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_FUNCTION && Jsi_Strcmp(func->name,\"Interp\")) {\n                            Jsi_Func* sfunc = v->d.obj->d.fobj->func;\n                            /* Handle \"Math.pow(2,3)\", \"String.fromCharCode(0x21)\", ... */\n                            sfunc->callflags.bits.addargs = 1;\n                        }\n                        return v;\n                    }\n                }\n            }\n            if (Jsi_ValueIsString(interp, key)) {\n                char *kstr = Jsi_ValueString(interp, key, NULL);\n                if (!Jsi_Strcmp(kstr,\"call\") || !Jsi_Strcmp(kstr,\"apply\") || !Jsi_Strcmp(kstr,\"bind\")) {\n                    char fbuf[JSI_MAX_NUMBER_STRING];\n                    snprintf(fbuf, sizeof(fbuf), \"Function.%s\", kstr);\n                    Jsi_Value *vv = Jsi_NameLookup(interp, fbuf);\n                    if (vv)\n                        return vv;\n                }\n            }\n        }\n    }\n    return NULL;\n}\n\nbool Jsi_ValueKeyPresent(Jsi_Interp *interp, Jsi_Value *target, const char *key, int isstrkey)\n{\n    SIGASSERT(interp,INTERP);\n    //SIGASSERT(target,VALUE);\n    if (Jsi_TreeObjGetValue(target->d.obj, key, isstrkey))\n        return 1;\n    if (target->d.obj->__proto__ == NULL || target->d.obj->__proto__ == target)\n        return 0;\n    return Jsi_ValueKeyPresent(interp, target->d.obj->__proto__, key, isstrkey);\n}\n\nvoid jsi_ValueObjGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret, bool isof)\n{\n    Jsi_IterObj *io = Jsi_IterObjNew(interp, NULL);\n    Jsi_Obj *to = target->d.obj;\n    \n    if (target->vt != JSI_VT_UNDEF && target->vt != JSI_VT_NULL) {\n\n        if (target->vt == JSI_VT_OBJECT && to->arr) {\n            io->isArrayList = 1;\n            io->count = to->arrCnt;\n        } else {\n            if (isof &&interp->strict)\n                Jsi_LogWarn(\"non-array in 'for...of'\");\n            Jsi_IterGetKeys(interp, target, io, 0);\n        }\n    }\n    io->obj = to;\n    io->isof = isof;\n    Jsi_Obj *r = Jsi_ObjNew(interp);\n    r->ot = JSI_OT_ITER;\n    r->d.iobj = io;\n    Jsi_ValueMakeObject(interp, &ret, r);\n}\n\nJsi_RC Jsi_ValueGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *ret)\n{\n    uint i, n = 0;\n    Jsi_IterObj *io;\n    if (target->vt != JSI_VT_OBJECT)\n        return JSI_ERROR;\n    Jsi_Obj *to = target->d.obj;\n    Jsi_Obj *r = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    Jsi_ValueMakeArrayObject(interp, &ret, r);\n    if (to->arr) {\n        for (i=0; i<to->arrCnt; i++)\n            if (to->arr[i]) n++;\n        if (Jsi_ObjArraySizer(interp, r, n) <= 0) {\n            Jsi_LogError(\"too long\");\n            Jsi_ValueMakeUndef(interp, &ret);\n            return JSI_ERROR;\n        }\n        for (i=0, n=0; i<to->arrCnt; i++) {\n            if (to->arr[i]) {\n                r->arr[n] = Jsi_ValueNewNumber(interp, (Jsi_Number)i);\n                Jsi_IncrRefCount(interp, r->arr[n]);\n                n++;\n            }\n        }\n        r->arrCnt = n;\n        return JSI_OK;\n    }\n    io = Jsi_IterObjNew(interp, NULL);\n    Jsi_IterGetKeys(interp, target, io, 0);\n    if (Jsi_ObjArraySizer(interp, r, io->count) <= 0) {\n        Jsi_LogError(\"too long\");\n        Jsi_ValueMakeUndef(interp, &ret);\n        return JSI_ERROR;\n    }\n    for (i=0; i<io->count; i++) {\n        r->arr[i] = (io->keys[i] ? Jsi_ValueNewStringKey(interp, io->keys[i]) : NULL);\n        Jsi_IncrRefCount(interp, r->arr[i]);\n    }\n    io->count = 0;\n    r->arrCnt = i;\n    Jsi_IterObjFree(io);\n    return JSI_OK;\n}\n\njsi_ScopeChain *jsi_ScopeChainNew(Jsi_Interp *interp, int cnt)\n{\n    jsi_ScopeChain *r = (jsi_ScopeChain *)Jsi_Calloc(1, sizeof(*r));\n    r->interp = interp;\n    SIGINIT(r,SCOPE);\n    r->chains = (Jsi_Value **)Jsi_Calloc(cnt, sizeof(r->chains[0]));\n    r->chains_cnt = cnt;\n    return r;\n}\n\nJsi_Value *jsi_ScopeChainObjLookupUni(jsi_ScopeChain *sc, char *key)\n{\n    int i;\n    Jsi_Value *ret;\n    for (i = sc->chains_cnt - 1; i >= 0; --i) {\n        if ((ret = Jsi_ValueObjLookup(sc->interp, sc->chains[i], key, 0))) {\n            return ret;\n        }\n    }\n    return NULL;\n}\n\njsi_ScopeChain *jsi_ScopeChainDupNext(Jsi_Interp *interp, jsi_ScopeChain *sc, Jsi_Value *next)\n{\n    if (!sc) {\n        jsi_ScopeChain *nr = jsi_ScopeChainNew(interp, 1);\n        nr->chains[0] = next;\n        Jsi_IncrRefCount(interp, next);\n        nr->chains_cnt = 1;\n        return nr;\n    }\n    jsi_ScopeChain *r = jsi_ScopeChainNew(interp, sc->chains_cnt + 1);\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        r->chains[i] = sc->chains[i];\n        Jsi_IncrRefCount(interp, sc->chains[i]);\n    }\n    r->chains[i] =  next;\n    Jsi_IncrRefCount(interp, next);\n    r->chains_cnt = i + 1;\n    return r;\n}\n\nvoid jsi_ScopeChainFree(Jsi_Interp *interp, jsi_ScopeChain *sc)\n{\n    int i;\n    for (i = 0; i < sc->chains_cnt; ++i) {\n        Jsi_DecrRefCount(interp, sc->chains[i]);\n    }\n    Jsi_Free(sc->chains);\n    _JSI_MEMCLEAR(sc);\n    Jsi_Free(sc);\n}\n\nint Jsi_ValueGetLength(Jsi_Interp *interp, Jsi_Value *v) {\n    if (Jsi_ValueIsArray(interp, v))\n        return v->d.obj->arrCnt;\n    Jsi_LogWarn(\"expected array\");\n    return 0;\n}\n\nchar *Jsi_ValueArrayIndexToStr(Jsi_Interp *interp, Jsi_Value *args, int index, int *lenPtr)\n{\n    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, index);\n    if (!arg)\n        return NULL;\n    char *res = Jsi_ValueString(interp, arg, lenPtr);\n    if (res)\n        return res;\n    res = (char*)Jsi_ValueToString(interp, arg, NULL);\n    if (res && lenPtr)\n        *lenPtr = Jsi_Strlen(res);\n    return res;\n}\n\nJsi_RC Jsi_ValueInsert(Jsi_Interp *interp, Jsi_Value *target, const char *key, Jsi_Value *val, int flags)\n{\n    if (target == NULL)\n        target = interp->csc;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    target->f.flag |= flags;\n    if (Jsi_ObjInsert(interp, target->d.obj, key, val, flags))\n        return JSI_OK;\n    return JSI_ERROR;\n}\n\nJsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    \n    if (obj->isarrlist) {\n        if (key >= 0 && (uint)key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}\n\n/* OBJ INTERFACE TO BTREE */\n\nstatic void IterObjInsertKey(Jsi_IterObj *io, const char *key)\n{\n    assert(!io->isArrayList);\n    if (io->depth) {\n        uint i;\n        for (i=0; i<io->count; i++) {\n            if (!Jsi_Strcmp(key, io->keys[i]))\n                return;\n        }\n    }\n\n    if (io->count >= io->size) {\n        io->size += 10;\n        io->keys = (const char**)Jsi_Realloc(io->keys, io->size * sizeof(io->keys[0]));\n    }\n    io->keys[io->count] = key;\n    io->count++;\n}\nstatic void IterObjInsert(Jsi_IterObj *io, Jsi_TreeEntry *hPtr)\n{\n    IterObjInsertKey(io, (const char*)Jsi_TreeKeyGet(hPtr));\n}\n\nJsi_TreeEntry * Jsi_ObjInsert(Jsi_Interp *interp, Jsi_Obj *obj, const char *key, Jsi_Value *val, int flags)\n{\n    Jsi_TreeEntry *hPtr;\n    SIGASSERT(val, VALUE);\n    /*if (val)\n        Jsi_IncrRefCount(interp, val);*/\n    hPtr = Jsi_TreeObjSetValue(obj, key, val, (flags&JSI_OM_ISSTRKEY));\n    if ((flags&JSI_OM_DONTDEL))\n        val->f.bits.dontdel = hPtr->f.bits.dontdel = 1;\n    if ((flags&JSI_OM_READONLY))\n        val->f.bits.readonly =hPtr->f.bits.readonly = 1;\n    if ((flags&JSI_OM_DONTENUM))\n        val->f.bits.dontenum =hPtr->f.bits.dontenum = 1;\n    return hPtr;\n}\n\nstatic Jsi_RC IterGetKeysCallback(Jsi_Tree* tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_IterObj *io = (Jsi_IterObj *)data;\n    if (!hPtr->f.bits.dontenum) {\n        IterObjInsert(io, hPtr);\n    }\n    return JSI_OK;\n}\n\nvoid Jsi_IterGetKeys(Jsi_Interp *interp, Jsi_Value *target, Jsi_IterObj *iterobj, int depth)\n{\n    if (!target) return;\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"operand is not a object\");\n        return;\n    }\n    Jsi_Obj *to = target->d.obj;\n    Jsi_CmdSpec *cs = NULL;\n    if (to->ot == JSI_OT_USEROBJ) {\n        Jsi_UserObj *uobj = to->d.uobj;\n        cs = uobj->reg->spec;\n    } else if (to->ot == JSI_OT_FUNCTION) {\n        Jsi_FuncObj *fobj = to->d.fobj;\n        if (fobj->func->type == FC_BUILDIN)\n            cs = fobj->func->cmdSpec;\n    }\n    if (cs) {\n        while (cs->name) {\n            IterObjInsertKey(iterobj, cs->name);\n            cs++;\n        }\n        return;\n    }\n    iterobj->depth = depth;\n    Jsi_TreeWalk(target->d.obj->tree, IterGetKeysCallback, iterobj, 0);\n    if (target->d.obj->__proto__ && target != target->d.obj->__proto__)\n        Jsi_IterGetKeys(interp, target->d.obj->__proto__, iterobj, depth+1);\n    iterobj->depth = depth;\n}\n\nJsi_Value* Jsi_ValueMakeDStringObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_DString *dsPtr)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    Jsi_Obj *obj;\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        assert(v->vt <= JSI_VT__MAX);\n        if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING\n            && v->d.obj->refcnt == 1\n        ) {\n            Jsi_ObjFromDS(dsPtr, v->d.obj);\n            return v;\n        }\n        Jsi_ValueReset(interp, &v);\n    }\n    obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ObjFromDS(dsPtr, obj);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (v && v->vt == JSI_VT_OBJECT && o == v->d.obj)\n        return v;\n    if (v)\n        Jsi_ValueReset(interp, vPtr);\n    else\n        v = Jsi_ValueNew(interp);\n    //Jsi_IncrRefCount(interp, v);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_OBJECT);\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeArrayObject(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Obj *o)  {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!o)\n        o = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n       if (v->vt == JSI_VT_OBJECT && o == v->d.obj) {\n            if (!o->isarrlist) {\n                if (o->tree)\n                    Jsi_TreeDelete( o->tree);\n                o->tree = NULL;\n                o->__proto__ = interp->Array_prototype;\n                o->isarrlist = 1;\n            }\n            return v;\n        }\n        Jsi_ValueReset(interp, vPtr);\n    }\n    v->vt = JSI_VT_OBJECT;\n    v->d.obj = o;\n    o->ot = JSI_OT_OBJECT;\n    o->__proto__ = interp->Array_prototype;\n    o->isarrlist = 1;\n    Jsi_ObjArraySizer(interp, o, 0);\n    Jsi_ObjIncrRefCount(interp,v->d.obj);\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNumber(Jsi_Interp *interp, Jsi_Value **vPtr, Jsi_Number n) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBool(Jsi_Interp *interp, Jsi_Value **vPtr, int b) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = b;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeBlob(Jsi_Interp *interp, Jsi_Value **vPtr, unsigned char *s, int len) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = len;\n    obj->isBlob = 1;\n    return v;\n}\nJsi_Value* jsi_ValueMakeBlobDup(Jsi_Interp *interp, Jsi_Value **ret, unsigned char *s, int len) {\n    if (len<0) len = Jsi_Strlen((char*)s);\n    uchar *dp = (uchar*)Jsi_Malloc(len+1);\n    memcpy(dp, s, len);\n    dp[len] = 0;\n    return Jsi_ValueMakeBlob(interp, ret, dp, len);\n}\n\n\nJsi_Value* Jsi_ValueMakeString(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    return Jsi_ValueMakeBlob(interp, vPtr, (unsigned char *)s, Jsi_Strlen(s));\n}\n\nJsi_Value* Jsi_ValueMakeStringKey(Jsi_Interp *interp, Jsi_Value **vPtr, const char *s) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeNull(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else\n        Jsi_ValueReset(interp, vPtr);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value* Jsi_ValueMakeUndef(Jsi_Interp *interp, Jsi_Value **vPtr) {\n    Jsi_Value *v = (vPtr?*vPtr:NULL);\n    if (!v)\n        v = Jsi_ValueNew(interp);\n    else {\n        if (v->vt == JSI_VT_UNDEF) return v;\n        Jsi_ValueReset(interp, vPtr);\n    }\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNumber(Jsi_Interp *interp, Jsi_Number n) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NUMBER;\n    v->d.num = n;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewObj(Jsi_Interp *interp, Jsi_Obj *o) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_ValueMakeObject(interp, &v, o);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewString(Jsi_Interp *interp, const char *s, int len) {\n    assert(s);\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, obj);\n    obj->d.s.str = (char*)s;\n    obj->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewStringDup(Jsi_Interp *interp, const char *s) {\n    return Jsi_ValueNewString(interp, Jsi_Strdup(s), -1);\n}\n\nJsi_Value* Jsi_ValueNewStringKey(Jsi_Interp *interp, const char *s) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)Jsi_KeyAdd(interp,s);\n    v->d.s.len = Jsi_Strlen(s);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\n\nJsi_Value* Jsi_ValueNewStringConst(Jsi_Interp *interp, const char *s, int len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_STRING;\n    v->d.s.str = (char*)s;\n    v->d.s.len = (len<0?Jsi_Strlen(s):(uint)len);\n    v->f.bits.isstrkey = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBlob(Jsi_Interp *interp, unsigned char *s, uint len) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    Jsi_Obj *o = Jsi_ObjNewType(interp, JSI_OT_STRING);\n    Jsi_ValueMakeObject(interp, &v, o);\n    o->d.s.str = (char*)Jsi_Malloc(len+1);\n    memcpy(o->d.s.str, (char*)s, len);\n    o->d.s.str[len] = 0;\n    o->d.s.len = len;\n    o->isBlob = 1;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewBoolean(Jsi_Interp *interp, int bval) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_BOOL;\n    v->d.val = bval;\n    return v;\n}\n\nJsi_Value* Jsi_ValueNewNull(Jsi_Interp *interp) {\n    Jsi_Value *v = Jsi_ValueNew(interp);\n    v->vt = JSI_VT_NULL;\n    return v;\n}\n\nJsi_Value *Jsi_ValueNewArray(Jsi_Interp *interp, const char **items, int count)\n{\n    Jsi_Obj *obj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    int i = 0;\n    if (count<0) {\n        count = 0;\n        while (items[count])\n            count++;\n    }\n    if (Jsi_ObjArraySizer(interp, obj, count) <= 0) {\n        Jsi_ObjFree(interp, obj);\n        return NULL;\n    }\n    for (i = 0; i < count; ++i) {\n        obj->arr[i] = Jsi_ValueNewStringDup(interp, items[i]);\n        Jsi_IncrRefCount(interp, obj->arr[i]);\n    }\n    obj->arrCnt = count;\n    assert(obj->arrCnt<=obj->arrMaxSize);\n    return Jsi_ValueMakeArrayObject(interp, NULL, obj);\n}\n\nJsi_Obj *Jsi_ValueGetObj(Jsi_Interp *interp, Jsi_Value* v)\n{\n    if (v->vt == JSI_VT_OBJECT) {\n        return v->d.obj;\n    }\n    return NULL;\n}\n\nint Jsi_ValueStrlen(Jsi_Value* v) {\n    //if (v->vt == JSI_VT_OBJECT && v->d.obj->ot == JSI_OT_STRING && v->d.obj->isBlob)\n    //    return v->d.obj->d.s.len;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s == 0 || s->str == 0)\n        return 0;\n#if JSI__UTF8\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#else\n    if (s->len>=0) return s->len;\n    return (int)Jsi_NumUtfChars(s->str, s->len);\n#endif\n}\n\nchar *Jsi_ValueString(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    if (!v) return NULL;\n    Jsi_String *s = jsi_ValueString(v);\n    if (s) {\n        if (lenPtr)\n            *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n        return s->str;\n    }\n    if (lenPtr)\n        *lenPtr = 0;\n    return NULL;\n}\n\nunsigned char *Jsi_ValueBlob(Jsi_Interp *interp, Jsi_Value* v, int *lenPtr)\n{\n    return (unsigned char*)Jsi_ValueString(interp, v, lenPtr);\n}\n\nchar* Jsi_ValueGetStringLen(Jsi_Interp *interp, Jsi_Value *pv, int *lenPtr)\n{\n    if (!pv)\n        return NULL;\n    Jsi_String *s = jsi_ValueString(pv);\n    if (!s)\n        return NULL;\n    if (lenPtr)\n        *lenPtr = (s->len<0 ? (int)Jsi_Strlen(s->str) : s->len);\n    return s->str;\n}\n\nint Jsi_ValueInstanceOf( Jsi_Interp *interp, Jsi_Value* v1, Jsi_Value* v2)\n{\n    Jsi_Value *proto, *sproto;\n    if (v1->vt != JSI_VT_OBJECT || v2->vt != JSI_VT_OBJECT  || v2->d.obj->ot != JSI_OT_FUNCTION)\n        return 0;\n    proto = Jsi_ValueObjLookup(interp, v2, \"prototype\", 0);\n    if (!proto)\n        return 0;\n    sproto = v1->d.obj->__proto__ ;\n    while (sproto) {\n        if (sproto == proto)\n            return 1;\n        if (sproto->vt != JSI_VT_OBJECT)\n            return 0;\n        sproto = sproto->d.obj->__proto__;\n    }\n    return 0;\n}\n\n\nJsi_RC jsi_InitValue(Jsi_Interp *interp, int release)\n{\n    return JSI_OK;\n}\n\nvoid  Jsi_ValueFromDS(Jsi_Interp *interp, Jsi_DString *dsPtr, Jsi_Value **ret)\n{\n    char *cp = NULL;\n    int len = Jsi_DSLength(dsPtr);\n    if (len && !(cp=(char*)dsPtr->strA)) \n        cp = Jsi_StrdupLen(dsPtr->Str, len);\n    dsPtr->strA = NULL;\n    dsPtr->Str[0] = 0;\n    dsPtr->len = 0;\n    dsPtr->spaceAvl = dsPtr->staticSize;\n    if (!cp)\n        Jsi_ValueMakeStringDup(interp, ret, \"\");\n    else\n        Jsi_ValueMakeBlob(interp, ret, (uchar*)cp, len);\n}\n\n#endif\n", "//JSI Command Prototypes: version 3.0.8\nthrow(\"NOT EXECUTABLE: USE FILE IN GEANY EDITOR FOR CMD LINE COMPLETION + GOTO TAG\");\n\nvar Array = function(cmd,args) {};\nArray.prototype.concat = function(...):array {};\nArray.prototype.every = function(callback:function):any {};\nArray.prototype.fill = function(value:any, start:number=0, end:number=-1):array {};\nArray.prototype.filter = function(callback:function, this:object=void):array {};\nArray.prototype.find = function(callback:function):any {};\nArray.prototype.findIndex = function(callback:function):any {};\nArray.prototype.flat = function(depth:number=1):array {};\nArray.prototype.forEach = function(callback:function, this:object=void):void {};\nArray.prototype.includes = function(val:any):any {};\nArray.prototype.indexOf = function(str:any, startIdx:number=0):number {};\nArray.prototype.isArray = function():boolean {};\nArray.prototype.join = function(sep:string=''):string {};\nArray.prototype.lastIndexOf = function(val:any, start:number=0):number {};\nArray.prototype.map = function(callback:function, this:object=void):array {};\nArray.prototype.pop = function():any {};\nArray.prototype.push = function(val:any, ...):number {};\nArray.prototype.reduce = function(callback:function, initial:any):any {};\nArray.prototype.reduceRight = function(callback:function, initial:any):any {};\nArray.prototype.reverse = function():array {};\nArray.prototype.shift = function():any {};\nArray.prototype.sizeOf = function():number {};\nArray.prototype.slice = function(start:number, end:number=void):array {};\nArray.prototype.some = function(callback:function, this:object=void):boolean {};\nArray.prototype.sort = function(options:function|object=void):array {};\nArray.prototype.splice = function(start:number, howmany:number=void, ...):array {};\nArray.prototype.unshift = function(...):number {};\nvar Boolean = function(cmd,args) {};\nvar CData = function(cmd,args) {};\nCData.prototype.conf = function(options:object|string=void):any {};\nCData.prototype.get = function(key:string|number|object=null, field:string=void):any {};\nCData.prototype.incr = function(key:string|number|object|null, field:object|string, value:number=1):number {};\nCData.prototype.info = function():object {};\nCData.prototype.names = function():array {};\nCData.prototype.set = function(key:string|number|object|null, field:object|string, value:any=void):any {};\nCData.prototype.unset = function(key:string|number|object):any {};\nvar CEnum = function(cmd,args) {};\nCEnum.prototype.add = function(options:object|string, fields:array|string):any {};\nCEnum.prototype.conf = function(enum:string, options:object|string=void):any {};\nCEnum.prototype.fieldconf = function(enum:string, field:string, options:object|string=void):any {};\nCEnum.prototype.find = function(enum:string, intValue:number):string {};\nCEnum.prototype.get = function(enum:string):object {};\nCEnum.prototype.names = function(enum:string=void):array {};\nCEnum.prototype.remove = function(enum:string):any {};\nCEnum.prototype.value = function(enum:string, item:string):number {};\nvar CStruct = function(cmd,args) {};\nCStruct.prototype.add = function(options:object|string, fields:array|string):any {};\nCStruct.prototype.conf = function(struct:string, options:object|string=void):any {};\nCStruct.prototype.fieldconf = function(struct:string, field:string, options:object|string=void):any {};\nCStruct.prototype.get = function(struct, options:object=void):object {};\nCStruct.prototype.names = function(struct:string=void):array {};\nCStruct.prototype.remove = function(name:string):any {};\nCStruct.prototype.schema = function():string {};\nvar CType = function(cmd,args) {};\nCType.prototype.conf = function(typ:string, options:object|string=void):any {};\nCType.prototype.names = function(ctype=false):array {};\nvar Channel = function(cmd,args) {};\nChannel.prototype.close = function():boolean {};\nChannel.prototype.eof = function():boolean {};\nChannel.prototype.filename = function():string {};\nChannel.prototype.flush = function():number {};\nChannel.prototype.gets = function():string|void {};\nChannel.prototype.lstat = function():object {};\nChannel.prototype.mode = function():string {};\nChannel.prototype.open = function(file:string, mode:string='r'):boolean {};\nChannel.prototype.puts = function(str):boolean {};\nChannel.prototype.read = function(size:number=-1):string|void {};\nChannel.prototype.seek = function(pos:number, whence:string):number {};\nChannel.prototype.stat = function():object {};\nChannel.prototype.tell = function():number {};\nChannel.prototype.truncate = function(pos:number):number {};\nChannel.prototype.write = function(data):number {};\nvar Debugger = function(cmd,args) {};\nDebugger.prototype.add = function(val:string|number, temp:boolean=false):number {};\nDebugger.prototype.enable = function(id:number, on:boolean):void {};\nDebugger.prototype.info = function(id:number=void):array|object {};\nDebugger.prototype.remove = function(id:number):void {};\nvar Event = function(cmd,args) {};\nEvent.prototype.clearInterval = function(id:number):void {};\nEvent.prototype.info = function(id:number):object {};\nEvent.prototype.names = function():array {};\nEvent.prototype.setInterval = function(callback:function, millisecs:number):number {};\nEvent.prototype.setTimeout = function(callback:function, millisecs:number):number {};\nEvent.prototype.update = function(options:number|object=void):number {};\nvar File = function(cmd,args) {};\nFile.prototype.atime = function(file:string):number {};\nFile.prototype.chdir = function(file:string):any {};\nFile.prototype.chmod = function(file:string, mode:number):any {};\nFile.prototype.copy = function(src:string, dest:string, force:boolean=false):any {};\nFile.prototype.dirname = function(file:string):string {};\nFile.prototype.executable = function(file:string):boolean {};\nFile.prototype.exists = function(file:string):boolean {};\nFile.prototype.extension = function(file:string):string {};\nFile.prototype.glob = function(pattern:regexp|string|null='*', options:function|object|null=void):array {};\nFile.prototype.isdir = function(file:string):boolean {};\nFile.prototype.isfile = function(file:string):boolean {};\nFile.prototype.isrelative = function(file:string):boolean {};\nFile.prototype.join = function(path:string, path:string):string {};\nFile.prototype.link = function(src:string, dest:string, ishard:boolean=false):any {};\nFile.prototype.lstat = function(file:string):object {};\nFile.prototype.mkdir = function(file:string,force:boolean=false):any {};\nFile.prototype.mknod = function(file:string, mode:number, dev:number):any {};\nFile.prototype.mtime = function(file:string):number {};\nFile.prototype.owned = function(file:string):boolean {};\nFile.prototype.pwd = function():string {};\nFile.prototype.read = function(file:string, mode:string='rb'):string {};\nFile.prototype.readable = function(file:string):boolean {};\nFile.prototype.readlink = function(file:string):string {};\nFile.prototype.realpath = function(file:string):string {};\nFile.prototype.remove = function(file:string, force:boolean=false):any {};\nFile.prototype.rename = function(src:string, dest:string, force:boolean=false):any {};\nFile.prototype.rootname = function(file:string):string {};\nFile.prototype.size = function(file:string):number {};\nFile.prototype.stat = function(file:string):object {};\nFile.prototype.tail = function(file:string):string {};\nFile.prototype.tempfile = function(file:string):any {};\nFile.prototype.truncate = function(file:string, size:number):any {};\nFile.prototype.type = function(file:string):string {};\nFile.prototype.writable = function(file:string):boolean {};\nFile.prototype.write = function(file:string, str:string, mode:string='wb+'):number {};\nvar Function = function(cmd,args) {};\nFunction.prototype.apply = function(thisArg:null|object|function, args:array=void):any {};\nFunction.prototype.bind = function(thisArg:object|function=null,arg,...):any {};\nFunction.prototype.call = function(thisArg:null|object|function, arg1, ...):any {};\nvar Info = function(cmd,args) {};\nInfo.prototype.argv0 = function():string|void {};\nInfo.prototype.cmds = function(val:string|regexp='*', options:object=void):array|object {};\nInfo.prototype.completions = function(str:string, start:number=0, end:number=void):array {};\nInfo.prototype.data = function(val:string|regexp|object=void):array|object {};\nInfo.prototype.error = function():object {};\nInfo.prototype.event = function(id:number=void):array|object {};\nInfo.prototype.execZip = function():string|void {};\nInfo.prototype.executable = function():string {};\nInfo.prototype.files = function():array {};\nInfo.prototype.funcs = function(string|regexp|object=void):array|object {};\nInfo.prototype.interp = function(interp:userobj=void):object {};\nInfo.prototype.isMain = function():boolean {};\nInfo.prototype.keywords = function(isSql=false, name:string=void):boolean|array {};\nInfo.prototype.level = function(level:number=void):number|array|object {};\nInfo.prototype.locals = function(filter:boolean=void):object {};\nInfo.prototype.lookup = function(name:string):any {};\nInfo.prototype.methods = function(val:string|regexp):array|object {};\nInfo.prototype.named = function(name:string=void):array|userobj {};\nInfo.prototype.options = function(ctype:boolean=false):array {};\nInfo.prototype.package = function(pkgName:string):object|null {};\nInfo.prototype.platform = function():object {};\nInfo.prototype.script = function(func:function|regexp=void):string|array|void {};\nInfo.prototype.scriptDir = function():string|void {};\nInfo.prototype.vars = function(val:string|regexp|object=void):array|object {};\nInfo.prototype.version = function(full:boolean=false):number|object {};\nvar Interp = function(cmd,args) {};\nInterp.prototype.alias = function(name:string=void, func:function|null=void, args:array|null=void, async=false):any {};\nInterp.prototype.call = function(funcName:string, args:array, wait:boolean=false):any {};\nInterp.prototype.conf = function(options:string|object=void):any {};\nInterp.prototype.eval = function(js:string, async:boolean=false):any {};\nInterp.prototype.info = function():object {};\nInterp.prototype.source = function(file:string, async:boolean=false):any {};\nInterp.prototype.uplevel = function(js:string, level:number=0):any {};\nInterp.prototype.value = function(var:string, level:number=0):any {};\nvar JSON = function(cmd,args) {};\nJSON.prototype.check = function(str:string, strict:boolean=true):boolean {};\nJSON.prototype.parse = function(str:string, strict:boolean=true):any {};\nJSON.prototype.stringify = function(value:any,  strict:boolean=true):string {};\nvar Math = function(cmd,args) {};\nMath.prototype.abs = function(num:number):number {};\nMath.prototype.acos = function(num:number):number {};\nMath.prototype.asin = function(num:number):number {};\nMath.prototype.atan = function(num:number):number {};\nMath.prototype.atan2 = function(x:number, y:number):number {};\nMath.prototype.ceil = function(num:number):number {};\nMath.prototype.cos = function(num:number):number {};\nMath.prototype.exp = function(num:number):number {};\nMath.prototype.floor = function(num:number):number {};\nMath.prototype.log = function(num:number):number {};\nMath.prototype.max = function(x:number, y:number, ...):number {};\nMath.prototype.min = function(x:number, y:number, ...):number {};\nMath.prototype.pow = function(x:number, y:number):number {};\nMath.prototype.random = function():number {};\nMath.prototype.round = function(num:number):number {};\nMath.prototype.sin = function(num:number):number {};\nMath.prototype.sqrt = function(num:number):number {};\nMath.prototype.srand = function(seed:number):number {};\nMath.prototype.tan = function(num:number):number {};\nvar MySql = function(cmd,args) {};\nMySql.prototype.affectedRows = function():number {};\nMySql.prototype.complete = function(sql:string):boolean {};\nMySql.prototype.conf = function(options:string|object=void):any {};\nMySql.prototype.errorNo = function():number {};\nMySql.prototype.errorState = function():string {};\nMySql.prototype.eval = function(sql:string):number {};\nMySql.prototype.exists = function(sql:string):boolean {};\nMySql.prototype.info = function():object {};\nMySql.prototype.lastQuery = function():string {};\nMySql.prototype.lastRowid = function():number {};\nMySql.prototype.onecolumn = function(sql:string):any {};\nMySql.prototype.ping = function(noError:boolean=false):number {};\nMySql.prototype.query = function(sql:string, options:function|string|array|object=void):any {};\nMySql.prototype.reconnect = function():void {};\nMySql.prototype.reset = function():number {};\nvar Number = function(cmd,args) {};\nNumber.prototype.isFinite = function():boolean {};\nNumber.prototype.isInteger = function():boolean {};\nNumber.prototype.isNaN = function():boolean {};\nNumber.prototype.isSafeInteger = function():boolean {};\nNumber.prototype.toExponential = function(num:number):string {};\nNumber.prototype.toFixed = function(num:number=0):string {};\nNumber.prototype.toPrecision = function(num:number):string {};\nNumber.prototype.toString = function(radix:number=10):string {};\nvar Object = function(cmd,args) {};\nObject.prototype.create = function(proto:null|object, properties:object=void):object {};\nObject.prototype.getPrototypeOf = function(name:object|function):function|object {};\nObject.prototype.hasOwnProperty = function(name:string):boolean {};\nObject.prototype.is = function(value1, value2):boolean {};\nObject.prototype.isPrototypeOf = function(name):boolean {};\nObject.prototype.keys = function(obj:object|function=void):array {};\nObject.prototype.merge = function(obj:object|function):object {};\nObject.prototype.propertyIsEnumerable = function(name):boolean {};\nObject.prototype.setPrototypeOf = function(name:object, value:object):any {};\nObject.prototype.toLocaleString = function(quote:boolean=false):string {};\nObject.prototype.toString = function(quote:boolean=false):string {};\nObject.prototype.valueOf = function():any {};\nvar RegExp = function(cmd,args) {};\nRegExp.prototype.exec = function(val:string):array|object|null {};\nRegExp.prototype.test = function(val:string):boolean {};\nvar Signal = function(cmd,args) {};\nSignal.prototype.alarm = function(secs):number {};\nSignal.prototype.callback = function(func:function, sig:number|string):number {};\nSignal.prototype.handle = function(sig:number|string=void, ...):any {};\nSignal.prototype.ignore = function(sig:number|string=void, ...):any {};\nSignal.prototype.kill = function(pid:number, sig:number|string='SIGTERM'):void {};\nSignal.prototype.names = function():array {};\nSignal.prototype.reset = function(sig:number|string=void, ...):array {};\nvar Socket = function(cmd,args) {};\nSocket.prototype.close = function():void {};\nSocket.prototype.conf = function(options:string|object=void):any {};\nSocket.prototype.idconf = function(id:number=void, options:string|object=void):any {};\nSocket.prototype.names = function():array {};\nSocket.prototype.recv = function(id:number=void):string {};\nSocket.prototype.send = function(id:number, data:string, options:object=void):void {};\nSocket.prototype.update = function():void {};\nvar Sqlite = function(cmd,args) {};\nSqlite.prototype.backup = function(file:string, dbname:string='main'):void {};\nSqlite.prototype.collate = function(name:string, callback:function):void {};\nSqlite.prototype.complete = function(sql:string):boolean {};\nSqlite.prototype.conf = function(options:string|object=void):any {};\nSqlite.prototype.eval = function(sql:string):number {};\nSqlite.prototype.exists = function(sql:string):boolean {};\nSqlite.prototype.filename = function(name:string='main'):string {};\nSqlite.prototype.func = function(name:string, callback:function, numArgs:number=void):void {};\nSqlite.prototype.import = function(table:string, file:string, options:object=void):number {};\nSqlite.prototype.interrupt = function():void {};\nSqlite.prototype.onecolumn = function(sql:string):any {};\nSqlite.prototype.query = function(sql:string, options:function|string|array|object=void):any {};\nSqlite.prototype.restore = function(file:string, dbname:string):void {};\nSqlite.prototype.transaction = function(callback:function, type:string=void):void {};\nvar String = function(cmd,args) {};\nString.prototype.charAt = function(index:number):string {};\nString.prototype.charCodeAt = function(index:number):number {};\nString.prototype.concat = function(str:string, ...):string {};\nString.prototype.fromCharCode = function(...):string {};\nString.prototype.indexOf = function(str:string, start:number):number {};\nString.prototype.lastIndexOf = function(str:string, start:number):number {};\nString.prototype.map = function(strMap:array, nocase:boolean=false):string {};\nString.prototype.match = function(pattern:regexp|string):array|null {};\nString.prototype.repeat = function(count:number):string {};\nString.prototype.replace = function(pattern:regexp|string, replace:string|function):string {};\nString.prototype.search = function(pattern:regexp|string):number {};\nString.prototype.slice = function(start:number, end:number):string {};\nString.prototype.split = function(char:string|null=void):array {};\nString.prototype.substr = function(start:number, length:number):string {};\nString.prototype.substring = function(start:number, end:number):string {};\nString.prototype.toLocaleLowerCase = function():string {};\nString.prototype.toLocaleUpperCase = function():string {};\nString.prototype.toLowerCase = function():string {};\nString.prototype.toTitle = function(chars:string):string {};\nString.prototype.toUpperCase = function():string {};\nString.prototype.trim = function(chars:string):string {};\nString.prototype.trimLeft = function(chars:string):string {};\nString.prototype.trimRight = function(chars:string):string {};\nvar System = function(cmd,args) {};\nSystem.prototype.assert = function(expr:boolean|number|function, msg:string=void, options:object=void):void {};\nSystem.prototype.clearInterval = function(id:number):void {};\nSystem.prototype.decodeURI = function(val:string):string {};\nSystem.prototype.encodeURI = function(val:string):string {};\nSystem.prototype.exec = function(val:string, options:string|object=void):any {};\nSystem.prototype.exit = function(code:number=0):void {};\nSystem.prototype.format = function(format:string, ...):string {};\nSystem.prototype.isFinite = function(val):boolean {};\nSystem.prototype.isMain = function():boolean {};\nSystem.prototype.isNaN = function(val):boolean {};\nSystem.prototype.load = function(shlib:string):void {};\nSystem.prototype.log = function(val, ...):void {};\nSystem.prototype.matchObj = function(obj:object, match:string=void, partial=false, noerror=false):string|boolean {};\nSystem.prototype.noOp = function():any {};\nSystem.prototype.parseFloat = function(val):number {};\nSystem.prototype.parseInt = function(val:any, base:number=10):number {};\nSystem.prototype.parseOpts = function(self:object|userobj, options:object, conf:object|null|undefined):any {};\nSystem.prototype.printf = function(format:string, ...):void {};\nSystem.prototype.provide = function(name:string|function=void, version:number|string=1.0, opts:object|function=void):void {};\nSystem.prototype.puts = function(val, ...):void {};\nSystem.prototype.quote = function(val:string):string {};\nSystem.prototype.require = function(name:string=void, version:number|string=1, options:object=void):number|array|object {};\nSystem.prototype.runMain = function(cmd:string|null|function=void, conf:array=undefined):any {};\nSystem.prototype.runModule = function(cmd:string|null|function=void, conf:array=undefined):any {};\nSystem.prototype.setInterval = function(callback:function, ms:number):number {};\nSystem.prototype.setTimeout = function(callback:function, ms:number):number {};\nSystem.prototype.sleep = function(secs:number=1.0):void {};\nSystem.prototype.source = function(val:string|array, options:object=void):any {};\nSystem.prototype.strftime = function(num:number=null, options:string|object=void):string {};\nSystem.prototype.strptime = function(val:string=void, options:string|object=void):number {};\nSystem.prototype.times = function(callback:function|boolean, count:number=1):number {};\nSystem.prototype.unload = function(shlib:string):void {};\nSystem.prototype.update = function(options:number|object=void):number {};\nvar Util = function(cmd,args) {};\nUtil.prototype.argArray = function(arg:any|undefined):array|null {};\nUtil.prototype.base64 = function(val:string, decode:boolean=false):string {};\nUtil.prototype.complete = function(val:string):boolean {};\nUtil.prototype.crc32 = function(val:string, crcSeed=0):number {};\nUtil.prototype.decrypt = function(val:string, key:string):string {};\nUtil.prototype.encrypt = function(val:string, key:string):string {};\nUtil.prototype.fromCharCode = function(code:number):string {};\nUtil.prototype.getenv = function(name:string=void):string|object|void {};\nUtil.prototype.getpid = function(parent:boolean=false):number {};\nUtil.prototype.getuser = function():object {};\nUtil.prototype.hash = function(val:string, options|object=void):string {};\nUtil.prototype.hexStr = function(val:string, decode:boolean=false):string {};\nUtil.prototype.setenv = function(name:string, value:string=void):any {};\nUtil.prototype.sqlValues = function(name:string, var:object=void):any {};\nUtil.prototype.times = function(callback:function|boolean, count:number=1):number {};\nUtil.prototype.verConvert = function(ver:string|number, zeroTrim:number=0):number|string|null {};\nvar Vfs = function(cmd,args) {};\nVfs.prototype.conf = function(mount:string, string|options:object|string=void):any {};\nVfs.prototype.exec = function(cmd:string):any {};\nVfs.prototype.fileconf = function(mount:string, path:string, options:string|object=void):any {};\nVfs.prototype.list = function():array {};\nVfs.prototype.mount = function(type:string, file:string, param:object=void):string {};\nVfs.prototype.type = function(type:string=void, options:object|null=void):any {};\nVfs.prototype.unmount = function(mount:string):void {};\nVfs.prototype.vmount = function(options:object=void):string {};\nvar WebSocket = function(cmd,args) {};\nWebSocket.prototype.conf = function(options:string|object=void):any {};\nWebSocket.prototype.file = function(name:string=void):array|void {};\nWebSocket.prototype.handler = function(extension:string=void, cmd:string|function=void, flags:number=0):string|array|function|void {};\nWebSocket.prototype.header = function(id:number, name:string=void):string|array|void {};\nWebSocket.prototype.idconf = function(id:number, options:string|object=void):any {};\nWebSocket.prototype.ids = function(name:string=void):array {};\nWebSocket.prototype.query = function(id:number, name:string=void):string|object|void {};\nWebSocket.prototype.send = function(id:number, data:any):void {};\nWebSocket.prototype.status = function():object|void {};\nWebSocket.prototype.unalias = function(path:string):string|void {};\nWebSocket.prototype.update = function():void {};\nWebSocket.prototype.version = function():string {};\nvar Zvfs = function(cmd,args) {};\nZvfs.prototype.append = function(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void {};\nZvfs.prototype.create = function(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void {};\nZvfs.prototype.deflate = function(data:string):string {};\nZvfs.prototype.inflate = function(data:string):string {};\nZvfs.prototype.list = function(archive:string):array {};\nZvfs.prototype.mount = function(archive:string, mountdir:string=void):string {};\nZvfs.prototype.names = function(mountdir:string=void):array {};\nZvfs.prototype.offset = function(archive:string):number {};\nZvfs.prototype.stat = function(filename:string):object {};\nZvfs.prototype.truncate = function(archive:string, noerror:boolean=false):number {};\nZvfs.prototype.unmount = function(archive:string):void {};\nvar assert = function(expr:boolean|number|function, msg:string=void, options:object=void):void {};\nvar clearInterval = function(id:number):void {};\nvar console = function(cmd,args) {};\nconsole.prototype.assert = function(expr:boolean|number|function, msg:string=void, options:object=void):void {};\nconsole.prototype.error = function(val, ...):void {};\nconsole.prototype.input = function():string|void {};\nconsole.prototype.log = function(val, ...):void {};\nconsole.prototype.printf = function(format:string, ...):void {};\nconsole.prototype.puts = function(val, ...):void {};\nconsole.prototype.warn = function(val, ...):void {};\nvar decodeURI = function(val:string):string {};\nvar encodeURI = function(val:string):string {};\nvar exec = function(val:string, options:string|object=void):any {};\nvar exit = function(code:number=0):void {};\nvar format = function(format:string, ...):string {};\nvar isFinite = function(val):boolean {};\nvar isMain = function():boolean {};\nvar isNaN = function(val):boolean {};\nvar load = function(shlib:string):void {};\nvar log = function(val, ...):void {};\nvar matchObj = function(obj:object, match:string=void, partial=false, noerror=false):string|boolean {};\nvar noOp = function():any {};\nvar parseFloat = function(val):number {};\nvar parseInt = function(val:any, base:number=10):number {};\nvar parseOpts = function(self:object|userobj, options:object, conf:object|null|undefined):any {};\nvar printf = function(format:string, ...):void {};\nvar provide = function(name:string|function=void, version:number|string=1.0, opts:object|function=void):void {};\nvar puts = function(val, ...):void {};\nvar quote = function(val:string):string {};\nvar require = function(name:string=void, version:number|string=1, options:object=void):number|array|object {};\nvar runMain = function(cmd:string|null|function=void, conf:array=undefined):any {};\nvar runModule = function(cmd:string|null|function=void, conf:array=undefined):any {};\nvar setInterval = function(callback:function, ms:number):number {};\nvar setTimeout = function(callback:function, ms:number):number {};\nvar sleep = function(secs:number=1.0):void {};\nvar source = function(val:string|array, options:object=void):any {};\nvar strftime = function(num:number=null, options:string|object=void):string {};\nvar strptime = function(val:string=void, options:string|object=void):number {};\nvar times = function(callback:function|boolean, count:number=1):number {};\nvar unload = function(shlib:string):void {};\nvar update = function(options:number|object=void):number {};\n\n", "<title>Reference</title>\n<p>\n<div id=\"sectmenu\" data-opts=\"closed:false\"></div><B>JSI REFERENCE</B>: <a href=\"#System\">System</a> contains global methods\n(Related: [./functions.wiki|Functions], [./language.wiki|Syntax]).\n<p>\n<a name=\"TOC\"></a>\n<a href='#Array'>Array</a>\n<a href='#Boolean'>Boolean</a>\n<a href='#CData'>CData</a>\n<a href='#CEnum'>CEnum</a>\n<a href='#CStruct'>CStruct</a>\n<a href='#CType'>CType</a>\n<a href='#Channel'>Channel</a>\n<a href='#Debugger'>Debugger</a>\n<a href='#Event'>Event</a>\n<a href='#File'>File</a>\n<a href='#Function'>Function</a>\n<a href='#Info'>Info</a>\n<a href='#Interp'>Interp</a>\n<a href='#JSON'>JSON</a>\n<a href='#Math'>Math</a>\n<a href='#MySql'>MySql</a>\n<a href='#Number'>Number</a>\n<a href='#Object'>Object</a>\n<a href='#RegExp'>RegExp</a>\n<a href='#Signal'>Signal</a>\n<a href='#Socket'>Socket</a>\n<a href='#Sqlite'>Sqlite</a>\n<a href='#String'>String</a>\n<a href='#System'>System</a>\n<a href='#Util'>Util</a>\n<a href='#Vfs'>Vfs</a>\n<a href='#WebSocket'>WebSocket</a>\n<a href='#Zvfs'>Zvfs</a>\n<a href='#console'>console</a>\n<nowiki>\n<a name=\"Array\"></a>\n\n<hr>\n\n\n<h1>Array</h1>\n\n<font color=red>Synopsis:new Array(...):array\n\n</font><p>Provide access to array objects.\n\n\n<h2>Methods for \"Array\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Array</td><td>new Array(...):array </td><td>jsi_Array constructor.</td></tr>\n<tr><td>concat</td><td>concat(...):array </td><td>Return array with args appended.</td></tr>\n<tr><td>every</td><td>every(callback:function) </td><td>Returns true if every value in array satisfies the test.</td></tr>\n<tr><td>fill</td><td>fill(value:any, start:number=0, end:number=-1):array </td><td>Fill an array with values.</td></tr>\n<tr><td>filter</td><td>filter(callback:function, this:object=void):array </td><td>Return a filtered array.</td></tr>\n<tr><td>find</td><td>find(callback:function) </td><td>Returns the value of the first element in the array that satisfies the test.</td></tr>\n<tr><td>findIndex</td><td>findIndex(callback:function) </td><td>Returns the index of the first element in the array that satisfies the test.</td></tr>\n<tr><td>flat</td><td>flat(depth:number=1):array </td><td>Flatten an arra.</td></tr>\n<tr><td>forEach</td><td>forEach(callback:function, this:object=void):void </td><td>Invoke function with each item in object.</td></tr>\n<tr><td>includes</td><td>includes(val:any) </td><td>Returns true if array contains value.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:any, startIdx:number=0):number </td><td>Return index of first occurrance in array.</td></tr>\n<tr><td>isArray</td><td>isArray():boolean </td><td>True if val array.</td></tr>\n<tr><td>join</td><td>join(sep:string=''):string </td><td>Return elements joined by char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(val:any, start:number=0):number </td><td>Return index of last occurence in array.</td></tr>\n<tr><td>map</td><td>map(callback:function, this:object=void):array </td><td>Creates a new array with the results of calling a provided function on every element in this array.</td></tr>\n<tr><td>pop</td><td>pop() </td><td>Remove and return last element of array.</td></tr>\n<tr><td>push</td><td>push(val:any, ...):number </td><td>Push one or more elements onto array and return size.</td></tr>\n<tr><td>reduce</td><td>reduce(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reduceRight</td><td>reduceRight(callback:function, initial:any) </td><td>Return a reduced array.</td></tr>\n<tr><td>reverse</td><td>reverse():array </td><td>Reverse order of all elements in an array.</td></tr>\n<tr><td>shift</td><td>shift() </td><td>Remove first element and shift downwards.</td></tr>\n<tr><td>sizeOf</td><td>sizeOf():number </td><td>Return size of array.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number=void):array </td><td>Return sub-array.</td></tr>\n<tr><td>some</td><td>some(callback:function, this:object=void):boolean </td><td>Return true if function returns true some element.</td></tr>\n<tr><td>sort</td><td>sort(<a href='#Array.sortOptions'>options</a>:function|object=void):array </td><td>Sort an array.</td></tr>\n<tr><td>splice</td><td>splice(start:number, howmany:number=void, ...):array </td><td>Change the content of an array, adding new elements while removing old elements.</td></tr>\n<tr><td>unshift</td><td>unshift(...):number </td><td>Add new elements to start of array and return size.</td></tr>\n</table>\n\n\n<a name=\"Array.sortOptions\"></a>\n<a name=\"Array.confOptions\"></a>\n<h2>Options for \"Array.sort\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Mode to sort by. (one of: <b>default</b>, <b>desc</b>, <b>dict</b>, <b>nocase</b>)</td><td><i></i></td></tr>\n<tr><td>compare</td><td><i>FUNC</i></td><td>Function to do comparison. @function(val1,val2)</td><td><i></i></td></tr>\n<tr><td>unique</td><td><i>BOOL</i></td><td>Eliminate duplicate items.</td><td><i></i></td></tr>\n</table>\n<a name=\"Arrayend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Boolean\"></a>\n\n<hr>\n\n\n<h1>Boolean</h1>\n\n<font color=red>Synopsis:new Boolean(bool:boolean=false):boolean\n\n</font><p>A Boolean object.\n\n\n<h2>Methods for \"Boolean\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Boolean</td><td>new Boolean(bool:boolean=false):boolean </td><td>Boolean constructor.</td></tr>\n</table>\n<a name=\"Booleanend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CData\"></a>\n\n<hr>\n\n\n<h1>CData</h1>\n\n<font color=red>Synopsis:new CData(options:string&verbar;object=void, inits:object=undefined):userobj\n\n</font><p>\n<h2>Methods for \"CData\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>CData</td><td>new CData(<a href='#new CDataOptions'>options</a>:string|object=void, inits:object=undefined):userobj </td><td>Create a new struct or map/array of structs.The 2nd arg is used for function option parsing and will report errors at the callers file:line</td></tr>\n<tr><td>conf</td><td>conf(<a href='#CData.confOptions'>options</a>:object|string=void) </td><td>Configure options for c-data.</td></tr>\n<tr><td>get</td><td>get(key:string|number|object=null, field:string=void) </td><td>Get struct/map/array value.</td></tr>\n<tr><td>incr</td><td>incr(key:string|number|object|null, field:object|string, value:number=1):number </td><td>Increment a numeric field: returns the new value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info for data.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return keys for map.</td></tr>\n<tr><td>set</td><td>set(key:string|number|object|null, field:object|string, value:any=void) </td><td>Set a struct/map/array value.</td></tr>\n<tr><td>unset</td><td>unset(key:string|number|object) </td><td>Remove entry from map/array.</td></tr>\n</table>\n\n\n<a name=\"new CDataOptions\"></a>\n<a name=\"CData.confOptions\"></a>\n<h2>Options for \"new CData\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>If an array, its size in elements.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>UINT</i></td><td>Flags.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of data.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyName</td><td><i>STRKEY</i></td><td>Key struct, for key struct maps.</td><td><i>initOnly</i></td></tr>\n<tr><td>keyType</td><td><i>STRKEY</i></td><td>Key id. (one of: <b>string</b>, <b>strkey</b>, <b>number</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>mapType</td><td><i>STRKEY</i></td><td>If a map, its type. (one of: <b>none</b>, <b>hash</b>, <b>tree</b>, <b>list</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>maxSize</td><td><i>UINT</i></td><td>Limit the array size or number of keys in a map.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name (eg. of var assigned to on create).</td><td><i>initOnly</i></td></tr>\n<tr><td>noAuto</td><td><i>BOOL</i></td><td>Disable auto-create of map keys in set/incr.</td><td><i></i></td></tr>\n<tr><td>structName</td><td><i>STRKEY</i></td><td>Struct used for storing data.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>varParam</td><td><i>STRKEY</i></td><td>Param for maps/array vars.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CDataend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CEnum\"></a>\n\n<hr>\n\n\n<h1>CEnum</h1>\n\n<font color=red>Synopsis:CEnum.method(...)\n\n</font><p>Enum commands. Note: Enum() is a shortcut for Enum.add().\n\n\n<h2>Methods for \"CEnum\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CEnum.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a new enum: value of items same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(enum:string, <a href='#CEnum.confOptions'>options</a>:object|string=void) </td><td>Configure options for enum.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(enum:string, field:string, <a href='#CEnum.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>find</td><td>find(enum:string, intValue:number):string </td><td>Find item with given value in enum.</td></tr>\n<tr><td>get</td><td>get(enum:string):object </td><td>Return enum definition.</td></tr>\n<tr><td>names</td><td>names(enum:string=void):array </td><td>Return name list of all enums, or items within one enum.</td></tr>\n<tr><td>remove</td><td>remove(enum:string) </td><td>Remove an enum.</td></tr>\n<tr><td>value</td><td>value(enum:string, item:string):number </td><td>Return value for given enum item.</td></tr>\n</table>\n\n\n<a name=\"CEnum.addOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.confOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of enum.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Number of items in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CEnum.fieldconfOptions\"></a>\n<a name=\"CEnum.confOptions\"></a>\n<h2>Options for \"CEnum.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Desciption of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of item.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Value for item.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT</i></td><td>Index of item in enum.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"CEnumend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CStruct\"></a>\n\n<hr>\n\n\n<h1>CStruct</h1>\n\n<font color=red>Synopsis:CStruct.method(...)\n\n</font><p>Struct commands. Note: Struct() is a shortcut for Struct.add().\n\n\n<h2>Methods for \"CStruct\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(<a href='#CStruct.addOptions'>options</a>:object|string, fields:array|string) </td><td>Create a struct: field values same as in fieldconf.</td></tr>\n<tr><td>conf</td><td>conf(struct:string, <a href='#CStruct.confOptions'>options</a>:object|string=void) </td><td>Configure options for struct.</td></tr>\n<tr><td>fieldconf</td><td>fieldconf(struct:string, field:string, <a href='#CStruct.fieldconfOptions'>options</a>:object|string=void) </td><td>Configure options for fields.</td></tr>\n<tr><td>get</td><td>get(struct, options:object=void):object </td><td>Return the struct definition.</td></tr>\n<tr><td>names</td><td>names(struct:string=void):array </td><td>Return name list of all structs, or fields for one struct.</td></tr>\n<tr><td>remove</td><td>remove(name:string) </td><td>Remove a struct.</td></tr>\n<tr><td>schema</td><td>schema():string </td><td>Return database schema for struct.</td></tr>\n</table>\n\n\n<a name=\"CStruct.addOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.add\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.confOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>crc</td><td><i>UINT32</i></td><td>Crc for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Struct description.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Number of fields in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of struct.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of struct in bytes.</td><td><i>readOnly</i></td></tr>\n<tr><td>ssig</td><td><i>UINT32</i></td><td>Signature for struct.</td><td><i>initOnly</i></td></tr>\n<tr><td>value</td><td><i>INT64</i></td><td>Reference count.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"CStruct.fieldconfOptions\"></a>\n<a name=\"CStruct.confOptions\"></a>\n<h2>Options for \"CStruct.fieldconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>arrSize</td><td><i>UINT</i></td><td>Size of field if an array.</td><td><i>initOnly</i></td></tr>\n<tr><td>bits</td><td><i>UINT32</i></td><td>Size of bitfield.</td><td><i>initOnly</i></td></tr>\n<tr><td>boffset</td><td><i>UINT32</i></td><td>Bit offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>idx</td><td><i>UINT32</i></td><td>Index of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Field description.</td><td><i>initOnly</i></td></tr>\n<tr><td>info</td><td><i>STRKEY</i></td><td>Info for field.</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Name of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>offset</td><td><i>UINT</i></td><td>Offset of field within struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>size</td><td><i>UINT</i></td><td>Size of field in struct.</td><td><i>readOnly</i></td></tr>\n<tr><td>type</td><td><i>CUSTOM</i></td><td>Type of field.</td><td><i>initOnly|required</i></td></tr>\n<tr><td>init</td><td><i>CUSTOM</i></td><td>Initial value for field.</td><td><i>initOnly</i></td></tr>\n</table>\n<a name=\"CStructend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"CType\"></a>\n\n<hr>\n\n\n<h1>CType</h1>\n\n<font color=red>Synopsis:CType.method(...)\n\n</font><p>Type commands. Note: Type() is a shortcut for Type.conf().\n\n\n<h2>Methods for \"CType\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(typ:string, <a href='#CType.confOptions'>options</a>:object|string=void) </td><td>Configure options for type.</td></tr>\n<tr><td>names</td><td>names(ctype=false):array </td><td>Return type names.</td></tr>\n</table>\n\n\n<a name=\"CType.confOptions\"></a>\n<a name=\"CType.confOptions\"></a>\n<h2>Options for \"CType.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>idName</td><td><i>STRKEY</i></td><td>The id name: usually upcased cName.</td><td><i>initOnly</i></td></tr>\n<tr><td>cName</td><td><i>STRKEY</i></td><td>C type name.</td><td><i>initOnly</i></td></tr>\n<tr><td>help</td><td><i>STRKEY</i></td><td>Description of id.</td><td><i>initOnly</i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>xfmt</td><td><i>STRKEY</i></td><td>Hex printf format for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>flags</td><td><i>INT64</i></td><td>Flags for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>size</td><td><i>INT</i></td><td>Size for id.</td><td><i>initOnly</i></td></tr>\n<tr><td>user</td><td><i>INT64</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n<a name=\"CTypeend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Channel\"></a>\n\n<hr>\n\n\n<h1>Channel</h1>\n\n<font color=red>Synopsis:new Channel(file:string, mode:string='r'):userobj\n\n</font><p>Commands for accessing Channel objects for file IO.\n\n\n<h2>Methods for \"Channel\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Channel</td><td>new Channel(file:string, mode:string='r'):userobj </td><td>A file input/output object. The mode string is r or w and an optional +.</td></tr>\n<tr><td>close</td><td>close():boolean </td><td>Close the file.</td></tr>\n<tr><td>eof</td><td>eof():boolean </td><td>Return true if read to end-of-file.</td></tr>\n<tr><td>filename</td><td>filename():string </td><td>Get file name.</td></tr>\n<tr><td>flush</td><td>flush():number </td><td>Flush file output.</td></tr>\n<tr><td>gets</td><td>gets():string|void </td><td>Get one line of input.</td></tr>\n<tr><td>lstat</td><td>lstat():object </td><td>Return status for file.</td></tr>\n<tr><td>mode</td><td>mode():string </td><td>Get file mode used with open.</td></tr>\n<tr><td>open</td><td>open(file:string, mode:string='r'):boolean </td><td>Open the file (after close).</td></tr>\n<tr><td>puts</td><td>puts(str):boolean </td><td>Write one line of output.</td></tr>\n<tr><td>read</td><td>read(size:number=-1):string|void </td><td>Read some or all of file.</td></tr>\n<tr><td>seek</td><td>seek(pos:number, whence:string):number </td><td>Seek to position. Return 0 if ok.</td></tr>\n<tr><td>stat</td><td>stat():object </td><td>Return status for file.</td></tr>\n<tr><td>tell</td><td>tell():number </td><td>Return current position.</td></tr>\n<tr><td>truncate</td><td>truncate(pos:number):number </td><td>Truncate file.</td></tr>\n<tr><td>write</td><td>write(data):number </td><td>Write data to file.</td></tr>\n</table>\n<a name=\"Channelend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Debugger\"></a>\n\n<hr>\n\n\n<h1>Debugger</h1>\n\n<font color=red>Synopsis:Debugger.method(...)\n\n</font><p>Debugger breakpoint management.\n\n\n<h2>Methods for \"Debugger\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>add</td><td>add(val:string|number, temp:boolean=false):number </td><td>Add a breakpoint for line, file:line or func.</td></tr>\n<tr><td>enable</td><td>enable(id:number, on:boolean):void </td><td>Enable/disable breakpoint.</td></tr>\n<tr><td>info</td><td>info(id:number=void):array|object </td><td>Return info about one breakpoint, or list of bp numbers.</td></tr>\n<tr><td>remove</td><td>remove(id:number):void </td><td>Remove breakpoint.</td></tr>\n</table>\n<a name=\"Debuggerend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Event\"></a>\n\n<hr>\n\n\n<h1>Event</h1>\n\n<font color=red>Synopsis:Event.method(...)\n\n</font><p>Event management.\n\n\n<h2>Methods for \"Event\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete an event (created with setInterval/setTimeout).</td></tr>\n<tr><td>info</td><td>info(id:number):object </td><td>Return info for the given event id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list event ids (created with setTimeout/setInterval).</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, millisecs:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, millisecs:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>update</td><td>update(<a href='#Event.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"Event.updateOptions\"></a>\n<a name=\"Event.confOptions\"></a>\n<h2>Options for \"Event.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Eventend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"File\"></a>\n\n<hr>\n\n\n<h1>File</h1>\n\n<font color=red>Synopsis:File.method(...)\n\n</font><p>Commands for accessing the filesystem.\n\n\n<h2>Methods for \"File\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>atime</td><td>atime(file:string):number </td><td>Return file Jsi_Access time.</td></tr>\n<tr><td>chdir</td><td>chdir(file:string) </td><td>Change current directory.</td></tr>\n<tr><td>chmod</td><td>chmod(file:string, mode:number) </td><td>Set file permissions.</td></tr>\n<tr><td>copy</td><td>copy(src:string, dest:string, force:boolean=false) </td><td>Copy a file to destination. Directories are not handled.\nThe third argument if given is a boolean force value which if true allows overwrite of an existing file. </td></tr>\n<tr><td>dirname</td><td>dirname(file:string):string </td><td>Return directory path.</td></tr>\n<tr><td>executable</td><td>executable(file:string):boolean </td><td>Return true if file is executable.</td></tr>\n<tr><td>exists</td><td>exists(file:string):boolean </td><td>Return true if file exists.</td></tr>\n<tr><td>extension</td><td>extension(file:string):string </td><td>Return file extension.</td></tr>\n<tr><td>glob</td><td>glob(pattern:regexp|string|null='*', <a href='#File.globOptions'>options</a>:function|object|null=void):array </td><td>Return list of files in dir with optional pattern match. With no arguments (or null) returns all files/directories in current directory.\nThe first argument can be a pattern (either a glob or regexp) of the files to return.\nWhen the second argument is a function, it is called with each path, and filter on false.\nOtherwise second argument must be a set of options.</td></tr>\n<tr><td>isdir</td><td>isdir(file:string):boolean </td><td>Return true if file is a directory.</td></tr>\n<tr><td>isfile</td><td>isfile(file:string):boolean </td><td>Return true if file is a normal file.</td></tr>\n<tr><td>isrelative</td><td>isrelative(file:string):boolean </td><td>Return true if file path is relative.</td></tr>\n<tr><td>join</td><td>join(path:string, path:string):string </td><td>Join two file realpaths, or just second if an absolute path.</td></tr>\n<tr><td>link</td><td>link(src:string, dest:string, ishard:boolean=false) </td><td>Link a file. The second argument is the destination file to be created. If a third bool argument is true, a hard link is created.</td></tr>\n<tr><td>lstat</td><td>lstat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>mkdir</td><td>mkdir(file:string,force:boolean=false) </td><td>Create a directory: force creates subdirs.</td></tr>\n<tr><td>mknod</td><td>mknod(file:string, mode:number, dev:number) </td><td>Create unix device file using mknod.</td></tr>\n<tr><td>mtime</td><td>mtime(file:string):number </td><td>Return file modified time.</td></tr>\n<tr><td>owned</td><td>owned(file:string):boolean </td><td>Return true if file is owned by user.</td></tr>\n<tr><td>pwd</td><td>pwd():string </td><td>Return current directory.</td></tr>\n<tr><td>read</td><td>read(file:string, mode:string='rb'):string </td><td>Read a file.</td></tr>\n<tr><td>readable</td><td>readable(file:string):boolean </td><td>Return true if file is readable.</td></tr>\n<tr><td>readlink</td><td>readlink(file:string):string </td><td>Read file link destination.</td></tr>\n<tr><td>realpath</td><td>realpath(file:string):string </td><td>Return absolute file name minus .., ./ etc.</td></tr>\n<tr><td>remove</td><td>remove(file:string, force:boolean=false) </td><td>Delete a file or direcotry.</td></tr>\n<tr><td>rename</td><td>rename(src:string, dest:string, force:boolean=false) </td><td>Rename a file, with possible overwrite.</td></tr>\n<tr><td>rootname</td><td>rootname(file:string):string </td><td>Return file name minus extension.</td></tr>\n<tr><td>size</td><td>size(file:string):number </td><td>Return size for file.</td></tr>\n<tr><td>stat</td><td>stat(file:string):object </td><td>Return status info for file.</td></tr>\n<tr><td>tail</td><td>tail(file:string):string </td><td>Return file name minus dirname.</td></tr>\n<tr><td>tempfile</td><td>tempfile(file:string) </td><td>Create a temp file.</td></tr>\n<tr><td>truncate</td><td>truncate(file:string, size:number) </td><td>Truncate file.</td></tr>\n<tr><td>type</td><td>type(file:string):string </td><td>Return type of file.</td></tr>\n<tr><td>writable</td><td>writable(file:string):boolean </td><td>Return true if file is writable.</td></tr>\n<tr><td>write</td><td>write(file:string, str:string, mode:string='wb+'):number </td><td>Write a file.</td></tr>\n</table>\n\n\n<a name=\"File.globOptions\"></a>\n<a name=\"File.confOptions\"></a>\n<h2>Options for \"File.glob\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>dir</td><td><i>STRING</i></td><td>The start directory: this path will not be prepended to results.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Maximum directory depth to recurse into.</td><td><i></i></td></tr>\n<tr><td>maxDiscard</td><td><i>INT</i></td><td>Maximum number of items to discard before giving up.</td><td><i></i></td></tr>\n<tr><td>dirFilter</td><td><i>FUNC</i></td><td>Filter function for directories, returning false to discard. @function(dir:string)</td><td><i></i></td></tr>\n<tr><td>filter</td><td><i>FUNC</i></td><td>Filter function to call with each file, returning false to discard. @function(file:string)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>The maximum number of results to return/count: -1 is unlimited (Interp.maxArrayList).</td><td><i></i></td></tr>\n<tr><td>noTypes</td><td><i>STRKEY</i></td><td>Filter files to exclude these \"types\".</td><td><i></i></td></tr>\n<tr><td>prefix</td><td><i>STRKEY</i></td><td>String prefix to prepend to each file in result list.</td><td><i></i></td></tr>\n<tr><td>recurse</td><td><i>BOOL</i></td><td>Recurse into sub-directories.</td><td><i></i></td></tr>\n<tr><td>retCount</td><td><i>BOOL</i></td><td>Return only the count of matches.</td><td><i></i></td></tr>\n<tr><td>tails</td><td><i>BOOL</i></td><td>Returned only tail of path.</td><td><i></i></td></tr>\n<tr><td>types</td><td><i>STRKEY</i></td><td>Filter files to include type: one or more of chars 'fdlpsbc' for file, directory, link, etc.</td><td><i></i></td></tr>\n</table>\n<a name=\"Fileend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Function\"></a>\n\n<hr>\n\n\n<h1>Function</h1>\n\n<font color=red>Synopsis:new Function():function\n\n</font><p>Commands for accessing functions.\n\n\n<h2>Methods for \"Function\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Function</td><td>new Function():function </td><td>Function constructor (unimplemented).</td></tr>\n<tr><td>apply</td><td>apply(thisArg:null|object|function, args:array=void) </td><td>Call function passing args array.</td></tr>\n<tr><td>bind</td><td>bind(thisArg:object|function=null,arg,...) </td><td>Return function that calls bound function prepended with thisArg+arguments.</td></tr>\n<tr><td>call</td><td>call(thisArg:null|object|function, arg1, ...) </td><td>Call function with args.</td></tr>\n</table>\n<a name=\"Functionend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Info\"></a>\n\n<hr>\n\n\n<h1>Info</h1>\n\n<font color=red>Synopsis:Info.method(...)\n\n</font><p>Commands for inspecting internal state information in JSI.\n\n\n<h2>Methods for \"Info\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argv0</td><td>argv0():string|void </td><td>Return initial start script file name.</td></tr>\n<tr><td>cmds</td><td>cmds(val:string|regexp='*', <a href='#Info.cmdsOptions'>options</a>:object=void):array|object </td><td>Return details or list of matching commands.</td></tr>\n<tr><td>completions</td><td>completions(str:string, start:number=0, end:number=void):array </td><td>Return command completions on portion of string from start to end.</td></tr>\n<tr><td>data</td><td>data(val:string|regexp|object=void):array|object </td><td>Return list of matching data (non-functions). Like info.vars(), but does not return function values.</td></tr>\n<tr><td>error</td><td>error():object </td><td>Return file and line number of error (used inside catch).</td></tr>\n<tr><td>event</td><td>event(id:number=void):array|object </td><td>List events or info for 1 event (setTimeout/setInterval). With no args, returns list of all outstanding events.  With one arg, returns infofor the given event id.</td></tr>\n<tr><td>execZip</td><td>execZip():string|void </td><td>If executing a .zip file, return file name.</td></tr>\n<tr><td>executable</td><td>executable():string </td><td>Return name of executable.</td></tr>\n<tr><td>files</td><td>files():array </td><td>Return list of all sourced files.</td></tr>\n<tr><td>funcs</td><td>funcs(string|regexp|object=void):array|object </td><td>Return details or list of matching functions.</td></tr>\n<tr><td>interp</td><td>interp(interp:userobj=void):object </td><td>Return info on given or current interp.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>keywords</td><td>keywords(isSql=false, name:string=void):boolean|array </td><td>Return/lookup reserved keyword.</td></tr>\n<tr><td>level</td><td>level(level:number=void):number|array|object </td><td>Return current level or details of a call-stack frame. With no arg, returns the number of the current stack frame level.\nOtherwise returns details on the specified level.\nThe topmost level is 1, and 0 is the current level, and a negative level translates as relative to the current level.</td></tr>\n<tr><td>locals</td><td>locals(filter:boolean=void):object </td><td>Return locals; use filter=true/false just vars/functions.</td></tr>\n<tr><td>lookup</td><td>lookup(name:string) </td><td>Given string name, lookup and return value, eg: function.</td></tr>\n<tr><td>methods</td><td>methods(val:string|regexp):array|object </td><td>Return functions and commands.</td></tr>\n<tr><td>named</td><td>named(name:string=void):array|userobj </td><td>Returns command names for builtin Objects, eg: 'File', 'Interp', sub-Object names, or the named object.</td></tr>\n<tr><td>options</td><td>options(ctype:boolean=false):array </td><td>Return Option type name, or with true the C type.</td></tr>\n<tr><td>package</td><td>package(pkgName:string):object|null </td><td>Return info about provided package if exists, else null.</td></tr>\n<tr><td>platform</td><td>platform():object </td><td>N/A. Returns general platform information for JSI.</td></tr>\n<tr><td>script</td><td>script(func:function|regexp=void):string|array|void </td><td>Get current script file name, or file containing function.</td></tr>\n<tr><td>scriptDir</td><td>scriptDir():string|void </td><td>Get directory of current script.</td></tr>\n<tr><td>vars</td><td>vars(val:string|regexp|object=void):array|object </td><td>Return details or list of matching variables. Returns all values, data or function.</td></tr>\n<tr><td>version</td><td>version(full:boolean=false):number|object </td><td>JSI version: returns object when full=true.</td></tr>\n</table>\n\n\n<a name=\"Info.cmdsOptions\"></a>\n<a name=\"Info.confOptions\"></a>\n<h2>Options for \"Info.cmds\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Return full path.</td><td><i></i></td></tr>\n<tr><td>constructor</td><td><i>BOOL</i></td><td>Do not exclude constructor.</td><td><i></i></td></tr>\n</table>\n<a name=\"Infoend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Interp\"></a>\n\n<hr>\n\n\n<h1>Interp</h1>\n\n<font color=red>Synopsis:new Interp(options:object=void):userobj\n\n</font><p>Commands for accessing interps.\n\n\n<h2>Methods for \"Interp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Interp</td><td>new Interp(<a href='#new InterpOptions'>options</a>:object=void):userobj </td><td>Create a new interp.</td></tr>\n<tr><td>alias</td><td>alias(name:string=void, func:function|null=void, args:array|null=void, async=false) </td><td>Set/get global alias bindings for command in an interp. With 0 args, returns list of all aliases in interp.\nWith 1 arg returns func for given alias name.\nWith 2 args where arg2 == null, returns args for given alias name .\nWith 3 args, create/update an alias for func and args. \nDelete an alias by creating it with null for both func and args.</td></tr>\n<tr><td>call</td><td>call(funcName:string, args:array, wait:boolean=false) </td><td>Call named function in subinterp. Invoke function in sub-interp with arguments.\nSince interps are not allowed to share objects, data is automatically cleansed by encoding/decoding to/from JSON if required.\nUnless an 'async' parameter is true call is acyncronous.\nOtherwise waits until the sub-interp is idle, to make call and return result.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Interp.confOptions'>options</a>:string|object=void) </td><td>Configure option(s).</td></tr>\n<tr><td>eval</td><td>eval(js:string, async:boolean=false) </td><td>Interpret script within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Returns internal statistics about interp.</td></tr>\n<tr><td>source</td><td>source(file:string, async:boolean=false) </td><td>Interpret file within sub-interp. When the 'async' option is used on a threaded interp, the script is queued as an Event.</td></tr>\n<tr><td>uplevel</td><td>uplevel(js:string, level:number=0) </td><td>Interpret code at the given stack level. The level argument is as returned by Info.level().  Not supported with threads.</td></tr>\n<tr><td>value</td><td>value(var:string, level:number=0) </td><td>Lookup value of variable at stack level.</td></tr>\n</table>\n\n\n<a name=\"new InterpOptions\"></a>\n<a name=\"Interp.confOptions\"></a>\n<h2>Options for \"new Interp\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>args</td><td><i>ARRAY</i></td><td>The console.arguments for interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>asserts</td><td><i>BOOL</i></td><td>Enable assert.</td><td><i></i></td></tr>\n<tr><td>assertMode</td><td><i>STRKEY</i></td><td>Action upon assert failure. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>autoFiles</td><td><i>ARRAY</i></td><td>File(s) to source for loading Jsi_Auto to handle unknown commands.</td><td><i></i></td></tr>\n<tr><td>busyCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp (or noOp) to periodically call.</td><td><i></i></td></tr>\n<tr><td>busyInterval</td><td><i>INT</i></td><td>Call busyCallback command after this many op-code evals (100000).</td><td><i></i></td></tr>\n<tr><td>confFile</td><td><i>STRKEY</i></td><td>Config file of options in non-strict JSON form.</td><td><i>initOnly</i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>debugOpts</td><td><i><a href='#debugOptsOptions'>options</a></i></td><td>Options for debugging.</td><td><i></i></td></tr>\n<tr><td>interactive</td><td><i>BOOL</i></td><td>Force interactive mode. ie. ignore no_interactive flag.</td><td><i>initOnly</i></td></tr>\n<tr><td>hasOpenSSL</td><td><i>BOOL</i></td><td>Is SSL available in WebSocket.</td><td><i>initOnly</i></td></tr>\n<tr><td>historyFile</td><td><i>STRKEY</i></td><td>In interactive mode, file to use for history (~/.jsish_history).</td><td><i>initOnly</i></td></tr>\n<tr><td>isSafe</td><td><i>BOOL</i></td><td>Is this a safe interp (ie. with limited or no file access).</td><td><i>initOnly</i></td></tr>\n<tr><td>jsppChars</td><td><i>STRKEY</i></td><td>Line preprocessor when sourcing files. Line starts with first char, and either ends with it, or matches string.</td><td><i></i></td></tr>\n<tr><td>jsppCallback</td><td><i>FUNC</i></td><td>Command to preprocess lines that match jsppChars. Call func(interpName:string, opCnt:number).</td><td><i></i></td></tr>\n<tr><td>lockTimeout</td><td><i>INT</i></td><td>Thread time-out for mutex lock acquires (milliseconds).</td><td><i></i></td></tr>\n<tr><td>logOpts</td><td><i><a href='#logOptsOptions'>options</a></i></td><td>Options for log output to add file/line/time.</td><td><i></i></td></tr>\n<tr><td>maxDepth</td><td><i>INT</i></td><td>Depth limit of recursive function calls (1000).</td><td><i></i></td></tr>\n<tr><td>maxArrayList</td><td><i>UINT</i></td><td>Maximum array convertable to list (100000).</td><td><i></i></td></tr>\n<tr><td>maxIncDepth</td><td><i>INT</i></td><td>Maximum allowed source/require nesting depth (50).</td><td><i></i></td></tr>\n<tr><td>maxInterpDepth</td><td><i>INT</i></td><td>Maximum nested subinterp create depth (10).</td><td><i></i></td></tr>\n<tr><td>maxUserObjs</td><td><i>INT</i></td><td>Maximum number of 'new' object calls, eg. File, RegExp, etc.</td><td><i></i></td></tr>\n<tr><td>maxOpCnt</td><td><i>INT</i></td><td>Execution limit for op-code evaluation.</td><td><i>initOnly</i></td></tr>\n<tr><td>memDebug</td><td><i>INT</i></td><td>Memory debugging level: 1=summary, 2=detail.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>STRKEY</i></td><td>Optional text name for this interp.</td><td><i></i></td></tr>\n<tr><td>noAutoLoad</td><td><i>BOOL</i></td><td>Disable autoload.</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Interp.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noInput</td><td><i>BOOL</i></td><td>Disable use of console.input().</td><td><i></i></td></tr>\n<tr><td>noLoad</td><td><i>BOOL</i></td><td>Disable load of shared libs.</td><td><i></i></td></tr>\n<tr><td>noNetwork</td><td><i>BOOL</i></td><td>Disable new Socket/WebSocket, or load of builtin MySql.</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Make puts, log, assert, etc use stdout.</td><td><i></i></td></tr>\n<tr><td>noSubInterps</td><td><i>BOOL</i></td><td>Disallow sub-interp creation.</td><td><i></i></td></tr>\n<tr><td>onComplete</td><td><i>FUNC</i></td><td>Function to return commands completions for interactive mode.  Default uses Info.completions . @function(prefix:string, start:number, end:number)</td><td><i></i></td></tr>\n<tr><td>onEval</td><td><i>FUNC</i></td><td>Function to get control for interactive evals. @function(cmd:string)</td><td><i></i></td></tr>\n<tr><td>onExit</td><td><i>FUNC</i></td><td>Command to call in parent on exit, returns true to continue. @function()</td><td><i>initOnly</i></td></tr>\n<tr><td>pkgDirs</td><td><i>ARRAY</i></td><td>list of library directories for require() to search.</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>retValue</td><td><i>VALUE</i></td><td>Return value from last eval.</td><td><i>readOnly</i></td></tr>\n<tr><td>safeMode</td><td><i>STRKEY</i></td><td>In safe mode source() support for pwd and script-dir . (one of: <b>none</b>, <b>read</b>, <b>write</b>, <b>writeRead</b>, <b>lockdown</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>safeReadDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow reads to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeWriteDirs</td><td><i>ARRAY</i></td><td>In safe mode, files/dirs to allow writes to.</td><td><i>initOnly</i></td></tr>\n<tr><td>safeExecPattern</td><td><i>STRKEY</i></td><td>In safe mode, regexp pattern allow exec of commands.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptStr</td><td><i>STRKEY</i></td><td>Interp init script string.</td><td><i>initOnly</i></td></tr>\n<tr><td>scriptFile</td><td><i>STRING</i></td><td>Interp init script file.</td><td><i></i></td></tr>\n<tr><td>stdinStr</td><td><i>STRING</i></td><td>String to use as stdin for console.input().</td><td><i></i></td></tr>\n<tr><td>stdoutStr</td><td><i>STRING</i></td><td>String to collect stdout for puts().</td><td><i></i></td></tr>\n<tr><td>strict</td><td><i>BOOL</i></td><td>Globally enable strict: same as 'use strict' in main program.</td><td><i></i></td></tr>\n<tr><td>subOpts</td><td><i><a href='#subOptsOptions'>options</a></i></td><td>Infrequently used sub-options.</td><td><i></i></td></tr>\n<tr><td>subthread</td><td><i>BOOL</i></td><td>Create a threaded Interp.</td><td><i>initOnly</i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n<tr><td>traceOp</td><td><i>INT</i></td><td>Set debugging level for OPCODE execution.</td><td><i></i></td></tr>\n<tr><td>tracePuts</td><td><i>BOOL</i></td><td>Trace puts by making it use logOpts.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>ARRAY</i></td><td>Type-check control options. (zero or more of: <b>parse</b>, <b>run</b>, <b>all</b>, <b>error</b>, <b>strict</b>, <b>noundef</b>, <b>nowith</b>, <b>funcsig</b>)</td><td><i></i></td></tr>\n<tr><td>typeWarnMax</td><td><i>INT</i></td><td>Type checking is silently disabled after this many warnings (50).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>unitTest</td><td><i>UINT</i></td><td>Unit test control bits: 1=subst, 2=Puts with file:line prefix.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"debugOptsOptions\"></a>\n<h2>Options for \"debugOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>debugCallback</td><td><i>CUSTOM</i></td><td>Command in parent interp for handling debugging.</td><td><i></i></td></tr>\n<tr><td>doContinue</td><td><i>BOOL</i></td><td>Continue execution until breakpoint.</td><td><i></i></td></tr>\n<tr><td>forceBreak</td><td><i>BOOL</i></td><td>Force debugger to break.</td><td><i></i></td></tr>\n<tr><td>includeOnce</td><td><i>BOOL</i></td><td>Source the file only if not already sourced.</td><td><i></i></td></tr>\n<tr><td>includeTrace</td><td><i>BOOL</i></td><td>Trace includes.</td><td><i></i></td></tr>\n<tr><td>minLevel</td><td><i>INT</i></td><td>Disable eval callback for level higher than this.</td><td><i></i></td></tr>\n<tr><td>msgCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle Jsi_LogError/Jsi_LogWarn,...</td><td><i></i></td></tr>\n<tr><td>pkgTrace</td><td><i>BOOL</i></td><td>Trace package loads.</td><td><i></i></td></tr>\n<tr><td>putsCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle puts output.</td><td><i></i></td></tr>\n<tr><td>traceCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to handle traceCall.</td><td><i></i></td></tr>\n<tr><td>testFmtCallback</td><td><i>CUSTOM</i></td><td>Comand in parent interp to format unittest string.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"logOptsOptions\"></a>\n<h2>Options for \"logOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages.</td><td><i></i></td></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages.</td><td><i></i></td></tr>\n<tr><td>Info</td><td><i>BOOL</i></td><td>Enable LogInfo messages.</td><td><i></i></td></tr>\n<tr><td>Warn</td><td><i>BOOL</i></td><td>Enable LogWarn messages.</td><td><i></i></td></tr>\n<tr><td>Error</td><td><i>BOOL</i></td><td>Enable LogError messages.</td><td><i></i></td></tr>\n<tr><td>time</td><td><i>BOOL</i></td><td>Prefix with time.</td><td><i></i></td></tr>\n<tr><td>date</td><td><i>BOOL</i></td><td>Prefix with date.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>BOOL</i></td><td>Ouptut contains file:line.</td><td><i></i></td></tr>\n<tr><td>func</td><td><i>BOOL</i></td><td>Output function.</td><td><i></i></td></tr>\n<tr><td>full</td><td><i>BOOL</i></td><td>Show full file path.</td><td><i></i></td></tr>\n<tr><td>ftail</td><td><i>BOOL</i></td><td>Show tail of file only, even in LogWarn, etc.</td><td><i></i></td></tr>\n<tr><td>before</td><td><i>BOOL</i></td><td>Output file:line before message string.</td><td><i></i></td></tr>\n<tr><td>isUTC</td><td><i>BOOL</i></td><td>Time is to be UTC.</td><td><i></i></td></tr>\n<tr><td>timeFmt</td><td><i>STRKEY</i></td><td>A format string to use with strftime.</td><td><i></i></td></tr>\n<tr><td>chan</td><td><i>USEROBJ</i></td><td>Channel to send output to.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"subOptsOptions\"></a>\n<h2>Options for \"subOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>blacklist</td><td><i>STRKEY</i></td><td>Comma separated modules to disable loading for.</td><td><i>initOnly</i></td></tr>\n<tr><td>compat</td><td><i>BOOL</i></td><td>Ignore unknown options via JSI_OPTS_IGNORE_EXTRA in option parser.</td><td><i></i></td></tr>\n<tr><td>dblPrec</td><td><i>INT</i></td><td>Format precision of double where 0=max, -1=max-1, ... (max-1).</td><td><i></i></td></tr>\n<tr><td>istty</td><td><i>BOOL</i></td><td>Indicates interp is in interactive mode.</td><td><i>readOnly</i></td></tr>\n<tr><td>logColNums</td><td><i>BOOL</i></td><td>Display column numbers in error messages.</td><td><i></i></td></tr>\n<tr><td>logAllowDups</td><td><i>BOOL</i></td><td>Log should not filter out duplicate messages.</td><td><i></i></td></tr>\n<tr><td>mutexUnlock</td><td><i>BOOL</i></td><td>Unlock own mutex when evaling in other interps (true).</td><td><i>initOnly</i></td></tr>\n<tr><td>noproto</td><td><i>BOOL</i></td><td>Disable support of the OOP symbols:  __proto__, prototype, constructor, etc.</td><td><i></i></td></tr>\n<tr><td>noFuncString</td><td><i>BOOL</i></td><td>Disable viewing code body for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noRegex</td><td><i>BOOL</i></td><td>Disable viewing code for functions.</td><td><i>initOnly</i></td></tr>\n<tr><td>noReadline</td><td><i>BOOL</i></td><td>In interactive mode disable use of readline.</td><td><i></i></td></tr>\n<tr><td>outUndef</td><td><i>BOOL</i></td><td>In interactive mode output result values that are undefined.</td><td><i></i></td></tr>\n<tr><td>prompt</td><td><i>STRKEY</i></td><td>Prompt for interactive mode ('$ ').</td><td><i></i></td></tr>\n<tr><td>prompt2</td><td><i>STRKEY</i></td><td>Prompt for interactive mode line continue ('> ').</td><td><i></i></td></tr>\n</table>\n<a name=\"Interpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"JSON\"></a>\n\n<hr>\n\n\n<h1>JSON</h1>\n\n<font color=red>Synopsis:JSON.method(...)\n\n</font><p>Commands for handling JSON data.\n\n\n<h2>Methods for \"JSON\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>check</td><td>check(str:string, strict:boolean=true):boolean </td><td>Return true if str is JSON.</td></tr>\n<tr><td>parse</td><td>parse(str:string, strict:boolean=true) </td><td>Parse JSON and return js.</td></tr>\n<tr><td>stringify</td><td>stringify(value:any,  strict:boolean=true):string </td><td>Return JSON from a js object.</td></tr>\n</table>\n<a name=\"JSONend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Math\"></a>\n\n<hr>\n\n\n<h1>Math</h1>\n\n<font color=red>Synopsis:Math.method(...)\n\n</font><p>Commands performing math operations on numbers.\n\n\n<h2>Methods for \"Math\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>abs</td><td>abs(num:number):number </td><td>Returns the absolute value of x.</td></tr>\n<tr><td>acos</td><td>acos(num:number):number </td><td>Returns the arccosine of x, in radians.</td></tr>\n<tr><td>asin</td><td>asin(num:number):number </td><td>Returns the arcsine of x, in radians.</td></tr>\n<tr><td>atan</td><td>atan(num:number):number </td><td>Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians.</td></tr>\n<tr><td>atan2</td><td>atan2(x:number, y:number):number </td><td>Returns the arctangent of the quotient of its arguments.</td></tr>\n<tr><td>ceil</td><td>ceil(num:number):number </td><td>Returns x, rounded upwards to the nearest integer.</td></tr>\n<tr><td>cos</td><td>cos(num:number):number </td><td>Returns the cosine of x (x is in radians).</td></tr>\n<tr><td>exp</td><td>exp(num:number):number </td><td>Returns the value of Ex.</td></tr>\n<tr><td>floor</td><td>floor(num:number):number </td><td>Returns x, rounded downwards to the nearest integer.</td></tr>\n<tr><td>log</td><td>log(num:number):number </td><td>Returns the natural logarithm (base E) of x.</td></tr>\n<tr><td>max</td><td>max(x:number, y:number, ...):number </td><td>Returns the number with the highest value.</td></tr>\n<tr><td>min</td><td>min(x:number, y:number, ...):number </td><td>Returns the number with the lowest value.</td></tr>\n<tr><td>pow</td><td>pow(x:number, y:number):number </td><td>Returns the value of x to the power of y.</td></tr>\n<tr><td>random</td><td>random():number </td><td>Returns a random number between 0 and 1.</td></tr>\n<tr><td>round</td><td>round(num:number):number </td><td>Rounds x to the nearest integer.</td></tr>\n<tr><td>sin</td><td>sin(num:number):number </td><td>Returns the sine of x (x is in radians).</td></tr>\n<tr><td>sqrt</td><td>sqrt(num:number):number </td><td>Returns the square root of x.</td></tr>\n<tr><td>srand</td><td>srand(seed:number):number </td><td>Set random seed.</td></tr>\n<tr><td>tan</td><td>tan(num:number):number </td><td>Returns the tangent of an angle.</td></tr>\n</table>\n<a name=\"Mathend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"MySql\"></a>\n\n<hr>\n\n\n<h1>MySql</h1>\n\n<font color=red>Synopsis:new MySql(options:object=void):userobj\n\n</font><p>Commands for accessing mysql databases.\n\n\n<h2>Methods for \"MySql\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>MySql</td><td>new MySql(<a href='#new MySqlOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to a MySql database:.</td></tr>\n<tr><td>affectedRows</td><td>affectedRows():number </td><td>Return affected rows.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#MySql.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>errorNo</td><td>errorNo():number </td><td>Return error code returned by most recent call to mysql3_exec().</td></tr>\n<tr><td>errorState</td><td>errorState():string </td><td>Return the mysql error state str.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output.</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>info</td><td>info():object </td><td>Return info about last query.</td></tr>\n<tr><td>lastQuery</td><td>lastQuery():string </td><td>Return info string about most recently executed statement.</td></tr>\n<tr><td>lastRowid</td><td>lastRowid():number </td><td>Return rowid of last insert.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>ping</td><td>ping(noError:boolean=false):number </td><td>Ping connection.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#MySql.queryOptions'>options</a>:function|string|array|object=void) </td><td>Run sql query with input and/or outputs..</td></tr>\n<tr><td>reconnect</td><td>reconnect():void </td><td>Reconnect with current settings.</td></tr>\n<tr><td>reset</td><td>reset():number </td><td>Reset connection.</td></tr>\n</table>\n\n\n<a name=\"new MySqlOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"new MySql\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>database</td><td><i>STRKEY</i></td><td>Database to use.</td><td><i>initOnly</i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>enableMulti</td><td><i>BOOL</i></td><td>Accept muiltiple semi-colon separated statements in eval().</td><td><i>initOnly</i></td></tr>\n<tr><td>errorCnt</td><td><i>INT</i></td><td>Count of errors.</td><td><i>readOnly</i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>host</td><td><i>STRING</i></td><td>IP address or host name for mysqld (default is 127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>maxStmts</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>Name for this db handle.</td><td><i></i></td></tr>\n<tr><td>numStmts</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>password</td><td><i>STRKEY</i></td><td>Database password..</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>IP port for mysqld.</td><td><i>initOnly</i></td></tr>\n<tr><td>reconnect</td><td><i>BOOL</i></td><td>Reconnect.</td><td><i></i></td></tr>\n<tr><td>sslKey</td><td><i>STRING</i></td><td>SSL key.</td><td><i></i></td></tr>\n<tr><td>sslCert</td><td><i>STRING</i></td><td>SSL Cert.</td><td><i></i></td></tr>\n<tr><td>sslCA</td><td><i>STRING</i></td><td>SSL CA.</td><td><i></i></td></tr>\n<tr><td>sslCAPath</td><td><i>STRING</i></td><td>SSL CA path.</td><td><i></i></td></tr>\n<tr><td>sslCipher</td><td><i>STRING</i></td><td>SSL Cipher.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data..</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>STRKEY</i></td><td>Database user name. Default is current user-name..</td><td><i>initOnly</i></td></tr>\n<tr><td>version</td><td><i>DOUBLE</i></td><td>Mysql version number.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"MySql.queryOptions\"></a>\n<a name=\"MySql.confOptions\"></a>\n<h2>Options for \"MySql.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable binds, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>maxString</td><td><i>INT</i></td><td>If not using prefetch, the maximum string value size (0=8K).</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>noNamedParams</td><td><i>BOOL</i></td><td>Disable translating sql to support named params.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non-json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>paramVar</td><td><i>ARRAY</i></td><td>Array var to use for parameters.</td><td><i></i></td></tr>\n<tr><td>prefetch</td><td><i>BOOL</i></td><td>Let client library cache entire results.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (error). (one of: <b>convert</b>, <b>error</b>, <b>warn</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"MySqlend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Number\"></a>\n\n<hr>\n\n\n<h1>Number</h1>\n\n<font color=red>Synopsis:new Number(num:string=0):number\n\n</font><p>Commands for accessing number objects.\n\n\n<h2>Methods for \"Number\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Number</td><td>new Number(num:string=0):number </td><td>Number constructor.</td></tr>\n<tr><td>isFinite</td><td>isFinite():boolean </td><td>Return true if is finite.</td></tr>\n<tr><td>isInteger</td><td>isInteger():boolean </td><td>Return true if is an integer.</td></tr>\n<tr><td>isNaN</td><td>isNaN():boolean </td><td>Return true if is NaN.</td></tr>\n<tr><td>isSafeInteger</td><td>isSafeInteger():boolean </td><td>Return true if is a safe integer.</td></tr>\n<tr><td>toExponential</td><td>toExponential(num:number):string </td><td>Converts a number into an exponential notation.</td></tr>\n<tr><td>toFixed</td><td>toFixed(num:number=0):string </td><td>Formats a number with x numbers of digits after the decimal point.</td></tr>\n<tr><td>toPrecision</td><td>toPrecision(num:number):string </td><td>Formats a number to x length.</td></tr>\n<tr><td>toString</td><td>toString(radix:number=10):string </td><td>Convert to string.</td></tr>\n</table>\n<a name=\"Numberend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Object\"></a>\n\n<hr>\n\n\n<h1>Object</h1>\n\n<font color=red>Synopsis:new Object(val:object&verbar;function|null=void):object\n\n</font><p>Commands for accessing Objects.\n\n\n<h2>Methods for \"Object\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Object</td><td>new Object(val:object|function|null=void):object </td><td>Object constructor.</td></tr>\n<tr><td>create</td><td>create(proto:null|object, properties:object=void):object </td><td>Create a new object with prototype object and properties.</td></tr>\n<tr><td>getPrototypeOf</td><td>getPrototypeOf(name:object|function):function|object </td><td>Return prototype of an object.</td></tr>\n<tr><td>hasOwnProperty</td><td>hasOwnProperty(name:string):boolean </td><td>Returns a true if object has the specified property.</td></tr>\n<tr><td>is</td><td>is(value1, value2):boolean </td><td>Tests if two values are equal.</td></tr>\n<tr><td>isPrototypeOf</td><td>isPrototypeOf(name):boolean </td><td>Tests for an object in another object's prototype chain.</td></tr>\n<tr><td>keys</td><td>keys(obj:object|function=void):array </td><td>Return the keys of an object or array.</td></tr>\n<tr><td>merge</td><td>merge(obj:object|function):object </td><td>Return new object containing merged values.</td></tr>\n<tr><td>propertyIsEnumerable</td><td>propertyIsEnumerable(name):boolean </td><td>Determine if a property is enumerable.</td></tr>\n<tr><td>setPrototypeOf</td><td>setPrototypeOf(name:object, value:object) </td><td>Set prototype of an object.</td></tr>\n<tr><td>toLocaleString</td><td>toLocaleString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>toString</td><td>toString(quote:boolean=false):string </td><td>Convert to string.</td></tr>\n<tr><td>valueOf</td><td>valueOf() </td><td>Returns primitive value.</td></tr>\n</table>\n<a name=\"Objectend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"RegExp\"></a>\n\n<hr>\n\n\n<h1>RegExp</h1>\n\n<font color=red>Synopsis:new RegExp(val:regexp&verbar;string, flags:string):regexp\n\n</font><p>Commands for managing reqular expression objects.\n\n\n<h2>Methods for \"RegExp\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>RegExp</td><td>new RegExp(val:regexp|string, flags:string):regexp </td><td>Create a regexp object.</td></tr>\n<tr><td>exec</td><td>exec(val:string):array|object|null </td><td>return matching string. Perform regexp match checking.  Returns the array of matches.With the global flag g, sets lastIndex and returns next match.</td></tr>\n<tr><td>test</td><td>test(val:string):boolean </td><td>test if a string matches.</td></tr>\n</table>\n<a name=\"RegExpend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Signal\"></a>\n\n<hr>\n\n\n<h1>Signal</h1>\n\n<font color=red>Synopsis:Signal.method(...)\n\n</font><p>Commands for handling unix signals.\n\n\n<h2>Methods for \"Signal\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>alarm</td><td>alarm(secs):number </td><td>Setup alarm in seconds.</td></tr>\n<tr><td>callback</td><td>callback(func:function, sig:number|string):number </td><td>Setup callback handler for signal.</td></tr>\n<tr><td>handle</td><td>handle(sig:number|string=void, ...) </td><td>Set named signals to handle action.</td></tr>\n<tr><td>ignore</td><td>ignore(sig:number|string=void, ...) </td><td>Set named signals to ignore action.</td></tr>\n<tr><td>kill</td><td>kill(pid:number, sig:number|string='SIGTERM'):void </td><td>Send signal to process id.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return names of all signals.</td></tr>\n<tr><td>reset</td><td>reset(sig:number|string=void, ...):array </td><td>Set named signals to default action.</td></tr>\n</table>\n<a name=\"Signalend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Socket\"></a>\n\n<hr>\n\n\n<h1>Socket</h1>\n\n<font color=red>Synopsis:new Socket(options:object=void):userobj\n\n</font><p>Commands for managing Socket server/client connections.\n\n\n<h2>Methods for \"Socket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Socket</td><td>new Socket(<a href='#new SocketOptions'>options</a>:object=void):userobj </td><td>Create socket server/client object.Create a socket server or client object.</td></tr>\n<tr><td>close</td><td>close():void </td><td>Close socket(s).</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Socket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number=void, <a href='#Socket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for a connection id, or return list of ids.</td></tr>\n<tr><td>names</td><td>names():array </td><td>Return list of active ids on server.</td></tr>\n<tr><td>recv</td><td>recv(id:number=void):string </td><td>Recieve data.</td></tr>\n<tr><td>send</td><td>send(id:number, data:string, <a href='#Socket.sendOptions'>options</a>:object=void):void </td><td>Send a socket message to id. Send a message to a (or all if -1) connection.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this socket.</td></tr>\n</table>\n\n\n<a name=\"new SocketOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"new Socket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>Client destination address (127.0.0.0).</td><td><i>initOnly</i></td></tr>\n<tr><td>broadcast</td><td><i>BOOL</i></td><td>Enable broadcast.</td><td><i>initOnly</i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Enable client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Counter for number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createLast</td><td><i>TIME_T</i></td><td>Time of last create.</td><td><i>readOnly</i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Debugging level.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>keepalive</td><td><i>BOOL</i></td><td>Enable keepalive.</td><td><i>initOnly</i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>mcastAddMember</td><td><i>STRING</i></td><td>Multicast add membership: address/interface ('127.0.0.1/0.0.0.0').</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastInterface</td><td><i>STRING</i></td><td>Multicast interface address.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastNoLoop</td><td><i>BOOL</i></td><td>Multicast loopback disable.</td><td><i>initOnly</i></td></tr>\n<tr><td>mcastTtl</td><td><i>INT</i></td><td>Multicast TTL.</td><td><i>initOnly</i></td></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i>initOnly</i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Stop processing update events (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when connection closes. @function(s:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last connection closes. On object delete arg is null. @function(s:userobj|null)</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Socket.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when connection opens. @function(s:userobj, info:object)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call with recieved data. @function(s:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for client dest or server listen.</td><td><i>initOnly</i></td></tr>\n<tr><td>quiet</td><td><i>BOOL</i></td><td>Suppress info messages.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvTimeout</td><td><i>UINT64</i></td><td>Timeout for receive, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>sendTimeout</td><td><i>UINT64</i></td><td>Timeout for send, in microseconds.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcAddress</td><td><i>STRING</i></td><td>Client source address.</td><td><i>initOnly</i></td></tr>\n<tr><td>srcPort</td><td><i>INT</i></td><td>Client source port.</td><td><i>initOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of start.</td><td><i>readOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>timeout</td><td><i>NUMBER</i></td><td>Timeout value in seconds (0.5).</td><td><i>initOnly</i></td></tr>\n<tr><td>tos</td><td><i>INT8</i></td><td>Type-Of-Service value.</td><td><i>initOnly</i></td></tr>\n<tr><td>ttl</td><td><i>INT</i></td><td>Time-To-Live value.</td><td><i>initOnly</i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>udp</td><td><i>BOOL</i></td><td>Protocol is udp.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.idconfOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all socket Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>recvAddr</td><td><i>CUSTOM</i></td><td>Incoming port and address.</td><td><i></i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i></i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i></i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i></i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i></i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Socket.sendOptions\"></a>\n<a name=\"Socket.confOptions\"></a>\n<h2>Options for \"Socket.send\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>noAsync</td><td><i>BOOL</i></td><td>Send is not async.</td><td><i></i></td></tr>\n</table>\n<a name=\"Socketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Sqlite\"></a>\n\n<hr>\n\n\n<h1>Sqlite</h1>\n\n<font color=red>Synopsis:new Sqlite(file:null&verbar;string=void, options:object=void):userobj\n\n</font><p>Commands for accessing sqlite databases.\n\n\n<h2>Methods for \"Sqlite\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>Sqlite</td><td>new Sqlite(file:null|string=void, <a href='#new SqliteOptions'>options</a>:object=void):userobj </td><td>Create a new db connection to the named file or :memory:.</td></tr>\n<tr><td>backup</td><td>backup(file:string, dbname:string='main'):void </td><td>Backup db to file. Open or create a database file named FILENAME.\nTransfer the content of local database DATABASE (default: 'main') into the FILENAME database.</td></tr>\n<tr><td>collate</td><td>collate(name:string, callback:function):void </td><td>Create new SQL collation command.</td></tr>\n<tr><td>complete</td><td>complete(sql:string):boolean </td><td>Return true if sql is complete.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#Sqlite.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>eval</td><td>eval(sql:string):number </td><td>Run sql commands without input/output. Supports multiple semicolon seperated commands.\nVariable binding is NOT performed, results are discarded, and  returns sqlite3_changes()</td></tr>\n<tr><td>exists</td><td>exists(sql:string):boolean </td><td>Execute sql, and return true if there is at least one result value.</td></tr>\n<tr><td>filename</td><td>filename(name:string='main'):string </td><td>Return filename for named or all attached databases.</td></tr>\n<tr><td>func</td><td>func(name:string, callback:function, numArgs:number=void):void </td><td>Register a new function with database.</td></tr>\n<tr><td>import</td><td>import(table:string, file:string, <a href='#Sqlite.importOptions'>options</a>:object=void):number </td><td>Import data from file into table . Import data from a file into table. SqlOptions include the 'separator' to use, which defaults to commas for csv, or tabs otherwise.\nIf a column contains a null string, or the value of 'nullvalue', a null is inserted for the column.\nA 'conflict' is one of the sqlite conflict algorithms:    rollback, abort, fail, ignore, replace\nOn success, return the number of lines processed, not necessarily same as 'changeCnt' due to the conflict algorithm selected. </td></tr>\n<tr><td>interrupt</td><td>interrupt():void </td><td>Interrupt in progress statement.</td></tr>\n<tr><td>onecolumn</td><td>onecolumn(sql:string) </td><td>Execute sql, and return a single value.</td></tr>\n<tr><td>query</td><td>query(sql:string, <a href='#Sqlite.queryOptions'>options</a>:function|string|array|object=void) </td><td>Evaluate an sql query with bindings. Return values in formatted as JSON, HTML, etc. , optionally calling function with a result object</td></tr>\n<tr><td>restore</td><td>restore(file:string, dbname:string):void </td><td>Restore db from file (default db is 'main').    db.restore(FILENAME, ?,DATABASE? ) \nOpen a database file named FILENAME.  Transfer the content of FILENAME into the local database DATABASE (default: 'main').</td></tr>\n<tr><td>transaction</td><td>transaction(callback:function, type:string=void):void </td><td>Call function inside db tranasaction. Type is: 'deferred', 'exclusive', 'immediate'. Start a new transaction (if we are not already in the midst of a transaction) and execute the JS function FUNC.\nAfter FUNC completes, either commit the transaction or roll it back if FUNC throws an exception.\nOr if no new transation was started, do nothing. pass the exception on up the stack.</td></tr>\n</table>\n\n\n<a name=\"new SqliteOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"new Sqlite\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bindWarn</td><td><i>BOOL</i></td><td>Treat failed variable binds as a warning.</td><td><i>initOnly</i></td></tr>\n<tr><td>changeCnt</td><td><i>INT</i></td><td>The number of rows modified, inserted, or deleted by last command.</td><td><i></i></td></tr>\n<tr><td>changeCntAll</td><td><i>INT</i></td><td>Total number of rows modified, inserted, or deleted since db opened.</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>ARRAY</i></td><td>Enable debug trace for various operations. (zero or more of: <b>eval</b>, <b>delete</b>, <b>prepare</b>, <b>step</b>)</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query/eval string to log.</td><td><i></i></td></tr>\n<tr><td>errCnt</td><td><i>INT</i></td><td>Count of errors in script callbacks.</td><td><i>readOnly</i></td></tr>\n<tr><td>errorCode</td><td><i>INT</i></td><td>Numeric error code returned by the most recent call to sqlite3_exec.</td><td><i></i></td></tr>\n<tr><td>forceInt</td><td><i>BOOL</i></td><td>Bind float as int if possible.</td><td><i></i></td></tr>\n<tr><td>noJsonConv</td><td><i>BOOL</i></td><td>Do not JSON auto-convert array and object in CHARJSON columns.</td><td><i></i></td></tr>\n<tr><td>lastInsertId</td><td><i>UINT64</i></td><td>The rowid of last insert.</td><td><i></i></td></tr>\n<tr><td>load</td><td><i>BOOL</i></td><td>Extensions can be loaded.</td><td><i></i></td></tr>\n<tr><td>mutex</td><td><i>STRKEY</i></td><td>Mutex type to use. (one of: <b>default</b>, <b>none</b>, <b>full</b>)</td><td><i>initOnly</i></td></tr>\n<tr><td>name</td><td><i>DSTRING</i></td><td>The dbname to use instead of 'main'.</td><td><i>initOnly</i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of Sqlite.conf to change options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCreate</td><td><i>BOOL</i></td><td>Database is must already exist (false).</td><td><i>initOnly</i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for auth. @function(db:userobj, code:string, descr1:string, decr2:string, dbname:string, trigname:string)</td><td><i></i></td></tr>\n<tr><td>onBusy</td><td><i>FUNC</i></td><td>Function to call when busy. @function(db:userobj, tries:number)</td><td><i></i></td></tr>\n<tr><td>onCommit</td><td><i>FUNC</i></td><td>Function to call on commit. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onNeedCollate</td><td><i>FUNC</i></td><td>Function to call for collation. @function(db:userobj, name:string)</td><td><i></i></td></tr>\n<tr><td>onProfile</td><td><i>FUNC</i></td><td>Function to call for profile. @function(db:userobj, sql:string, time:number)</td><td><i></i></td></tr>\n<tr><td>onProgress</td><td><i>FUNC</i></td><td>Function to call for progress: progressSteps must be >0. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onRollback</td><td><i>FUNC</i></td><td>Function to call for rollback. @function(db:userobj)</td><td><i></i></td></tr>\n<tr><td>onTrace</td><td><i>FUNC</i></td><td>Function to call for trace. @function(db:userobj, sql:string)</td><td><i></i></td></tr>\n<tr><td>onUpdate</td><td><i>FUNC</i></td><td>Function to call for update. @function(db:userobj, op:string, dbname:string, table:string, rowid:number)</td><td><i></i></td></tr>\n<tr><td>onWalHook</td><td><i>FUNC</i></td><td>Function to call for WAL. @function(db:userobj, dbname:string, entry:number)</td><td><i></i></td></tr>\n<tr><td>progressSteps</td><td><i>UINT</i></td><td>Number of steps between calling onProgress: 0 is disabled.</td><td><i></i></td></tr>\n<tr><td>queryOpts</td><td><i><a href='#queryOptsOptions'>options</a></i></td><td>Default options for to use with query().</td><td><i></i></td></tr>\n<tr><td>readonly</td><td><i>BOOL</i></td><td>Database opened in readonly mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>sortCnt</td><td><i>INT</i></td><td>Number of sorts in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stepCnt</td><td><i>INT</i></td><td>Number of steps in most recent operation.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheCnt</td><td><i>INT</i></td><td>Current size of compiled statement cache.</td><td><i>readOnly</i></td></tr>\n<tr><td>stmtCacheMax</td><td><i>INT</i></td><td>Max cache size for compiled statements.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>Sqlite version info.</td><td><i></i></td></tr>\n<tr><td>timeout</td><td><i>INT</i></td><td>Amount of time to wait when file is locked, in ms.</td><td><i></i></td></tr>\n<tr><td>vfs</td><td><i>STRING</i></td><td>VFS to use.</td><td><i>initOnly</i></td></tr>\n</table>\n\n\n<a name=\"queryOptsOptions\"></a>\n<h2>Options for \"queryOpts\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.importOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.import\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row contains column labels.</td><td><i></i></td></tr>\n<tr><td>csv</td><td><i>BOOL</i></td><td>Treat input values as CSV.</td><td><i></i></td></tr>\n<tr><td>conflict</td><td><i>STRKEY</i></td><td>Set conflict resolution. (one of: <b>ROLLBACK</b>, <b>ABORT</b>, <b>FAIL</b>, <b>IGNORE</b>, <b>REPLACE</b>)</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of lines to load.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string.</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string; default is comma if csv, else tabs.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Sqlite.queryOptions\"></a>\n<a name=\"Sqlite.confOptions\"></a>\n<h2>Options for \"Sqlite.query\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function to call with each row result. @function(values:object)</td><td><i></i></td></tr>\n<tr><td>cdata</td><td><i>STRKEY</i></td><td>Name of Cdata array object to use.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>Output query string to log.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>BOOL</i></td><td>First row returned contains column labels.</td><td><i></i></td></tr>\n<tr><td>limit</td><td><i>INT</i></td><td>Maximum number of returned values.</td><td><i></i></td></tr>\n<tr><td>mapundef</td><td><i>BOOL</i></td><td>In variable bind, map an 'undefined' var to null.</td><td><i></i></td></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Set output mode of returned data. (one of: <b>rows</b>, <b>arrays</b>, <b>array1d</b>, <b>list</b>, <b>column</b>, <b>json</b>, <b>json2</b>, <b>html</b>, <b>csv</b>, <b>insert</b>, <b>line</b>, <b>tabs</b>, <b>none</b>)</td><td><i></i></td></tr>\n<tr><td>nocache</td><td><i>BOOL</i></td><td>Disable query cache.</td><td><i></i></td></tr>\n<tr><td>nullvalue</td><td><i>STRKEY</i></td><td>Null string output (for non js/json mode).</td><td><i></i></td></tr>\n<tr><td>objName</td><td><i>STRKEY</i></td><td>Object var name for CREATE/INSERT: replaces %s with fields in query.</td><td><i></i></td></tr>\n<tr><td>objOpts</td><td><i>ARRAY</i></td><td>Options for objName. (zero or more of: <b>getSql</b>, <b>noTypes</b>, <b>noDefaults</b>, <b>nullDefaults</b>)</td><td><i></i></td></tr>\n<tr><td>retChanged</td><td><i>BOOL</i></td><td>Query returns value of sqlite3_changed().</td><td><i></i></td></tr>\n<tr><td>separator</td><td><i>STRKEY</i></td><td>Separator string (for csv and text mode).</td><td><i></i></td></tr>\n<tr><td>typeCheck</td><td><i>STRKEY</i></td><td>Type check mode (warn). (one of: <b>convert</b>, <b>warn</b>, <b>error</b>, <b>disable</b>)</td><td><i></i></td></tr>\n<tr><td>table</td><td><i>STRKEY</i></td><td>Table name for mode=insert.</td><td><i></i></td></tr>\n<tr><td>values</td><td><i>ARRAY</i></td><td>Values for ? bind parameters.</td><td><i></i></td></tr>\n<tr><td>width</td><td><i>CUSTOM</i></td><td>In column mode, set column widths.</td><td><i></i></td></tr>\n</table>\n<a name=\"Sqliteend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"String\"></a>\n\n<hr>\n\n\n<h1>String</h1>\n\n<font color=red>Synopsis:new String(str):string\n\n</font><p>Commands for accessing string objects..\n\n\n<h2>Methods for \"String\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>String</td><td>new String(str):string </td><td>String constructor.</td></tr>\n<tr><td>charAt</td><td>charAt(index:number):string </td><td>Return char at index.</td></tr>\n<tr><td>charCodeAt</td><td>charCodeAt(index:number):number </td><td>Return char code at index.</td></tr>\n<tr><td>concat</td><td>concat(str:string, ...):string </td><td>Append one or more strings.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(...):string </td><td>Return string for char codes.</td></tr>\n<tr><td>indexOf</td><td>indexOf(str:string, start:number):number </td><td>Return index of char.</td></tr>\n<tr><td>lastIndexOf</td><td>lastIndexOf(str:string, start:number):number </td><td>Return index of last char.</td></tr>\n<tr><td>map</td><td>map(strMap:array, nocase:boolean=false):string </td><td>Replaces characters in string based on the key-value pairs in strMap.</td></tr>\n<tr><td>match</td><td>match(pattern:regexp|string):array|null </td><td>Return array of matches.</td></tr>\n<tr><td>repeat</td><td>repeat(count:number):string </td><td>Return count copies of string.</td></tr>\n<tr><td>replace</td><td>replace(pattern:regexp|string, replace:string|function):string </td><td>Regex/string replacement. If the replace argument is a function, it is called with match,p1,p2,...,offset,string.  If called function is known to have 1 argument, it is called with just the match.</td></tr>\n<tr><td>search</td><td>search(pattern:regexp|string):number </td><td>Return index of first char matching pattern.</td></tr>\n<tr><td>slice</td><td>slice(start:number, end:number):string </td><td>Return section of string.</td></tr>\n<tr><td>split</td><td>split(char:string|null=void):array </td><td>Split on char and return Array. When char is omitted splits on bytes.  When char==null splits on whitespace and removes empty elements.</td></tr>\n<tr><td>substr</td><td>substr(start:number, length:number):string </td><td>Return substring.</td></tr>\n<tr><td>substring</td><td>substring(start:number, end:number):string </td><td>Return substring.</td></tr>\n<tr><td>toLocaleLowerCase</td><td>toLocaleLowerCase():string </td><td>Lower case.</td></tr>\n<tr><td>toLocaleUpperCase</td><td>toLocaleUpperCase():string </td><td>Upper case.</td></tr>\n<tr><td>toLowerCase</td><td>toLowerCase():string </td><td>Return lower cased string.</td></tr>\n<tr><td>toTitle</td><td>toTitle(chars:string):string </td><td>Make first char upper case.</td></tr>\n<tr><td>toUpperCase</td><td>toUpperCase():string </td><td>Return upper cased string.</td></tr>\n<tr><td>trim</td><td>trim(chars:string):string </td><td>Trim chars.</td></tr>\n<tr><td>trimLeft</td><td>trimLeft(chars:string):string </td><td>Trim chars from left.</td></tr>\n<tr><td>trimRight</td><td>trimRight(chars:string):string </td><td>Trim chars from right.</td></tr>\n</table>\n<a name=\"Stringend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"System\"></a>\n\n<hr>\n\n\n<h1>System</h1>\n\n<font color=red>Synopsis:System.method(...)\n\n</font><p>Builtin system commands. All methods are exported as global.\n\n\n<h2>Methods for \"System\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#System.assertOptions'>options</a>:object=void):void </td><td>Throw or output msg if expr is false. Assert does nothing by default, but can be enabled with \"use assert\" or setting Interp.asserts.</td></tr>\n<tr><td>clearInterval</td><td>clearInterval(id:number):void </td><td>Delete event id returned from setInterval/setTimeout/info.events().</td></tr>\n<tr><td>decodeURI</td><td>decodeURI(val:string):string </td><td>Decode an HTTP URL.</td></tr>\n<tr><td>encodeURI</td><td>encodeURI(val:string):string </td><td>Encode an HTTP URL.</td></tr>\n<tr><td>exec</td><td>exec(val:string, <a href='#System.execOptions'>options</a>:string|object=void) </td><td>Execute an OS command. If the command ends with '&', set the 'bg' option to true.\nThe second argument can be a string, which is the same as setting the 'inputStr' option.\nBy default, returns the string output, unless the 'bg', 'inputStr', 'retCode' or 'retAll' options are used</td></tr>\n<tr><td>exit</td><td>exit(code:number=0):void </td><td>Exit the current interpreter.</td></tr>\n<tr><td>format</td><td>format(format:string, ...):string </td><td>Printf style formatting: adds %q and %S.</td></tr>\n<tr><td>isFinite</td><td>isFinite(val):boolean </td><td>Return true if is a finite number.</td></tr>\n<tr><td>isMain</td><td>isMain():boolean </td><td>Return true if current script was the main script invoked from command-line.</td></tr>\n<tr><td>isNaN</td><td>isNaN(val):boolean </td><td>Return true if not a number.</td></tr>\n<tr><td>load</td><td>load(shlib:string):void </td><td>Load a shared executable and invoke its _Init call.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as puts, but includes file:line.</td></tr>\n<tr><td>matchObj</td><td>matchObj(obj:object, match:string=void, partial=false, noerror=false):string|boolean </td><td>Object field names/types matching. Single arg generates string.</td></tr>\n<tr><td>noOp</td><td>noOp() </td><td>A No-Op. A zero overhead command call that is useful for debugging.</td></tr>\n<tr><td>parseFloat</td><td>parseFloat(val):number </td><td>Convert string to a double.</td></tr>\n<tr><td>parseInt</td><td>parseInt(val:any, base:number=10):number </td><td>Convert string to an integer.</td></tr>\n<tr><td>parseOpts</td><td>parseOpts(self:object|userobj, options:object, conf:object|null|undefined) </td><td>Parse options.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Formatted output to stdout.</td></tr>\n<tr><td>provide</td><td>provide(name:string|function=void, version:number|string=1.0, opts:object|function=void):void </td><td>Provide a package for use with require. Default is the file tail-rootname.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Output one or more values to stdout. Each argument is quoted.  Use Interp.logOpts to control source line and/or timestamps output.</td></tr>\n<tr><td>quote</td><td>quote(val:string):string </td><td>Return quoted string.</td></tr>\n<tr><td>require</td><td>require(name:string=void, version:number|string=1, <a href='#System.requireOptions'>options</a>:object=void):number|array|object </td><td>Load/query packages. With no arguments, returns the list of all loaded packages.\nWith one argument, loads the package (if necessary) and returns its version.\nWith two arguments, returns object containing: version, loadFile, func.\nA third argument sets options for package or module.\nNote an error is thrown if requested version is greater than actual version.</td></tr>\n<tr><td>runMain</td><td>runMain(cmd:string|null|function=void, conf:array=undefined) </td><td>If isMain invokes runModule.</td></tr>\n<tr><td>runModule</td><td>runModule(cmd:string|null|function=void, conf:array=undefined) </td><td>Invoke named module. If name is empty, uses file basename. If isMain and no args givine parses console.args.</td></tr>\n<tr><td>setInterval</td><td>setInterval(callback:function, ms:number):number </td><td>Setup recurring function to run every given millisecs.</td></tr>\n<tr><td>setTimeout</td><td>setTimeout(callback:function, ms:number):number </td><td>Setup function to run after given millisecs.</td></tr>\n<tr><td>sleep</td><td>sleep(secs:number=1.0):void </td><td>sleep for N milliseconds, minimum .001.</td></tr>\n<tr><td>source</td><td>source(val:string|array, <a href='#System.sourceOptions'>options</a>:object=void) </td><td>Load and evaluate source files: trailing '/' appends PARENTDIR.jsi.</td></tr>\n<tr><td>strftime</td><td>strftime(num:number=null, <a href='#System.strftimeOptions'>options</a>:string|object=void):string </td><td>Format numeric time (in ms) to a string. Null or no value will use current time.</td></tr>\n<tr><td>strptime</td><td>strptime(val:string=void, <a href='#System.strptimeOptions'>options</a>:string|object=void):number </td><td>Parse time from string and return ms time since 1970-01-01 in UTC, or NaN.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>unload</td><td>unload(shlib:string):void </td><td>Unload a shared executable and invoke its _Done call.</td></tr>\n<tr><td>update</td><td>update(<a href='#System.updateOptions'>options</a>:number|object=void):number </td><td>Service all events, eg. setInterval/setTimeout. Returns the number of events processed. Events are processed until minTime (in milliseconds) is exceeded, or forever if -1.\nThe default minTime is 0, meaning return as soon as no events can be processed. A positive mintime will result in sleeps between event checks.</td></tr>\n</table>\n\n\n<a name=\"System.assertOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.execOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>bg</td><td><i>BOOL</i></td><td>Run command in background using system() and return OS code.</td><td><i></i></td></tr>\n<tr><td>chdir</td><td><i>STRING</i></td><td>Change to directory.</td><td><i></i></td></tr>\n<tr><td>inputStr</td><td><i>STRING</i></td><td>Use string as input and return OS code.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Suppress all OS errors.</td><td><i></i></td></tr>\n<tr><td>noRedir</td><td><i>BOOL</i></td><td>Disable redirect and shell escapes in command.</td><td><i></i></td></tr>\n<tr><td>noShell</td><td><i>BOOL</i></td><td>Do not use native popen which invokes via /bin/sh.</td><td><i></i></td></tr>\n<tr><td>trim</td><td><i>BOOL</i></td><td>Trim trailing whitespace from output.</td><td><i></i></td></tr>\n<tr><td>retAll</td><td><i>BOOL</i></td><td>Return the OS return code and data as an object.</td><td><i></i></td></tr>\n<tr><td>retCode</td><td><i>BOOL</i></td><td>Return only the OS return code.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.requireOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.require\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>Debug</td><td><i>BOOL</i></td><td>Enable LogDebug messages for module.</td><td><i></i></td></tr>\n<tr><td>Test</td><td><i>BOOL</i></td><td>Enable LogTest messages for module.</td><td><i></i></td></tr>\n<tr><td>Trace</td><td><i>BOOL</i></td><td>Enable LogTrace messages for module.</td><td><i></i></td></tr>\n<tr><td>coverage</td><td><i>BOOL</i></td><td>On exit generate detailed code coverage for function calls (with profile).</td><td><i></i></td></tr>\n<tr><td>profile</td><td><i>BOOL</i></td><td>On exit generate profile of function calls.</td><td><i></i></td></tr>\n<tr><td>traceCall</td><td><i>ARRAY</i></td><td>Trace commands. (zero or more of: <b>funcs</b>, <b>cmds</b>, <b>new</b>, <b>return</b>, <b>args</b>, <b>notrunc</b>, <b>noparent</b>, <b>full</b>, <b>before</b>)</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.sourceOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.source\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>autoIndex</td><td><i>BOOL</i></td><td>Look for and load Jsi_Auto.jsi auto-index file.</td><td><i></i></td></tr>\n<tr><td>exists</td><td><i>BOOL</i></td><td>Source file only if exists.</td><td><i></i></td></tr>\n<tr><td>global</td><td><i>BOOL</i></td><td>File is to be sourced in global frame rather than local.</td><td><i></i></td></tr>\n<tr><td>isMain</td><td><i>BOOL</i></td><td>Coerce to true the value of Info.isMain().</td><td><i></i></td></tr>\n<tr><td>level</td><td><i>UINT</i></td><td>Frame to source file in.</td><td><i></i></td></tr>\n<tr><td>noError</td><td><i>BOOL</i></td><td>Ignore errors in sourced file.</td><td><i></i></td></tr>\n<tr><td>once</td><td><i>BOOL</i></td><td>Source file only if not already sourced (Default: Interp.debugOpts.includeOnce).</td><td><i></i></td></tr>\n<tr><td>trace</td><td><i>BOOL</i></td><td>Trace include statements (Default: Interp.debugOpts.includeTrace).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strftimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strftime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.strptimeOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.strptime\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>secs</td><td><i>BOOL</i></td><td>Time is seconds (out for parse, in for format).</td><td><i></i></td></tr>\n<tr><td>fmt</td><td><i>STRKEY</i></td><td>Format string for time.</td><td><i></i></td></tr>\n<tr><td>iso</td><td><i>BOOL</i></td><td>ISO fmt plus milliseconds ie: %FT%T.%f.</td><td><i></i></td></tr>\n<tr><td>utc</td><td><i>BOOL</i></td><td>Time is utc (in for parse, out for format).</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"System.updateOptions\"></a>\n<a name=\"System.confOptions\"></a>\n<h2>Options for \"System.update\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>maxEvents</td><td><i>INT</i></td><td>Maximum number of events to process (or -1 for all).</td><td><i></i></td></tr>\n<tr><td>maxPasses</td><td><i>INT</i></td><td>Maximum passes through event queue.</td><td><i></i></td></tr>\n<tr><td>minTime</td><td><i>INT</i></td><td>Minimum milliseconds before returning, or -1 to loop forever (default is 0).</td><td><i></i></td></tr>\n<tr><td>sleep</td><td><i>INT</i></td><td>Time to sleep time (in milliseconds) between event checks. Default is 1.</td><td><i></i></td></tr>\n</table>\n<a name=\"Systemend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Util\"></a>\n\n<hr>\n\n\n<h1>Util</h1>\n\n<font color=red>Synopsis:Util.method(...)\n\n</font><p>Utilities commands.\n\n\n<h2>Methods for \"Util\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>argArray</td><td>argArray(arg:any|undefined):array|null </td><td>Coerces non-null to an array, if necessary.</td></tr>\n<tr><td>base64</td><td>base64(val:string, decode:boolean=false):string </td><td>Base64 encode/decode a string.</td></tr>\n<tr><td>complete</td><td>complete(val:string):boolean </td><td>Return true if string is complete command with balanced braces, etc.</td></tr>\n<tr><td>crc32</td><td>crc32(val:string, crcSeed=0):number </td><td>Calculate 32-bit CRC.</td></tr>\n<tr><td>decrypt</td><td>decrypt(val:string, key:string):string </td><td>Decrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>encrypt</td><td>encrypt(val:string, key:string):string </td><td>Encrypt data using BTEA encryption. Keys that are not 16 bytes use the MD5 hash of the key.</td></tr>\n<tr><td>fromCharCode</td><td>fromCharCode(code:number):string </td><td>Return char with given character code.</td></tr>\n<tr><td>getenv</td><td>getenv(name:string=void):string|object|void </td><td>Get one or all environment.</td></tr>\n<tr><td>getpid</td><td>getpid(parent:boolean=false):number </td><td>Get process/parent id.</td></tr>\n<tr><td>getuser</td><td>getuser():object </td><td>Get userid info.</td></tr>\n<tr><td>hash</td><td>hash(val:string, <a href='#Util.hashOptions'>options</a>|object=void):string </td><td>Return hash (default SHA256) of string/file.</td></tr>\n<tr><td>hexStr</td><td>hexStr(val:string, decode:boolean=false):string </td><td>Hex encode/decode a string.</td></tr>\n<tr><td>setenv</td><td>setenv(name:string, value:string=void) </td><td>Set/get an environment var.</td></tr>\n<tr><td>sqlValues</td><td>sqlValues(name:string, var:object=void) </td><td>Get object values for SQL.</td></tr>\n<tr><td>times</td><td>times(callback:function|boolean, count:number=1):number </td><td>Call function count times and return execution time in microseconds.</td></tr>\n<tr><td>verConvert</td><td>verConvert(ver:string|number, zeroTrim:number=0):number|string|null </td><td>Convert a version to/from a string/number, or return null if not a version. For string output zeroTrim says how many trailing .0 to trim (0-2).</td></tr>\n</table>\n\n\n<a name=\"Util.hashOptions\"></a>\n<a name=\"Util.confOptions\"></a>\n<h2>Options for \"Util.hash\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Read data from file and append to str.</td><td><i></i></td></tr>\n<tr><td>hashcash</td><td><i>UINT</i></td><td>Search for a hash with this many leading zero bits by appending :nonce (Proof-Of-Work).</td><td><i></i></td></tr>\n<tr><td>noHex</td><td><i>BOOL</i></td><td>Return binary digest, without conversion to hex chars.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type of hash. (one of: <b>sha256</b>, <b>sha1</b>, <b>md5</b>, <b>sha3_224</b>, <b>sha3_384</b>, <b>sha3_512</b>, <b>sha3_256</b>)</td><td><i></i></td></tr>\n</table>\n<a name=\"Utilend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Vfs\"></a>\n\n<hr>\n\n\n<h1>Vfs</h1>\n\n<font color=red>Synopsis:Vfs.method(...)\n\n</font><p>Commands for creating in memory readonly Virtual file-systems.\n\n\n<h2>Methods for \"Vfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>conf</td><td>conf(mount:string, string|<a href='#Vfs.confOptions'>options</a>:object|string=void) </td><td>Configure mount.</td></tr>\n<tr><td>exec</td><td>exec(cmd:string) </td><td>Safe mode exec for VFS support cmds eg. fossil info/ls/cat.</td></tr>\n<tr><td>fileconf</td><td>fileconf(mount:string, path:string, <a href='#Vfs.fileconfOptions'>options</a>:string|object=void) </td><td>Configure file info which is same info as in fileList.</td></tr>\n<tr><td>list</td><td>list():array </td><td>Return list of all vfs mounts.</td></tr>\n<tr><td>mount</td><td>mount(type:string, file:string, param:object=void):string </td><td>Mount fossil file as given VFS type name, returning the mount point: frontend for vmount.</td></tr>\n<tr><td>type</td><td>type(type:string=void, <a href='#Vfs.typeOptions'>options</a>:object|null=void) </td><td>Set/get/delete VFS type name.</td></tr>\n<tr><td>unmount</td><td>unmount(mount:string):void </td><td>Unmount a VFS.</td></tr>\n<tr><td>vmount</td><td>vmount(<a href='#Vfs.vmountOptions'>options</a>:object=void):string </td><td>Create and mount a VFS, returning the mount point.</td></tr>\n</table>\n\n\n<a name=\"Vfs.confOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.conf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.execOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.exec\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.fileconfOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.fileconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>data</td><td><i>STRING</i></td><td>Data for file.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRKEY</i></td><td>File pathname.</td><td><i>required</i></td></tr>\n<tr><td>perms</td><td><i>UINT32</i></td><td>Permissions for file.</td><td><i></i></td></tr>\n<tr><td>size</td><td><i>SSIZE_T</i></td><td>Size of file.</td><td><i></i></td></tr>\n<tr><td>timestamp</td><td><i>TIME_T</i></td><td>Timestamp of file.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.typeOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.type\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i>required</i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"Vfs.vmountOptions\"></a>\n<a name=\"Vfs.confOptions\"></a>\n<h2>Options for \"Vfs.vmount\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>callback</td><td><i>FUNC</i></td><td>Function implementing VFS. @function(op:string, mount:string, arg:string|object|null)</td><td><i></i></td></tr>\n<tr><td>extra</td><td><i>OBJ</i></td><td>Extra info, typically used by predefined VFS type.</td><td><i></i></td></tr>\n<tr><td>noAddDirs</td><td><i>BOOL</i></td><td>Disable auto-adding of directories; needed by File.glob.</td><td><i></i></td></tr>\n<tr><td>file</td><td><i>STRING</i></td><td>Fossil file to mount.</td><td><i></i></td></tr>\n<tr><td>fileList</td><td><i>ARRAY</i></td><td>List of files in the VFS (from listFunc).</td><td><i></i></td></tr>\n<tr><td>info</td><td><i>OBJ</i></td><td>Info for VFS that is stored upon init.</td><td><i></i></td></tr>\n<tr><td>mount</td><td><i>STRING</i></td><td>Mount point for the VFS.</td><td><i></i></td></tr>\n<tr><td>noPatches</td><td><i>BOOL</i></td><td>Ignore patchlevel updates: accepts only X.Y releases.</td><td><i></i></td></tr>\n<tr><td>param</td><td><i>OBJ</i></td><td>Optional 3rd argument passed to mount.</td><td><i></i></td></tr>\n<tr><td>type</td><td><i>STRKEY</i></td><td>Type for predefined VFS.</td><td><i></i></td></tr>\n<tr><td>user</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>STRKEY</i></td><td>Version to mount.</td><td><i></i></td></tr>\n</table>\n<a name=\"Vfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"WebSocket\"></a>\n\n<hr>\n\n\n<h1>WebSocket</h1>\n\n<font color=red>Synopsis:new WebSocket(options:object=void):userobj\n\n</font><p>Commands for managing WebSocket server/client connections.\n\n\n<h2>Methods for \"WebSocket\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>WebSocket</td><td>new WebSocket(<a href='#new WebSocketOptions'>options</a>:object=void):userobj </td><td>Create websocket server/client object.Create a websocket server/client object.  The server serves out pages to a web browser,\nwhich can use javascript to upgrade connection to a bidirectional websocket.</td></tr>\n<tr><td>conf</td><td>conf(<a href='#WebSocket.confOptions'>options</a>:string|object=void) </td><td>Configure options.</td></tr>\n<tr><td>file</td><td>file(name:string=void):array|void </td><td>Add file to hash, or with no args return file hash.</td></tr>\n<tr><td>handler</td><td>handler(extension:string=void, cmd:string|function=void, flags:number=0):string|array|function|void </td><td>Get/Set handler command for an extension. With no args, returns list of handlers.  With one arg, returns value for that handler.\nOtherwise, sets the handler. When cmd is a string, the call is via runModule([cmd], arg).\nIf a cmd is a function, it is called with a single arg: the file name.</td></tr>\n<tr><td>header</td><td>header(id:number, name:string=void):string|array|void </td><td>Get one or all input headers for connect id.</td></tr>\n<tr><td>idconf</td><td>idconf(id:number, <a href='#WebSocket.idconfOptions'>options</a>:string|object=void) </td><td>Configure options for connect id.</td></tr>\n<tr><td>ids</td><td>ids(name:string=void):array </td><td>Return list of ids, or lookup one id.</td></tr>\n<tr><td>query</td><td>query(id:number, name:string=void):string|object|void </td><td>Get one or all query values for connect id.</td></tr>\n<tr><td>send</td><td>send(id:number, data:any):void </td><td>Send a websocket message to id. Send a message to one (or all connections if -1). If not already a string, msg is formatted as JSON prior to the send.</td></tr>\n<tr><td>status</td><td>status():object|void </td><td>Return libwebsocket server status.</td></tr>\n<tr><td>unalias</td><td>unalias(path:string):string|void </td><td>Return alias reverse lookup.</td></tr>\n<tr><td>update</td><td>update():void </td><td>Service events for just this websocket.</td></tr>\n<tr><td>version</td><td>version():string </td><td>Runtime library version string.</td></tr>\n</table>\n\n\n<a name=\"new WebSocketOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"new WebSocket\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>address</td><td><i>STRING</i></td><td>In client-mode the address to connect to (127.0.0.1).</td><td><i></i></td></tr>\n<tr><td>bufferPwr2</td><td><i>INT</i></td><td>Tune the recv/send buffer: value is a power of 2 in [0-20] (16).</td><td><i></i></td></tr>\n<tr><td>client</td><td><i>BOOL</i></td><td>Run in client mode.</td><td><i>initOnly</i></td></tr>\n<tr><td>clientHost</td><td><i>STRKEY</i></td><td>Override host name for client.</td><td><i></i></td></tr>\n<tr><td>clientOrigin</td><td><i>STRKEY</i></td><td>Override client origin (origin).</td><td><i></i></td></tr>\n<tr><td>debug</td><td><i>INT</i></td><td>Set debug level. Setting this to 512 will turn on max libwebsocket log levels.</td><td><i></i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>formParams</td><td><i>STRKEY</i></td><td>Comma seperated list of upload form param names ('text,send,file,upload').</td><td><i>readOnly</i></td></tr>\n<tr><td>extHandlers</td><td><i>BOOL</i></td><td>Setup builtin extension-handlers, ie: .htmli, .cssi, .jsi, .mdi.</td><td><i>initOnly</i></td></tr>\n<tr><td>extOpts</td><td><i>OBJ</i></td><td>Key/value store for extension-handlers options.</td><td><i>initOnly</i></td></tr>\n<tr><td>getRegexp</td><td><i>REGEXP</i></td><td>Call onGet() only if Url matches pattern.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser: name/value pairs.</td><td><i>initOnly</i></td></tr>\n<tr><td>jsiFnPattern</td><td><i>STRKEY</i></td><td>A glob-match pattern for files to which is appended 'window.jsiWebSocket=true;' (jsig*.js).</td><td><i>readOnly</i></td></tr>\n<tr><td>interface</td><td><i>STRING</i></td><td>Interface for server to listen on, eg. 'eth0' or 'lo'.</td><td><i>initOnly</i></td></tr>\n<tr><td>local</td><td><i>BOOL</i></td><td>Limit connections to localhost addresses on the 127 network.</td><td><i></i></td></tr>\n<tr><td>localhostName</td><td><i>STRKEY</i></td><td>Client name used by localhost connections ('localhost').</td><td><i></i></td></tr>\n<tr><td>maxConnects</td><td><i>INT</i></td><td>In server mode, max number of client connections accepted.</td><td><i></i></td></tr>\n<tr><td>maxDownload</td><td><i>INT</i></td><td>Max size of file download.</td><td><i></i></td></tr>\n<tr><td>maxUpload</td><td><i>INT</i></td><td>Max size of file upload will accept.</td><td><i></i></td></tr>\n<tr><td>mimeTypes</td><td><i>OBJ</i></td><td>Object providing map of file extensions to mime types. eg. {txt:'text/plain', bb:'text/bb'}.</td><td><i>initOnly</i></td></tr>\n<tr><td>modifySecs</td><td><i>UINT</i></td><td>Seconds between checking for modified files with onModify (2).</td><td><i></i></td></tr>\n<tr><td>noConfig</td><td><i>BOOL</i></td><td>Disable use of conf() to change options after options after create.</td><td><i>initOnly</i></td></tr>\n<tr><td>noCompress</td><td><i>BOOL</i></td><td>Disable per-message-deflate extension which can truncate large msgs.</td><td><i></i></td></tr>\n<tr><td>noUpdate</td><td><i>BOOL</i></td><td>Disable update event-processing (eg. to exit).</td><td><i></i></td></tr>\n<tr><td>noWebsock</td><td><i>BOOL</i></td><td>Serve html, but disallow websocket upgrade.</td><td><i>initOnly</i></td></tr>\n<tr><td>noWarn</td><td><i>BOOL</i></td><td>Quietly ignore file related errors.</td><td><i></i></td></tr>\n<tr><td>onAuth</td><td><i>FUNC</i></td><td>Function to call for http basic authentication. @function(ws:userobj, id:number, url:string, userpass:string)</td><td><i></i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onCloseLast</td><td><i>FUNC</i></td><td>Function to call when last websock connection closes. On object delete arg is null. @function(ws:userobj|null)</td><td><i></i></td></tr>\n<tr><td>onFilter</td><td><i>FUNC</i></td><td>Function to call on a new connection: return false to kill connection. @function(ws:userobj, id:number, url:string, ishttp:boolean)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onModify</td><td><i>FUNC</i></td><td>Function to call when a served-out-file is modified. @function(ws:userobj, file:string)</td><td><i>initOnly</i></td></tr>\n<tr><td>onOpen</td><td><i>FUNC</i></td><td>Function to call when the websocket connection occurs. @function(ws:userobj, id:number)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>pathAliases</td><td><i>OBJ</i></td><td>Path alias lookups.</td><td><i>initOnly</i></td></tr>\n<tr><td>port</td><td><i>INT</i></td><td>Port for server to listen on (8080).</td><td><i>initOnly</i></td></tr>\n<tr><td>post</td><td><i>STRING</i></td><td>Post string to serve.</td><td><i>initOnly</i></td></tr>\n<tr><td>protocol</td><td><i>STRKEY</i></td><td>Name of protocol (ws/wss).</td><td><i></i></td></tr>\n<tr><td>realm</td><td><i>STRKEY</i></td><td>Realm for basic auth (jsish).</td><td><i></i></td></tr>\n<tr><td>recvBufMax</td><td><i>INT</i></td><td>Size limit of a websocket message.</td><td><i>initOnly</i></td></tr>\n<tr><td>recvBufTimeout</td><td><i>INT</i></td><td>Timeout for recv of a websock msg.</td><td><i>initOnly</i></td></tr>\n<tr><td>redirMax</td><td><i>BOOL</i></td><td>Temporarily disable redirects when see more than this in 10 minutes.</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>server</td><td><i>STRKEY</i></td><td>String to send out int the header SERVER (jsiWebSocket).</td><td><i></i></td></tr>\n<tr><td>ssiExts</td><td><i>OBJ</i></td><td>Object map of file extensions to apply SSI.  eg. {myext:true, shtml:false} .</td><td><i>initOnly</i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistical data.</td><td><i>readOnly</i></td></tr>\n<tr><td>startTime</td><td><i>TIME_T</i></td><td>Time of websocket start.</td><td><i>readOnly</i></td></tr>\n<tr><td>includeFile</td><td><i>STRKEY</i></td><td>Default file when no extension given (include.shtml).</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>urlPrefix</td><td><i>STRKEY</i></td><td>Prefix in url to strip from path; for reverse proxy.</td><td><i></i></td></tr>\n<tr><td>urlRedirect</td><td><i>STRKEY</i></td><td>Redirect when no url or / is given. Must match urlPrefix, if given.</td><td><i></i></td></tr>\n<tr><td>use_ssl</td><td><i>BOOL</i></td><td>Use https (for client).</td><td><i>initOnly</i></td></tr>\n<tr><td>useridPass</td><td><i>STRKEY</i></td><td>The USERID:PASSWORD to use for basic authentication.</td><td><i></i></td></tr>\n<tr><td>version</td><td><i>OBJ</i></td><td>WebSocket version info.</td><td><i>readOnly</i></td></tr>\n</table>\n\n\n<a name=\"WebSocket.idconfOptions\"></a>\n<a name=\"WebSocket.confOptions\"></a>\n<h2>Options for \"WebSocket.idconf\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>clientIP</td><td><i>STRKEY</i></td><td>Client IP Address.</td><td><i>readOnly</i></td></tr>\n<tr><td>clientName</td><td><i>STRKEY</i></td><td>Client hostname.</td><td><i>readOnly</i></td></tr>\n<tr><td>echo</td><td><i>BOOL</i></td><td>LogInfo outputs all websock Send/Recv messages.</td><td><i></i></td></tr>\n<tr><td>headers</td><td><i>ARRAY</i></td><td>Headers to send to browser on connection: name/value pairs.</td><td><i></i></td></tr>\n<tr><td>isWebsock</td><td><i>BOOL</i></td><td>Is a websocket connection.</td><td><i></i></td></tr>\n<tr><td>key</td><td><i>STRBUF</i></td><td>String key lookup in ids command for SSI echo ${#}.</td><td><i>readOnly</i></td></tr>\n<tr><td>onClose</td><td><i>FUNC</i></td><td>Function to call when the websocket connection closes. @function(ws:userobj|null, id:number)</td><td><i></i></td></tr>\n<tr><td>onGet</td><td><i>FUNC</i></td><td>Function to call to server handle http-get. @function(ws:userobj, id:number, url:string, query:array)</td><td><i></i></td></tr>\n<tr><td>onUnknown</td><td><i>FUNC</i></td><td>Function to call to server out content when no file exists. @function(ws:userobj, id:number, url:string, args:array)</td><td><i></i></td></tr>\n<tr><td>onRecv</td><td><i>FUNC</i></td><td>Function to call when websock data recieved. @function(ws:userobj, id:number, data:string)</td><td><i></i></td></tr>\n<tr><td>onUpload</td><td><i>FUNC</i></td><td>Function to call handle http-post. @function(ws:userobj, id:number, filename:string, data:string, startpos:number, complete:boolean)</td><td><i></i></td></tr>\n<tr><td>rootdir</td><td><i>STRING</i></td><td>Directory to serve html from (\".\").</td><td><i></i></td></tr>\n<tr><td>stats</td><td><i><a href='#statsOptions'>options</a></i></td><td>Statistics for connection.</td><td><i>readOnly</i></td></tr>\n<tr><td>query</td><td><i>ARRAY</i></td><td>Uri arg values for connection.</td><td><i></i></td></tr>\n<tr><td>queryObj</td><td><i>OBJ</i></td><td>Uri arg values for connection as an object.</td><td><i></i></td></tr>\n<tr><td>udata</td><td><i>OBJ</i></td><td>User data.</td><td><i></i></td></tr>\n<tr><td>url</td><td><i>DSTRING</i></td><td>Url for connection.</td><td><i></i></td></tr>\n<tr><td>username</td><td><i>STRING</i></td><td>The login userid for this connection.</td><td><i></i></td></tr>\n</table>\n\n\n<a name=\"statsOptions\"></a>\n<h2>Options for \"stats\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>connectCnt</td><td><i>INT</i></td><td>Number of active connections.</td><td><i>readOnly</i></td></tr>\n<tr><td>createTime</td><td><i>TIME_T</i></td><td>Time created.</td><td><i></i></td></tr>\n<tr><td>eventCnt</td><td><i>INT</i></td><td>Number of events of any type.</td><td><i></i></td></tr>\n<tr><td>eventLast</td><td><i>TIME_T</i></td><td>Time of last event of any type.</td><td><i></i></td></tr>\n<tr><td>httpCnt</td><td><i>INT</i></td><td>Number of http reqs.</td><td><i></i></td></tr>\n<tr><td>httpLast</td><td><i>TIME_T</i></td><td>Time of last http reqs.</td><td><i></i></td></tr>\n<tr><td>isBinary</td><td><i>BOOL</i></td><td>Connection recv data is binary.</td><td><i>readOnly</i></td></tr>\n<tr><td>isFinal</td><td><i>BOOL</i></td><td>Final data for current message was recieved.</td><td><i>readOnly</i></td></tr>\n<tr><td>msgQLen</td><td><i>INT</i></td><td>Number of messages in input queue.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvCnt</td><td><i>INT</i></td><td>Number of recieves.</td><td><i>readOnly</i></td></tr>\n<tr><td>recvLast</td><td><i>TIME_T</i></td><td>Time of last recv.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirLast</td><td><i>TIME_T</i></td><td>Time of last redirect.</td><td><i>readOnly</i></td></tr>\n<tr><td>redirCnt</td><td><i>INT</i></td><td>Count of redirects.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentLast</td><td><i>TIME_T</i></td><td>Time of last send.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrCnt</td><td><i>INT</i></td><td>Number of sends.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>sentErrLast</td><td><i>TIME_T</i></td><td>Time of last sendErr.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadCnt</td><td><i>INT</i></td><td>Number of uploads.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadEnd</td><td><i>TIME_T</i></td><td>Time of upload end.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadLast</td><td><i>TIME_T</i></td><td>Time of last upload input.</td><td><i>readOnly</i></td></tr>\n<tr><td>uploadStart</td><td><i>TIME_T</i></td><td>Time of upload start.</td><td><i>readOnly</i></td></tr>\n</table>\n<a name=\"WebSocketend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"Zvfs\"></a>\n\n<hr>\n\n\n<h1>Zvfs</h1>\n\n<font color=red>Synopsis:Zvfs.method(...)\n\n</font><p>Commands for mounting and accessing .zip files as a filesystem.\n\n\n<h2>Methods for \"Zvfs\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>append</td><td>append(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Like 'create()', but appends to an existing archive (with no dup checking).</td></tr>\n<tr><td>create</td><td>create(archive:string, filelist:array, path:string|null=void, filelist:array=void, path:string|null=void, ...):void </td><td>Create a zip with the given files in prefix path. This command creates a zip archive and adds files to it. Files are relative the given 'path', or the current directory. If the destignation file already exist but is not an archive (eg. an executable), zip data is appended to the end of the file. If the existing file is already an archive, an error will be thrown. To truncate an existing archive, use zvfs.truncate(). Or use zvfs.append() instead. \n   zvfs.create('foo.zip',['main.js', 'bar.js'], 'src', ['a.html', 'css/a.css'], 'html');</td></tr>\n<tr><td>deflate</td><td>deflate(data:string):string </td><td>Compress string using zlib deflate.</td></tr>\n<tr><td>inflate</td><td>inflate(data:string):string </td><td>Uncompress string using zlib inflate.</td></tr>\n<tr><td>list</td><td>list(archive:string):array </td><td>List files in archive. Return contents of zip directory as an array of arrays. The first element contains the labels, ie: \n[ 'Name', 'Special', 'Offset', 'Bytes', 'BytesCompressed' ] </td></tr>\n<tr><td>mount</td><td>mount(archive:string, mountdir:string=void):string </td><td>Mount zip on mount point. Read a ZIP archive and make entries in the virutal file hash table for all files contained therein.</td></tr>\n<tr><td>names</td><td>names(mountdir:string=void):array </td><td>Return all zvfs mounted zips, or archive for specified mount. Given an mount point argument, returns the archive for it. Otherwise, returns an array of mount points</td></tr>\n<tr><td>offset</td><td>offset(archive:string):number </td><td>Return the start offset of zip data. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>stat</td><td>stat(filename:string):object </td><td>Return details on file in zvfs mount. Return details about the given file in the ZVFS.  The information consists of (1) the name of the ZIP archive that contains the file, (2) the size of the file after decompressions, (3) the compressed size of the file, and (4) the offset of the compressed data in the archive.</td></tr>\n<tr><td>truncate</td><td>truncate(archive:string, noerror:boolean=false):number </td><td>Truncate zip data from archive. Opens and scans the file to determine start of zip data and truncate this off the end of the file.  For ordinary zip archives, the resulting truncated file will be of zero length. If an optional bool argument can disable errors. In any case, the start offset of zip data (or 0) is returned.</td></tr>\n<tr><td>unmount</td><td>unmount(archive:string):void </td><td>Unmount zip.</td></tr>\n</table>\n<a name=\"Zvfsend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n<a name=\"console\"></a>\n\n<hr>\n\n\n<h1>console</h1>\n\n<font color=red>Synopsis:console.method(...)\n\n</font><p>Console input and output to stderr.\n\n\n<h2>Methods for \"console\"</h2>\n<table border=\"1\"class=\"cmdstbl table\">\n<tr><th>Method</th><th>Prototype</th><th>Description</th></tr>\n<tr><td>assert</td><td>assert(expr:boolean|number|function, msg:string=void, <a href='#console.assertOptions'>options</a>:object=void):void </td><td>Same as System.assert().</td></tr>\n<tr><td>error</td><td>error(val, ...):void </td><td>Same as log.</td></tr>\n<tr><td>input</td><td>input():string|void </td><td>Read input from the console.</td></tr>\n<tr><td>log</td><td>log(val, ...):void </td><td>Same as System.puts, but goes to stderr and includes file:line.</td></tr>\n<tr><td>printf</td><td>printf(format:string, ...):void </td><td>Same as System.printf but goes to stderr.</td></tr>\n<tr><td>puts</td><td>puts(val, ...):void </td><td>Same as System.puts, but goes to stderr.</td></tr>\n<tr><td>warn</td><td>warn(val, ...):void </td><td>Same as log.</td></tr>\n</table>\n\n\n<a name=\"console.assertOptions\"></a>\n<a name=\"console.confOptions\"></a>\n<h2>Options for \"console.assert\"</h2>\n<table border=\"1\" class=\"optstbl table\">\n<tr><th>Option</th> <th>Type</th> <th>Description</th><th>Flags</th></tr>\n<tr><td>mode</td><td><i>STRKEY</i></td><td>Action when assertion fails. Default from Interp.assertMode. (one of: <b>throw</b>, <b>log</b>, <b>puts</b>)</td><td><i></i></td></tr>\n<tr><td>noStderr</td><td><i>BOOL</i></td><td>Logged msg to stdout. Default from Interp.noStderr.</td><td><i></i></td></tr>\n</table>\n<a name=\"consoleend\"></a>\n<p><a href=\"#TOC\">Return to top</a>\n</nowiki><p>\n"], "filenames": ["md/Reference.md", "src/jsi.h", "src/jsiArray.c", "src/jsiCData.c", "src/jsiInt.h", "src/jsiInterp.c", "src/jsiObj.c", "src/jsiValue.c", "tools/protos.jsi", "www/reference.wiki"], "buggy_code_start_loc": [603, 7, 270, 1279, 1262, 103, 79, 1039, 1, 636], "buggy_code_end_loc": [604, 8, 271, 1281, 1263, 1486, 423, 1377, 2, 637], "fixing_code_start_loc": [603, 7, 270, 1279, 1262, 103, 79, 1039, 1, 636], "fixing_code_end_loc": [604, 8, 271, 1281, 1263, 1485, 423, 1377, 2, 637], "type": "CWE-190", "message": "Integer overflow vulnerability in function Jsi_ObjArraySizer in jsish before 3.0.8, allows remote attackers to execute arbitrary code.", "other": {"cve": {"id": "CVE-2020-22874", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-13T15:15:08.457", "lastModified": "2021-07-15T12:55:09.603", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow vulnerability in function Jsi_ObjArraySizer in jsish before 3.0.8, allows remote attackers to execute arbitrary code."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de enteros en la funci\u00f3n Jsi_ObjArraySizer en jsish versiones anteriores a 3.0.8, permite a atacantes remotos ejecutar c\u00f3digo arbitrario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jsish:jsish:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.8", "matchCriteriaId": "F7B5CBE8-C60A-451B-88C5-630F33C398CE"}]}]}], "references": [{"url": "https://github.com/pcmacdon/jsish/commit/858da537bde4de9d8c92466d5a866505310bc328", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pcmacdon/jsish/issues/5", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pcmacdon/jsish/commit/858da537bde4de9d8c92466d5a866505310bc328"}}