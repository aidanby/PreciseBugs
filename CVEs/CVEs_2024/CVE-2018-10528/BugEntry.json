{"buggy_code": ["/* -*- C++ -*-\n * File: libraw_cxx.cpp\n * Copyright 2008-2017 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n *\n * LibRaw C++ interface (implementation)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include <math.h>\n#include <errno.h>\n#include <float.h>\n#include <new>\n#include <exception>\n#include <sys/types.h>\n#include <sys/stat.h>\n#if !defined(_WIN32) && !defined(__MINGW32__)\n#include <netinet/in.h>\n#else\n#include <winsock2.h>\n#endif\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#ifdef USE_ZLIB\n#include <zlib.h>\n#endif\n\n\n\n#ifdef USE_RAWSPEED\n#include \"../RawSpeed/rawspeed_xmldata.cpp\"\n#include <RawSpeed/StdAfx.h>\n#include <RawSpeed/FileMap.h>\n#include <RawSpeed/RawParser.h>\n#include <RawSpeed/RawDecoder.h>\n#include <RawSpeed/CameraMetaData.h>\n#include <RawSpeed/ColorFilterArray.h>\n#endif\n\n#ifdef USE_DNGSDK\n#include \"dng_host.h\"\n#include \"dng_negative.h\"\n#include \"dng_simple_image.h\"\n#include \"dng_info.h\"\n#endif\n\n#include \"libraw_xtrans_compressed.cpp\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n  void default_memory_callback(void *,const char *file,const char *where)\n  {\n    fprintf (stderr,\"%s: Out of memory in %s\\n\", file?file:\"unknown file\", where);\n  }\n\n  void default_data_callback(void*,const char *file, const int offset)\n  {\n    if(offset < 0)\n      fprintf (stderr,\"%s: Unexpected end of file\\n\", file?file:\"unknown file\");\n    else\n      fprintf (stderr,\"%s: data corrupted at %d\\n\",file?file:\"unknown file\",offset);\n  }\n  const char *libraw_strerror(int e)\n  {\n    enum LibRaw_errors errorcode = (LibRaw_errors)e;\n    switch(errorcode)\n      {\n      case        LIBRAW_SUCCESS:\n        return \"No error\";\n      case        LIBRAW_UNSPECIFIED_ERROR:\n        return \"Unspecified error\";\n      case        LIBRAW_FILE_UNSUPPORTED:\n        return \"Unsupported file format or not RAW file\";\n      case        LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:\n        return \"Request for nonexisting image number\";\n      case        LIBRAW_OUT_OF_ORDER_CALL:\n        return \"Out of order call of libraw function\";\n      case    LIBRAW_NO_THUMBNAIL:\n        return \"No thumbnail in file\";\n      case    LIBRAW_UNSUPPORTED_THUMBNAIL:\n        return \"Unsupported thumbnail format\";\n      case LIBRAW_INPUT_CLOSED:\n        return \"No input stream, or input stream closed\";\n      case    LIBRAW_UNSUFFICIENT_MEMORY:\n        return \"Unsufficient memory\";\n      case    LIBRAW_DATA_ERROR:\n        return \"Corrupted data or unexpected EOF\";\n      case    LIBRAW_IO_ERROR:\n        return \"Input/output error\";\n      case LIBRAW_CANCELLED_BY_CALLBACK:\n        return \"Cancelled by user callback\";\n      case LIBRAW_BAD_CROP:\n        return \"Bad crop box\";\n      default:\n        return \"Unknown error code\";\n      }\n  }\n\n#ifdef __cplusplus\n}\n#endif\n\n#define Sigma_X3F   22\n\nconst double LibRaw_constants::xyz_rgb[3][3] =\n{\n    { 0.412453, 0.357580, 0.180423 },\n    { 0.212671, 0.715160, 0.072169 },\n    { 0.019334, 0.119193, 0.950227 }\n};\n\nconst float LibRaw_constants::d65_white[3] =  { 0.950456f, 1.0f, 1.088754f };\n\n#define P1 imgdata.idata\n#define S imgdata.sizes\n#define O imgdata.params\n#define C imgdata.color\n#define T imgdata.thumbnail\n#define IO libraw_internal_data.internal_output_params\n#define ID libraw_internal_data.internal_data\n\n#define EXCEPTION_HANDLER(e) do{                        \\\n    /* fprintf(stderr,\"Exception %d caught\\n\",e);*/     \\\n    switch(e)                                           \\\n      {                                                 \\\n      case LIBRAW_EXCEPTION_ALLOC:                      \\\n        recycle();                                      \\\n        return LIBRAW_UNSUFFICIENT_MEMORY;              \\\n      case LIBRAW_EXCEPTION_DECODE_RAW:                 \\\n      case LIBRAW_EXCEPTION_DECODE_JPEG:                \\\n        recycle();                                      \\\n        return LIBRAW_DATA_ERROR;                       \\\n      case LIBRAW_EXCEPTION_DECODE_JPEG2000:            \\\n        recycle();                                      \\\n        return LIBRAW_DATA_ERROR;                       \\\n      case LIBRAW_EXCEPTION_IO_EOF:                     \\\n      case LIBRAW_EXCEPTION_IO_CORRUPT:                 \\\n        recycle();                                      \\\n        return LIBRAW_IO_ERROR;                                 \\\n      case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:              \\\n        recycle();                                              \\\n        return LIBRAW_CANCELLED_BY_CALLBACK;                    \\\n      case LIBRAW_EXCEPTION_BAD_CROP:                           \\\n        recycle();                                              \\\n        return LIBRAW_BAD_CROP;                                 \\\n      default:                                                  \\\n        return LIBRAW_UNSPECIFIED_ERROR;                        \\\n      }                                                         \\\n  }while(0)\n\nconst char* LibRaw::version() { return LIBRAW_VERSION_STR;}\nint LibRaw::versionNumber() { return LIBRAW_VERSION; }\nconst char* LibRaw::strerror(int p) { return libraw_strerror(p);}\n\nunsigned LibRaw::capabilities()\n{\n\tunsigned ret = 0;\n#ifdef USE_RAWSPEED\n\tret |= LIBRAW_CAPS_RAWSPEED;\n#endif\n#ifdef USE_DNGSDK\n\tret |= LIBRAW_CAPS_DNGSDK;\n#endif\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n\tret |= LIBRAW_CAPS_DEMOSAICSGPL2;\n#endif\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL3\n\tret |= LIBRAW_CAPS_DEMOSAICSGPL3;\n#endif\n\treturn ret;\n}\n\nunsigned LibRaw:: parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char** list)\n{\n  if(!list) return 0;\n  unsigned index = 0;\n  for(int i=0; i< limit; i++)\n    {\n      if(!list[i]) break;\n      if(strlen(list[i])<10) continue;\n      char *string =  (char*)malloc(strlen(list[i])+1);\n\t  strcpy(string,list[i]);\n      char *start = string;\n      memset(&table[index],0,sizeof(table[0]));\n      for(int j = 0; start && j < 14; j++)\n\t{\n\t  char *end = strchr(start,',');\n\t  if(end) { *end = 0; end++; } // move to next char\n\t  while(isspace(*start) && *start) start++; // skip leading spaces?\n\t  unsigned val = strtol(start,0,10);\n\t  switch(j)\n\t    {\n\t    case 0:  table[index].fsize = val; break;\n\t    case 1:  table[index].rw = val;    break;\n\t    case 2:  table[index].rh = val;    break;\n\t    case 3:  table[index].lm = val;    break;\n\t    case 4:  table[index].tm = val;    break;\n\t    case 5:  table[index].rm = val;    break;\n\t    case 6:  table[index].bm = val;    break;\n\t    case 7:  table[index].lf = val;    break;\n\t    case 8:  table[index].cf = val;    break;\n\t    case 9:  table[index].max = val;    break;\n\t    case 10:  table[index].flags = val;    break;\n\t    case 11: strncpy(table[index].t_make,start,sizeof(table[index].t_make)-1);    break;\n\t    case 12: strncpy(table[index].t_model,start,sizeof(table[index].t_model)-1);    break;\n\t    case 13:  table[index].offset = val;    break;\n\t    default: break;\n\t    }\n\t  start = end;\n\t}\n      free(string);\n      if(table[index].t_make[0])\n\t  index++;\n    }\n  return index;\n}\n\nvoid LibRaw::derror()\n{\n  if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)\n    {\n      if (libraw_internal_data.internal_data.input->eof())\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),-1);\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        }\n      else\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),\n                                                    libraw_internal_data.internal_data.input->tell());\n          //throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        }\n    }\n  libraw_internal_data.unpacker_data.data_error++;\n}\n\nvoid LibRaw::dcraw_clear_mem(libraw_processed_image_t* p)\n{\n    if(p) ::free(p);\n}\n\nint LibRaw::is_sraw() { return load_raw == &LibRaw::canon_sraw_load_raw || load_raw == &LibRaw::nikon_load_sraw ; }\nint LibRaw::is_coolscan_nef() { return load_raw == &LibRaw::nikon_coolscan_load_raw;}\n\nint LibRaw::is_nikon_sraw(){\n  return load_raw == &LibRaw::nikon_load_sraw;\n}\nint LibRaw::sraw_midpoint() {\n  if (load_raw == &LibRaw::canon_sraw_load_raw) return 8192;\n  else if (load_raw == &LibRaw::nikon_load_sraw) return 2048;\n  else return 0;\n}\n\n\n#ifdef USE_RAWSPEED\nusing namespace RawSpeed;\nclass CameraMetaDataLR : public CameraMetaData\n{\npublic:\n  CameraMetaDataLR() : CameraMetaData() {}\n  CameraMetaDataLR(char *filename) : CameraMetaData(filename){}\n  CameraMetaDataLR(char *data, int sz);\n};\n\nCameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData() {\n  ctxt = xmlNewParserCtxt();\n  if (ctxt == NULL) {\n    ThrowCME(\"CameraMetaData:Could not initialize context.\");\n  }\n\n  xmlResetLastError();\n  doc = xmlCtxtReadMemory(ctxt, data,sz, \"\", NULL, XML_PARSE_DTDVALID);\n\n  if (doc == NULL) {\n    ThrowCME(\"CameraMetaData: XML Document could not be parsed successfully. Error was: %s\", ctxt->lastError.message);\n  }\n\n  if (ctxt->valid == 0) {\n    if (ctxt->lastError.code == 0x5e) {\n      // printf(\"CameraMetaData: Unable to locate DTD, attempting to ignore.\");\n    } else {\n      ThrowCME(\"CameraMetaData: XML file does not validate. DTD Error was: %s\", ctxt->lastError.message);\n    }\n  }\n\n  xmlNodePtr cur;\n  cur = xmlDocGetRootElement(doc);\n  if (xmlStrcmp(cur->name, (const xmlChar *) \"Cameras\")) {\n    ThrowCME(\"CameraMetaData: XML document of the wrong type, root node is not cameras.\");\n    return;\n  }\n\n  cur = cur->xmlChildrenNode;\n  while (cur != NULL) {\n    if ((!xmlStrcmp(cur->name, (const xmlChar *)\"Camera\"))) {\n      Camera *camera = new Camera(doc, cur);\n      addCamera(camera);\n\n      // Create cameras for aliases.\n      for (unsigned int i = 0; i < camera->aliases.size(); i++) {\n        addCamera(new Camera(camera, i));\n      }\n    }\n    cur = cur->next;\n  }\n  if (doc)\n    xmlFreeDoc(doc);\n  doc = 0;\n  if (ctxt)\n    xmlFreeParserCtxt(ctxt);\n  ctxt = 0;\n}\n\n#define RAWSPEED_DATA_COUNT (sizeof(_rawspeed_data_xml)/sizeof(_rawspeed_data_xml[0]))\nstatic CameraMetaDataLR* make_camera_metadata()\n{\n  int len = 0,i;\n  for(i=0;i<RAWSPEED_DATA_COUNT;i++)\n    if(_rawspeed_data_xml[i])\n      {\n        len+=strlen(_rawspeed_data_xml[i]);\n      }\n  char *rawspeed_xml = (char*)calloc(len+1,sizeof(_rawspeed_data_xml[0][0]));\n  if(!rawspeed_xml) return NULL;\n  int offt = 0;\n  for(i=0;i<RAWSPEED_DATA_COUNT;i++)\n    if(_rawspeed_data_xml[i])\n      {\n        int ll = strlen(_rawspeed_data_xml[i]);\n        if(offt+ll>len) break;\n        memmove(rawspeed_xml+offt,_rawspeed_data_xml[i],ll);\n        offt+=ll;\n      }\n  rawspeed_xml[offt]=0;\n  CameraMetaDataLR *ret=NULL;\n  try {\n    ret = new CameraMetaDataLR(rawspeed_xml,offt);\n  } catch (...) {\n    // Mask all exceptions\n  }\n  free(rawspeed_xml);\n  return ret;\n}\n\n#endif\n\n#define ZERO(a) memset(&a,0,sizeof(a))\n\nstatic void cleargps(libraw_gps_info_t*q)\n{\n\tfor (int i = 0; i < 3; i++)\n\t\tq->latitude[i] = q->longtitude[i] = q->gpstimestamp[i] = 0.f;\n\tq->altitude = 0.f;\n\tq->altref = q->latref = q->longref = q->gpsstatus = q->gpsparsed = 0;\n}\n\nLibRaw:: LibRaw(unsigned int flags)\n{\n  double aber[4] = {1,1,1,1};\n  double gamm[6] = { 0.45,4.5,0,0,0,0 };\n  unsigned greybox[4] =  { 0, 0, UINT_MAX, UINT_MAX };\n  unsigned cropbox[4] =  { 0, 0, UINT_MAX, UINT_MAX };\n#ifdef DCRAW_VERBOSE\n  verbose = 1;\n#else\n  verbose = 0;\n#endif\n  ZERO(imgdata);\n\n  cleargps(&imgdata.other.parsed_gps);\n  ZERO(libraw_internal_data);\n  ZERO(callbacks);\n\n  _rawspeed_camerameta = _rawspeed_decoder = NULL;\n  dnghost =  NULL;\n  _x3f_data = NULL;\n\n#ifdef USE_RAWSPEED\n  CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()\n  _rawspeed_camerameta = static_cast<void*>(camerameta);\n#endif\n  callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL:  &default_memory_callback;\n  callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK)? NULL : &default_data_callback;\n  callbacks.exif_cb = NULL; // no default callback\n  memmove(&imgdata.params.aber,&aber,sizeof(aber));\n  memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));\n  memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));\n  memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));\n\n  imgdata.params.bright=1;\n  imgdata.params.use_camera_matrix=1;\n  imgdata.params.user_flip=-1;\n  imgdata.params.user_black=-1;\n  imgdata.params.user_cblack[0]=imgdata.params.user_cblack[1]=imgdata.params.user_cblack[2]=imgdata.params.user_cblack[3]=-1000001;\n  imgdata.params.user_sat=-1;\n  imgdata.params.user_qual=-1;\n  imgdata.params.output_color=1;\n  imgdata.params.output_bps=8;\n  imgdata.params.use_fuji_rotate=1;\n  imgdata.params.exp_shift = 1.0;\n  imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;\n  imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n  imgdata.params.use_rawspeed = 1;\n  imgdata.params.use_dngsdk = LIBRAW_DNG_DEFAULT;\n  imgdata.params.no_auto_scale = 0;\n  imgdata.params.no_interpolation = 0;\n  imgdata.params.raw_processing_options = LIBRAW_PROCESSING_DP2Q_INTERPOLATERG|LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF | LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT;\n  imgdata.params.sony_arw2_posterization_thr = 0;\n  imgdata.params.green_matching = 0;\n  imgdata.params.custom_camera_strings=0;\n  imgdata.params.coolscan_nef_gamma = 1.0f;\n  imgdata.parent_class = this;\n  imgdata.progress_flags = 0;\n  imgdata.color.baseline_exposure = -999.f;\n  _exitflag = 0;\n  tls = new LibRaw_TLS;\n  tls->init();\n\n  interpolate_bayer = 0;\n  interpolate_xtrans = 0;\n}\n\nint LibRaw::set_rawspeed_camerafile(char *filename)\n{\n#ifdef USE_RAWSPEED\n  try\n    {\n      CameraMetaDataLR *camerameta = new CameraMetaDataLR(filename);\n      if(_rawspeed_camerameta)\n        {\n          CameraMetaDataLR *d = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);\n          delete d;\n        }\n      _rawspeed_camerameta = static_cast<void*>(camerameta);\n    }\n  catch (...)\n    {\n      //just return error code\n      return -1;\n    }\n#endif\n  return 0;\n}\n\nLibRaw::~LibRaw()\n{\n  recycle();\n  delete tls;\n#ifdef USE_RAWSPEED\n  if(_rawspeed_camerameta)\n    {\n      CameraMetaDataLR *cmeta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);\n      delete cmeta;\n      _rawspeed_camerameta = NULL;\n    }\n#endif\n}\n\nvoid* LibRaw:: malloc(size_t t)\n{\n    void *p = memmgr.malloc(t);\n\tif(!p)\n\t\tthrow LIBRAW_EXCEPTION_ALLOC;\n    return p;\n}\nvoid* LibRaw:: realloc(void *q,size_t t)\n{\n    void *p = memmgr.realloc(q,t);\n\tif(!p)\n\t\tthrow LIBRAW_EXCEPTION_ALLOC;\n    return p;\n}\n\n\nvoid* LibRaw::       calloc(size_t n,size_t t)\n{\n    void *p = memmgr.calloc(n,t);\n\tif(!p)\n\t\tthrow LIBRAW_EXCEPTION_ALLOC;\n    return p;\n}\nvoid  LibRaw::      free(void *p)\n{\n    memmgr.free(p);\n}\n\nvoid LibRaw:: recycle_datastream()\n{\n  if(libraw_internal_data.internal_data.input && libraw_internal_data.internal_data.input_internal)\n    {\n      delete libraw_internal_data.internal_data.input;\n      libraw_internal_data.internal_data.input = NULL;\n    }\n  libraw_internal_data.internal_data.input_internal = 0;\n}\n\nvoid x3f_clear(void*);\n\n\nvoid LibRaw:: recycle()\n{\n  recycle_datastream();\n#define FREE(a) do { if(a) { free(a); a = NULL;} }while(0)\n\n  FREE(imgdata.image);\n  FREE(imgdata.thumbnail.thumb);\n  FREE(libraw_internal_data.internal_data.meta_data);\n  FREE(libraw_internal_data.output_data.histogram);\n  FREE(libraw_internal_data.output_data.oprof);\n  FREE(imgdata.color.profile);\n  FREE(imgdata.rawdata.ph1_cblack);\n  FREE(imgdata.rawdata.ph1_rblack);\n  FREE(imgdata.rawdata.raw_alloc);\n  FREE(imgdata.idata.xmpdata);\n#undef FREE\n  ZERO(imgdata.sizes);\n  ZERO(imgdata.idata);\n  ZERO(imgdata.makernotes);\n  ZERO(imgdata.color);\n  ZERO(imgdata.other);\n  ZERO(imgdata.thumbnail);\n  ZERO(imgdata.rawdata);\n  imgdata.makernotes.olympus.OlympusCropID = -1;\n  cleargps(&imgdata.other.parsed_gps);\n  imgdata.color.baseline_exposure = -999.f;\n\n  imgdata.makernotes.fuji.FujiExpoMidPointShift = -999.f;\n  imgdata.makernotes.fuji.FujiDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiFilmMode = 0xffff;\n  imgdata.makernotes.fuji.FujiDynamicRangeSetting = 0xffff;\n  imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiAutoDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FocusMode = 0xffff;\n  imgdata.makernotes.fuji.AFMode = 0xffff;\n  imgdata.makernotes.fuji.FocusPixel[0] = imgdata.makernotes.fuji.FocusPixel[1] = 0xffff;\n  imgdata.makernotes.fuji.ImageStabilization[0] = imgdata.makernotes.fuji.ImageStabilization[1] = imgdata.makernotes.fuji.ImageStabilization[2] = 0xffff;\n\n  imgdata.makernotes.sony.SonyCameraType = 0xffff;\n  imgdata.color.dng_color[0].illuminant = imgdata.color.dng_color[1].illuminant = 0xffff;\n\n  for(int i = 0; i < 4; i++)\n   imgdata.color.dng_levels.analogbalance[i]=\n   imgdata.color.dng_levels.analogbalance[i]=1.0f;\n\n  ZERO(libraw_internal_data);\n  ZERO(imgdata.lens);\n  imgdata.lens.makernotes.CanonFocalUnits = 1;\n  imgdata.lens.makernotes.LensID = 0xffffffffffffffffULL;\n  ZERO(imgdata.shootinginfo);\n  imgdata.shootinginfo.DriveMode = -1;\n  imgdata.shootinginfo.FocusMode = -1;\n  imgdata.shootinginfo.MeteringMode = -1;\n  imgdata.shootinginfo.AFPoint = -1;\n  imgdata.shootinginfo.ExposureMode = -1;\n  imgdata.shootinginfo.ImageStabilization = -1;\n\n  _exitflag = 0;\n#ifdef USE_RAWSPEED\n  if(_rawspeed_decoder)\n    {\n      RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);\n      delete d;\n    }\n  _rawspeed_decoder = 0;\n#endif\n\n  if(_x3f_data)\n    {\n      x3f_clear(_x3f_data);\n      _x3f_data = 0;\n    }\n\n  memmgr.cleanup();\n  imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n  imgdata.progress_flags = 0;\n\n  load_raw = thumb_load_raw = 0;\n\n  tls->init();\n}\n\nconst char * LibRaw::unpack_function_name()\n{\n  libraw_decoder_info_t decoder_info;\n  get_decoder_info(&decoder_info);\n  return decoder_info.decoder_name;\n}\n\nint LibRaw::get_decoder_info(libraw_decoder_info_t* d_info)\n{\n  if(!d_info)   return LIBRAW_UNSPECIFIED_ERROR;\n  d_info->decoder_name = 0;\n  d_info->decoder_flags = 0;\n  if (!load_raw) return LIBRAW_OUT_OF_ORDER_CALL;\n\n  int rawdata = (imgdata.idata.filters || P1.colors == 1);\n  // dcraw.c names order\n  if (load_raw == &LibRaw::android_tight_load_raw)\n  {\n\t  d_info->decoder_name = \"android_tight_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::android_loose_load_raw)\n  {\n\t  d_info->decoder_name = \"android_loose_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::canon_600_load_raw)\n    {\n      d_info->decoder_name = \"canon_600_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::xtrans_compressed_load_raw)\n  {\n\t  d_info->decoder_name = \"xtrans_compressed_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::canon_load_raw)\n    {\n      d_info->decoder_name = \"canon_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::lossless_jpeg_load_raw)\n    {\n      d_info->decoder_name = \"lossless_jpeg_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::canon_sraw_load_raw)\n    {\n      d_info->decoder_name = \"canon_sraw_load_raw()\";\n      //d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::lossless_dng_load_raw)\n    {\n      d_info->decoder_name = \"lossless_dng_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n    }\n  else if (load_raw == &LibRaw::packed_dng_load_raw)\n    {\n      d_info->decoder_name = \"packed_dng_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n    }\n  else if (load_raw == &LibRaw::pentax_load_raw )\n    {\n      d_info->decoder_name = \"pentax_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::nikon_load_raw)\n    {\n      d_info->decoder_name = \"nikon_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::nikon_coolscan_load_raw )\n  {\n\t  d_info->decoder_name = \"nikon_coolscan_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_sraw )\n    {\n      d_info->decoder_name = \"nikon_load_sraw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::nikon_yuv_load_raw )\n    {\n      d_info->decoder_name = \"nikon_load_yuv_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::rollei_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"rollei_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::phase_one_load_raw )\n    {\n      d_info->decoder_name = \"phase_one_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::phase_one_load_raw_c )\n    {\n      d_info->decoder_name = \"phase_one_load_raw_c()\";\n    }\n  else if (load_raw == &LibRaw::hasselblad_load_raw )\n    {\n      d_info->decoder_name = \"hasselblad_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::leaf_hdr_load_raw )\n    {\n      d_info->decoder_name = \"leaf_hdr_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::unpacked_load_raw )\n    {\n      d_info->decoder_name = \"unpacked_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::unpacked_load_raw_reversed )\n  {\n\t  d_info->decoder_name = \"unpacked_load_raw_reversed()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::sinar_4shot_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"sinar_4shot_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::imacon_full_load_raw )\n    {\n      d_info->decoder_name = \"imacon_full_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::hasselblad_full_load_raw )\n    {\n      d_info->decoder_name = \"hasselblad_full_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::packed_load_raw )\n    {\n      d_info->decoder_name = \"packed_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::broadcom_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"broadcom_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::nokia_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"nokia_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::canon_rmf_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"canon_rmf_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::panasonic_load_raw )\n    {\n      d_info->decoder_name = \"panasonic_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::olympus_load_raw )\n    {\n      d_info->decoder_name = \"olympus_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::minolta_rd175_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"minolta_rd175_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::quicktake_100_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"quicktake_100_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::kodak_radc_load_raw )\n    {\n      d_info->decoder_name = \"kodak_radc_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::kodak_jpeg_load_raw )\n    {\n      // UNTESTED + RBAYER\n      d_info->decoder_name = \"kodak_jpeg_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::lossy_dng_load_raw)\n    {\n      // Check rbayer\n      d_info->decoder_name = \"lossy_dng_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;\n    }\n  else if (load_raw == &LibRaw::kodak_dc120_load_raw )\n    {\n      d_info->decoder_name = \"kodak_dc120_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::eight_bit_load_raw )\n    {\n      d_info->decoder_name = \"eight_bit_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_c330_load_raw )\n    {\n      d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_c603_load_raw )\n    {\n      d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_262_load_raw )\n    {\n      d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_65000_load_raw )\n    {\n      d_info->decoder_name = \"kodak_65000_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n    }\n  else if (load_raw == &LibRaw::kodak_ycbcr_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"kodak_ycbcr_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_rgb_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"kodak_rgb_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::sony_load_raw )\n    {\n      d_info->decoder_name = \"sony_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::sony_arw_load_raw )\n    {\n      d_info->decoder_name = \"sony_arw_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n\n    }\n  else if (load_raw == &LibRaw::sony_arw2_load_raw )\n    {\n      d_info->decoder_name = \"sony_arw2_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_SONYARW2;\n    }\n  else if (load_raw == &LibRaw::samsung_load_raw )\n    {\n      d_info->decoder_name = \"samsung_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::samsung2_load_raw )\n    {\n      d_info->decoder_name = \"samsung2_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::samsung3_load_raw )\n    {\n      d_info->decoder_name = \"samsung3_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::smal_v6_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"smal_v6_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::smal_v9_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"smal_v9_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else  if (load_raw == &LibRaw::redcine_load_raw)\n    {\n      d_info->decoder_name = \"redcine_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n    }\n  else if (load_raw == &LibRaw::x3f_load_raw )\n    {\n      d_info->decoder_name = \"x3f_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC|LIBRAW_DECODER_FIXEDMAXC | LIBRAW_DECODER_LEGACY_WITH_MARGINS ;\n    }\n  else if (load_raw == &LibRaw::pentax_4shot_load_raw )\n  {\n\t  d_info->decoder_name = \"pentax_4shot_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::deflate_dng_load_raw )\n  {\n\t  d_info->decoder_name = \"deflate_dng_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_striped_packed_raw )\n    {\n      d_info->decoder_name = \"nikon_load_striped_packed_raw()\";\n    }\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n  else if (load_raw == &LibRaw::foveon_sd_load_raw )\n    {\n      d_info->decoder_name = \"foveon_sd_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::foveon_dp_load_raw )\n    {\n      d_info->decoder_name = \"foveon_dp_load_raw()\";\n    }\n#endif\n  else\n    {\n      d_info->decoder_name = \"Unknown unpack function\";\n      d_info->decoder_flags = LIBRAW_DECODER_NOTSET;\n    }\n  return LIBRAW_SUCCESS;\n}\n\nint LibRaw::adjust_maximum()\n{\n    ushort real_max;\n    float  auto_threshold;\n\n    if(O.adjust_maximum_thr < 0.00001)\n        return LIBRAW_SUCCESS;\n    else if (O.adjust_maximum_thr > 0.99999)\n        auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n    else\n        auto_threshold = O.adjust_maximum_thr;\n\n\n    real_max = C.data_maximum;\n    if (real_max > 0 && real_max < C.maximum && real_max > C.maximum* auto_threshold)\n      {\n        C.maximum = real_max;\n      }\n    return LIBRAW_SUCCESS;\n}\n\n\nvoid LibRaw:: merror (void *ptr, const char *where)\n{\n    if (ptr) return;\n    if(callbacks.mem_cb)(*callbacks.mem_cb)(callbacks.memcb_data,\n                                            libraw_internal_data.internal_data.input\n                                            ?libraw_internal_data.internal_data.input->fname()\n                                            :NULL,\n                                            where);\n    throw LIBRAW_EXCEPTION_ALLOC;\n}\n\n\n\nint LibRaw::open_file(const char *fname, INT64 max_buf_size)\n{\n#ifndef WIN32\n  struct stat st;\n  if(stat(fname,&st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size)?1:0;\n#else\n  struct _stati64 st;\n  if(_stati64(fname,&st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size)?1:0;\n#endif\n\n  LibRaw_abstract_datastream *stream;\n  try {\n    if(big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n    {\n      recycle();\n      return LIBRAW_UNSUFFICIENT_MEMORY;\n    }\n  if(!stream->valid())\n    {\n      delete stream;\n      return LIBRAW_IO_ERROR;\n    }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n    {\n      ID.input_internal =1 ; // flag to delete datastream on recycle\n    }\n  else\n    {\n      delete stream;\n      ID.input_internal = 0;\n    }\n  return ret;\n}\n\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\nint LibRaw::open_file(const wchar_t *fname, INT64 max_buf_size)\n{\n  struct _stati64 st;\n  if(_wstati64(fname,&st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size)?1:0;\n\n  LibRaw_abstract_datastream *stream;\n  try {\n    if(big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n    {\n      recycle();\n      return LIBRAW_UNSUFFICIENT_MEMORY;\n    }\n  if(!stream->valid())\n    {\n      delete stream;\n      return LIBRAW_IO_ERROR;\n    }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n    {\n      ID.input_internal =1 ; // flag to delete datastream on recycle\n    }\n  else\n    {\n      delete stream;\n      ID.input_internal = 0;\n    }\n  return ret;\n}\n#endif\n\nint LibRaw::open_buffer(void *buffer, size_t size)\n{\n  // this stream will close on recycle()\n  if(!buffer  || buffer==(void*)-1)\n    return LIBRAW_IO_ERROR;\n\n  LibRaw_buffer_datastream *stream;\n  try {\n    stream = new LibRaw_buffer_datastream(buffer,size);\n  }\n  catch (std::bad_alloc)\n    {\n      recycle();\n      return LIBRAW_UNSUFFICIENT_MEMORY;\n    }\n  if(!stream->valid())\n    {\n      delete stream;\n      return LIBRAW_IO_ERROR;\n    }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n    {\n      ID.input_internal =1 ; // flag to delete datastream on recycle\n    }\n  else\n    {\n      delete stream;\n      ID.input_internal = 0;\n    }\n  return ret;\n}\n\n#ifdef USE_ZLIB\ninline unsigned int __DNG_HalfToFloat (ushort halfValue)\n{\n\tint sign \t   = (halfValue >> 15) & 0x00000001;\n\tint exponent = (halfValue >> 10) & 0x0000001f;\n\tint mantissa =  halfValue\t\t   & 0x000003ff;\n\tif (exponent == 0)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) (sign << 31);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (!(mantissa & 0x00000400))\n\t\t\t{\n\t\t\t\tmantissa <<= 1;\n\t\t\t\texponent -=  1;\n\t\t\t}\n\t\t\texponent += 1;\n\t\t\tmantissa &= ~0x00000400;\n\t\t}\n\t}\n\telse if (exponent == 31)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) ((sign << 31) | ((0x1eL + 127 - 15) << 23) |  (0x3ffL << 13));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\texponent += (127 - 15);\n\tmantissa <<= 13;\n\treturn (unsigned int) ((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline unsigned int __DNG_FP24ToFloat (const unsigned char *input)\n{\n\tint sign     = (input [0] >> 7) & 0x01;\n\tint exponent = (input [0]     ) & 0x7F;\n\tint mantissa = (((int) input [1]) << 8) | input[2];\n\tif (exponent == 0)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) (sign << 31);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (!(mantissa & 0x00010000))\n\t\t\t{\n\t\t\t\tmantissa <<= 1;\n\t\t\t\texponent -=  1;\n\t\t\t}\n\t\t\texponent += 1;\n\t\t\tmantissa &= ~0x00010000;\n\t\t}\n\t}\n\telse if (exponent == 127)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) ((sign << 31) | ((0x7eL + 128 - 64) << 23) |  (0xffffL << 7));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Nan -- Just set to zero.\n\t\t\treturn 0;\n\t\t}\n\t}\n\texponent += (128 - 64);\n\tmantissa <<= 7;\n\treturn (uint32_t) ((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline void DecodeDeltaBytes (unsigned char *bytePtr, int cols, int channels)\n{\n\tif (channels == 1)\n\t{\n\t\tunsigned char b0 = bytePtr [0];\n\t\tbytePtr += 1;\n\t\tfor (uint32_t col = 1; col < cols; ++col)\n\t\t{\n\t\t\tb0 += bytePtr [0];\n\t\t\tbytePtr [0] = b0;\n\t\t\tbytePtr += 1;\n\t\t}\n\t}\n\telse if (channels == 3)\n\t{\n\t\tunsigned char b0 = bytePtr [0];\n\t\tunsigned char b1 = bytePtr [1];\n\t\tunsigned char b2 = bytePtr [2];\n\t\tbytePtr += 3;\n\t\tfor (int col = 1; col < cols; ++col)\n\t\t{\n\t\t\tb0 += bytePtr [0];\n\t\t\tb1 += bytePtr [1];\n\t\t\tb2 += bytePtr [2];\n\t\t\tbytePtr [0] = b0;\n\t\t\tbytePtr [1] = b1;\n\t\t\tbytePtr [2] = b2;\n\t\t\tbytePtr += 3;\n\t\t}\n\t}\n\telse if (channels == 4)\n\t{\n\t\tunsigned char b0 = bytePtr [0];\n\t\tunsigned char b1 = bytePtr [1];\n\t\tunsigned char b2 = bytePtr [2];\n\t\tunsigned char b3 = bytePtr [3];\n\t\tbytePtr += 4;\n\t\tfor (uint32_t col = 1; col < cols; ++col)\n\t\t{\n\t\t\tb0 += bytePtr [0];\n\t\t\tb1 += bytePtr [1];\n\t\t\tb2 += bytePtr [2];\n\t\t\tb3 += bytePtr [3];\n\t\t\tbytePtr [0] = b0;\n\t\t\tbytePtr [1] = b1;\n\t\t\tbytePtr [2] = b2;\n\t\t\tbytePtr [3] = b3;\n\t\t\tbytePtr += 4;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int col = 1; col < cols; ++col)\n\t\t{\n\t\t\tfor (int chan = 0; chan < channels; ++chan)\n\t\t\t{\n\t\t\t\tbytePtr [chan + channels] += bytePtr [chan];\n\t\t\t}\n\t\t\tbytePtr += channels;\n\t\t}\n\t}\n}\n\nstatic void DecodeFPDelta (unsigned char *input,\n\tunsigned char *output,\n\tint cols,\n\tint channels,\n\tint bytesPerSample)\n{\n\tDecodeDeltaBytes (input, cols * bytesPerSample, channels);\n\tint32_t rowIncrement = cols * channels;\n\n\tif (bytesPerSample == 2)\n\t{\n\n#if LibRawBigEndian\n\t\tconst unsigned char *input0 = input;\n\t\tconst unsigned char *input1 = input + rowIncrement;\n#else\n\t\tconst unsigned char *input1 = input;\n\t\tconst unsigned char *input0 = input + rowIncrement;\n#endif\n\t\tfor (int col = 0; col < rowIncrement; ++col)\n\t\t{\n\t\t\toutput [0] = input0 [col];\n\t\t\toutput [1] = input1 [col];\n\t\t\toutput += 2;\n\t\t}\n\t}\n\telse if (bytesPerSample == 3)\n\t{\n\t\tconst unsigned char *input0 = input;\n\t\tconst unsigned char *input1 = input + rowIncrement;\n\t\tconst unsigned char *input2 = input + rowIncrement * 2;\n\t\tfor (int col = 0; col < rowIncrement; ++col)\n\t\t{\n\t\t\toutput [0] = input0 [col];\n\t\t\toutput [1] = input1 [col];\n\t\t\toutput [2] = input2 [col];\n\t\t\toutput += 3;\n\t\t}\n\t}\n\telse\n\t{\n#if LibRawBigEndian\n\t\tconst unsigned char *input0 = input;\n\t\tconst unsigned char *input1 = input + rowIncrement;\n\t\tconst unsigned char *input2 = input + rowIncrement * 2;\n\t\tconst unsigned char *input3 = input + rowIncrement * 3;\n#else\n\t\tconst unsigned char *input3 = input;\n\t\tconst unsigned char *input2 = input + rowIncrement;\n\t\tconst unsigned char *input1 = input + rowIncrement * 2;\n\t\tconst unsigned char *input0 = input + rowIncrement * 3;\n#endif\n\t\tfor (int col = 0; col < rowIncrement; ++col)\n\t\t{\n\t\t\toutput [0] = input0 [col];\n\t\t\toutput [1] = input1 [col];\n\t\t\toutput [2] = input2 [col];\n\t\t\toutput [3] = input3 [col];\n\t\t\toutput += 4;\n\t\t}\n\t}\n}\n\nstatic float expandFloats(unsigned char * dst, int tileWidth, int bytesps) {\n\tfloat max = 0.f;\n\tif (bytesps == 2) {\n\t\tuint16_t * dst16 = (ushort *) dst;\n\t\tuint32_t * dst32 = (unsigned int *) dst;\n\t\tfloat *f32 = (float*) dst;\n\t\tfor (int index = tileWidth - 1; index >= 0; --index) {\n\t\t\tdst32[index] = __DNG_HalfToFloat(dst16[index]);\n\t\t\tmax = MAX(max,f32[index]);\n\t\t}\n\t}\n\telse if (bytesps == 3)\n\t{\n\t\tuint8_t  * dst8  = ((unsigned char *) dst) + (tileWidth - 1) * 3;\n\t\tuint32_t * dst32 = (unsigned int *) dst;\n\t\tfloat *f32 = (float*) dst;\n\t\tfor (int index = tileWidth - 1; index >= 0; --index, dst8 -= 3) {\n\t\t\tdst32[index] = __DNG_FP24ToFloat(dst8);\n\t\t\tmax = MAX(max,f32[index]);\n\t\t}\n\t}\n\telse if (bytesps==4)\n\t{\n\t\tfloat *f32 = (float*) dst;\n\t\tfor (int index = 0; index < tileWidth; index++)\n\t\t\tmax = MAX(max,f32[index]);\n\t}\n\treturn max;\n}\n\nvoid LibRaw::deflate_dng_load_raw()\n{\n\tstruct tiff_ifd_t * ifd = &tiff_ifd[0];\n\twhile (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;\n\tif (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n\t{\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\t}\n\n\tfloat *float_raw_image=0;\n\tfloat max = 0.f;\n\n\tif(ifd->samples!=1 && ifd->samples!=3 && ifd->samples !=4)\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n\tif(libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD\n\n\n\tsize_t tilesH = (imgdata.sizes.raw_width + libraw_internal_data.unpacker_data.tile_width - 1) / libraw_internal_data.unpacker_data.tile_width;\n\tsize_t tilesV = (imgdata.sizes.raw_height + libraw_internal_data.unpacker_data.tile_length - 1) / libraw_internal_data.unpacker_data.tile_length;\n\tsize_t tileCnt = tilesH * tilesV;\n\n\n\tif (ifd->sample_format == 3)\n\t{  // Floating point data\n\t\tfloat_raw_image = (float*)calloc(tileCnt*libraw_internal_data.unpacker_data.tile_length* libraw_internal_data.unpacker_data.tile_width * ifd->samples,sizeof(float));\n\t\t//imgdata.color.maximum = 65535;\n\t\t//imgdata.color.black = 0;\n\t\t//memset(imgdata.color.cblack,0,sizeof(imgdata.color.cblack));\n\t}\n\telse\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n\tint xFactor;\n\tswitch(ifd->predictor)\n\t{\n\t\tcase 3:\n\t\tdefault:\n\t\t\txFactor = 1; break;\n\t\tcase 34894: xFactor = 2; break;\n\t\tcase 34895: xFactor = 4; break;\n\t}\n\n\tif (libraw_internal_data.unpacker_data.tile_length < INT_MAX)\n\t{\n\t\tif(tileCnt<1 || tileCnt > 1000000)\n\t\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\n\t\tsize_t *tOffsets = (size_t*)malloc(tileCnt*sizeof(size_t));\n\t\tfor (int t = 0; t < tileCnt; ++t)\n\t\t\ttOffsets[t] = get4();\n\n\t\tsize_t *tBytes = (size_t*) malloc(tileCnt*sizeof(size_t));\n\t\tunsigned long maxBytesInTile = 0;\n\t\tif (tileCnt == 1)\n\t\t\ttBytes[0] = maxBytesInTile = ifd->bytes;\n\t\telse\n\t\t{\n\t\t\tlibraw_internal_data.internal_data.input->seek(ifd->bytes, SEEK_SET);\n\t\t\tfor (size_t t = 0; t < tileCnt; ++t)\n\t\t\t{\n\t\t\t\ttBytes[t] = get4();\n\t\t\t\tmaxBytesInTile = MAX(maxBytesInTile,tBytes[t]);\n\t\t\t}\n\t\t}\n\t\tunsigned tilePixels = libraw_internal_data.unpacker_data.tile_width * libraw_internal_data.unpacker_data.tile_length;\n\t\tunsigned pixelSize = sizeof(float)*ifd->samples;\n\t\tunsigned tileBytes = tilePixels*pixelSize;\n\t\tunsigned tileRowBytes = libraw_internal_data.unpacker_data.tile_width*pixelSize;\n\n\t\tunsigned char *cBuffer = (unsigned char*)malloc(maxBytesInTile);\n\t\tunsigned char *uBuffer = (unsigned char*)malloc(tileBytes+tileRowBytes); // extra row for decoding\n\n\t\tfor (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += libraw_internal_data.unpacker_data.tile_length)\n\t\t{\n\t\t\tfor (size_t x = 0; x < imgdata.sizes.raw_width; x += libraw_internal_data.unpacker_data.tile_width, ++t)\n\t\t\t{\n\t\t\t\tlibraw_internal_data.internal_data.input->seek(tOffsets[t], SEEK_SET);\n\t\t\t\tlibraw_internal_data.internal_data.input->read(cBuffer, 1, tBytes[t]);\n\t\t\t\tunsigned long dstLen = tileBytes;\n\t\t\t\tint err = uncompress(uBuffer+tileRowBytes, &dstLen, cBuffer, tBytes[t]);\n\t\t\t\tif (err != Z_OK)\n\t\t\t\t{\n\t\t\t\t\tfree(tOffsets);\n\t\t\t\t\tfree(tBytes);\n\t\t\t\t\tfree(cBuffer);\n\t\t\t\t\tfree(uBuffer);\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint bytesps = ifd->bps >> 3;\n\t\t\t\t\tsize_t rowsInTile = y + libraw_internal_data.unpacker_data.tile_length > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : libraw_internal_data.unpacker_data.tile_length;\n\t\t\t\t\tsize_t colsInTile= x + libraw_internal_data.unpacker_data.tile_width > imgdata.sizes.raw_width ? imgdata.sizes.raw_width - x : libraw_internal_data.unpacker_data.tile_width;\n\n\t\t\t\t\tfor (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char* dst = uBuffer + row*libraw_internal_data.unpacker_data.tile_width*bytesps*ifd->samples;\n\t\t\t\t\t\tunsigned char* src = dst+tileRowBytes;\n\t\t\t\t\t\tDecodeFPDelta (src,dst,\n\t\t\t\t\t\t\tlibraw_internal_data.unpacker_data.tile_width/ xFactor,\n\t\t\t\t\t\t\tifd->samples * xFactor,\n\t\t\t\t\t\t\tbytesps);\n\t\t\t\t\t\tfloat lmax = expandFloats(dst, libraw_internal_data.unpacker_data.tile_width*ifd->samples, bytesps);\n\t\t\t\t\t\tmax = MAX(max,lmax);\n\t\t\t\t\t\tunsigned char* dst2 = (unsigned char*)&float_raw_image[((y+row)*imgdata.sizes.raw_width + x)*ifd->samples];\n\t\t\t\t\t\tmemmove(dst2,dst,colsInTile*ifd->samples*sizeof(float));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(tOffsets);\n\t\tfree(tBytes);\n\t\tfree(cBuffer);\n\t\tfree(uBuffer);\n\t}\n\timgdata.color.fmaximum = max;\n\n\t// Set fields according to data format\n\n\timgdata.rawdata.raw_alloc = float_raw_image;\n\tif(ifd->samples == 1)\n\t{\n\t\timgdata.rawdata.float_image = float_raw_image;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*4;\n\t}\n\telse if(ifd->samples == 3)\n\t{\n\t\timgdata.rawdata.float3_image = (float(*)[3])float_raw_image;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*12;\n\t}\n\telse if(ifd->samples == 4)\n\t{\n\t\timgdata.rawdata.float4_image = (float(*)[4])float_raw_image;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*16;\n\t}\n\n\tif(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT)\n\t\tconvertFloatToInt(); // with default settings\n}\n#else\nvoid LibRaw::deflate_dng_load_raw()\n{\n\n throw LIBRAW_EXCEPTION_DECODE_RAW;\n}\n#endif\n\nint LibRaw::is_floating_point()\n{\n\tstruct tiff_ifd_t * ifd = &tiff_ifd[0];\n\twhile (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;\n\tif (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n\t\treturn 0;\n\n\treturn ifd->sample_format == 3;\n}\n\nint LibRaw::have_fpdata()\n{\n\treturn imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;\n}\n\n\nvoid LibRaw::convertFloatToInt(float dmin/* =4096.f */, float dmax/* =32767.f */, float dtarget /*= 16383.f */)\n{\n\tint samples = 0;\n\tfloat *data = 0;\n\tif(imgdata.rawdata.float_image)\n\t{\n\t\tsamples = 1;\n\t\tdata = imgdata.rawdata.float_image;\n\t}\n\telse if (imgdata.rawdata.float3_image)\n\t{\n\t\tsamples = 3;\n\t\tdata = (float*)imgdata.rawdata.float3_image;\n\t}\n\telse if (imgdata.rawdata.float4_image)\n\t{\n\t\tsamples = 4;\n\t\tdata = (float*)imgdata.rawdata.float4_image;\n\t}\n\telse\n\t\treturn;\n\n\tushort *raw_alloc = (ushort*)malloc(imgdata.sizes.raw_height*imgdata.sizes.raw_width*libraw_internal_data.unpacker_data.tiff_samples*sizeof(ushort));\n\tfloat tmax = MAX(imgdata.color.maximum,1);\n\tfloat datamax = imgdata.color.fmaximum;\n\n\ttmax = MAX(tmax,datamax);\n\ttmax = MAX(tmax,1.f);\n\n\tfloat multip = 1.f;\n\tif(tmax < dmin || tmax > dmax)\n\t{\n\t\timgdata.rawdata.color.fnorm = imgdata.color.fnorm = multip = dtarget / tmax;\n\t\timgdata.rawdata.color.maximum = imgdata.color.maximum = dtarget;\n\t\timgdata.rawdata.color.black = imgdata.color.black = (float)imgdata.color.black*multip;\n\t\tfor(int i=0; i<sizeof(imgdata.color.cblack)/sizeof(imgdata.color.cblack[0]); i++)\n\t\t\tif(i!=4 && i!=5)\n\t\t\t\timgdata.rawdata.color.cblack[i] = imgdata.color.cblack[i] = (float)imgdata.color.cblack[i]*multip;\n\n\t}\n\telse\n\t\timgdata.rawdata.color.fnorm = imgdata.color.fnorm = 0.f;\n\n\tfor (size_t i = 0; i < imgdata.sizes.raw_height*imgdata.sizes.raw_width*libraw_internal_data.unpacker_data.tiff_samples; ++i)\n\t{\n\t\tfloat val = MAX(data[i],0.f);\n\t\traw_alloc[i] = (ushort)(val*multip);\n\t}\n\n\tif(samples==1)\n\t{\n\t\timgdata.rawdata.raw_alloc = imgdata.rawdata.raw_image = raw_alloc;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*2;\n\t}\n\telse if(samples == 3)\n\t{\n\t\timgdata.rawdata.raw_alloc = imgdata.rawdata.color3_image = (ushort (*)[3]) raw_alloc;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;\n\t}\n\telse if(samples == 4)\n\t{\n\t\timgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = (ushort (*)[4]) raw_alloc;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*8;\n\t}\n\tfree(data); // remove old allocation\n\timgdata.rawdata.float_image = 0;\n\timgdata.rawdata.float3_image = 0;\n\timgdata.rawdata.float4_image = 0;\n}\n\nvoid LibRaw::pentax_4shot_load_raw()\n{\n\tushort *plane = (ushort*)malloc(imgdata.sizes.raw_width*imgdata.sizes.raw_height*sizeof(ushort));\n\tint alloc_sz = imgdata.sizes.raw_width*(imgdata.sizes.raw_height+16)*4*sizeof(ushort);\n\tushort (*result)[4] = (ushort(*)[4]) malloc(alloc_sz);\n\tstruct movement_t\n\t{\n\t\tint row,col;\n\t} _move[4] = {\n\t\t{1,1},\n\t\t{0,1},\n\t\t{0,0},\n\t\t{1,0},\n\t};\n\n\tint tidx = 0;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint move_row,move_col;\n\t\tif(imgdata.params.p4shot_order[i] >= '0' && imgdata.params.p4shot_order[i] <= '3')\n\t\t{\n\t\t\tmove_row = (imgdata.params.p4shot_order[i]-'0' & 2)?1:0;\n\t\t\tmove_col = (imgdata.params.p4shot_order[i]-'0' & 1)?1:0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmove_row = _move[i].row;\n\t\t\tmove_col = _move[i].col;\n\t\t}\n\t\tfor(; tidx<16; tidx++)\n\t\t\tif(tiff_ifd[tidx].t_width == imgdata.sizes.raw_width && tiff_ifd[tidx].t_height == imgdata.sizes.raw_height && tiff_ifd[tidx].bps>8 && tiff_ifd[tidx].samples == 1 )\n\t\t\t\tbreak;\n\t\tif(tidx>=16)\n\t\t\tbreak;\n\t\timgdata.rawdata.raw_image = plane;\n\t\tID.input->seek(tiff_ifd[tidx].offset, SEEK_SET);\n\t\timgdata.idata.filters = 0xb4b4b4b4;\n\t\tlibraw_internal_data.unpacker_data.data_offset = tiff_ifd[tidx].offset;\n\t\t(this->*pentax_component_load_raw)();\n\t\tfor(int row = 0; row < imgdata.sizes.raw_height-move_row; row++)\n\t\t{\n\t\t\tint colors[2];\n\t\t\tfor(int c = 0; c < 2; c++ )\n\t\t\t\tcolors[c] = COLOR(row,c);\n\t\t\tushort *srcrow = &plane[imgdata.sizes.raw_width*row];\n\t\t\tushort (*dstrow)[4] = & result[(imgdata.sizes.raw_width)*(row+move_row)+move_col];\n\t\t\tfor(int col = 0; col < imgdata.sizes.raw_width-move_col; col++)\n\t\t\t\tdstrow[col][colors[col%2]] = srcrow[col];\n\t\t}\n\t\ttidx++;\n\t}\n\t// assign things back:\n\timgdata.sizes.raw_pitch = imgdata.sizes.raw_width*8;\n\timgdata.idata.filters = 0;\n\timgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = result;\n\tfree(plane);\n\timgdata.rawdata.raw_image = 0;\n}\n\nvoid LibRaw::hasselblad_full_load_raw()\n{\n  int row, col;\n\n  for (row=0; row < S.height; row++)\n    for (col=0; col < S.width; col++)\n      {\n        read_shorts (&imgdata.image[row*S.width+col][2], 1); // B\n        read_shorts (&imgdata.image[row*S.width+col][1], 1); // G\n        read_shorts (&imgdata.image[row*S.width+col][0], 1); // R\n      }\n}\n\nvoid LibRaw::nikon_load_striped_packed_raw()\n{\n\tint vbits=0, bwide, rbits, bite,row, col, val, i;\n\n\tUINT64 bitbuf=0;\n\tunsigned load_flags = 24; //libraw_internal_data.unpacker_data.load_flags;\n\tunsigned tiff_bps = libraw_internal_data.unpacker_data.tiff_bps;\n\tint tiff_compress = libraw_internal_data.unpacker_data.tiff_compress;\n\n\tstruct tiff_ifd_t * ifd = &tiff_ifd[0];\n\twhile (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;\n\tif (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\n\tif(!ifd->rows_per_strip || !ifd->strip_offsets_count)\n\t\treturn; // not unpacked\n\tint stripcnt = 0;\n\n\tbwide = S.raw_width *  tiff_bps / 8;\n\tbwide += bwide & load_flags >> 7;\n\trbits = bwide * 8 - S.raw_width * tiff_bps;\n\tif (load_flags & 1) bwide = bwide * 16 / 15;\n\tbite = 8 + (load_flags & 24);\n\tfor (row=0; row < S.raw_height; row++)\n\t{\n\t\tcheckCancel();\n\t\tif(!(row%ifd->rows_per_strip))\n\t\t{\n\t\t\tif(stripcnt >= ifd->strip_offsets_count)\n\t\t\t\treturn; // run out of data\n\t\t\tlibraw_internal_data.internal_data.input->seek(ifd->strip_offsets[stripcnt],SEEK_SET);\n\t\t\tstripcnt++;\n\t\t}\n\t\tfor (col=0; col < S.raw_width; col++)\n\t\t{\n\t\t\tfor (vbits -= tiff_bps; vbits < 0; vbits += bite)\n\t\t\t{\n\t\t\t\tbitbuf <<= bite;\n\t\t\t\tfor (i=0; i < bite; i+=8)\n\t\t\t\t\tbitbuf |= (unsigned) (libraw_internal_data.internal_data.input->get_char() << i);\n\t\t\t}\n\t\t\timgdata.rawdata.raw_image[(row)*S.raw_width+(col)] = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n\t\t}\n\t\tvbits -= rbits;\n\t}\n}\n\nstruct foveon_data_t\n{\n    const char *make;\n    const char *model;\n    const int raw_width,raw_height;\n    const int  white;\n    const int  left_margin,top_margin;\n    const int  width,height;\n} foveon_data [] =\n{\n  {\"Sigma\",\"SD9\",2304,1531,12000,20,8,2266,1510},\n  {\"Sigma\",\"SD9\",1152,763,12000,10,2,1132,755},\n  {\"Sigma\",\"SD10\",2304,1531,12000,20,8,2266,1510},\n  {\"Sigma\",\"SD10\",1152,763,12000,10,2,1132,755},\n  {\"Sigma\",\"SD14\",2688,1792,14000,18,12,2651,1767},\n  {\"Sigma\",\"SD14\",2688,896,14000,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"SD14\",1344,896,14000,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"SD15\",2688,1792,2900,18,12,2651,1767},\n  {\"Sigma\",\"SD15\",2688,896,2900,18,6,2651,883}, // 2/3 ?\n  {\"Sigma\",\"SD15\",1344,896,2900,9,6,1326,883}, // 1/2 ?\n  {\"Sigma\",\"DP1\",2688,1792,2100,18,12,2651,1767},\n  {\"Sigma\",\"DP1\",2688,896,2100,18,6,2651,883}, // 2/3 ?\n  {\"Sigma\",\"DP1\",1344,896,2100,9,6,1326,883}, // 1/2 ?\n  {\"Sigma\",\"DP1S\",2688,1792,2200,18,12,2651,1767},\n  {\"Sigma\",\"DP1S\",2688,896,2200,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP1S\",1344,896,2200,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"DP1X\",2688,1792,3560,18,12,2651,1767},\n  {\"Sigma\",\"DP1X\",2688,896,3560,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP1X\",1344,896,3560,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"DP2\",2688,1792,2326,13,16,2651,1767},\n  {\"Sigma\",\"DP2\",2688,896,2326,13,8,2651,883}, // 2/3 ??\n  {\"Sigma\",\"DP2\",1344,896,2326,7,8,1325,883}, // 1/2 ??\n  {\"Sigma\",\"DP2S\",2688,1792,2300,18,12,2651,1767},\n  {\"Sigma\",\"DP2S\",2688,896,2300,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP2S\",1344,896,2300,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"DP2X\",2688,1792,2300,18,12,2651,1767},\n  {\"Sigma\",\"DP2X\",2688,896,2300,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP2X\",1344,896,2300,9,6,1325,883}, // 1/2\n  {\"Sigma\",\"SD1\",4928,3264,3900,12,52,4807,3205}, // Full size\n  {\"Sigma\",\"SD1\",4928,1632,3900,12,26,4807,1603}, // 2/3 size\n  {\"Sigma\",\"SD1\",2464,1632,3900,6,26,2403,1603}, // 1/2 size\n  {\"Sigma\",\"SD1 Merrill\",4928,3264,3900,12,52,4807,3205}, // Full size\n  {\"Sigma\",\"SD1 Merrill\",4928,1632,3900,12,26,4807,1603}, // 2/3 size\n  {\"Sigma\",\"SD1 Merrill\",2464,1632,3900,6,26,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP1 Merrill\",4928,3264,3900,12,0,4807,3205},\n  {\"Sigma\",\"DP1 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP1 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size\n  {\"Sigma\",\"DP2 Merrill\",4928,3264,3900,12,0,4807,3205},\n  {\"Sigma\",\"DP2 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP2 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size\n  {\"Sigma\",\"DP3 Merrill\",4928,3264,3900,12,0,4807,3205},\n  {\"Sigma\",\"DP3 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP3 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size\n  {\"Polaroid\",\"x530\",1440,1088,2700,10,13,1419,1059},\n  // dp2 Q\n  {\"Sigma\",\"dp3 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp3 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  {\"Sigma\",\"dp2 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp2 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  {\"Sigma\",\"dp1 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp1 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  {\"Sigma\",\"dp0 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp0 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  // Sigma sd Quattro\n  {\"Sigma\",\"sd Quattro\",5888,3776,16383,204,76,5446,3624}, // full size\n  {\"Sigma\",\"sd Quattro\",2944,1888,16383,102,38,2723,1812}, // half size\n  // Sd Quattro H\n  {\"Sigma\",\"sd Quattro H\",6656,4480,16383,224,160,6208,4160}, // full size\n  {\"Sigma\",\"sd Quattro H\",3328,2240,16383,112,80,3104,2080}, // half size\n  {\"Sigma\",\"sd Quattro H\",5504,3680,16383,0,4,5496,3668}, // full size\n  {\"Sigma\",\"sd Quattro H\",2752,1840,16383,0,2,2748,1834}, // half size\n};\nconst int foveon_count = sizeof(foveon_data)/sizeof(foveon_data[0]);\n\n\nint LibRaw::open_datastream(LibRaw_abstract_datastream *stream)\n{\n\n  if(!stream)\n    return ENOENT;\n  if(!stream->valid())\n    return LIBRAW_IO_ERROR;\n  recycle();\n\n  try {\n    ID.input = stream;\n    SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);\n\n    identify();\n\n\tif (!strcasecmp(imgdata.idata.make, \"Canon\")  && (load_raw == &LibRaw::canon_sraw_load_raw) && imgdata.sizes.raw_width>0)\n\t{\n\t\tfloat ratio = float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);\n\t\tif((ratio < 0.57 || ratio > 0.75) && imgdata.makernotes.canon.SensorHeight>1 && imgdata.makernotes.canon.SensorWidth > 1)\n\t\t{\n\t\t\timgdata.sizes.raw_width = imgdata.makernotes.canon.SensorWidth;\n\t\t\timgdata.sizes.left_margin = imgdata.makernotes.canon.SensorLeftBorder;\n\t\t\timgdata.sizes.iwidth = imgdata.sizes.width = imgdata.makernotes.canon.SensorRightBorder - imgdata.makernotes.canon.SensorLeftBorder+1;\n\t\t\timgdata.sizes.raw_height = imgdata.makernotes.canon.SensorHeight;\n\t\t\timgdata.sizes.top_margin = imgdata.makernotes.canon.SensorTopBorder;\n\t\t\timgdata.sizes.iheight = imgdata.sizes.height = imgdata.makernotes.canon.SensorBottomBorder - imgdata.makernotes.canon.SensorTopBorder+1;\n\t\t\tlibraw_internal_data.unpacker_data.load_flags |= 256; // reset width/height in canon_sraw_load_raw()\n\t\t\timgdata.sizes.raw_pitch = 8*imgdata.sizes.raw_width;\n\t\t}\n\t\telse if(imgdata.sizes.raw_width == 4032 && imgdata.sizes.raw_height == 3402 && !strcasecmp(imgdata.idata.model, \"EOS 80D\")) // 80D hardcoded\n\t\t{\n\t\t\timgdata.sizes.raw_width = 4536;\n\t\t\timgdata.sizes.left_margin = 28;\n\t\t\timgdata.sizes.iwidth = imgdata.sizes.width = imgdata.sizes.raw_width - imgdata.sizes.left_margin;\n\t\t\timgdata.sizes.raw_height = 3024;\n\t\t\timgdata.sizes.top_margin = 8;\n\t\t\timgdata.sizes.iheight = imgdata.sizes.height = imgdata.sizes.raw_height - imgdata.sizes.top_margin;\n\t\t\tlibraw_internal_data.unpacker_data.load_flags |= 256;\n\t\t\timgdata.sizes.raw_pitch = 8*imgdata.sizes.raw_width;\n\t\t}\n\t}\n\n\t// XTrans Compressed?\n\tif (!imgdata.idata.dng_version && !strcasecmp(imgdata.idata.make, \"Fujifilm\") && (load_raw == &LibRaw::unpacked_load_raw) )\n\t{\n\t\tif (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 2 != libraw_internal_data.unpacker_data.data_size)\n\t\t\tparse_xtrans_header();\n\n\t\tif(imgdata.idata.filters == 9)\n\t\t{\n\t\t\t// Adjust top/left margins for X-Trans\n\t\t\tint newtm = imgdata.sizes.top_margin%6?(imgdata.sizes.top_margin/6+1)*6 : imgdata.sizes.top_margin;\n\t\t\tint newlm = imgdata.sizes.left_margin%6?(imgdata.sizes.left_margin/6+1)*6 : imgdata.sizes.left_margin;\n\t\t\tif(newtm != imgdata.sizes.top_margin || newlm != imgdata.sizes.left_margin)\n\t\t\t{\n\t\t\t\timgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);\n\t\t\t\timgdata.sizes.top_margin = newtm;\n\t\t\t\timgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);\n\t\t\t\timgdata.sizes.left_margin = newlm;\n\t\t\t\tfor(int c = 0; c < 36; c++)\n\t\t\t\t\timgdata.idata.xtrans[0][c] = imgdata.idata.xtrans_abs[0][c];\n\t\t\t}\n\t\t}\n\t}\n\n    // Fix DNG white balance if needed\n    if(imgdata.idata.dng_version && (imgdata.idata.filters == 0) && imgdata.idata.colors > 1 && imgdata.idata.colors < 5)\n      {\n\tfloat delta[4]={0.f,0.f,0.f,0.f};\n\tfor(int c = 0; c < imgdata.idata.colors ; c++ )\n\t  delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - imgdata.color.dng_levels.dng_blacklevel[c];\n\tfloat mindelta = delta[0],maxdelta = delta[0];\n\tfor(int c = 1; c < imgdata.idata.colors; c++)\n\t  {\n\t    if(mindelta > delta[c]) mindelta = delta[c];\n\t    if(maxdelta < delta[c]) maxdelta = delta[c];\n\t  }\n\tif(mindelta > 1 && maxdelta < (mindelta *20)) // safety\n\t  {\n\t    for(int c = 0; c < imgdata.idata.colors; c++)\n\t      {\n\t\timgdata.color.cam_mul[c] /= (delta[c]/maxdelta);\n\t\timgdata.color.pre_mul[c] /= (delta[c]/maxdelta);\n\t      }\n\t    imgdata.color.maximum = imgdata.color.cblack[0]+maxdelta;\n\t  }\n      }\n\n    if(imgdata.idata.dng_version &&\n      (\n    (!strcasecmp(imgdata.idata.make,\"Leica\") && !strcasecmp(imgdata.idata.model,\"D-LUX (Typ 109)\"))\n\t  ||\n\t  (!strcasecmp(imgdata.idata.make,\"Panasonic\") && !strcasecmp(imgdata.idata.model,\"LX100\"))\n\t)\n       )\n      imgdata.sizes.width = 4288;\n\n\tif (!strncasecmp(imgdata.idata.make, \"Sony\", 4) && imgdata.idata.dng_version)\n\t{\n\t\tif(S.raw_width == 3984) S.width = 3925;\n\t\telse if (S.raw_width == 4288) S.width = S.raw_width-32;\n\t\telse if (S.raw_width == 4928 && S.height < 3280) S.width = S.raw_width-8;\n\t\telse if (S.raw_width == 5504) S.width = S.raw_width-(S.height > 3664 ? 8 : 32);\n\t\telse if (S.raw_width == 6048)\n\t\t{\n\t\t\tS.width = S.raw_width-24;\n\t\t\tif (strstr(imgdata.idata.model,\"RX1\") || strstr(imgdata.idata.model,\"A99\")) S.width -= 6;\n\t\t}\n\t\telse if (S.raw_width == 7392) S.width = S.raw_width-30;\n\t\telse if(S.raw_width == 8000)\tS.width = S.raw_width - 32;\n\t}\n\n\tif(!strcasecmp(imgdata.idata.make,\"Pentax\") &&  /*!strcasecmp(imgdata.idata.model,\"K-3 II\")  &&*/ imgdata.idata.raw_count == 4 && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES))\n\t{\n\t\timgdata.idata.raw_count = 1;\n\t\timgdata.idata.filters = 0;\n\t\timgdata.idata.colors = 4;\n\t\tIO.mix_green = 1;\n\t\tpentax_component_load_raw = load_raw;\n\t\tload_raw= &LibRaw::pentax_4shot_load_raw;\n\t}\n\n\tif (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Leaf\") && !strcmp(imgdata.idata.model, \"Credo 50\"))\n\t{\n\t\timgdata.color.pre_mul[0] = 1.f / 0.3984f;\n\t\timgdata.color.pre_mul[2] = 1.f / 0.7666f;\n\t\timgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;\n\t}\n\n\t// S3Pro DNG patch\n\tif(imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\") && !strcmp(imgdata.idata.model,\"S3Pro\") && imgdata.sizes.raw_width == 4288 )\n\t{\n\t\timgdata.sizes.left_margin++;\n\t\timgdata.sizes.width--;\n\t}\n\tif(imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\") && !strcmp(imgdata.idata.model,\"S5Pro\") && imgdata.sizes.raw_width == 4288 )\n\t{\n\t\timgdata.sizes.left_margin++;\n\t\timgdata.sizes.width--;\n\t}\n\tif(!imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\")\n           && (!strncmp(imgdata.idata.model,\"S20Pro\",6) || !strncmp(imgdata.idata.model,\"F700\",4))\n           )\n\t{\n          imgdata.sizes.raw_width/=2;\n          load_raw= &LibRaw::unpacked_load_raw_fuji_f700s20;\n\t}\n\tif(load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\")\n\t\t && !libraw_internal_data.unpacker_data.load_flags\n\t\t && (!strncasecmp(imgdata.idata.model,\"D810\",4) || !strcasecmp(imgdata.idata.model,\"D4S\"))\n\t\t && libraw_internal_data.unpacker_data.data_size*2 == imgdata.sizes.raw_height*imgdata.sizes.raw_width*3)\n\t{\n\t\tlibraw_internal_data.unpacker_data.load_flags = 80;\n\t}\n\t// Adjust BL for Sony A900/A850\n    if(load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make,\"Sony\")) // 12 bit sony, but metadata may be for 14-bit range\n      {\n        if(C.maximum>4095)\n          C.maximum = 4095;\n        if(C.black > 256 || C.cblack[0] > 256)\n          {\n            C.black /=4;\n            for(int c=0; c< 4; c++)\n              C.cblack[c]/=4;\n            for(int c=0; c< C.cblack[4]*C.cblack[5];c++)\n              C.cblack[6+c]/=4;\n          }\n      }\n    if(  load_raw == &LibRaw::nikon_yuv_load_raw  ) // Is it Nikon sRAW?\n      {\n           load_raw= &LibRaw::nikon_load_sraw;\n           C.black =0;\n           memset(C.cblack,0,sizeof(C.cblack));\n           imgdata.idata.filters = 0;\n           libraw_internal_data.unpacker_data.tiff_samples=3;\n           imgdata.idata.colors = 3;\n           double beta_1 = -5.79342238397656E-02;\n           double beta_2 = 3.28163551282665;\n           double beta_3 = -8.43136004842678;\n           double beta_4 = 1.03533181861023E+01;\n           for(int i=0; i<=3072;i++)\n           {\n               double x = (double)i/3072.;\n               double y = (1.-exp(-beta_1*x-beta_2*x*x-beta_3*x*x*x-beta_4*x*x*x*x));\n               if(y<0.)y=0.;\n               imgdata.color.curve[i] = (y*16383.);\n           }\n           for(int i=0;i<3;i++)\n             for(int j=0;j<4;j++)\n               imgdata.color.rgb_cam[i][j]=float(i==j);\n      }\n    // Adjust BL for Nikon 12bit\n    if((\n        load_raw == &LibRaw::nikon_load_raw\n        || load_raw == &LibRaw::packed_load_raw)\n       && !strcasecmp(imgdata.idata.make,\"Nikon\")\n       && strncmp(imgdata.idata.model,\"COOLPIX\",7)\n//\t   && strncmp(imgdata.idata.model,\"1 \",2)\n       && libraw_internal_data.unpacker_data.tiff_bps == 12)\n      {\n        C.maximum = 4095;\n        C.black /=4;\n        for(int c=0; c< 4; c++)\n          C.cblack[c]/=4;\n        for(int c=0; c< C.cblack[4]*C.cblack[5];c++)\n          C.cblack[6+c]/=4;\n      }\n\n    // Adjust Highlight Linearity limit\n    if (C.linear_max[0] < 0) {\n      if (imgdata.idata.dng_version) {\n          for (int c=0; c<4; c++)\n            C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c+6];\n      } else {\n          for (int c=0; c<4; c++)\n            C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];\n      }\n    }\n\n    if  (!strcasecmp(imgdata.idata.make,\"Nikon\") && (!C.linear_max[0]) && (C.maximum > 1024) && (load_raw != &LibRaw::nikon_load_sraw)) {\n      C.linear_max[0] =\n        C.linear_max[1] =\n        C.linear_max[2] =\n        C.linear_max[3] =\n        (long) ((float)(C.maximum) / 1.07f);\n    }\n\n    // Correct WB for Samsung GX20\n    if  (!strcasecmp(imgdata.idata.make,\"Samsung\") && !strcasecmp(imgdata.idata.model,\"GX20\")) {\n      C.WB_Coeffs[LIBRAW_WBI_Daylight][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Daylight][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Shade][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Shade][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Cloudy][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Tungsten][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_D][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_D][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_N][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_N][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_W][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_W][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Flash][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Flash][2]) * 2.56f);\n      for (int c=0; c<64; c++) {\n        if (imgdata.color.WBCT_Coeffs[c][0] > 0.0f) {\n          imgdata.color.WBCT_Coeffs[c][3] *= 2.56f;\n        }\n      }\n    }\n\n\t// Adjust BL for Panasonic\n    if(load_raw == &LibRaw::panasonic_load_raw && (!strcasecmp(imgdata.idata.make,\"Panasonic\") || !strcasecmp(imgdata.idata.make,\"Leica\") ||  !strcasecmp(imgdata.idata.make,\"YUNEEC\"))\n       &&  ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])\n      {\n        C.black=0;\n        C.cblack[0] = ID.pana_black[0]+ID.pana_black[3];\n        C.cblack[1] = C.cblack[3] = ID.pana_black[1]+ID.pana_black[3];\n        C.cblack[2] = ID.pana_black[2]+ID.pana_black[3];\n        int i = C.cblack[3];\n        for(int c=0; c<3; c++) if(i>C.cblack[c]) i = C.cblack[c];\n        for(int c=0; c< 4; c++) C.cblack[c]-=i;\n        C.black = i;\n      }\n\n    // Adjust sizes for X3F processing\n    if(load_raw == &LibRaw::x3f_load_raw)\n    {\n        for(int i=0; i< foveon_count;i++)\n            if(!strcasecmp(imgdata.idata.make,foveon_data[i].make) && !strcasecmp(imgdata.idata.model,foveon_data[i].model)\n                && imgdata.sizes.raw_width == foveon_data[i].raw_width\n                && imgdata.sizes.raw_height == foveon_data[i].raw_height\n                )\n            {\n                imgdata.sizes.top_margin = foveon_data[i].top_margin;\n                imgdata.sizes.left_margin = foveon_data[i].left_margin;\n                imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;\n                imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;\n                C.maximum = foveon_data[i].white;\n                break;\n            }\n    }\n#if 0\n    size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;\n    float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);\n    float bpp2 = float(bytes)/float(S.width)/float(S.height);\n    printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);\n    if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)\n      {\n        load_raw = &LibRaw::hasselblad_full_load_raw;\n        S.width = S.raw_width;\n        S.height = S.raw_height;\n        P1.filters = 0;\n        P1.colors=3;\n        P1.raw_count=1;\n        C.maximum=0xffff;\n        printf(\"3 channel hassy found\\n\");\n      }\n#endif\n    if(C.profile_length)\n      {\n        if(C.profile) free(C.profile);\n        C.profile = malloc(C.profile_length);\n        merror(C.profile,\"LibRaw::open_file()\");\n        ID.input->seek(ID.profile_offset,SEEK_SET);\n        ID.input->read(C.profile,C.profile_length,1);\n      }\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee) {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n\n  if(P1.raw_count < 1)\n    return LIBRAW_FILE_UNSUPPORTED;\n\n\n  write_fun = &LibRaw::write_ppm_tiff;\n\n  if (load_raw == &LibRaw::kodak_ycbcr_load_raw)\n    {\n      S.height += S.height & 1;\n      S.width  += S.width  & 1;\n    }\n\n  IO.shrink = P1.filters && (O.half_size ||\n                             ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n\n  // Save color,sizes and internal data into raw_image fields\n  memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));\n  memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));\n  memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));\n  memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));\n\n  SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);\n\n\n  return LIBRAW_SUCCESS;\n}\n\n#ifdef USE_RAWSPEED\nvoid LibRaw::fix_after_rawspeed(int bl)\n{\n  if (load_raw == &LibRaw::lossy_dng_load_raw)\n    C.maximum = 0xffff;\n  else if (load_raw == &LibRaw::sony_load_raw)\n    C.maximum = 0x3ff0;\n}\n#else\nvoid LibRaw::fix_after_rawspeed(int)\n{\n}\n#endif\n\nvoid LibRaw::clearCancelFlag()\n{\n#ifdef WIN32\n\tInterlockedExchange(&_exitflag, 0);\n#else\n\t__sync_fetch_and_and(&_exitflag, 0);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n\tif (_rawspeed_decoder)\n\t{\n\t\tRawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);\n\t\td->resumeProcessing();\n\t}\n#endif\n\n}\n\nvoid LibRaw::setCancelFlag()\n{\n#ifdef WIN32\n  InterlockedExchange(&_exitflag,1);\n#else\n  __sync_fetch_and_add(&_exitflag,1);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n  if(_rawspeed_decoder)\n    {\n      RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);\n      d->cancelProcessing();\n    }\n#endif\n}\n\nvoid LibRaw::checkCancel()\n{\n#ifdef WIN32\n  if(InterlockedExchange(&_exitflag,0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#else\n  if( __sync_fetch_and_and(&_exitflag,0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\nint LibRaw::try_rawspeed()\n{\n#ifdef USE_RAWSPEED\n\tint ret=LIBRAW_SUCCESS;\n\n\tint rawspeed_ignore_errors = 0;\n\tif (imgdata.idata.dng_version && imgdata.idata.colors == 3 && !strcasecmp(imgdata.idata.software, \"Adobe Photoshop Lightroom 6.1.1 (Windows)\"))\n\t\trawspeed_ignore_errors = 1;\n\n\t// RawSpeed Supported,\n\t\tINT64 spos = ID.input->tell();\n\t\tvoid *_rawspeed_buffer = 0;\n\t\ttry\n\t\t{\n\t\t\t//                printf(\"Using rawspeed\\n\");\n\t\t\tID.input->seek(0,SEEK_SET);\n\t\t\tINT64 _rawspeed_buffer_sz = ID.input->size()+32;\n\t\t\t_rawspeed_buffer = malloc(_rawspeed_buffer_sz);\n\t\t\tif(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;\n\t\t\tID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);\n\t\t\tFileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);\n\t\t\tRawParser t(&map);\n\t\t\tRawDecoder *d = 0;\n\t\t\tCameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);\n\t\t\td = t.getDecoder();\n\t\t\tif(!d) throw \"Unable to find decoder\";\n\t\t\ttry {\n\t\t\t\td->checkSupport(meta);\n\t\t\t}\n\t\t\tcatch (const RawDecoderException& e)\n\t\t\t{\n\t\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\td->interpolateBadPixels = FALSE;\n\t\t\td->applyStage1DngOpcodes = FALSE;\n\t\t\t_rawspeed_decoder = static_cast<void*>(d);\n\t\t\td->decodeRaw();\n\t\t\td->decodeMetaData(meta);\n\t\t\tRawImage r = d->mRaw;\n\t\t\tif( r->errors.size()>0 && !rawspeed_ignore_errors)\n\t\t\t{\n\t\t\t\tdelete d;\n\t\t\t\t_rawspeed_decoder = 0;\n\t\t\t\tthrow 1;\n\t\t\t}\n\t\t\tif (r->isCFA)\n\t\t\t{\n\t\t\t\timgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);\n\t\t\t}\n\t\t\telse if(r->getCpp()==4)\n\t\t\t{\n\t\t\t\timgdata.rawdata.color4_image = (ushort(*)[4]) r->getDataUncropped(0,0);\n\t\t\t\tif(r->whitePoint > 0 && r->whitePoint < 65536)\n\t\t\t\t\tC.maximum = r->whitePoint;\n\t\t\t} else if(r->getCpp() == 3)\n\t\t\t{\n\t\t\t\timgdata.rawdata.color3_image = (ushort(*)[3]) r->getDataUncropped(0,0);\n\t\t\t\tif(r->whitePoint > 0 && r->whitePoint < 65536)\n\t\t\t\t\tC.maximum = r->whitePoint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelete d;\n\t\t\t\t_rawspeed_decoder = 0;\n\t\t\t\tret = LIBRAW_UNSPECIFIED_ERROR;\n\t\t\t}\n\t\t\tif(_rawspeed_decoder)\n\t\t\t{\n\t\t\t\t// set sizes\n\t\t\t\tiPoint2D rsdim = r->getUncroppedDim();\n\t\t\t\tS.raw_pitch = r->pitch;\n\t\t\t\tS.raw_width = rsdim.x;\n\t\t\t\tS.raw_height = rsdim.y;\n\t\t\t\t//C.maximum = r->whitePoint;\n\t\t\t\tfix_after_rawspeed(r->blackLevel);\n\t\t\t}\n\t\t\tfree(_rawspeed_buffer);\n\t\t\t_rawspeed_buffer = 0;\n\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;\n\t\t}\n\t\tcatch (const RawDecoderException& RDE)\n\t\t{\n\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n\t\t\tif (_rawspeed_buffer)\n\t\t\t{\n\t\t\t\tfree(_rawspeed_buffer);\n\t\t\t\t_rawspeed_buffer = 0;\n\t\t\t}\n\t\t\tconst char *p = RDE.what();\n\t\t\tif (!strncmp(RDE.what(), \"Decoder canceled\", strlen(\"Decoder canceled\")))\n\t\t\t\tthrow LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n\t\t\tret = LIBRAW_UNSPECIFIED_ERROR;\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\t// We may get here due to cancellation flag\n\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n\t\t\tif(_rawspeed_buffer)\n\t\t\t{\n\t\t\t\tfree(_rawspeed_buffer);\n\t\t\t\t_rawspeed_buffer = 0;\n\t\t\t}\n\t\t\tret = LIBRAW_UNSPECIFIED_ERROR;\n\t\t}\n\t\tID.input->seek(spos,SEEK_SET);\n\n\treturn ret;\n#else\n\treturn LIBRAW_NOT_IMPLEMENTED;\n#endif\n}\n\nint LibRaw::valid_for_dngsdk()\n{\n#ifndef USE_DNGSDK\n\treturn 0;\n#else\n\tif(!imgdata.idata.dng_version)\n\t\treturn 0;\n\tif(!imgdata.params.use_dngsdk)\n\t\treturn 0;\n\tif (load_raw == &LibRaw::lossy_dng_load_raw)\n\t\treturn 0;\n\tif(is_floating_point() && (imgdata.params.use_dngsdk & LIBRAW_DNG_FLOAT))\n\t\treturn 1;\n\tif(!imgdata.idata.filters && (imgdata.params.use_dngsdk & LIBRAW_DNG_LINEAR))\n\t\treturn 1;\n\tif(libraw_internal_data.unpacker_data.tiff_bps == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_8BIT))\n\t\treturn 1;\n\tif(libraw_internal_data.unpacker_data.tiff_compress == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_DEFLATE))\n\t\treturn 1;\n\tif(libraw_internal_data.unpacker_data.tiff_samples == 2 )\n\t\treturn 0; // Always deny 2-samples (old fuji superccd)\n\tif(imgdata.idata.filters == 9 && (imgdata.params.use_dngsdk & LIBRAW_DNG_XTRANS))\n\t\treturn 1;\n\tif(is_fuji_rotated())\n\t\treturn 0; // refuse\n\tif(imgdata.params.use_dngsdk & LIBRAW_DNG_OTHER)\n\t\treturn 1;\n\treturn 0;\n#endif\n}\n\n\nint LibRaw::is_curve_linear()\n{\n\tfor (int i=0; i < 0x10000; i++)\n\t\tif(imgdata.color.curve[i] != i)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n\nint LibRaw::try_dngsdk()\n{\n#ifdef USE_DNGSDK\n\tif(!dnghost)\n\t\treturn LIBRAW_UNSPECIFIED_ERROR;\n\n\tdng_host *host = static_cast<dng_host*>(dnghost);\n\n\ttry\n\t{\n\t\tlibraw_dng_stream stream(libraw_internal_data.internal_data.input);\n\n\t\tAutoPtr<dng_negative> negative;\n\t\tnegative.Reset (host->Make_dng_negative ());\n\n\t\tdng_info info;\n\t\tinfo.Parse (*host, stream);\n\t\tinfo.PostParse (*host);\n\n\t\tif (!info.IsValidDNG ())\n\t\t{\n\t\t\treturn LIBRAW_DATA_ERROR;\n\t\t}\n\t\tnegative->Parse (*host, stream, info);\n\t\tnegative->PostParse (*host, stream, info);\n\t\tnegative->ReadStage1Image (*host, stream, info);\n\t\tdng_simple_image *stage2 = (dng_simple_image *)negative->Stage1Image ();\n\t\tif(stage2->Bounds().W() != S.raw_width || stage2->Bounds().H()!= S.raw_height)\n\t\t{\n\t\t\treturn LIBRAW_DATA_ERROR;\n\t\t}\n\n\t\tint pplanes = stage2->Planes();\n\t\tint ptype = stage2->PixelType();\n\n\t\tdng_pixel_buffer buffer;\n\t\tstage2->GetPixelBuffer(buffer);\n\n\t\tint pixels =  stage2->Bounds().H () * stage2->Bounds().W () * pplanes;\n\t\tif(ptype == ttByte )\n\t\t\timgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ttShort));\n\t\telse\n\t\t\timgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ptype));\n\n\t\tif(ptype == ttShort && !is_curve_linear())\n\t\t{\n\t\t\tushort *src = (ushort *)buffer.fData;\n\t\t\tushort *dst = (ushort*)imgdata.rawdata.raw_alloc;\n\t\t\tfor(int i = 0; i < pixels; i++)\n\t\t\t\tdst[i] = imgdata.color.curve[src[i]];\n\t\t\tS.raw_pitch = S.raw_width*pplanes*TagTypeSize(ptype);\n\t\t}\n\t\telse if(ptype == ttByte)\n\t\t{\n\t\t\tunsigned char *src = (unsigned char *)buffer.fData;\n\t\t\tushort *dst = (ushort*)imgdata.rawdata.raw_alloc;\n\t\t\tif(is_curve_linear())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < pixels; i++)\n\t\t\t\t\tdst[i] = src[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < pixels; i++)\n\t\t\t\t\tdst[i] = imgdata.color.curve[src[i]];\n\t\t\t}\n\t\t\tS.raw_pitch = S.raw_width*pplanes*TagTypeSize(ttShort);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemmove(imgdata.rawdata.raw_alloc,buffer.fData,pixels * TagTypeSize(ptype));\n\t\t\tS.raw_pitch = S.raw_width*pplanes*TagTypeSize(ptype);\n\t\t}\n\n\t\tswitch(ptype)\n\t\t{\n\t\tcase ttFloat:\n\t\t\tif(pplanes==1)\n\t\t\t\timgdata.rawdata.float_image = (float*)imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 3)\n\t\t\t\timgdata.rawdata.float3_image = (float (*)[3])imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 4)\n\t\t\t\timgdata.rawdata.float4_image = (float (*)[4])imgdata.rawdata.raw_alloc;\n\t\t\tbreak;\n\n\t\tcase ttByte:\n\t\tcase ttShort:\n\t\t\tif(pplanes==1)\n\t\t\t\timgdata.rawdata.raw_image = (ushort*)imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 3)\n\t\t\t\timgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 4)\n\t\t\t\timgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* do nothing */\n\t\t\tbreak;\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t\treturn LIBRAW_UNSPECIFIED_ERROR;\n\t}\n\treturn imgdata.rawdata.raw_alloc?LIBRAW_SUCCESS:LIBRAW_UNSPECIFIED_ERROR;\n#else\n\treturn LIBRAW_UNSPECIFIED_ERROR;\n#endif\n}\nvoid LibRaw::set_dng_host(void *p)\n{\n#ifdef USE_DNGSDK\n\tdnghost = p;\n#endif\n}\n\nint LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try {\n\n    if(!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if(!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if(imgdata.image)\n      {\n        free(imgdata.image);\n        imgdata.image = 0;\n      }\n    if(imgdata.rawdata.raw_alloc)\n      {\n        free(imgdata.rawdata.raw_alloc);\n        imgdata.rawdata.raw_alloc = 0;\n      }\n    if (libraw_internal_data.unpacker_data.meta_length)\n      {\n        libraw_internal_data.internal_data.meta_data =\n          (char *) malloc (libraw_internal_data.unpacker_data.meta_length);\n        merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");\n      }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if( !IO.fuji_width)\n      {\n        // adjust non-Fuji allocation\n        if(rwidth < S.width + S.left_margin)\n          rwidth = S.width + S.left_margin;\n        if(rheight < S.height + S.top_margin)\n          rheight = S.height + S.top_margin;\n      }\n    if(rwidth > 65535 || rheight > 65535) // No way to make image larger than 64k pix\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n\timgdata.rawdata.float_image = 0;\n\timgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n\tif(imgdata.idata.dng_version && dnghost && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)\n\t{\n\t\tint rr = try_dngsdk();\n\t}\n#endif\n\n#ifdef USE_RAWSPEED\n\tif(!raw_was_read())\n\t{\n\t\tint rawspeed_enabled = 1;\n\n\t\tif(imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.raw_count > 1)\n\t\t\trawspeed_enabled = 0;\n\n\t\t// Disable rawspeed for double-sized Oly files\n\t\tif(!strncasecmp(imgdata.idata.make,\"Olympus\",7) &&\n\t\t\t( ( imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model,\"SH-2\",4) || !strncasecmp(imgdata.idata.model,\"SH-3\",4) || !strncasecmp(imgdata.idata.model,\"TG-4\",4))\n\t\t\t)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.dng_version && imgdata.idata.filters==0 && libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make,\"Nikon\",5) && !strncasecmp(imgdata.idata.model,\"E\",1) )\n\t\t\trawspeed_enabled = 0;\n\n\t\t// RawSpeed Supported,\n\t\tif(O.use_rawspeed  && rawspeed_enabled\n\t\t\t&& !(is_sraw() && (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)))\n\t\t\t&& (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n\t\t{\n\t\t\tint rr = try_rawspeed();\n\t\t}\n\t}\n#endif\n    if(!raw_was_read()) //RawSpeed failed or not run\n      {\n        // Not allocated on RawSpeed call, try call LibRaow\n\t\tint zero_rawimage = 0;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder and DNG float\n            // Do nothing! Decoder will allocate data internally\n          }\n        else if(imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n          {\n\n\t    if(INT64(rwidth)*INT64(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]) > LIBRAW_MAX_ALLOC_MB * INT64(1024*1024))\n\t      throw LIBRAW_EXCEPTION_ALLOC;\n\t    \n            imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]));\n            imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;\n            if(!S.raw_pitch)\n                S.raw_pitch = S.raw_width*2; // Bayer case, not set before\n          }\n        else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n          {\n            // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n            S.iwidth = S.width;\n            S.iheight= S.height;\n            IO.shrink = 0;\n\t\t\tif(!S.raw_pitch)\n\t\t\t\tS.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8;\n            // allocate image as temporary buffer, size\n            imgdata.rawdata.raw_alloc = 0;\n\t    if(INT64(MAX(S.width,S.raw_width))*INT64(MAX(S.height,S.raw_height))*sizeof(*imgdata.image) > LIBRAW_MAX_ALLOC_MB * INT64(1024*1024))\n\t      throw LIBRAW_EXCEPTION_ALLOC;\n\n            imgdata.image = (ushort (*)[4]) calloc(unsigned(MAX(S.width,S.raw_width))*unsigned(MAX(S.height,S.raw_height)),sizeof(*imgdata.image));\n\t\t\tif(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL))\n\t\t\t{\n\t\t\t\timgdata.rawdata.raw_image = (ushort*) imgdata.image ;\n\t\t\t\tzero_rawimage = 1;\n\t\t\t}\n          }\n        ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n        unsigned m_save = C.maximum;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum=65535;\n        (this->*load_raw)();\n\t\tif(zero_rawimage)\n\t\t\timgdata.rawdata.raw_image = 0;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum = m_save;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder only: do nothing\n\n          }\n        else if (!(imgdata.idata.filters || P1.colors == 1) ) // legacy decoder, ownalloc handled above\n          {\n            // successfully decoded legacy image, attach image to raw_alloc\n            imgdata.rawdata.raw_alloc = imgdata.image;\n\t\t    imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;\n            imgdata.image = 0;\n            // Restore saved values. Note: Foveon have masked frame\n            // Other 4-color legacy data: no borders\n\t\t\tif(!(libraw_internal_data.unpacker_data.load_flags & 256))\n\t\t\t{\n\t\t\t\tS.raw_width = S.width;\n\t\t\t\tS.left_margin = 0;\n\t\t\t\tS.raw_height = S.height;\n\t\t\t\tS.top_margin = 0;\n\t\t\t}\n          }\n      }\n\n    if(imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for(c=0;c<3;c++)\n      if (i > C.cblack[c]) i = C.cblack[c];\n    for (c=0;c<4;c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);\n\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee) {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}\n\nvoid LibRaw::unpacked_load_raw_fuji_f700s20()\n{\n  int base_offset = 0;\n  int row_size = imgdata.sizes.raw_width * 2; // in bytes\n  if(imgdata.idata.raw_count==2 && imgdata.params.shot_select)\n    {\n      libraw_internal_data.internal_data.input->seek(-row_size,SEEK_CUR);\n      base_offset = row_size; // in bytes\n    }\n  unsigned char *buffer = (unsigned char*)malloc(row_size*2);\n  for(int row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      read_shorts((ushort*)buffer,imgdata.sizes.raw_width * 2);\n      memmove(&imgdata.rawdata.raw_image[row*imgdata.sizes.raw_pitch/2],buffer+base_offset,row_size);\n    }\n  free(buffer);\n}\n\nvoid LibRaw::nikon_load_sraw()\n{\n  // We're already seeked to data!\n  unsigned char *rd = (unsigned char *)malloc(3*(imgdata.sizes.raw_width+2));\n  if(!rd) throw LIBRAW_EXCEPTION_ALLOC;\n  try {\n    int row,col;\n    for(row = 0; row < imgdata.sizes.raw_height; row++)\n      {\n        checkCancel();\n        libraw_internal_data.internal_data.input->read(rd,3,imgdata.sizes.raw_width);\n        for(col = 0; col < imgdata.sizes.raw_width-1;col+=2)\n          {\n            int bi = col*3;\n            ushort bits1 = (rd[bi+1] &0xf)<<8| rd[bi]; // 3,0,1\n            ushort bits2 = rd[bi+2] << 4 | ((rd[bi+1]>>4)& 0xf); //452\n            ushort bits3 =  ((rd[bi+4] & 0xf)<<8) | rd[bi+3]; // 967\n            ushort bits4 = rd[bi+5] << 4 | ((rd[bi+4]>>4)& 0xf); // ab8\n            imgdata.image[row*imgdata.sizes.raw_width+col][0]=bits1;\n            imgdata.image[row*imgdata.sizes.raw_width+col][1]=bits3;\n            imgdata.image[row*imgdata.sizes.raw_width+col][2]=bits4;\n            imgdata.image[row*imgdata.sizes.raw_width+col+1][0]=bits2;\n            imgdata.image[row*imgdata.sizes.raw_width+col+1][1]=2048;\n            imgdata.image[row*imgdata.sizes.raw_width+col+1][2]=2048;\n          }\n      }\n  }catch (...) {\n    free(rd);\n    throw ;\n  }\n  free(rd);\n  C.maximum = 0xfff; // 12 bit?\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n    {\n      return; // no CbCr interpolation\n    }\n  // Interpolate CC channels\n  int row,col;\n  for(row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      checkCancel(); // will throw out\n      for(col = 0; col < imgdata.sizes.raw_width;col+=2)\n        {\n          int col2 = col<imgdata.sizes.raw_width-2?col+2:col;\n          imgdata.image[row*imgdata.sizes.raw_width+col+1][1]\n            =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][1]\n                                  +imgdata.image[row*imgdata.sizes.raw_width+col2][1])/2);\n          imgdata.image[row*imgdata.sizes.raw_width+col+1][2]\n            =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][2]\n                                  +imgdata.image[row*imgdata.sizes.raw_width+col2][2])/2);\n        }\n    }\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n    return;\n\n  for(row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      checkCancel(); // will throw out\n      for(col = 0; col < imgdata.sizes.raw_width;col++)\n        {\n          float Y = float(imgdata.image[row*imgdata.sizes.raw_width+col][0])/2549.f;\n          float Ch2 = float(imgdata.image[row*imgdata.sizes.raw_width+col][1]-1280)/1536.f;\n          float Ch3 = float(imgdata.image[row*imgdata.sizes.raw_width+col][2]-1280)/1536.f;\n          if(Y>1.f) Y = 1.f;\n\t\t  if(Y>0.803f) Ch2 = Ch3 = 0.5f;\n          float r = Y + 1.40200f*(Ch3 - 0.5f);\n\t\t  if(r<0.f) r=0.f;\n\t\t  if(r>1.f) r=1.f;\n          float g = Y - 0.34414f*(Ch2-0.5f) - 0.71414*(Ch3 - 0.5f) ;\n\t\t  if(g>1.f) g = 1.f;\n\t\t  if(g<0.f) g = 0.f;\n          float b = Y + 1.77200*(Ch2-0.5f);\n\t\t  if(b>1.f) b = 1.f;\n\t\t  if(b<0.f) b = 0.f;\n          imgdata.image[row*imgdata.sizes.raw_width+col][0]=imgdata.color.curve[int(r*3072.f)];\n          imgdata.image[row*imgdata.sizes.raw_width+col][1]=imgdata.color.curve[int(g*3072.f)];\n          imgdata.image[row*imgdata.sizes.raw_width+col][2]=imgdata.color.curve[int(b*3072.f)];\n        }\n    }\n  C.maximum=16383;\n}\n\nvoid LibRaw::free_image(void)\n{\n  if(imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n      imgdata.progress_flags\n        = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN\n        |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;\n    }\n}\n\n\nvoid LibRaw::raw2image_start()\n{\n  // restore color,sizes and internal data into raw_image fields\n  memmove(&imgdata.color,&imgdata.rawdata.color,sizeof(imgdata.color));\n  memmove(&imgdata.sizes,&imgdata.rawdata.sizes,sizeof(imgdata.sizes));\n  memmove(&imgdata.idata,&imgdata.rawdata.iparams,sizeof(imgdata.idata));\n  memmove(&libraw_internal_data.internal_output_params,&imgdata.rawdata.ioparams,sizeof(libraw_internal_data.internal_output_params));\n\n  if (O.user_flip >= 0)\n    S.flip = O.user_flip;\n\n  switch ((S.flip+3600) % 360)\n    {\n    case 270:  S.flip = 5;  break;\n    case 180:  S.flip = 3;  break;\n    case  90:  S.flip = 6;  break;\n    }\n\n  // adjust for half mode!\n  IO.shrink = P1.filters && (O.half_size ||\n                             ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n\n}\n\nint LibRaw::is_phaseone_compressed()\n{\n  return (load_raw == &LibRaw::phase_one_load_raw_c || load_raw == &LibRaw::phase_one_load_raw);\n}\n\nint LibRaw::is_canon_600()\n{\n\treturn load_raw == &LibRaw::canon_600_load_raw;\n}\n\nint LibRaw::raw2image(void)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try {\n    raw2image_start();\n\n    if (is_phaseone_compressed())\n      {\n        phase_one_allocate_tempbuffer();\n        int rc = phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);\n\tif(rc == 0)\n\t  rc = phase_one_correct();\n\tif(rc!=0)\n\t{\n\t  phase_one_free_tempbuffer();\n\t  return rc;\n\t}\n      }\n\n    // free and re-allocate image bitmap\n    if(imgdata.image)\n      {\n        imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));\n        memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));\n      }\n    else\n      imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));\n\n    merror (imgdata.image, \"raw2image()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Move saved bitmap to imgdata.image\n    if( imgdata.idata.filters || P1.colors == 1)\n      {\n        if (IO.fuji_width) {\n          unsigned r,c;\n          int row,col;\n          for (row=0; row < S.raw_height-S.top_margin*2; row++) {\n            for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {\n              if (libraw_internal_data.unpacker_data.fuji_layout) {\n                r = IO.fuji_width - 1 - col + (row >> 1);\n                c = col + ((row+1) >> 1);\n              } else {\n                r = IO.fuji_width - 1 + row - (col >> 1);\n                c = row + ((col+1) >> 1);\n              }\n              if (r < S.height && c < S.width)\n                imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]\n                  = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n            }\n          }\n        }\n        else {\n          int row,col;\n          for (row=0; row < S.height; row++)\n            for (col=0; col < S.width; col++)\n              imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]\n                = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n        }\n      }\n    else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if(imgdata.rawdata.color4_image)\n          {\n            if(S.width*8 == S.raw_pitch)\n              memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));\n            else\n              {\n                for(int row = 0; row < S.height; row++)\n                  memmove(&imgdata.image[row*S.width],\n                          &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],\n                          S.width*sizeof(*imgdata.image));\n              }\n          }\n        else if(imgdata.rawdata.color3_image)\n          {\n            unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;\n            for(int row = 0; row < S.height; row++)\n              {\n                ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];\n                ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];\n                for(int col=0; col < S.width; col++)\n                  {\n                    for(int c=0; c< 3; c++)\n                      dstrow[col][c] = srcrow[S.left_margin+col][c];\n                    dstrow[col][3]=0;\n                  }\n              }\n          }\n        else\n          {\n            // legacy decoder, but no data?\n            throw LIBRAW_EXCEPTION_DECODE_RAW;\n          }\n      }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n      {\n        phase_one_free_tempbuffer();\n      }\n    // hack - clear later flags!\n\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n      {\n        canon_600_correct();\n      }\n\n    imgdata.progress_flags\n      = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE\n      |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nvoid LibRaw::phase_one_allocate_tempbuffer()\n{\n  // Allocate temp raw_image buffer\n  imgdata.rawdata.raw_image = (ushort*)malloc(S.raw_pitch*S.raw_height);\n  merror (imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");\n}\nvoid LibRaw::phase_one_free_tempbuffer()\n{\n\tfree(imgdata.rawdata.raw_image);\n\timgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;\n}\n\nint LibRaw::phase_one_subtract_black(ushort *src, ushort *dest)\n{\n\n  try\n    {\n      if (O.user_black < 0 && O.user_cblack[0] <= -1000000 && O.user_cblack[1] <= -1000000 && O.user_cblack[2] <= -1000000 && O.user_cblack[3] <= -1000000)\n        {\n          if (!imgdata.rawdata.ph1_cblack || !imgdata.rawdata.ph1_rblack)\n            {\n              register int bl = imgdata.color.phase_one_data.t_black;\n              for (int row = 0; row < S.raw_height; row++)\n                {\n                  checkCancel();\n                  for (int col = 0; col < S.raw_width; col++)\n                    {\n                      int idx = row*S.raw_width + col;\n                      int val = int(src[idx]) - bl;\n                      dest[idx] = val>0 ? val : 0;\n                    }\n                }\n            }\n          else\n            {\n              register int bl = imgdata.color.phase_one_data.t_black;\n              for (int row = 0; row < S.raw_height; row++)\n                {\n                  checkCancel();\n                  for (int col = 0; col < S.raw_width; col++)\n                    {\n                      int idx = row*S.raw_width + col;\n                      int val = int(src[idx]) - bl\n                      + imgdata.rawdata.ph1_cblack[row][col >= imgdata.rawdata.color.phase_one_data.split_col]\n                        + imgdata.rawdata.ph1_rblack[col][row >= imgdata.rawdata.color.phase_one_data.split_row];\n                      dest[idx] = val>0 ? val : 0;\n                    }\n                }\n            }\n        }\n      else // black set by user interaction\n        {\n          // Black level in cblack!\n          for (int row = 0; row < S.raw_height; row++)\n            {\n              checkCancel();\n              unsigned short cblk[16];\n              for (int cc = 0; cc < 16; cc++)\n                cblk[cc] = C.cblack[fcol(row, cc)];\n              for (int col = 0; col < S.raw_width; col++)\n                {\n                  int idx = row*S.raw_width + col;\n                  ushort val = src[idx];\n                  ushort bl = cblk[col & 0xf];\n                  dest[idx] = val>bl ? val - bl : 0;\n                }\n            }\n        }\n      return 0;\n    }\n  catch (LibRaw_exceptions err) {\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n}\n\nvoid LibRaw::copy_fuji_uncropped(unsigned short cblack[4],unsigned short *dmaxp)\n{\n  int row;\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row=0; row < S.raw_height-S.top_margin*2; row++)\n    {\n      int col;\n      unsigned short ldmax = 0;\n      for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)\n        {\n          unsigned r,c;\n          if (libraw_internal_data.unpacker_data.fuji_layout) {\n            r = IO.fuji_width - 1 - col + (row >> 1);\n            c = col + ((row+1) >> 1);\n          } else {\n            r = IO.fuji_width - 1 + row - (col >> 1);\n            c = row + ((col+1) >> 1);\n          }\n          if (r < S.height && c < S.width)\n            {\n              unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n              int cc = FC(r,c);\n              if(val>cblack[cc])\n                {\n                  val-=cblack[cc];\n                  if(val>ldmax)ldmax = val;\n                }\n              else\n                val = 0;\n              imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][cc] = val;\n            }\n        }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n      {\n        if(*dmaxp < ldmax)\n          *dmaxp = ldmax;\n      }\n    }\n}\n\nvoid LibRaw::copy_bayer(unsigned short cblack[4],unsigned short *dmaxp)\n{\n  // Both cropped and uncropped\n  int row;\n\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row=0; row < S.height; row++)\n    {\n      int col;\n      unsigned short ldmax = 0;\n      for (col=0; col < S.width; col++)\n        {\n          unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n          int cc = fcol(row,col);\n          if(val>cblack[cc])\n            {\n              val-=cblack[cc];\n              if(val>ldmax)ldmax = val;\n            }\n          else\n            val = 0;\n          imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][cc] = val;\n        }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n      {\n        if(*dmaxp < ldmax)\n          *dmaxp = ldmax;\n      }\n    }\n}\n\n\nint LibRaw::raw2image_ex(int do_subtract_black)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try {\n    raw2image_start();\n\n    // Compressed P1 files with bl data!\n    if (is_phaseone_compressed())\n      {\n        phase_one_allocate_tempbuffer();\n        int rc = phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);\n\tif(rc == 0)\n\t  rc = phase_one_correct();\n\tif(rc!=0)\n\t  {\n\t    phase_one_free_tempbuffer();\n\t    return rc;\n\t  }\n      }\n\n    // process cropping\n    int do_crop = 0;\n    unsigned save_width = S.width;\n    if (~O.cropbox[2] && ~O.cropbox[3]\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        && load_raw != &LibRaw::foveon_sd_load_raw\n#endif\n        ) // Foveon SD to be cropped later\n      {\n        int crop[4],c,filt;\n        for(int c=0;c<4;c++)\n          {\n            crop[c] = O.cropbox[c];\n            if(crop[c]<0)\n              crop[c]=0;\n          }\n\n        if(IO.fuji_width && imgdata.idata.filters >= 1000)\n          {\n            crop[0] = (crop[0]/4)*4;\n            crop[1] = (crop[1]/4)*4;\n            if(!libraw_internal_data.unpacker_data.fuji_layout)\n              {\n                crop[2]*=sqrt(2.0);\n                crop[3]/=sqrt(2.0);\n              }\n            crop[2] = (crop[2]/4+1)*4;\n            crop[3] = (crop[3]/4+1)*4;\n          }\n        else if (imgdata.idata.filters == 1)\n          {\n            crop[0] = (crop[0]/16)*16;\n            crop[1] = (crop[1]/16)*16;\n          }\n        else if(imgdata.idata.filters == LIBRAW_XTRANS)\n          {\n            crop[0] = (crop[0]/6)*6;\n            crop[1] = (crop[1]/6)*6;\n          }\n        do_crop = 1;\n\n        crop[2] = MIN (crop[2], (signed) S.width-crop[0]);\n        crop[3] = MIN (crop[3], (signed) S.height-crop[1]);\n        if (crop[2] <= 0 || crop[3] <= 0)\n          throw LIBRAW_EXCEPTION_BAD_CROP;\n\n        // adjust sizes!\n        S.left_margin+=crop[0];\n        S.top_margin+=crop[1];\n        S.width=crop[2];\n        S.height=crop[3];\n\n        S.iheight = (S.height + IO.shrink) >> IO.shrink;\n        S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n        if(!IO.fuji_width && imgdata.idata.filters && imgdata.idata.filters >= 1000)\n          {\n            for (filt=c=0; c < 16; c++)\n              filt |= FC((c >> 1)+(crop[1]),\n                         (c &  1)+(crop[0])) << c*2;\n            imgdata.idata.filters = filt;\n          }\n      }\n\n    int alloc_width = S.iwidth;\n    int alloc_height = S.iheight;\n\n    if(IO.fuji_width && do_crop)\n      {\n        int IO_fw = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n        int t_alloc_width = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO_fw;\n        int t_alloc_height = t_alloc_width - 1;\n        alloc_height = (t_alloc_height + IO.shrink) >> IO.shrink;\n        alloc_width = (t_alloc_width + IO.shrink) >> IO.shrink;\n      }\n    int alloc_sz = alloc_width*alloc_height;\n\n    if(imgdata.image)\n      {\n        imgdata.image = (ushort (*)[4]) realloc (imgdata.image,alloc_sz *sizeof (*imgdata.image));\n        memset(imgdata.image,0,alloc_sz *sizeof (*imgdata.image));\n      }\n    else\n      imgdata.image = (ushort (*)[4]) calloc (alloc_sz, sizeof (*imgdata.image));\n    merror (imgdata.image, \"raw2image_ex()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Adjust black levels\n    unsigned short cblack[4]={0,0,0,0};\n    unsigned short dmax = 0;\n    if(do_subtract_black)\n      {\n        adjust_bl();\n        for(int i=0; i< 4; i++)\n          cblack[i] = (unsigned short)C.cblack[i];\n      }\n\n    // Move saved bitmap to imgdata.image\n    if(imgdata.idata.filters || P1.colors == 1)\n      {\n        if (IO.fuji_width)\n          {\n            if(do_crop)\n              {\n                IO.fuji_width = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n                int IO_fwidth = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO.fuji_width;\n                int IO_fheight = IO_fwidth - 1;\n\n                int row,col;\n                for(row=0;row<S.height;row++)\n                  {\n                    for(col=0;col<S.width;col++)\n                      {\n                        int r,c;\n                        if (libraw_internal_data.unpacker_data.fuji_layout) {\n                          r = IO.fuji_width - 1 - col + (row >> 1);\n                          c = col + ((row+1) >> 1);\n                        } else {\n                          r = IO.fuji_width - 1 + row - (col >> 1);\n                          c = row + ((col+1) >> 1);\n                        }\n\n                        unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2\n                                                            +(col+S.left_margin)];\n                        int cc = FCF(row,col);\n                        if(val > cblack[cc])\n                          {\n                            val-=cblack[cc];\n                            if(dmax < val) dmax = val;\n                          }\n                        else\n                          val = 0;\n                        imgdata.image[((r) >> IO.shrink)*alloc_width + ((c) >> IO.shrink)][cc] = val;\n                      }\n                  }\n                S.height = IO_fheight;\n                S.width = IO_fwidth;\n                S.iheight = (S.height + IO.shrink) >> IO.shrink;\n                S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n                S.raw_height -= 2*S.top_margin;\n              }\n            else\n              {\n                copy_fuji_uncropped(cblack,&dmax);\n              }\n          } // end Fuji\n        else\n          {\n            copy_bayer(cblack,&dmax);\n          }\n      }\n    else //if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if(imgdata.rawdata.color4_image)\n          {\n            if(S.raw_pitch != S.width*8)\n              {\n                for(int row = 0; row < S.height; row++)\n                  memmove(&imgdata.image[row*S.width],\n                          &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],\n                          S.width*sizeof(*imgdata.image));\n              }\n            else\n              {\n                // legacy is always 4channel and not shrinked!\n                memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));\n              }\n          }\n        else if(imgdata.rawdata.color3_image)\n          {\n            unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;\n            for(int row = 0; row < S.height; row++)\n              {\n                ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];\n                ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];\n                for(int col=0; col < S.width; col++)\n                  {\n                    for(int c=0; c< 3; c++)\n                      dstrow[col][c] = srcrow[S.left_margin+col][c];\n                    dstrow[col][3]=0;\n                  }\n              }\n          }\n        else\n          {\n            // legacy decoder, but no data?\n            throw LIBRAW_EXCEPTION_DECODE_RAW;\n          }\n      }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n      {\n\t\t  phase_one_free_tempbuffer();\n      }\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n      {\n        canon_600_correct();\n      }\n\n    if(do_subtract_black)\n      {\n        C.data_maximum = (int)dmax;\n        C.maximum -= C.black;\n        //        ZERO(C.cblack);\n        C.cblack[0]=C.cblack[1]=C.cblack[2]=C.cblack[3]=0;\n        C.black = 0;\n      }\n\n    // hack - clear later flags!\n    imgdata.progress_flags\n      = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE\n      |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#if 1\n\nlibraw_processed_image_t * LibRaw::dcraw_make_mem_thumb(int *errcode)\n{\n  if(!T.thumb)\n    {\n      if ( !ID.toffset\n        && !(imgdata.thumbnail.tlength>0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n        )\n        {\n          if(errcode) *errcode= LIBRAW_NO_THUMBNAIL;\n        }\n      else\n        {\n          if(errcode) *errcode= LIBRAW_OUT_OF_ORDER_CALL;\n        }\n      return NULL;\n    }\n\n  if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)\n    {\n      libraw_processed_image_t * ret =\n        (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+T.tlength);\n\n      if(!ret)\n        {\n          if(errcode) *errcode= ENOMEM;\n          return NULL;\n        }\n\n      memset(ret,0,sizeof(libraw_processed_image_t));\n      ret->type   = LIBRAW_IMAGE_BITMAP;\n      ret->height = T.theight;\n      ret->width  = T.twidth;\n      ret->colors = 3;\n      ret->bits   = 8;\n      ret->data_size = T.tlength;\n      memmove(ret->data,T.thumb,T.tlength);\n      if(errcode) *errcode= 0;\n      return ret;\n    }\n  else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)\n    {\n      ushort exif[5];\n      int mk_exif = 0;\n      if(strcmp(T.thumb+6,\"Exif\")) mk_exif = 1;\n\n      int dsize = T.tlength + mk_exif * (sizeof(exif)+sizeof(tiff_hdr));\n\n      libraw_processed_image_t * ret =\n        (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+dsize);\n\n      if(!ret)\n        {\n          if(errcode) *errcode= ENOMEM;\n          return NULL;\n        }\n\n      memset(ret,0,sizeof(libraw_processed_image_t));\n\n      ret->type = LIBRAW_IMAGE_JPEG;\n      ret->data_size = dsize;\n\n      ret->data[0] = 0xff;\n      ret->data[1] = 0xd8;\n      if(mk_exif)\n        {\n          struct tiff_hdr th;\n          memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n          exif[1] = htons (8 + sizeof th);\n          memmove(ret->data+2,exif,sizeof(exif));\n          tiff_head (&th, 0);\n          memmove(ret->data+(2+sizeof(exif)),&th,sizeof(th));\n          memmove(ret->data+(2+sizeof(exif)+sizeof(th)),T.thumb+2,T.tlength-2);\n        }\n      else\n        {\n          memmove(ret->data+2,T.thumb+2,T.tlength-2);\n        }\n      if(errcode) *errcode= 0;\n      return ret;\n\n    }\n  else\n    {\n      if(errcode) *errcode= LIBRAW_UNSUPPORTED_THUMBNAIL;\n      return NULL;\n    }\n}\n\n\n\n// jlb\n// macros for copying pixels to either BGR or RGB formats\n#define FORBGR for(c=P1.colors-1; c >=0 ; c--)\n#define FORRGB for(c=0; c < P1.colors ; c++)\n\nvoid LibRaw::get_mem_image_format(int* width, int* height, int* colors, int* bps) const\n\n{\n  if (S.flip & 4) {\n    *width = S.height;\n    *height = S.width;\n  }\n  else {\n    *width = S.width;\n    *height = S.height;\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}\n\nint LibRaw::copy_mem_image(void* scan0, int stride, int bgr)\n\n{\n    // the image memory pointed to by scan0 is assumed to be in the format returned by get_mem_image_format\n    if((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < LIBRAW_PROGRESS_PRE_INTERPOLATE)\n        return LIBRAW_OUT_OF_ORDER_CALL;\n\n    if(libraw_internal_data.output_data.histogram)\n      {\n        int perc, val, total, t_white=0x2000,c;\n        perc = S.width * S.height * O.auto_bright_thr;\n        if (IO.fuji_width) perc /= 2;\n        if (!((O.highlight & ~2) || O.no_auto_bright))\n          for (t_white=c=0; c < P1.colors; c++) {\n            for (val=0x2000, total=0; --val > 32; )\n              if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;\n            if (t_white < val) t_white = val;\n          }\n        gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);\n      }\n\n    int s_iheight = S.iheight;\n    int s_iwidth = S.iwidth;\n    int s_width = S.width;\n    int s_hwight = S.height;\n\n    S.iheight = S.height;\n    S.iwidth  = S.width;\n\n    if (S.flip & 4) SWAP(S.height,S.width);\n    uchar *ppm;\n    ushort *ppm2;\n    int c, row, col, soff, rstep, cstep;\n\n    soff  = flip_index (0, 0);\n    cstep = flip_index (0, 1) - soff;\n    rstep = flip_index (1, 0) - flip_index (0, S.width);\n\n    for (row=0; row < S.height; row++, soff += rstep)\n      {\n        uchar *bufp = ((uchar*)scan0)+row*stride;\n        ppm2 = (ushort*) (ppm = bufp);\n        // keep trivial decisions in the outer loop for speed\n        if (bgr) {\n          if (O.output_bps == 8) {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]]>>8;\n          }\n          else {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n          }\n        }\n        else {\n          if (O.output_bps == 8) {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]]>>8;\n          }\n          else {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n          }\n        }\n\n//            bufp += stride;           // go to the next line\n      }\n\n    S.iheight = s_iheight;\n    S.iwidth = s_iwidth;\n    S.width = s_width;\n    S.height = s_hwight;\n\n    return 0;\n\n\n}\n#undef FORBGR\n#undef FORRGB\n\n\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_image(int *errcode)\n\n{\n    int width, height, colors, bps;\n    get_mem_image_format(&width, &height, &colors, &bps);\n    int stride = width * (bps/8) * colors;\n    unsigned ds = height * stride;\n    libraw_processed_image_t *ret = (libraw_processed_image_t*)::malloc(sizeof(libraw_processed_image_t)+ds);\n    if(!ret)\n        {\n                if(errcode) *errcode= ENOMEM;\n                return NULL;\n        }\n    memset(ret,0,sizeof(libraw_processed_image_t));\n\n    // metadata init\n    ret->type   = LIBRAW_IMAGE_BITMAP;\n    ret->height = height;\n    ret->width  = width;\n    ret->colors = colors;\n    ret->bits   = bps;\n    ret->data_size = ds;\n    copy_mem_image(ret->data, stride, 0);\n\n    return ret;\n}\n\n#undef FORC\n#undef FORCC\n#undef SWAP\n#endif\n\n\nint LibRaw::dcraw_ppm_tiff_writer(const char *filename)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  if(!imgdata.image)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if(!filename)\n    return ENOENT;\n  FILE *f = fopen(filename,\"wb\");\n\n  if(!f)\n    return errno;\n\n  try {\n    if(!libraw_internal_data.output_data.histogram)\n      {\n        libraw_internal_data.output_data.histogram =\n          (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);\n        merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_ppm_tiff_writer()\");\n      }\n    libraw_internal_data.internal_data.output = f;\n    write_ppm_tiff();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    libraw_internal_data.internal_data.output = NULL;\n    fclose(f);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(f);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#define THUMB_READ_BEYOND  16384\n\nvoid LibRaw::kodak_thumb_loader()\n{\n\tINT64 est_datasize = T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n\tif (ID.toffset < 0)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\tif (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n\t\tthrow LIBRAW_EXCEPTION_IO_EOF;\n\n\t// some kodak cameras\n  ushort s_height = S.height, s_width = S.width,s_iwidth = S.iwidth,s_iheight=S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort (*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width  = T.twidth;\n  P1.filters = 0;\n\n  if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)\n    {\n      S.height += S.height & 1;\n      S.width  += S.width  & 1;\n    }\n\n  imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));\n  merror (imgdata.image, \"LibRaw::kodak_thumb_loader()\");\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try {\n\t  (this->*thumb_load_raw)();\n  } catch (...)\n  {\n\t  free(imgdata.image);\n\t  imgdata.image  = s_image;\n\n\t  T.twidth = 0;\n\t  S.width = s_width;\n\n\t  S.iwidth = s_iwidth;\n\t  S.iheight = s_iheight;\n\n\t  T.theight = 0;\n\t  S.height = s_height;\n\n\t  T.tcolors = 0;\n\t  P1.colors = s_colors;\n\n\t  P1.filters = s_filters;\n\t  T.tlength=0;\n\t  libraw_internal_data.unpacker_data.load_flags = s_flags;\n\t  return;\n  }\n\n  // copy-n-paste from image pipe\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#ifndef CLIP\n#define CLIP(x) LIM(x,0,65535)\n#endif\n#define SWAP(a,b) { a ^= b; a ^= (b ^= a); }\n\n  // from scale_colors\n  {\n    double   dmax;\n    float scale_mul[4];\n    int c,val;\n    for (dmax=DBL_MAX, c=0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for( c=0; c< 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i=0; i < size*4 ; i++)\n      {\n        val = imgdata.image[0][i];\n        if(!val) continue;\n        val *= scale_mul[i & 3];\n        imgdata.image[0][i] = CLIP(val);\n      }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row,col;\n\n  int  (*t_hist)[LIBRAW_HISTOGRAM_SIZE] =  (int (*)[LIBRAW_HISTOGRAM_SIZE]) calloc(sizeof(*t_hist),4);\n  merror (t_hist, \"LibRaw::kodak_thumb_loader()\");\n\n  float out[3],\n    out_cam[3][4] =\n    {\n      {2.81761312, -1.98369181, 0.166078627, 0},\n      {-0.111855984, 1.73688626, -0.625030339, 0},\n      {-0.0379119813, -0.891268849, 1.92918086, 0}\n    };\n\n  for (img=imgdata.image[0], row=0; row < S.height; row++)\n    for (col=0; col < S.width; col++, img+=4)\n      {\n        out[0] = out[1] = out[2] = 0;\n        int c;\n        for(c=0;c<3;c++)\n          {\n            out[0] += out_cam[0][c] * img[c];\n            out[1] += out_cam[1][c] * img[c];\n            out[2] += out_cam[2][c] * img[c];\n          }\n        for(c=0; c<3; c++)\n          img[c] = CLIP((int) out[c]);\n        for(c=0; c<P1.colors;c++)\n          t_hist[c][img[c] >> 3]++;\n\n      }\n\n  // from gamma_lut\n  int  (*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort (*t_curve) = (ushort*) calloc(sizeof(C.curve),1);\n  merror (t_curve, \"LibRaw::kodak_thumb_loader()\");\n  memmove(t_curve,C.curve,sizeof(C.curve));\n  memset(C.curve,0,sizeof(C.curve));\n  {\n    int perc, val, total, t_white=0x2000,c;\n\n    perc = S.width * S.height * 0.01;\t\t/* 99th percentile white level */\n    if (IO.fuji_width) perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white=c=0; c < P1.colors; c++) {\n        for (val=0x2000, total=0; --val > 32; )\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;\n        if (t_white < val) t_white = val;\n      }\n    gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  S.iheight = S.height;\n  S.iwidth  = S.width;\n  if (S.flip & 4) SWAP(S.height,S.width);\n\n  if(T.thumb) free(T.thumb);\n  T.thumb = (char*) calloc (S.width * S.height, P1.colors);\n  merror (T.thumb, \"LibRaw::kodak_thumb_loader()\");\n  T.tlength = S.width * S.height * P1.colors;\n\n// from write_tiff_ppm\n  {\n\t  int soff = flip_index(0, 0);\n\t  int cstep = flip_index(0, 1) - soff;\n\t  int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n\t  for (int row = 0; row < S.height; row++, soff += rstep)\n\t  {\n\t\t  char *ppm = T.thumb + row*S.width*P1.colors;\n\t\t  for (int col = 0; col < S.width; col++, soff += cstep)\n\t\t\t  for (int c = 0; c < P1.colors; c++)\n\t\t\t\t  ppm[col*P1.colors + c] = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n\t  }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n#undef SWAP\n\n\n// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumbnail \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd, \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumb_format \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\nint LibRaw::thumbOK(INT64 maxsz)\n{\n\tif (!ID.input) return 0;\n\tif (!ID.toffset\n\t\t&& !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n\t\t) return 0;\n\tINT64 fsize = ID.input->size();\n\tif (fsize > 0x7fffffffU) return 0; // No thumb for raw > 2Gb\n\tint tsize = 0;\n\tint tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;\n\tif (write_thumb == &LibRaw::jpeg_thumb)\n\t\ttsize = T.tlength;\n\telse if (write_thumb == &LibRaw::ppm_thumb)\n\t\ttsize = tcol * T.twidth * T.theight;\n\telse if (write_thumb == &LibRaw::ppm16_thumb)\n\t\ttsize = tcol * T.twidth * T.theight * 2;\n\telse if (write_thumb == &LibRaw::x3f_thumb_loader)\n\t{\n\t\ttsize = x3f_thumb_size();\n\t}\n\telse // Kodak => no check\n\t\ttsize = 1;\n\tif (tsize < 0)\n\t\treturn 0;\n\tif (maxsz > 0 && tsize > maxsz)\n\t\treturn 0;\n\treturn (tsize + ID.toffset <= fsize) ? 1 : 0;\n}\n\nint LibRaw::unpack_thumb(void)\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n\tCHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n\ttry {\n\t\tif (!libraw_internal_data.internal_data.input)\n\t\t\treturn LIBRAW_INPUT_CLOSED;\n\n\t\tif (!ID.toffset &&\n\t\t\t!(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n\t\t\t)\n\t\t{\n\t\t\treturn LIBRAW_NO_THUMBNAIL;\n\t\t}\n\t\telse if (thumb_load_raw)\n\t\t{\n\t\t\tkodak_thumb_loader();\n\t\t\tT.tformat = LIBRAW_THUMBNAIL_BITMAP;\n\t\t\tSET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (write_thumb == &LibRaw::x3f_thumb_loader)\n\t\t\t{\n\t\t\t\tINT64 tsize = x3f_thumb_size();\n\t\t\t\tif (tsize < 2048 ||INT64(ID.toffset) + tsize < 1)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\t\t\t\tif (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_EOF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (INT64(ID.toffset) + INT64(T.tlength) < 1)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\t\t\t\tif (INT64(ID.toffset) + INT64(T.tlength) > ID.input->size() + THUMB_READ_BEYOND)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_EOF;\n\t\t\t}\n\n        ID.input->seek(ID.toffset, SEEK_SET);\n        if ( write_thumb == &LibRaw::jpeg_thumb)\n          {\n            if(T.thumb) free(T.thumb);\n            T.thumb = (char *) malloc (T.tlength);\n            merror (T.thumb, \"jpeg_thumb()\");\n            ID.input->read (T.thumb, 1, T.tlength);\n\t\t\tT.thumb[0] = 0xff;\n\t\t\tT.thumb[1] = 0xd8;\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_JPEG;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        else if (write_thumb == &LibRaw::ppm_thumb)\n          {\n            T.tlength = T.twidth * T.theight*3;\n            if(T.thumb) free(T.thumb);\n\n            T.thumb = (char *) malloc (T.tlength);\n            merror (T.thumb, \"ppm_thumb()\");\n\n            ID.input->read(T.thumb, 1, T.tlength);\n\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n\n          }\n        else if (write_thumb == &LibRaw::ppm16_thumb)\n          {\n            T.tlength = T.twidth * T.theight*3;\n            ushort *t_thumb = (ushort*)calloc(T.tlength,2);\n            ID.input->read(t_thumb,2,T.tlength);\n            if ((libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234))\n              swab ((char*)t_thumb, (char*)t_thumb, T.tlength*2);\n\n            if(T.thumb) free(T.thumb);\n            T.thumb = (char *) malloc (T.tlength);\n            merror (T.thumb, \"ppm_thumb()\");\n            for (int i=0; i < T.tlength; i++)\n              T.thumb[i] = t_thumb[i] >> 8;\n            free(t_thumb);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n\n          }\n        else if (write_thumb == &LibRaw::x3f_thumb_loader)\n          {\n            x3f_thumb_loader();\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        else if (write_thumb == &LibRaw::foveon_thumb)\n          {\n            foveon_thumb_loader();\n            // may return with error, so format is set in\n            // foveon thumb loader itself\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        // else if -- all other write_thumb cases!\n#endif\n        else\n          {\n            return LIBRAW_UNSUPPORTED_THUMBNAIL;\n          }\n      }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n\n}\n\nint LibRaw::dcraw_thumb_writer(const char *fname)\n{\n//    CHECK_ORDER_LOW(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  if(!fname)\n    return ENOENT;\n\n  FILE *tfp = fopen(fname,\"wb\");\n\n  if(!tfp)\n    return errno;\n\n  if(!T.thumb)\n    {\n      fclose(tfp);\n      return LIBRAW_OUT_OF_ORDER_CALL;\n    }\n\n  try {\n    switch (T.tformat)\n      {\n      case LIBRAW_THUMBNAIL_JPEG:\n        jpeg_thumb_writer (tfp,T.thumb,T.tlength);\n        break;\n      case LIBRAW_THUMBNAIL_BITMAP:\n        fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n        fwrite (T.thumb, 1, T.tlength, tfp);\n        break;\n      default:\n        fclose(tfp);\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    fclose(tfp);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nint LibRaw::adjust_sizes_info_only(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n\n  raw2image_start();\n  if (O.use_fuji_rotate)\n    {\n      if (IO.fuji_width)\n        {\n          IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n          S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));\n          S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));\n        }\n      else\n        {\n          if (S.pixel_aspect < 0.995) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);\n          if (S.pixel_aspect > 1.005) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);\n        }\n    }\n  SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n  if ( S.flip & 4)\n    {\n      unsigned short t = S.iheight;\n      S.iheight=S.iwidth;\n      S.iwidth = t;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    }\n  return 0;\n}\n\nint LibRaw::subtract_black()\n{\n  adjust_bl();\n  return subtract_black_internal();\n}\n\nint LibRaw::subtract_black_internal()\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\n  try {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3] || (C.cblack[4] && C.cblack[5]) ))\n      {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]\n        int cblk[4],i;\n        for(i=0;i<4;i++)\n          cblk[i] = C.cblack[i];\n\n        int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n        int dmax = 0;\n        if(C.cblack[4] && C.cblack[5])\n          {\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= C.cblack[6 + i/4 / S.iwidth % C.cblack[4] * C.cblack[5] +\n\t\t\ti/4 % S.iwidth % C.cblack[5]];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(dmax < val) dmax = val;\n              }\n          }\n        else\n          {\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(dmax < val) dmax = val;\n              }\n          }\n        C.data_maximum = dmax & 0xffff;\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n        C.maximum -= C.black;\n        ZERO(C.cblack); // Yeah, we used cblack[6+] values too!\n        C.black = 0;\n#undef BAYERC\n      }\n    else\n      {\n        // Nothing to Do, maximum is already calculated, black level is 0, so no change\n        // only calculate channel maximum;\n        int idx;\n        ushort *p = (ushort*)imgdata.image;\n        int dmax = 0;\n        for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n          if(dmax < p[idx]) dmax = p[idx];\n        C.data_maximum = dmax;\n      }\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n\n}\n\n#define TBLN 65535\n\nvoid LibRaw::exp_bef(float shift, float smooth)\n{\n  // params limits\n  if(shift>8) shift = 8;\n  if(shift<0.25) shift = 0.25;\n  if(smooth < 0.0) smooth = 0.0;\n  if(smooth > 1.0) smooth = 1.0;\n\n  unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));\n\n  if(shift <=1.0)\n    {\n      for(int i=0;i<=TBLN;i++)\n        lut[i] = (unsigned short)((float)i*shift);\n    }\n  else\n    {\n      float x1,x2,y1,y2;\n\n      float cstops = log(shift)/log(2.0f);\n      float room = cstops*2;\n      float roomlin = powf(2.0f,room);\n      x2 = (float)TBLN;\n      x1 = (x2+1)/roomlin-1;\n      y1 = x1*shift;\n      y2 = x2*(1+(1-smooth)*(shift-1));\n      float sq3x=powf(x1*x1*x2,1.0f/3.0f);\n      float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);\n      float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);\n      float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;\n      for(int i=0;i<=TBLN;i++)\n        {\n          float X = (float)i;\n          float Y = A*powf(X,1.0f/3.0f)+B*X+CC;\n          if(i<x1)\n            lut[i] = (unsigned short)((float)i*shift);\n          else\n            lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));\n        }\n    }\n  for(int i=0; i< S.height*S.width; i++)\n    {\n      imgdata.image[i][0] = lut[imgdata.image[i][0]];\n      imgdata.image[i][1] = lut[imgdata.image[i][1]];\n      imgdata.image[i][2] = lut[imgdata.image[i][2]];\n      imgdata.image[i][3] = lut[imgdata.image[i][3]];\n    }\n\n  if(C.data_maximum <=TBLN)\n    C.data_maximum = lut[C.data_maximum];\n  if(C.maximum <= TBLN)\n    C.maximum = lut[C.maximum];\n  // no need to adjust the minumum, black is already subtracted\n  free(lut);\n}\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))\n#define CLIP(x) LIM(x,0,65535)\n\nvoid LibRaw::convert_to_rgb_loop(float out_cam[3][4])\n{\n  int row,col,c;\n  float out[3];\n  ushort *img;\n  memset(libraw_internal_data.output_data.histogram,0,sizeof(int)*LIBRAW_HISTOGRAM_SIZE*4);\n  for (img=imgdata.image[0], row=0; row < S.height; row++)\n    for (col=0; col < S.width; col++, img+=4) {\n      if (!libraw_internal_data.internal_output_params.raw_color) {\n        out[0] = out[1] = out[2] = 0;\n        for(c=0; c< imgdata.idata.colors; c++) {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        for(c=0;c<3;c++) img[c] = CLIP((int) out[c]);\n      }\n      for(c=0; c< imgdata.idata.colors; c++) libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;\n    }\n\n}\n\nvoid LibRaw::scale_colors_loop(float scale_mul[4])\n{\n  unsigned size = S.iheight*S.iwidth;\n\n\n  if (C.cblack[4] && C.cblack[5])\n    {\n      int val;\n      for (unsigned i=0; i < size*4; i++)\n        {\n          if (!(val = imgdata.image[0][i])) continue;\n          val -= C.cblack[6 + i/4 / S.iwidth % C.cblack[4] * C.cblack[5] +\n\t\t\ti/4 % S.iwidth % C.cblack[5]];\n          val -= C.cblack[i & 3];\n          val *= scale_mul[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n        }\n    }\n  else if(C.cblack[0]||C.cblack[1]||C.cblack[2]||C.cblack[3])\n    {\n      for (unsigned i=0; i < size*4; i++)\n        {\n          int val = imgdata.image[0][i];\n          if (!val) continue;\n          val -= C.cblack[i & 3];\n          val *= scale_mul[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n        }\n    }\n  else // BL is zero\n    {\n      for (unsigned i=0; i < size*4; i++)\n        {\n          int val = imgdata.image[0][i];\n          val *= scale_mul[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n        }\n    }\n}\n\nvoid LibRaw::adjust_bl()\n{\n  int clear_repeat=0;\n   if (O.user_black >= 0)\n     {\n       C.black = O.user_black;\n       clear_repeat = 1;\n     }\n   for(int i=0; i<4; i++)\n     if(O.user_cblack[i]>-1000000)\n       {\n         C.cblack[i] = O.user_cblack[i];\n         clear_repeat  = 1;\n       }\n\n   if(clear_repeat)\n     C.cblack[4]=C.cblack[5]=0;\n\n // Add common part to cblack[] early\n   if (imgdata.idata.filters > 1000 && (C.cblack[4]+1)/2 == 1 && (C.cblack[5]+1)/2 == 1)\n   {\n\t   int clrs[4];\n\t   int lastg = -1, gcnt = 0;\n\t   for(int c = 0; c < 4; c++)\n\t   {\n\t\t\tclrs[c] = FC(c/2,c%2);\n\t\t\tif(clrs[c]==1)\n\t\t\t{\n\t\t\t\tgcnt++;\n\t\t\t\tlastg = c;\n\t\t\t}\n\t   }\n\t   if(gcnt>1 && lastg>=0)\n\t\t   clrs[lastg] = 3;\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[clrs[c]] += C.cblack[6 + c/2 % C.cblack[4] * C.cblack[5] + c%2 % C.cblack[5]];\n\t   C.cblack[4]=C.cblack[5]=0;\n\t   //imgdata.idata.filters = sfilters;\n   }\n   else if(imgdata.idata.filters <= 1000 && C.cblack[4]==1 && C.cblack[5]==1) // Fuji RAF dng\n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n  // remove common part from C.cblack[]\n  int i = C.cblack[3];\n  int c;\n  for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];\n\n  for(c=0;c<4;c++) C.cblack[c] -= i; // remove common part\n  C.black += i;\n\n  // Now calculate common part for cblack[6+] part and move it to C.black\n\n  if(C.cblack[4] && C.cblack[5])\n    {\n      i = C.cblack[6];\n      for(c=1; c<C.cblack[4]*C.cblack[5]; c++)\n        if(i>C.cblack[6+c]) i = C.cblack[6+c];\n      // Remove i from cblack[6+]\n      int nonz=0;\n      for(c=0; c<C.cblack[4]*C.cblack[5]; c++)\n        {\n          C.cblack[6+c]-=i;\n          if(C.cblack[6+c])nonz++;\n        }\n      C.black +=i;\n      if(!nonz)\n        C.cblack[4] = C.cblack[5] = 0;\n    }\n  for(c=0;c<4;c++) C.cblack[c] += C.black;\n}\n\nint LibRaw::dcraw_process(void)\n{\n  int quality,i;\n\n  int iterations=-1, dcb_enhance=1, noiserd=0;\n  int eeci_refine_fl=0, es_med_passes_fl=0;\n  float cared=0,cablue=0;\n  float linenoise=0;\n  float lclean=0,cclean=0;\n  float thresh=0;\n  float preser=0;\n  float expos=1.0;\n\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n  //    CHECK_ORDER_HIGH(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n  try {\n\n    int no_crop = 1;\n\n    if (~O.cropbox[2] && ~O.cropbox[3])\n      no_crop=0;\n\n    libraw_decoder_info_t di;\n    get_decoder_info(&di);\n\n    bool is_bayer = (imgdata.idata.filters || P1.colors == 1);\n    int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && is_bayer && !IO.zero_is_bad;\n\n    raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!\n\n    // Adjust sizes\n\n    int save_4color = O.four_color_rgb;\n\n    if (IO.zero_is_bad)\n      {\n        remove_zeroes();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);\n      }\n\n    if(O.bad_pixels && no_crop)\n      {\n        bad_pixels(O.bad_pixels);\n        SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);\n      }\n\n    if (O.dark_frame && no_crop)\n      {\n        subtract (O.dark_frame);\n        SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);\n      }\n\n    if (O.wf_debanding)\n      {\n        wf_remove_banding();\n      }\n\n    quality = 2 + !IO.fuji_width;\n\n    if (O.user_qual >= 0) quality = O.user_qual;\n\n    if(!subtract_inline || !C.data_maximum)\n      {\n        adjust_bl();\n        subtract_black_internal();\n      }\n\n\tif(!(di.decoder_flags & LIBRAW_DECODER_FIXEDMAXC))\n\t\tadjust_maximum();\n\n    if (O.user_sat > 0) C.maximum = O.user_sat;\n\n    if (P1.is_foveon)\n      {\n        if(load_raw == &LibRaw::x3f_load_raw)\n          {\n            // Filter out zeroes\n            for (int i=0; i < S.height*S.width*4; i++)\n              if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;\n          }\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        else if(load_raw == &LibRaw::foveon_dp_load_raw)\n          {\n            for (int i=0; i < S.height*S.width*4; i++)\n              if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;\n          }\n        else\n          {\n            foveon_interpolate();\n          }\n#endif\n        SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);\n      }\n\n    if (O.green_matching && !O.half_size)\n      {\n        green_matching();\n      }\n\n    if (\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        (!P1.is_foveon || (O.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F)) &&\n#endif\n        !O.no_auto_scale)\n      {\n        scale_colors();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);\n      }\n\n    pre_interpolate();\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n    if (O.dcb_iterations >= 0) iterations = O.dcb_iterations;\n    if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl;\n    if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd;\n    if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine;\n    if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes;\n\n    // LIBRAW_DEMOSAIC_PACK_GPL3\n\n    if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);}\n    if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);}\n    if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);}\n    if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);}\n    if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);}\n\n    if (P1.filters  && !O.no_interpolation)\n      {\n        if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd);\n\n\t\tif(P1.filters>1000 && interpolate_bayer)\n\t\t\t(this->*interpolate_bayer)();\n\t\telse if(P1.filters==9 && interpolate_xtrans)\n\t\t\t(this->*interpolate_xtrans)();\n        else if (quality == 0)\n          lin_interpolate();\n        else if (quality == 1 || P1.colors > 3)\n          vng_interpolate();\n        else if (quality == 2 && P1.filters > 1000)\n          ppg_interpolate();\n        else if (P1.filters == LIBRAW_XTRANS)\n          {\n            // Fuji X-Trans\n            xtrans_interpolate(quality>2?3:1);\n          }\n        else if (quality == 3)\n          ahd_interpolate(); // really don't need it here due to fallback op\n        else if (quality == 4)\n          dcb(iterations, dcb_enhance);\n        //  LIBRAW_DEMOSAIC_PACK_GPL2\n        else if (quality == 5)\n          ahd_interpolate_mod();\n        else if (quality == 6)\n          afd_interpolate_pl(2,1);\n        else if (quality == 7)\n          vcd_interpolate(0);\n        else if (quality == 8)\n          vcd_interpolate(12);\n        else if (quality == 9)\n          lmmse_interpolate(1);\n\n        // LIBRAW_DEMOSAIC_PACK_GPL3\n        else if (quality == 10)\n          amaze_demosaic_RT();\n        // LGPL2\n        else if (quality == 11)\n          dht_interpolate();\n        else if (quality == 12)\n          aahd_interpolate();\n        // fallback to AHD\n        else\n          {\n            ahd_interpolate();\n            imgdata.process_warnings |= LIBRAW_WARN_FALLBACK_TO_AHD;\n          }\n\n\n        SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);\n      }\n    if (IO.mix_green)\n      {\n        for (P1.colors=3, i=0; i < S.height * S.width; i++)\n          imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);\n      }\n\n    if(!P1.is_foveon)\n      {\n        if (P1.colors == 3)\n          {\n\n            if (quality == 8)\n              {\n                if (eeci_refine_fl == 1) refinement();\n                if (O.med_passes > 0)    median_filter_new();\n                if (es_med_passes_fl > 0) es_median_filter();\n              }\n            else {\n              median_filter();\n            }\n            SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);\n          }\n      }\n\n    if (O.highlight == 2)\n      {\n        blend_highlights();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n      }\n\n    if (O.highlight > 2)\n      {\n        recover_highlights();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n      }\n\n    if (O.use_fuji_rotate)\n      {\n        fuji_rotate();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n      }\n\n    if(!libraw_internal_data.output_data.histogram)\n      {\n        libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);\n        merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_process()\");\n      }\n#ifndef NO_LCMS\n    if(O.camera_profile)\n      {\n        apply_profile(O.camera_profile,O.output_profile);\n        SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);\n      }\n#endif\n\n    convert_to_rgb();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);\n\n    if (O.use_fuji_rotate)\n      {\n        stretch();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);\n      }\n    O.four_color_rgb = save_4color; // also, restore\n\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n// Supported cameras:\nstatic const char  *static_camera_list[] =\n{\n\"Adobe Digital Negative (DNG)\",\n\"AgfaPhoto DC-833m\",\n\"Alcatel 5035D\",\n\"Apple iPad Pro\",\n\"Apple iPhone SE\",\n\"Apple iPhone 6s\",\n\"Apple iPhone 6 plus\",\n\"Apple iPhone 7\",\n\"Apple iPhone 7 plus\",\n\"Apple QuickTake 100\",\n\"Apple QuickTake 150\",\n\"Apple QuickTake 200\",\n\"ARRIRAW format\",\n\"AVT F-080C\",\n\"AVT F-145C\",\n\"AVT F-201C\",\n\"AVT F-510C\",\n\"AVT F-810C\",\n\"Baumer TXG14\",\n\"BlackMagic Cinema Camera\",\n\"BlackMagic Micro Cinema Camera\",\n\"BlackMagic Pocket Cinema Camera\",\n\"BlackMagic Production Camera 4k\",\n\"BlackMagic URSA\",\n\"BlackMagic URSA Mini\",\n\"Canon PowerShot 600\",\n\"Canon PowerShot A5\",\n\"Canon PowerShot A5 Zoom\",\n\"Canon PowerShot A50\",\n\"Canon PowerShot A460 (CHDK hack)\",\n\"Canon PowerShot A470 (CHDK hack)\",\n\"Canon PowerShot A530 (CHDK hack)\",\n\"Canon PowerShot A550 (CHDK hack)\",\n\"Canon PowerShot A570 (CHDK hack)\",\n\"Canon PowerShot A590 (CHDK hack)\",\n\"Canon PowerShot A610 (CHDK hack)\",\n\"Canon PowerShot A620 (CHDK hack)\",\n\"Canon PowerShot A630 (CHDK hack)\",\n\"Canon PowerShot A640 (CHDK hack)\",\n\"Canon PowerShot A650 (CHDK hack)\",\n\"Canon PowerShot A710 IS (CHDK hack)\",\n\"Canon PowerShot A720 IS (CHDK hack)\",\n\"Canon PowerShot A3300 IS (CHDK hack)\",\n\"Canon PowerShot Pro70\",\n\"Canon PowerShot Pro90 IS\",\n\"Canon PowerShot Pro1\",\n\"Canon PowerShot G1\",\n\"Canon PowerShot G1 X\",\n\"Canon PowerShot G1 X Mark II\",\n\"Canon PowerShot G2\",\n\"Canon PowerShot G3\",\n\"Canon PowerShot G3 X\",\n\"Canon PowerShot G5\",\n\"Canon PowerShot G5 X\",\n\"Canon PowerShot G6\",\n\"Canon PowerShot G7 (CHDK hack)\",\n\"Canon PowerShot G7 X\",\n\"Canon PowerShot G7 X Mark II\",\n\"Canon PowerShot G9\",\n\"Canon PowerShot G9 X\",\n\"Canon PowerShot G10\",\n\"Canon PowerShot G11\",\n\"Canon PowerShot G12\",\n\"Canon PowerShot G15\",\n\"Canon PowerShot G16\",\n\"Canon PowerShot S2 IS (CHDK hack)\",\n\"Canon PowerShot S3 IS (CHDK hack)\",\n\"Canon PowerShot S5 IS (CHDK hack)\",\n\"Canon PowerShot SD300 (CHDK hack)\",\n\"Canon PowerShot SD950 (CHDK hack)\",\n\"Canon PowerShot S30\",\n\"Canon PowerShot S40\",\n\"Canon PowerShot S45\",\n\"Canon PowerShot S50\",\n\"Canon PowerShot S60\",\n\"Canon PowerShot S70\",\n\"Canon PowerShot S90\",\n\"Canon PowerShot S95\",\n\"Canon PowerShot S100\",\n\"Canon PowerShot S110\",\n\"Canon PowerShot S120\",\n\"Canon PowerShot SX1 IS\",\n\"Canon PowerShot SX50 HS\",\n\"Canon PowerShot SX60 HS\",\n\"Canon PowerShot SX110 IS (CHDK hack)\",\n\"Canon PowerShot SX120 IS (CHDK hack)\",\n\"Canon PowerShot SX220 HS (CHDK hack)\",\n\"Canon PowerShot SX20 IS (CHDK hack)\",\n\"Canon PowerShot SX30 IS (CHDK hack)\",\n\"Canon PowerShot IXUS 160 (CHDK hack)\",\n\"Canon EOS D30\",\n\"Canon EOS D60\",\n\"Canon EOS 5D\",\n\"Canon EOS 5DS\",\n\"Canon EOS 5DS R\",\n\"Canon EOS 5D Mark II\",\n\"Canon EOS 5D Mark III\",\n\"Canon EOS 5D Mark IV\",\n\"Canon EOS 6D\",\n\"Canon EOS 7D\",\n\"Canon EOS 7D Mark II\",\n\"Canon EOS 10D\",\n\"Canon EOS 20D\",\n\"Canon EOS 20Da\",\n\"Canon EOS 30D\",\n\"Canon EOS 40D\",\n\"Canon EOS 50D\",\n\"Canon EOS 60D\",\n\"Canon EOS 60Da\",\n\"Canon EOS 70D\",\n\"Canon EOS 80D\",\n\"Canon EOS 300D / Digital Rebel / Kiss Digital\",\n\"Canon EOS 350D / Digital Rebel XT / Kiss Digital N\",\n\"Canon EOS 400D / Digital Rebel XTi / Kiss Digital X\",\n\"Canon EOS 450D / Digital Rebel XSi / Kiss Digital X2\",\n\"Canon EOS 500D / Digital Rebel T1i / Kiss Digital X3\",\n\"Canon EOS 550D / Digital Rebel T2i / Kiss Digital X4\",\n\"Canon EOS 600D / Digital Rebel T3i / Kiss Digital X5\",\n\"Canon EOS 650D / Digital Rebel T4i / Kiss Digital X6i\",\n\"Canon EOS 700D / Digital Rebel T5i\",\n\"Canon EOS 750D / Digital Rebel T6i\",\n\"Canon EOS 760D / Digital Rebel T6S\",\n\"Canon EOS 100D / Digital Rebel SL1\",\n\"Canon EOS 1000D / Digital Rebel XS / Kiss Digital F\",\n\"Canon EOS 1100D / Digital Rebel T3 / Kiss Digital X50\",\n\"Canon EOS 1200D\",\n\"Canon EOS 1300D\",\n\"Canon EOS C500\",\n\"Canon EOS D2000C\",\n\"Canon EOS M\",\n\"Canon EOS M2\",\n\"Canon EOS M3\",\n\"Canon EOS M5\",\n\"Canon EOS M10\",\n\"Canon EOS-1D\",\n\"Canon EOS-1DS\",\n\"Canon EOS-1D C\",\n\"Canon EOS-1D X\",\n\"Canon EOS-1D Mark II\",\n\"Canon EOS-1D Mark II N\",\n\"Canon EOS-1D Mark III\",\n\"Canon EOS-1D Mark IV\",\n\"Canon EOS-1Ds Mark II\",\n\"Canon EOS-1Ds Mark III\",\n\"Canon EOS-1D X Mark II\",\n\"Casio QV-2000UX\",\n\"Casio QV-3000EX\",\n\"Casio QV-3500EX\",\n\"Casio QV-4000\",\n\"Casio QV-5700\",\n\"Casio QV-R41\",\n\"Casio QV-R51\",\n\"Casio QV-R61\",\n\"Casio EX-F1\",\n\"Casio EX-FC300S\",\n\"Casio EX-FC400S\",\n\"Casio EX-FH20\",\n\"Casio EX-FH25\",\n\"Casio EX-FH100\",\n\"Casio EX-S20\",\n\"Casio EX-S100\",\n\"Casio EX-Z4\",\n\"Casio EX-Z50\",\n\"Casio EX-Z500\",\n\"Casio EX-Z55\",\n\"Casio EX-Z60\",\n\"Casio EX-Z75\",\n\"Casio EX-Z750\",\n\"Casio EX-Z8\",\n\"Casio EX-Z850\",\n\"Casio EX-Z1050\",\n\"Casio EX-ZR100\",\n\"Casio EX-Z1080\",\n\"Casio EX-ZR700\",\n\"Casio EX-ZR710\",\n\"Casio EX-ZR750\",\n\"Casio EX-ZR800\",\n\"Casio EX-ZR850\",\n\"Casio EX-ZR1000\",\n\"Casio EX-ZR1100\",\n\"Casio EX-ZR1200\",\n\"Casio EX-ZR1300\",\n\"Casio EX-ZR1500\",\n\"Casio EX-ZR3000\",\n\"Casio EX-ZR4000/5000\",\n\"Casio EX-100\",\n\"Casio EX-100F\",\n\"Casio EX-10\",\n\"Casio Exlim Pro 505\",\n\"Casio Exlim Pro 600\",\n\"Casio Exlim Pro 700\",\n\"Contax N Digital\",\n\"Creative PC-CAM 600\",\n\"Digital Bolex D16\",\n\"Digital Bolex D16M\",\n\"DJI 4384x3288\",\n\"DXO One\",\n\"Epson R-D1\",\n\"Epson R-D1s\",\n\"Epson R-D1x\",\n\"Foculus 531C\",\n\"FujiFilm E505\",\n\"FujiFilm E550\",\n\"FujiFilm E900\",\n\"FujiFilm F700\",\n\"FujiFilm F710\",\n\"FujiFilm F800\",\n\"FujiFilm F810\",\n\"FujiFilm S2Pro\",\n\"FujiFilm S3Pro\",\n\"FujiFilm S5Pro\",\n\"FujiFilm S20Pro\",\n\"FujiFilm S1\",\n\"FujiFilm S100FS\",\n\"FujiFilm S5000\",\n\"FujiFilm S5100/S5500\",\n\"FujiFilm S5200/S5600\",\n\"FujiFilm S6000fd\",\n\"FujiFilm S7000\",\n\"FujiFilm S9000/S9500\",\n\"FujiFilm S9100/S9600\",\n\"FujiFilm S200EXR\",\n\"FujiFilm S205EXR\",\n\"FujiFilm SL1000\",\n\"FujiFilm HS10/HS11\",\n\"FujiFilm HS20EXR\",\n\"FujiFilm HS22EXR\",\n\"FujiFilm HS30EXR\",\n\"FujiFilm HS33EXR\",\n\"FujiFilm HS35EXR\",\n\"FujiFilm HS50EXR\",\n\"FujiFilm F505EXR\",\n\"FujiFilm F550EXR\",\n\"FujiFilm F600EXR\",\n\"FujiFilm F605EXR\",\n\"FujiFilm F770EXR\",\n\"FujiFilm F775EXR\",\n\"FujiFilm F800EXR\",\n\"FujiFilm F900EXR\",\n\"FujiFilm X-Pro1\",\n\"FujiFilm X-Pro2\",\n\"FujiFilm X-S1\",\n\"FujiFilm XQ1\",\n\"FujiFilm XQ2\",\n\"FujiFilm X100\",\n\"FujiFilm X100S\",\n\"FujiFilm X100T\",\n\"FujiFilm X10\",\n\"FujiFilm X20\",\n\"FujiFilm X30\",\n\"FujiFilm X70\",\n\"FujiFilm X-A1\",\n\"FujiFilm X-A2\",\n\"FujiFilm X-E1\",\n\"FujiFilm X-E2\",\n\"FujiFilm X-E2S\",\n\"FujiFilm X-M1\",\n\"FujiFilm XF1\",\n\"FujiFilm X-T1\",\n\"FujiFilm X-T1 Graphite Silver\",\n\"FujiFilm X-T2\",\n\"FujiFilm X-T10\",\n\"FujiFilm IS-1\",\n\"Gione E7\",\n\"GITUP GIT2\",\n\"Google Pixel\",\n\"Google Pixel XL\",\n\"Hasselblad H5D-60\",\n\"Hasselblad H5D-50\",\n\"Hasselblad H5D-50c\",\n\"Hasselblad H5D-40\",\n\"Hasselblad H4D-60\",\n\"Hasselblad H4D-50\",\n\"Hasselblad H4D-40\",\n\"Hasselblad H4D-31\",\n\"Hasselblad H3DII-22\",\n\"Hasselblad H3DII-31\",\n\"Hasselblad H3DII-39\",\n\"Hasselblad H3DII-50\",\n\"Hasselblad H3D-22\",\n\"Hasselblad H3D-31\",\n\"Hasselblad H3D-39\",\n\"Hasselblad H2D-22\",\n\"Hasselblad H2D-39\",\n\"Hasselblad CFV\",\n\"Hasselblad CFH\",\n\"Hasselblad CF-22\",\n\"Hasselblad CF-31\",\n\"Hasselblad CF-39\",\n\"Hasselblad V96C\",\n\"Hasselblad Lusso\",\n\"Hasselblad Lunar\",\n\"Hasselblad True Zoom\",\n\"Hasselblad Stellar\",\n\"Hasselblad Stellar II\",\n\"Hasselblad HV\",\n\"Hasselblad X1D\",\n\"HTC UltraPixel\",\n\"HTC MyTouch 4G\",\n\"HTC One (A9)\",\n\"HTC One (M9)\",\n\"HTC 10\",\n\"Huawei P9\",\n\"Imacon Ixpress 96, 96C\",\n\"Imacon Ixpress 384, 384C (single shot only)\",\n\"Imacon Ixpress 132C\",\n\"Imacon Ixpress 528C (single shot only)\",\n\"ISG 2020x1520\",\n\"Ikonoskop A-Cam dII Panchromatic\",\n\"Ikonoskop A-Cam dII\",\n\"Kinefinity KineMINI\",\n\"Kinefinity KineRAW Mini\",\n\"Kinefinity KineRAW S35\",\n\"Kodak DC20\",\n\"Kodak DC25\",\n\"Kodak DC40\",\n\"Kodak DC50\",\n\"Kodak DC120\",\n\"Kodak DCS200\",\n\"Kodak DCS315C\",\n\"Kodak DCS330C\",\n\"Kodak DCS420\",\n\"Kodak DCS460\",\n\"Kodak DCS460A\",\n\"Kodak DCS460D\",\n\"Kodak DCS520C\",\n\"Kodak DCS560C\",\n\"Kodak DCS620C\",\n\"Kodak DCS620X\",\n\"Kodak DCS660C\",\n\"Kodak DCS660M\",\n\"Kodak DCS720X\",\n\"Kodak DCS760C\",\n\"Kodak DCS760M\",\n\"Kodak EOSDCS1\",\n\"Kodak EOSDCS3B\",\n\"Kodak NC2000F\",\n\"Kodak ProBack\",\n\"Kodak PB645C\",\n\"Kodak PB645H\",\n\"Kodak PB645M\",\n\"Kodak DCS Pro 14n\",\n\"Kodak DCS Pro 14nx\",\n\"Kodak DCS Pro SLR/c\",\n\"Kodak DCS Pro SLR/n\",\n\"Kodak C330\",\n\"Kodak C603\",\n\"Kodak P850\",\n\"Kodak P880\",\n\"Kodak S-1\",\n\"Kodak Z980\",\n\"Kodak Z981\",\n\"Kodak Z990\",\n\"Kodak Z1015\",\n\"Kodak KAI-0340\",\n\"Konica KD-400Z\",\n\"Konica KD-510Z\",\n\"Leaf AFi 5\",\n\"Leaf AFi 6\",\n\"Leaf AFi 7\",\n\"Leaf AFi-II 6\",\n\"Leaf AFi-II 7\",\n\"Leaf AFi-II 10\",\n\"Leaf AFi-II 10R\",\n\"Leaf Aptus-II 5\",\n\"Leaf Aptus-II 6\",\n\"Leaf Aptus-II 7\",\n\"Leaf Aptus-II 8\",\n\"Leaf Aptus-II 10\",\n\"Leaf Aptus-II 12\",\n\"Leaf Aptus-II 12R\",\n\"Leaf Aptus 17\",\n\"Leaf Aptus 22\",\n\"Leaf Aptus 54S\",\n\"Leaf Aptus 65\",\n\"Leaf Aptus 65S\",\n\"Leaf Aptus 75\",\n\"Leaf Aptus 75S\",\n\"Leaf Cantare\",\n\"Leaf Cantare XY\",\n\"Leaf CatchLight\",\n\"Leaf CMost\",\n\"Leaf Credo 40\",\n\"Leaf Credo 50\",\n\"Leaf Credo 60\",\n\"Leaf Credo 80 (low compression mode only)\",\n\"Leaf DCB-II\",\n\"Leaf Valeo 6\",\n\"Leaf Valeo 11\",\n\"Leaf Valeo 17\",\n\"Leaf Valeo 17wi\",\n\"Leaf Valeo 22\",\n\"Leaf Valeo 22wi\",\n\"Leaf Volare\",\n\"Lenovo a820\",\n\"Leica C (Typ 112)\",\n\"Leica Digilux 2\",\n\"Leica Digilux 3\",\n\"Leica Digital-Modul-R\",\n\"Leica D-LUX2\",\n\"Leica D-LUX3\",\n\"Leica D-LUX4\",\n\"Leica D-LUX5\",\n\"Leica D-LUX6\",\n\"Leica D-Lux (Typ 109)\",\n\"Leica M8\",\n\"Leica M8.2\",\n\"Leica M9\",\n\"Leica M (Typ 240)\",\n\"Leica M (Typ 262)\",\n\"Leica Monochrom (Typ 240)\",\n\"Leica Monochrom (Typ 246)\",\n\"Leica M-D (Typ 262)\",\n\"Leica M-E\",\n\"Leica M-P\",\n\"Leica R8\",\n\"Leica Q (Typ 116)\",\n\"Leica S\",\n\"Leica S2\",\n\"Leica S (Typ 007)\",\n\"Leica SL (Typ 601)\",\n\"Leica T (Typ 701)\",\n\"Leica TL\",\n\"Leica X1\",\n\"Leica X (Typ 113)\",\n\"Leica X2\",\n\"Leica X-E (Typ 102)\",\n\"Leica X-U (Typ 113)\",\n\"Leica V-LUX1\",\n\"Leica V-LUX2\",\n\"Leica V-LUX3\",\n\"Leica V-LUX4\",\n\"Leica V-Lux (Typ 114)\",\n\"Leica X VARIO (Typ 107)\",\n\"LG G3\",\n\"LG G4\",\n\"Logitech Fotoman Pixtura\",\n\"Mamiya ZD\",\n\"Matrix 4608x3288\",\n\"Meizy MX4\",\n\"Micron 2010\",\n\"Minolta RD175\",\n\"Minolta DiMAGE 5\",\n\"Minolta DiMAGE 7\",\n\"Minolta DiMAGE 7i\",\n\"Minolta DiMAGE 7Hi\",\n\"Minolta DiMAGE A1\",\n\"Minolta DiMAGE A2\",\n\"Minolta DiMAGE A200\",\n\"Minolta DiMAGE G400\",\n\"Minolta DiMAGE G500\",\n\"Minolta DiMAGE G530\",\n\"Minolta DiMAGE G600\",\n\"Minolta DiMAGE Z2\",\n\"Minolta Alpha/Dynax/Maxxum 5D\",\n\"Minolta Alpha/Dynax/Maxxum 7D\",\n\"Motorola PIXL\",\n\"Nikon D1\",\n\"Nikon D1H\",\n\"Nikon D1X\",\n\"Nikon D2H\",\n\"Nikon D2Hs\",\n\"Nikon D2X\",\n\"Nikon D2Xs\",\n\"Nikon D3\",\n\"Nikon D3s\",\n\"Nikon D3X\",\n\"Nikon D4\",\n\"Nikon D4s\",\n\"Nikon D40\",\n\"Nikon D40X\",\n\"Nikon D5\",\n\"Nikon D50\",\n\"Nikon D60\",\n\"Nikon D70\",\n\"Nikon D70s\",\n\"Nikon D80\",\n\"Nikon D90\",\n\"Nikon D100\",\n\"Nikon D200\",\n\"Nikon D300\",\n\"Nikon D300s\",\n\"Nikon D500\",\n\"Nikon D600\",\n\"Nikon D610\",\n\"Nikon D700\",\n\"Nikon D750\",\n\"Nikon D800\",\n\"Nikon D800E\",\n\"Nikon D810\",\n\"Nikon D810A\",\n\"Nikon D3000\",\n\"Nikon D3100\",\n\"Nikon D3200\",\n\"Nikon D3300\",\n\"Nikon D3400\",\n\"Nikon D5000\",\n\"Nikon D5100\",\n\"Nikon D5200\",\n\"Nikon D5300\",\n\"Nikon D5500\",\n\"Nikon D7000\",\n\"Nikon D7100\",\n\"Nikon D7200\",\n\"Nikon Df\",\n\"Nikon 1 AW1\",\n\"Nikon 1 J1\",\n\"Nikon 1 J2\",\n\"Nikon 1 J3\",\n\"Nikon 1 J4\",\n\"Nikon 1 J5\",\n\"Nikon 1 S1\",\n\"Nikon 1 S2\",\n\"Nikon 1 V1\",\n\"Nikon 1 V2\",\n\"Nikon 1 V3\",\n\"Nikon E700 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E800 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E880 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E900 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E950 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E990 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E995 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E2100 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E2500 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E3200 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E3700 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E4300 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E4500 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E5000\",\n\"Nikon E5400\",\n\"Nikon E5700\",\n\"Nikon E8400\",\n\"Nikon E8700\",\n\"Nikon E8800\",\n\"Nikon Coolpix A\",\n\"Nikon Coolpix P330\",\n\"Nikon Coolpix P340\",\n\"Nikon Coolpix P6000\",\n\"Nikon Coolpix P7000\",\n\"Nikon Coolpix P7100\",\n\"Nikon Coolpix P7700\",\n\"Nikon Coolpix P7800\",\n\"Nikon Coolpix S6 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon Coolscan NEF\",\n\"Nokia N95\",\n\"Nokia X2\",\n\"Nokia 1200x1600\",\n\"Nokia Lumia 950 XL\",\n\"Nokia Lumia 1020\",\n\"Nokia Lumia 1520\",\n\"Olympus AIR A01\",\n\"Olympus C3030Z\",\n\"Olympus C5050Z\",\n\"Olympus C5060Z\",\n\"Olympus C7070WZ\",\n\"Olympus C70Z,C7000Z\",\n\"Olympus C740UZ\",\n\"Olympus C770UZ\",\n\"Olympus C8080WZ\",\n\"Olympus X200,D560Z,C350Z\",\n\"Olympus E-1\",\n\"Olympus E-3\",\n\"Olympus E-5\",\n\"Olympus E-10\",\n\"Olympus E-20\",\n\"Olympus E-30\",\n\"Olympus E-300\",\n\"Olympus E-330\",\n\"Olympus E-400\",\n\"Olympus E-410\",\n\"Olympus E-420\",\n\"Olympus E-450\",\n\"Olympus E-500\",\n\"Olympus E-510\",\n\"Olympus E-520\",\n\"Olympus E-600\",\n\"Olympus E-620\",\n\"Olympus E-P1\",\n\"Olympus E-P2\",\n\"Olympus E-P3\",\n\"Olympus E-P5\",\n\"Olympus E-PL1\",\n\"Olympus E-PL1s\",\n\"Olympus E-PL2\",\n\"Olympus E-PL3\",\n\"Olympus E-PL5\",\n\"Olympus E-PL6\",\n\"Olympus E-PL7\",\n\"Olympus E-PL8\",\n\"Olympus E-PM1\",\n\"Olympus E-PM2\",\n\"Olympus E-M1\",\n\"Olympus E-M1 Mark II\",\n\"Olympus E-M10\",\n\"Olympus E-M10 Mark II\",\n\"Olympus E-M5\",\n\"Olympus E-M5 Mark II\",\n\"Olympus Pen F\",\n\"Olympus SP310\",\n\"Olympus SP320\",\n\"Olympus SP350\",\n\"Olympus SP500UZ\",\n\"Olympus SP510UZ\",\n\"Olympus SP550UZ\",\n\"Olympus SP560UZ\",\n\"Olympus SP565UZ\",\n\"Olympus SP570UZ\",\n\"Olympus STYLUS1\",\n\"Olympus STYLUS1s\",\n\"Olympus SH-2\",\n\"Olympus SH-3\",\n\"Olympus TG-4\",\n\"Olympus XZ-1\",\n\"Olympus XZ-2\",\n\"Olympus XZ-10\",\n\"OmniVision 4688\",\n\"OmniVision OV5647\",\n\"OmniVision OV5648\",\n\"OmniVision OV8850\",\n\"OmniVision 13860\",\n\"Panasonic DMC-CM1\",\n\"Panasonic DMC-FZ8\",\n\"Panasonic DMC-FZ18\",\n\"Panasonic DMC-FZ28\",\n\"Panasonic DMC-FZ30\",\n\"Panasonic DMC-FZ35/FZ38\",\n\"Panasonic DMC-FZ40\",\n\"Panasonic DMC-FZ50\",\n\"Panasonic DMC-FZ7\",\n\"Panasonic DMC-FZ70\",\n\"Panasonic DMC-FZ100\",\n\"Panasonic DMC-FZ150\",\n\"Panasonic DMC-FZ200\",\n\"Panasonic DMC-FZ300/330\",\n\"Panasonic DMC-FZ1000\",\n\"Panasonic DMC-FZ2000/2500/FZH1\",\n\"Panasonic DMC-FX150\",\n\"Panasonic DMC-G1\",\n\"Panasonic DMC-G10\",\n\"Panasonic DMC-G2\",\n\"Panasonic DMC-G3\",\n\"Panasonic DMC-G5\",\n\"Panasonic DMC-G6\",\n\"Panasonic DMC-G7/G70\",\n\"Panasonic DMC-G8/80/81/85\",\n\"Panasonic DMC-GF1\",\n\"Panasonic DMC-GF2\",\n\"Panasonic DMC-GF3\",\n\"Panasonic DMC-GF5\",\n\"Panasonic DMC-GF6\",\n\"Panasonic DMC-GF7\",\n\"Panasonic DMC-GH1\",\n\"Panasonic DMC-GH2\",\n\"Panasonic DMC-GH3\",\n\"Panasonic DMC-GH4\",\n\"Panasonic AG-GH4\",\n\"Panasonic DMC-GM1\",\n\"Panasonic DMC-GM1s\",\n\"Panasonic DMC-GM5\",\n\"Panasonic DMC-GX1\",\n\"Panasonic DMC-GX7\",\n\"Panasonic DMC-GX8\",\n\"Panasonic DMC-GX80/85\",\n\"Panasonic DMC-L1\",\n\"Panasonic DMC-L10\",\n\"Panasonic DMC-LC1\",\n\"Panasonic DMC-LX1\",\n\"Panasonic DMC-LF1\",\n\"Panasonic DMC-LX2\",\n\"Panasonic DMC-LX3\",\n\"Panasonic DMC-LX5\",\n\"Panasonic DMC-LX7\",\n\"Panasonic DMC-LX9/10/15\",\n\"Panasonic DMC-LX100\",\n\"Panasonic DMC-TZ60/61/SZ40\",\n\"Panasonic DMC-TZ70/71/ZS50\",\n\"Panasonic DMC-TZ80/81/85/ZS60\",\n\"Panasonic DMC-TZ100/101/ZS100\",\n\"Pentax *ist D\",\n\"Pentax *ist DL\",\n\"Pentax *ist DL2\",\n\"Pentax *ist DS\",\n\"Pentax *ist DS2\",\n\"Pentax GR\",\n\"Pentax K10D\",\n\"Pentax K20D\",\n\"Pentax K100D\",\n\"Pentax K100D Super\",\n\"Pentax K110D\",\n\"Pentax K200D\",\n\"Pentax K2000/K-m\",\n\"Pentax K-x\",\n\"Pentax K-r\",\n\"Pentax K-01\",\n\"Pentax K-1\",\n\"Pentax K-3\",\n\"Pentax K-3 II\",\n\"Pentax K-30\",\n\"Pentax K-5\",\n\"Pentax K-5 II\",\n\"Pentax K-5 IIs\",\n\"Pentax K-50\",\n\"Pentax K-500\",\n\"Pentax K-7\",\n\"Pentax K-70\",\n\"Pentax K-S1\",\n\"Pentax K-S2\",\n\"Pentax MX-1\",\n\"Pentax Q\",\n\"Pentax Q7\",\n\"Pentax Q10\",\n\"Pentax QS-1\",\n\"Pentax Optio S\",\n\"Pentax Optio S4\",\n\"Pentax Optio 33WR\",\n\"Pentax Optio 750Z\",\n\"Pentax 645D\",\n\"Pentax 645Z\",\n\"PhaseOne IQ140\",\n\"PhaseOne IQ150\",\n\"PhaseOne IQ160\",\n\"PhaseOne IQ180\",\n\"PhaseOne IQ180 IR\",\n\"PhaseOne IQ250\",\n\"PhaseOne IQ260\",\n\"PhaseOne IQ260 Achromatic\",\n\"PhaseOne IQ280\",\n\"PhaseOne IQ3 50MP\",\n\"PhaseOne IQ3 60MP\",\n\"PhaseOne IQ3 80MP\",\n\"PhaseOne IQ3 100MP\",\n\"PhaseOne LightPhase\",\n\"PhaseOne Achromatic+\",\n\"PhaseOne H 10\",\n\"PhaseOne H 20\",\n\"PhaseOne H 25\",\n\"PhaseOne P 20\",\n\"PhaseOne P 20+\",\n\"PhaseOne P 21\",\n\"PhaseOne P 25\",\n\"PhaseOne P 25+\",\n\"PhaseOne P 30\",\n\"PhaseOne P 30+\",\n\"PhaseOne P 40+\",\n\"PhaseOne P 45\",\n\"PhaseOne P 45+\",\n\"PhaseOne P 65\",\n\"PhaseOne P 65+\",\n\"Photron BC2-HD\",\n\"Pixelink A782\",\n\"Polaroid x530\",\n\"RaspberryPi Camera\",\n\"RaspberryPi Camera V2\",\n\"Ricoh GR\",\n\"Ricoh GR Digital\",\n\"Ricoh GR Digital II\",\n\"Ricoh GR Digital III\",\n\"Ricoh GR Digital IV\",\n\"Ricoh GR II\",\n\"Ricoh GX100\",\n\"Ricoh GX200\",\n\"Ricoh GXR MOUNT A12\",\n\"Ricoh GXR MOUNT A16 24-85mm F3.5-5.5\",\n\"Ricoh GXR, S10 24-72mm F2.5-4.4 VC\",\n\"Ricoh GXR, GR A12 50mm F2.5 MACRO\",\n\"Ricoh GXR, GR LENS A12 28mm F2.5\",\n\"Ricoh GXR, GXR P10\",\n#ifndef NO_JASPER\n\"Redcode R3D format\",\n#endif\n\"Rollei d530flex\",\n\"RoverShot 3320af\",\n\"Samsung EX1\",\n\"Samsung EX2F\",\n\"Samsung GX-1L\",\n\"Samsung GX-1S\",\n\"Samsung GX10\",\n\"Samsung GX20\",\n\"Samsung Galaxy NX (EK-GN120)\",\n\"Samsung Galaxy S7 (SM-G935F)\",\n\"Samsung NX1\",\n\"Samsung NX5\",\n\"Samsung NX10\",\n\"Samsung NX11\",\n\"Samsung NX100\",\n\"Samsung NX1000\",\n\"Samsung NX1100\",\n\"Samsung NX20\",\n\"Samsung NX200\",\n\"Samsung NX210\",\n\"Samsung NX2000\",\n\"Samsung NX30\",\n\"Samsung NX300\",\n\"Samsung NX300M\",\n\"Samsung NX3000\",\n\"Samsung NX500\",\n\"Samsung NX mini\",\n\"Samsung Pro815\",\n\"Samsung WB550\",\n\"Samsung WB2000\",\n\"Samsung S85 (hacked)\",\n\"Samsung S850 (hacked)\",\n\"Samsung Galaxy S3\",\n\"Samsung Galaxy S7\",\n\"Samsung Galaxy S7 Edge\",\n\"Samsung Galaxy Nexus\",\n\"Sarnoff 4096x5440\",\n\"Seitz 6x17\",\n\"Seitz Roundshot D3\",\n\"Seitz Roundshot D2X\",\n\"Seitz Roundshot D2Xs\",\n\"Sigma SD9\",\n\"Sigma SD10\",\n\"Sigma SD14\",\n\"Sigma SD15\",\n\"Sigma SD1\",\n\"Sigma SD1 Merill\",\n\"Sigma DP1\",\n\"Sigma DP1 Merill\",\n\"Sigma DP1S\",\n\"Sigma DP1X\",\n\"Sigma DP2\",\n\"Sigma DP2 Merill\",\n\"Sigma DP2S\",\n\"Sigma DP2X\",\n\"Sigma DP3 Merill\",\n\"Sigma dp0 Quattro\",\n\"Sigma dp1 Quattro\",\n\"Sigma dp2 Quattro\",\n\"Sigma dp3 Quattro\",\n\"Sigma sd Quattro\",\n\"Sigma sd Quattro H\",\n\"Sinar eMotion 22\",\n\"Sinar eMotion 54\",\n\"Sinar eSpirit 65\",\n\"Sinar eMotion 75\",\n\"Sinar eVolution 75\",\n\"Sinar 3072x2048\",\n\"Sinar 4080x4080\",\n\"Sinar 4080x5440\",\n\"Sinar STI format\",\n\"Sinar Sinarback 54\",\n\"SMaL Ultra-Pocket 3\",\n\"SMaL Ultra-Pocket 4\",\n\"SMaL Ultra-Pocket 5\",\n\"Sony A7\",\n\"Sony A7 II\",\n\"Sony A7R\",\n\"Sony A7R II\",\n\"Sony A7S\",\n\"Sony A7S II\",\n\"Sony ILCA-68 (A68)\",\n\"Sony ILCA-77M2 (A77-II)\",\n\"Sony ILCA-99M2 (A99-II)\",\n\"Sony ILCE-3000\",\n\"Sony ILCE-5000\",\n\"Sony ILCE-5100\",\n\"Sony ILCE-6000\",\n\"Sony ILCE-6300\",\n\"Sony ILCE-6500\",\n\"Sony ILCE-QX1\",\n\"Sony DSC-F828\",\n\"Sony DSC-R1\",\n\"Sony DSC-RX1\",\n\"Sony DSC-RX1R\",\n\"Sony DSC-RX1R II\",\n\"Sony DSC-RX10\",\n\"Sony DSC-RX10II\",\n\"Sony DSC-RX10III\",\n\"Sony DSC-RX100\",\n\"Sony DSC-RX100II\",\n\"Sony DSC-RX100III\",\n\"Sony DSC-RX100IV\",\n\"Sony DSC-RX100V\",\n\"Sony DSC-V3\",\n\"Sony DSLR-A100\",\n\"Sony DSLR-A200\",\n\"Sony DSLR-A230\",\n\"Sony DSLR-A290\",\n\"Sony DSLR-A300\",\n\"Sony DSLR-A330\",\n\"Sony DSLR-A350\",\n\"Sony DSLR-A380\",\n\"Sony DSLR-A390\",\n\"Sony DSLR-A450\",\n\"Sony DSLR-A500\",\n\"Sony DSLR-A550\",\n\"Sony DSLR-A560\",\n\"Sony DSLR-A580\",\n\"Sony DSLR-A700\",\n\"Sony DSLR-A850\",\n\"Sony DSLR-A900\",\n\"Sony NEX-3\",\n\"Sony NEX-3N\",\n\"Sony NEX-5\",\n\"Sony NEX-5N\",\n\"Sony NEX-5R\",\n\"Sony NEX-5T\",\n\"Sony NEX-6\",\n\"Sony NEX-7\",\n\"Sony NEX-C3\",\n\"Sony NEX-F3\",\n\"Sony NEX-VG20\",\n\"Sony NEX-VG30\",\n\"Sony NEX-VG900\",\n\"Sony SLT-A33\",\n\"Sony SLT-A35\",\n\"Sony SLT-A37\",\n\"Sony SLT-A55V\",\n\"Sony SLT-A57\",\n\"Sony SLT-A58\",\n\"Sony SLT-A65V\",\n\"Sony SLT-A77V\",\n\"Sony SLT-A99V\",\n\"Sony XCD-SX910CR\",\n\"Sony IMX135-mipi 13mp\",\n\"Sony IMX135-QCOM\",\n\"Sony IMX072-mipi\",\n\"Sony IMX214\",\n\"Sony IMX219\",\n\"Sony IMX230\",\n\"Sony IMX298-mipi 16mp\",\n\"Sony IMX219-mipi 8mp\",\n\"Sony Xperia L\",\n\"STV680 VGA\",\n\"PtGrey GRAS-50S5C\",\n\"JaiPulnix BB-500CL\",\n\"JaiPulnix BB-500GE\",\n\"SVS SVS625CL\",\n\"YUNEEC CGO4\",\n\"Xiaomi MI3\",\n\"Xiaomi RedMi Note3 Pro\",\n   NULL\n};\n\nconst char** LibRaw::cameraList() { return static_camera_list;}\nint LibRaw::cameraCount() { return (sizeof(static_camera_list)/sizeof(static_camera_list[0]))-1; }\n\n\nconst char * LibRaw::strprogress(enum LibRaw_progress p)\n{\n  switch(p)\n    {\n    case LIBRAW_PROGRESS_START:\n      return \"Starting\";\n    case LIBRAW_PROGRESS_OPEN :\n      return \"Opening file\";\n    case LIBRAW_PROGRESS_IDENTIFY :\n      return \"Reading metadata\";\n    case LIBRAW_PROGRESS_SIZE_ADJUST:\n      return \"Adjusting size\";\n    case LIBRAW_PROGRESS_LOAD_RAW:\n      return \"Reading RAW data\";\n    case LIBRAW_PROGRESS_REMOVE_ZEROES:\n      return \"Clearing zero values\";\n    case LIBRAW_PROGRESS_BAD_PIXELS :\n      return \"Removing dead pixels\";\n    case LIBRAW_PROGRESS_DARK_FRAME:\n      return \"Subtracting dark frame data\";\n    case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:\n      return \"Interpolating Foveon sensor data\";\n    case LIBRAW_PROGRESS_SCALE_COLORS:\n      return \"Scaling colors\";\n    case LIBRAW_PROGRESS_PRE_INTERPOLATE:\n      return \"Pre-interpolating\";\n    case LIBRAW_PROGRESS_INTERPOLATE:\n      return \"Interpolating\";\n    case LIBRAW_PROGRESS_MIX_GREEN :\n      return \"Mixing green channels\";\n    case LIBRAW_PROGRESS_MEDIAN_FILTER   :\n      return \"Median filter\";\n    case LIBRAW_PROGRESS_HIGHLIGHTS:\n      return \"Highlight recovery\";\n    case LIBRAW_PROGRESS_FUJI_ROTATE :\n      return \"Rotating Fuji diagonal data\";\n    case LIBRAW_PROGRESS_FLIP :\n      return \"Flipping image\";\n    case LIBRAW_PROGRESS_APPLY_PROFILE:\n      return \"ICC conversion\";\n    case LIBRAW_PROGRESS_CONVERT_RGB:\n      return \"Converting to RGB\";\n    case LIBRAW_PROGRESS_STRETCH:\n      return \"Stretching image\";\n    case LIBRAW_PROGRESS_THUMB_LOAD:\n      return \"Loading thumbnail\";\n    default:\n      return \"Some strange things\";\n    }\n}\n\n#undef ID\n\n\n#include \"../internal/libraw_x3f.cpp\"\n\nvoid x3f_clear(void *p)\n{\n  x3f_delete((x3f_t*)p);\n}\n\nstatic char *utf2char(utf16_t *str, char *buffer)\n{\n  char *b = buffer;\n\n  while (*str != 0x00) {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n  return buffer;\n}\n\nstatic void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)\n{\n\tregister char *cur, *last;\n\tconst char *cl = (const char *)l;\n\tconst char *cs = (const char *)s;\n\n\t/* we need something to compare */\n\tif (l_len == 0 || s_len == 0)\n\t\treturn NULL;\n\n\t/* \"s\" must be smaller or equal to \"l\" */\n\tif (l_len < s_len)\n\t\treturn NULL;\n\n\t/* special case where s_len == 1 */\n\tif (s_len == 1)\n\t\treturn (void*)memchr(l, (int)*cs, l_len);\n\n\t/* the last position where its possible to find \"s\" in \"l\" */\n\tlast = (char *)cl + l_len - s_len;\n\n\tfor (cur = (char *)cl; cur <= last; cur++)\n\t\tif (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)\n\t\t\treturn cur;\n\treturn NULL;\n}\n\nvoid LibRaw::parse_x3f()\n{\n  x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);\n  if(!x3f)\n      return;\n  _x3f_data = x3f;\n\n  x3f_header_t *H = NULL;\n  x3f_directory_section_t *DS = NULL;\n\n  H = &x3f->header;\n  // Parse RAW size from RAW section\n  x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n  if(!DE) return;\n  imgdata.sizes.flip = H->rotation;\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  imgdata.sizes.raw_width = ID->columns;\n  imgdata.sizes.raw_height = ID->rows;\n  // Parse other params from property section\n  DE = x3f_get_prop(x3f);\n  if((x3f_load_data(x3f,DE) == X3F_OK))\n  {\n\t  // Parse property list\n\t  DEH = &DE->header;\n\t  x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\t  if (PL->property_table.size != 0) {\n\t\t  int i;\n\t\t  x3f_property_t *P = PL->property_table.element;\n\t\t  for (i=0; i<PL->num_properties; i++) {\n\t\t\t  char name[100], value[100];\n\t\t\t  utf2char(P[i].name,name);\n\t\t\t  utf2char(P[i].value,value);\n\t\t\t  if (!strcmp (name, \"ISO\"))\n\t\t\t\t  imgdata.other.iso_speed = atoi(value);\n\t\t\t  if (!strcmp (name, \"CAMMANUF\"))\n\t\t\t\t  strcpy (imgdata.idata.make, value);\n\t\t\t  if (!strcmp (name, \"CAMMODEL\"))\n\t\t\t\t  strcpy (imgdata.idata.model, value);\n\t\t\t  if (!strcmp (name, \"CAMSERIAL\"))\n\t\t\t\t  strcpy (imgdata.shootinginfo.BodySerial, value);\n\t\t\t  if (!strcmp (name, \"WB_DESC\"))\n\t\t\t\t  strcpy (imgdata.color.model2, value);\n\t\t\t  if (!strcmp (name, \"TIME\"))\n\t\t\t\t  imgdata.other.timestamp = atoi(value);\n\t\t\t  if (!strcmp (name, \"SHUTTER\"))\n\t\t\t\t  imgdata.other.shutter = atof(value);\n\t\t\t  if (!strcmp (name, \"APERTURE\"))\n\t\t\t\t  imgdata.other.aperture = atof(value);\n\t\t\t  if (!strcmp (name, \"FLENGTH\"))\n\t\t\t\t  imgdata.other.focal_len = atof(value);\n\t\t\t\tif (!strcmp (name, \"FLEQ35MM\"))\n\t\t\t\t  imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n\t\t\t\tif (!strcmp (name, \"LENSARANGE\"))\n\t\t\t\t{\n\t\t\t\t  char *sp;\n\t\t\t\t  imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n\t\t\t\t  sp = strrchr (value, ' ');\n\t\t\t\t  if (sp)\n\t\t\t\t    {\n\t\t\t\t      imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n\t\t\t\t      if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n\t\t\t\t        my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!strcmp (name, \"LENSFRANGE\"))\n\t\t\t\t{\n\t\t\t\t\tchar *sp;\n\t\t\t\t\timgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n\t\t\t\t\tsp = strrchr (value, ' ');\n\t\t\t\t\tif (sp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timgdata.lens.makernotes.MaxFocal = atof(sp);\n\t\t\t\t\t\t\tif ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n\t\t\t\t\t\t\t\tmy_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!strcmp (name, \"LENSMODEL\"))\n\t\t\t\t{\n\t\t\t\t\tchar *sp;\n                                        imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); // atoi(value);\n\t\t\t\t\tif (imgdata.lens.makernotes.LensID)\n\t\t\t\t\t imgdata.lens.makernotes.LensMount = Sigma_X3F;\n\t\t\t\t}\n\t\t  }\n\t\t  imgdata.idata.raw_count=1;\n\t\t  load_raw = &LibRaw::x3f_load_raw;\n\t\t  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;\n\t\t  imgdata.idata.is_foveon = 1;\n\t\t  libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff\n\t\t  imgdata.color.maximum=0x3fff; // To be reset by color table\n\t\t  libraw_internal_data.unpacker_data.order = 0x4949;\n\t  }\n  }\n  else\n  {\n\t  // No property list\n\t  if(imgdata.sizes.raw_width == 5888 ||imgdata.sizes.raw_width == 2944 \n\t\t  || imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 \t  \n\t\t  || imgdata.sizes.raw_width == 5504 ||imgdata.sizes.raw_width == 2752 \t  \n\t\t  ) // Quattro\n\t  {\n\t\t  imgdata.idata.raw_count=1;\n\t\t  load_raw = &LibRaw::x3f_load_raw;\n\t\t  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;\n\t\t  imgdata.idata.is_foveon = 1;\n\t\t  libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff\n\t\t  libraw_internal_data.unpacker_data.order = 0x4949;\n\t\t  strcpy (imgdata.idata.make, \"SIGMA\");\n#if 1\n\t\t  // Try to find model number in first 2048 bytes;\n\t\t  int pos = libraw_internal_data.internal_data.input->tell();\n\t\t  libraw_internal_data.internal_data.input->seek(0,SEEK_SET);\n\t\t  unsigned char buf[2048];\n\t\t  libraw_internal_data.internal_data.input->read(buf,2048,1);\n\t\t  libraw_internal_data.internal_data.input->seek(pos,SEEK_SET);\n\t\t  unsigned char *fnd=(unsigned char*)lr_memmem(buf,2048,\"SIGMA dp\",8);\n\t\t  unsigned char *fndsd=(unsigned char*)lr_memmem(buf,2048,\"sd Quatt\",8);\n\t\t  if(fnd)\n\t\t  {\n\t\t\t  unsigned char *nm = fnd+8;\n\t\t\t  snprintf(imgdata.idata.model,64,\"dp%c Quattro\",*nm<='9' && *nm >='0' ? *nm: '2');\n\t\t  }\n\t\t  else if(fndsd)\n\t\t  {\n\t\t\t  snprintf(imgdata.idata.model,64,\"%s\",fndsd);\n\t\t  }\n\t\t  else\n#endif\n\t\t  if(imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 )\n\t\t\tstrcpy (imgdata.idata.model, \"sd Quattro H\");\n\t\t  else\n\t\t\tstrcpy (imgdata.idata.model, \"dp2 Quattro\");\n\t  }\n\t  //else\n  }\n  // Try to get thumbnail data\n  LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;\n  if( (DE = x3f_get_thumb_jpeg(x3f)))\n    {\n      format = LIBRAW_THUMBNAIL_JPEG;\n    }\n  else if( (DE = x3f_get_thumb_plain(x3f)))\n    {\n      format = LIBRAW_THUMBNAIL_BITMAP;\n    }\n  if(DE)\n    {\n      x3f_directory_entry_header_t *DEH = &DE->header;\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n      imgdata.thumbnail.twidth = ID->columns;\n      imgdata.thumbnail.theight = ID->rows;\n      imgdata.thumbnail.tcolors = 3;\n      imgdata.thumbnail.tformat = format;\n      libraw_internal_data.internal_data.toffset = DE->input.offset;\n      write_thumb = &LibRaw::x3f_thumb_loader;\n    }\n}\n\nINT64 LibRaw::x3f_thumb_size()\n{\n\ttry {\n\t\tx3f_t *x3f = (x3f_t*)_x3f_data;\n\t\tif (!x3f) return -1; // No data pointer set\n\t\tx3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n\t\tif (!DE)\n\t\t\tDE = x3f_get_thumb_plain(x3f);\n\t\tif (!DE)\n\t\t\treturn -1;\n\t\tint64_t p = x3f_load_data_size(x3f, DE);\n\t\tif (p < 0 || p > 0xffffffff)\n\t\t\treturn -1;\n\t\treturn p;\n\t}\n\tcatch (...)\n\t{\n\t\treturn -1;\n\t}\n}\n\nvoid LibRaw::x3f_thumb_loader()\n{\n\ttry\n\t{\n\t\tx3f_t *x3f = (x3f_t*)_x3f_data;\n\t\tif (!x3f) return; // No data pointer set\n\t\tx3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n\t\tif (!DE)\n\t\t\tDE = x3f_get_thumb_plain(x3f);\n\t\tif (!DE)\n\t\t\treturn;\n\t\tif (X3F_OK != x3f_load_data(x3f, DE))\n\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\tx3f_directory_entry_header_t *DEH = &DE->header;\n\t\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\t\timgdata.thumbnail.twidth = ID->columns;\n\t\timgdata.thumbnail.theight = ID->rows;\n\t\timgdata.thumbnail.tcolors = 3;\n\t\tif (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_JPEG)\n\t\t{\n\t\t\timgdata.thumbnail.thumb = (char*)malloc(ID->data_size);\n\t\t\tmerror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n\t\t\tmemmove(imgdata.thumbnail.thumb, ID->data, ID->data_size);\n\t\t\timgdata.thumbnail.tlength = ID->data_size;\n\t\t}\n\t\telse if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_BITMAP)\n\t\t{\n\t\t\timgdata.thumbnail.tlength = ID->columns * ID->rows * 3;\n\t\t\timgdata.thumbnail.thumb = (char*)malloc(ID->columns * ID->rows * 3);\n\t\t\tmerror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n\t\t\tchar *src0 = (char*)ID->data;\n\t\t\tfor (int row = 0; row < ID->rows; row++)\n\t\t\t{\n\t\t\t\tint offset = row * ID->row_stride;\n\t\t\t\tif (offset + ID->columns * 3 > ID->data_size)\n\t\t\t\t\tbreak;\n\t\t\t\tchar *dest = &imgdata.thumbnail.thumb[row*ID->columns * 3];\n\t\t\t\tchar *src = &src0[offset];\n\t\t\t\tmemmove(dest, src, ID->columns * 3);\n\t\t\t}\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t\t// do nothing\n\t}\n}\n\nstatic inline uint32_t _clampbits(int x, uint32_t n) {\n\tuint32_t _y_temp;\n\tif( (_y_temp=x>>n) )\n\t\tx = ~_y_temp >> (32-n);\n\treturn x;\n}\n\nvoid LibRaw::x3f_dpq_interpolate_rg()\n{\n\tint w = imgdata.sizes.raw_width/2;\n\tint h = imgdata.sizes.raw_height/2;\n\tunsigned short *image = (ushort*)imgdata.rawdata.color3_image;\n\n\tfor (int color = 0; color < 2;  color++)\n\t{\n\t\tfor (int y = 2; y < (h-2); y++)\n\t\t{\n\t\t\tuint16_t* row0 = &image[imgdata.sizes.raw_width*3*(y*2)+color]; // dst[1]\n\t\t\tuint16_t  row0_3 = row0[3];\n\t\t\tuint16_t* row1 = &image[imgdata.sizes.raw_width*3*(y*2+1)+color]; //dst1[1]\n\t\t\tuint16_t  row1_3 = row1[3];\n\t\t\tfor (int x = 2; x < (w-2); x++)\n\t\t\t{\n\t\t\t\trow1[0]=row1[3]=row0[3]=row0[0];\n\t\t\t\trow0 += 6;\n\t\t\t\trow1 += 6;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define _ABS(a) ((a)<0?-(a):(a))\n\n#undef CLIP\n#define CLIP(value,high) ((value)>(high)?(high):(value))\n\nvoid LibRaw::x3f_dpq_interpolate_af(int xstep, int ystep, int scale)\n{\n\tunsigned short *image = (ushort*)imgdata.rawdata.color3_image;\n\tunsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch/2; // in 16-bit words\n\t\t// Interpolate single pixel\n\tfor(int y = 0;  y < imgdata.rawdata.sizes.height+imgdata.rawdata.sizes.top_margin; y+=ystep)\n\t{\n\t\tif(y<imgdata.rawdata.sizes.top_margin) continue;\n\t\tif(y<scale) continue;\n\t\tif(y>imgdata.rawdata.sizes.raw_height-scale) break;\n\t\tuint16_t* row0 = &image[imgdata.sizes.raw_width*3*y]; // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n\t\tuint16_t* row_minus = &image[imgdata.sizes.raw_width*3*(y-scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n\t\tuint16_t* row_plus = &image[imgdata.sizes.raw_width*3*(y+scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435\n\t\tfor(int x = 0; x < imgdata.rawdata.sizes.width+imgdata.rawdata.sizes.left_margin; x+= xstep)\n\t\t\t{\n\t\t\t\tif(x<imgdata.rawdata.sizes.left_margin) continue;\n\t\t\t\tif(x<scale) continue;\n\t\t\t\tif(x>imgdata.rawdata.sizes.raw_width-scale) break;\n\t\t\t\tuint16_t* pixel0 = &row0[x*3];\n\t\t\t\tuint16_t* pixel_top = &row_minus[x*3];\n\t\t\t\tuint16_t* pixel_bottom = &row_plus[x*3];\n\t\t\t\tuint16_t* pixel_left = &row0[(x-scale)*3];\n\t\t\t\tuint16_t* pixel_right = &row0[(x+scale)*3];\n\t\t\t\tuint16_t* pixf = pixel_top;\n\t\t\t\tif(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_bottom[2]-pixel0[2]))\n\t\t\t\t\tpixf = pixel_bottom;\n\t\t\t\tif(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_left[2]-pixel0[2]))\n\t\t\t\t\tpixf = pixel_left;\n\t\t\t\tif(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_right[2]-pixel0[2]))\n\t\t\t\t\tpixf = pixel_right;\n\t\t\t\tint blocal = pixel0[2],bnear = pixf[2];\n\t\t\t\tif(blocal < imgdata.color.black+16 || bnear < imgdata.color.black+16\t)\n\t\t\t\t{\n\t\t\t\t\tif(pixel0[0] < imgdata.color.black)\tpixel0[0] = imgdata.color.black;\n\t\t\t\t\tif(pixel0[1] < imgdata.color.black)\tpixel0[1] = imgdata.color.black;\n\t\t\t\t\tpixel0[0] = CLIP((pixel0[0] - imgdata.color.black)*4 + imgdata.color.black,16383);\n\t\t\t\t\tpixel0[1] = CLIP((pixel0[1] - imgdata.color.black)*4 + imgdata.color.black,16383);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfloat multip = float(bnear - imgdata.color.black)/float(blocal-imgdata.color.black);\n\t\t\t\t\tif(pixel0[0] < imgdata.color.black)\tpixel0[0] = imgdata.color.black;\n\t\t\t\t\tif(pixel0[1] < imgdata.color.black)\tpixel0[1] = imgdata.color.black;\n\t\t\t\t\tfloat pixf0 = pixf[0];\n\t\t\t\t\tif(pixf0 < imgdata.color.black) pixf0 = imgdata.color.black;\n\t\t\t\t\tfloat pixf1 = pixf[1];\n\t\t\t\t\tif(pixf1 < imgdata.color.black) pixf1 = imgdata.color.black;\n\n\t\t\t\t\tpixel0[0] = CLIP(((float(pixf0-imgdata.color.black)*multip + imgdata.color.black)+((pixel0[0]-imgdata.color.black)*3.75 + imgdata.color.black))/2,16383);\n\t\t\t\t\tpixel0[1] = CLIP(((float(pixf1-imgdata.color.black)*multip + imgdata.color.black)+((pixel0[1]-imgdata.color.black)*3.75 + imgdata.color.black))/2,16383);\n\t\t\t\t\t//pixel0[1] = float(pixf[1]-imgdata.color.black)*multip + imgdata.color.black;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\nvoid LibRaw::x3f_dpq_interpolate_af_sd(int xstart,int ystart, int xend, int yend, int xstep, int ystep, int scale)\n{\n\tunsigned short *image = (ushort*)imgdata.rawdata.color3_image;\n\tunsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch/2; // in 16-bit words\n\t// Interpolate single pixel\n\tfor(int y = ystart;  y< yend && y < imgdata.rawdata.sizes.height+imgdata.rawdata.sizes.top_margin; y+=ystep)\n\t{\n\t\tuint16_t* row0 = &image[imgdata.sizes.raw_width*3*y]; // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n\t\tuint16_t* row1 = &image[imgdata.sizes.raw_width*3*(y+1)]; // \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n\t\tuint16_t* row_minus = &image[imgdata.sizes.raw_width*3*(y-scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n\t\tuint16_t* row_plus = &image[imgdata.sizes.raw_width*3*(y+scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435 AF-point (scale=2 -> \u043d\u0438\u0436\u0435 row1\n\t\tuint16_t* row_minus1 = &image[imgdata.sizes.raw_width*3*(y-1)]; \n\t\tfor(int x = xstart; x< xend && x < imgdata.rawdata.sizes.width+imgdata.rawdata.sizes.left_margin; x+= xstep)\n\t\t{\n\t\t\tuint16_t* pixel00 = &row0[x*3]; // Current pixel\n\t\t\tfloat sumR = 0.f,sumG=0.f;\n\t\t\tfloat cnt = 0.f;\n\t\t\tfor(int xx = -scale; xx <= scale; xx+= scale)\n\t\t\t{\n\t\t\t\tsumR += row_minus[(x+xx)*3];\n\t\t\t\tsumR += row_plus[(x+xx)*3];\n\t\t\t\tsumG += row_minus[(x+xx)*3+1];\n\t\t\t\tsumG += row_plus[(x+xx)*3+1];\n\t\t\t\tcnt +=1.f;\n\t\t\t\tif(xx)\n\t\t\t\t{\n\t\t\t\t\tcnt +=1.f;\n\t\t\t\t\tsumR += row0[(x+xx)*3];\n\t\t\t\t\tsumG += row0[(x+xx)*3+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpixel00[0] = sumR/8.f;\n\t\t\tpixel00[1] = sumG/8.f;\n\n\t\t\tif(scale == 2)\n\t\t\t{\n\t\t\t\tuint16_t* pixel0B = &row0[x*3+3]; // right pixel\n\t\t\t\tuint16_t* pixel1B = &row1[x*3+3]; // right pixel\n\t\t\t\tfloat sumG0 = 0, sumG1 = 0.f;\n\t\t\t\tfloat cnt = 0.f;\n\t\t\t\tfor(int xx = -scale; xx <= scale; xx+= scale)\n\t\t\t\t{\n\t\t\t\t\tsumG0 += row_minus1[(x+xx)*3+2];\n\t\t\t\t\tsumG1 += row_plus[(x+xx)*3+2];\n\t\t\t\t\tcnt +=1.f;\n\t\t\t\t\tif(xx)\n\t\t\t\t\t{\n\t\t\t\t\t\tsumG0 += row0[(x+xx)*3+2];\n\t\t\t\t\t\tsumG1 += row1[(x+xx)*3+2];\n\t\t\t\t\t\tcnt +=1.f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpixel0B[2] = sumG0/cnt;\n\t\t\t\tpixel1B[2] = sumG1/cnt;\n\t\t\t}\n\n\t\t\t//\t\t\tuint16_t* pixel10 = &row1[x*3]; // Pixel below current\n//\t\t\tuint16_t* pixel_bottom = &row_plus[x*3];\n\t\t}\n\t}\n}\n\n\nvoid LibRaw::x3f_load_raw()\n{\n\t// already in try/catch \n  int raise_error=0;\n  x3f_t *x3f = (x3f_t*)_x3f_data;\n  if(!x3f) return; // No data pointer set\n  if(X3F_OK == x3f_load_data(x3f, x3f_get_raw(x3f)))\n    {\n      x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n      x3f_directory_entry_header_t *DEH = &DE->header;\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\t  if(!ID)\n\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t  x3f_quattro_t *Q = ID->quattro;\n      x3f_huffman_t *HUF = ID->huffman;\n      x3f_true_t *TRU = ID->tru;\n      uint16_t *data = NULL;\n      if(ID->rows != S.raw_height || ID->columns != S.raw_width)\n        {\n          raise_error = 1;\n          goto end;\n        }\n      if (HUF != NULL)\n        data = HUF->x3rgb16.data;\n      if (TRU != NULL)\n        data = TRU->x3rgb16.data;\n      if (data == NULL)\n        {\n          raise_error = 1;\n          goto end;\n        } \n\n\t  size_t datasize = S.raw_height*S.raw_width*3*sizeof(unsigned short);\n\t  S.raw_pitch = S.raw_width*3*sizeof(unsigned short);\n\t  if(!(imgdata.rawdata.raw_alloc = malloc(datasize)))\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n\n      imgdata.rawdata.color3_image = (ushort (*)[3])imgdata.rawdata.raw_alloc;\n\t  if(HUF)\n\t\t  memmove(imgdata.rawdata.raw_alloc,data,datasize);\n\t  else if(TRU && (!Q || !Q->quattro_layout))\n\t\t  memmove(imgdata.rawdata.raw_alloc,data,datasize);\n\t  else if(TRU && Q)\n\t  {\n\t\t  // Move quattro data in place\n\t\t  // R/B plane\n\t\t  for(int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height/2; prow++)\n\t\t  {\n\t\t\t  ushort (*destrow)[3] = (unsigned short (*)[3]) &imgdata.rawdata.color3_image[prow*2*S.raw_pitch/3/sizeof(ushort)][0];\n\t\t\t  ushort (*srcrow)[3] = (unsigned short (*)[3]) &data[prow*TRU->x3rgb16.row_stride];\n\t\t\t  for(int pcol = 0; pcol < TRU->x3rgb16.columns && pcol < S.raw_width/2; pcol++)\n\t\t\t  {\n\t\t\t\t  destrow[pcol*2][0] = srcrow[pcol][0];\n\t\t\t\t  destrow[pcol*2][1] = srcrow[pcol][1];\n\t\t\t  }\n\t\t  }\n\t\t  for(int row = 0; row < Q->top16.rows && row < S.raw_height; row++)\n\t\t  {\n\t\t\t  ushort (*destrow)[3] = (unsigned short (*)[3]) &imgdata.rawdata.color3_image[row*S.raw_pitch/3/sizeof(ushort)][0];\n\t\t\t  ushort (*srcrow) = (unsigned short *) &Q->top16.data[row * Q->top16.columns];\n\t\t\t  for(int col = 0; col < Q->top16.columns && col < S.raw_width; col++)\n\t\t\t\t  destrow[col][2] = srcrow[col];\n\t\t  }\n\t  }\n\n#if 1\n\t  if(TRU && Q  && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF) \n\t\t  )\n\t  {\n\t\t  if(imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3672) // dpN Quattro normal\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af(32,8,2);\n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3776) // sd Quattro normal raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(216,464,imgdata.sizes.raw_width-1,3312,16,32,2);\n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 6656 && imgdata.sizes.raw_height == 4480) // sd Quattro H normal raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(232,592,imgdata.sizes.raw_width-1,3888,16,32,2); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 3328 && imgdata.sizes.raw_height == 2240) // sd Quattro H half size\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(116,296,imgdata.sizes.raw_width-1,2200,8,16,1); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 5504 && imgdata.sizes.raw_height == 3680) // sd Quattro H APS-C raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(8,192,imgdata.sizes.raw_width-1,3185,16,32,2); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 2752 && imgdata.sizes.raw_height == 1840) // sd Quattro H APS-C half size\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(4, 96,imgdata.sizes.raw_width-1,1800,8,16,1); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1836) // dpN Quattro small raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af(16,4,1);\n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1888) // sd Quattro small\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(108,232,imgdata.sizes.raw_width-1,1656,8,16,1);\n\t\t  }\n\t  }\n#endif\n\t  if(TRU && Q && Q->quattro_layout  && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATERG)  )\n\t\t\tx3f_dpq_interpolate_rg();\n\n  }\n  else\n    raise_error = 1;\nend:\n  if(raise_error)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n\n"], "fixing_code": ["/* -*- C++ -*-\n * File: libraw_cxx.cpp\n * Copyright 2008-2017 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n *\n * LibRaw C++ interface (implementation)\n\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#include <math.h>\n#include <errno.h>\n#include <float.h>\n#include <new>\n#include <exception>\n#include <sys/types.h>\n#include <sys/stat.h>\n#if !defined(_WIN32) && !defined(__MINGW32__)\n#include <netinet/in.h>\n#else\n#include <winsock2.h>\n#endif\n#define LIBRAW_LIBRARY_BUILD\n#include \"libraw/libraw.h\"\n#include \"internal/defines.h\"\n#ifdef USE_ZLIB\n#include <zlib.h>\n#endif\n\n\n\n#ifdef USE_RAWSPEED\n#include \"../RawSpeed/rawspeed_xmldata.cpp\"\n#include <RawSpeed/StdAfx.h>\n#include <RawSpeed/FileMap.h>\n#include <RawSpeed/RawParser.h>\n#include <RawSpeed/RawDecoder.h>\n#include <RawSpeed/CameraMetaData.h>\n#include <RawSpeed/ColorFilterArray.h>\n#endif\n\n#ifdef USE_DNGSDK\n#include \"dng_host.h\"\n#include \"dng_negative.h\"\n#include \"dng_simple_image.h\"\n#include \"dng_info.h\"\n#endif\n\n#include \"libraw_xtrans_compressed.cpp\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n  void default_memory_callback(void *,const char *file,const char *where)\n  {\n    fprintf (stderr,\"%s: Out of memory in %s\\n\", file?file:\"unknown file\", where);\n  }\n\n  void default_data_callback(void*,const char *file, const int offset)\n  {\n    if(offset < 0)\n      fprintf (stderr,\"%s: Unexpected end of file\\n\", file?file:\"unknown file\");\n    else\n      fprintf (stderr,\"%s: data corrupted at %d\\n\",file?file:\"unknown file\",offset);\n  }\n  const char *libraw_strerror(int e)\n  {\n    enum LibRaw_errors errorcode = (LibRaw_errors)e;\n    switch(errorcode)\n      {\n      case        LIBRAW_SUCCESS:\n        return \"No error\";\n      case        LIBRAW_UNSPECIFIED_ERROR:\n        return \"Unspecified error\";\n      case        LIBRAW_FILE_UNSUPPORTED:\n        return \"Unsupported file format or not RAW file\";\n      case        LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE:\n        return \"Request for nonexisting image number\";\n      case        LIBRAW_OUT_OF_ORDER_CALL:\n        return \"Out of order call of libraw function\";\n      case    LIBRAW_NO_THUMBNAIL:\n        return \"No thumbnail in file\";\n      case    LIBRAW_UNSUPPORTED_THUMBNAIL:\n        return \"Unsupported thumbnail format\";\n      case LIBRAW_INPUT_CLOSED:\n        return \"No input stream, or input stream closed\";\n      case    LIBRAW_UNSUFFICIENT_MEMORY:\n        return \"Unsufficient memory\";\n      case    LIBRAW_DATA_ERROR:\n        return \"Corrupted data or unexpected EOF\";\n      case    LIBRAW_IO_ERROR:\n        return \"Input/output error\";\n      case LIBRAW_CANCELLED_BY_CALLBACK:\n        return \"Cancelled by user callback\";\n      case LIBRAW_BAD_CROP:\n        return \"Bad crop box\";\n      default:\n        return \"Unknown error code\";\n      }\n  }\n\n#ifdef __cplusplus\n}\n#endif\n\n#define Sigma_X3F   22\n\nconst double LibRaw_constants::xyz_rgb[3][3] =\n{\n    { 0.412453, 0.357580, 0.180423 },\n    { 0.212671, 0.715160, 0.072169 },\n    { 0.019334, 0.119193, 0.950227 }\n};\n\nconst float LibRaw_constants::d65_white[3] =  { 0.950456f, 1.0f, 1.088754f };\n\n#define P1 imgdata.idata\n#define S imgdata.sizes\n#define O imgdata.params\n#define C imgdata.color\n#define T imgdata.thumbnail\n#define IO libraw_internal_data.internal_output_params\n#define ID libraw_internal_data.internal_data\n\n#define EXCEPTION_HANDLER(e) do{                        \\\n    /* fprintf(stderr,\"Exception %d caught\\n\",e);*/     \\\n    switch(e)                                           \\\n      {                                                 \\\n      case LIBRAW_EXCEPTION_ALLOC:                      \\\n        recycle();                                      \\\n        return LIBRAW_UNSUFFICIENT_MEMORY;              \\\n      case LIBRAW_EXCEPTION_DECODE_RAW:                 \\\n      case LIBRAW_EXCEPTION_DECODE_JPEG:                \\\n        recycle();                                      \\\n        return LIBRAW_DATA_ERROR;                       \\\n      case LIBRAW_EXCEPTION_DECODE_JPEG2000:            \\\n        recycle();                                      \\\n        return LIBRAW_DATA_ERROR;                       \\\n      case LIBRAW_EXCEPTION_IO_EOF:                     \\\n      case LIBRAW_EXCEPTION_IO_CORRUPT:                 \\\n        recycle();                                      \\\n        return LIBRAW_IO_ERROR;                                 \\\n      case LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK:              \\\n        recycle();                                              \\\n        return LIBRAW_CANCELLED_BY_CALLBACK;                    \\\n      case LIBRAW_EXCEPTION_BAD_CROP:                           \\\n        recycle();                                              \\\n        return LIBRAW_BAD_CROP;                                 \\\n      default:                                                  \\\n        return LIBRAW_UNSPECIFIED_ERROR;                        \\\n      }                                                         \\\n  }while(0)\n\nconst char* LibRaw::version() { return LIBRAW_VERSION_STR;}\nint LibRaw::versionNumber() { return LIBRAW_VERSION; }\nconst char* LibRaw::strerror(int p) { return libraw_strerror(p);}\n\nunsigned LibRaw::capabilities()\n{\n\tunsigned ret = 0;\n#ifdef USE_RAWSPEED\n\tret |= LIBRAW_CAPS_RAWSPEED;\n#endif\n#ifdef USE_DNGSDK\n\tret |= LIBRAW_CAPS_DNGSDK;\n#endif\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n\tret |= LIBRAW_CAPS_DEMOSAICSGPL2;\n#endif\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL3\n\tret |= LIBRAW_CAPS_DEMOSAICSGPL3;\n#endif\n\treturn ret;\n}\n\nunsigned LibRaw:: parse_custom_cameras(unsigned limit, libraw_custom_camera_t table[], char** list)\n{\n  if(!list) return 0;\n  unsigned index = 0;\n  for(int i=0; i< limit; i++)\n    {\n      if(!list[i]) break;\n      if(strlen(list[i])<10) continue;\n      char *string =  (char*)malloc(strlen(list[i])+1);\n\t  strcpy(string,list[i]);\n      char *start = string;\n      memset(&table[index],0,sizeof(table[0]));\n      for(int j = 0; start && j < 14; j++)\n\t{\n\t  char *end = strchr(start,',');\n\t  if(end) { *end = 0; end++; } // move to next char\n\t  while(isspace(*start) && *start) start++; // skip leading spaces?\n\t  unsigned val = strtol(start,0,10);\n\t  switch(j)\n\t    {\n\t    case 0:  table[index].fsize = val; break;\n\t    case 1:  table[index].rw = val;    break;\n\t    case 2:  table[index].rh = val;    break;\n\t    case 3:  table[index].lm = val;    break;\n\t    case 4:  table[index].tm = val;    break;\n\t    case 5:  table[index].rm = val;    break;\n\t    case 6:  table[index].bm = val;    break;\n\t    case 7:  table[index].lf = val;    break;\n\t    case 8:  table[index].cf = val;    break;\n\t    case 9:  table[index].max = val;    break;\n\t    case 10:  table[index].flags = val;    break;\n\t    case 11: strncpy(table[index].t_make,start,sizeof(table[index].t_make)-1);    break;\n\t    case 12: strncpy(table[index].t_model,start,sizeof(table[index].t_model)-1);    break;\n\t    case 13:  table[index].offset = val;    break;\n\t    default: break;\n\t    }\n\t  start = end;\n\t}\n      free(string);\n      if(table[index].t_make[0])\n\t  index++;\n    }\n  return index;\n}\n\nvoid LibRaw::derror()\n{\n  if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input)\n    {\n      if (libraw_internal_data.internal_data.input->eof())\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),-1);\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        }\n      else\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),\n                                                    libraw_internal_data.internal_data.input->tell());\n          //throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        }\n    }\n  libraw_internal_data.unpacker_data.data_error++;\n}\n\nvoid LibRaw::dcraw_clear_mem(libraw_processed_image_t* p)\n{\n    if(p) ::free(p);\n}\n\nint LibRaw::is_sraw() { return load_raw == &LibRaw::canon_sraw_load_raw || load_raw == &LibRaw::nikon_load_sraw ; }\nint LibRaw::is_coolscan_nef() { return load_raw == &LibRaw::nikon_coolscan_load_raw;}\n\nint LibRaw::is_nikon_sraw(){\n  return load_raw == &LibRaw::nikon_load_sraw;\n}\nint LibRaw::sraw_midpoint() {\n  if (load_raw == &LibRaw::canon_sraw_load_raw) return 8192;\n  else if (load_raw == &LibRaw::nikon_load_sraw) return 2048;\n  else return 0;\n}\n\n\n#ifdef USE_RAWSPEED\nusing namespace RawSpeed;\nclass CameraMetaDataLR : public CameraMetaData\n{\npublic:\n  CameraMetaDataLR() : CameraMetaData() {}\n  CameraMetaDataLR(char *filename) : CameraMetaData(filename){}\n  CameraMetaDataLR(char *data, int sz);\n};\n\nCameraMetaDataLR::CameraMetaDataLR(char *data, int sz) : CameraMetaData() {\n  ctxt = xmlNewParserCtxt();\n  if (ctxt == NULL) {\n    ThrowCME(\"CameraMetaData:Could not initialize context.\");\n  }\n\n  xmlResetLastError();\n  doc = xmlCtxtReadMemory(ctxt, data,sz, \"\", NULL, XML_PARSE_DTDVALID);\n\n  if (doc == NULL) {\n    ThrowCME(\"CameraMetaData: XML Document could not be parsed successfully. Error was: %s\", ctxt->lastError.message);\n  }\n\n  if (ctxt->valid == 0) {\n    if (ctxt->lastError.code == 0x5e) {\n      // printf(\"CameraMetaData: Unable to locate DTD, attempting to ignore.\");\n    } else {\n      ThrowCME(\"CameraMetaData: XML file does not validate. DTD Error was: %s\", ctxt->lastError.message);\n    }\n  }\n\n  xmlNodePtr cur;\n  cur = xmlDocGetRootElement(doc);\n  if (xmlStrcmp(cur->name, (const xmlChar *) \"Cameras\")) {\n    ThrowCME(\"CameraMetaData: XML document of the wrong type, root node is not cameras.\");\n    return;\n  }\n\n  cur = cur->xmlChildrenNode;\n  while (cur != NULL) {\n    if ((!xmlStrcmp(cur->name, (const xmlChar *)\"Camera\"))) {\n      Camera *camera = new Camera(doc, cur);\n      addCamera(camera);\n\n      // Create cameras for aliases.\n      for (unsigned int i = 0; i < camera->aliases.size(); i++) {\n        addCamera(new Camera(camera, i));\n      }\n    }\n    cur = cur->next;\n  }\n  if (doc)\n    xmlFreeDoc(doc);\n  doc = 0;\n  if (ctxt)\n    xmlFreeParserCtxt(ctxt);\n  ctxt = 0;\n}\n\n#define RAWSPEED_DATA_COUNT (sizeof(_rawspeed_data_xml)/sizeof(_rawspeed_data_xml[0]))\nstatic CameraMetaDataLR* make_camera_metadata()\n{\n  int len = 0,i;\n  for(i=0;i<RAWSPEED_DATA_COUNT;i++)\n    if(_rawspeed_data_xml[i])\n      {\n        len+=strlen(_rawspeed_data_xml[i]);\n      }\n  char *rawspeed_xml = (char*)calloc(len+1,sizeof(_rawspeed_data_xml[0][0]));\n  if(!rawspeed_xml) return NULL;\n  int offt = 0;\n  for(i=0;i<RAWSPEED_DATA_COUNT;i++)\n    if(_rawspeed_data_xml[i])\n      {\n        int ll = strlen(_rawspeed_data_xml[i]);\n        if(offt+ll>len) break;\n        memmove(rawspeed_xml+offt,_rawspeed_data_xml[i],ll);\n        offt+=ll;\n      }\n  rawspeed_xml[offt]=0;\n  CameraMetaDataLR *ret=NULL;\n  try {\n    ret = new CameraMetaDataLR(rawspeed_xml,offt);\n  } catch (...) {\n    // Mask all exceptions\n  }\n  free(rawspeed_xml);\n  return ret;\n}\n\n#endif\n\n#define ZERO(a) memset(&a,0,sizeof(a))\n\nstatic void cleargps(libraw_gps_info_t*q)\n{\n\tfor (int i = 0; i < 3; i++)\n\t\tq->latitude[i] = q->longtitude[i] = q->gpstimestamp[i] = 0.f;\n\tq->altitude = 0.f;\n\tq->altref = q->latref = q->longref = q->gpsstatus = q->gpsparsed = 0;\n}\n\nLibRaw:: LibRaw(unsigned int flags)\n{\n  double aber[4] = {1,1,1,1};\n  double gamm[6] = { 0.45,4.5,0,0,0,0 };\n  unsigned greybox[4] =  { 0, 0, UINT_MAX, UINT_MAX };\n  unsigned cropbox[4] =  { 0, 0, UINT_MAX, UINT_MAX };\n#ifdef DCRAW_VERBOSE\n  verbose = 1;\n#else\n  verbose = 0;\n#endif\n  ZERO(imgdata);\n\n  cleargps(&imgdata.other.parsed_gps);\n  ZERO(libraw_internal_data);\n  ZERO(callbacks);\n\n  _rawspeed_camerameta = _rawspeed_decoder = NULL;\n  dnghost =  NULL;\n  _x3f_data = NULL;\n\n#ifdef USE_RAWSPEED\n  CameraMetaDataLR *camerameta = make_camera_metadata(); // May be NULL in case of exception in make_camera_metadata()\n  _rawspeed_camerameta = static_cast<void*>(camerameta);\n#endif\n  callbacks.mem_cb = (flags & LIBRAW_OPIONS_NO_MEMERR_CALLBACK) ? NULL:  &default_memory_callback;\n  callbacks.data_cb = (flags & LIBRAW_OPIONS_NO_DATAERR_CALLBACK)? NULL : &default_data_callback;\n  callbacks.exif_cb = NULL; // no default callback\n  memmove(&imgdata.params.aber,&aber,sizeof(aber));\n  memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));\n  memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));\n  memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));\n\n  imgdata.params.bright=1;\n  imgdata.params.use_camera_matrix=1;\n  imgdata.params.user_flip=-1;\n  imgdata.params.user_black=-1;\n  imgdata.params.user_cblack[0]=imgdata.params.user_cblack[1]=imgdata.params.user_cblack[2]=imgdata.params.user_cblack[3]=-1000001;\n  imgdata.params.user_sat=-1;\n  imgdata.params.user_qual=-1;\n  imgdata.params.output_color=1;\n  imgdata.params.output_bps=8;\n  imgdata.params.use_fuji_rotate=1;\n  imgdata.params.exp_shift = 1.0;\n  imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;\n  imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n  imgdata.params.use_rawspeed = 1;\n  imgdata.params.use_dngsdk = LIBRAW_DNG_DEFAULT;\n  imgdata.params.no_auto_scale = 0;\n  imgdata.params.no_interpolation = 0;\n  imgdata.params.raw_processing_options = LIBRAW_PROCESSING_DP2Q_INTERPOLATERG|LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF | LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT;\n  imgdata.params.sony_arw2_posterization_thr = 0;\n  imgdata.params.green_matching = 0;\n  imgdata.params.custom_camera_strings=0;\n  imgdata.params.coolscan_nef_gamma = 1.0f;\n  imgdata.parent_class = this;\n  imgdata.progress_flags = 0;\n  imgdata.color.baseline_exposure = -999.f;\n  _exitflag = 0;\n  tls = new LibRaw_TLS;\n  tls->init();\n\n  interpolate_bayer = 0;\n  interpolate_xtrans = 0;\n}\n\nint LibRaw::set_rawspeed_camerafile(char *filename)\n{\n#ifdef USE_RAWSPEED\n  try\n    {\n      CameraMetaDataLR *camerameta = new CameraMetaDataLR(filename);\n      if(_rawspeed_camerameta)\n        {\n          CameraMetaDataLR *d = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);\n          delete d;\n        }\n      _rawspeed_camerameta = static_cast<void*>(camerameta);\n    }\n  catch (...)\n    {\n      //just return error code\n      return -1;\n    }\n#endif\n  return 0;\n}\n\nLibRaw::~LibRaw()\n{\n  recycle();\n  delete tls;\n#ifdef USE_RAWSPEED\n  if(_rawspeed_camerameta)\n    {\n      CameraMetaDataLR *cmeta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);\n      delete cmeta;\n      _rawspeed_camerameta = NULL;\n    }\n#endif\n}\n\nvoid* LibRaw:: malloc(size_t t)\n{\n    void *p = memmgr.malloc(t);\n\tif(!p)\n\t\tthrow LIBRAW_EXCEPTION_ALLOC;\n    return p;\n}\nvoid* LibRaw:: realloc(void *q,size_t t)\n{\n    void *p = memmgr.realloc(q,t);\n\tif(!p)\n\t\tthrow LIBRAW_EXCEPTION_ALLOC;\n    return p;\n}\n\n\nvoid* LibRaw::       calloc(size_t n,size_t t)\n{\n    void *p = memmgr.calloc(n,t);\n\tif(!p)\n\t\tthrow LIBRAW_EXCEPTION_ALLOC;\n    return p;\n}\nvoid  LibRaw::      free(void *p)\n{\n    memmgr.free(p);\n}\n\nvoid LibRaw:: recycle_datastream()\n{\n  if(libraw_internal_data.internal_data.input && libraw_internal_data.internal_data.input_internal)\n    {\n      delete libraw_internal_data.internal_data.input;\n      libraw_internal_data.internal_data.input = NULL;\n    }\n  libraw_internal_data.internal_data.input_internal = 0;\n}\n\nvoid x3f_clear(void*);\n\n\nvoid LibRaw:: recycle()\n{\n  recycle_datastream();\n#define FREE(a) do { if(a) { free(a); a = NULL;} }while(0)\n\n  FREE(imgdata.image);\n  FREE(imgdata.thumbnail.thumb);\n  FREE(libraw_internal_data.internal_data.meta_data);\n  FREE(libraw_internal_data.output_data.histogram);\n  FREE(libraw_internal_data.output_data.oprof);\n  FREE(imgdata.color.profile);\n  FREE(imgdata.rawdata.ph1_cblack);\n  FREE(imgdata.rawdata.ph1_rblack);\n  FREE(imgdata.rawdata.raw_alloc);\n  FREE(imgdata.idata.xmpdata);\n#undef FREE\n  ZERO(imgdata.sizes);\n  ZERO(imgdata.idata);\n  ZERO(imgdata.makernotes);\n  ZERO(imgdata.color);\n  ZERO(imgdata.other);\n  ZERO(imgdata.thumbnail);\n  ZERO(imgdata.rawdata);\n  imgdata.makernotes.olympus.OlympusCropID = -1;\n  cleargps(&imgdata.other.parsed_gps);\n  imgdata.color.baseline_exposure = -999.f;\n\n  imgdata.makernotes.fuji.FujiExpoMidPointShift = -999.f;\n  imgdata.makernotes.fuji.FujiDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiFilmMode = 0xffff;\n  imgdata.makernotes.fuji.FujiDynamicRangeSetting = 0xffff;\n  imgdata.makernotes.fuji.FujiDevelopmentDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FujiAutoDynamicRange = 0xffff;\n  imgdata.makernotes.fuji.FocusMode = 0xffff;\n  imgdata.makernotes.fuji.AFMode = 0xffff;\n  imgdata.makernotes.fuji.FocusPixel[0] = imgdata.makernotes.fuji.FocusPixel[1] = 0xffff;\n  imgdata.makernotes.fuji.ImageStabilization[0] = imgdata.makernotes.fuji.ImageStabilization[1] = imgdata.makernotes.fuji.ImageStabilization[2] = 0xffff;\n\n  imgdata.makernotes.sony.SonyCameraType = 0xffff;\n  imgdata.color.dng_color[0].illuminant = imgdata.color.dng_color[1].illuminant = 0xffff;\n\n  for(int i = 0; i < 4; i++)\n   imgdata.color.dng_levels.analogbalance[i]=\n   imgdata.color.dng_levels.analogbalance[i]=1.0f;\n\n  ZERO(libraw_internal_data);\n  ZERO(imgdata.lens);\n  imgdata.lens.makernotes.CanonFocalUnits = 1;\n  imgdata.lens.makernotes.LensID = 0xffffffffffffffffULL;\n  ZERO(imgdata.shootinginfo);\n  imgdata.shootinginfo.DriveMode = -1;\n  imgdata.shootinginfo.FocusMode = -1;\n  imgdata.shootinginfo.MeteringMode = -1;\n  imgdata.shootinginfo.AFPoint = -1;\n  imgdata.shootinginfo.ExposureMode = -1;\n  imgdata.shootinginfo.ImageStabilization = -1;\n\n  _exitflag = 0;\n#ifdef USE_RAWSPEED\n  if(_rawspeed_decoder)\n    {\n      RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);\n      delete d;\n    }\n  _rawspeed_decoder = 0;\n#endif\n\n  if(_x3f_data)\n    {\n      x3f_clear(_x3f_data);\n      _x3f_data = 0;\n    }\n\n  memmgr.cleanup();\n  imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n  imgdata.progress_flags = 0;\n\n  load_raw = thumb_load_raw = 0;\n\n  tls->init();\n}\n\nconst char * LibRaw::unpack_function_name()\n{\n  libraw_decoder_info_t decoder_info;\n  get_decoder_info(&decoder_info);\n  return decoder_info.decoder_name;\n}\n\nint LibRaw::get_decoder_info(libraw_decoder_info_t* d_info)\n{\n  if(!d_info)   return LIBRAW_UNSPECIFIED_ERROR;\n  d_info->decoder_name = 0;\n  d_info->decoder_flags = 0;\n  if (!load_raw) return LIBRAW_OUT_OF_ORDER_CALL;\n\n  int rawdata = (imgdata.idata.filters || P1.colors == 1);\n  // dcraw.c names order\n  if (load_raw == &LibRaw::android_tight_load_raw)\n  {\n\t  d_info->decoder_name = \"android_tight_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::android_loose_load_raw)\n  {\n\t  d_info->decoder_name = \"android_loose_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::canon_600_load_raw)\n    {\n      d_info->decoder_name = \"canon_600_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::xtrans_compressed_load_raw)\n  {\n\t  d_info->decoder_name = \"xtrans_compressed_load_raw()\";\n  }\n  else if (load_raw == &LibRaw::canon_load_raw)\n    {\n      d_info->decoder_name = \"canon_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::lossless_jpeg_load_raw)\n    {\n      d_info->decoder_name = \"lossless_jpeg_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::canon_sraw_load_raw)\n    {\n      d_info->decoder_name = \"canon_sraw_load_raw()\";\n      //d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::lossless_dng_load_raw)\n    {\n      d_info->decoder_name = \"lossless_dng_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n    }\n  else if (load_raw == &LibRaw::packed_dng_load_raw)\n    {\n      d_info->decoder_name = \"packed_dng_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_ADOBECOPYPIXEL;\n    }\n  else if (load_raw == &LibRaw::pentax_load_raw )\n    {\n      d_info->decoder_name = \"pentax_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::nikon_load_raw)\n    {\n      d_info->decoder_name = \"nikon_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::nikon_coolscan_load_raw )\n  {\n\t  d_info->decoder_name = \"nikon_coolscan_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_sraw )\n    {\n      d_info->decoder_name = \"nikon_load_sraw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::nikon_yuv_load_raw )\n    {\n      d_info->decoder_name = \"nikon_load_yuv_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::rollei_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"rollei_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::phase_one_load_raw )\n    {\n      d_info->decoder_name = \"phase_one_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::phase_one_load_raw_c )\n    {\n      d_info->decoder_name = \"phase_one_load_raw_c()\";\n    }\n  else if (load_raw == &LibRaw::hasselblad_load_raw )\n    {\n      d_info->decoder_name = \"hasselblad_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::leaf_hdr_load_raw )\n    {\n      d_info->decoder_name = \"leaf_hdr_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::unpacked_load_raw )\n    {\n      d_info->decoder_name = \"unpacked_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::unpacked_load_raw_reversed )\n  {\n\t  d_info->decoder_name = \"unpacked_load_raw_reversed()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n  }\n  else if (load_raw == &LibRaw::sinar_4shot_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"sinar_4shot_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::imacon_full_load_raw )\n    {\n      d_info->decoder_name = \"imacon_full_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::hasselblad_full_load_raw )\n    {\n      d_info->decoder_name = \"hasselblad_full_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::packed_load_raw )\n    {\n      d_info->decoder_name = \"packed_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::broadcom_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"broadcom_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::nokia_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"nokia_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::canon_rmf_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"canon_rmf_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::panasonic_load_raw )\n    {\n      d_info->decoder_name = \"panasonic_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::olympus_load_raw )\n    {\n      d_info->decoder_name = \"olympus_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::minolta_rd175_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"minolta_rd175_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::quicktake_100_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"quicktake_100_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::kodak_radc_load_raw )\n    {\n      d_info->decoder_name = \"kodak_radc_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::kodak_jpeg_load_raw )\n    {\n      // UNTESTED + RBAYER\n      d_info->decoder_name = \"kodak_jpeg_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::lossy_dng_load_raw)\n    {\n      // Check rbayer\n      d_info->decoder_name = \"lossy_dng_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_HASCURVE;\n    }\n  else if (load_raw == &LibRaw::kodak_dc120_load_raw )\n    {\n      d_info->decoder_name = \"kodak_dc120_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::eight_bit_load_raw )\n    {\n      d_info->decoder_name = \"eight_bit_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_c330_load_raw )\n    {\n      d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_c603_load_raw )\n    {\n      d_info->decoder_name = \"kodak_yrgb_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_262_load_raw )\n    {\n      d_info->decoder_name = \"kodak_262_load_raw()\"; // UNTESTED!\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_65000_load_raw )\n    {\n      d_info->decoder_name = \"kodak_65000_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n    }\n  else if (load_raw == &LibRaw::kodak_ycbcr_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"kodak_ycbcr_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE|LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::kodak_rgb_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"kodak_rgb_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::sony_load_raw )\n    {\n      d_info->decoder_name = \"sony_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::sony_arw_load_raw )\n    {\n      d_info->decoder_name = \"sony_arw_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n\n    }\n  else if (load_raw == &LibRaw::sony_arw2_load_raw )\n    {\n      d_info->decoder_name = \"sony_arw2_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE | LIBRAW_DECODER_TRYRAWSPEED | LIBRAW_DECODER_SONYARW2;\n    }\n  else if (load_raw == &LibRaw::samsung_load_raw )\n    {\n      d_info->decoder_name = \"samsung_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_TRYRAWSPEED;\n    }\n  else if (load_raw == &LibRaw::samsung2_load_raw )\n    {\n      d_info->decoder_name = \"samsung2_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::samsung3_load_raw )\n    {\n      d_info->decoder_name = \"samsung3_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::smal_v6_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"smal_v6_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else if (load_raw == &LibRaw::smal_v9_load_raw )\n    {\n      // UNTESTED\n      d_info->decoder_name = \"smal_v9_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_FIXEDMAXC;\n    }\n  else  if (load_raw == &LibRaw::redcine_load_raw)\n    {\n      d_info->decoder_name = \"redcine_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_HASCURVE;\n    }\n  else if (load_raw == &LibRaw::x3f_load_raw )\n    {\n      d_info->decoder_name = \"x3f_load_raw()\";\n      d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC|LIBRAW_DECODER_FIXEDMAXC | LIBRAW_DECODER_LEGACY_WITH_MARGINS ;\n    }\n  else if (load_raw == &LibRaw::pentax_4shot_load_raw )\n  {\n\t  d_info->decoder_name = \"pentax_4shot_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::deflate_dng_load_raw )\n  {\n\t  d_info->decoder_name = \"deflate_dng_load_raw()\";\n\t  d_info->decoder_flags = LIBRAW_DECODER_OWNALLOC;\n  }\n  else if (load_raw == &LibRaw::nikon_load_striped_packed_raw )\n    {\n      d_info->decoder_name = \"nikon_load_striped_packed_raw()\";\n    }\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n  else if (load_raw == &LibRaw::foveon_sd_load_raw )\n    {\n      d_info->decoder_name = \"foveon_sd_load_raw()\";\n    }\n  else if (load_raw == &LibRaw::foveon_dp_load_raw )\n    {\n      d_info->decoder_name = \"foveon_dp_load_raw()\";\n    }\n#endif\n  else\n    {\n      d_info->decoder_name = \"Unknown unpack function\";\n      d_info->decoder_flags = LIBRAW_DECODER_NOTSET;\n    }\n  return LIBRAW_SUCCESS;\n}\n\nint LibRaw::adjust_maximum()\n{\n    ushort real_max;\n    float  auto_threshold;\n\n    if(O.adjust_maximum_thr < 0.00001)\n        return LIBRAW_SUCCESS;\n    else if (O.adjust_maximum_thr > 0.99999)\n        auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;\n    else\n        auto_threshold = O.adjust_maximum_thr;\n\n\n    real_max = C.data_maximum;\n    if (real_max > 0 && real_max < C.maximum && real_max > C.maximum* auto_threshold)\n      {\n        C.maximum = real_max;\n      }\n    return LIBRAW_SUCCESS;\n}\n\n\nvoid LibRaw:: merror (void *ptr, const char *where)\n{\n    if (ptr) return;\n    if(callbacks.mem_cb)(*callbacks.mem_cb)(callbacks.memcb_data,\n                                            libraw_internal_data.internal_data.input\n                                            ?libraw_internal_data.internal_data.input->fname()\n                                            :NULL,\n                                            where);\n    throw LIBRAW_EXCEPTION_ALLOC;\n}\n\n\n\nint LibRaw::open_file(const char *fname, INT64 max_buf_size)\n{\n#ifndef WIN32\n  struct stat st;\n  if(stat(fname,&st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size)?1:0;\n#else\n  struct _stati64 st;\n  if(_stati64(fname,&st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size)?1:0;\n#endif\n\n  LibRaw_abstract_datastream *stream;\n  try {\n    if(big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n    {\n      recycle();\n      return LIBRAW_UNSUFFICIENT_MEMORY;\n    }\n  if(!stream->valid())\n    {\n      delete stream;\n      return LIBRAW_IO_ERROR;\n    }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n    {\n      ID.input_internal =1 ; // flag to delete datastream on recycle\n    }\n  else\n    {\n      delete stream;\n      ID.input_internal = 0;\n    }\n  return ret;\n}\n\n#if defined(_WIN32) && !defined(__MINGW32__) && defined(_MSC_VER) && (_MSC_VER > 1310)\nint LibRaw::open_file(const wchar_t *fname, INT64 max_buf_size)\n{\n  struct _stati64 st;\n  if(_wstati64(fname,&st))\n    return LIBRAW_IO_ERROR;\n  int big = (st.st_size > max_buf_size)?1:0;\n\n  LibRaw_abstract_datastream *stream;\n  try {\n    if(big)\n      stream = new LibRaw_bigfile_datastream(fname);\n    else\n      stream = new LibRaw_file_datastream(fname);\n  }\n\n  catch (std::bad_alloc)\n    {\n      recycle();\n      return LIBRAW_UNSUFFICIENT_MEMORY;\n    }\n  if(!stream->valid())\n    {\n      delete stream;\n      return LIBRAW_IO_ERROR;\n    }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n    {\n      ID.input_internal =1 ; // flag to delete datastream on recycle\n    }\n  else\n    {\n      delete stream;\n      ID.input_internal = 0;\n    }\n  return ret;\n}\n#endif\n\nint LibRaw::open_buffer(void *buffer, size_t size)\n{\n  // this stream will close on recycle()\n  if(!buffer  || buffer==(void*)-1)\n    return LIBRAW_IO_ERROR;\n\n  LibRaw_buffer_datastream *stream;\n  try {\n    stream = new LibRaw_buffer_datastream(buffer,size);\n  }\n  catch (std::bad_alloc)\n    {\n      recycle();\n      return LIBRAW_UNSUFFICIENT_MEMORY;\n    }\n  if(!stream->valid())\n    {\n      delete stream;\n      return LIBRAW_IO_ERROR;\n    }\n  ID.input_internal = 0; // preserve from deletion on error\n  int ret = open_datastream(stream);\n  if (ret == LIBRAW_SUCCESS)\n    {\n      ID.input_internal =1 ; // flag to delete datastream on recycle\n    }\n  else\n    {\n      delete stream;\n      ID.input_internal = 0;\n    }\n  return ret;\n}\n\n#ifdef USE_ZLIB\ninline unsigned int __DNG_HalfToFloat (ushort halfValue)\n{\n\tint sign \t   = (halfValue >> 15) & 0x00000001;\n\tint exponent = (halfValue >> 10) & 0x0000001f;\n\tint mantissa =  halfValue\t\t   & 0x000003ff;\n\tif (exponent == 0)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) (sign << 31);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (!(mantissa & 0x00000400))\n\t\t\t{\n\t\t\t\tmantissa <<= 1;\n\t\t\t\texponent -=  1;\n\t\t\t}\n\t\t\texponent += 1;\n\t\t\tmantissa &= ~0x00000400;\n\t\t}\n\t}\n\telse if (exponent == 31)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) ((sign << 31) | ((0x1eL + 127 - 15) << 23) |  (0x3ffL << 13));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\texponent += (127 - 15);\n\tmantissa <<= 13;\n\treturn (unsigned int) ((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline unsigned int __DNG_FP24ToFloat (const unsigned char *input)\n{\n\tint sign     = (input [0] >> 7) & 0x01;\n\tint exponent = (input [0]     ) & 0x7F;\n\tint mantissa = (((int) input [1]) << 8) | input[2];\n\tif (exponent == 0)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) (sign << 31);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (!(mantissa & 0x00010000))\n\t\t\t{\n\t\t\t\tmantissa <<= 1;\n\t\t\t\texponent -=  1;\n\t\t\t}\n\t\t\texponent += 1;\n\t\t\tmantissa &= ~0x00010000;\n\t\t}\n\t}\n\telse if (exponent == 127)\n\t{\n\t\tif (mantissa == 0)\n\t\t{\n\t\t\treturn (unsigned int) ((sign << 31) | ((0x7eL + 128 - 64) << 23) |  (0xffffL << 7));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Nan -- Just set to zero.\n\t\t\treturn 0;\n\t\t}\n\t}\n\texponent += (128 - 64);\n\tmantissa <<= 7;\n\treturn (uint32_t) ((sign << 31) | (exponent << 23) | mantissa);\n}\n\ninline void DecodeDeltaBytes (unsigned char *bytePtr, int cols, int channels)\n{\n\tif (channels == 1)\n\t{\n\t\tunsigned char b0 = bytePtr [0];\n\t\tbytePtr += 1;\n\t\tfor (uint32_t col = 1; col < cols; ++col)\n\t\t{\n\t\t\tb0 += bytePtr [0];\n\t\t\tbytePtr [0] = b0;\n\t\t\tbytePtr += 1;\n\t\t}\n\t}\n\telse if (channels == 3)\n\t{\n\t\tunsigned char b0 = bytePtr [0];\n\t\tunsigned char b1 = bytePtr [1];\n\t\tunsigned char b2 = bytePtr [2];\n\t\tbytePtr += 3;\n\t\tfor (int col = 1; col < cols; ++col)\n\t\t{\n\t\t\tb0 += bytePtr [0];\n\t\t\tb1 += bytePtr [1];\n\t\t\tb2 += bytePtr [2];\n\t\t\tbytePtr [0] = b0;\n\t\t\tbytePtr [1] = b1;\n\t\t\tbytePtr [2] = b2;\n\t\t\tbytePtr += 3;\n\t\t}\n\t}\n\telse if (channels == 4)\n\t{\n\t\tunsigned char b0 = bytePtr [0];\n\t\tunsigned char b1 = bytePtr [1];\n\t\tunsigned char b2 = bytePtr [2];\n\t\tunsigned char b3 = bytePtr [3];\n\t\tbytePtr += 4;\n\t\tfor (uint32_t col = 1; col < cols; ++col)\n\t\t{\n\t\t\tb0 += bytePtr [0];\n\t\t\tb1 += bytePtr [1];\n\t\t\tb2 += bytePtr [2];\n\t\t\tb3 += bytePtr [3];\n\t\t\tbytePtr [0] = b0;\n\t\t\tbytePtr [1] = b1;\n\t\t\tbytePtr [2] = b2;\n\t\t\tbytePtr [3] = b3;\n\t\t\tbytePtr += 4;\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int col = 1; col < cols; ++col)\n\t\t{\n\t\t\tfor (int chan = 0; chan < channels; ++chan)\n\t\t\t{\n\t\t\t\tbytePtr [chan + channels] += bytePtr [chan];\n\t\t\t}\n\t\t\tbytePtr += channels;\n\t\t}\n\t}\n}\n\nstatic void DecodeFPDelta (unsigned char *input,\n\tunsigned char *output,\n\tint cols,\n\tint channels,\n\tint bytesPerSample)\n{\n\tDecodeDeltaBytes (input, cols * bytesPerSample, channels);\n\tint32_t rowIncrement = cols * channels;\n\n\tif (bytesPerSample == 2)\n\t{\n\n#if LibRawBigEndian\n\t\tconst unsigned char *input0 = input;\n\t\tconst unsigned char *input1 = input + rowIncrement;\n#else\n\t\tconst unsigned char *input1 = input;\n\t\tconst unsigned char *input0 = input + rowIncrement;\n#endif\n\t\tfor (int col = 0; col < rowIncrement; ++col)\n\t\t{\n\t\t\toutput [0] = input0 [col];\n\t\t\toutput [1] = input1 [col];\n\t\t\toutput += 2;\n\t\t}\n\t}\n\telse if (bytesPerSample == 3)\n\t{\n\t\tconst unsigned char *input0 = input;\n\t\tconst unsigned char *input1 = input + rowIncrement;\n\t\tconst unsigned char *input2 = input + rowIncrement * 2;\n\t\tfor (int col = 0; col < rowIncrement; ++col)\n\t\t{\n\t\t\toutput [0] = input0 [col];\n\t\t\toutput [1] = input1 [col];\n\t\t\toutput [2] = input2 [col];\n\t\t\toutput += 3;\n\t\t}\n\t}\n\telse\n\t{\n#if LibRawBigEndian\n\t\tconst unsigned char *input0 = input;\n\t\tconst unsigned char *input1 = input + rowIncrement;\n\t\tconst unsigned char *input2 = input + rowIncrement * 2;\n\t\tconst unsigned char *input3 = input + rowIncrement * 3;\n#else\n\t\tconst unsigned char *input3 = input;\n\t\tconst unsigned char *input2 = input + rowIncrement;\n\t\tconst unsigned char *input1 = input + rowIncrement * 2;\n\t\tconst unsigned char *input0 = input + rowIncrement * 3;\n#endif\n\t\tfor (int col = 0; col < rowIncrement; ++col)\n\t\t{\n\t\t\toutput [0] = input0 [col];\n\t\t\toutput [1] = input1 [col];\n\t\t\toutput [2] = input2 [col];\n\t\t\toutput [3] = input3 [col];\n\t\t\toutput += 4;\n\t\t}\n\t}\n}\n\nstatic float expandFloats(unsigned char * dst, int tileWidth, int bytesps) {\n\tfloat max = 0.f;\n\tif (bytesps == 2) {\n\t\tuint16_t * dst16 = (ushort *) dst;\n\t\tuint32_t * dst32 = (unsigned int *) dst;\n\t\tfloat *f32 = (float*) dst;\n\t\tfor (int index = tileWidth - 1; index >= 0; --index) {\n\t\t\tdst32[index] = __DNG_HalfToFloat(dst16[index]);\n\t\t\tmax = MAX(max,f32[index]);\n\t\t}\n\t}\n\telse if (bytesps == 3)\n\t{\n\t\tuint8_t  * dst8  = ((unsigned char *) dst) + (tileWidth - 1) * 3;\n\t\tuint32_t * dst32 = (unsigned int *) dst;\n\t\tfloat *f32 = (float*) dst;\n\t\tfor (int index = tileWidth - 1; index >= 0; --index, dst8 -= 3) {\n\t\t\tdst32[index] = __DNG_FP24ToFloat(dst8);\n\t\t\tmax = MAX(max,f32[index]);\n\t\t}\n\t}\n\telse if (bytesps==4)\n\t{\n\t\tfloat *f32 = (float*) dst;\n\t\tfor (int index = 0; index < tileWidth; index++)\n\t\t\tmax = MAX(max,f32[index]);\n\t}\n\treturn max;\n}\n\nvoid LibRaw::deflate_dng_load_raw()\n{\n\tstruct tiff_ifd_t * ifd = &tiff_ifd[0];\n\twhile (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;\n\tif (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n\t{\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\t}\n\n\tfloat *float_raw_image=0;\n\tfloat max = 0.f;\n\n\tif(ifd->samples!=1 && ifd->samples!=3 && ifd->samples !=4)\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n\tif(libraw_internal_data.unpacker_data.tiff_samples != ifd->samples)\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW; // Wrong IFD\n\n\n\tsize_t tilesH = (imgdata.sizes.raw_width + libraw_internal_data.unpacker_data.tile_width - 1) / libraw_internal_data.unpacker_data.tile_width;\n\tsize_t tilesV = (imgdata.sizes.raw_height + libraw_internal_data.unpacker_data.tile_length - 1) / libraw_internal_data.unpacker_data.tile_length;\n\tsize_t tileCnt = tilesH * tilesV;\n\n\n\tif (ifd->sample_format == 3)\n\t{  // Floating point data\n\t\tfloat_raw_image = (float*)calloc(tileCnt*libraw_internal_data.unpacker_data.tile_length* libraw_internal_data.unpacker_data.tile_width * ifd->samples,sizeof(float));\n\t\t//imgdata.color.maximum = 65535;\n\t\t//imgdata.color.black = 0;\n\t\t//memset(imgdata.color.cblack,0,sizeof(imgdata.color.cblack));\n\t}\n\telse\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW; // Only float deflated supported\n\n\tint xFactor;\n\tswitch(ifd->predictor)\n\t{\n\t\tcase 3:\n\t\tdefault:\n\t\t\txFactor = 1; break;\n\t\tcase 34894: xFactor = 2; break;\n\t\tcase 34895: xFactor = 4; break;\n\t}\n\n\tif (libraw_internal_data.unpacker_data.tile_length < INT_MAX)\n\t{\n\t\tif(tileCnt<1 || tileCnt > 1000000)\n\t\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\n\t\tsize_t *tOffsets = (size_t*)malloc(tileCnt*sizeof(size_t));\n\t\tfor (int t = 0; t < tileCnt; ++t)\n\t\t\ttOffsets[t] = get4();\n\n\t\tsize_t *tBytes = (size_t*) malloc(tileCnt*sizeof(size_t));\n\t\tunsigned long maxBytesInTile = 0;\n\t\tif (tileCnt == 1)\n\t\t\ttBytes[0] = maxBytesInTile = ifd->bytes;\n\t\telse\n\t\t{\n\t\t\tlibraw_internal_data.internal_data.input->seek(ifd->bytes, SEEK_SET);\n\t\t\tfor (size_t t = 0; t < tileCnt; ++t)\n\t\t\t{\n\t\t\t\ttBytes[t] = get4();\n\t\t\t\tmaxBytesInTile = MAX(maxBytesInTile,tBytes[t]);\n\t\t\t}\n\t\t}\n\t\tunsigned tilePixels = libraw_internal_data.unpacker_data.tile_width * libraw_internal_data.unpacker_data.tile_length;\n\t\tunsigned pixelSize = sizeof(float)*ifd->samples;\n\t\tunsigned tileBytes = tilePixels*pixelSize;\n\t\tunsigned tileRowBytes = libraw_internal_data.unpacker_data.tile_width*pixelSize;\n\n\t\tunsigned char *cBuffer = (unsigned char*)malloc(maxBytesInTile);\n\t\tunsigned char *uBuffer = (unsigned char*)malloc(tileBytes+tileRowBytes); // extra row for decoding\n\n\t\tfor (size_t y = 0, t = 0; y < imgdata.sizes.raw_height; y += libraw_internal_data.unpacker_data.tile_length)\n\t\t{\n\t\t\tfor (size_t x = 0; x < imgdata.sizes.raw_width; x += libraw_internal_data.unpacker_data.tile_width, ++t)\n\t\t\t{\n\t\t\t\tlibraw_internal_data.internal_data.input->seek(tOffsets[t], SEEK_SET);\n\t\t\t\tlibraw_internal_data.internal_data.input->read(cBuffer, 1, tBytes[t]);\n\t\t\t\tunsigned long dstLen = tileBytes;\n\t\t\t\tint err = uncompress(uBuffer+tileRowBytes, &dstLen, cBuffer, tBytes[t]);\n\t\t\t\tif (err != Z_OK)\n\t\t\t\t{\n\t\t\t\t\tfree(tOffsets);\n\t\t\t\t\tfree(tBytes);\n\t\t\t\t\tfree(cBuffer);\n\t\t\t\t\tfree(uBuffer);\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint bytesps = ifd->bps >> 3;\n\t\t\t\t\tsize_t rowsInTile = y + libraw_internal_data.unpacker_data.tile_length > imgdata.sizes.raw_height ? imgdata.sizes.raw_height - y : libraw_internal_data.unpacker_data.tile_length;\n\t\t\t\t\tsize_t colsInTile= x + libraw_internal_data.unpacker_data.tile_width > imgdata.sizes.raw_width ? imgdata.sizes.raw_width - x : libraw_internal_data.unpacker_data.tile_width;\n\n\t\t\t\t\tfor (size_t row = 0; row < rowsInTile; ++row) // do not process full tile if not needed\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char* dst = uBuffer + row*libraw_internal_data.unpacker_data.tile_width*bytesps*ifd->samples;\n\t\t\t\t\t\tunsigned char* src = dst+tileRowBytes;\n\t\t\t\t\t\tDecodeFPDelta (src,dst,\n\t\t\t\t\t\t\tlibraw_internal_data.unpacker_data.tile_width/ xFactor,\n\t\t\t\t\t\t\tifd->samples * xFactor,\n\t\t\t\t\t\t\tbytesps);\n\t\t\t\t\t\tfloat lmax = expandFloats(dst, libraw_internal_data.unpacker_data.tile_width*ifd->samples, bytesps);\n\t\t\t\t\t\tmax = MAX(max,lmax);\n\t\t\t\t\t\tunsigned char* dst2 = (unsigned char*)&float_raw_image[((y+row)*imgdata.sizes.raw_width + x)*ifd->samples];\n\t\t\t\t\t\tmemmove(dst2,dst,colsInTile*ifd->samples*sizeof(float));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(tOffsets);\n\t\tfree(tBytes);\n\t\tfree(cBuffer);\n\t\tfree(uBuffer);\n\t}\n\timgdata.color.fmaximum = max;\n\n\t// Set fields according to data format\n\n\timgdata.rawdata.raw_alloc = float_raw_image;\n\tif(ifd->samples == 1)\n\t{\n\t\timgdata.rawdata.float_image = float_raw_image;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*4;\n\t}\n\telse if(ifd->samples == 3)\n\t{\n\t\timgdata.rawdata.float3_image = (float(*)[3])float_raw_image;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*12;\n\t}\n\telse if(ifd->samples == 4)\n\t{\n\t\timgdata.rawdata.float4_image = (float(*)[4])float_raw_image;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*16;\n\t}\n\n\tif(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT)\n\t\tconvertFloatToInt(); // with default settings\n}\n#else\nvoid LibRaw::deflate_dng_load_raw()\n{\n\n throw LIBRAW_EXCEPTION_DECODE_RAW;\n}\n#endif\n\nint LibRaw::is_floating_point()\n{\n\tstruct tiff_ifd_t * ifd = &tiff_ifd[0];\n\twhile (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;\n\tif (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n\t\treturn 0;\n\n\treturn ifd->sample_format == 3;\n}\n\nint LibRaw::have_fpdata()\n{\n\treturn imgdata.rawdata.float_image || imgdata.rawdata.float3_image || imgdata.rawdata.float4_image;\n}\n\n\nvoid LibRaw::convertFloatToInt(float dmin/* =4096.f */, float dmax/* =32767.f */, float dtarget /*= 16383.f */)\n{\n\tint samples = 0;\n\tfloat *data = 0;\n\tif(imgdata.rawdata.float_image)\n\t{\n\t\tsamples = 1;\n\t\tdata = imgdata.rawdata.float_image;\n\t}\n\telse if (imgdata.rawdata.float3_image)\n\t{\n\t\tsamples = 3;\n\t\tdata = (float*)imgdata.rawdata.float3_image;\n\t}\n\telse if (imgdata.rawdata.float4_image)\n\t{\n\t\tsamples = 4;\n\t\tdata = (float*)imgdata.rawdata.float4_image;\n\t}\n\telse\n\t\treturn;\n\n\tushort *raw_alloc = (ushort*)malloc(imgdata.sizes.raw_height*imgdata.sizes.raw_width*libraw_internal_data.unpacker_data.tiff_samples*sizeof(ushort));\n\tfloat tmax = MAX(imgdata.color.maximum,1);\n\tfloat datamax = imgdata.color.fmaximum;\n\n\ttmax = MAX(tmax,datamax);\n\ttmax = MAX(tmax,1.f);\n\n\tfloat multip = 1.f;\n\tif(tmax < dmin || tmax > dmax)\n\t{\n\t\timgdata.rawdata.color.fnorm = imgdata.color.fnorm = multip = dtarget / tmax;\n\t\timgdata.rawdata.color.maximum = imgdata.color.maximum = dtarget;\n\t\timgdata.rawdata.color.black = imgdata.color.black = (float)imgdata.color.black*multip;\n\t\tfor(int i=0; i<sizeof(imgdata.color.cblack)/sizeof(imgdata.color.cblack[0]); i++)\n\t\t\tif(i!=4 && i!=5)\n\t\t\t\timgdata.rawdata.color.cblack[i] = imgdata.color.cblack[i] = (float)imgdata.color.cblack[i]*multip;\n\n\t}\n\telse\n\t\timgdata.rawdata.color.fnorm = imgdata.color.fnorm = 0.f;\n\n\tfor (size_t i = 0; i < imgdata.sizes.raw_height*imgdata.sizes.raw_width*libraw_internal_data.unpacker_data.tiff_samples; ++i)\n\t{\n\t\tfloat val = MAX(data[i],0.f);\n\t\traw_alloc[i] = (ushort)(val*multip);\n\t}\n\n\tif(samples==1)\n\t{\n\t\timgdata.rawdata.raw_alloc = imgdata.rawdata.raw_image = raw_alloc;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*2;\n\t}\n\telse if(samples == 3)\n\t{\n\t\timgdata.rawdata.raw_alloc = imgdata.rawdata.color3_image = (ushort (*)[3]) raw_alloc;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;\n\t}\n\telse if(samples == 4)\n\t{\n\t\timgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = (ushort (*)[4]) raw_alloc;\n\t\timgdata.rawdata.sizes.raw_pitch = imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*8;\n\t}\n\tfree(data); // remove old allocation\n\timgdata.rawdata.float_image = 0;\n\timgdata.rawdata.float3_image = 0;\n\timgdata.rawdata.float4_image = 0;\n}\n\nvoid LibRaw::pentax_4shot_load_raw()\n{\n\tushort *plane = (ushort*)malloc(imgdata.sizes.raw_width*imgdata.sizes.raw_height*sizeof(ushort));\n\tint alloc_sz = imgdata.sizes.raw_width*(imgdata.sizes.raw_height+16)*4*sizeof(ushort);\n\tushort (*result)[4] = (ushort(*)[4]) malloc(alloc_sz);\n\tstruct movement_t\n\t{\n\t\tint row,col;\n\t} _move[4] = {\n\t\t{1,1},\n\t\t{0,1},\n\t\t{0,0},\n\t\t{1,0},\n\t};\n\n\tint tidx = 0;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint move_row,move_col;\n\t\tif(imgdata.params.p4shot_order[i] >= '0' && imgdata.params.p4shot_order[i] <= '3')\n\t\t{\n\t\t\tmove_row = (imgdata.params.p4shot_order[i]-'0' & 2)?1:0;\n\t\t\tmove_col = (imgdata.params.p4shot_order[i]-'0' & 1)?1:0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmove_row = _move[i].row;\n\t\t\tmove_col = _move[i].col;\n\t\t}\n\t\tfor(; tidx<16; tidx++)\n\t\t\tif(tiff_ifd[tidx].t_width == imgdata.sizes.raw_width && tiff_ifd[tidx].t_height == imgdata.sizes.raw_height && tiff_ifd[tidx].bps>8 && tiff_ifd[tidx].samples == 1 )\n\t\t\t\tbreak;\n\t\tif(tidx>=16)\n\t\t\tbreak;\n\t\timgdata.rawdata.raw_image = plane;\n\t\tID.input->seek(tiff_ifd[tidx].offset, SEEK_SET);\n\t\timgdata.idata.filters = 0xb4b4b4b4;\n\t\tlibraw_internal_data.unpacker_data.data_offset = tiff_ifd[tidx].offset;\n\t\t(this->*pentax_component_load_raw)();\n\t\tfor(int row = 0; row < imgdata.sizes.raw_height-move_row; row++)\n\t\t{\n\t\t\tint colors[2];\n\t\t\tfor(int c = 0; c < 2; c++ )\n\t\t\t\tcolors[c] = COLOR(row,c);\n\t\t\tushort *srcrow = &plane[imgdata.sizes.raw_width*row];\n\t\t\tushort (*dstrow)[4] = & result[(imgdata.sizes.raw_width)*(row+move_row)+move_col];\n\t\t\tfor(int col = 0; col < imgdata.sizes.raw_width-move_col; col++)\n\t\t\t\tdstrow[col][colors[col%2]] = srcrow[col];\n\t\t}\n\t\ttidx++;\n\t}\n\t// assign things back:\n\timgdata.sizes.raw_pitch = imgdata.sizes.raw_width*8;\n\timgdata.idata.filters = 0;\n\timgdata.rawdata.raw_alloc = imgdata.rawdata.color4_image = result;\n\tfree(plane);\n\timgdata.rawdata.raw_image = 0;\n}\n\nvoid LibRaw::hasselblad_full_load_raw()\n{\n  int row, col;\n\n  for (row=0; row < S.height; row++)\n    for (col=0; col < S.width; col++)\n      {\n        read_shorts (&imgdata.image[row*S.width+col][2], 1); // B\n        read_shorts (&imgdata.image[row*S.width+col][1], 1); // G\n        read_shorts (&imgdata.image[row*S.width+col][0], 1); // R\n      }\n}\n\nvoid LibRaw::nikon_load_striped_packed_raw()\n{\n\tint vbits=0, bwide, rbits, bite,row, col, val, i;\n\n\tUINT64 bitbuf=0;\n\tunsigned load_flags = 24; //libraw_internal_data.unpacker_data.load_flags;\n\tunsigned tiff_bps = libraw_internal_data.unpacker_data.tiff_bps;\n\tint tiff_compress = libraw_internal_data.unpacker_data.tiff_compress;\n\n\tstruct tiff_ifd_t * ifd = &tiff_ifd[0];\n\twhile (ifd < &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds] && ifd->offset != libraw_internal_data.unpacker_data.data_offset) ++ifd;\n\tif (ifd == &tiff_ifd[libraw_internal_data.identify_data.tiff_nifds])\n\t\tthrow LIBRAW_EXCEPTION_DECODE_RAW;\n\n\tif(!ifd->rows_per_strip || !ifd->strip_offsets_count)\n\t\treturn; // not unpacked\n\tint stripcnt = 0;\n\n\tbwide = S.raw_width *  tiff_bps / 8;\n\tbwide += bwide & load_flags >> 7;\n\trbits = bwide * 8 - S.raw_width * tiff_bps;\n\tif (load_flags & 1) bwide = bwide * 16 / 15;\n\tbite = 8 + (load_flags & 24);\n\tfor (row=0; row < S.raw_height; row++)\n\t{\n\t\tcheckCancel();\n\t\tif(!(row%ifd->rows_per_strip))\n\t\t{\n\t\t\tif(stripcnt >= ifd->strip_offsets_count)\n\t\t\t\treturn; // run out of data\n\t\t\tlibraw_internal_data.internal_data.input->seek(ifd->strip_offsets[stripcnt],SEEK_SET);\n\t\t\tstripcnt++;\n\t\t}\n\t\tfor (col=0; col < S.raw_width; col++)\n\t\t{\n\t\t\tfor (vbits -= tiff_bps; vbits < 0; vbits += bite)\n\t\t\t{\n\t\t\t\tbitbuf <<= bite;\n\t\t\t\tfor (i=0; i < bite; i+=8)\n\t\t\t\t\tbitbuf |= (unsigned) (libraw_internal_data.internal_data.input->get_char() << i);\n\t\t\t}\n\t\t\timgdata.rawdata.raw_image[(row)*S.raw_width+(col)] = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);\n\t\t}\n\t\tvbits -= rbits;\n\t}\n}\n\nstruct foveon_data_t\n{\n    const char *make;\n    const char *model;\n    const int raw_width,raw_height;\n    const int  white;\n    const int  left_margin,top_margin;\n    const int  width,height;\n} foveon_data [] =\n{\n  {\"Sigma\",\"SD9\",2304,1531,12000,20,8,2266,1510},\n  {\"Sigma\",\"SD9\",1152,763,12000,10,2,1132,755},\n  {\"Sigma\",\"SD10\",2304,1531,12000,20,8,2266,1510},\n  {\"Sigma\",\"SD10\",1152,763,12000,10,2,1132,755},\n  {\"Sigma\",\"SD14\",2688,1792,14000,18,12,2651,1767},\n  {\"Sigma\",\"SD14\",2688,896,14000,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"SD14\",1344,896,14000,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"SD15\",2688,1792,2900,18,12,2651,1767},\n  {\"Sigma\",\"SD15\",2688,896,2900,18,6,2651,883}, // 2/3 ?\n  {\"Sigma\",\"SD15\",1344,896,2900,9,6,1326,883}, // 1/2 ?\n  {\"Sigma\",\"DP1\",2688,1792,2100,18,12,2651,1767},\n  {\"Sigma\",\"DP1\",2688,896,2100,18,6,2651,883}, // 2/3 ?\n  {\"Sigma\",\"DP1\",1344,896,2100,9,6,1326,883}, // 1/2 ?\n  {\"Sigma\",\"DP1S\",2688,1792,2200,18,12,2651,1767},\n  {\"Sigma\",\"DP1S\",2688,896,2200,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP1S\",1344,896,2200,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"DP1X\",2688,1792,3560,18,12,2651,1767},\n  {\"Sigma\",\"DP1X\",2688,896,3560,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP1X\",1344,896,3560,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"DP2\",2688,1792,2326,13,16,2651,1767},\n  {\"Sigma\",\"DP2\",2688,896,2326,13,8,2651,883}, // 2/3 ??\n  {\"Sigma\",\"DP2\",1344,896,2326,7,8,1325,883}, // 1/2 ??\n  {\"Sigma\",\"DP2S\",2688,1792,2300,18,12,2651,1767},\n  {\"Sigma\",\"DP2S\",2688,896,2300,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP2S\",1344,896,2300,9,6,1326,883}, // 1/2\n  {\"Sigma\",\"DP2X\",2688,1792,2300,18,12,2651,1767},\n  {\"Sigma\",\"DP2X\",2688,896,2300,18,6,2651,883}, // 2/3\n  {\"Sigma\",\"DP2X\",1344,896,2300,9,6,1325,883}, // 1/2\n  {\"Sigma\",\"SD1\",4928,3264,3900,12,52,4807,3205}, // Full size\n  {\"Sigma\",\"SD1\",4928,1632,3900,12,26,4807,1603}, // 2/3 size\n  {\"Sigma\",\"SD1\",2464,1632,3900,6,26,2403,1603}, // 1/2 size\n  {\"Sigma\",\"SD1 Merrill\",4928,3264,3900,12,52,4807,3205}, // Full size\n  {\"Sigma\",\"SD1 Merrill\",4928,1632,3900,12,26,4807,1603}, // 2/3 size\n  {\"Sigma\",\"SD1 Merrill\",2464,1632,3900,6,26,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP1 Merrill\",4928,3264,3900,12,0,4807,3205},\n  {\"Sigma\",\"DP1 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP1 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size\n  {\"Sigma\",\"DP2 Merrill\",4928,3264,3900,12,0,4807,3205},\n  {\"Sigma\",\"DP2 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP2 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size\n  {\"Sigma\",\"DP3 Merrill\",4928,3264,3900,12,0,4807,3205},\n  {\"Sigma\",\"DP3 Merrill\",2464,1632,3900,12,0,2403,1603}, // 1/2 size\n  {\"Sigma\",\"DP3 Merrill\",4928,1632,3900,12,0,4807,1603}, // 2/3 size\n  {\"Polaroid\",\"x530\",1440,1088,2700,10,13,1419,1059},\n  // dp2 Q\n  {\"Sigma\",\"dp3 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp3 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  {\"Sigma\",\"dp2 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp2 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  {\"Sigma\",\"dp1 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp1 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  {\"Sigma\",\"dp0 Quattro\",5888,3672,16383,204,24,5446,3624}, // full size\n  {\"Sigma\",\"dp0 Quattro\",2944,1836,16383,102,12,2723,1812}, // half size\n  // Sigma sd Quattro\n  {\"Sigma\",\"sd Quattro\",5888,3776,16383,204,76,5446,3624}, // full size\n  {\"Sigma\",\"sd Quattro\",2944,1888,16383,102,38,2723,1812}, // half size\n  // Sd Quattro H\n  {\"Sigma\",\"sd Quattro H\",6656,4480,16383,224,160,6208,4160}, // full size\n  {\"Sigma\",\"sd Quattro H\",3328,2240,16383,112,80,3104,2080}, // half size\n  {\"Sigma\",\"sd Quattro H\",5504,3680,16383,0,4,5496,3668}, // full size\n  {\"Sigma\",\"sd Quattro H\",2752,1840,16383,0,2,2748,1834}, // half size\n};\nconst int foveon_count = sizeof(foveon_data)/sizeof(foveon_data[0]);\n\n\nint LibRaw::open_datastream(LibRaw_abstract_datastream *stream)\n{\n\n  if(!stream)\n    return ENOENT;\n  if(!stream->valid())\n    return LIBRAW_IO_ERROR;\n  recycle();\n\n  try {\n    ID.input = stream;\n    SET_PROC_FLAG(LIBRAW_PROGRESS_OPEN);\n\n    identify();\n\n\tif (!strcasecmp(imgdata.idata.make, \"Canon\")  && (load_raw == &LibRaw::canon_sraw_load_raw) && imgdata.sizes.raw_width>0)\n\t{\n\t\tfloat ratio = float(imgdata.sizes.raw_height) / float(imgdata.sizes.raw_width);\n\t\tif((ratio < 0.57 || ratio > 0.75) && imgdata.makernotes.canon.SensorHeight>1 && imgdata.makernotes.canon.SensorWidth > 1)\n\t\t{\n\t\t\timgdata.sizes.raw_width = imgdata.makernotes.canon.SensorWidth;\n\t\t\timgdata.sizes.left_margin = imgdata.makernotes.canon.SensorLeftBorder;\n\t\t\timgdata.sizes.iwidth = imgdata.sizes.width = imgdata.makernotes.canon.SensorRightBorder - imgdata.makernotes.canon.SensorLeftBorder+1;\n\t\t\timgdata.sizes.raw_height = imgdata.makernotes.canon.SensorHeight;\n\t\t\timgdata.sizes.top_margin = imgdata.makernotes.canon.SensorTopBorder;\n\t\t\timgdata.sizes.iheight = imgdata.sizes.height = imgdata.makernotes.canon.SensorBottomBorder - imgdata.makernotes.canon.SensorTopBorder+1;\n\t\t\tlibraw_internal_data.unpacker_data.load_flags |= 256; // reset width/height in canon_sraw_load_raw()\n\t\t\timgdata.sizes.raw_pitch = 8*imgdata.sizes.raw_width;\n\t\t}\n\t\telse if(imgdata.sizes.raw_width == 4032 && imgdata.sizes.raw_height == 3402 && !strcasecmp(imgdata.idata.model, \"EOS 80D\")) // 80D hardcoded\n\t\t{\n\t\t\timgdata.sizes.raw_width = 4536;\n\t\t\timgdata.sizes.left_margin = 28;\n\t\t\timgdata.sizes.iwidth = imgdata.sizes.width = imgdata.sizes.raw_width - imgdata.sizes.left_margin;\n\t\t\timgdata.sizes.raw_height = 3024;\n\t\t\timgdata.sizes.top_margin = 8;\n\t\t\timgdata.sizes.iheight = imgdata.sizes.height = imgdata.sizes.raw_height - imgdata.sizes.top_margin;\n\t\t\tlibraw_internal_data.unpacker_data.load_flags |= 256;\n\t\t\timgdata.sizes.raw_pitch = 8*imgdata.sizes.raw_width;\n\t\t}\n\t}\n\n\t// XTrans Compressed?\n\tif (!imgdata.idata.dng_version && !strcasecmp(imgdata.idata.make, \"Fujifilm\") && (load_raw == &LibRaw::unpacked_load_raw) )\n\t{\n\t\tif (imgdata.sizes.raw_width * imgdata.sizes.raw_height * 2 != libraw_internal_data.unpacker_data.data_size)\n\t\t\tparse_xtrans_header();\n\n\t\tif(imgdata.idata.filters == 9)\n\t\t{\n\t\t\t// Adjust top/left margins for X-Trans\n\t\t\tint newtm = imgdata.sizes.top_margin%6?(imgdata.sizes.top_margin/6+1)*6 : imgdata.sizes.top_margin;\n\t\t\tint newlm = imgdata.sizes.left_margin%6?(imgdata.sizes.left_margin/6+1)*6 : imgdata.sizes.left_margin;\n\t\t\tif(newtm != imgdata.sizes.top_margin || newlm != imgdata.sizes.left_margin)\n\t\t\t{\n\t\t\t\timgdata.sizes.height -= (newtm - imgdata.sizes.top_margin);\n\t\t\t\timgdata.sizes.top_margin = newtm;\n\t\t\t\timgdata.sizes.width -= (newlm - imgdata.sizes.left_margin);\n\t\t\t\timgdata.sizes.left_margin = newlm;\n\t\t\t\tfor(int c = 0; c < 36; c++)\n\t\t\t\t\timgdata.idata.xtrans[0][c] = imgdata.idata.xtrans_abs[0][c];\n\t\t\t}\n\t\t}\n\t}\n\n    // Fix DNG white balance if needed\n    if(imgdata.idata.dng_version && (imgdata.idata.filters == 0) && imgdata.idata.colors > 1 && imgdata.idata.colors < 5)\n      {\n\tfloat delta[4]={0.f,0.f,0.f,0.f};\n\tfor(int c = 0; c < imgdata.idata.colors ; c++ )\n\t  delta[c] = imgdata.color.dng_levels.dng_whitelevel[c] - imgdata.color.dng_levels.dng_blacklevel[c];\n\tfloat mindelta = delta[0],maxdelta = delta[0];\n\tfor(int c = 1; c < imgdata.idata.colors; c++)\n\t  {\n\t    if(mindelta > delta[c]) mindelta = delta[c];\n\t    if(maxdelta < delta[c]) maxdelta = delta[c];\n\t  }\n\tif(mindelta > 1 && maxdelta < (mindelta *20)) // safety\n\t  {\n\t    for(int c = 0; c < imgdata.idata.colors; c++)\n\t      {\n\t\timgdata.color.cam_mul[c] /= (delta[c]/maxdelta);\n\t\timgdata.color.pre_mul[c] /= (delta[c]/maxdelta);\n\t      }\n\t    imgdata.color.maximum = imgdata.color.cblack[0]+maxdelta;\n\t  }\n      }\n\n    if(imgdata.idata.dng_version &&\n      (\n    (!strcasecmp(imgdata.idata.make,\"Leica\") && !strcasecmp(imgdata.idata.model,\"D-LUX (Typ 109)\"))\n\t  ||\n\t  (!strcasecmp(imgdata.idata.make,\"Panasonic\") && !strcasecmp(imgdata.idata.model,\"LX100\"))\n\t)\n       )\n      imgdata.sizes.width = 4288;\n\n\tif (!strncasecmp(imgdata.idata.make, \"Sony\", 4) && imgdata.idata.dng_version)\n\t{\n\t\tif(S.raw_width == 3984) S.width = 3925;\n\t\telse if (S.raw_width == 4288) S.width = S.raw_width-32;\n\t\telse if (S.raw_width == 4928 && S.height < 3280) S.width = S.raw_width-8;\n\t\telse if (S.raw_width == 5504) S.width = S.raw_width-(S.height > 3664 ? 8 : 32);\n\t\telse if (S.raw_width == 6048)\n\t\t{\n\t\t\tS.width = S.raw_width-24;\n\t\t\tif (strstr(imgdata.idata.model,\"RX1\") || strstr(imgdata.idata.model,\"A99\")) S.width -= 6;\n\t\t}\n\t\telse if (S.raw_width == 7392) S.width = S.raw_width-30;\n\t\telse if(S.raw_width == 8000)\tS.width = S.raw_width - 32;\n\t}\n\n\tif(!strcasecmp(imgdata.idata.make,\"Pentax\") &&  /*!strcasecmp(imgdata.idata.model,\"K-3 II\")  &&*/ imgdata.idata.raw_count == 4 && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES))\n\t{\n\t\timgdata.idata.raw_count = 1;\n\t\timgdata.idata.filters = 0;\n\t\timgdata.idata.colors = 4;\n\t\tIO.mix_green = 1;\n\t\tpentax_component_load_raw = load_raw;\n\t\tload_raw= &LibRaw::pentax_4shot_load_raw;\n\t}\n\n\tif (!imgdata.idata.dng_version && !strcmp(imgdata.idata.make, \"Leaf\") && !strcmp(imgdata.idata.model, \"Credo 50\"))\n\t{\n\t\timgdata.color.pre_mul[0] = 1.f / 0.3984f;\n\t\timgdata.color.pre_mul[2] = 1.f / 0.7666f;\n\t\timgdata.color.pre_mul[1] = imgdata.color.pre_mul[3] = 1.0;\n\t}\n\n\t// S3Pro DNG patch\n\tif(imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\") && !strcmp(imgdata.idata.model,\"S3Pro\") && imgdata.sizes.raw_width == 4288 )\n\t{\n\t\timgdata.sizes.left_margin++;\n\t\timgdata.sizes.width--;\n\t}\n\tif(imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\") && !strcmp(imgdata.idata.model,\"S5Pro\") && imgdata.sizes.raw_width == 4288 )\n\t{\n\t\timgdata.sizes.left_margin++;\n\t\timgdata.sizes.width--;\n\t}\n\tif(!imgdata.idata.dng_version && !strcmp(imgdata.idata.make,\"Fujifilm\")\n           && (!strncmp(imgdata.idata.model,\"S20Pro\",6) || !strncmp(imgdata.idata.model,\"F700\",4))\n           )\n\t{\n          imgdata.sizes.raw_width/=2;\n          load_raw= &LibRaw::unpacked_load_raw_fuji_f700s20;\n\t}\n\tif(load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\")\n\t\t && !libraw_internal_data.unpacker_data.load_flags\n\t\t && (!strncasecmp(imgdata.idata.model,\"D810\",4) || !strcasecmp(imgdata.idata.model,\"D4S\"))\n\t\t && libraw_internal_data.unpacker_data.data_size*2 == imgdata.sizes.raw_height*imgdata.sizes.raw_width*3)\n\t{\n\t\tlibraw_internal_data.unpacker_data.load_flags = 80;\n\t}\n\t// Adjust BL for Sony A900/A850\n    if(load_raw == &LibRaw::packed_load_raw && !strcasecmp(imgdata.idata.make,\"Sony\")) // 12 bit sony, but metadata may be for 14-bit range\n      {\n        if(C.maximum>4095)\n          C.maximum = 4095;\n        if(C.black > 256 || C.cblack[0] > 256)\n          {\n            C.black /=4;\n            for(int c=0; c< 4; c++)\n              C.cblack[c]/=4;\n            for(int c=0; c< C.cblack[4]*C.cblack[5];c++)\n              C.cblack[6+c]/=4;\n          }\n      }\n    if(  load_raw == &LibRaw::nikon_yuv_load_raw  ) // Is it Nikon sRAW?\n      {\n           load_raw= &LibRaw::nikon_load_sraw;\n           C.black =0;\n           memset(C.cblack,0,sizeof(C.cblack));\n           imgdata.idata.filters = 0;\n           libraw_internal_data.unpacker_data.tiff_samples=3;\n           imgdata.idata.colors = 3;\n           double beta_1 = -5.79342238397656E-02;\n           double beta_2 = 3.28163551282665;\n           double beta_3 = -8.43136004842678;\n           double beta_4 = 1.03533181861023E+01;\n           for(int i=0; i<=3072;i++)\n           {\n               double x = (double)i/3072.;\n               double y = (1.-exp(-beta_1*x-beta_2*x*x-beta_3*x*x*x-beta_4*x*x*x*x));\n               if(y<0.)y=0.;\n               imgdata.color.curve[i] = (y*16383.);\n           }\n           for(int i=0;i<3;i++)\n             for(int j=0;j<4;j++)\n               imgdata.color.rgb_cam[i][j]=float(i==j);\n      }\n    // Adjust BL for Nikon 12bit\n    if((\n        load_raw == &LibRaw::nikon_load_raw\n        || load_raw == &LibRaw::packed_load_raw)\n       && !strcasecmp(imgdata.idata.make,\"Nikon\")\n       && strncmp(imgdata.idata.model,\"COOLPIX\",7)\n//\t   && strncmp(imgdata.idata.model,\"1 \",2)\n       && libraw_internal_data.unpacker_data.tiff_bps == 12)\n      {\n        C.maximum = 4095;\n        C.black /=4;\n        for(int c=0; c< 4; c++)\n          C.cblack[c]/=4;\n        for(int c=0; c< C.cblack[4]*C.cblack[5];c++)\n          C.cblack[6+c]/=4;\n      }\n\n    // Adjust Highlight Linearity limit\n    if (C.linear_max[0] < 0) {\n      if (imgdata.idata.dng_version) {\n          for (int c=0; c<4; c++)\n            C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c+6];\n      } else {\n          for (int c=0; c<4; c++)\n            C.linear_max[c] = -1 * C.linear_max[c] + imgdata.color.cblack[c];\n      }\n    }\n\n    if  (!strcasecmp(imgdata.idata.make,\"Nikon\") && (!C.linear_max[0]) && (C.maximum > 1024) && (load_raw != &LibRaw::nikon_load_sraw)) {\n      C.linear_max[0] =\n        C.linear_max[1] =\n        C.linear_max[2] =\n        C.linear_max[3] =\n        (long) ((float)(C.maximum) / 1.07f);\n    }\n\n    // Correct WB for Samsung GX20\n    if  (!strcasecmp(imgdata.idata.make,\"Samsung\") && !strcasecmp(imgdata.idata.model,\"GX20\")) {\n      C.WB_Coeffs[LIBRAW_WBI_Daylight][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Daylight][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Shade][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Shade][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Cloudy][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Tungsten][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_D][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_D][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_N][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_N][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_FL_W][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_FL_W][2]) * 2.56f);\n      C.WB_Coeffs[LIBRAW_WBI_Flash][2] = (int) ((float) (C.WB_Coeffs[LIBRAW_WBI_Flash][2]) * 2.56f);\n      for (int c=0; c<64; c++) {\n        if (imgdata.color.WBCT_Coeffs[c][0] > 0.0f) {\n          imgdata.color.WBCT_Coeffs[c][3] *= 2.56f;\n        }\n      }\n    }\n\n\t// Adjust BL for Panasonic\n    if(load_raw == &LibRaw::panasonic_load_raw && (!strcasecmp(imgdata.idata.make,\"Panasonic\") || !strcasecmp(imgdata.idata.make,\"Leica\") ||  !strcasecmp(imgdata.idata.make,\"YUNEEC\"))\n       &&  ID.pana_black[0] && ID.pana_black[1] && ID.pana_black[2])\n      {\n        C.black=0;\n        C.cblack[0] = ID.pana_black[0]+ID.pana_black[3];\n        C.cblack[1] = C.cblack[3] = ID.pana_black[1]+ID.pana_black[3];\n        C.cblack[2] = ID.pana_black[2]+ID.pana_black[3];\n        int i = C.cblack[3];\n        for(int c=0; c<3; c++) if(i>C.cblack[c]) i = C.cblack[c];\n        for(int c=0; c< 4; c++) C.cblack[c]-=i;\n        C.black = i;\n      }\n\n    // Adjust sizes for X3F processing\n    if(load_raw == &LibRaw::x3f_load_raw)\n    {\n        for(int i=0; i< foveon_count;i++)\n            if(!strcasecmp(imgdata.idata.make,foveon_data[i].make) && !strcasecmp(imgdata.idata.model,foveon_data[i].model)\n                && imgdata.sizes.raw_width == foveon_data[i].raw_width\n                && imgdata.sizes.raw_height == foveon_data[i].raw_height\n                )\n            {\n                imgdata.sizes.top_margin = foveon_data[i].top_margin;\n                imgdata.sizes.left_margin = foveon_data[i].left_margin;\n                imgdata.sizes.width = imgdata.sizes.iwidth = foveon_data[i].width;\n                imgdata.sizes.height = imgdata.sizes.iheight = foveon_data[i].height;\n                C.maximum = foveon_data[i].white;\n                break;\n            }\n    }\n#if 0\n    size_t bytes = ID.input->size()-libraw_internal_data.unpacker_data.data_offset;\n    float bpp = float(bytes)/float(S.raw_width)/float(S.raw_height);\n    float bpp2 = float(bytes)/float(S.width)/float(S.height);\n    printf(\"RawSize: %dx%d data offset: %d data size:%d bpp: %g bpp2: %g\\n\",S.raw_width,S.raw_height,libraw_internal_data.unpacker_data.data_offset,bytes,bpp,bpp2);\n    if(!strcasecmp(imgdata.idata.make,\"Hasselblad\") && bpp == 6.0f)\n      {\n        load_raw = &LibRaw::hasselblad_full_load_raw;\n        S.width = S.raw_width;\n        S.height = S.raw_height;\n        P1.filters = 0;\n        P1.colors=3;\n        P1.raw_count=1;\n        C.maximum=0xffff;\n        printf(\"3 channel hassy found\\n\");\n      }\n#endif\n    if(C.profile_length)\n      {\n        if(C.profile) free(C.profile);\n        C.profile = malloc(C.profile_length);\n        merror(C.profile,\"LibRaw::open_file()\");\n        ID.input->seek(ID.profile_offset,SEEK_SET);\n        ID.input->read(C.profile,C.profile_length,1);\n      }\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_IDENTIFY);\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee) {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n\n  if(P1.raw_count < 1)\n    return LIBRAW_FILE_UNSUPPORTED;\n\n\n  write_fun = &LibRaw::write_ppm_tiff;\n\n  if (load_raw == &LibRaw::kodak_ycbcr_load_raw)\n    {\n      S.height += S.height & 1;\n      S.width  += S.width  & 1;\n    }\n\n  IO.shrink = P1.filters && (O.half_size ||\n                             ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n\n  // Save color,sizes and internal data into raw_image fields\n  memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));\n  memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));\n  memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));\n  memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));\n\n  SET_PROC_FLAG(LIBRAW_PROGRESS_SIZE_ADJUST);\n\n\n  return LIBRAW_SUCCESS;\n}\n\n#ifdef USE_RAWSPEED\nvoid LibRaw::fix_after_rawspeed(int bl)\n{\n  if (load_raw == &LibRaw::lossy_dng_load_raw)\n    C.maximum = 0xffff;\n  else if (load_raw == &LibRaw::sony_load_raw)\n    C.maximum = 0x3ff0;\n}\n#else\nvoid LibRaw::fix_after_rawspeed(int)\n{\n}\n#endif\n\nvoid LibRaw::clearCancelFlag()\n{\n#ifdef WIN32\n\tInterlockedExchange(&_exitflag, 0);\n#else\n\t__sync_fetch_and_and(&_exitflag, 0);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n\tif (_rawspeed_decoder)\n\t{\n\t\tRawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);\n\t\td->resumeProcessing();\n\t}\n#endif\n\n}\n\nvoid LibRaw::setCancelFlag()\n{\n#ifdef WIN32\n  InterlockedExchange(&_exitflag,1);\n#else\n  __sync_fetch_and_add(&_exitflag,1);\n#endif\n#ifdef RAWSPEED_FASTEXIT\n  if(_rawspeed_decoder)\n    {\n      RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);\n      d->cancelProcessing();\n    }\n#endif\n}\n\nvoid LibRaw::checkCancel()\n{\n#ifdef WIN32\n  if(InterlockedExchange(&_exitflag,0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#else\n  if( __sync_fetch_and_and(&_exitflag,0))\n    throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n#endif\n}\n\nint LibRaw::try_rawspeed()\n{\n#ifdef USE_RAWSPEED\n\tint ret=LIBRAW_SUCCESS;\n\n\tint rawspeed_ignore_errors = 0;\n\tif (imgdata.idata.dng_version && imgdata.idata.colors == 3 && !strcasecmp(imgdata.idata.software, \"Adobe Photoshop Lightroom 6.1.1 (Windows)\"))\n\t\trawspeed_ignore_errors = 1;\n\n\t// RawSpeed Supported,\n\t\tINT64 spos = ID.input->tell();\n\t\tvoid *_rawspeed_buffer = 0;\n\t\ttry\n\t\t{\n\t\t\t//                printf(\"Using rawspeed\\n\");\n\t\t\tID.input->seek(0,SEEK_SET);\n\t\t\tINT64 _rawspeed_buffer_sz = ID.input->size()+32;\n\t\t\t_rawspeed_buffer = malloc(_rawspeed_buffer_sz);\n\t\t\tif(!_rawspeed_buffer) throw LIBRAW_EXCEPTION_ALLOC;\n\t\t\tID.input->read(_rawspeed_buffer,_rawspeed_buffer_sz,1);\n\t\t\tFileMap map((uchar8*)_rawspeed_buffer,_rawspeed_buffer_sz);\n\t\t\tRawParser t(&map);\n\t\t\tRawDecoder *d = 0;\n\t\t\tCameraMetaDataLR *meta = static_cast<CameraMetaDataLR*>(_rawspeed_camerameta);\n\t\t\td = t.getDecoder();\n\t\t\tif(!d) throw \"Unable to find decoder\";\n\t\t\ttry {\n\t\t\t\td->checkSupport(meta);\n\t\t\t}\n\t\t\tcatch (const RawDecoderException& e)\n\t\t\t{\n\t\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_UNSUPPORTED;\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\td->interpolateBadPixels = FALSE;\n\t\t\td->applyStage1DngOpcodes = FALSE;\n\t\t\t_rawspeed_decoder = static_cast<void*>(d);\n\t\t\td->decodeRaw();\n\t\t\td->decodeMetaData(meta);\n\t\t\tRawImage r = d->mRaw;\n\t\t\tif( r->errors.size()>0 && !rawspeed_ignore_errors)\n\t\t\t{\n\t\t\t\tdelete d;\n\t\t\t\t_rawspeed_decoder = 0;\n\t\t\t\tthrow 1;\n\t\t\t}\n\t\t\tif (r->isCFA)\n\t\t\t{\n\t\t\t\timgdata.rawdata.raw_image = (ushort*) r->getDataUncropped(0,0);\n\t\t\t}\n\t\t\telse if(r->getCpp()==4)\n\t\t\t{\n\t\t\t\timgdata.rawdata.color4_image = (ushort(*)[4]) r->getDataUncropped(0,0);\n\t\t\t\tif(r->whitePoint > 0 && r->whitePoint < 65536)\n\t\t\t\t\tC.maximum = r->whitePoint;\n\t\t\t} else if(r->getCpp() == 3)\n\t\t\t{\n\t\t\t\timgdata.rawdata.color3_image = (ushort(*)[3]) r->getDataUncropped(0,0);\n\t\t\t\tif(r->whitePoint > 0 && r->whitePoint < 65536)\n\t\t\t\t\tC.maximum = r->whitePoint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdelete d;\n\t\t\t\t_rawspeed_decoder = 0;\n\t\t\t\tret = LIBRAW_UNSPECIFIED_ERROR;\n\t\t\t}\n\t\t\tif(_rawspeed_decoder)\n\t\t\t{\n\t\t\t\t// set sizes\n\t\t\t\tiPoint2D rsdim = r->getUncroppedDim();\n\t\t\t\tS.raw_pitch = r->pitch;\n\t\t\t\tS.raw_width = rsdim.x;\n\t\t\t\tS.raw_height = rsdim.y;\n\t\t\t\t//C.maximum = r->whitePoint;\n\t\t\t\tfix_after_rawspeed(r->blackLevel);\n\t\t\t}\n\t\t\tfree(_rawspeed_buffer);\n\t\t\t_rawspeed_buffer = 0;\n\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROCESSED;\n\t\t}\n\t\tcatch (const RawDecoderException& RDE)\n\t\t{\n\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n\t\t\tif (_rawspeed_buffer)\n\t\t\t{\n\t\t\t\tfree(_rawspeed_buffer);\n\t\t\t\t_rawspeed_buffer = 0;\n\t\t\t}\n\t\t\tconst char *p = RDE.what();\n\t\t\tif (!strncmp(RDE.what(), \"Decoder canceled\", strlen(\"Decoder canceled\")))\n\t\t\t\tthrow LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;\n\t\t\tret = LIBRAW_UNSPECIFIED_ERROR;\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t\t// We may get here due to cancellation flag\n\t\t\timgdata.process_warnings |= LIBRAW_WARN_RAWSPEED_PROBLEM;\n\t\t\tif(_rawspeed_buffer)\n\t\t\t{\n\t\t\t\tfree(_rawspeed_buffer);\n\t\t\t\t_rawspeed_buffer = 0;\n\t\t\t}\n\t\t\tret = LIBRAW_UNSPECIFIED_ERROR;\n\t\t}\n\t\tID.input->seek(spos,SEEK_SET);\n\n\treturn ret;\n#else\n\treturn LIBRAW_NOT_IMPLEMENTED;\n#endif\n}\n\nint LibRaw::valid_for_dngsdk()\n{\n#ifndef USE_DNGSDK\n\treturn 0;\n#else\n\tif(!imgdata.idata.dng_version)\n\t\treturn 0;\n\tif(!imgdata.params.use_dngsdk)\n\t\treturn 0;\n\tif (load_raw == &LibRaw::lossy_dng_load_raw)\n\t\treturn 0;\n\tif(is_floating_point() && (imgdata.params.use_dngsdk & LIBRAW_DNG_FLOAT))\n\t\treturn 1;\n\tif(!imgdata.idata.filters && (imgdata.params.use_dngsdk & LIBRAW_DNG_LINEAR))\n\t\treturn 1;\n\tif(libraw_internal_data.unpacker_data.tiff_bps == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_8BIT))\n\t\treturn 1;\n\tif(libraw_internal_data.unpacker_data.tiff_compress == 8 && (imgdata.params.use_dngsdk & LIBRAW_DNG_DEFLATE))\n\t\treturn 1;\n\tif(libraw_internal_data.unpacker_data.tiff_samples == 2 )\n\t\treturn 0; // Always deny 2-samples (old fuji superccd)\n\tif(imgdata.idata.filters == 9 && (imgdata.params.use_dngsdk & LIBRAW_DNG_XTRANS))\n\t\treturn 1;\n\tif(is_fuji_rotated())\n\t\treturn 0; // refuse\n\tif(imgdata.params.use_dngsdk & LIBRAW_DNG_OTHER)\n\t\treturn 1;\n\treturn 0;\n#endif\n}\n\n\nint LibRaw::is_curve_linear()\n{\n\tfor (int i=0; i < 0x10000; i++)\n\t\tif(imgdata.color.curve[i] != i)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n\nint LibRaw::try_dngsdk()\n{\n#ifdef USE_DNGSDK\n\tif(!dnghost)\n\t\treturn LIBRAW_UNSPECIFIED_ERROR;\n\n\tdng_host *host = static_cast<dng_host*>(dnghost);\n\n\ttry\n\t{\n\t\tlibraw_dng_stream stream(libraw_internal_data.internal_data.input);\n\n\t\tAutoPtr<dng_negative> negative;\n\t\tnegative.Reset (host->Make_dng_negative ());\n\n\t\tdng_info info;\n\t\tinfo.Parse (*host, stream);\n\t\tinfo.PostParse (*host);\n\n\t\tif (!info.IsValidDNG ())\n\t\t{\n\t\t\treturn LIBRAW_DATA_ERROR;\n\t\t}\n\t\tnegative->Parse (*host, stream, info);\n\t\tnegative->PostParse (*host, stream, info);\n\t\tnegative->ReadStage1Image (*host, stream, info);\n\t\tdng_simple_image *stage2 = (dng_simple_image *)negative->Stage1Image ();\n\t\tif(stage2->Bounds().W() != S.raw_width || stage2->Bounds().H()!= S.raw_height)\n\t\t{\n\t\t\treturn LIBRAW_DATA_ERROR;\n\t\t}\n\n\t\tint pplanes = stage2->Planes();\n\t\tint ptype = stage2->PixelType();\n\n\t\tdng_pixel_buffer buffer;\n\t\tstage2->GetPixelBuffer(buffer);\n\n\t\tint pixels =  stage2->Bounds().H () * stage2->Bounds().W () * pplanes;\n\t\tif(ptype == ttByte )\n\t\t\timgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ttShort));\n\t\telse\n\t\t\timgdata.rawdata.raw_alloc = malloc(pixels * TagTypeSize(ptype));\n\n\t\tif(ptype == ttShort && !is_curve_linear())\n\t\t{\n\t\t\tushort *src = (ushort *)buffer.fData;\n\t\t\tushort *dst = (ushort*)imgdata.rawdata.raw_alloc;\n\t\t\tfor(int i = 0; i < pixels; i++)\n\t\t\t\tdst[i] = imgdata.color.curve[src[i]];\n\t\t\tS.raw_pitch = S.raw_width*pplanes*TagTypeSize(ptype);\n\t\t}\n\t\telse if(ptype == ttByte)\n\t\t{\n\t\t\tunsigned char *src = (unsigned char *)buffer.fData;\n\t\t\tushort *dst = (ushort*)imgdata.rawdata.raw_alloc;\n\t\t\tif(is_curve_linear())\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < pixels; i++)\n\t\t\t\t\tdst[i] = src[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < pixels; i++)\n\t\t\t\t\tdst[i] = imgdata.color.curve[src[i]];\n\t\t\t}\n\t\t\tS.raw_pitch = S.raw_width*pplanes*TagTypeSize(ttShort);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemmove(imgdata.rawdata.raw_alloc,buffer.fData,pixels * TagTypeSize(ptype));\n\t\t\tS.raw_pitch = S.raw_width*pplanes*TagTypeSize(ptype);\n\t\t}\n\n\t\tswitch(ptype)\n\t\t{\n\t\tcase ttFloat:\n\t\t\tif(pplanes==1)\n\t\t\t\timgdata.rawdata.float_image = (float*)imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 3)\n\t\t\t\timgdata.rawdata.float3_image = (float (*)[3])imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 4)\n\t\t\t\timgdata.rawdata.float4_image = (float (*)[4])imgdata.rawdata.raw_alloc;\n\t\t\tbreak;\n\n\t\tcase ttByte:\n\t\tcase ttShort:\n\t\t\tif(pplanes==1)\n\t\t\t\timgdata.rawdata.raw_image = (ushort*)imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 3)\n\t\t\t\timgdata.rawdata.color3_image = (ushort(*)[3])imgdata.rawdata.raw_alloc;\n\t\t\telse if(pplanes == 4)\n\t\t\t\timgdata.rawdata.color4_image = (ushort(*)[4])imgdata.rawdata.raw_alloc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* do nothing */\n\t\t\tbreak;\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t\treturn LIBRAW_UNSPECIFIED_ERROR;\n\t}\n\treturn imgdata.rawdata.raw_alloc?LIBRAW_SUCCESS:LIBRAW_UNSPECIFIED_ERROR;\n#else\n\treturn LIBRAW_UNSPECIFIED_ERROR;\n#endif\n}\nvoid LibRaw::set_dng_host(void *p)\n{\n#ifdef USE_DNGSDK\n\tdnghost = p;\n#endif\n}\n\nint LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try {\n\n    if(!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if(!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if(imgdata.image)\n      {\n        free(imgdata.image);\n        imgdata.image = 0;\n      }\n    if(imgdata.rawdata.raw_alloc)\n      {\n        free(imgdata.rawdata.raw_alloc);\n        imgdata.rawdata.raw_alloc = 0;\n      }\n    if (libraw_internal_data.unpacker_data.meta_length)\n      {\n        libraw_internal_data.internal_data.meta_data =\n          (char *) malloc (libraw_internal_data.unpacker_data.meta_length);\n        merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");\n      }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if( !IO.fuji_width)\n      {\n        // adjust non-Fuji allocation\n        if(rwidth < S.width + S.left_margin)\n          rwidth = S.width + S.left_margin;\n        if(rheight < S.height + S.top_margin)\n          rheight = S.height + S.top_margin;\n      }\n    if(rwidth > 65535 || rheight > 65535) // No way to make image larger than 64k pix\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n\timgdata.rawdata.float_image = 0;\n\timgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n\tif(imgdata.idata.dng_version && dnghost && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)\n\t{\n\t\tint rr = try_dngsdk();\n\t}\n#endif\n\n#ifdef USE_RAWSPEED\n\tif(!raw_was_read())\n\t{\n\t\tint rawspeed_enabled = 1;\n\n\t\tif(imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.raw_count > 1)\n\t\t\trawspeed_enabled = 0;\n\n\t\t// Disable rawspeed for double-sized Oly files\n\t\tif(!strncasecmp(imgdata.idata.make,\"Olympus\",7) &&\n\t\t\t( ( imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model,\"SH-2\",4) || !strncasecmp(imgdata.idata.model,\"SH-3\",4) || !strncasecmp(imgdata.idata.model,\"TG-4\",4))\n\t\t\t)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.dng_version && imgdata.idata.filters==0 && libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make,\"Nikon\",5) && !strncasecmp(imgdata.idata.model,\"E\",1) )\n\t\t\trawspeed_enabled = 0;\n\n\t\t// RawSpeed Supported,\n\t\tif(O.use_rawspeed  && rawspeed_enabled\n\t\t\t&& !(is_sraw() && (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)))\n\t\t\t&& (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n\t\t{\n\t\t\tint rr = try_rawspeed();\n\t\t}\n\t}\n#endif\n    if(!raw_was_read()) //RawSpeed failed or not run\n      {\n        // Not allocated on RawSpeed call, try call LibRaow\n\t\tint zero_rawimage = 0;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder and DNG float\n            // Do nothing! Decoder will allocate data internally\n          }\n        else if(imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n          {\n\n\t    if(INT64(rwidth)*INT64(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]) > LIBRAW_MAX_ALLOC_MB * INT64(1024*1024))\n\t      throw LIBRAW_EXCEPTION_ALLOC;\n\t    \n            imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]));\n            imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;\n            if(!S.raw_pitch)\n                S.raw_pitch = S.raw_width*2; // Bayer case, not set before\n          }\n        else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n          {\n            // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n            S.iwidth = S.width;\n            S.iheight= S.height;\n            IO.shrink = 0;\n\t\t\tif(!S.raw_pitch)\n\t\t\t\tS.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8;\n            // allocate image as temporary buffer, size\n            imgdata.rawdata.raw_alloc = 0;\n\t    if(INT64(MAX(S.width,S.raw_width))*INT64(MAX(S.height,S.raw_height))*sizeof(*imgdata.image) > LIBRAW_MAX_ALLOC_MB * INT64(1024*1024))\n\t      throw LIBRAW_EXCEPTION_ALLOC;\n\n            imgdata.image = (ushort (*)[4]) calloc(unsigned(MAX(S.width,S.raw_width))*unsigned(MAX(S.height,S.raw_height)),sizeof(*imgdata.image));\n\t\t\tif(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL))\n\t\t\t{\n\t\t\t\timgdata.rawdata.raw_image = (ushort*) imgdata.image ;\n\t\t\t\tzero_rawimage = 1;\n\t\t\t}\n          }\n        ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n        unsigned m_save = C.maximum;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum=65535;\n        (this->*load_raw)();\n\t\tif(zero_rawimage)\n\t\t\timgdata.rawdata.raw_image = 0;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum = m_save;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder only: do nothing\n\n          }\n        else if (!(imgdata.idata.filters || P1.colors == 1) ) // legacy decoder, ownalloc handled above\n          {\n            // successfully decoded legacy image, attach image to raw_alloc\n            imgdata.rawdata.raw_alloc = imgdata.image;\n\t\t    imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;\n            imgdata.image = 0;\n            // Restore saved values. Note: Foveon have masked frame\n            // Other 4-color legacy data: no borders\n\t\t\tif(!(libraw_internal_data.unpacker_data.load_flags & 256))\n\t\t\t{\n\t\t\t\tS.raw_width = S.width;\n\t\t\t\tS.left_margin = 0;\n\t\t\t\tS.raw_height = S.height;\n\t\t\t\tS.top_margin = 0;\n\t\t\t}\n          }\n      }\n\n    if(imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for(c=0;c<3;c++)\n      if (i > C.cblack[c]) i = C.cblack[c];\n    for (c=0;c<4;c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);\n\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee) {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}\n\nvoid LibRaw::unpacked_load_raw_fuji_f700s20()\n{\n  int base_offset = 0;\n  int row_size = imgdata.sizes.raw_width * 2; // in bytes\n  if(imgdata.idata.raw_count==2 && imgdata.params.shot_select)\n    {\n      libraw_internal_data.internal_data.input->seek(-row_size,SEEK_CUR);\n      base_offset = row_size; // in bytes\n    }\n  unsigned char *buffer = (unsigned char*)malloc(row_size*2);\n  for(int row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      read_shorts((ushort*)buffer,imgdata.sizes.raw_width * 2);\n      memmove(&imgdata.rawdata.raw_image[row*imgdata.sizes.raw_pitch/2],buffer+base_offset,row_size);\n    }\n  free(buffer);\n}\n\nvoid LibRaw::nikon_load_sraw()\n{\n  // We're already seeked to data!\n  unsigned char *rd = (unsigned char *)malloc(3*(imgdata.sizes.raw_width+2));\n  if(!rd) throw LIBRAW_EXCEPTION_ALLOC;\n  try {\n    int row,col;\n    for(row = 0; row < imgdata.sizes.raw_height; row++)\n      {\n        checkCancel();\n        libraw_internal_data.internal_data.input->read(rd,3,imgdata.sizes.raw_width);\n        for(col = 0; col < imgdata.sizes.raw_width-1;col+=2)\n          {\n            int bi = col*3;\n            ushort bits1 = (rd[bi+1] &0xf)<<8| rd[bi]; // 3,0,1\n            ushort bits2 = rd[bi+2] << 4 | ((rd[bi+1]>>4)& 0xf); //452\n            ushort bits3 =  ((rd[bi+4] & 0xf)<<8) | rd[bi+3]; // 967\n            ushort bits4 = rd[bi+5] << 4 | ((rd[bi+4]>>4)& 0xf); // ab8\n            imgdata.image[row*imgdata.sizes.raw_width+col][0]=bits1;\n            imgdata.image[row*imgdata.sizes.raw_width+col][1]=bits3;\n            imgdata.image[row*imgdata.sizes.raw_width+col][2]=bits4;\n            imgdata.image[row*imgdata.sizes.raw_width+col+1][0]=bits2;\n            imgdata.image[row*imgdata.sizes.raw_width+col+1][1]=2048;\n            imgdata.image[row*imgdata.sizes.raw_width+col+1][2]=2048;\n          }\n      }\n  }catch (...) {\n    free(rd);\n    throw ;\n  }\n  free(rd);\n  C.maximum = 0xfff; // 12 bit?\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)\n    {\n      return; // no CbCr interpolation\n    }\n  // Interpolate CC channels\n  int row,col;\n  for(row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      checkCancel(); // will throw out\n      for(col = 0; col < imgdata.sizes.raw_width;col+=2)\n        {\n          int col2 = col<imgdata.sizes.raw_width-2?col+2:col;\n          imgdata.image[row*imgdata.sizes.raw_width+col+1][1]\n            =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][1]\n                                  +imgdata.image[row*imgdata.sizes.raw_width+col2][1])/2);\n          imgdata.image[row*imgdata.sizes.raw_width+col+1][2]\n            =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][2]\n                                  +imgdata.image[row*imgdata.sizes.raw_width+col2][2])/2);\n        }\n    }\n  if(imgdata.params.raw_processing_options & LIBRAW_PROCESSING_SRAW_NO_RGB)\n    return;\n\n  for(row = 0; row < imgdata.sizes.raw_height; row++)\n    {\n      checkCancel(); // will throw out\n      for(col = 0; col < imgdata.sizes.raw_width;col++)\n        {\n          float Y = float(imgdata.image[row*imgdata.sizes.raw_width+col][0])/2549.f;\n          float Ch2 = float(imgdata.image[row*imgdata.sizes.raw_width+col][1]-1280)/1536.f;\n          float Ch3 = float(imgdata.image[row*imgdata.sizes.raw_width+col][2]-1280)/1536.f;\n          if(Y>1.f) Y = 1.f;\n\t\t  if(Y>0.803f) Ch2 = Ch3 = 0.5f;\n          float r = Y + 1.40200f*(Ch3 - 0.5f);\n\t\t  if(r<0.f) r=0.f;\n\t\t  if(r>1.f) r=1.f;\n          float g = Y - 0.34414f*(Ch2-0.5f) - 0.71414*(Ch3 - 0.5f) ;\n\t\t  if(g>1.f) g = 1.f;\n\t\t  if(g<0.f) g = 0.f;\n          float b = Y + 1.77200*(Ch2-0.5f);\n\t\t  if(b>1.f) b = 1.f;\n\t\t  if(b<0.f) b = 0.f;\n          imgdata.image[row*imgdata.sizes.raw_width+col][0]=imgdata.color.curve[int(r*3072.f)];\n          imgdata.image[row*imgdata.sizes.raw_width+col][1]=imgdata.color.curve[int(g*3072.f)];\n          imgdata.image[row*imgdata.sizes.raw_width+col][2]=imgdata.color.curve[int(b*3072.f)];\n        }\n    }\n  C.maximum=16383;\n}\n\nvoid LibRaw::free_image(void)\n{\n  if(imgdata.image)\n    {\n      free(imgdata.image);\n      imgdata.image = 0;\n      imgdata.progress_flags\n        = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN\n        |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;\n    }\n}\n\n\nvoid LibRaw::raw2image_start()\n{\n  // restore color,sizes and internal data into raw_image fields\n  memmove(&imgdata.color,&imgdata.rawdata.color,sizeof(imgdata.color));\n  memmove(&imgdata.sizes,&imgdata.rawdata.sizes,sizeof(imgdata.sizes));\n  memmove(&imgdata.idata,&imgdata.rawdata.iparams,sizeof(imgdata.idata));\n  memmove(&libraw_internal_data.internal_output_params,&imgdata.rawdata.ioparams,sizeof(libraw_internal_data.internal_output_params));\n\n  if (O.user_flip >= 0)\n    S.flip = O.user_flip;\n\n  switch ((S.flip+3600) % 360)\n    {\n    case 270:  S.flip = 5;  break;\n    case 180:  S.flip = 3;  break;\n    case  90:  S.flip = 6;  break;\n    }\n\n  // adjust for half mode!\n  IO.shrink = P1.filters && (O.half_size ||\n                             ((O.threshold || O.aber[0] != 1 || O.aber[2] != 1) ));\n\n  S.iheight = (S.height + IO.shrink) >> IO.shrink;\n  S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n\n}\n\nint LibRaw::is_phaseone_compressed()\n{\n  return (load_raw == &LibRaw::phase_one_load_raw_c || load_raw == &LibRaw::phase_one_load_raw);\n}\n\nint LibRaw::is_canon_600()\n{\n\treturn load_raw == &LibRaw::canon_600_load_raw;\n}\n\nint LibRaw::raw2image(void)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try {\n    raw2image_start();\n\n    if (is_phaseone_compressed())\n      {\n        phase_one_allocate_tempbuffer();\n        int rc = phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);\n\tif(rc == 0)\n\t  rc = phase_one_correct();\n\tif(rc!=0)\n\t{\n\t  phase_one_free_tempbuffer();\n\t  return rc;\n\t}\n      }\n\n    // free and re-allocate image bitmap\n    if(imgdata.image)\n      {\n        imgdata.image = (ushort (*)[4]) realloc (imgdata.image,S.iheight*S.iwidth *sizeof (*imgdata.image));\n        memset(imgdata.image,0,S.iheight*S.iwidth *sizeof (*imgdata.image));\n      }\n    else\n      imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));\n\n    merror (imgdata.image, \"raw2image()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Move saved bitmap to imgdata.image\n    if( imgdata.idata.filters || P1.colors == 1)\n      {\n        if (IO.fuji_width) {\n          unsigned r,c;\n          int row,col;\n          for (row=0; row < S.raw_height-S.top_margin*2; row++) {\n            for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++) {\n              if (libraw_internal_data.unpacker_data.fuji_layout) {\n                r = IO.fuji_width - 1 - col + (row >> 1);\n                c = col + ((row+1) >> 1);\n              } else {\n                r = IO.fuji_width - 1 + row - (col >> 1);\n                c = row + ((col+1) >> 1);\n              }\n              if (r < S.height && c < S.width)\n                imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][FC(r,c)]\n                  = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n            }\n          }\n        }\n        else {\n          int row,col;\n          for (row=0; row < S.height; row++)\n            for (col=0; col < S.width; col++)\n              imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][fcol(row,col)]\n                = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n        }\n      }\n    else // if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if(imgdata.rawdata.color4_image)\n          {\n            if(S.width*8 == S.raw_pitch)\n              memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));\n            else\n              {\n                for(int row = 0; row < S.height; row++)\n                  memmove(&imgdata.image[row*S.width],\n                          &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],\n                          S.width*sizeof(*imgdata.image));\n              }\n          }\n        else if(imgdata.rawdata.color3_image)\n          {\n            unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;\n            for(int row = 0; row < S.height; row++)\n              {\n                ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];\n                ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];\n                for(int col=0; col < S.width; col++)\n                  {\n                    for(int c=0; c< 3; c++)\n                      dstrow[col][c] = srcrow[S.left_margin+col][c];\n                    dstrow[col][3]=0;\n                  }\n              }\n          }\n        else\n          {\n            // legacy decoder, but no data?\n            throw LIBRAW_EXCEPTION_DECODE_RAW;\n          }\n      }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n      {\n        phase_one_free_tempbuffer();\n      }\n    // hack - clear later flags!\n\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n      {\n        canon_600_correct();\n      }\n\n    imgdata.progress_flags\n      = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE\n      |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nvoid LibRaw::phase_one_allocate_tempbuffer()\n{\n  // Allocate temp raw_image buffer\n  imgdata.rawdata.raw_image = (ushort*)malloc(S.raw_pitch*S.raw_height);\n  merror (imgdata.rawdata.raw_image, \"phase_one_prepare_to_correct()\");\n}\nvoid LibRaw::phase_one_free_tempbuffer()\n{\n\tfree(imgdata.rawdata.raw_image);\n\timgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;\n}\n\nint LibRaw::phase_one_subtract_black(ushort *src, ushort *dest)\n{\n\n  try\n    {\n      if (O.user_black < 0 && O.user_cblack[0] <= -1000000 && O.user_cblack[1] <= -1000000 && O.user_cblack[2] <= -1000000 && O.user_cblack[3] <= -1000000)\n        {\n          if (!imgdata.rawdata.ph1_cblack || !imgdata.rawdata.ph1_rblack)\n            {\n              register int bl = imgdata.color.phase_one_data.t_black;\n              for (int row = 0; row < S.raw_height; row++)\n                {\n                  checkCancel();\n                  for (int col = 0; col < S.raw_width; col++)\n                    {\n                      int idx = row*S.raw_width + col;\n                      int val = int(src[idx]) - bl;\n                      dest[idx] = val>0 ? val : 0;\n                    }\n                }\n            }\n          else\n            {\n              register int bl = imgdata.color.phase_one_data.t_black;\n              for (int row = 0; row < S.raw_height; row++)\n                {\n                  checkCancel();\n                  for (int col = 0; col < S.raw_width; col++)\n                    {\n                      int idx = row*S.raw_width + col;\n                      int val = int(src[idx]) - bl\n                      + imgdata.rawdata.ph1_cblack[row][col >= imgdata.rawdata.color.phase_one_data.split_col]\n                        + imgdata.rawdata.ph1_rblack[col][row >= imgdata.rawdata.color.phase_one_data.split_row];\n                      dest[idx] = val>0 ? val : 0;\n                    }\n                }\n            }\n        }\n      else // black set by user interaction\n        {\n          // Black level in cblack!\n          for (int row = 0; row < S.raw_height; row++)\n            {\n              checkCancel();\n              unsigned short cblk[16];\n              for (int cc = 0; cc < 16; cc++)\n                cblk[cc] = C.cblack[fcol(row, cc)];\n              for (int col = 0; col < S.raw_width; col++)\n                {\n                  int idx = row*S.raw_width + col;\n                  ushort val = src[idx];\n                  ushort bl = cblk[col & 0xf];\n                  dest[idx] = val>bl ? val - bl : 0;\n                }\n            }\n        }\n      return 0;\n    }\n  catch (LibRaw_exceptions err) {\n    return LIBRAW_CANCELLED_BY_CALLBACK;\n  }\n}\n\nvoid LibRaw::copy_fuji_uncropped(unsigned short cblack[4],unsigned short *dmaxp)\n{\n  int row;\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row=0; row < S.raw_height-S.top_margin*2; row++)\n    {\n      int col;\n      unsigned short ldmax = 0;\n      for (col=0; col < IO.fuji_width << !libraw_internal_data.unpacker_data.fuji_layout; col++)\n        {\n          unsigned r,c;\n          if (libraw_internal_data.unpacker_data.fuji_layout) {\n            r = IO.fuji_width - 1 - col + (row >> 1);\n            c = col + ((row+1) >> 1);\n          } else {\n            r = IO.fuji_width - 1 + row - (col >> 1);\n            c = row + ((col+1) >> 1);\n          }\n          if (r < S.height && c < S.width)\n            {\n              unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n              int cc = FC(r,c);\n              if(val>cblack[cc])\n                {\n                  val-=cblack[cc];\n                  if(val>ldmax)ldmax = val;\n                }\n              else\n                val = 0;\n              imgdata.image[((r)>>IO.shrink)*S.iwidth+((c)>>IO.shrink)][cc] = val;\n            }\n        }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n      {\n        if(*dmaxp < ldmax)\n          *dmaxp = ldmax;\n      }\n    }\n}\n\nvoid LibRaw::copy_bayer(unsigned short cblack[4],unsigned short *dmaxp)\n{\n  // Both cropped and uncropped\n  int row;\n\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for default(shared)\n#endif\n  for (row=0; row < S.height; row++)\n    {\n      int col;\n      unsigned short ldmax = 0;\n      for (col=0; col < S.width; col++)\n        {\n          unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2+(col+S.left_margin)];\n          int cc = fcol(row,col);\n          if(val>cblack[cc])\n            {\n              val-=cblack[cc];\n              if(val>ldmax)ldmax = val;\n            }\n          else\n            val = 0;\n          imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][cc] = val;\n        }\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp critical(dataupdate)\n#endif\n      {\n        if(*dmaxp < ldmax)\n          *dmaxp = ldmax;\n      }\n    }\n}\n\n\nint LibRaw::raw2image_ex(int do_subtract_black)\n{\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  try {\n    raw2image_start();\n\n    // Compressed P1 files with bl data!\n    if (is_phaseone_compressed())\n      {\n        phase_one_allocate_tempbuffer();\n        int rc = phase_one_subtract_black((ushort*)imgdata.rawdata.raw_alloc,imgdata.rawdata.raw_image);\n\tif(rc == 0)\n\t  rc = phase_one_correct();\n\tif(rc!=0)\n\t  {\n\t    phase_one_free_tempbuffer();\n\t    return rc;\n\t  }\n      }\n\n    // process cropping\n    int do_crop = 0;\n    unsigned save_width = S.width;\n    if (~O.cropbox[2] && ~O.cropbox[3]\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        && load_raw != &LibRaw::foveon_sd_load_raw\n#endif\n        ) // Foveon SD to be cropped later\n      {\n        int crop[4],c,filt;\n        for(int c=0;c<4;c++)\n          {\n            crop[c] = O.cropbox[c];\n            if(crop[c]<0)\n              crop[c]=0;\n          }\n\n        if(IO.fuji_width && imgdata.idata.filters >= 1000)\n          {\n            crop[0] = (crop[0]/4)*4;\n            crop[1] = (crop[1]/4)*4;\n            if(!libraw_internal_data.unpacker_data.fuji_layout)\n              {\n                crop[2]*=sqrt(2.0);\n                crop[3]/=sqrt(2.0);\n              }\n            crop[2] = (crop[2]/4+1)*4;\n            crop[3] = (crop[3]/4+1)*4;\n          }\n        else if (imgdata.idata.filters == 1)\n          {\n            crop[0] = (crop[0]/16)*16;\n            crop[1] = (crop[1]/16)*16;\n          }\n        else if(imgdata.idata.filters == LIBRAW_XTRANS)\n          {\n            crop[0] = (crop[0]/6)*6;\n            crop[1] = (crop[1]/6)*6;\n          }\n        do_crop = 1;\n\n        crop[2] = MIN (crop[2], (signed) S.width-crop[0]);\n        crop[3] = MIN (crop[3], (signed) S.height-crop[1]);\n        if (crop[2] <= 0 || crop[3] <= 0)\n          throw LIBRAW_EXCEPTION_BAD_CROP;\n\n        // adjust sizes!\n        S.left_margin+=crop[0];\n        S.top_margin+=crop[1];\n        S.width=crop[2];\n        S.height=crop[3];\n\n        S.iheight = (S.height + IO.shrink) >> IO.shrink;\n        S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n        if(!IO.fuji_width && imgdata.idata.filters && imgdata.idata.filters >= 1000)\n          {\n            for (filt=c=0; c < 16; c++)\n              filt |= FC((c >> 1)+(crop[1]),\n                         (c &  1)+(crop[0])) << c*2;\n            imgdata.idata.filters = filt;\n          }\n      }\n\n    int alloc_width = S.iwidth;\n    int alloc_height = S.iheight;\n\n    if(IO.fuji_width && do_crop)\n      {\n        int IO_fw = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n        int t_alloc_width = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO_fw;\n        int t_alloc_height = t_alloc_width - 1;\n        alloc_height = (t_alloc_height + IO.shrink) >> IO.shrink;\n        alloc_width = (t_alloc_width + IO.shrink) >> IO.shrink;\n      }\n    int alloc_sz = alloc_width*alloc_height;\n\n    if(imgdata.image)\n      {\n        imgdata.image = (ushort (*)[4]) realloc (imgdata.image,alloc_sz *sizeof (*imgdata.image));\n        memset(imgdata.image,0,alloc_sz *sizeof (*imgdata.image));\n      }\n    else\n      imgdata.image = (ushort (*)[4]) calloc (alloc_sz, sizeof (*imgdata.image));\n    merror (imgdata.image, \"raw2image_ex()\");\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    // Adjust black levels\n    unsigned short cblack[4]={0,0,0,0};\n    unsigned short dmax = 0;\n    if(do_subtract_black)\n      {\n        adjust_bl();\n        for(int i=0; i< 4; i++)\n          cblack[i] = (unsigned short)C.cblack[i];\n      }\n\n    // Move saved bitmap to imgdata.image\n    if(imgdata.idata.filters || P1.colors == 1)\n      {\n        if (IO.fuji_width)\n          {\n            if(do_crop)\n              {\n                IO.fuji_width = S.width >> !libraw_internal_data.unpacker_data.fuji_layout;\n                int IO_fwidth = (S.height >> libraw_internal_data.unpacker_data.fuji_layout) + IO.fuji_width;\n                int IO_fheight = IO_fwidth - 1;\n\n                int row,col;\n                for(row=0;row<S.height;row++)\n                  {\n                    for(col=0;col<S.width;col++)\n                      {\n                        int r,c;\n                        if (libraw_internal_data.unpacker_data.fuji_layout) {\n                          r = IO.fuji_width - 1 - col + (row >> 1);\n                          c = col + ((row+1) >> 1);\n                        } else {\n                          r = IO.fuji_width - 1 + row - (col >> 1);\n                          c = row + ((col+1) >> 1);\n                        }\n\n                        unsigned short val = imgdata.rawdata.raw_image[(row+S.top_margin)*S.raw_pitch/2\n                                                            +(col+S.left_margin)];\n                        int cc = FCF(row,col);\n                        if(val > cblack[cc])\n                          {\n                            val-=cblack[cc];\n                            if(dmax < val) dmax = val;\n                          }\n                        else\n                          val = 0;\n                        imgdata.image[((r) >> IO.shrink)*alloc_width + ((c) >> IO.shrink)][cc] = val;\n                      }\n                  }\n                S.height = IO_fheight;\n                S.width = IO_fwidth;\n                S.iheight = (S.height + IO.shrink) >> IO.shrink;\n                S.iwidth  = (S.width  + IO.shrink) >> IO.shrink;\n                S.raw_height -= 2*S.top_margin;\n              }\n            else\n              {\n                copy_fuji_uncropped(cblack,&dmax);\n              }\n          } // end Fuji\n        else\n          {\n            copy_bayer(cblack,&dmax);\n          }\n      }\n    else //if(decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n      {\n        if(imgdata.rawdata.color4_image)\n          {\n            if(S.raw_pitch != S.width*8)\n              {\n                for(int row = 0; row < S.height; row++)\n                  memmove(&imgdata.image[row*S.width],\n                          &imgdata.rawdata.color4_image[(row+S.top_margin)*S.raw_pitch/8+S.left_margin],\n                          S.width*sizeof(*imgdata.image));\n              }\n            else\n              {\n                // legacy is always 4channel and not shrinked!\n                memmove(imgdata.image,imgdata.rawdata.color4_image,S.width*S.height*sizeof(*imgdata.image));\n              }\n          }\n        else if(imgdata.rawdata.color3_image)\n          {\n            unsigned char *c3image = (unsigned char*) imgdata.rawdata.color3_image;\n            for(int row = 0; row < S.height; row++)\n              {\n                ushort (*srcrow)[3] = (ushort (*)[3]) &c3image[(row+S.top_margin)*S.raw_pitch];\n                ushort (*dstrow)[4] = (ushort (*)[4]) &imgdata.image[row*S.width];\n                for(int col=0; col < S.width; col++)\n                  {\n                    for(int c=0; c< 3; c++)\n                      dstrow[col][c] = srcrow[S.left_margin+col][c];\n                    dstrow[col][3]=0;\n                  }\n              }\n          }\n        else\n          {\n            // legacy decoder, but no data?\n            throw LIBRAW_EXCEPTION_DECODE_RAW;\n          }\n      }\n\n    // Free PhaseOne separate copy allocated at function start\n    if (is_phaseone_compressed())\n      {\n\t\t  phase_one_free_tempbuffer();\n      }\n    if (load_raw == &CLASS canon_600_load_raw && S.width < S.raw_width)\n      {\n        canon_600_correct();\n      }\n\n    if(do_subtract_black)\n      {\n        C.data_maximum = (int)dmax;\n        C.maximum -= C.black;\n        //        ZERO(C.cblack);\n        C.cblack[0]=C.cblack[1]=C.cblack[2]=C.cblack[3]=0;\n        C.black = 0;\n      }\n\n    // hack - clear later flags!\n    imgdata.progress_flags\n      = LIBRAW_PROGRESS_START|LIBRAW_PROGRESS_OPEN | LIBRAW_PROGRESS_RAW2_IMAGE\n      |LIBRAW_PROGRESS_IDENTIFY|LIBRAW_PROGRESS_SIZE_ADJUST|LIBRAW_PROGRESS_LOAD_RAW;\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#if 1\n\nlibraw_processed_image_t * LibRaw::dcraw_make_mem_thumb(int *errcode)\n{\n  if(!T.thumb)\n    {\n      if ( !ID.toffset\n        && !(imgdata.thumbnail.tlength>0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n        )\n        {\n          if(errcode) *errcode= LIBRAW_NO_THUMBNAIL;\n        }\n      else\n        {\n          if(errcode) *errcode= LIBRAW_OUT_OF_ORDER_CALL;\n        }\n      return NULL;\n    }\n\n  if (T.tformat == LIBRAW_THUMBNAIL_BITMAP)\n    {\n      libraw_processed_image_t * ret =\n        (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+T.tlength);\n\n      if(!ret)\n        {\n          if(errcode) *errcode= ENOMEM;\n          return NULL;\n        }\n\n      memset(ret,0,sizeof(libraw_processed_image_t));\n      ret->type   = LIBRAW_IMAGE_BITMAP;\n      ret->height = T.theight;\n      ret->width  = T.twidth;\n      ret->colors = 3;\n      ret->bits   = 8;\n      ret->data_size = T.tlength;\n      memmove(ret->data,T.thumb,T.tlength);\n      if(errcode) *errcode= 0;\n      return ret;\n    }\n  else if (T.tformat == LIBRAW_THUMBNAIL_JPEG)\n    {\n      ushort exif[5];\n      int mk_exif = 0;\n      if(strcmp(T.thumb+6,\"Exif\")) mk_exif = 1;\n\n      int dsize = T.tlength + mk_exif * (sizeof(exif)+sizeof(tiff_hdr));\n\n      libraw_processed_image_t * ret =\n        (libraw_processed_image_t *)::malloc(sizeof(libraw_processed_image_t)+dsize);\n\n      if(!ret)\n        {\n          if(errcode) *errcode= ENOMEM;\n          return NULL;\n        }\n\n      memset(ret,0,sizeof(libraw_processed_image_t));\n\n      ret->type = LIBRAW_IMAGE_JPEG;\n      ret->data_size = dsize;\n\n      ret->data[0] = 0xff;\n      ret->data[1] = 0xd8;\n      if(mk_exif)\n        {\n          struct tiff_hdr th;\n          memcpy (exif, \"\\xff\\xe1  Exif\\0\\0\", 10);\n          exif[1] = htons (8 + sizeof th);\n          memmove(ret->data+2,exif,sizeof(exif));\n          tiff_head (&th, 0);\n          memmove(ret->data+(2+sizeof(exif)),&th,sizeof(th));\n          memmove(ret->data+(2+sizeof(exif)+sizeof(th)),T.thumb+2,T.tlength-2);\n        }\n      else\n        {\n          memmove(ret->data+2,T.thumb+2,T.tlength-2);\n        }\n      if(errcode) *errcode= 0;\n      return ret;\n\n    }\n  else\n    {\n      if(errcode) *errcode= LIBRAW_UNSUPPORTED_THUMBNAIL;\n      return NULL;\n    }\n}\n\n\n\n// jlb\n// macros for copying pixels to either BGR or RGB formats\n#define FORBGR for(c=P1.colors-1; c >=0 ; c--)\n#define FORRGB for(c=0; c < P1.colors ; c++)\n\nvoid LibRaw::get_mem_image_format(int* width, int* height, int* colors, int* bps) const\n\n{\n  if (S.flip & 4) {\n    *width = S.height;\n    *height = S.width;\n  }\n  else {\n    *width = S.width;\n    *height = S.height;\n  }\n  *colors = P1.colors;\n  *bps = O.output_bps;\n}\n\nint LibRaw::copy_mem_image(void* scan0, int stride, int bgr)\n\n{\n    // the image memory pointed to by scan0 is assumed to be in the format returned by get_mem_image_format\n    if((imgdata.progress_flags & LIBRAW_PROGRESS_THUMB_MASK) < LIBRAW_PROGRESS_PRE_INTERPOLATE)\n        return LIBRAW_OUT_OF_ORDER_CALL;\n\n    if(libraw_internal_data.output_data.histogram)\n      {\n        int perc, val, total, t_white=0x2000,c;\n        perc = S.width * S.height * O.auto_bright_thr;\n        if (IO.fuji_width) perc /= 2;\n        if (!((O.highlight & ~2) || O.no_auto_bright))\n          for (t_white=c=0; c < P1.colors; c++) {\n            for (val=0x2000, total=0; --val > 32; )\n              if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;\n            if (t_white < val) t_white = val;\n          }\n        gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);\n      }\n\n    int s_iheight = S.iheight;\n    int s_iwidth = S.iwidth;\n    int s_width = S.width;\n    int s_hwight = S.height;\n\n    S.iheight = S.height;\n    S.iwidth  = S.width;\n\n    if (S.flip & 4) SWAP(S.height,S.width);\n    uchar *ppm;\n    ushort *ppm2;\n    int c, row, col, soff, rstep, cstep;\n\n    soff  = flip_index (0, 0);\n    cstep = flip_index (0, 1) - soff;\n    rstep = flip_index (1, 0) - flip_index (0, S.width);\n\n    for (row=0; row < S.height; row++, soff += rstep)\n      {\n        uchar *bufp = ((uchar*)scan0)+row*stride;\n        ppm2 = (ushort*) (ppm = bufp);\n        // keep trivial decisions in the outer loop for speed\n        if (bgr) {\n          if (O.output_bps == 8) {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORBGR *ppm++ = imgdata.color.curve[imgdata.image[soff][c]]>>8;\n          }\n          else {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORBGR *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n          }\n        }\n        else {\n          if (O.output_bps == 8) {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORRGB *ppm++ = imgdata.color.curve[imgdata.image[soff][c]]>>8;\n          }\n          else {\n            for (col=0; col < S.width; col++, soff += cstep)\n              FORRGB *ppm2++ = imgdata.color.curve[imgdata.image[soff][c]];\n          }\n        }\n\n//            bufp += stride;           // go to the next line\n      }\n\n    S.iheight = s_iheight;\n    S.iwidth = s_iwidth;\n    S.width = s_width;\n    S.height = s_hwight;\n\n    return 0;\n\n\n}\n#undef FORBGR\n#undef FORRGB\n\n\n\nlibraw_processed_image_t *LibRaw::dcraw_make_mem_image(int *errcode)\n\n{\n    int width, height, colors, bps;\n    get_mem_image_format(&width, &height, &colors, &bps);\n    int stride = width * (bps/8) * colors;\n    unsigned ds = height * stride;\n    libraw_processed_image_t *ret = (libraw_processed_image_t*)::malloc(sizeof(libraw_processed_image_t)+ds);\n    if(!ret)\n        {\n                if(errcode) *errcode= ENOMEM;\n                return NULL;\n        }\n    memset(ret,0,sizeof(libraw_processed_image_t));\n\n    // metadata init\n    ret->type   = LIBRAW_IMAGE_BITMAP;\n    ret->height = height;\n    ret->width  = width;\n    ret->colors = colors;\n    ret->bits   = bps;\n    ret->data_size = ds;\n    copy_mem_image(ret->data, stride, 0);\n\n    return ret;\n}\n\n#undef FORC\n#undef FORCC\n#undef SWAP\n#endif\n\n\nint LibRaw::dcraw_ppm_tiff_writer(const char *filename)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n\n  if(!imgdata.image)\n    return LIBRAW_OUT_OF_ORDER_CALL;\n\n  if(!filename)\n    return ENOENT;\n  FILE *f = fopen(filename,\"wb\");\n\n  if(!f)\n    return errno;\n\n  try {\n    if(!libraw_internal_data.output_data.histogram)\n      {\n        libraw_internal_data.output_data.histogram =\n          (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);\n        merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_ppm_tiff_writer()\");\n      }\n    libraw_internal_data.internal_data.output = f;\n    write_ppm_tiff();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    libraw_internal_data.internal_data.output = NULL;\n    fclose(f);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(f);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n#define THUMB_READ_BEYOND  16384\n\nvoid LibRaw::kodak_thumb_loader()\n{\n\tINT64 est_datasize = T.theight * T.twidth / 3; // is 0.3 bytes per pixel good estimate?\n\tif (ID.toffset < 0)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\tif (ID.toffset + est_datasize > ID.input->size() + THUMB_READ_BEYOND)\n\t\tthrow LIBRAW_EXCEPTION_IO_EOF;\n\n\t// some kodak cameras\n  ushort s_height = S.height, s_width = S.width,s_iwidth = S.iwidth,s_iheight=S.iheight;\n  ushort s_flags = libraw_internal_data.unpacker_data.load_flags;\n  libraw_internal_data.unpacker_data.load_flags = 12;\n  int s_colors = P1.colors;\n  unsigned s_filters = P1.filters;\n  ushort (*s_image)[4] = imgdata.image;\n\n  S.height = T.theight;\n  S.width  = T.twidth;\n  P1.filters = 0;\n\n  if (thumb_load_raw == &CLASS kodak_ycbcr_load_raw)\n    {\n      S.height += S.height & 1;\n      S.width  += S.width  & 1;\n    }\n\n  imgdata.image = (ushort (*)[4]) calloc (S.iheight*S.iwidth, sizeof (*imgdata.image));\n  merror (imgdata.image, \"LibRaw::kodak_thumb_loader()\");\n\n  ID.input->seek(ID.toffset, SEEK_SET);\n  // read kodak thumbnail into T.image[]\n  try {\n\t  (this->*thumb_load_raw)();\n  } catch (...)\n  {\n\t  free(imgdata.image);\n\t  imgdata.image  = s_image;\n\n\t  T.twidth = 0;\n\t  S.width = s_width;\n\n\t  S.iwidth = s_iwidth;\n\t  S.iheight = s_iheight;\n\n\t  T.theight = 0;\n\t  S.height = s_height;\n\n\t  T.tcolors = 0;\n\t  P1.colors = s_colors;\n\n\t  P1.filters = s_filters;\n\t  T.tlength=0;\n\t  libraw_internal_data.unpacker_data.load_flags = s_flags;\n\t  return;\n  }\n\n  // copy-n-paste from image pipe\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#ifndef CLIP\n#define CLIP(x) LIM(x,0,65535)\n#endif\n#define SWAP(a,b) { a ^= b; a ^= (b ^= a); }\n\n  // from scale_colors\n  {\n    double   dmax;\n    float scale_mul[4];\n    int c,val;\n    for (dmax=DBL_MAX, c=0; c < 3; c++)\n      if (dmax > C.pre_mul[c])\n        dmax = C.pre_mul[c];\n\n    for( c=0; c< 3; c++)\n      scale_mul[c] = (C.pre_mul[c] / dmax) * 65535.0 / C.maximum;\n    scale_mul[3] = scale_mul[1];\n\n    size_t size = S.height * S.width;\n    for (unsigned i=0; i < size*4 ; i++)\n      {\n        val = imgdata.image[0][i];\n        if(!val) continue;\n        val *= scale_mul[i & 3];\n        imgdata.image[0][i] = CLIP(val);\n      }\n  }\n\n  // from convert_to_rgb\n  ushort *img;\n  int row,col;\n\n  int  (*t_hist)[LIBRAW_HISTOGRAM_SIZE] =  (int (*)[LIBRAW_HISTOGRAM_SIZE]) calloc(sizeof(*t_hist),4);\n  merror (t_hist, \"LibRaw::kodak_thumb_loader()\");\n\n  float out[3],\n    out_cam[3][4] =\n    {\n      {2.81761312, -1.98369181, 0.166078627, 0},\n      {-0.111855984, 1.73688626, -0.625030339, 0},\n      {-0.0379119813, -0.891268849, 1.92918086, 0}\n    };\n\n  for (img=imgdata.image[0], row=0; row < S.height; row++)\n    for (col=0; col < S.width; col++, img+=4)\n      {\n        out[0] = out[1] = out[2] = 0;\n        int c;\n        for(c=0;c<3;c++)\n          {\n            out[0] += out_cam[0][c] * img[c];\n            out[1] += out_cam[1][c] * img[c];\n            out[2] += out_cam[2][c] * img[c];\n          }\n        for(c=0; c<3; c++)\n          img[c] = CLIP((int) out[c]);\n        for(c=0; c<P1.colors;c++)\n          t_hist[c][img[c] >> 3]++;\n\n      }\n\n  // from gamma_lut\n  int  (*save_hist)[LIBRAW_HISTOGRAM_SIZE] = libraw_internal_data.output_data.histogram;\n  libraw_internal_data.output_data.histogram = t_hist;\n\n  // make curve output curve!\n  ushort (*t_curve) = (ushort*) calloc(sizeof(C.curve),1);\n  merror (t_curve, \"LibRaw::kodak_thumb_loader()\");\n  memmove(t_curve,C.curve,sizeof(C.curve));\n  memset(C.curve,0,sizeof(C.curve));\n  {\n    int perc, val, total, t_white=0x2000,c;\n\n    perc = S.width * S.height * 0.01;\t\t/* 99th percentile white level */\n    if (IO.fuji_width) perc /= 2;\n    if (!((O.highlight & ~2) || O.no_auto_bright))\n      for (t_white=c=0; c < P1.colors; c++) {\n        for (val=0x2000, total=0; --val > 32; )\n          if ((total += libraw_internal_data.output_data.histogram[c][val]) > perc) break;\n        if (t_white < val) t_white = val;\n      }\n    gamma_curve (O.gamm[0], O.gamm[1], 2, (t_white << 3)/O.bright);\n  }\n\n  libraw_internal_data.output_data.histogram = save_hist;\n  free(t_hist);\n\n  // from write_ppm_tiff - copy pixels into bitmap\n\n  S.iheight = S.height;\n  S.iwidth  = S.width;\n  if (S.flip & 4) SWAP(S.height,S.width);\n\n  if(T.thumb) free(T.thumb);\n  T.thumb = (char*) calloc (S.width * S.height, P1.colors);\n  merror (T.thumb, \"LibRaw::kodak_thumb_loader()\");\n  T.tlength = S.width * S.height * P1.colors;\n\n// from write_tiff_ppm\n  {\n\t  int soff = flip_index(0, 0);\n\t  int cstep = flip_index(0, 1) - soff;\n\t  int rstep = flip_index(1, 0) - flip_index(0, S.width);\n\n\t  for (int row = 0; row < S.height; row++, soff += rstep)\n\t  {\n\t\t  char *ppm = T.thumb + row*S.width*P1.colors;\n\t\t  for (int col = 0; col < S.width; col++, soff += cstep)\n\t\t\t  for (int c = 0; c < P1.colors; c++)\n\t\t\t\t  ppm[col*P1.colors + c] = imgdata.color.curve[imgdata.image[soff][c]] >> 8;\n\t  }\n  }\n\n  memmove(C.curve, t_curve, sizeof(C.curve));\n  free(t_curve);\n\n  // restore variables\n  free(imgdata.image);\n  imgdata.image = s_image;\n\n  T.twidth = S.width;\n  S.width = s_width;\n\n  S.iwidth = s_iwidth;\n  S.iheight = s_iheight;\n\n  T.theight = S.height;\n  S.height = s_height;\n\n  T.tcolors = P1.colors;\n  P1.colors = s_colors;\n\n  P1.filters = s_filters;\n  libraw_internal_data.unpacker_data.load_flags = s_flags;\n}\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n#undef SWAP\n\n\n// \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumbnail \ufffd\ufffd \ufffd\ufffd\ufffd\ufffd\ufffd, \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd thumb_format \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd \ufffd \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\n\nint LibRaw::thumbOK(INT64 maxsz)\n{\n\tif (!ID.input) return 0;\n\tif (!ID.toffset\n\t\t&& !(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n\t\t) return 0;\n\tINT64 fsize = ID.input->size();\n\tif (fsize > 0x7fffffffU) return 0; // No thumb for raw > 2Gb\n\tint tsize = 0;\n\tint tcol = (T.tcolors > 0 && T.tcolors < 4) ? T.tcolors : 3;\n\tif (write_thumb == &LibRaw::jpeg_thumb)\n\t\ttsize = T.tlength;\n\telse if (write_thumb == &LibRaw::ppm_thumb)\n\t\ttsize = tcol * T.twidth * T.theight;\n\telse if (write_thumb == &LibRaw::ppm16_thumb)\n\t\ttsize = tcol * T.twidth * T.theight * 2;\n\telse if (write_thumb == &LibRaw::x3f_thumb_loader)\n\t{\n\t\ttsize = x3f_thumb_size();\n\t}\n\telse // Kodak => no check\n\t\ttsize = 1;\n\tif (tsize < 0)\n\t\treturn 0;\n\tif (maxsz > 0 && tsize > maxsz)\n\t\treturn 0;\n\treturn (tsize + ID.toffset <= fsize) ? 1 : 0;\n}\n\nint LibRaw::unpack_thumb(void)\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n\tCHECK_ORDER_BIT(LIBRAW_PROGRESS_THUMB_LOAD);\n\n\ttry {\n\t\tif (!libraw_internal_data.internal_data.input)\n\t\t\treturn LIBRAW_INPUT_CLOSED;\n\n\t\tif (!ID.toffset &&\n\t\t\t!(imgdata.thumbnail.tlength > 0 && load_raw == &LibRaw::broadcom_load_raw) // RPi\n\t\t\t)\n\t\t{\n\t\t\treturn LIBRAW_NO_THUMBNAIL;\n\t\t}\n\t\telse if (thumb_load_raw)\n\t\t{\n\t\t\tkodak_thumb_loader();\n\t\t\tT.tformat = LIBRAW_THUMBNAIL_BITMAP;\n\t\t\tSET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (write_thumb == &LibRaw::x3f_thumb_loader)\n\t\t\t{\n\t\t\t\tINT64 tsize = x3f_thumb_size();\n\t\t\t\tif (tsize < 2048 ||INT64(ID.toffset) + tsize < 1)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\t\t\t\tif (INT64(ID.toffset) + tsize > ID.input->size() + THUMB_READ_BEYOND)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_EOF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (INT64(ID.toffset) + INT64(T.tlength) < 1)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\n\t\t\t\tif (INT64(ID.toffset) + INT64(T.tlength) > ID.input->size() + THUMB_READ_BEYOND)\n\t\t\t\t\tthrow LIBRAW_EXCEPTION_IO_EOF;\n\t\t\t}\n\n        ID.input->seek(ID.toffset, SEEK_SET);\n        if ( write_thumb == &LibRaw::jpeg_thumb)\n          {\n            if(T.thumb) free(T.thumb);\n            T.thumb = (char *) malloc (T.tlength);\n            merror (T.thumb, \"jpeg_thumb()\");\n            ID.input->read (T.thumb, 1, T.tlength);\n\t\t\tT.thumb[0] = 0xff;\n\t\t\tT.thumb[1] = 0xd8;\n            T.tcolors = 3;\n            T.tformat = LIBRAW_THUMBNAIL_JPEG;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        else if (write_thumb == &LibRaw::ppm_thumb)\n          {\n            T.tlength = T.twidth * T.theight*3;\n            if(T.thumb) free(T.thumb);\n\n            T.thumb = (char *) malloc (T.tlength);\n            merror (T.thumb, \"ppm_thumb()\");\n\n            ID.input->read(T.thumb, 1, T.tlength);\n\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n\n          }\n        else if (write_thumb == &LibRaw::ppm16_thumb)\n          {\n            T.tlength = T.twidth * T.theight*3;\n            ushort *t_thumb = (ushort*)calloc(T.tlength,2);\n            ID.input->read(t_thumb,2,T.tlength);\n            if ((libraw_internal_data.unpacker_data.order == 0x4949) == (ntohs(0x1234) == 0x1234))\n              swab ((char*)t_thumb, (char*)t_thumb, T.tlength*2);\n\n            if(T.thumb) free(T.thumb);\n            T.thumb = (char *) malloc (T.tlength);\n            merror (T.thumb, \"ppm_thumb()\");\n            for (int i=0; i < T.tlength; i++)\n              T.thumb[i] = t_thumb[i] >> 8;\n            free(t_thumb);\n            T.tformat = LIBRAW_THUMBNAIL_BITMAP;\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n\n          }\n        else if (write_thumb == &LibRaw::x3f_thumb_loader)\n          {\n            x3f_thumb_loader();\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        else if (write_thumb == &LibRaw::foveon_thumb)\n          {\n            foveon_thumb_loader();\n            // may return with error, so format is set in\n            // foveon thumb loader itself\n            SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);\n            return 0;\n          }\n        // else if -- all other write_thumb cases!\n#endif\n        else\n          {\n            return LIBRAW_UNSUPPORTED_THUMBNAIL;\n          }\n      }\n    // last resort\n    return LIBRAW_UNSUPPORTED_THUMBNAIL;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n\n}\n\nint LibRaw::dcraw_thumb_writer(const char *fname)\n{\n//    CHECK_ORDER_LOW(LIBRAW_PROGRESS_THUMB_LOAD);\n\n  if(!fname)\n    return ENOENT;\n\n  FILE *tfp = fopen(fname,\"wb\");\n\n  if(!tfp)\n    return errno;\n\n  if(!T.thumb)\n    {\n      fclose(tfp);\n      return LIBRAW_OUT_OF_ORDER_CALL;\n    }\n\n  try {\n    switch (T.tformat)\n      {\n      case LIBRAW_THUMBNAIL_JPEG:\n        jpeg_thumb_writer (tfp,T.thumb,T.tlength);\n        break;\n      case LIBRAW_THUMBNAIL_BITMAP:\n        fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n        fwrite (T.thumb, 1, T.tlength, tfp);\n        break;\n      default:\n        fclose(tfp);\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    fclose(tfp);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}\n\nint LibRaw::adjust_sizes_info_only(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n\n  raw2image_start();\n  if (O.use_fuji_rotate)\n    {\n      if (IO.fuji_width)\n        {\n          IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n          S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));\n          S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));\n        }\n      else\n        {\n          if (S.pixel_aspect < 0.995) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);\n          if (S.pixel_aspect > 1.005) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);\n        }\n    }\n  SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n  if ( S.flip & 4)\n    {\n      unsigned short t = S.iheight;\n      S.iheight=S.iwidth;\n      S.iwidth = t;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    }\n  return 0;\n}\n\nint LibRaw::subtract_black()\n{\n  adjust_bl();\n  return subtract_black_internal();\n}\n\nint LibRaw::subtract_black_internal()\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\n  try {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3] || (C.cblack[4] && C.cblack[5]) ))\n      {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]\n        int cblk[4],i;\n        for(i=0;i<4;i++)\n          cblk[i] = C.cblack[i];\n\n        int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n        int dmax = 0;\n        if(C.cblack[4] && C.cblack[5])\n          {\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= C.cblack[6 + i/4 / S.iwidth % C.cblack[4] * C.cblack[5] +\n\t\t\ti/4 % S.iwidth % C.cblack[5]];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(dmax < val) dmax = val;\n              }\n          }\n        else\n          {\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(dmax < val) dmax = val;\n              }\n          }\n        C.data_maximum = dmax & 0xffff;\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n        C.maximum -= C.black;\n        ZERO(C.cblack); // Yeah, we used cblack[6+] values too!\n        C.black = 0;\n#undef BAYERC\n      }\n    else\n      {\n        // Nothing to Do, maximum is already calculated, black level is 0, so no change\n        // only calculate channel maximum;\n        int idx;\n        ushort *p = (ushort*)imgdata.image;\n        int dmax = 0;\n        for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n          if(dmax < p[idx]) dmax = p[idx];\n        C.data_maximum = dmax;\n      }\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n\n}\n\n#define TBLN 65535\n\nvoid LibRaw::exp_bef(float shift, float smooth)\n{\n  // params limits\n  if(shift>8) shift = 8;\n  if(shift<0.25) shift = 0.25;\n  if(smooth < 0.0) smooth = 0.0;\n  if(smooth > 1.0) smooth = 1.0;\n\n  unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));\n\n  if(shift <=1.0)\n    {\n      for(int i=0;i<=TBLN;i++)\n        lut[i] = (unsigned short)((float)i*shift);\n    }\n  else\n    {\n      float x1,x2,y1,y2;\n\n      float cstops = log(shift)/log(2.0f);\n      float room = cstops*2;\n      float roomlin = powf(2.0f,room);\n      x2 = (float)TBLN;\n      x1 = (x2+1)/roomlin-1;\n      y1 = x1*shift;\n      y2 = x2*(1+(1-smooth)*(shift-1));\n      float sq3x=powf(x1*x1*x2,1.0f/3.0f);\n      float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);\n      float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);\n      float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;\n      for(int i=0;i<=TBLN;i++)\n        {\n          float X = (float)i;\n          float Y = A*powf(X,1.0f/3.0f)+B*X+CC;\n          if(i<x1)\n            lut[i] = (unsigned short)((float)i*shift);\n          else\n            lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));\n        }\n    }\n  for(int i=0; i< S.height*S.width; i++)\n    {\n      imgdata.image[i][0] = lut[imgdata.image[i][0]];\n      imgdata.image[i][1] = lut[imgdata.image[i][1]];\n      imgdata.image[i][2] = lut[imgdata.image[i][2]];\n      imgdata.image[i][3] = lut[imgdata.image[i][3]];\n    }\n\n  if(C.data_maximum <=TBLN)\n    C.data_maximum = lut[C.data_maximum];\n  if(C.maximum <= TBLN)\n    C.maximum = lut[C.maximum];\n  // no need to adjust the minumum, black is already subtracted\n  free(lut);\n}\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define ULIM(x,y,z) ((y) < (z) ? LIM(x,y,z) : LIM(x,z,y))\n#define CLIP(x) LIM(x,0,65535)\n\nvoid LibRaw::convert_to_rgb_loop(float out_cam[3][4])\n{\n  int row,col,c;\n  float out[3];\n  ushort *img;\n  memset(libraw_internal_data.output_data.histogram,0,sizeof(int)*LIBRAW_HISTOGRAM_SIZE*4);\n  for (img=imgdata.image[0], row=0; row < S.height; row++)\n    for (col=0; col < S.width; col++, img+=4) {\n      if (!libraw_internal_data.internal_output_params.raw_color) {\n        out[0] = out[1] = out[2] = 0;\n        for(c=0; c< imgdata.idata.colors; c++) {\n          out[0] += out_cam[0][c] * img[c];\n          out[1] += out_cam[1][c] * img[c];\n          out[2] += out_cam[2][c] * img[c];\n        }\n        for(c=0;c<3;c++) img[c] = CLIP((int) out[c]);\n      }\n      for(c=0; c< imgdata.idata.colors; c++) libraw_internal_data.output_data.histogram[c][img[c] >> 3]++;\n    }\n\n}\n\nvoid LibRaw::scale_colors_loop(float scale_mul[4])\n{\n  unsigned size = S.iheight*S.iwidth;\n\n\n  if (C.cblack[4] && C.cblack[5])\n    {\n      int val;\n      for (unsigned i=0; i < size*4; i++)\n        {\n          if (!(val = imgdata.image[0][i])) continue;\n          val -= C.cblack[6 + i/4 / S.iwidth % C.cblack[4] * C.cblack[5] +\n\t\t\ti/4 % S.iwidth % C.cblack[5]];\n          val -= C.cblack[i & 3];\n          val *= scale_mul[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n        }\n    }\n  else if(C.cblack[0]||C.cblack[1]||C.cblack[2]||C.cblack[3])\n    {\n      for (unsigned i=0; i < size*4; i++)\n        {\n          int val = imgdata.image[0][i];\n          if (!val) continue;\n          val -= C.cblack[i & 3];\n          val *= scale_mul[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n        }\n    }\n  else // BL is zero\n    {\n      for (unsigned i=0; i < size*4; i++)\n        {\n          int val = imgdata.image[0][i];\n          val *= scale_mul[i & 3];\n          imgdata.image[0][i] = CLIP(val);\n        }\n    }\n}\n\nvoid LibRaw::adjust_bl()\n{\n  int clear_repeat=0;\n   if (O.user_black >= 0)\n     {\n       C.black = O.user_black;\n       clear_repeat = 1;\n     }\n   for(int i=0; i<4; i++)\n     if(O.user_cblack[i]>-1000000)\n       {\n         C.cblack[i] = O.user_cblack[i];\n         clear_repeat  = 1;\n       }\n\n   if(clear_repeat)\n     C.cblack[4]=C.cblack[5]=0;\n\n // Add common part to cblack[] early\n   if (imgdata.idata.filters > 1000 && (C.cblack[4]+1)/2 == 1 && (C.cblack[5]+1)/2 == 1)\n   {\n\t   int clrs[4];\n\t   int lastg = -1, gcnt = 0;\n\t   for(int c = 0; c < 4; c++)\n\t   {\n\t\t\tclrs[c] = FC(c/2,c%2);\n\t\t\tif(clrs[c]==1)\n\t\t\t{\n\t\t\t\tgcnt++;\n\t\t\t\tlastg = c;\n\t\t\t}\n\t   }\n\t   if(gcnt>1 && lastg>=0)\n\t\t   clrs[lastg] = 3;\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[clrs[c]] += C.cblack[6 + c/2 % C.cblack[4] * C.cblack[5] + c%2 % C.cblack[5]];\n\t   C.cblack[4]=C.cblack[5]=0;\n\t   //imgdata.idata.filters = sfilters;\n   }\n   else if(imgdata.idata.filters <= 1000 && C.cblack[4]==1 && C.cblack[5]==1) // Fuji RAF dng\n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n  // remove common part from C.cblack[]\n  int i = C.cblack[3];\n  int c;\n  for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];\n\n  for(c=0;c<4;c++) C.cblack[c] -= i; // remove common part\n  C.black += i;\n\n  // Now calculate common part for cblack[6+] part and move it to C.black\n\n  if(C.cblack[4] && C.cblack[5])\n    {\n      i = C.cblack[6];\n      for(c=1; c<C.cblack[4]*C.cblack[5]; c++)\n        if(i>C.cblack[6+c]) i = C.cblack[6+c];\n      // Remove i from cblack[6+]\n      int nonz=0;\n      for(c=0; c<C.cblack[4]*C.cblack[5]; c++)\n        {\n          C.cblack[6+c]-=i;\n          if(C.cblack[6+c])nonz++;\n        }\n      C.black +=i;\n      if(!nonz)\n        C.cblack[4] = C.cblack[5] = 0;\n    }\n  for(c=0;c<4;c++) C.cblack[c] += C.black;\n}\n\nint LibRaw::dcraw_process(void)\n{\n  int quality,i;\n\n  int iterations=-1, dcb_enhance=1, noiserd=0;\n  int eeci_refine_fl=0, es_med_passes_fl=0;\n  float cared=0,cablue=0;\n  float linenoise=0;\n  float lclean=0,cclean=0;\n  float thresh=0;\n  float preser=0;\n  float expos=1.0;\n\n\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW);\n  //    CHECK_ORDER_HIGH(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n  try {\n\n    int no_crop = 1;\n\n    if (~O.cropbox[2] && ~O.cropbox[3])\n      no_crop=0;\n\n    libraw_decoder_info_t di;\n    get_decoder_info(&di);\n\n    bool is_bayer = (imgdata.idata.filters || P1.colors == 1);\n    int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && is_bayer && !IO.zero_is_bad;\n\n    raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!\n\n    // Adjust sizes\n\n    int save_4color = O.four_color_rgb;\n\n    if (IO.zero_is_bad)\n      {\n        remove_zeroes();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES);\n      }\n\n    if(O.bad_pixels && no_crop)\n      {\n        bad_pixels(O.bad_pixels);\n        SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS);\n      }\n\n    if (O.dark_frame && no_crop)\n      {\n        subtract (O.dark_frame);\n        SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME);\n      }\n\n    if (O.wf_debanding)\n      {\n        wf_remove_banding();\n      }\n\n    quality = 2 + !IO.fuji_width;\n\n    if (O.user_qual >= 0) quality = O.user_qual;\n\n    if(!subtract_inline || !C.data_maximum)\n      {\n        adjust_bl();\n        subtract_black_internal();\n      }\n\n\tif(!(di.decoder_flags & LIBRAW_DECODER_FIXEDMAXC))\n\t\tadjust_maximum();\n\n    if (O.user_sat > 0) C.maximum = O.user_sat;\n\n    if (P1.is_foveon)\n      {\n        if(load_raw == &LibRaw::x3f_load_raw)\n          {\n            // Filter out zeroes\n            for (int i=0; i < S.height*S.width*4; i++)\n              if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;\n          }\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        else if(load_raw == &LibRaw::foveon_dp_load_raw)\n          {\n            for (int i=0; i < S.height*S.width*4; i++)\n              if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0;\n          }\n        else\n          {\n            foveon_interpolate();\n          }\n#endif\n        SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);\n      }\n\n    if (O.green_matching && !O.half_size)\n      {\n        green_matching();\n      }\n\n    if (\n#ifdef LIBRAW_DEMOSAIC_PACK_GPL2\n        (!P1.is_foveon || (O.raw_processing_options & LIBRAW_PROCESSING_FORCE_FOVEON_X3F)) &&\n#endif\n        !O.no_auto_scale)\n      {\n        scale_colors();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);\n      }\n\n    pre_interpolate();\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE);\n\n    if (O.dcb_iterations >= 0) iterations = O.dcb_iterations;\n    if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl;\n    if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd;\n    if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine;\n    if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes;\n\n    // LIBRAW_DEMOSAIC_PACK_GPL3\n\n    if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);}\n    if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);}\n    if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);}\n    if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);}\n    if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);}\n\n    if (P1.filters  && !O.no_interpolation)\n      {\n        if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd);\n\n\t\tif(P1.filters>1000 && interpolate_bayer)\n\t\t\t(this->*interpolate_bayer)();\n\t\telse if(P1.filters==9 && interpolate_xtrans)\n\t\t\t(this->*interpolate_xtrans)();\n        else if (quality == 0)\n          lin_interpolate();\n        else if (quality == 1 || P1.colors > 3)\n          vng_interpolate();\n        else if (quality == 2 && P1.filters > 1000)\n          ppg_interpolate();\n        else if (P1.filters == LIBRAW_XTRANS)\n          {\n            // Fuji X-Trans\n            xtrans_interpolate(quality>2?3:1);\n          }\n        else if (quality == 3)\n          ahd_interpolate(); // really don't need it here due to fallback op\n        else if (quality == 4)\n          dcb(iterations, dcb_enhance);\n        //  LIBRAW_DEMOSAIC_PACK_GPL2\n        else if (quality == 5)\n          ahd_interpolate_mod();\n        else if (quality == 6)\n          afd_interpolate_pl(2,1);\n        else if (quality == 7)\n          vcd_interpolate(0);\n        else if (quality == 8)\n          vcd_interpolate(12);\n        else if (quality == 9)\n          lmmse_interpolate(1);\n\n        // LIBRAW_DEMOSAIC_PACK_GPL3\n        else if (quality == 10)\n          amaze_demosaic_RT();\n        // LGPL2\n        else if (quality == 11)\n          dht_interpolate();\n        else if (quality == 12)\n          aahd_interpolate();\n        // fallback to AHD\n        else\n          {\n            ahd_interpolate();\n            imgdata.process_warnings |= LIBRAW_WARN_FALLBACK_TO_AHD;\n          }\n\n\n        SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE);\n      }\n    if (IO.mix_green)\n      {\n        for (P1.colors=3, i=0; i < S.height * S.width; i++)\n          imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1;\n        SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);\n      }\n\n    if(!P1.is_foveon)\n      {\n        if (P1.colors == 3)\n          {\n\n            if (quality == 8)\n              {\n                if (eeci_refine_fl == 1) refinement();\n                if (O.med_passes > 0)    median_filter_new();\n                if (es_med_passes_fl > 0) es_median_filter();\n              }\n            else {\n              median_filter();\n            }\n            SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);\n          }\n      }\n\n    if (O.highlight == 2)\n      {\n        blend_highlights();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n      }\n\n    if (O.highlight > 2)\n      {\n        recover_highlights();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);\n      }\n\n    if (O.use_fuji_rotate)\n      {\n        fuji_rotate();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n      }\n\n    if(!libraw_internal_data.output_data.histogram)\n      {\n        libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4);\n        merror(libraw_internal_data.output_data.histogram,\"LibRaw::dcraw_process()\");\n      }\n#ifndef NO_LCMS\n    if(O.camera_profile)\n      {\n        apply_profile(O.camera_profile,O.output_profile);\n        SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE);\n      }\n#endif\n\n    convert_to_rgb();\n    SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB);\n\n    if (O.use_fuji_rotate)\n      {\n        stretch();\n        SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH);\n      }\n    O.four_color_rgb = save_4color; // also, restore\n\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n}\n\n// Supported cameras:\nstatic const char  *static_camera_list[] =\n{\n\"Adobe Digital Negative (DNG)\",\n\"AgfaPhoto DC-833m\",\n\"Alcatel 5035D\",\n\"Apple iPad Pro\",\n\"Apple iPhone SE\",\n\"Apple iPhone 6s\",\n\"Apple iPhone 6 plus\",\n\"Apple iPhone 7\",\n\"Apple iPhone 7 plus\",\n\"Apple QuickTake 100\",\n\"Apple QuickTake 150\",\n\"Apple QuickTake 200\",\n\"ARRIRAW format\",\n\"AVT F-080C\",\n\"AVT F-145C\",\n\"AVT F-201C\",\n\"AVT F-510C\",\n\"AVT F-810C\",\n\"Baumer TXG14\",\n\"BlackMagic Cinema Camera\",\n\"BlackMagic Micro Cinema Camera\",\n\"BlackMagic Pocket Cinema Camera\",\n\"BlackMagic Production Camera 4k\",\n\"BlackMagic URSA\",\n\"BlackMagic URSA Mini\",\n\"Canon PowerShot 600\",\n\"Canon PowerShot A5\",\n\"Canon PowerShot A5 Zoom\",\n\"Canon PowerShot A50\",\n\"Canon PowerShot A460 (CHDK hack)\",\n\"Canon PowerShot A470 (CHDK hack)\",\n\"Canon PowerShot A530 (CHDK hack)\",\n\"Canon PowerShot A550 (CHDK hack)\",\n\"Canon PowerShot A570 (CHDK hack)\",\n\"Canon PowerShot A590 (CHDK hack)\",\n\"Canon PowerShot A610 (CHDK hack)\",\n\"Canon PowerShot A620 (CHDK hack)\",\n\"Canon PowerShot A630 (CHDK hack)\",\n\"Canon PowerShot A640 (CHDK hack)\",\n\"Canon PowerShot A650 (CHDK hack)\",\n\"Canon PowerShot A710 IS (CHDK hack)\",\n\"Canon PowerShot A720 IS (CHDK hack)\",\n\"Canon PowerShot A3300 IS (CHDK hack)\",\n\"Canon PowerShot Pro70\",\n\"Canon PowerShot Pro90 IS\",\n\"Canon PowerShot Pro1\",\n\"Canon PowerShot G1\",\n\"Canon PowerShot G1 X\",\n\"Canon PowerShot G1 X Mark II\",\n\"Canon PowerShot G2\",\n\"Canon PowerShot G3\",\n\"Canon PowerShot G3 X\",\n\"Canon PowerShot G5\",\n\"Canon PowerShot G5 X\",\n\"Canon PowerShot G6\",\n\"Canon PowerShot G7 (CHDK hack)\",\n\"Canon PowerShot G7 X\",\n\"Canon PowerShot G7 X Mark II\",\n\"Canon PowerShot G9\",\n\"Canon PowerShot G9 X\",\n\"Canon PowerShot G10\",\n\"Canon PowerShot G11\",\n\"Canon PowerShot G12\",\n\"Canon PowerShot G15\",\n\"Canon PowerShot G16\",\n\"Canon PowerShot S2 IS (CHDK hack)\",\n\"Canon PowerShot S3 IS (CHDK hack)\",\n\"Canon PowerShot S5 IS (CHDK hack)\",\n\"Canon PowerShot SD300 (CHDK hack)\",\n\"Canon PowerShot SD950 (CHDK hack)\",\n\"Canon PowerShot S30\",\n\"Canon PowerShot S40\",\n\"Canon PowerShot S45\",\n\"Canon PowerShot S50\",\n\"Canon PowerShot S60\",\n\"Canon PowerShot S70\",\n\"Canon PowerShot S90\",\n\"Canon PowerShot S95\",\n\"Canon PowerShot S100\",\n\"Canon PowerShot S110\",\n\"Canon PowerShot S120\",\n\"Canon PowerShot SX1 IS\",\n\"Canon PowerShot SX50 HS\",\n\"Canon PowerShot SX60 HS\",\n\"Canon PowerShot SX110 IS (CHDK hack)\",\n\"Canon PowerShot SX120 IS (CHDK hack)\",\n\"Canon PowerShot SX220 HS (CHDK hack)\",\n\"Canon PowerShot SX20 IS (CHDK hack)\",\n\"Canon PowerShot SX30 IS (CHDK hack)\",\n\"Canon PowerShot IXUS 160 (CHDK hack)\",\n\"Canon EOS D30\",\n\"Canon EOS D60\",\n\"Canon EOS 5D\",\n\"Canon EOS 5DS\",\n\"Canon EOS 5DS R\",\n\"Canon EOS 5D Mark II\",\n\"Canon EOS 5D Mark III\",\n\"Canon EOS 5D Mark IV\",\n\"Canon EOS 6D\",\n\"Canon EOS 7D\",\n\"Canon EOS 7D Mark II\",\n\"Canon EOS 10D\",\n\"Canon EOS 20D\",\n\"Canon EOS 20Da\",\n\"Canon EOS 30D\",\n\"Canon EOS 40D\",\n\"Canon EOS 50D\",\n\"Canon EOS 60D\",\n\"Canon EOS 60Da\",\n\"Canon EOS 70D\",\n\"Canon EOS 80D\",\n\"Canon EOS 300D / Digital Rebel / Kiss Digital\",\n\"Canon EOS 350D / Digital Rebel XT / Kiss Digital N\",\n\"Canon EOS 400D / Digital Rebel XTi / Kiss Digital X\",\n\"Canon EOS 450D / Digital Rebel XSi / Kiss Digital X2\",\n\"Canon EOS 500D / Digital Rebel T1i / Kiss Digital X3\",\n\"Canon EOS 550D / Digital Rebel T2i / Kiss Digital X4\",\n\"Canon EOS 600D / Digital Rebel T3i / Kiss Digital X5\",\n\"Canon EOS 650D / Digital Rebel T4i / Kiss Digital X6i\",\n\"Canon EOS 700D / Digital Rebel T5i\",\n\"Canon EOS 750D / Digital Rebel T6i\",\n\"Canon EOS 760D / Digital Rebel T6S\",\n\"Canon EOS 100D / Digital Rebel SL1\",\n\"Canon EOS 1000D / Digital Rebel XS / Kiss Digital F\",\n\"Canon EOS 1100D / Digital Rebel T3 / Kiss Digital X50\",\n\"Canon EOS 1200D\",\n\"Canon EOS 1300D\",\n\"Canon EOS C500\",\n\"Canon EOS D2000C\",\n\"Canon EOS M\",\n\"Canon EOS M2\",\n\"Canon EOS M3\",\n\"Canon EOS M5\",\n\"Canon EOS M10\",\n\"Canon EOS-1D\",\n\"Canon EOS-1DS\",\n\"Canon EOS-1D C\",\n\"Canon EOS-1D X\",\n\"Canon EOS-1D Mark II\",\n\"Canon EOS-1D Mark II N\",\n\"Canon EOS-1D Mark III\",\n\"Canon EOS-1D Mark IV\",\n\"Canon EOS-1Ds Mark II\",\n\"Canon EOS-1Ds Mark III\",\n\"Canon EOS-1D X Mark II\",\n\"Casio QV-2000UX\",\n\"Casio QV-3000EX\",\n\"Casio QV-3500EX\",\n\"Casio QV-4000\",\n\"Casio QV-5700\",\n\"Casio QV-R41\",\n\"Casio QV-R51\",\n\"Casio QV-R61\",\n\"Casio EX-F1\",\n\"Casio EX-FC300S\",\n\"Casio EX-FC400S\",\n\"Casio EX-FH20\",\n\"Casio EX-FH25\",\n\"Casio EX-FH100\",\n\"Casio EX-S20\",\n\"Casio EX-S100\",\n\"Casio EX-Z4\",\n\"Casio EX-Z50\",\n\"Casio EX-Z500\",\n\"Casio EX-Z55\",\n\"Casio EX-Z60\",\n\"Casio EX-Z75\",\n\"Casio EX-Z750\",\n\"Casio EX-Z8\",\n\"Casio EX-Z850\",\n\"Casio EX-Z1050\",\n\"Casio EX-ZR100\",\n\"Casio EX-Z1080\",\n\"Casio EX-ZR700\",\n\"Casio EX-ZR710\",\n\"Casio EX-ZR750\",\n\"Casio EX-ZR800\",\n\"Casio EX-ZR850\",\n\"Casio EX-ZR1000\",\n\"Casio EX-ZR1100\",\n\"Casio EX-ZR1200\",\n\"Casio EX-ZR1300\",\n\"Casio EX-ZR1500\",\n\"Casio EX-ZR3000\",\n\"Casio EX-ZR4000/5000\",\n\"Casio EX-100\",\n\"Casio EX-100F\",\n\"Casio EX-10\",\n\"Casio Exlim Pro 505\",\n\"Casio Exlim Pro 600\",\n\"Casio Exlim Pro 700\",\n\"Contax N Digital\",\n\"Creative PC-CAM 600\",\n\"Digital Bolex D16\",\n\"Digital Bolex D16M\",\n\"DJI 4384x3288\",\n\"DXO One\",\n\"Epson R-D1\",\n\"Epson R-D1s\",\n\"Epson R-D1x\",\n\"Foculus 531C\",\n\"FujiFilm E505\",\n\"FujiFilm E550\",\n\"FujiFilm E900\",\n\"FujiFilm F700\",\n\"FujiFilm F710\",\n\"FujiFilm F800\",\n\"FujiFilm F810\",\n\"FujiFilm S2Pro\",\n\"FujiFilm S3Pro\",\n\"FujiFilm S5Pro\",\n\"FujiFilm S20Pro\",\n\"FujiFilm S1\",\n\"FujiFilm S100FS\",\n\"FujiFilm S5000\",\n\"FujiFilm S5100/S5500\",\n\"FujiFilm S5200/S5600\",\n\"FujiFilm S6000fd\",\n\"FujiFilm S7000\",\n\"FujiFilm S9000/S9500\",\n\"FujiFilm S9100/S9600\",\n\"FujiFilm S200EXR\",\n\"FujiFilm S205EXR\",\n\"FujiFilm SL1000\",\n\"FujiFilm HS10/HS11\",\n\"FujiFilm HS20EXR\",\n\"FujiFilm HS22EXR\",\n\"FujiFilm HS30EXR\",\n\"FujiFilm HS33EXR\",\n\"FujiFilm HS35EXR\",\n\"FujiFilm HS50EXR\",\n\"FujiFilm F505EXR\",\n\"FujiFilm F550EXR\",\n\"FujiFilm F600EXR\",\n\"FujiFilm F605EXR\",\n\"FujiFilm F770EXR\",\n\"FujiFilm F775EXR\",\n\"FujiFilm F800EXR\",\n\"FujiFilm F900EXR\",\n\"FujiFilm X-Pro1\",\n\"FujiFilm X-Pro2\",\n\"FujiFilm X-S1\",\n\"FujiFilm XQ1\",\n\"FujiFilm XQ2\",\n\"FujiFilm X100\",\n\"FujiFilm X100S\",\n\"FujiFilm X100T\",\n\"FujiFilm X10\",\n\"FujiFilm X20\",\n\"FujiFilm X30\",\n\"FujiFilm X70\",\n\"FujiFilm X-A1\",\n\"FujiFilm X-A2\",\n\"FujiFilm X-E1\",\n\"FujiFilm X-E2\",\n\"FujiFilm X-E2S\",\n\"FujiFilm X-M1\",\n\"FujiFilm XF1\",\n\"FujiFilm X-T1\",\n\"FujiFilm X-T1 Graphite Silver\",\n\"FujiFilm X-T2\",\n\"FujiFilm X-T10\",\n\"FujiFilm IS-1\",\n\"Gione E7\",\n\"GITUP GIT2\",\n\"Google Pixel\",\n\"Google Pixel XL\",\n\"Hasselblad H5D-60\",\n\"Hasselblad H5D-50\",\n\"Hasselblad H5D-50c\",\n\"Hasselblad H5D-40\",\n\"Hasselblad H4D-60\",\n\"Hasselblad H4D-50\",\n\"Hasselblad H4D-40\",\n\"Hasselblad H4D-31\",\n\"Hasselblad H3DII-22\",\n\"Hasselblad H3DII-31\",\n\"Hasselblad H3DII-39\",\n\"Hasselblad H3DII-50\",\n\"Hasselblad H3D-22\",\n\"Hasselblad H3D-31\",\n\"Hasselblad H3D-39\",\n\"Hasselblad H2D-22\",\n\"Hasselblad H2D-39\",\n\"Hasselblad CFV\",\n\"Hasselblad CFH\",\n\"Hasselblad CF-22\",\n\"Hasselblad CF-31\",\n\"Hasselblad CF-39\",\n\"Hasselblad V96C\",\n\"Hasselblad Lusso\",\n\"Hasselblad Lunar\",\n\"Hasselblad True Zoom\",\n\"Hasselblad Stellar\",\n\"Hasselblad Stellar II\",\n\"Hasselblad HV\",\n\"Hasselblad X1D\",\n\"HTC UltraPixel\",\n\"HTC MyTouch 4G\",\n\"HTC One (A9)\",\n\"HTC One (M9)\",\n\"HTC 10\",\n\"Huawei P9\",\n\"Imacon Ixpress 96, 96C\",\n\"Imacon Ixpress 384, 384C (single shot only)\",\n\"Imacon Ixpress 132C\",\n\"Imacon Ixpress 528C (single shot only)\",\n\"ISG 2020x1520\",\n\"Ikonoskop A-Cam dII Panchromatic\",\n\"Ikonoskop A-Cam dII\",\n\"Kinefinity KineMINI\",\n\"Kinefinity KineRAW Mini\",\n\"Kinefinity KineRAW S35\",\n\"Kodak DC20\",\n\"Kodak DC25\",\n\"Kodak DC40\",\n\"Kodak DC50\",\n\"Kodak DC120\",\n\"Kodak DCS200\",\n\"Kodak DCS315C\",\n\"Kodak DCS330C\",\n\"Kodak DCS420\",\n\"Kodak DCS460\",\n\"Kodak DCS460A\",\n\"Kodak DCS460D\",\n\"Kodak DCS520C\",\n\"Kodak DCS560C\",\n\"Kodak DCS620C\",\n\"Kodak DCS620X\",\n\"Kodak DCS660C\",\n\"Kodak DCS660M\",\n\"Kodak DCS720X\",\n\"Kodak DCS760C\",\n\"Kodak DCS760M\",\n\"Kodak EOSDCS1\",\n\"Kodak EOSDCS3B\",\n\"Kodak NC2000F\",\n\"Kodak ProBack\",\n\"Kodak PB645C\",\n\"Kodak PB645H\",\n\"Kodak PB645M\",\n\"Kodak DCS Pro 14n\",\n\"Kodak DCS Pro 14nx\",\n\"Kodak DCS Pro SLR/c\",\n\"Kodak DCS Pro SLR/n\",\n\"Kodak C330\",\n\"Kodak C603\",\n\"Kodak P850\",\n\"Kodak P880\",\n\"Kodak S-1\",\n\"Kodak Z980\",\n\"Kodak Z981\",\n\"Kodak Z990\",\n\"Kodak Z1015\",\n\"Kodak KAI-0340\",\n\"Konica KD-400Z\",\n\"Konica KD-510Z\",\n\"Leaf AFi 5\",\n\"Leaf AFi 6\",\n\"Leaf AFi 7\",\n\"Leaf AFi-II 6\",\n\"Leaf AFi-II 7\",\n\"Leaf AFi-II 10\",\n\"Leaf AFi-II 10R\",\n\"Leaf Aptus-II 5\",\n\"Leaf Aptus-II 6\",\n\"Leaf Aptus-II 7\",\n\"Leaf Aptus-II 8\",\n\"Leaf Aptus-II 10\",\n\"Leaf Aptus-II 12\",\n\"Leaf Aptus-II 12R\",\n\"Leaf Aptus 17\",\n\"Leaf Aptus 22\",\n\"Leaf Aptus 54S\",\n\"Leaf Aptus 65\",\n\"Leaf Aptus 65S\",\n\"Leaf Aptus 75\",\n\"Leaf Aptus 75S\",\n\"Leaf Cantare\",\n\"Leaf Cantare XY\",\n\"Leaf CatchLight\",\n\"Leaf CMost\",\n\"Leaf Credo 40\",\n\"Leaf Credo 50\",\n\"Leaf Credo 60\",\n\"Leaf Credo 80 (low compression mode only)\",\n\"Leaf DCB-II\",\n\"Leaf Valeo 6\",\n\"Leaf Valeo 11\",\n\"Leaf Valeo 17\",\n\"Leaf Valeo 17wi\",\n\"Leaf Valeo 22\",\n\"Leaf Valeo 22wi\",\n\"Leaf Volare\",\n\"Lenovo a820\",\n\"Leica C (Typ 112)\",\n\"Leica Digilux 2\",\n\"Leica Digilux 3\",\n\"Leica Digital-Modul-R\",\n\"Leica D-LUX2\",\n\"Leica D-LUX3\",\n\"Leica D-LUX4\",\n\"Leica D-LUX5\",\n\"Leica D-LUX6\",\n\"Leica D-Lux (Typ 109)\",\n\"Leica M8\",\n\"Leica M8.2\",\n\"Leica M9\",\n\"Leica M (Typ 240)\",\n\"Leica M (Typ 262)\",\n\"Leica Monochrom (Typ 240)\",\n\"Leica Monochrom (Typ 246)\",\n\"Leica M-D (Typ 262)\",\n\"Leica M-E\",\n\"Leica M-P\",\n\"Leica R8\",\n\"Leica Q (Typ 116)\",\n\"Leica S\",\n\"Leica S2\",\n\"Leica S (Typ 007)\",\n\"Leica SL (Typ 601)\",\n\"Leica T (Typ 701)\",\n\"Leica TL\",\n\"Leica X1\",\n\"Leica X (Typ 113)\",\n\"Leica X2\",\n\"Leica X-E (Typ 102)\",\n\"Leica X-U (Typ 113)\",\n\"Leica V-LUX1\",\n\"Leica V-LUX2\",\n\"Leica V-LUX3\",\n\"Leica V-LUX4\",\n\"Leica V-Lux (Typ 114)\",\n\"Leica X VARIO (Typ 107)\",\n\"LG G3\",\n\"LG G4\",\n\"Logitech Fotoman Pixtura\",\n\"Mamiya ZD\",\n\"Matrix 4608x3288\",\n\"Meizy MX4\",\n\"Micron 2010\",\n\"Minolta RD175\",\n\"Minolta DiMAGE 5\",\n\"Minolta DiMAGE 7\",\n\"Minolta DiMAGE 7i\",\n\"Minolta DiMAGE 7Hi\",\n\"Minolta DiMAGE A1\",\n\"Minolta DiMAGE A2\",\n\"Minolta DiMAGE A200\",\n\"Minolta DiMAGE G400\",\n\"Minolta DiMAGE G500\",\n\"Minolta DiMAGE G530\",\n\"Minolta DiMAGE G600\",\n\"Minolta DiMAGE Z2\",\n\"Minolta Alpha/Dynax/Maxxum 5D\",\n\"Minolta Alpha/Dynax/Maxxum 7D\",\n\"Motorola PIXL\",\n\"Nikon D1\",\n\"Nikon D1H\",\n\"Nikon D1X\",\n\"Nikon D2H\",\n\"Nikon D2Hs\",\n\"Nikon D2X\",\n\"Nikon D2Xs\",\n\"Nikon D3\",\n\"Nikon D3s\",\n\"Nikon D3X\",\n\"Nikon D4\",\n\"Nikon D4s\",\n\"Nikon D40\",\n\"Nikon D40X\",\n\"Nikon D5\",\n\"Nikon D50\",\n\"Nikon D60\",\n\"Nikon D70\",\n\"Nikon D70s\",\n\"Nikon D80\",\n\"Nikon D90\",\n\"Nikon D100\",\n\"Nikon D200\",\n\"Nikon D300\",\n\"Nikon D300s\",\n\"Nikon D500\",\n\"Nikon D600\",\n\"Nikon D610\",\n\"Nikon D700\",\n\"Nikon D750\",\n\"Nikon D800\",\n\"Nikon D800E\",\n\"Nikon D810\",\n\"Nikon D810A\",\n\"Nikon D3000\",\n\"Nikon D3100\",\n\"Nikon D3200\",\n\"Nikon D3300\",\n\"Nikon D3400\",\n\"Nikon D5000\",\n\"Nikon D5100\",\n\"Nikon D5200\",\n\"Nikon D5300\",\n\"Nikon D5500\",\n\"Nikon D7000\",\n\"Nikon D7100\",\n\"Nikon D7200\",\n\"Nikon Df\",\n\"Nikon 1 AW1\",\n\"Nikon 1 J1\",\n\"Nikon 1 J2\",\n\"Nikon 1 J3\",\n\"Nikon 1 J4\",\n\"Nikon 1 J5\",\n\"Nikon 1 S1\",\n\"Nikon 1 S2\",\n\"Nikon 1 V1\",\n\"Nikon 1 V2\",\n\"Nikon 1 V3\",\n\"Nikon E700 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E800 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E880 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E900 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E950 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E990 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E995 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E2100 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E2500 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E3200 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E3700 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E4300 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E4500 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon E5000\",\n\"Nikon E5400\",\n\"Nikon E5700\",\n\"Nikon E8400\",\n\"Nikon E8700\",\n\"Nikon E8800\",\n\"Nikon Coolpix A\",\n\"Nikon Coolpix P330\",\n\"Nikon Coolpix P340\",\n\"Nikon Coolpix P6000\",\n\"Nikon Coolpix P7000\",\n\"Nikon Coolpix P7100\",\n\"Nikon Coolpix P7700\",\n\"Nikon Coolpix P7800\",\n\"Nikon Coolpix S6 (\\\"DIAG RAW\\\" hack)\",\n\"Nikon Coolscan NEF\",\n\"Nokia N95\",\n\"Nokia X2\",\n\"Nokia 1200x1600\",\n\"Nokia Lumia 950 XL\",\n\"Nokia Lumia 1020\",\n\"Nokia Lumia 1520\",\n\"Olympus AIR A01\",\n\"Olympus C3030Z\",\n\"Olympus C5050Z\",\n\"Olympus C5060Z\",\n\"Olympus C7070WZ\",\n\"Olympus C70Z,C7000Z\",\n\"Olympus C740UZ\",\n\"Olympus C770UZ\",\n\"Olympus C8080WZ\",\n\"Olympus X200,D560Z,C350Z\",\n\"Olympus E-1\",\n\"Olympus E-3\",\n\"Olympus E-5\",\n\"Olympus E-10\",\n\"Olympus E-20\",\n\"Olympus E-30\",\n\"Olympus E-300\",\n\"Olympus E-330\",\n\"Olympus E-400\",\n\"Olympus E-410\",\n\"Olympus E-420\",\n\"Olympus E-450\",\n\"Olympus E-500\",\n\"Olympus E-510\",\n\"Olympus E-520\",\n\"Olympus E-600\",\n\"Olympus E-620\",\n\"Olympus E-P1\",\n\"Olympus E-P2\",\n\"Olympus E-P3\",\n\"Olympus E-P5\",\n\"Olympus E-PL1\",\n\"Olympus E-PL1s\",\n\"Olympus E-PL2\",\n\"Olympus E-PL3\",\n\"Olympus E-PL5\",\n\"Olympus E-PL6\",\n\"Olympus E-PL7\",\n\"Olympus E-PL8\",\n\"Olympus E-PM1\",\n\"Olympus E-PM2\",\n\"Olympus E-M1\",\n\"Olympus E-M1 Mark II\",\n\"Olympus E-M10\",\n\"Olympus E-M10 Mark II\",\n\"Olympus E-M5\",\n\"Olympus E-M5 Mark II\",\n\"Olympus Pen F\",\n\"Olympus SP310\",\n\"Olympus SP320\",\n\"Olympus SP350\",\n\"Olympus SP500UZ\",\n\"Olympus SP510UZ\",\n\"Olympus SP550UZ\",\n\"Olympus SP560UZ\",\n\"Olympus SP565UZ\",\n\"Olympus SP570UZ\",\n\"Olympus STYLUS1\",\n\"Olympus STYLUS1s\",\n\"Olympus SH-2\",\n\"Olympus SH-3\",\n\"Olympus TG-4\",\n\"Olympus XZ-1\",\n\"Olympus XZ-2\",\n\"Olympus XZ-10\",\n\"OmniVision 4688\",\n\"OmniVision OV5647\",\n\"OmniVision OV5648\",\n\"OmniVision OV8850\",\n\"OmniVision 13860\",\n\"Panasonic DMC-CM1\",\n\"Panasonic DMC-FZ8\",\n\"Panasonic DMC-FZ18\",\n\"Panasonic DMC-FZ28\",\n\"Panasonic DMC-FZ30\",\n\"Panasonic DMC-FZ35/FZ38\",\n\"Panasonic DMC-FZ40\",\n\"Panasonic DMC-FZ50\",\n\"Panasonic DMC-FZ7\",\n\"Panasonic DMC-FZ70\",\n\"Panasonic DMC-FZ100\",\n\"Panasonic DMC-FZ150\",\n\"Panasonic DMC-FZ200\",\n\"Panasonic DMC-FZ300/330\",\n\"Panasonic DMC-FZ1000\",\n\"Panasonic DMC-FZ2000/2500/FZH1\",\n\"Panasonic DMC-FX150\",\n\"Panasonic DMC-G1\",\n\"Panasonic DMC-G10\",\n\"Panasonic DMC-G2\",\n\"Panasonic DMC-G3\",\n\"Panasonic DMC-G5\",\n\"Panasonic DMC-G6\",\n\"Panasonic DMC-G7/G70\",\n\"Panasonic DMC-G8/80/81/85\",\n\"Panasonic DMC-GF1\",\n\"Panasonic DMC-GF2\",\n\"Panasonic DMC-GF3\",\n\"Panasonic DMC-GF5\",\n\"Panasonic DMC-GF6\",\n\"Panasonic DMC-GF7\",\n\"Panasonic DMC-GH1\",\n\"Panasonic DMC-GH2\",\n\"Panasonic DMC-GH3\",\n\"Panasonic DMC-GH4\",\n\"Panasonic AG-GH4\",\n\"Panasonic DMC-GM1\",\n\"Panasonic DMC-GM1s\",\n\"Panasonic DMC-GM5\",\n\"Panasonic DMC-GX1\",\n\"Panasonic DMC-GX7\",\n\"Panasonic DMC-GX8\",\n\"Panasonic DMC-GX80/85\",\n\"Panasonic DMC-L1\",\n\"Panasonic DMC-L10\",\n\"Panasonic DMC-LC1\",\n\"Panasonic DMC-LX1\",\n\"Panasonic DMC-LF1\",\n\"Panasonic DMC-LX2\",\n\"Panasonic DMC-LX3\",\n\"Panasonic DMC-LX5\",\n\"Panasonic DMC-LX7\",\n\"Panasonic DMC-LX9/10/15\",\n\"Panasonic DMC-LX100\",\n\"Panasonic DMC-TZ60/61/SZ40\",\n\"Panasonic DMC-TZ70/71/ZS50\",\n\"Panasonic DMC-TZ80/81/85/ZS60\",\n\"Panasonic DMC-TZ100/101/ZS100\",\n\"Pentax *ist D\",\n\"Pentax *ist DL\",\n\"Pentax *ist DL2\",\n\"Pentax *ist DS\",\n\"Pentax *ist DS2\",\n\"Pentax GR\",\n\"Pentax K10D\",\n\"Pentax K20D\",\n\"Pentax K100D\",\n\"Pentax K100D Super\",\n\"Pentax K110D\",\n\"Pentax K200D\",\n\"Pentax K2000/K-m\",\n\"Pentax K-x\",\n\"Pentax K-r\",\n\"Pentax K-01\",\n\"Pentax K-1\",\n\"Pentax K-3\",\n\"Pentax K-3 II\",\n\"Pentax K-30\",\n\"Pentax K-5\",\n\"Pentax K-5 II\",\n\"Pentax K-5 IIs\",\n\"Pentax K-50\",\n\"Pentax K-500\",\n\"Pentax K-7\",\n\"Pentax K-70\",\n\"Pentax K-S1\",\n\"Pentax K-S2\",\n\"Pentax MX-1\",\n\"Pentax Q\",\n\"Pentax Q7\",\n\"Pentax Q10\",\n\"Pentax QS-1\",\n\"Pentax Optio S\",\n\"Pentax Optio S4\",\n\"Pentax Optio 33WR\",\n\"Pentax Optio 750Z\",\n\"Pentax 645D\",\n\"Pentax 645Z\",\n\"PhaseOne IQ140\",\n\"PhaseOne IQ150\",\n\"PhaseOne IQ160\",\n\"PhaseOne IQ180\",\n\"PhaseOne IQ180 IR\",\n\"PhaseOne IQ250\",\n\"PhaseOne IQ260\",\n\"PhaseOne IQ260 Achromatic\",\n\"PhaseOne IQ280\",\n\"PhaseOne IQ3 50MP\",\n\"PhaseOne IQ3 60MP\",\n\"PhaseOne IQ3 80MP\",\n\"PhaseOne IQ3 100MP\",\n\"PhaseOne LightPhase\",\n\"PhaseOne Achromatic+\",\n\"PhaseOne H 10\",\n\"PhaseOne H 20\",\n\"PhaseOne H 25\",\n\"PhaseOne P 20\",\n\"PhaseOne P 20+\",\n\"PhaseOne P 21\",\n\"PhaseOne P 25\",\n\"PhaseOne P 25+\",\n\"PhaseOne P 30\",\n\"PhaseOne P 30+\",\n\"PhaseOne P 40+\",\n\"PhaseOne P 45\",\n\"PhaseOne P 45+\",\n\"PhaseOne P 65\",\n\"PhaseOne P 65+\",\n\"Photron BC2-HD\",\n\"Pixelink A782\",\n\"Polaroid x530\",\n\"RaspberryPi Camera\",\n\"RaspberryPi Camera V2\",\n\"Ricoh GR\",\n\"Ricoh GR Digital\",\n\"Ricoh GR Digital II\",\n\"Ricoh GR Digital III\",\n\"Ricoh GR Digital IV\",\n\"Ricoh GR II\",\n\"Ricoh GX100\",\n\"Ricoh GX200\",\n\"Ricoh GXR MOUNT A12\",\n\"Ricoh GXR MOUNT A16 24-85mm F3.5-5.5\",\n\"Ricoh GXR, S10 24-72mm F2.5-4.4 VC\",\n\"Ricoh GXR, GR A12 50mm F2.5 MACRO\",\n\"Ricoh GXR, GR LENS A12 28mm F2.5\",\n\"Ricoh GXR, GXR P10\",\n#ifndef NO_JASPER\n\"Redcode R3D format\",\n#endif\n\"Rollei d530flex\",\n\"RoverShot 3320af\",\n\"Samsung EX1\",\n\"Samsung EX2F\",\n\"Samsung GX-1L\",\n\"Samsung GX-1S\",\n\"Samsung GX10\",\n\"Samsung GX20\",\n\"Samsung Galaxy NX (EK-GN120)\",\n\"Samsung Galaxy S7 (SM-G935F)\",\n\"Samsung NX1\",\n\"Samsung NX5\",\n\"Samsung NX10\",\n\"Samsung NX11\",\n\"Samsung NX100\",\n\"Samsung NX1000\",\n\"Samsung NX1100\",\n\"Samsung NX20\",\n\"Samsung NX200\",\n\"Samsung NX210\",\n\"Samsung NX2000\",\n\"Samsung NX30\",\n\"Samsung NX300\",\n\"Samsung NX300M\",\n\"Samsung NX3000\",\n\"Samsung NX500\",\n\"Samsung NX mini\",\n\"Samsung Pro815\",\n\"Samsung WB550\",\n\"Samsung WB2000\",\n\"Samsung S85 (hacked)\",\n\"Samsung S850 (hacked)\",\n\"Samsung Galaxy S3\",\n\"Samsung Galaxy S7\",\n\"Samsung Galaxy S7 Edge\",\n\"Samsung Galaxy Nexus\",\n\"Sarnoff 4096x5440\",\n\"Seitz 6x17\",\n\"Seitz Roundshot D3\",\n\"Seitz Roundshot D2X\",\n\"Seitz Roundshot D2Xs\",\n\"Sigma SD9\",\n\"Sigma SD10\",\n\"Sigma SD14\",\n\"Sigma SD15\",\n\"Sigma SD1\",\n\"Sigma SD1 Merill\",\n\"Sigma DP1\",\n\"Sigma DP1 Merill\",\n\"Sigma DP1S\",\n\"Sigma DP1X\",\n\"Sigma DP2\",\n\"Sigma DP2 Merill\",\n\"Sigma DP2S\",\n\"Sigma DP2X\",\n\"Sigma DP3 Merill\",\n\"Sigma dp0 Quattro\",\n\"Sigma dp1 Quattro\",\n\"Sigma dp2 Quattro\",\n\"Sigma dp3 Quattro\",\n\"Sigma sd Quattro\",\n\"Sigma sd Quattro H\",\n\"Sinar eMotion 22\",\n\"Sinar eMotion 54\",\n\"Sinar eSpirit 65\",\n\"Sinar eMotion 75\",\n\"Sinar eVolution 75\",\n\"Sinar 3072x2048\",\n\"Sinar 4080x4080\",\n\"Sinar 4080x5440\",\n\"Sinar STI format\",\n\"Sinar Sinarback 54\",\n\"SMaL Ultra-Pocket 3\",\n\"SMaL Ultra-Pocket 4\",\n\"SMaL Ultra-Pocket 5\",\n\"Sony A7\",\n\"Sony A7 II\",\n\"Sony A7R\",\n\"Sony A7R II\",\n\"Sony A7S\",\n\"Sony A7S II\",\n\"Sony ILCA-68 (A68)\",\n\"Sony ILCA-77M2 (A77-II)\",\n\"Sony ILCA-99M2 (A99-II)\",\n\"Sony ILCE-3000\",\n\"Sony ILCE-5000\",\n\"Sony ILCE-5100\",\n\"Sony ILCE-6000\",\n\"Sony ILCE-6300\",\n\"Sony ILCE-6500\",\n\"Sony ILCE-QX1\",\n\"Sony DSC-F828\",\n\"Sony DSC-R1\",\n\"Sony DSC-RX1\",\n\"Sony DSC-RX1R\",\n\"Sony DSC-RX1R II\",\n\"Sony DSC-RX10\",\n\"Sony DSC-RX10II\",\n\"Sony DSC-RX10III\",\n\"Sony DSC-RX100\",\n\"Sony DSC-RX100II\",\n\"Sony DSC-RX100III\",\n\"Sony DSC-RX100IV\",\n\"Sony DSC-RX100V\",\n\"Sony DSC-V3\",\n\"Sony DSLR-A100\",\n\"Sony DSLR-A200\",\n\"Sony DSLR-A230\",\n\"Sony DSLR-A290\",\n\"Sony DSLR-A300\",\n\"Sony DSLR-A330\",\n\"Sony DSLR-A350\",\n\"Sony DSLR-A380\",\n\"Sony DSLR-A390\",\n\"Sony DSLR-A450\",\n\"Sony DSLR-A500\",\n\"Sony DSLR-A550\",\n\"Sony DSLR-A560\",\n\"Sony DSLR-A580\",\n\"Sony DSLR-A700\",\n\"Sony DSLR-A850\",\n\"Sony DSLR-A900\",\n\"Sony NEX-3\",\n\"Sony NEX-3N\",\n\"Sony NEX-5\",\n\"Sony NEX-5N\",\n\"Sony NEX-5R\",\n\"Sony NEX-5T\",\n\"Sony NEX-6\",\n\"Sony NEX-7\",\n\"Sony NEX-C3\",\n\"Sony NEX-F3\",\n\"Sony NEX-VG20\",\n\"Sony NEX-VG30\",\n\"Sony NEX-VG900\",\n\"Sony SLT-A33\",\n\"Sony SLT-A35\",\n\"Sony SLT-A37\",\n\"Sony SLT-A55V\",\n\"Sony SLT-A57\",\n\"Sony SLT-A58\",\n\"Sony SLT-A65V\",\n\"Sony SLT-A77V\",\n\"Sony SLT-A99V\",\n\"Sony XCD-SX910CR\",\n\"Sony IMX135-mipi 13mp\",\n\"Sony IMX135-QCOM\",\n\"Sony IMX072-mipi\",\n\"Sony IMX214\",\n\"Sony IMX219\",\n\"Sony IMX230\",\n\"Sony IMX298-mipi 16mp\",\n\"Sony IMX219-mipi 8mp\",\n\"Sony Xperia L\",\n\"STV680 VGA\",\n\"PtGrey GRAS-50S5C\",\n\"JaiPulnix BB-500CL\",\n\"JaiPulnix BB-500GE\",\n\"SVS SVS625CL\",\n\"YUNEEC CGO4\",\n\"Xiaomi MI3\",\n\"Xiaomi RedMi Note3 Pro\",\n   NULL\n};\n\nconst char** LibRaw::cameraList() { return static_camera_list;}\nint LibRaw::cameraCount() { return (sizeof(static_camera_list)/sizeof(static_camera_list[0]))-1; }\n\n\nconst char * LibRaw::strprogress(enum LibRaw_progress p)\n{\n  switch(p)\n    {\n    case LIBRAW_PROGRESS_START:\n      return \"Starting\";\n    case LIBRAW_PROGRESS_OPEN :\n      return \"Opening file\";\n    case LIBRAW_PROGRESS_IDENTIFY :\n      return \"Reading metadata\";\n    case LIBRAW_PROGRESS_SIZE_ADJUST:\n      return \"Adjusting size\";\n    case LIBRAW_PROGRESS_LOAD_RAW:\n      return \"Reading RAW data\";\n    case LIBRAW_PROGRESS_REMOVE_ZEROES:\n      return \"Clearing zero values\";\n    case LIBRAW_PROGRESS_BAD_PIXELS :\n      return \"Removing dead pixels\";\n    case LIBRAW_PROGRESS_DARK_FRAME:\n      return \"Subtracting dark frame data\";\n    case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:\n      return \"Interpolating Foveon sensor data\";\n    case LIBRAW_PROGRESS_SCALE_COLORS:\n      return \"Scaling colors\";\n    case LIBRAW_PROGRESS_PRE_INTERPOLATE:\n      return \"Pre-interpolating\";\n    case LIBRAW_PROGRESS_INTERPOLATE:\n      return \"Interpolating\";\n    case LIBRAW_PROGRESS_MIX_GREEN :\n      return \"Mixing green channels\";\n    case LIBRAW_PROGRESS_MEDIAN_FILTER   :\n      return \"Median filter\";\n    case LIBRAW_PROGRESS_HIGHLIGHTS:\n      return \"Highlight recovery\";\n    case LIBRAW_PROGRESS_FUJI_ROTATE :\n      return \"Rotating Fuji diagonal data\";\n    case LIBRAW_PROGRESS_FLIP :\n      return \"Flipping image\";\n    case LIBRAW_PROGRESS_APPLY_PROFILE:\n      return \"ICC conversion\";\n    case LIBRAW_PROGRESS_CONVERT_RGB:\n      return \"Converting to RGB\";\n    case LIBRAW_PROGRESS_STRETCH:\n      return \"Stretching image\";\n    case LIBRAW_PROGRESS_THUMB_LOAD:\n      return \"Loading thumbnail\";\n    default:\n      return \"Some strange things\";\n    }\n}\n\n#undef ID\n\n\n#include \"../internal/libraw_x3f.cpp\"\n\nvoid x3f_clear(void *p)\n{\n  x3f_delete((x3f_t*)p);\n}\n\nvoid utf2char(utf16_t *str, char *buffer, unsigned bufsz)\n{\n if(bufsz<1) return;\n buffer[bufsz-1] = 0;\n  char *b = buffer;\n\n  while (*str != 0x00 && --bufsz>0)\n  {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n}\n\nstatic void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)\n{\n\tregister char *cur, *last;\n\tconst char *cl = (const char *)l;\n\tconst char *cs = (const char *)s;\n\n\t/* we need something to compare */\n\tif (l_len == 0 || s_len == 0)\n\t\treturn NULL;\n\n\t/* \"s\" must be smaller or equal to \"l\" */\n\tif (l_len < s_len)\n\t\treturn NULL;\n\n\t/* special case where s_len == 1 */\n\tif (s_len == 1)\n\t\treturn (void*)memchr(l, (int)*cs, l_len);\n\n\t/* the last position where its possible to find \"s\" in \"l\" */\n\tlast = (char *)cl + l_len - s_len;\n\n\tfor (cur = (char *)cl; cur <= last; cur++)\n\t\tif (cur[0] == cs[0] && memcmp(cur, cs, s_len) == 0)\n\t\t\treturn cur;\n\treturn NULL;\n}\n\nvoid LibRaw::parse_x3f()\n{\n  x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);\n  if(!x3f)\n      return;\n  _x3f_data = x3f;\n\n  x3f_header_t *H = NULL;\n  x3f_directory_section_t *DS = NULL;\n\n  H = &x3f->header;\n  // Parse RAW size from RAW section\n  x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n  if(!DE) return;\n  imgdata.sizes.flip = H->rotation;\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  imgdata.sizes.raw_width = ID->columns;\n  imgdata.sizes.raw_height = ID->rows;\n  // Parse other params from property section\n  DE = x3f_get_prop(x3f);\n  if((x3f_load_data(x3f,DE) == X3F_OK))\n  {\n\t  // Parse property list\n\t  DEH = &DE->header;\n\t  x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n\t  if (PL->property_table.size != 0) {\n\t\t  int i;\n\t\t  x3f_property_t *P = PL->property_table.element;\n\t\t  for (i=0; i<PL->num_properties; i++) {\n\t\t\t  char name[100], value[100];\n\t\t\t  utf2char(P[i].name,name,sizeof(name));\n\t\t\t  utf2char(P[i].value,value,sizeof(value));\n\t\t\t  if (!strcmp (name, \"ISO\"))\n\t\t\t\t  imgdata.other.iso_speed = atoi(value);\n\t\t\t  if (!strcmp (name, \"CAMMANUF\"))\n\t\t\t\t  strcpy (imgdata.idata.make, value);\n\t\t\t  if (!strcmp (name, \"CAMMODEL\"))\n\t\t\t\t  strcpy (imgdata.idata.model, value);\n\t\t\t  if (!strcmp (name, \"CAMSERIAL\"))\n\t\t\t\t  strcpy (imgdata.shootinginfo.BodySerial, value);\n\t\t\t  if (!strcmp (name, \"WB_DESC\"))\n\t\t\t\t  strcpy (imgdata.color.model2, value);\n\t\t\t  if (!strcmp (name, \"TIME\"))\n\t\t\t\t  imgdata.other.timestamp = atoi(value);\n\t\t\t  if (!strcmp (name, \"SHUTTER\"))\n\t\t\t\t  imgdata.other.shutter = atof(value);\n\t\t\t  if (!strcmp (name, \"APERTURE\"))\n\t\t\t\t  imgdata.other.aperture = atof(value);\n\t\t\t  if (!strcmp (name, \"FLENGTH\"))\n\t\t\t\t  imgdata.other.focal_len = atof(value);\n\t\t\t\tif (!strcmp (name, \"FLEQ35MM\"))\n\t\t\t\t  imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);\n\t\t\t\tif (!strcmp (name, \"LENSARANGE\"))\n\t\t\t\t{\n\t\t\t\t  char *sp;\n\t\t\t\t  imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);\n\t\t\t\t  sp = strrchr (value, ' ');\n\t\t\t\t  if (sp)\n\t\t\t\t    {\n\t\t\t\t      imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);\n\t\t\t\t      if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)\n\t\t\t\t        my_swap (float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\tif (!strcmp (name, \"LENSFRANGE\"))\n\t\t\t\t{\n\t\t\t\t\tchar *sp;\n\t\t\t\t\timgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);\n\t\t\t\t\tsp = strrchr (value, ' ');\n\t\t\t\t\tif (sp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\timgdata.lens.makernotes.MaxFocal = atof(sp);\n\t\t\t\t\t\t\tif ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)\n\t\t\t\t\t\t\t\tmy_swap (float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!strcmp (name, \"LENSMODEL\"))\n\t\t\t\t{\n\t\t\t\t\tchar *sp;\n                                        imgdata.lens.makernotes.LensID = strtol (value, &sp, 16); // atoi(value);\n\t\t\t\t\tif (imgdata.lens.makernotes.LensID)\n\t\t\t\t\t imgdata.lens.makernotes.LensMount = Sigma_X3F;\n\t\t\t\t}\n\t\t  }\n\t\t  imgdata.idata.raw_count=1;\n\t\t  load_raw = &LibRaw::x3f_load_raw;\n\t\t  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;\n\t\t  imgdata.idata.is_foveon = 1;\n\t\t  libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff\n\t\t  imgdata.color.maximum=0x3fff; // To be reset by color table\n\t\t  libraw_internal_data.unpacker_data.order = 0x4949;\n\t  }\n  }\n  else\n  {\n\t  // No property list\n\t  if(imgdata.sizes.raw_width == 5888 ||imgdata.sizes.raw_width == 2944 \n\t\t  || imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 \t  \n\t\t  || imgdata.sizes.raw_width == 5504 ||imgdata.sizes.raw_width == 2752 \t  \n\t\t  ) // Quattro\n\t  {\n\t\t  imgdata.idata.raw_count=1;\n\t\t  load_raw = &LibRaw::x3f_load_raw;\n\t\t  imgdata.sizes.raw_pitch = imgdata.sizes.raw_width*6;\n\t\t  imgdata.idata.is_foveon = 1;\n\t\t  libraw_internal_data.internal_output_params.raw_color=1; // Force adobe coeff\n\t\t  libraw_internal_data.unpacker_data.order = 0x4949;\n\t\t  strcpy (imgdata.idata.make, \"SIGMA\");\n#if 1\n\t\t  // Try to find model number in first 2048 bytes;\n\t\t  int pos = libraw_internal_data.internal_data.input->tell();\n\t\t  libraw_internal_data.internal_data.input->seek(0,SEEK_SET);\n\t\t  unsigned char buf[2048];\n\t\t  libraw_internal_data.internal_data.input->read(buf,2048,1);\n\t\t  libraw_internal_data.internal_data.input->seek(pos,SEEK_SET);\n\t\t  unsigned char *fnd=(unsigned char*)lr_memmem(buf,2048,\"SIGMA dp\",8);\n\t\t  unsigned char *fndsd=(unsigned char*)lr_memmem(buf,2048,\"sd Quatt\",8);\n\t\t  if(fnd)\n\t\t  {\n\t\t\t  unsigned char *nm = fnd+8;\n\t\t\t  snprintf(imgdata.idata.model,64,\"dp%c Quattro\",*nm<='9' && *nm >='0' ? *nm: '2');\n\t\t  }\n\t\t  else if(fndsd)\n\t\t  {\n\t\t\t  snprintf(imgdata.idata.model,64,\"%s\",fndsd);\n\t\t  }\n\t\t  else\n#endif\n\t\t  if(imgdata.sizes.raw_width == 6656 ||imgdata.sizes.raw_width == 3328 )\n\t\t\tstrcpy (imgdata.idata.model, \"sd Quattro H\");\n\t\t  else\n\t\t\tstrcpy (imgdata.idata.model, \"dp2 Quattro\");\n\t  }\n\t  //else\n  }\n  // Try to get thumbnail data\n  LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;\n  if( (DE = x3f_get_thumb_jpeg(x3f)))\n    {\n      format = LIBRAW_THUMBNAIL_JPEG;\n    }\n  else if( (DE = x3f_get_thumb_plain(x3f)))\n    {\n      format = LIBRAW_THUMBNAIL_BITMAP;\n    }\n  if(DE)\n    {\n      x3f_directory_entry_header_t *DEH = &DE->header;\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n      imgdata.thumbnail.twidth = ID->columns;\n      imgdata.thumbnail.theight = ID->rows;\n      imgdata.thumbnail.tcolors = 3;\n      imgdata.thumbnail.tformat = format;\n      libraw_internal_data.internal_data.toffset = DE->input.offset;\n      write_thumb = &LibRaw::x3f_thumb_loader;\n    }\n}\n\nINT64 LibRaw::x3f_thumb_size()\n{\n\ttry {\n\t\tx3f_t *x3f = (x3f_t*)_x3f_data;\n\t\tif (!x3f) return -1; // No data pointer set\n\t\tx3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n\t\tif (!DE)\n\t\t\tDE = x3f_get_thumb_plain(x3f);\n\t\tif (!DE)\n\t\t\treturn -1;\n\t\tint64_t p = x3f_load_data_size(x3f, DE);\n\t\tif (p < 0 || p > 0xffffffff)\n\t\t\treturn -1;\n\t\treturn p;\n\t}\n\tcatch (...)\n\t{\n\t\treturn -1;\n\t}\n}\n\nvoid LibRaw::x3f_thumb_loader()\n{\n\ttry\n\t{\n\t\tx3f_t *x3f = (x3f_t*)_x3f_data;\n\t\tif (!x3f) return; // No data pointer set\n\t\tx3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n\t\tif (!DE)\n\t\t\tDE = x3f_get_thumb_plain(x3f);\n\t\tif (!DE)\n\t\t\treturn;\n\t\tif (X3F_OK != x3f_load_data(x3f, DE))\n\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n\t\tx3f_directory_entry_header_t *DEH = &DE->header;\n\t\tx3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\t\timgdata.thumbnail.twidth = ID->columns;\n\t\timgdata.thumbnail.theight = ID->rows;\n\t\timgdata.thumbnail.tcolors = 3;\n\t\tif (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_JPEG)\n\t\t{\n\t\t\timgdata.thumbnail.thumb = (char*)malloc(ID->data_size);\n\t\t\tmerror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n\t\t\tmemmove(imgdata.thumbnail.thumb, ID->data, ID->data_size);\n\t\t\timgdata.thumbnail.tlength = ID->data_size;\n\t\t}\n\t\telse if (imgdata.thumbnail.tformat == LIBRAW_THUMBNAIL_BITMAP)\n\t\t{\n\t\t\timgdata.thumbnail.tlength = ID->columns * ID->rows * 3;\n\t\t\timgdata.thumbnail.thumb = (char*)malloc(ID->columns * ID->rows * 3);\n\t\t\tmerror(imgdata.thumbnail.thumb, \"LibRaw::x3f_thumb_loader()\");\n\t\t\tchar *src0 = (char*)ID->data;\n\t\t\tfor (int row = 0; row < ID->rows; row++)\n\t\t\t{\n\t\t\t\tint offset = row * ID->row_stride;\n\t\t\t\tif (offset + ID->columns * 3 > ID->data_size)\n\t\t\t\t\tbreak;\n\t\t\t\tchar *dest = &imgdata.thumbnail.thumb[row*ID->columns * 3];\n\t\t\t\tchar *src = &src0[offset];\n\t\t\t\tmemmove(dest, src, ID->columns * 3);\n\t\t\t}\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t\t// do nothing\n\t}\n}\n\nstatic inline uint32_t _clampbits(int x, uint32_t n) {\n\tuint32_t _y_temp;\n\tif( (_y_temp=x>>n) )\n\t\tx = ~_y_temp >> (32-n);\n\treturn x;\n}\n\nvoid LibRaw::x3f_dpq_interpolate_rg()\n{\n\tint w = imgdata.sizes.raw_width/2;\n\tint h = imgdata.sizes.raw_height/2;\n\tunsigned short *image = (ushort*)imgdata.rawdata.color3_image;\n\n\tfor (int color = 0; color < 2;  color++)\n\t{\n\t\tfor (int y = 2; y < (h-2); y++)\n\t\t{\n\t\t\tuint16_t* row0 = &image[imgdata.sizes.raw_width*3*(y*2)+color]; // dst[1]\n\t\t\tuint16_t  row0_3 = row0[3];\n\t\t\tuint16_t* row1 = &image[imgdata.sizes.raw_width*3*(y*2+1)+color]; //dst1[1]\n\t\t\tuint16_t  row1_3 = row1[3];\n\t\t\tfor (int x = 2; x < (w-2); x++)\n\t\t\t{\n\t\t\t\trow1[0]=row1[3]=row0[3]=row0[0];\n\t\t\t\trow0 += 6;\n\t\t\t\trow1 += 6;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define _ABS(a) ((a)<0?-(a):(a))\n\n#undef CLIP\n#define CLIP(value,high) ((value)>(high)?(high):(value))\n\nvoid LibRaw::x3f_dpq_interpolate_af(int xstep, int ystep, int scale)\n{\n\tunsigned short *image = (ushort*)imgdata.rawdata.color3_image;\n\tunsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch/2; // in 16-bit words\n\t\t// Interpolate single pixel\n\tfor(int y = 0;  y < imgdata.rawdata.sizes.height+imgdata.rawdata.sizes.top_margin; y+=ystep)\n\t{\n\t\tif(y<imgdata.rawdata.sizes.top_margin) continue;\n\t\tif(y<scale) continue;\n\t\tif(y>imgdata.rawdata.sizes.raw_height-scale) break;\n\t\tuint16_t* row0 = &image[imgdata.sizes.raw_width*3*y]; // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n\t\tuint16_t* row_minus = &image[imgdata.sizes.raw_width*3*(y-scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n\t\tuint16_t* row_plus = &image[imgdata.sizes.raw_width*3*(y+scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435\n\t\tfor(int x = 0; x < imgdata.rawdata.sizes.width+imgdata.rawdata.sizes.left_margin; x+= xstep)\n\t\t\t{\n\t\t\t\tif(x<imgdata.rawdata.sizes.left_margin) continue;\n\t\t\t\tif(x<scale) continue;\n\t\t\t\tif(x>imgdata.rawdata.sizes.raw_width-scale) break;\n\t\t\t\tuint16_t* pixel0 = &row0[x*3];\n\t\t\t\tuint16_t* pixel_top = &row_minus[x*3];\n\t\t\t\tuint16_t* pixel_bottom = &row_plus[x*3];\n\t\t\t\tuint16_t* pixel_left = &row0[(x-scale)*3];\n\t\t\t\tuint16_t* pixel_right = &row0[(x+scale)*3];\n\t\t\t\tuint16_t* pixf = pixel_top;\n\t\t\t\tif(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_bottom[2]-pixel0[2]))\n\t\t\t\t\tpixf = pixel_bottom;\n\t\t\t\tif(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_left[2]-pixel0[2]))\n\t\t\t\t\tpixf = pixel_left;\n\t\t\t\tif(_ABS(pixf[2]-pixel0[2])>_ABS(pixel_right[2]-pixel0[2]))\n\t\t\t\t\tpixf = pixel_right;\n\t\t\t\tint blocal = pixel0[2],bnear = pixf[2];\n\t\t\t\tif(blocal < imgdata.color.black+16 || bnear < imgdata.color.black+16\t)\n\t\t\t\t{\n\t\t\t\t\tif(pixel0[0] < imgdata.color.black)\tpixel0[0] = imgdata.color.black;\n\t\t\t\t\tif(pixel0[1] < imgdata.color.black)\tpixel0[1] = imgdata.color.black;\n\t\t\t\t\tpixel0[0] = CLIP((pixel0[0] - imgdata.color.black)*4 + imgdata.color.black,16383);\n\t\t\t\t\tpixel0[1] = CLIP((pixel0[1] - imgdata.color.black)*4 + imgdata.color.black,16383);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfloat multip = float(bnear - imgdata.color.black)/float(blocal-imgdata.color.black);\n\t\t\t\t\tif(pixel0[0] < imgdata.color.black)\tpixel0[0] = imgdata.color.black;\n\t\t\t\t\tif(pixel0[1] < imgdata.color.black)\tpixel0[1] = imgdata.color.black;\n\t\t\t\t\tfloat pixf0 = pixf[0];\n\t\t\t\t\tif(pixf0 < imgdata.color.black) pixf0 = imgdata.color.black;\n\t\t\t\t\tfloat pixf1 = pixf[1];\n\t\t\t\t\tif(pixf1 < imgdata.color.black) pixf1 = imgdata.color.black;\n\n\t\t\t\t\tpixel0[0] = CLIP(((float(pixf0-imgdata.color.black)*multip + imgdata.color.black)+((pixel0[0]-imgdata.color.black)*3.75 + imgdata.color.black))/2,16383);\n\t\t\t\t\tpixel0[1] = CLIP(((float(pixf1-imgdata.color.black)*multip + imgdata.color.black)+((pixel0[1]-imgdata.color.black)*3.75 + imgdata.color.black))/2,16383);\n\t\t\t\t\t//pixel0[1] = float(pixf[1]-imgdata.color.black)*multip + imgdata.color.black;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\nvoid LibRaw::x3f_dpq_interpolate_af_sd(int xstart,int ystart, int xend, int yend, int xstep, int ystep, int scale)\n{\n\tunsigned short *image = (ushort*)imgdata.rawdata.color3_image;\n\tunsigned int rowpitch = imgdata.rawdata.sizes.raw_pitch/2; // in 16-bit words\n\t// Interpolate single pixel\n\tfor(int y = ystart;  y< yend && y < imgdata.rawdata.sizes.height+imgdata.rawdata.sizes.top_margin; y+=ystep)\n\t{\n\t\tuint16_t* row0 = &image[imgdata.sizes.raw_width*3*y]; // \u041d\u0430\u0448\u0430 \u0441\u0442\u0440\u043e\u043a\u0430\n\t\tuint16_t* row1 = &image[imgdata.sizes.raw_width*3*(y+1)]; // \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430\n\t\tuint16_t* row_minus = &image[imgdata.sizes.raw_width*3*(y-scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u0432\u044b\u0448\u0435\n\t\tuint16_t* row_plus = &image[imgdata.sizes.raw_width*3*(y+scale)]; // \u0421\u0442\u0440\u043e\u043a\u0430 \u043d\u0438\u0436\u0435 AF-point (scale=2 -> \u043d\u0438\u0436\u0435 row1\n\t\tuint16_t* row_minus1 = &image[imgdata.sizes.raw_width*3*(y-1)]; \n\t\tfor(int x = xstart; x< xend && x < imgdata.rawdata.sizes.width+imgdata.rawdata.sizes.left_margin; x+= xstep)\n\t\t{\n\t\t\tuint16_t* pixel00 = &row0[x*3]; // Current pixel\n\t\t\tfloat sumR = 0.f,sumG=0.f;\n\t\t\tfloat cnt = 0.f;\n\t\t\tfor(int xx = -scale; xx <= scale; xx+= scale)\n\t\t\t{\n\t\t\t\tsumR += row_minus[(x+xx)*3];\n\t\t\t\tsumR += row_plus[(x+xx)*3];\n\t\t\t\tsumG += row_minus[(x+xx)*3+1];\n\t\t\t\tsumG += row_plus[(x+xx)*3+1];\n\t\t\t\tcnt +=1.f;\n\t\t\t\tif(xx)\n\t\t\t\t{\n\t\t\t\t\tcnt +=1.f;\n\t\t\t\t\tsumR += row0[(x+xx)*3];\n\t\t\t\t\tsumG += row0[(x+xx)*3+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpixel00[0] = sumR/8.f;\n\t\t\tpixel00[1] = sumG/8.f;\n\n\t\t\tif(scale == 2)\n\t\t\t{\n\t\t\t\tuint16_t* pixel0B = &row0[x*3+3]; // right pixel\n\t\t\t\tuint16_t* pixel1B = &row1[x*3+3]; // right pixel\n\t\t\t\tfloat sumG0 = 0, sumG1 = 0.f;\n\t\t\t\tfloat cnt = 0.f;\n\t\t\t\tfor(int xx = -scale; xx <= scale; xx+= scale)\n\t\t\t\t{\n\t\t\t\t\tsumG0 += row_minus1[(x+xx)*3+2];\n\t\t\t\t\tsumG1 += row_plus[(x+xx)*3+2];\n\t\t\t\t\tcnt +=1.f;\n\t\t\t\t\tif(xx)\n\t\t\t\t\t{\n\t\t\t\t\t\tsumG0 += row0[(x+xx)*3+2];\n\t\t\t\t\t\tsumG1 += row1[(x+xx)*3+2];\n\t\t\t\t\t\tcnt +=1.f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpixel0B[2] = sumG0/cnt;\n\t\t\t\tpixel1B[2] = sumG1/cnt;\n\t\t\t}\n\n\t\t\t//\t\t\tuint16_t* pixel10 = &row1[x*3]; // Pixel below current\n//\t\t\tuint16_t* pixel_bottom = &row_plus[x*3];\n\t\t}\n\t}\n}\n\n\nvoid LibRaw::x3f_load_raw()\n{\n\t// already in try/catch \n  int raise_error=0;\n  x3f_t *x3f = (x3f_t*)_x3f_data;\n  if(!x3f) return; // No data pointer set\n  if(X3F_OK == x3f_load_data(x3f, x3f_get_raw(x3f)))\n    {\n      x3f_directory_entry_t *DE = x3f_get_raw(x3f);\n      x3f_directory_entry_header_t *DEH = &DE->header;\n      x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n\t  if(!ID)\n\t\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\t  x3f_quattro_t *Q = ID->quattro;\n      x3f_huffman_t *HUF = ID->huffman;\n      x3f_true_t *TRU = ID->tru;\n      uint16_t *data = NULL;\n      if(ID->rows != S.raw_height || ID->columns != S.raw_width)\n        {\n          raise_error = 1;\n          goto end;\n        }\n      if (HUF != NULL)\n        data = HUF->x3rgb16.data;\n      if (TRU != NULL)\n        data = TRU->x3rgb16.data;\n      if (data == NULL)\n        {\n          raise_error = 1;\n          goto end;\n        } \n\n\t  size_t datasize = S.raw_height*S.raw_width*3*sizeof(unsigned short);\n\t  S.raw_pitch = S.raw_width*3*sizeof(unsigned short);\n\t  if(!(imgdata.rawdata.raw_alloc = malloc(datasize)))\n\t\t  throw LIBRAW_EXCEPTION_ALLOC;\n\n      imgdata.rawdata.color3_image = (ushort (*)[3])imgdata.rawdata.raw_alloc;\n\t  if(HUF)\n\t\t  memmove(imgdata.rawdata.raw_alloc,data,datasize);\n\t  else if(TRU && (!Q || !Q->quattro_layout))\n\t\t  memmove(imgdata.rawdata.raw_alloc,data,datasize);\n\t  else if(TRU && Q)\n\t  {\n\t\t  // Move quattro data in place\n\t\t  // R/B plane\n\t\t  for(int prow = 0; prow < TRU->x3rgb16.rows && prow < S.raw_height/2; prow++)\n\t\t  {\n\t\t\t  ushort (*destrow)[3] = (unsigned short (*)[3]) &imgdata.rawdata.color3_image[prow*2*S.raw_pitch/3/sizeof(ushort)][0];\n\t\t\t  ushort (*srcrow)[3] = (unsigned short (*)[3]) &data[prow*TRU->x3rgb16.row_stride];\n\t\t\t  for(int pcol = 0; pcol < TRU->x3rgb16.columns && pcol < S.raw_width/2; pcol++)\n\t\t\t  {\n\t\t\t\t  destrow[pcol*2][0] = srcrow[pcol][0];\n\t\t\t\t  destrow[pcol*2][1] = srcrow[pcol][1];\n\t\t\t  }\n\t\t  }\n\t\t  for(int row = 0; row < Q->top16.rows && row < S.raw_height; row++)\n\t\t  {\n\t\t\t  ushort (*destrow)[3] = (unsigned short (*)[3]) &imgdata.rawdata.color3_image[row*S.raw_pitch/3/sizeof(ushort)][0];\n\t\t\t  ushort (*srcrow) = (unsigned short *) &Q->top16.data[row * Q->top16.columns];\n\t\t\t  for(int col = 0; col < Q->top16.columns && col < S.raw_width; col++)\n\t\t\t\t  destrow[col][2] = srcrow[col];\n\t\t  }\n\t  }\n\n#if 1\n\t  if(TRU && Q  && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF) \n\t\t  )\n\t  {\n\t\t  if(imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3672) // dpN Quattro normal\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af(32,8,2);\n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 5888 && imgdata.sizes.raw_height == 3776) // sd Quattro normal raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(216,464,imgdata.sizes.raw_width-1,3312,16,32,2);\n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 6656 && imgdata.sizes.raw_height == 4480) // sd Quattro H normal raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(232,592,imgdata.sizes.raw_width-1,3888,16,32,2); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 3328 && imgdata.sizes.raw_height == 2240) // sd Quattro H half size\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(116,296,imgdata.sizes.raw_width-1,2200,8,16,1); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 5504 && imgdata.sizes.raw_height == 3680) // sd Quattro H APS-C raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(8,192,imgdata.sizes.raw_width-1,3185,16,32,2); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 2752 && imgdata.sizes.raw_height == 1840) // sd Quattro H APS-C half size\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(4, 96,imgdata.sizes.raw_width-1,1800,8,16,1); \n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1836) // dpN Quattro small raw\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af(16,4,1);\n\t\t  }\n\t\t  else if(imgdata.sizes.raw_width == 2944 && imgdata.sizes.raw_height == 1888) // sd Quattro small\n\t\t  {\n\t\t\t  x3f_dpq_interpolate_af_sd(108,232,imgdata.sizes.raw_width-1,1656,8,16,1);\n\t\t  }\n\t  }\n#endif\n\t  if(TRU && Q && Q->quattro_layout  && (imgdata.params.raw_processing_options & LIBRAW_PROCESSING_DP2Q_INTERPOLATERG)  )\n\t\t\tx3f_dpq_interpolate_rg();\n\n  }\n  else\n    raise_error = 1;\nend:\n  if(raise_error)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n}\n\n"], "filenames": ["src/libraw_cxx.cpp"], "buggy_code_start_loc": [5487], "buggy_code_end_loc": [5560], "fixing_code_start_loc": [5487], "fixing_code_end_loc": [5562], "type": "CWE-787", "message": "An issue was discovered in LibRaw 0.18.9. There is a stack-based buffer overflow in the utf2char function in libraw_cxx.cpp.", "other": {"cve": {"id": "CVE-2018-10528", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-29T03:29:00.310", "lastModified": "2020-10-15T13:35:47.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LibRaw 0.18.9. There is a stack-based buffer overflow in the utf2char function in libraw_cxx.cpp."}, {"lang": "es", "value": "Se ha descubierto un problema en LibRaw 0.18.9. Existe un desbordamiento de b\u00fafer basado en pila en la funci\u00f3n utf2char de libraw_cxx.cpp."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.18.9:*:*:*:*:*:*:*", "matchCriteriaId": "7E0EC812-F04B-4671-B565-1B48A368C85F"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw/commit/efd8cfabb93fd0396266a7607069901657c082e3", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/issues/144", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3639-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/efd8cfabb93fd0396266a7607069901657c082e3"}}