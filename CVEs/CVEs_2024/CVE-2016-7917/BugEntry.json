{"buggy_code": ["/* Netfilter messages via netlink socket. Allows for user space\n * protocol helpers and general trouble making from userspace.\n *\n * (C) 2001 by Jay Schulist <jschlst@samba.org>,\n * (C) 2002-2005 by Harald Welte <laforge@gnumonks.org>\n * (C) 2005,2007 by Pablo Neira Ayuso <pablo@netfilter.org>\n *\n * Initial netfilter messages via netlink development funded and\n * generally made possible by Network Robots, Inc. (www.networkrobots.com)\n *\n * Further development of this code funded by Astaro AG (http://www.astaro.com)\n *\n * This software may be used and distributed according to the terms\n * of the GNU General Public License, incorporated herein by reference.\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <asm/uaccess.h>\n#include <net/sock.h>\n#include <linux/init.h>\n\n#include <net/netlink.h>\n#include <linux/netfilter/nfnetlink.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_NETFILTER);\n\n#define nfnl_dereference_protected(id) \\\n\trcu_dereference_protected(table[(id)].subsys, \\\n\t\t\t\t  lockdep_nfnl_is_held((id)))\n\nstatic char __initdata nfversion[] = \"0.30\";\n\nstatic struct {\n\tstruct mutex\t\t\t\tmutex;\n\tconst struct nfnetlink_subsystem __rcu\t*subsys;\n} table[NFNL_SUBSYS_COUNT];\n\nstatic const int nfnl_group2type[NFNLGRP_MAX+1] = {\n\t[NFNLGRP_CONNTRACK_NEW]\t\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_UPDATE]\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_DESTROY]\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_EXP_NEW]\t= NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_CONNTRACK_EXP_UPDATE]\t= NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_CONNTRACK_EXP_DESTROY] = NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_NFTABLES]\t\t= NFNL_SUBSYS_NFTABLES,\n\t[NFNLGRP_ACCT_QUOTA]\t\t= NFNL_SUBSYS_ACCT,\n\t[NFNLGRP_NFTRACE]\t\t= NFNL_SUBSYS_NFTABLES,\n};\n\nvoid nfnl_lock(__u8 subsys_id)\n{\n\tmutex_lock(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(nfnl_lock);\n\nvoid nfnl_unlock(__u8 subsys_id)\n{\n\tmutex_unlock(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(nfnl_unlock);\n\n#ifdef CONFIG_PROVE_LOCKING\nbool lockdep_nfnl_is_held(u8 subsys_id)\n{\n\treturn lockdep_is_held(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(lockdep_nfnl_is_held);\n#endif\n\nint nfnetlink_subsys_register(const struct nfnetlink_subsystem *n)\n{\n\tnfnl_lock(n->subsys_id);\n\tif (table[n->subsys_id].subsys) {\n\t\tnfnl_unlock(n->subsys_id);\n\t\treturn -EBUSY;\n\t}\n\trcu_assign_pointer(table[n->subsys_id].subsys, n);\n\tnfnl_unlock(n->subsys_id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfnetlink_subsys_register);\n\nint nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n)\n{\n\tnfnl_lock(n->subsys_id);\n\ttable[n->subsys_id].subsys = NULL;\n\tnfnl_unlock(n->subsys_id);\n\tsynchronize_rcu();\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfnetlink_subsys_unregister);\n\nstatic inline const struct nfnetlink_subsystem *nfnetlink_get_subsys(u_int16_t type)\n{\n\tu_int8_t subsys_id = NFNL_SUBSYS_ID(type);\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn NULL;\n\n\treturn rcu_dereference(table[subsys_id].subsys);\n}\n\nstatic inline const struct nfnl_callback *\nnfnetlink_find_client(u_int16_t type, const struct nfnetlink_subsystem *ss)\n{\n\tu_int8_t cb_id = NFNL_MSG_TYPE(type);\n\n\tif (cb_id >= ss->cb_count)\n\t\treturn NULL;\n\n\treturn &ss->cb[cb_id];\n}\n\nint nfnetlink_has_listeners(struct net *net, unsigned int group)\n{\n\treturn netlink_has_listeners(net->nfnl, group);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_has_listeners);\n\nstruct sk_buff *nfnetlink_alloc_skb(struct net *net, unsigned int size,\n\t\t\t\t    u32 dst_portid, gfp_t gfp_mask)\n{\n\treturn netlink_alloc_skb(net->nfnl, size, dst_portid, gfp_mask);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_alloc_skb);\n\nint nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,\n\t\t   unsigned int group, int echo, gfp_t flags)\n{\n\treturn nlmsg_notify(net->nfnl, skb, portid, group, echo, flags);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_send);\n\nint nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error)\n{\n\treturn netlink_set_err(net->nfnl, portid, group, error);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_set_err);\n\nint nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid,\n\t\t      int flags)\n{\n\treturn netlink_unicast(net->nfnl, skb, portid, flags);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_unicast);\n\n/* Process one complete nfnetlink message. */\nstatic int nfnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnl_callback *nc;\n\tconst struct nfnetlink_subsystem *ss;\n\tint type, err;\n\n\t/* All the messages must at least contain nfgenmsg */\n\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg))\n\t\treturn 0;\n\n\ttype = nlh->nlmsg_type;\nreplay:\n\trcu_read_lock();\n\tss = nfnetlink_get_subsys(type);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\trcu_read_unlock();\n\t\trequest_module(\"nfnetlink-subsys-%d\", NFNL_SUBSYS_ID(type));\n\t\trcu_read_lock();\n\t\tss = nfnetlink_get_subsys(type);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnc = nfnetlink_find_client(type, ss);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t{\n\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\tint attrlen = nlh->nlmsg_len - min_len;\n\t\t__u8 subsys_id = NFNL_SUBSYS_ID(type);\n\n\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\tif (err < 0) {\n\t\t\trcu_read_unlock();\n\t\t\treturn err;\n\t\t}\n\n\t\tif (nc->call_rcu) {\n\t\t\terr = nc->call_rcu(net, net->nfnl, skb, nlh,\n\t\t\t\t\t   (const struct nlattr **)cda);\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\trcu_read_unlock();\n\t\t\tnfnl_lock(subsys_id);\n\t\t\tif (nfnl_dereference_protected(subsys_id) != ss ||\n\t\t\t    nfnetlink_find_client(type, ss) != nc)\n\t\t\t\terr = -EAGAIN;\n\t\t\telse if (nc->call)\n\t\t\t\terr = nc->call(net, net->nfnl, skb, nlh,\n\t\t\t\t\t       (const struct nlattr **)cda);\n\t\t\telse\n\t\t\t\terr = -EINVAL;\n\t\t\tnfnl_unlock(subsys_id);\n\t\t}\n\t\tif (err == -EAGAIN)\n\t\t\tgoto replay;\n\t\treturn err;\n\t}\n}\n\nstruct nfnl_err {\n\tstruct list_head\thead;\n\tstruct nlmsghdr\t\t*nlh;\n\tint\t\t\terr;\n};\n\nstatic int nfnl_err_add(struct list_head *list, struct nlmsghdr *nlh, int err)\n{\n\tstruct nfnl_err *nfnl_err;\n\n\tnfnl_err = kmalloc(sizeof(struct nfnl_err), GFP_KERNEL);\n\tif (nfnl_err == NULL)\n\t\treturn -ENOMEM;\n\n\tnfnl_err->nlh = nlh;\n\tnfnl_err->err = err;\n\tlist_add_tail(&nfnl_err->head, list);\n\n\treturn 0;\n}\n\nstatic void nfnl_err_del(struct nfnl_err *nfnl_err)\n{\n\tlist_del(&nfnl_err->head);\n\tkfree(nfnl_err);\n}\n\nstatic void nfnl_err_reset(struct list_head *err_list)\n{\n\tstruct nfnl_err *nfnl_err, *next;\n\n\tlist_for_each_entry_safe(nfnl_err, next, err_list, head)\n\t\tnfnl_err_del(nfnl_err);\n}\n\nstatic void nfnl_err_deliver(struct list_head *err_list, struct sk_buff *skb)\n{\n\tstruct nfnl_err *nfnl_err, *next;\n\n\tlist_for_each_entry_safe(nfnl_err, next, err_list, head) {\n\t\tnetlink_ack(skb, nfnl_err->nlh, nfnl_err->err);\n\t\tnfnl_err_del(nfnl_err);\n\t}\n}\n\nenum {\n\tNFNL_BATCH_FAILURE\t= (1 << 0),\n\tNFNL_BATCH_DONE\t\t= (1 << 1),\n\tNFNL_BATCH_REPLAY\t= (1 << 2),\n};\n\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n\t\t    skb->len < nlh->nlmsg_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}\n\nstatic void nfnetlink_rcv(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tu_int16_t res_id;\n\tint msglen;\n\n\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t    skb->len < nlh->nlmsg_len)\n\t\treturn;\n\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN)) {\n\t\tnetlink_ack(skb, nlh, -EPERM);\n\t\treturn;\n\t}\n\n\tif (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN) {\n\t\tstruct nfgenmsg *nfgenmsg;\n\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < NLMSG_HDRLEN + sizeof(struct nfgenmsg))\n\t\t\treturn;\n\n\t\tnfgenmsg = nlmsg_data(nlh);\n\t\tskb_pull(skb, msglen);\n\t\t/* Work around old nft using host byte order */\n\t\tif (nfgenmsg->res_id == NFNL_SUBSYS_NFTABLES)\n\t\t\tres_id = NFNL_SUBSYS_NFTABLES;\n\t\telse\n\t\t\tres_id = ntohs(nfgenmsg->res_id);\n\t\tnfnetlink_rcv_batch(skb, nlh, res_id);\n\t} else {\n\t\tnetlink_rcv_skb(skb, &nfnetlink_rcv_msg);\n\t}\n}\n\n#ifdef CONFIG_MODULES\nstatic int nfnetlink_bind(struct net *net, int group)\n{\n\tconst struct nfnetlink_subsystem *ss;\n\tint type;\n\n\tif (group <= NFNLGRP_NONE || group > NFNLGRP_MAX)\n\t\treturn 0;\n\n\ttype = nfnl_group2type[group];\n\n\trcu_read_lock();\n\tss = nfnetlink_get_subsys(type << 8);\n\trcu_read_unlock();\n\tif (!ss)\n\t\trequest_module(\"nfnetlink-subsys-%d\", type);\n\treturn 0;\n}\n#endif\n\nstatic int __net_init nfnetlink_net_init(struct net *net)\n{\n\tstruct sock *nfnl;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= NFNLGRP_MAX,\n\t\t.input\t= nfnetlink_rcv,\n#ifdef CONFIG_MODULES\n\t\t.bind\t= nfnetlink_bind,\n#endif\n\t};\n\n\tnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\n\tif (!nfnl)\n\t\treturn -ENOMEM;\n\tnet->nfnl_stash = nfnl;\n\trcu_assign_pointer(net->nfnl, nfnl);\n\treturn 0;\n}\n\nstatic void __net_exit nfnetlink_net_exit_batch(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->nfnl, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->nfnl_stash);\n}\n\nstatic struct pernet_operations nfnetlink_net_ops = {\n\t.init\t\t= nfnetlink_net_init,\n\t.exit_batch\t= nfnetlink_net_exit_batch,\n};\n\nstatic int __init nfnetlink_init(void)\n{\n\tint i;\n\n\tfor (i = NFNLGRP_NONE + 1; i <= NFNLGRP_MAX; i++)\n\t\tBUG_ON(nfnl_group2type[i] == NFNL_SUBSYS_NONE);\n\n\tfor (i=0; i<NFNL_SUBSYS_COUNT; i++)\n\t\tmutex_init(&table[i].mutex);\n\n\tpr_info(\"Netfilter messages via NETLINK v%s.\\n\", nfversion);\n\treturn register_pernet_subsys(&nfnetlink_net_ops);\n}\n\nstatic void __exit nfnetlink_exit(void)\n{\n\tpr_info(\"Removing netfilter NETLINK layer.\\n\");\n\tunregister_pernet_subsys(&nfnetlink_net_ops);\n}\nmodule_init(nfnetlink_init);\nmodule_exit(nfnetlink_exit);\n"], "fixing_code": ["/* Netfilter messages via netlink socket. Allows for user space\n * protocol helpers and general trouble making from userspace.\n *\n * (C) 2001 by Jay Schulist <jschlst@samba.org>,\n * (C) 2002-2005 by Harald Welte <laforge@gnumonks.org>\n * (C) 2005,2007 by Pablo Neira Ayuso <pablo@netfilter.org>\n *\n * Initial netfilter messages via netlink development funded and\n * generally made possible by Network Robots, Inc. (www.networkrobots.com)\n *\n * Further development of this code funded by Astaro AG (http://www.astaro.com)\n *\n * This software may be used and distributed according to the terms\n * of the GNU General Public License, incorporated herein by reference.\n */\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <asm/uaccess.h>\n#include <net/sock.h>\n#include <linux/init.h>\n\n#include <net/netlink.h>\n#include <linux/netfilter/nfnetlink.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_NETFILTER);\n\n#define nfnl_dereference_protected(id) \\\n\trcu_dereference_protected(table[(id)].subsys, \\\n\t\t\t\t  lockdep_nfnl_is_held((id)))\n\nstatic char __initdata nfversion[] = \"0.30\";\n\nstatic struct {\n\tstruct mutex\t\t\t\tmutex;\n\tconst struct nfnetlink_subsystem __rcu\t*subsys;\n} table[NFNL_SUBSYS_COUNT];\n\nstatic const int nfnl_group2type[NFNLGRP_MAX+1] = {\n\t[NFNLGRP_CONNTRACK_NEW]\t\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_UPDATE]\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_DESTROY]\t= NFNL_SUBSYS_CTNETLINK,\n\t[NFNLGRP_CONNTRACK_EXP_NEW]\t= NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_CONNTRACK_EXP_UPDATE]\t= NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_CONNTRACK_EXP_DESTROY] = NFNL_SUBSYS_CTNETLINK_EXP,\n\t[NFNLGRP_NFTABLES]\t\t= NFNL_SUBSYS_NFTABLES,\n\t[NFNLGRP_ACCT_QUOTA]\t\t= NFNL_SUBSYS_ACCT,\n\t[NFNLGRP_NFTRACE]\t\t= NFNL_SUBSYS_NFTABLES,\n};\n\nvoid nfnl_lock(__u8 subsys_id)\n{\n\tmutex_lock(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(nfnl_lock);\n\nvoid nfnl_unlock(__u8 subsys_id)\n{\n\tmutex_unlock(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(nfnl_unlock);\n\n#ifdef CONFIG_PROVE_LOCKING\nbool lockdep_nfnl_is_held(u8 subsys_id)\n{\n\treturn lockdep_is_held(&table[subsys_id].mutex);\n}\nEXPORT_SYMBOL_GPL(lockdep_nfnl_is_held);\n#endif\n\nint nfnetlink_subsys_register(const struct nfnetlink_subsystem *n)\n{\n\tnfnl_lock(n->subsys_id);\n\tif (table[n->subsys_id].subsys) {\n\t\tnfnl_unlock(n->subsys_id);\n\t\treturn -EBUSY;\n\t}\n\trcu_assign_pointer(table[n->subsys_id].subsys, n);\n\tnfnl_unlock(n->subsys_id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfnetlink_subsys_register);\n\nint nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n)\n{\n\tnfnl_lock(n->subsys_id);\n\ttable[n->subsys_id].subsys = NULL;\n\tnfnl_unlock(n->subsys_id);\n\tsynchronize_rcu();\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfnetlink_subsys_unregister);\n\nstatic inline const struct nfnetlink_subsystem *nfnetlink_get_subsys(u_int16_t type)\n{\n\tu_int8_t subsys_id = NFNL_SUBSYS_ID(type);\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn NULL;\n\n\treturn rcu_dereference(table[subsys_id].subsys);\n}\n\nstatic inline const struct nfnl_callback *\nnfnetlink_find_client(u_int16_t type, const struct nfnetlink_subsystem *ss)\n{\n\tu_int8_t cb_id = NFNL_MSG_TYPE(type);\n\n\tif (cb_id >= ss->cb_count)\n\t\treturn NULL;\n\n\treturn &ss->cb[cb_id];\n}\n\nint nfnetlink_has_listeners(struct net *net, unsigned int group)\n{\n\treturn netlink_has_listeners(net->nfnl, group);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_has_listeners);\n\nstruct sk_buff *nfnetlink_alloc_skb(struct net *net, unsigned int size,\n\t\t\t\t    u32 dst_portid, gfp_t gfp_mask)\n{\n\treturn netlink_alloc_skb(net->nfnl, size, dst_portid, gfp_mask);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_alloc_skb);\n\nint nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,\n\t\t   unsigned int group, int echo, gfp_t flags)\n{\n\treturn nlmsg_notify(net->nfnl, skb, portid, group, echo, flags);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_send);\n\nint nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error)\n{\n\treturn netlink_set_err(net->nfnl, portid, group, error);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_set_err);\n\nint nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid,\n\t\t      int flags)\n{\n\treturn netlink_unicast(net->nfnl, skb, portid, flags);\n}\nEXPORT_SYMBOL_GPL(nfnetlink_unicast);\n\n/* Process one complete nfnetlink message. */\nstatic int nfnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnl_callback *nc;\n\tconst struct nfnetlink_subsystem *ss;\n\tint type, err;\n\n\t/* All the messages must at least contain nfgenmsg */\n\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg))\n\t\treturn 0;\n\n\ttype = nlh->nlmsg_type;\nreplay:\n\trcu_read_lock();\n\tss = nfnetlink_get_subsys(type);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\trcu_read_unlock();\n\t\trequest_module(\"nfnetlink-subsys-%d\", NFNL_SUBSYS_ID(type));\n\t\trcu_read_lock();\n\t\tss = nfnetlink_get_subsys(type);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\trcu_read_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnc = nfnetlink_find_client(type, ss);\n\tif (!nc) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t{\n\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\tint attrlen = nlh->nlmsg_len - min_len;\n\t\t__u8 subsys_id = NFNL_SUBSYS_ID(type);\n\n\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\tif (err < 0) {\n\t\t\trcu_read_unlock();\n\t\t\treturn err;\n\t\t}\n\n\t\tif (nc->call_rcu) {\n\t\t\terr = nc->call_rcu(net, net->nfnl, skb, nlh,\n\t\t\t\t\t   (const struct nlattr **)cda);\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\trcu_read_unlock();\n\t\t\tnfnl_lock(subsys_id);\n\t\t\tif (nfnl_dereference_protected(subsys_id) != ss ||\n\t\t\t    nfnetlink_find_client(type, ss) != nc)\n\t\t\t\terr = -EAGAIN;\n\t\t\telse if (nc->call)\n\t\t\t\terr = nc->call(net, net->nfnl, skb, nlh,\n\t\t\t\t\t       (const struct nlattr **)cda);\n\t\t\telse\n\t\t\t\terr = -EINVAL;\n\t\t\tnfnl_unlock(subsys_id);\n\t\t}\n\t\tif (err == -EAGAIN)\n\t\t\tgoto replay;\n\t\treturn err;\n\t}\n}\n\nstruct nfnl_err {\n\tstruct list_head\thead;\n\tstruct nlmsghdr\t\t*nlh;\n\tint\t\t\terr;\n};\n\nstatic int nfnl_err_add(struct list_head *list, struct nlmsghdr *nlh, int err)\n{\n\tstruct nfnl_err *nfnl_err;\n\n\tnfnl_err = kmalloc(sizeof(struct nfnl_err), GFP_KERNEL);\n\tif (nfnl_err == NULL)\n\t\treturn -ENOMEM;\n\n\tnfnl_err->nlh = nlh;\n\tnfnl_err->err = err;\n\tlist_add_tail(&nfnl_err->head, list);\n\n\treturn 0;\n}\n\nstatic void nfnl_err_del(struct nfnl_err *nfnl_err)\n{\n\tlist_del(&nfnl_err->head);\n\tkfree(nfnl_err);\n}\n\nstatic void nfnl_err_reset(struct list_head *err_list)\n{\n\tstruct nfnl_err *nfnl_err, *next;\n\n\tlist_for_each_entry_safe(nfnl_err, next, err_list, head)\n\t\tnfnl_err_del(nfnl_err);\n}\n\nstatic void nfnl_err_deliver(struct list_head *err_list, struct sk_buff *skb)\n{\n\tstruct nfnl_err *nfnl_err, *next;\n\n\tlist_for_each_entry_safe(nfnl_err, next, err_list, head) {\n\t\tnetlink_ack(skb, nfnl_err->nlh, nfnl_err->err);\n\t\tnfnl_err_del(nfnl_err);\n\t}\n}\n\nenum {\n\tNFNL_BATCH_FAILURE\t= (1 << 0),\n\tNFNL_BATCH_DONE\t\t= (1 << 1),\n\tNFNL_BATCH_REPLAY\t= (1 << 2),\n};\n\nstatic void nfnetlink_rcv_batch(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\tu_int16_t subsys_id)\n{\n\tstruct sk_buff *oskb = skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nfnetlink_subsystem *ss;\n\tconst struct nfnl_callback *nc;\n\tstatic LIST_HEAD(err_list);\n\tu32 status;\n\tint err;\n\n\tif (subsys_id >= NFNL_SUBSYS_COUNT)\n\t\treturn netlink_ack(skb, nlh, -EINVAL);\nreplay:\n\tstatus = 0;\n\n\tskb = netlink_skb_clone(oskb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn netlink_ack(oskb, nlh, -ENOMEM);\n\n\tnfnl_lock(subsys_id);\n\tss = nfnl_dereference_protected(subsys_id);\n\tif (!ss) {\n#ifdef CONFIG_MODULES\n\t\tnfnl_unlock(subsys_id);\n\t\trequest_module(\"nfnetlink-subsys-%d\", subsys_id);\n\t\tnfnl_lock(subsys_id);\n\t\tss = nfnl_dereference_protected(subsys_id);\n\t\tif (!ss)\n#endif\n\t\t{\n\t\t\tnfnl_unlock(subsys_id);\n\t\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\t\treturn kfree_skb(skb);\n\t\t}\n\t}\n\n\tif (!ss->commit || !ss->abort) {\n\t\tnfnl_unlock(subsys_id);\n\t\tnetlink_ack(oskb, nlh, -EOPNOTSUPP);\n\t\treturn kfree_skb(skb);\n\t}\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen, type;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < nlh->nlmsg_len ||\n\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* Only requests are handled by the kernel */\n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\ttype = nlh->nlmsg_type;\n\t\tif (type == NFNL_MSG_BATCH_BEGIN) {\n\t\t\t/* Malformed: Batch begin twice */\n\t\t\tnfnl_err_reset(&err_list);\n\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\tgoto done;\n\t\t} else if (type == NFNL_MSG_BATCH_END) {\n\t\t\tstatus |= NFNL_BATCH_DONE;\n\t\t\tgoto done;\n\t\t} else if (type < NLMSG_MIN_TYPE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* We only accept a batch with messages for the same\n\t\t * subsystem.\n\t\t */\n\t\tif (NFNL_SUBSYS_ID(type) != subsys_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\tnc = nfnetlink_find_client(type, ss);\n\t\tif (!nc) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ack;\n\t\t}\n\n\t\t{\n\t\t\tint min_len = nlmsg_total_size(sizeof(struct nfgenmsg));\n\t\t\tu_int8_t cb_id = NFNL_MSG_TYPE(nlh->nlmsg_type);\n\t\t\tstruct nlattr *cda[ss->cb[cb_id].attr_count + 1];\n\t\t\tstruct nlattr *attr = (void *)nlh + min_len;\n\t\t\tint attrlen = nlh->nlmsg_len - min_len;\n\n\t\t\terr = nla_parse(cda, ss->cb[cb_id].attr_count,\n\t\t\t\t\tattr, attrlen, ss->cb[cb_id].policy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto ack;\n\n\t\t\tif (nc->call_batch) {\n\t\t\t\terr = nc->call_batch(net, net->nfnl, skb, nlh,\n\t\t\t\t\t\t     (const struct nlattr **)cda);\n\t\t\t}\n\n\t\t\t/* The lock was released to autoload some module, we\n\t\t\t * have to abort and start from scratch using the\n\t\t\t * original skb.\n\t\t\t */\n\t\t\tif (err == -EAGAIN) {\n\t\t\t\tstatus |= NFNL_BATCH_REPLAY;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err) {\n\t\t\t/* Errors are delivered once the full batch has been\n\t\t\t * processed, this avoids that the same error is\n\t\t\t * reported several times when replaying the batch.\n\t\t\t */\n\t\t\tif (nfnl_err_add(&err_list, nlh, err) < 0) {\n\t\t\t\t/* We failed to enqueue an error, reset the\n\t\t\t\t * list of errors and send OOM to userspace\n\t\t\t\t * pointing to the batch header.\n\t\t\t\t */\n\t\t\t\tnfnl_err_reset(&err_list);\n\t\t\t\tnetlink_ack(oskb, nlmsg_hdr(oskb), -ENOMEM);\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\t/* We don't stop processing the batch on errors, thus,\n\t\t\t * userspace gets all the errors that the batch\n\t\t\t * triggers.\n\t\t\t */\n\t\t\tif (err)\n\t\t\t\tstatus |= NFNL_BATCH_FAILURE;\n\t\t}\nnext:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\ndone:\n\tif (status & NFNL_BATCH_REPLAY) {\n\t\tss->abort(net, oskb);\n\t\tnfnl_err_reset(&err_list);\n\t\tnfnl_unlock(subsys_id);\n\t\tkfree_skb(skb);\n\t\tgoto replay;\n\t} else if (status == NFNL_BATCH_DONE) {\n\t\tss->commit(net, oskb);\n\t} else {\n\t\tss->abort(net, oskb);\n\t}\n\n\tnfnl_err_deliver(&err_list, oskb);\n\tnfnl_unlock(subsys_id);\n\tkfree_skb(skb);\n}\n\nstatic void nfnetlink_rcv(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tu_int16_t res_id;\n\tint msglen;\n\n\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t    skb->len < nlh->nlmsg_len)\n\t\treturn;\n\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN)) {\n\t\tnetlink_ack(skb, nlh, -EPERM);\n\t\treturn;\n\t}\n\n\tif (nlh->nlmsg_type == NFNL_MSG_BATCH_BEGIN) {\n\t\tstruct nfgenmsg *nfgenmsg;\n\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n\t\t    skb->len < NLMSG_HDRLEN + sizeof(struct nfgenmsg))\n\t\t\treturn;\n\n\t\tnfgenmsg = nlmsg_data(nlh);\n\t\tskb_pull(skb, msglen);\n\t\t/* Work around old nft using host byte order */\n\t\tif (nfgenmsg->res_id == NFNL_SUBSYS_NFTABLES)\n\t\t\tres_id = NFNL_SUBSYS_NFTABLES;\n\t\telse\n\t\t\tres_id = ntohs(nfgenmsg->res_id);\n\t\tnfnetlink_rcv_batch(skb, nlh, res_id);\n\t} else {\n\t\tnetlink_rcv_skb(skb, &nfnetlink_rcv_msg);\n\t}\n}\n\n#ifdef CONFIG_MODULES\nstatic int nfnetlink_bind(struct net *net, int group)\n{\n\tconst struct nfnetlink_subsystem *ss;\n\tint type;\n\n\tif (group <= NFNLGRP_NONE || group > NFNLGRP_MAX)\n\t\treturn 0;\n\n\ttype = nfnl_group2type[group];\n\n\trcu_read_lock();\n\tss = nfnetlink_get_subsys(type << 8);\n\trcu_read_unlock();\n\tif (!ss)\n\t\trequest_module(\"nfnetlink-subsys-%d\", type);\n\treturn 0;\n}\n#endif\n\nstatic int __net_init nfnetlink_net_init(struct net *net)\n{\n\tstruct sock *nfnl;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= NFNLGRP_MAX,\n\t\t.input\t= nfnetlink_rcv,\n#ifdef CONFIG_MODULES\n\t\t.bind\t= nfnetlink_bind,\n#endif\n\t};\n\n\tnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\n\tif (!nfnl)\n\t\treturn -ENOMEM;\n\tnet->nfnl_stash = nfnl;\n\trcu_assign_pointer(net->nfnl, nfnl);\n\treturn 0;\n}\n\nstatic void __net_exit nfnetlink_net_exit_batch(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->nfnl, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->nfnl_stash);\n}\n\nstatic struct pernet_operations nfnetlink_net_ops = {\n\t.init\t\t= nfnetlink_net_init,\n\t.exit_batch\t= nfnetlink_net_exit_batch,\n};\n\nstatic int __init nfnetlink_init(void)\n{\n\tint i;\n\n\tfor (i = NFNLGRP_NONE + 1; i <= NFNLGRP_MAX; i++)\n\t\tBUG_ON(nfnl_group2type[i] == NFNL_SUBSYS_NONE);\n\n\tfor (i=0; i<NFNL_SUBSYS_COUNT; i++)\n\t\tmutex_init(&table[i].mutex);\n\n\tpr_info(\"Netfilter messages via NETLINK v%s.\\n\", nfversion);\n\treturn register_pernet_subsys(&nfnetlink_net_ops);\n}\n\nstatic void __exit nfnetlink_exit(void)\n{\n\tpr_info(\"Removing netfilter NETLINK layer.\\n\");\n\tunregister_pernet_subsys(&nfnetlink_net_ops);\n}\nmodule_init(nfnetlink_init);\nmodule_exit(nfnetlink_exit);\n"], "filenames": ["net/netfilter/nfnetlink.c"], "buggy_code_start_loc": [331], "buggy_code_end_loc": [335], "fixing_code_start_loc": [331], "fixing_code_end_loc": [337], "type": "CWE-125", "message": "The nfnetlink_rcv_batch function in net/netfilter/nfnetlink.c in the Linux kernel before 4.5 does not check whether a batch message's length field is large enough, which allows local users to obtain sensitive information from kernel memory or cause a denial of service (infinite loop or out-of-bounds read) by leveraging the CAP_NET_ADMIN capability.", "other": {"cve": {"id": "CVE-2016-7917", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:11.970", "lastModified": "2016-12-02T23:13:07.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The nfnetlink_rcv_batch function in net/netfilter/nfnetlink.c in the Linux kernel before 4.5 does not check whether a batch message's length field is large enough, which allows local users to obtain sensitive information from kernel memory or cause a denial of service (infinite loop or out-of-bounds read) by leveraging the CAP_NET_ADMIN capability."}, {"lang": "es", "value": "La funci\u00f3n nfnetlink_rcv_batch en net / netfilter / nfnetlink.c en el kernel de Linux en versiones anteriores a 4.5 no comprueba si el campo de longitud de un mensaje por lotes es lo suficientemente grande, lo que permite a los usuarios locales obtener informaci\u00f3n sensible de la memoria del kernel o provocar una denegaci\u00f3n de servicio (bucle infinito o lectura fuera de rango) aprovechando la capacidad de CAP_NET_ADMIN."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4.32", "matchCriteriaId": "268BB38E-3466-45EB-868F-B2262EB71CA7"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c58d6c93680f28ac58984af61d0a7ebf4319c241", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94147", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/c58d6c93680f28ac58984af61d0a7ebf4319c241", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c58d6c93680f28ac58984af61d0a7ebf4319c241"}}