{"buggy_code": ["#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include \"jv.h\"\n#include \"jv_dtoa.h\"\n#include \"jv_unicode.h\"\n#include \"jv_alloc.h\"\n#include \"jv_dtoa.h\"\n\ntypedef const char* presult;\n\n#define TRY(x) do {presult msg__ = (x); if (msg__) return msg__; } while(0)\n#ifdef __GNUC__\n#define pfunc __attribute__((warn_unused_result)) presult\n#else\n#define pfunc presult\n#endif\n\nenum last_seen {\n  JV_LAST_NONE = 0,\n  JV_LAST_OPEN_ARRAY = '[',\n  JV_LAST_OPEN_OBJECT = '{',\n  JV_LAST_COLON = ':',\n  JV_LAST_COMMA = ',',\n  JV_LAST_VALUE = 'V',\n};\n\nstruct jv_parser {\n  const char* curr_buf;\n  int curr_buf_length;\n  int curr_buf_pos;\n  int curr_buf_is_partial;\n  int eof;\n  unsigned bom_strip_position;\n\n  int flags;\n\n  jv* stack;                   // parser\n  int stackpos;                // parser\n  int stacklen;                // both (optimization; it's really pathlen for streaming)\n  jv path;                     // streamer\n  enum last_seen last_seen;    // streamer\n  jv output;                   // streamer\n  jv next;                     // both\n\n  char* tokenbuf;\n  int tokenpos;\n  int tokenlen;\n\n  int line, column;\n\n  struct dtoa_context dtoa;\n\n  enum {\n    JV_PARSER_NORMAL,\n    JV_PARSER_STRING,\n    JV_PARSER_STRING_ESCAPE,\n    JV_PARSER_WAITING_FOR_RS // parse error, waiting for RS\n  } st;\n  unsigned int last_ch_was_ws:1;\n};\n\n\nstatic void parser_init(struct jv_parser* p, int flags) {\n  p->flags = flags;\n  if ((p->flags & JV_PARSE_STREAMING)) {\n    p->path = jv_array();\n  } else {\n    p->path = jv_invalid();\n    p->flags &= ~(JV_PARSE_STREAM_ERRORS);\n  }\n  p->stack = 0;\n  p->stacklen = p->stackpos = 0;\n  p->last_seen = JV_LAST_NONE;\n  p->output = jv_invalid();\n  p->next = jv_invalid();\n  p->tokenbuf = 0;\n  p->tokenlen = p->tokenpos = 0;\n  if ((p->flags & JV_PARSE_SEQ))\n    p->st = JV_PARSER_WAITING_FOR_RS;\n  else\n    p->st = JV_PARSER_NORMAL;\n  p->eof = 0;\n  p->curr_buf = 0;\n  p->curr_buf_length = p->curr_buf_pos = p->curr_buf_is_partial = 0;\n  p->bom_strip_position = 0;\n  p->last_ch_was_ws = 0;\n  p->line = 1;\n  p->column = 0;\n  jvp_dtoa_context_init(&p->dtoa);\n}\n\nstatic void parser_reset(struct jv_parser* p) {\n  if ((p->flags & JV_PARSE_STREAMING)) {\n    jv_free(p->path);\n    p->path = jv_array();\n    p->stacklen = 0;\n  }\n  p->last_seen = JV_LAST_NONE;\n  jv_free(p->output);\n  p->output = jv_invalid();\n  jv_free(p->next);\n  p->next = jv_invalid();\n  for (int i=0; i<p->stackpos; i++)\n    jv_free(p->stack[i]);\n  p->stackpos = 0;\n  p->tokenpos = 0;\n  p->st = JV_PARSER_NORMAL;\n}\n\nstatic void parser_free(struct jv_parser* p) {\n  parser_reset(p);\n  jv_free(p->path);\n  jv_free(p->output);\n  jv_mem_free(p->stack);\n  jv_mem_free(p->tokenbuf);\n  jvp_dtoa_context_free(&p->dtoa);\n}\n\nstatic pfunc value(struct jv_parser* p, jv val) {\n  if ((p->flags & JV_PARSE_STREAMING)) {\n    if (jv_is_valid(p->next) || p->last_seen == JV_LAST_VALUE)\n      return \"Expected separator between values\";\n    if (p->stacklen > 0)\n      p->last_seen = JV_LAST_VALUE;\n    else\n      p->last_seen = JV_LAST_NONE;\n  } else {\n    if (jv_is_valid(p->next)) return \"Expected separator between values\";\n  }\n  jv_free(p->next);\n  p->next = val;\n  return 0;\n}\n\nstatic void push(struct jv_parser* p, jv v) {\n  assert(p->stackpos <= p->stacklen);\n  if (p->stackpos == p->stacklen) {\n    p->stacklen = p->stacklen * 2 + 10;\n    p->stack = jv_mem_realloc(p->stack, p->stacklen * sizeof(jv));\n  }\n  assert(p->stackpos < p->stacklen);\n  p->stack[p->stackpos++] = v;\n}\n\nstatic pfunc parse_token(struct jv_parser* p, char ch) {\n  switch (ch) {\n  case '[':\n    if (jv_is_valid(p->next)) return \"Expected separator between values\";\n    push(p, jv_array());\n    break;\n\n  case '{':\n    if (jv_is_valid(p->next)) return \"Expected separator between values\";\n    push(p, jv_object());\n    break;\n\n  case ':':\n    if (!jv_is_valid(p->next))\n      return \"Expected string key before ':'\";\n    if (p->stackpos == 0 || jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_OBJECT)\n      return \"':' not as part of an object\";\n    if (jv_get_kind(p->next) != JV_KIND_STRING)\n      return \"Object keys must be strings\";\n    push(p, p->next);\n    p->next = jv_invalid();\n    break;\n\n  case ',':\n    if (!jv_is_valid(p->next))\n      return \"Expected value before ','\";\n    if (p->stackpos == 0)\n      return \"',' not as part of an object or array\";\n    if (jv_get_kind(p->stack[p->stackpos-1]) == JV_KIND_ARRAY) {\n      p->stack[p->stackpos-1] = jv_array_append(p->stack[p->stackpos-1], p->next);\n      p->next = jv_invalid();\n    } else if (jv_get_kind(p->stack[p->stackpos-1]) == JV_KIND_STRING) {\n      assert(p->stackpos > 1 && jv_get_kind(p->stack[p->stackpos-2]) == JV_KIND_OBJECT);\n      p->stack[p->stackpos-2] = jv_object_set(p->stack[p->stackpos-2],\n                                              p->stack[p->stackpos-1], p->next);\n      p->stackpos--;\n      p->next = jv_invalid();\n    } else {\n      // this case hits on input like {\"a\", \"b\"}\n      return \"Objects must consist of key:value pairs\";\n    }\n    break;\n\n  case ']':\n    if (p->stackpos == 0 || jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_ARRAY)\n      return \"Unmatched ']'\";\n    if (jv_is_valid(p->next)) {\n      p->stack[p->stackpos-1] = jv_array_append(p->stack[p->stackpos-1], p->next);\n      p->next = jv_invalid();\n    } else {\n      if (jv_array_length(jv_copy(p->stack[p->stackpos-1])) != 0) {\n        // this case hits on input like [1,2,3,]\n        return \"Expected another array element\";\n      }\n    }\n    jv_free(p->next);\n    p->next = p->stack[--p->stackpos];\n    break;\n\n  case '}':\n    if (p->stackpos == 0)\n      return \"Unmatched '}'\";\n    if (jv_is_valid(p->next)) {\n      if (jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_STRING)\n        return \"Objects must consist of key:value pairs\";\n      assert(p->stackpos > 1 && jv_get_kind(p->stack[p->stackpos-2]) == JV_KIND_OBJECT);\n      p->stack[p->stackpos-2] = jv_object_set(p->stack[p->stackpos-2],\n                                              p->stack[p->stackpos-1], p->next);\n      p->stackpos--;\n      p->next = jv_invalid();\n    } else {\n      if (jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_OBJECT)\n        return \"Unmatched '}'\";\n      if (jv_object_length(jv_copy(p->stack[p->stackpos-1])) != 0)\n        return \"Expected another key-value pair\";\n    }\n    jv_free(p->next);\n    p->next = p->stack[--p->stackpos];\n    break;\n  }\n  return 0;\n}\n\nstatic pfunc stream_token(struct jv_parser* p, char ch) {\n  jv_kind k;\n  jv last;\n\n  switch (ch) {\n  case '[':\n    if (jv_is_valid(p->next))\n      return \"Expected a separator between values\";\n    p->path = jv_array_append(p->path, jv_number(0)); // push\n    p->last_seen = JV_LAST_OPEN_ARRAY;\n    p->stacklen++;\n    break;\n\n  case '{':\n    if (p->last_seen == JV_LAST_VALUE)\n      return \"Expected a separator between values\";\n    // Push object key: null, since we don't know it yet\n    p->path = jv_array_append(p->path, jv_null()); // push\n    p->last_seen = JV_LAST_OPEN_OBJECT;\n    p->stacklen++;\n    break;\n\n  case ':':\n    if (p->stacklen == 0 || jv_get_kind(jv_array_get(jv_copy(p->path), p->stacklen - 1)) == JV_KIND_NUMBER)\n      return \"':' not as part of an object\";\n    if (!jv_is_valid(p->next) || p->last_seen == JV_LAST_NONE)\n      return \"Expected string key before ':'\";\n    if (jv_get_kind(p->next) != JV_KIND_STRING)\n      return \"Object keys must be strings\";\n    if (p->last_seen != JV_LAST_VALUE)\n      return \"':' should follow a key\";\n    p->last_seen = JV_LAST_COLON;\n    p->path = jv_array_set(p->path, p->stacklen - 1, p->next);\n    p->next = jv_invalid();\n    break;\n\n  case ',':\n    if (p->last_seen != JV_LAST_VALUE)\n      return \"Expected value before ','\";\n    if (p->stacklen == 0)\n      return \"',' not as part of an object or array\";\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    if (k == JV_KIND_NUMBER) {\n      int idx = jv_number_value(last);\n\n      if (jv_is_valid(p->next)) {\n        p->output = JV_ARRAY(jv_copy(p->path), p->next);\n        p->next = jv_invalid();\n      }\n      p->path = jv_array_set(p->path, p->stacklen - 1, jv_number(idx + 1));\n      p->last_seen = JV_LAST_COMMA;\n    } else if (k == JV_KIND_STRING) {\n      if (jv_is_valid(p->next)) {\n        p->output = JV_ARRAY(jv_copy(p->path), p->next);\n        p->next = jv_invalid();\n      }\n      p->path = jv_array_set(p->path, p->stacklen - 1, jv_true()); // ready for another name:value pair\n      p->last_seen = JV_LAST_COMMA;\n    } else {\n      assert(k == JV_KIND_NULL);\n      // this case hits on input like {,}\n      // make sure to handle input like {\"a\", \"b\"} and {\"a\":, ...}\n      jv_free(last);\n      return \"Objects must consist of key:value pairs\";\n    }\n    jv_free(last);\n    break;\n\n  case ']':\n    if (p->stacklen == 0)\n      return \"Unmatched ']' at the top-level\";\n    if (p->last_seen == JV_LAST_COMMA)\n      return \"Expected another array element\";\n    if (p->last_seen == JV_LAST_OPEN_ARRAY)\n      assert(!jv_is_valid(p->next));\n\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    jv_free(last);\n\n    if (k != JV_KIND_NUMBER)\n      return \"Unmatched ']' in the middle of an object\";\n    if (jv_is_valid(p->next)) {\n      p->output = JV_ARRAY(jv_copy(p->path), p->next, jv_true());\n      p->next = jv_invalid();\n    } else if (p->last_seen != JV_LAST_OPEN_ARRAY) {\n      p->output = JV_ARRAY(jv_copy(p->path));\n    }\n\n    p->path = jv_array_slice(p->path, 0, --(p->stacklen)); // pop\n    //assert(!jv_is_valid(p->next));\n    jv_free(p->next);\n    p->next = jv_invalid();\n\n    if (p->last_seen == JV_LAST_OPEN_ARRAY)\n      p->output = JV_ARRAY(jv_copy(p->path), jv_array()); // Empty arrays are leaves\n\n    if (p->stacklen == 0)\n      p->last_seen = JV_LAST_NONE;\n    else\n      p->last_seen = JV_LAST_VALUE;\n    break;\n\n  case '}':\n    if (p->stacklen == 0)\n      return \"Unmatched '}' at the top-level\";\n    if (p->last_seen == JV_LAST_COMMA)\n      return \"Expected another key:value pair\";\n    if (p->last_seen == JV_LAST_OPEN_OBJECT)\n      assert(!jv_is_valid(p->next));\n\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    jv_free(last);\n    if (k == JV_KIND_NUMBER)\n      return \"Unmatched '}' in the middle of an array\";\n\n    if (jv_is_valid(p->next)) {\n      if (k != JV_KIND_STRING)\n        return \"Objects must consist of key:value pairs\";\n      p->output = JV_ARRAY(jv_copy(p->path), p->next, jv_true());\n      p->next = jv_invalid();\n    } else {\n      // Perhaps {\"a\":[]}\n      if (p->last_seen == JV_LAST_COLON)\n        // Looks like {\"a\":}\n        return \"Missing value in key:value pair\";\n      if (p->last_seen == JV_LAST_COMMA)\n        // Looks like {\"a\":0,}\n        return \"Expected another key-value pair\";\n      if (p->last_seen == JV_LAST_OPEN_ARRAY)\n        return \"Unmatched '}' in the middle of an array\";\n      if (p->last_seen != JV_LAST_VALUE && p->last_seen != JV_LAST_OPEN_OBJECT)\n        return \"Unmatched '}'\";\n      if (p->last_seen != JV_LAST_OPEN_OBJECT)\n        p->output = JV_ARRAY(jv_copy(p->path));\n    }\n    p->path = jv_array_slice(p->path, 0, --(p->stacklen)); // pop\n    jv_free(p->next);\n    p->next = jv_invalid();\n\n    if (p->last_seen == JV_LAST_OPEN_OBJECT)\n      p->output = JV_ARRAY(jv_copy(p->path), jv_object()); // Empty arrays are leaves\n\n    if (p->stacklen == 0)\n      p->last_seen = JV_LAST_NONE;\n    else\n      p->last_seen = JV_LAST_VALUE;\n    break;\n  }\n  return 0;\n}\n\nstatic void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}\n\nstatic int unhex4(char* hex) {\n  int r = 0;\n  for (int i=0; i<4; i++) {\n    char c = *hex++;\n    int n;\n    if ('0' <= c && c <= '9') n = c - '0';\n    else if ('a' <= c && c <= 'f') n = c - 'a' + 10;\n    else if ('A' <= c && c <= 'F') n = c - 'A' + 10;\n    else return -1;\n    r <<= 4;\n    r |= n;\n  }\n  return r;\n}\n\nstatic pfunc found_string(struct jv_parser* p) {\n  char* in = p->tokenbuf;\n  char* out = p->tokenbuf;\n  char* end = p->tokenbuf + p->tokenpos;\n\n  while (in < end) {\n    char c = *in++;\n    if (c == '\\\\') {\n      if (in >= end)\n        return \"Expected escape character at end of string\";\n      c = *in++;\n      switch (c) {\n      case '\\\\':\n      case '\"':\n      case '/': *out++ = c;    break;\n      case 'b': *out++ = '\\b'; break;\n      case 'f': *out++ = '\\f'; break;\n      case 't': *out++ = '\\t'; break;\n      case 'n': *out++ = '\\n'; break;\n      case 'r': *out++ = '\\r'; break;\n\n      case 'u':\n        /* ahh, the complicated case */\n        if (in + 4 > end)\n          return \"Invalid \\\\uXXXX escape\";\n        int hexvalue = unhex4(in);\n        if (hexvalue < 0)\n          return \"Invalid characters in \\\\uXXXX escape\";\n        unsigned long codepoint = (unsigned long)hexvalue;\n        in += 4;\n        if (0xD800 <= codepoint && codepoint <= 0xDBFF) {\n          /* who thought UTF-16 surrogate pairs were a good idea? */\n          if (in + 6 > end || in[0] != '\\\\' || in[1] != 'u')\n            return \"Invalid \\\\uXXXX\\\\uXXXX surrogate pair escape\";\n          unsigned long surrogate = unhex4(in+2);\n          if (!(0xDC00 <= surrogate && surrogate <= 0xDFFF))\n            return \"Invalid \\\\uXXXX\\\\uXXXX surrogate pair escape\";\n          in += 6;\n          codepoint = 0x10000 + (((codepoint - 0xD800) << 10)\n                                 |(surrogate - 0xDC00));\n        }\n        if (codepoint > 0x10FFFF)\n          codepoint = 0xFFFD; // U+FFFD REPLACEMENT CHARACTER\n        out += jvp_utf8_encode(codepoint, out);\n        break;\n\n      default:\n        return \"Invalid escape\";\n      }\n    } else {\n      if (c > 0 && c < 0x001f)\n        return \"Invalid string: control characters from U+0000 through U+001F must be escaped\";\n      *out++ = c;\n    }\n  }\n  TRY(value(p, jv_string_sized(p->tokenbuf, out - p->tokenbuf)));\n  p->tokenpos = 0;\n  return 0;\n}\n\nstatic pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    // FIXME: better parser\n    p->tokenbuf[p->tokenpos] = 0; // FIXME: invalid\n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}\n\ntypedef enum {\n  LITERAL,\n  WHITESPACE,\n  STRUCTURE,\n  QUOTE,\n  INVALID\n} chclass;\n\nstatic chclass classify(char c) {\n  switch (c) {\n  case ' ':\n  case '\\t':\n  case '\\r':\n  case '\\n':\n    return WHITESPACE;\n  case '\"':\n    return QUOTE;\n  case '[':\n  case ',':\n  case ']':\n  case '{':\n  case ':':\n  case '}':\n    return STRUCTURE;\n  default:\n    return LITERAL;\n  }\n}\n\n\nstatic const presult OK = \"output produced\";\n\nstatic int parse_check_done(struct jv_parser* p, jv* out) {\n  if (p->stackpos == 0 && jv_is_valid(p->next)) {\n    *out = p->next;\n    p->next = jv_invalid();\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nstatic int stream_check_done(struct jv_parser* p, jv* out) {\n  if (p->stacklen == 0 && jv_is_valid(p->next)) {\n    *out = JV_ARRAY(jv_copy(p->path),p->next);\n    p->next = jv_invalid();\n    return 1;\n  } else if (jv_is_valid(p->output)) {\n    if (jv_array_length(jv_copy(p->output)) > 2) {\n      // At end of an array or object, necessitating one more output by\n      // which to indicate this\n      *out = jv_array_slice(jv_copy(p->output), 0, 2);\n      p->output = jv_array_slice(p->output, 0, 1);      // arrange one more output\n    } else {\n      // No further processing needed\n      *out = p->output;\n      p->output = jv_invalid();\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nstatic int parse_check_truncation(struct jv_parser* p) {\n  return ((p->flags & JV_PARSE_SEQ) && !p->last_ch_was_ws && (p->stackpos > 0 || p->tokenpos > 0 || jv_get_kind(p->next) == JV_KIND_NUMBER));\n}\n\nstatic int stream_check_truncation(struct jv_parser* p) {\n  jv_kind k = jv_get_kind(p->next);\n  return (p->stacklen > 0 || k == JV_KIND_NUMBER || k == JV_KIND_TRUE || k == JV_KIND_FALSE || k == JV_KIND_NULL);\n}\n\nstatic int parse_is_top_num(struct jv_parser* p) {\n  return (p->stackpos == 0 && jv_get_kind(p->next) == JV_KIND_NUMBER);\n}\n\nstatic int stream_is_top_num(struct jv_parser* p) {\n  return (p->stacklen == 0 && jv_get_kind(p->next) == JV_KIND_NUMBER);\n}\n\n#define check_done(p, o) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_check_done((p), (o)) : parse_check_done((p), (o)))\n\n#define token(p, ch) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_token((p), (ch)) : parse_token((p), (ch)))\n\n#define check_truncation(p) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_check_truncation((p)) : parse_check_truncation((p)))\n\n#define is_top_num(p) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_is_top_num((p)) : parse_is_top_num((p)))\n\nstatic pfunc scan(struct jv_parser* p, char ch, jv* out) {\n  p->column++;\n  if (ch == '\\n') {\n    p->line++;\n    p->column = 0;\n  }\n  if (ch == '\\036' /* ASCII RS; see draft-ietf-json-sequence-07 */) {\n    if (check_truncation(p)) {\n      if (check_literal(p) == 0 && is_top_num(p))\n        return \"Potentially truncated top-level numeric value\";\n      return \"Truncated value\";\n    }\n    TRY(check_literal(p));\n    if (p->st == JV_PARSER_NORMAL && check_done(p, out))\n      return OK;\n    // shouldn't happen?\n    assert(!jv_is_valid(*out));\n    parser_reset(p);\n    jv_free(*out);\n    *out = jv_invalid();\n    return OK;\n  }\n  presult answer = 0;\n  p->last_ch_was_ws = 0;\n  if (p->st == JV_PARSER_NORMAL) {\n    chclass cls = classify(ch);\n    if (cls == WHITESPACE)\n      p->last_ch_was_ws = 1;\n    if (cls != LITERAL) {\n      TRY(check_literal(p));\n      if (check_done(p, out)) answer = OK;\n    }\n    switch (cls) {\n    case LITERAL:\n      tokenadd(p, ch);\n      break;\n    case WHITESPACE:\n      break;\n    case QUOTE:\n      p->st = JV_PARSER_STRING;\n      break;\n    case STRUCTURE:\n      TRY(token(p, ch));\n      break;\n    case INVALID:\n      return \"Invalid character\";\n    }\n    if (check_done(p, out)) answer = OK;\n  } else {\n    if (ch == '\"' && p->st == JV_PARSER_STRING) {\n      TRY(found_string(p));\n      p->st = JV_PARSER_NORMAL;\n      if (check_done(p, out)) answer = OK;\n    } else {\n      tokenadd(p, ch);\n      if (ch == '\\\\' && p->st == JV_PARSER_STRING) {\n        p->st = JV_PARSER_STRING_ESCAPE;\n      } else {\n        p->st = JV_PARSER_STRING;\n      }\n    }\n  }\n  return answer;\n}\n\nstruct jv_parser* jv_parser_new(int flags) {\n  struct jv_parser* p = jv_mem_alloc(sizeof(struct jv_parser));\n  parser_init(p, flags);\n  p->flags = flags;\n  return p;\n}\n\nvoid jv_parser_free(struct jv_parser* p) {\n  parser_free(p);\n  jv_mem_free(p);\n}\n\nstatic const unsigned char UTF8_BOM[] = {0xEF,0xBB,0xBF};\n\nint jv_parser_remaining(struct jv_parser* p) {\n  if (p->curr_buf == 0)\n    return 0;\n  return (p->curr_buf_length - p->curr_buf_pos);\n}\n\nvoid jv_parser_set_buf(struct jv_parser* p, const char* buf, int length, int is_partial) {\n  assert((p->curr_buf == 0 || p->curr_buf_pos == p->curr_buf_length)\n         && \"previous buffer not exhausted\");\n  while (length > 0 && p->bom_strip_position < sizeof(UTF8_BOM)) {\n    if ((unsigned char)*buf == UTF8_BOM[p->bom_strip_position]) {\n      // matched a BOM character\n      buf++;\n      length--;\n      p->bom_strip_position++;\n    } else {\n      if (p->bom_strip_position == 0) {\n        // no BOM in this document\n        p->bom_strip_position = sizeof(UTF8_BOM);\n      } else {\n        // malformed BOM (prefix present, rest missing)\n        p->bom_strip_position = 0xff;\n      }\n    }\n  }\n  p->curr_buf = buf;\n  p->curr_buf_length = length;\n  p->curr_buf_pos = 0;\n  p->curr_buf_is_partial = is_partial;\n}\n\nstatic jv make_error(struct jv_parser*, const char *, ...) JV_PRINTF_LIKE(2, 3);\n\nstatic jv make_error(struct jv_parser* p, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  jv e = jv_string_vfmt(fmt, ap);\n  va_end(ap);\n  if ((p->flags & JV_PARSE_STREAM_ERRORS))\n    return JV_ARRAY(e, jv_copy(p->path));\n  return jv_invalid_with_msg(e);\n}\n\njv jv_parser_next(struct jv_parser* p) {\n  if (p->eof)\n    return jv_invalid();\n  if (!p->curr_buf)\n    return jv_invalid(); // Need a buffer\n  if (p->bom_strip_position == 0xff) {\n    if (!(p->flags & JV_PARSE_SEQ))\n      return jv_invalid_with_msg(jv_string(\"Malformed BOM\"));\n    p->st =JV_PARSER_WAITING_FOR_RS;\n    parser_reset(p);\n  }\n  jv value = jv_invalid();\n  if ((p->flags & JV_PARSE_STREAMING) && stream_check_done(p, &value))\n    return value;\n  char ch;\n  presult msg = 0;\n  while (!msg && p->curr_buf_pos < p->curr_buf_length) {\n    ch = p->curr_buf[p->curr_buf_pos++];\n    if (p->st == JV_PARSER_WAITING_FOR_RS) {\n      if (ch == '\\n') {\n        p->line++;\n        p->column = 0;\n      } else {\n        p->column++;\n      }\n      if (ch == '\\036')\n        p->st = JV_PARSER_NORMAL;\n      continue; // need to resync, wait for RS\n    }\n    msg = scan(p, ch, &value);\n  }\n  if (msg == OK) {\n    return value;\n  } else if (msg) {\n    jv_free(value);\n    if (ch != '\\036' && (p->flags & JV_PARSE_SEQ)) {\n      // Skip to the next RS\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      value = make_error(p, \"%s at line %d, column %d (need RS to resync)\", msg, p->line, p->column);\n      parser_reset(p);\n      return value;\n    }\n    value = make_error(p, \"%s at line %d, column %d\", msg, p->line, p->column);\n    parser_reset(p);\n    if (!(p->flags & JV_PARSE_SEQ)) {\n      // We're not parsing a JSON text sequence; throw this buffer away.\n      // XXX We should fail permanently here.\n      p->curr_buf = 0;\n      p->curr_buf_pos = 0;\n    } // Else ch must be RS; don't clear buf so we can start parsing again after this ch\n    return value;\n  } else if (p->curr_buf_is_partial) {\n    assert(p->curr_buf_pos == p->curr_buf_length);\n    // need another buffer\n    return jv_invalid();\n  } else {\n    // at EOF\n    p->eof = 1;\n    assert(p->curr_buf_pos == p->curr_buf_length);\n    jv_free(value);\n    if (p->st == JV_PARSER_WAITING_FOR_RS)\n      return make_error(p, \"Unfinished abandoned text at EOF at line %d, column %d\", p->line, p->column);\n    if (p->st != JV_PARSER_NORMAL) {\n      value = make_error(p, \"Unfinished string at EOF at line %d, column %d\", p->line, p->column);\n      parser_reset(p);\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      return value;\n    }\n    if ((msg = check_literal(p))) {\n      value = make_error(p, \"%s at EOF at line %d, column %d\", msg, p->line, p->column);\n      parser_reset(p);\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      return value;\n    }\n    if (((p->flags & JV_PARSE_STREAMING) && p->stacklen != 0) ||\n        (!(p->flags & JV_PARSE_STREAMING) && p->stackpos != 0)) {\n      value = make_error(p, \"Unfinished JSON term at EOF at line %d, column %d\", p->line, p->column);\n      parser_reset(p);\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      return value;\n    }\n    // p->next is either invalid (nothing here, but no syntax error)\n    // or valid (this is the value). either way it's the thing to return\n    if ((p->flags & JV_PARSE_STREAMING) && jv_is_valid(p->next)) {\n      value = JV_ARRAY(jv_copy(p->path), p->next); // except in streaming mode we've got to make it [path,value]\n    } else {\n      value = p->next;\n    }\n    p->next = jv_invalid();\n    if ((p->flags & JV_PARSE_SEQ) && !p->last_ch_was_ws && jv_get_kind(value) == JV_KIND_NUMBER) {\n      jv_free(value);\n      return make_error(p, \"Potentially truncated top-level numeric value at EOF at line %d, column %d\", p->line, p->column);\n    }\n    return value;\n  }\n}\n\njv jv_parse_sized(const char* string, int length) {\n  struct jv_parser parser;\n  parser_init(&parser, 0);\n  jv_parser_set_buf(&parser, string, length, 0);\n  jv value = jv_parser_next(&parser);\n  if (jv_is_valid(value)) {\n    jv next = jv_parser_next(&parser);\n    if (jv_is_valid(next)) {\n      // multiple JSON values, we only wanted one\n      jv_free(value);\n      jv_free(next);\n      value = jv_invalid_with_msg(jv_string(\"Unexpected extra JSON values\"));\n    } else if (jv_invalid_has_msg(jv_copy(next))) {\n      // parser error after the first JSON value\n      jv_free(value);\n      value = next;\n    } else {\n      // a single valid JSON value\n      jv_free(next);\n    }\n  } else if (jv_invalid_has_msg(jv_copy(value))) {\n    // parse error, we'll return it\n  } else {\n    // no value at all\n    jv_free(value);\n    value = jv_invalid_with_msg(jv_string(\"Expected JSON value\"));\n  }\n  parser_free(&parser);\n\n  if (!jv_is_valid(value) && jv_invalid_has_msg(jv_copy(value))) {\n    jv msg = jv_invalid_get_msg(value);\n    value = jv_invalid_with_msg(jv_string_fmt(\"%s (while parsing '%s')\",\n                                              jv_string_value(msg),\n                                              string));\n    jv_free(msg);\n  }\n  return value;\n}\n\njv jv_parse(const char* string) {\n  return jv_parse_sized(string, strlen(string));\n}\n"], "fixing_code": ["#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include \"jv.h\"\n#include \"jv_dtoa.h\"\n#include \"jv_unicode.h\"\n#include \"jv_alloc.h\"\n#include \"jv_dtoa.h\"\n\ntypedef const char* presult;\n\n#define TRY(x) do {presult msg__ = (x); if (msg__) return msg__; } while(0)\n#ifdef __GNUC__\n#define pfunc __attribute__((warn_unused_result)) presult\n#else\n#define pfunc presult\n#endif\n\nenum last_seen {\n  JV_LAST_NONE = 0,\n  JV_LAST_OPEN_ARRAY = '[',\n  JV_LAST_OPEN_OBJECT = '{',\n  JV_LAST_COLON = ':',\n  JV_LAST_COMMA = ',',\n  JV_LAST_VALUE = 'V',\n};\n\nstruct jv_parser {\n  const char* curr_buf;\n  int curr_buf_length;\n  int curr_buf_pos;\n  int curr_buf_is_partial;\n  int eof;\n  unsigned bom_strip_position;\n\n  int flags;\n\n  jv* stack;                   // parser\n  int stackpos;                // parser\n  int stacklen;                // both (optimization; it's really pathlen for streaming)\n  jv path;                     // streamer\n  enum last_seen last_seen;    // streamer\n  jv output;                   // streamer\n  jv next;                     // both\n\n  char* tokenbuf;\n  int tokenpos;\n  int tokenlen;\n\n  int line, column;\n\n  struct dtoa_context dtoa;\n\n  enum {\n    JV_PARSER_NORMAL,\n    JV_PARSER_STRING,\n    JV_PARSER_STRING_ESCAPE,\n    JV_PARSER_WAITING_FOR_RS // parse error, waiting for RS\n  } st;\n  unsigned int last_ch_was_ws:1;\n};\n\n\nstatic void parser_init(struct jv_parser* p, int flags) {\n  p->flags = flags;\n  if ((p->flags & JV_PARSE_STREAMING)) {\n    p->path = jv_array();\n  } else {\n    p->path = jv_invalid();\n    p->flags &= ~(JV_PARSE_STREAM_ERRORS);\n  }\n  p->stack = 0;\n  p->stacklen = p->stackpos = 0;\n  p->last_seen = JV_LAST_NONE;\n  p->output = jv_invalid();\n  p->next = jv_invalid();\n  p->tokenbuf = 0;\n  p->tokenlen = p->tokenpos = 0;\n  if ((p->flags & JV_PARSE_SEQ))\n    p->st = JV_PARSER_WAITING_FOR_RS;\n  else\n    p->st = JV_PARSER_NORMAL;\n  p->eof = 0;\n  p->curr_buf = 0;\n  p->curr_buf_length = p->curr_buf_pos = p->curr_buf_is_partial = 0;\n  p->bom_strip_position = 0;\n  p->last_ch_was_ws = 0;\n  p->line = 1;\n  p->column = 0;\n  jvp_dtoa_context_init(&p->dtoa);\n}\n\nstatic void parser_reset(struct jv_parser* p) {\n  if ((p->flags & JV_PARSE_STREAMING)) {\n    jv_free(p->path);\n    p->path = jv_array();\n    p->stacklen = 0;\n  }\n  p->last_seen = JV_LAST_NONE;\n  jv_free(p->output);\n  p->output = jv_invalid();\n  jv_free(p->next);\n  p->next = jv_invalid();\n  for (int i=0; i<p->stackpos; i++)\n    jv_free(p->stack[i]);\n  p->stackpos = 0;\n  p->tokenpos = 0;\n  p->st = JV_PARSER_NORMAL;\n}\n\nstatic void parser_free(struct jv_parser* p) {\n  parser_reset(p);\n  jv_free(p->path);\n  jv_free(p->output);\n  jv_mem_free(p->stack);\n  jv_mem_free(p->tokenbuf);\n  jvp_dtoa_context_free(&p->dtoa);\n}\n\nstatic pfunc value(struct jv_parser* p, jv val) {\n  if ((p->flags & JV_PARSE_STREAMING)) {\n    if (jv_is_valid(p->next) || p->last_seen == JV_LAST_VALUE)\n      return \"Expected separator between values\";\n    if (p->stacklen > 0)\n      p->last_seen = JV_LAST_VALUE;\n    else\n      p->last_seen = JV_LAST_NONE;\n  } else {\n    if (jv_is_valid(p->next)) return \"Expected separator between values\";\n  }\n  jv_free(p->next);\n  p->next = val;\n  return 0;\n}\n\nstatic void push(struct jv_parser* p, jv v) {\n  assert(p->stackpos <= p->stacklen);\n  if (p->stackpos == p->stacklen) {\n    p->stacklen = p->stacklen * 2 + 10;\n    p->stack = jv_mem_realloc(p->stack, p->stacklen * sizeof(jv));\n  }\n  assert(p->stackpos < p->stacklen);\n  p->stack[p->stackpos++] = v;\n}\n\nstatic pfunc parse_token(struct jv_parser* p, char ch) {\n  switch (ch) {\n  case '[':\n    if (jv_is_valid(p->next)) return \"Expected separator between values\";\n    push(p, jv_array());\n    break;\n\n  case '{':\n    if (jv_is_valid(p->next)) return \"Expected separator between values\";\n    push(p, jv_object());\n    break;\n\n  case ':':\n    if (!jv_is_valid(p->next))\n      return \"Expected string key before ':'\";\n    if (p->stackpos == 0 || jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_OBJECT)\n      return \"':' not as part of an object\";\n    if (jv_get_kind(p->next) != JV_KIND_STRING)\n      return \"Object keys must be strings\";\n    push(p, p->next);\n    p->next = jv_invalid();\n    break;\n\n  case ',':\n    if (!jv_is_valid(p->next))\n      return \"Expected value before ','\";\n    if (p->stackpos == 0)\n      return \"',' not as part of an object or array\";\n    if (jv_get_kind(p->stack[p->stackpos-1]) == JV_KIND_ARRAY) {\n      p->stack[p->stackpos-1] = jv_array_append(p->stack[p->stackpos-1], p->next);\n      p->next = jv_invalid();\n    } else if (jv_get_kind(p->stack[p->stackpos-1]) == JV_KIND_STRING) {\n      assert(p->stackpos > 1 && jv_get_kind(p->stack[p->stackpos-2]) == JV_KIND_OBJECT);\n      p->stack[p->stackpos-2] = jv_object_set(p->stack[p->stackpos-2],\n                                              p->stack[p->stackpos-1], p->next);\n      p->stackpos--;\n      p->next = jv_invalid();\n    } else {\n      // this case hits on input like {\"a\", \"b\"}\n      return \"Objects must consist of key:value pairs\";\n    }\n    break;\n\n  case ']':\n    if (p->stackpos == 0 || jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_ARRAY)\n      return \"Unmatched ']'\";\n    if (jv_is_valid(p->next)) {\n      p->stack[p->stackpos-1] = jv_array_append(p->stack[p->stackpos-1], p->next);\n      p->next = jv_invalid();\n    } else {\n      if (jv_array_length(jv_copy(p->stack[p->stackpos-1])) != 0) {\n        // this case hits on input like [1,2,3,]\n        return \"Expected another array element\";\n      }\n    }\n    jv_free(p->next);\n    p->next = p->stack[--p->stackpos];\n    break;\n\n  case '}':\n    if (p->stackpos == 0)\n      return \"Unmatched '}'\";\n    if (jv_is_valid(p->next)) {\n      if (jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_STRING)\n        return \"Objects must consist of key:value pairs\";\n      assert(p->stackpos > 1 && jv_get_kind(p->stack[p->stackpos-2]) == JV_KIND_OBJECT);\n      p->stack[p->stackpos-2] = jv_object_set(p->stack[p->stackpos-2],\n                                              p->stack[p->stackpos-1], p->next);\n      p->stackpos--;\n      p->next = jv_invalid();\n    } else {\n      if (jv_get_kind(p->stack[p->stackpos-1]) != JV_KIND_OBJECT)\n        return \"Unmatched '}'\";\n      if (jv_object_length(jv_copy(p->stack[p->stackpos-1])) != 0)\n        return \"Expected another key-value pair\";\n    }\n    jv_free(p->next);\n    p->next = p->stack[--p->stackpos];\n    break;\n  }\n  return 0;\n}\n\nstatic pfunc stream_token(struct jv_parser* p, char ch) {\n  jv_kind k;\n  jv last;\n\n  switch (ch) {\n  case '[':\n    if (jv_is_valid(p->next))\n      return \"Expected a separator between values\";\n    p->path = jv_array_append(p->path, jv_number(0)); // push\n    p->last_seen = JV_LAST_OPEN_ARRAY;\n    p->stacklen++;\n    break;\n\n  case '{':\n    if (p->last_seen == JV_LAST_VALUE)\n      return \"Expected a separator between values\";\n    // Push object key: null, since we don't know it yet\n    p->path = jv_array_append(p->path, jv_null()); // push\n    p->last_seen = JV_LAST_OPEN_OBJECT;\n    p->stacklen++;\n    break;\n\n  case ':':\n    if (p->stacklen == 0 || jv_get_kind(jv_array_get(jv_copy(p->path), p->stacklen - 1)) == JV_KIND_NUMBER)\n      return \"':' not as part of an object\";\n    if (!jv_is_valid(p->next) || p->last_seen == JV_LAST_NONE)\n      return \"Expected string key before ':'\";\n    if (jv_get_kind(p->next) != JV_KIND_STRING)\n      return \"Object keys must be strings\";\n    if (p->last_seen != JV_LAST_VALUE)\n      return \"':' should follow a key\";\n    p->last_seen = JV_LAST_COLON;\n    p->path = jv_array_set(p->path, p->stacklen - 1, p->next);\n    p->next = jv_invalid();\n    break;\n\n  case ',':\n    if (p->last_seen != JV_LAST_VALUE)\n      return \"Expected value before ','\";\n    if (p->stacklen == 0)\n      return \"',' not as part of an object or array\";\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    if (k == JV_KIND_NUMBER) {\n      int idx = jv_number_value(last);\n\n      if (jv_is_valid(p->next)) {\n        p->output = JV_ARRAY(jv_copy(p->path), p->next);\n        p->next = jv_invalid();\n      }\n      p->path = jv_array_set(p->path, p->stacklen - 1, jv_number(idx + 1));\n      p->last_seen = JV_LAST_COMMA;\n    } else if (k == JV_KIND_STRING) {\n      if (jv_is_valid(p->next)) {\n        p->output = JV_ARRAY(jv_copy(p->path), p->next);\n        p->next = jv_invalid();\n      }\n      p->path = jv_array_set(p->path, p->stacklen - 1, jv_true()); // ready for another name:value pair\n      p->last_seen = JV_LAST_COMMA;\n    } else {\n      assert(k == JV_KIND_NULL);\n      // this case hits on input like {,}\n      // make sure to handle input like {\"a\", \"b\"} and {\"a\":, ...}\n      jv_free(last);\n      return \"Objects must consist of key:value pairs\";\n    }\n    jv_free(last);\n    break;\n\n  case ']':\n    if (p->stacklen == 0)\n      return \"Unmatched ']' at the top-level\";\n    if (p->last_seen == JV_LAST_COMMA)\n      return \"Expected another array element\";\n    if (p->last_seen == JV_LAST_OPEN_ARRAY)\n      assert(!jv_is_valid(p->next));\n\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    jv_free(last);\n\n    if (k != JV_KIND_NUMBER)\n      return \"Unmatched ']' in the middle of an object\";\n    if (jv_is_valid(p->next)) {\n      p->output = JV_ARRAY(jv_copy(p->path), p->next, jv_true());\n      p->next = jv_invalid();\n    } else if (p->last_seen != JV_LAST_OPEN_ARRAY) {\n      p->output = JV_ARRAY(jv_copy(p->path));\n    }\n\n    p->path = jv_array_slice(p->path, 0, --(p->stacklen)); // pop\n    //assert(!jv_is_valid(p->next));\n    jv_free(p->next);\n    p->next = jv_invalid();\n\n    if (p->last_seen == JV_LAST_OPEN_ARRAY)\n      p->output = JV_ARRAY(jv_copy(p->path), jv_array()); // Empty arrays are leaves\n\n    if (p->stacklen == 0)\n      p->last_seen = JV_LAST_NONE;\n    else\n      p->last_seen = JV_LAST_VALUE;\n    break;\n\n  case '}':\n    if (p->stacklen == 0)\n      return \"Unmatched '}' at the top-level\";\n    if (p->last_seen == JV_LAST_COMMA)\n      return \"Expected another key:value pair\";\n    if (p->last_seen == JV_LAST_OPEN_OBJECT)\n      assert(!jv_is_valid(p->next));\n\n    last = jv_array_get(jv_copy(p->path), p->stacklen - 1);\n    k = jv_get_kind(last);\n    jv_free(last);\n    if (k == JV_KIND_NUMBER)\n      return \"Unmatched '}' in the middle of an array\";\n\n    if (jv_is_valid(p->next)) {\n      if (k != JV_KIND_STRING)\n        return \"Objects must consist of key:value pairs\";\n      p->output = JV_ARRAY(jv_copy(p->path), p->next, jv_true());\n      p->next = jv_invalid();\n    } else {\n      // Perhaps {\"a\":[]}\n      if (p->last_seen == JV_LAST_COLON)\n        // Looks like {\"a\":}\n        return \"Missing value in key:value pair\";\n      if (p->last_seen == JV_LAST_COMMA)\n        // Looks like {\"a\":0,}\n        return \"Expected another key-value pair\";\n      if (p->last_seen == JV_LAST_OPEN_ARRAY)\n        return \"Unmatched '}' in the middle of an array\";\n      if (p->last_seen != JV_LAST_VALUE && p->last_seen != JV_LAST_OPEN_OBJECT)\n        return \"Unmatched '}'\";\n      if (p->last_seen != JV_LAST_OPEN_OBJECT)\n        p->output = JV_ARRAY(jv_copy(p->path));\n    }\n    p->path = jv_array_slice(p->path, 0, --(p->stacklen)); // pop\n    jv_free(p->next);\n    p->next = jv_invalid();\n\n    if (p->last_seen == JV_LAST_OPEN_OBJECT)\n      p->output = JV_ARRAY(jv_copy(p->path), jv_object()); // Empty arrays are leaves\n\n    if (p->stacklen == 0)\n      p->last_seen = JV_LAST_NONE;\n    else\n      p->last_seen = JV_LAST_VALUE;\n    break;\n  }\n  return 0;\n}\n\nstatic void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos >= (p->tokenlen - 1)) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}\n\nstatic int unhex4(char* hex) {\n  int r = 0;\n  for (int i=0; i<4; i++) {\n    char c = *hex++;\n    int n;\n    if ('0' <= c && c <= '9') n = c - '0';\n    else if ('a' <= c && c <= 'f') n = c - 'a' + 10;\n    else if ('A' <= c && c <= 'F') n = c - 'A' + 10;\n    else return -1;\n    r <<= 4;\n    r |= n;\n  }\n  return r;\n}\n\nstatic pfunc found_string(struct jv_parser* p) {\n  char* in = p->tokenbuf;\n  char* out = p->tokenbuf;\n  char* end = p->tokenbuf + p->tokenpos;\n\n  while (in < end) {\n    char c = *in++;\n    if (c == '\\\\') {\n      if (in >= end)\n        return \"Expected escape character at end of string\";\n      c = *in++;\n      switch (c) {\n      case '\\\\':\n      case '\"':\n      case '/': *out++ = c;    break;\n      case 'b': *out++ = '\\b'; break;\n      case 'f': *out++ = '\\f'; break;\n      case 't': *out++ = '\\t'; break;\n      case 'n': *out++ = '\\n'; break;\n      case 'r': *out++ = '\\r'; break;\n\n      case 'u':\n        /* ahh, the complicated case */\n        if (in + 4 > end)\n          return \"Invalid \\\\uXXXX escape\";\n        int hexvalue = unhex4(in);\n        if (hexvalue < 0)\n          return \"Invalid characters in \\\\uXXXX escape\";\n        unsigned long codepoint = (unsigned long)hexvalue;\n        in += 4;\n        if (0xD800 <= codepoint && codepoint <= 0xDBFF) {\n          /* who thought UTF-16 surrogate pairs were a good idea? */\n          if (in + 6 > end || in[0] != '\\\\' || in[1] != 'u')\n            return \"Invalid \\\\uXXXX\\\\uXXXX surrogate pair escape\";\n          unsigned long surrogate = unhex4(in+2);\n          if (!(0xDC00 <= surrogate && surrogate <= 0xDFFF))\n            return \"Invalid \\\\uXXXX\\\\uXXXX surrogate pair escape\";\n          in += 6;\n          codepoint = 0x10000 + (((codepoint - 0xD800) << 10)\n                                 |(surrogate - 0xDC00));\n        }\n        if (codepoint > 0x10FFFF)\n          codepoint = 0xFFFD; // U+FFFD REPLACEMENT CHARACTER\n        out += jvp_utf8_encode(codepoint, out);\n        break;\n\n      default:\n        return \"Invalid escape\";\n      }\n    } else {\n      if (c > 0 && c < 0x001f)\n        return \"Invalid string: control characters from U+0000 through U+001F must be escaped\";\n      *out++ = c;\n    }\n  }\n  TRY(value(p, jv_string_sized(p->tokenbuf, out - p->tokenbuf)));\n  p->tokenpos = 0;\n  return 0;\n}\n\nstatic pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    // FIXME: better parser\n    p->tokenbuf[p->tokenpos] = 0;\n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}\n\ntypedef enum {\n  LITERAL,\n  WHITESPACE,\n  STRUCTURE,\n  QUOTE,\n  INVALID\n} chclass;\n\nstatic chclass classify(char c) {\n  switch (c) {\n  case ' ':\n  case '\\t':\n  case '\\r':\n  case '\\n':\n    return WHITESPACE;\n  case '\"':\n    return QUOTE;\n  case '[':\n  case ',':\n  case ']':\n  case '{':\n  case ':':\n  case '}':\n    return STRUCTURE;\n  default:\n    return LITERAL;\n  }\n}\n\n\nstatic const presult OK = \"output produced\";\n\nstatic int parse_check_done(struct jv_parser* p, jv* out) {\n  if (p->stackpos == 0 && jv_is_valid(p->next)) {\n    *out = p->next;\n    p->next = jv_invalid();\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nstatic int stream_check_done(struct jv_parser* p, jv* out) {\n  if (p->stacklen == 0 && jv_is_valid(p->next)) {\n    *out = JV_ARRAY(jv_copy(p->path),p->next);\n    p->next = jv_invalid();\n    return 1;\n  } else if (jv_is_valid(p->output)) {\n    if (jv_array_length(jv_copy(p->output)) > 2) {\n      // At end of an array or object, necessitating one more output by\n      // which to indicate this\n      *out = jv_array_slice(jv_copy(p->output), 0, 2);\n      p->output = jv_array_slice(p->output, 0, 1);      // arrange one more output\n    } else {\n      // No further processing needed\n      *out = p->output;\n      p->output = jv_invalid();\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nstatic int parse_check_truncation(struct jv_parser* p) {\n  return ((p->flags & JV_PARSE_SEQ) && !p->last_ch_was_ws && (p->stackpos > 0 || p->tokenpos > 0 || jv_get_kind(p->next) == JV_KIND_NUMBER));\n}\n\nstatic int stream_check_truncation(struct jv_parser* p) {\n  jv_kind k = jv_get_kind(p->next);\n  return (p->stacklen > 0 || k == JV_KIND_NUMBER || k == JV_KIND_TRUE || k == JV_KIND_FALSE || k == JV_KIND_NULL);\n}\n\nstatic int parse_is_top_num(struct jv_parser* p) {\n  return (p->stackpos == 0 && jv_get_kind(p->next) == JV_KIND_NUMBER);\n}\n\nstatic int stream_is_top_num(struct jv_parser* p) {\n  return (p->stacklen == 0 && jv_get_kind(p->next) == JV_KIND_NUMBER);\n}\n\n#define check_done(p, o) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_check_done((p), (o)) : parse_check_done((p), (o)))\n\n#define token(p, ch) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_token((p), (ch)) : parse_token((p), (ch)))\n\n#define check_truncation(p) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_check_truncation((p)) : parse_check_truncation((p)))\n\n#define is_top_num(p) \\\n   (((p)->flags & JV_PARSE_STREAMING) ? stream_is_top_num((p)) : parse_is_top_num((p)))\n\nstatic pfunc scan(struct jv_parser* p, char ch, jv* out) {\n  p->column++;\n  if (ch == '\\n') {\n    p->line++;\n    p->column = 0;\n  }\n  if (ch == '\\036' /* ASCII RS; see draft-ietf-json-sequence-07 */) {\n    if (check_truncation(p)) {\n      if (check_literal(p) == 0 && is_top_num(p))\n        return \"Potentially truncated top-level numeric value\";\n      return \"Truncated value\";\n    }\n    TRY(check_literal(p));\n    if (p->st == JV_PARSER_NORMAL && check_done(p, out))\n      return OK;\n    // shouldn't happen?\n    assert(!jv_is_valid(*out));\n    parser_reset(p);\n    jv_free(*out);\n    *out = jv_invalid();\n    return OK;\n  }\n  presult answer = 0;\n  p->last_ch_was_ws = 0;\n  if (p->st == JV_PARSER_NORMAL) {\n    chclass cls = classify(ch);\n    if (cls == WHITESPACE)\n      p->last_ch_was_ws = 1;\n    if (cls != LITERAL) {\n      TRY(check_literal(p));\n      if (check_done(p, out)) answer = OK;\n    }\n    switch (cls) {\n    case LITERAL:\n      tokenadd(p, ch);\n      break;\n    case WHITESPACE:\n      break;\n    case QUOTE:\n      p->st = JV_PARSER_STRING;\n      break;\n    case STRUCTURE:\n      TRY(token(p, ch));\n      break;\n    case INVALID:\n      return \"Invalid character\";\n    }\n    if (check_done(p, out)) answer = OK;\n  } else {\n    if (ch == '\"' && p->st == JV_PARSER_STRING) {\n      TRY(found_string(p));\n      p->st = JV_PARSER_NORMAL;\n      if (check_done(p, out)) answer = OK;\n    } else {\n      tokenadd(p, ch);\n      if (ch == '\\\\' && p->st == JV_PARSER_STRING) {\n        p->st = JV_PARSER_STRING_ESCAPE;\n      } else {\n        p->st = JV_PARSER_STRING;\n      }\n    }\n  }\n  return answer;\n}\n\nstruct jv_parser* jv_parser_new(int flags) {\n  struct jv_parser* p = jv_mem_alloc(sizeof(struct jv_parser));\n  parser_init(p, flags);\n  p->flags = flags;\n  return p;\n}\n\nvoid jv_parser_free(struct jv_parser* p) {\n  parser_free(p);\n  jv_mem_free(p);\n}\n\nstatic const unsigned char UTF8_BOM[] = {0xEF,0xBB,0xBF};\n\nint jv_parser_remaining(struct jv_parser* p) {\n  if (p->curr_buf == 0)\n    return 0;\n  return (p->curr_buf_length - p->curr_buf_pos);\n}\n\nvoid jv_parser_set_buf(struct jv_parser* p, const char* buf, int length, int is_partial) {\n  assert((p->curr_buf == 0 || p->curr_buf_pos == p->curr_buf_length)\n         && \"previous buffer not exhausted\");\n  while (length > 0 && p->bom_strip_position < sizeof(UTF8_BOM)) {\n    if ((unsigned char)*buf == UTF8_BOM[p->bom_strip_position]) {\n      // matched a BOM character\n      buf++;\n      length--;\n      p->bom_strip_position++;\n    } else {\n      if (p->bom_strip_position == 0) {\n        // no BOM in this document\n        p->bom_strip_position = sizeof(UTF8_BOM);\n      } else {\n        // malformed BOM (prefix present, rest missing)\n        p->bom_strip_position = 0xff;\n      }\n    }\n  }\n  p->curr_buf = buf;\n  p->curr_buf_length = length;\n  p->curr_buf_pos = 0;\n  p->curr_buf_is_partial = is_partial;\n}\n\nstatic jv make_error(struct jv_parser*, const char *, ...) JV_PRINTF_LIKE(2, 3);\n\nstatic jv make_error(struct jv_parser* p, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  jv e = jv_string_vfmt(fmt, ap);\n  va_end(ap);\n  if ((p->flags & JV_PARSE_STREAM_ERRORS))\n    return JV_ARRAY(e, jv_copy(p->path));\n  return jv_invalid_with_msg(e);\n}\n\njv jv_parser_next(struct jv_parser* p) {\n  if (p->eof)\n    return jv_invalid();\n  if (!p->curr_buf)\n    return jv_invalid(); // Need a buffer\n  if (p->bom_strip_position == 0xff) {\n    if (!(p->flags & JV_PARSE_SEQ))\n      return jv_invalid_with_msg(jv_string(\"Malformed BOM\"));\n    p->st =JV_PARSER_WAITING_FOR_RS;\n    parser_reset(p);\n  }\n  jv value = jv_invalid();\n  if ((p->flags & JV_PARSE_STREAMING) && stream_check_done(p, &value))\n    return value;\n  char ch;\n  presult msg = 0;\n  while (!msg && p->curr_buf_pos < p->curr_buf_length) {\n    ch = p->curr_buf[p->curr_buf_pos++];\n    if (p->st == JV_PARSER_WAITING_FOR_RS) {\n      if (ch == '\\n') {\n        p->line++;\n        p->column = 0;\n      } else {\n        p->column++;\n      }\n      if (ch == '\\036')\n        p->st = JV_PARSER_NORMAL;\n      continue; // need to resync, wait for RS\n    }\n    msg = scan(p, ch, &value);\n  }\n  if (msg == OK) {\n    return value;\n  } else if (msg) {\n    jv_free(value);\n    if (ch != '\\036' && (p->flags & JV_PARSE_SEQ)) {\n      // Skip to the next RS\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      value = make_error(p, \"%s at line %d, column %d (need RS to resync)\", msg, p->line, p->column);\n      parser_reset(p);\n      return value;\n    }\n    value = make_error(p, \"%s at line %d, column %d\", msg, p->line, p->column);\n    parser_reset(p);\n    if (!(p->flags & JV_PARSE_SEQ)) {\n      // We're not parsing a JSON text sequence; throw this buffer away.\n      // XXX We should fail permanently here.\n      p->curr_buf = 0;\n      p->curr_buf_pos = 0;\n    } // Else ch must be RS; don't clear buf so we can start parsing again after this ch\n    return value;\n  } else if (p->curr_buf_is_partial) {\n    assert(p->curr_buf_pos == p->curr_buf_length);\n    // need another buffer\n    return jv_invalid();\n  } else {\n    // at EOF\n    p->eof = 1;\n    assert(p->curr_buf_pos == p->curr_buf_length);\n    jv_free(value);\n    if (p->st == JV_PARSER_WAITING_FOR_RS)\n      return make_error(p, \"Unfinished abandoned text at EOF at line %d, column %d\", p->line, p->column);\n    if (p->st != JV_PARSER_NORMAL) {\n      value = make_error(p, \"Unfinished string at EOF at line %d, column %d\", p->line, p->column);\n      parser_reset(p);\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      return value;\n    }\n    if ((msg = check_literal(p))) {\n      value = make_error(p, \"%s at EOF at line %d, column %d\", msg, p->line, p->column);\n      parser_reset(p);\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      return value;\n    }\n    if (((p->flags & JV_PARSE_STREAMING) && p->stacklen != 0) ||\n        (!(p->flags & JV_PARSE_STREAMING) && p->stackpos != 0)) {\n      value = make_error(p, \"Unfinished JSON term at EOF at line %d, column %d\", p->line, p->column);\n      parser_reset(p);\n      p->st = JV_PARSER_WAITING_FOR_RS;\n      return value;\n    }\n    // p->next is either invalid (nothing here, but no syntax error)\n    // or valid (this is the value). either way it's the thing to return\n    if ((p->flags & JV_PARSE_STREAMING) && jv_is_valid(p->next)) {\n      value = JV_ARRAY(jv_copy(p->path), p->next); // except in streaming mode we've got to make it [path,value]\n    } else {\n      value = p->next;\n    }\n    p->next = jv_invalid();\n    if ((p->flags & JV_PARSE_SEQ) && !p->last_ch_was_ws && jv_get_kind(value) == JV_KIND_NUMBER) {\n      jv_free(value);\n      return make_error(p, \"Potentially truncated top-level numeric value at EOF at line %d, column %d\", p->line, p->column);\n    }\n    return value;\n  }\n}\n\njv jv_parse_sized(const char* string, int length) {\n  struct jv_parser parser;\n  parser_init(&parser, 0);\n  jv_parser_set_buf(&parser, string, length, 0);\n  jv value = jv_parser_next(&parser);\n  if (jv_is_valid(value)) {\n    jv next = jv_parser_next(&parser);\n    if (jv_is_valid(next)) {\n      // multiple JSON values, we only wanted one\n      jv_free(value);\n      jv_free(next);\n      value = jv_invalid_with_msg(jv_string(\"Unexpected extra JSON values\"));\n    } else if (jv_invalid_has_msg(jv_copy(next))) {\n      // parser error after the first JSON value\n      jv_free(value);\n      value = next;\n    } else {\n      // a single valid JSON value\n      jv_free(next);\n    }\n  } else if (jv_invalid_has_msg(jv_copy(value))) {\n    // parse error, we'll return it\n  } else {\n    // no value at all\n    jv_free(value);\n    value = jv_invalid_with_msg(jv_string(\"Expected JSON value\"));\n  }\n  parser_free(&parser);\n\n  if (!jv_is_valid(value) && jv_invalid_has_msg(jv_copy(value))) {\n    jv msg = jv_invalid_get_msg(value);\n    value = jv_invalid_with_msg(jv_string_fmt(\"%s (while parsing '%s')\",\n                                              jv_string_value(msg),\n                                              string));\n    jv_free(msg);\n  }\n  return value;\n}\n\njv jv_parse(const char* string) {\n  return jv_parse_sized(string, strlen(string));\n}\n"], "filenames": ["src/jv_parse.c"], "buggy_code_start_loc": [386], "buggy_code_end_loc": [489], "fixing_code_start_loc": [386], "fixing_code_end_loc": [489], "type": "CWE-119", "message": "Off-by-one error in the tokenadd function in jv_parse.c in jq allows remote attackers to cause a denial of service (crash) via a long JSON-encoded number, which triggers a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2015-8863", "sourceIdentifier": "security@debian.org", "published": "2016-05-06T17:59:03.347", "lastModified": "2018-10-30T16:27:35.843", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Off-by-one error in the tokenadd function in jv_parse.c in jq allows remote attackers to cause a denial of service (crash) via a long JSON-encoded number, which triggers a heap-based buffer overflow."}, {"lang": "es", "value": "Error por un paso en la funci\u00f3n tokenadd en jv_parse.c en jq permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) a trav\u00e9s de un n\u00famero largo codificado en JSON, lo que desencadena un desbordamiento de buffer basado en memoria din\u00e1mica."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jq_project:jq:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.5", "matchCriteriaId": "CF54817B-2574-48EC-AB56-D080733E0C2D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-05/msg00012.html", "source": "security@debian.org"}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-05/msg00014.html", "source": "security@debian.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1098.html", "source": "security@debian.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1099.html", "source": "security@debian.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1106.html", "source": "security@debian.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/04/23/1", "source": "security@debian.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/04/23/2", "source": "security@debian.org"}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=802231", "source": "security@debian.org"}, {"url": "https://github.com/stedolan/jq/commit/8eb1367ca44e772963e704a700ef72ae2e12babd", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://github.com/stedolan/jq/issues/995", "source": "security@debian.org"}, {"url": "https://security.gentoo.org/glsa/201612-20", "source": "security@debian.org"}]}, "github_commit_url": "https://github.com/stedolan/jq/commit/8eb1367ca44e772963e704a700ef72ae2e12babd"}}